- contents:
  - '           Policy Quality of Service (QoS) Information Model

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document presents an object-oriented information model for\n
    \  representing Quality of Service (QoS) network management policies.\n   This
    document is based on the IETF Policy Core Information Model and\n   its extensions.
    \ It defines an information model for QoS enforcement\n   for differentiated and
    integrated services using policy.  It is\n   important to note that this document
    defines an information model,\n   which by definition is independent of any particular
    data storage\n   mechanism and access protocol.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.   Introduction. . . . . . . . . . . . . . . . . . .
    . . . . . .  5\n        1.1.  The Process of QoS Policy Definition. . . . . .
    . . . .  5\n        1.2.  Design Goals and Their Ramifications. . . . . . . .
    . .  8\n              1.2.1.  Policy-Definition Oriented. . . . . . . . . . .
    \ 8\n                      1.2.1.1.  Rule-based Modeling . . . . . . . . .  9\n
    \                     1.2.1.2.  Organize Information Hierarchically .  9\n                      1.2.1.3.
    \ Goal-Oriented Policy Definition . . . 10\n              1.2.2. Policy Domain
    Model. . . . . . . . . . . . . . . 11\n                      1.2.2.1.  Model QoS
    Policy in a Device- and\n                                Vendor-Independent Manner
    . . . . . . 11\n                      1.2.2.2.  Use Roles for Mapping Policy to\n
    \                               Network Devices . . . . . . . . . . . 11\n                      1.2.2.3.
    \ Reusability . . . . . . . . . . . . . 12\n              1.2.3.  Enforceable
    Policy. . . . . . . . . . . . . . . 12\n              1.2.4.  QPIM Covers Both
    Signaled And Provisioned QoS . 14\n              1.2.5.  Interoperability for
    PDPs and Management\n                      Applications. . . . . . . . . . . .
    . . . . . . 14\n        1.3.  Modeling Abstract QoS Policies. . . . . . . . .
    . . . . 15\n        1.4.  Rule Hierarchy. . . . . . . . . . . . . . . . . . .
    . . 17\n              1.4.1.  Use of Hierarchy Within Bandwidth Allocation\n                      Policies.
    . . . . . . . . . . . . . . . . . . . 17\n              1.4.2.  Use of Rule Hierarchy
    to Describe Drop\n                      Threshold Policies. . . . . . . . . .
    . . . . . 21\n              1.4.3.  Restrictions of the Use of Hierarchy Within\n
    \                     QPIM. . . . . . . . . . . . . . . . . . . . . . 22\n        1.5.
    \ Intended Audiences. . . . . . . . . . . . . . . . . . . 23\n   2.   Class Hierarchies
    . . . . . . . . . . . . . . . . . . . . . . 23\n        2.1.  Inheritance Hierarchy
    . . . . . . . . . . . . . . . . . 23\n        2.2.  Relationship Hierarchy. .
    . . . . . . . . . . . . . . . 26\n   3.   QoS Actions . . . . . . . . . . . .
    . . . . . . . . . . . . . 26\n        3.1.  Overview. . . . . . . . . . . . .
    . . . . . . . . . . . 26\n        3.2.  RSVP Policy Actions . . . . . . . . .
    . . . . . . . . . 27\n              3.2.1.  Example: Controlling COPS Stateless
    Decision. . 28\n              3.2.2.  Example: Controlling the COPS Replace Decision.
    29\n        3.3.  Provisioning Policy Actions . . . . . . . . . . . . . . 29\n
    \             3.3.1.  Admission Actions: Controlling Policers and\n                      Shapers
    . . . . . . . . . . . . . . . . . . . . 29\n              3.3.2.  Controlling
    Markers . . . . . . . . . . . . . . 32\n              3.3.3.  Controlling Edge
    Policies - Examples. . . . . . 33\n        3.4.  Per-Hop Behavior Actions. . .
    . . . . . . . . . . . . . 34\n              3.4.1.  Controlling Bandwidth and
    Delay . . . . . . . . 35\n              3.4.2.  Congestion Control Actions. .
    . . . . . . . . . 35\n              3.4.3.  Using Hierarchical Policies: Examples
    for PHB\n                      Actions . . . . . . . . . . . . . . . . . . . .
    36\n   4.   Traffic Profiles. . . . . . . . . . . . . . . . . . . . . . . 38\n
    \       4.1.  Provisioning Traffic Profiles . . . . . . . . . . . . . 38\n        4.2.
    \ RSVP Traffic Profiles . . . . . . . . . . . . . . . . . 39\n   5.   Pre-Defined
    QoS-Related Variables . . . . . . . . . . . . . . 40\n   6.   QoS Related Values.
    . . . . . . . . . . . . . . . . . . . . . 42\n   7.   Class Definitions: Association
    Hierarchy. . . . . . . . . . . 44\n        7.1.  The Association \"QoSPolicyTrfcProfInAdmissionAction\".
    . 44\n              7.1.1.  The Reference \"Antecedent\". . . . . . . . . . .
    44\n              7.1.2.  The Reference \"Dependent\" . . . . . . . . . . . 44\n
    \       7.2.  The Association \"PolicyConformAction\" . . . . . . . . . 44\n              7.2.1.
    \ The Reference \"Antecedent\". . . . . . . . . . . 45\n              7.2.2.  The
    Reference \"Dependent\" . . . . . . . . . . . 45\n        7.3.  The Association
    \"QoSPolicyExceedAction\" . . . . . . . . 45\n              7.3.1.  The Reference
    \"Antecedent\". . . . . . . . . . . 46\n              7.3.2.  The Reference \"Dependent\"
    . . . . . . . . . . . 46\n        7.4.  The Association \"PolicyViolateAction\"
    . . . . . . . . . 46\n              7.4.1.  The Reference \"Antecedent\". . .
    . . . . . . . . 46\n              7.4.2.  The Reference \"Dependent\" . . . .
    . . . . . . . 47\n        7.5   The Aggregation\n              \"QoSPolicyRSVPVariableInRSVPSimplePolicyAction\"
    . . . . 47\n              7.5.1.  The Reference \"GroupComponent\". . . . . .
    . . . 47\n              7.5.2.  The Reference \"PartComponent\" . . . . . . .
    . . 47\n   8.   Class Definitions: Inheritance Hierarchy. . . . . . . . . . .
    48\n        8.1.  The Class QoSPolicyDiscardAction. . . . . . . . . . . . 48\n
    \       8.2.  The Class QoSPolicyAdmissionAction. . . . . . . . . . . 48\n              8.2.1.
    \ The Property qpAdmissionScope . . . . . . . . . 48\n        8.3.  The Class
    QoSPolicyPoliceAction . . . . . . . . . . . . 49\n        8.4.  The Class QoSPolicyShapeAction.
    . . . . . . . . . . . . 49\n        8.5.  The Class QoSPolicyRSVPAdmissionAction.
    . . . . . . . . 50\n              8.5.1.  The Property qpRSVPWarnOnly . . . .
    . . . . . . 50\n              8.5.2.  The Property qpRSVPMaxSessions. . . . .
    . . . . 51\n        8.6.  The Class QoSPolicyPHBAction. . . . . . . . . . . .
    . . 51\n              8.6.1.  The Property qpMaxPacketSize. . . . . . . . . .
    51\n        8.7.  The Class QoSPolicyBandwidthAction. . . . . . . . . . . 52\n
    \             8.7.1.  The Property qpForwardingPriority . . . . . . . 52\n              8.7.2.
    \ The Property qpBandwidthUnits . . . . . . . . . 52\n              8.7.3.  The
    Property qpMinBandwidth . . . . . . . . . . 53\n              8.7.4.  The Property
    qpMaxBandwidth . . . . . . . . . . 53\n              8.7.5.  The Property qpMaxDelay
    . . . . . . . . . . . . 53\n              8.7.6.  The Property qpMaxJitter. .
    . . . . . . . . . . 53\n              8.7.7.  The Property qpFairness . . . .
    . . . . . . . . 54\n        8.8.  The Class QoSPolicyCongestionControlAction.
    . . . . . . 54\n              8.8.1.  The Property qpQueueSizeUnits . . . . .
    . . . . 54\n              8.8.2.  The Property qpQueueSize. . . . . . . . . .
    . . 55\n              8.8.3.  The Property qpDropMethod . . . . . . . . . . .
    55\n              8.8.4.  The Property qpDropThresholdUnits . . . . . . . 55\n
    \             8.8.5.  The Property qpDropMinThresholdValue. . . . . . 55\n              8.8.6.
    \ The Property qpDropMaxThresholdValue. . . . . . 56\n        8.9.  The Class
    QoSPolicyTrfcProf . . . . . . . . . . . . . . 56\n        8.10. The Class QoSPolicyTokenBucketTrfcProf.
    . . . . . . . . 57\n              8.10.1. The Property qpTBRate . . . . . . .
    . . . . . . 57\n              8.10.2. The Property qpTBNormalBurst. . . . . .
    . . . . 57\n              8.10.3. The Property qpTBExcessBurst. . . . . . . .
    . . 57\n        8.11. The Class QoSPolicyIntServTrfcProf. . . . . . . . . . .
    57\n              8.11.1. The Property qpISTokenRate. . . . . . . . . . . 58\n
    \             8.11.2. The Property qpISPeakRate . . . . . . . . . . . 58\n              8.11.3.
    The Property qpISBucketSize . . . . . . . . . . 58\n              8.11.4. The
    Property qpISResvRate . . . . . . . . . . . 58\n              8.11.5. The Property
    qpISResvSlack. . . . . . . . . . . 59\n              8.11.6. The Property qpISMinPolicedUnit
    . . . . . . . . 59\n              8.11.7. The Property qpISMaxPktSize . . . .
    . . . . . . 59\n        8.12. The Class QoSPolicyAttributeValue . . . . . . .
    . . . . 59\n              8.12.1. The Property qpAttributeName. . . . . . . .
    . . 60\n              8.12.2. The Property qpAttributeValueList . . . . . . .
    60\n        8.13. The Class QoSPolicyRSVPVariable . . . . . . . . . . . . 60\n
    \       8.14. The Class QoSPolicyRSVPSourceIPv4Variable . . . . . . . 61\n        8.15.
    The Class QoSPolicyRSVPDestinationIPv4Variable. . . . . 61\n        8.16. The
    Class QoSPolicyRSVPSourceIPv6Variable . . . . . . . 62\n        8.17. The Class
    QoSPolicyRSVPDestinationIPv6Variable. . . . . 62\n        8.18. The Class QoSPolicyRSVPSourcePortVariable
    . . . . . . . 62\n        8.19. The Class QoSPolicyRSVPDestinationPortVariable.
    . . . . 63\n        8.20. The Class QoSPolicyRSVPIPProtocolVariable . . . . .
    . . 63\n        8.21. The Class QoSPolicyRSVPIPVersionVariable. . . . . . . .
    63\n        8.22. The Class QoSPolicyRSVPDCLASSVariable . . . . . . . . . 64\n
    \       8.23. The Class QoSPolicyRSVPStyleVariable. . . . . . . . . . 64\n        8.24.
    The Class QoSPolicyRSVPIntServVariable. . . . . . . . . 65\n        8.25. The
    Class QoSPolicyRSVPMessageTypeVariable. . . . . . . 65\n        8.26. The Class
    QoSPolicyRSVPPreemptionPriorityVariable . . . 65\n        8.27. The Class QoSPolicyRSVPPreemptionDefPriorityVariable.
    . 66\n        8.28. The Class QoSPolicyRSVPUserVariable . . . . . . . . . . 66\n
    \       8.29. The Class QoSPolicyRSVPApplicationVariable. . . . . . . 66\n        8.30.
    The Class QoSPolicyRSVPAuthMethodVariable . . . . . . . 67\n        8.31. The
    Class QosPolicyDNValue. . . . . . . . . . . . . . . 67\n              8.31.1.
    The Property qpDNList . . . . . . . . . . . . . 68\n        8.32. The Class QoSPolicyRSVPSimpleAction
    . . . . . . . . . . 68\n              8.32.1. The Property qpRSVPActionType .
    . . . . . . . . 68\n   9.   Intellectual Property Rights Statement. . . . . .
    . . . . . . 69\n   10.  Acknowledgements. . . . . . . . . . . . . . . . . . .
    . . . . 69\n   11.  Security Considerations . . . . . . . . . . . . . . . . .
    . . 69\n   12.  References. . . . . . . . . . . . . . . . . . . . . . . . . .
    70\n        12.1.  Normative References . . . . . . . . . . . . . . . . . 70\n
    \       12.2.  Informative References . . . . . . . . . . . . . . . . 70\n   13.
    \ Authors' Addresses. . . . . . . . . . . . . . . . . . . . . . 72\n   14.  Full
    Copyright Statement. . . . . . . . . . . . . . . . . . . 73\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The QoS Policy Information Model (QPIM) establishes a standard\n
    \  framework and constructs for specifying and representing policies\n   that
    administer, manage, and control access to network QoS resources.\n   Such policies
    will be referred to as \"QoS policies\" in this document.\n   The framework consists
    of a set of classes and relationships that are\n   organized in an object-oriented
    information model.  It is agnostic of\n   any specific Policy Decision Point (PDP)
    or Policy Enforcement Point\n   (PEP) (see [TERMS] for definitions) implementation,
    and independent\n   of any particular QoS implementation mechanism.\n   QPIM is
    designed to represent QoS policy information for large-scale\n   policy domains
    (the term \"policy domain\" is defined in [TERMS]).  A\n   primary goal of this
    information model is to assist human\n   administrators in their definition of
    policies to control QoS\n   resources (as opposed to individual network element
    configuration).\n   The process of creating QPIM data instances is fed by business
    rules,\n   network topology and QoS methodology (e.g., Differentiated Services).\n
    \  This document is based on the IETF Policy Core Information Model and\n   its
    extensions as specified by [PCIM] and [PCIMe].  QPIM builds upon\n   these two
    documents to define an information model for QoS\n   enforcement for differentiated
    and integrated services ([DIFFSERV]\n   and [INTSERV], respectively) using policy.
    \ It is important to note\n   that this document defines an information model,
    which by definition\n   is independent of any particular data storage mechanism
    and access\n   protocol.  This enables various data models (e.g., directory\n
    \  schemata, relational database schemata, and SNMP MIBs) to be designed\n   and
    implemented according to a single uniform model.\n   The key words \"MUST\", \"MUST
    NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
    \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
    as described in BCP 14, RFC 2119\n   [KEYWORDS].\n"
  - contents:
    - "1.1.  The Process of QoS Policy Definition\n   This section describes the process
      of using QPIM for the definition\n   QoS policy for a policy domain.  Figure
      1 illustrates information\n   flow and not the actual procedure, which has several
      loops and\n   feedback not depicted.\n    ----------        ----------       -----------\n
      \  | Business |      | Topology |     |   QoS     |\n   | Policy   |      |
      \         |     |Methodology|\n    ----------        ----------       -----------\n
      \       |                  |               |\n        |                  |               |\n
      \       ------------------------------------\n                           |\n
      \                          V\n                    ---------------\n                   |
      \ QPIM/PCIM(e) |\n                   |   modeling    |\n                    ---------------\n
      \                          |\n                           |            --------------\n
      \                          |<----------| Device info, |\n                           |
      \          | capabilities |\n                           |            --------------\n
      \                          V\n                    (---------------)\n                    (
      \   device     )---)\n                    ( configuration )   )---)\n                    (---------------)
      \  )   )\n                         (--------------)   )\n                              (-------------)\n
      \              Figure 1: The QoS definition information flow\n   The process
      of QoS policy definition is dependent on three types of\n   information: the
      topology of the network devices under management,\n   the particular type of
      QoS methodology used (e.g., DiffServ) and the\n   business rules and requirements
      for specifying service(s) [TERMS]\n   delivered by the network.  Both topology
      and business rules are\n   outside the scope of QPIM.  However, important facets
      of both must be\n   known and understood for correctly specifying the QoS policy.\n
      \  Typically, the process of QoS policy definition relies on a\n   methodology
      based on one or more QoS methodologies.  For example, the\n   DiffServ methodology
      may be employed in the QoS policy definition\n   process.\n   The topology of
      the network consists of an inventory of the network\n   elements that make up
      the network and the set of paths that traffic\n   may take through the network.
      \ For example, a network administrator\n   may decide to use the DiffServ architectural
      model [DIFFSERV] and\n   classify network devices using the roles \"boundary\"
      and \"core\" (see\n   [TERMS] for a definition of role, and [PCIM] for an explanation
      of\n   how they are used in the policy framework).  While this is not a\n   complete
      topological view of the network, many times it may suffice\n   for the purpose
      of QoS policy definition.\n   Business rules are informal sets of requirements
      for specifying the\n   behavior of various types of traffic that may traverse
      the network.\n   For example, the administrator may be instructed to implement
      policy\n   such that VoIP traffic manifests behavior that is similar to legacy\n
      \  voice traffic over telephone networks.  Note that this business rule\n   (indirectly)
      prescribes specific behavior for this traffic type\n   (VoIP), for example in
      terms of minimal delay, jitter and loss.\n   Other traffic types, such as WEB
      buying transactions, system backup\n   traffic, video streaming, etc., will
      express their traffic\n   conditioning requirements in different terms.  Again,
      this\n   information is required not by QPIM itself, but by the overall policy\n
      \  management system that uses QPIM.  QPIM is used to help map the\n   business
      rules into a form that defines the requirements for\n   conditioning different
      types of traffic in the network.\n   The topology, QoS methodology, and business
      rules are necessary\n   prerequisites for defining traffic conditioning.  QPIM
      enables a set\n   of tools for specifying traffic conditioning policy in a standard\n
      \  manner.  Using a standard QoS policy information model such as QPIM\n   is
      needed also because different devices can have markedly different\n   capabilities.
      \ Even the same model of equipment can have different\n   functionality if the
      network operating system and software running in\n   those devices is different.
      \ Therefore, a means is required to\n   specify functionality in a standard
      way that is independent of the\n   capabilities of different vendors' devices.
      \ This is the role of\n   QPIM.\n   In a typical scenario, the administrator
      would first determine the\n   role(s) that each interface of each network element
      plays in the\n   overall network topology.  These roles define the functions
      supplied\n   by a given network element independent of vendor and device type.\n
      \  The [PCIM] and [PCIMe] documents define the concept of a role.  Roles\n   can
      be used to identify what parts of the network need which type of\n   traffic
      conditioning.  For example, network interface cards that are\n   categorized
      as \"core\" interfaces can be assigned the role name\n   \"core-interface\".
      \ This enables the administrator to design policies\n   to configure all interfaces
      having the role \"core-interface\"\n   independent of the actual physical devices
      themselves.  QPIM uses\n   roles to help the administrator map a given set of
      devices or\n   interfaces to a given set of policy constructs.\n   The policy
      constructs define the functionality required to perform\n   the desired traffic
      conditioning for particular traffic type(s).  The\n   functions themselves depend
      on the particular type of networking\n   technologies chosen.  For example,
      the DiffServ methodology\n   encourages us to aggregate similar types of traffic
      by assigning to\n   each traffic class a particular per-hop forwarding behavior
      on each\n   node.  RSVP enables bandwidth to be reserved.  These two\n   methodologies
      can be used separately or in conjunction, as defined by\n   the appropriate
      business policy.  QPIM provides specific classes to\n   enable DiffServ and
      RSVP conditioning to be modeled.\n   The QPIM class definitions are used to
      create instances of various\n   policy constructs such as QoS actions and conditions
      that may be\n   hierarchically organized in rules and groups (PolicyGroup and\n
      \  PolicyRule as defined in [PCIM] and [PCIMe]).  Examples of policy\n   actions
      are rate limiting, jitter control and bandwidth allocation.\n   Policy conditions
      are constructs that can select traffic according to\n   a complex Boolean expression.\n
      \  A hierarchical organization was chosen for two reasons.  First, it\n   best
      reflects the way humans tend to think about complex policy.\n   Second, it enables
      policy to be easily mapped onto administrative\n   organizations, as the hierarchical
      organization of policy mirrors\n   most administrative organizations.  It is
      important to note that the\n   policy definition process described here is done
      independent of any\n   specific device capabilities and configuration options.
      \ The policy\n   definition is completely independent from the details of the\n
      \  implementation and the configuration interface of individual network\n   elements,
      as well as of the mechanisms that a network element can use\n   to condition
      traffic.\n"
    title: 1.1.  The Process of QoS Policy Definition
  - contents:
    - "1.2.  Design Goals and Their Ramifications\n   This section explains the QPIM
      design goals and how these goals are\n   addressed in this document.  This section
      also describes the\n   ramifications of the design goals and the design decisions
      made in\n   developing QPIM.\n"
    - contents:
      - "1.2.1.  Policy-Definition Oriented\n   The primary design goal of QPIM is
        to model policies controlling QoS\n   behavior in a way that as closely as
        possible reflects the way humans\n   tend to think about policy.  Therefore,
        QPIM is designed to address\n   the needs of policy definition and management,
        and not device/network\n   configuration.\n   There are several ramifications
        of this design goal.  First, QPIM\n   uses rules to define policies, based
        on [PCIM] and [PCIMe].  Second,\n   QPIM uses hierarchical organizations of
        policies and policy\n   information extensively.  Third, QPIM does not force
        the policy\n   writer to specify all implementation details; rather, it assumes
        that\n   configuration agents (PDPs) interpret the policies and match them
        to\n   suit the needs of device-specific configurations.\n"
      - contents:
        - "1.2.1.1.  Rule-based Modeling\n   Policy is best described using rule-based
          modeling as explained and\n   described in [PCIM] and [PCIMe].  A QoS policy
          rule is structured as\n   a condition clause and an action clause.  The
          semantics are simple:\n   if the condition clause evaluates to TRUE, then
          a set of QoS actions\n   (specified in the action clause) can be executed.
          \ For example, the\n   rule:\n      \"WEB traffic should receive at least
          50% of the available\n      bandwidth resources or more, when more is available\"\n
          \  can be formalized as:\n      \"<If protocol == HTTP> then <minimum BW
          = 50%>\"\n   where the first angle bracketed clause is a traffic condition
          and the\n   second angle bracketed clause is a QoS action.\n   This approach
          differs from data path modeling that describes the\n   mechanisms that operates
          on the packet flows to achieve the desired\n   effect.\n   Note that the
          approach taken in QPIM specifically did NOT subclass\n   the PolicyRule
          class.  Rather, it uses the SimplePolicyCondition,\n   CompoundPolicyCondition,
          SimplePolicyAction, and CompoundPolicyAction\n   classes defined in [PCIMe],
          as well as defining subclasses of the\n   following classes: Policy, PolicyAction,
          SimplePolicyAction,\n   PolicyImplicitVariable, and PolicyValue.  Subclassing
          the PolicyRule\n   class would have made it more difficult to combine actions
          and\n   conditions defined within different functional domains [PCIMe] within\n
          \  the same rules.\n"
        title: 1.2.1.1.  Rule-based Modeling
      - contents:
        - "1.2.1.2.  Organize Information Hierarchically\n   The organization of the
          information represented by QPIM is designed\n   to be hierarchical.  To
          do this, QPIM utilizes the PolicySetComponent\n   aggregation [PCIMe] to
          provide an arbitrarily nested organization of\n   policy information.  A
          policy group functions as a container of\n   policy rules and/or policy
          groups.  A policy rule can also contain\n   policy rules and/or groups,
          enabling a rule/sub-rule relationship to\n   be realized.\n   The hierarchical
          design decision is based on the realization that it\n   is natural for humans
          to organize policy rules in groups.  Breaking\n   down a complex policy
          into a set of simple rules is a process that\n   follows the way people
          tend to think and analyze systems.  The\n   complexity of the abstract,
          business-oriented policy is simplified\n   and made into a hierarchy of
          simple rules and grouping of simple\n   rules.\n   The hierarchical information
          organization helps to simplify the\n   definition and readability of data
          instances based on QPIM.\n   Hierarchies can also serve to carry additional
          semantics for QoS\n   actions in a given context.  An example, detailed
          in section 2.3,\n   demonstrates how hierarchical bandwidth allocation policies
          can be\n   specified in an intuitive form, without the need to specify complex\n
          \  scheduler structures.\n"
        title: 1.2.1.2.  Organize Information Hierarchically
      - contents:
        - "1.2.1.3.  Goal-Oriented Policy Definition\n   QPIM facilitates goal-oriented
          QoS policy definition.  This means\n   that the process of defining QoS
          policy is focused on the desired\n   effect of policies, as opposed to the
          means of implementing the\n   policy on network elements.\n   QPIM is intended
          to define a minimal specification of desired network\n   behavior.  It is
          the role of device-specific configuration agents to\n   interpret policy
          expressed in a standard way and fill in the\n   necessary configuration
          details that are required for their\n   particular application.  The benefit
          of using QPIM is that it\n   provides a common lingua franca that each of
          the device- and/or\n   vendor-specific configuration agents can use.  This
          helps ensure a\n   common interpretation of the general policy as well as
          aid the\n   administrator in specifying a common policy to be implemented
          across\n   different devices.  This is analogous to the fundamental object-\n
          \  oriented paradigm of separating specification from implementation.\n
          \  Using QPIM, traffic conditioning can be specified in a general manner\n
          \  that can help different implementations satisfy a common goal.\n   For
          example, a valid policy may include only a single rule that\n   specifies
          that bandwidth should be reserved for a given set of\n   traffic flows.
          \ The rule does not need to include any of the various\n   other details
          that may be needed for implementing a scheduler that\n   supports this bandwidth
          allocation (e.g., the queue length required).\n   It is assumed that a PDP
          or the PEPs would fill in these details\n   using (for example) their default
          queue length settings.  The policy\n   writer need only specify the main
          goal of the policy, making sure\n   that the preferred application receives
          enough bandwidth to operate\n   adequately.\n"
        title: 1.2.1.3.  Goal-Oriented Policy Definition
      title: 1.2.1.  Policy-Definition Oriented
    - contents:
      - "1.2.2.  Policy Domain Model\n   An important design goal of QPIM is to provide
        a means for defining\n   policies that span numerous devices.  This goal differentiates
        QPIM\n   from device-level information models, which are designed for modeling\n
        \  policy that controls a single device, its mechanisms and\n   capabilities.\n
        \  This design goal has several ramifications.  First, roles [PCIM] are\n
        \  used to define policies across multiple devices.  Second, the use of\n
        \  abstract policies frees the policy definition process from having to\n
        \  deal with individual device peculiarities, and leaves interpretation\n
        \  and configuration to be modeled by PDPs or other configuration\n   agents.
        Third, QPIM allows extensive reuse of all policy building\n   blocks in multiple
        rules used within different devices.\n"
      - contents:
        - "1.2.2.1.  Model QoS Policy in a Device- and Vendor-Independent Manner\n
          \  QPIM models QoS policy in a way designed to be independent of any\n   particular
          device or vendor.  This enables networks made up of\n   different devices
          that have different capabilities to be managed and\n   controlled using
          a single standard set of policies.  Using such a\n   single set of policies
          is important because otherwise, the policy\n   will itself reflect the differences
          between different device\n   implementations.\n"
        title: 1.2.2.1.  Model QoS Policy in a Device- and Vendor-Independent Manner
      - contents:
        - "1.2.2.2.  Use Roles for Mapping Policy to Network Devices\n   The use of
          roles enables a policy definition to be targeted to the\n   network function
          of a network element, rather than to the element's\n   type and capabilities.
          \ The use of roles for mapping policy to\n   network elements provides an
          efficient and simple method for compact\n   and abstract policy definition.
          \ A given abstract policy may be\n   mapped to a group of network elements
          without the need to specify\n   configuration for each of those elements
          based on the capabilities of\n   any one individual element.\n   The policy
          definition is designed to allow aggregating multiple\n   devices within
          the same role, if desired.  For example, if two core\n   network interfaces
          operate at different rates, one does not have to\n   define two separate
          policy rules to express the very same abstract\n   policy (e.g., allocating
          30% of the interface bandwidth to a given\n   preferred set of flows).  The
          use of hierarchical context and\n   relative QoS actions in QPIM addresses
          this and other related\n   problems.\n"
        title: 1.2.2.2.  Use Roles for Mapping Policy to Network Devices
      - contents:
        - "1.2.2.3.  Reusability\n   Reusable objects, as defined by [PCIM] and [PCIMe],
          are the means for\n   sharing policy building blocks, thus allowing central
          management of\n   global concepts.  QPIM provides the ability to reuse all
          policy\n   building blocks: variables and values, conditions and actions,\n
          \  traffic profiles, and policy groups and policy rules.  This provides\n
          \  the required flexibility to manage large sets of policy rules over\n
          \  large policy domains.\n   For example, the following rule makes use of
          centrally defined\n   objects being reused (referenced):\n      If <DestinationAddress
          == FinanceSubNet> then <DSCP =\n      MissionCritical>\n   In this rule,
          the condition refers to an object named FinanceSubNet,\n   which is a value
          (or possibly a set of values) defined and maintained\n   in a reusable objects
          container.  The QoS action makes use of a value\n   named MissionCritical,
          which is also a reusable object.  The\n   advantage of specifying a policy
          in this way is its inherent\n   flexibility.  Given the above policy, whenever
          business needs require\n   a change in the subnet definition for the organization,
          all that's\n   required is to change the reusable value FinanceSubNet centrally.\n
          \  All referencing rules are immediately affected, without the need to\n
          \  modify them individually. Without this capability, the repository\n   that
          is used to store the rules would have to be searched for all\n   rules that
          refer to the finance subnet, and then each matching rule's\n   condition
          would have to be individually updated.  This is not only\n   much less efficient,
          but also is more prone to error.\n   For a complete description of reusable
          objects, refer to [PCIM] and\n   [PCIMe].\n"
        title: 1.2.2.3.  Reusability
      title: 1.2.2.  Policy Domain Model
    - contents:
      - "1.2.3.  Enforceable Policy\n   Policy defined by QPIM should be enforceable.
        \ This means that a PDP\n   can use QPIM's policy definition in order to make
        the necessary\n   decisions and enforce the required policy rules.  For example,
        RSVP\n   admission decisions should be made based on the policy definitions\n
        \  specified by QPIM.  A PDP should be able to map QPIM policy\n   definitions
        into PEP configurations, using either standard or\n   proprietary protocols.\n
        \  QPIM is designed to be agnostic of any particular, vendor-dependent\n   technology.
        \ However, QPIM's constructs SHOULD always be interpreted\n   so that policy-compliant
        behavior can be enforced on the network\n   under management.  Therefore,
        there are three fundamental\n   requirements that QPIM must satisfy:\n   1.
        Policy specified by QPIM must be able to be mapped to actual\n      network
        elements.\n   2. Policy specified by QPIM must be able to control QoS network\n
        \     functions without making reference to a specific type of device or\n
        \     vendor.\n   3. Policy specified by QPIM must be able to be translated
        into\n      network element configuration.\n   QPIM satisfies requirements
        #1 and #2 above by using the concept of\n   roles (specifically, the PolicyRoles
        property, defined in PCIM).  By\n   matching roles assigned to policy groups
        and to network elements, a\n   PDP (or other enforcement agent) can determine
        what policy should be\n   applied to a given device or devices.\n   The use
        of roles in mapping policy to network elements supports model\n   scalability.
        \ QPIM policy can be mapped to large-scale policy domains\n   by assigning
        a single role to a group of network elements.  This can\n   be done even when
        the policy domain contains heterogeneous devices.\n   So, a small set of policies
        can be deployed to large networks without\n   having to re-specify the policy
        for each device separately.  This\n   QPIM property is important for QoS policy
        management applications\n   that strive to ease the task of policy definition
        for large policy\n   domains.\n   Requirement #2 is also satisfied by making
        QPIM domain-oriented (see\n   [TERMS] for a definition of \"domain\").  In
        other words, the target of\n   the policy is a domain, as opposed to a specific
        device or interface.\n   Requirement #3 is satisfied by modeling QoS conditions
        and actions\n   that are commonly configured on various devices.  However,
        QPIM is\n   extensible to allow modeling of actions that are not included
        in\n   QPIM.\n   It is important to note that different PEPs will have different\n
        \  capabilities and functions, which necessitate different individual\n   configurations
        even if the different PEPs are controlled by the same\n   policy.\n"
      title: 1.2.3.  Enforceable Policy
    - contents:
      - "1.2.4.  QPIM Covers Both Signaled And Provisioned QoS\n   The two predominant
        standards-based QoS methodologies developed so\n   far are Differentiated
        Services (DiffServ) and Integrated Services\n   (IntServ).  The DiffServ provides
        a way to enforce policies that\n   apply to a large number of devices in a
        scalable manner.  QPIM\n   provides actions and conditions that control the
        classification,\n   policing and shaping done within the differentiated service
        domain\n   boundaries, as well as actions that control the per-hop behavior\n
        \  within the core of the DiffServ network.  QPIM does not mandate the\n   use
        of DiffServ as a policy methodology.\n   Integrated services, together with
        its signaling protocol (RSVP),\n   provides a way for end nodes (and edge
        nodes) to request QoS from the\n   network.  QPIM provides actions that control
        the reservation of such\n   requests within the network.\n   As both methodologies
        continue to evolve, QPIM does not attempt to\n   provide full coverage of
        all possible scenarios.  Instead, QPIM aims\n   to provide policy control
        modeling for all major scenarios.  QPIM is\n   designed to be extensible to
        allow for incorporation of control over\n   newly developed QoS mechanisms.\n"
      title: 1.2.4.  QPIM Covers Both Signaled And Provisioned QoS
    - contents:
      - "1.2.5.  Interoperability for PDPs and Management Applications\n   Another
        design goal of QPIM is to facilitate interoperability among\n   policy systems
        such as PDPs and policy management applications.  QPIM\n   accomplishes this
        interoperability goal by standardizing the\n   representation of policy.  Producers
        and consumers of QoS policy need\n   only rely on QPIM-based schemata (and
        resulting data models) to\n   ensure mutual understanding and agreement on
        the semantics of QoS\n   policy.\n   For example, suppose that a QoS policy
        management application, built\n   by vendor A writes its policies based on
        the LDAP schema that maps\n   from QPIM to a directory implementation using
        LDAP.  Now assume that\n   a separately built PDP from vendor B also relies
        on this same LDAP\n   schema derived from QPIM.  Even though these are two
        vendors with two\n   different PDPs, each may read the schema of the other
        and\n   \"understand\" it.  This is because both the management application
        and\n   the PDP were architected to comply with the QPIM specification.  The\n
        \  same is true with two policy management applications.  For example,\n   vendor
        B's policy application may run a validation tool that computes\n   whether
        there are conflicts within rules specified by the other\n   vendor's policy
        management application.\n   Interoperability of QPIM producers/consumers is
        by definition at a\n   high level, and does not guarantee that the same policy
        will result\n   in the same PEP configuration.  First, different PEPs will
        have\n   different capabilities and functions, which necessitate different\n
        \  individual configurations even if the different PEPs are controlled\n   by
        the same policy.  Second, different PDPs will also have different\n   capabilities
        and functions, and may choose to translate the high-\n   level QPIM policy
        differently depending on the functionality of the\n   PDP, as well as on the
        capabilities of the PEPs that are being\n   controlled by the PDP.  However,
        the different configurations should\n   still result in the same network behavior
        as that specified by the\n   policy rules.\n"
      title: 1.2.5.  Interoperability for PDPs and Management Applications
    title: 1.2.  Design Goals and Their Ramifications
  - contents:
    - "1.3.  Modeling Abstract QoS Policies\n   This section provides a discussion
      of QoS policy abstraction and the\n   way QPIM addresses this issue.\n   As
      described above, the main goal of the QPIM is to create an\n   information model
      that can be used to help bridge part of the\n   conceptual gap between a human
      policy maker and a network element\n   that is configured to enforce the policy.
      \ Clearly this wide gap\n   implies several translation levels, from the abstract
      to the\n   concrete.  At the abstract end are the business QoS policy rules.\n
      \  Once the business rules are known, a network administrator must\n   interpret
      them as network QoS policy and represent this QoS policy by\n   using QPIM constructs.
      \ QPIM facilitates a formal representation of\n   QoS rules, thus providing
      the first concretization level: formally\n   representing humanly expressed
      QoS policy.\n   When a human business executive defines network policy, it is
      usually\n   done using informal business terms and language.  For example, a\n
      \  human may utter a policy statement that reads:\n      \"human resources applications
      should have better QoS than simple\n      web applications\"\n   This might
      be translated to a slightly more sophisticated form, such\n   as:\n      \"traffic
      generated by our human resources applications should have\n      a higher probability
      of communicating with its destinations than\n      traffic generated by people
      browsing the WEB using non-mission-\n      critical applications\"\n   While
      this statement clearly defines QoS policy at the business\n   level, it isn't
      specific enough to be enforceable by network\n   elements. Translation to \"network
      terms and language\" is required.\n   On the other end of the scale, a network
      element functioning as a\n   PEP, such as a router, can be configured with specific
      commands that\n   determine the operational parameters of its inner working
      QoS\n   mechanisms.  For example, the (imaginary) command \"output-queue-depth\n
      \  = 100\" may be an instruction to a network interface card of a router\n   to
      allow up to 100 packets to be stored before subsequent packets are\n   discarded
      (not forwarded).  On a different device within the same\n   network, the same
      instruction may take another form, because a\n   different vendor built that
      device or it has a different set of\n   functions, and hence implementation,
      even though it is from the same\n   vendor.  In addition, a particular PEP may
      not have the ability to\n   create queues that are longer than, say, 50 packets,
      which may result\n   in a different instruction implementing the same QoS policy.\n
      \  The first example illustrates 'abstract policy', while the second\n   illustrates
      'concrete configuration'.  Furthermore, the first example\n   illustrates end-to-end
      policy, which covers the conditioning of\n   application traffic throughout
      the network.  The second example\n   illustrates configuration for a particular
      PEP or a set thereof.\n   While an end-to-end policy statement can only be enforced
      by\n   configuration of PEPs in various parts of the network, the\n   information
      model of policy and that of the mechanisms that a PEP\n   uses to implement
      that policy are vastly different.\n   The translation process from abstract
      business policy to concrete PEP\n   configuration is roughly expressed as follows:\n
      \  1. Informal business QoS policy is expressed by a human policy maker\n      (e.g.,
      \"All executives' WEB requests should be prioritized ahead\n      of other employees'
      WEB requests\")\n   2. A network administrator analyzes the policy domain's
      topology and\n      determines the roles of particular device interfaces.  A
      role may\n      be assigned to a large group of elements, which will result
      in\n      mapping a particular policy to a large group of device interfaces.\n
      \  3. The network administrator models the informal policy using QPIM\n      constructs,
      thus creating a formal representation of the abstract\n      policy.  For example,
      \"If a packet's protocol is HTTP and its\n      destination is in  the 'EXECUTIVES'
      user group, then assign IPP 7\n      to the packet header\".\n   4. The network
      administrator assigns roles to the policy groups\n      created in the previous
      step matching the network elements' roles\n      assigned in step #2 above.\n
      \  5. A PDP translates the abstract policy constructs created in step #3\n      into
      device-specific configuration commands for all devices\n      effected by the
      new policy (i.e., devices that have interfaces\n      that are assigned a role
      matching the new policy constructs'\n      roles).  In this process, the PDP
      consults the particular devices'\n      capabilities to determine the appropriate
      configuration commands\n      implementing the policy.\n   6. For each PEP in
      the network, the PDP (or an agent of the PDP)\n      issues the appropriate
      device-specific instructions necessary to\n      enforce the policy.\n   QPIM,
      PCIM and PCIMe are used in step #3 above.\n"
    title: 1.3.  Modeling Abstract QoS Policies
  - contents:
    - "1.4.  Rule Hierarchy\n   Policy is described by a set of policy rules that
      may be grouped into\n   subsets [PCIMe].  Policy rules and policy groups can
      be nested within\n   other policy rules, providing a hierarchical policy definition.\n
      \  Nested rules are also called sub-rules, and we use both terms in this\n   document
      interchangeably.  The aggregation PolicySetComponent\n   (defined in [PCIMe]
      is used to represent the nesting of a policy rule\n   or group in another policy
      rule.\n   The hierarchical policy rule definition enhances policy readability\n
      \  and reusability.  Within the QoS policy information model, hierarchy\n   is
      used to model context or scope for the sub-rule actions.  Within\n   QPIM, bandwidth
      allocation policy actions and drop threshold actions\n   use this hierarchal
      context.  First we provide a detailed example of\n   the use of hierarchy in
      bandwidth allocation policies.  The\n   differences between flat and hierarchical
      policy representation are\n   discussed.  The use of hierarchy in drop threshold
      policies is\n   described in a following subsection.  Last but not least, the\n
      \  restrictions on the use of rule hierarchies within QPIM are\n   described.\n"
    - contents:
      - "1.4.1.  Use of Hierarchy Within Bandwidth Allocation Policies\n   Consider
        the following example where the informal policy reads:\n      On any interface
        on which these rules apply, guarantee at least\n      30% of the interface
        bandwidth to UDP flows, and at least 40% of\n      the interface bandwidth
        to TCP flows.\n   The QoS Policy information model follows the Policy Core
        information\n   model by using roles as a way to specify the set of interfaces
        on\n   which this policy applies.  The policy does not assume that all\n   interfaces
        are run at the same speed, or have any other property in\n   common apart
        from being able to forward packets.  Bandwidth is\n   allocated between UDP
        and TCP flows using percentages of the\n   available interface bandwidth.
        \ Assume that we have an available\n   interface bandwidth of 1 Mbits/sec.
        \ Then this rule will guarantee\n   300Kbits/sec to UDP flows.  However, if
        the interface bandwidth was\n   instead only 64kbits/sec, then this rule would
        correspondingly\n   guarantee 19.2kb/sec.\n   This policy is modeled within
        QPIM using two policy rules of the\n   form:\n      If (IP protocol is UDP)
        THEN (guarantee 30% of available BW) (1)\n      If (IP protocol is TCP) THEN
        (guarantee 40% of available BW) (2)\n   Assume that these two rules are grouped
        within a PolicySet [PCIMe]\n   carrying the appropriate role combination.
        \ A possible implementation\n   of these rules within a PEP would be to use
        a Weighted-Round-Robin\n   scheduler with 3 queues.  The first queue would
        be used for UDP\n   traffic, the second queue for TCP traffic and the third
        queue for the\n   rest of the traffic.  The weights of the Weighted-Round-Robin\n
        \  scheduler would be 30% for the first queue, 40% for the second queue\n
        \  and 30% for the last queue.\n   The actions specifying the bandwidth guarantee
        implicitly assume that\n   the bandwidth resource being guaranteed is the
        bandwidth available at\n   the interface level.  A PolicyRoleCollection is
        a class defined in\n   [PCIMe] whose purpose is to identify the set of resources
        (in this\n   example, interfaces) that are assigned to a particular role.
        \ Thus,\n   the type of managed elements aggregated within the\n   PolicyRoleCollection
        defines the bandwidth resource being controlled.\n   In our example, interfaces
        are aggregated within the\n   PolicyRoleCollection.  Therefore, the rules
        specify bandwidth\n   allocation to all interfaces that match a given role.
        \ Other behavior\n   could be similarly defined by changing what was aggregated
        within the\n   PolicyRoleCollection.\n   Normally, a full specification of
        the rules would require indicating\n   the direction of the traffic for which
        bandwidth allocation is being\n   made.  Using the direction variable defined
        in [PCIMe], the rules can\n   be specified in the following form:\n      If
        (direction is out)\n          If (IP protocol is UDP) THEN (guarantee 30%
        of available BW)\n          If (IP protocol is TCP) THEN (guarantee 40% of
        available BW)\n   where indentation is used to indicate rule nesting.  To
        save space,\n   we omit the direction condition from further discussion.\n
        \  Rule nesting provides the ability to further refine the scope of\n   bandwidth
        allocation within a given traffic class forwarded via these\n   interfaces.
        \ The example below adds two nested rules to refine\n   bandwidth allocation
        for UDP and TCP applications.\n      If (IP protocol is UDP) THEN (guarantee
        30% of available BW) (1)\n         If (protocol is TFTP) THEN (guarantee 10%
        of available BW) (1a)\n         If (protocol is NFS) THEN (guarantee 40% of
        available BW) (1b)\n      If (IP protocol is TCP) THEN (guarantee 40% of available
        BW) (2)\n         If (protocol is HTTP) THEN guarantee 20% of available BW)
        (2a)\n         If (protocol is FTP) THEN (guarantee 30% of available BW) (2b)\n
        \  Subrules 1a and 1b specify bandwidth allocation for UDP applications.\n
        \  The total bandwidth resource being partitioned among UDP applications\n
        \  is the bandwidth available for the UDP traffic class (i.e., 30%), not\n
        \  the total bandwidth available at the interface level.  Furthermore,\n   TFTP
        and NFS are guaranteed to get at least 10% and 40% of the total\n   available
        bandwidth for UDP, while other UDP applications aren't\n   guaranteed to receive
        anything.  Thus, TFTP and NFS are guaranteed to\n   get at least 3% and 12%
        of the total bandwidth.  Similar logic\n   applies to the TCP applications.\n
        \  The point of this section will be to show that a hierarchical policy\n
        \  representation enables a finer level of granularity for bandwidth\n   allocation
        to be specified than is otherwise available using a non-\n   hierarchical
        policy representation.  To see this, let's compare this\n   set of rules with
        a non-hierarchical (flat) rule representation.  In\n   the non-hierarchical
        representation, the guaranteed bandwidth for\n   TFTP flows is calculated
        by taking 10% of the bandwidth guaranteed to\n   UDP flows, resulting in 3%
        of the total interface bandwidth\n   guarantee.\n      If (UDP AND TFTP) THEN
        (guarantee 3% of available BW) (1a)\n      If (UDP AND NFS) THEN (guarantee
        12% of available BW) (1b)\n      If (other UDP APPs) THEN (guarantee 15% of
        available BW) (1c)\n      If (TCP AND HTTP) THEN guarantee 8% of available
        BW) (2a)\n      If (TCP AND FTP) THEN (guarantee 12% of available BW) (2b)\n
        \     If (other TCP APPs) THEN (guarantee 20% of available BW) (2c)\n   Are
        these two representations identical?  No, bandwidth allocation is\n   not
        the same.  For example, within the hierarchical representation,\n   UDP applications
        are guaranteed 30% of the bandwidth.  Suppose a\n   single UDP flow of an
        application different from NFS or TFTP is\n   running.  This application would
        be guaranteed 30% of the interface\n   bandwidth in the hierarchical representation
        but only 15% of the\n   interface bandwidth in the flat representation.\n
        \  A two stage scheduler is best modeled by a hierarchical\n   representation
        whereas a flat representation may be realized by a\n   non-hierarchical scheduler.\n
        \  A schematic hierarchical Weighted-Round-Robin scheduler\n   implementation
        that supports the hierarchical rule representation is\n   described below.\n
        \     --UDP AND TFTP queue--10%\n      --UDP AND NFS  queue--40%-Scheduler-30%--+\n
        \     --Other UDP    queue--50%     A1         |\n                                               |\n
        \     --TCP AND HTTP queue--20%                |\n      --TCP AND FTP  queue--30%-Scheduler-40%--Scheduler--Interface\n
        \     --Other TCP    queue--50%     A2         |   B\n                                               |\n
        \     ------------Non UDP/TCP traffic-----30%--+\n   Scheduler A1 extracts
        packets from the 3 UDP queues according to the\n   weight specified by the
        UDP sub-rule policy.  Scheduler A2 extracts\n   packets from the 3 TCP queues
        specified by the TCP sub-rule policy.\n   The second stage scheduler B schedules
        between UDP, TCP and all other\n   traffic according to the policy specified
        in the top most rule level.\n   Another difference between the flat and hierarchical
        rule\n   representation is the actual division of bandwidth above the minimal\n
        \  bandwidth guarantee.  Suppose two high rate streams are being\n   forwarded
        via this interface: an HTTP stream and an NFS stream.\n   Suppose that the
        rate of each flow is far beyond the capacity of the\n   interface.  In the
        flat scheduler implementation, the ratio between\n   the weights is 8:12 (i.e.,
        HTTP:NFS), and therefore HTTP stream would\n   consume 40% of the bandwidth
        while NFS would consume 60% of the\n   bandwidth.  In the hierarchical scheduler
        implementation the only\n   scheduler that has two queues filled is scheduler
        B, therefore the\n   ratio between the HTTP (TCP) stream and the NFS (UDP)
        stream would be\n   30:40, and therefore the HTTP stream would consume approximately
        42%\n   of the interface bandwidth while NFS would consume 58% of the\n   interface
        bandwidth.  In both cases both HTTP and NFS streams got\n   more than the
        minimal guaranteed bandwidth, but the actual rates\n   forwarded via the interface
        differ.\n   The conclusion is that hierarchical policy representation provides\n
        \  additional structure and context beyond the flat policy\n   representation.
        \ Furthermore, policies specifying bandwidth\n   allocation using rule hierarchies
        should be enforced using\n   hierarchical schedulers where the rule hierarchy
        level is mapped to\n   the hierarchical scheduler level.\n"
      title: 1.4.1.  Use of Hierarchy Within Bandwidth Allocation Policies
    - contents:
      - "1.4.2.  Use of Rule Hierarchy to Describe Drop Threshold Policies\n   Two
        major resources govern the per hop behavior in each node.  The\n   bandwidth
        allocation resource governs the forwarding behavior of each\n   traffic class.
        \ A scheduler priority and weights are controlled by\n   the bandwidth allocation
        policies, as well as the (minimal) number of\n   queues needed for traffic
        separation.  A second resource, which is\n   not controlled by bandwidth allocation
        policies, is the queuing\n   length and drop behavior.  For this purpose,
        queue length and\n   threshold policies are used.\n   Rule hierarchy is used
        to describe the context on which thresholds\n   act.  The policy rule's condition
        describes the traffic class and the\n   rule's actions describe the bandwidth
        allocation, the forwarding\n   priority and the queue length.  If the traffic
        class contains\n   different drop precedence sub-classes that require different\n
        \  thresholds within the same queue, the sub-rules actions describe\n   these
        thresholds.\n   Below is an example of the use of rule nesting for threshold
        control\n   purposes.  Let's look at the following rules:\n      If (protocol
        is FTP) THEN (guarantee 10% of available BW)\n                                (queue
        length equals 40 packets)\n                                (drop technique
        is random)\n         if (src-ip is from net 2.x.x.x) THEN min threshold =
        30%\n                                              max threshold = 70%\n         if
        (src-ip is from net 3.x.x.x) THEN min threshold = 40%\n                                              max
        threshold = 90%\n         if (all other)                  THEN min threshold
        = 20%\n                                                    max threshold =
        60%\n   The rule describes the bandwidth allocation, the queue length and
        the\n   drop technique assigned to FTP flows.  The sub-rules describe the\n
        \  drop threshold priorities within those FTP flows.  FTP packets\n   received
        from all networks apart from networks 2.x.x.x and 3.x.x.x\n   are randomly
        dropped when the queue threshold for FTP flows\n   accumulates to 20% of the
        queue length.  Once the queue fills to 60%,\n   all these packets are dropped
        before queuing.  The two other sub\n   rules provide other thresholds for
        FTP packets coming from the\n   specified two subnets.  The Assured Forwarding
        per hop behavior (AF)\n   is another good example of the use of hierarchy
        to describe the\n   different drop preferences within a traffic class.  This
        example is\n   provided in a later section.\n"
      title: 1.4.2.  Use of Rule Hierarchy to Describe Drop Threshold Policies
    - contents:
      - "1.4.3.  Restrictions of the Use of Hierarchy Within QPIM\n   Rule nesting
        is used within QPIM for two important purposes:\n   1) Enhance clarity, readability
        and reusability.\n   2) Provide hierarchical context for actions.\n   The
        second point captures the ability to specify context for\n   bandwidth allocation,
        as well as providing context for drop threshold\n   policies.\n   When is
        a hierarchy level supposed to specify the bandwidth\n   allocation context,
        when is the hierarchy used for specifying the\n   drop threshold context,
        and when is it used merely for clarity and\n   reusability?  The answer depends
        entirely on the actions.  Bandwidth\n   control actions within a sub-rule
        specify how the bandwidth allocated\n   to the traffic class determined by
        the rule's condition clause should\n   be further divided among the sub-rules.
        \ Drop threshold actions\n   control the traffic class's queue drop behavior
        for each of the sub-\n   rules.  The bandwidth control actions have an implicit
        pointer\n   saying: the bandwidth allocation is relative to the bandwidth\n
        \  resources defined by the higher level rule. Drop threshold actions\n   have
        an implicit pointer saying: the thresholds are taken from the\n   queue resources
        defined by the higher level rule. Other actions do\n   not have such an implicit
        pointer, and for these actions hierarchy is\n   used only for reusability
        and readability purposes.\n   Each rule that includes a bandwidth allocation
        action implies that a\n   queue should be allocated to the traffic class defined
        by the rule's\n   condition clause.  Therefore, once a bandwidth allocation
        action\n   exists within the actions of a sub-rule, a threshold action within\n
        \  this sub-rule cannot refer to thresholds of the parent rule's queue.\n
        \  Instead, it must refer to the queue of the sub-rule itself.\n   Therefore,
        in order to have a clear and unambiguous definition,\n   refinement of thresholds
        and refinements of bandwidth allocations\n   within sub-rules should be avoided.
        \ If both refinements are needed\n   for the same rule, threshold refinements
        and bandwidth refinements\n   rules should each be aggregated to a separate
        group, and these groups\n   should be aggregated under the policy rule, using
        the\n   PolicySetComponent aggregation.\n"
      title: 1.4.3.  Restrictions of the Use of Hierarchy Within QPIM
    title: 1.4.  Rule Hierarchy
  - contents:
    - "1.5.  Intended Audiences\n   QPIM is intended for several audiences.  The following
      lists some of\n   the intended audiences and their respective uses:\n   1. Developers
      of QoS policy management applications can use this\n      model as an extensible
      framework for defining policies to control\n      PEPs and PDPs in an interoperable
      manner.\n   2. Developers of Policy Decision Point (PDP) systems built to control\n
      \     resource allocation signaled by RSVP requests.\n   3. Developers of Policy
      Decision Points (PDP) systems built to create\n      QoS configuration for PEPs.\n
      \  4. Builders of large organization data and knowledge bases who decide\n      to
      combine QoS policy information with other networking policy\n      information,
      assuming all modeling is based on [PCIM] and [PCIMe].\n   5. Authors of various
      standards may use constructs introduced in this\n      document to enhance their
      work.  Authors of data models wishing to\n      map a storage specific technology
      to QPIM must use this document\n      as well.\n"
    title: 1.5.  Intended Audiences
  title: 1.  Introduction
- contents:
  - '2.  Class Hierarchies

    '
  - contents:
    - "2.1.  Inheritance Hierarchy\n   QPIM's class and association inheritance hierarchies
      are rooted in\n   [PCIM] and [PCIMe].  Figures 2 and 3 depict these QPIM inheritance\n
      \  hierarchies, while noting their relationships to [PCIM] and\n   [PCIMe]classes.
      \ Note that many other classes used to form QPIM\n   policies, such as SimplePolicyCondition,
      are defined in [PCIM] and\n   [PCIMe].  Thus, the following figures do NOT represent
      ALL necessary\n   classes and relationships for defining QPIM policies.  Rather,
      the\n   designer using QPIM should use appropriate classes and relationships\n
      \  from [PCIM] and [PCIMe] in conjunction with those defined below.\n [ManagedElement]
      (abstract, PCIM)\n   |\n   +--Policy (abstract, PCIM)\n   |  |\n   |  +---PolicyAction
      (abstract, PCIM)\n   |  |     |\n   |  |     +---SimplePolicyAction (PCIMe)\n
      \  |  |     |   |\n   |  |     |   +---QoSPolicyRSVPSimpleAction (QPIM)\n   |
      \ |     |\n   |  |     +---QoSPolicyDiscardAction (QPIM)\n   |  |     |\n   |
      \ |     +---QoSPolicyAdmissionAction (abstract, QPIM)\n   |  |     |   |\n   |
      \ |     |   +---QoSPolicyPoliceAction (QPIM)\n   |  |     |   |\n   |  |     |
      \  +---QoSPolicyShapeAction (QPIM)\n   |  |     |   |\n   |  |     |   +---QoSPolicyRSVPAdmissionAction
      (QPIM)\n   |  |     |\n   |  |     +---QoSPolicyPHBAction (abstract, QPIM)\n
      \  |  |         |\n   |  |         +---QoSPolicyBandwidthAction (QPIM)\n   |
      \ |         |\n   |  |         +---QoSPolicyCongestionControlAction (QPIM)\n
      \  |  |\n   |  +---QoSPolicyTrfcProf (abstract, QPIM)\n   |  |   |\n   |  |
      \  +---QoSPolicyTokenBucketTrfcProf (QPIM)\n   |  |   |\n   |  |   +---QoSPolicyIntServTrfcProf
      (QPIM)\n   |  |\n   |  |\n   |  +---PolicyVariable (abstract, PCIMe)\n   |  |
      \  |\n   |  |   +---PolicyImplicitVariable (abstract, PCIMe)\n   |  |       |\n
      \  |  |       +---QoSPolicyRSVPVariable (abstract, QPIM)\n   |  |           |\n
      \  |  |           +---QoSPolicyRSVPSourceIPv4Variable (QPIM)\n   |  |           |\n
      \  |  |           +---QoSPolicyRSVPDestinationIPv4Variable (QPIM)\n   |  |           |\n
      \  |  |           +---QoSPolicyRSVPSourceIPv6Variable (QPIM)\n   |  |           |\n"
    - '(continued on the next page)

      '
    - '(continued from the previous page)

      '
    - "[ManagedElement] (abstract, PCIM, repeated for convenience)\n   |\n   +--Policy
      (abstract, PCIM, repeated for convenience)\n   |  |\n   |  +---PolicyVariable
      (abstract, PCIMe)\n   |  |   |\n   |  |   +---PolicyImplicitVariable (abstract,
      PCIMe)\n   |  |       |\n   |  |       +---QoSPolicyRSVPVariable (abstract,
      QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPDestinationIPv6Variable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPSourcePortVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPDestinationPortVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPIPProtocolVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPIPVersionVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPDCLASSVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPStyleVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPDIntServVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPMessageTypeVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPPreemptionPriorityVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPPreemptionDefPriorityVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPUserVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPApplicationVariable
      (QPIM)\n   |  |           |\n   |  |           +---QoSPolicyRSVPAuthMethodVariable
      (QPIM)\n   |  |\n   |  +---PolicyValue (abstract, PCIMe)\n   |  |     |\n   |
      \ |     +---QoSPolicyDNValue (QPIM)\n   |  |     |\n   |  |     +---QoSPolicyAttributeValue
      (QPIM)\n            Figure 2.  The QPIM Class Inheritance Hierarchy\n"
    title: 2.1.  Inheritance Hierarchy
  - contents:
    - "2.2.  Relationship Hierarchy\n   Figure 3 shows the QPIM relationship hierarchy.\n
      \  [unrooted] (abstract, PCIM)\n     |\n     +---Dependency (abstract)\n     |
      \  |\n     |   +--- QoSPolicyTrfcProfInAdmissionAction (QPIM)\n     |   |\n
      \    |   +--- QoSPolicyConformAction (QPIM)\n     |   |\n     |   +--- QoSPolicyExceedAction
      (QPIM)\n     |   |\n     |   +--- QoSPolicyViolateAction (QPIM)\n     |   |\n
      \    |   +--- PolicyVariableInSimplePolicyAction\n     |   |       |\n     |
      \  |       + QoSPolicyRSVPVariableInRSVPSimplePolicyAction\n        Figure 3.
      \ The QPIM Association Class Inheritance Hierarchy\n"
    title: 2.2.  Relationship Hierarchy
  title: 2.  Class Hierarchies
- contents:
  - "3.  QoS Actions\n   This section describes the QoS actions that are modeled by
    QPIM.  QoS\n   actions are policy enforced network behaviors that are specified
    for\n   traffic selected by QoS conditions.  QoS actions are modeled using\n   the
    classes PolicyAction (defined in [PCIM]), SimplePolicyAction\n   (defined in [PCIMe])
    and several QoS actions defined in this document\n   that are derived from both
    of these classes, which are described\n   below.\n   Note that there is no discussion
    of PolicyRule, PolicyGroup, or\n   different types of PolicyCondition classes
    in this document.  This is\n   because these classes are fully specified in [PCIM]
    and [PCIMe].\n"
  - contents:
    - "3.1.  Overview\n   QoS policy based systems allow the network administrator
      to specify a\n   set of rules that control both the selection of the flows that
      need\n   to be provided with a preferred forwarding treatment, as well as\n
      \  specifying the specific set of preferred forwarding behaviors.  QPIM\n   provides
      an information model for specifying such a set of rules.\n   QoS policy rules
      enable controlling environments in which RSVP\n   signaling is used to request
      different forwarding treatment for\n   different traffic types from the network,
      as well as environments\n   where no signaling is used, but preferred treatment
      is desired for\n   some (but not all) traffic types.  QoS policy rules also
      allow\n   controlling environments where strict QoS guarantees are provided
      to\n   individual flows, as well as environments where QoS is provided to\n
      \  flow aggregates.  QoS actions allow a PDP or a PEP to determine which\n   RSVP
      requests should be admitted before network resources are\n   allocated.  QoS
      actions allow control of the RSVP signaling content\n   itself, as well as differentiation
      between priorities of RSVP\n   requests.  QoS actions allow controlling the
      Differentiated Service\n   edge enforcement including policing, shaping and
      marking, as well as\n   the per-hop behaviors used in the network core.  Finally,
      QoS actions\n   can be used to control mapping of RSVP requests at the edge
      of a\n   differentiated service cloud into per hop behaviors.\n   Four groups
      of actions are derived from action classes defined in\n   [PCIM] and [PCIMe].
      \ The first QoS action group contains a single\n   action, QoSPolicyRSVPSimpleAction.
      \ This action is used for both RSVP\n   signal control and install actions.
      \ The second QoS action group\n   determines whether a flow or class of flows
      should be admitted.  This\n   is done by specifying an appropriate traffic profile
      using the\n   QoSPolicyTrfcProf class and its subclasses.  This set of actions
      also\n   includes QoS admission control actions, which use the\n   QoSPolicyAdmissionAction
      class and its subclasses.  The third group\n   of actions control bandwidth
      allocation and congestion control\n   differentiations, which together specify
      the per-hop behavior\n   forwarding treatment.  This group of actions includes
      the\n   QoSPolicyPHBAction class and its subclasses.  The fourth QoS action\n
      \  is an unconditional packet discard action, which uses the\n   QoSPolicyDiscardAction
      class.  This action is used either by itself\n   or as a building block of the
      QoSPolicyPoliceAction.\n   Note that some QoS actions are not directly modeled.
      \ Instead, they\n   are modeled by using the class SimplePolicyAction with the\n
      \  appropriate associations.  For example, the three marking actions\n   (DSCP,
      IPP and CoS) are modeled by using the SimplePolicyAction\n   class, and associating
      that class with variables and values of the\n   appropriate type defined in
      [PCIMe].\n"
    title: 3.1.  Overview
  - contents:
    - "3.2.  RSVP Policy Actions\n   There are three types of decisions a PDP (either
      remote or within a\n   PEP) can make when it evaluates an RSVP request:\n   1.
      \ Admit or reject the request\n   2.  Add or modify the request admission parameters\n
      \  3.  Modify the RSVP signaling content\n   The COPS for RSVP [RFC2749] specification
      uses different Decision\n   object types to model each of these decisions.  QPIM
      follows the COPS\n   for RSVP specification and models each decision using a
      different\n   action class.\n   The QoSPolicyRSVPAdmissionAction controls the
      Decision Command and\n   Decision Flags objects used within COPS for RSVP.  The\n
      \  QoSPolicyRSVPAdmissionAction class, with its associated\n   QoSPolicyIntServTrfcProf
      class, is used to determine whether to\n   accept or reject a given RSVP request
      by comparing the RSVP request's\n   TSPEC or RSPEC parameters against the traffic
      profile specified by\n   the QoSPolicyIntServTrfcProf.  For a full description
      of the\n   comparison method, see section 4.  Following the COPS for RSVP\n
      \  specification, the admission decision has an option to both accept\n   the
      request and send a warning to the requester.  The\n   QoSPolicyRSVPAdmissionAction
      can be used to limit the number of\n   admitted reservations as well.\n   The
      class QoSPolicyRSVPSimpleAction, which is derived from the\n   PolicySimpleAction
      class [PCIMe], can be used to control the two\n   other COPS RSVP decision types.
      \ The property qpRSVPActionType\n   designates the instance of the class to
      be either of type 'REPLACE',\n   'STATELESS', or both ('REPLACEANDSTATELESS').
      \ For instances carrying\n   a qpRSVPActionType property value of 'REPLACE',
      the action is\n   interpreted as a COPS Replace Decision, controlling the contents
      of\n   the RSVP message.  For instances carrying a qpRSVPActionType property\n
      \  value of 'STATELESS', the action is interpreted as a COPS Stateless\n   Decision,
      controlling the admission parameters.  If both of these\n   actions are required,
      this can be done by assigning the value\n   REPLACEANDSTATELESS to the qpRSVPActionType
      property.\n   This class is modeled to represent the COPS for RSVP Replace and\n
      \  Stateless decisions.  This similarity allows future use of these COPS\n   decisions
      to be directly controlled by a QoSPolicySimpleAction.  The\n   only required
      extension might be the definition of a new RSVP\n   variable.\n"
    - contents:
      - "3.2.1.  Example: Controlling COPS Stateless Decision\n   The QoSPolicyRSVPSimpleAction
        allows the specification of admission\n   parameters.  It allows specification
        of the preemption priority\n   [RFC3181] of a given RSVP Reservation request.
        \ Using the preemption\n   priority value, the PEP can determine the importance
        of a Reservation\n   compared with already admitted reservations, and if necessary
        can\n   preempt lower priority reservations to make room for the higher\n
        \  priority one.  This class can also be used to control mapping of RSVP\n
        \  requests to a differentiated services domain by setting the\n   QoSPolicyRSVPDCLASSVariable
        to the required value.  This instructs\n   the PEP to mark traffic matching
        the Session and Sender\n   specifications carried in an RSVP request to a
        given DSCP value.\n"
      title: '3.2.1.  Example: Controlling COPS Stateless Decision'
    - contents:
      - "3.2.2.  Example: Controlling the COPS Replace Decision\n   A Policy system
        should be able to control the information carried in\n   the RSVP messages.
        \ The QoSPolicyRSVPSimpleAction allows control of\n   the content of RSVP
        signaling messages.  An RSVP message can carry a\n   preemption policy object
        [RFC3181] specifying the priority of the\n   reservation request in comparison
        to other requests.  An RSVP message\n   can also carry a policy object for
        authentication purposes.  An RSVP\n   message can carry a DCLASS [DCLASS]
        object that specifies to the\n   receiver or sender the particular DSCP value
        that should be set on\n   the data traffic.  A COPS for RSVP Replacement Data
        Decision controls\n   the content of the RSVP message by specifying a set
        of RSVP objects\n   replacing or removing the existing ones.\n"
      title: '3.2.2.  Example: Controlling the COPS Replace Decision'
    title: 3.2.  RSVP Policy Actions
  - contents:
    - "3.3.  Provisioning Policy Actions\n   The differentiated Service Architecture
      [DIFFSERV] was designed to\n   provide a scalable QoS differentiation without
      requiring any\n   signaling protocols running between the hosts and the network.
      \ The\n   QoS actions modeled in QPIM can be used to control all of the\n   building
      blocks of the Differentiated Service architecture, including\n   per-hop behaviors,
      edge classification, and policing and shaping,\n   without a need to specify
      the datapath mechanisms used by PEP\n   implementations.  This provides an abstraction
      level hiding the\n   unnecessary details and allowing the network administrator
      to write\n   rules that express the network requirements in a more natural form.\n
      \  In this architecture, as no signaling between the end host and the\n   network
      occurs before the sender starts sending information, the QoS\n   mechanisms
      should be set up in advance.  This usually means that PEPs\n   need to be provisioned
      with the set of policy rules in advance.\n   Policing and Shaping actions are
      modeled as subclasses of the QoS\n   admission action.  DSCP and CoS marking
      are modeled by using the\n   SimplePolicyAction ([PCIMe]) class associated with
      the appropriate\n   variables and values.  Bandwidth allocation and congestion
      control\n   actions are modeled as subclasses of the QpQPolicyPHBAction, which
      is\n   itself a subclass PolicyAction class ([PCIM])\n"
    - contents:
      - "3.3.1.  Admission Actions: Controlling Policers and Shapers\n   Admission
        Actions (QoSPolicyAdmissionAction and its subclasses) are\n   used to police
        and/or shape traffic.\n   Each Admission Action is bound to a traffic profile\n
        \  (QoSPolicyTrfcProf) via the QoSPolicyTrfcProfInAdmissionAction\n   association.
        \ The traffic profile is used to meter traffic for\n   purposes of policing
        or shaping.\n   An Admission Action carries a scope property (qpAdmissionScope)
        that\n   is used to determine whether the action controls individual traffic\n
        \  flows or aggregate traffic classes.  The concepts of \"flow\" and\n   \"traffic
        class\" are explained in [DIFFSERV] using the terms\n   'microflow' and 'traffic
        stream'.  Roughly speaking, a flow is a set\n   of packets carrying an IP
        header that has the same values for source\n   IP, destination IP, protocol
        and layer 4 source and destination\n   ports.  A traffic class is a set of
        flows.  In QPIM, simple and\n   compound conditions can identify flows and/or
        traffic classes by\n   using Boolean terms over the values of IP header fields,
        including\n   the value of the ToS byte.\n   Thus, the interpretation of the
        scope property is as follows: If the\n   value of the scope property is 0
        (per-flow), each (micro) flow that\n   can be positively matched with the
        rule's condition is metered and\n   policed individually.  If the value of
        the scope property is 1 (per-\n   class), all flows matched with the rule's
        condition are metered as a\n   single aggregate and policed together.\n   The
        following example illustrates the use of the scope property.\n   Using two
        provisioned policing actions, the following policies can be\n   enforced:\n
        \  -  Make sure that each HTTP flow will not exceed 64kb/s\n   -  Make sure
        that the aggregate rate of all HTTP flows will not\n      exceed 512Kb/s\n
        \  Both policies are modeled using the same class QoSPolicyPoliceAction\n
        \  (derived from QoSPolicyAdmissionAction).  The first policy has its\n   scope
        property set to 'flow', while the second policy has its scope\n   property
        set to 'class'.  The two policies are modeled using a rule\n   with two police
        actions that, in a pseudo-formal definition, looks\n   like the following:\n
        \     If (HTTP) Action1=police, Traffic Profile1=64kb/s, Scope1=flow\n                Action2=police,
        Traffic Profile2=512kb/s, Scope2=class\n   The provisioned policing action
        QoSPolicyPoliceAction has three\n   associations, QoSPolicyConformAction,
        QoSPolicyExceedAction and\n   QoSPolicyViolateAction.\n   To accomplish the
        desired result stated above, two possible modeling\n   techniques may be used:
        The two actions can be part of a single\n   policy rule using two PolicyActionInPolicyRule
        [PCIM] associations.\n   In this case the ExecutionStrategy property of the
        PolicyRule class\n   [PCIMe] SHOULD be set to \"Do All\" so that both individual
        flows and\n   aggregate streams are policed.\n   Alternatively, Action1 and
        Action2 could be aggregated in a\n   CompundPolicyAction instance using the
        PolicyActionInPolicyAction\n   aggregations [PCIMe].  In this case, in order
        for both individual\n   flows and aggregate traffic classes to be policed,
        the\n   ExecutionStrategy property of the CompoundPolicyAction class [PCIMe]\n
        \  SHOULD be set to \"Do All\".\n   The policing action is associated with
        a three-level token bucket\n   traffic profile carrying rate, burst and excess-burst
        parameters.\n   Traffic measured by a meter can be classified as conforming
        traffic\n   when the metered rate is below the rate defined by the traffic\n
        \  profile, as excess traffic when the metered traffic is above the\n   normal
        burst and below the excess burst size, and violating traffic\n   when rate
        is above the maximum excess burst.\n   The [DIFF-MIB] defines a two-level
        meter, and provides a means to\n   combine two-level meters into more complex
        meters.  In this document,\n   a three-level traffic profile is defined.  This
        allows construction\n   of both two-level meters as well as providing an easier
        definition\n   for three-level meters needed for creating AF [AF] provisioning\n
        \  actions.\n   A policing action that models three-level policing MUST associate\n
        \  three separate actions with a three-level traffic profile.  These\n   actions
        are a conforming action, an exceeding action and a violating\n   action.  A
        policing action that models two-level policing uses a\n   two-level traffic
        profile and associates only conforming and\n   exceeding actions.  A policing
        action with a three-level traffic\n   profile that specifies an exceed action
        but does not specify a\n   violate action implies that the action taken when
        the traffic is\n   above the maximum excess burst is identical to the action
        taken when\n   the traffic is above the normal burst.  A policer determines
        whether\n   the profile is being met, while the actions to be performed are\n
        \  determined by the associations QoSPolicyXXXAction.\n   Shapers are used
        to delay some or all of the packets in a traffic\n   stream, in order to bring
        the stream into compliance with a traffic\n   profile.  A shaper usually has
        a finite-sized buffer, and packets may\n   be discarded if there is not sufficient
        buffer space to hold the\n   delayed packets.  Shaping is controlled by the
        QoSPolicyShapeAction\n   class.  The only required association is a traffic
        profile that\n   specifies the rate and burst parameters that the outgoing
        flows\n   should conform with.\n"
      title: '3.3.1.  Admission Actions: Controlling Policers and Shapers'
    - contents:
      - "3.3.2.  Controlling Markers\n   Three types of marking control actions are
        modeled in QPIM:\n   Differentiated Services Code Point (DSCP) assignment,
        IP Precedence\n   (IPP) assignment and layer-2 Class of Service (CoS) assignment.\n
        \  These assignment actions themselves are modeled by using the\n   SimplePolicyAction
        class associated with the appropriate variables\n   and values.\n   DSCP assignment
        sets (\"marks\" or \"colors\") the DS field of a packet\n   header to a particular
        DS Code Point (DSCP), adding the marked packet\n   to a particular DS behavior
        aggregate.\n   When used in the basic form, \"If <condition> then 'DCSP =
        ds1'\", the\n   assignment action assigns a DSCP value (ds1) to all packets
        that\n   result in the condition being evaluated to true.\n   When used in
        combination with a policing action, a different\n   assignment action can
        be issued via each of the 'conform', 'exceed'\n   and 'violate' action associations.
        \ This way, one may select a PHB in\n   a PHB group according to the state
        of a meter.\n   The semantics of the DSCP assignment is encapsulated in the
        pairing\n   of a DSCP variable and a DSCP value within a single\n   SimplePolicyAction
        instance via the appropriate associations.\n   IPP assignment sets the IPP
        field of a packet header to a particular\n   IPP value (0 through 7).  The
        semantics of the IPP assignment is\n   encapsulated in the pairing of a ToS
        variable (PolicyIPTosVariable)\n   and a bit string value () (defined in [PCIMe])
        within a single\n   SimplePolicyAction instance via the appropriate associations.
        \ The\n   bit string value is used in its masked bit string format.  The mask\n
        \  indicates the relevant 3 bits of the IPP sub field within the ToS\n   byte,
        while the bit string indicates the IPP value to be set.\n   CoS assignments
        control the mapping of a per-hop behavior to a\n   layer-2 Class of Service.
        \ For example, mapping of a set of DSCP\n   values into a 802.1p user priority
        value can be specified using a\n   rule with a condition describing the set
        of DSCP values, and a CoS\n   assignment action that specifies the required
        mapping to the given\n   user priority value. The semantics of the CoS assignment
        is\n   encapsulated in the pairing of a CoS variable and a CoS value\n   (integer
        in the range of 0 through 7) within a single\n   SimplePolicyAction instance
        via the appropriate associations.\n"
      title: 3.3.2.  Controlling Markers
    - contents:
      - "3.3.3.  Controlling Edge Policies - Examples\n   Assuming that the AF1 behavior
        aggregate is enforced within a DS\n   domain, policy rules on the boundaries
        of the network should mark\n   packets to one of the AF1x DSCPs, depending
        on the conformance of the\n   traffic to a predetermined three-parameter traffic
        profile.  QPIM\n   models such AF1 policing action as defined in Figure 4.\n
        \    +-----------------------+    +------------------------------+\n     |
        QoSPolicyPoliceAction |====| QoSPolicyTokenBucketTrfcProf |\n     | scope
        = class         |    | rate = x, bc = y, be = z     |\n     +-----------------------+
        \   +------------------------------+\n       *     @     #\n       *     @
        \    #\n       *     @  +--------------------+   +--------------------------+\n
        \      *     @  | SimplePolicyAction |---| PolicyIntegerValue -AF13 |\n       *
        \    @  +--------------------+   +--------------------------+\n       *     @\n
        \      *  +--------------------+   +---------------------------+\n       *
        \ | SimplePolicyAction |---| PolicyIntegerValue - AF12 |\n       *  +--------------------+
        \  +---------------------------+\n       *\n     +--------------------+   +---------------------------+\n
        \    | SimplePolicyAction |---| PolicyIntegerValue - AF11 |\n     +--------------------+
        \  +---------------------------+\n   Association and Aggregation Legend:\n
        \    ****  QoSPolicyConformAction\n     @@@@  QoSPolicyExceedAction\n     ####
        \ QoSPolicyViolateAction\n     ====  QoSTrfcProfInAdmissionAction\n     ----
        \ PolicyValueInSimplePolicyAction ([PCIMe])\n     &&&&  PolicyVariableInSimplePolicyAction
        ([PCIMe], not shown)\n                   Figure 4.    AF Policing and Marking\n
        \  The AF policing action is composed of a police action, a token bucket\n
        \  traffic profile and three instances of the SimplePolicyAction class.\n
        \  Each of the simple policy action instances models a different marking\n
        \  action.  Each SimplePolicyAction uses the aggregation\n   PolicyVariableInSimplePolicyAction
        to specify that the associated\n   PolicyDSCPVariable is set to the appropriate
        integer value.  This is\n   done using the PolicyValueInSimplePolicyAction
        aggregation.  The\n   three PolicyVariableInSimplePolicyAction aggregations
        which connect\n   the appropriate SimplePolicyActions with the appropriate
        DSCP\n   Variables, are not shown in this figure for simplicity.  AF11 is\n
        \  marked on detecting conforming traffic; AF12 is marked on detecting\n   exceeding
        traffic, and AF13 on detecting violating traffic.\n   The second example,
        shown in Figure 5, is the simplest policing\n   action.  Traffic below a two-parameter
        traffic profile is unmodified,\n   while traffic exceeding the traffic profile
        is discarded.\n     +-----------------------+    +------------------------------+\n
        \    | QoSPolicyPoliceAction |====| QoSPolicyTokenBucketTrfcProf |\n     |
        scope = class         |    | rate = x, bc = y             |\n     +-----------------------+
        \   +------------------------------+\n            @\n            @\n         +-------------------------+\n
        \        | QoSPolicyDiscardAction  |\n         +-------------------------+\n
        \  Association and Aggregation Legend:\n     ****  QoSPolicyConformAction
        (not used)\n     @@@@  QoSPolicyExceedAction\n     ####  QoSPolicyViolateAction
        (not used)\n     ====  QoSTrfcProfInAdmissionAction\n   Figure 5.    A Simple
        Policing Action\n"
      title: 3.3.3.  Controlling Edge Policies - Examples
    title: 3.3.  Provisioning Policy Actions
  - contents:
    - "3.4.  Per-Hop Behavior Actions\n   A Per-Hop Behavior (PHB) is a description
      of the externally\n   observable forwarding behavior of a DS node applied to
      a particular\n   DS behavior aggregate [DIFFSERV].  The approach taken here
      is that a\n   PHB action specifies both observable forwarding behavior (e.g.,
      loss,\n   delay, jitter) as well as specifying the buffer and bandwidth\n   resources
      that need to be allocated to each of the behavior\n   aggregates in order to
      achieve this behavior.  That is, a rule with a\n   set of PHB actions can specify
      that an EF packet must not be delayed\n   more than 20 msec in each hop.  The
      same rule may also specify that\n   EF packets need to be treated with preemptive
      forwarding (e.g., with\n   priority queuing), and specify the maximum bandwidth
      for this class,\n   as well as the maximum buffer resources.  PHB actions can
      therefore\n   be used both to represent the final requirements from PHBs and
      to\n   provide enough detail to be able to map the PHB actions into a set of\n
      \  configuration parameters to configure queues, schedulers, droppers\n   and
      other mechanisms.\n   The QoSPolicyPHBAction abstract class has two subclasses.
      \ The\n   QoSPolicyBandwidthAction class is used to control bandwidth, delay\n
      \  and forwarding behavior, while the QoSPolicyCongestionControlAction\n   class
      is used to control queue size, thresholds and congestion\n   algorithms.  The
      qpMaxPacketSize property of the QoSPolicyPHBAction\n   class specifies the packet
      size in bytes, and is needed when\n   translating the bandwidth and congestion
      control actions into actual\n   implementation configurations. For example,
      an implementation\n   measuring queue length in bytes will need to use this
      property to map\n   the qpQueueSize property into the desired queue length in
      bytes.\n"
    - contents:
      - "3.4.1.  Controlling Bandwidth and Delay\n   QoSPolicyBandwidthAction allows
        specifying the minimal bandwidth that\n   should be reserved for a class of
        traffic.  The property\n   qpMinBandwidth can be specified either in Kb/sec
        or as a percentage\n   of the total available bandwidth.  The property qpBandwidthUnits
        is\n   used to determine whether percentages or fixed values are used.\n   The
        property qpForwardingPriority is used whenever preemptive\n   forwarding is
        required.  A policy rule that defines the EF PHB should\n   indicate a non-zero
        forwarding priority.  The qpForwardingPriority\n   property holds an integer
        value to enable multiple levels of\n   preemptive forwarding where higher
        values are used to specify higher\n   priority.\n   The property qpMaxBandwidth
        specifies the maximum bandwidth that\n   should be allocated to a class of
        traffic.  This property may be\n   specified in PHB actions with non-zero
        forwarding priority in order\n   to guard against starvation of other PHBs.\n
        \  The properties qpMaxDelay and qpMaxJitter specify limits on the per-\n
        \  hop delay and jitter in milliseconds for any given packet within a\n   traffic
        class.  Enforcement of the maximum delay and jitter may\n   require use of
        preemptive forwarding as well as minimum and maximum\n   bandwidth controls.
        \ Enforcement of low max delay and jitter values\n   may also require fragmentation
        and interleave mechanisms over low\n   speed links.\n   The Boolean property
        qpFairness indicates whether flows should have a\n   fair chance to be forwarded
        without drop or delay.  A way to enforce\n   a bandwidth action with qpFairness
        set to TRUE would be to build a\n   queue per flow for the class of traffic
        specified in the rule's\n   filter.  In this way, interactive flows like terminal
        access will not\n   be queued behind a bursty flow (like FTP) and therefore
        have a\n   reasonable response time.\n"
      title: 3.4.1.  Controlling Bandwidth and Delay
    - contents:
      - "3.4.2.  Congestion Control Actions\n   The QoSPolicyCongestionControlAction
        class controls queue length,\n   thresholds and congestion control algorithms.\n
        \  A PEP should be able to keep in its queues qpQueueSize packets\n   matching
        the rule's condition.  In order to provide a link-speed\n   independent queue
        size, the qpQueueSize property can also be measured\n   in milliseconds.  The
        time interval specifies the time needed to\n   transmit all packets within
        the queue if the link speed is dedicated\n   entirely for transmission of
        packets within this queue.  The property\n   qpQueueSizeUnit determines whether
        queue size is measured in number\n   of packets or in milliseconds.  The property
        qpDropMethod selects\n   either tail-drop, head-drop or random-drop algorithms.
        \ The set of\n   maximum and minimum threshold values can be specified as
        well, using\n   qpDropMinThresholdValue and qpDropMaxThresholdValue properties,\n
        \  either in packets or in percentage of the total available queue size\n
        \  as specified by the qpDropThresholdUnits property.\n"
      title: 3.4.2.  Congestion Control Actions
    - contents:
      - "3.4.3.  Using Hierarchical Policies: Examples for PHB Actions\n   Hierarchical
        policy definition is a primary tool in the QoS Policy\n   information model.
        \ Rule nesting introduced in [PCIMe] allows\n   specification of hierarchical
        policies controlling RSVP requests,\n   hierarchical shaping, policing and
        marking actions, as well as\n   hierarchical schedulers and definition of
        the differences in PHB\n   groups.\n   This example provides a set of rules
        that specify PHBs enforced\n   within a Differentiated Service domain.  The
        network administrator\n   chose to enforce the EF, AF11 and AF13 and Best
        Effort PHBs.  For\n   simplicity, AF12 is not differentiated.  The set of
        rules takes the\n   form:\n      If (EF) then do EF actions\n      If (AF1)
        then do AF1 actions\n          If (AF11) then do AF11 actions\n          If
        (AF12) then do AF12 actions\n          If (AF13) then do AF13 actions\n      If
        (default) then do Default actions.\n   EF, AF1, AF11, AF12 and AF13 are conditions
        that filter traffic\n   according to DSCP values.  The AF1 condition matches
        the entire AF1\n   PHB group including the AF11, AF12 and AF13 DSCP values.
        \ The default\n   rule specifies the Best Effort rules.  The nesting of the
        AF1x rules\n   within the AF1 rule specifies that there are further refinements
        on\n   how AF1x traffic should be treated relative to the entire AF1 PHB\n
        \  group.  The set of rules reside in a PolicyGroup with a decision\n   strategy
        property set to 'FirstMatching'.\n   The class instances below specify the
        set of actions used to describe\n   each of the PHBs.  Queue sizes are not
        specified, but can easily be\n   added to the example.\n   The actions used
        to describe the Best Effort PHB are simple.  No\n   bandwidth is allocated
        to Best Effort traffic.  The first action\n   specifies that Best Effort traffic
        class should have fairness.\n   QoSPolicyBandwidthAction  BE-B:\n     qpFairness:
        TRUE\n   The second action specifies that the congestion algorithm for the\n
        \  Best Effort traffic class should be random, and specifies the\n   thresholds
        in percentage of the default queue size.\n   QoSPolicyCongestionControlAction
        \ BE-C:\n     qpDropMethod: random\n     qpDropThresholdUnits %\n     qpDropMinThreshold:
        \ 10%\n     qpDropMaxThreshold:  70%\n   EF requires preemptive forwarding.
        \ The maximum bandwidth is also\n   specified to make sure that the EF class
        does not starve the other\n   classes.  EF PHB uses tail drop as the applications
        using EF are\n   supposed to be UDP-based and therefore would not benefit
        from a\n   random dropper.\n   QoSPolicyBandwidthAction  EF-B:\n     qpForwardingPriority:
        1\n     qpBandwidthUnits: %\n     qpMaxBandwidth  50%\n     qpFairness: FALSE\n
        \  QoSPolicyCongestionControlAction  EF-C:\n     qpDropMethod: tail-drop\n
        \    qpDropThresholdUnits packet\n     qpDropMaxThreshold:  3 packets\n   The
        AF1 actions define the bandwidth allocations for the entire PHB\n   group:\n
        \  QoSPolicyBandwidthAction  AF1-B:\n     qpBandwidthUnits: %\n     qpMinBandwidth:
        30%\n   The AF1i actions specifies the differentiating refinement for the\n
        \  AF1x PHBs within the AF1 PHB group.  The different threshold values\n   provide
        the difference in discard probability of the AF1x PHBs within\n   the AF1
        PHB group.\n   QoSPolicyCongestionControlAction  AF11-C:\n     qpDropMethod:
        random\n     qpDropThresholdUnits packet\n     qpDropMinThreshold:  6 packets\n
        \    qpDropMaxThreshold:  16 packets\n   QoSPolicyCongestionControlAction
        \ AF12-C:\n     qpDropMethod: random\n     qpDropThresholdUnits packet\n     qpDropMinThreshold:
        \ 4 packets\n     qpDropMaxThreshold:  13 packets\n   QoSPolicyCongestionControlAction
        \ AF13-C:\n     qpDropMethod: random\n     qpDropThresholdUnits packet\n     qpDropMinThreshold:
        \ 2 packets\n     qpDropMaxThreshold:  10 packets\n"
      title: '3.4.3.  Using Hierarchical Policies: Examples for PHB Actions'
    title: 3.4.  Per-Hop Behavior Actions
  title: 3.  QoS Actions
- contents:
  - "4.  Traffic Profiles\n   Meters measure the temporal state of a flow or a set
    of flows against\n   a traffic profile.  In this document, traffic profiles are
    modeled by\n   the QoSPolicyTrfcProf class.  The association QoSPolicyTrfcProf\n
    \  InAdmissionAction binds the traffic profile to the admission action\n   using
    it.  Two traffic profiles are derived from the abstract class\n   QoSPolicyTrfcProf.
    \ The first is a Token Bucket provisioning traffic\n   profile carrying rate and
    burst parameters.  The second is an RSVP\n   traffic profile, which enables flows
    to be compared with RSVP TSPEC\n   and FLOWSPEC parameters.\n"
  - contents:
    - "4.1.  Provisioning Traffic Profiles\n   Provisioned Admission Actions, including
      shaping and policing, are\n   specified using a two- or three-parameter token
      bucket traffic\n   profile.  The QoSPolicyTokenBucketTrfcProf class includes
      the\n   following properties:\n   1.  Rate measured in kbits/sec\n   2.  Normal
      burst measured in bytes\n   3.  Excess burst measured in bytes\n   Rate determines
      the long-term average transmission rate.  Traffic\n   that falls under this
      rate is conforming, as long as the normal burst\n   is not exceeded at any time.
      \ Traffic exceeding the normal burst but\n   still below the excess burst is
      exceeding the traffic profile.\n   Traffic beyond the excess burst is said to
      be violating the traffic\n   profile.\n   Excess burst size is measured in bytes
      in addition to the burst size.\n   A zero excess burst size indicates that no
      excess burst is allowed.\n"
    title: 4.1.  Provisioning Traffic Profiles
  - contents:
    - "4.2.  RSVP traffic profiles\n   RSVP admission policy can condition the decision
      whether to accept or\n   deny an RSVP request based on the traffic specification
      of the flow\n   (TSPEC) or the amount of QoS resources requested (FLOWSPEC).
      \ The\n   admission decision can be based on matching individual RSVP requests\n
      \  against a traffic profile or by matching the aggregated sum of all\n   FLOWSPECs
      (TSPECs) currently admitted, as determined by the\n   qpAdmissionScope property
      in an associated\n   QoSPolicyRSVPAdmissionAction.\n   The QoSPolicyIntservTrfcProf
      class models both such traffic profiles.\n   This class has the following properties:\n
      \     1.  Token Rate (r) measured in bits/sec\n      2.  Peak Rate (p) measured
      in bits/sec\n      3.  Bucket Size (b) measured in bytes\n      4.  Min Policed
      unit (m) measured in bytes\n      5.  Max packet size (M) measured in bytes\n
      \     6.  Resv Rate (R) measured in bits/sec\n      7.  Slack term (s) measured
      in microseconds\n   The first five parameters are the traffic specification
      parameters\n   used in the Integrated Service architecture ([INTSERV]).  These\n
      \  parameters are used to define a sender TSPEC as well as a FLOWSPEC\n   for
      the Controlled-Load service [CL].  For a definition and full\n   explanation
      of their meanings, please refer to [RSVP-IS].\n   Parameters 6 and 7 are the
      additional parameters used for\n   specification of the Guaranteed Service FLOWSPEC
      [GS].\n   A partial order is defined between TSPECs (and FLOWSPECs).  The TSPEC\n
      \  A is larger than the TSPEC B if and only if rA>rB, pA>pB, bA>bB,\n   mA<mB
      and MA>MB.  A TSPEC (FLOWSPEC) measured against a traffic\n   profile uses the
      same ordering rule.  An RSVP message is accepted\n   only if its TSPEC (FLOWSPEC)
      is either smaller or equal to the\n   traffic profile.  Only parameters specified
      in the traffic profile\n   are compared.\n   The GS FLOWSPEC is compared against
      the rate R and the slack term s.\n   The term R should not be larger than the
      traffic profile R parameter,\n   while the FLOWSPEC slack term should not be
      smaller than that\n   specified in the slack term.\n   TSPECs as well as FLOWSPECs
      can be added.  The sum of two TSPECs is\n   computed by summing the rate r,
      the peak rate p, the bucket size b,\n   and by taking the minimum value of the
      minimum policed unit m and the\n   maximum value of the maximum packet size
      M.  GS FLOWSPECs are summed\n   by adding the Resv rate and minimizing the slack
      term s.  These rules\n   are used to compute the temporal state of admitted
      RSVP states\n   matching the traffic class defined by the rule condition.  This
      state\n   is compared with the traffic profile to arrive at an admission\n   decision
      when the scope of the QoSPolicyRSVPAdmissionAction is set to\n   'class'.\n"
    title: 4.2.  RSVP traffic profiles
  title: 4.  Traffic Profiles
- contents:
  - "5.  Pre-Defined QoS-Related Variables\n   Pre-defined variables are necessary
    for ensuring interoperability\n   among policy servers and policy management tools
    from different\n   vendors.  The purpose of this section is to define frequently
    used\n   variables in QoS policy domains.\n   Notice that this section only adds
    to the variable classes as defined\n   in [PCIMe] and reuses the mechanism defined
    there.\n   The QoS policy information model specifies a set of pre-defined\n   variable
    classes to support a set of fundamental QoS terms that are\n   commonly used to
    form conditions and actions and are missing from the\n   [PCIMe]. Examples of
    these include RSVP related variables.  All\n   variable classes defined in this
    document extend the\n   QoSPolicyRSVPVariable class (defined in this document),
    which itself\n   extends the PolicyImplictVariable class, defined in [PCIMe].\n
    \  Subclasses specify the data type and semantics of the policy\n   variables.\n
    \  This document defines the following RSVP variable classes; for\n   details,
    see their class definitions:\n   RSVP related Variables:\n   1.   QoSPolicyRSVPSourceIPv4Variable
    - The source IPv4 address of the\n        RSVP signaled flow, as defined in the
    RSVP PATH SENDER_TEMPLATE\n        and RSVP RESV FILTER_SPEC [RSVP] objects.\n
    \  2.   QoSPolicyRSVPDestinationIPv4Variable - The destination port of\n        the
    RSVP signaled flow, as defined in the RSVP PATH and RESV\n        SESSION [RSVP]
    objects (for IPv4 traffic).\n   3.   QoSPolicyRSVPSourceIPv6Variable - The source
    IPv6 address of the\n        RSVP signaled flow, as defied in the RSVP PATH SENDER_TEMPLATE\n
    \       and RSVP RESV FILTER_SPEC [RSVP] objects.\n   4.   QoSPolicyRSVPDestinationIPv6Variable
    - The destination port of\n        the RSVP signaled flow, as defined in the RSVP
    PATH and RESV\n        SESSION [RSVP] objects (for IPv6 traffic).\n   5.   QoSPolicyRSVPSourcePortVariable
    - The source port of the RSVP\n        signaled flow, as defined in the RSVP PATH
    SENDER_TEMPLATE and\n        RSVP RESV FILTER_SPEC [RSVP] objects.\n   6.   QoSPolicyRSVPDestinationPortVariable
    - The destination port of\n        the RSVP signaled flow, as defined in the RSVP
    PATH and RESV\n        SESSION [RSVP] objects.\n   7.   QoSPolicyRSVPIPProtocolVariable
    - The IP Protocol of the RSVP\n        signaled flow, as defined in the RSVP PATH
    and RESV SESSION\n        [RSVP] objects.\n   8.   QoSPolicyRSVPIPVersionVariable
    - The version of the IP addresses\n        carrying the RSVP signaled flow, as
    defined in the RSVP PATH and\n        RESV SESSION [RSVP] objects.\n   9.   QoSPolicyRSVPDCLASSVariable
    - The DSCP value as defined in the\n        RSVP DCLASS [DCLASS] object.\n   10.
    \ QoSPolicyRSVPStyleVariable - The reservation style (FF, SE, WF)\n        as
    defined in the RSVP RESV message [RSVP].\n   11.  QoSPolicyRSVPIntServVariable
    - The type of Integrated Service\n        (CL, GS, NULL) requested in the RSVP
    Reservation message, as\n        defined in the FLOWSPEC RSVP Object [RSVP].\n
    \  12.  QoSPolicyRSVPMessageTypeVariable - The RSVP message type, either\n        PATH,
    PATHTEAR, RESV, RESVTEAR, RESVERR, CONF or PATHERR [RSVP].\n   13.  QoSPolicyRSVPPreemptionPriorityVariable
    - The RSVP reservation\n        priority as defined in [RFC3181].\n   14.  QoSPolicyRSVPPreemptionDefPriorityVariable
    - The RSVP preemption\n        reservation defending priority as defined in [RFC3181].\n
    \  15.  QoSPolicyRSVPUserVariable - The ID of the user that initiated\n        the
    flow as defined in the User Locator string in the Identity\n        Policy Object
    [RFC3182].\n   16.  QoSPolicyRSVPApplicationVariable - The ID of the application\n
    \       that generated the flow as defined in the application locator\n        string
    in the Application policy object [RFC2872].\n   17.  QoSPolicyRSVPAuthMethodVariable
    - The RSVP Authentication type\n        used in the Identity Policy Object [RFC3182].\n
    \  Each class restricts the possible value types associated with a\n   specific
    variable.  For example, the QoSPolicyRSVPSourcePortVariable\n   class is used
    to define the source port of the RSVP signaled flow.\n   The value associated
    with this variable is of type\n   PolicyIntegerValue.\n"
  title: 5.  Pre-Defined QoS-Related Variables
- contents:
  - "6.  QoS Related Values\n   Values are used in the information model as building
    blocks for the\n   policy conditions and policy actions, as described in [PCIM]
    and\n   [PCIMe].  This section defines a set of auxiliary values that are\n   used
    for QoS policies as well as other policy domains.\n   All value classes extend
    the PolicyValue class [PCIMe].  The\n   subclasses specify specific data/value
    types that are not defined in\n   [PCIMe].\n   This document defines the following
    two subclasses of the PolicyValue\n   class:\n   QoSPolicyDNValue          This
    class is used to represent a single or\n                             set of Distinguished
    Name [DNDEF] values,\n                             including wildcards.  A Distinguished
    Name\n                             is a name that can be used as a key to\n                             retrieve
    an object from a directory\n                             service.  This value
    can be used in\n                             comparison to reference values carried
    in\n                             RSVP policy objects, as specified in\n                             [RFC3182].
    \ This class is defined in\n                             Section 8.31.\n   QoSPolicyAttributeValue
    \  A condition term uses the form \"Variable\n                             matches
    Value\", and an action term uses the\n                             form \"set
    Variable to Value\" ([PCIMe]).\n                             This class is used
    to represent a single or\n                             set of property values
    for the \"Value\" term\n                             in either a condition or
    an action. This\n                             value can be used in conjunction
    with\n                             reference values carried in RSVP objects,\n
    \                            as specified in [RFC3182].  This class is\n                             defined
    in section 8.12.\n   The property name is used to specify which of the properties
    in the\n   QoSPolicyAttributeValue class instance is being used in the condition\n
    \  or action term.  The value of this property or properties will then\n   be
    retrieved.  In the case of a condition, a match (which is\n   dependent on the
    property name) will be used to see if the condition\n   is satisfied or not.  In
    the case of an action, the semantics are\n   instead \"set the variable to this
    value\".\n   For example, suppose the \"user\" objects in the organization include\n
    \  several properties, among them:\n      - First Name\n      - Last Name\n      -
    Login Name\n      - Department\n      - Title\n   A simple condition could be
    constructed to identify flows by their\n   RSVP user carried policy object.  The
    simple condition: Last Name =\n   \"Smith\" to identify a user named Bill would
    be constructed in the\n   following way:\n      A SimplePolicyCondition [PCIMe]
    would aggregate a\n      QoSPolicyRSVPUserVariable [QPIM] object, via the\n      PolicyVariableInSimplePolicyCondition
    [PCIMe] aggregation.\n   The implicit value associated with this condition is
    created in the\n   following way:\n      A QoSPolicyAttributeValue object would
    be aggregated to the simple\n      condition object via a PolicyValueInSimplePolicyCondition
    [PCIMe].\n      The QoSPolicyAttributeValue attribute qpAttributeName would be
    set\n      to \"last name\" and the qpAttributeValueList would be set to\n      \"Smith\".\n
    \  Another example is a condition that has to do with the user's\n   organizational
    department.  It can be constructed in the exact same\n   way, by changing the
    QoSPolicyAttributeValue attribute\n   qpAttributeName to \"Department\" and the
    qpAttributeValueList would be\n   set to the particular value that is to be matched
    (e.g.,\n   \"engineering\" or \"customer support\").  The logical condition would\n
    \  than be evaluated to true if the user belong to either the\n   engineering
    department or the customer support.\n   Notice that many multiple-attribute objects
    require the use of the\n   QoSPolicyAttributeValue class to specify exactly which
    of its\n   attributes should be used in the condition match operation.\n"
  title: 6.  QoS Related Values
- contents:
  - "7.  Class Definitions: Association Hierarchy\n   The following sections define
    associations that are specified by\n   QPIM.\n"
  - contents:
    - "7.1.  The Association \"QoSPolicyTrfcProfInAdmissionAction\"\n   This association
      links a QoSPolicyTrfcProf object (defined in section\n   8.9), modeling a specific
      traffic profile, to a\n   QoSPolicyAdmissionAction object (defined in section
      8.2).  The class\n   definition for this association is as follows:\n   NAME
      \             QoSPolicyTrfcProfInAdmissionAction\n   DESCRIPTION       A class
      representing the association between a\n                     QoS admission action
      and its traffic profile.\n   DERIVED FROM      Dependency (See [PCIM])\n   ABSTRACT
      \         FALSE\n   PROPERTIES        Antecedent[ref QoSPolicyAdmissionAction
      [0..n]]\n                     Dependent[ref QoSPolicyTrfcProf [1..1]]\n"
    - contents:
      - "7.1.1.  The Reference \"Antecedent\"\n   This property is inherited from
        the Dependency association, defined\n   in [PCIM].  Its type is overridden
        to become an object reference to a\n   QoSPolicyAdmissionAction object.  This
        represents the \"independent\"\n   part of the association.  The [0..n] cardinality
        indicates that any\n   number of QoSPolicyAdmissionAction object(s) may use
        a given\n   QoSPolicyTrfcProf.\n"
      title: 7.1.1.  The Reference "Antecedent"
    - contents:
      - "7.1.2.  The Reference \"Dependent\"\n   This property is inherited from the
        Dependency association, and is\n   overridden to become an object reference
        to a QoSPolicyTrfcProf\n   object.  This represents a specific traffic profile
        that is used by\n   any number of QoSPolicyAdmissionAction objects.  The [1..1]\n
        \  cardinality means that exactly one object of the QoSPolicyTrfcProf\n   can
        be used by a given QoSPolicyAddmissionAction.\n"
      title: 7.1.2.  The Reference "Dependent"
    title: 7.1.  The Association "QoSPolicyTrfcProfInAdmissionAction"
  - contents:
    - "7.2.  The Association \"PolicyConformAction\"\n   This association links a
      policing action with an object defining an\n   action to be applied to conforming
      traffic relative to the associated\n   traffic profile.  The class definition
      for this association is as\n   follows:\n   NAME              PolicyConformAction\n
      \  DESCRIPTION       A class representing the association between a\n                     policing
      action and the action that should be\n                     applied to traffic
      conforming to an associated\n                     traffic profile.\n   DERIVED
      FROM      Dependency (see [PCIM])\n   ABSTRACT          FALSE\n   PROPERTIES
      \       Antecedent[ref QoSPolicyPoliceAction[0..n]]\n                     Dependent[ref
      PolicyAction [1..1]]\n"
    - contents:
      - "7.2.1.  The Reference \"Antecedent\"\n   This property is inherited from
        the Dependency association.  Its type\n   is overridden to become an object
        reference to a\n   QoSPolicyPoliceAction object.  This represents the \"independent\"
        part\n   of the association.  The [0..n] cardinality indicates that any number\n
        \  of QoSPolicyPoliceAction objects may be given the same action to be\n   executed
        as the conforming action.\n"
      title: 7.2.1.  The Reference "Antecedent"
    - contents:
      - "7.2.2.  The Reference \"Dependent\"\n   This property is inherited from the
        Dependency association, and is\n   overridden to become an object reference
        to a PolicyAction object.\n   This represents a specific policy action that
        is used by a given\n   QoSPolicyPoliceAction.  The [1..1] cardinality means
        that exactly one\n   policy action  can be used as the \"conform\" action
        for a\n   QoSPolicyPoliceAction.  To execute more than one conforming action,\n
        \  use the PolicyCompoundAction class to model the conforming action.\n"
      title: 7.2.2.  The Reference "Dependent"
    title: 7.2.  The Association "PolicyConformAction"
  - contents:
    - "7.3.  The Association \"QoSPolicyExceedAction\"\n   This association links
      a policing action with an object defining an\n   action to be applied to traffic
      exceeding the associated traffic\n   profile.  The class definition for this
      association is as follows:\n   NAME              QoSPolicyExceedAction\n   DESCRIPTION
      \      A class representing the association between a\n                     policing
      action and the action that should be\n                     applied to traffic
      exceeding an associated traffic\n                     profile.\n   DERIVED FROM
      \     Dependency (see [PCIM])\n   ABSTRACT          FALSE\n   PROPERTIES        Antecedent[ref
      QoSPolicePoliceAction[0..n]]\n                     Dependent[ref PolicyAction
      [1..1]]\n"
    - contents:
      - "7.3.1.  The Reference \"Antecedent\"\n   This property is inherited from
        the Dependency association.  Its type\n   is overridden to become an object
        reference to a\n   QoSPolicyPoliceAction object.  This represents the \"independent\"
        part\n   of the association.  The [0..n] cardinality indicates that any number\n
        \  of QoSPolicyPoliceAction objects may be given the same action to be\n   executed
        as the exceeding action.\n"
      title: 7.3.1.  The Reference "Antecedent"
    - contents:
      - "7.3.2.  The Reference \"Dependent\"\n   This property is inherited from the
        Dependency association, and is\n   overridden to become an object reference
        to a PolicyAction object.\n   This represents a specific policy action that
        is used by a given\n   QoSPolicyPoliceAction.  The [1..1] cardinality means
        that a exactly\n   one policy action can be used as the \"exceed\" action
        by a\n   QoSPolicyPoliceAction.  To execute more than one conforming action,\n
        \  use the PolicyCompoundAction class to model the exceeding action.\n"
      title: 7.3.2.  The Reference "Dependent"
    title: 7.3.  The Association "QoSPolicyExceedAction"
  - contents:
    - "7.4.  The Association \"PolicyViolateAction\"\n   This association links a
      policing action with an object defining an\n   action to be applied to traffic
      violating the associated traffic\n   profile.  The class definition for this
      association is as follows:\n   NAME              PolicyViolateAction\n   DESCRIPTION
      \      A class representing the association between\n                     a
      policing action and the action that should be\n                     applied
      to traffic violating an associated traffic\n                     profile.\n
      \  DERIVED FROM      Dependency (see [PCIM])\n   ABSTRACT          FALSE\n   PROPERTIES
      \       Antecedent[ref QoSPolicePoliceAction[0..n]]\n                     Dependent[ref
      PolicyAction [1..1]]\n"
    - contents:
      - "7.4.1.  The Reference \"Antecedent\"\n   This property is inherited from
        the Dependency association.  Its type\n   is overridden to become an object
        reference to a\n   QoSPolicyPoliceAction object.  This represents the \"independent\"
        part\n   of the association.  The [0..n] cardinality indicates that any number\n
        \  of QoSPolicyPoliceAction objects may be given the same action to be\n   executed
        as the violating action.\n"
      title: 7.4.1.  The Reference "Antecedent"
    - contents:
      - "7.4.2.  The Reference \"Dependent\"\n   This property is inherited from the
        Dependency association, and is\n   overridden to become an object reference
        to a PolicyAction object.\n   This represents a specific policy action that
        is used by a given\n   QoSPolicyPoliceAction.  The [1..1] cardinality means
        that exactly one\n   policy action can be used as the \"violate\" action by
        a\n   QoSPolicyPoliceAction.  To execute more than one violating action,\n
        \  use the PolicyCompoundAction class to model the conforming action.\n"
      title: 7.4.2.  The Reference "Dependent"
    title: 7.4.  The Association "PolicyViolateAction"
  - contents:
    - "7.5.  The Aggregation \"QoSPolicyRSVPVariableInRSVPSimplePolicyAction\"\n   A
      simple RSVP policy action is represented as a pair {variable,\n   value}. This
      aggregation provides the linkage between a\n   QoSPolicyRSVPSimpleAction instance
      and a single\n   QoSPolicyRSVPVariable.  The aggregation\n   PolicyValueInSimplePolicyAction
      links the QoSPolicyRSVPSimpleAction\n   to a single PolicyValue.\n   The class
      definition for this aggregation is as follows:\n   NAME             QoSPolicyRSVPVariableInRSVPSimplePolicyAction\n
      \  DERIVED FROM     PolicyVariableInSimplePolicyAction\n   ABSTRACT         FALSE\n
      \  PROPERTIES       GroupComponent[ref QoSPolicyRSVPSimpleAction\n                      [0..n]]\n
      \                   PartComponent[ref QoSPolicyRSVPVariable [1..1] ]\n"
    - contents:
      - "7.5.1.  The Reference \"GroupComponent\"\n   The reference property \"GroupComponent\"
        is inherited from\n   PolicyComponent, and overridden to become an object
        reference to a\n   QoSPolicyRSVPSimpleAction that contains exactly one\n   QoSPolicyRSVPVariable.
        \ Note that for any single instance of the\n   aggregation class QoSPolicyRSVPVariableInRSVPSimplePolicyAction,
        this\n   property is single-valued.  The [0..n] cardinality indicates that\n
        \  there may be 0, 1, or more QoSPolicyRSVPSimpleAction objects that\n   contain
        any given RSVP variable object.\n"
      title: 7.5.1.  The Reference "GroupComponent"
    - contents:
      - "7.5.2.  The Reference \"PartComponent\"\n   The reference property \"PartComponent\"
        is inherited from\n   PolicyComponent, and overridden to become an object
        reference to a\n   QoSPolicyRSVPVariable that is defined within the scope
        of a\n   QoSPolicyRSVPSimpleAction.  Note that for any single instance of
        the\n   association class QoSPolicyRSVPVariableInRSVPSimplePolicyAction, this\n
        \  property (like all reference properties) is single-valued.  The\n   [1..1]
        cardinality indicates that a\n   QoSPolicyRSVPVariableInRSVPSimplePolicyAction
        must have exactly one\n   RSVP variable defined within its scope in order
        to be meaningful.\n"
      title: 7.5.2.  The Reference "PartComponent"
    title: 7.5.  The Aggregation "QoSPolicyRSVPVariableInRSVPSimplePolicyAction"
  title: '7.  Class Definitions: Association Hierarchy'
- contents:
  - "8.  Class Definitions: Inheritance Hierarchy\n   The following sections define
    object classes that are specified by\n   QPIM.\n"
  - contents:
    - "8.1.  The Class QoSPolicyDiscardAction\n   This class is used to specify that
      packets should be discarded.  This\n   is the same as stating that packets should
      be denied forwarding.  The\n   class definition is as follows:\n   NAME           QoSPolicyDiscardAction\n
      \  DESCRIPTION    This action specifies that packets should be\n                  discarded.\n
      \  DERIVED FROM   PolicyAction (defined in [PCIM])\n   ABSTRACT       FALSEFALSE\n
      \  PROPERTIES     None\n"
    title: 8.1.  The Class QoSPolicyDiscardAction
  - contents:
    - "8.2.  The Class QoSPolicyAdmissionAction\n   This class is the base class for
      performing admission decisions based\n   on a comparison of a meter measuring
      the temporal behavior of a flow\n   or a set of flow with a traffic profile.
      \ The qpAdmissionScope\n   property controls whether the comparison is done
      per flow or per\n   class (of flows).  Only packets that conform to the traffic
      profile\n   are admitted for further processing; other packets are discarded.\n
      \  The class definition is as follows:\n   NAME           QoSPolicyAdmissionAction\n
      \  DESCRIPTION    This action controls admission decisions based on\n                  comparison
      of a meter to a traffic profile.\n   DERIVED FROM   PolicyAction (defined in
      [PCIM])\n   ABSTRACT       FALSEFALSE\n   PROPERTIES     qpAdmissionScope\n"
    - contents:
      - "8.2.1.  The Property qpAdmissionScope\n   This attribute specifies whether
        the admission decision is done per\n   flow or per the entire class of flows
        defined by the rule condition.\n   If the scope is \"flow\", the actual or
        requested rate of each flow is\n   compared against the traffic profile.  If
        the scope is set to\n   \"class\", the aggregate actual or requested rate
        of all flows matching\n   the rule condition is measured against the traffic
        profile.  The\n   property is defined as follows:\n   NAME         qpAdmissionScope\n
        \  DESCRIPTION  This property specifies whether the admission decision\n                is
        done per flow or per the entire class of flows.\n   SYNTAX       Integer\n
        \  VALUE        This is an enumerated integer.  A value of 0 specifies\n                that
        admission is done on a per-flow basis, and a value\n                of 1 specifies
        that admission is done on a per-class\n                basis.\n"
      title: 8.2.1.  The Property qpAdmissionScope
    title: 8.2.  The Class QoSPolicyAdmissionAction
  - contents:
    - "8.3.  The Class QoSPolicyPoliceAction\n   This is used for defining policing
      actions (i.e., those actions that\n   restrict traffic based on a comparison
      with a traffic profile).\n   Using the three associations QoSPolicyConformAction,\n
      \  QoSPolicyExceedAction and QoSPolicyViolateAction, it is possible to\n   specify
      different actions to take based on whether the traffic is\n   conforming, exceeding,
      or violating a traffic profile.  The traffic\n   profile is specified in a subclass
      of the QoSPolicyTrfcProf class.\n   The class definition is as follows:\n   NAME
      \        QoSPolicyPoliceAction\n   DESCRIPTION  This action controls the operation
      of policers.  The\n                rate of flows is measured against a traffic
      profile.\n                The actions that need to be performed on conforming,\n
      \               exceeding and violating traffic are indicated using\n                the
      conform, exceed and violate action associations.\n   DERIVED FROM QoSPolicyAdmissionAction
      (defined in this document)\n   ABSTRACT     FALSEFALSE\n   PROPERTIES   None\n"
    title: 8.3.  The Class QoSPolicyPoliceAction
  - contents:
    - "8.4.  The Class  QoSPolicyShapeAction\n   This class is used for defining shaping
      actions.  Shapers are used to\n   delay some or all of the packets in a traffic
      stream in order to\n   bring a particular traffic stream into compliance with
      a given\n   traffic profile.  The traffic profile is specified in a subclass
      of\n   the QoSPolicyTrfcProf class.  The class definition is as follows:\n   NAME
      \        QoSPolicyShapeAction\n   DESCRIPTION  This action indicate that traffic
      should be shaped to be\n                conforming with a traffic profile.\n
      \  DERIVED FROM QoSPolicyAdmissionAction (defined in this document)\n   ABSTRACT
      \    FALSEFALSE\n   PROPERTIES   None\n"
    title: 8.4.  The Class  QoSPolicyShapeAction
  - contents:
    - "8.5.  The Class QoSPolicyRSVPAdmissionAction\n   This class determines whether
      to accept or reject a given RSVP\n   request by comparing the RSVP request's
      TSPEC or RSPEC parameters\n   against the associated traffic profile and/or
      by enforcing the pre-\n   set maximum sessions limit.  The traffic profile is
      specified in the\n   QoSPolicyIntServTrfcProf class.  This class inherits the\n
      \  qpAdmissionScope property from its superclass.  This property\n   specifies
      whether admission should be done on a per-flow or per-class\n   basis.  If the
      traffic profile is not larger than or equal to the\n   requested reservation,
      or to the sum of the admitted reservation\n   merged with the requested reservation,
      the result is a deny decision.\n   If no traffic profile is specified, the assumption
      is that all\n   traffic can be admitted.\n   The class definition is as follows:\n
      \  NAME         QoSPolicyRSVPAdmissionAction\n   DESCRIPTION  This action controls
      the admission of RSVP requests.\n                Depending on the scope, either
      a single RSVP request or\n                the total admitted RSVP requests matching
      the conditions\n                are compared against a traffic profile.\n   DERIVED
      FROM QoSPolicyAdmissionAction (defined in this document)\n   ABSTRACT     FALSEFALSE\n
      \  PROPERTIES   qpRSVPWarnOnly, qpRSVPMaxSessions\n"
    - contents:
      - "8.5.1.  The Property qpRSVPWarnOnly\n   This property is applicable when
        fulfilling (\"admitting\") an RSVP\n   request would violate the policer (traffic
        profile) limits or when\n   the maximum number session would be exceeded (or
        both).\n   When this property is set to TRUE, the RSVP request is admitted
        in\n   spite of the violation, but an RSVP error message carrying a warning\n
        \  is sent to the originator (sender or receiver).  When set to FALSE,\n   the
        request would be denied and an error message would be sent back\n   to the
        originator.  So the meaning of the qpWarnOnly flag is: Based\n   on property's
        value (TRUE or FALSE), determine whether to admit but\n   warn the originator
        that the request is in violation or to deny the\n   request altogether (and
        send back an error).\n   Specifically, a PATHERR (in response to a Path message)
        or a RESVERR\n   (in response of a RESV message) will be sent.  This follows
        the COPS\n   for RSVP send error flag in the Decision Flags object.  This
        property\n   is defined as follows:\n   NAME      qpRSVPWarnOnly\n   SYNTAX
        \   Boolean\n   Default   FALSE\n   VALUE     The value TRUE means that the
        request should be admitted\n             AND an RSVP warning message should
        be sent to the\n             originator.  The value of FALSE means that the
        request\n             should be not admitted and an appropriate error message\n
        \            should be sent back to the originator of the request.\n"
      title: 8.5.1.  The Property qpRSVPWarnOnly
    - contents:
      - "8.5.2.  The Property qpRSVPMaxSessions\n   This attribute is used to limit
        the total number of RSVP requests\n   admitted for the specified class of
        traffic.  For this property to be\n   meaningful, the qpAdmissionScope property
        must be set to class.  The\n   definition of this property is as follows:\n
        \  NAME     qpRSVPMaxSessions\n   SYNTAX   Integer\n   VALUE    Must be greater
        than 0.\n"
      title: 8.5.2.  The Property qpRSVPMaxSessions
    title: 8.5.  The Class QoSPolicyRSVPAdmissionAction
  - contents:
    - "8.6.  The Class QoSPolicyPHBAction\n   This class is a base class that is used
      to define the per-hop\n   behavior that is to be assigned to behavior aggregates.
      \ It defines a\n   common property, qpMaxPacketSize, for use by its subclasses\n
      \  (QoSPolicyBandwidthAction and QoSPolicyCongestionControlAction).  The\n   class
      definition is as follows:\n   NAME           QoSPolicyPHBAction\n   DESCRIPTION
      \   This action controls the Per-Hop-Behavior provided to\n                  behavior
      aggregates.\n   DERIVED FROM   PolicyAction  (defined in [PCIM])\n   ABSTRACT
      \      TRUE\n   PROPERTIES     qpMaxPacketSize\n"
    - contents:
      - "8.6.1.  The Property qpMaxPacketSize\n   This property specifies the maximum
        packet size in bytes, of packets\n   in the designated flow.  This attribute
        is used in translation of\n   QPIM attributes to QoS mechanisms used within
        a PEP.  For example,\n   queue length may be measured in bytes, while the
        minimum number of\n   packets that should be kept in a PEP is defined within
        QPIM in number\n   of packets.  This property is defined as follows:\n   NAME
        \      qpMaxPacketSize\n   SYNTAX     Integer\n   Value      Must be greater
        than 0\n"
      title: 8.6.1.  The Property qpMaxPacketSize
    title: 8.6.  The Class QoSPolicyPHBAction
  - contents:
    - "8.7.  The Class QoSPolicyBandwidthAction\n   This class is used to control
      the bandwidth, delay, and forwarding\n   behavior of a PHB.  Its class definition
      is as follows:\n   NAME           QoSPolicyBandwidthAction\n   DESCRIPTION    This
      action controls the bandwidth, delay, and\n                  forwarding characteristics
      of the PHB.\n   DERIVED FROM   QoSPolicyPBHAction (defined in this document)\n
      \  ABSTRACT       FALSE\n   PROPERTIES     qpForwardingPriority, qpBandwidthUnits,\n
      \                 qpMinBandwdith, qpMaxBandwidth, qpMaxDelay,\n                  qpMaxJitter,
      qpFairness\n"
    - contents:
      - "8.7.1.  The Property qpForwardingPriority\n   This property defines the forwarding
        priority for this set of flows.\n   A non-zero value indicates that preemptive
        forwarding is required.\n   Higher values represent higher forwarding priority.
        \ This property is\n   defined as follows:\n   NAME        qpForwardingPriority\n
        \  SYNTAX      Integer\n   VALUE       Must be non-negative.  The value 0
        means that preemptive\n               forwarding is not required.  A positive
        value indicates\n               the priority that is to be assigned for this
        (set of)\n               flow(s).  Larger values represent higher priorities.\n"
      title: 8.7.1.  The Property qpForwardingPriority
    - contents:
      - "8.7.2.  The Property qpBandwidthUnits\n   This property defines the units
        that the properties qpMinBandwidth\n   and qpMaxBandwidth have.  Bandwidth
        can either be defined in bits/sec\n   or as a percentage of the available
        bandwidth or scheduler resources.\n   This property is defined as follows:\n
        \  NAME        qpBandwidthUnits\n   SYNTAX      Integer\n   VALUE       Two
        values are possible.  The value of 0 is used to\n               specify units
        of bits/sec, while the value of 1 is used\n               to specify units
        as a percentage of the available\n               bandwidth.  If this property
        indicates that the bandwidth\n               units are percentages, then each
        of the bandwidth\n               properties expresses a whole-number percentage,
        and hence\n               its maximum value is 100.\n"
      title: 8.7.2.  The Property qpBandwidthUnits
    - contents:
      - "8.7.3.  The Property qpMinBandwidth\n   This property defines the minimum
        bandwidth that should be reserved\n   for this class of traffic.  Both relative
        (i.e., a percentage of the\n   bandwidth) and absolute (i.e., bits/second)
        values can be specified\n   according to the value of the qpBandwidthUnits
        property.  This\n   property is defined as follows:\n   NAME        qpMinBandwidth\n
        \  SYNTAX      Integer\n   VALUE       The value must be greater than 0.  If
        the property\n               qpMaxBandwidth is defined, then the value of\n
        \              qpMinBandwidth must be less than or equal to the value of\n
        \              qpMaxBandwidth.\n"
      title: 8.7.3.  The Property qpMinBandwidth
    - contents:
      - "8.7.4.  The Property qpMaxBandwidth\n   This property defines the maximum
        bandwidth that should be allocated\n   to this class of traffic.  Both relative
        (i.e., a percentage of the\n   bandwidth)and absolute (i.e., bits/second)
        values can be specified\n   according to the value of the qpBandwidthUnits
        property.  This\n   property is defined as follows:\n   NAME        qpMaxBandwidth\n
        \  SYNTAX      Integer\n   VALUE       The value must be greater than 0.  If
        the property\n               qpMaxBandwidth is defined, then the value of\n
        \              qpMinBandwidth must be less than or equal to the value of\n
        \              qpMaxBandwidth.\n"
      title: 8.7.4.  The Property qpMaxBandwidth
    - contents:
      - "8.7.5.  The Property qpMaxDelay\n   This property defines the maximal per-hop
        delay that traffic of this\n   class should experience while being forwarded
        through this hop.  The\n   maximum delay is measured in microseconds.  This
        property is defined\n   as follows:\n   NAME        qpMaxDelay\n   SYNTAX
        \     Integer (microseconds)\n   VALUE       The value must be greater than
        0.\n"
      title: 8.7.5.  The Property qpMaxDelay
    - contents:
      - "8.7.6.  The Property qpMaxJitter\n   This property defines the maximal per-hop
        delay variance that traffic\n   of this class should experience while being
        forwarded through this\n   hop. The maximum jitter is measured in microseconds.
        \ This property\n   is defined as follows:\n   NAME        qpMaxJitter\n   SYNTAX
        \     Integer (microseconds)\n   VALUE       The value must be greater than
        0.\n"
      title: 8.7.6.  The Property qpMaxJitter
    - contents:
      - "8.7.7.  The Property qpFairness\n   This property defines whether fair queuing
        is required for this class\n   of traffic.  This property is defined as follows:\n
        \  NAME        qpFairness\n   SYNTAX      Boolean\n   VALUE       The value
        of FALSE means that fair queuing is not\n               required for this
        class of traffic, while the value of\n               TRUE means that fair
        queuing is required for this class\n               of traffic.\n"
      title: 8.7.7.  The Property qpFairness
    title: 8.7.  The Class QoSPolicyBandwidthAction
  - contents:
    - "8.8.  The Class QoSPolicyCongestionControlAction\n   This class is used to
      control the characteristics of the congestion\n   control algorithm being used.
      \ The class definition is as follows:\n   NAME         QoSPolicyCongestionControlAction\n
      \  DESCRIPTION  This action control congestion control characteristics\n                of
      the PHB.\n   DERIVED FROM QoSPolicyPBHAction (defined in this document)\n   ABSTRACT
      \    FALSE\n   PROPERTIES   qpQueueSizeUnits, qpQueueSize, qpDropMethod,\n                qpDropThresholdUnits,
      qpDropMinThresholdValue,\n                qpDropMaxThresholdValue\n"
    - contents:
      - "8.8.1.  The property qpQueueSizeUnits\n   This property specifies the units
        in which the qpQueueSize attribute\n   is measured.  The queue size is measured
        either in number of packets\n   or in units of time.  The time interval specifies
        the time needed to\n   transmit all packets within the queue if the link speed
        is dedicated\n   entirely to transmission of packets within this queue.  The
        property\n   definition is:\n   NAME        qpQueueSizeUnits\n   SYNTAX      Integer\n
        \  VALUE       This property can have two values.  If the value is set\n               to
        0, then the unit of measurement is number of packets.\n               If the
        value is set to 1, then the unit of measurement is\n               milliseconds.\n"
      title: 8.8.1.  The property qpQueueSizeUnits
    - contents:
      - "8.8.2.  The Property qpQueueSize\n   This property specifies the maximum
        queue size in packets or in\n   milliseconds, depending on the value of the
        qpQueueSizeUnits (0\n   specifies packets, and 1 specifies milliseconds).
        \ This property is\n   defined as follows:\n   NAME        qpQueueSize\n   SYNTAX
        \     Integer\n   VALUE       This value must be greater than 0.\n"
      title: 8.8.2.  The Property qpQueueSize
    - contents:
      - "8.8.3.  The Property qpDropMethod\n   This property specifies the congestion
        control drop algorithm that\n   should be used for this type of traffic.  This
        property is defined as\n   follows:\n   NAME        qpDropMethod\n   SYNTAX
        \     Integer\n   VALUES      Three values are currently defined.  The value
        0\n               specifies a random drop algorithm, the value 1 specifies\n
        \              a tail drop algorithm, and the value 2 specifies a head\n               drop
        algorithm.\n"
      title: 8.8.3.  The Property qpDropMethod
    - contents:
      - "8.8.4.  The Property qpDropThresholdUnits\n   This property specifies the
        units in which the two properties\n   qpDropMinThresholdValue and qpDropMaxThresholdValue
        are measured.\n   Thresholds can be measured either in packets or as a percentage
        of\n   the available queue sizes.  This property is defined as follows:\n
        \  NAME        qpDropThresholdUnits\n   SYNTAX      Integer\n   VALUES      Three
        values are defined.  The value 0 defines the units\n               as number
        of packets, the value 1 defines the units as a\n               percentage
        of the queue size and the value 2 defines the\n               units in milliseconds.
        \ If this property indicates that\n               the threshold units are
        percentages, then each of the\n               threshold properties expresses
        a whole-number percentage,\n               and hence its maximum value is
        100.\n"
      title: 8.8.4.  The Property qpDropThresholdUnits
    - contents:
      - "8.8.5.  The Property qpDropMinThresholdValue\n   This property specifies
        the minimum number of queuing and buffer\n   resources that should be reserved
        for this class of flows.  The\n   threshold can be specified as either relative
        (i.e., a percentage) or\n   absolute (i.e., number of packets or millisecond)
        value according to\n   the value of the qpDropThresholdUnits property.  If
        this property\n   specifies a value of 5 packets, then enough buffer and queuing\n
        \  resources should be reserved to hold 5 packets before running the\n   specified
        congestion control drop algorithm.  This property is\n   defined as follows:\n
        \  NAME        qpDropMinThresholdValue\n   SYNTAX      Integer\n   VALUE       This
        value must be greater than or equal to 0.  If the\n               property
        qpDropMaxThresholdValue is defined, then the\n               value of the
        qpDropMinThresholdValue property must be\n               less than or equal
        to the value of the\n               qpDropMaxThresholdValue property.\n"
      title: 8.8.5.  The Property qpDropMinThresholdValue
    - contents:
      - "8.8.6.  The Property qpDropMaxThresholdValue\n   This property specifies
        the maximum number of queuing and buffer\n   resources that should be reserved
        for this class of flows.  The\n   threshold can be specified as either relative
        (i.e., a percentage) or\n   absolute (i.e., number of packets or milliseconds)
        value according to\n   the value of the qpDropThresholdUnits property.  Congestion
        Control\n   droppers should not keep more packets than the value specified
        in\n   this property.  Note, however, that some droppers may calculate queue\n
        \  occupancy averages, and therefore the actual maximum queue resources\n
        \  should be larger.  This property is defined as follows:\n   NAME        qpDropMaxThresholdValue\n
        \  SYNTAX      Integer\n   VALUE       This value must be greater than or
        equal to 0.  If the\n               property qpDropMinThresholdValue is defined,
        then the\n               value of the qpDropMinThresholdValue property must
        be\n               less than or equal to the value of the\n               qpDropMaxThresholdValue
        property.\n"
      title: 8.8.6.  The Property qpDropMaxThresholdValue
    title: 8.8.  The Class QoSPolicyCongestionControlAction
  - contents:
    - "8.9.  Class QoSPolicyTrfcProf\n   This is an abstract base class that models
      a traffic profile.\n   Traffic profiles specify the maximum rate parameters
      used within\n   admission decisions.  The association\n   QoSPolicyTrfcProfInAdmissionAction
      binds the admission decision to\n   the traffic profile.  The class definition
      is as follows:\n   NAME          QoSPolicyTrfcProf\n   DERIVED FROM  Policy
      (defined in [PCIM])\n   ABSTRACT      TRUE\n   PROPERTIES    None\n"
    title: 8.9.  Class QoSPolicyTrfcProf
  - contents:
    - "8.10.  Class QoSPolicyTokenBucketTrfcProf\n   This class models a two- or three-level
      Token Bucket traffic profile.\n   Additional profiles can be modeled by cascading
      multiple instances of\n   this class (e.g., by connecting the output of one
      instance to the\n   input of another instance).  This traffic profile carries
      the policer\n   or shaper rate values to be enforced on a flow or a set of flows.\n
      \  The class definition is as follows:\n   NAME          QoSPolicyTokenBucketTrfcProf\n
      \  DERIVED FROM  QoSPolicyTrfcProf (defined in this document)\n   ABSTRACT      FALSE\n
      \  PROPERTIES    qpTBRate, qpTBNormalBurst, qpTBExcessBurst\n"
    - contents:
      - "8.10.1.  The Property qpTBRate\n   This is a non-negative integer that defines
        the token rate in\n   kilobits per second.  A rate of zero means that all
        packets will be\n   out of profile.  This property is defined as follows:\n
        \  NAME        qpTBRate\n   SYNTAX      Integer\n   VALUE       This value
        must be greater than to 0\n"
      title: 8.10.1.  The Property qpTBRate
    - contents:
      - "8.10.2.  The Property qpTBNormalBurst\n   This property is an integer that
        defines the normal size of a burst\n   measured in bytes.  This property is
        defined as follows:\n   NAME        qpTBNormalBurst\n   SYNTAX      Integer\n
        \  VALUE       This value must be greater than to 0\n"
      title: 8.10.2.  The Property qpTBNormalBurst
    - contents:
      - "8.10.3.  The Property qpTBExcessBurst\n   This property is an integer that
        defines the excess burst size\n   measured in bytes.  This property is defined
        as follows:\n   NAME        qpTBExcessBurst\n   SYNTAX      Integer\n   VALUE
        \      This value must be greater than or equal to\n               qpTBNormalBurst\n"
      title: 8.10.3.  The Property qpTBExcessBurst
    title: 8.10.  Class QoSPolicyTokenBucketTrfcProf
  - contents:
    - "8.11.  Class QoSPolicyIntServTrfcProf\n   This class represents an IntServ
      traffic profile.  Values of IntServ\n   traffic profiles are compared against
      Traffic specification (TSPEC)\n   and QoS Reservation (FLOWSPEC) requests carried
      in RSVP requests.\n   The class definition is as follows:\n   NAME          QoSPolicyIntServTrfcProf\n
      \  DERIVED FROM  QoSPolicyTrfcProf (defined in this document)\n   ABSTRACT      FALSE\n
      \  PROPERTIES    qpISTokenRate, qpISPeakRate, qpISBucketSize,\n                 qpISResvRate,
      qpISResvSlack, qpISMinPolicedUnit,\n                 qpISMaxPktSize\n"
    - contents:
      - "8.11.1.  The Property qpISTokenRate\n   This property is a non-negative integer
        that defines the token rate\n   parameter, measured in kilobits per second.
        \ This property is defined\n   as follows:\n   NAME        qpISTokenRate\n
        \  SYNTAX      Integer\n   VALUE       This value must be greater than or
        equal to 0\n"
      title: 8.11.1.  The Property qpISTokenRate
    - contents:
      - "8.11.2.  The Property qpISPeakRate\n   This property is a non-negative integer
        that defines the peak rate\n   parameter, measured in kilobits per second.
        \ This property is defined\n   as follows:\n   NAME        qpISPeakRate\n
        \  SYNTAX      Integer\n   VALUE       This value must be greater than or
        equal to 0\n"
      title: 8.11.2.  The Property qpISPeakRate
    - contents:
      - "8.11.3.  The Property qpISBucketSize\n   This property is a non-negative
        integer that defines the token bucket\n   size parameter, measured in bytes.
        \ This property is defined as\n   follows:\n   NAME        qpISBucketSize\n
        \  SYNTAX      Integer\n   VALUE       This value must be greater than or
        equal to 0\n"
      title: 8.11.3.  The Property qpISBucketSize
    - contents:
      - "8.11.4.  The Property qpISResvRate\n   This property is a non-negative integer
        that defines the reservation\n   rate (R-Spec) in the RSVP guaranteed service
        reservation.  It is\n   measured in kilobits per second.  This property is
        defined as\n   follows:\n   NAME        qpISResvRate\n   SYNTAX      Integer\n
        \  VALUE       This value must be greater than or equal to 0\n"
      title: 8.11.4.  The Property qpISResvRate
    - contents:
      - "8.11.5.  The Property qpISResvSlack\n   This property is a non-negative integer
        that defines the RSVP slack\n   term in the RSVP guaranteed service reservation.
        \ It is measured in\n   microseconds.  This property is defined as follows:\n
        \  NAME        qpISResvSlack\n   SYNTAX      Integer\n   VALUE       This
        value must be greater than or equal to 0\n"
      title: 8.11.5.  The Property qpISResvSlack
    - contents:
      - "8.11.6.  The Property qpISMinPolicedUnit\n   This property is a non-negative
        integer that defines the minimum RSVP\n   policed unit, measured in bytes.
        \ This property is defined as\n   follows:\n   NAME        qpISMinPolicedUnit\n
        \  SYNTAX      Integer\n   VALUE       This value must be greater than or
        equal to 0\n"
      title: 8.11.6.  The Property qpISMinPolicedUnit
    - contents:
      - "8.11.7.  The Property qpISMaxPktSize\n   This property is a positive integer
        that defines the maximum allowed\n   packet size for RSVP messages, measured
        in bytes.  This property is\n   defined as follows:\n   NAME        qpISMaxPktSize\n
        \  SYNTAX      Integer\n   VALUE       This value must be a positive integer,
        denoting the\n               number of bytes in the largest payload packet
        of an RSVP\n               signaled flow or class.\n"
      title: 8.11.7.  The Property qpISMaxPktSize
    title: 8.11.  Class QoSPolicyIntServTrfcProf
  - contents:
    - "8.12.  The Class QoSPolicyAttributeValue\n   This class can be used for representing
      an indirection in variable\n   and value references either in a simple condition
      (\"<x> match <y>\")\n   or a simple action (\"<x> = <y>\").  In both cases,
      <x> and <y> are\n   known as the variable and the value of either the condition
      or\n   action.  The value of the properties qpAttributeName and\n   qpAttributeValueList
      are used to substitute <x> and <y> in the\n   condition or action respectively.\n
      \  The substitution is done as follows: The value of the property\n   qpAttributeName
      is used to substitute <x> and the value of the\n   property qpAttributeValueList
      is used to substitute <y>.\n   Once the substitution is done, the condition
      can be evaluated and the\n   action can be performed.\n   For example, suppose
      we want to define a condition over a user name\n   of the form \"user == 'Smith'\",
      using the QoSPolicyRSVPUserVariable\n   class.  The user information in the
      RSVP message provides a DN.  The\n   DN points to a user objects holding many
      attributes.  If the relevant\n   attribute is \"last name\", we would use the
      QoSPolicyAttributeValue\n   class with qpAttributeName = \"Last Name\", qpAttributeValueList
      =\n   {\"Smith\"}.\n   The class definition is as follows:\n   NAME           QoSPolicyAttributeValue\n
      \  DERIVED FROM   PolicyValue (defined in [PCIMe])\n   ABSTRACT       FALSE\n
      \  PROPERTIES     qpAttributeName, qpAttributeValueList\n"
    - contents:
      - "8.12.1.  The Property qpAttributeName\n   This property carries the name
        of the attribute that is to be used to\n   substitute <x> in a simple condition
        or simple condition of the forms\n   \"<x> match <y>\" or \"<x> = <y>\" respectively.
        \ This property is\n   defined as follows:\n   NAME       qpAttributeName\n
        \  SYNTAX     String\n"
      title: 8.12.1.  The Property qpAttributeName
    - contents:
      - "8.12.2.  The Property qpAttributeValueList\n   This property carries a list
        of values that is to be used to\n   substitute <y> in a simple condition or
        simple action of the forms\n   \"<x> match <y>\" or \"<x> = <y>\" respectively.\n
        \  This property is defined as follows:\n   NAME       qpAttributeValueList\n
        \  SYNTAX     String\n"
      title: 8.12.2.  The Property qpAttributeValueList
    title: 8.12.  The Class QoSPolicyAttributeValue
  - contents:
    - "8.13.  The Class \"QoSPolicyRSVPVariable\"\n   This is an abstract class that
      serves as the base class for all\n   implicit variables that have to do with
      RSVP conditioning.  The class\n   definition is as follows:\n   NAME           QoSPolicyRSVPVariable\n
      \  DESCRIPTION    An abstract base class used to build other classes\n                  that
      specify different attributes of an RSVP request\n   DERIVED FROM   PolicyImplicitVariable
      (defined in [PCIMe])\n   ABSTRACT       TRUE\n   PROPERTIES     None\n"
    title: 8.13.  The Class "QoSPolicyRSVPVariable"
  - contents:
    - "8.14.  The Class \"QoSPolicyRSVPSourceIPv4Variable\"\n   This is a concrete
      class that contains the source IPv4 address of the\n   RSVP signaled flow, as
      defined in the RSVP PATH SENDER_TEMPLATE and\n   RSVP RESV FILTER_SPEC [RSVP]
      objects.  The class definition is as\n   follows:\n   NAME           QoSPolicyRSVPSourceIPv4Variable\n
      \  DESCRIPTION    The source IPv4 address of the RSVP signaled flow, as\n                  defined
      in the RSVP PATH SENDER_TEMPLATE and RSVP RESV\n                  FILTER_SPEC
      [RSVP] objects.\n                  ALLOWED VALUE TYPES: PolicyIPv4AddrValue\n
      \  DERIVED FROM   QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT
      \      FALSE\n   PROPERTIES     None\n"
    title: 8.14.  The Class "QoSPolicyRSVPSourceIPv4Variable"
  - contents:
    - "8.15.  The Class \"QoSPolicyRSVPDestinationIPv4Variable\"\n   This is a concrete
      class that contains the destination IPv4 address\n   of the RSVP signaled flow,
      as defined in the RSVP PATH\n   SENDER_TEMPLATE and RSVP RESV FILTER_SPEC [RSVP]
      objects.  The class\n   definition is as follows:\n   NAME           QoSPolicyRSVPDestinationIPv4Variable\n
      \  DESCRIPTION    The destination IPv4 address of the RSVP signaled\n                  flow,
      as defined in the RSVP PATH and RESV SESSION\n                  [RSVP] objects.\n
      \                 ALLOWED VALUE TYPES: PolicyIPv4AddrValue\n   DERIVED FROM
      \  QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT       FALSE\n
      \  PROPERTIES     None\n"
    title: 8.15.  The Class "QoSPolicyRSVPDestinationIPv4Variable"
  - contents:
    - "8.16.  The Class \"QoSPolicyRSVPSourceIPv6Variable\"\n   This is a concrete
      class that contains the source IPv6 address of the\n   RSVP signaled flow, as
      defined in the RSVP PATH SENDER_TEMPLATE and\n   RSVP RESV FILTER_SPEC [RSVP]
      objects.  The class definition is as\n   follows:\n   NAME           QoSPolicyRSVPSourceIPv6Variable\n
      \  DESCRIPTION    The source IPv6 address of the RSVP signaled flow, as\n                  defined
      in the RSVP PATH SENDER_TEMPLATE and RSVP RESV\n                  FILTER_SPEC
      [RSVP] objects.\n                  ALLOWED VALUE TYPES: PolicyIPv6AddrValue\n
      \  DERIVED FROM   QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT
      \      FALSE\n   PROPERTIES     None\n"
    title: 8.16.  The Class "QoSPolicyRSVPSourceIPv6Variable"
  - contents:
    - "8.17.  The Class \"QoSPolicyRSVPDestinationIPv6Variable\"\n   This is a concrete
      class that contains the destination IPv6 address\n   of the RSVP signaled flow,
      as defined in the RSVP PATH\n   SENDER_TEMPLATE and RSVP RESV FILTER_SPEC [RSVP]
      objects.  The class\n   definition is as follows:\n   NAME           QoSPolicyRSVPDestinationIPv6Variable\n
      \  DESCRIPTION    The destination IPv6 address of the RSVP signaled\n                  flow,
      as defined in the RSVP PATH and RESV SESSION\n                  [RSVP] objects.\n
      \                 ALLOWED VALUE TYPES: PolicyIPv6AddrValue\n   DERIVED FROM
      \  QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT       FALSE\n
      \  PROPERTIES     None\n"
    title: 8.17.  The Class "QoSPolicyRSVPDestinationIPv6Variable"
  - contents:
    - "8.18.  The Class \"QoSPolicyRSVPSourcePortVariable\"\n   This class contains
      the source port of the RSVP signaled flow, as\n   defined in the RSVP PATH SENDER_TEMPLATE
      and RSVP RESV FILTER_SPEC\n   [RSVP] objects.  The class definition is as follows:\n
      \  NAME           QoSPolicyRSVPSourcePortVariable\n   DESCRIPTION    The source
      port of the RSVP signaled flow, as defined\n                  in the RSVP PATH
      SENDER_TEMPLATE and RSVP RESV\n                  FILTER_SPEC [RSVP] objects.\n
      \                 ALLOWED VALUE TYPES: PolicyIntegerValue (0..65535)\n   DERIVED
      FROM   QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT       FALSE\n
      \  PROPERTIES     None\n"
    title: 8.18.  The Class "QoSPolicyRSVPSourcePortVariable"
  - contents:
    - "8.19.  The Class \"QoSPolicyRSVPDestinationPortVariable\"\n   This is a concrete
      class that contains the destination port of the\n   RSVP signaled flow, as defined
      in the RSVP PATH SENDER_TEMPLATE and\n   RSVP RESV FILTER_SPEC [RSVP] objects.
      \ The class definition is as\n   follows:\n   NAME           QoSPolicyRSVPDestinationPortVariable\n
      \  DESCRIPTION    The destination port of the RSVP signaled flow, as\n                  defined
      in the RSVP PATH and RESV SESSION [RSVP]\n                  objects.\n                  ALLOWED
      VALUE TYPES: PolicyIntegerValue (0..65535)\n   DERIVED FROM   QoSPolicyRSVPVariable
      (defined in this document)\n   ABSTRACT       FALSE\n   PROPERTIES     None\n"
    title: 8.19.  The Class "QoSPolicyRSVPDestinationPortVariable"
  - contents:
    - "8.20.  The Class \"QoSPolicyRSVPIPProtocolVariable\"\n   This is a concrete
      class that contains the IP Protocol number of the\n   RSVP signaled flow, as
      defined in the RSVP PATH and RESV SESSION\n   [RSVP] objects.  The class definition
      is as follows:\n   NAME           QoSPolicyRSVPIPProtocolVariable\n   DESCRIPTION
      \   The IP Protocol number of the RSVP signaled flow, as\n                  defined
      in the RSVP PATH and RESV SESSION [RSVP]\n                  objects.\n                  ALLOWED
      VALUE TYPES: PolicyIntegerValue\n   DERIVED FROM   QoSPolicyRSVPVariable (defined
      in this document)\n   ABSTRACT       FALSE\n   PROPERTIES     None\n"
    title: 8.20.  The Class "QoSPolicyRSVPIPProtocolVariable"
  - contents:
    - "8.21.  The Class \"QoSPolicyRSVPIPVersionVariable\"\n   This is a concrete
      class that contains the IP Protocol version number\n   of the RSVP signaled
      flow, as defined in the RSVP PATH and RESV\n   SESSION [RSVP] objects.  The
      well-known version numbers are 4 and 6.\n   This variable allows a policy definition
      of the type:\n      \"If IP version = IPv4 then ...\".\n   The class definition
      is as follows:\n   NAME           QoSPolicyRSVPIPVersionVariable\n   DESCRIPTION
      \   The IP version number of the IP Addresses carried the\n                  RSVP
      signaled flow, as defined in the RSVP PATH and\n                  RESV SESSION
      [RSVP] objects.\n                  ALLOWED VALUE TYPES: PolciIntegerValue\n
      \  DERIVED FROM   QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT
      \      FALSE\n   PROPERTIES     None\n"
    title: 8.21.  The Class "QoSPolicyRSVPIPVersionVariable"
  - contents:
    - "8.22.  The Class \"QoSPolicyRSVPDCLASSVariable\"\n   This is a concrete class
      that contains the DSCP value as defined in\n   the RSVP DCLASS [DCLASS] object.
      \ The class definition is as follows:\n   NAME           QoSPolicyRSVPDCLASSVariable\n
      \  DESCRIPTION    The DSCP value as defined in the RSVP DCLASS [DCLASS]\n                  object.\n
      \                 ALLOWED VALUE TYPES: PolicyIntegerValue,\n                                       PolicyBitStringValue\n
      \  DERIVED FROM   QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT
      \      FALSE\n   PROPERTIES     None\n"
    title: 8.22.  The Class "QoSPolicyRSVPDCLASSVariable"
  - contents:
    - "8.23.  The Class \"QoSPolicyRSVPStyleVariable\"\n   This is a concrete class
      that contains the reservation style as\n   defined in the RSVP STYLE object
      in the RESV message [RSVP].  The\n   class definition is as follows:\n   NAME
      \          QoSPolicyRSVPStyleVariable\n   DESCRIPTION    The reservation style
      as defined in the RSVP STYLE\n                  object in the RESV message [RSVP].\n
      \                 ALLOWED VALUE TYPES:  PolicyBitStringValue,\n                                        PolicyIntegerValue
      (Integer has\n                                        an enumeration of\n                                        {
      Fixed-Filter=1,\n                                         Shared-Explicit=2,\n
      \                                        Wildcard-Filter=3}\n   DERIVED FROM
      \  QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT       FALSE\n
      \  PROPERTIES     None\n"
    title: 8.23.  The Class "QoSPolicyRSVPStyleVariable"
  - contents:
    - "8.24.  The Class \"QoSPolicyIntServVariable\"\n   This is a concrete class
      that contains the Integrated Service\n   requested in the RSVP Reservation message,
      as defined in the FLOWSPEC\n   RSVP Object [RSVP].  The class definition is
      as follows:\n   NAME           QoSPolicyRSVPIntServVariable\n   DESCRIPTION
      \   The integrated Service requested in the RSVP\n                  Reservation
      message, as defined in the FLOWSPEC RSVP\n                  Object [RSVP].\n
      \                ALLOWED VALUE TYPES: PolicyIntegerValue (An enumerated\n                                      value
      of { CL=1 , GS=2, NULL=3}\n   DERIVED FROM   QoSPolicyRSVPVariable (defined
      in this document)\n   ABSTRACT       FALSE\n   PROPERTIES     None\n"
    title: 8.24.  The Class "QoSPolicyIntServVariable"
  - contents:
    - "8.25.  The Class \"QoSPolicyRSVPMessageTypeVariable\"\n   This is a concrete
      class that contains the RSVP message type, as\n   defined in the RSVP message
      common header [RSVP] object.  The class\n   definition is as follows:\n   NAME
      \         QoSPolicyRSVPMessageTypeVariable\n   DESCRIPTION   The RSVP message
      type, as defined in the RSVP message\n                 common header [RSVP]
      object.\n                 ALLOWED VALUE TYPES: Integer (An enumerated value
      of\n                                       {PATH=1 , PATHTEAR=2, RESV=3,\n                                        RESVTEAR=4,
      RESVERR=5, CONF=6,\n                                        PATHERR=7}\n   DERIVED
      FROM  QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT      FALSE\n
      \  PROPERTIES    None\n"
    title: 8.25.  The Class "QoSPolicyRSVPMessageTypeVariable"
  - contents:
    - "8.26.  The Class \"QoSPolicyRSVPPreemptionPriorityVariable\"\n   This is a
      concrete class that contains the RSVP reservation priority,\n   as defined in
      [RFC3181] object.  The class definition is as follows:\n   NAME          QoSPolicyRSVPPreemptionPriorityVariable\n
      \  DESCRIPTION   The RSVP reservation priority as defined in [RFC3181].\n                 ALLOWED
      VALUE TYPES: PolicyIntegerValue\n   DERIVED FROM  QoSPolicyRSVPVariable (defined
      in this document)\n   ABSTRACT      FALSE\n   PROPERTIES    None\n"
    title: 8.26.  The Class "QoSPolicyRSVPPreemptionPriorityVariable"
  - contents:
    - "8.27.  The Class \"QoSPolicyRSVPPreemptionDefPriorityVariable\"\n   This is
      a concrete class that contains the RSVP reservation defending\n   priority,
      as defined in [RFC3181] object.  The class definition is as\n   follows:\n   NAME
      \         QoSPolicyRSVPPreemptionDefPriorityVariable\n   DESCRIPTION   The RSVP
      preemption reservation defending priority as\n                 defined in [RFC3181].\n
      \                ALLOWED VALUE TYPES: PolicyIntegerValue\n   DERIVED FROM  QoSPolicyRSVPVariable
      (defined in this document)\n   ABSTRACT      FALSE\n   PROPERTIES    None\n"
    title: 8.27.  The Class "QoSPolicyRSVPPreemptionDefPriorityVariable"
  - contents:
    - "8.28.  The Class \"QoSPolicyRSVPUserVariable\"\n   This is a concrete class
      that contains the ID of the user that\n   initiated the flow as defined in the
      User Locator string in the\n   Identity Policy Object [RFC3182].  The class
      definition is as\n   follows:\n   NAME          QoSPolicyRSVPUserVariable\n
      \  DESCRIPTION   The ID of the user that initiated the flow as defined\n                 in
      the User Locator string in the Identity Policy\n                 Object [RFC3182].\n
      \                ALLOWED VALUE TYPES: QoSPolicyDNValue,\n                                      PolicyStringValue,\n
      \                                     QoSPolicyAttributeValue\n   DERIVED FROM
      \ QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT      FALSE\n
      \  PROPERTIES    None\n"
    title: 8.28.  The Class "QoSPolicyRSVPUserVariable"
  - contents:
    - "8.29.  The Class \"QoSPolicyRSVPApplicationVariable\"\n   This is a concrete
      class that contains the ID of the application that\n   generated the flow as
      defined in the application locator string in\n   the Application policy object
      [RFC2872].  The class definition is as\n   follows:\n   NAME          QoSPolicyRSVPApplicationVariable\n
      \  DESCRIPTION   The ID of the application that generated the flow as\n                 defined
      in the application locator string in the\n                 Application policy
      object [RFC2872].\n                 ALLOWED VALUE TYPES: QoSPolicyDNValue,\n
      \                                     PolicyStringValue,\n                                      QoSPolicyAttributeValue\n
      \  DERIVED FROM  QoSPolicyRSVPVariable (defined in this document)\n   ABSTRACT
      \     FALSE\n   PROPERTIES    None\n"
    title: 8.29.  The Class "QoSPolicyRSVPApplicationVariable"
  - contents:
    - "8.30.  The Class \"QoSPolicyRSVPAuthMethodVariable\"\n   This is a concrete
      class that contains the type of authentication\n   used in the Identity Policy
      Object [RFC3182].  The class definition\n   is as follows:\n   NAME          QoSPolicyRSVPAuthMethodVariable\n
      \  DESCRIPTION   The RSVP Authentication type used in the Identity\n                 Policy
      Object [RFC3182].\n                 ALLOWED VALUE TYPES: PolicyIntegerValue
      (An enumeration\n                                      of { NONE=0, PLAIN-TEXT=1,\n
      \                                     DIGITAL-SIG = 2, KERBEROS_TKT=3,\n                                      X509_V3_CERT=4,
      PGP_CERT=5}\n   DERIVED FROM  QoSPolicyRSVPVariable (defined in this document)\n
      \  ABSTRACT      FALSE\n   PROPERTIES    None\n"
    title: 8.30.  The Class "QoSPolicyRSVPAuthMethodVariable"
  - contents:
    - "8.31.  The Class QoSPolicyDNValue\n   This class is used to represent a single
      or set of Distinguished Name\n   [DNDEF] values, including wildcards.  A Distinguished
      Name is a name\n   that can be used as a key to retrieve an object from a directory\n
      \  service. This value can be used in comparison to reference values\n   carried
      in RSVP policy objects, as specified in [RFC3182].  The class\n   definition
      is as follows:\n   NAME           QoSPolicyDNValue\n   DERIVED FROM   PolicyValue\n
      \  ABSTRACT       FALSE\n   PROPERTIES     qpDNList\n"
    - contents:
      - "8.31.1.  The Property qpDNList\n   This attribute provides an unordered list
        of strings, each\n   representing a Distinguished Name (DN) with wildcards.
        \ The format of\n   a DN is defined in [DNDEF].  The asterisk character (\"*\")
        is used as\n   wildcard for either a single attribute value or a wildcard
        for an\n   RDN.  The order of RDNs is significant.  For example: A qpDNList\n
        \  attribute carrying the following value:\n      \"CN=*, OU=Sales, O=Widget
        Inc., *, C=US\" matches:\n      \"CN=J. Smith, OU=Sales, O=Widget Inc, C=US\"\n
        \  and also matches:\n      \"CN=J. Smith, OU=Sales, O=Widget Inc, L=CA, C=US\".\n
        \  The attribute is defined as follows:\n   NAME     qpDNList\n   SYNTAX   List
        of Distinguished Names implemented as strings, each of\n            which
        serves as a reference to another object.\n"
      title: 8.31.1.  The Property qpDNList
    title: 8.31.  The Class QoSPolicyDNValue
  - contents:
    - "8.32.  The Class QoSPolicyRSVPSimpleAction\n   This action controls the content
      of RSVP messages and the way RSVP\n   requests are admitted.  Depending on the
      value of its\n   qpRSVPActionType property, this action directly translates
      into\n   either a COPS Replace Decision or a COPS Stateless Decision, or both\n
      \  as defined in COPS for RSVP.  Only variables that are subclasses of\n   the
      QoSPolicyRSVPVariable are allowed to be associated with this\n   action.  The
      property definition is as follows:\n   NAME          QoSPolicyRSVPSimpleAction\n
      \  DESCRIPTION   This action controls the content of RSVP messages and\n                 the
      way RSVP requests are admitted.\n   DERIVED FROM  SimplePolicyAction (defined
      in [PCIMe])\n   ABSTRACT      FALSE\n   PROPERTIES    qpRSVPActionType\n"
    - contents:
      - "8.32.1.  The Property qpRSVPActionType\n   This property is an enumerated
        integer denoting the type(s) of RSVP\n   action.  The value 'REPLACE' denotes
        a COPS Replace Decision action.\n   The value 'STATELESS' denotes a COPS Stateless
        Decision action.  The\n   value REPLACEANDSTATELESS denotes both decision
        actions.  Refer to\n   [RFC2749] for details.\n   NAME          qpRSVPActionType\n
        \  DESCRIPTION   This property specifies whether the action type is for\n
        \                COPS Replace, Stateless, or both types of decisions.\n   SYNTAX
        \       Integer\n   VALUE         This is an enumerated integer.  A value
        of 0 specifies\n                 a COPS Replace decision.  A value of 1 specifies
        a COPS\n                 Stateless Decision.  A value of 2 specifies both
        COPS\n                 Replace and COPS Stateless decisions.\n"
      title: 8.32.1.  The Property qpRSVPActionType
    title: 8.32.  The Class QoSPolicyRSVPSimpleAction
  title: '8.  Class Definitions: Inheritance Hierarchy'
- contents:
  - "9.  Intellectual Property Rights Statement\n   The IETF takes no position regarding
    the validity or scope of any\n   intellectual property or other rights that might
    be claimed to\n   pertain to the implementation or use of the technology described
    in\n   this document or the extent to which any license under such rights\n   might
    or might not be available; neither does it represent that it\n   has made any
    effort to identify any such rights.  Information on the\n   IETF's procedures
    with respect to rights in standards-track and\n   standards-related documentation
    can be found in BCP-11.\n   Copies of claims of rights made available for publication
    and any\n   assurances of licenses to be made available, or the result of an\n
    \  attempt made to obtain a general license or permission for the use of\n   such
    proprietary rights by implementers or users of this\n   specification can be obtained
    from the IETF Secretariat.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights which may cover technology that may be required to practice\n
    \  this standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 9.  Intellectual Property Rights Statement
- contents:
  - "10.  Acknowledgements\n   The authors wish to thank the input of the participants
    of the Policy\n   Framework working group, and especially the combined group of
    the\n   PCIMe coauthors, Lee Rafalow, Andrea Westerinen, Ritu Chadha and\n   Marcus
    Brunner.  In addition, we'd like to acknowledge the valuable\n   contribution
    from Ed Ellesson, Joel Halpern and Mircea Pana.  Thank\n   you all for your comments,
    critique, ideas and general contribution.\n"
  title: 10.  Acknowledgements
- contents:
  - "11.  Security Considerations\n   The Policy Core Information Model [PCIM] describes
    the general\n   security considerations related to the general core policy model.\n
    \  The extensions defined in this document do not introduce any\n   additional
    considerations related to security.\n"
  title: 11.  Security Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [KEYWORDS] Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [PCIM]     Moore, B., Ellesson, E., Strassner, J. and A. Westerinen,\n
      \             \"Policy Core Information Model -- Version 1\n              Specification\",
      RFC 3060, February 2001.\n   [PCIMe]    Moore, B., Ed., \"Policy Core Information
      Model\n              Extensions\", RFC 3460, January 2003.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [TERMS]    Westerinen, A., Schnizlein, J.,
      Strassner, J., Scherling,\n              M., Quinn, B., Herzog, S., Huynh, A.,
      Carlson, M., Perry,\n              J. and M. Waldbusser, \"Terminology for Policy-based\n
      \             Management\", RFC 3198, November 2001.\n   [DIFFSERV] Blake, S.,
      Black, D., Carlson, M., Davies, E., Wang, Z.\n              and W. Weiss, \"An
      Architecture for Differentiated\n              Services\", RFC 2475, December
      1998.\n   [INTSERV]  Braden, R., Clark, D. and S. Shenker, \"Integrated Services\n
      \             in the Internet Architecture: an Overview\", RFC 1633, June\n
      \             1994.\n   [RSVP]     Braden, R., Ed., Zhang, L., Berson, S.,  Herzog,
      S. and S.\n              Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version
      1\n              Functional Specification\", RFC 2205, September 1997.\n   [RFC2749]
      \ Herzog, S., Ed., Boyle, J., Cohen, R., Durham, D., Rajan,\n              R.
      and A. Sastry, \"COPS usage for RSVP\", RFC 2749, January\n              2000.\n
      \  [RFC3181]  Herzog, S., \"Signaled Preemption Priority Policy Element\",\n
      \             RFC 3181, October 2001.\n   [DIFF-MIB] Baker, F., Chan, K. and
      A. Smith, \"Management Information\n              Base for the Differentiated
      Services Architecture\", RFC\n              3289, May 2002.\n   [AF]       Heinanen,
      J., Baker, F., Weiss, W. and J. Wroclawski,\n              \"Assured Forwarding
      PHB Group\", RFC 2597, June 1999.\n   [CL]       Wroclawski, J., \"Specification
      of the Controlled-Load\n              Network Element Service\", RFC 2211, September
      1997.\n   [RSVP-IS]  Wroclawski, J., \"The Use of RSVP with IETF Integrated\n
      \             Services\", RFC 2210, September 1997.\n   [GS]       Shenker,
      S., Partridge, C. and R. Guerin, \"Specification\n              of the Guaranteed
      Quality of Service\", RFC 2212, September\n              1997.\n   [DCLASS]
      \  Bernet, Y., \"Format of the RSVP DCLASS Object\", RFC 2996,\n              November
      2000.\n   [RFC3182]  Yadav, S., Yavatkar, R., Pabbati, R., Ford, P., Moore,
      T.,\n              Herzog, S. and R. Hess, \"Identity Representation for\n              RSVP\",
      RFC 3182, October 2001.\n   [RFC2872]  Bernet, Y. and R. Pabbati, \"Application
      and Sub\n              Application Identity Policy Element for Use with RSVP\",\n
      \             RFC 2872, June 2000.\n   [DNDEF]    Wahl, M., Kille, S. and T.
      Howes, \"Lightweight Directory\n              Access Protocol (v3): UTF-8 String
      Representation of\n              Distinguished Names\", RFC 2253, December 1997.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "13.  Authors' Addresses\n   Yoram Ramberg\n   Cisco Systems\n   4 Maskit Street\n
    \  Herzliya Pituach, Israel  46766\n   Phone:  +972-9-970-0081\n   Fax:    +972-9-970-0219\n
    \  EMail:  yramberg@cisco.com\n   Yoram Snir\n   Cisco Systems\n   300 East Tasman
    Drive\n   San Jose, CA 95134\n   Phone:  +1 408-853-4053\n   Fax:    +1 408 526-7864\n
    \  EMail:  ysnir@cisco.com\n   John Strassner\n   Intelliden Corporation\n   90
    South Cascade Avenue\n   Colorado Springs, Colorado  80903\n   Phone:  +1-719-785-0648\n
    \  Fax:    +1-719-785-0644\n   EMail: john.strassner@intelliden.com\n   Ron Cohen\n
    \  Ntear LLC\n   Phone: +972-8-9402586\n   Fax:   +972-9-9717798\n   EMail: ronc@lyciumnetworks.com\n
    \  Bob Moore\n   IBM Corporation\n   P. O. Box 12195, BRQA/501/G206\n   3039 Cornwallis
    Rd.\n   Research Triangle Park, NC 27709-2195\n   Phone:   +1 919-254-4436\n   Fax:
    \    +1 919-254-6243\n   EMail: remoore@us.ibm.com\n"
  title: 13.  Authors' Addresses
- contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assignees.\n   This document and the
    information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET
    SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES,
    EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE
    OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 14.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
