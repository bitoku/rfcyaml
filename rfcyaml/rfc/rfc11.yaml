- title: __initial_text__
  contents:
  - "                   Implementation of the Host - Host\n                      Software\
    \ Procedures in GORDO\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   Chapter                                               \
    \         Page\n   1.  Introduction . . . . . . . . . . . . . . . . . . . . .\
    \ . .   1\n   2.  HOST - HOST Procedures . . . . . . . . . . . . . . . . . . \
    \  2\n       2.1  Generalities  . . . . . . . . . . . . . . . . . . . .   2\n\
    \       2.2  Connections and Links . . . . . . . . . . . . . . . .   2\n     \
    \       2.2.1  Definitions  . . . . . . . . . . . . . . . . .   2\n          \
    \  2.2.2  Connection types . . . . . . . . . . . . . . .   3\n       2.3  Message\
    \ Structure . . . . . . . . . . . . . . . . . .   5\n       2.4  User Transactions\
    \ . . . . . . . . . . . . . . . . . .   6\n            2.4.1  List of transactions\
    \   . . . . . . . . . . . .   7\n            2.4.2  HOST-HOST protocol and control\
    \ messages  . . .   8\n   3.  Implementation in GORDO  . . . . . . . . . . . .\
    \ . . . . .  11\n       3.1  Introduction to GORDO . . . . . . . . . . . . . .\
    \ . .  11\n            3.1.1  GORDO file system  . . . . . . . . . . . . . . \
    \ 11\n            3.1.2  GORDO process  . . . . . . . . . . . . . . . .  12\n\
    \       3.2  Software Organization Overview  . . . . . . . . . . .  12\n     \
    \  3.3  Software Description  . . . . . . . . . . . . . . . .  13\n          \
    \  3.3.1  Data structures  . . . . . . . . . . . . . . .  13\n               \
    \    3.3.1.1  Allocation tables . . . . . . . . . .  13\n                   3.3.1.2\
    \  Buffer pages  . . . . . . . . . . . .  16\n            3.3.2  Programs . .\
    \ . . . . . . . . . . . . . . . . .  18\n                   3.3.2.1  Handler .\
    \ . . . . . . . . . . . . . .  18\n                   3.3.2.2  Network . . . .\
    \ . . . . . . . . . . .  19\n       3.4  Software Procedures . . . . . . . . .\
    \ . . . . . . . .  20\n            3.4.1  Description of some typical sequences\
    \  . . . .  20\n   Appendix A:  Flowcharts  . . . . . . . . . . . . . . . . .\
    \ . .  23\n   [[RFC Editor Note: [s] represents subscript s]]\n"
- title: 1.  INTRODUCTION
  contents:
  - "1.  INTRODUCTION\n   This technical note concentrates upon (1) the HOST-HOST\
    \ procedures\n   and (2) the implementation of the corresponding programs in GORDO\n\
    \   (Operating System of the UCLA HOST).\n   The first section is closely related\
    \ to the BBN reports No. 1822 and\n   1763[1] and specifies the HOST functions\
    \ for exchanging messages.  It\n   mostly deals with links and connections, message\
    \ structure,\n   transactions, and control messages.\n   The second section is\
    \ software oriented; it explains how the HOST\n   functions are implemented and\
    \ integrated into GORDO.  It is involved\n   with data structures, programs, buffers,\
    \ interrupt processing, etc.\n   [1]  Parts of this section are taken from or\
    \ referred to those\n   reports.\n"
- title: 2.  HOST-HOST PROCEDURES
  contents:
  - '2.  HOST-HOST PROCEDURES

    '
- title: 2.1  Generalities
  contents:
  - "2.1  Generalities\n   The basic idea is that several users, at a given HOST,\
    \ should\n   simultaneously be able to utilize the network by time-sharing its\n\
    \   physical facilities.\n   This implies that within each HOST operating system,\
    \ there must exist\n   a special program that multiplexes outgoing messages from\
    \ the users\n   into the network and distributes incoming messages to the appropriate\n\
    \   users.  We will call this special program the Network program.\n"
- title: 2.2  Links and Connections  (See figure 1)
  contents:
  - "2.2  Links and Connections  (See figure 1)\n   2.2.1  Definitions\n   It is convenient\
    \ to consider the Network as a black box - a system\n   whose behavior is known\
    \ but whose mechanisms are not - for\n   communicating messages between remote\
    \ users rather than between pairs\n   of HOST computers.\n      (a)  Logical connections\n\
    \         We define a logical connection as being a communication path\n     \
    \    linking two users at remote HOST[s].\n         With that concept, a user\
    \ (user program) in a HOST computer can\n         (1) establish several logical\
    \ connections to any remote HOST\n         users, and (2) send or receive messages\
    \ over those connections.\n         Connections appear to users as full duplex.\n\
    \         One of the purposes of the Network program is to serve the\n       \
    \  users in establishing, identifying, and maintaining these\n         connections.\n\
    \      (b)  Logical links\n         Each logical connection is made of a pair\
    \ of directional links:\n         one for transmitting, the other for receiving.\n\
    \         Those links, called logical links, are established by the\n        \
    \ Network programs and used by them.\n         Note here that users are only interested\
    \ in connections and are\n         completely unaware of links.  Relationships\
    \ between links and\n         connections are carried out by the Network program.\n\
    \         One of the advantages to define a connection as a pair of\n        \
    \ directional links is that a HOST will have the capability to\n         loop\
    \ himself through its IMP (it opens a connection to\n         himself).  This\
    \ feature can be useful for debugging purposes.\n         Further on through this\
    \ paper we will not use any more the\n         attribute logical when referring\
    \ either to links or\n         connections.\n   2.2.2  Connection types\n   In\
    \ order to reach a high flexibility in utilizing the Network there\n   is advantage\
    \ to classify the connections.\n   Three types of connections are distinguished:\
    \  (a) control\n   connection, (b) primary connection, and (c) auxiliary connection.\n\
    \      (a)  Control connection\n      This connection has a special status and\
    \ is unique between a pair\n      of HOST[s], e.g., if the Network includes x\
    \ HOST[s], there are at\n      most x control connections issued from one HOST.\n\
    \      This connection is used by remote Network programs for passing\n      control\
    \ messages back and forth.  Control messages are basic to\n      the establishment/deletion\
    \ of standard connections.  (See 2.4.2)\n      Note here that this control connection\
    \ is the only connection\n      which is not used by the HOST users.\n      Let\
    \ us describe now the standard connections.\n      (b)  Primary connection\n \
    \     These connections connect remote users.\n      A primary connection:\n \
    \           * Is unique between a pair of users and is the first to be\n     \
    \          established.\n            * Is \"teletype-like\", i.e.:\n         \
    \      - ASCII characters are transmitted;\n               - Echoes are generated\
    \ by the remote HOST;\n               - The receiving HOST[s] scan for break characters;\n\
    \               - The transmission rate is slow (less than 20\n              \
    \ characters/sec).\n            * Is mainly used for transmitting control commands,\
    \ e.g.,\n               for log-in into a remote HOST operating system.\n    \
    \  (c) Auxiliary connection\n         These connections also connect remote users:\n\
    \         An auxiliary connection:\n            * Is opened in parallel to a primary\
    \ connection and is not\n               unique, i.e., several auxiliary connections\
    \ can be\n               established between users.\n            * Is used for\
    \ transmitting large volumes of data (file\n               oriented).\n      \
    \      * Is used either for binary or character transmission.\n             [Figure\
    \ 1 - Links and Connections - see PDF file]\n"
- title: 2.3  Message Structure
  contents:
  - "2.3  Message Structure\n   The HOST[s] communicate with each other via messages.\
    \  A message may\n   vary in length up to 8095 bits (See down below the structure).\n\
    \   Larger transmission must therefore be broken up by HOST users into a\n   sequence\
    \ of such messages.\n      A message structure is identified on figure 2.\n  \
    \    It includes the following:\n      (1) A leader (32 bits): Message type, Source/Destination\
    \ HOST,\n          link number.  (See BBN report No. 1822, pp 13, 17)\n      (2)\
    \ A marketing (32 bits when sent by the Sigma 7) for starting a\n          message\
    \ text on a word boundary.  (See BBN report No. 1822,\n          pp. 17, 19)\n\
    \      (3) The message text (Max: 8015 bits for the Sigma 7).  It mostly\n   \
    \       consists of user's text.  However, it may represent\n          information\
    \ for use by the Network programs.  (Control\n          messages, see 2.4.2)\n\
    \      (4) A checksum (16 bits).  Its purpose is to check, at the HOST\n     \
    \     level, the right transmission of a message.  (Changes in bit\n         \
    \ pattern or packet transposition; packets are defined in BBN\n          report\
    \ No. 1763, p. 13)  See down below for checksum\n          calculation.\n    \
    \  (5) A padding for solving word length mismatch problems.  (See BBN\n      \
    \    report No. 1822, p. 17, 19.).  As far as software is\n          concerned,\
    \ padding is only involved at message reception for\n          delineating message\
    \ ends.  (At transmission the hardware takes\n          care of the padding.)\n\
    \   Remark:\n      Checksum calculation:\n      The last 16 bits of every message\
    \ sent by a HOST is a checksum.\n      This checksum is computed on the whole\
    \ message including any\n      marking, but excluding the 32 bit leader and any\
    \ padding.  To\n      compute the checksum:\n      1.  Consider the message to\
    \ be padded with zeroes to a length of\n          8640 bits.\n      2.  Section\
    \ the 8640 bits into six 1440-bit segments, S0, S1...S5.\n      3.  Section each\
    \ 1440-bit segment S into 90 16-bit elements, T0,\n          T1...T89.\n     \
    \ 4.  Define a function [(+)], which takes two 16-bit elements as\n          inputs\
    \ and outputs a 16-bit element.  This function is defined\n          by\n    \
    \      Tm [(+)] Tn = Tm [(+)] Tn, if Tm + Tn < 2[exp 16]\n          Tm [(+)] Tn\
    \ = Tm [(+)] Tn - 2[exp 16] + 1, if Tm + Tn >= 2[exp\n          16]\n      5.\
    \  For each 1440-bit segment Si compute Ci = K(Si), where\n          K(S) = T0\
    \ [(+)] T1 + ..... T89\n      6.  Computer C =\n          C0[(+)]C1[(+)]C1[(+)]C2[(+)]C2[(+)]C2[(+)]C2....[(+)]C5\n\
    \          (Notice that C1[(+)]C1 is just C1 rotated left one bit)\n   The number\
    \ C is the checksum.  The reason the Ci are rotated by i\n   bits is to detect\
    \ packet transposition.\n    [Figure 2 - Format of a message sent by the Sigma\
    \ 7 - see PDF file]\n"
- title: 2.4  User Transactions
  contents:
  - "2.4  User Transactions\n   From what has been discussed until here, the Network\
    \ appears to a\n   user as a bunch of connections.  Let us now explain how one\
    \ can make\n   use of these connections.\n   First, we are going to describe the\
    \ set of transactions that a user\n   should be able to access for utilizing the\
    \ connection facilities.\n   Then, we are going to explain the role of the Network\
    \ program for the\n   execution of these transactions.  This will cover a HOST-HOST\n\
    \   protocol in which control messages are exchanged between network\n   programs.\n\
    \   For explanation purposes those transactions are represented, at the\n   user\
    \ level, in the form of subroutine calls and parameters.  However,\n   this does\
    \ not imply at all that the implementation will closely\n   follow this pattern.\
    \  (We are more involved here with the description\n   than the implementation\
    \ aspect, see chapter 3.)\n   2.4.1  List of transactions\n   Listed below are\
    \ the descriptions of subroutines that could be at\n   user's disposal for creating/breaking\
    \ connections and\n   transmitting/receiving data over them.  This set of subroutines\
    \ can\n   be considered as a kind of interface between the user level and the\n\
    \   network program level.\n   (a)  Open primary connection:\n        OPENPRIM\
    \ (CONNECTID, HOSTID, BUFFADDR, [OPT])\n        CONNECTID:  Connection identification\
    \ #\n        HOSTID:  Remote HOST identification #\n        BUFFADDR:  Buffer\
    \ address for incoming messages.\n        OPT:  Options such as message required\
    \ after successful\n              connection establishment, \"full echo\" (each\
    \ message is\n              transmitted back by the remote HOST for checking purpose),\n\
    \              etc.\n        Remark: [  ] means optional\n   (b) Open auxiliary\
    \ connection\n        OPENAUX (CONNECTID, BUFFADDR, N, [OPT])\n        CONNECTID:\
    \  Connection identification #, i.e., the\n                    identification\
    \ of the corresponding primary\n                    connection (First a user has\
    \ to open a primary\n                    connection).\n        BUFFADDR:  Same\
    \ meaning as above.\n        N:  Number of auxiliary connections that should be\
    \ opened.\n        OPT:  Same meaning as above.\n   (c)  Transmission over connection\n\
    \        TRANSM (CONNECTID, NO, BUFFADDR, N, [OPT])\n        CONNECTID:  Connection\
    \ identification #\n        NO:  Connection #.  The primary connection is always\
    \ referred to\n             as being NO=0.  An auxiliary connection number corresponds\n\
    \             to the order in which it has been established.  (The first\n   \
    \          auxiliary opened is referred to by NO=1, the second by\n          \
    \   NO=2, etc.)\n        BUFFADDR:  Buffer address of the message to be transmitted.\n\
    \        N:  Message size (byte number)\n        OPT:  Options such as data type\
    \ (characters vs. binary), trace\n              bit, etc.\n   (d)  Close connection\n\
    \        CLOSE (CONNECTID, [N], [NO])\n        CONNECTID: Connection identification\
    \ #.\n        N:  Number of connections to be closed.  If omitted all\n      \
    \      connections in use by the user, included the primary link,\n          \
    \  are closed.\n        NO:  In case of N different from zero this number indicates\
    \ the\n             auxiliary connection # to be closed.\n   2.4.2  HOST-HOST\
    \ protocol and control messages\n   The HOST-HOST protocol is carried out by the\
    \ Network programs.  It\n   mainly involves the execution of the previous transactions\
    \ (initiated\n   by users) and covers a HOST-HOST dialogue.\n   This dialogue\
    \ fulfills control procedures for opening or breaking\n   connections and consists\
    \ in exchanging control messages over the\n   control link.  A control message\
    \ has a structure identical to that of\n   a regular message; it only differs\
    \ from it by the text which is for\n   use by Network programs instead of users.\n\
    \   Let us insist that this control procedure is completely unrelated to\n   transmission\
    \ control procedures implemented in the IMP computers.  We\n   are here at the\
    \ HOST level (Network programs), and therefore control\n   messages, that are\
    \ going to be described below, are transmitted over\n   the IMP[s] like regular\
    \ messages.\n   Consider now the previous transactions and describe for each of\
    \ them\n   which messages are exchanged over which links.  Each case will be\n\
    \   explained by means of trivial examples.\n   We suppose that a HOST(x) user\
    \ wants to a remote HOST(y) program\n   called URSA.\n      (a)  Open a primary\
    \ connection: (OPENPRIM)\n      The HOST (x)'s Network program, waken up (See\
    \ 3.3) by a use for\n      opening a primary connection, starts a dialogue with\
    \ the HOST\n      (y)'s Network program.\n        (i)  HOST(x) sends the following\
    \ control message:\n             HOST(x)       Control link                  \
    \    HOST(y)\n                         -------------------->\n               \
    \            ENQ PRIM 0 1 2\n             ENQ:     Enquiry for connection establishment\
    \ (one ASCII\n                      character)\n             PRIM:    Connection\
    \ type: primary (one special character)\n             0 1 2:   Outgoing link #.\
    \  It is a decimal number (3 ASCII\n                      characters), e.g., link\
    \ #12.\n                      This link # has been determined by the HOST(x)\n\
    \                      Network program (See implementation: 3.3)\n        (ii)\
    \ HOST(y) acknowledges by sending back the following control\n               \
    \       message:\n             HOST(x)        Control link                   \
    \  HOST(y)\n                         <------------------------\n             \
    \             ACK ENQ PRIM 0 1 2 0 1 5\n             ACK:     Positive acknowledgment\
    \ (one ASCII character)\n             ENQ PRIM 0 1 2:  Same meaning as above.\
    \  This part of the\n                      message is returned for checking purposes.\n\
    \             0 1 5:   Incoming link #.  It follows the same pattern as\n    \
    \                  the outgoing link #.  This link # has been\n              \
    \        determined by the HOST(y) Network program.\n                      Now\
    \ the connection is established; it will use\n                      links #12\
    \ and 15 for exchanging user messages.\n                      The connection is\
    \ said to be in a pre-log-in\n                      state, i.e., the remote HOST(y)\
    \ expects its\n                      standard log-in procedures.\n      (b)  Transmission\
    \ over primary connection: (TRANSM)\n         By means of TRANSM subroutines referring\
    \ to the primary\n         connection, the HOST(x) user is able to sign-in into\
    \ the\n         HOST(y) operating system and then to call for the URSA program\n\
    \         (HOST(y) user program).\n         The Network programs at both ends\
    \ will use the link #12 and #15\n         for passing along messages.  These messages\
    \ are standard\n         messages whose contents serve for log in sequence.\n\
    \         A trivial example could be:\n             HOST(x)     Prim. Link #12\
    \                       HOST(y)\n                         ---------------------------->\n\
    \                         ! S I G N - I N : X X\n             HOST(x)     Prim.\
    \ Link #15                       HOST(y)\n                         <--------------------------\n\
    \                         ! ! R E A D Y\n             HOST(x)     Prim. Link #12\
    \                       HOST(y)\n                         ---------------------------->\n\
    \                           ! U R S A\n      (c)  Open an auxiliary connection:\
    \ (OPENAUXI)\n         In a very similar manner as (a) an auxiliary connection\
    \ is\n         established between HOST(x) and HOST(y).  For so doing control\n\
    \         messages are exchanged over the control link.\n             HOST(x)\
    \           Control link                  HOST(y)\n                         ------------------------------>\n\
    \                               ENQ AUX 0 2 5\n             HOST(x)          \
    \ Control link                  HOST(y)\n                         <--------------------------------\n\
    \                             ACK ENQ AUX 0 2 5 0 2 1\n         Now the auxiliary\
    \ connection is established, it will use links\n         #25 and 21 for exchanging\
    \ standard messages.\n      (d)  Transmission over auxiliary connection: (TRANSM)\n\
    \         By means of TRANSM subroutines referring to the auxiliary\n        \
    \ connection, the users at both ends can exchange data:\n             HOST(x)\
    \        Aux. Link #25                    HOST(y)\n                         -------------------------------->\n\
    \                               X X ..... X X\n             HOST(x)         Aux.\
    \ Link #21                   HOST(y)\n                         <--------------------------------\n\
    \                             X ......... X\n         etc.......\n      (e)  Close\
    \ connections: (CLOSE)\n         This is carried out in a similar manner as (a).\
    \  The user calls\n         a CLOSE subroutine and then the Network programs at\
    \ both ends\n         exchange control messages.\n             HOST(x)       \
    \    Control Link                  HOST(y)\n                         ----------------------------->\n\
    \                               EOT 0 0 1 0 1 2\n             EOT:     End of\
    \ transmission (one ASCII character)\n             0 0 1 :  No. of connections\
    \ to be closed (3 decimal ASCII\n                       characters)\n        \
    \     0 1 2 :  Outgoing link # to be closed.\n             Then HOST(y) acknowledges\
    \ back as in (a).\n             HOST(x)           Control Link               \
    \   HOST(y)\n                         <-----------------------------\n       \
    \                     ACK EOT 0 0 1 0 1 2 0 1 5\n         Remark 1 - In (a), (c),\
    \ and (e) HOST(y) may answer back a\n         message including a negative acknowledgement\
    \ character NAK\n         instead of ACK.  This for many various reasons such\
    \ as: wrong\n         sequence, connection already opened, and so forth.  The\
    \ message\n         could be NAK IND, where IND is an alphanumerical character\n\
    \         indicating, in a coded form, why the previous block has been\n     \
    \    refused.  Upon receiving back such acknowledgments HOST(x) will\n       \
    \  repeat its message until HOST(y) accepts it.  An emergency\n         procedure\
    \ will take place if too many successive \"NAK messages\"\n         occur.\n \
    \        Remark 2 - On each of the above illustrations (arrows) only the\n   \
    \      message text is represented.  In fact, complete messages (with\n      \
    \   leader, marking, padding...) are exchanged over these links.\n"
- title: 3.  IMPLEMENTATION IN GORDO
  contents:
  - '3.  IMPLEMENTATION IN GORDO

    '
- title: 3.1  Introduction to GORDO
  contents:
  - "3.1  Introduction to GORDO\n   GORDO is a time-sharing system implemented on\
    \ SDS Sigma 7.  We\n   outline below some of the characteristics relevant to our\
    \ paper.\n   3.1.1  GORDO file system\n   The file system is page oriented.  It\
    \ is composed of files and\n   directories.  A file consists of a heading and\
    \ a number of pages\n   which compose the body of the file.  A directory consists\
    \ of a number\n   of entries that point to either files or other directories.\n\
    \   3.1.2  GORDO process\n   *  A process is a program (procedures and data) plus\
    \ its logical\n      environment.  In other words a process is a program which\
    \ is known\n      and controlled by the GORDO scheduler.\n   *  A user (a job)\
    \ may have several processes as different as\n      compiler, loader, editor,\
    \ application program, etc.  A process is\n      created through a system call\
    \ (FORK).\n   *  The space a process can refer to is the Virtual Space of 128k\
    \ word\n      length.  A part (8k) of it is reserved for the operating system,\n\
    \      the other part (120k) is directly accessed by the user.  This\n      later\
    \ may fill or modify its part of the virtual space upon\n      'coupling'.  (See\
    \ below: service calls) pages taken from different\n      files.  Figure 3 illustrates\
    \ this coupling.\n   *  A process can request for services by means of system\
    \ calls.  The\n      system calls relevant to our paper are:\n         WAKE  \
    \  for awaking (set active) a sleeping process\n         SLEEP   for putting asleep\
    \ another process (or itself)\n         COUPLE  for coupling a page from the file\
    \ space to the virtual\n                 space.\n   *  A process ordinarily runs\
    \ in slave mode.  However if it is set up\n      as an I/O process it can access\
    \ privileged instructions.\n   *  Processes can share data through files attached\
    \ to \"mail box\"\n      directories.\n   Remark:  Through this note the words\
    \ process and program are used\n   inter-changeably.\n          [Figure 3 - Virtual\
    \ Space and Coupling - see PDF file]\n"
- title: 3.2  Software Organization Overview
  contents:
  - "3.2  Software Organization Overview\n   Figure 4 illustrates the overall organization.\n\
    \   The system is based upon two main programs: the \"Network\" and the\n   \"\
    Handler\".\n   The Handler is an I/O interrupt routine closely related to the\
    \ IMP-\n   HOST hardware interface.  It serves the Network process in\n   transmitting\
    \ an receiving network messages.\n   The Network process carries out most of the\
    \ work.\n   Its main function is to satisfy the users' requests for opening/\n\
    \   closing connections and transmitting/receiving network messages.  For\n  \
    \ so doing,\n   *  it establishes, identifies, and breaks the links upon using\
    \ the\n      allocation tables (HOST, CONNECT, INPUT LINK; see 3.3.1.1)\n   *\
    \  it is aware of the presence of new users upon exploring the\n      Network\
    \ mail box directory;\n   *  it communicates with active users by means of shared\
    \ pages through\n      which messages and requests are exchanged (connection shared\n\
    \      pages);\n   *  it formats incoming/outgoing messages in a working page.\
    \  This\n      working page has an extension (emergency ring);\n   *  it communicates\
    \ with the Handler by means of a shared page (I/O\n      communication page) which\
    \ contains the I/O communication buffers.\n        [Figure 4 - Software organization\
    \ overview - see PDF file]\n"
- title: 3.3  Software Description
  contents:
  - '3.3  Software Description

    '
- title: 3.3.1  Data Structures
  contents:
  - "3.3.1  Data Structures\n   3.3.1.1  Allocation tables: HOST, CONNECT, INPUT LINK\n\
    \      The Network program establishes, identifies, and breaks links and\n   \
    \   connections upon using 3 tables:\n      A table sorted by remote HOST #.\n\
    \      A table sorted by connection #.\n      A table sorted by input link #.\n\
    \        (a) HOST table (see figure 5)\n            It is a bit table indicating\
    \ the free outgoing links.  It\n            has the following characteristics:\n\
    \            *  Location: Disc resident\n            *  Coupling: Coupled to the\
    \ Network process virtual space.\n            *  Size:  As many slots as remote\
    \ HOST[s].\n            *  Slot structure: As many bits as possible outgoing links\n\
    \                               to a remote HOST, i.e., 256.\n            *  Access:\
    \ Indexing.  Each slot is accessed through a remote\n                       HOST\
    \ #.\n            *  Specific feature:  Throughout the whole table no more\n \
    \                                 than 64 bits can be turned on.  This\n     \
    \                             figure corresponds to the maximum\n            \
    \                      number of outgoing links that can be\n                \
    \                  activated at one time (No matter what\n                   \
    \               is the number of remote HOST[s]).\n        (b)  CONNECT table\n\
    \            This table keeps track of all the connections' environment.\n   \
    \         It has the following characteristics:\n            *  Location:  Disc\
    \ resident\n            *  Coupling:  Couples to the Network process virtual space\n\
    \            *  Size:  As many slots as connections in use.\n            *  Slot\
    \ structure:  See figure 6.  Each slot is 2 word\n                           \
    \     length\n            *  Access:  Indexing.  Each slot is accessed through\
    \ a\n                        connection #.  See 3.4 the way it is handled.\n \
    \           *  Specific feature 1:  The slot structure corresponding to\n    \
    \                                a primary connection is not\n               \
    \                     identical to that of an auxiliary\n                    \
    \                connection (See figure 7).  This\n                          \
    \          because user identifications and\n                                \
    \    requests are done through primary\n                                    shared\
    \ pages.\n            *  Specific feature 2:  This table is handled in parallel\n\
    \                                    with the connection pages (See 3.3.2\n  \
    \                                  (b))\n            *  Specific feature 3:  This\
    \ table is mainly used for\n                                    transmitting messages.\
    \  (For each\n                                    connection it contains the outgoing\n\
    \                                    link # and remote HOST #, i.e., all\n   \
    \                                 the information required for\n             \
    \                       transmitting a message.)\n        (c)  INPUT LINK table\n\
    \            This table keeps track of all the incoming (input) links and\n  \
    \          so is closely related to the CONNECT table.\n                  [Figure\
    \ 5 - HOST table - see PDF file]\n         [Figure 6 - CONNECT table: Slot structure\
    \ - see PDF file]\n       [Figure 7 - INSERT LINK table: Slot structure - see\
    \ PDF file]\n   It has the following characteristics:\n   *  Location:  Disc resident.\n\
    \   *  Coupling:  Coupled to the Network process virtual space.\n            *\
    \  Size:  As many slots as incoming links, i.e., as\n                      connections\n\
    \            *  Slot structure:  See figure 7.  Each slot is 1 word\n        \
    \                        length\n            *  Access:  Hashing.  The hashed\
    \ key value is mainly based\n                        upon the incoming link #\
    \ and the remote HOST #.\n            *  Specific feature 1:  This table is also\
    \ used for\n                                    momentarily memorizing the\n \
    \                                   connection number while establishing\n   \
    \                                 the next connection.  See 3.4 the\n        \
    \                            way it is handled.\n            *  Specific feature\
    \ 2:  This table is primarily used upon\n                                    receiving\
    \ messages.  (For each\n                                    incoming link it contains\
    \ the\n                                    corresponding connection #, i.e.,\n\
    \                                    indirectly the user identification\n    \
    \                                to which the message should be\n            \
    \                        passed along)\n      3.3.1.2  Buffer pages\n      All\
    \ the pages that are now to be described contain two buffers\n      (input and\
    \ output).  These buffers are used for either passing\n      along or processing\
    \ messages.\n      The size of each of these buffers should at least be equal\
    \ to that\n      of a message, i.e., 8095 bits.  We have chosen a buffer size\
    \ of\n      253 words (8096 bits) so that both of the buffers are included\n \
    \     within one page (512 words).  The 6 remaining words of the page\n      are\
    \ generally used for control.\n      A typical buffer page structure is identified\
    \ on figure 8.\n      (a)  I/O communication page\n         See figure 9.\n  \
    \       This I/O communication page is used as an interface between the\n    \
    \     Handler and the Network program.\n         In the buffers of this page the\
    \ messages are assembled (input)\n         or de-assembled (output) word by word\
    \ by the Handler, e.g., a\n         \"ready to go\" message, sorted by the Network\
    \ program in the\n         output buffer, is shipped out word by word by the Handler.\n\
    \         Main characteristics:\n         *  Location:  Resident in core: Locked\
    \ page\n         *  Coupling:  Coupled to the Network process virtual space\n\
    \         *  Content: * Input buffer (253 words) for incoming messages\n     \
    \                  Output buffer (253 words) for outgoing messages\n         \
    \            * Input control zone (6 half words)\n                     * Output\
    \ control zone (6 half words)\n         *  Structure:  See figure 9.\n       \
    \  *  Specific feature: * The input buffer is filled by the\n                \
    \                Handler (read from hardware) and emptied\n                  \
    \              by the Network program\n                              * Vice versa\
    \ for the output buffer\n      (b)  Connection shared pages (User-Network shared\
    \ zone)\n         General features:\n         *  There are as many shared pages\
    \ as connections.\n         *  These pages shared between the network and the\
    \ user\n            processes constitute a communication zone for (1) passing\n\
    \            the messages back and forth, and (2) exchanging control\n       \
    \     information, e.g., a request for establishing new\n            connections.\n\
    \         Main characteristics:\n         *  Location:  Disc resident\n      \
    \   *  Coupling:  Coupled to both a user process virtual space and\n         \
    \   the\n                          network process virtual space.\n         *\
    \  Content: - Input buffer (253 words) for incoming messages\n               \
    \       - Output buffer (253 words) for outgoing messages\n                  \
    \    - Input control zone (6 half words)\n                      - Output control\
    \ zone (6 half words)\n         *  Structure:  See figure 10.\n         *  Specific\
    \ feature 1: - The input buffer is filled by the\n                           \
    \       Network and emptied by the user.\n                                - Vice\
    \ versa for the output buffer.\n         *  Specific feature 2:  The control zone\
    \ corresponding to a\n                                  primary connection shared\
    \ page differs\n                                  from that of an auxiliary connection.\n\
    \                                  This because it is via a \"primary\n      \
    \                            connection control zone\" that\n                \
    \                  auxiliary connection establishment\n                      \
    \            requests are transmitted to the\n                               \
    \   Network process.\n      (c)  Working page\n         General feature:\n   \
    \      *  This page allows the Network and the Handler programs to\n         work\
    \ independently on different messages and so contributes to\n         an overlapping.\
    \  For instance, when the Handler is busy\n         transmitting a message to\
    \ the hardware, the Network program can\n         format (leader, marking, etc.)\
    \ the reset message to be shipped\n         out, so that it can reinitiate the\
    \ Handler as soon as it is\n         free.\n         Main characteristics:\n \
    \        *  Location:  Disc resident\n         *  Coupling:  Coupled to the Network\
    \ process virtual space\n         *  Content:  - Input buffer (253 words) for\
    \ incoming messages\n                      - Output buffer (253 words) for outgoing\
    \ messages\n         Remark:\n         During reception it may happen that a user\
    \ program is not ready\n         to accept a new message.  In that case, to avoid\
    \ clogging up\n         the system, the Network stores momentarily the incoming\
    \ message\n         in one of the buffer of the emergency ring.  (If this ring\
    \ is\n         full a help routine will be invoked.)\n         During emission\
    \ all operations are synchronized with the\n         RFNM[s], therefore such procedures\
    \ need not be provided.  (The\n         Network program allows a user to re-emit\
    \ only when having\n         received the RFNM of the previous transmitted message.)\n\
    \             [Figure 8 - Typical buffer page - see PDF file]\n       [Figure\
    \ 9 - I/O Communication page structure - see PDF file]\n       [Figure 10 - Connection\
    \ shared page structure - see PDF file]\n"
- title: 3.3.2  Programs
  contents:
  - "3.3.2  Programs\n   3.3.2.1  Handler program\n      General features:\n     \
    \ It is an I/O interrupt routine which drives the IMP/HOST hardware\n      interface\
    \ in order to transmit or receive messages.  Transmission\n      and reception\
    \ are carried out in a full duplex mode.\n      Main characteristics:\n      *\
    \  Location:  Core resident.  The Handler is in the same memory\n            \
    \        zone as the operating system and can be considered\n                \
    \    as part of it.\n      *  Initiation: By the IMP-HOST hardware interrupt.\
    \  This interrupt\n                     is triggered either:\n               \
    \      * during transmission when a message word is\n                       completely\
    \ sent to the IMP\n                     * during reception when a message word\
    \ has been\n                       completely received from the IMP\n        \
    \             * during idle time when the hardware received\n                \
    \       either a 'start input' or 'start output' order\n                     \
    \  from the Sigma 7 CPU.  Those orders are issued by\n                       the\
    \ Network program for provoking interrupts back\n                       (consequently\
    \ for indirectly initiating the\n                       Handler).\n      *  Main\
    \ functions: * Empties the output buffer upon transmitting\n                 \
    \          its content (outgoing message to the IMP.\n                       \
    \    This operation is carried out word by word\n                           (32\
    \ bits) and makes use of \"Write\" orders for\n                           driving\
    \ the HOST-IMP hardware.\n                         * Fills the input buffer with\
    \ data received\n                           from HOST-IMP hardware (incoming message).\n\
    \                           This operation is also carried out word by\n     \
    \                      word and makes use of \"Read\" orders for\n           \
    \                driving the HOST-IMP hardware.\n                         * Wakes\
    \ up the Network program when any of the\n                           previous\
    \ operations is complete.\n   3.3.2.2  Network program\n      General features:\n\
    \      This program serves the user for opening/closing connections and\n    \
    \  transmitting/receiving messages.  It uses the Handler as an aid\n      for\
    \ inter-facing with the hardware.\n      For the GORDO point of view it is a regular\
    \ process and treated as\n      such.\n      Main characteristics:\n      *  Location:\
    \  Disc resident.  More precisely it is on disc when\n                    asleep\
    \ and called in core when awakened by a\n                    program.\n      *\
    \  Initiation:  It is initiated through 'WAKE' service calls\n               \
    \       issued either by a user process or by the Handler.\n      *  Main functions:\
    \ * Establishes/deletes outgoing connections upon\n                          \
    \ users' requests.  For so doing it sends\n                           control\
    \ messages (see 2.4.2) to remote\n                           HOST[s] in order\
    \ to get links\n                           established/released; it then notifies\
    \ back\n                           the users.\n                         * Insures\
    \ the processing of incoming control\n                           messages (transmitted\
    \ over control links),\n                           e.g., for contributing to\n\
    \                           establishments/deletions of connections\n        \
    \                   (those requested by remote HOSTS).\n                     \
    \    * Prepares transmission of outgoing messages.\n                         \
    \  It picks up text messages from shared pages\n                           (the\
    \ messages are stored there by users),\n                           formats them\
    \ (adds leader, marking,\n                           checksum..), and passes them\
    \ along to the\n                           Handler for transmission.\n       \
    \                  * Insures delivery of incoming messages.  It is\n         \
    \                  the opposite of the above operation.  The\n               \
    \            users to which the messages should be\n                         \
    \  delivered are identified through the leaders.\n      *  Virtual space configuration:\
    \  See figure 11.\n      *  Specific feature:  It is integrated as an I/O process,\
    \ so that\n                            it can access privileged instruction (RD/WD\n\
    \                            for indirectly initiating the Handler).\n       \
    \ [Figure 11 - Network Process Virtual Space - see PDF file]\n"
- title: 3.4  Software Procedures
  contents:
  - "3.4  Software Procedures\n   The detailed software procedures are given on the\
    \ flowcharts attached\n   with Appendix A.\n   However, to get a quick understanding\
    \ of the implementation we list\n   below some typical software procedures.\n"
- title: 3.4.1  Description of some typical sequences
  contents:
  - "3.4.1  Description of some typical sequences\n   Consider some of the transactions\
    \ at user's disposal (See 2.4) and\n   point out the basic software procedures\
    \ they imply.  For each case we\n   will delineate (i) what the user program does\
    \ and (ii) what the\n   Network program does.\n   (a)  Open a primary link (See\
    \ also 2.4.2)\n         (i)  What the user program does[1]:\n              * \
    \ it stores in the Network mail box directory the name of\n                 a\
    \ file, e.g., DATA;\n              *  it couples the first page of this file to\
    \ its virtual\n                 space;\n              *  it stores information\
    \ in this page (its job/process #,\n                 the remote HOST #, e.g.,\
    \ (i));\n              *  it wakes up the Network process;\n              *  it\
    \ goes to sleep.\n         (ii) What the Network program does:\n             \
    \ *  it explores the Network mail box directory and accesses\n               \
    \  the file DATA;\n              *  it couples the first page of this file to\
    \ its virtual\n                 space (Shared Zone, see 3.3.1.2).  Suppose this\
    \ page to\n                 be kth in the shared zone; k is the internal connection\n\
    \                 #;\n              *  it explores the ith slot of the new HOST\
    \ table (See\n                 3.3.1.1 (a)) and selects the first bit = 0, e.g.,\
    \ the\n                 (alpha)th bit; alpha corresponds to the outgoing link\n\
    \                 #;\n              *  it stores information (job/process #, remote\
    \ HOST #\n                 (i), outgoing link # (alpha)) in the kth slot of the\n\
    \                 CONNECT table (See 3.3.1.2).\n              *  it momentarily\
    \ stores the connection # (k) in the INPUT\n                 LINK table.  This\
    \ is carried out upon creating an entry\n                 in this table (Hashing\
    \ the key value:  \"outgoing link #\n                 (alpha) + remote HOST #\
    \ (i) + outgoing flag\".);\n              *  it prepares the message text ENQ\
    \ PRIM 0 0 a and formats\n                 a complete message in adding leader,\
    \ marking, checksum,\n                 etc.;\n              *  it checks the Handler\
    \ state (bit in I/O locked page).\n                 If the Handler is free, it\
    \ stores the 'ready to go'\n                 control message in the output buffer\
    \ of the I/O locked\n                 page, initiates the Handler, and goes to\
    \ sleep.  Else\n                 it goes to sleep.\n   After a while the Handler\
    \ wakes up the Network process because it has\n   received a complete message.\
    \  We suppose this message be the control\n   message sent by the remote HOST\
    \ for acknowledging the establishment\n   of the connection.  The message text\
    \ should be:\n            ACK ENQ PRIM 0 0 alpha 0 0 beta\n   where beta is the\
    \ incoming link #.  (See 2.4.2)\n   Let's see now what the Network program does\
    \ when receiving the above\n   control message:\n              *  it retrieves\
    \ the connection # previously stored in the\n                 INPUT LINK table\
    \ upon re-hashing the same key value\n                 (See above).  Also it deletes\
    \ this entry;\n              *  it creates an entry in the INPUT LINK table for\
    \ the\n                 incoming link.  For so doing it hashes the key value:\n\
    \                 \"incoming link # (beta]) + remote HOST # (i) +\n          \
    \       \"incoming flag\".  In this entry it stores the HOST #\n             \
    \    (i), the incoming link # (beta), and connection # (k);\n              * \
    \ it updates the kth slot of the CONNECT table in storing\n                 the\
    \ incoming link # (beta);\n              *  it turns on the 'net-user' bit in\
    \ the kth shared page\n                 (page corresponding to the primary connection\
    \ that has\n                 just been opened) and wakes up the user process;\n\
    \              *  it goes to sleep.\n   (b)  Transmit a message over primary link\n\
    \         (i)  What the user program does[1].\n              *  it stores the\
    \ message text in the output buffer of the\n                 primary connection\
    \ shared page (see 3.3.1.2);\n              *  it turns on the 'user-net' bit\
    \ of this page and wakes\n                 up the Network process;\n         \
    \     *  it goes to sleep.\n         (ii) What the Network program does:\n   \
    \           *  it looks for user request, i.e., it explores in\n             \
    \    sequence the connection shared pages and selects the\n                 one\
    \ that has its 'user-net' bit turned on.  Suppose k\n                 be the selected\
    \ page # on the shared list, K is the\n                 connection #;\n      \
    \        *  it determines the request type in testing the 'request\n         \
    \        bits' of the shared page k.  It finds out that it is a\n            \
    \     request for transmitting a message.\n              *  it takes the message\
    \ text from the output buffer of the\n                 shared page k, formats\
    \ it into a complete message and\n                 transmits to the Handler in\
    \ a very similar way as above\n                 (See Open a primary link).\n \
    \             *  it goes to sleep.\n      [1]  Remark:  In a first phase the user\
    \ will directly write the\n                    network functions in his program.\
    \  Later on\n                    subroutines will be put at user's disposal. \
    \ These\n                    subroutines will be very close to those described\
    \ in\n                    2.4.\n"
- title: APPENDIX A
  contents:
  - "APPENDIX A\n   Flowcharts\n                       [see PDF file for flowcharts]\n\
    \       [ This RFC was put into machine readable form for entry ]\n          [\
    \ into the online RFC archives by Bob German 8/99 ]\n"
