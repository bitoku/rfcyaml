Abstract This document describes a data representation for collections of DNS messages.
The format is designed for efficient storage and transmission of large packet captures of DNS traffic; it attempts to minimize the size of such packet capture files but retain the full DNS message contents along with the most useful transport metadata.
It is intended to assist with the development of DNS traffic  monitoring applications.
There has long been a need for server operators to collect DNS Queries and Responses on authoritative and recursive name servers for monitoring and analysis.
This data is used in a number of ways, including traffic monitoring, analyzing network attacks, and "day in the life" (DITL)
A wide variety of tools already exist that facilitate the collection of DNS traffic data, such as the DNS Statistics Collector (DSC)
[dsc], packetq [packetq], dnscap [dnscap], and dnstap [dnstap].
However, there is no standard exchange format for large DNS packet captures.
The PCAP ("packet capture") [pcap] format or the PCAP
[pcapng] format is typically used in practice for packet captures, but these file formats can contain a great deal of additional information that is not directly pertinent to DNS traffic analysis and thus unnecessarily increases the capture file size.
Additionally, these tools and formats typically have no filter mechanism to selectively record only certain fields at capture time, requiring post processing for anonymization or pseudonymization of data to protect user privacy.
There has also been work on using text based formats to describe DNS packets (for example, see [dnsxml] and [RFC8427]), but this work is largely aimed at producing convenient representations of single messages.
Many DNS operators may receive hundreds of thousands of Queries per second on a single name server instance, so a mechanism to minimize the storage and transmission size (and therefore upload overhead) of the data collected is highly desirable.
The format described in this document, C DNS (Compacted DNS), focuses on the problem of capturing and storing large packet capture files of DNS traffic with the following goals in mind:  Minimize the file size for storage and transmission.
Minimize the overhead of producing the packet capture file and the cost of any further (general purpose) compression of the file.
This document contains:  A discussion of some common use cases in which DNS data is collected; see Section 3.
A discussion of the major design considerations in developing an efficient data representation for collections of DNS messages; see Section 4.
A description of why the Concise Binary Object Representation (CBOR) [RFC7049] was chosen for this format; see Section 5.
A conceptual overview of the C DNS format; see Section 6.
The definition of the C DNS format for the collection of DNS messages; see Section 7.
Notes on converting C DNS data to PCAP format; see Section 9.
Some high level implementation considerations for applications designed to produce C DNS; see Section 10. 2.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14
when, and only when, they appear in all capitals, as shown here. "
Packet" refers to an individual IPv4 or IPv6 packet.
Typically, packets are UDP datagrams, but such packets may also be part of a TCP data stream.
"Message", unless otherwise qualified, refers to a DNS payload extracted from a UDP datagram or a TCP data stream.
The parts of DNS messages are named as they are in [RFC1035].
Specifically, the DNS message has five sections: Header, Question, Answer, Authority, and Additional.
From a purely server operator perspective, collecting full packet captures of all packets going into or out of a name server provides the most comprehensive picture of network activity.
However, there are several design choices or other limitations that are common to many DNS installations and operators.
Third party hardware (including multiple third parties)  Data is collected under different conditions:
On well provisioned servers running in a steady state
On servers that are under DoS attack
The capabilities of data collection (and upload)
Everything being on the in band network
Thus, there is a wide range of use cases, from very limited data collection environments (third party hardware, servers that are under attack, packet capture on the name server itself and no out of band network) to "limitless" environments (self hosted, well provisioned servers, using a network tap or port mirroring with out of band networks with the same capacity as the in band network).
In the former case, it is infeasible to reliably collect full packet captures, especially if the server is under attack.
In the latter case, collection of full packet captures may be reasonable.
As a result of these restrictions, the C DNS data format is designed with the most limited use case in mind, such that:  Data collection will occur on the same hardware as the name server itself
Collected data will be stored on the same hardware as the name server itself, at least temporarily  Collected data being returned to some central analysis system will use the same network interface as the DNS Queries and Responses
There can be multiple third party servers involved Because of these considerations,
a major factor in the design of the format is minimal storage size of the capture files.
Another significant consideration for any application that records DNS traffic is that the running of the name server software and the transmission of DNS Queries and Responses are the most important jobs of a name server; capturing data is not.
Any data collection system co located with the name server needs to be intelligent enough to carefully manage its CPU, disk, memory, and network utilization.
This leads to designing a format that requires a relatively low overhead to produce and minimizes the requirement for further potentially costly compression.
However, it is also essential that interoperability with less restricted infrastructure is maintained.
In particular, it is highly desirable that the collection format should facilitate the re creation of common formats (such as PCAP) that are as close to the original as is realistic, given the restrictions above.
This section presents some of the major design considerations used in the development of the C DNS format.
The basic unit of data is a combined DNS Query and the associated Response (a "Query/Response (Q/R) data item").
The same structure will be used for unmatched Queries and Responses.
Queries without Responses will be captured omitting the Response data.
Responses without Queries will be captured omitting the Query data (but using the Question section from the Response, if present, as an identifying QNAME).
A Query and the associated Response represent the basic level of a client's interaction with the server.
Also, combining the Query and Response into one item often reduces storage requirements due to commonality in the data of the two messages.
In the context of generating a C DNS file, it is assumed that only those DNS payloads that can be parsed to produce a well formed DNS message are stored in the structured Query/ Response data items of the C DNS format and that all other messages will (optionally) be recorded as separate malformed messages.
Parsing a well formed message means, at a minimum, the following:
The packet has a well formed 12 byte DNS Header with a recognized OPCODE.
The section counts are consistent with the section contents.
All of the Resource Records (RRs) can be fully parsed.
All top level fields in each Query/Response data item will be optional.
Different operators will have different requirements for data to be available for analysis.
Operators with minimal requirements should not have to pay the cost of recording full data, though this will limit the ability to perform certain kinds of data analysis and also to reconstruct packet captures.
For example, omitting the RRs from a Response will reduce the C DNS file size; in principle, Responses can be synthesized if there is enough context.
Operators may have different policies for collecting user data and can choose to omit or anonymize certain fields at capture time, e.g., client address.
Multiple Query/Response data items will be collected into blocks in the format.
Common data in a block will be abstracted and referenced from individual Query/Response data items by indexing.
The maximum number of Query/Response data items in a block will be configurable.
This blocking and indexing action provides a significant reduction in the volume of file data generated.
Although this introduces complexity, it provides compression of the data that makes use of knowledge of the DNS message structure.
It is anticipated that the files produced can be subject to further compression using general purpose compression tools.
Measurements show that blocking significantly reduces the CPU required to perform such strong compression.
Examples of commonality between DNS messages are that in most cases the QUESTION RR is the same in the Query and Response and that there is a finite set of Query "signatures" (based on a subset of attributes).
For many authoritative servers, there is very likely to be a finite set of Responses that are generated, of which a large number are NXDOMAIN.
Traffic metadata can optionally be included in each block.
Specifically, counts of some types of non DNS packets (e.g., ICMP, TCP resets) sent to the server may be of interest.
The wire format content of malformed DNS messages may optionally be recorded.
Any structured capture format that does not capture the DNS payload byte for byte will be limited to some extent in that it cannot represent malformed DNS messages.
Only those messages that can be fully parsed and transformed into the structured format can be fully represented.
Note, however, that this can result in rather misleading statistics.
For example, a malformed Query that cannot be represented in the C DNS format will lead to the (well formed) DNS Response with error code FORMERR appearing as "unmatched".
Therefore, it can greatly aid downstream analysis to have the wire format of the malformed DNS messages available directly in the C DNS file.
This document presents a detailed format description for C DNS.
The format uses CBOR [RFC7049].
The choice of CBOR was made taking a number of factors into account.
CBOR is a binary representation and thus is economical in storage space.
Other binary representations were investigated, and whilst all had attractive features, none had a significant advantage over CBOR.
See Appendix C for some discussion of this.
CBOR is an IETF specification and is familiar to IETF participants.
It is based on the now common ideas of lists and objects and thus requires very little familiarization for those in the wider industry.
CBOR is a simple format and can easily be implemented from scratch if necessary.
Formats that are more complex require library support, which may present problems on unusual platforms.
CBOR can also be easily converted to text formats such as JSON [RFC8259] for debugging and other human inspection requirements.
CBOR data schemas can be described using the Concise Data Definition Language (CDDL) [RFC8610].
C DNS Format Conceptual Overview
The following figures show purely schematic representations of the C DNS format to convey the high level structure of the C DNS format.
Section 7 provides a detailed discussion of the CBOR representation and individual elements.
Figure 1 shows the C DNS format at the top level, including the file header and data blocks.
The Query/Response data items, Address/Event Count data items, and Malformed Message data items link to various Block Tables.
The C DNS Format Figure 2 shows some more detailed relationships within each Block, specifically those between the Query/Response data item and the relevant Block Tables.
Some fields have been omitted for clarity.
The Query/Response Data Item and Subsidiary Tables
In Figure 2, data items annotated (q) are only present when a Query/Response has a Query, and those annotated (r) are only present when a Query/Response Response is present.
A C DNS file begins with a file header containing a File Type Identifier and a File Preamble.
The File Preamble contains information on the file Format Version and an array of Block Parameters items (the contents of which include Collection and Storage Parameters used for one or more Blocks).
The file header is followed by a series of Blocks.
A Block consists of a Block Preamble item, some Block Statistics for the traffic stored within the Block, and then various arrays of common data collectively called the Block Tables.
This is then followed by an array of the Query/Response data items detailing the Queries and Responses stored within the Block.
The array of Query/Response data items is in turn followed by the Address/Event Count data items (an array of per client counts of particular IP events) and then Malformed Message data items (an array of malformed messages that are stored in the Block).
The exact nature of the DNS data will affect what Block size is the best fit; however, sample data for a root server indicated that Block sizes up to 10,000 Query/Response data items give good results.
See Appendix C.6 for more details.
This design exploits data commonality and block based storage to minimize the C DNS file size.
As a result, C DNS cannot be streamed below the level of a Block.
The details of the Block Parameters items are not shown in the diagrams but are discussed here for context.
An array of Block Parameters items is stored in the File Preamble (with a minimum of one item at index 0); a Block Parameters item consists of a collection of Storage and Collection Parameters that applies to any given Block.
An array is used in order to support use cases such as wanting to merge C DNS files from different sources.
The Block Preamble item then contains an optional index for the Block Parameters item that applies for that Block; if not present, the index defaults to 0.
Hence, in effect, a global Block Parameters item is defined that can then be overridden per Block.
The Block Parameters item includes a Storage Parameters item   this contains information about the specific data fields stored in the C DNS file.
These parameters include:  The sub second timing resolution used by the data.
Information (hints) on which optional data are omitted.
Recorded OPCODES [opcodes] and RR TYPEs [rrtypes].
Flags indicating, for example, whether the data is sampled or anonymized.
See Sections 6.2.3 and 14.
Client and server IPv4 and IPv6 address prefixes.
Optional Data Items To enable implementations to store data to their precise requirements in as space efficient a manner as possible
, all fields in the following arrays are optional:  Query/Response  Query Signature
In other words, an implementation can choose to omit any data item that is not required for its use case (whilst observing the restrictions relating to IP address storage described in Section 6.2.4).
In addition, implementations may be configured to not record all RRs or to only record messages with certain OPCODES.
This does, however, mean that a consumer of a C DNS file faces two problems: 1.
How can it quickly determine if a file definitely does not contain the data items it requires to complete a particular task (e.g., reconstructing DNS traffic or performing a specific piece of data analysis)?
How can it determine whether a data item is not present because it was (1) explicitly not recorded or (2) not available/present?
For example, capturing C DNS data from within a name server implementation makes it unlikely that the Client Hoplimit can be recorded.
Or, if there is no Query ARCOUNT recorded and no Query OPT RDATA [RFC6891] recorded, is that because no Query contained an OPT RR, or because that data was not stored?
The Storage Parameters item therefore also contains a Storage Hints item, which specifies which items the encoder of the file omits from the stored data and will therefore never be present.
(This approach is taken because a flag that indicated which items were included for collection would not guarantee that the item was present   only that it might be.)
An implementation decoding that file can then use these flags to quickly determine whether the input data is not rich enough for its needs.
One scenario where this may be particularly important is the case of regenerating traffic.
It is possible to collect such a small set of data items that an implementation decoding the file cannot determine if a given Query/Response data item was generated from just a Query, just a Response, or a Query/Response pair.
This makes it impossible to reconstruct DNS traffic even if sensible defaults are provided for the missing data items.
This is discussed in more detail in Section 9.
Optional RRs and OPCODEs Also included in the Storage Parameters item
are explicit arrays listing the RR TYPEs and the OPCODEs to be recorded.
These arrays remove any ambiguity over whether, for example, messages containing particular OPCODEs are not present because (1)
certain OPCODEs did not occur or (2)
the implementation is not configured to record them.
In the case of OPCODEs, for a message to be fully parsable, the OPCODE must be known to the collecting implementation.
Any message with an OPCODE unknown to the collecting implementation cannot be validated as correctly formed and so must be treated as malformed.
Messages with OPCODES known to the recording application but not listed in the Storage Parameters item are discarded by the recording application during C DNS capture (regardless of whether they are malformed or not).
In the case of RRs, each record in a message must be fully parsable, including parsing the record RDATA, as otherwise the message cannot be validated as correctly formed.
Any RR with an RR TYPE not known to the collecting implementation cannot be validated as correctly formed and so must be treated as malformed.
Once a message is correctly parsed, an implementation is free to record only a subset of the RRs present.
The Storage Parameters item contains flags that can be used to indicate if:  the data is anonymized,  the data is produced from sample data, or  names in the data have been normalized (converted to uniform case).
The Storage Parameters item also contains optional fields holding details of the sampling method used and the anonymization method used.
It is RECOMMENDED that these fields contain URIs [RFC3986] pointing to resources describing the methods used.
See Section 14 for further discussion of anonymization and normalization.
The format can store either full IP addresses or just IP prefixes; the Storage Parameters item contains fields to indicate if only IP prefixes were stored.
If the IP address prefixes are absent, then full addresses are stored.
In this case, the IP version can be directly inferred from the stored address length and the fields "qr transport flags" in QueryResponseSignature, "ae transport flags" in AddressEventCount, and "mm transport flags" in MalformedMessageData (which contain the IP version bit) are optional.
If IP address prefixes are given, only the prefix bits of addresses are stored.
In this case, in order to determine the IP version, the fields "qr transport flags" in QueryResponseSignature, "ae transport  flags" in AddressEventCount, and "mm transport flags" in MalformedMessageData MUST be present.
See Sections 7.3.2.3.2 and 7.3.2.3.5.
As an example of storing only IP prefixes, if a client IPv6 prefix of 48 is specified, a client address of 2001:db8:85a3::8a2e:370:7334 will be stored as 0x20010db885a3, reducing address storage space requirements.
Similarly, if a client IPv4 prefix of 16 is specified, a client address of 192.0.2.1 will be stored as 0xc000 (192.0).
C DNS Format Detailed Description
The CDDL definition for the C DNS format is given in Appendix A. 7.1.
All map keys are integers with values specified in the CDDL.
String keys would significantly bloat the file size.
All key values specified are positive integers under 24, so their CBOR representation is a single byte.
Positive integer values not currently used as keys in a map are reserved for use in future standard extensions.
Implementations may choose to add additional implementation specific entries to any map.
Negative integer map keys are reserved for these values.
Key values from  1 to  24 also have a single byte CBOR representation, so such implementation specific extensions are not at any space efficiency disadvantage.
An item described as an index is the index of the data item in the referenced array.
The following sections present the C DNS specification in tabular format with a detailed description of each item.
In all quantities that contain bit flags, bit 0 indicates the least significant bit, i.e., flag "n" in quantity "q" is on if "(q & (1 << n)) !
For the sake of readability, all type and field names defined in the CDDL definition are shown in double quotes.
Type names are by convention camel case (e.g., "BlockTables"), and field names are lowercase with hyphens (e.g., "block tables").
For the sake of brevity, the following conventions are used in the tables:
The column M marks whether items in a map are mandatory.
Such items are usually optional but may be mandatory in some configurations.
If the column is empty, the item is optional.
The column T gives the CBOR datatype of the item.
I Signed integer (i.e., either a CBOR unsigned integer or a CBOR negative integer).
In the case of maps and arrays, more information on the type of each value, including the CDDL definition name if applicable, is given in the description.
"C DNS" identifying the file type.
"FilePreamble" Information about data in the file.
"BlockParameters" Parameters relating to data storage and collection that apply to one or more items of type "Block".
"StorageParameters" Parameters relating to how data is stored in the items of type "Block".
A   Array of OPCODES [opcodes]
1 if the data is sampled data.
"StorageHints" An indicator of which fields the collecting implementation omits in the maps with optional fields.
Note that hints have a top down precedence.
In other words, where a map contains another map, the hint on the containing map overrides any hints in the contained map and the contained map is omitted.
"CollectionParameters" Parameters providing information regarding how data in the file was collected (applicable for some, but not all, collection environments).
The values are informational only and serve as metadata to downstream analyzers as to the configuration of a collecting implementation.
They can provide context when interpreting what data is present/absent from the capture but cannot necessarily be validated against the data captured.
These parameters have no default.
If they do not appear, nothing can be inferred about their value.
"Block" Container for data with common collection and storage parameters.
"BlockPreamble" Overall information for a "Block" item.
"BlockStatistics" Basic statistical information about a "Block" item.
"BlockTables" Map of arrays containing data referenced by individual "QueryResponse" or "MalformedMessage" items in this "Block".
Each element is an array that, if present, must not be empty.
An item in the "qlist" array contains indexes to values in the "qrr" array.
Therefore, if "qlist" is present, "qrr" must also be present.
Similarly, if "rrlist" is present, "rr" must also be present.
A   Array of Q/R data item signatures.
A   Array of type "RR".
"ClassType" RR CLASS and TYPE information.
"QueryResponseSignature" Elements of a Q/R data item that are often common between multiple individual Q/R data items.
1 if a Query was present.
1 if a Response was present.
Version 1.0 of C DNS supports transport values corresponding to DNS transports defined in IETF Standards Track documents at the time of writing.
There are numerous non standard methods of sending DNS messages over various transports using a variety of protocols, but they are out of scope for this document.
With the current specification, these can be generically stored using value 15 (Non standard transport), or implementations are free to use the negative integer map keys to define their own mappings.
Such non standard transports may also be the subject of a future extension to the specification.
"Question" Details on individual Questions in a Question section.
"RR" Details on individual RRs in RR sections.
The RR Time to Live.
"MalformedMessageData" Details on malformed DNS messages stored in this "Block" item.
"QueryResponse" Details on individual Q/R data items.
Note that there is no requirement that the elements of the "query responses" array are presented in strict chronological order.
The "query size" and "response size" fields hold the DNS message size.
For UDP, this is the size of the UDP payload that contained the DNS message.
For TCP, it is the size of the DNS message as specified in the two byte message length header.
Trailing bytes in UDP Queries are routinely observed in traffic to authoritative servers, and this value allows a calculation of how many trailing bytes were present.
"ResponseProcessingData" Information on the server processing that produced the Response.
"QueryResponseExtended" Extended data on the Q/R data item.
Each item in the map is present only if collection of the relevant details is configured.
"AddressEventCount" Counts of various IP related events relating to traffic with individual client addresses.
A code relating to the event.
"MalformedMessage" Details on Malformed Message data items.
Versioning The C DNS File Preamble includes a file Format Version; a major and minor version number are required fields.
This document defines version 1.0 of the C DNS specification.
This section describes the intended use of these version numbers in future specifications.
It is noted that version 1.0 includes many optional fields; therefore, consumers of version 1.0 should be inherently robust to parsing files with variable data content.
Within a major version, a new minor version MUST be a strict superset of the previous minor version, with no semantic changes to existing fields.
New keys MAY be added to existing maps, and new maps MAY be added.
A consumer capable of reading a particular major.minor version MUST also be capable of reading all previous minor versions of the same major version.
It SHOULD also be capable of parsing all subsequent minor versions, ignoring any keys or maps that it does not recognize.
A new major version indicates changes to the format that are not backwards compatible with previous major versions.
A consumer capable of only reading a particular major version (greater than 1) is neither required nor expected to be capable of reading a previous major version.
It is usually possible to reconstruct PCAP files from the C DNS format in a lossy fashion.
Some of the issues with reconstructing both the DNS payload and the full packet stream are outlined here.
The reconstruction of well formed DNS messages depends on two factors: 1.
Whether or not a particular subset of the optional fields were captured in the C DNS file, specifically the data fields necessary to reconstruct a valid IP header and DNS payload for both Query and Response
Clearly, if not all these data fields were captured, the reconstruction is likely to be imperfect even if reasonable defaults are provided for the reconstruction.
Whether or not at least one field was captured that unambiguously identifies the Query/Response data item as containing just a Query, just a Response, or a Query/Response pair.
Obviously, the qr sig flags defined in Section 7.3.2.3.2 is such a field; however, this field is optional.
For more details, see Appendix D.2.
It is noted again that simply having hints that indicate that certain data fields were not omitted does not guarantee that those data fields were actually captured.
Therefore, the ability to reconstruct PCAP data (in the absence of defaults) can in principle vary for each record captured in a C DNS file, and between Blocks that have differing hints.
Even if all sections of the Response were captured, one cannot reconstruct the DNS Response payload exactly, due to the fact that some DNS names in the message on the wire may have been compressed.
Section 9.1 discusses this in more detail.
Some transport information is not captured in the C DNS format.
For example, the following aspects of the original packet stream cannot be reconstructed from the C DNS format:  IP fragmentation  TCP stream information:
TLS related features such as TCP Fast Open (TFO) [
RFC7413] or TLS session resumption [RFC5077]  DNS over HTTPS [RFC8484]
Whether the message used POST or GET    HTTPS Headers
Malformed DNS messages if the wire format is not recorded  Any non DNS messages that were in the original packet stream, e.g., ICMP Simple assumptions can be made on the reconstruction: fragmented and DNS over TCP messages can be reconstructed into single packets, and a single TCP session can be constructed for each TCP packet.
Additionally, if malformed messages and non DNS packets are captured separately, they can be merged with packet captures reconstructed from C DNS to produce a more complete packet stream.
All the names stored in the C DNS format are full domain names; no name compression (per [RFC1035]) is used on the individual names within the format.
Therefore, when reconstructing a packet, name compression must be used in order to reproduce the on the wire representation of the packet.
Name compression per [RFC1035] works by substituting trailing sections of a name with a reference back to the occurrence of those sections earlier in the message.
Not all name server software uses the same algorithm when compressing domain names within the Responses.
Some attempt maximum recompression at the expense of runtime resources, others use heuristics to balance compression and speed, and others use different rules for what is a valid compression target.
This means that Responses to the same Query from different name server software that match in terms of DNS payload content (header, counts, RRs with name compression removed) do not necessarily match byte for byte on the wire.
Therefore, it is not possible to ensure that the DNS Response payload is reconstructed byte for byte from C DNS data.
However, it can at least, in principle, be reconstructed to have the correct payload length (since the original Response length is captured)
if there is enough knowledge of the commonly implemented name compression algorithms.
For example, a simplistic approach would be to try each algorithm in turn to see if it reproduces the original length, stopping at the first match.
This would not guarantee that the correct algorithm has been used, as it is possible to match the length whilst still not matching the on the wire bytes; however, without further information added to the C DNS data, this is the best that can be achieved.
Appendix B presents an example of two different compression algorithms used by well known name server software.
This section describes a non normative proposed algorithm for the processing of a captured stream of DNS Queries and Responses and production of a stream of Q/R data items, matching Queries and Responses where possible.
For the purposes of this discussion, it is assumed that the input has been preprocessed such that: 1.
All IP fragmentation reassembly, TCP stream reassembly, and so on, have already been performed.
Each message is associated with transport metadata required to generate the Primary ID (see Section 10.2.1).
Each message has a well formed DNS Header of 12 bytes, and (if present)
the first Question in the Question section can be parsed to generate the Secondary ID (see below).
As noted earlier, this requirement can result in a malformed Query being removed in the preprocessing stage, but the correctly formed Response with RCODE of FORMERR being present.
DNS messages are processed in the order they are delivered to the implementation.
It should be noted that packet capture libraries do not necessarily provide packets in strict chronological order.
This can, for example, arise on multi core platforms where packets arriving at a network device are processed by different cores.
On systems where this behavior has been observed, the timestamps associated with each packet are consistent; Queries always have a timestamp prior to the Response timestamp.
However, the order in which these packets appear in the packet capture stream is not necessarily strictly chronological; a Response can appear in the capture stream before the Query that provoked the Response.
For this discussion, this non chronological delivery is termed "skew".
In the presence of skew, Response packets can arrive for matching before the corresponding Query.
To avoid generating false instances of Responses without a matching Query, and Queries without a matching Response, the matching algorithm must take the possibility of skew into account.
Matching Algorithm A schematic representation of the algorithm for matching Q/R data items is shown in Figure 3.
It takes individual DNS Query or Response messages as input, and it outputs matched Q/R data items.
The numbers in the figure identify matching operations listed in Table 1.
Specific details of the algorithm   for example, queues, timers, and identifiers   are given in the following sections.
Update all timed out (QT) OFIFO QR items
/ / OFIFO   output FIFO containing Q/R data items (Section 10.6) RFIFO   Response FIFO containing unmatched Response items (Section 10.6)
QT   Query Timeout (Section 10.3)
ST   Skew Timeout (Section 10.3)
Operations Used in the Matching Algorithm 10.2.
A Primary ID is constructed for each message.
It is composed of the following data: 1.
If present, the first Question in the Question section is used as a Secondary ID for each message.
that there may be well formed DNS Queries that have a QDCOUNT of 0, and some Responses may have a QDCOUNT of 0 (for example, Responses with RCODE FORMERR or NOTIMP).
In this case, the Secondary ID is not used in matching.
A Query arrives with timestamp t1.
If no Response matching that Query has arrived before other input arrives timestamped later than (t1   QT), a Q/R data item containing only a Query is recorded.
The QT value is typically on the order of 5 seconds.
A Response arrives with timestamp t2.
If a Response has not been matched by a Query before input arrives timestamped later than (t2   ST), a Q/R data item containing only a Response is recorded.
The ST value is typically a few microseconds.
The algorithm is designed to handle the following input data: 1.
Multiple Queries with the same Primary ID (but different Secondary ID) arriving before any Responses for these Queries are seen.
Multiple Queries with the same Primary and Secondary ID arriving before any Responses for these Queries are seen.
Queries for which no later Response can be found within the specified timeout.
Responses for which no previous Query can be found within the specified timeout.
For cases 1 and 2 listed in the above requirements, it is not possible to unambiguously match Queries with Responses.
This algorithm chooses to match to the earliest Query with the correct Primary and Secondary ID.
The algorithm employs two FIFO queues:  OFIFO: an output FIFO containing Q/R data items in chronological order.
RFIFO: a FIFO holding Responses without a matching Query in order of arrival.
The output is a list of Q/R data items.
Both the Query and Response elements are optional in these items; therefore, Q/R data items have one of three types of content: 1.
A matched pair of Query and Response messages 2.
A Query message with no Response 3.
A Response message with no Query
The timestamp of a list item is that of the Query for cases 1 and 2 and that of the Response for case 3.
When ending a capture, all items in the RFIFO are timed out immediately, generating Response only entries to the OFIFO.
These and all other remaining entries in the OFIFO should be treated as timed out Queries.
Whilst this document makes no specific recommendations with respect to "Canonical CBOR"
(see Section 3.9 of [RFC7049]), the following guidance may be of use to implementers.
Adherence to the first two rules given in Section 3.9 of [RFC7049] will minimize file sizes.
Adherence to the last two rules given in Section 3.9 of [RFC7049] for all maps and arrays would unacceptably constrain implementations   for example, in the use case of real time data collection in constrained environments where outputting Block Tables after Q/R data items and allowing indefinite length maps and arrays could reduce memory requirements.
It is recommended that implementations that have fundamental restrictions on what data fields they can collect SHOULD always store hints with the bits unset for those fields, i.e., they unambiguously indicate that those data fields will be omitted from captured C DNS.
When decoding C DNS data, some of the items required for a particular function that the consumer wishes to perform may be missing.
Consumers should consider providing configurable default values to be used in place of the missing values in their output.
A DNS Query message in a UDP or TCP payload can be followed by some additional (spurious) bytes, which are not stored in C DNS.
When DNS traffic is sent over TCP, each message is prefixed with a two byte length field, which gives the message length, excluding the two byte length field.
In this context, trailing bytes can occur in two circumstances, with different results: 1.
The number of bytes consumed by fully parsing the message is less than the number of bytes given in the length field (i.e., the length field is incorrect and too large).
In this case, the surplus bytes are considered trailing bytes in a manner analogous to UDP and recorded as such.
If only this case occurs, it is possible to process a packet containing multiple DNS messages where one or more have trailing bytes.
There are surplus bytes between the end of a well formed message and the start of the length field for the next message.
In this case, the first of the surplus bytes will be processed as the first byte of the next length field, and parsing will proceed from there, almost certainly leading to the next and any subsequent messages in the packet being considered malformed.
This will not generate a trailing bytes record for the processed well formed message.
Limiting Collection of RDATA Implementations should consider providing a configurable maximum RDATA size for captures   for example, to avoid memory issues when confronted with large zone transfer records.
The preamble to each block includes a timestamp of the earliest record in the Block.
As described in Section 7.3.2.1, the timestamp is an array of two unsigned integers.
The first is a POSIX "time t" [posix time].
Consumers of C DNS should be aware of this, as it excludes leap seconds and therefore may cause minor anomalies in the data, e.g., when calculating Query throughput.
IANA Considerations IANA has created a registry "C DNS DNS Capture Format" containing the subregistries defined in Sections 12.1 to 12.4 inclusive.
In all cases, new entries may be added to the subregistries by Expert Review as defined in [RFC8126].
Experts are expected to exercise their own expert judgment and should consider the following general guidelines in addition to any provided guidelines that are particular to a subregistry.
There should be a real and compelling use for any new value.
Values assigned should be carefully chosen to minimize storage requirements for common cases.
Transport Types IANA has created a registry "C DNS Transports" of C DNS transport type identifiers.
The primary purpose of this registry is to provide unique identifiers for all transports used for DNS Queries.
The following note is included in this registry: "In version 1.0 of C DNS [RFC8618], there is a field to identify the type of DNS transport.
This field is 4 bits in size.
" The initial contents of the registry are as follows.
See Sections 7.3.2.3.2, 7.3.2.3.5, and 7.3.2.5 of this document:
Is the requested DNS transport described by a Standards Track RFC?
Data Storage Flags IANA has created a registry "C DNS Storage Flags" of C DNS data storage flags.
The primary purpose of this registry is to provide indicators giving hints on processing of the data stored.
The following note is included in this registry: "In version 1.0 of C DNS [RFC8618], there is a field describing attributes of the data recorded.
The field is a CBOR [RFC7049] unsigned integer holding bit flags."
The initial contents of the registry are as follows.
See Section 7.3.1.1.1 of this document:
The data is sampled data.
Response Processing Flags IANA has created a registry "C DNS Response Flags" of C DNS response  processing flags.
The primary purpose of this registry is to provide indicators giving hints on the generation of a particular Response.
The following note is included in this registry: "In version 1.0 of C DNS [RFC8618], there is a field describing attributes of the Responses recorded.
The field is a CBOR [RFC7049] unsigned integer holding bit flags."
The initial contents of the registry are as follows.
The Response came from cache.
AddressEvent Types IANA has created a registry "C DNS Address Event Types" of C DNS AddressEvent types.
The primary purpose of this registry is to provide unique identifiers of different types of C DNS address events and so specify the contents of the optional companion field "ae code" for each type.
The following note is included in this registry: "In version 1.0 of C DNS [RFC8618], there is a field identifying types of the events related to client addresses.
This field is a CBOR [RFC7049] unsigned integer.
There is a related optional field "ae code", which, if present, holds an additional CBOR unsigned integer giving additional information specific to the event type.
" The initial contents of the registry are as follows.
See Section 7.3.2.5 of this document:
A specification of "None" requires less storage and is therefore preferred.
Any control interface MUST perform authentication and encryption.
Any data upload MUST be authenticated and encrypted.
Privacy Considerations Storage of DNS traffic by operators in PCAP and other formats is a long standing and widespread practice.
Section 2.5 of [DNS Priv Cons] provides an analysis of the risks to Internet users regarding the storage of DNS traffic data in servers (recursive resolvers, authoritative servers, and rogue servers).
Section 5.2 of [DNS Priv Svc] describes mitigations for those risks for data stored on recursive resolvers (but that could by extension apply to authoritative servers).
These include data handling practices and methods for data minimization, IP address pseudonymization, and anonymization.
Appendix C of [DNS Priv Svc] presents an analysis of seven published anonymization processes.
In addition, the ICANN Root Server System Advisory Committee (RSSAC) have recently published [RSSAC04] ("Recommendations on Anonymization Processes for Source IP Addresses Submitted for Future Analysis").
The above analyses consider full data capture (e.g., using PCAP) as a baseline for privacy considerations; therefore, this format specification introduces no new user privacy issues beyond those of full data capture (which are quite severe).
It does provide mechanisms to selectively record only certain fields at the time of data capture, to improve user privacy and to explicitly indicate that data is sampled, anonymized, or both.
It also provides flags to indicate if data normalization has been performed; data normalization increases user privacy by reducing the potential for fingerprinting individuals.
However, a trade off is the potential reduction of the capacity to identify attack traffic via Query name signatures.
Operators should carefully consider their operational requirements and privacy policies and SHOULD capture at the source the minimum user data required to meet their needs.
This appendix gives a CDDL [RFC8610] specification for C DNS.
CDDL does not permit a range of allowed values to be specified for a bitfield.
Where necessary, those values are given as a CDDL group, but the group definition is commented out to prevent CDDL tooling from warning that the group is unused. ; CDDL specification of the file format for C DNS, ; which describes a collection of DNS messages and ; traffic metadata.
; ; The overall structure of a file.
client address prefix ipv6  > IPv6PrefixLength, ?
server address prefix ipv6  > IPv6PrefixLength, ?
7 server address prefix ipv4
8 server address prefix ipv6
> RRHints, other data hints
0 query response signature hints
uint .bits StorageFlagValues ; Metadata about data collection
; ; Data in the file is stored in Blocks.
The number of ticks in a second is ; file/block metadata.
Signed and unsigned tick types are defined.
8 IPv4Address   bstr .size (0..4)
uint, } type    0 class
; Transport gives the values that may appear in bits 1..4 of ; TransportFlags.
There is currently no way to express this in ; CDDL, so Transport is unused.
To avoid confusion when used ; with CDDL tools, it is commented out.
response has no question: 5, )
response rd: 12, response tc: 13, response aa: 14, ) DNSFlags   uint
A single Query/Response data item.
response processing data  > ResponseProcessingData, ?
Time offset from ; start of Block ?
The basic algorithm, which follows the guidance in [RFC1035], is simply to collect each name, and the offset in the packet at which it starts, during packet construction.
As each name is added, it is offered to each of the collected names in order of collection, starting from the first name.
If (1) labels at the end of the name can be replaced with a reference back to part (or all) of the earlier name and (2)
the uncompressed part of the name is shorter than any compression already found, the earlier name is noted as the compression target for the name.
The following tables illustrate the step by step process of adding names and performing name compression.
In an example packet, the first name added is foo.example, which cannot be compressed.
The next name added is bar.example.
This is matched against foo.example.
The example part of this can be used as a compression target, with the remaining uncompressed part of the name being bar.
The third name added is www.bar.example.
This is first matched against foo.example, and as before this is recorded as a compression target, with the remaining uncompressed part of the name being www.bar.
It is then matched against the second name, which again can be a compression target.
Because the remaining uncompressed part of the name is www, this is an improved compression, and so it is adopted.
As an optimization, if a name is already perfectly compressed (in other words, the uncompressed part of the name is empty), then no further names will be considered for compression.
Using the above basic algorithm, the packet lengths of Responses generated by the Name Server Daemon (NSD)
[NSD] can be matched almost exactly.
At the time of writing, a tiny number (<.01%) of the reconstructed packets had incorrect lengths.
The Knot Authoritative name server [Knot] uses different compression behavior, which is the result of internal optimization designed to balance runtime speed with compression size gains.
In brief, and omitting complications, Knot Authoritative will only consider the QNAME and names in the immediately preceding RR section in an RRSET as compression targets.
A set of smart heuristics as described below can be implemented to mimic this, and while not perfect, it produces output nearly, but not quite, as good a match as with NSD.
The heuristics are as follows:
A match is only perfect if the name is completely compressed AND the TYPE of the section in which the name occurs matches the TYPE of the name used as the compression target.
If the name occurs in RDATA:
If the compression target name is in a Query, then only the first RR in an RRSET can use that name as a compression target.
The compression target name MUST be in RDATA.
The name section TYPE must match the compression target name section TYPE.
The compression target name MUST be in the immediately preceding RR in the RRSET.
Using this algorithm, less than 0.1% of the reconstructed packets had incorrect lengths.
In sample traffic collected on a root name server, around 2 4% of Responses generated by Knot had different packet lengths than those produced by NSD.
Appendix C.  Comparison of Binary Formats
Several binary serialization formats were considered.
For completeness, they were also compared to JSON.
Data is stored according to a predefined schema.
The schema itself is always included in the data file.
Data can therefore be stored untagged, for a smaller serialization size, and be written and read by an Avro library.
At the time of writing, Avro libraries are available for C, C , C#, Java, Python, Ruby, and PHP.
Optionally, tools are available for C , Java, and C# to generate code for encoding and decoding.
Google Protocol Buffers [Protocol Buffers].
Data is stored according to a predefined schema.
The schema is used by a generator to generate code for encoding and decoding the data.
Data can therefore be stored untagged, for a smaller serialization size.
The schema is not stored with the data, so unlike Avro, it cannot be read with a generic library.
Code must be generated for a particular data schema to read and write data using that schema.
At the time of writing, the Google code generator can currently generate code for encoding and decoding a schema for C , Go, Java, Python, Ruby, C#, Objective C, JavaScript, and PHP.
This serialization format is comparable to JSON but with a binary representation.
It does not use a predefined schema, so data is always stored tagged.
However, CBOR data schemas can be described using CDDL [RFC8610], and tools exist to verify that data files conform to the schema.
CBOR is a simple format and is simple to implement.
At the time of writing, the CBOR website lists implementations for 16 languages.
Avro and Protocol Buffers both allow storage of untagged data, but because they rely on the data schema for this, their implementation is considerably more complex than CBOR.
Using Avro or Protocol Buffers in an unsupported environment would require notably greater development effort compared to CBOR.
A test program was written that reads input from a PCAP file and writes output using one of two basic structures: either a simple structure, where each Query/Response pair is represented in a single record entry, or the C DNS block structure.
The resulting output files were then compressed using a variety of common general purpose lossless compression tools to explore the compressibility of the formats.
The compression tools employed were:  snzip [snzip].
A command line compression tool based on the Google Snappy library [snappy].
The command line compression tool from the reference C LZ4 implementation.
The ubiquitous GNU zip tool.
Compression using the Zstandard algorithm.
A popular compression tool noted for high compression.
In all cases, the compression tools were run using their default settings.
Note that this document does not mandate the use of compression, nor any particular compression scheme, but it anticipates that in practice output data will be subject to general purpose compression, and so this should be taken into consideration.
"test.pcap", a 662 MB capture of sample data from a root instance, was used for the comparison.
The following table shows the formatted size and size after compression (abbreviated to Comp.
in the table headers), together with the task Resident Set Size (RSS) and the user time taken by the compression.
File sizes are in MB, RSS is in kB, and user time is in seconds.
The above results are discussed in the following sections.
Comparison with Full PCAP Files
An important first consideration is whether moving away from PCAP offers significant benefits.
The simple binary formats are typically larger than PCAP, even though they omit some information such as Ethernet Media Access Control (MAC) addresses.
But not only do they require less CPU to compress than PCAP, the resulting compressed files are smaller than compressed PCAP.
The intention of the block coding is to perform data deduplication on Query/Response records within the block.
The simple and block formats shown above store exactly the same information for each Query/Response record.
This information is parsed from the DNS traffic in the input PCAP file, and in all cases each field has an identifier and the field data is typed.
The data deduplication on the block formats show an order of  magnitude reduction in the size of the format file size against the simple formats.
As would be expected, the compression tools are able to find and exploit a lot of this duplication, but as the deduplication process uses knowledge of DNS traffic, it is able to retain a size advantage.
This advantage reduces as stronger compression is applied, as again would be expected, but even with the strongest compression applied the block formatted data remains around 75% of the size of the simple format and its compression requires roughly a third of the CPU time.
Text data formats offer many advantages over binary formats, particularly in the areas of ad hoc data inspection and extraction.
It was therefore felt worthwhile to carry out a direct comparison, implementing JSON versions of the simple and block formats.
Concentrating on JSON block format, the format files produced are a significant fraction of an order of magnitude larger than binary formats.
The impact on file size after compression is as might be expected from that starting point; the stronger compression produces files that are 150% of the size of similarly compressed binary format and require over 4x more CPU to compress.
Performance Concentrating again on the block formats, all three produce format files that are close to an order of magnitude smaller than the original "test.pcap" file.
CBOR produces the largest files and Avro the smallest, 20% smaller than CBOR.
However, once compression is taken into account, the size difference narrows.
At medium compression (with gzip), the size difference is 4%.
Using strong compression (with xz), the difference reduces to 2%, with Avro the largest and Protocol Buffers the smallest, although CBOR and Protocol Buffers require slightly more compression CPU.
The measurements presented above do not include data on the CPU required to generate the format files.
Measurements indicate that writing Avro requires 10% more CPU than CBOR or Protocol Buffers.
It appears, therefore, that Avro's advantage in compression CPU usage is probably offset by a larger CPU requirement in writing Avro.
The above assessments lead us to the choice of a binary format file using blocking.
As noted previously, this document anticipates that output data will be subject to compression.
There is no compelling case for one particular binary serialization format in terms of either final file size or machine resources consumed, so the choice must be largely based on other factors.
CBOR was therefore chosen as the binary serialization format for the reasons listed in Section 5.
Given the choice of a CBOR format using blocking, the question arises of what an appropriate default value for the maximum number of Query/Response pairs in a block should be.
This has two components: 1.
What is the impact on performance of using different block sizes in the format file?
What is the impact on the size of the format file before and after compression?
The following table addresses the performance question, showing the impact on the performance of a C  program converting "test.pcap" to C DNS.
File sizes are in MB, RSS is in kB, and user time is in seconds.
Therefore, increasing block size tends to increase maximum RSS a little, with no significant effect (if anything, a small reduction) on CPU consumption.
The following table demonstrates the effect of increasing block size on output file size for different compressions.
There is obviously scope for tuning the default block size to the compression being employed, traffic characteristics, frequency of output file rollover, etc.
Using a strong compression scheme, block sizes over 10,000 Query/Response pairs would seem to offer limited improvements.
Appendix D.  Data Fields for Traffic Regeneration D.1.
Recommended Fields for Traffic Regeneration
This section specifies the data fields that would need to be captured in order to perform the fullest PCAP traffic reconstruction for well formed DNS messages that is possible with C DNS.
All data fields in the QueryResponse type except response  processing data.
All data fields in the QueryResponseSignature type except qr type.
All data fields in the RR TYPE.
Issues with Small Data Captures
At the other extreme, an interesting corner case arises when opting to perform captures with a smaller data set than that recommended above.
The following list specifies a subset of the above data fields; if only these data fields are captured, then even a minimal traffic reconstruction is problematic because there is not enough information to determine if the Query/Response data item contained just a Query, just a Response, or a Query/Response pair.
In this case, simply also capturing the qr sig flags will provide enough information to perform a minimal traffic reconstruction (assuming that suitable defaults for the remaining fields are provided).
Additionally, capturing response delay, query opcode, and response rcode will avoid having to rely on potentially misleading defaults for these values and should result in a PCAP that represents the basics of the real traffic flow.
