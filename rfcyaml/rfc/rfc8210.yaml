- contents:
  - "   The Resource Public Key Infrastructure (RPKI) to Router Protocol,\n                               Version
    1\n"
  title: __initial_text__
- contents:
  - "Abstract\n   In order to verifiably validate the origin Autonomous Systems and\n
    \  Autonomous System Paths of BGP announcements, routers need a simple\n   but
    reliable mechanism to receive Resource Public Key Infrastructure\n   (RFC 6480)
    prefix origin data and router keys from a trusted cache.\n   This document describes
    a protocol to deliver them.\n   This document describes version 1 of the RPKI-Router
    protocol.  RFC\n   6810 describes version 0.  This document updates RFC 6810.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8210.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Requirements Language . . . . . . . . . . . . . . .
    . . .   4\n     1.2.  Changes from RFC 6810 . . . . . . . . . . . . . . . . .
    .   4\n   2.  Glossary  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n
    \  3.  Deployment Structure  . . . . . . . . . . . . . . . . . . . .   5\n   4.
    \ Operational Overview  . . . . . . . . . . . . . . . . . . . .   6\n   5.  Protocol
    Data Units (PDUs)  . . . . . . . . . . . . . . . . .   7\n     5.1.  Fields of
    a PDU . . . . . . . . . . . . . . . . . . . . .   7\n     5.2.  Serial Notify
    . . . . . . . . . . . . . . . . . . . . . .  10\n     5.3.  Serial Query  . .
    . . . . . . . . . . . . . . . . . . . .  10\n     5.4.  Reset Query . . . . .
    . . . . . . . . . . . . . . . . . .  12\n     5.5.  Cache Response  . . . . .
    . . . . . . . . . . . . . . . .  12\n     5.6.  IPv4 Prefix . . . . . . . . .
    . . . . . . . . . . . . . .  13\n     5.7.  IPv6 Prefix . . . . . . . . . . .
    . . . . . . . . . . . .  14\n     5.8.  End of Data . . . . . . . . . . . . .
    . . . . . . . . . .  15\n     5.9.  Cache Reset . . . . . . . . . . . . . . .
    . . . . . . . .  16\n     5.10. Router Key  . . . . . . . . . . . . . . . . .
    . . . . . .  16\n     5.11. Error Report  . . . . . . . . . . . . . . . . . .
    . . . .  17\n   6.  Protocol Timing Parameters  . . . . . . . . . . . . . . .
    . .  18\n   7.  Protocol Version Negotiation  . . . . . . . . . . . . . . . .
    \ 20\n   8.  Protocol Sequences  . . . . . . . . . . . . . . . . . . . . .  21\n
    \    8.1.  Start or Restart  . . . . . . . . . . . . . . . . . . . .  21\n     8.2.
    \ Typical Exchange  . . . . . . . . . . . . . . . . . . . .  22\n     8.3.  No
    Incremental Update Available . . . . . . . . . . . . .  23\n     8.4.  Cache Has
    No Data Available . . . . . . . . . . . . . . .  23\n   9.  Transport . . . .
    . . . . . . . . . . . . . . . . . . . . . .  24\n     9.1.  SSH Transport . .
    . . . . . . . . . . . . . . . . . . . .  25\n     9.2.  TLS Transport . . . .
    . . . . . . . . . . . . . . . . . .  26\n     9.3.  TCP MD5 Transport . . . .
    . . . . . . . . . . . . . . . .  26\n     9.4.  TCP-AO Transport  . . . . . .
    . . . . . . . . . . . . . .  27\n   10. Router-Cache Setup  . . . . . . . . .
    . . . . . . . . . . . .  27\n   11. Deployment Scenarios  . . . . . . . . . .
    . . . . . . . . . .  28\n   12. Error Codes . . . . . . . . . . . . . . . . .
    . . . . . . . .  29\n   13. Security Considerations . . . . . . . . . . . . .
    . . . . . .  30\n   14. IANA Considerations . . . . . . . . . . . . . . . . .
    . . . .  31\n   15. References  . . . . . . . . . . . . . . . . . . . . . . .
    . .  32\n     15.1.  Normative References . . . . . . . . . . . . . . . . . .
    \ 32\n     15.2.  Informative References . . . . . . . . . . . . . . . . .  34\n
    \  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  35\n   Authors'
    Addresses  . . . . . . . . . . . . . . . . . . . . . . .  35\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In order to verifiably validate the origin Autonomous Systems
    (ASes)\n   and AS paths of BGP announcements, routers need a simple but reliable\n
    \  mechanism to receive cryptographically validated Resource Public Key\n   Infrastructure
    (RPKI) [RFC6480] prefix origin data and router keys\n   from a trusted cache.
    \ This document describes a protocol to deliver\n   them.  The design is intentionally
    constrained to be usable on much\n   of the current generation of ISP router platforms.\n
    \  This document updates [RFC6810].\n   Section 3 describes the deployment structure,
    and Section 4 then\n   presents an operational overview.  The binary payloads
    of the\n   protocol are formally described in Section 5, and the expected\n   Protocol
    Data Unit (PDU) sequences are described in Section 8.  The\n   transport protocol
    options are described in Section 9.  Section 10\n   details how routers and caches
    are configured to connect and\n   authenticate.  Section 11 describes likely deployment
    scenarios.  The\n   traditional security and IANA considerations end the document.\n
    \  The protocol is extensible in order to support new PDUs with new\n   semantics,
    if deployment experience indicates that they are needed.\n   PDUs are versioned
    should deployment experience call for change.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n"
    title: 1.1.  Requirements Language
  - contents:
    - "1.2.  Changes from RFC 6810\n   This section summarizes the significant changes
      between [RFC6810] and\n   the protocol described in this document.\n   o  New
      Router Key PDU type (Section 5.10) added.\n   o  Explicit timing parameters
      (Section 5.8, Section 6) added.\n   o  Protocol version number incremented from
      0 (zero) to 1 (one).\n   o  Protocol version number negotiation (Section 7)
      added.\n"
    title: 1.2.  Changes from RFC 6810
  title: 1.  Introduction
- contents:
  - "2.  Glossary\n   The following terms are used with special meaning.\n   Global
    RPKI:  The authoritative data of the RPKI are published in a\n      distributed
    set of servers at the IANA, Regional Internet\n      Registries (RIRs), National
    Internet Registries (NIRs), and ISPs;\n      see [RFC6481].\n   Cache:  A cache
    is a coalesced copy of the published Global RPKI\n      data, periodically fetched
    or refreshed, directly or indirectly,\n      using the rsync protocol [RFC5781]
    or some successor.  Relying\n      Party software is used to gather and validate
    the distributed data\n      of the RPKI into a cache.  Trusting this cache further
    is a matter\n      between the provider of the cache and a Relying Party.\n   Serial
    Number:  \"Serial Number\" is a 32-bit strictly increasing\n      unsigned integer
    which wraps from 2^32-1 to 0.  It denotes the\n      logical version of a cache.
    \ A cache increments the value when it\n      successfully updates its data from
    a parent cache or from primary\n      RPKI data.  While a cache is receiving updates,
    new incoming data\n      and implicit deletes are associated with the new serial
    but MUST\n      NOT be sent until the fetch is complete.  A Serial Number is not\n
    \     commensurate between different caches or different protocol\n      versions,
    nor need it be maintained across resets of the cache\n      server.  See [RFC1982]
    on DNS Serial Number Arithmetic for too\n      much detail on the topic.\n   Session
    ID:  When a cache server is started, it generates a\n      Session ID to uniquely
    identify the instance of the cache and to\n      bind it to the sequence of Serial
    Numbers that cache instance will\n      generate.  This allows the router to restart
    a failed session\n      knowing that the Serial Number it is using is commensurate
    with\n      that of the cache.\n   Payload PDU:  A payload PDU is a protocol message
    which contains data\n      for use by the router, as opposed to a PDU which conveys
    the\n      control mechanisms of this protocol.  Prefixes and Router Keys are\n
    \     examples of payload PDUs.\n"
  title: 2.  Glossary
- contents:
  - "3.  Deployment Structure\n   Deployment of the RPKI to reach routers has a three-level
    structure\n   as follows:\n   Global RPKI:  The authoritative data of the RPKI
    are published in a\n      distributed set of servers at the IANA, RIRs, NIRs,
    and ISPs (see\n      [RFC6481]).\n   Local Caches:  Local caches are a local set
    of one or more collected\n      and verified caches of RPKI data.  A Relying Party,
    e.g., router\n      or other client, MUST have a trust relationship with, and
    a\n      trusted transport channel to, any cache(s) it uses.\n   Routers:  A router
    fetches data from a local cache using the protocol\n      described in this document.
    \ It is said to be a client of the\n      cache.  There MAY be mechanisms for
    the router to assure itself of\n      the authenticity of the cache and to authenticate
    itself to the\n      cache (see Section 9).\n"
  title: 3.  Deployment Structure
- contents:
  - "4.  Operational Overview\n   A router establishes and keeps open a connection
    to one or more\n   caches with which it has client/server relationships.  It is\n
    \  configured with a semi-ordered list of caches and establishes a\n   connection
    to the most preferred cache, or set of caches, which\n   accept the connections.\n
    \  The router MUST choose the most preferred, by configuration, cache or\n   set
    of caches so that the operator may control load on their caches\n   and the Global
    RPKI.\n   Periodically, the router sends to the cache the most recent Serial\n
    \  Number for which it has received data from that cache, i.e., the\n   router's
    current Serial Number, in the form of a Serial Query.  When\n   a router establishes
    a new session with a cache or wishes to reset a\n   current relationship, it sends
    a Reset Query.\n   The cache responds to the Serial Query with all data changes
    which\n   took place since the given Serial Number.  This may be the null set,\n
    \  in which case the End of Data PDU (Section 5.8) is still sent.  Note\n   that
    the Serial Number comparison used to determine \"since the given\n   Serial Number\"
    MUST take wrap-around into account; see [RFC1982].\n   When the router has received
    all data records from the cache, it sets\n   its current Serial Number to that
    of the Serial Number in the\n   received End of Data PDU.\n   When the cache updates
    its database, it sends a Notify PDU to every\n   currently connected router.  This
    is a hint that now would be a good\n   time for the router to poll for an update,
    but it is only a hint.\n   The protocol requires the router to poll for updates
    periodically in\n   any case.\n   Strictly speaking, a router could track a cache
    simply by asking for\n   a complete data set every time it updates, but this would
    be very\n   inefficient.  The Serial-Number-based incremental update mechanism\n
    \  allows an efficient transfer of just the data records which have\n   changed
    since the last update.  As with any update protocol based on\n   incremental transfers,
    the router must be prepared to fall back to a\n   full transfer if for any reason
    the cache is unable to provide the\n   necessary incremental data.  Unlike some
    incremental transfer\n   protocols, this protocol requires the router to make
    an explicit\n   request to start the fallback process; this is deliberate, as
    the\n   cache has no way of knowing whether the router has also established\n
    \  sessions with other caches that may be able to provide better\n   service.\n
    \  As a cache server must evaluate certificates and ROAs (Route Origin\n   Authorizations;
    see [RFC6480]), which are time dependent, servers'\n   clocks MUST be correct
    to a tolerance of approximately an hour.\n"
  title: 4.  Operational Overview
- contents:
  - "5.  Protocol Data Units (PDUs)\n   The exchanges between the cache and the router
    are sequences of\n   exchanges of the following PDUs according to the rules described
    in\n   Section 8.\n   Reserved fields (marked \"zero\" in PDU diagrams) MUST be
    zero on\n   transmission and MUST be ignored on receipt.\n"
  - contents:
    - "5.1.  Fields of a PDU\n   PDUs contain the following data elements:\n   Protocol
      Version:  An 8-bit unsigned integer, currently 1, denoting\n      the version
      of this protocol.\n   PDU Type:  An 8-bit unsigned integer, denoting the type
      of the PDU,\n      e.g., IPv4 Prefix.\n   Serial Number:  The Serial Number
      of the RPKI cache when this set of\n      PDUs was received from an upstream
      cache server or gathered from\n      the Global RPKI.  A cache increments its
      Serial Number when\n      completing a rigorously validated update from a parent
      cache or\n      the Global RPKI.\n   Session ID:  A 16-bit unsigned integer.
      \ When a cache server is\n      started, it generates a Session ID to identify
      the instance of the\n      cache and to bind it to the sequence of Serial Numbers
      that cache\n      instance will generate.  This allows the router to restart
      a\n      failed session knowing that the Serial Number it is using is\n      commensurate
      with that of the cache.  If, at any time after the\n      protocol version has
      been negotiated (Section 7), either the\n      router or the cache finds that
      the value of the Session ID is not\n      the same as the other's, the party
      which detects the mismatch MUST\n      immediately terminate the session with
      an Error Report PDU with\n      code 0 (\"Corrupt Data\"), and the router MUST
      flush all data\n      learned from that cache.\n      Note that sessions are
      specific to a particular protocol version.\n      That is, if a cache server
      supports multiple versions of this\n      protocol, happens to use the same
      Session ID value for multiple\n      protocol versions, and further happens
      to use the same Serial\n      Number values for two or more sessions using the
      same Session ID\n      but different Protocol Version values, the Serial Numbers
      are not\n      commensurate.  The full test for whether Serial Numbers are\n
      \     commensurate requires comparing Protocol Version, Session ID, and\n      Serial
      Number.  To reduce the risk of confusion, cache servers\n      SHOULD NOT use
      the same Session ID across multiple protocol\n      versions, but even if they
      do, routers MUST treat sessions with\n      different Protocol Version fields
      as separate sessions even if\n      they do happen to have the same Session
      ID.\n      Should a cache erroneously reuse a Session ID so that a router\n
      \     does not realize that the session has changed (old Session ID and\n      new
      Session ID have the same numeric value), the router may become\n      confused
      as to the content of the cache.  The time it takes the\n      router to discover
      that it is confused will depend on whether the\n      Serial Numbers are also
      reused.  If the Serial Numbers in the old\n      and new sessions are different
      enough, the cache will respond to\n      the router's Serial Query with a Cache
      Reset, which will solve the\n      problem.  If, however, the Serial Numbers
      are close, the cache may\n      respond with a Cache Response, which may not
      be enough to bring\n      the router into sync.  In such cases, it's likely
      but not certain\n      that the router will detect some discrepancy between
      the state\n      that the cache expects and its own state.  For example, the
      Cache\n      Response may tell the router to drop a record which the router\n
      \     does not hold or may tell the router to add a record which the\n      router
      already has.  In such cases, a router will detect the error\n      and reset
      the session.  The one case in which the router may stay\n      out of sync is
      when nothing in the Cache Response contradicts any\n      data currently held
      by the router.\n      Using persistent storage for the Session ID or a clock-based\n
      \     scheme for generating Session IDs should avoid the risk of\n      Session
      ID collisions.\n      The Session ID might be a pseudorandom value, a strictly\n
      \     increasing value if the cache has reliable storage, et cetera.  A\n      seconds-since-epoch
      timestamp value such as the POSIX time()\n      function makes a good Session
      ID value.\n   Length:  A 32-bit unsigned integer which has as its value the
      count\n      of the bytes in the entire PDU, including the 8 bytes of header\n
      \     which includes the length field.\n   Flags:  The lowest-order bit of the
      Flags field is 1 for an\n      announcement and 0 for a withdrawal.  For a Prefix
      PDU (IPv4 or\n      IPv6), the flag indicates whether this PDU announces a new
      right\n      to announce the prefix or withdraws a previously announced right;\n
      \     a withdraw effectively deletes one previously announced Prefix PDU\n      with
      the exact same Prefix, Length, Max-Len, and Autonomous System\n      Number
      (ASN).  Similarly, for a Router Key PDU, the flag indicates\n      whether this
      PDU announces a new Router Key or deletes one\n      previously announced Router
      Key PDU with the exact same AS Number,\n      subjectKeyIdentifier, and subjectPublicKeyInfo.\n
      \     The remaining bits in the Flags field are reserved for future use.\n      In
      protocol version 1, they MUST be zero on transmission and MUST\n      be ignored
      on receipt.\n   Prefix Length:  An 8-bit unsigned integer denoting the shortest\n
      \     prefix allowed by the Prefix element.\n   Max Length:  An 8-bit unsigned
      integer denoting the longest prefix\n      allowed by the Prefix element.  This
      MUST NOT be less than the\n      Prefix Length element.\n   Prefix:  The IPv4
      or IPv6 prefix of the ROA.\n   Autonomous System Number:  A 32-bit unsigned
      integer representing an\n      ASN allowed to announce a prefix or associated
      with a router key.\n   Subject Key Identifier:  20-octet Subject Key Identifier
      (SKI) value\n      of a router key, as described in [RFC6487].\n   Subject Public
      Key Info:  A router key's subjectPublicKeyInfo value,\n      as described in
      [RFC8208].  This is the full ASN.1 DER encoding of\n      the subjectPublicKeyInfo,
      including the ASN.1 tag and length\n      values of the subjectPublicKeyInfo
      SEQUENCE.\n   Refresh Interval:  Interval between normal cache polls.  See\n
      \     Section 6.\n   Retry Interval:  Interval between cache poll retries after
      a failed\n      cache poll.  See Section 6.\n   Expire Interval:  Interval during
      which data fetched from a cache\n      remains valid in the absence of a successful
      subsequent cache\n      poll.  See Section 6.\n"
    title: 5.1.  Fields of a PDU
  - contents:
    - "5.2.  Serial Notify\n   The cache notifies the router that the cache has new
      data.\n   The Session ID reassures the router that the Serial Numbers are\n
      \  commensurate, i.e., the cache session has not been changed.\n   Upon receipt
      of a Serial Notify PDU, the router MAY issue an\n   immediate Serial Query (Section
      5.3) or Reset Query (Section 5.4)\n   without waiting for the Refresh Interval
      timer (see Section 6) to\n   expire.\n   Serial Notify is the only message that
      the cache can send that is not\n   in response to a message from the router.\n
      \  If the router receives a Serial Notify PDU during the initial startup\n   period
      where the router and cache are still negotiating to agree on a\n   protocol
      version, the router MUST simply ignore the Serial Notify\n   PDU, even if the
      Serial Notify PDU is for an unexpected protocol\n   version.  See Section 7
      for details.\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \    Session ID      |\n   |    1     |    0     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                Length=12
      \                 |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |               Serial
      Number               |\n   |                                           |\n   `-------------------------------------------'\n"
    title: 5.2.  Serial Notify
  - contents:
    - "5.3.  Serial Query\n   The router sends a Serial Query to ask the cache for
      all\n   announcements and withdrawals which have occurred since the Serial\n
      \  Number specified in the Serial Query.\n   The cache replies to this query
      with a Cache Response PDU\n   (Section 5.5) if the cache has a (possibly null)
      record of the\n   changes since the Serial Number specified by the router, followed
      by\n   zero or more payload PDUs and an End Of Data PDU (Section 5.8).\n   When
      replying to a Serial Query, the cache MUST return the minimum\n   set of changes
      needed to bring the router into sync with the cache.\n   That is, if a particular
      prefix or router key underwent multiple\n   changes between the Serial Number
      specified by the router and the\n   cache's current Serial Number, the cache
      MUST merge those changes to\n   present the simplest possible view of those
      changes to the router.\n   In general, this means that, for any particular prefix
      or router key,\n   the data stream will include at most one withdrawal followed
      by at\n   most one announcement, and if all of the changes cancel out, the data\n
      \  stream will not mention the prefix or router key at all.\n   The rationale
      for this approach is that the entire purpose of the\n   RPKI-Router protocol
      is to offload work from the router to the cache,\n   and it should therefore
      be the cache's job to simplify the change\n   set, thus reducing work for the
      router.\n   If the cache does not have the data needed to update the router,\n
      \  perhaps because its records do not go back to the Serial Number in\n   the
      Serial Query, then it responds with a Cache Reset PDU\n   (Section 5.9).\n   The
      Session ID tells the cache what instance the router expects to\n   ensure that
      the Serial Numbers are commensurate, i.e., the cache\n   session has not been
      changed.\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \    Session ID      |\n   |    1     |    1     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=12
      \                |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |               Serial
      Number               |\n   |                                           |\n   `-------------------------------------------'\n"
    title: 5.3.  Serial Query
  - contents:
    - "5.4.  Reset Query\n   The router tells the cache that it wants to receive the
      total active,\n   current, non-withdrawn database.  The cache responds with
      a Cache\n   Response PDU (Section 5.5), followed by zero or more payload PDUs
      and\n   an End of Data PDU (Section 5.8).\n   0          8          16         24
      \       31\n   .-------------------------------------------.\n   | Protocol
      |   PDU    |                     |\n   | Version  |   Type   |         zero
      \       |\n   |    1     |    2     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=8
      \                 |\n   |                                           |\n   `-------------------------------------------'\n"
    title: 5.4.  Reset Query
  - contents:
    - "5.5.  Cache Response\n   The cache responds to queries with zero or more payload
      PDUs.  When\n   replying to a Serial Query (Section 5.3), the cache sends the
      set of\n   announcements and withdrawals that have occurred since the Serial\n
      \  Number sent by the client router.  When replying to a Reset Query\n   (Section
      5.4), the cache sends the set of all data records it has; in\n   this case,
      the withdraw/announce field in the payload PDUs MUST have\n   the value 1 (announce).\n
      \  In response to a Reset Query, the new value of the Session ID tells\n   the
      router the instance of the cache session for future confirmation.\n   In response
      to a Serial Query, the Session ID being the same\n   reassures the router that
      the Serial Numbers are commensurate, i.e.,\n   the cache session has not been
      changed.\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \    Session ID      |\n   |    1     |    3     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=8
      \                 |\n   |                                           |\n   `-------------------------------------------'\n"
    title: 5.5.  Cache Response
  - contents:
    - "5.6.  IPv4 Prefix\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \        zero        |\n   |    1     |    4     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=20
      \                |\n   |                                           |\n   +-------------------------------------------+\n
      \  |          |  Prefix  |   Max    |          |\n   |  Flags   |  Length  |
      \ Length  |   zero   |\n   |          |   0..32  |   0..32  |          |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                IPv4 Prefix
      \               |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |         Autonomous System
      Number          |\n   |                                           |\n   `-------------------------------------------'\n
      \  The lowest-order bit of the Flags field is 1 for an announcement and\n   0
      for a withdrawal.\n   In the RPKI, nothing prevents a signing certificate from
      issuing two\n   identical ROAs.  In this case, there would be no semantic difference\n
      \  between the objects, merely a process redundancy.\n   In the RPKI, there
      is also an actual need for what might appear to a\n   router as identical IPvX
      PDUs.  This can occur when an upstream\n   certificate is being reissued or
      there is an address ownership\n   transfer up the validation chain.  The ROA
      would be identical in the\n   router sense, i.e., have the same {Prefix, Len,
      Max-Len, ASN}, but it\n   would have a different validation path in the RPKI.
      \ This is\n   important to the RPKI but not to the router.\n   The cache server
      MUST ensure that it has told the router client to\n   have one and only one
      IPvX PDU for a unique {Prefix, Len, Max-Len,\n   ASN} at any one point in time.
      \ Should the router client receive an\n   IPvX PDU with a {Prefix, Len, Max-Len,
      ASN} identical to one it\n   already has active, it SHOULD raise a Duplicate
      Announcement Received\n   error.\n"
    title: 5.6.  IPv4 Prefix
  - contents:
    - "5.7.  IPv6 Prefix\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \        zero        |\n   |    1     |    6     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=32
      \                |\n   |                                           |\n   +-------------------------------------------+\n
      \  |          |  Prefix  |   Max    |          |\n   |  Flags   |  Length  |
      \ Length  |   zero   |\n   |          |  0..128  |  0..128  |          |\n   +-------------------------------------------+\n
      \  |                                           |\n   +---                                     ---+\n
      \  |                                           |\n   +---            IPv6 Prefix
      \             ---+\n   |                                           |\n   +---
      \                                    ---+\n   |                                           |\n
      \  +-------------------------------------------+\n   |                                           |\n
      \  |         Autonomous System Number          |\n   |                                           |\n
      \  `-------------------------------------------'\n   Analogous to the IPv4 Prefix
      PDU, it has 96 more bits and no magic.\n"
    title: 5.7.  IPv6 Prefix
  - contents:
    - "5.8.  End of Data\n   The cache tells the router it has no more data for the
      request.\n   The Session ID and Protocol Version MUST be the same as that of
      the\n   corresponding Cache Response which began the (possibly null) sequence\n
      \  of payload PDUs.\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \    Session ID      |\n   |    1     |    7     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=24
      \                |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |               Serial
      Number               |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |              Refresh
      Interval             |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |               Retry Interval
      \             |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |              Expire Interval
      \             |\n   |                                           |\n   `-------------------------------------------'\n
      \  The Refresh Interval, Retry Interval, and Expire Interval are all\n   32-bit
      elapsed times measured in seconds.  They express the timing\n   parameters which
      the cache expects the router to use in deciding when\n   to send subsequent
      Serial Query or Reset Query PDUs to the cache.\n   See Section 6 for an explanation
      of the use and the range of allowed\n   values for these parameters.\n"
    title: 5.8.  End of Data
  - contents:
    - "5.9.  Cache Reset\n   The cache may respond to a Serial Query informing the
      router that the\n   cache cannot provide an incremental update starting from
      the Serial\n   Number specified by the router.  The router must decide whether
      to\n   issue a Reset Query or switch to a different cache.\n   0          8
      \         16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \        zero        |\n   |    1     |    8     |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 Length=8
      \                 |\n   |                                           |\n   `-------------------------------------------'\n"
    title: 5.9.  Cache Reset
  - contents:
    - "5.10.  Router Key\n   0          8          16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |          |          |\n   | Version  |   Type   |
      \  Flags  |   zero   |\n   |    1     |    9     |          |          |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                  Length
      \                  |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   +---                                     ---+\n
      \  |          Subject Key Identifier           |\n   +---                                     ---+\n
      \  |                                           |\n   +---                                     ---+\n
      \  |                (20 octets)                |\n   +---                                     ---+\n
      \  |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                 AS Number
      \                |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |          Subject Public
      Key Info          |\n   |                                           |\n   `-------------------------------------------'\n
      \  The lowest-order bit of the Flags field is 1 for an announcement and\n   0
      for a withdrawal.\n   The cache server MUST ensure that it has told the router
      client to\n   have one and only one Router Key PDU for a unique {SKI, ASN, Subject\n
      \  Public Key} at any one point in time.  Should the router client\n   receive
      a Router Key PDU with a {SKI, ASN, Subject Public Key}\n   identical to one
      it already has active, it SHOULD raise a Duplicate\n   Announcement Received
      error.\n   Note that a particular ASN may appear in multiple Router Key PDUs\n
      \  with different Subject Public Key values, while a particular Subject\n   Public
      Key value may appear in multiple Router Key PDUs with\n   different ASNs.  In
      the interest of keeping the announcement and\n   withdrawal semantics as simple
      as possible for the router, this\n   protocol makes no attempt to compress either
      of these cases.\n   Also note that it is possible, albeit very unlikely, for
      multiple\n   distinct Subject Public Key values to hash to the same SKI.  For
      this\n   reason, implementations MUST compare Subject Public Key values as\n
      \  well as SKIs when detecting duplicate PDUs.\n"
    title: 5.10.  Router Key
  - contents:
    - "5.11.  Error Report\n   This PDU is used by either party to report an error
      to the other.\n   Error reports are only sent as responses to other PDUs, not
      to report\n   errors in Error Report PDUs.\n   Error codes are described in
      Section 12.\n   If the error is generic (e.g., \"Internal Error\") and not associated\n
      \  with the PDU to which it is responding, the Erroneous PDU field MUST\n   be
      empty and the Length of Encapsulated PDU field MUST be zero.\n   An Error Report
      PDU MUST NOT be sent for an Error Report PDU.  If an\n   erroneous Error Report
      PDU is received, the session SHOULD be\n   dropped.\n   If the error is associated
      with a PDU of excessive length, i.e., too\n   long to be any legal PDU other
      than another Error Report, or a\n   possibly corrupt length, the Erroneous PDU
      field MAY be truncated.\n   The diagnostic text is optional; if not present,
      the Length of Error\n   Text field MUST be zero.  If error text is present,
      it MUST be a\n   string in UTF-8 encoding (see [RFC3629]).\n   0          8
      \         16         24        31\n   .-------------------------------------------.\n
      \  | Protocol |   PDU    |                     |\n   | Version  |   Type   |
      \    Error Code      |\n   |    1     |    10    |                     |\n   +-------------------------------------------+\n
      \  |                                           |\n   |                  Length
      \                  |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |       Length of Encapsulated
      PDU          |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   ~               Erroneous
      PDU               ~\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |           Length of Error
      Text            |\n   |                                           |\n   +-------------------------------------------+\n
      \  |                                           |\n   |              Arbitrary
      Text               |\n   |                    of                     |\n   ~
      \         Error Diagnostic Message         ~\n   |                                           |\n
      \  `-------------------------------------------'\n"
    title: 5.11.  Error Report
  title: 5.  Protocol Data Units (PDUs)
- contents:
  - "6.  Protocol Timing Parameters\n   Since the data the cache distributes via the
    RPKI-Router protocol are\n   retrieved from the Global RPKI system at intervals
    which are only\n   known to the cache, only the cache can really know how frequently
    it\n   makes sense for the router to poll the cache, or how long the data\n   are
    likely to remain valid (or, at least, unchanged).  For this\n   reason, as well
    as to allow the cache some control over the load\n   placed on it by its client
    routers, the End Of Data PDU includes\n   three values that allow the cache to
    communicate timing parameters to\n   the router:\n   Refresh Interval:  This parameter
    tells the router how long to wait\n      before next attempting to poll the cache
    and between subsequent\n      attempts, using a Serial Query or Reset Query PDU.
    \ The router\n      SHOULD NOT poll the cache sooner than indicated by this parameter.\n
    \     Note that receipt of a Serial Notify PDU overrides this interval\n      and
    suggests that the router issue an immediate query without\n      waiting for the
    Refresh Interval to expire.  Countdown for this\n      timer starts upon receipt
    of the containing End Of Data PDU.\n      Minimum allowed value:  1 second.\n
    \     Maximum allowed value:  86400 seconds (1 day).\n      Recommended default:
    \ 3600 seconds (1 hour).\n   Retry Interval:  This parameter tells the router
    how long to wait\n      before retrying a failed Serial Query or Reset Query.
    \ The router\n      SHOULD NOT retry sooner than indicated by this parameter.
    \ Note\n      that a protocol version mismatch overrides this interval: if the\n
    \     router needs to downgrade to a lower protocol version number, it\n      MAY
    send the first Serial Query or Reset Query immediately.\n      Countdown for this
    timer starts upon failure of the query and\n      restarts after each subsequent
    failure until a query succeeds.\n      Minimum allowed value:  1 second.\n      Maximum
    allowed value:  7200 seconds (2 hours).\n      Recommended default:  600 seconds
    (10 minutes).\n   Expire Interval:  This parameter tells the router how long it
    can\n      continue to use the current version of the data while unable to\n      perform
    a successful subsequent query.  The router MUST NOT retain\n      the data past
    the time indicated by this parameter.  Countdown for\n      this timer starts
    upon receipt of the containing End Of Data PDU.\n      Minimum allowed value:
    \ 600 seconds (10 minutes).\n      Maximum allowed value:  172800 seconds (2 days).\n
    \     Recommended default:  7200 seconds (2 hours).\n   If the router has never
    issued a successful query against a\n   particular cache, it SHOULD retry periodically
    using the default\n   Retry Interval, above.\n   Caches MUST set Expire Interval
    to a value larger than either Refresh\n   Interval or Retry Interval.\n"
  title: 6.  Protocol Timing Parameters
- contents:
  - "7.  Protocol Version Negotiation\n   A router MUST start each transport connection
    by issuing either a\n   Reset Query or a Serial Query.  This query will tell the
    cache which\n   version of this protocol the router implements.\n   If a cache
    which supports version 1 receives a query from a router\n   which specifies version
    0, the cache MUST downgrade to protocol\n   version 0 [RFC6810] or send a version
    1 Error Report PDU with Error\n   Code 4 (\"Unsupported Protocol Version\") and
    terminate the connection.\n   If a router which supports version 1 sends a query
    to a cache which\n   only supports version 0, one of two things will happen:\n
    \  1.  The cache may terminate the connection, perhaps with a version 0\n       Error
    Report PDU.  In this case, the router MAY retry the\n       connection using protocol
    version 0.\n   2.  The cache may reply with a version 0 response.  In this case,
    the\n       router MUST either downgrade to version 0 or terminate the\n       connection.\n
    \  In any of the downgraded combinations above, the new features of\n   version
    1 will not be available, and all PDUs will have 0 in their\n   version fields.\n
    \  If either party receives a PDU containing an unrecognized Protocol\n   Version
    (neither 0 nor 1) during this negotiation, it MUST either\n   downgrade to a known
    version or terminate the connection, with an\n   Error Report PDU unless the received
    PDU is itself an Error\n   Report PDU.\n   The router MUST ignore any Serial Notify
    PDUs it might receive from\n   the cache during this initial startup period, regardless
    of the\n   Protocol Version field in the Serial Notify PDU.  Since Session ID\n
    \  and Serial Number values are specific to a particular protocol\n   version,
    the values in the notification are not useful to the router.\n   Even if these
    values were meaningful, the only effect that processing\n   the notification would
    have would be to trigger exactly the same\n   Reset Query or Serial Query that
    the router has already sent as part\n   of the not-yet-complete version negotiation
    process, so there is\n   nothing to be gained by processing notifications until
    version\n   negotiation completes.\n   Caches SHOULD NOT send Serial Notify PDUs
    before version negotiation\n   completes.  Routers, however, MUST handle such
    notifications (by\n   ignoring them) for backwards compatibility with caches serving\n
    \  protocol version 0.\n   Once the cache and router have agreed upon a Protocol
    Version via the\n   negotiation process above, that version is stable for the
    life of the\n   session.  See Section 5.1 for a discussion of the interaction
    between\n   Protocol Version and Session ID.\n   If either party receives a PDU
    for a different Protocol Version once\n   the above negotiation completes, that
    party MUST drop the session;\n   unless the PDU containing the unexpected Protocol
    Version was itself\n   an Error Report PDU, the party dropping the session SHOULD
    send an\n   Error Report with an error code of 8 (\"Unexpected Protocol Version\").\n"
  title: 7.  Protocol Version Negotiation
- contents:
  - "8.  Protocol Sequences\n   The sequences of PDU transmissions fall into four
    conversations as\n   follows:\n"
  - contents:
    - "8.1.  Start or Restart\n   Cache                         Router\n     ~                             ~\n
      \    | <----- Reset Query -------- | R requests data (or Serial Query)\n     |
      \                            |\n     | ----- Cache Response -----> | C confirms
      request\n     | ------- Payload PDU ------> | C sends zero or more\n     | -------
      Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n     | ------- Payload PDU
      ------> |   or Router Key PDUs\n     | ------- End of Data ------> | C sends
      End of Data\n     |                             |   and sends new serial\n     ~
      \                            ~\n   When a transport connection is first established,
      the router MUST\n   send either a Reset Query or a Serial Query.  A Serial Query
      would be\n   appropriate if the router has significant unexpired data from a\n
      \  broken session with the same cache and remembers the Session ID of\n   that
      session, in which case a Serial Query containing the Session ID\n   from the
      previous session will allow the router to bring itself up to\n   date while
      ensuring that the Serial Numbers are commensurate and that\n   the router and
      cache are speaking compatible versions of the\n   protocol.  In all other cases,
      the router lacks the necessary data\n   for fast resynchronization and therefore
      MUST fall back to a Reset\n   Query.\n   The Reset Query sequence is also used
      when the router receives a\n   Cache Reset, chooses a new cache, or fears that
      it has otherwise lost\n   its way.\n   See Section 7 for details on version
      negotiation.\n   To limit the length of time a cache must keep the data necessary
      to\n   generate incremental updates, a router MUST send either a Serial\n   Query
      or a Reset Query periodically.  This also acts as a keep-alive\n   at the application
      layer.  See Section 6 for details on the required\n   polling frequency.\n"
    title: 8.1.  Start or Restart
  - contents:
    - "8.2.  Typical Exchange\n   Cache                         Router\n     ~                             ~\n
      \    | -------- Notify ----------> |  (optional)\n     |                             |\n
      \    | <----- Serial Query ------- | R requests data\n     |                             |\n
      \    | ----- Cache Response -----> | C confirms request\n     | ------- Payload
      PDU ------> | C sends zero or more\n     | ------- Payload PDU ------> |   IPv4
      Prefix, IPv6 Prefix,\n     | ------- Payload PDU ------> |   or Router Key PDUs\n
      \    | ------- End of Data ------> | C sends End of Data\n     |                             |
      \  and sends new serial\n     ~                             ~\n   The cache
      server SHOULD send a Notify PDU with its current Serial\n   Number when the
      cache's serial changes, with the expectation that the\n   router MAY then issue
      a Serial Query earlier than it otherwise might.\n   This is analogous to DNS
      NOTIFY in [RFC1996].  The cache MUST\n   rate-limit Serial Notifies to no more
      frequently than one per minute.\n   When the transport layer is up and either
      a timer has gone off in the\n   router or the cache has sent a Notify PDU, the
      router queries for new\n   data by sending a Serial Query, and the cache sends
      all data newer\n   than the serial in the Serial Query.\n   To limit the length
      of time a cache must keep old withdraws, a router\n   MUST send either a Serial
      Query or a Reset Query periodically.  See\n   Section 6 for details on the required
      polling frequency.\n"
    title: 8.2.  Typical Exchange
  - contents:
    - "8.3.  No Incremental Update Available\n   Cache                         Router\n
      \    ~                             ~\n     | <------ Serial Query ------ | R
      requests data\n     | ------- Cache Reset ------> | C cannot supply update\n
      \    |                             |   from specified serial\n     | <------
      Reset Query ------- | R requests new data\n     | ----- Cache Response ----->
      | C confirms request\n     | ------- Payload PDU ------> | C sends zero or more\n
      \    | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n     | -------
      Payload PDU ------> |   or Router Key PDUs\n     | ------- End of Data ------>
      | C sends End of Data\n     |                             |   and sends new
      serial\n     ~                             ~\n   The cache may respond to a
      Serial Query with a Cache Reset, informing\n   the router that the cache cannot
      supply an incremental update from\n   the Serial Number specified by the router.
      \ This might be because the\n   cache has lost state, or because the router
      has waited too long\n   between polls and the cache has cleaned up old data
      that it no longer\n   believes it needs, or because the cache has run out of
      storage space\n   and had to expire some old data early.  Regardless of how
      this state\n   arose, the cache replies with a Cache Reset to tell the router
      that\n   it cannot honor the request.  When a router receives this, the router\n
      \  SHOULD attempt to connect to any more-preferred caches in its cache\n   list.
      \ If there are no more-preferred caches, it MUST issue a Reset\n   Query and
      get an entire new load from the cache.\n"
    title: 8.3.  No Incremental Update Available
  - contents:
    - "8.4.  Cache Has No Data Available\n   Cache                         Router\n
      \    ~                             ~\n     | <------ Serial Query ------ | R
      requests data\n     | ---- Error Report PDU ----> | C No Data Available\n     ~
      \                            ~\n   Cache                         Router\n     ~
      \                            ~\n     | <------ Reset Query ------- | R requests
      data\n     | ---- Error Report PDU ----> | C No Data Available\n     ~                             ~\n
      \  The cache may respond to either a Serial Query or a Reset Query\n   informing
      the router that the cache cannot supply any update at all.\n   The most likely
      cause is that the cache has lost state, perhaps due\n   to a restart, and has
      not yet recovered.  While it is possible that a\n   cache might go into such
      a state without dropping any of its active\n   sessions, a router is more likely
      to see this behavior when it\n   initially connects and issues a Reset Query
      while the cache is still\n   rebuilding its database.\n   When a router receives
      this kind of error, the router SHOULD attempt\n   to connect to any other caches
      in its cache list, in preference\n   order.  If no other caches are available,
      the router MUST issue\n   periodic Reset Queries until it gets a new usable
      load from the\n   cache.\n"
    title: 8.4.  Cache Has No Data Available
  title: 8.  Protocol Sequences
- contents:
  - "9.  Transport\n   The transport-layer session between a router and a cache carries
    the\n   binary PDUs in a persistent session.\n   To prevent cache spoofing and
    DoS attacks by illegitimate routers, it\n   is highly desirable that the router
    and the cache be authenticated to\n   each other.  Integrity protection for payloads
    is also desirable to\n   protect against monkey-in-the-middle (MITM) attacks.
    \ Unfortunately,\n   there is no protocol to do so on all currently used platforms.\n
    \  Therefore, as of the writing of this document, there is no mandatory-\n   to-implement
    transport which provides authentication and integrity\n   protection.\n   To reduce
    exposure to dropped but non-terminated sessions, both\n   caches and routers SHOULD
    enable keep-alives when available in the\n   chosen transport protocol.\n   It
    is expected that, when the TCP Authentication Option (TCP-AO)\n   [RFC5925] is
    available on all platforms deployed by operators, it\n   will become the mandatory-to-implement
    transport.\n   Caches and routers MUST implement unprotected transport over TCP\n
    \  using a port, rpki-rtr (323); see Section 14.  Operators SHOULD use\n   procedural
    means, e.g., access control lists (ACLs), to reduce the\n   exposure to authentication
    issues.\n   If unprotected TCP is the transport, the cache and routers MUST be
    on\n   the same trusted and controlled network.\n   If available to the operator,
    caches and routers MUST use one of the\n   following more protected protocols:\n
    \  o  Caches and routers SHOULD use TCP-AO transport [RFC5925] over the\n      rpki-rtr
    port.\n   o  Caches and routers MAY use Secure Shell version 2 (SSHv2)\n      transport
    [RFC4252] using the normal SSH port.  For an example,\n      see Section 9.1.\n
    \  o  Caches and routers MAY use TCP MD5 transport [RFC2385] using the\n      rpki-rtr
    port.  Note that TCP MD5 has been obsoleted by TCP-AO\n      [RFC5925].\n   o
    \ Caches and routers MAY use TCP over IPsec transport [RFC4301]\n      using the
    rpki-rtr port.\n   o  Caches and routers MAY use Transport Layer Security (TLS)\n
    \     transport [RFC5246] using port rpki-rtr-tls (324); see Section 14.\n"
  - contents:
    - "9.1.  SSH Transport\n   To run over SSH, the client router first establishes
      an SSH transport\n   connection using the SSHv2 transport protocol, and the
      client and\n   server exchange keys for message integrity and encryption.  The\n
      \  client then invokes the \"ssh-userauth\" service to authenticate the\n   application,
      as described in the SSH authentication protocol\n   [RFC4252].  Once the application
      has been successfully authenticated,\n   the client invokes the \"ssh-connection\"
      service, also known as the\n   SSH connection protocol.\n   After the ssh-connection
      service is established, the client opens a\n   channel of type \"session\",
      which results in an SSH session.\n   Once the SSH session has been established,
      the application invokes\n   the application transport as an SSH subsystem called
      \"rpki-rtr\".\n   Subsystem support is a feature of SSHv2 and is not included
      in SSHv1.\n   Running this protocol as an SSH subsystem avoids the need for
      the\n   application to recognize shell prompts or skip over extraneous\n   information,
      such as a system message that is sent at shell startup.\n   It is assumed that
      the router and cache have exchanged keys out of\n   band by some reasonably
      secured means.\n   Cache servers supporting SSH transport MUST accept RSA authentication\n
      \  and SHOULD accept Elliptic Curve Digital Signature Algorithm (ECDSA)\n   authentication.
      \ User authentication MUST be supported; host\n   authentication MAY be supported.
      \ Implementations MAY support\n   password authentication.  Client routers SHOULD
      verify the public key\n   of the cache to avoid MITM attacks.\n"
    title: 9.1.  SSH Transport
  - contents:
    - "9.2.  TLS Transport\n   Client routers using TLS transport MUST present client-side\n
      \  certificates to authenticate themselves to the cache in order to\n   allow
      the cache to manage the load by rejecting connections from\n   unauthorized
      routers.  In principle, any type of certificate and\n   Certification Authority
      (CA) may be used; however, in general, cache\n   operators will wish to create
      their own small-scale CA and issue\n   certificates to each authorized router.
      \ This simplifies credential\n   rollover; any unrevoked, unexpired certificate
      from the proper CA may\n   be used.\n   Certificates used to authenticate client
      routers in this protocol\n   MUST include a subjectAltName extension [RFC5280]
      containing one or\n   more iPAddress identities; when authenticating the router's\n
      \  certificate, the cache MUST check the IP address of the TLS\n   connection
      against these iPAddress identities and SHOULD reject the\n   connection if none
      of the iPAddress identities match the connection.\n   Routers MUST also verify
      the cache's TLS server certificate, using\n   subjectAltName dNSName identities
      as described in [RFC6125], to avoid\n   MITM attacks.  The rules and guidelines
      defined in [RFC6125] apply\n   here, with the following considerations:\n   o
      \ Support for the DNS-ID identifier type (that is, the dNSName\n      identity
      in the subjectAltName extension) is REQUIRED in rpki-rtr\n      server and client
      implementations which use TLS.  Certification\n      authorities which issue
      rpki-rtr server certificates MUST support\n      the DNS-ID identifier type,
      and the DNS-ID identifier type MUST be\n      present in rpki-rtr server certificates.\n
      \  o  DNS names in rpki-rtr server certificates SHOULD NOT contain the\n      wildcard
      character \"*\".\n   o  rpki-rtr implementations which use TLS MUST NOT use
      Common Name\n      (CN-ID) identifiers; a CN field may be present in the server\n
      \     certificate's subject name but MUST NOT be used for authentication\n      within
      the rules described in [RFC6125].\n   o  The client router MUST set its \"reference
      identifier\" to the DNS\n      name of the rpki-rtr cache.\n"
    title: 9.2.  TLS Transport
  - contents:
    - "9.3.  TCP MD5 Transport\n   If TCP MD5 is used, implementations MUST support
      key lengths of at\n   least 80 printable ASCII bytes, per Section 4.5 of [RFC2385].\n
      \  Implementations MUST also support hexadecimal sequences of at least\n   32
      characters, i.e., 128 bits.\n   Key rollover with TCP MD5 is problematic.  Cache
      servers SHOULD\n   support [RFC4808].\n"
    title: 9.3.  TCP MD5 Transport
  - contents:
    - "9.4.  TCP-AO Transport\n   Implementations MUST support key lengths of at least
      80 printable\n   ASCII bytes.  Implementations MUST also support hexadecimal
      sequences\n   of at least 32 characters, i.e., 128 bits.  Message Authentication\n
      \  Code (MAC) lengths of at least 96 bits MUST be supported, per\n   Section
      5.1 of [RFC5925].\n   The cryptographic algorithms and associated parameters
      described in\n   [RFC5926] MUST be supported.\n"
    title: 9.4.  TCP-AO Transport
  title: 9.  Transport
- contents:
  - "10.  Router-Cache Setup\n   A cache has the public authentication data for each
    router it is\n   configured to support.\n   A router may be configured to peer
    with a selection of caches, and a\n   cache may be configured to support a selection
    of routers.  Each must\n   have the name of, and authentication data for, each
    peer.  In\n   addition, in a router, this list has a non-unique preference value\n
    \  for each server.  This preference merely denotes proximity, not\n   trust,
    preferred belief, et cetera.  The client router attempts to\n   establish a session
    with each potential serving cache in preference\n   order and then starts to load
    data from the most preferred cache to\n   which it can connect and authenticate.
    \ The router's list of caches\n   has the following elements:\n   Preference:
    \ An unsigned integer denoting the router's preference to\n      connect to that
    cache; the lower the value, the more preferred.\n   Name:  The IP address or fully
    qualified domain name of the cache.\n   Cache Credential(s):  Any credential (such
    as a public key) needed to\n      authenticate the cache's identity to the router.\n
    \  Router Credential(s):  Any credential (such as a private key or\n      certificate)
    needed to authenticate the router's identity to the\n      cache.\n   Due to the
    distributed nature of the RPKI, caches simply cannot be\n   rigorously synchronous.
    \ A client may hold data from multiple caches\n   but MUST keep the data marked
    as to source, as later updates MUST\n   affect the correct data.\n   Just as there
    may be more than one covering ROA from a single cache,\n   there may be multiple
    covering ROAs from multiple caches.  The\n   results are as described in [RFC6811].\n
    \  If data from multiple caches are held, implementations MUST NOT\n   distinguish
    between data sources when performing validation of BGP\n   announcements.\n   When
    a more-preferred cache becomes available, if resources allow, it\n   would be
    prudent for the client to start fetching from that cache.\n   The client SHOULD
    attempt to maintain at least one set of data,\n   regardless of whether it has
    chosen a different cache or established\n   a new connection to the previous cache.\n
    \  A client MAY drop the data from a particular cache when it is fully\n   in
    sync with one or more other caches.\n   See Section 6 for details on what to do
    when the client is not able\n   to refresh from a particular cache.\n   If a client
    loses connectivity to a cache it is using or otherwise\n   decides to switch to
    a new cache, it SHOULD retain the data from the\n   previous cache until it has
    a full set of data from one or more other\n   caches.  Note that this may already
    be true at the point of\n   connection loss if the client has connections to more
    than one cache.\n"
  title: 10.  Router-Cache Setup
- contents:
  - "11.  Deployment Scenarios\n   For illustration, we present three likely deployment
    scenarios:\n   Small End Site:  The small multihomed end site may wish to outsource\n
    \     the RPKI cache to one or more of their upstream ISPs.  They would\n      exchange
    authentication material with the ISP using some out-of-\n      band mechanism,
    and their router(s) would connect to the cache(s)\n      of one or more upstream
    ISPs.  The ISPs would likely deploy caches\n      intended for customer use separately
    from the caches with which\n      their own BGP speakers peer.\n   Large End Site:
    \ A larger multihomed end site might run one or more\n      caches, arranging
    them in a hierarchy of client caches, each\n      fetching from a serving cache
    which is closer to the Global RPKI.\n      They might configure fallback peerings
    to upstream ISP caches.\n   ISP Backbone:  A large ISP would likely have one or
    more redundant\n      caches in each major point of presence (PoP), and these
    caches\n      would fetch from each other in an ISP-dependent topology so as not\n
    \     to place undue load on the Global RPKI.\n   Experience with large DNS cache
    deployments has shown that complex\n   topologies are ill-advised, as it is easy
    to make errors in the\n   graph, e.g., not maintain a loop-free condition.\n   Of
    course, these are illustrations, and there are other possible\n   deployment strategies.
    \ It is expected that minimizing load on the\n   Global RPKI servers will be a
    major consideration.\n   To keep load on Global RPKI services from unnecessary
    peaks, it is\n   recommended that primary caches which load from the distributed\n
    \  Global RPKI not do so all at the same times, e.g., on the hour.\n   Choose
    a random time, perhaps the ISP's AS number modulo 60, and\n   jitter the inter-fetch
    timing.\n"
  title: 11.  Deployment Scenarios
- contents:
  - "12.  Error Codes\n   This section contains a preliminary list of error codes.
    \ The authors\n   expect additions to the list during development of the initial\n
    \  implementations.  There is an IANA registry where valid error codes\n   are
    listed; see Section 14.  Errors which are considered fatal MUST\n   cause the
    session to be dropped.\n   0: Corrupt Data (fatal):  The receiver believes the
    received PDU to\n      be corrupt in a manner not specified by another error code.\n
    \  1: Internal Error (fatal):  The party reporting the error experienced\n      some
    kind of internal error unrelated to protocol operation (ran\n      out of memory,
    a coding assertion failed, et cetera).\n   2: No Data Available:  The cache believes
    itself to be in good\n      working order but is unable to answer either a Serial
    Query or a\n      Reset Query because it has no useful data available at this
    time.\n      This is likely to be a temporary error and most likely indicates\n
    \     that the cache has not yet completed pulling down an initial\n      current
    data set from the Global RPKI system after some kind of\n      event that invalidated
    whatever data it might have previously held\n      (reboot, network partition,
    et cetera).\n   3: Invalid Request (fatal):  The cache server believes the client's\n
    \     request to be invalid.\n   4: Unsupported Protocol Version (fatal):  The
    Protocol Version is not\n      known by the receiver of the PDU.\n   5: Unsupported
    PDU Type (fatal):  The PDU Type is not known by the\n      receiver of the PDU.\n
    \  6: Withdrawal of Unknown Record (fatal):  The received PDU has\n      Flag=0,
    but a matching record ({Prefix, Len, Max-Len, ASN} tuple\n      for an IPvX PDU
    or {SKI, ASN, Subject Public Key} tuple for a\n      Router Key PDU) does not
    exist in the receiver's database.\n   7: Duplicate Announcement Received (fatal):
    \ The received PDU has\n      Flag=1, but a matching record ({Prefix, Len, Max-Len,
    ASN} tuple\n      for an IPvX PDU or {SKI, ASN, Subject Public Key} tuple for
    a\n      Router Key PDU) is already active in the router.\n   8: Unexpected Protocol
    Version (fatal):  The received PDU has a\n      Protocol Version field that differs
    from the protocol version\n      negotiated in Section 7.\n"
  title: 12.  Error Codes
- contents:
  - "13.  Security Considerations\n   As this document describes a security protocol,
    many aspects of\n   security interest are described in the relevant sections.
    \ This\n   section points out issues which may not be obvious in other sections.\n
    \  Cache Validation:  In order for a collection of caches as described\n      in
    Section 11 to guarantee a consistent view, they need to be\n      given consistent
    trust anchors to use in their internal validation\n      process.  Distribution
    of a consistent trust anchor is assumed to\n      be out of band.\n   Cache Peer
    Identification:  The router initiates a transport\n      connection to a cache,
    which it identifies by either IP address or\n      fully qualified domain name.
    \ Be aware that a DNS or address\n      spoofing attack could make the correct
    cache unreachable.  No\n      session would be established, as the authorization
    keys would not\n      match.\n   Transport Security:  The RPKI relies on object,
    not server or\n      transport, trust.  That is, the IANA root trust anchor is\n
    \     distributed to all caches through some out-of-band means and can\n      then
    be used by each cache to validate certificates and ROAs all\n      the way down
    the tree.  The inter-cache relationships are based on\n      this object security
    model; hence, the inter-cache transport can\n      be lightly protected.\n      However,
    this protocol document assumes that the routers cannot do\n      the validation
    cryptography.  Hence, the last link, from cache to\n      router, is secured by
    server authentication and transport-level\n      security.  This is dangerous,
    as server authentication and\n      transport have very different threat models
    than object security.\n      So the strength of the trust relationship and the
    transport\n      between the router(s) and the cache(s) are critical.  You're\n
    \     betting your routing on this.\n      While we cannot say the cache must
    be on the same LAN, if only due\n      to the issue of an enterprise wanting to
    offload the cache task to\n      their upstream ISP(s), locality, trust, and control
    are very\n      critical issues here.  The cache(s) really SHOULD be as close,
    in\n      the sense of controlled and protected (against DDoS, MITM)\n      transport,
    to the router(s) as possible.  It also SHOULD be\n      topologically close so
    that a minimum of validated routing data\n      are needed to bootstrap a router's
    access to a cache.\n      The identity of the cache server SHOULD be verified
    and\n      authenticated by the router client, and vice versa, before any\n      data
    are exchanged.\n      Transports which cannot provide the necessary authentication
    and\n      integrity (see Section 9) must rely on network design and\n      operational
    controls to provide protection against spoofing/\n      corruption attacks.  As
    pointed out in Section 9, TCP-AO is the\n      long-term plan.  Protocols which
    provide integrity and\n      authenticity SHOULD be used, and if they cannot,
    i.e., TCP is used\n      as the transport, the router and cache MUST be on the
    same\n      trusted, controlled network.\n"
  title: 13.  Security Considerations
- contents:
  - "14.  IANA Considerations\n   This section only discusses updates required in
    the existing IANA\n   protocol registries to accommodate version 1 of this protocol.
    \ See\n   [RFC6810] for IANA considerations from the original (version 0)\n   protocol.\n
    \  All existing entries in the IANA \"rpki-rtr-pdu\" registry remain valid\n   for
    protocol version 0.  All of the PDU types allowed in protocol\n   version 0 are
    also allowed in protocol version 1, with the addition\n   of the new Router Key
    PDU.  To reduce the likelihood of confusion,\n   the PDU number used by the Router
    Key PDU in protocol version 1 is\n   hereby registered as reserved (and unused)
    in protocol version 0.\n   The policy for adding to the registry is RFC Required
    per [RFC8126];\n   the document must be either Standards Track or Experimental.\n
    \  The \"rpki-rtr-pdu\" registry has been updated as follows:\n              Protocol
    \  PDU\n              Version    Type  Description\n              --------   ----
    \ ---------------\n                 0-1       0   Serial Notify\n                 0-1
    \      1   Serial Query\n                 0-1       2   Reset Query\n                 0-1
    \      3   Cache Response\n                 0-1       4   IPv4 Prefix\n                 0-1
    \      6   IPv6 Prefix\n                 0-1       7   End of Data\n                 0-1
    \      8   Cache Reset\n                  0        9   Reserved\n                  1
    \       9   Router Key\n                 0-1      10   Error Report\n                 0-1
    \    255   Reserved\n   All existing entries in the IANA \"rpki-rtr-error\" registry
    remain\n   valid for all protocol versions.  Protocol version 1 adds one new\n
    \  error code:\n              Error\n              Code    Description\n              -----
    \  ---------------------------\n                  8   Unexpected Protocol Version\n"
  title: 14.  IANA Considerations
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [RFC1982]  Elz, R. and R. Bush, \"Serial Number
      Arithmetic\", RFC 1982,\n              DOI 10.17487/RFC1982, August 1996,\n
      \             <https://www.rfc-editor.org/info/rfc1982>.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2385]  Heffernan, A., \"Protection of BGP Sessions via the TCP MD5\n
      \             Signature Option\", RFC 2385, DOI 10.17487/RFC2385, August\n              1998,
      <https://www.rfc-editor.org/info/rfc2385>.\n   [RFC3629]  Yergeau, F., \"UTF-8,
      a transformation format of ISO\n              10646\", STD 63, RFC 3629, DOI
      10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC4252]  Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH)\n              Authentication
      Protocol\", RFC 4252, DOI 10.17487/RFC4252,\n              January 2006, <https://www.rfc-editor.org/info/rfc4252>.\n
      \  [RFC4301]  Kent, S. and K. Seo, \"Security Architecture for the\n              Internet
      Protocol\", RFC 4301, DOI 10.17487/RFC4301,\n              December 2005, <https://www.rfc-editor.org/info/rfc4301>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]
      \ Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC5925]  Touch, J., Mankin, A., and R. Bonica, \"The TCP\n              Authentication
      Option\", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <https://www.rfc-editor.org/info/rfc5925>.\n
      \  [RFC5926]  Lebovitz, G. and E. Rescorla, \"Cryptographic Algorithms\n              for
      the TCP Authentication Option (TCP-AO)\", RFC 5926,\n              DOI 10.17487/RFC5926,
      June 2010,\n              <https://www.rfc-editor.org/info/rfc5926>.\n   [RFC6125]
      \ Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125, March\n              2011, <https://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC6487]  Huston, G., Michaelson, G., and R. Loomans, \"A Profile for\n
      \             X.509 PKIX Resource Certificates\", RFC 6487,\n              DOI
      10.17487/RFC6487, February 2012,\n              <https://www.rfc-editor.org/info/rfc6487>.\n
      \  [RFC6810]  Bush, R. and R. Austein, \"The Resource Public Key\n              Infrastructure
      (RPKI) to Router Protocol\", RFC 6810,\n              DOI 10.17487/RFC6810,
      January 2013,\n              <https://www.rfc-editor.org/info/rfc6810>.\n   [RFC6811]
      \ Mohapatra, P., Scudder, J., Ward, D., Bush, R., and R.\n              Austein,
      \"BGP Prefix Origin Validation\", RFC 6811,\n              DOI 10.17487/RFC6811,
      January 2013,\n              <https://www.rfc-editor.org/info/rfc6811>.\n   [RFC8126]
      \ Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8208]  Turner, S. and O.
      Borchert, \"BGPsec Algorithms, Key\n              Formats, and Signature Formats\",
      RFC 8208,\n              DOI 10.17487/RFC8208, September 2017,\n              <http://www.rfc-editor.org/info/rfc8208>.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [RFC1996]  Vixie, P., \"A Mechanism for Prompt
      Notification of Zone\n              Changes (DNS NOTIFY)\", RFC 1996, DOI 10.17487/RFC1996,\n
      \             August 1996, <https://www.rfc-editor.org/info/rfc1996>.\n   [RFC4808]
      \ Bellovin, S., \"Key Change Strategies for TCP-MD5\",\n              RFC 4808,
      DOI 10.17487/RFC4808, March 2007,\n              <https://www.rfc-editor.org/info/rfc4808>.\n
      \  [RFC5781]  Weiler, S., Ward, D., and R. Housley, \"The rsync URI\n              Scheme\",
      RFC 5781, DOI 10.17487/RFC5781, February 2010,\n              <https://www.rfc-editor.org/info/rfc5781>.\n
      \  [RFC6480]  Lepinski, M. and S. Kent, \"An Infrastructure to Support\n              Secure
      Internet Routing\", RFC 6480, DOI 10.17487/RFC6480,\n              February
      2012, <https://www.rfc-editor.org/info/rfc6480>.\n   [RFC6481]  Huston, G.,
      Loomans, R., and G. Michaelson, \"A Profile for\n              Resource Certificate
      Repository Structure\", RFC 6481,\n              DOI 10.17487/RFC6481, February
      2012,\n              <https://www.rfc-editor.org/info/rfc6481>.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Acknowledgements\n   The authors wish to thank Nils Bars, Steve Bellovin, Tim
    Bruijnzeels,\n   Rex Fernando, Richard Hansen, Paul Hoffman, Fabian Holler, Russ\n
    \  Housley, Pradosh Mohapatra, Keyur Patel, David Mandelberg, Sandy\n   Murphy,
    Robert Raszuk, Andreas Reuter, Thomas C. Schmidt, John\n   Scudder, Ruediger Volk,
    Matthias Waehlisch, and David Ward.\n   Particular thanks go to Hannes Gredler
    for showing us the dangers of\n   unnecessary fields.\n   No doubt this list is
    incomplete.  We apologize to any contributor\n   whose name we missed.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Randy Bush\n   Internet Initiative Japan\n   5147 Crystal
    Springs\n   Bainbridge Island, Washington  98110\n   United States of America\n
    \  Email: randy@psg.com\n   Rob Austein\n   Dragon Research Labs\n   Email: sra@hactrn.net\n"
  title: Authors' Addresses
