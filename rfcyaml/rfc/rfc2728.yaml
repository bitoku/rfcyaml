- contents:
  - "    The Transmission of IP Over the Vertical Blanking Interval of a\n                           Television
    Signal\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "1. Abstract\n   This document describes a method for broadcasting IP data in
    a\n   unidirectional manner using the vertical blanking interval of\n   television
    signals.  It includes a description for compressing IP\n   headers on unidirectional
    networks, a framing protocol identical to\n   SLIP, a forward error correction
    scheme, and the NABTS byte\n   structures.\n"
  title: 1. Abstract
- contents:
  - "2. Introduction\n   This RFC proposes several protocols to be used in the transmission
    of\n   IP datagrams using the Vertical Blanking Interval (VBI) of a\n   television
    signal.  The VBI is a non-viewable portion of the\n   television signal that can
    be used to provide point-to-multipoint IP\n   data services which will relieve
    congestion and traffic in the\n   traditional Internet access networks.  Wherever
    possible these\n   protocols make use of existing RFC standards and non-standards.\n
    \  Traditionally, point-to-point connections (TCP/IP) have been used\n   even
    for the transmission of broadcast type data.  Distribution of\n   the same content--news
    feeds, stock quotes, newsgroups, weather\n   reports, and the like--are typically
    sent repeatedly to individual\n   clients rather than being broadcast to the large
    number of users who\n   want to receive such data.\n   Today, IP is quickly becoming
    the preferred method of distributing\n   one-to-many data on intranets and the
    Internet. The coming\n   availability of low cost PC hardware for receiving television
    signals\n   accompanied by broadcast data streams makes a defined standard for\n
    \  the transmission of data over traditional broadcast networks\n   imperative.
    \ A lack of standards in this area as well as the expense\n   of hardware has
    prevented traditional broadcast networks from\n   becoming effective deliverers
    of data to the home and office.\n   This document describes the transmission of
    IP using the North\n   American Basic Teletext Standard (NABTS), a recognized
    and industry-\n   supported method of transporting data on the VBI.  NABTS is\n
    \  traditionally used on 525-line television systems such as NTSC.\n   Another
    byte structure, WST, is traditionally used on 625-line\n   systems such as PAL
    and SECAM.  These generalizations have\n   exceptions, and countries should be
    treated on an individual basis.\n   These existing television system standards
    will enable the television\n   and Internet communities to provide inexpensive
    broadcast data\n   services.  A set of existing protocols will be layered above
    the\n   specific FEC for NABTS including a serial stream framing protocol\n   similar
    to SLIP (RFC 1055 [Romkey 1988]) and a compression technique\n   for unidirectional
    UDP/IP headers.\n   The protocols described in this document are intended for
    the\n   unidirectional delivery of IP datagrams using the VBI.  That is, no\n
    \  return channel is described, or for that matter possible, in the VBI.\n   The
    key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in RFC 2119.\n"
  title: 2. Introduction
- contents:
  - "3. Proposed protocol stack\n   The following protocol stack demonstrates the
    layers used in the\n   transmission of VBI data.  Each layer has no knowledge
    of the data it\n   encapsulates, and is therefore abstracted from the other layers.
    At\n   the link layer, the NABTS protocol defines the modulation scheme used\n
    \  to transport data on the VBI.  At the network layer, IP handles the\n   movement
    of data to the appropriate clients.  In the transport layer,\n   UDP determines
    the flow of data to the appropriate processes and\n   applications.\n              +-------------------+\n
    \             |                   |\n              |    Application    |\n              |
    \                  |\n              +-------------------+\n              |                   |
    \ )\n              |        UDP        |   )\n              |                   |
    \  )\n              +-------------------+   (-- IP\n              |                   |
    \  )\n              |        IP         |   )\n              |                   |
    \ )\n              +-------------------+\n              |    SLIP-style     |\n
    \             |   encapsulation   |\n              |                   |\n              +-------------------+\n
    \             |        FEC        |\n              |-------------------|\n              |
    \      NABTS       |\n              |                   |\n              +---------+---------+\n
    \             |                   |\n              |     NTSC/other    |\n              |
    \                  |\n              +-------------------+\n                        |\n
    \                       |\n                        |            cable, off-air,
    etc.\n                        +--------<----<----<--------\n   These protocols
    can be described in a bottom up component model using\n   the example of NABTS
    carried over NTSC modulation as follows:\n   Video signal --> NABTS --> FEC -->
    serial data stream --> Framing\n   protocol --> compressed UDP/IP headers -->
    application data\n   This diagram can be read as follows: television signals have
    NABTS\n   packets, which contain a Forward Error Correction (FEC) protocol,\n
    \  modulated onto them.  The data contained in these sequential, ordered\n   packets
    form a serial data stream on which a framing protocol\n   indicates the location
    of IP packets, with compressed headers,\n   containing application data.\n   The
    structure of these components and protocols are described in\n   following subsections.\n"
  - contents:
    - "3.1. VBI\n   The characteristics and definition of the VBI is dependent on
      the\n   television system in use, be it NTSC, PAL, SECAM or some other.  For\n
      \  more information on Television standards worldwide, see ref [12].\n"
    - contents:
      - "3.1.1. 525 line systems\n   A 525-line television frame is comprised of two
        fields of 262.5\n   horizontal scan lines each.  The first 21 lines of each
        field are not\n   part of the visible picture and are collectively called
        the Vertical\n   Blanking Interval (VBI).\n   Of these 21 lines, the first
        9 are used while repositioning the\n   cathode ray to the top of the screen,
        but the remaining lines are\n   available for data transport.\n   There are
        12 possible VBI lines being broadcast 60 times a second\n   (each field 30
        times a second).  In some countries Line 21 is\n   reserved for the transport
        of closed captioning data (Ref.[11]).  In\n   that case, there are 11 possible
        VBI lines, some or all of which\n   could be used for IP transport.  It should
        be noted that some of\n   these lines are sometimes used for existing, proprietary,
        data and\n   testing services. IP delivery therefore becomes one more data
        service\n   using a subset or all of these lines.\n"
      title: 3.1.1. 525 line systems
    - contents:
      - "3.1.2. 625 Line Systems\n   A 625-line television frame is comprised of two
        fields of 312.5\n   horizontal scan lines each.  The first few lines of each
        field are\n   used while repositioning the cathode ray to the top of the screen.\n
        \  The lines available for data insertion are 6-22 in the first field\n   and
        319-335 in the second field.\n   There are, therefore, 17 possible VBI lines
        being broadcast 50 times\n   a second (each field 25 times a second), some
        or all of which could\n   be used for IP transport.  It should be noted that
        some of these\n   lines are sometimes used for existing, proprietary, data
        and testing\n   services. IP, therefore, becomes one more data service using
        a subset\n   or all of these lines.\n"
      title: 3.1.2. 625 Line Systems
    title: 3.1. VBI
  - contents:
    - "3.2. NABTS\n   The North American Basic Teletext Standard is defined in the\n
      \  Electronic Industry Association's EIA-516, Ref. [2], and ITU.R\n   BT.653-2,
      system C, Ref. [13].  It provides an industry-accepted\n   method of modulating
      data onto the VBI, usually of an NTSC signal.\n   This section describes the
      NABTS packet format as it is used for the\n   transport of IP.\n   It should
      be noted that only a subset of the NABTS standard is used,\n   as is common
      practice in NABTS implementations.  Further information\n   concerning the NABTS
      standard and its implementation can be found in\n   EIA-516.\n   The NABTS packet
      is a 36-byte structure encoded onto one horizontal\n   scan line of a television
      signal having the following structure:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            clock sync         |   byte sync   |  packet addr. |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  packet address (cont.)       |  cont. index  |PcktStructFlags|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      user data (26 bytes)                     |\n   :                                                               :\n
      \  :                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n   |                               |
      \             FEC              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The two-byte Clock Synchronization and one-byte Byte Synchronization\n   are
      located at the beginning of every scan line containing a NABTS\n   packet and
      are used to synchronize the decoding sampling rate and\n   byte timing.\n   The
      three-byte Packet Address field is Hamming encoded (as specified\n   in EIA-516),
      provides 4 data bits per byte, and thus provides 4096\n   possible packet addresses.
      \ These addresses are used to distinguish\n   related services originating from
      the same source.  This is necessary\n   for the receiver to determine which
      packets are related, and part of\n   the same service.  NABTS packet addresses
      therefore distinguish\n   different data services, possibly inserted at different
      points of the\n   transmission system, and most likely totally unrelated.  Section
      4 of\n   this document discusses Packet Addresses in detail.\n   The one-byte
      Continuity Index field is a Hamming encoded byte, which\n   is incremented by
      one for each subsequent packet of a given Packet\n   Address.  The value or
      number of the Continuity Index sequences from\n   0 to 15. It increments by
      one each time a data packet is transmitted.\n   This allows the decoder to determine
      if packets were lost during\n   transmission.\n   The Packet Structure field
      is also a Hamming encoded byte, which\n   contains information about the structure
      of the remaining portions of\n   the packet.  The least significant bit is always
      \"0\" in this\n   implementation.  The second least significant bit specifies
      if the\n   Data Block is full--\"0\" indicates the data block is full of useful\n
      \  data, and \"1\" indicates some or all of the data is filler data.  The\n
      \  two most significant bits are used to indicate the length of the\n   suffix
      of the Data Block--in this implementation, either 2 or 28\n   bytes (10 for
      2-byte FEC suffix, 11 for 28-byte FEC suffix).  This\n   suffix is used for
      the forward error correction described in the next\n   section.  The following
      table shows the possible values of the Packet\n   Structure field:\n         Data
      Packet, no filler                     D0\n         Data Packet, with filler
      \                  8C\n         FEC Packet                                 A1\n
      \  The Data Block field is 26 bytes, zero to 26 of which is useful data\n   (part
      of a IP packet or SLIP frame), the remainder is filler data.\n   Data is byte-ordered
      least significant bit first. Filler data is\n   indicated by an Ox15 followed
      by as many OxEA as are needed to fill\n   the Data Block field. Sequential data
      blocks minus the filler data\n   form an asynchronous serial stream of data.\n
      \  These NABTS packets are modulated onto the television signal\n   sequentially
      and on any combination of lines.\n"
    title: 3.2. NABTS
  - contents:
    - "3.3. FEC\n   Due to the unidirectional nature of VBI data transport, Forward
      Error\n   Correction (FEC) is needed to ensure the integrity of data at the\n
      \  receiver.  The type of FEC described here and in the appendix of this\n   document
      for NABTS has been in use for a number of years, and has\n   proven popular
      with the broadcast industry.  It is capable of\n   correcting single-byte errors
      and single- and double-byte erasures in\n   the data block and suffix of a NABTS
      packet.  In a system using\n   NABTS, the FEC algorithm splits a serial stream
      of data into 364-byte\n   \"bundles\".  The data is arranged as 14 packets of
      26 bytes each.  A\n   function is applied to the 26 bytes of each packet to
      determine the\n   two suffix bytes, which (with the addition of a header) complete
      the\n   NABTS packet (8+26+2).\n   For every 14 packets in the bundle, two additional
      packets are\n   appended which contain only FEC data, each of which contain
      28 bytes\n   of FEC data.  The first packet in the bundle has a Continuity Index\n
      \  value of 0, and the two FEC only packets at the end have Continuity\n   Index
      values of 14 and 15 respectively.  This data is obtained by\n   first writing
      the packets into a table of 16 rows and 28 columns.\n   The same expression
      as above can be used on the columns of the table\n   with the suffix now represented
      by the bytes at the base of the\n   columns in rows 15 and 16.  With NABTS headers
      on each of these rows,\n   we now have a bundle of 16 NABTS packets ready for
      sequential\n   modulation onto lines of the television signal.\n   At the receiver,
      these formulae can be used to verify the validity of\n   the data with very
      high accuracy.  If single bit errors, double bit\n   errors, single-byte errors
      or single- and double-byte erasures are\n   found in any row or column (including
      an entire packet lost) they can\n   be corrected using the algorithms found
      in the appendix. The success\n   at correcting errors will depend on the particular
      implementation\n   used on the receiver.\n"
    title: 3.3. FEC
  - contents:
    - "3.4. Framing\n   A framing protocol identical to SLIP is proposed for encapsulating\n
      \  the packets described in the following section, thus abstracting this\n   data
      from the lower protocol layers.  This protocol uses two special\n   characters:
      END (0xc0) and ESC (0xdb).  To send a packet, the host\n   will send the packet
      followed by the END character.  If a data byte\n   in the packet is the same
      code as END character, a two-byte sequence\n   of ESC (0xdb) and 0xdc is sent
      instead.  If a data byte is the same\n   code as ESC character, a two-byte sequence
      of ESC (0xdb) and 0xdd is\n   sent instead.  SLIP implementations are widely
      available; see RFC\n   1055 [Romkey 1988] for more detail.\n      +--------------+--+------------+--+--+---------+--+\n
      \     |   packet     |c0|    packet  |db|dd|         |c0|\n      +--------------+--+------------+--+--+---------+--+\n
      \                     END              ESC            END\n   The packet framed
      in this manner shall be formatted according to its\n   schema type identified
      by the schema field, which shall start every\n   packet:\n      +-----------+---------------------------------------------+\n
      \     |  schema   |   packet (formatted according to schema)    |\n      |  1
      byte   |      ?? bytes (schema dependant length)     |\n      +-----------+---------------------------------------------+\n
      \  In the case where the most significant bit in this field is set to\n   \"1\",
      the length of the field extends to two bytes, allowing for 32768\n   additional
      schemas:\n      +-----------+---------------------------------------------+\n
      \     | extended  |   packet (formatted according to schema)    |\n      |  schema
      \  |       ?? bytes (schema dependant length)    |\n      |   2 bytes |                                             |\n
      \     +-----------+---------------------------------------------+\n   In the
      section 3.5, one such schema for sending IP is described.\n   This is the only
      schema specified by this document. Additional\n   schemas may be proposed for
      other packet types or other compression\n   schemes as described in section
      7.\n"
    - contents:
      - "3.4.1 Maximum Transmission Unit Size\n   The maximum length of an uncompressed
        IP packet, or Maximum-\n   Transmission Unit (MTU) size is 1500 octets.  Packets
        larger than\n   1500 octets MUST be fragmented before transmission, and the
        client\n   VBI interface MUST be able to receive full 1500 octet packet\n
        \  transmissions.\n"
      title: 3.4.1 Maximum Transmission Unit Size
    title: 3.4. Framing
  - contents:
    - "3.5. IP Header Compression Scheme\n   The one-byte scheme defines the format
      for encoding the IP packet\n   itself.  Due to the value of bandwidth, it may
      be desirable to\n   introduce as much efficiency as possible in this encoding.
      \ One such\n   efficiency is the optional compression of the UDP/IP header using
      a\n   method related to the TCP/IP header compression as described by Van\n
      \  Jacobson (RFC 1144).  UDP/IP header compression is not identical due\n   to
      the limitation of unidirectional transmission.  One such scheme is\n   proposed
      in this document for the compression of UDP/IP version 4.\n   It is assigned
      a value of 0x00.  All future encapsulation schemes\n   should use a unique value
      in this field.\n   Only schema 0x00 is defined in this document; this schema
      must be\n   supported by all receivers.  In schema 0x00, the format of the IP\n
      \  packet itself takes one of two forms.  Packets can be sent with full,\n   uncompressed
      headers as follows:\n     0                   1                   2                   3\n
      \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |0|    group    |         uncompressed IP header (20 bytes)     |\n    +-+-+-+-+-+-+-+-+
      \                                              +\n    |                                                               |\n
      \   :                             ....                              :\n    +
      \              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |               |
      \       uncompressed UDP header (8 bytes)      |\n    +-+-+-+-+-+-+-+-+                                               +\n
      \   |                                                               |\n    +
      \              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |               |
      \             payload  (<1472 bytes)           |\n    +-+-+-+-+-+-+-+-+                                               +\n
      \   |                                                               |\n    :
      \                             ....                             :\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                              CRC                              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The first byte in the 0x00 scheme is the Compression Key.  It is a\n   one-byte
      value: the first bit indicates if the header has been\n   compressed, and the
      remaining seven bits indicate the compression\n   group to which it belongs.\n
      \  If the high bit of the Compression Key is set to zero, no compression\n   is
      performed and the full header is sent, as shown above. The client\n   VBI interface
      should store the most recent uncompressed header for a\n   given group value
      for future potential use in rebuilding subsequent\n   compressed headers.  Packets
      with identical group bits are assumed to\n   have identical UDP/IP headers for
      all UDP and IP fields, with the\n   exception of the \"IP identification\" and
      \"UDP checksum\" fields.\n   Group values may be recycled following 60 seconds
      of nonuse by the\n   preceding UDP/IP session (no uncompressed packets sent),
      or by\n   sending packets with uncompressed headers for the 60-second duration\n
      \  following the last packet in the preceding UDP/IP session.\n   Furthermore,
      the first packet sent following 60 seconds of nonuse, or\n   compressed header
      packets only use, must use an uncompressed header.\n   Client VBI interfaces
      should disregard compressed packets received 60\n   or more seconds after the
      last uncompressed packet using a given\n   group address.  This avoids any incorrectly
      decompressed packets due\n   to group number reuse, and limits the outage due
      to a lost\n   uncompressed packet to 60 seconds.\n   If the high bit of the
      Compression Key is set to one, a compressed\n   version of the UDP/IP header
      is sent.  The client VBI interface must\n   then combine the compressed header
      with the stored uncompressed\n   header of the same group and recreate a full
      packet.  For compressed\n   packets, the only portions of the UDP/IP header
      sent are the \"IP\n   identification\" and \"UDP checksum\" fields:\n     0
      \                  1                   2                   3\n     0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |1|    group    |        IP identification        | UDP checksum|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |UDP cksm (cont)|           payload  (<1472 bytes)              |\n    +-+-+-+-+-+-+-+-+
      \                                              +\n    :                              ....
      \                            :\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                              CRC                              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  All datagrams belonging to a multi fragment IP packet shall be sent\n   with
      full headers, in the uncompressed header format.  Therefore,\n   only packets
      that have not been fragmented can be sent with the most\n   significant bit
      of the compression key set to \"1\".\n   A 32-bit CRC has also been added to
      the end of every packet in this\n   scheme to ensure data integrity.  It is
      performed over the entire\n   packet including schema byte, compression key,
      and either compressed\n   or uncompressed headers.  It uses the same algorithm
      as the MPEG-2\n   transport stream (ISO/IEC 13818-1).  The generator polynomial
      is:\n   1 + D + D2 + D4 + D5 + D7 + D8 + D10 + D11 + D12 + D16 + D22 + D23 +\n
      \  D26 + D32\n   As in the ISO/IEC 13818-1 specification, the initial state
      of the sum\n   is 0xFFFFFFFF.  This is not the same algorithm used by Ethernet.
      This\n   CRC provides a final check for damaged datagrams that span FEC\n   bundles
      or were not properly corrected by FEC.\n"
    title: 3.5. IP Header Compression Scheme
  title: 3. Proposed protocol stack
- contents:
  - "4. Addressing Considerations\n   The addressing of IP packets should adhere to
    existing standards in\n   this area.  The inclusion of an appropriate source address
    is needed\n   to ensure the receiving client can distinguish between sources and\n
    \  thus services if multiple hosts are sharing an insertion point and\n   NABTS
    packet address.\n   NABTS packet addressing is not regulated or standardized and
    requires\n   care to ensure that unrelated services on the same channel are not\n
    \  broadcasting with the same packet address.  This could occur due to\n   multiple
    possible NABTS insertion sites, including show production,\n   network redistribution,
    regional operator, and local operator.\n   Traditionally, the marketplace has
    recognized this concern and made\n   amicable arrangements for the distribution
    of these addresses for\n   each channel.\n"
  title: 4. Addressing Considerations
- contents:
  - "5. IANA Considerations\n   IANA will register new schemas on a \"First Come First
    Served\" basis\n   [RFC 2434].  Anyone can register a scheme, so long as they
    provide a\n   point of contact and a brief description. The scheme number will
    be\n   assigned by IANA.  Registrants are encouraged to publish complete\n   specifications
    for new schemas (preferably as standards-track RFCs),\n   but this is not required.\n"
  title: 5. IANA Considerations
- contents:
  - "6. Security Considerations\n   As with any broadcast network, there are security
    issues due to the\n   accessibility of data.  It is assumed that the responsibility
    for\n   securing data lies in other protocol layers, including the IP\n   Security
    (IPSEC) protocol suite, Transport Layer Security (TLS)\n   protocols, as well
    as application layer protocols appropriate for a\n   broadcast-only network.\n"
  title: 6. Security Considerations
- contents:
  - "7. Conclusions\n   This document provides a method for broadcasting Internet
    data over a\n   television signal for reception by client devices.  With an\n
    \  appropriate broadcast content model, this will become an attractive\n   method
    of providing data services to end users.  By using existing\n   standards and
    a layered protocol approach, this document has also\n   provided a model for data
    transmission on unidirectional and\n   broadcast networks.\n"
  title: 7. Conclusions
- contents:
  - "8. Acknowledgements\n   The description of the FEC in Appendix A is taken from
    a document\n   prepared by Trevor Dee of Norpak Corporation. Dean Blackketter
    of\n   WebTV Networks, Inc., edited the final draft of this document.\n"
  title: 8. Acknowledgements
- contents:
  - "9. References\n   [1]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n
    \       Levels\", BCP 14, RFC 2119, March 1997.\n   [2]  Deering, S., \"Host Extensions
    for IP Multicasting\", STD 5, RFC\n        1112, August 1989.\n   [3]  EIA-516,
    \"Joint EIA/CVCC Recommended Practice for Teletext:\n        North American Basic
    Teletext Specification (NABTS)\" Washington:\n        Electronic Industries Association,
    c1988\n   [4]  International Telecommunications Union Recommendation. ITU-R\n
    \       BT.470-5 (02/98) \"Conventional TV Systems\"\n   [5]  International Telecommunications
    Union Recommendation. ITU.R\n        BT.653-2, system C\n   [6]  Jack, Keith.
    \"Video Demystified: A Handbook for the Digital\n        Engineer, Second Edition,\"
    San Diego: HighText Pub.  c1996.\n   [7]  Jacobson, V., \"Compressing TCP/IP Headers
    for Low-Speed Serial\n        Links\", RFC 1144, February 1990.\n   [8]  Mortimer,
    Brian.  \"An Error-correction system for the Teletext\n        Transmission in
    the Case of Transparent Data\" c1989 Department\n        of Mathematics and Statistics,
    Carleton University, Ottawa\n        Canada\n   [9]  Narten, T. and H. Alvestrand,
    \"Guidelines for Writing an IANA\n        Considerations Section in RFCs\", BCP
    26, RFC 2434, October 1998.\n   [10] Norpak Corporation \"TTX71x Programming Reference
    Manual\", c1996,\n        Kanata, Ontario, Canada\n   [11] Norpak Corporation,
    \"TES3 EIA-516 NABTS Data Broadcast Encoder\n        Software User's Manual.\"
    c1996, Kanata, Ontario, Canada\n   [12] Norpak Corporation, \"TES3/GES3 Hardware
    Manual\" c1996, Kanata,\n        Ontario, Canada\n   [13] Pretzel, Oliver. \"Correcting
    Codes and Finite Fields: Student\n        Edition\" OUP, c1996\n   [14] Rorabaugh,
    C. Britton.  \"Error Coding Cookbook\" McGraw Hill,\n        c1996\n   [15] Romkey,
    J., \"A Nonstandard for Transmission of IP Datagrams Over\n        Serial Lines:
    SLIP\", STD 47, RFC 1055, June 1988.\n   [16] Recommended Practice for Line 21
    Data Service (ANSI/EIA-608-94)\n        (Sept., 1994)\n   [17] Stevens, W. Richard.
    \ \"TCP/IP Illustrated, Volume 1,: The\n        Protocols\"  Reading: Addison-Wesley
    Publishing Company, c1994.\n"
  title: 9. References
- contents:
  - "10. Acronyms\n   FEC            - Forward Error Correction\n   IP             -
    Internet Protocol\n   NABTS          - North American Basic Teletext Standard\n
    \  NTSC           - National Television Standards Committee\n   NTSC-J         -
    NTSC-Japanese\n   PAL            - Phase Alternation Line\n   RFC            -
    Request for Comments\n   SECAM          - Sequentiel Couleur Avec Memoire\n                    (sequential
    color with memory)\n   SLIP           - Serial Line Internet Protocol\n   TCP
    \           - Transmission Control Protocol\n   UDP            - User Datagram
    Protocol\n   VBI            - Vertical Blanking Interval\n   WST            -
    World System Teletext\n"
  title: 10. Acronyms
- contents:
  - "11. Editors' Addresses and Contacts\n   Ruston Panabaker, co-editor\n   Microsoft\n
    \  One Microsoft Way Redmond, WA 98052\n   EMail: rustonp@microsoft.com\n   Simon
    Wegerif, co-editor\n   Philips Semiconductors\n   811 E. Arques Avenue\n   M/S
    52, P.O. Box 3409 Sunnyvale, CA 94088-3409\n   EMail: Simon.Wegerif@sv.sc.philips.com\n
    \  Dan Zigmond, WG Chair\n   WebTV Networks\n   One Microsoft Way Redmond, WA
    98052\n   EMail: djz@corp.webtv.net\n"
  title: 11. Editors' Addresses and Contacts
- contents:
  - "12. Appendix A: Forward Error Correction Specification\n   This FEC is optimized
    for data carried in the VBI of a television\n   signal.  Teletext has been in
    use for many years and data\n   transmission errors have been categorized into
    three main types: 1)\n   Randomly distributed single bit errors 2) Loss of lines
    of NABTS data\n   3) Burst Errors\n   The quantity and distribution of these errors
    is highly variable and\n   dependent on many factors.  The FEC is designed to
    fix all these\n   types of errors.\n"
  - contents:
    - "12.1. Mathematics used in the FEC\n   Galois fields form the basis for the
      FEC algorithm presented here.\n   Rather then explain these fields in general,
      a specific explanation\n   is given of the Galois field used in the FEC algorithm.\n
      \  The Galois field used is GF(2^8) with a primitive element alpha of\n   00011101.
      \ This is a set of 256 elements, along with the operations\n   of \"addition\",
      \"subtraction\", \"division\", and \"multiplication\" on\n   these elements.
      \ An 8-bit binary number represents each element.\n   The operations of \"addition\"
      and \"subtraction\" are the same for this\n   Galois field.  Both operations
      are the XOR of two elements.  Thus,\n   the \"sum\" of 00011011 and 00000111
      is 00011100.\n   Division of two elements is done using long division with subtraction\n
      \  operations replaced by XOR.  For multiplication, standard long\n   multiplication
      is used but with the final addition stage replaced\n   with XOR.\n   All arithmetic
      in the following FEC is done modulo 100011101; for\n   instance, after you multiply
      two numbers, you replace the result with\n   its remainder when divided by 100011101.
      \ There are 256 values in\n   this field (256 possible remainders), the 8-bit
      numbers.  It is very\n   important to remember that when we write A*B = C, we
      more accurately\n   imply modulo(A*B) = C.\n   It is obvious from the above
      description that multiplication and\n   division is time consuming to perform.
      \ Elements of the Galois Field\n   share two important properties with real
      numbers.\n   A*B = POWERalpha(LOGalpha(A) + LOGalpha(B))\n   A/B = POWERalpha(LOGalpha(A)
      - LOGalpha(B))\n   The Galois Field is limited to 256 entries so the power and
      log\n   tables are limited to 256 entries.  The addition and subtraction\n   shown
      is standard so the result must be modulo alpha.  Written as a\n   \"C\" expression:\n
      \  A*B = apower[alog[A] + alog[B]]\n   A/B = apower[255 + alog[A] - alog[B]]\n
      \  You may note that alog[A] + alog[B] can be greater than 255 and\n   therefore
      a modulo operation should be performed.  This is not\n   necessary if the power
      table is extended to 512 entries by repeating\n   the table.  The same logic
      is true for division as shown.  The power\n   and log tables are calculated
      once using the long multiplication\n   shown above.\n"
    title: 12.1. Mathematics used in the FEC
  - contents:
    - "12.2. Calculating FEC bytes\n   The FEC algorithm splits a serial stream of
      data into \"bundles\".\n   These are arranged as 16 packets of 28 bytes when
      the correction\n   bytes are included.  The bundle therefore has 16 horizontal
      codewords\n   interleaved with 28 vertical codewords.  Two sums are calculated
      for\n   a codeword, S0 and S1.  S0 is the sum of all bytes of the codeword\n
      \  each multiplied by alpha to the power of its index in the codeword.\n   S1
      is the sum of all bytes of the codeword each multiplied by alpha\n   to the
      power of three times its index in the codeword.  In \"C\" the\n   sum calculations
      would look like:\n   Sum0 = 0;\n      Sum1 = 0;\n      For (i = 0;i < m;i++)\n
      \     {\n         if (codeword[i] != 0)\n         {\n            Sum0 = sum0
      ^ power[i + alog[codeword[i]]];\n            Sum1 = sum1 ^ power[3*i + alog[codeword[i]]];\n
      \           }\n         }\n   Note that the codeword order is different from
      the packet order.\n   Codeword positions 0 and 1 are the suffix bytes at the
      end of a\n   packet horizontally or at the end of a column vertically.\n   When
      calculating the two FEC bytes, the summation above must produce\n   two sums
      of zero.  All codewords except 0 and 1 are know so the sums\n   for the known
      codewords can be calculated.  Let's call these values\n   tot0 and tot1.\n   Sum0
      = tot0^power[0+alog[codeword[0]]]^power[1+alog[codeword[1]]]\n   Sum1 = tot1^power[0+alog[codeword[0]]]^power[3+alog[codeword[1]]]\n
      \  This gives us two equations with the two unknowns that we can solve:\n   codeword[1]
      = power[255+alog[tot0^tot1]-alog[power[1]^power[3]]]\n   codeword[0] = tot0^power[alog[codeword[1]]+alog[power[1]]]\n"
    title: 12.2. Calculating FEC bytes
  - contents:
    - "12.3. Correcting Errors\n   This section describes the procedure for detecting
      and correcting\n   errors using the FEC data calculated above.  Upon reception,
      we begin\n   by rebuilding the bundle.  This is perhaps the most important part
      of\n   the procedure because if the bundle is not built correctly it cannot\n
      \  possibly correct any errors.  The continuity index is used to\n   determine
      the order of the packets and if any packets are missing\n   (not captured by
      the hardware).  The recommendation, when building\n   the bundle, is to convert
      the bundle from packet order to codeword\n   order.  This conversion will simplify
      the codeword calculations. This\n   is done by taking the last byte of a packet
      and making it the second\n   byte of the codeword and taking the second last
      byte of a packet and\n   making it the first byte of a codeword.  Also the packet
      with\n   continuity index 15 becomes codeword position one and the packet with\n
      \  continuity index 14 becomes codeword position zero.  The same FEC is\n   used
      regardless of the number of bytes in the codeword.  So let's\n   think of the
      codewords as an array codeword[vert][hor] where vert is\n   16 packets and hor
      is 28.  Each byte in the array is protected by\n   both a horizontal and a vertical
      codeword.  For each of the\n   codewords, the sums must be calculated. If both
      the sums for a\n   codeword are zero then no errors have been detected for that\n
      \  codeword.  Otherwise, an error has been detected and further steps\n   need
      to be taken to see if the error can be corrected.  In \"C\" the\n   horizontal
      summation would look like:\n   for (i = 0; i < 16; i++)\n   {\n      sum0 =
      0;\n      sum1 = 0;\n      for (j = 0;j < hor;j++)\n      {\n         if (codeword[i][j]
      != 0)\n         {\n            sum0 = sum0 ^ power[j + alog[codeword[i][j]];\n
      \           sum1 = sum1 ^ power[3*j + alog[codeword[i][j]];\n         }\n      }\n
      \     if ((sum0 != 0) || (sum1 != 0))\n      {\n         Try Correcting Packet\n
      \     }\n   }\n   Similarly, vertical looks like:\n   for (j = 0;i < hor;i++)\n
      \  {\n      sum0 = 0;\n      sum1 = 0;\n      for (i = 0;i < 16;i++)\n      {\n
      \        if (codeword[i][j] != 0)\n         {\n            sum0 = sum0 ^ power[i
      + alog[codeword[i][j]];\n            sum1 = sum1 ^ power[3*i + alog[codeword[i][j]];\n
      \        }\n      }\n      if ((sum0 != 0) || (sum1 != 0))\n      {\n         Try
      Correcting Column\n      }\n   }\n"
    title: 12.3. Correcting Errors
  - contents:
    - "12.4. Correction Schemes\n   This FEC provides four possible corrections:\n
      \  1)    Single bit correction in codeword.  All single bit errors.\n   2)    Double
      bit correction in a codeword.  Most two-bit errors.\n   3)    Single byte correction
      in a codeword.  All single-byte errors.\n   4)    Packet replacement.  One or
      two missing packets from a bundle.\n"
    - contents:
      - "12.4.1. Single Bit Correction\n   When correcting a single-bit in a codeword,
        the byte and bit position\n   must be calculated.  The equations are:\n   Byte
        = 1/2LOGalpha(S1/S0)\n   Bit  = 8LOGalpha(S0/POWERalpha(Byte))\n   In \"C\"
        this is written:\n   Byte = alog[power[255 + alog[sum1] - alog[sum0]]];\n
        \  if (Byte & 1)\n      Byte = Byte + 255;\n   Byte = Byte >> 1;\n   Bit =
        alog[power[255 + alog[sum0] - Byte]] << 3;\n   while (Bit > 255)\n      Bit
        = Bit - 255;\n   The error is correctable if Byte is less than the number
        of bytes in\n   the codeword and Bit is less than eight.  For this math to
        be valid\n   both sum0 and sum1 must be non-zero.  The codeword is corrected
        by:\n   codeword[Byte] = codeword[Byte] ^ (1 << Bit);\n"
      title: 12.4.1. Single Bit Correction
    - contents:
      - "12.4.2. Double Bit Correction\n   Double bit correction is much more complex
        than single bit correction\n   for two reasons.  First, not all double bit
        errors are deterministic.\n   That is two different bit patterns can generate
        the same sums.\n   Second, the solution is iterative.  To find two bit errors
        you assume\n   one bit in error and then solve for the second error as a single
        bit\n   error.\n   The procedure is to iteratively move through the bits of
        the codeword\n   changing each bit's state.  The new sums are calculated for
        the\n   modified codeword. Then the single bit calculation above determines\n
        \  if this is the correct solution.  If not, the bit is restored and the\n
        \  next bit is tried.\n   For a long codeword, this can involve many calculations.
        \ However,\n   tricks can speed the process.  For example, the vertical sums
        give a\n   strong indication of which bytes are in error horizontally.  Bits
        in\n   other bytes need not be tried.\n"
      title: 12.4.2. Double Bit Correction
    - contents:
      - "12.4.3. Single Byte Correction\n   For single byte correction, the byte position
        and bits to correct\n   must be calculated.  The equations are:\n   Byte =
        1/2*LOGalpha(S1/S0)\n   Mask = S0/POWERalpha[Byte]\n   Notice that the byte
        position is the same calculation as for single\n   bit correction.  The mask
        will allow more than one bit in the byte to\n   be corrected.  In \"C\" the
        mask calculation looks like:\n   Mask = power[255 + alog[sum0] - Byte]\n   Both
        sum0 and sum1 must be non-zero for the calculations to be valid.\n   The Byte
        value must be less than the codeword length but Mask can be\n   any value.
        \ This corrects the byte in the codeword by:\n   Codeword[Byte] = Codeword[Byte]
        ^ Mask\n"
      title: 12.4.3. Single Byte Correction
    - contents:
      - "12.4.4. Packet Replacement\n   If a packet is missing, as determined by the
        continuity index, then\n   its byte position is known and does not need to
        be calculated.  The\n   formula for single packet replacement is therefore
        the same as for\n   the Mask calculation of single byte correction.  Instead
        of XORing an\n   existing byte with the Mask, the Mask replaces the missing
        codeword\n   position:\n   Codeword[Byte] = Mask\n   When two packets are
        missing, both the codeword positions are known\n   by the continuity index.
        \ This again gives two equations with two\n   unknowns, which is solved to
        give the following equations.  Mask2 =\n   POWERalpha(2*Byte1)*S0+S1\n   POWERalpha(2*Byte1+Byte2)
        +POWERalpha(3*BYTE2)\n   Mask1 = S0 + Mask2*POWERalpha(Byte2)/POWERalpha(BYTE1)\n"
      - 'In "C" these equations are written:

        '
      - 'if (sum0 == 0)

        '
      - "{\n   if (sum1 == 0)\n      mask2 = 0;\n   else\n      mask2=power[255+alog[sum1]-alog[power[byte2+2*byte1]\n
        \                 ^power[3*Byte2]]];\n"
      - '}

        '
      - 'else

        '
      - "{\n   if ((a=sum1^power[alog[sum0]+2*byte1]) == 0)\n      mask2 = 0;\n   else\n
        \     mask2 =\n"
      - 'power[255+alog[a]-alog[power[byte2+2*byte1]^power[3*byte2]]];

        '
      - '}

        '
      - 'if (mask2 = 0)

        '
      - "{\n   if (sum0 == 0)\n      mask1 = 0;\n   else\n      mask1 = power[255+alog[sum0]-byte1];\n"
      - '}

        '
      - 'else

        '
      - "{\n   if ((a=sum0^power[alog[mask2] + byte2]) == 0)\n      mask1 = 0;\n   else\n
        \     mask1 = power[255+alog[a]-byte1];\n"
      - "}\n   Notice that, in the code above, care is taken to check for zero\n   values.
        \ The missing codeword position can be fixed by:\n         codeword[byte1]
        = mask1;\n         codeword[byte2] = mask2;\n"
      title: 12.4.4. Packet Replacement
    title: 12.4. Correction Schemes
  - contents:
    - "12.5. FEC Performance Considerations\n   The section above shows how to correct
      the different types of errors.\n   It does not suggest how these corrections
      may be used in an algorithm\n   to correct a bundle.  There are many possible
      algorithms and the one\n   chosen depends on many variables.  These include:\n
      \     . The amount of processing power available\n      . The number of packets
      per VBI to process\n      . The type of hardware capturing the data\n      .
      The delivery path of the VBI\n      . How the code is implemented\n   As a minimum,
      it is recommended that the algorithm use single bit or\n   single byte correction
      for one pass in each direction followed by\n   packet replacement if appropriate.
      \ It is possible to do more than\n   one pass of error correction in each direction.
      \ The theory is that\n   errors not corrected in the first pass may be corrected
      in the second\n   pass because error correction in the other direction has removed
      some\n   errors.\n   In making choices, it is important to remember that the
      code has\n   several possible states:\n   1)    Shows codeword as correct and
      it is.\n   2)    Shows codeword as correct and it is not (detection failure).\n
      \  3)    Shows codeword as incorrect but cannot correct (detection).\n   4)
      \   Shows codeword as incorrect and corrects it correctly\n         (correction).\n
      \  5)    Shows codeword as incorrect but corrects wrong bits (false\n         correction).\n
      \  There is actually overlap among the different types of errors.  For\n   example,
      a pair of sums may indicate both a double bit error and a\n   byte error.  It
      is not possible to know at the code level which is\n   correct and which is
      a false correction.  In fact, neither might be\n   correct if both are false
      corrections.\n   If you know something about the types of errors in the delivery\n
      \  channel, you can greatly improve efficiency.  If you know that errors\n   are
      randomly distributed (as in a weak terrestrial broadcast) then\n   single and
      double bit correction are more powerful than single byte.\n"
    title: 12.5. FEC Performance Considerations
  title: '12. Appendix A: Forward Error Correction Specification'
- contents:
  - "13. Appendix B: Architecture\n   The architecture that this document is addressing
    can be broken down\n   into three areas: insertion, distribution network, and
    receiving\n   client.\n   The insertion of IP data onto the television signal
    can occur at any\n   part of the delivery system.  A VBI encoder typically accepts
    a video\n   signal and an asynchronous serial stream of bytes forming framed IP\n
    \  packets as inputs and subsequently packetizes the data onto a\n   selected
    set of lines using NABTS and an FEC.  This composite signal\n   is then modulated
    with other channels before being broadcast onto the\n   distribution network.
    Operators further down the distribution chain\n   could then add their own data,
    to other unused lines, as well.  The\n   distribution networks include coax plant,
    off-air, and analog\n   satellite systems and are primarily unidirectional broadcast\n
    \  networks.  They must provide a signal to noise ratio, which is\n   sufficient
    for FEC to recover any lost data for the broadcast of data\n   to be effective.\n
    \  The receiving client must be capable of tuning, NABTS waveform\n   sampling
    as appropriate, filtering on NABTS addresses as appropriate,\n   forward error
    correction, unframing, verification of the CRC and\n   decompressing the UDP/IP
    header if they are compressed. All of the\n   above functions can be carried out
    in PC software and inexpensive\n   off-the-shelf hardware.\n"
  title: '13. Appendix B: Architecture'
- contents:
  - "14. Appendix C: Scope of proposed protocols\n   The protocols described in this
    document are for transmitting IP\n   packets.  However, their scope may be extensible
    to other\n   applications outside this area.  Many of the protocols in this\n
    \  document could be implemented on any unidirectional network.\n   The unidirectional
    framing protocol provides encapsulation of IP\n   datagrams on the serial stream,
    and the compression of the UDP/IP\n   headers reduces the overhead on transmission,
    thus conserving\n   bandwidth.  These two protocols could be widely used on different\n
    \  unidirectional broadcast networks or modulation schemes to\n   efficiently
    transport any type of packet data.  In particular, new\n   versions of Internet
    protocols can be supported to provide a\n   standardized method of data transport.\n"
  title: '14. Appendix C: Scope of proposed protocols'
- contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 15.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
