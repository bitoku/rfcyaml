- contents:
  - "                             Extensions to\n     Resource Reservation Protocol
    - Traffic Engineering (RSVP-TE)\n         for Point-to-Multipoint TE Label Switched
    Paths (LSPs)\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes extensions to Resource Reservation Protocol
    -\n   Traffic Engineering (RSVP-TE) for the set up of Traffic Engineered\n   (TE)
    point-to-multipoint (P2MP) Label Switched Paths (LSPs) in Multi-\n   Protocol
    Label Switching (MPLS) and Generalized MPLS (GMPLS)\n   networks.  The solution
    relies on RSVP-TE without requiring a\n   multicast routing protocol in the Service
    Provider core.  Protocol\n   elements and procedures for this solution are described.\n
    \  There can be various applications for P2MP TE LSPs such as IP\n   multicast.
    \ Specification of how such applications will use a P2MP TE\n   LSP is outside
    the scope of this document.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Conventions Used in This Document ...............................4\n   3.
    Terminology .....................................................4\n   4. Mechanism
    .......................................................5\n      4.1. P2MP Tunnels
    ...............................................5\n      4.2. P2MP LSP ...................................................5\n
    \     4.3. Sub-Groups .................................................5\n      4.4.
    S2L Sub-LSPs ...............................................6\n           4.4.1.
    Representation of an S2L Sub-LSP ....................6\n           4.4.2. S2L
    Sub-LSPs and Path Messages ......................7\n      4.5. Explicit Routing
    ...........................................7\n   5. Path Message ....................................................9\n
    \     5.1. Path Message Format ........................................9\n      5.2.
    Path Message Processing ...................................11\n           5.2.1.
    Multiple Path Messages .............................11\n           5.2.2. Multiple
    S2L Sub-LSPs in One Path Message ..........12\n           5.2.3. Transit Fragmentation
    of Path State Information ....14\n           5.2.4. Control of Branch Fate Sharing
    .....................15\n      5.3. Grafting ..................................................15\n
    \  6. Resv Message ...................................................16\n      6.1.
    Resv Message Format .......................................16\n      6.2. Resv
    Message Processing ...................................17\n           6.2.1. Resv
    Message Throttling ............................18\n      6.3. Route Recording
    ...........................................19\n           6.3.1. RRO Processing
    .....................................19\n      6.4. Reservation Style .........................................19\n
    \  7. PathTear Message ...............................................20\n      7.1.
    PathTear Message Format ...................................20\n      7.2. Pruning
    ...................................................20\n           7.2.1. Implicit
    S2L Sub-LSP Teardown ......................20\n           7.2.2. Explicit S2L
    Sub-LSP Teardown ......................21\n   8. Notify and ResvConf Messages
    ...................................21\n      8.1. Notify Messages ...........................................21\n
    \     8.2. ResvConf Messages .........................................23\n   9.
    Refresh Reduction ..............................................24\n   10. State
    Management ..............................................24\n      10.1. Incremental
    State Update .................................25\n      10.2. Combining Multiple
    Path Messages .........................25\n   11. Error Processing ..............................................26\n
    \     11.1. PathErr Messages .........................................27\n      11.2.
    ResvErr Messages .........................................27\n      11.3. Branch
    Failure Handling ..................................28\n   12. Admin Status Change
    ...........................................29\n   13. Label Allocation on LANs
    with Multiple Downstream Nodes .......29\n   14. P2MP LSP and Sub-LSP Re-Optimization
    ..........................29\n      14.1. Make-before-Break ........................................29\n
    \     14.2. Sub-Group-Based Re-Optimization ..........................29\n   15.
    Fast Reroute ..................................................30\n      15.1.
    Facility Backup ..........................................31\n           15.1.1.
    Link Protection ...................................31\n           15.1.2. Node
    Protection ...................................31\n      15.2. One-to-One Backup
    ........................................32\n   16. Support for LSRs That Are Not
    P2MP Capable ....................33\n   17. Reduction in Control Plane Processing
    with LSP Hierarchy ......34\n   18. P2MP LSP Re-Merging and Cross-Over ............................35\n
    \     18.1. Procedures ...............................................36\n           18.1.1.
    Re-Merge Procedures ...............................36\n   19. New and Updated
    Message Objects ...............................39\n      19.1. SESSION Object
    ...........................................39\n           19.1.1. P2MP LSP Tunnel
    IPv4 SESSION Object ...............39\n           19.1.2. P2MP LSP Tunnel IPv6
    SESSION Object ...............40\n      19.2. SENDER_TEMPLATE Object ...................................40\n
    \          19.2.1. P2MP LSP Tunnel IPv4 SENDER_TEMPLATE Object .......41\n           19.2.2.
    P2MP LSP Tunnel IPv6 SENDER_TEMPLATE Object .......42\n      19.3. S2L_SUB_LSP
    Object .......................................43\n           19.3.1. S2L_SUB_LSP
    IPv4 Object ...........................43\n           19.3.2. S2L_SUB_LSP IPv6
    Object ...........................43\n      19.4. FILTER_SPEC Object .......................................43\n
    \          19.4.1. P2MP LSP_IPv4 FILTER_SPEC Object ..................43\n           19.4.2.
    P2MP LSP_IPv6 FILTER_SPEC Object ..................44\n      19.5. P2MP SECONDARY_EXPLICIT_ROUTE
    Object (SERO) ..............44\n      19.6. P2MP SECONDARY_RECORD_ROUTE Object
    (SRRO) ................44\n   20. IANA Considerations ...........................................44\n
    \     20.1. New Class Numbers ........................................44\n      20.2.
    New Class Types ..........................................44\n      20.3. New
    Error Values .........................................45\n      20.4. LSP Attributes
    Flags .....................................46\n   21. Security Considerations
    .......................................46\n   22. Acknowledgements ..............................................47\n
    \  23. References ....................................................47\n      23.1.
    Normative References .....................................47\n      23.2. Informative
    References ...................................48\n   Appendix A. Example of P2MP
    LSP Setup .............................49\n   Appendix B. Contributors ..........................................50\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC3209] defines a mechanism for setting up point-to-point
    (P2P)\n   Traffic Engineered (TE) Label Switched Paths (LSPs) in Multi-Protocol\n
    \  Label Switching (MPLS) networks.  [RFC3473] defines extensions to\n   [RFC3209]
    for setting up P2P TE LSPs in Generalized MPLS (GMPLS)\n   networks.  However
    these specifications do not provide a mechanism\n   for building point-to-multipoint
    (P2MP) TE LSPs.\n   This document defines extensions to the RSVP-TE protocol ([RFC3209]\n
    \  and [RFC3473]) to support P2MP TE LSPs satisfying the set of\n   requirements
    described in [RFC4461].\n   This document relies on the semantics of the Resource
    Reservation\n   Protocol (RSVP) that RSVP-TE inherits for building P2MP LSPs.
    \ A P2MP\n   LSP is comprised of multiple source-to-leaf (S2L) sub-LSPs.  These\n
    \  S2L sub-LSPs are set up between the ingress and egress LSRs and are\n   appropriately
    combined by the branch LSRs using RSVP semantics to\n   result in a P2MP TE LSP.
    \ One Path message may signal one or multiple\n   S2L sub-LSPs for a single P2MP
    LSP.  Hence the S2L sub-LSPs belonging\n   to a P2MP LSP can be signaled using
    one Path message or split across\n   multiple Path messages.\n   There are various
    applications for P2MP TE LSPs and the signaling\n   techniques described in this
    document can be used, sometimes in\n   combination with other techniques, to support
    different applications.\n   Specification of how applications will use P2MP TE
    LSPs and how the\n   paths of P2MP TE LSPs are computed is outside the scope of
    this\n   document.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in RFC 2119 [RFC2119].\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  Terminology\n   This document uses terminologies defined in [RFC2205], [RFC3031],\n
    \  [RFC3209], [RFC3473], [RFC4090], and [RFC4461].\n"
  title: 3.  Terminology
- contents:
  - "4.  Mechanism\n   This document describes a solution that optimizes data replication
    by\n   allowing non-ingress nodes in the network to be replication/branch\n   nodes.
    \ A branch node is an LSR that replicates the incoming data on\n   to one or more
    outgoing interfaces.  The solution relies on RSVP-TE\n   in the network for setting
    up a P2MP TE LSP.\n   The P2MP TE LSP is set up by associating multiple S2L sub-LSPs
    and\n   relying on data replication at branch nodes.  This is described\n   further
    in the following sub-sections by describing P2MP tunnels and\n   how they relate
    to S2L sub-LSPs.\n"
  - contents:
    - "4.1.  P2MP Tunnels\n   The defining feature of a P2MP TE LSP is the action
      required at\n   branch nodes where data replication occurs.  Incoming MPLS labeled\n
      \  data is replicated to outgoing interfaces which may use different\n   labels
      for the data.\n   A P2MP TE Tunnel comprises one or more P2MP LSPs.  A P2MP
      TE Tunnel\n   is identified by a P2MP SESSION object.  This object contains
      the\n   identifier of the P2MP Session, which includes the P2MP Identifier\n
      \  (P2MP ID), a tunnel Identifier (Tunnel ID), and an extended tunnel\n   identifier
      (Extended Tunnel ID).  The P2MP ID is a four-octet number\n   and is unique
      within the scope of the ingress LSR.\n   The <P2MP ID, Tunnel ID, Extended Tunnel
      ID> tuple provides an\n   identifier for the set of destinations of the P2MP
      TE Tunnel.\n   The fields of the P2MP SESSION object are identical to those
      of the\n   SESSION object defined in [RFC3209] except that the Tunnel Endpoint\n
      \  Address field is replaced by the P2MP ID field.  The P2MP SESSION\n   object
      is defined in section 19.1\n"
    title: 4.1.  P2MP Tunnels
  - contents:
    - "4.2.  P2MP LSP\n   A P2MP LSP is identified by the combination of the P2MP
      ID, Tunnel\n   ID, and Extended Tunnel ID that are part of the P2MP SESSION
      object,\n   and the tunnel sender address and LSP ID fields of the P2MP\n   SENDER_TEMPLATE
      object.  The new P2MP SENDER_TEMPLATE object is\n   defined in section 19.2.\n"
    title: 4.2.  P2MP LSP
  - contents:
    - "4.3.  Sub-Groups\n   As with all other RSVP controlled LSPs, P2MP LSP state
      is managed\n   using RSVP messages.  While the use of RSVP messages is the same,\n
      \  P2MP LSP state differs from P2P LSP state in a number of ways.  A\n   P2MP
      LSP comprises multiple S2L Sub-LSPs, and as a result of this, it\n   may not
      be possible to represent full state in a single IP packet.\n   It must also
      be possible to efficiently add and remove endpoints to\n   and from P2MP TE
      LSPs.  An additional issue is that the P2MP LSP must\n   also handle the state
      \"re-merge\" problem, see [RFC4461] and section\n   18.\n   These differences
      in P2MP state are addressed through the addition of\n   a sub-group identifier
      (Sub-Group ID) and sub-group originator (Sub-\n   Group Originator ID) to the
      SENDER_TEMPLATE and FILTER_SPEC objects.\n   Taken together, the Sub-Group ID
      and Sub-Group Originator ID are\n   referred to as the Sub-Group fields.\n   The
      Sub-Group fields, together with the rest of the SENDER_TEMPLATE\n   and SESSION
      objects, are used to represent a portion of a P2MP LSP's\n   state.  This portion
      of a P2MP LSP's state refers only to signaling\n   state and not data plane
      replication or branching.  For example, it\n   is possible for a node to \"branch\"
      signaling state for a P2MP LSP,\n   but to not branch the data associated with
      the P2MP LSP.  Typical\n   applications for generation and use of multiple sub-groups
      are (1)\n   addition of an egress and (2) semantic fragmentation to ensure that
      a\n   Path message remains within a single IP packet.\n"
    title: 4.3.  Sub-Groups
  - contents:
    - "4.4.  S2L Sub-LSPs\n   A P2MP LSP is constituted of one or more S2L sub-LSPs.\n"
    - contents:
      - "4.4.1.  Representation of an S2L Sub-LSP\n   An S2L sub-LSP exists within
        the context of a P2MP LSP.  Thus, it is\n   identified by the P2MP ID, Tunnel
        ID, and Extended Tunnel ID that are\n   part of the P2MP SESSION, the tunnel
        sender address and LSP ID fields\n   of the P2MP SENDER_TEMPLATE object, and
        the S2L sub-LSP destination\n   address that is part of the S2L_SUB_LSP object.
        \ The S2L_SUB_LSP\n   object is defined in section 19.3.\n   An EXPLICIT_ROUTE
        Object (ERO) or P2MP_SECONDARY_EXPLICIT_ROUTE\n   Object (SERO) is used to
        optionally specify the explicit route of a\n   S2L sub-LSP.  Each ERO or SERO
        that is signaled corresponds to a\n   particular S2L_SUB_LSP object.  Details
        of explicit route encoding\n   are specified in section 4.5.  The SECONDARY_EXPLICIT_ROUTE
        Object is\n   defined in [RFC4873], a new P2MP SECONDARY_EXPLICIT_ROUTE Object\n
        \  C-type is defined in section 19.5, and a matching\n   P2MP_SECONDARY_RECORD_ROUTE
        Object C-type is defined in section 19.6.\n"
      title: 4.4.1.  Representation of an S2L Sub-LSP
    - contents:
      - "4.4.2.  S2L Sub-LSPs and Path Messages\n   The mechanism in this document
        allows a P2MP LSP to be signaled using\n   one or more Path messages.  Each
        Path message may signal one or more\n   S2L sub-LSPs.  Support for multiple
        Path messages is desirable as one\n   Path message may not be large enough
        to contain all the S2L sub-LSPs;\n   and they also allow separate manipulation
        of sub-trees of the P2MP\n   LSP.  The reason for allowing a single Path message
        to signal\n   multiple S2L sub-LSPs is to optimize the number of control messages\n
        \  needed to set up a P2MP LSP.\n"
      title: 4.4.2.  S2L Sub-LSPs and Path Messages
    title: 4.4.  S2L Sub-LSPs
  - contents:
    - "4.5.  Explicit Routing\n   When a Path message signals a single S2L sub-LSP
      (that is, the Path\n   message is only targeting a single leaf in the P2MP tree),
      the\n   EXPLICIT_ROUTE object encodes the path to the egress LSR.  The Path\n
      \  message also includes the S2L_SUB_LSP object for the S2L sub-LSP\n   being
      signaled.  The < [<EXPLICIT_ROUTE>], <S2L_SUB_LSP> > tuple\n   represents the
      S2L sub-LSP and is referred to as the sub-LSP\n   descriptor.  The absence of
      the ERO should be interpreted as\n   requiring hop-by-hop routing for the sub-LSP
      based on the S2L sub-LSP\n   destination address field of the S2L_SUB_LSP object.\n
      \  When a Path message signals multiple S2L sub-LSPs, the path of the\n   first
      S2L sub-LSP to the egress LSR is encoded in the ERO.  The first\n   S2L sub-LSP
      is the one that corresponds to the first S2L_SUB_LSP\n   object in the Path
      message.  The S2L sub-LSPs corresponding to the\n   S2L_SUB_LSP objects that
      follow are termed as subsequent S2L sub-\n   LSPs.\n   The path of each subsequent
      S2L sub-LSP is encoded in a\n   P2MP_SECONDARY_EXPLICIT_ROUTE object (SERO).
      \ The format of the SERO\n   is the same as an ERO (as defined in [RFC3209]
      and [RFC3473]).  Each\n   subsequent S2L sub-LSP is represented by tuples of
      the form < [<P2MP\n   SECONDARY_EXPLICIT_ROUTE>], <S2L_SUB_LSP> >.  An SERO
      for a\n   particular S2L sub-LSP includes only the path from a branch LSR to\n
      \  the egress LSR of that S2L sub-LSP.  The branch MUST appear as an\n   explicit
      hop in the ERO or some other SERO.  The absence of an SERO\n   should be interpreted
      as requiring hop-by-hop routing for that S2L\n   sub-LSP.  Note that the destination
      address is carried in the S2L\n   sub-LSP object.  The encoding of the SERO
      and S2L_SUB_LSP object is\n   described in detail in section 19.\n   In order
      to avoid the potential repetition of path information for\n   the parts of S2L
      sub-LSPs that share hops, this information is\n   deduced from the explicit
      routes of other S2L sub-LSPs using explicit\n   route compression in SEROs.\n
      \                                   A\n                                    |\n
      \                                   |\n                                    B\n
      \                                   |\n                                    |\n
      \                         C----D----E\n                          |    |    |\n
      \                         |    |    |\n                          F    G    H-------I\n
      \                              |    |\\      |\n                               |
      \   | \\     |\n                               J    K   L   M\n                               |
      \   |   |   |\n                               |    |   |   |\n                               N
      \   O   P   Q--R\n                  Figure 1.  Explicit Route Compression\n
      \  Figure 1 shows a P2MP LSP with LSR A as the ingress LSR and six\n   egress
      LSRs: (F, N, O, P, Q and R).  When all six S2L sub-LSPs are\n   signaled in
      one Path message, let us assume that the S2L sub-LSP to\n   LSR F is the first
      S2L sub-LSP, and the rest are subsequent S2L sub-\n   LSPs.  The following encoding
      is one way for the ingress LSR A to\n   encode the S2L sub-LSP explicit routes
      using compression:\n      S2L sub-LSP-F:   ERO = {B, E, D, C, F},  <S2L_SUB_LSP>
      object-F\n      S2L sub-LSP-N:   SERO = {D, G, J, N}, <S2L_SUB_LSP> object-N\n
      \     S2L sub-LSP-O:   SERO = {E, H, K, O}, <S2L_SUB_LSP> object-O\n      S2L
      sub-LSP-P:   SERO = {H, L, P}, <S2L_SUB_LSP> object-P\n      S2L sub-LSP-Q:
      \  SERO = {H, I, M, Q}, <S2L_SUB_LSP> object-Q\n      S2L sub-LSP-R:   SERO
      = {Q, R}, <S2L_SUB_LSP> object-R\n   After LSR E processes the incoming Path
      message from LSR B it sends a\n   Path message to LSR D with the S2L sub-LSP
      explicit routes encoded as\n   follows:\n      S2L sub-LSP-F:   ERO = {D, C,
      F},  <S2L_SUB_LSP> object-F\n      S2L sub-LSP-N:   SERO = {D, G, J, N}, <S2L_SUB_LSP>
      object-N\n   LSR E also sends a Path message to LSR H, and the following is
      one\n   way to encode the S2L sub-LSP explicit routes using compression:\n      S2L
      sub-LSP-O:   ERO = {H, K, O}, <S2L_SUB_LSP> object-O\n      S2L sub-LSP-P:   SERO
      = {H, L, P}, S2L_SUB_LSP object-P\n      S2L sub-LSP-Q:   SERO = {H, I, M, Q},
      <S2L_SUB_LSP> object-Q\n      S2L sub-LSP-R:   SERO = {Q, R}, <S2L_SUB_LSP>
      object-R\n   After LSR H processes the incoming Path message from E, it sends
      a\n   Path message to LSR K, LSR L, and LSR I.  The encoding for the Path\n
      \  message to LSR K is as follows:\n      S2L sub-LSP-O:   ERO  = {K, O}, <S2L_SUB_LSP>
      object-O\n   The encoding of the Path message sent by LSR H to LSR L is as\n
      \  follows:\n      S2L sub-LSP-P:   ERO = {L, P}, <S2L_SUB_LSP> object-P\n   The
      following encoding is one way for LSR H to encode the S2L sub-LSP\n   explicit
      routes in the Path message sent to LSR I:\n      S2L sub-LSP-Q:   ERO = {I,
      M, Q}, <S2L_SUB_LSP> object-Q\n      S2L sub-LSP-R:   SERO = {Q, R}, <S2L_SUB_LSP>
      object-R\n   The explicit route encodings in the Path messages sent by LSRs
      D and\n   Q are left as an exercise for the reader.\n   This compression mechanism
      reduces the Path message size.  It also\n   reduces extra processing that can
      result if explicit routes are\n   encoded from ingress to egress for each S2L
      sub-LSP.  No assumptions\n   are placed on the ordering of the subsequent S2L
      sub-LSPs and hence\n   on the ordering of the SEROs in the Path message.  All
      LSRs need to\n   process the ERO corresponding to the first S2L sub-LSP.  An
      LSR needs\n   to process an S2L sub-LSP descriptor for a subsequent S2L sub-LSP\n
      \  only if the first hop in the corresponding SERO is a local address of\n   that
      LSR.  The branch LSR that is the first hop of an SERO propagates\n   the corresponding
      S2L sub-LSP downstream.\n"
    title: 4.5.  Explicit Routing
  title: 4.  Mechanism
- contents:
  - '5.  Path Message

    '
  - contents:
    - "5.1.  Path Message Format\n   This section describes modifications made to
      the Path message format\n   as specified in [RFC3209] and [RFC3473].  The Path
      message is\n   enhanced to signal one or more S2L sub-LSPs.  This is done by\n
      \  including the S2L sub-LSP descriptor list in the Path message as\n   shown
      below.\n   <Path Message> ::=     <Common Header> [ <INTEGRITY> ]\n                          [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ...]\n                          [ <MESSAGE_ID>
      ]\n                          <SESSION> <RSVP_HOP>\n                          <TIME_VALUES>\n
      \                         [ <EXPLICIT_ROUTE> ]\n                          <LABEL_REQUEST>\n
      \                         [ <PROTECTION> ]\n                          [ <LABEL_SET>
      ... ]\n                          [ <SESSION_ATTRIBUTE> ]\n                          [
      <NOTIFY_REQUEST> ]\n                          [ <ADMIN_STATUS> ]\n                          [
      <POLICY_DATA> ... ]\n                          <sender descriptor>\n                          [<S2L
      sub-LSP descriptor list>]\n   The following is the format of the S2L sub-LSP
      descriptor list.\n   <S2L sub-LSP descriptor list> ::= <S2L sub-LSP descriptor>\n
      \                                    [ <S2L sub-LSP descriptor list> ]\n   <S2L
      sub-LSP descriptor> ::= <S2L_SUB_LSP>\n                                [ <P2MP
      SECONDARY_EXPLICIT_ROUTE> ]\n   Each LSR MUST use the common objects in the
      Path message and the S2L\n   sub-LSP descriptors to process each S2L sub-LSP
      represented by the\n   S2L_SUB_LSP object and the SECONDARY-/EXPLICIT_ROUTE
      object\n   combination.\n   Per the definition of <S2L sub-LSP descriptor>,
      each S2L_SUB_LSP\n   object MAY be followed by a corresponding SERO.  The first\n
      \  S2L_SUB_LSP object is a special case, and its explicit route is\n   specified
      by the ERO.  Therefore, the first S2L_SUB_LSP object SHOULD\n   NOT be followed
      by an SERO, and if one is present, it MUST be\n   ignored.\n   The RRO in the
      sender descriptor contains the upstream hops traversed\n   by the Path message
      and applies to all the S2L sub-LSPs signaled in\n   the Path message.\n   An
      IF_ID RSVP_HOP object MUST be used on links where there is not a\n   one-to-one
      association of a control channel to a data channel\n   [RFC3471].  An RSVP_HOP
      object defined in [RFC2205] SHOULD be used\n   otherwise.\n   Path message processing
      is described in the next section.\n"
    title: 5.1.  Path Message Format
  - contents:
    - "5.2.  Path Message Processing\n   The ingress LSR initiates the setup of an
      S2L sub-LSP to each egress\n   LSR that is a destination of the P2MP LSP.  Each
      S2L sub-LSP is\n   associated with the same P2MP LSP using common P2MP SESSION
      object\n   and <Sender Address, LSP-ID> fields in the P2MP SENDER_TEMPLATE\n
      \  object.  Hence, it can be combined with other S2L sub-LSPs to form a\n   P2MP
      LSP.  Another S2L sub-LSP belonging to the same instance of this\n   S2L sub-LSP
      (i.e., the same P2MP LSP) SHOULD share resources with\n   this S2L sub-LSP.
      \ The session corresponding to the P2MP TE tunnel is\n   determined based on
      the P2MP SESSION object.  Each S2L sub-LSP is\n   identified using the S2L_SUB_LSP
      object.  Explicit routing for the\n   S2L sub-LSPs is achieved using the ERO
      and SEROs.\n   As mentioned earlier, it is possible to signal S2L sub-LSPs for
      a\n   given P2MP LSP in one or more Path messages, and a given Path message\n
      \  can contain one or more S2L sub-LSPs.  An LSR that supports RSVP-TE\n   signaled
      P2MP LSPs MUST be able to receive and process multiple Path\n   messages for
      the same P2MP LSP and multiple S2L sub-LSPs in one Path\n   message.  This implies
      that such an LSR MUST be able to receive and\n   process all objects listed
      in section 19.\n"
    - contents:
      - "5.2.1.  Multiple Path Messages\n   As described in section 4, either the
        < [<EXPLICIT_ROUTE>]\n   <S2L_SUB_LSP> > or the < [<P2MP SECONDARY_EXPLICIT_ROUTE>]\n
        \  <S2L_SUB_LSP> > tuple is used to specify an S2L sub-LSP.  Multiple\n   Path
        messages can be used to signal a P2MP LSP.  Each Path message\n   can signal
        one or more S2L sub-LSPs.  If a Path message contains only\n   one S2L sub-LSP,
        each LSR along the S2L sub-LSP follows [RFC3209]\n   procedures for processing
        the Path message besides the S2L_SUB_LSP\n   object processing described in
        this document.\n   Processing of Path messages containing more than one S2L
        sub-LSP is\n   described in section 5.2.2.\n   An ingress LSR MAY use multiple
        Path messages for signaling a P2MP\n   LSP.  This may be because a single
        Path message may not be large\n   enough to signal the P2MP LSP.  Or it may
        be that when new leaves are\n   added to the P2MP LSP, they are signaled in
        a new Path message.  Or\n   an ingress LSR MAY choose to break the P2MP tree
        into separate\n   manageable P2MP trees.  These trees share the same root
        and may share\n   the trunk and certain branches.  The scope of this management\n
        \  decomposition of P2MP trees is bounded by a single tree (the P2MP\n   Tree)
        and multiple trees with a single leaf each (S2L sub-LSPs).  Per\n   [RFC4461],
        a P2MP LSP MUST have consistent attributes across all\n   portions of a tree.
        \ This implies that each Path message that is used\n   to signal a P2MP LSP
        is signaled using the same signaling attributes\n   with the exception of
        the S2L sub-LSP descriptors and Sub-Group\n   identifier.\n   The resulting
        sub-LSPs from the different Path messages belonging to\n   the same P2MP LSP
        SHOULD share labels and resources where they share\n   hops to prevent multiple
        copies of the data being sent.\n   In certain cases, a transit LSR may need
        to generate multiple Path\n   messages to signal state corresponding to a
        single received Path\n   message.  For instance ERO expansion may result in
        an overflow of the\n   resultant Path message.  In this case, the message
        can be decomposed\n   into multiple Path messages such that each message carries
        a subset\n   of the X2L sub-tree carried by the incoming message.\n   Multiple
        Path messages generated by an LSR that signal state for the\n   same P2MP
        LSP are signaled with the same SESSION object and have the\n   same <Source
        address, LSP-ID> in the SENDER_TEMPLATE object.  In\n   order to disambiguate
        these Path messages, a <Sub-Group Originator\n   ID, Sub- Group ID> tuple
        is introduced (also referred to as the Sub-\n   Group fields) and encoded
        in the SENDER_TEMPLATE object.  Multiple\n   Path messages generated by an
        LSR to signal state for the same P2MP\n   LSP have the same Sub-Group Originator
        ID and have a different sub-\n   Group ID.  The Sub-Group Originator ID MUST
        be set to the TE Router\n   ID of the LSR that originates the Path message.
        \ Cases when a transit\n   LSR may change the Sub-Group Originator ID of an
        incoming Path\n   message are described below.  The Sub-Group Originator ID
        is globally\n   unique.  The Sub-Group ID space is specific to the Sub-Group\n
        \  Originator ID.\n"
      title: 5.2.1.  Multiple Path Messages
    - contents:
      - "5.2.2.  Multiple S2L Sub-LSPs in One Path Message\n   The S2L sub-LSP descriptor
        list allows the signaling of one or more\n   S2L sub-LSPs in one Path message.
        \ Each S2L sub-LSP descriptor\n   describes a single S2L sub-LSP.\n   All
        LSRs MUST process the ERO corresponding to the first S2L sub-LSP\n   if the
        ERO is present.  If one or more SEROs are present, an ERO MUST\n   be present.
        \ The first S2L sub-LSP MUST be propagated in a Path\n   message by each LSR
        along the explicit route specified by the ERO, if\n   the ERO is present.
        \ Else it MUST be propagated using hop-by-hop\n   routing towards the destination
        identified by the S2L_SUB_LSP object.\n   An LSR MUST process an S2L sub-LSP
        descriptor for a subsequent S2L\n   sub-LSP as follows:\n   If the S2L_SUB_LSP
        object is followed by an SERO, the LSR MUST check\n   the first hop in the
        SERO:\n      - If the first hop of the SERO identifies a local address of
        the\n        LSR, and the LSR is also the egress identified by the\n        S2L_SUB_LSP
        object, the descriptor MUST NOT be propagated\n        downstream, but the
        SERO may be used for egress control per\n        [RFC4003].\n      - If the
        first hop of the SERO identifies a local address of the\n        LSR, and
        the LSR is not the egress as identified by the\n        S2L_SUB_LSP object,
        the S2L sub-LSP descriptor MUST be included\n        in a Path message sent
        to the next-hop determined from the SERO.\n      - If the first hop of the
        SERO is not a local address of the LSR,\n        the S2L sub-LSP descriptor
        MUST be included in the Path message\n        sent to the LSR that is the
        next hop to reach the first hop in\n        the SERO.  This next hop is determined
        by using the ERO or other\n        SEROs that encode the path to the SERO's
        first hop.\n   If the S2L_SUB_LSP object is not followed by an SERO, the LSR
        MUST\n   examine the S2L_SUB_LSP object:\n      - If this LSR is the egress
        as identified by the S2L_SUB_LSP\n        object, the S2L sub-LSP descriptor
        MUST NOT be propagated\n        downstream.\n      - If this LSR is not the
        egress as identified by the S2L_SUB_LSP\n        object, the LSR MUST make
        a routing decision to determine the\n        next hop towards the egress,
        and MUST include the S2L sub-LSP\n        descriptor in a Path message sent
        to the next-hop towards the\n        egress.  In this case, the LSR MAY insert
        an SERO into the S2L\n        sub-LSP descriptor.\n   Hence, a branch LSR
        MUST only propagate the relevant S2L sub-LSP\n   descriptors to each downstream
        hop.  An S2L sub-LSP descriptor list\n   that is propagated on a downstream
        link MUST only contain those S2L\n   sub-LSPs that are routed using that hop.
        \ This processing MAY result\n   in a subsequent S2L sub-LSP in an incoming
        Path message becoming the\n   first S2L sub-LSP in an outgoing Path message.\n
        \  Note that if one or more SEROs contain loose hops, expansion of such\n
        \  loose hops MAY result in overflowing the Path message size.  section\n
        \  5.2.3 describes how signaling of the set of S2L sub-LSPs can be split\n
        \  across more than one Path message.\n   The RECORD_ROUTE Object (RRO) contains
        the hops traversed by the Path\n   message and applies to all the S2L sub-LSPs
        signaled in the Path\n   message.  A transit LSR MUST append its address in
        an incoming RRO\n   and propagate it downstream.  A branch LSR MUST form a
        new RRO for\n   each of the outgoing Path messages by copying the RRO from
        the\n   incoming Path message and appending its address.  Each such updated\n
        \  RRO MUST be formed using the rules in [RFC3209] (and updated by\n   [RFC3473]),
        as appropriate.\n   If an LSR is unable to support an S2L sub-LSP in a Path
        message (for\n   example, it is unable to route towards the destination using
        the\n   SERO), a PathErr message MUST be sent for the impacted S2L sub-LSP,\n
        \  and normal processing of the rest of the P2MP LSP SHOULD continue.\n   The
        default behavior is that the remainder of the LSP is not impacted\n   (that
        is, all other branches are allowed to set up) and the failed\n   branches
        are reported in PathErr messages in which the\n   Path_State_Removed flag
        MUST NOT be set.  However, the ingress LSR\n   may set an LSP Integrity flag
        to request that if there is a setup\n   failure on any branch, the entire
        LSP should fail to set up.  This is\n   described further in sections 5.2.4
        and 11.\n"
      title: 5.2.2.  Multiple S2L Sub-LSPs in One Path Message
    - contents:
      - "5.2.3.  Transit Fragmentation of Path State Information\n   In certain cases,
        a transit LSR may need to generate multiple Path\n   messages to signal state
        corresponding to a single received Path\n   message.  For instance, ERO expansion
        may result in an overflow of\n   the resultant Path message.  RSVP [RFC2205]
        disallows the use of IP\n   fragmentation, and thus IP fragmentation MUST
        be avoided in this\n   case.  In order to achieve this, the multiple Path
        messages generated\n   by the transit LSR are signaled with the Sub-Group
        Originator ID set\n   to the TE Router ID of the transit LSR and with a distinct
        Sub-Group\n   ID for each Path message.  Thus, each distinct Path message
        that is\n   generated by the transit LSR for the P2MP LSP carries a distinct\n
        \  <Sub-Group Originator ID, Sub-Group ID> tuple.\n   When multiple Path messages
        are used by an ingress or transit node,\n   each Path message SHOULD be identical
        with the exception of the S2L\n   sub-LSP related descriptor (e.g., SERO),
        message and hop information\n   (e.g., INTEGRITY, MESSAGE_ID, and RSVP_HOP),
        and the Sub-Group fields\n   of the SENDER_TEMPLATE objects.  Except when
        a make-before-break\n   operation is being performed (as specified in section
        14.1), the\n   tunnel sender address and LSP ID fields MUST be the same in
        each\n   message.  For transit nodes, they MUST be the same as the values
        in\n   the received Path message.\n   As described above, one case in which
        the Sub-Group Originator ID of\n   a received Path message is changed is that
        of fragmentation of a Path\n   message at a transit node.  Another case is
        when the Sub-Group\n   Originator ID of a received Path message may be changed
        in the\n   outgoing Path message and set to that of the LSR originating the
        Path\n   message based on a local policy.  For instance, an LSR may decide
        to\n   always change the Sub-Group Originator ID while performing ERO\n   expansion.
        \ The Sub-Group ID MUST not be changed if the Sub-Group\n   Originator ID
        is not changed.\n"
      title: 5.2.3.  Transit Fragmentation of Path State Information
    - contents:
      - "5.2.4.  Control of Branch Fate Sharing\n   An ingress LSR can control the
        behavior of an LSP if there is a\n   failure during LSP setup or after an
        LSP has been established.  The\n   default behavior is that only the branches
        downstream of the failure\n   are not established, but the ingress may request
        'LSP integrity' such\n   that any failure anywhere within the LSP tree causes
        the entire P2MP\n   LSP to fail.\n   The ingress LSP may request 'LSP integrity'
        by setting bit 3 of the\n   Attributes Flags TLV.  The bit is set if LSP integrity
        is required.\n   It is RECOMMENDED to use the LSP_REQUIRED_ATTRIBUTES object\n
        \  [RFC4420].\n   A branch LSR that supports the Attributes Flags TLV and
        recognizes\n   this bit MUST support LSP integrity or reject the LSP setup
        with a\n   PathErr message carrying the error \"Routing Error\"/\"Unsupported
        LSP\n   Integrity\".\n"
      title: 5.2.4.  Control of Branch Fate Sharing
    title: 5.2.  Path Message Processing
  - contents:
    - "5.3.  Grafting\n   The operation of adding egress LSR(s) to an existing P2MP
      LSP is\n   termed grafting.  This operation allows egress nodes to join a P2MP\n
      \  LSP at different points in time.\n   There are two methods to add S2L sub-LSPs
      to a P2MP LSP.  The first\n   is to add new S2L sub-LSPs to the P2MP LSP by
      adding them to an\n   existing Path message and refreshing the entire Path message.
      \ Path\n   message processing described in section 4 results in adding these
      S2L\n   sub-LSPs to the P2MP LSP.  Note that as a result of adding one or\n
      \  more S2L sub-LSPs to a Path message, the ERO compression encoding may\n   have
      to be recomputed.\n   The second is to use incremental updates described in
      section 10.1.\n   The egress LSRs can be added by signaling only the impacted
      S2L sub-\n   LSPs in a new Path message.  Hence, other S2L sub-LSPs do not have
      to\n   be re-signaled.\n"
    title: 5.3.  Grafting
  title: 5.  Path Message
- contents:
  - '6.  Resv Message

    '
  - contents:
    - "6.1.  Resv Message Format\n   The Resv message follows the [RFC3209] and [RFC3473]
      format:\n   <Resv Message> ::=    <Common Header> [ <INTEGRITY> ]\n                         [
      [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID>
      ]\n                         <SESSION> <RSVP_HOP>\n                         <TIME_VALUES>\n
      \                        [ <RESV_CONFIRM> ]  [ <SCOPE> ]\n                         [
      <NOTIFY_REQUEST> ]\n                         [ <ADMIN_STATUS> ]\n                         [
      <POLICY_DATA> ... ]\n                         <STYLE> <flow descriptor list>\n
      \  <flow descriptor list> ::= <FF flow descriptor list>\n                              |
      <SE flow descriptor>\n   <FF flow descriptor list> ::= <FF flow descriptor>\n
      \                                | <FF flow descriptor list>\n                                 <FF
      flow descriptor>\n   <SE flow descriptor> ::= <FLOWSPEC> <SE filter spec list>\n
      \  <SE filter spec list> ::= <SE filter spec>\n                            |
      <SE filter spec list> <SE filter spec>\n   The FF flow descriptor and SE filter
      spec are modified as follows to\n   identify the S2L sub-LSPs that they correspond
      to:\n   <FF flow descriptor> ::= [ <FLOWSPEC> ] <FILTER_SPEC> <LABEL>\n                            [
      <RECORD_ROUTE> ]\n                            [ <S2L sub-LSP flow descriptor
      list> ]\n   <SE filter spec> ::=     <FILTER_SPEC> <LABEL> [ <RECORD_ROUTE>
      ]\n                            [ <S2L sub-LSP flow descriptor list> ]\n   <S2L
      sub-LSP flow descriptor list> ::=\n                               <S2L sub-LSP
      flow descriptor>\n                               [ <S2L sub-LSP flow descriptor
      list> ]\n   <S2L sub-LSP flow descriptor> ::= <S2L_SUB_LSP>\n                                     [
      <P2MP_SECONDARY_RECORD_ROUTE> ]\n   FILTER_SPEC is defined in section 19.4.\n
      \  The S2L sub-LSP flow descriptor has the same format as S2L sub-LSP\n   descriptor
      in section 4.1 with the difference that a\n   P2MP_SECONDARY_RECORD_ROUTE object
      is used in place of a P2MP\n   SECONDARY_EXPLICIT_ROUTE object.  The P2MP_SECONDARY_RECORD_ROUTE\n
      \  objects follow the same compression mechanism as the P2MP\n   SECONDARY_EXPLICIT_ROUTE
      objects.  Note that a Resv message can\n   signal multiple S2L sub-LSPs that
      may belong to the same FILTER_SPEC\n   object or different FILTER_SPEC objects.
      \ The same label SHOULD be\n   allocated if the <Sender Address, LSP-ID> fields
      of the FILTER_SPEC\n   object are the same.\n   However different labels MUST
      be allocated if the <Sender Address,\n   LSP-ID> of the FILTER_SPEC object is
      different, as that implies that\n   the FILTER_SPEC refers to a different P2MP
      LSP.\n"
    title: 6.1.  Resv Message Format
  - contents:
    - "6.2.  Resv Message Processing\n   The egress LSR MUST follow normal RSVP procedures
      while originating a\n   Resv message.  The format of Resv messages is as defined
      in section\n   6.1.  As usual, the Resv message carries the label allocated
      by the\n   egress LSR.\n   A node upstream of the egress node MUST allocate
      its own label and\n   pass it upstream in the Resv message.  The node MAY combine
      multiple\n   flow descriptors, from different Resv messages received from\n
      \  downstream, in one Resv message sent upstream.  A Resv message MUST\n   NOT
      be sent upstream until at least one Resv message has been\n   received from
      a downstream neighbor.  When the integrity bit is set\n   in the LSP_REQUIRED_ATTRIBUTE
      object, Resv message MUST NOT be sent\n   upstream until all Resv messages have
      been received from the\n   downstream neighbors.\n   Each Fixed-Filter (FF)
      flow descriptor or Shared-Explicit (SE) filter\n   spec sent upstream in a Resv
      message includes an S2L sub-LSP\n   descriptor list.  Each such FF flow descriptor
      or SE filter spec for\n   the same P2MP LSP (whether on one or multiple Resv
      messages) on the\n   same Resv MUST be allocated the same label, and FF flow
      descriptors\n   or SE filter specs SHOULD use the same label across multiple
      Resv\n   messages.\n   The node that sends the Resv message, for a P2MP LSP,
      upstream MUST\n   associate the label assigned by this node with all the labels\n
      \  received from downstream Resv messages, for that P2MP LSP.  Note that\n   a
      transit node may become a replication point in the future when a\n   branch
      is attached to it.  Hence, this results in the setup of a P2MP\n   LSP from
      the ingress LSR to the egress LSRs.\n   The ingress LSR may need to understand
      when all desired egresses have\n   been reached.  This is achieved using S2L_SUB_LSP
      objects.\n   Each branch node MAY forward a single Resv message upstream for
      each\n   received Resv message from a downstream receiver.  Note that there\n
      \  may be a large number of Resv messages at and close to the ingress\n   LSR
      for an LSP with many receivers.  A branch LSR SHOULD combine Resv\n   state
      from multiple receivers into a single Resv message to be sent\n   upstream (see
      section 6.2.1).  However, note that this may result in\n   overflowing the Resv
      message, particularly as the number of receivers\n   downstream of any branch
      LSR increases as the LSR is closer to the\n   ingress LSR.  Thus, a branch LSR
      MAY choose to send more than one\n   Resv message upstream and partition the
      Resv state between the\n   messages.\n   When a transit node sets the Sub-Group
      Originator field in a Path\n   message, it MUST replace the Sub-Group fields
      received in the\n   FILTER_SPEC objects of any associated Resv messages with
      the value\n   that it originally received in the Sub-Group fields of the Path\n
      \  message from the upstream neighbor.\n   ResvErr message generation is unmodified.
      \ Nodes propagating a\n   received ResvErr message MUST use the Sub-Group field
      values carried\n   in the corresponding Resv message.\n"
    - contents:
      - "6.2.1.  Resv Message Throttling\n   A branch node may have to send a revised
        Resv message upstream\n   whenever there is a change in a Resv message for
        an S2L sub-LSP\n   received from one of the downstream neighbors.  This can
        result in\n   excessive Resv messages sent upstream, particularly when the
        S2L sub-\n   LSPs are first established.  In order to mitigate this situation,\n
        \  branch nodes can limit their transmission of Resv messages.\n   Specifically,
        in the case where the only change being sent in a Resv\n   message is in one
        or more P2MP_SECONDARY_RECORD_ROUTE objects\n   (SRROs), the branch node SHOULD
        transmit the Resv message only after\n   a delay time has passed since the
        transmission of the previous Resv\n   message for the same session.  This
        delayed Resv message SHOULD\n   include SRROs for all branches.  A suggested
        value for the delay time\n   is thirty seconds, and delay times SHOULD generally
        be longer than 1\n   second.  Specific mechanisms for Resv message throttling
        and delay\n   timer settings are implementation dependent and are outside
        the scope\n   of this document.\n"
      title: 6.2.1.  Resv Message Throttling
    title: 6.2.  Resv Message Processing
  - contents:
    - '6.3.  Route Recording

      '
    - contents:
      - "6.3.1.  RRO Processing\n   A Resv message for a P2P LSP contains a recorded
        route if the ingress\n   LSR requested route recording by including an RRO
        in the original\n   Path message.  The same rule is used during signaling
        of P2MP LSPs.\n   That is, inclusion of an RRO in the Path message used to
        signal one\n   or more S2L sub-LSPs triggers the inclusion of a recorded route
        for\n   each sub-LSP in the Resv message.\n   The recorded route of the first
        S2L sub-LSP is encoded in the RRO.\n   Additional recorded routes for the
        subsequent S2L sub-LSPs are\n   encoded in P2MP_SECONDARY_RECORD_ROUTE objects
        (SRROs).  Their format\n   is specified in section 19.5.  Each S2L_SUB_LSP
        object in a Resv is\n   associated with an RRO or SRRO.  The first S2L_SUB_LSP
        object (for\n   the first S2L sub-LSP) is associated with the RRO.  Subsequent\n
        \  S2L_SUB_LSP objects (for subsequent S2L sub-LSPs) are each followed\n   by
        an SRRO that contains the recorded route for that S2L sub-LSP from\n   the
        leaf to a branch.  The ingress node can then use the RRO and\n   SRROs to
        determine the end-to-end path for each S2L sub-LSP.\n"
      title: 6.3.1.  RRO Processing
    title: 6.3.  Route Recording
  - contents:
    - "6.4.  Reservation Style\n   Considerations about the reservation style in a
      Resv message apply as\n   described in [RFC3209].  The reservation style in
      the Resv messages\n   can be either FF or SE.  All P2MP LSPs that belong to
      the same P2MP\n   Tunnel MUST be signaled with the same reservation style.\n
      \  Irrespective of whether the reservation style is FF or SE, the S2L\n   sub-LSPs
      that belong to the same P2MP LSP SHOULD share labels where\n   they share hops.
      \ If the S2L sub-LSPs that belong to the same P2MP\n   LSP share labels then
      they MUST share resources.  If the reservation\n   style is FF, then S2L sub-LSPs
      that belong to different P2MP LSPs\n   MUST NOT share resources or labels.  If
      the reservation style is SE,\n   then S2L sub-LSPs that belong to different
      P2MP LSPs and the same\n   P2MP tunnel SHOULD share resources where they share
      hops, but they\n   MUST not share labels in packet environments.\n"
    title: 6.4.  Reservation Style
  title: 6.  Resv Message
- contents:
  - '7.  PathTear Message

    '
  - contents:
    - "7.1.  PathTear Message Format\n   The format of the PathTear message is as
      follows:\n   <PathTear Message> ::= <Common Header> [ <INTEGRITY> ]\n                           [
      [ <MESSAGE_ID_ACK> |\n                               <MESSAGE_ID_NACK> ... ]\n
      \                          [ <MESSAGE_ID> ]\n                           <SESSION>
      <RSVP_HOP>\n                           [ <sender descriptor> ]\n                           [
      <S2L sub-LSP descriptor list> ]\n   <S2L sub-LSP descriptor list> ::= <S2L_SUB_LSP>\n
      \                                    [ <S2L sub-LSP descriptor list> ]\n   The
      definition of <sender descriptor> is not changed by this\n   document.\n"
    title: 7.1.  PathTear Message Format
  - contents:
    - "7.2.  Pruning\n   The operation of removing egress LSR(s) from an existing
      P2MP LSP is\n   termed as pruning.  This operation allows egress nodes to be
      removed\n   from a P2MP LSP at different points in time.  This section describes\n
      \  the mechanisms to perform pruning.\n"
    - contents:
      - "7.2.1.  Implicit S2L Sub-LSP Teardown\n   Implicit teardown uses standard
        RSVP message processing.  Per\n   standard RSVP processing, an S2L sub-LSP
        may be removed from a P2MP\n   TE LSP by sending a modified message for the
        Path or Resv message\n   that previously advertised the S2L sub-LSP.  This
        message MUST list\n   all S2L sub-LSPs that are not being removed.  When using
        this\n   approach, a node processing a message that removes an S2L sub-LSP\n
        \  from a P2MP TE LSP MUST ensure that the S2L sub-LSP is not included\n   in
        any other Path state associated with session before interrupting\n   the data
        path to that egress.  All other message processing remains\n   unchanged.\n
        \  When implicit teardown is used to delete one or more S2L sub-LSPs, by\n
        \  modifying a Path message, a transit LSR may have to generate a\n   PathTear
        message downstream to delete one or more of these S2L sub-\n   LSPs.  This
        can happen if as a result of the implicit deletion of S2L\n   sub-LSP(s) there
        are no remaining S2L sub-LSPs to send in the\n   corresponding Path message
        downstream.\n"
      title: 7.2.1.  Implicit S2L Sub-LSP Teardown
    - contents:
      - "7.2.2.  Explicit S2L Sub-LSP Teardown\n   Explicit S2L Sub-LSP teardown relies
        on generating a PathTear message\n   for the corresponding Path message.  The
        PathTear message is signaled\n   with the SESSION and SENDER_TEMPLATE objects
        corresponding to the\n   P2MP LSP and the <Sub-Group Originator ID, Sub-Group
        ID> tuple\n   corresponding to the Path message.  This approach SHOULD be
        used when\n   all the egresses signaled by a Path message need to be removed
        from\n   the P2MP LSP.  Other S2L sub-LSPs, from other sub-groups signaled\n
        \  using other Path messages, are not affected by the PathTear.\n   A transit
        LSR that propagates the PathTear message downstream MUST\n   ensure that it
        sets the <Sub-Group Originator ID, Sub-Group ID> tuple\n   in the PathTear
        message to the values used in the Path message that\n   was used to set up
        the S2L sub-LSPs being torn down.  The transit LSR\n   may need to generate
        multiple PathTear messages for an incoming\n   PathTear message if it had
        performed transit fragmentation for the\n   corresponding incoming Path message.\n
        \  When a P2MP LSP is removed by the ingress, a PathTear message MUST be\n
        \  generated for each Path message used to signal the P2MP LSP.\n"
      title: 7.2.2.  Explicit S2L Sub-LSP Teardown
    title: 7.2.  Pruning
  title: 7.  PathTear Message
- contents:
  - '8.  Notify and ResvConf Messages

    '
  - contents:
    - "8.1.  Notify Messages\n   The Notify Request object and Notify message are
      described in\n   [RFC3473].  Both object and message SHALL be supported for
      delivery\n   of upstream and downstream notification.  Processing not detailed
      in\n   this section MUST comply to [RFC3473].\n   1.  Upstream Notification\n
      \  If a transit LSR sets the Sub-Group Originator ID in the\n   SENDER_TEMPLATE
      object of a Path message to its own address, and the\n   incoming Path message
      carries a Notify Request object, then this LSR\n   MUST change the Notify node
      address in the Notify Request object to\n   its own address in the Path message
      that it sends.\n   If this LSR subsequently receives a corresponding Notify
      message from\n   a downstream LSR, then it MUST:\n      - send a Notify message
      upstream toward the Notify node address\n        that the LSR received in the
      Path message.\n      - process the Sub-Group fields of the SENDER_TEMPLATE object
      on\n        the received Notify message, and modify their values, in the\n        Notify
      message that is forwarded, to match the Sub-Group field\n        values in the
      original Path message received from upstream.\n   The receiver of an (upstream)
      Notify message MUST identify the state\n   referenced in this message based
      on the SESSION and SENDER_TEMPLATE.\n   2.  Downstream Notification\n   A transit
      LSR sets the Sub-Group Originator ID in the FILTER_SPEC\n   object(s) of a Resv
      message to the value that was received in the\n   corresponding Path message.
      \ If the incoming Resv message carries a\n   Notify Request object, then:\n
      \     - If there is at least another incoming Resv message that carries\n        a
      Notify Request object, and the LSR merges these Resv messages\n        into
      a single Resv message that is sent upstream, the LSR MUST\n        set the Notify
      node address in the Notify Request object to its\n        Router ID.\n      -
      Else if the LSR sets the Sub-Group Originator ID (in the\n        outgoing Path
      message that corresponds to the received Resv\n        message) to its own address,
      the LSR MUST set the Notify node\n        address in the Notify Request object
      to its Router ID.\n      - Else the LSR MUST propagate the Notify Request object
      unchanged,\n        in the Resv message that it sends upstream.\n   If this
      LSR subsequently receives a corresponding Notify message from\n   an upstream
      LSR, then it MUST:\n      - process the Sub-Group fields of the FILTER_SPEC
      object in the\n        received Notify message, and modify their values, in
      the Notify\n        message that is forwarded, to match the Sub-Group field
      values\n        in the original Path message sent downstream by this LSR.\n
      \     - send a Notify message downstream toward the Notify node address\n        that
      the LSR received in the Resv message.\n   The receiver of a (downstream) Notify
      message MUST identify the state\n   referenced in the message based on the SESSION
      and FILTER_SPEC\n   objects.\n   The consequence of these rules for a P2MP LSP
      is that an upstream\n   Notify message generated on a branch will result in
      a Notify being\n   delivered to the upstream Notify node address.  The receiver
      of the\n   Notify message MUST NOT assume that the Notify message applies to
      all\n   downstream egresses, but MUST examine the information in the message\n
      \  to determine to which egresses the message applies.\n   Downstream Notify
      messages MUST be replicated at branch LSRs\n   according to the Notify Request
      objects received on Resv messages.\n   Some downstream branches might not request
      Notify messages, but all\n   that have requested Notify messages MUST receive
      them.\n"
    title: 8.1.  Notify Messages
  - contents:
    - "8.2.  ResvConf Messages\n   ResvConf messages are described in [RFC2205].  ResvConf
      processing in\n   [RFC3473] and [RFC3209] is taken directly from [RFC2205].
      \ An egress\n   LSR MAY include a RESV_CONFIRM object that contains the egress
      LSR's\n   address.  The object and message SHALL be supported for the\n   confirmation
      of receipt of the Resv message in P2MP TE LSPs.\n   Processing not detailed
      in this section MUST comply to [RFC2205].\n   A transit LSR sets the Sub-Group
      Originator ID in the FILTER_SPEC\n   object(s) of a Resv message to the value
      that was received in the\n   corresponding Path message.  If any of the incoming
      Resv messages\n   corresponding to a single Path message carry a RESV_CONFIRM
      object,\n   then the LSR MUST include a RESV_CONFIRM object in the corresponding\n
      \  Resv message that it sends upstream.  If the Sub-Group Originator ID\n   is
      its own address, then it MUST set the receiver address in the\n   RESV_CONFIRM
      object to this address, else it MUST propagate the\n   object unchanged.\n   A
      transit LSR sets the Sub-Group Originator ID in the FILTER_SPEC\n   object(s)
      of a Resv message to the value that was received in the\n   corresponding Path
      message.  If an incoming Resv message\n   corresponding to a single Path message
      carries a RESV_CONFIRM object,\n   then the LSR MUST include a RESV_CONFIRM
      object in the corresponding\n   Resv message that it sends upstream and:\n      -
      If there is at least another incoming Resv message that carries\n        a RESV_CONFIRM
      object, and the LSR merges these Resv messages\n        into a single Resv message
      that is sent upstream, the LSR MUST\n        set the receiver address in the
      RESV_CONFIRM object to its\n        Router ID.\n      - If the LSR sets the
      Sub-Group Originator ID (in the outgoing\n        Path message that corresponds
      to the received Resv message) to\n        its own address, the LSR MUST set
      the receiver address in the\n        RESV_CONFIRM object to its Router ID.\n
      \     - Else the LSR MUST propagate the RESV_CONFIRM object unchanged,\n        in
      the Resv message that it sends upstream.\n   If this LSR subsequently receives
      a corresponding ResvConf message\n   from an upstream LSR, then it MUST:\n      -
      process the Sub-Group fields of the FILTER_SPEC object in the\n        received
      ResvConf message, and modify their values, in the\n        ResvConf message
      that is forwarded, to match the Sub-Group field\n        values in the original
      Path message sent downstream by this LSR.\n      - send a ResvConf message downstream
      toward the receiver address\n        that the LSR received in the RESV_CONFIRM
      object in the Resv\n        message.\n   The receiver of a ResvConf message
      MUST identify the state referenced\n   in this message based on the SESSION
      and FILTER_SPEC objects.\n   The consequence of these rules for a P2MP LSP is
      that a ResvConf\n   message generated at the ingress will result in a ResvConf
      message\n   being delivered to the branch and then to the receiver address in
      the\n   original RESV_CONFIRM object.  The receiver of a ResvConf message\n
      \  MUST NOT assume that the ResvConf message should be sent to all\n   downstream
      egresses, but it MUST replicate the message according to\n   the RESV_CONFIRM
      objects received in Resv messages.  Some downstream\n   branches might not request
      ResvConf messages, and ResvConf messages\n   SHOULD NOT be sent on these branches.
      \ All downstream branches that\n   requested ResvConf messages MUST be sent
      such a message.\n"
    title: 8.2.  ResvConf Messages
  title: 8.  Notify and ResvConf Messages
- contents:
  - "9.  Refresh Reduction\n   The refresh reduction procedures described in [RFC2961]
    are equally\n   applicable to P2MP LSPs described in this document.  Refresh\n
    \  reduction applies to individual messages and the state they\n   install/maintain,
    and that continues to be the case for P2MP LSPs.\n"
  title: 9.  Refresh Reduction
- contents:
  - "10.  State Management\n   State signaled by a P2MP Path message is identified
    by a local\n   implementation using the <P2MP ID, Tunnel ID, Extended Tunnel ID>\n
    \  tuple as part of the SESSION object and the <Tunnel Sender Address,\n   LSP
    ID, Sub-Group Originator ID, Sub-Group ID> tuple as part of the\n   SENDER_TEMPLATE
    object.\n   Additional information signaled in the Path/Resv message is part of\n
    \  the state created by a local implementation.  This includes PHOP/NHOP\n   and
    SENDER_TSPEC/FILTER_SPEC objects.\n"
  - contents:
    - "10.1.  Incremental State Update\n   RSVP (as defined in [RFC2205] and as extended
      by RSVP-TE [RFC3209]\n   and GMPLS [RFC3473]) uses the same basic approach to
      state\n   communication and synchronization -- namely, full state is sent in\n
      \  each state advertisement message.  Per [RFC2205], Path and Resv\n   messages
      are idempotent.  Also, [RFC2961] categorizes RSVP messages\n   into two types
      (trigger and refresh messages) and improves RSVP\n   message handling and scaling
      of state refreshes, but does not modify\n   the full state advertisement nature
      of Path and Resv messages.  The\n   full state advertisement nature of Path
      and Resv messages has many\n   benefits, but also has some drawbacks.  One notable
      drawback is when\n   an incremental modification is being made to a previously
      advertised\n   state.  In this case, there is the message overhead of sending
      the\n   full state and the cost of processing it.  It is desirable to\n   overcome
      this drawback and add/delete S2L sub-LSPs to/from a P2MP LSP\n   by incrementally
      updating the existing state.\n   It is possible to use the procedures described
      in this document to\n   allow S2L sub-LSPs to be incrementally added to or deleted
      from the\n   P2MP LSP by allowing a Path or a PathTear message to incrementally\n
      \  change the existing P2MP LSP Path state.\n   As described in section 5.2,
      multiple Path messages can be used to\n   signal a P2MP LSP.  The Path messages
      are distinguished by different\n   <Sub-Group Originator ID, Sub-Group ID> tuples
      in the SENDER_TEMPLATE\n   object.  In order to perform incremental S2L sub-LSP
      state addition,\n   a separate Path message with a new Sub-Group ID is used
      to add the\n   new S2L sub-LSPs, by the ingress LSR.  The Sub-Group Originator
      ID\n   MUST be set to the TE Router ID [RFC3477] of the node that sets the\n
      \  Sub-Group ID.\n   This maintains the idempotent nature of RSVP Path messages,
      avoids\n   keeping track of individual S2L sub-LSP state expiration, and\n   provides
      the ability to perform incremental P2MP LSP state updates.\n"
    title: 10.1.  Incremental State Update
  - contents:
    - "10.2.  Combining Multiple Path Messages\n   There is a tradeoff between the
      number of Path messages used by the\n   ingress to maintain the P2MP LSP and
      the processing imposed by full\n   state messages when adding S2L sub-LSPs to
      an existing Path message.\n   It is possible to combine S2L sub-LSPs previously
      advertised in\n   different Path messages in a single Path message in order
      to reduce\n   the number of Path messages needed to maintain the P2MP LSP.  This\n
      \  can also be done by a transit node that performed fragmentation and\n   that
      at a later point is able to combine multiple Path messages that\n   it generated
      into a single Path message.  This may happen when one or\n   more S2L sub-LSPs
      are pruned from the existing Path states.\n   The new Path message is signaled
      by the node that is combining\n   multiple Path messages with all the S2L sub-LSPs
      that are being\n   combined in a single Path message.  This Path message MAY
      contain new\n   Sub-Group ID field values.  When a new Path and Resv message
      that is\n   signaled for an existing S2L sub-LSP is received by a transit LSR,\n
      \  state including the new instance of the S2L sub-LSP is created.\n   The S2L
      sub-LSP SHOULD continue to be advertised in both the old and\n   new Path messages
      until a Resv message listing the S2L sub-LSP and\n   corresponding to the new
      Path message is received by the combining\n   node.  Hence, until this point,
      state for the S2L sub-LSP SHOULD be\n   maintained as part of the Path state
      for both the old and the new\n   Path message (see section 3.1.3 of [RFC2205]).
      \ At that point the S2L\n   sub-LSP SHOULD be deleted from the old Path state
      using the\n   procedures of section 7.\n   A Path message with a Sub-Group_ID(n)
      may signal a set of S2L sub-\n   LSPs that belong partially or entirely to an
      already existing Sub-\n   Group_ID(i), or a strictly non-overlapping new set
      of S2L sub-LSPs.\n   A newly received Path message that matches SESSION object
      and Sender\n   Tunnel Address, LSP ID, Sub-Group Originator ID> with existing
      Path\n   state carrying the same or different Sub-Group_ID, referred to Sub-\n
      \  Group_ID(n) is processed as follows:\n   1) If Sub-Group_ID(i) = Sub-Group_ID(n),
      then S2L Sub-LSPs that are\n      in both Sub-Group_ID(i) and Sub-Group_ID(n)
      are refreshed.  New\n      S2L Sub-LSPs are added to Sub-Group_ID(i) Path state
      and S2L Sub-\n      LSPs that are in Sub-Group_ID(i) but not in Sub-Group_ID(n)
      are\n      deleted from the Sub-Group_ID(i) Path state.\n   2) If Sub-Group_ID(i)
      != Sub-Group_ID(n), then a new Sub-Group_ID(n)\n      Path state is created
      for S2L Sub-LSPs signaled by Sub-\n      Group_ID(n).  S2L Sub-LSPs in existing
      Sub-Group_IDs(i) Path state\n      (that are or are not in the newly received
      Path message Sub-\n      Group_ID(n)) are left unmodified (see above).\n"
    title: 10.2.  Combining Multiple Path Messages
  title: 10.  State Management
- contents:
  - "11.  Error Processing\n   PathErr and ResvErr messages are processed as per RSVP-TE
    procedures.\n   Note that an LSR, on receiving a PathErr/ResvErr message for a\n
    \  particular S2L sub-LSP, changes the state only for that S2L sub-LSP.\n   Hence
    other S2L sub-LSPs are not impacted.  If the ingress node\n   requests 'LSP integrity',
    an error reported on a branch of a P2MP TE\n   LSP for a particular S2L sub-LSP
    may change the state of any other\n   S2L sub-LSP of the same P2MP TE LSP.  This
    is explained further in\n   section 11.3.\n"
  - contents:
    - "11.1.  PathErr Messages\n   The PathErr message will include one or more S2L_SUB_LSP
      objects.\n   The resulting modified format for a PathErr message is:\n   <PathErr
      Message> ::=    <Common Header> [ <INTEGRITY> ]\n                             [
      [<MESSAGE_ID_ACK> |\n                                <MESSAGE_ID_NACK>] ...
      ]\n                             [ <MESSAGE_ID> ]\n                             <SESSION>
      <ERROR_SPEC>\n                             [ <ACCEPTABLE_LABEL_SET> ... ]\n
      \                            [ <POLICY_DATA> ... ]\n                             <sender
      descriptor>\n                             [ <S2L sub-LSP descriptor list> ]\n
      \  PathErr message generation is unmodified, but nodes that set the\n   Sub-Group
      Originator field and propagate a received PathErr message\n   upstream MUST
      replace the Sub-Group fields received in the PathErr\n   message with the value
      that was received in the Sub-Group fields of\n   the Path message from the upstream
      neighbor.  Note the receiver of a\n   PathErr message is able to identify the
      errored outgoing Path\n   message, and outgoing interface, based on the Sub-Group
      fields\n   received in the PathErr message.  The S2L sub-LSP descriptor list
      is\n   defined in section 5.1.\n"
    title: 11.1.  PathErr Messages
  - contents:
    - "11.2.  ResvErr Messages\n   The ResvErr message will include one or more S2L_SUB_LSP
      objects.\n   The resulting modified format for a ResvErr Message is:\n   <ResvErr
      Message> ::=    <Common Header> [ <INTEGRITY> ]\n                             [
      [<MESSAGE_ID_ACK> |\n                                <MESSAGE_ID_NACK>] ...
      ]\n                             [ <MESSAGE_ID> ]\n                             <SESSION>
      <RSVP_HOP>\n                             <ERROR_SPEC> [ <SCOPE> ]\n                             [
      <ACCEPTABLE_LABEL_SET> ... ]\n                             [ <POLICY_DATA> ...
      ]\n                             <STYLE> <flow descriptor list>\n   ResvErr message
      generation is unmodified, but nodes that set the\n   Sub-Group Originator field
      and propagate a received ResvErr message\n   downstream MUST replace the Sub-Group
      fields received in the ResvErr\n   message with the value that was set in the
      Sub-Group fields of the\n   Path message sent to the downstream neighbor.  Note
      the receiver of a\n   ResvErr message is able to identify the errored outgoing
      Resv\n   message, and outgoing interface, based on the Sub-Group fields\n   received
      in the ResvErr message.  The flow descriptor list is defined\n   in section
      6.1.\n"
    title: 11.2.  ResvErr Messages
  - contents:
    - "11.3.  Branch Failure Handling\n   During setup and during normal operation,
      PathErr messages may be\n   received at a branch node.  In all cases, a received
      PathErr message\n   is first processed per standard processing rules.  That
      is, the\n   PathErr message is sent hop-by-hop to the ingress/branch LSR for
      that\n   Path message.  Intermediate nodes until this ingress/branch LSR MAY\n
      \  inspect this message but take no action upon it.  The behavior of a\n   branch
      LSR that generates a PathErr message is under the control of\n   the ingress
      LSR.\n   The default behavior is that the PathErr message does not have the\n
      \  Path_State_Removed flag set.  However, if the ingress LSR has set the\n   LSP
      integrity flag on the Path message (see LSP_REQUIRED_ATTRIBUTEs\n   object in
      section 5.2.4), and if the Path_State_Removed flag is\n   supported, the LSR
      generating a PathErr to report the failure of a\n   branch of the P2MP LSP SHOULD
      set the Path_State_Removed flag.\n   A branch LSR that receives a PathErr message
      during LSP setup with\n   the Path_State_Removed flag set MUST act according
      to the wishes of\n   the ingress LSR.  The default behavior is that the branch
      LSR clears\n   the Path_State_Removed flag on the PathErr and sends it further\n
      \  upstream.  It does not tear any other branches of the LSP.  However,\n   if
      the LSP integrity flag is set on the Path message, the branch LSR\n   MUST send
      PathTear on all other downstream branches and send the\n   PathErr message upstream
      with the Path_State_Removed flag set.\n   A branch LSR that receives a PathErr
      message with the\n   Path_State_Removed flag clear MUST act according to the
      wishes of the\n   ingress LSR.  The default behavior is that the branch LSR
      forwards\n   the PathErr upstream and takes no further action.  However, if
      the\n   LSP integrity flag is set on the Path message, the branch LSR MUST\n
      \  send PathTear on all downstream branches and send the PathErr\n   upstream
      with the Path_State_Removed flag set (per [RFC3473]).\n   In all cases, the
      PathErr message forwarded by a branch LSR MUST\n   contain the S2L sub-LSP identification
      and explicit routes of all\n   branches that are reported by received PathErr
      messages and all\n   branches that are explicitly torn by the branch LSR.\n"
    title: 11.3.  Branch Failure Handling
  title: 11.  Error Processing
- contents:
  - "12.  Admin Status Change\n   A branch node that receives an ADMIN_STATUS object
    processes it\n   normally and also relays the ADMIN_STATUS object in a Path on
    every\n   branch.  All Path messages may be concurrently sent to the downstream\n
    \  neighbors.\n   Downstream nodes process the change in the ADMIN_STATUS object
    per\n   [RFC3473], including generation of Resv messages.  When the last\n   received
    upstream ADMIN_STATUS object had the R bit set, branch nodes\n   wait for a Resv
    message with a matching ADMIN_STATUS object to be\n   received (or a corresponding
    PathErr or ResvTear message) on all\n   branches before relaying a corresponding
    Resv message upstream.\n"
  title: 12.  Admin Status Change
- contents:
  - "13.  Label Allocation on LANs with Multiple Downstream Nodes\n   A branch LSR
    of a P2MP LSP on an Ethernet LAN segment SHOULD send one\n   copy of the data
    traffic per downstream LSR connected on that LAN for\n   that P2MP LSP.  Procedures
    for preventing MPLS labeled traffic\n   replication in such a case is beyond the
    scope of this document.\n"
  title: 13.  Label Allocation on LANs with Multiple Downstream Nodes
- contents:
  - "14.  P2MP LSP and Sub-LSP Re-Optimization\n   It is possible to change the path
    used by P2MP LSPs to reach the\n   destinations of the P2MP tunnel.  There are
    two methods that can be\n   used to accomplish this.  The first is make-before-break,
    defined in\n   [RFC3209], and the second uses the sub-groups defined above.\n"
  - contents:
    - "14.1.  Make-before-Break\n   In this case, all the S2L sub-LSPs are signaled
      with a different LSP\n   ID by the ingress LSR and follow the make-before-break
      procedure\n   defined in [RFC3209].  Thus, a new P2MP LSP is established.  Each
      S2L\n   sub-LSP is signaled with a different LSP ID, corresponding to the new\n
      \  P2MP LSP.  After moving traffic to the new P2MP LSP, the ingress can\n   tear
      down the old P2MP LSP.  This procedure can be used to re-\n   optimize the path
      of the entire P2MP LSP or the paths to a subset of\n   the destinations of the
      P2MP LSP.  When modifying just a portion of\n   the P2MP LSP, this approach
      requires the entire P2MP LSP to be re-\n   signaled.\n"
    title: 14.1.  Make-before-Break
  - contents:
    - "14.2.  Sub-Group-Based Re-Optimization\n   Any node may initiate re-optimization
      of a set of S2L sub-LSPs by\n   using incremental state update and then, optionally,
      combining\n   multiple path messages.\n   To alter the path taken by a particular
      set of S2L sub-LSPs, the node\n   initiating the path change initiates one or
      more separate Path\n   messages for the same P2MP LSP, each with a new sub-Group
      ID.  The\n   generation of these Path messages, each with one or more S2L sub-\n
      \  LSPs, follows procedures in section 5.2.  As is the case in section\n   10.2,
      a particular egress continues to be advertised in both the old\n   and new Path
      messages until a Resv message listing the egress and\n   corresponding to the
      new Path message is received by the re-\n   optimizing node.  At that point,
      the egress SHOULD be deleted from\n   the old Path state using the procedures
      of section 7.  Sub-tree re-\n   optimization is then completed.\n   Sub-Group-based
      re-optimization may result in transient data\n   duplication as the new Path
      messages for a set of S2L sub-LSPs may\n   transit one or more nodes with the
      old Path state for the same set of\n   S2L sub-LSPs.\n   As is always the case,
      a node may choose to combine multiple path\n   messages as described in section
      10.2.\n"
    title: 14.2.  Sub-Group-Based Re-Optimization
  title: 14.  P2MP LSP and Sub-LSP Re-Optimization
- contents:
  - "15.  Fast Reroute\n   [RFC4090] extensions can be used to perform fast reroute
    for the\n   mechanism described in this document when applied within packet\n
    \  networks.  GMPLS introduces other protection techniques that can be\n   applied
    to packet and non-packet environments [RFC4873], but which\n   are not discussed
    further in this document.  This section only\n   applies to LSRs that support
    [RFC4090].\n   This section uses terminology defined in [RFC4090], and fast reroute\n
    \  procedures defined in [RFC4090] MUST be followed unless specified\n   below.
    \ The head-end and transit LSRs MUST follow the\n   SESSION_ATTRIBUTE and FAST_REROUTE
    object processing as specified in\n   [RFC4090] for each Path message and S2L
    sub-LSP of a P2MP LSP.  Each\n   S2L sub-LSP of a P2MP LSP MUST have the same
    protection\n   characteristics.  The RRO processing MUST apply to SRRO as well\n
    \  unless modified below.\n   The sections that follow describe how fast reroute
    may be applied to\n   P2MP MPLS TE LSPs in all of the principal operational scenarios.\n
    \  This document does not describe the detailed processing steps for\n   every
    imaginable usage case, and they may be described in future\n   documents, as needed.\n"
  - contents:
    - "15.1.  Facility Backup\n   Facility backup can be used for link or node protection
      of LSRs on\n   the path of a P2MP LSP.  The downstream labels MUST be learned
      by the\n   Point of Local Repair (PLR), as specified in [RFC4090], from the\n
      \  label corresponding to the S2L sub-LSP in the RESV message.\n   Processing
      of SEROs signaled in a backup tunnel MUST follow backup\n   tunnel ERO processing
      described in [RFC4090].\n"
    - contents:
      - "15.1.1.  Link Protection\n   If link protection is desired, a bypass tunnel
        MUST be used to\n   protect the link between the PLR and next-hop.  Thus all
        S2L sub-LSPs\n   that use the link SHOULD be protected in the event of link
        failure.\n   Note that all such S2L sub-LSPs belonging to a particular instance
        of\n   a P2MP tunnel SHOULD share the same outgoing label on the link\n   between
        the PLR and the next-hop as per section 5.2.1.  This is the\n   P2MP LSP label
        on the link.  Label stacking is used to send data for\n   each P2MP LSP into
        the bypass tunnel.  The inner label is the P2MP\n   LSP label allocated by
        the next-hop.\n   During failure, Path messages for each S2L sub-LSP that
        is affected,\n   MUST be sent to the Merge Point (MP) by the PLR.  It is RECOMMENDED\n
        \  that the PLR uses the sender template-specific method to identify\n   these
        Path messages.  Hence, the PLR will set the source address in\n   the sender
        template to a local PLR address.\n   The MP MUST use the LSP-ID to identify
        the corresponding S2L sub-\n   LSPs.  The MP MUST NOT use the <Sub-Group Originator
        ID, Sub-Group\n   ID> tuple while identifying the corresponding S2L sub-LSPs.
        \ In order\n   to further process an S2L sub-LSP the MP MUST determine the
        protected\n   S2L sub-LSP using the LSP-ID and the S2L_SUB_LSP object.\n"
      title: 15.1.1.  Link Protection
    - contents:
      - "15.1.2.  Node Protection\n   If node protection is desired the PLR SHOULD
        use one or more P2P\n   bypass tunnels to protect the set of S2L sub-LSPs
        that transit the\n   protected node.  Each of these P2P bypass tunnels MUST
        intersect the\n   path of the S2L sub-LSPs that they protect on an LSR that
        is\n   downstream from the protected node.  This constrains the set of S2L\n
        \  sub-LSPs being backed- up via that bypass tunnel to those S2L sub-\n   LSPs
        that pass through a common downstream MP.  This MP is the\n   destination
        of the bypass tunnel.  When the PLR forwards incoming\n   data for a P2MP
        LSP into the bypass tunnel, the outer label is the\n   bypass tunnel label
        and the inner label is the label allocated by the\n   MP to the set of S2L
        sub-LSPs belonging to that P2MP LSP.\n   After detecting failure of the protected
        node the PLR MUST send one\n   or more Path messages for all protected S2L
        sub-LSPs to the MP of the\n   protected S2L sub-LSP.  It is RECOMMENDED that
        the PLR use the sender\n   template specific method to identify these Path
        messages.  Hence the\n   PLR will set the source address in the sender template
        to a local PLR\n   address.  The MP MUST use the LSP-ID to identify the corresponding\n
        \  S2L sub-LSPs.  The MP MUST NOT use the <Sub-Group Originator ID,\n   Sub-Group
        ID> tuple while identifying the corresponding S2L sub-LSPs\n   because the
        Sub-Group Originator ID might be changed by some LSR that\n   is bypassed
        by the bypass tunnel.  In order to further process an S2L\n   sub-LSP the
        MP MUST determine the protected S2L sub-LSP using the\n   LSP-ID and the S2L_SUB_LSP
        object.\n   Note that node protection MAY require the PLR to be branch capable
        in\n   the data plane, as multiple bypass tunnels may be required to back
        up\n   the set of S2L sub-LSPs passing through the protected node.  If the\n
        \  PLR is not branch capable, the node protection mechanism described\n   here
        is applicable to only those cases where all the S2L sub-LSPs\n   passing through
        the protected node also pass through a single MP that\n   is downstream from
        the protected node.  A PLR MUST set the Node\n   protection flag in the RRO/SRRO
        as specified in [RFC4090].  If a PLR\n   is not branch capable, and one or
        more S2L sub-LSPs are added to a\n   P2MP tree, and these S2L sub-LSPs do
        not transit the existing MP\n   downstream of the protected node, then the
        PLR MUST reset this flag.\n   It is to be noted that procedures in this section
        require P2P bypass\n   tunnels.  Procedures for using P2MP bypass tunnels
        are for further\n   study.\n"
      title: 15.1.2.  Node Protection
    title: 15.1.  Facility Backup
  - contents:
    - "15.2.  One-to-One Backup\n   One-to-one backup, as described in [RFC4090],
      can be used to protect\n   a particular S2L sub-LSP against link and next-hop
      failure.\n   Protection may be used for one or more S2L sub-LSPs between the
      PLR\n   and the next-hop.  All the S2L sub-LSPs corresponding to the same\n
      \  instance of the P2MP tunnel between the PLR and the next-hop SHOULD\n   share
      the same P2MP LSP label, as per section 5.2.1.  All such S2L\n   sub-LSPs belonging
      to a P2MP LSP MUST be protected.\n   The backup S2L sub-LSPs may traverse different
      next-hops at the PLR.\n   Thus, the set of outgoing labels and next-hops for
      a P2MP LSP, at the\n   PLR, may change once protection is triggered.  Consider
      a P2MP LSP\n   that is using a single next-hop and label between the PLR and
      the\n   next-hop of the PLR.  This may no longer be the case once protection\n
      \  is triggered.  This MAY require a PLR to be branch capable in the\n   data
      plane.  If the PLR is not branch capable, the one-to-one backup\n   mechanisms
      described here are only applicable to those cases where\n   all the backup S2L
      sub-LSPs pass through the same next-hop downstream\n   of the PLR.  Procedures
      for one-to-one backup when a PLR is not\n   branch capable and when all the
      backup S2L sub-LSPs do not pass\n   through the same downstream next-hop are
      for further study.\n   It is recommended that the path-specific method be used
      to identify a\n   backup S2L sub-LSP.  Hence, the DETOUR object SHOULD be inserted
      in\n   the backup Path message.  A backup S2L sub-LSP MUST be treated as\n   belonging
      to a different P2MP tunnel instance than the one specified\n   by the LSP-ID.
      \ Furthermore multiple backup S2L sub-LSPs MUST be\n   treated as part of the
      same P2MP tunnel instance if they have the\n   same LSP-ID and the same DETOUR
      objects.  Note that, as specified in\n   section 4, S2L sub-LSPs between different
      P2MP tunnel instances use\n   different labels.\n   If there is only one S2L
      sub-LSP in the Path message, the DETOUR\n   object applies to that sub-LSP.
      \ If there are multiple S2L sub-LSPs\n   in the Path message, the DETOUR object
      applies to all the S2L sub-\n   LSPs.\n"
    title: 15.2.  One-to-One Backup
  title: 15.  Fast Reroute
- contents:
  - "16.  Support for LSRs That Are Not P2MP Capable\n   It may be that some LSRs
    in a network are capable of processing the\n   P2MP extensions described in this
    document, but do not support P2MP\n   branching in the data plane.  If such an
    LSR is requested to become a\n   branch LSR by a received Path message, it MUST
    respond with a PathErr\n   message carrying the Error Code \"Routing Error\" and
    Error Value\n   \"Unable to Branch\".\n   It is also conceivable that some LSRs,
    in a network deploying P2MP\n   capability, may not support the extensions described
    in this\n   document.  If a Path message for the establishment of a P2MP LSP\n
    \  reaches such an LSR, it will reject it with a PathErr because it will\n   not
    recognize the C-Type of the P2MP SESSION object.\n   LSRs that do not support
    the P2MP extensions in this document may be\n   included as transit LSRs by the
    use of LSP stitching [LSP-STITCH] and\n   LSP hierarchy [RFC4206].  Note that
    LSRs that are required to play\n   any other role in the network (ingress, branch
    or egress) MUST\n   support the extensions defined in this document.\n   The use
    of LSP stitching and LSP hierarchy [RFC4206] allows P2MP LSPs\n   to be built
    in such an environment.  A P2P LSP segment is signaled\n   from the last P2MP-capable
    hop that is upstream of a legacy LSR to\n   the first P2MP-capable hop that is
    downstream of it.  This assumes\n   that intermediate legacy LSRs are transit
    LSRs: they cannot act as\n   P2MP branch points.  Transit LSRs along this LSP
    segment do not\n   process control plane messages associated with the P2MP LSP.\n
    \  Furthermore, these transit LSRs also do not need to have P2MP data\n   plane
    capabilities as they only need to process data belonging to the\n   P2P LSP segment.
    \ Hence, these transit LSRs do not need to support\n   P2MP MPLS.  This P2P LSP
    segment is stitched to the incoming P2MP\n   LSP.  After the P2P LSP segment is
    established, the P2MP Path message\n   is sent to the next P2MP-capable LSR as
    a directed Path message.  The\n   next P2MP-capable LSR stitches the P2P LSP segment
    to the outgoing\n   P2MP LSP.\n   In packet networks, the S2L sub-LSPs may be
    nested inside the outer\n   P2P LSP.  Hence, label stacking can be used to enable
    use of the same\n   LSP segment for multiple P2MP LSPs.  Stitching and nesting\n
    \  considerations and procedures are described further in [LSP-STITCH]\n   and
    [RFC4206].\n   There maybe overhead for an operator to configure the P2P LSP\n
    \  segments in advance, when it is desired to support legacy LSRs.  It\n   may
    be desirable to do this dynamically.  The ingress can use IGP\n   extensions to
    determine P2MP-capable LSRs [TE-NODE-CAP].  It can use\n   this information to
    compute S2L sub-LSP paths such that they avoid\n   legacy non-P2MP-capable LSRs.
    \ The explicit route object of an S2L\n   sub-LSP path may contain loose hops
    if there are legacy LSRs along\n   the path.  The corresponding explicit route
    contains a list of\n   objects up to the P2MP-capable LSR that is adjacent to
    a legacy LSR\n   followed by a loose object with the address of the next P2MP-capable\n
    \  LSR.  The P2MP-capable LSR expands the loose hop using its Traffic\n   Engineering
    Database (TED).  When doing this it determines that the\n   loose hop expansion
    requires a P2P LSP to tunnel through the legacy\n   LSR.  If such a P2P LSP exists,
    it uses that P2P LSP.  Else it\n   establishes the P2P LSP.  The P2MP Path message
    is sent to the next\n   P2MP-capable LSR using non-adjacent signaling.\n   The
    P2MP-capable LSR that initiates the non-adjacent signaling\n   message to the
    next P2MP-capable LSR may have to employ a fast\n   detection mechanism (such
    as [BFD] or [BFD-MPLS]) to the next P2MP-\n   capable LSR.  This may be needed
    for the directed Path message head-\n   end to use node protection fast reroute
    when the protected node is\n   the directed Path message tail.\n   Note that legacy
    LSRs along a P2P LSP segment cannot perform node\n   protection of the tail of
    the P2P LSP segment.\n"
  title: 16.  Support for LSRs That Are Not P2MP Capable
- contents:
  - "17.  Reduction in Control Plane Processing with LSP Hierarchy\n   It is possible
    to take advantage of LSP hierarchy [RFC4206] while\n   setting up P2MP LSP, as
    described in the previous section, to reduce\n   control plane processing along
    transit LSRs that are P2MP capable.\n   This is applicable only in environments
    where LSP hierarchy can be\n   used.  Transit LSRs along a P2P LSP segment, being
    used by a P2MP\n   LSP, do not process control plane messages associated with
    the P2MP\n   LSP.  In fact, they are not aware of these messages as they are\n
    \  tunneled over the P2P LSP segment.  This reduces the amount of\n   control
    plane processing required on these transit LSRs.\n   Note that the P2P LSPs can
    be set up dynamically as described in the\n   previous section or preconfigured.
    \ For example, in Figure 2 in\n   section 24, PE1 can set up a P2P LSP to P1 and
    use that as a LSP\n   segment.  The Path messages for PE3 and PE4 can now be tunneled
    over\n   the LSP segment.  Thus, P3 is not aware of the P2MP LSP and does not\n
    \  process the P2MP control messages.\n"
  title: 17.  Reduction in Control Plane Processing with LSP Hierarchy
- contents:
  - "18.  P2MP LSP Re-Merging and Cross-Over\n   This section details the procedures
    for detecting and dealing with\n   re-merge and cross-over.  The term \"re-merge\"
    refers to the case of\n   an ingress or transit node that creates a branch of
    a P2MP LSP, a re-\n   merge branch, that intersects the P2MP LSP at another node
    farther\n   down the tree.  This may occur due to such events as an error in path\n
    \  calculation, an error in manual configuration, or network topology\n   changes
    during the establishment of the P2MP LSP.  If the procedures\n   detailed in this
    section are not followed, data duplication will\n   result.\n   The term \"cross-over\"
    refers to the case of an ingress or transit\n   node that creates a branch of
    a P2MP LSP, a cross-over branch, that\n   intersects the P2MP LSP at another node
    farther down the tree.  It is\n   unlike re-merge in that, at the intersecting
    node, the cross-over\n   branch has a different outgoing interface as well as
    a different\n   incoming interface.  This may be necessary in certain combinations
    of\n   topology and technology; e.g., in a transparent optical network in\n   which
    different wavelengths are required to reach different leaf\n   nodes.\n   Normally,
    a P2MP LSP has a single incoming interface on which all of\n   the data for the
    P2MP LSP is received.  The incoming interface is\n   identified by the IF_ID RSVP_HOP
    object, if present, and by the\n   interface over which the Path message was received
    if the IF_ID\n   RSVP_HOP object is not present.  However, in the case of dynamic
    LSP\n   re-routing, the incoming interface may change.\n   Similarly, in both
    the re-merge and cross-over cases, a node will\n   receive a Path message for
    a given P2MP LSP identifying a different\n   incoming interface for the data,
    and the node needs to be able to\n   distinguish between dynamic LSP re-routing
    and the re- merge/cross-\n   over cases.\n   Make-before-break represents yet
    another similar but different case,\n   in that the incoming interface associated
    with the make-before-break\n   P2MP LSP may be different than that associated
    with the original P2MP\n   LSP.  However, the two P2MP LSPs will be treated as
    distinct (but\n   related) LSPs because they will have different LSP ID field
    values in\n   their SENDER_TEMPLATE objects.\n"
  - contents:
    - "18.1.  Procedures\n   When a node receives a Path message, it MUST check whether
      it has\n   matching state for the P2MP LSP.  Matching state is identified by\n
      \  comparing the SESSION and SENDER_TEMPLATE objects in the received\n   Path
      message with the SESSION and SENDER_TEMPLATE objects of each\n   locally maintained
      P2MP LSP Path state.  The P2MP ID, Tunnel ID, and\n   Extended Tunnel ID in
      the SESSION object and the sender address and\n   LSP ID in the SENDER_TEMPLATE
      object are used for the comparison.  If\n   the node has matching state, and
      the incoming interface for the\n   received Path message is different than the
      incoming interface of the\n   matching P2MP LSP Path state, then the node MUST
      determine whether it\n   is dealing with dynamic LSP rerouting or re-merge/cross-over.\n
      \  Dynamic LSP rerouting is identified by checking whether there is any\n   intersection
      between the set of S2L_SUB_LSP objects associated with\n   the matching P2MP
      LSP Path state and the set of S2L_SUB_LSP objects\n   in the received Path message.
      \ If there is any intersection, then\n   dynamic re-routing has occurred.  If
      there is no intersection between\n   the two sets of S2L_SUB_LSP objects, then
      either re-merge or cross-\n   over has occurred.  (Note that in the case of
      dynamic LSP rerouting,\n   Path messages for the non-intersecting members of
      set of S2L_SUB_LSPs\n   associated with the matching P2MP LSP Path state will
      be received\n   subsequently on the new incoming interface.)\n   In order to
      identify the re-merge case, the node processing the\n   received Path message
      MUST identify the outgoing interfaces\n   associated with the matching P2MP
      Path state.  Re-merge has occurred\n   if there is any intersection between
      the set of outgoing interfaces\n   associated with the matching P2MP LSP Path
      state and the set of\n   outgoing interfaces in the received Path message.\n"
    - contents:
      - "18.1.1.  Re-Merge Procedures\n   There are two approaches to dealing with
        the re-merge case.  In the\n   first, the node detecting the re-merge case,
        i.e., the re-merge node,\n   allows the re-merge case to persist, but data
        from all but one\n   incoming interface is dropped at the re-merge node.  In
        the second,\n   the re-merge node initiates the removal of the re-merge branch(es)\n
        \  via signaling.  Which approach is used is a matter of local policy.\n   A
        node MUST support both approaches and MUST allow user configuration\n   of
        which approach is to be used.\n   When configured to allow a re-merge case
        to persist, the re-merge\n   node MUST validate consistency between the objects
        included in the\n   received Path message and the matching P2MP LSP Path state.
        \ Any\n   inconsistencies MUST result in a PathErr message sent to the previous\n
        \  hop of the received Path message.  The Error Code is set to \"Routing\n
        \  Problem\", and the Error Value is set to \"P2MP Re-Merge Parameter\n   Mismatch\".\n
        \  If there are no inconsistencies, the node logically merges, from the\n
        \  downstream perspective, the control state of incoming Path message\n   with
        the matching P2MP LSP Path state.  Specifically, procedures\n   related to
        processing of messages received from upstream MUST NOT be\n   modified from
        the upstream perspective; this includes processing\n   related to refresh
        and state timeout.  In addition to the standard\n   upstream related procedures,
        the node MUST ensure that each object\n   received from upstream is appropriately
        represented within the set of\n   Path messages sent downstream.  For example,
        the received <S2L sub-\n   LSP descriptor list> MUST be included in the set
        of outgoing Path\n   messages.  If there are any NOTIFY_REQUEST objects present,
        then the\n   procedures defined in section 8 MUST be followed for all Path
        and\n   Resv messages.  Special processing is also required for Resv\n   processing.
        \ Specifically, any Resv message received from downstream\n   MUST be mapped
        into an outgoing Resv message that is sent to the\n   previous hop of the
        received Path message.  In practice, this\n   translates to decomposing the
        complete <S2L sub-LSP descriptor list>\n   into subsets that match the incoming
        Path messages, and then\n   constructing an outgoing Resv message for each
        incoming Path message.\n   When configured to allow a re-merge case to persist,
        the re-merge\n   node receives data associated with the P2MP LSP on multiple
        incoming\n   interfaces, but it MUST only send the data from one of these\n
        \  interfaces to its outgoing interfaces.  That is, the node MUST drop\n   data
        from all but one incoming interface.  This ensures that\n   duplicate data
        is not sent on any outgoing interface.  The mechanism\n   used to select the
        incoming interface is implementation specific and\n   is outside the scope
        of this document.\n   When configured to correct the re-merge branch via signaling,
        the re-\n   merge node MUST send a PathErr message corresponding to the received\n
        \  Path message.  The PathErr message MUST include all of the objects\n   normally
        included in a PathErr message, as well as one or more\n   S2L_SUB_LSP objects
        from the set of sub-LSPs associated with the\n   matching P2MP LSP Path state.
        \ A minimum of three S2L_SUB_LSP objects\n   is RECOMMENDED.  This will allow
        the node that caused the re-merge to\n   identify the outgoing Path state
        associated with the valid portion of\n   the P2MP LSP.  The set of S2L_SUB_LSP
        objects in the received Path\n   message MUST also be included.  The PathErr
        message MUST include the\n   Error Code \"Routing Problem\" and Error Value
        of \"P2MP Re-Merge\n   Detected\".  The node MAY set the Path_State_Removed
        flag [RFC3473].\n   As is always the case, the PathErr message is sent to
        the previous\n   hop of the received Path message.\n   A node that receives
        a PathErr message that contains the Error Value\n   \"Routing Problem/P2MP
        Re-Merge Detected\" MUST determine if it is the\n   node that created the
        re-merge case.  This is done by checking\n   whether there is any intersection
        between the set of S2L_SUB_LSP\n   objects associated with the matching P2MP
        LSP Path state and the set\n   of other-branch S2L_SUB_LSP objects in the
        received PathErr message.\n   If there is, then the node created the re-merge
        case.  Other-branch\n   S2L_SUB_LSP objects are those S2L_SUB_LSP objects
        included, by the\n   node detecting the re-merge case, in the PathErr message
        that were\n   taken from the matching P2MP LSP Path state.  Such S2L_SUB_LSP\n
        \  objects are identifiable as they will not be included in the Path\n   message
        associated with the received PathErr message.  See section\n   11.1 for more
        details on how such an association is identified.\n   The node SHOULD remove
        the re-merge case by moving the S2L_SUB_LSP\n   objects included in the Path
        message associated with the received\n   PathErr message to the outgoing interface
        associated with the\n   matching P2MP LSP Path state.  A trigger Path message
        for the moved\n   S2L_SUB_LSP objects is then sent via that outgoing interface.
        \ If the\n   received PathErr message did not have the Path_State_Removed
        flag\n   set, the node SHOULD send a PathTear via the outgoing interface\n
        \  associated with the re-merge branch.\n   If use of a new outgoing interface
        violates one or more SERO\n   constraints, then a PathErr message containing
        the associated\n   egresses and any identified S2L_SUB_LSP objects SHOULD
        be generated\n   with the Error Code \"Routing Problem\" and Error Value of
        \"ERO\n   Resulted in Re-Merge\".\n   The only case where this process will
        fail is when all the listed\n   S2L_SUB_LSP objects are deleted prior to the
        PathErr message\n   propagating to the ingress.  In this case, the whole process
        will be\n   corrected on the next (refresh or trigger) transmission of the\n
        \  offending Path message.\n"
      title: 18.1.1.  Re-Merge Procedures
    title: 18.1.  Procedures
  title: 18.  P2MP LSP Re-Merging and Cross-Over
- contents:
  - "19.  New and Updated Message Objects\n   This section presents the RSVP object
    formats as modified by this\n   document.\n"
  - contents:
    - "19.1.  SESSION Object\n   A P2MP LSP SESSION object is used.  This object uses
      the existing\n   SESSION C-Num.  New C-Types are defined to accommodate a logical
      P2MP\n   destination identifier of the P2MP tunnel.  This SESSION object has
      a\n   similar structure as the existing point-to-point RSVP-TE SESSION\n   object.
      \ However the destination address is set to the P2MP ID\n   instead of the unicast
      Tunnel Endpoint address.  All S2L sub-LSPs\n   that are part of the same P2MP
      LSP share the same SESSION object.\n   This SESSION object identifies the P2MP
      tunnel.\n   The combination of the SESSION object, the SENDER_TEMPLATE object
      and\n   the S2L_SUB_LSP object identifies each S2L sub-LSP.  This follows the\n
      \  existing P2P RSVP-TE notion of using the SESSION object for\n   identifying
      a P2P Tunnel, which in turn can contain multiple LSPs,\n   each distinguished
      by a unique SENDER_TEMPLATE object.\n"
    - contents:
      - "19.1.1.  P2MP LSP Tunnel IPv4 SESSION Object\n   Class = SESSION, P2MP_LSP_TUNNEL_IPv4
        C-Type = 13\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                       P2MP ID                                 |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |  MUST be zero                 |      Tunnel ID                |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Extended Tunnel ID                       |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  P2MP ID\n      A 32-bit identifier used in the SESSION object that remains\n
        \     constant over the life of the P2MP tunnel.  It encodes the P2MP\n      Identifier
        that is unique within the scope of the ingress LSR.\n   Tunnel ID\n      A
        16-bit identifier used in the SESSION object that remains\n      constant
        over the life of the P2MP tunnel.\n   Extended Tunnel ID\n      A 32-bit identifier
        used in the SESSION object that remains\n      constant over the life of the
        P2MP tunnel.  Ingress LSRs that wish\n      to have a globally unique identifier
        for the P2MP tunnel SHOULD\n      place their tunnel sender address here.
        \ A combination of this\n      address, P2MP ID, and Tunnel ID provides a
        globally unique\n      identifier for the P2MP tunnel.\n"
      title: 19.1.1.  P2MP LSP Tunnel IPv4 SESSION Object
    - contents:
      - "19.1.2.  P2MP LSP Tunnel IPv6 SESSION Object\n   This is the same as the
        P2MP IPv4 LSP SESSION object with the\n   difference that the extended tunnel
        ID may be set to a 16-byte\n   identifier [RFC3209].\n   Class = SESSION,
        P2MP_LSP_TUNNEL_IPv6 C-Type = 14\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                       P2MP ID                                 |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |  MUST be zero                 |      Tunnel ID                |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Extended Tunnel ID (16 bytes)            |\n
        \     |                                                               |\n
        \     |                             .......                           |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
      title: 19.1.2.  P2MP LSP Tunnel IPv6 SESSION Object
    title: 19.1.  SESSION Object
  - contents:
    - "19.2.  SENDER_TEMPLATE Object\n   The SENDER_TEMPLATE object contains the ingress
      LSR source address.\n   The LSP ID can be changed to allow a sender to share
      resources with\n   itself.  Thus, multiple instances of the P2MP tunnel can
      be created,\n   each with a different LSP ID.  The instances can share resources
      with\n   each other.  The S2L sub-LSPs corresponding to a particular instance\n
      \  use the same LSP ID.\n   As described in section 4.2, it is necessary to
      distinguish different\n   Path messages that are used to signal state for the
      same P2MP LSP by\n   using a <Sub-Group ID Originator ID, Sub-Group ID> tuple.
      \ The\n   SENDER_TEMPLATE object is modified to carry this information as shown\n
      \  below.\n"
    - contents:
      - "19.2.1.  P2MP LSP Tunnel IPv4 SENDER_TEMPLATE Object\n   Class = SENDER_TEMPLATE,
        P2MP_LSP_TUNNEL_IPv4 C-Type = 12\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                   IPv4 tunnel sender address                  |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |       Reserved                |            LSP ID             |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                   Sub-Group Originator ID                     |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |       Reserved                |            Sub-Group ID       |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv4 tunnel sender address\n      See [RFC3209].\n   Sub-Group Originator
        ID\n      The Sub-Group Originator ID is set to the TE Router ID of the LSR\n
        \     that originates the Path message.  This is either the ingress LSR\n
        \     or an LSR which re-originates the Path message with its own Sub-\n      Group
        Originator ID.\n   Sub-Group ID\n      An identifier of a Path message used
        to differentiate multiple\n      Path messages that signal state for the same
        P2MP LSP.  This may\n      be seen as identifying a group of one or more egress
        nodes\n      targeted by this Path message.\n   LSP ID\n      See [RFC3209].\n"
      title: 19.2.1.  P2MP LSP Tunnel IPv4 SENDER_TEMPLATE Object
    - contents:
      - "19.2.2.  P2MP LSP Tunnel IPv6 SENDER_TEMPLATE Object\n   Class = SENDER_TEMPLATE,
        P2MP_LSP_TUNNEL_IPv6 C-Type = 13\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                                                               |\n
        \     +                                                               +\n
        \     |                   IPv6 tunnel sender address                  |\n
        \     +                                                               +\n
        \     |                            (16 bytes)                         |\n
        \     +                                                               +\n
        \     |                                                               |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |       Reserved                |            LSP ID             |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                                                               |\n
        \     +                                                               +\n
        \     |                   Sub-Group Originator ID                     |\n
        \     +                                                               +\n
        \     |                            (16 bytes)                         |\n
        \     +                                                               +\n
        \     |                                                               |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |       Reserved                |            Sub-Group ID       |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv6 tunnel sender address\n      See [RFC3209].\n   Sub-Group Originator
        ID\n      The Sub-Group Originator ID is set to the IPv6 TE Router ID of the\n
        \     LSR that originates the Path message.  This is either the ingress\n
        \     LSR or an LSR which re-originates the Path message with its own\n      Sub-Group
        Originator ID.\n   Sub-Group ID\n      As above in section 19.2.1.\n   LSP
        ID\n      See [RFC3209].\n"
      title: 19.2.2.  P2MP LSP Tunnel IPv6 SENDER_TEMPLATE Object
    title: 19.2.  SENDER_TEMPLATE Object
  - contents:
    - "19.3.  S2L_SUB_LSP Object\n   An S2L_SUB_LSP object identifies a particular
      S2L sub-LSP belonging\n   to the P2MP LSP.\n"
    - contents:
      - "19.3.1.  S2L_SUB_LSP IPv4 Object\n   S2L_SUB_LSP Class = 50, S2L_SUB_LSP_IPv4
        C-Type = 1\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                   IPv4 S2L Sub-LSP destination address        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv4 Sub-LSP destination address\n      IPv4 address of the S2L sub-LSP
        destination.\n"
      title: 19.3.1.  S2L_SUB_LSP IPv4 Object
    - contents:
      - "19.3.2.  S2L_SUB_LSP IPv6 Object\n   S2L_SUB_LSP Class = 50, S2L_SUB_LSP_IPv6
        C-Type = 2\n   This is the same as the S2L IPv4 Sub-LSP object, with the difference\n
        \  that the destination address is a 16-byte IPv6 address.\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |        IPv6 S2L Sub-LSP destination address (16 bytes)        |\n
        \     |                        ....                                   |\n
        \     |                                                               |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
      title: 19.3.2.  S2L_SUB_LSP IPv6 Object
    title: 19.3.  S2L_SUB_LSP Object
  - contents:
    - "19.4.  FILTER_SPEC Object\n   The FILTER_SPEC object is canonical to the P2MP
      SENDER_TEMPLATE\n   object.\n"
    - contents:
      - "19.4.1.  P2MP LSP_IPv4 FILTER_SPEC Object\n   Class = FILTER_SPEC, P2MP LSP_IPv4
        C-Type = 12\n   The format of the P2MP LSP_IPv4 FILTER_SPEC object is identical
        to\n   the P2MP LSP_IPv4 SENDER_TEMPLATE object.\n"
      title: 19.4.1.  P2MP LSP_IPv4 FILTER_SPEC Object
    - contents:
      - "19.4.2.  P2MP LSP_IPv6 FILTER_SPEC Object\n   Class = FILTER_SPEC, P2MP LSP_IPv6
        C-Type = 13\n   The format of the P2MP LSP_IPv6 FILTER_SPEC object is identical
        to\n   the P2MP LSP_IPv6 SENDER_TEMPLATE object.\n"
      title: 19.4.2.  P2MP LSP_IPv6 FILTER_SPEC Object
    title: 19.4.  FILTER_SPEC Object
  - contents:
    - "19.5.  P2MP SECONDARY_EXPLICIT_ROUTE Object (SERO)\n   The P2MP SECONDARY_EXPLICIT_ROUTE
      Object (SERO) is defined as\n   identical to the ERO.  The class of the P2MP
      SERO is the same as the\n   SERO defined in [RFC4873].  The P2MP SERO uses a
      new C-Type = 2.  The\n   sub-objects are identical to those defined for the
      ERO.\n"
    title: 19.5.  P2MP SECONDARY_EXPLICIT_ROUTE Object (SERO)
  - contents:
    - "19.6.  P2MP SECONDARY_RECORD_ROUTE Object (SRRO)\n   The P2MP SECONDARY_RECORD_ROUTE
      Object (SRRO) is defined as identical\n   to the ERO.  The class of the P2MP
      SRRO is the same as the SRRO\n   defined in [RFC4873].  The P2MP SRRO uses a
      new C-Type = 2.  The\n   sub-objects are identical to those defined for the
      RRO.\n"
    title: 19.6.  P2MP SECONDARY_RECORD_ROUTE Object (SRRO)
  title: 19.  New and Updated Message Objects
- contents:
  - '20.  IANA Considerations

    '
  - contents:
    - "20.1.  New Class Numbers\n   IANA has assigned the following Class Numbers
      for the new object\n   classes introduced.  The Class Types for each of them
      are to be\n   assigned via standards action.  The sub-object types for the P2MP\n
      \  SECONDARY_EXPLICIT_ROUTE and P2MP_SECONDARY_RECORD_ROUTE follow the\n   same
      IANA considerations as those of the ERO and RRO [RFC3209].\n   50  Class Name
      = S2L_SUB_LSP\n   C-Type\n      1   S2L_SUB_LSP_IPv4 C-Type\n      2   S2L_SUB_LSP_IPv6
      C-Type\n"
    title: 20.1.  New Class Numbers
  - contents:
    - "20.2.  New Class Types\n   IANA has assigned the following C-Type values:\n
      \  Class Name = SESSION\n   C-Type\n     13    P2MP_LSP_TUNNEL_IPv4 C-Type\n
      \    14    P2MP_LSP_TUNNEL_IPv6 C-Type\n   Class Name = SENDER_TEMPLATE\n   C-Type\n
      \    12    P2MP_LSP_TUNNEL_IPv4 C-Type\n     13    P2MP_LSP_TUNNEL_IPv6 C-Type\n
      \  Class Name = FILTER_SPEC\n   C-Type\n     12    P2MP LSP_IPv4 C-Type\n     13
      \   P2MP LSP_IPv6 C-Type\n   Class Name = SECONDARY_EXPLICIT_ROUTE (Defined
      in [RFC4873])\n   C-Type\n      2  P2MP SECONDARY_EXPLICIT_ROUTE C-Type\n   Class
      Name = SECONDARY_RECORD_ROUTE (Defined in [RFC4873])\n   C-Type\n      2  P2MP_SECONDARY_RECORD_ROUTE
      C-Type\n"
    title: 20.2.  New Class Types
  - contents:
    - "20.3.  New Error Values\n   Five new Error Values are defined for use with
      the Error Code\n   \"Routing Problem\".  IANA has assigned values for them as
      follows.\n   The Error Value \"Unable to Branch\" indicates that a P2MP branch\n
      \  cannot be formed by the reporting LSR.  IANA has assigned value 23 to\n   this
      Error Value.\n   The Error Value \"Unsupported LSP Integrity\" indicates that
      a P2MP\n   branch does not support the requested LSP integrity function.  IANA\n
      \  has assigned value 24 to this Error Value.\n   The Error Value \"P2MP Re-Merge
      Detected\" indicates that a node has\n   detected re-merge.  IANA has assigned
      value 25 to this Error Value.\n   The Error Value \"P2MP Re-Merge Parameter
      Mismatch\" is described in\n   section 18.  IANA has assigned value 26 to this
      Error Value.\n   The Error Value \"ERO Resulted in Re-Merge\" is described in
      section\n   18.  IANA has assigned value 27 to this Error Value.\n"
    title: 20.3.  New Error Values
  - contents:
    - "20.4.  LSP Attributes Flags\n   IANA has been asked to manage the space of
      flags in the Attributes\n   Flags TLV carried in the LSP_REQUIRED_ATTRIBUTES
      object [RFC4420].\n   This document defines a new flag as follows:\n   Bit Number:
      \                      3\n   Meaning:                          LSP Integrity
      Required\n   Used in Attributes Flags on Path: Yes\n   Used in Attributes Flags
      on Resv: No\n   Used in Attributes Flags on RRO:  No\n   Referenced Section
      of this Doc:   5.2.4\n"
    title: 20.4.  LSP Attributes Flags
  title: 20.  IANA Considerations
- contents:
  - "21.  Security Considerations\n   In principle this document does not introduce
    any new security issues\n   above those identified in [RFC3209], [RFC3473], and
    [RFC4206].\n   [RFC2205] specifies the message integrity mechanisms for hop-by-hop\n
    \  RSVP signaling.  These mechanisms apply to the hop-by-hop P2MP RSVP-\n   TE
    signaling in this document.  Further, [RFC3473] and [RFC4206]\n   specify the
    security mechanisms for non hop-by-hop RSVP-TE signaling.\n   These mechanisms
    apply to the non hop-by-hop P2MP RSVP-TE signaling\n   specified in this document,
    particularly in sections 16 and 17.\n   An administration may wish to limit the
    domain over which P2MP TE\n   tunnels can be established.  This can be accomplished
    by setting\n   filters on various ports to deny action on a RSVP path message
    with a\n   SESSION object of type P2MP_LSP_IPv4 or P2MP_LSP_IPv6.\n   The ingress
    LSR of a P2MP TE LSP determines the leaves of the P2MP TE\n   LSP based on the
    application of the P2MP TE LSP.  The specification\n   of how such applications
    will use a P2MP TE LSP is outside the scope\n   of this document.  Applications
    MUST provide a mechanism to notify\n   the ingress LSR of the appropriate leaves
    for the P2MP LSP.\n   Specifications of applications within the IETF MUST specify
    this\n   mechanism in sufficient detail that an ingress LSR from one vendor\n
    \  can be used with an application implementation provided by another\n   vendor.
    \ Manual configuration of security parameters when other\n   parameters are auto-discovered
    is generally not sufficient to meet\n   security and interoperability requirements
    of IETF specifications.\n"
  title: 21.  Security Considerations
- contents:
  - "22.  Acknowledgements\n   This document is the product of many people.  The contributors
    are\n   listed in Appendix B.\n   Thanks to Yakov Rekhter, Der-Hwa Gan, Arthi
    Ayyanger, and Nischal\n   Sheth for their suggestions and comments.  Thanks also
    to Dino\n   Farninacci and Benjamin Niven for their comments.\n"
  title: 22.  Acknowledgements
- contents:
  - '23.  References

    '
  - contents:
    - "23.1.  Normative References\n   [RFC4206]     Kompella, K. and Y. Rekhter,
      \"Label Switched Paths\n                 (LSP) Hierarchy with Generalized Multi-Protocol
      Label\n                 Switching (GMPLS) Traffic Engineering (TE)\", RFC 4206,\n
      \                October 2005.\n   [RFC4420]     Farrel, A., Ed., Papadimitriou,
      D., Vasseur, J.-P., and\n                 A. Ayyangar, \"Encoding of Attributes
      for Multiprotocol\n                 Label Switching (MPLS) Label Switched Path
      (LSP)\n                 Establishment Using Resource ReserVation Protocol-\n
      \                Traffic Engineering (RSVP-TE)\", RFC 4420, February\n                 2006.\n
      \  [RFC3209]     Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan,\n                 V.,
      and G. Swallow, \"RSVP-TE: Extensions to RSVP for\n                 LSP Tunnels\",
      RFC 3209, December 2001.\n   [RFC2119]     Bradner, S., \"Key words for use
      in RFCs to Indicate\n                 Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC2205]     Braden, R., Ed., Zhang, L., Berson, S., Herzog,
      S., and\n                 S. Jamin, \"Resource ReSerVation Protocol (RSVP) --\n
      \                Version 1 Functional Specification\", RFC 2205,\n                 September
      1997.\n   [RFC3471]     Berger, L., Ed., \"Generalized Multi-Protocol Label\n
      \                Switching (GMPLS) Signaling Functional Description\",\n                 RFC
      3471, January 2003.\n   [RFC3473]     Berger, L., Ed., \"Generalized Multi-Protocol
      Label\n                 Switching (GMPLS) Signaling Resource ReserVation\n                 Protocol-Traffic
      Engineering (RSVP-TE) Extensions\", RFC\n                 3473, January 2003.\n
      \  [RFC2961]     Berger, L., Gan, D., Swallow, G., Pan, P., Tommasi, F.,\n                 and
      S. Molendini, \"RSVP Refresh Overhead Reduction\n                 Extensions\",
      RFC 2961, April 2001.\n   [RFC3031]     Rosen, E., Viswanathan, A., and R. Callon,\n
      \                \"Multiprotocol Label Switching Architecture\", RFC 3031,\n
      \                January 2001.\n   [RFC4090]     Pan, P., Ed., Swallow, G.,
      Ed., and A. Atlas, Ed.,\n                 \"Fast Reroute Extensions to RSVP-TE
      for LSP Tunnels\",\n                 RFC 4090, May 2005.\n   [RFC3477]     Kompella,
      K. and Y. Rekhter, \"Signalling Unnumbered\n                 Links in Resource
      ReSerVation Protocol - Traffic\n                 Engineering (RSVP-TE)\", RFC
      3477, January 2003.\n   [RFC4873]     Berger, L., Bryskin, I., Papadimitriou,
      D., and A.\n                 Farrel, \"GMPLS Segment Recovery\", RFC 4873, April
      2007.\n"
    title: 23.1.  Normative References
  - contents:
    - "23.2. Informative References\n   [RFC4461]     Yasukawa, S., Ed., \"Signaling
      Requirements for Point-\n                 to-Multipoint Traffic-Engineered MPLS
      Label Switched\n                 Paths (LSPs)\", RFC 4461, April 2006.\n   [BFD]
      \        Katz, D. and D. Ward, \"Bidirectional Forwarding\n                 Detection\",
      Work in Progress, March 2007.\n   [BFD-MPLS]    Aggarwal, R., Kompella, K.,
      Nadeau, T., and G. Swallow,\n                 \"BFD for MPLS LSPs\", Work in
      Progress, March 2007.\n   [LSP-STITCH]  Ayyanger, A., Kompella, K., Vasseur,
      JP., and A.\n                 Farrel, \"Label Switched Path Stitching with Generalized\n
      \                Multiprotocol Label Switching Traffic Engineering\n                 (GMPLS
      TE)\", Work in Progress, March 2007.\n   [TE-NODE-CAP] Vasseur, JP., Ed., Le
      Roux, JL., Ed., \"IGP Routing\n                 Protocol Extensions for Discovery
      of Traffic\n                 Engineering Node Capabilities\", Work in Progress,
      April\n                 2007.\n   [RFC4003]     Berger, L., \"GMPLS Signaling
      Procedure for Egress\n                 Control\", RFC 4003, February 2005.\n"
    title: 23.2. Informative References
  title: 23.  References
- contents:
  - "Appendix A.  Example of P2MP LSP Setup\n   The Following is one example of setting
    up a P2MP LSP using the\n   procedures described in this document.\n                   Source
    1 (S1)\n                     |\n                    PE1\n                   |
    \  |\n                   |L5 |\n                   P3  |\n                   |
    \  |\n                L3 |L1 |L2\n       R2----PE3--P1   P2---PE2--Receiver 1
    (R1)\n                  | L4\n          PE5----PE4----R3\n                  |\n
    \                 |\n                 R4\n                Figure 2.\n   The mechanism
    is explained using Figure 2.  PE1 is the ingress LSR.\n   PE2, PE3, and PE4 are
    egress LSRs.\n   a) PE1 learns that PE2, PE3, and PE4 are interested in joining
    a P2MP\n      tree with a P2MP ID of P2MP ID1.  We assume that PE1 learns of the\n
    \     egress LSRs at different points in time.\n   b) PE1 computes the P2P path
    to reach PE2.\n   c) PE1 establishes the S2L sub-LSP to PE2 along <PE1, P2, PE2>.\n
    \  d) PE1 computes the P2P path to reach PE3 when it discovers PE3.\n      This
    path is computed to share the same links where possible with\n      the sub-LSP
    to PE2 as they belong to the same P2MP session.\n   e) PE1 establishes the S2L
    sub-LSP to PE3 along <PE1, P3, P1, PE3>.\n   f) PE1 computes the P2P path to reach
    PE4 when it discovers PE4.\n      This path is computed to share the same links
    where possible with\n      the sub-LSPs to PE2 and PE3 as they belong to the same
    P2MP\n      session.\n   g) PE1 signals the Path message for PE4 sub-LSP along
    <PE1, P3, P1,\n      PE4>.\n   h) P1 receives a Resv message from PE4 with label
    L4.  It had\n      previously received a Resv message from PE3 with label L3.
    \ It had\n      allocated a label L1 for the sub-LSP to PE3.  It uses the same\n
    \     label and sends the Resv messages to P3.  Note that it may send\n      only
    one Resv message with multiple flow descriptors in the flow\n      descriptor
    list.  If this is the case, and FF style is used, the\n      FF flow descriptor
    will contain the S2L sub-LSP descriptor list\n      with two entries: one for
    PE4 and the other for PE3.  For SE\n      style, the SE filter spec will contain
    this S2L sub-LSP descriptor\n      list.  P1 also creates a label mapping of (L1
    -> {L3, L4}).  P3\n      uses the existing label L5 and sends the Resv message
    to PE1, with\n      label L5.  It reuses the label mapping of {L5 -> L1}.\n"
  title: Appendix A.  Example of P2MP LSP Setup
- contents:
  - "Appendix B.  Contributors\n   John Drake\n   Boeing\n   EMail: john.E.Drake2@boeing.com\n
    \  Alan Kullberg\n   Motorola Computer Group\n   120 Turnpike Road 1st Floor\n
    \  Southborough, MA  01772\n   EMail: alan.kullberg@motorola.com\n   Lou Berger\n
    \  LabN Consulting, L.L.C.\n   EMail: lberger@labn.net\n   Liming Wei\n   Redback
    Networks\n   350 Holger Way\n   San Jose, CA 95134\n   EMail: lwei@redback.com\n
    \  George Apostolopoulos\n   Redback Networks\n   350 Holger Way\n   San Jose,
    CA 95134\n   EMail: georgeap@redback.com\n   Kireeti Kompella\n   Juniper Networks\n
    \  1194 N. Mathilda Ave\n   Sunnyvale, CA 94089\n   EMail: kireeti@juniper.net\n
    \  George Swallow\n   Cisco Systems, Inc.\n   300 Beaver Brook Road\n   Boxborough
    , MA - 01719\n   USA\n   EMail: swallow@cisco.com\n   JP Vasseur\n   Cisco Systems,
    Inc.\n   300 Beaver Brook Road\n   Boxborough , MA - 01719\n   USA\n   EMail:
    jpv@cisco.com\n   Dean Cheng\n   Cisco Systems Inc.\n   170 W Tasman Dr.\n   San
    Jose, CA 95134\n   Phone 408 527 0677\n   EMail:  dcheng@cisco.com\n   Markus
    Jork\n   Avici Systems\n   101 Billerica Avenue\n   N. Billerica, MA 01862\n   Phone:
    +1 978 964 2142\n   EMail: mjork@avici.com\n   Hisashi Kojima\n   NTT Corporation\n
    \  9-11, Midori-Cho 3-Chome\n   Musashino-Shi, Tokyo 180-8585 Japan\n   Phone:
    +81 422 59 6070\n   EMail: kojima.hisashi@lab.ntt.co.jp\n   Andrew G. Malis\n
    \  Tellabs\n   2730 Orchard Parkway\n   San Jose, CA 95134\n   Phone: +1 408 383
    7223\n   EMail: Andy.Malis@tellabs.com\n   Koji Sugisono\n   NTT Corporation\n
    \  9-11, Midori-Cho 3-Chome\n   Musashino-Shi, Tokyo 180-8585 Japan\n   Phone:
    +81 422 59 2605\n   EMail: sugisono.koji@lab.ntt.co.jp\n   Masanori Uga\n   NTT
    Corporation\n   9-11, Midori-Cho 3-Chome\n   Musashino-Shi, Tokyo 180-8585 Japan\n
    \  Phone: +81 422 59 4804\n   EMail: uga.masanori@lab.ntt.co.jp\n   Igor Bryskin\n
    \  Movaz Networks, Inc.\n   7926 Jones Branch Drive\n   Suite 615\n   McLean VA,
    22102\n   ibryskin@movaz.com\n   Adrian Farrel\n   Old Dog Consulting\n   Phone:
    +44 0 1978 860944\n   EMail: adrian@olddog.co.uk\n   Jean-Louis Le Roux\n   France
    Telecom\n   2, avenue Pierre-Marzin\n   22307 Lannion Cedex\n   France\n   EMail:
    jeanlouis.leroux@francetelecom.com\n"
  title: Appendix B.  Contributors
- contents:
  - "Editors' Addresses\n   Rahul Aggarwal\n   Juniper Networks\n   1194 North Mathilda
    Ave.\n   Sunnyvale, CA 94089\n   EMail: rahul@juniper.net\n   Seisho Yasukawa\n
    \  NTT Corporation\n   9-11, Midori-Cho 3-Chome\n   Musashino-Shi, Tokyo 180-8585
    Japan\n   Phone: +81 422 59 4769\n   EMail: yasukawa.seisho@lab.ntt.co.jp\n   Dimitri
    Papadimitriou\n   Alcatel\n   Francis Wellesplein 1,\n   B-2018 Antwerpen, Belgium\n
    \  Phone: +32 3 240-8491\n   EMail: Dimitri.Papadimitriou@alcatel-lucent.be\n"
  title: Editors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
