- contents:
  - "                       The Simple and Protected\n    Generic Security Service
    Application Program Interface (GSS-API)\n                         Negotiation
    Mechanism\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies a negotiation mechanism for the Generic\n
    \  Security Service Application Program Interface (GSS-API), which is\n   described
    in RFC 2743.  GSS-API peers can use this negotiation\n   mechanism to choose from
    a common set of security mechanisms.  If\n   per-message integrity services are
    available on the established\n   mechanism context, then the negotiation is protected
    against an\n   attacker that forces the selection of a mechanism not desired by
    the\n   peers.\n   This mechanism replaces RFC 2478 in order to fix defects in
    that\n   specification and to describe how to inter-operate with\n   implementations
    of that specification that are commonly deployed on\n   the Internet.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \  2. Conventions Used in This Document ...............................3\n   3.
    Negotiation Protocol ............................................3\n      3.1.
    Negotiation Description ....................................4\n      3.2. Negotiation
    Procedure ......................................5\n   4. Token Definitions ...............................................7\n
    \     4.1. Mechanism Types ............................................7\n      4.2.
    Negotiation Tokens .........................................7\n           4.2.1.
    negTokenInit ........................................8\n           4.2.2. negTokenResp
    ........................................9\n   5. Processing of mechListMIC ......................................10\n
    \  6. Extensibility ..................................................13\n   7.
    Security Considerations ........................................13\n   8. Acknowledgments
    ................................................14\n   9. References .....................................................14\n
    \     9.1. Normative References ......................................14\n      9.2.
    Informative References ....................................15\n   Appendix A.
    \ SPNEGO ASN.1 Module ..................................16\n   Appendix B.  GSS-API
    Negotiation Support API ......................17\n      B.1.  GSS_Set_neg_mechs
    Call ...................................17\n      B.2.  GSS_Get_neg_mechs Call
    ...................................18\n   Appendix C.  Changes since RFC 2478
    ...............................18\n   Appendix D.  mechListMIC Computation Example
    ......................20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The GSS-API [RFC2743] provides a generic interface that
    can be\n   layered atop different security mechanisms such that, if\n   communicating
    peers acquire GSS-API credentials for the same security\n   mechanism, then a
    security context may be established between them\n   (subject to policy).  However,
    GSS-API does not prescribe the method\n   by which GSS-API peers can establish
    whether they have a common\n   security mechanism.\n   The Simple and Protected
    GSS-API Negotiation (SPNEGO) mechanism\n   defined here is a pseudo security mechanism
    that enables GSS-API\n   peers to determine in-band whether their credentials
    support a common\n   set of one or more GSS-API security mechanisms; if so, it
    invokes the\n   normal security context establishment for a selected common security\n
    \  mechanism.  This is most useful for applications that depend on GSS-\n   API
    implementations and share multiple mechanisms between the peers.\n   The SPNEGO
    mechanism negotiation is based on the following model: the\n   initiator proposes
    a list of security mechanism(s), in decreasing\n   preference order (favorite
    choice first), the acceptor (also known as\n   the target) either accepts the
    initiator's preferred security\n   mechanism (the first in the list) or chooses
    one of the available\n   mechanisms from the offered list; if neither is acceptable,
    the\n   acceptor rejects the proposed value(s).  The target then informs the\n
    \  initiator of its choice.\n   Once a common security mechanism is chosen, mechanism-specific\n
    \  options MAY be negotiated as part of the selected mechanism's context\n   establishment.
    \ These negotiations (if any) are internal to the\n   mechanism and opaque to
    the SPNEGO protocol.  As such, they are\n   outside the scope of this document.\n
    \  If per-message integrity services [RFC2743] are available on the\n   established
    mechanism security context, then the negotiation is\n   protected to ensure that
    the mechanism list has not been modified.\n   In cases where an attacker could
    have materially influenced the\n   negotiation, peers exchange message integrity
    code (MIC) tokens to\n   confirm that the mechanism list has not been modified.
    \ If no action\n   of an attacker could have materially modified the outcome of
    the\n   negotiation, the exchange of MIC tokens is optional (see Section 5).\n
    \  Allowing MIC tokens to be optional in this case provides\n   interoperability
    with existing implementations while still protecting\n   the negotiation.  This
    interoperability comes at the cost of\n   increased complexity.\n   SPNEGO relies
    on the concepts developed in the GSS-API specification\n   [RFC2743].  The negotiation
    data is encapsulated in context-level\n   tokens.  Therefore, callers of the GSS-API
    do not need to be aware of\n   the existence of the negotiation tokens, but only
    of the new pseudo-\n   security mechanism.  A failure in the negotiation phase
    causes a\n   major status code to be returned: GSS_S_BAD_MECH.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  Negotiation Protocol\n   When the established mechanism context provides
    integrity protection,\n   the mechanism negotiation can be protected.  When acquiring\n
    \  negotiated security mechanism tokens, per-message integrity services\n   are
    always requested by the SPNEGO mechanism.\n   When the established mechanism context
    supports per-message integrity\n   services, SPNEGO guarantees that the selected
    mechanism is mutually\n   preferred.\n   This section describes the negotiation
    process of this protocol.\n"
  - contents:
    - "3.1.  Negotiation Description\n   The first negotiation token sent by the initiator
      contains an ordered\n   list of mechanisms in decreasing preference order (favorite
      mechanism\n   first), and optionally the initial mechanism token for the preferred\n
      \  mechanism of the initiator (i.e., the first in the list).  (Note that\n   the
      list MUST NOT contain this SPNEGO mechanism itself or any\n   mechanism for
      which the client does not have appropriate\n   credentials.)\n   The target
      then processes the token from the initiator.  This will\n   result in one of
      four possible states (as defined in Section 4.2.2)\n   being returned in the
      reply message: accept-completed, accept-\n   incomplete, reject, or request-mic.
      \ A reject state will terminate\n   the negotiation; an accept-completed state
      indicates that the\n   initiator-selected mechanism was acceptable to the target,
      and that\n   the security mechanism token embedded in the first negotiation\n
      \  message was sufficient to complete the authentication; an accept-\n   incomplete
      state indicates that further message exchange is needed\n   but the MIC token
      exchange (as described in Section 5) is OPTIONAL; a\n   request-mic state (this
      state can only be present in the first reply\n   message from the target) indicates
      that the MIC token exchange is\n   REQUIRED if per-message integrity services
      are available.\n   Unless the preference order is specified by the application,
      the\n   policy by which the target chooses a mechanism is an implementation-\n
      \  specific, local matter.  In the absence of an application-specified\n   preference
      order or other policy, the target SHALL choose the first\n   mechanism in the
      initiator proposed list for which it has valid\n   credentials.\n   In case
      of a successful negotiation, the security mechanism in the\n   first reply message
      represents the value suitable for the target that\n   was chosen from the list
      offered by the initiator.\n   In case of an unsuccessful negotiation, the reject
      state is returned,\n   and the generation of a context-level negotiation token
      is OPTIONAL.\n   Once a mechanism has been selected, context establishment tokens\n
      \  specific to the selected mechanism are carried within the negotiation\n   tokens.\n
      \  Lastly, MIC tokens may be exchanged to ensure the authenticity of the\n   mechanism
      list received by the target.\n   To avoid conflicts with the use of MIC tokens
      by SPNEGO, partially-\n   established contexts MUST NOT be used for per-message
      calls.  To\n   guarantee this, the prot_ready_state [RFC2743] MUST be set to
      false\n   on return from GSS_Init_sec_context() and GSS_Accept_sec_context(),\n
      \  even if the underlying mechanism returned true.\n   Note that in order to
      avoid an extra round trip, the first context\n   establishment token of the
      initiator's preferred mechanism SHOULD be\n   embedded in the initial negotiation
      message (as defined in Section\n   4.2).  (This mechanism token is referred
      to as the optimistic\n   mechanism token in this document.)  In addition, using
      the optimistic\n   mechanism token allows the initiator to recover from non-fatal
      errors\n   encountered when trying to produce the first mechanism token before
      a\n   mechanism can be selected.  In cases where the initiator's preferred\n
      \  mechanism is not likely to be selected by the acceptor because of the\n   significant
      cost of its generation, implementations MAY omit the\n   optimistic mechanism
      token.\n"
    title: 3.1.  Negotiation Description
  - contents:
    - "3.2.  Negotiation Procedure\n   The basic form of the procedure assumes that
      per-message integrity\n   services are available on the established mechanism
      context, and it\n   is summarized as follows:\n   a) The GSS-API initiator invokes
      GSS_Init_sec_context() as normal,\n      but requests that SPNEGO be used.  SPNEGO
      can either be explicitly\n      requested or accepted as the default mechanism.\n
      \  b) The initiator GSS-API implementation generates a negotiation token\n      containing
      a list of one or more security mechanisms that are\n      available based on
      the credentials used for this context\n      establishment, and optionally on
      the initial mechanism token for\n      the first mechanism in the list.\n   c)
      The GSS-API initiator application sends the token to the target\n      application.
      \ The GSS-API target application passes the token by\n      invoking GSS_Accept_sec_context().
      \ The acceptor will do one of\n      the following:\n        I) If none of the
      proposed mechanisms are acceptable, the\n           negotiation SHALL be terminated.
      \ GSS_Accept_sec_context\n           indicates GSS_S_BAD_MECH.  The acceptor
      MAY output a\n           negotiation token containing a reject state.\n       II)
      If either the initiator's preferred mechanism is not accepted\n           by
      the target or this mechanism is accepted but is not the\n           acceptor's
      most preferred mechanism (i.e., the MIC token\n           exchange as described
      in Section 5 is required),\n           GSS_Accept_sec_context() indicates GSS_S_CONTINUE_NEEDED.\n
      \          The acceptor MUST output a negotiation token containing a\n           request-mic
      state.\n      III) Otherwise, if at least one additional negotiation token from\n
      \          the initiator is needed to establish this context,\n           GSS_Accept_sec_context()
      indicates GSS_S_CONTINUE_NEEDED and\n           outputs a negotiation token
      containing an accept-incomplete\n           state.\n       IV) Otherwise, no
      additional negotiation token from the initiator\n           is needed to establish
      this context, GSS_Accept_sec_context()\n           indicates GSS_S_COMPLETE
      and outputs a negotiation token\n           containing an accept_complete state.\n
      \     If the initiator's preferred mechanism is accepted, and an\n      optimistic
      mechanism token was included, this mechanism token MUST\n      be passed to
      the selected mechanism by invoking\n      GSS_Accept_sec_context().  If a response
      mechanism token is\n      returned, it MUST be included in the response negotiation
      token.\n      Otherwise, the target will not generate a response mechanism token\n
      \     in the first reply.\n   d) The GSS-API target application returns the
      negotiation token to\n      the initiator application.  The GSS-API initiator
      application\n      passes the token by invoking GSS_Init_sec_context().  The
      security\n      context initialization is then continued according to the standard\n
      \     GSS-API conventions for the selected mechanism, where the tokens\n      of
      the selected mechanism are encapsulated in negotiation messages\n      (see
      Section 4) until GSS_S_COMPLETE is returned for both the\n      initiator and
      the target by the selected security mechanism.\n   e) MIC tokens are then either
      skipped or exchanged according to\n      Section 5.\n   Note that the *_req_flag
      input parameters for context establishment\n   are relative to the selected
      mechanism, as are the *_state output\n   parameters.  That is, these parameters
      are not applicable to the\n   negotiation process per se.\n   On receipt of
      a negotiation token on the target side, a GSS-API\n   implementation that does
      not support negotiation would indicate the\n   GSS_S_BAD_MECH status as though
      a particular basic security mechanism\n   had been requested and was not supported.\n
      \  When a GSS-API credential is acquired for the SPNEGO mechanism, the\n   implementation
      SHOULD produce a credential element for the SPNEGO\n   mechanism that internally
      contains GSS-API credential elements for\n   all mechanisms for which the principal
      has credentials available,\n   except for any mechanisms that are not to be
      negotiated, per\n   implementation-, site-, or application-specific policy.
      \ See Appendix\n   B for interfaces for expressing application policy.\n"
    title: 3.2.  Negotiation Procedure
  title: 3.  Negotiation Protocol
- contents:
  - "4.  Token Definitions\n   The type definitions in this section assume an ASN.1
    module\n   definition of the following form:\n      SPNEGOASNOneSpec {\n         iso(1)
    identified-organization(3) dod(6) internet(1)\n         security(5) mechanism(5)
    snego (2) modules(4) spec2(2)\n      } DEFINITIONS EXPLICIT TAGS ::= BEGIN\n      --
    rest of definitions here\n      END\n   This specifies that the tagging context
    for the module will be\n   explicit and non-automatic.\n   The encoding of the
    SPNEGO protocol messages shall obey the\n   Distinguished Encoding Rules (DER)
    of ASN.1, as described in [X690].\n"
  - contents:
    - "4.1.  Mechanism Types\n   In this negotiation model, each OID represents one
      GSS-API mechanism\n   or one variant (see Section 6) of it, according to [RFC2743].\n
      \     MechType ::= OBJECT IDENTIFIER\n          -- OID represents each security
      mechanism as suggested by\n          -- [RFC2743]\n      MechTypeList ::= SEQUENCE
      OF MechType\n"
    title: 4.1.  Mechanism Types
  - contents:
    - "4.2.  Negotiation Tokens\n   The syntax of the initial negotiation tokens follows
      the\n   initialContextToken syntax defined in Section 3.1 of [RFC2743].  The\n
      \  SPNEGO pseudo mechanism is identified by the Object Identifier\n   iso.org.dod.internet.security.mechanism.snego
      (1.3.6.1.5.5.2).\n   Subsequent tokens MUST NOT be encapsulated in this GSS-API
      generic\n   token framing.\n   This section specifies the syntax of the inner
      token for the initial\n   message and the syntax of subsequent context establishment
      tokens.\n      NegotiationToken ::= CHOICE {\n          negTokenInit    [0]
      NegTokenInit,\n          negTokenResp    [1] NegTokenResp\n      }\n"
    - contents:
      - "4.2.1.  negTokenInit\n      NegTokenInit ::= SEQUENCE {\n          mechTypes
        \      [0] MechTypeList,\n          reqFlags        [1] ContextFlags  OPTIONAL,\n
        \           -- inherited from RFC 2478 for backward compatibility,\n            --
        RECOMMENDED to be left out\n          mechToken       [2] OCTET STRING  OPTIONAL,\n
        \         mechListMIC     [3] OCTET STRING  OPTIONAL,\n          ...\n      }\n
        \     ContextFlags ::= BIT STRING {\n          delegFlag       (0),\n          mutualFlag
        \     (1),\n          replayFlag      (2),\n          sequenceFlag    (3),\n
        \         anonFlag        (4),\n          confFlag        (5),\n          integFlag
        \      (6)\n      } (SIZE (32))\n   This is the syntax for the inner token
        of the initial negotiation\n   message.\n   mechTypes\n      This field contains
        one or more security mechanisms available for\n      the initiator, in decreasing
        preference order (favorite choice\n      first).\n   reqFlags\n      This
        field, if present, contains the service options that are\n      requested
        to establish the context (the req_flags parameter of\n      GSS_Init_sec_context()).
        \ This field is inherited from RFC 2478\n      and is not integrity protected.
        \ For implementations of this\n      specification, the initiator SHOULD omit
        this reqFlags field and\n      the acceptor MUST ignore this reqFlags field.\n
        \     The size constraint on the ContextFlags ASN.1 type only applies to\n
        \     the abstract type.  The ASN.1 DER requires that all trailing zero\n
        \     bits be truncated from the encoding of a bit string type whose\n      abstract
        definition includes named bits.  Implementations should\n      not expect
        to receive exactly 32 bits in an encoding of\n      ContextFlags.\n   mechToken\n
        \     This field, if present, contains the optimistic mechanism token.\n   mechlistMIC\n
        \     This field, if present, contains an MIC token for the mechanism\n      list
        in the initial negotiation message.  This MIC token is\n      computed according
        to Section 5.\n"
      title: 4.2.1.  negTokenInit
    - contents:
      - "4.2.2.  negTokenResp\n      NegTokenResp ::= SEQUENCE {\n          negState
        \      [0] ENUMERATED {\n              accept-completed    (0),\n              accept-incomplete
        \  (1),\n              reject              (2),\n              request-mic
        \        (3)\n          }                                 OPTIONAL,\n            --
        REQUIRED in the first reply from the target\n          supportedMech   [1]
        MechType      OPTIONAL,\n            -- present only in the first reply from
        the target\n          responseToken   [2] OCTET STRING  OPTIONAL,\n          mechListMIC
        \    [3] OCTET STRING  OPTIONAL,\n          ...\n      }\n   This is the syntax
        for all subsequent negotiation messages.\n   negState\n      This field, if
        present, contains the state of the negotiation.\n      This can be:\n      accept-completed\n
        \        No further negotiation message from the peer is expected, and\n         the
        security context is established for the sender.\n      accept-incomplete\n
        \        At least one additional negotiation message from the peer is\n         needed
        to establish the security context.\n      reject\n         The sender terminates
        the negotiation.\n      request-mic\n         The sender indicates that the
        exchange of MIC tokens, as\n         described in Section 5, will be REQUIRED
        if per-message\n         integrity services are available on the mechanism
        context to be\n         established.  This value SHALL only be present in
        the first\n         reply from the target.\n      This field is REQUIRED in
        the first reply from the target, and is\n      OPTIONAL thereafter.  When
        negState is absent, the actual state\n      should be inferred from the state
        of the negotiated mechanism\n      context.\n   supportedMech\n      This
        field SHALL only be present in the first reply from the\n      target.  It
        MUST be one of the mechanism(s) offered by the\n      initiator.\n   ResponseToken\n
        \     This field, if present, contains tokens specific to the mechanism\n
        \     selected.\n   mechlistMIC\n      This field, if present, contains an
        MIC token for the mechanism\n      list in the initial negotiation message.
        \ This MIC token is\n      computed according to Section 5.\n"
      title: 4.2.2.  negTokenResp
    title: 4.2.  Negotiation Tokens
  title: 4.  Token Definitions
- contents:
  - "5.  Processing of mechListMIC\n   If the mechanism selected by the negotiation
    does not support\n   integrity protection, then no mechlistMIC token is used.\n
    \  Otherwise, if the accepted mechanism is the most preferred mechanism\n   of
    both the initiator and the acceptor, then the MIC token exchange,\n   as described
    later in this section, is OPTIONAL.  A mechanism is the\n   acceptor's most preferred
    mechanism if there is no other mechanism\n   that the acceptor would have preferred
    over the accepted mechanism\n   had it been present in the mechanism list.\n   In
    all other cases, MIC tokens MUST be exchanged after the mechanism\n   context
    is fully established.\n   a) The mechlistMIC token (or simply the MIC token) is
    computed over\n      the mechanism list in the initial negotiation message by
    invoking\n      GSS_GetMIC() as follows: the input context_handle is the\n      established
    mechanism context, the input qop_req is 0, and the\n      input message is the
    DER encoding of the value of type\n      MechTypeList, which is contained in the
    \"mechTypes\" field of the\n      NegTokenInit.  The input message is NOT the
    DER encoding of the\n      type \"[0] MechTypeList\".\n   b) If the selected mechanism
    exchanges an even number of mechanism\n      tokens (i.e., the acceptor sends
    the last mechanism token), the\n      acceptor does the following when generating
    the negotiation\n      message containing the last mechanism token: if the MIC
    token\n      exchange is optional, GSS_Accept_sec_context() either indicates\n
    \     GSS_S_COMPLETE and does not include a mechlistMIC token, or\n      indicates
    GSS_S_CONTINUE_NEEDED and includes a mechlistMIC token\n      and an accept-incomplete
    state; if the MIC token exchange is\n      required, GSS_Accept_sec_context()
    indicates GSS_S_CONTINUE_NEEDED\n      and includes a mechlistMIC token.  Acceptors
    that wish to be\n      compatible with legacy Windows SPNEGO implementations,
    as\n      described in Appendix C, should not generate a mechlistMIC token\n      when
    the MIC token exchange is not required.  The initiator then\n      processes the
    last mechanism token, and does one of the following:\n        I) If a mechlistMIC
    token was included and is correctly\n           verified, GSS_Init_sec_context()
    indicates GSS_S_COMPLETE.\n           The output negotiation message contains
    a mechlistMIC token\n           and an accept_complete state.  The acceptor MUST
    then verify\n           this mechlistMIC token.\n       II) If a mechlistMIC token
    was included but is incorrect, the\n           negotiation SHALL be terminated.
    \ GSS_Init_sec_context()\n           indicates GSS_S_DEFECTIVE_TOKEN.\n      III)
    If no mechlistMIC token was included and the MIC token\n           exchange is
    not required, GSS_Init_sec_context() indicates\n           GSS_S_COMPLETE with
    no output token.\n       IV) If no mechlistMIC token was included but the MIC
    token\n           exchange is required, the negotiation SHALL be terminated.\n
    \          GSS_Accept_sec_context() indicates GSS_S_DEFECTIVE_TOKEN.\n   c) In
    the case that the chosen mechanism exchanges an odd number of\n      mechanism
    tokens (i.e., the initiator sends the last mechanism\n      token), the initiator
    does the following when generating the\n      negotiation message containing the
    last mechanism token: if the\n      negState was request-mic in the first reply
    from the target, a\n      mechlistMIC token MUST be included; otherwise, the mechlistMIC\n
    \     token is OPTIONAL.  (Note that the MIC token exchange is required\n      if
    a mechanism other than the initiator's first choice is chosen.)\n      In the
    case that the optimistic mechanism token is the only\n      mechanism token for
    the initiator's preferred mechanism, the\n      mechlistMIC token is OPTIONAL.
    \ Whether the mechlistMIC token is\n      included, GSS_Init_sec_context() indicates
    GSS_S_CONTINUE_NEEDED.\n      Initiators that wish to be compatible with legacy
    Windows SPNEGO\n      implementations, as described in Appendix C, should not
    generate a\n      mechlistMIC token when the MIC token exchange is not required.\n
    \     The acceptor then processes the last mechanism token and does one\n      of
    the following:\n        I) If a mechlistMIC token was included and is correctly\n
    \          verified, GSS_Accept_sec_context() indicates GSS_S_COMPLETE.\n           The
    output negotiation message contains a mechlistMIC token\n           and an accept_complete
    state.  The initiator MUST then verify\n           this mechlistMIC token.\n       II)
    If a mechlistMIC token was included but is incorrect, the\n           negotiation
    SHALL be terminated.  GSS_Accept_sec_context()\n           indicates GSS_S_DEFECTIVE_TOKEN.\n
    \     III) If no mechlistMIC token was included and the mechlistMIC\n           token
    exchange is not required, GSS_Accept_sec_context()\n           indicates GSS_S_COMPLETE.
    \ The output negotiation message\n           contains an accept_complete state.\n
    \      IV) In the case that the optimistic mechanism token is also the\n           last
    mechanism token (when the initiator's preferred\n           mechanism is accepted
    by the target) and the target sends a\n           request-mic state but the initiator
    did not send a\n           mechlistMIC token, the target then MUST include a mechlistMIC\n
    \          token in that first reply.  GSS_Accept_sec_context()\n           indicates
    GSS_S_CONTINUE_NEEDED.  The initiator MUST verify\n           the received mechlistMIC
    token and generate a mechlistMIC\n           token to send back to the target.
    \ The target SHALL, in turn,\n           verify the returned mechlistMIC token
    and complete the\n           negotiation.\n        V) If no mechlistMIC token
    was included and the acceptor sent a\n           request-mic state in the first
    reply message (the exchange of\n           MIC tokens is required), the negotiation
    SHALL be terminated.\n           GSS_Accept_sec_context() indicates GSS_S_DEFECTIVE_TOKEN.\n"
  title: 5.  Processing of mechListMIC
- contents:
  - "6.  Extensibility\n   Two mechanisms are provided for extensibility.  First,
    the ASN.1\n   structures in this specification MAY be expanded by IETF standards\n
    \  action.  Implementations receiving unknown fields MUST ignore these\n   fields.\n
    \  Secondly, OIDs corresponding to a desired mechanism attribute (i.e.,\n   mechanism
    variants) may be included in the set of preferred\n   mechanisms by an initiator.
    \ The acceptor can choose to honor this\n   request by preferring mechanisms that
    have the included attributes.\n   Future work within the Kitten working group
    is expected to\n   standardize common attributes that SPNEGO mechanisms may wish
    to\n   support.  At this time, it is sufficient to say that initiators MAY\n   include
    OIDs that do not correspond to mechanisms.  Such OIDs MAY\n   influence the acceptor's
    choice of mechanism.  As discussed in\n   Section 5, if there are mechanisms that,
    if present in the\n   initiator's list of mechanisms, might be preferred by the
    acceptor\n   instead of the initiator's preferred mechanism, the acceptor MUST\n
    \  demand the MIC token exchange.  As the consequence, acceptors MUST\n   demand
    the MIC token exchange if they support negotiation of\n   attributes not available
    in the initiator's preferred mechanism,\n   regardless of whether the initiator
    actually requested these\n   attributes.\n"
  title: 6.  Extensibility
- contents:
  - "7.  Security Considerations\n   In order to produce the MIC token for the mechanism
    list, the\n   mechanism must provide integrity protection.  When the selected\n
    \  mechanism does not support integrity protection, the negotiation is\n   vulnerable:
    an active attacker can force it to use a security\n   mechanism that is not mutually
    preferred but is acceptable to the\n   target.\n   This protocol provides the
    following guarantees when per-message\n   integrity services are available on
    the established mechanism\n   context, and the mechanism list was altered by an
    adversary such that\n   a mechanism that is not mutually preferred could be selected:\n
    \  a) If the last mechanism token is sent by the initiator, both peers\n      shall
    fail;\n   b) If the last mechanism token is sent by the acceptor, the acceptor\n
    \     shall not complete and the initiator, at worst, shall complete\n      with
    its preferred mechanism being selected.\n   The negotiation may not be terminated
    if an alteration was made but\n   had no material impact.\n   The protection of
    the negotiation depends on the strength of the\n   integrity protection.  In particular,
    the strength of SPNEGO is no\n   stronger than the integrity protection of the
    weakest mechanism\n   acceptable to GSS-API peers.\n   Note that where there exist
    multiple mechanisms with similar context\n   tokens, but different semantics,
    such that some or all of the\n   mechanisms' context tokens can be easily altered
    so that one\n   mechanism's context tokens may pass for another of the similar\n
    \  mechanism's context tokens, then there may exist a downgrade or\n   similar
    attacks.  For example, if a given family of mechanisms uses\n   the same context
    token syntax for two or more variants and depends on\n   the OID in the initial
    token's pseudo-ASN.1/DER wrapper, but does not\n   provide integrity protection
    for that OID, then there may exist an\n   attack against those mechanisms.  SPNEGO
    does not generally defeat\n   such attacks.\n   In all cases, the communicating
    peers are exposed to the denial of\n   service threat.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgments\n   The authors wish to thank Sam Hartman, Nicolas Williams,
    Ken Raeburn,\n   Martin Rex, Jeff Altman, Tom Yu, Cristian Ilac, Simon Spero,
    and Bill\n   Sommerfeld for their comments and suggestions during the development\n
    \  of this document.\n   Luke Howard provided a prototype of this protocol in
    Heimdal and\n   resolved several issues in the initial version of this document.\n
    \  Eric Baize and Denis Pinkas wrote the original SPNEGO specification\n   [RFC2478]
    of which some of the text has been retained in this\n   document.\n"
  title: 8.  Acknowledgments
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use in
      RFCs to Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2743] Linn, J., \"Generic Security Service Application Program\n
      \            Interface Version 2, Update 1\", RFC 2743, January 2000.\n   [X690]
      \   ASN.1 encoding rules: Specification of Basic Encoding Rules\n             (BER),
      Canonical Encoding Rules (CER) and Distinguished\n             Encoding Rules
      (DER), ITU-T Recommendation X.690 (1997) |\n             ISO/IEC International
      Standard 8825-1:1998.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC2478] Baize, E. and D. Pinkas, \"The Simple
      and Protected GSS-API\n             Negotiation Mechanism\", RFC 2478, December
      1998.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  SPNEGO ASN.1 Module\n   SPNEGOASNOneSpec {\n      iso(1) identified-organization(3)
    dod(6) internet(1)\n      security(5) mechanism(5) snego (2) modules(4) spec2(2)\n
    \  } DEFINITIONS EXPLICIT TAGS ::= BEGIN\n   MechType ::= OBJECT IDENTIFIER\n
    \      -- OID represents each security mechanism as suggested by\n       -- [RFC2743]\n
    \  MechTypeList ::= SEQUENCE OF MechType\n   NegotiationToken ::= CHOICE {\n       negTokenInit
    \   [0] NegTokenInit,\n       negTokenResp    [1] NegTokenResp\n   }\n   NegTokenInit
    ::= SEQUENCE {\n       mechTypes       [0] MechTypeList,\n       reqFlags        [1]
    ContextFlags  OPTIONAL,\n         -- inherited from RFC 2478 for backward compatibility,\n
    \        -- RECOMMENDED to be left out\n       mechToken       [2] OCTET STRING
    \ OPTIONAL,\n       mechListMIC     [3] OCTET STRING  OPTIONAL,\n       ...\n
    \  }\n   NegTokenResp ::= SEQUENCE {\n       negState       [0] ENUMERATED {\n
    \          accept-completed    (0),\n           accept-incomplete   (1),\n           reject
    \             (2),\n           request-mic         (3)\n       }                                 OPTIONAL,\n
    \        -- REQUIRED in the first reply from the target\n       supportedMech
    \  [1] MechType      OPTIONAL,\n         -- present only in the first reply from
    the target\n       responseToken   [2] OCTET STRING  OPTIONAL,\n       mechListMIC
    \    [3] OCTET STRING  OPTIONAL,\n       ...\n   }\n   ContextFlags ::= BIT STRING
    {\n       delegFlag       (0),\n       mutualFlag      (1),\n       replayFlag
    \     (2),\n       sequenceFlag    (3),\n       anonFlag        (4),\n       confFlag
    \       (5),\n       integFlag       (6)\n   } (SIZE (32))\n   END\n"
  title: Appendix A.  SPNEGO ASN.1 Module
- contents:
  - "Appendix B.  GSS-API Negotiation Support API\n   In order to provide to a GSS-API
    caller (the initiator or the target\n   or both) with the ability to choose among
    the set of supported\n   mechanisms, a reduced set of mechanisms for negotiation
    and two\n   additional APIs are defined:\n   o  GSS_Get_neg_mechs() indicates
    the set of security mechanisms\n      available on the local system to the caller
    for negotiation, for\n      which appropriate credentials are available.\n   o
    \ GSS_Set_neg_mechs() specifies the set of security mechanisms to be\n      used
    on the local system by the caller for negotiation, for the\n      given credentials.\n"
  - contents:
    - "B.1.  GSS_Set_neg_mechs Call\n   Inputs:\n   o  cred_handle CREDENTIAL HANDLE,
      -- NULL specifies default\n       -- credentials\n   o  mech_set SET OF OBJECT
      IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER\n
      \  Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the set of
      security mechanisms\n      available for negotiation has been set to mech_set.\n
      \  o  GSS_S_FAILURE indicates that the requested operation could not be\n      performed
      for reasons unspecified at the GSS-API level.\n   This allows callers to specify
      the set of security mechanisms that\n   may be negotiated with the credential
      identified by cred_handle.\n   This call is intended to support specialized
      callers who need to\n   restrict the set of negotiable security mechanisms from
      the set of\n   all security mechanisms available to the caller (based on available\n
      \  credentials).  Note that if more than one mechanism is specified in\n   mech_set,
      the order in which those mechanisms are specified implies a\n   relative preference.\n"
    title: B.1.  GSS_Set_neg_mechs Call
  - contents:
    - "B.2.  GSS_Get_neg_mechs Call\n   Input:\n   o  cred_handle CREDENTIAL HANDLE
      -- NULL specifies default --\n      credentials\n   Outputs:\n   o  major_status
      INTEGER,\n   o  minor_status INTEGER,\n   o  mech_set SET OF OBJECT IDENTIFIER\n
      \  Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the set of
      security mechanisms\n      available for negotiation has been returned in mech_set.\n
      \  o  GSS_S_FAILURE indicates that the requested operation could not be\n      performed
      for reasons unspecified at the GSS-API level.\n   This allows callers to determine
      the set of security mechanisms\n   available for negotiation with the credential
      identified by\n   cred_handle.  This call is intended to support specialized
      callers\n   who need to reduce the set of negotiable security mechanisms from
      the\n   set of supported security mechanisms available to the caller (based\n
      \  on available credentials).\n   Note: The GSS_Indicate_mechs() function indicates
      the full set of\n   mechanism types available on the local system.  Since this
      call has\n   no input parameter, the returned set is not necessarily available
      for\n   all credentials.\n"
    title: B.2.  GSS_Get_neg_mechs Call
  title: Appendix B.  GSS-API Negotiation Support API
- contents:
  - "Appendix C.  Changes since RFC 2478\n   SPNEGO implementations in Microsoft Windows
    2000/Windows XP/Windows\n   Server 2003 have the following behavior: no mechlistMIC
    is produced\n   and mechlistMIC is not processed if one is provided; if the initiator\n
    \  sends the last mechanism token, the acceptor will send back a\n   negotiation
    token with an accept_complete state and no mechlistMIC\n   token.  In addition,
    an incorrect OID (1.2.840.48018.1.2.2) can be\n   used to identify the GSS-API
    Kerberos Version 5 mechanism.\n   The following changes have been made to be compatible
    with these\n   legacy implementations.\n   *  NegTokenTarg is changed to negTokenResp
    and is the message format\n      for all subsequent negotiation tokens.\n   *
    \ NegTokenInit is the message for the initial negotiation message,\n      and
    only that message.\n   *  mechTypes in negTokenInit is not optional.\n   *  If
    the selected mechanism is also the most preferred mechanism for\n      both peers,
    it is safe to omit the MIC tokens.\n   If at least one of the two peers implements
    the updated pseudo\n   mechanism in this document, the negotiation is protected.\n
    \  The following changes are to address problems in RFC 2478.\n   *  reqFlags
    is not protected, therefore it should not impact the\n      negotiation.\n   *
    \ DER encoding is required.\n   *  GSS_GetMIC() input is clarified.\n   *  Per-message
    integrity services are requested for the negotiated\n      mechanism.\n   *  Two
    MIC tokens are exchanged, one in each direction.\n   An implementation that conforms
    to this specification will not\n   inter-operate with a strict RFC 2748 implementation.
    \ Even if the new\n   implementation always sends a mechlistMIC token, it will
    still fail\n   to inter-operate.  If it is a server, it will fail because it\n
    \  requests a mechlistMIC token using an option that older\n   implementations
    do not support.  Clients will tend to fail as well.\n   As an alternative to the
    approach chosen in this specification, we\n   could have documented a correct
    behavior that is fully backward\n   compatible with RFC 2478 and included an appendix
    on how to inter-\n   operate with existing incorrect implementations of RFC 2478.\n
    \  As a practical matter, the SPNEGO implementers within the IETF have\n   valued
    interoperability with the Microsoft implementations.  We were\n   unable to choose
    to maintain reasonable security guarantees, to\n   maintain interoperability with
    the Microsoft implementations, and to\n   maintain interoperability with correct
    implementations of RFC 2478.\n   The working group was not aware of any RFC 2478
    implementations\n   deployed on the Internet.  Even if there are such implementations,
    it\n   is unlikely that they will inter-operate because of a critical flaw\n   in
    the description of the encoding of the mechanism list in RFC 2478.\n   With the
    approach taken in this specification, security is ensured\n   between new implementations
    all the time while maintaining\n   interoperability with the implementations deployed
    within the IETF\n   community.  The working group believes that this justifies
    breaking\n   compatibility with a correct implementation of RFC 2478.\n"
  title: Appendix C.  Changes since RFC 2478
- contents:
  - "Appendix D.  mechListMIC Computation Example\n   The following is an example
    to illustrate how the mechListMIC field\n   would be computed.\n   The initial
    part of the DER encoding of NegTokenInit is constructed\n   as follows (the \"nn\"
    are length encodings, possibly longer than one\n   octet):\n      30 -- identifier
    octet for constructed SEQUENCE (NegTokenInit)\n      nn -- length\n         --
    contents octets of the SEQUENCE begin with\n         -- DER encoding of \"[0]
    MechTypeList\":\n         A0 -- identifier octet for constructed [0]\n         nn
    -- length\n             -- contents of the constructed [0] are DER encoding\n
    \            -- of MechTypeList (which is a SEQUENCE):\n             30 -- identifier
    octet for constructed SEQUENCE\n             nn -- length\n                --
    contents octets of the SEQUENCE begin with\n                -- DER encoding of
    OBJECT IDENTIFIER:\n                06 -- identifier octet for primitive OBJECT
    IDENTIFIER\n                09 -- length\n                2A 86 48 86 F7 12 01
    02 02 -- Kerberos V5\n                                           -- {1 2 840 113554
    1 2 2}\n   If a mechlistMIC needs to be generated (according to the rules in\n
    \  Section 5), it is computed by using the DER encoding of the type\n   MechTypeList
    data from the initiator's NegTokenInit token as input to\n   the GSS_GetMIC()
    function.  In this case, the MIC would be computed\n   over the following octets:\n
    \     DER encoding of MechTypeList:\n      30 nn 06 09 2A 86 48 86 F7 12 01 02
    02 ...\n   Note that the identifier octet and length octet(s) for constructed\n
    \  [0] (A0 nn) are not included in the MIC computation.\n"
  title: Appendix D.  mechListMIC Computation Example
- contents:
  - "Authors' Addresses\n   Larry Zhu\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA  98052\n   US\n   EMail: lzhu@microsoft.com\n   Paul Leach\n
    \  Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA  98052\n   US\n
    \  EMail: paulle@microsoft.com\n   Karthik Jaganathan\n   Microsoft Corporation\n
    \  One Microsoft Way\n   Redmond, WA  98052\n   US\n   EMail: karthikj@microsoft.com\n
    \  Wyllys Ingersoll\n   Sun Microsystems\n   1775 Wiehle Avenue, 2nd Floor\n   Reston,
    VA  20190\n   US\n   EMail: wyllys.ingersoll@sun.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
