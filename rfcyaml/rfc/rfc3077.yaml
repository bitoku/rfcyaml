- contents:
  - '       A Link-Layer Tunneling Mechanism for Unidirectional Links

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a mechanism to emulate full bidirectional\n
    \  connectivity between all nodes that are directly connected by a\n   unidirectional
    link.  The \"receiver\" uses a link-layer tunneling\n   mechanism to forward datagrams
    to \"feeds\" over a separate\n   bidirectional IP (Internet Protocol) network.
    \ As it is implemented\n   at the link-layer, protocols in addition to IP may
    also be supported\n   by this mechanism.\n"
  title: Abstract
- contents:
  - "1. Introduction\n   Internet routing and upper layer protocols assume that links
    are\n   bidirectional, i.e., directly connected hosts can communicate with\n   each
    other over the same link.\n   This document describes a link-layer tunneling mechanism
    that allows\n   a set of nodes (feeds and receivers, see Section 2 for terminology)\n
    \  which are directly connected by a unidirectional link to send\n   datagrams
    as if they were all connected by a bidirectional link.  We\n   present a generic
    topology in section 3 with a tunneling mechanism\n   that supports multiple feeds
    and receivers.  Note, this mechanism is\n   not designed for topologies where
    a pair of nodes are connected by 2\n   unidirectional links in opposite direction.\n
    \  The tunneling mechanism requires that all nodes have an additional\n   interface
    to an IP interconnected infrastructure.\n   The tunneling mechanism is implemented
    at the link-layer of the\n   interface of every node connected to the unidirectional
    link.  The\n   aim is to hide from higher layers, i.e., the network layer and
    above,\n   the unidirectional nature of the link.  The tunneling mechanism also\n
    \  includes an automatic tunnel configuration protocol that allows nodes\n   to
    come up/down at any time.\n   Generic Routing Encapsulation [RFC2784] is suggested
    as the tunneling\n   mechanism as it provides a means for carrying IP, ARP datagrams,
    and\n   any other layer-3 protocol between nodes.\n   The tunneling mechanism
    described in this document was discussed and\n   agreed upon by the UDLR working
    group.\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n
    \  SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this\n   document,
    are to be interpreted as described in [RFC2119].\n"
  title: 1. Introduction
- contents:
  - "2. Terminology\n   Unidirectional link (UDL): A one way transmission link, e.g.,
    a\n      broadcast satellite link.\n   Receiver: A router or a host that has receive-only
    connectivity to a\n      UDL.\n   Send-only feed: A router that has send-only
    connectivity to a UDL.\n   Receive capable feed: A router that has send-and-receive
    connectivity\n      to a UDL.\n   Feed: A send-only or a receive capable feed.\n
    \  Node: A receiver or a feed.\n   Bidirectional interface: a typical communication
    interface that can\n      send or receive packets, such as an Ethernet card, a
    modem, etc.\n"
  title: 2. Terminology
- contents:
  - "3. Topology\n   Feeds and receivers are connected via a unidirectional link.
    \ Send-\n   only feeds can only send data over this unidirectional link, and\n
    \  receivers can only receive data from it.  Receive capable feeds have\n   both
    send and receive capabilities.\n   This mechanism has been designed to work with
    any topology with any\n   number of receivers and one or more feeds.  However,
    it is expected\n   that the number of feeds will be small.  In particular, the
    special\n   case of a single send-only feed and multiple receivers is among the\n
    \  topologies supported.\n   A receiver has several interfaces, a receive-only
    interface and one\n   or more additional bidirectional communication interfaces.\n
    \  A feed has several interfaces, a send-only or a send-and-receive\n   capable
    interface connected to the unidirectional link and one or\n   more additional
    bidirectional communication interfaces.  A feed MUST\n   be a router.\n   Tunnels
    are constructed between the bidirectional interfaces of\n   nodes, so these interfaces
    must be interconnected by an IP\n   infrastructure.  In this document we assume
    that that infrastructure\n   is the Internet.\n   Figure 1 depicts a generic topology
    with several feeds and several\n   receivers.\n                     Unidirectional
    Link\n         ---->---------->------------------->------\n          |          |
    \              |           |\n          |f1u       |f2u            |r2u        |r1u\n
    \     --------   --------        --------    --------   ----------\n      |Feed
    1|   |Feed 2|        |Recv 2|    |Recv 1|---|subnet A|\n      --------   --------
    \       --------    --------   ----------\n          |f1b       |f2b            |r2b
    \       |r1b      |\n          |          |               |           |         |\n
    \        ----------------------------------------------------\n         |                     Internet
    \                    |\n         ----------------------------------------------------\n
    \                    Figure 1: Generic topology\n   f1u (resp. f2u) is the IP
    address of the 'Feed 1' (resp. Feed 2)\n       send-only interface.\n   f1b (resp.
    f2b) is the IP address of the 'Feed 1' (resp. Feed 2)\n       bidirectional interface
    connected to the Internet.\n   r1u (resp. r2u) is the IP address of the 'Receiver
    1' (resp. Receiver\n       2) receive-only interface.\n   r1b (resp. r2b) is the
    IP address of the 'Receiver 1' (resp. Receiver\n       2) bidirectional interface
    connected to the Internet.\n   Subnet A is a local area network connected to recv1.\n
    \  Note that nodes have IP addresses on their unidirectional and their\n   bidirectional
    interfaces.  The addresses on the unidirectional\n   interfaces (f1u, f2u, r1u,
    r2u) will be drawn from the same IP\n   network.  In general the addresses on
    the bidirectional interfaces\n   (f1b, f2b, r1b, r2b) will be drawn from different
    IP networks, and\n   the Internet will route between them.\n"
  title: 3. Topology
- contents:
  - "4. Problems related to unidirectional links\n   Receive-only interfaces are \"dumb\"
    and send-only interfaces are\n   \"deaf\".  Thus a datagram passed to the link-layer
    driver of a\n   receive-only interface is simply discarded.  The link-layer of
    a\n   send-only interface never receives anything.\n   The network layer has no
    knowledge of the underlying transmission\n   technology except that it considers
    its access as bidirectional.\n   Basically, for outgoing datagrams, the network
    layer selects the\n   correct first hop on the connected network according to
    a routing\n   table and passes the packet(s) to the appropriate link-layer driver.\n
    \  Referring to Figure 1, Recv 1 and Feed 1 belong to the same network.\n   However,
    if Recv 1 initiates a 'ping f1u', it cannot get a response\n   from Feed 1.  The
    network layer of Recv 1 delivers the packet to the\n   driver of the receive-only
    interface, which obviously cannot send it\n   to the feed.\n   Many protocols
    in the Internet assume that links are bidirectional.\n   In particular, routing
    protocols used by directly connected routers\n   no longer behave properly in
    the presence of a unidirectional link.\n"
  title: 4. Problems related to unidirectional links
- contents:
  - "5. Emulating a broadcast bidirectional network\n   The simplest solution is to
    emulate a broadcast capable link-layer\n   network.  This will allow the immediate
    deployment of existing higher\n   level protocols without change.  Though other
    network structures,\n   such as NBMA, could also be emulated, a broadcast network
    is more\n   generally useful.  Though a layer 3 network could be emulated, a\n
    \  link-layer network allows the immediate use of any other network\n   layer
    protocols, and most particularly allows the immediate use of\n   ARP.\n   A link-layer
    tunneling mechanism which emulates bidirectional\n   connectivity in the presence
    of a unidirectional link will be\n   described in the next Section.  We first
    consider the various\n   communication scenarios which characterize a broadcast
    network in\n   order to define what functionalities the link-layer tunneling\n
    \  mechanism has to perform in order to emulate a bidirectional\n   broadcast
    link.\n   Here we enumerate the scenarios which would be feasible on a\n   broadcast
    network, i.e., if feeds and receivers were connected by a\n   bidirectional broadcast
    link:\n   Scenario 1: A receiver can send a packet to a feed (point-to-point\n
    \     communication between a receiver and a feed).\n   Scenario 2: A receiver
    can send a broadcast/multicast packet on the\n      link to all nodes (point-to-multipoint).\n
    \  Scenario 3: A receiver can send a packet to another receiver (point-\n      to-point
    communication between two receivers).\n   Scenario 4: A feed can send a packet
    to a send-only feed (point-to-\n      point communication between two feeds).\n
    \  Scenario 5: A feed can send a broadcast/multicast packet on the link\n      to
    all nodes (point-to-multipoint).\n   Scenario 6: A feed can send a packet to a
    receiver or a receive\n      capable feed (point-to-point).\n   These scenarios
    are possible on a broadcast network.  Scenario 6 is\n   already feasible on the
    unidirectional link.  The link-layer\n   tunneling mechanism should therefore
    provide the functionality to\n   support scenarios 1 to 5.\n   Note that regular
    IP forwarding over such an emulated network (i.e.,\n   using the emulated network
    as a transit network) works correctly; the\n   next hop address at the receiver
    will be the unidirectional link\n   address of another router (a feed or a receiver)
    which will then\n   relay the packet.\n"
  title: 5. Emulating a broadcast bidirectional network
- contents:
  - "6. Link-layer tunneling mechanism\n   This link-layer tunneling mechanism operates
    underneath the network\n   layer.  Its aim is to emulate bidirectional link-layer
    connectivity.\n   This is transparent to the network layer: the link appears and\n
    \  behaves to the network layer as if it was bidirectional.\n   Figure 2 depicts
    a layered representation of the link-layer tunneling\n   mechanism in the case
    of Scenario 1.\n              Send-only Feed                       Receiver\n
    \              decapsulation                     encapsulation\n        /-----***************----\\
    \      /-->---***************--\\\n        |                        |       |
    \                      |\n        |                        |       |                       |\n
    \     --|----------------------  |       |  ---------------------|---\n      |
    |    f1b  |  f1u      |  |       |  |    x  r1u | r1b    |  |\n      | |         |
    \      ^   |  |   IP  |  |    |      |        v  |\n      | ^         |       |
    \  |  v       |  |    |      |        |  |\n      | |         |       |   |  |
    \      |  |    v      |        |  |\n      |-|---------|-------|---|  |       |
    \ |----|------|--------|--|\n      | |         |       |   |  |       ^  |    |
    \     |        |  |\n      | |         |       |   |  |   LL  |  |    |      |
    \       |  |\n      | |         |       |   |  |       |  |    |      |        |
    \ |\n      | |         |       O------/       \\<------O      |        |  |\n
    \     |-|---------|-----------|             |-----------|--------|--|\n      |
    |         |           |             |           |        |  |\n      | |         |
    \          |     PHY     |           |        |  |\n      | |         |           |
    \            |           |        v  |\n      | |         | |         |             |
    \        | |        |  |\n      --|-----------|----------             ----------|----------|---\n
    \       | Bidir     | Send-Only             Recv-Only |   Bidir  |\n        ^
    Interf    | Interf        UDL      Interf   |   Interf |\n        |           \\------------>------->------------/
    \         |\n        \\----------------------<------------------------<--------/\n
    \                            Bidirectional network\n     x : IP layer at the receiver
    generates a datagram to be forwarded\n         on the receive-only interface.\n
    \    O : Entry point where the link-layer tunneling mechanism is\n         triggered.\n
    \    Figure 2: Scenario 1 using the link-layer Tunneling Mechanism\n"
  - contents:
    - "6.1. Tunneling mechanism on the receiver\n   On the receiver, a datagram is
      delivered to the link-layer of the\n   unidirectional interface for transmission
      (see Figure 2).  It is then\n   encapsulated within a MAC header corresponding
      to the unidirectional\n   link.  This packet cannot be sent directly over the
      link, so it is\n   then processed by the tunneling mechanism.\n   The packet
      is encapsulated within an IP header whose destination is\n   the IP address
      of a feed bidirectional interface (f1b or f2b).  This\n   destination address
      is also called the tunnel end-point.  The\n   mechanism for a receiver to learn
      these addresses and to choose the\n   feed is explained in Section 7.  The type
      of encapsulation is\n   described in Section 8.\n   In all cases the packet
      is encapsulated, but the tunnel end-point (an\n   IP address) depends on the
      encapsulated packet's destination MAC\n   address.  If the destination MAC address
      is:\n      1) the MAC address of a feed interface connected to the\n         unidirectional
      link (Scenario 1).  The datagram is\n         encapsulated, the destination
      address of the encapsulating\n         datagram is the feed tunnel end-point
      (f1b referring to Figure\n         2).\n      2) a MAC broadcast/multicast address
      (Scenario 2).  The datagram\n         is encapsulated, the destination address
      of the encapsulating\n         datagram is the default feed tunnel end-point.
      \ See Section 7.4\n         for further details on the default feed.\n      3)
      a MAC address that belongs to the unidirectional network but is\n         not
      a feed address (Scenario 3).  The datagram is encapsulated,\n         the destination
      address of the encapsulating datagram is the\n         default feed tunnel end-point.\n
      \  The encapsulated datagram is passed to the network layer which\n   forwards
      it according to its destination address.  The destination\n   address is a feed
      bidirectional interface which is reachable via the\n   Internet.  In this case,
      the encapsulated datagram is forwarded via\n   the receiver bidirectional interface
      (r1b).\n"
    title: 6.1. Tunneling mechanism on the receiver
  - contents:
    - "6.2. Tunneling mechanism on the feed\n   A feed processes unidirectional link
      related packets in two different\n   ways:\n   -  packets generated by a local
      application or packets routed as\n      usual by the IP layer may have to be
      forwarded over the\n      unidirectional link (Section 6.2.1)\n   -  encapsulated
      packets received from another receiver or feed need\n      tunnel processing
      (Section 6.2.2).\n   A feed cannot directly send a packet to a send-only feed
      over the\n   unidirectional link (Scenario 4).  In order to emulate this type
      of\n   communication, feeds have to tunnel packets to send-only feeds.  A\n
      \  feed MUST maintain a list of all other feed tunnel end-points.  This\n   list
      MUST indicate which are send-only feed tunnel end-points.  This\n   is configured
      manually at the feed by the local administrator, as\n   described in Section
      7.\n"
    - contents:
      - "6.2.1. Forwarding packets over the unidirectional link\n   When a datagram
        is delivered to the link-layer of the unidirectional\n   interface of a feed
        for transmission, its treatment depends on the\n   packet's destination MAC
        address.  If the destination MAC address is:\n      1) the MAC address of
        a receiver or a receive capable feed\n         (Scenario 6).  The packet is
        sent over the unidirectional link.\n         This is classical \"forwarding\".\n
        \     2) the MAC address of a send-only feed (Scenario 4).  The packet\n         is
        encapsulated and sent to the send-only feed tunnel end-\n         point.  The
        type of encapsulation is described in Section 8.\n      3) a broadcast/multicast
        destination (Scenario 5).  The packet is\n         sent over the unidirectional
        link.  Concurrently, a copy of\n         this packet is encapsulated and sent
        to every feed of the list\n         of send-only feed tunnel end-points.  Thus
        the\n         broadcast/multicast will reach all receivers and all send-only\n
        \        feeds.\n"
      title: 6.2.1. Forwarding packets over the unidirectional link
    - contents:
      - "6.2.2. Receiving encapsulated packets\n   Feeds listen for incoming encapsulated
        datagrams on their tunnel\n   end-points.  Encapsulated packets will have
        been received on a\n   bidirectional interface, and traversed their way up
        the IP stack.\n   They will then enter a decapsulation process (See Figure
        2).\n   Decapsulation reveals the original link-layer packet.  Note that this\n
        \  has not been modified in any way by intermediate routers; in\n   particular,
        the original MAC header will be intact.\n   Further actions depend on the
        destination MAC address of the link-\n   layer packet, which can be:\n      1)
        the MAC address of the feed interface connected to the\n         unidirectional
        link, i.e., own MAC address (Scenarios 1 and 4).\n         The packet is passed
        to the link-layer of the interface\n         connected to the unidirectional
        link which can then deliver it\n         up to higher layers.  As a result,
        the datagram is processed as\n         if it was coming from the unidirectional
        link, and being\n         delivered locally.  Scenarios 1 and 4 are now feasible,
        a\n         receiver or a feed can send a packet to a feed.\n      2) a receiver
        address (Scenario 3).  The packet is passed to the\n         link-layer of
        the interface connected to the unidirectional\n         link.  It is directly
        sent over the unidirectional link, to the\n         indicated receiver.  Note,
        the packet must not be delivered\n         locally.  Scenario 3 is now feasible,
        a receiver can send a\n         packet to another receiver.\n      3) a broadcast/multicast
        address, this corresponds to Scenarios 2\n         and 5.  We have to distinguish
        two cases, either (i) the\n         encapsulated packet was sent from a receiver
        or (ii) from a\n         feed (encapsulated broadcast/multicast packet sent
        to a send-\n         only feed).  These cases are distinguished by examining
        the\n         source address of the encapsulating packet and comparing it\n
        \        with the configured list of feed IP addresses.  The action then\n
        \        taken is:\n         i) the feed was designated as a default feed
        by a receiver to\n            forward the broadcast/multicast packet.  The
        feed is then in\n            charge of sending the multicast packet to all
        nodes.\n            Delivery to all nodes is accomplished by executing all
        3 of\n            the following actions:\n            -  The packet is encapsulated
        and sent to the list of send-\n               only feed tunnel end-points.\n
        \           -  Also, the packet is passed to the link-layer of the\n               interface
        which forwards it directly over the\n               unidirectional link (all
        receivers and receive capable\n               feeds receive it).\n            -
        \ Also, the link-layer delivers it locally to higher\n               layers.\n
        \           Caution: a receiver which sends an encapsulated\n            broadcast/multicast
        packet to a default feed will receive\n            its own packet via the
        unidirectional link.  Correct\n            filtering as described in [RFC1112]
        must be applied.\n        ii) the feed receives the packet and keeps it for
        local\n            delivery.  The packet is passed to the link-layer of the\n
        \           interface connected to the unidirectional link which\n            delivers
        it to higher layers.\n         Scenario 2 is now feasible, a receiver can
        send a\n         broadcast/multicast packet over the unidirectional link and
        it\n         will be heard by all nodes.\n"
      title: 6.2.2. Receiving encapsulated packets
    title: 6.2. Tunneling mechanism on the feed
  title: 6. Link-layer tunneling mechanism
- contents:
  - "7. Dynamic Tunnel Configuration Protocol (DTCP)\n   Receivers and feeds have
    to know the feed tunnel end-points in order\n   to forward encapsulated datagrams
    (e.g., Scenarios 1 and 4).\n   The number of feeds is expected to be relatively
    small (Section 3),\n   so at every feed the list of all feeds is configured manually.
    \ This\n   list should note which are send-only feeds, and which are receive\n
    \  capable feeds.  The administrator sets up tunnels to all send-only\n   feeds.
    \ A tunnel end-point is an IP address of a bidirectional link\n   on a send-only
    feed.\n   For scalability reasons, manual configuration cannot be done at the\n
    \  receivers.  Tunnels must be configured and maintained dynamically by\n   receivers,
    both for scalability, and in order to cope with the\n   following events:\n      1)
    New feed detection.\n         When a new feed comes up, every receiver must create
    a tunnel\n         to enable bidirectional communication with it.\n      2) Loss
    of unidirectional link detection.\n         When the unidirectional link is down,
    receivers must disable\n         their tunnels.  The tunneling mechanism emulates
    bidirectional\n         connectivity between nodes.  Therefore, if the unidirectional\n
    \        link is down, a feed should not receive datagrams from the\n         receivers.
    \ Protocols that consider a link as operational if\n         they receive datagrams
    from it (e.g., the RIP protocol\n         [RFC2453]) require this behavior for
    correct operation.\n      3) Loss of feed detection.\n         When a feed is
    down, receivers must disable their corresponding\n         tunnel.  This prevents
    unnecessary datagrams from being\n         tunneled which might overload the Internet.
    \ For instance,\n         there is no need for receivers to forward a broadcast
    message\n         through a tunnel whose end-point is down.\n   The DTCP protocol
    provides a means for receivers to dynamically\n   discover the presence of feeds
    and to maintain a list of operational\n   tunnel end-points.  Feeds periodically
    announce their tunnel end-\n   point addresses over the unidirectional link.  Receivers
    listen to\n   these announcements and maintain a list of tunnel end-points.\n"
  - contents:
    - "7.1. The HELLO message\n   The DTCP protocol is a 'unidirectional protocol',
      messages are only\n   sent from feeds to receivers.\n   The packet format is
      shown in Figure 3.  Fields contain binary\n   integers, in normal Internet order
      with the most significant bit\n   first.  Each tick mark represents one bit.\n
      \  0                   1                   2                   3\n   0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Vers  |  Com  |    Interval   |           Sequence            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | res |F|IP Vers|  Tunnel Type  |   Nb of FBIP  |    reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                   Feed  BDL IP addr (FBIP1)    (32/128 bits)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                             .....                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                   Feed  BDL IP addr (FBIPn)    (32/128 bits)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      Figure 3: Packet Format\n   Every datagram contains the
      following fields, note that constants are\n   written in uppercase and are defined
      in Section 7.5:\n   Vers (4 bit unsigned integer): DTCP version number.  MUST
      be\n      DTCP_VERSION.\n   Com (4 bit unsigned integer): Command field, possible
      values are\n      1 - JOIN   A message announcing that the feed sending this
      message\n           is up and running.\n      2 - LEAVE  A message announcing
      that the feed sending this message\n           is being shut down.\n   Interval
      (8 bit unsigned integer): Interval in seconds between HELLO\n      messages
      for the IP protocol in \"IP Vers\".  Must be > 0.  The\n      recommended value
      is HELLO_INTERVAL.  If this value is increased,\n      the feed MUST continue
      to send HELLO messages at the old rate for\n      at least the old HELLO_LEAVE
      period.\n   Sequence (16 bit unsigned integer): Random value initialized at
      boot\n      time and incremented by 1 every time a value of the HELLO message\n
      \     is modified.\n   res (3 bits): Reserved/unused field, MUST be zero.\n
      \  F (1 bit): bit indicating the type of feed:\n      0 = Send-only feed\n      1
      = Receive-capable feed\n   IP Vers (4 bit unsigned integer): IP protocol version
      of the feed\n      bidirectional IP addresses (FBIP):\n      4 = IP version
      4\n      6 = IP version 6\n   Tunnel Type (8 bit unsigned integer): tunneling
      protocol supported by\n      the feed.  This value is the IP protocol number
      defined in\n      [RFC1700] [iana/protocol-numbers] and their legitimate\n      descendents.
      \ Receivers MUST use this form of tunnel encapsulation\n      when tunneling
      to the feed.\n      47 = GRE [RFC2784] (recommended)\n      Other protocol types
      allowing link-layer encapsulation are\n      permitted.  Obtaining new values
      is documented in [RFC2780].\n   Nb of FBIP (8 bit unsigned integer): Number
      of bidirectional IP feed\n      addresses which are enumerated in the HELLO
      message\n   reserved (8 bits): Reserved/unused field, MUST be zero.\n   Feed
      BDL IP addr (32 or 128 bits).  The bidirectional IP address feed\n      is the
      IP address of a feed bidirectional interface (tunnel end-\n      point) reachable
      via the Internet.  A feed has 'Nb of FBIP' IP\n      addresses which are operational
      tunnel end-points.  They are\n      enumerated in preferred order.  FBIP1 being
      the most suitable\n      tunnel end-point.\n"
    title: 7.1. The HELLO message
  - contents:
    - "7.2. DTCP on the feed: sending HELLO packets\n   The DTCP protocol runs on
      top of UDP.  Packets are sent to the \"DTCP\n   announcement\" multicast address
      over the unidirectional link on port\n   HELLO_PORT with a TTL of 1.  Due to
      existing deployments a feed\n   SHOULD also support the use of the old DTCP
      announcement address, as\n   described in Appendix B.\n   The source address
      of the HELLO packet is set to the IP address of\n   the feed interface connected
      to the unidirectional link.  In the rest\n   of the document, this value is
      called FUIP (Feed Unidirectional IP\n   address).\n   The process in charge
      of sending HELLO packets fills every field of\n   the datagram according to
      the description given in Section 7.1.\n   As long as a feed is up and running,
      it periodically announces its\n   presence to receivers.  It MUST send HELLO
      packets containing a JOIN\n   command every HELLO_INTERVAL over the unidirectional
      link.\n   Referring to Figure 1 in Section 3, Feed 1 (resp. Feed 2) sends HELLO\n
      \  messages with the FBIP1 field set to f1b (resp. f2b).\n   When a feed is
      about to be shut down, or when routing over the\n   unidirectional link is about
      to be intentionally interrupted, it is\n   recommended that feeds:\n      1)
      stop sending HELLO messages containing a JOIN command.\n      2) send a HELLO
      message containing a LEAVE command to inform\n         receivers that the feed
      is no longer performing routing over\n         the unidirectional link.\n"
    title: '7.2. DTCP on the feed: sending HELLO packets'
  - contents:
    - "7.3. DTCP on the receiver: receiving HELLO packets\n   Based on the reception
      of HELLO messages, receivers discover the\n   presence of feeds, maintain a
      list of active feeds, and keep track of\n   the tunnel end-points for those
      feeds.\n   For each active feed, and each IP protocol supported, at least the\n
      \  following information will be kept:\n      FUIP              - feed unidirectional
      link IP address\n      FUMAC             - MAC address corresponding to the
      above IP\n                          address\n      (FBIP1,...,FBIPn) - list
      of tunnel end-points\n      tunnel type       - tunnel type supported by this
      feed\n      Sequence          - \"Sequence\" value from the last HELLO received\n
      \                         from this feed\n      timer             - used to
      timeout this entry\n   The FUMAC value for an active feed is needed for the
      operation of\n   this protocol.  However, the method of discovery of this value
      is not\n   specified here.\n   Initially, the list of active feeds is empty.\n
      \  When a receiver is started, it MUST run a process which joins the\n   \"DTCP
      announcement\" multicast group and listens to incoming packets\n   on the HELLO_PORT
      port from the unidirectional link.\n   Upon the reception of a HELLO message,
      the process checks the version\n   number of the protocol.  If it is different
      from HELLO_VERSION, the\n   packet is discarded and the process waits for the
      next incoming\n   packet.\n   After successfully checking the version number
      further action depends\n   on the type of command:\n   -  JOIN:\n      The process
      verifies if the address FUIP already belongs to the\n      list of active feeds.\n
      \     If it does not, a new entry, for feed FUIP, is created and added\n      to
      the list of active feeds.  The number of feed bidirectional IP\n      addresses
      to read is deduced from the 'Nb of FBID' field.  These\n      tunnel end-points
      (FBIP1,...,FBIPn) can then be added to the new\n      entry.  The tunnel Type
      and Sequence values are also taken from\n      the HELLO packet and recorded
      in the new entry.  A timer set to\n      HELLO_LEAVE is associated with this
      entry.\n      If it does, the sequence number is compared to the sequence number\n
      \     contained in the previous HELLO packet sent by this feed.  If they\n      are
      equal, the timer associated with this entry is reset to\n      HELLO_LEAVE.
      \ Otherwise all the information corresponding to FUIP\n      is set to the values
      from the HELLO packet.\n      Referring to Figure 1 in Section 3, both receivers
      (recv 1 and\n      recv 2) have a list of active feeds containing two entries:
      Feed 1\n      with a FUIP of f1u and a list of tunnel end-points (f1b); and
      Feed\n      2 with a FUIP of f2u and a list of tunnel end-points (f2b).\n   -
      \ LEAVE:\n      The process checks if there is an entry for FUIP in the list
      of\n      active feeds.  If there is, the timer is disabled and the entry is\n
      \     deleted from the list.  The LEAVE message provides a means of\n      quickly
      updating the list of active feeds.\n   A timeout occurs for either of two reasons:\n
      \     1) a feed went down without sending a LEAVE message.  As JOIN\n         messages
      are no longer sent from this feed, a timeout occurs at\n         HELLO_LEAVE
      after the last JOIN message.\n      2) the unidirectional link is down.  Thus
      no more JOIN messages\n         are received from any of the feeds, and they
      will each timeout\n         independently.  The timeout of each entry depends
      on its\n         individual HELLO_LEAVE value, and when the last JOIN message\n
      \        was sent by that feed, before the unidirectional link went\n         down.\n
      \  In either case, bidirectional connectivity can no longer be ensured\n   between
      the receiver and the feed (FUIP): either the feed is no\n   longer routing datagrams
      over the unidirectional link, or the link is\n   down.  Thus the associated
      entry is removed from the list of active\n   feeds, whatever the cause.  As
      a result, the list only contains\n   operational tunnel end-points.\n   The
      HELLO protocol provides receivers with a list of feeds, and a\n   list of usable
      tunnel end-points (FBIP1,..., FBIPn) for each feed.\n   In the following Section,
      we describe how to integrate the HELLO\n   protocol into the tunneling mechanism
      described in Sections 6.1 and\n   6.2.\n"
    title: '7.3. DTCP on the receiver: receiving HELLO packets'
  - contents:
    - "7.4. Tunneling mechanism using the list of active feeds\n   This Section explains
      how the tunneling mechanism uses the list of\n   active feeds to handle datagrams
      which are to be tunneled.  Referring\n   to Section 6.1, it shows how feed tunnel
      end-points are selected.\n   The choice of the default feed is made independently
      at each\n   receiver.  The choice is a matter of local policy, and this policy
      is\n   out of scope for this document.  However, as an example, the default\n
      \  feed may be the feed that has the lowest round trip time to the\n   receiver.\n
      \  When a receiver sends a packet to a feed, it must choose a tunnel\n   end-point
      from within the FBIP list.  The 'preferred FBIP' is\n   generally FBIP1 (Section
      7.1).  For various reasons, a receiver may\n   decide to use a different FBIP,
      say FBIPi instead of FBIP1, as the\n   tunnel end-point.  For example, the receiver
      may have better\n   connectivity to FBIPi.  This decision is taken by the receiver\n
      \  administrator.\n   Here we show how the list of active feeds is involved
      when a receiver\n   tunnels a link-layer packet.  Section 6.1 listed the following
      cases,\n   depending on whether the MAC destination address of the packet is:\n
      \     1) the MAC address of a feed interface connected to the\n         unidirectional
      link: This is TRUE if the address matches a\n         FUMAC address in the list
      of active feeds.  The packet is\n         tunneled to the preferred FBIP of
      the matching feed.\n      2) the broadcast address of the unidirectional link
      or a multicast\n         address:\n         This is determined by the MAC address
      format rules, and the\n         list of active feeds is not involved.  The packet
      is tunneled\n         to the preferred FBIP of the default feed.\n      3) an
      address that belongs to the unidirectional network but is\n         not a feed
      address:\n         This is TRUE if the address is neither broadcast nor multicast,\n
      \        nor found in the list of active feeds.  The packet is tunneled\n         to
      the preferred FBIP of the default feed.\n   In all cases, the encapsulation
      type depends on the tunnel type\n   required by the feed which is selected.\n"
    title: 7.4. Tunneling mechanism using the list of active feeds
  - contents:
    - "7.5. Constant definitions\n   DTCP_VERSION is 1.\n   HELLO_INTERVAL is 5 seconds.\n
      \  \"DTCP announcement\" multicast group is 224.0.0.36, assigned by IANA.\n
      \  HELLO_PORT is 652.  It is a reserved system port assigned by IANA, no\n      other
      traffic must be allowed.\n   HELLO_LEAVE is 3*Interval, as advertised in a HELLO
      packet, i.e., 15\n      seconds if the default HELLO_INTERVAL was advertised.\n"
    title: 7.5. Constant definitions
  title: 7. Dynamic Tunnel Configuration Protocol (DTCP)
- contents:
  - "8. Tunnel encapsulation format\n   The tunneling mechanism operates at the link-layer
    and emulates\n   bidirectional connectivity amongst receivers and feeds.  We assume\n
    \  that hardware connected to the unidirectional link supports broadcast\n   and
    unicast MAC addressing.  That is, a feed can send a packet to a\n   particular
    receiver using a unicast MAC destination address or to a\n   set of receivers
    using a broadcast/multicast destination address.\n   The hardware (or the driver)
    of the receiver can then filter the\n   incoming packets sent over the unidirectional
    links without any\n   assumption about the encapsulated data type.\n   In a similar
    way, a receiver should be capable of sending unicast and\n   broadcast MAC packets
    via its tunnels.  Link-layer packets are\n   encapsulated.  As a result, after
    decapsulating an incoming packet,\n   the feed can perform link-layer filtering
    as if the data came\n   directly from the unidirectional link (See Figure 2).\n
    \  Generic Routing Encapsulation (GRE) [RFC2784] suits our requirements\n   because
    it specifies a protocol for encapsulating arbitrary packets,\n   and allows use
    of IP as the delivery protocol.\n   The feed's local administrator decides what
    encapsulation it will\n   demand that receivers use, and sets the tunnel type
    field in the\n   HELLO message appropriately.  The value 47 (decimal) indicates
    GRE.\n   Other values can be used, but their interpretation must be agreed\n   upon
    between feeds and receivers.  Such usage is not defined here.\n"
  - contents:
    - "8.1. Generic Routing Encapsulation on the receiver\n   A GRE packet is composed
      of a header in which a type field specifies\n   the encapsulated protocol (ARP,
      IP, IPX, etc.).  See [RFC2784] for\n   details about the encapsulation.  In
      our case, only support for the\n   MAC addressing scheme of the unidirectional
      link MUST be implemented.\n   A packet tunneled with a GRE encapsulation has
      the following format:\n   the delivery header is an IP header whose destination
      is the tunnel\n   end-point (FBIP), followed by a GRE header specifying the
      link-layer\n   type of the unidirectional link.  Figure 4 presents the entire\n
      \  encapsulated packet.\n            ----------------------------------------\n
      \           |           IP delivery header         |\n            |        destination
      addr = FBIP       |\n            |          IP proto = GRE (47)         |\n
      \           ----------------------------------------\n            |             GRE
      Header               |\n            |      type = MAC type of the UDL      |\n
      \           ----------------------------------------\n            |            Payload
      packet            |\n            |             MAC packet               |\n
      \           ----------------------------------------\n                  Figure
      4: Encapsulated packet\n"
    title: 8.1. Generic Routing Encapsulation on the receiver
  title: 8. Tunnel encapsulation format
- contents:
  - '9. Issues

    '
  - contents:
    - "9.1. Hardware address resolution\n   Regardless of whether the link is unidirectional
      or bidirectional, if\n   a feed sends a packet over a non-point-to-point type
      network, it\n   requires the data link address of the destination.  ARP [RFC826]
      is\n   used on Ethernet networks for this purpose.\n   The link-layer mechanism
      emulates a bidirectional network in the\n   presence of an unidirectional link.
      \ However, there are asymmetric\n   delays between every (feed, receiver) pair.
      \ The backchannel between\n   a receiver and a feed has varying delays because
      packets go through\n   the Internet.  Furthermore, a typical example of a unidirectional\n
      \  link is a GEO satellite link whose delay is about 250 milliseconds.\n   Because
      of long round trip delays, reactive address resolution\n   methods such as ARP
      [RFC826] may not work well.  For example, a feed\n   may have to forward packets
      at high data rates to a receiver whose\n   hardware address is unknown.  The
      stream of packets is passed to the\n   link-layer driver of the feed send-only
      interface.  When the first\n   packet arrives, the link-layer realizes it does
      not have the\n   corresponding hardware address of the next hop, and sends an
      ARP\n   request.  While the link-layer is waiting for the response (at least\n
      \  250 ms for the GEO satellite case), IP packets are buffered by the\n   feed.
      \ If it runs out of space before the ARP response arrives, IP\n   packets will
      be dropped.\n   This problem of address resolution protocols is not addressed
      in this\n   document.  An ad-hoc solution is possible when the MAC address is\n
      \  configurable, which is possible in some satellite receiver cards.  A\n   simple
      transformation (maybe null) of the IP address can then be used\n   as the MAC
      address.  In this case, senders do not need to \"resolve\"\n   an IP address
      to a MAC address, they just need to perform the simple\n   transformation.\n"
    title: 9.1. Hardware address resolution
  - contents:
    - "9.2. Routing protocols\n   The link-layer tunneling mechanism hides from the
      network and higher\n   layers the fact that feeds and receivers are connected
      by a\n   unidirectional link.  Communication is bidirectional, but asymmetric\n
      \  in bandwidths and delays.\n   In order to incorporate unidirectional links
      in the Internet, feeds\n   and receivers might have to run routing protocols
      in some topologies.\n   These protocols will work fine because the tunneling
      mechanism\n   results in bidirectional connectivity between all feeds and\n
      \  receivers.  Thus routing messages can be exchanged as on any\n   bidirectional
      network.\n   The tunneling mechanism allows any IP traffic, not just routing\n
      \  protocol messages, to be forwarded between receivers and feeds.\n   Receivers
      can route datagrams on the Internet using the most suitable\n   feed or receiver
      as a next hop.  Administrators may want to set the\n   metrics used by their
      routing protocols in order to reflect in\n   routing tables the asymmetric characteristics
      of the link, and thus\n   direct traffic over appropriate paths.\n   Feeds and
      receivers may implement multicast routing and therefore\n   dynamic multicast
      routing can be performed over the unidirectional\n   link.  However issues related
      to multicast routing (e.g., protocol\n   configuration) are not addressed in
      this document.\n"
    title: 9.2. Routing protocols
  - contents:
    - "9.3. Scalability\n   The DTCP protocol does not generate a lot of traffic whatever
      the\n   number of nodes.  The problem with a large number of nodes is not\n
      \  related to this protocol but to more general issues such as the\n   maximum
      number of nodes which can be connected to any link.  This is\n   out of scope
      of this document.\n"
    title: 9.3. Scalability
  title: 9. Issues
- contents:
  - "10. IANA Considerations\n   IANA has reserved the address 224.0.0.36 for the
    \"DTCP announcement\"\n   multicast address as defined in Section 7.\n   IANA
    has reserved the udp port 652 for the HELLO_PORT as defined in\n   Section 7.\n"
  title: 10. IANA Considerations
- contents:
  - "11. Security Considerations\n   Many unidirectional link technologies are characterised
    by the ease\n   with which the link contents can be received.  If sensitive or\n
    \  valuable information is being sent, then link-layer security\n   mechanisms
    are an appropriate measure.  For the UDLR protocol itself,\n   the feed tunnel
    end-point addresses, sent in HELLO messages, may be\n   considered sensitive.
    \ In such cases link-layer security mechanisms\n   may be used.\n   Security in
    a network using the link-layer tunneling mechanism should\n   be relatively similar
    to security in a normal IPv4 network.  However,\n   as the link-layer tunneling
    mechanism requires the use of tunnels, it\n   introduces a potential for unauthorised
    access to the service.  In\n   particular, ARP and IP spoofing are potential threats
    because nodes\n   may not be authorised to tunnel packets.  This can be countered
    by\n   authenticating all tunnels.  The authenticating mechanism is not\n   specified
    in this document, it can take place either in the delivery\n   IP protocol (e.g.,
    AH[RFC2402]) or in an authentication protocol\n   integrated with the tunneling
    mechanism.\n   At a higher level, receivers may not be authorised to provide routing\n
    \  information even though they are connected to the unidirectional\n   link.
    \ In order to prevent unauthorised receivers from providing fake\n   routing information,
    routing protocols running on top of the link-\n   layer tunneling mechanism MUST
    use authentication mechanisms when\n   available.\n"
  title: 11. Security Considerations
- contents:
  - "12. Acknowledgments\n   We would like to thank Tim Gleeson (Cisco Japan) for
    his valuable\n   editing and technical input during the finalization phase of
    the\n   document.\n   We would like to thank Patrick Cipiere (UDcast) for his
    valuable\n   input concerning the design of the encapsulation mechanism.\n   We
    would like also to thank for their participation: Akihiro Tosaka\n   (IMD), Akira
    Kato (Tokyo Univ.), Hitoshi Asaeda (IBM/ITS), Hiromi\n   Komatsu (JSAT), Hiroyuki
    Kusumoto (Keio Univ.), Kazuhiro Hara (Sony),\n   Kenji Fujisawa (Sony), Mikiyo
    Nishida (Keio Univ.), Noritoshi Demizu\n   (Sony CSL), Jun Murai (Keio Univ.),
    Jun Takei (JSAT) and Harri\n   Hakulinen (Nokia).\n"
  title: 12. Acknowledgments
- contents:
  - "Appendix A: Conformance and interoperability\n   This document describes a mechanism
    to emulate bidirectional\n   connectivity between nodes that are directly connected
    by a\n   unidirectional link.  Applicability over a variety of equipment and\n
    \  environments is ensured by allowing a choice of several key system\n   parameters.\n
    \  Thus in order to ensure interoperability of equipment it is not\n   enough
    to simply claim conformance with the mechanism defined here.\n   A usage profile
    for a particular environment will require the\n   definition of several parameters:\n
    \     - the MAC format used\n      - the tunneling mechanism to be used (GRE is
    recommended)\n      - the \"tunnel type\" indication if GRE is not used\n   For
    example, a system might claim to implement \"the link-layer\n   tunneling mechanism
    for unidirectional links, using IEEE 802 LLC, and\n   GRE encapsulation for the
    tunnels.\"\n"
  title: 'Appendix A: Conformance and interoperability'
- contents:
  - "Appendix B: DTCP announcement address transition plan\n   Some older receivers
    listen for DTCP announcements on the 224.0.1.124\n   multicast address (the \"old
    DTCP announcement\" address).  In order to\n   support such legacy receivers,
    feeds SHOULD be configurable to send\n   all announcements simultaneously to both
    the \"DTCP announcement\"\n   address, and the \"old DTCP announcement\" address.
    \ The default\n   setting is to send announcements to just the \"DTCP announcement\"\n
    \  address.\n   In order to encourage the transition plan, the \"old\" feeds MUST
    be\n   updated to send DTCP announcements as defined in this section.  The\n   number
    of \"old\" feeds originally deployed is relatively small and\n   therefore the
    update should be fairly easy.  \"New\" receivers only\n   support \"new\" feeds,
    i.e., they listen to DTCP announcements on the\n   \"DTCP announcement\" address.\n"
  title: 'Appendix B: DTCP announcement address transition plan'
- contents:
  - "References\n   [RFC826]  Plummer, D., \"An Ethernet Address Resolution Protocol\",
    STD\n             37, RFC 826, November 1982.\n   [RFC1112] Deering, S., \"Host
    Extensions for IP Multicasting\", STD 5,\n             RFC 1112, August 1989\n
    \  [RFC1700] Reynolds, J. and J. Postel, \"ASSIGNED NUMBERS\", STD 2, RFC\n             1700,
    October 1994.\n   [RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate\n
    \            Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2402]
    Kent, S. and R. Atkinson, \"IP Authentication Header\", RFC\n             2402,
    November 1998.\n   [RFC2453] Malkin, G., \"RIP Version 2\", STD 56, RFC 2453,
    November\n             1998.\n   [RFC2780] Bradner, S. and V. Paxson, \"IANA Allocation
    Guidelines For\n             Values In the Internet Protocol and Related Headers\",
    BCP\n             37, RFC 2780, March 2000.\n   [RFC2784] Farinacci, D., Hanks,
    S., Meyer, D. and P. Traina, \"Generic\n             Routing Encapsulation (GRE)\",
    RFC 2784, March 2000.\n"
  title: References
- contents:
  - "Authors' Addresses\n   Emmanuel Duros\n   UDcast\n   1681, route des Dolines\n
    \  Les Taissounieres - BP 355\n   06906 Sophia-Antipolis Cedex\n   France\n   Phone
    : +33 4 93 00 16 60\n   Fax   : +33 4 93 00 16 61\n   EMail : Emmanuel.Duros@UDcast.com\n
    \  Walid Dabbous\n   INRIA Sophia Antipolis\n   2004, Route des Lucioles BP 93\n
    \  06902 Sophia Antipolis\n   France\n   Phone : +33 4 92 38 77 18\n   Fax   :
    +33 4 92 38 79 78\n   EMail : Walid.Dabbous@inria.fr\n   Hidetaka Izumiyama\n
    \  JSAT Corporation\n   Toranomon 17 Mori Bldg.5F\n   1-26-5 Toranomon, Minato-ku\n
    \  Tokyo 105\n   Japan\n   Phone : +81-3-5511-7568\n   Fax   : +81-3-5512-7181\n
    \  EMail : izu@jsat.net\n   Noboru Fujii\n   Sony Corporation\n   2-10-14 Osaki,
    Shinagawa-ku\n   Tokyo 141\n   Japan\n   Phone : +81-3-3495-3092\n   Fax   : +81-3-3495-3527\n
    \  EMail : fujii@dct.sony.co.jp\n   Yongguang Zhang\n   HRL\n   RL-96, 3011 Malibu
    Canyon Road\n   Malibu, CA 90265,\n   USA\n   Phone : 310-317-5147\n   Fax   :
    310-317-5695\n   EMail : ygz@hrl.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
