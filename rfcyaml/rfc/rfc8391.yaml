- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                          A. Huelsing
  contents:
  - "Internet Research Task Force (IRTF)                          A. Huelsing\n  \
    \               XMSS: eXtended Merkle Signature Scheme\n"
- title: Abstract
  contents:
  - "Abstract\n   This note describes the eXtended Merkle Signature Scheme (XMSS),\
    \ a\n   hash-based digital signature system that is based on existing\n   descriptions\
    \ in scientific literature.  This note specifies\n   Winternitz One-Time Signature\
    \ Plus (WOTS+), a one-time signature\n   scheme; XMSS, a single-tree scheme; and\
    \ XMSS^MT, a multi-tree variant\n   of XMSS.  Both XMSS and XMSS^MT use WOTS+\
    \ as a main building block.\n   XMSS provides cryptographic digital signatures\
    \ without relying on the\n   conjectured hardness of mathematical problems.  Instead,\
    \ it is proven\n   that it only relies on the properties of cryptographic hash\n\
    \   functions.  XMSS provides strong security guarantees and is even\n   secure\
    \ when the collision resistance of the underlying hash function\n   is broken.\
    \  It is suitable for compact implementations, is relatively\n   simple to implement,\
    \ and naturally resists side-channel attacks.\n   Unlike most other signature\
    \ systems, hash-based signatures can so far\n   withstand known attacks using\
    \ quantum computers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not candidates for any\
    \ level\n   of Internet Standard; see Section 2 of RFC 7841.\n   Information about\
    \ the current status of this document, any errata,\n   and how to provide feedback\
    \ on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8391.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. CFRG Note on Post-Quantum Cryptography .....................6\n  \
    \    1.2. Conventions Used in This Document ..........................7\n   2.\
    \ Notation ........................................................7\n      2.1.\
    \ Data Types .................................................7\n      2.2. Functions\
    \ ..................................................7\n      2.3. Operators ..................................................8\n\
    \      2.4. Integer-to-Byte Conversion .................................9\n  \
    \    2.5. Hash Function Address Scheme ...............................9\n    \
    \  2.6. Strings of Base w Numbers .................................12\n      2.7.\
    \ Member Functions ..........................................13\n   3. Primitives\
    \ .....................................................14\n      3.1. WOTS+: One-Time\
    \ Signatures ................................14\n           3.1.1. WOTS+ Parameters\
    \ ...................................14\n                  3.1.1.1. WOTS+ Functions\
    \ ...........................15\n           3.1.2. WOTS+ Chaining Function ............................15\n\
    \           3.1.3. WOTS+ Private Key ..................................16\n  \
    \         3.1.4. WOTS+ Public Key ...................................17\n    \
    \       3.1.5. WOTS+ Signature Generation .........................17\n      \
    \     3.1.6. WOTS+ Signature Verification .......................19\n        \
    \   3.1.7. Pseudorandom Key Generation ........................20\n   4. Schemes\
    \ ........................................................20\n      4.1. XMSS:\
    \ eXtended Merkle Signature Scheme ....................20\n           4.1.1. XMSS\
    \ Parameters ....................................21\n           4.1.2. XMSS Hash\
    \ Functions ................................22\n           4.1.3. XMSS Private\
    \ Key ...................................22\n           4.1.4. Randomized Tree\
    \ Hashing ............................23\n           4.1.5. L-Trees ............................................23\n\
    \           4.1.6. TreeHash ...........................................24\n  \
    \         4.1.7. XMSS Key Generation ................................25\n    \
    \       4.1.8. XMSS Signature .....................................27\n      \
    \     4.1.9. XMSS Signature Generation ..........................28\n        \
    \   4.1.10. XMSS Signature Verification .......................30\n          \
    \ 4.1.11. Pseudorandom Key Generation .......................32\n           4.1.12.\
    \ Free Index Handling and Partial Private Keys ......33\n      4.2. XMSS^MT: Multi-Tree\
    \ XMSS ..................................33\n           4.2.1. XMSS^MT Parameters\
    \ .................................33\n           4.2.2. XMSS^MT Key Generation\
    \ .............................33\n           4.2.3. XMSS^MT Signature ..................................36\n\
    \           4.2.4. XMSS^MT Signature Generation .......................37\n  \
    \         4.2.5. XMSS^MT Signature Verification .....................39\n    \
    \       4.2.6. Pseudorandom Key Generation ........................40\n      \
    \     4.2.7. Free Index Handling and Partial Private Keys .......40\n   5. Parameter\
    \ Sets .................................................40\n      5.1. Implementing\
    \ the Functions ................................41\n      5.2. WOTS+ Parameters\
    \ ..........................................43\n      5.3. XMSS Parameters ...........................................43\n\
    \           5.3.1. Parameter Guide ....................................44\n  \
    \    5.4. XMSS^MT Parameters ........................................45\n    \
    \       5.4.1. Parameter Guide ....................................47\n   6. Rationale\
    \ ......................................................49\n   7. Reference Code\
    \ .................................................50\n   8. IANA Considerations\
    \ ............................................50\n   9. Security Considerations\
    \ ........................................54\n      9.1. Security Proofs ...........................................55\n\
    \      9.2. Minimal Security Assumptions ..............................56\n  \
    \    9.3. Post-Quantum Security .....................................56\n   10.\
    \ References ....................................................57\n      10.1.\
    \ Normative References .....................................57\n      10.2. Informative\
    \ References ...................................58\n   Appendix A.  WOTS+ XDR\
    \ Formats ....................................60\n     A.1.  WOTS+ Parameter Sets\
    \ ......................................60\n     A.2.  WOTS+ Signatures ..........................................60\n\
    \     A.3.  WOTS+ Public Keys .........................................61\n  \
    \ Appendix B.  XMSS XDR Formats .....................................61\n    \
    \ B.1.  XMSS Parameter Sets .......................................61\n     B.2.\
    \  XMSS Signatures ...........................................62\n     B.3.  XMSS\
    \ Public Keys ..........................................64\n   Appendix C.  XMSS^MT\
    \ XDR Formats ..................................65\n     C.1.  XMSS^MT Parameter\
    \ Sets ....................................65\n     C.2.  XMSS^MT Signatures ........................................67\n\
    \     C.3.  XMSS^MT Public Keys .......................................71\n  \
    \ Acknowledgements ..................................................73\n   Authors'\
    \ Addresses ................................................74\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A (cryptographic) digital signature scheme provides asymmetric\n\
    \   message authentication.  The key generation algorithm produces a key\n   pair\
    \ consisting of a private and a public key.  A message is signed\n   using a private\
    \ key to produce a signature.  A message/signature pair\n   can be verified using\
    \ a public key.  A One-Time Signature (OTS)\n   scheme allows using a key pair\
    \ to sign exactly one message securely.\n   A Many-Time Signature (MTS) system\
    \ can be used to sign multiple\n   messages.\n   OTS schemes, and MTS schemes\
    \ composed from them, were proposed by\n   Merkle in 1979 [Merkle83].  They were\
    \ well-studied in the 1990s and\n   have regained interest from the mid 2000s\
    \ onwards because of their\n   resistance against quantum-computer-aided attacks.\
    \  These kinds of\n   signature schemes are called hash-based signature schemes\
    \ as they are\n   built out of a cryptographic hash function.  Hash-based signature\n\
    \   schemes generally feature small private and public keys as well as\n   fast\
    \ signature generation and verification; however, they also\n   feature large\
    \ signatures and relatively slow key generation.  In\n   addition, they are suitable\
    \ for compact implementations that benefit\n   various applications and are naturally\
    \ resistant to most kinds of\n   side-channel attacks.\n   Some progress has already\
    \ been made toward introducing and\n   standardizing hash-based signatures.  Buchmann,\
    \ Dahmen, and Huelsing\n   proposed the eXtended Merkle Signature Scheme (XMSS)\
    \ [BDH11], which\n   offers better efficiency than Merkle's original scheme and\
    \ a modern\n   security proof in the standard model.  McGrew, Curcio, and Fluhrer\n\
    \   authored an Internet-Draft [MCF18] specifying the Leighton-Micali\n   Signature\
    \ (LMS) scheme, which builds on the seminal works by Lamport,\n   Diffie, Winternitz,\
    \ and Merkle, taking a different approach than XMSS\n   and relying entirely on\
    \ security arguments in the random oracle\n   model.  Very recently, the stateless\
    \ hash-based signature scheme\n   SPHINCS was introduced [BHH15], with the intent\
    \ of being easier to\n   deploy in current applications.  A reasonable next step\
    \ toward\n   introducing hash-based signatures is to complete the specifications\n\
    \   of the basic algorithms -- LMS, XMSS, SPHINCS, and/or variants.\n   The eXtended\
    \ Merkle Signature Scheme (XMSS) [BDH11] is the latest\n   stateful hash-based\
    \ signature scheme.  It has the smallest signatures\n   out of such schemes and\
    \ comes with a multi-tree variant that solves\n   the problem of slow key generation.\
    \  Moreover, it can be shown that\n   XMSS is secure, making only mild assumptions\
    \ on the underlying hash\n   function.  In particular, it is not required that\
    \ the cryptographic\n   hash function is collision-resistant for the security\
    \ of XMSS.\n   Improvements upon XMSS, as described in [HRS16], are part of this\n\
    \   note.\n   This document describes a single-tree and a multi-tree variant of\n\
    \   XMSS.  It also describes WOTS+, a variant of the Winternitz OTS\n   scheme\
    \ introduced in [Huelsing13] that is used by XMSS.  The schemes\n   are described\
    \ with enough specificity to ensure interoperability\n   between implementations.\n\
    \   This document is structured as follows.  Notation is introduced in\n   Section\
    \ 2.  Section 3 describes the WOTS+ signature system.  MTS\n   schemes are defined\
    \ in Section 4: the eXtended Merkle Signature\n   Scheme (XMSS) in Section 4.1\
    \ and its multi-tree variant (XMSS^MT) in\n   Section 4.2.  Parameter sets are\
    \ described in Section 5.  Section 6\n   describes the rationale behind choices\
    \ in this note.  Section 7 gives\n   information about the reference code.  The\
    \ IANA registry for these\n   signature systems is described in Section 8.  Finally,\
    \ security\n   considerations are presented in Section 9.\n"
- title: 1.1.  CFRG Note on Post-Quantum Cryptography
  contents:
  - "1.1.  CFRG Note on Post-Quantum Cryptography\n   All post-quantum algorithms\
    \ documented by the Crypto Forum Research\n   Group (CFRG) are today considered\
    \ ready for experimentation and\n   further engineering development (e.g., to\
    \ establish the impact of\n   performance and sizes on IETF protocols).  However,\
    \ at the time of\n   writing, we do not have significant deployment experience\
    \ with such\n   algorithms.\n   Many of these algorithms come with specific restrictions,\
    \ e.g.,\n   change of classical interface or less cryptanalysis of proposed\n\
    \   parameters than established schemes.  CFRG has consensus that all\n   documents\
    \ describing post-quantum technologies include the above\n   paragraph and a clear\
    \ additional warning about any specific\n   restrictions, especially as those\
    \ might affect use or deployment of\n   the specific scheme.  That guidance may\
    \ be changed over time via\n   document updates.\n   Additionally, for XMSS:\n\
    \   CFRG consensus is that we are confident in the cryptographic security\n  \
    \ of the signature schemes described in this document against quantum\n   computers,\
    \ given the current state of the research community's\n   knowledge about quantum\
    \ algorithms.  Indeed, we are confident that\n   the security of a significant\
    \ part of the Internet could be made\n   dependent on the signature schemes defined\
    \ in this document, if\n   developers take care of the following.\n   In contrast\
    \ to traditional signature schemes, the signature schemes\n   described in this\
    \ document are stateful, meaning the secret key\n   changes over time.  If a secret\
    \ key state is used twice, no\n   cryptographic security guarantees remain.  In\
    \ consequence, it becomes\n   feasible to forge a signature on a new message.\
    \  This is a new\n   property that most developers will not be familiar with and\
    \ requires\n   careful handling of secret keys.  Developers should not use the\n\
    \   schemes described here except in systems that prevent the reuse of\n   secret\
    \ key states.\n   Note that the fact that the schemes described in this document\
    \ are\n   stateful also implies that classical APIs for digital signatures\n \
    \  cannot be used without modification.  The API MUST be able to handle\n   a\
    \ secret key state; in particular, this means that the API MUST allow\n   to return\
    \ an updated secret key state.\n"
- title: 1.2.  Conventions Used in This Document
  contents:
  - "1.2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 2.  Notation
  contents:
  - '2.  Notation

    '
- title: 2.1.  Data Types
  contents:
  - "2.1.  Data Types\n   Bytes and byte strings are the fundamental data types. \
    \ A byte is a\n   sequence of eight bits.  A single byte is denoted as a pair\
    \ of\n   hexadecimal digits with a leading \"0x\".  A byte string is an ordered\n\
    \   sequence of zero or more bytes and is denoted as an ordered sequence\n   of\
    \ hexadecimal characters with a leading \"0x\".  For example, 0xe534f0\n   is\
    \ a byte string of length 3.  An array of byte strings is an\n   ordered, indexed\
    \ set starting with index 0 in which all byte strings\n   have identical length.\
    \  We assume big-endian representation for any\n   data types or structures.\n"
- title: 2.2.  Functions
  contents:
  - "2.2.  Functions\n   If x is a non-negative real number, then we define the following\n\
    \   functions:\n      ceil(x): returns the smallest integer greater than or equal\
    \ to x.\n      floor(x): returns the largest integer less than or equal to x.\n\
    \      lg(x): returns the logarithm to base 2 of x.\n"
- title: 2.3.  Operators
  contents:
  - "2.3.  Operators\n   When a and b are integers, mathematical operators are defined\
    \ as\n   follows:\n      ^ : a ^ b denotes the result of a raised to the power\
    \ of b.\n      * : a * b denotes the product of a and b.  This operator is\n \
    \     sometimes omitted in the absence of ambiguity, as in usual\n      mathematical\
    \ notation.\n      / : a / b denotes the quotient of a by non-zero b.\n      %\
    \ : a % b denotes the non-negative remainder of the integer\n      division of\
    \ a by b.\n      + : a + b denotes the sum of a and b.\n      - : a - b denotes\
    \ the difference of a and b.\n      ++ : a++ denotes incrementing a by 1, i.e.,\
    \ a = a + 1.\n      << : a << b denotes a logical left shift with b being non-\n\
    \      negative, i.e., a * 2^b.\n      >> : a >> b denotes a logical right shift\
    \ with b being non-\n      negative, i.e., floor(a / 2^b).\n   The standard order\
    \ of operations is used when evaluating arithmetic\n   expressions.\n   Arrays\
    \ are used in the common way, where the i^th element of an array\n   A is denoted\
    \ A[i].  Byte strings are treated as arrays of bytes where\n   necessary: if X\
    \ is a byte string, then X[i] denotes its i^th byte,\n   where X[0] is the leftmost\
    \ byte.\n   If A and B are byte strings of equal length, then:\n   o  A AND B\
    \ denotes the bitwise logical conjunction operation.\n   o  A XOR B denotes the\
    \ bitwise logical exclusive disjunction\n      operation.\n   When B is a byte\
    \ and i is an integer, then B >> i denotes the logical\n   right-shift operation.\n\
    \   If X is an x-byte string and Y a y-byte string, then X || Y denotes\n   the\
    \ concatenation of X and Y, with X || Y = X[0] ... X[x-1] Y[0] ...\n   Y[y-1].\n"
- title: 2.4.  Integer-to-Byte Conversion
  contents:
  - "2.4.  Integer-to-Byte Conversion\n   If x and y are non-negative integers, we\
    \ define Z = toByte(x, y) to\n   be the y-byte string containing the binary representation\
    \ of x in\n   big-endian byte order.\n"
- title: 2.5.  Hash Function Address Scheme
  contents:
  - "2.5.  Hash Function Address Scheme\n   The schemes described in this document\
    \ randomize each hash function\n   call.  This means that aside from the initial\
    \ message digest, a\n   different key and different bitmask is used for each hash\
    \ function\n   call.  These values are pseudorandomly generated using a pseudorandom\n\
    \   function that takes a key SEED and a 32-byte address ADRS as input\n   and\
    \ outputs an n-byte value, where n is the security parameter.  Here\n   we explain\
    \ the structure of address ADRS and propose setter methods\n   to manipulate the\
    \ address.  We explain the generation of the\n   addresses in the following sections\
    \ where they are used.\n   The schemes in the next two sections use two kinds\
    \ of hash functions\n   parameterized by security parameter n.  For the hash tree\n\
    \   constructions, a hash function that maps an n-byte key and 2n-byte\n   inputs\
    \ to n-byte outputs is used.  To randomize this function, 3n\n   bytes are needed\
    \ -- n bytes for the key and 2n bytes for a bitmask.\n   For the OTS scheme constructions,\
    \ a hash function that maps n-byte\n   keys and n-byte inputs to n-byte outputs\
    \ is used.  To randomize this\n   function, 2n bytes are needed -- n bytes for\
    \ the key and n bytes for\n   a bitmask.  Consequently, three addresses are needed\
    \ for the first\n   function and two addresses for the second one.\n   There are\
    \ three different types of addresses for the different use\n   cases.  One type\
    \ is used for the hashes in OTS schemes, one is used\n   for hashes within the\
    \ main Merkle tree construction, and one is used\n   for hashes in the L-trees.\
    \  The latter is used to compress one-time\n   public keys.  All these types share\
    \ as much format as possible.  In\n   the remainder of this section, we describe\
    \ these types in detail.\n   The structure of an address complies with word borders,\
    \ with a word\n   being 32 bits long in this context.  Only the tree address is\
    \ too\n   long to fit a single word, but it can fit a double word.  An address\n\
    \   is structured as follows.  It always starts with a layer address of\n   one\
    \ word in the most significant bits, followed by a tree address of\n   two words.\
    \  Both addresses are needed for the multi-tree variant (see\n   Section 4.2)\
    \ and describe the position of a tree within a multi-tree.\n   They are therefore\
    \ set to zero in single-tree applications.  For\n   multi-tree hash-based signatures,\
    \ the layer address describes the\n   height of a tree within the multi-tree,\
    \ starting from height zero for\n   trees at the bottom layer.  The tree address\
    \ describes the position\n   of a tree within a layer of a multi-tree starting\
    \ with index zero for\n   the leftmost tree.  The next word defines the type of\
    \ the address.\n   It is set to 0 for an OTS address, to 1 for an L-tree address,\
    \ and to\n   2 for a hash tree address.  Whenever the type word of an address\
    \ is\n   changed, all following words should be initialized with 0 to prevent\n\
    \   non-zero values in unused padding words.\n   We first describe the OTS address\
    \ case.  In this case, the type word\n   is followed by an OTS address word that\
    \ encodes the index of the OTS\n   key pair within the tree.  The next word encodes\
    \ the chain address\n   followed by a word that encodes the address of the hash\
    \ function call\n   within the chain.  The last word, called keyAndMask, is used\
    \ to\n   generate two different addresses for one hash function call.  The\n \
    \  word is set to zero to generate the key.  To generate the n-byte\n   bitmask,\
    \ the word is set to one.\n                     +-------------------------+\n\
    \                     | layer address  (32 bits)|\n                     +-------------------------+\n\
    \                     | tree address   (64 bits)|\n                     +-------------------------+\n\
    \                     | type = 0       (32 bits)|\n                     +-------------------------+\n\
    \                     | OTS address    (32 bits)|\n                     +-------------------------+\n\
    \                     | chain address  (32 bits)|\n                     +-------------------------+\n\
    \                     | hash address   (32 bits)|\n                     +-------------------------+\n\
    \                     | keyAndMask     (32 bits)|\n                     +-------------------------+\n\
    \                            An OTS Hash Address\n   We now discuss the L-tree\
    \ case, which means that the type word is set\n   to one.  In that case, the type\
    \ word is followed by an L-tree address\n   word that encodes the index of the\
    \ leaf computed with this L-tree.\n   The next word encodes the height of the\
    \ node being input for the next\n   computation inside the L-tree.  The following\
    \ word encodes the index\n   of the node at that height, inside the L-tree.  This\
    \ time, the last\n   word, keyAndMask, is used to generate three different addresses\
    \ for\n   one function call.  The word is set to zero to generate the key.  To\n\
    \   generate the most significant n bytes of the 2n-byte bitmask, the\n   word\
    \ is set to one.  The least significant bytes are generated using\n   the address\
    \ with the word set to two.\n                     +-------------------------+\n\
    \                     | layer address  (32 bits)|\n                     +-------------------------+\n\
    \                     | tree address   (64 bits)|\n                     +-------------------------+\n\
    \                     | type = 1       (32 bits)|\n                     +-------------------------+\n\
    \                     | L-tree address (32 bits)|\n                     +-------------------------+\n\
    \                     | tree height    (32 bits)|\n                     +-------------------------+\n\
    \                     | tree index     (32 bits)|\n                     +-------------------------+\n\
    \                     | keyAndMask     (32 bits)|\n                     +-------------------------+\n\
    \                             An L-tree Address\n   We now describe the remaining\
    \ type for the main tree hash addresses.\n   In this case, the type word is set\
    \ to two, followed by a zero padding\n   of one word.  The next word encodes the\
    \ height of the tree node being\n   input for the next computation, followed by\
    \ a word that encodes the\n   index of this node at that height.  As for the L-tree\
    \ addresses, the\n   last word, keyAndMask, is used to generate three different\
    \ addresses\n   for one function call.  The word is set to zero to generate the\
    \ key.\n   To generate the most significant n bytes of the 2n-byte bitmask, the\n\
    \   word is set to one.  The least significant bytes are generated using\n   the\
    \ address with the word set to two.\n                     +-------------------------+\n\
    \                     | layer address  (32 bits)|\n                     +-------------------------+\n\
    \                     | tree address   (64 bits)|\n                     +-------------------------+\n\
    \                     | type = 2       (32 bits)|\n                     +-------------------------+\n\
    \                     | Padding = 0    (32 bits)|\n                     +-------------------------+\n\
    \                     | tree height    (32 bits)|\n                     +-------------------------+\n\
    \                     | tree index     (32 bits)|\n                     +-------------------------+\n\
    \                     | keyAndMask     (32 bits)|\n                     +-------------------------+\n\
    \                            A Hash Tree Address\n   All fields within these addresses\
    \ encode unsigned integers.  When\n   describing the generation of addresses we\
    \ use setter methods that\n   take positive integers and set the bits of a field\
    \ to the binary\n   representation of that integer of the length of the field.\
    \  We\n   furthermore assume that the setType() method sets the four words\n \
    \  following the type word to zero.\n"
- title: 2.6.  Strings of Base w Numbers
  contents:
  - "2.6.  Strings of Base w Numbers\n   A byte string can be considered as a string\
    \ of base w numbers, i.e.,\n   integers in the set {0, ... , w - 1}.  The correspondence\
    \ is defined\n   by the function base_w(X, w, out_len) (Algorithm 1) as follows.\
    \  If X\n   is a len_X-byte string, and w is a member of the set {4, 16}, then\n\
    \   base_w(X, w, out_len) outputs an array of out_len integers between 0\n   and\
    \ w - 1.  The length out_len is REQUIRED to be less than or equal\n   to 8 * len_X\
    \ / lg(w).\n   Algorithm 1: base_w\n     Input: len_X-byte string X, int w, output\
    \ length out_len\n     Output: out_len int array basew\n       int in = 0;\n \
    \      int out = 0;\n       unsigned int total = 0;\n       int bits = 0;\n  \
    \     int consumed;\n       for ( consumed = 0; consumed < out_len; consumed++\
    \ ) {\n           if ( bits == 0 ) {\n               total = X[in];\n        \
    \       in++;\n               bits += 8;\n           }\n           bits -= lg(w);\n\
    \           basew[out] = (total >> bits) AND (w - 1);\n           out++;\n   \
    \    }\n       return basew;\n   For example, if X is the (big-endian) byte string\
    \ 0x1234, then\n   base_w(X, 16, 4) returns the array a = {1, 2, 3, 4}.\n    \
    \                  X (represented as bits)\n         +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         | 0| 0| 0| 1| 0| 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0|\n         +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \                    X[0]         |         X[1]\n                 X (represented\
    \ as base 16 numbers)\n         +-----------+-----------+-----------+-----------+\n\
    \         |     1     |     2     |     3     |     4     |\n         +-----------+-----------+-----------+-----------+\n\
    \                          base_w(X, 16, 4)\n         +-----------+-----------+-----------+-----------+\n\
    \         |     1     |     2     |     3     |     4     |\n         +-----------+-----------+-----------+-----------+\n\
    \             a[0]        a[1]        a[2]        a[3]\n                     \
    \     base_w(X, 16, 3)\n         +-----------+-----------+-----------+\n     \
    \    |     1     |     2     |     3     |\n         +-----------+-----------+-----------+\n\
    \             a[0]        a[1]        a[2]\n                          base_w(X,\
    \ 16, 2)\n         +-----------+-----------+\n         |     1     |     2   \
    \  |\n         +-----------+-----------+\n             a[0]        a[1]\n    \
    \                              Example\n"
- title: 2.7.  Member Functions
  contents:
  - "2.7.  Member Functions\n   To simplify algorithm descriptions, we assume the\
    \ existence of member\n   functions.  If a complex data structure like a public\
    \ key PK contains\n   a value X, then getX(PK) returns the value of X for this\
    \ public key.\n   Accordingly, setX(PK, X, Y) sets value X in PK to the value\
    \ held by\n   Y.  Since camelCase is used for member function names, a value z\
    \ may\n   be referred to as Z in the function name, e.g., getZ.\n"
- title: 3.  Primitives
  contents:
  - '3.  Primitives

    '
- title: '3.1.  WOTS+: One-Time Signatures'
  contents:
  - "3.1.  WOTS+: One-Time Signatures\n   This section describes the WOTS+ system\
    \ in a manner similar to that\n   in [Huelsing13].  WOTS+ is an OTS scheme; while\
    \ a private key can be\n   used to sign any message, each private key MUST be\
    \ used only once to\n   sign a single message.  In particular, if a private key\
    \ is used to\n   sign two different messages, the scheme becomes insecure.\n \
    \  This section starts with an explanation of parameters.  Afterwards,\n   the\
    \ so-called chaining function, which forms the main building block\n   of the\
    \ WOTS+ scheme, is explained.  A description of the algorithms\n   for key generation,\
    \ signing, and verification follows.  Finally,\n   pseudorandom key generation\
    \ is discussed.\n"
- title: 3.1.1.  WOTS+ Parameters
  contents:
  - "3.1.1.  WOTS+ Parameters\n   WOTS+ uses the parameters n and w; they both take\
    \ positive integer\n   values.  These parameters are summarized as follows:\n\
    \      n: the message length as well as the length of a private key,\n      public\
    \ key, or signature element in bytes.\n      w: the Winternitz parameter; it is\
    \ a member of the set {4, 16}.\n   The parameters are used to compute values len,\
    \ len_1, and len_2:\n      len: the number of n-byte string elements in a WOTS+\
    \ private key,\n      public key, and signature.  It is computed as len = len_1\
    \ + len_2,\n      with len_1 = ceil(8n / lg(w)) and len_2 = floor(lg(len_1 *\n\
    \      (w - 1)) / lg(w)) + 1.\n   The value of n is determined by the cryptographic\
    \ hash function used\n   for WOTS+.  The hash function is chosen to ensure an\
    \ appropriate\n   level of security.  The value of n is the input length that\
    \ can be\n   processed by the signing algorithm.  It is often the length of a\n\
    \   message digest.  The parameter w can be chosen from the set {4, 16}.\n   A\
    \ larger value of w results in shorter signatures but slower overall\n   signing\
    \ operations; it has little effect on security.  Choices of w\n   are limited\
    \ to the values 4 and 16 since these values yield optimal\n   trade-offs and easy\
    \ implementation.\n   WOTS+ parameters are implicitly included in algorithm inputs\
    \ as\n   needed.\n"
- title: 3.1.1.1.  WOTS+ Functions
  contents:
  - "3.1.1.1.  WOTS+ Functions\n   The WOTS+ algorithm uses a keyed cryptographic\
    \ hash function F.  F\n   accepts and returns byte strings of length n using keys\
    \ of length n.\n   More detail on specific instantiations can be found in Section\
    \ 5.\n   Security requirements on F are discussed in Section 9.  In addition,\n\
    \   WOTS+ uses a pseudorandom function PRF.  PRF takes as input an n-byte\n  \
    \ key and a 32-byte index and generates pseudorandom outputs of length\n   n.\
    \  More detail on specific instantiations can be found in Section 5.\n   Security\
    \ requirements on PRF are discussed in Section 9.\n"
- title: 3.1.2.  WOTS+ Chaining Function
  contents:
  - "3.1.2.  WOTS+ Chaining Function\n   The chaining function (Algorithm 2) computes\
    \ an iteration of F on an\n   n-byte input using outputs of PRF.  It takes an\
    \ OTS hash address as\n   input.  This address will have the first six 32-bit\
    \ words set to\n   encode the address of this chain.  In each iteration, PRF is\
    \ used to\n   generate a key for F and a bitmask that is XORed to the intermediate\n\
    \   result before it is processed by F.  In the following, ADRS is a\n   32-byte\
    \ OTS hash address as specified in Section 2.5 and SEED is an\n   n-byte string.\
    \  To generate the keys and bitmasks, PRF is called with\n   SEED as key and ADRS\
    \ as input.  The chaining function takes as input\n   an n-byte string X, a start\
    \ index i, a number of steps s, as well as\n   ADRS and SEED.  The chaining function\
    \ returns as output the value\n   obtained by iterating F for s times on input\
    \ X, using the outputs of\n   PRF.\n   Algorithm 2: chain - Chaining Function\n\
    \     Input: Input string X, start index i, number of steps s,\n     seed SEED,\
    \ address ADRS\n     Output: value of F iterated s times on X\n     if ( s ==\
    \ 0 ) {\n       return X;\n     }\n     if ( (i + s) > (w - 1) ) {\n       return\
    \ NULL;\n     }\n     byte[n] tmp = chain(X, i, s - 1, SEED, ADRS);\n     ADRS.setHashAddress(i\
    \ + s - 1);\n     ADRS.setKeyAndMask(0);\n     KEY = PRF(SEED, ADRS);\n     ADRS.setKeyAndMask(1);\n\
    \     BM = PRF(SEED, ADRS);\n     tmp = F(KEY, tmp XOR BM);\n     return tmp;\n"
- title: 3.1.3.  WOTS+ Private Key
  contents:
  - "3.1.3.  WOTS+ Private Key\n   The private key in WOTS+, denoted by sk (s for\
    \ secret), is a length\n   len array of n-byte strings.  This private key MUST\
    \ be only used to\n   sign at most one message.  Each n-byte string MUST either\
    \ be selected\n   randomly from the uniform distribution or be selected using\
    \ a\n   cryptographically secure pseudorandom procedure.  In the latter case,\n\
    \   the security of the used procedure MUST at least match that of the\n   WOTS+\
    \ parameters used.  For a further discussion on pseudorandom key\n   generation,\
    \ see Section 3.1.7.  The following pseudocode (Algorithm\n   3) describes an\
    \ algorithm for generating sk.\n   Algorithm 3: WOTS_genSK - Generating a WOTS+\
    \ Private Key\n     Input: No input\n     Output: WOTS+ private key sk\n     for\
    \ ( i = 0; i < len; i++ ) {\n       initialize sk[i] with a uniformly random n-byte\
    \ string;\n     }\n     return sk;\n"
- title: 3.1.4.  WOTS+ Public Key
  contents:
  - "3.1.4.  WOTS+ Public Key\n   A WOTS+ key pair defines a virtual structure that\
    \ consists of len\n   hash chains of length w.  The len n-byte strings in the\
    \ private key\n   each define the start node for one hash chain.  The public key\n\
    \   consists of the end nodes of these hash chains.  Therefore, like the\n   private\
    \ key, the public key is also a length len array of n-byte\n   strings.  To compute\
    \ the hash chain, the chaining function (Algorithm\n   2) is used.  An OTS hash\
    \ address ADRS and a seed SEED have to be\n   provided by the calling algorithm.\
    \  This address will encode the\n   address of the WOTS+ key pair within a greater\
    \ structure.  Hence, a\n   WOTS+ algorithm MUST NOT manipulate any parts of ADRS\
    \ except for the\n   last three 32-bit words.  Please note that the SEED used\
    \ here is\n   public information also available to a verifier.  The following\n\
    \   pseudocode (Algorithm 4) describes an algorithm for generating the\n   public\
    \ key pk, where sk is the private key.\n   Algorithm 4: WOTS_genPK - Generating\
    \ a WOTS+ Public Key From a\n   Private Key\n     Input: WOTS+ private key sk,\
    \ address ADRS, seed SEED\n     Output: WOTS+ public key pk\n     for ( i = 0;\
    \ i < len; i++ ) {\n       ADRS.setChainAddress(i);\n       pk[i] = chain(sk[i],\
    \ 0, w - 1, SEED, ADRS);\n     }\n     return pk;\n"
- title: 3.1.5.  WOTS+ Signature Generation
  contents:
  - "3.1.5.  WOTS+ Signature Generation\n   A WOTS+ signature is a length len array\
    \ of n-byte strings.  The WOTS+\n   signature is generated by mapping a message\
    \ to len integers between 0\n   and w - 1.  To this end, the message is transformed\
    \ into len_1 base w\n   numbers using the base_w function defined in Section 2.6.\
    \  Next, a\n   checksum is computed and appended to the transformed message as\
    \ len_2\n   base w numbers using the base_w function.  Note that the checksum\
    \ may\n   reach a maximum integer value of len_1 * (w - 1) * 2^8 and therefore\n\
    \   depends on the parameters n and w.  For the parameter sets given in\n   Section\
    \ 5, a 32-bit unsigned integer is sufficient to hold the\n   checksum.  If other\
    \ parameter settings are used, the size of the\n   variable holding the integer\
    \ value of the checksum MUST be\n   sufficiently large.  Each of the base w integers\
    \ is used to select a\n   node from a different hash chain.  The signature is\
    \ formed by\n   concatenating the selected nodes.  An OTS hash address ADRS and\
    \ a\n   seed SEED have to be provided by the calling algorithm.  This address\n\
    \   will encode the address of the WOTS+ key pair within a greater\n   structure.\
    \  Hence, a WOTS+ algorithm MUST NOT manipulate any parts of\n   ADRS except for\
    \ the last three 32-bit words.  Please note that the\n   SEED used here is public\
    \ information also available to a verifier.\n   The pseudocode for signature generation\
    \ is shown below (Algorithm 5),\n   where M is the message and sig is the resulting\
    \ signature.\n   Algorithm 5: WOTS_sign - Generating a signature from a private\
    \ key\n   and a message\n     Input: Message M, WOTS+ private key sk, address\
    \ ADRS, seed SEED\n     Output: WOTS+ signature sig\n     csum = 0;\n     // Convert\
    \ message to base w\n     msg = base_w(M, w, len_1);\n     // Compute checksum\n\
    \     for ( i = 0; i < len_1; i++ ) {\n           csum = csum + w - 1 - msg[i];\n\
    \     }\n     // Convert csum to base w\n     csum = csum << ( 8 - ( ( len_2 *\
    \ lg(w) ) % 8 ));\n     len_2_bytes = ceil( ( len_2 * lg(w) ) / 8 );\n     msg\
    \ = msg || base_w(toByte(csum, len_2_bytes), w, len_2);\n     for ( i = 0; i <\
    \ len; i++ ) {\n          ADRS.setChainAddress(i);\n          sig[i] = chain(sk[i],\
    \ 0, msg[i], SEED, ADRS);\n     }\n     return sig;\n   The data format for a\
    \ signature is given below.\n             +---------------------------------+\n\
    \             |                                 |\n             |           sig_ots[0]\
    \            |    n bytes\n             |                                 |\n\
    \             +---------------------------------+\n             |            \
    \                     |\n             ~              ....               ~\n  \
    \           |                                 |\n             +---------------------------------+\n\
    \             |                                 |\n             |          sig_ots[len\
    \ - 1]       |    n bytes\n             |                                 |\n\
    \             +---------------------------------+\n                          \
    \    WOTS+ Signature\n"
- title: 3.1.6.  WOTS+ Signature Verification
  contents:
  - "3.1.6.  WOTS+ Signature Verification\n   In order to verify a signature sig on\
    \ a message M, the verifier\n   computes a WOTS+ public key value from the signature.\
    \  This can be\n   done by \"completing\" the chain computations starting from\
    \ the\n   signature values, using the base w values of the message hash and its\n\
    \   checksum.  This step, called WOTS_pkFromSig, is described below in\n   Algorithm\
    \ 6.  The result of WOTS_pkFromSig is then compared to the\n   given public key.\
    \  If the values are equal, the signature is\n   accepted.  Otherwise, the signature\
    \ MUST be rejected.  An OTS hash\n   address ADRS and a seed SEED have to be provided\
    \ by the calling\n   algorithm.  This address will encode the address of the WOTS+\
    \ key\n   pair within a greater structure.  Hence, a WOTS+ algorithm MUST NOT\n\
    \   manipulate any parts of ADRS except for the last three 32-bit words.\n   Please\
    \ note that the SEED used here is public information also\n   available to a verifier.\n\
    \   Algorithm 6: WOTS_pkFromSig - Computing a WOTS+ public key from a\n   message\
    \ and its signature\n     Input: Message M, WOTS+ signature sig, address ADRS,\
    \ seed SEED\n     Output: 'Temporary' WOTS+ public key tmp_pk\n     csum = 0;\n\
    \     // Convert message to base w\n     msg = base_w(M, w, len_1);\n     // Compute\
    \ checksum\n     for ( i = 0; i < len_1; i++ ) {\n           csum = csum + w -\
    \ 1 - msg[i];\n     }\n     // Convert csum to base w\n     csum = csum << ( 8\
    \ - ( ( len_2 * lg(w) ) % 8 ));\n     len_2_bytes = ceil( ( len_2 * lg(w) ) /\
    \ 8 );\n     msg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);\n     for\
    \ ( i = 0; i < len; i++ ) {\n          ADRS.setChainAddress(i);\n          tmp_pk[i]\
    \ = chain(sig[i], msg[i], w - 1 - msg[i], SEED, ADRS);\n     }\n     return tmp_pk;\n\
    \   Note: XMSS uses WOTS_pkFromSig to compute a public key value and\n   delays\
    \ the comparison to a later point.\n"
- title: 3.1.7.  Pseudorandom Key Generation
  contents:
  - "3.1.7.  Pseudorandom Key Generation\n   An implementation MAY use a cryptographically\
    \ secure pseudorandom\n   method to generate the private key from a single n-byte\
    \ value.  For\n   example, the method suggested in [BDH11] and explained below\
    \ MAY be\n   used.  Other methods MAY be used.  The choice of a pseudorandom\n\
    \   method does not affect interoperability, but the cryptographic\n   strength\
    \ MUST match that of the used WOTS+ parameters.\n   The advantage of generating\
    \ the private key elements from a random\n   n-byte string is that only this n-byte\
    \ string needs to be stored\n   instead of the full private key.  The key can\
    \ be regenerated when\n   needed.  The suggested method from [BDH11] can be described\
    \ using\n   PRF.  During key generation, a uniformly random n-byte string S is\n\
    \   sampled from a secure source of randomness.  This string S is stored\n   as\
    \ private key.  The private key elements are computed as sk[i] =\n   PRF(S, toByte(i,\
    \ 32)) whenever needed.  Please note that this seed S\n   MUST be different from\
    \ the seed SEED used to randomize the hash\n   function calls.  Also, this seed\
    \ S MUST be kept secret.  The seed S\n   MUST NOT be a low entropy, human-memorable\
    \ value since private key\n   elements are derived from S deterministically and\
    \ their\n   confidentiality is security-critical.\n"
- title: 4.  Schemes
  contents:
  - "4.  Schemes\n   In this section, the eXtended Merkle Signature Scheme (XMSS)\
    \ is\n   described using WOTS+.  XMSS comes in two flavors: a single-tree\n  \
    \ variant (XMSS) and a multi-tree variant (XMSS^MT).  Both allow\n   combining\
    \ a large number of WOTS+ key pairs under a single small\n   public key.  The\
    \ main ingredient added is a binary hash tree\n   construction.  XMSS uses a single\
    \ hash tree while XMSS^MT uses a tree\n   of XMSS key pairs.\n"
- title: '4.1.  XMSS: eXtended Merkle Signature Scheme'
  contents:
  - "4.1.  XMSS: eXtended Merkle Signature Scheme\n   XMSS is a method for signing\
    \ a potentially large but fixed number of\n   messages.  It is based on the Merkle\
    \ signature scheme.  XMSS uses\n   four cryptographic components: WOTS+ as OTS\
    \ method, two additional\n   cryptographic hash functions H and H_msg, and a pseudorandom\
    \ function\n   PRF.  One of the main advantages of XMSS with WOTS+ is that it\
    \ does\n   not rely on the collision resistance of the used hash functions but\n\
    \   on weaker properties.  Each XMSS public/private key pair is\n   associated\
    \ with a perfect binary tree, every node of which contains\n   an n-byte value.\
    \  Each tree leaf contains a special tree hash of a\n   WOTS+ public key value.\
    \  Each non-leaf tree node is computed by first\n   concatenating the values of\
    \ its child nodes, computing the XOR with a\n   bitmask, and applying the keyed\
    \ hash function H to the result.  The\n   bitmasks and the keys for the hash function\
    \ H are generated from a\n   (public) seed that is part of the public key using\
    \ the pseudorandom\n   function PRF.  The value corresponding to the root of the\
    \ XMSS tree\n   forms the XMSS public key together with the seed.\n   To generate\
    \ a key pair that can be used to sign 2^h messages, a tree\n   of height h is\
    \ used.  XMSS is a stateful signature scheme, meaning\n   that the private key\
    \ changes with every signature generation.  To\n   prevent one-time private keys\
    \ from being used twice, the WOTS+ key\n   pairs are numbered from 0 to (2^h)\
    \ - 1 according to the related leaf,\n   starting from index 0 for the leftmost\
    \ leaf.  The private key\n   contains an index that is updated with every signature\
    \ generation,\n   such that it contains the index of the next unused WOTS+ key\
    \ pair.\n   A signature consists of the index of the used WOTS+ key pair, the\n\
    \   WOTS+ signature on the message, and the so-called authentication\n   path.\
    \  The latter is a vector of tree nodes that allow a verifier to\n   compute a\
    \ value for the root of the tree starting from a WOTS+\n   signature.  A verifier\
    \ computes the root value and compares it to the\n   respective value in the XMSS\
    \ public key.  If they match, the\n   signature is declared valid.  The XMSS private\
    \ key consists of all\n   WOTS+ private keys and the current index.  To reduce\
    \ storage, a\n   pseudorandom key generation procedure, as described in [BDH11],\
    \ MAY\n   be used.  The security of the used method MUST at least match the\n\
    \   security of the XMSS instance.\n"
- title: 4.1.1.  XMSS Parameters
  contents:
  - "4.1.1.  XMSS Parameters\n   XMSS has the following parameters:\n      h: the\
    \ height (number of levels - 1) of the tree\n      n: the length in bytes of the\
    \ message digest as well as each node\n      w: the Winternitz parameter as defined\
    \ for WOTS+ in Section 3.1\n   There are 2^h leaves in the tree.\n   For XMSS\
    \ and XMSS^MT, private and public keys are denoted by SK (S\n   for secret) and\
    \ PK, respectively.  For WOTS+, private and public keys\n   are denoted by sk\
    \ (s for secret) and pk, respectively.  XMSS and\n   XMSS^MT signatures are denoted\
    \ by Sig.  WOTS+ signatures are denoted\n   by sig.\n   XMSS and XMSS^MT parameters\
    \ are implicitly included in algorithm\n   inputs as needed.\n"
- title: 4.1.2.  XMSS Hash Functions
  contents:
  - "4.1.2.  XMSS Hash Functions\n   Besides the cryptographic hash function F and\
    \ the pseudorandom\n   function PRF required by WOTS+, XMSS uses two more functions:\n\
    \   o  A cryptographic hash function H.  H accepts n-byte keys and byte\n    \
    \  strings of length 2n and returns an n-byte string.\n   o  A cryptographic hash\
    \ function H_msg.  H_msg accepts 3n-byte keys\n      and byte strings of arbitrary\
    \ length and returns an n-byte string.\n   More detail on specific instantiations\
    \ can be found in Section 5.\n   Security requirements on H and H_msg are discussed\
    \ in Section 9.\n"
- title: 4.1.3.  XMSS Private Key
  contents:
  - "4.1.3.  XMSS Private Key\n   An XMSS private key SK contains 2^h WOTS+ private\
    \ keys, the leaf\n   index idx of the next WOTS+ private key that has not yet\
    \ been used,\n   SK_PRF (an n-byte key to generate pseudorandom values for randomized\n\
    \   message hashing), the n-byte value root (which is the root node of\n   the\
    \ tree and SEED), and the n-byte public seed used to pseudorandomly\n   generate\
    \ bitmasks and hash function keys.  Although root and SEED\n   formally would\
    \ be considered only part of the public key, they are\n   needed (e.g., for signature\
    \ generation) and hence are also required\n   for functions that do not take the\
    \ public key as input.\n   The leaf index idx is initialized to zero when the\
    \ XMSS private key\n   is created.  The key SK_PRF MUST be sampled from a secure\
    \ source of\n   randomness that follows the uniform distribution.  The WOTS+ private\n\
    \   keys MUST be generated as described in Section 3.1, or, to reduce the\n  \
    \ private key size, a cryptographic pseudorandom method MUST be used as\n   discussed\
    \ in Section 4.1.11.  SEED is generated as a uniformly random\n   n-byte string.\
    \  Although SEED is public, it is critical for security\n   that it is generated\
    \ using a good entropy source.  The root node is\n   generated as described below\
    \ in the section on key generation\n   (Section 4.1.7).  That section also contains\
    \ an example algorithm for\n   combined private and public key generation.\n \
    \  For the following algorithm descriptions, the existence of a method\n   getWOTS_SK(SK,\
    \ i) is assumed.  This method takes as input an XMSS\n   private key SK and an\
    \ integer i and outputs the i^th WOTS+ private\n   key of SK.\n"
- title: 4.1.4.  Randomized Tree Hashing
  contents:
  - "4.1.4.  Randomized Tree Hashing\n   To improve readability, we introduce a function\
    \ RAND_HASH(LEFT,\n   RIGHT, SEED, ADRS) (Algorithm 7) that does the randomized\
    \ hashing in\n   the tree.  It takes as input two n-byte values LEFT and RIGHT\
    \ that\n   represent the left and the right halves of the hash function input,\n\
    \   the seed SEED used as key for PRF, and the address ADRS of this hash\n   function\
    \ call.  RAND_HASH first uses PRF with SEED and ADRS to\n   generate a key KEY\
    \ and n-byte bitmasks BM_0, BM_1.  Then, it returns\n   the randomized hash H(KEY,\
    \ (LEFT XOR BM_0) || (RIGHT XOR BM_1)).\n   Algorithm 7: RAND_HASH\n     Input:\
    \  n-byte value LEFT, n-byte value RIGHT, seed SEED,\n             address ADRS\n\
    \     Output: n-byte randomized hash\n     ADRS.setKeyAndMask(0);\n     KEY =\
    \ PRF(SEED, ADRS);\n     ADRS.setKeyAndMask(1);\n     BM_0 = PRF(SEED, ADRS);\n\
    \     ADRS.setKeyAndMask(2);\n     BM_1 = PRF(SEED, ADRS);\n     return H(KEY,\
    \ (LEFT XOR BM_0) || (RIGHT XOR BM_1));\n"
- title: 4.1.5.  L-Trees
  contents:
  - "4.1.5.  L-Trees\n   To compute the leaves of the binary hash tree, a so-called\
    \ L-tree is\n   used.  An L-tree is an unbalanced binary hash tree, distinct but\n\
    \   similar to the main XMSS binary hash tree.  The algorithm ltree\n   (Algorithm\
    \ 8) takes as input a WOTS+ public key pk and compresses it\n   to a single n-byte\
    \ value pk[0].  It also takes as input an L-tree\n   address ADRS that encodes\
    \ the address of the L-tree and the seed\n   SEED.\n   Algorithm 8: ltree\n  \
    \   Input: WOTS+ public key pk, address ADRS, seed SEED\n     Output: n-byte compressed\
    \ public key value pk[0]\n     unsigned int len' = len;\n     ADRS.setTreeHeight(0);\n\
    \     while ( len' > 1 ) {\n       for ( i = 0; i < floor(len' / 2); i++ ) {\n\
    \         ADRS.setTreeIndex(i);\n         pk[i] = RAND_HASH(pk[2i], pk[2i + 1],\
    \ SEED, ADRS);\n       }\n       if ( len' % 2 == 1 ) {\n         pk[floor(len'\
    \ / 2)] = pk[len' - 1];\n       }\n       len' = ceil(len' / 2);\n       ADRS.setTreeHeight(ADRS.getTreeHeight()\
    \ + 1);\n     }\n     return pk[0];\n"
- title: 4.1.6.  TreeHash
  contents:
  - "4.1.6.  TreeHash\n   For the computation of the internal n-byte nodes of a Merkle\
    \ tree,\n   the subroutine treeHash (Algorithm 9) accepts an XMSS private key\
    \ SK\n   (including seed SEED), an unsigned integer s (the start index), an\n\
    \   unsigned integer t (the target node height), and an address ADRS that\n  \
    \ encodes the address of the containing tree.  For the height of a node\n   within\
    \ a tree, counting starts with the leaves at height zero.  The\n   treeHash algorithm\
    \ returns the root node of a tree of height t with\n   the leftmost leaf being\
    \ the hash of the WOTS+ pk with index s.  It is\n   REQUIRED that s % 2^t = 0,\
    \ i.e., that the leaf at index s is a\n   leftmost leaf of a sub-tree of height\
    \ t.  Otherwise, the hash-\n   addressing scheme fails.  The treeHash algorithm\
    \ described here uses\n   a stack holding up to (t - 1) nodes, with the usual\
    \ stack functions\n   push() and pop().  We furthermore assume that the height\
    \ of a node\n   (an unsigned integer) is stored alongside a node's value (an n-byte\n\
    \   string) on the stack.\n   Algorithm 9: treeHash\n     Input: XMSS private\
    \ key SK, start index s, target node height t,\n            address ADRS\n   \
    \  Output: n-byte root node - top node on Stack\n     if( s % (1 << t) != 0 )\
    \ return -1;\n     for ( i = 0; i < 2^t; i++ ) {\n       SEED = getSEED(SK);\n\
    \       ADRS.setType(0);   // Type = OTS hash address\n       ADRS.setOTSAddress(s\
    \ + i);\n       pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n       ADRS.setType(1);\
    \   // Type = L-tree address\n       ADRS.setLTreeAddress(s + i);\n       node\
    \ = ltree(pk, SEED, ADRS);\n       ADRS.setType(2);   // Type = hash tree address\n\
    \       ADRS.setTreeHeight(0);\n       ADRS.setTreeIndex(i + s);\n       while\
    \ ( Top node on Stack has same height t' as node ) {\n          ADRS.setTreeIndex((ADRS.getTreeIndex()\
    \ - 1) / 2);\n          node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n   \
    \       ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n       }\n       Stack.push(node);\n\
    \     }\n     return Stack.pop();\n"
- title: 4.1.7.  XMSS Key Generation
  contents:
  - "4.1.7.  XMSS Key Generation\n   The XMSS key pair is computed as described in\
    \ XMSS_keyGen (Algorithm\n   10).  The XMSS public key PK consists of the root\
    \ of the binary hash\n   tree and the seed SEED, both also stored in SK.  The\
    \ root is computed\n   using treeHash.  For XMSS, there is only a single main\
    \ tree.  Hence,\n   the used address is set to the all-zero string in the beginning.\n\
    \   Note that we do not define any specific format or handling for the\n   XMSS\
    \ private key SK by introducing this algorithm.  It relates to\n   requirements\
    \ described earlier and simply shows a basic but very\n   inefficient example\
    \ to initialize a private key.\n   Algorithm 10: XMSS_keyGen - Generate an XMSS\
    \ key pair\n     Input: No input\n     Output: XMSS private key SK, XMSS public\
    \ key PK\n     // Example initialization for SK-specific contents\n     idx =\
    \ 0;\n     for ( i = 0; i < 2^h; i++ ) {\n       wots_sk[i] = WOTS_genSK();\n\
    \     }\n     initialize SK_PRF with a uniformly random n-byte string;\n     setSK_PRF(SK,\
    \ SK_PRF);\n     // Initialization for common contents\n     initialize SEED with\
    \ a uniformly random n-byte string;\n     setSEED(SK, SEED);\n     setWOTS_SK(SK,\
    \ wots_sk));\n     ADRS = toByte(0, 32);\n     root = treeHash(SK, 0, h, ADRS);\n\
    \     SK = idx || wots_sk || SK_PRF || root || SEED;\n     PK = OID || root ||\
    \ SEED;\n     return (SK || PK);\n   The above is just an example algorithm. \
    \ It is strongly RECOMMENDED\n   to use pseudorandom key generation to reduce\
    \ the private key size.\n   Public and private key generation MAY be interleaved\
    \ to save space.\n   Particularly, when a pseudorandom method is used to generate\
    \ the\n   private key, generation MAY be done when the respective WOTS+ key\n\
    \   pair is needed by treeHash.\n   The format of an XMSS public key is given\
    \ below.\n            +---------------------------------+\n            |     \
    \     algorithm OID          |\n            +---------------------------------+\n\
    \            |                                 |\n            |            root\
    \ node            |     n bytes\n            |                               \
    \  |\n            +---------------------------------+\n            |         \
    \                        |\n            |              SEED               |  \
    \   n bytes\n            |                                 |\n            +---------------------------------+\n\
    \                              XMSS Public Key\n"
- title: 4.1.8.  XMSS Signature
  contents:
  - "4.1.8.  XMSS Signature\n   An XMSS signature is a (4 + n + (len + h) * n)-byte\
    \ string consisting\n   of:\n   o  the index idx_sig of the used WOTS+ key pair\
    \ (4 bytes),\n   o  a byte string r used for randomized message hashing (n bytes),\n\
    \   o  a WOTS+ signature sig_ots (len * n bytes), and\n   o  the so-called authentication\
    \ path 'auth' for the leaf associated\n      with the used WOTS+ key pair (h *\
    \ n bytes).\n   The authentication path is an array of h n-byte strings.  It contains\n\
    \   the siblings of the nodes on the path from the used leaf to the root.\n  \
    \ It does not contain the nodes on the path itself.  A verifier needs\n   these\
    \ nodes to compute a root node for the tree from the WOTS+ public\n   key.  A\
    \ node Node is addressed by its position in the tree.  Node(x,\n   y) denotes\
    \ the y^th node on level x with y = 0 being the leftmost\n   node on a level.\
    \  The leaves are on level 0; the root is on level h.\n   An authentication path\
    \ contains exactly one node on every layer 0 <=\n   x <= (h - 1).  For the i^th\
    \ WOTS+ key pair, counting from zero, the\n   j^th authentication path node is:\n\
    \      Node(j, floor(i / (2^j)) XOR 1)\n   The computation of the authentication\
    \ path is discussed in\n   Section 4.1.9.\n   The data format for a signature\
    \ is given below.\n             +---------------------------------+\n        \
    \     |                                 |\n             |          index idx_sig\
    \          |    4 bytes\n             |                                 |\n  \
    \           +---------------------------------+\n             |              \
    \                   |\n             |          randomness r           |    n bytes\n\
    \             |                                 |\n             +---------------------------------+\n\
    \             |                                 |\n             |     WOTS+ signature\
    \ sig_ots     |    len * n bytes\n             |                             \
    \    |\n             +---------------------------------+\n             |     \
    \                            |\n             |             auth[0]           \
    \  |    n bytes\n             |                                 |\n          \
    \   +---------------------------------+\n             |                      \
    \           |\n             ~              ....               ~\n            \
    \ |                                 |\n             +---------------------------------+\n\
    \             |                                 |\n             |           auth[h\
    \ - 1]           |    n bytes\n             |                                \
    \ |\n             +---------------------------------+\n                      \
    \        XMSS Signature\n"
- title: 4.1.9.  XMSS Signature Generation
  contents:
  - "4.1.9.  XMSS Signature Generation\n   To compute the XMSS signature of a message\
    \ M with an XMSS private\n   key, the signer first computes a randomized message\
    \ digest using a\n   random value r, idx_sig, the index of the WOTS+ key pair\
    \ to be used,\n   and the root value from the public key as key.  Then, a WOTS+\n\
    \   signature of the message digest is computed using the next unused\n   WOTS+\
    \ private key.  Next, the authentication path is computed.\n   Finally, the private\
    \ key is updated, i.e., idx is incremented.  An\n   implementation MUST NOT output\
    \ the signature before the private key\n   is updated.\n   The node values of\
    \ the authentication path MAY be computed in any\n   way.  This computation is\
    \ assumed to be performed by the subroutine\n   buildAuth for the function XMSS_sign\
    \ (Algorithm 12).  The fastest\n   alternative is to store all tree nodes and\
    \ set the array in the\n   signature by copying the respective nodes.  The least\
    \ storage-\n   intensive alternative is to recompute all nodes for each signature\n\
    \   online using the treeHash algorithm (Algorithm 9).  Several\n   algorithms\
    \ exist in between, with different time/storage trade-offs.\n   For an overview,\
    \ see [BDS09].  A further approach can be found in\n   [KMN14].  Note that the\
    \ details of this procedure are not relevant to\n   interoperability; it is not\
    \ necessary to know any of these details in\n   order to perform the signature\
    \ verification operation.  The following\n   version of buildAuth is given for\
    \ completeness.  It is a simple\n   example for understanding, but extremely inefficient.\
    \  The use of one\n   of the alternative algorithms is strongly RECOMMENDED.\n\
    \   Given an XMSS private key SK, all nodes in a tree are determined.\n   Their\
    \ values are defined in terms of treeHash (Algorithm 9).  Hence,\n   one can compute\
    \ the authentication path as follows:\n   (Example) buildAuth - Compute the authentication\
    \ path for the i^th\n   WOTS+ key pair\n     Input: XMSS private key SK, WOTS+\
    \ key pair index i, ADRS\n     Output: Authentication path auth\n     for ( j\
    \ = 0; j < h; j++ ) {\n       k = floor(i / (2^j)) XOR 1;\n       auth[j] = treeHash(SK,\
    \ k * 2^j, j, ADRS);\n     }\n   We split the description of the signature generation\
    \ into two main\n   algorithms.  The first one, treeSig (Algorithm 11), generates\
    \ the\n   main part of an XMSS signature and is also used by the multi-tree\n\
    \   variant XMSS^MT.  XMSS_sign (Algorithm 12) calls treeSig but handles\n   message\
    \ compression before and the private key update afterwards.\n   The algorithm\
    \ treeSig (Algorithm 11) described below calculates the\n   WOTS+ signature on\
    \ an n-byte message and the corresponding\n   authentication path.  treeSig takes\
    \ as input an n-byte message M', an\n   XMSS private key SK, a signature index\
    \ idx_sig, and an address ADRS.\n   It returns the concatenation of the WOTS+\
    \ signature sig_ots and\n   authentication path auth.\n   Algorithm 11: treeSig\
    \ - Generate a WOTS+ signature on a message with\n   corresponding authentication\
    \ path\n     Input: n-byte message M', XMSS private key SK,\n            signature\
    \ index idx_sig, ADRS\n     Output: Concatenation of WOTS+ signature sig_ots and\n\
    \             authentication path auth\n     auth = buildAuth(SK, idx_sig, ADRS);\n\
    \     ADRS.setType(0);   // Type = OTS hash address\n     ADRS.setOTSAddress(idx_sig);\n\
    \     sig_ots = WOTS_sign(getWOTS_SK(SK, idx_sig),\n                         M',\
    \ getSEED(SK), ADRS);\n     Sig = sig_ots || auth;\n     return Sig;\n   The algorithm\
    \ XMSS_sign (Algorithm 12) described below calculates an\n   updated private key\
    \ SK and a signature on a message M.  XMSS_sign\n   takes as input a message M\
    \ of arbitrary length and an XMSS private\n   key SK.  It returns the byte string\
    \ containing the concatenation of\n   the updated private key SK and the signature\
    \ Sig.\n   Algorithm 12: XMSS_sign - Generate an XMSS signature and update the\n\
    \   XMSS private key\n     Input: Message M, XMSS private key SK\n     Output:\
    \ Updated SK, XMSS signature Sig\n     idx_sig = getIdx(SK);\n     setIdx(SK,\
    \ idx_sig + 1);\n     ADRS = toByte(0, 32);\n     byte[n] r = PRF(getSK_PRF(SK),\
    \ toByte(idx_sig, 32));\n     byte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig,\
    \ n)), M);\n     Sig = idx_sig || r || treeSig(M', SK, idx_sig, ADRS);\n     return\
    \ (SK || Sig);\n"
- title: 4.1.10.  XMSS Signature Verification
  contents:
  - "4.1.10.  XMSS Signature Verification\n   An XMSS signature is verified by first\
    \ computing the message digest\n   using randomness r, index idx_sig, the root\
    \ from PK and message M.\n   Then the used WOTS+ public key pk_ots is computed\
    \ from the WOTS+\n   signature using WOTS_pkFromSig.  The WOTS+ public key in\
    \ turn is used\n   to compute the corresponding leaf using an L-tree.  The leaf,\n\
    \   together with index idx_sig and authentication path auth is used to\n   compute\
    \ an alternative root value for the tree.  The verification\n   succeeds if and\
    \ only if the computed root value matches the one in\n   the XMSS public key.\
    \  In any other case, it MUST return fail.\n   As for signature generation, we\
    \ split verification into two parts to\n   allow for reuse in the XMSS^MT description.\
    \  The steps also needed\n   for XMSS^MT are done by the function XMSS_rootFromSig\
    \ (Algorithm 13).\n   XMSS_verify (Algorithm 14) calls XMSS_rootFromSig as a subroutine\
    \ and\n   handles the XMSS-specific steps.\n   The main part of XMSS signature\
    \ verification is done by the function\n   XMSS_rootFromSig (Algorithm 13) described\
    \ below.  XMSS_rootFromSig\n   takes as input an index idx_sig, a WOTS+ signature\
    \ sig_ots, an\n   authentication path auth, an n-byte message M', seed SEED, and\n\
    \   address ADRS.  XMSS_rootFromSig returns an n-byte string holding the\n   value\
    \ of the root of a tree defined by the input data.\n   Algorithm 13: XMSS_rootFromSig\
    \ - Compute a root node from a tree\n   signature\n     Input: index idx_sig,\
    \ WOTS+ signature sig_ots, authentication path\n            auth, n-byte message\
    \ M', seed SEED, address ADRS\n     Output: n-byte root value node[0]\n     ADRS.setType(0);\
    \   // Type = OTS hash address\n     ADRS.setOTSAddress(idx_sig);\n     pk_ots\
    \ = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);\n     ADRS.setType(1);   // Type\
    \ = L-tree address\n     ADRS.setLTreeAddress(idx_sig);\n     byte[n][2] node;\n\
    \     node[0] = ltree(pk_ots, SEED, ADRS);\n     ADRS.setType(2);   // Type =\
    \ hash tree address\n     ADRS.setTreeIndex(idx_sig);\n     for ( k = 0; k < h;\
    \ k++ ) {\n       ADRS.setTreeHeight(k);\n       if ( (floor(idx_sig / (2^k))\
    \ % 2) == 0 ) {\n         ADRS.setTreeIndex(ADRS.getTreeIndex() / 2);\n      \
    \   node[1] = RAND_HASH(node[0], auth[k], SEED, ADRS);\n       } else {\n    \
    \     ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);\n         node[1] = RAND_HASH(auth[k],\
    \ node[0], SEED, ADRS);\n       }\n       node[0] = node[1];\n     }\n     return\
    \ node[0];\n   The full XMSS signature verification is depicted below (Algorithm\n\
    \   14).  It handles message compression, delegates the root computation\n   to\
    \ XMSS_rootFromSig, and compares the result to the value in the\n   public key.\
    \  XMSS_verify takes as input an XMSS signature Sig, a\n   message M, and an XMSS\
    \ public key PK.  XMSS_verify returns true if\n   and only if Sig is a valid signature\
    \ on M under public key PK.\n   Otherwise, it returns false.\n   Algorithm 14:\
    \ XMSS_verify - Verify an XMSS signature using the\n   corresponding XMSS public\
    \ key and a message\n     Input: XMSS signature Sig, message M, XMSS public key\
    \ PK\n     Output: Boolean\n     ADRS = toByte(0, 32);\n     byte[n] M' = H_msg(r\
    \ || getRoot(PK) || (toByte(idx_sig, n)), M);\n     byte[n] node = XMSS_rootFromSig(idx_sig,\
    \ sig_ots, auth, M',\n                                     getSEED(PK), ADRS);\n\
    \     if ( node == getRoot(PK) ) {\n       return true;\n     } else {\n     \
    \  return false;\n     }\n"
- title: 4.1.11.  Pseudorandom Key Generation
  contents:
  - "4.1.11.  Pseudorandom Key Generation\n   An implementation MAY use a cryptographically\
    \ secure pseudorandom\n   method to generate the XMSS private key from a single\
    \ n-byte value.\n   For example, the method suggested in [BDH11] and explained\
    \ below MAY\n   be used.  Other methods, such as the one in [HRS16], MAY be used.\n\
    \   The choice of a pseudorandom method does not affect interoperability,\n  \
    \ but the cryptographic strength MUST match that of the used XMSS\n   parameters.\n\
    \   For XMSS, a method similar to that for WOTS+ can be used.  The\n   suggested\
    \ method from [BDH11] can be described using PRF.  During key\n   generation,\
    \ a uniformly random n-byte string S is sampled from a\n   secure source of randomness.\
    \  This seed S MUST NOT be confused with\n   the public seed SEED.  The seed S\
    \ MUST be independent of SEED, and\n   because it is the main secret, it MUST\
    \ be kept secret.  This seed S\n   is used to generate an n-byte value S_ots for\
    \ each WOTS+ key pair.\n   The n-byte value S_ots can then be used to compute\
    \ the respective\n   WOTS+ private key using the method described in Section 3.1.7.\
    \  The\n   seeds for the WOTS+ key pairs are computed as S_ots[i] = PRF(S,\n \
    \  toByte(i, 32)) where i is the index of the WOTS+ key pair.  An\n   advantage\
    \ of this method is that a WOTS+ key can be computed using\n   only len + 1 evaluations\
    \ of PRF when S is given.\n"
- title: 4.1.12.  Free Index Handling and Partial Private Keys
  contents:
  - "4.1.12.  Free Index Handling and Partial Private Keys\n   Some applications might\
    \ require working with partial private keys or\n   copies of private keys.  Examples\
    \ include load balancing and\n   delegation of signing rights or proxy signatures.\
    \  Such applications\n   MAY use their own key format and MAY use a signing algorithm\n\
    \   different from the one described above.  The index in partial private\n  \
    \ keys or copies of a private key MAY be manipulated as required by the\n   applications.\
    \  However, applications MUST establish means that\n   guarantee that each index,\
    \ and thereby each WOTS+ key pair, is used\n   to sign only a single message.\n"
- title: '4.2.  XMSS^MT: Multi-Tree XMSS'
  contents:
  - "4.2.  XMSS^MT: Multi-Tree XMSS\n   XMSS^MT is a method for signing a large but\
    \ fixed number of messages.\n   It was first described in [HRB13].  It builds\
    \ on XMSS.  XMSS^MT uses\n   a tree of several layers of XMSS trees, a so-called\
    \ hypertree.  The\n   trees on top and intermediate layers are used to sign the\
    \ root nodes\n   of the trees on the respective layer below.  Trees on the lowest\n\
    \   layer are used to sign the actual messages.  All XMSS trees have\n   equal\
    \ height.\n   Consider an XMSS^MT tree of total height h that has d layers of\
    \ XMSS\n   trees of height h / d.  Then, layer d - 1 contains one XMSS tree,\n\
    \   layer d - 2 contains 2^(h / d) XMSS trees, and so on.  Finally, layer\n  \
    \ 0 contains 2^(h - h / d) XMSS trees.\n"
- title: 4.2.1.  XMSS^MT Parameters
  contents:
  - "4.2.1.  XMSS^MT Parameters\n   In addition to all XMSS parameters, an XMSS^MT\
    \ system requires the\n   number of tree layers d, specified as an integer value\
    \ that divides h\n   without remainder.  The same tree height h / d and the same\n\
    \   Winternitz parameter w are used for all tree layers.\n   All the trees on\
    \ higher layers sign root nodes of other trees, with\n   the root nodes being\
    \ n-byte strings.  Hence, no message compression\n   is needed, and WOTS+ is used\
    \ to sign the root nodes themselves\n   instead of their hash values.\n"
- title: 4.2.2.  XMSS^MT Key Generation
  contents:
  - "4.2.2.  XMSS^MT Key Generation\n   An XMSS^MT private key SK_MT (S for secret)\
    \ consists of one reduced\n   XMSS private key for each XMSS tree.  These reduced\
    \ XMSS private keys\n   just contain the WOTS+ private keys corresponding to that\
    \ XMSS key\n   pair; they do not contain a pseudorandom function key, index, public\n\
    \   seed, or root node.  Instead, SK_MT contains a single n-byte\n   pseudorandom\
    \ function key SK_PRF, a single (ceil(h / 8))-byte index\n   idx_MT, a single\
    \ n-byte seed SEED, and a single root value root\n   (which is the root of the\
    \ single tree on the top layer).  The index\n   is a global index over all WOTS+\
    \ key pairs of all XMSS trees on layer\n   0.  It is initialized with 0.  It stores\
    \ the index of the last used\n   WOTS+ key pair on the bottom layer, i.e., a number\
    \ between 0 and 2^h\n   - 1.\n   The reduced XMSS private keys MUST either be\
    \ generated as described\n   in Section 4.1.3 or be generated using a cryptographic\
    \ pseudorandom\n   method as discussed in Section 4.2.6.  As for XMSS, the PRF\
    \ key\n   SK_PRF MUST be sampled from a secure source of randomness that\n   follows\
    \ the uniform distribution.  SEED is generated as a uniformly\n   random n-byte\
    \ string.  Although SEED is public, it is critical for\n   security that it is\
    \ generated using a good entropy source.  The root\n   is the root node of the\
    \ single XMSS tree on the top layer.  Its\n   computation is explained below.\
    \  As for XMSS, root and SEED are\n   public information and would classically\
    \ be considered part of the\n   public key.  However, as both are needed for signing,\
    \ which only\n   takes the private key, they are also part of SK_MT.\n   This\
    \ document does not define any specific format for the XMSS^MT\n   private key\
    \ SK_MT as it is not required for interoperability.\n   Algorithms 15 and 16 use\
    \ a function getXMSS_SK(SK, x, y) that outputs\n   the reduced private key of\
    \ the x^th XMSS tree on the y^th layer.\n   The XMSS^MT public key PK_MT contains\
    \ the root of the single XMSS\n   tree on layer d - 1 and the seed SEED.  These\
    \ are the same values as\n   in the private key SK_MT.  The pseudorandom function\
    \ PRF keyed with\n   SEED is used to generate the bitmasks and keys for all XMSS\
    \ trees.\n   XMSSMT_keyGen (Algorithm 15) shows example pseudocode to generate\n\
    \   SK_MT and PK_MT.  The n-byte root node of the top-layer tree is\n   computed\
    \ using treeHash.  The algorithm XMSSMT_keyGen outputs an\n   XMSS^MT private\
    \ key SK_MT and an XMSS^MT public key PK_MT.  The\n   algorithm below gives an\
    \ example of how the reduced XMSS private keys\n   can be generated.  However,\
    \ any of the above mentioned ways is\n   acceptable as long as the cryptographic\
    \ strength of the used method\n   matches or supersedes that of the used XMSS^MT\
    \ parameter set.\n   Algorithm 15: XMSSMT_keyGen - Generate an XMSS^MT key pair\n\
    \     Input: No input\n     Output: XMSS^MT private key SK_MT, XMSS^MT public\
    \ key PK_MT\n     // Example initialization\n     idx_MT = 0;\n     setIdx(SK_MT,\
    \ idx_MT);\n     initialize SK_PRF with a uniformly random n-byte string;\n  \
    \   setSK_PRF(SK_MT, SK_PRF);\n     initialize SEED with a uniformly random n-byte\
    \ string;\n     setSEED(SK_MT, SEED);\n     // Generate reduced XMSS private keys\n\
    \     ADRS = toByte(0, 32);\n     for ( layer = 0; layer < d; layer++ ) {\n  \
    \      ADRS.setLayerAddress(layer);\n        for ( tree = 0; tree <\n        \
    \      (1 << ((d - 1 - layer) * (h / d)));\n              tree++ ) {\n       \
    \    ADRS.setTreeAddress(tree);\n           for ( i = 0; i < 2^(h / d); i++ )\
    \ {\n             wots_sk[i] = WOTS_genSK();\n           }\n           setXMSS_SK(SK_MT,\
    \ wots_sk, tree, layer);\n        }\n     }\n     SK = getXMSS_SK(SK_MT, 0, d\
    \ - 1);\n     setSEED(SK, SEED);\n     root = treeHash(SK, 0, h / d, ADRS);\n\
    \     setRoot(SK_MT, root);\n     PK_MT = OID || root || SEED;\n     return (SK_MT\
    \ || PK_MT);\n   The above is just an example algorithm.  It is strongly RECOMMENDED\n\
    \   to use pseudorandom key generation to reduce the private key size.\n   Public\
    \ and private key generation MAY be interleaved to save space.\n   In particular,\
    \ when a pseudorandom method is used to generate the\n   private key, generation\
    \ MAY be delayed to the point that the\n   respective WOTS+ key pair is needed\
    \ by another algorithm.\n   The format of an XMSS^MT public key is given below.\n\
    \            +---------------------------------+\n            |          algorithm\
    \ OID          |\n            +---------------------------------+\n          \
    \  |                                 |\n            |            root node   \
    \         |     n bytes\n            |                                 |\n   \
    \         +---------------------------------+\n            |                 \
    \                |\n            |              SEED               |     n bytes\n\
    \            |                                 |\n            +---------------------------------+\n\
    \                            XMSS^MT Public Key\n"
- title: 4.2.3.  XMSS^MT Signature
  contents:
  - "4.2.3.  XMSS^MT Signature\n   An XMSS^MT signature Sig_MT is a byte string of\
    \ length (ceil(h / 8) +\n   n + (h + d * len) * n).  It consists of:\n   o  the\
    \ index idx_sig of the used WOTS+ key pair on the bottom layer\n      (ceil(h\
    \ / 8) bytes),\n   o  a byte string r used for randomized message hashing (n bytes),\
    \ and\n   o  d reduced XMSS signatures ((h / d + len) * n bytes each).\n   The\
    \ reduced XMSS signatures only contain a WOTS+ signature sig_ots\n   and an authentication\
    \ path auth.  They contain no index idx and no\n   byte string r.\n   The data\
    \ format for a signature is given below.\n           +---------------------------------+\n\
    \           |                                 |\n           |          index idx_sig\
    \          |   ceil(h / 8) bytes\n           |                               \
    \  |\n           +---------------------------------+\n           |           \
    \                      |\n           |          randomness r           |   n bytes\n\
    \           |                                 |\n           +---------------------------------+\n\
    \           |                                 |\n           |  (reduced) XMSS\
    \ signature Sig   |   (h / d + len) * n bytes\n           |        (bottom layer\
    \ 0)         |\n           |                                 |\n           +---------------------------------+\n\
    \           |                                 |\n           |  (reduced) XMSS\
    \ signature Sig   |   (h / d + len) * n bytes\n           |            (layer\
    \ 1)            |\n           |                                 |\n          \
    \ +---------------------------------+\n           |                          \
    \       |\n           ~              ....               ~\n           |      \
    \                           |\n           +---------------------------------+\n\
    \           |                                 |\n           |  (reduced) XMSS\
    \ signature Sig   |   (h / d + len) * n bytes\n           |          (layer d\
    \ - 1)          |\n           |                                 |\n          \
    \ +---------------------------------+\n                             XMSS^MT Signature\n"
- title: 4.2.4.  XMSS^MT Signature Generation
  contents:
  - "4.2.4.  XMSS^MT Signature Generation\n   To compute the XMSS^MT signature Sig_MT\
    \ of a message M using an\n   XMSS^MT private key SK_MT, XMSSMT_sign (Algorithm\
    \ 16) described below\n   uses treeSig as defined in Section 4.1.9.  First, the\
    \ signature index\n   is set to idx_sig.  Next, PRF is used to compute a pseudorandom\n\
    \   n-byte string r.  This n-byte string, idx_sig, and the root node from\n  \
    \ PK_MT are then used to compute a randomized message digest of length\n   n.\
    \  The message digest is signed using the WOTS+ key pair on the\n   bottom layer\
    \ with absolute index idx.  The authentication path for\n   the WOTS+ key pair\
    \ and the root of the containing XMSS tree are\n   computed.  The root is signed\
    \ by the parent XMSS tree.  This is\n   repeated until the top tree is reached.\n\
    \   Algorithm 16: XMSSMT_sign - Generate an XMSS^MT signature and update\n   the\
    \ XMSS^MT private key\n     Input: Message M, XMSS^MT private key SK_MT\n    \
    \ Output: Updated SK_MT, signature Sig_MT\n     // Init\n     ADRS = toByte(0,\
    \ 32);\n     SEED = getSEED(SK_MT);\n     SK_PRF = getSK_PRF(SK_MT);\n     idx_sig\
    \ = getIdx(SK_MT);\n     // Update SK_MT\n     setIdx(SK_MT, idx_sig + 1);\n \
    \    // Message compression\n     byte[n] r = PRF(SK_PRF, toByte(idx_sig, 32));\n\
    \     byte[n] M' = H_msg(r || getRoot(SK_MT) || (toByte(idx_sig, n)), M);\n  \
    \   // Sign\n     Sig_MT = idx_sig;\n     unsigned int idx_tree\n            \
    \       = (h - h / d) most significant bits of idx_sig;\n     unsigned int idx_leaf\
    \ = (h / d) least significant bits of idx_sig;\n     SK = idx_leaf || getXMSS_SK(SK_MT,\
    \ idx_tree, 0) || SK_PRF\n           || toByte(0, n) || SEED;\n     ADRS.setLayerAddress(0);\n\
    \     ADRS.setTreeAddress(idx_tree);\n     Sig_tmp = treeSig(M', SK, idx_leaf,\
    \ ADRS);\n     Sig_MT = Sig_MT || r || Sig_tmp;\n     for ( j = 1; j < d; j++\
    \ ) {\n        root = treeHash(SK, 0, h / d, ADRS);\n        idx_leaf = (h / d)\
    \ least significant bits of idx_tree;\n        idx_tree = (h - j * (h / d)) most\
    \ significant bits of idx_tree;\n        SK = idx_leaf || getXMSS_SK(SK_MT, idx_tree,\
    \ j) || SK_PRF\n               || toByte(0, n) || SEED;\n        ADRS.setLayerAddress(j);\n\
    \        ADRS.setTreeAddress(idx_tree);\n        Sig_tmp = treeSig(root, SK, idx_leaf,\
    \ ADRS);\n        Sig_MT = Sig_MT || Sig_tmp;\n     }\n     return SK_MT || Sig_MT;\n\
    \   Algorithm 16 is only one method to compute XMSS^MT signatures.  Time-\n  \
    \ memory trade-offs exist that allow reduction of the signing time to\n   less\
    \ than the signing time of an XMSS scheme with tree height h / d.\n   These trade-offs\
    \ 1) prevent certain values from being recomputed\n   several times by keeping\
    \ a state and 2) distribute all computations\n   over all signature generations.\
    \  Details can be found in\n   [Huelsing13a].\n"
- title: 4.2.5.  XMSS^MT Signature Verification
  contents:
  - "4.2.5.  XMSS^MT Signature Verification\n   XMSS^MT signature verification (Algorithm\
    \ 17) can be summarized as d\n   XMSS signature verifications with small changes.\
    \  First, the message\n   is hashed.  The XMSS signatures are then all on n-byte\
    \ values.\n   Second, instead of comparing the computed root node to a given value,\n\
    \   a signature on this root node is verified.  Only the root node of the\n  \
    \ top tree is compared to the value in the XMSS^MT public key.\n   XMSSMT_verify\
    \ uses XMSS_rootFromSig.  The function\n   getXMSSSignature(Sig_MT, i) returns\
    \ the ith reduced XMSS signature\n   from the XMSS^MT signature Sig_MT.  XMSSMT_verify\
    \ takes as input an\n   XMSS^MT signature Sig_MT, a message M, and a public key\
    \ PK_MT.\n   XMSSMT_verify returns true if and only if Sig_MT is a valid signature\n\
    \   on M under public key PK_MT.  Otherwise, it returns false.\n   Algorithm 17:\
    \ XMSSMT_verify - Verify an XMSS^MT signature Sig_MT on a\n   message M using\
    \ an XMSS^MT public key PK_MT\n     Input: XMSS^MT signature Sig_MT, message M,\n\
    \            XMSS^MT public key PK_MT\n     Output: Boolean\n     idx_sig = getIdx(Sig_MT);\n\
    \     SEED = getSEED(PK_MT);\n     ADRS = toByte(0, 32);\n     byte[n] M' = H_msg(getR(Sig_MT)\
    \ || getRoot(PK_MT)\n                        || (toByte(idx_sig, n)), M);\n  \
    \   unsigned int idx_leaf\n                   = (h / d) least significant bits\
    \ of idx_sig;\n     unsigned int idx_tree\n                   = (h - h / d) most\
    \ significant bits of idx_sig;\n     Sig' = getXMSSSignature(Sig_MT, 0);\n   \
    \  ADRS.setLayerAddress(0);\n     ADRS.setTreeAddress(idx_tree);\n     byte[n]\
    \ node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),\n                      \
    \                getAuth(Sig'), M', SEED, ADRS);\n     for ( j = 1; j < d; j++\
    \ ) {\n        idx_leaf = (h / d) least significant bits of idx_tree;\n      \
    \  idx_tree = (h - j * h / d) most significant bits of idx_tree;\n        Sig'\
    \ = getXMSSSignature(Sig_MT, j);\n        ADRS.setLayerAddress(j);\n        ADRS.setTreeAddress(idx_tree);\n\
    \        node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),\n               \
    \               getAuth(Sig'), node, SEED, ADRS);\n     }\n     if ( node == getRoot(PK_MT)\
    \ ) {\n       return true;\n     } else {\n       return false;\n     }\n"
- title: 4.2.6.  Pseudorandom Key Generation
  contents:
  - "4.2.6.  Pseudorandom Key Generation\n   Like for XMSS, an implementation MAY\
    \ use a cryptographically secure\n   pseudorandom method to generate the XMSS^MT\
    \ private key from a single\n   n-byte value.  For example, the method explained\
    \ below MAY be used.\n   Other methods, such as the one in [HRS16], MAY be used.\
    \  The choice\n   of a pseudorandom method does not affect interoperability, but\
    \ the\n   cryptographic strength MUST match that of the used XMSS^MT\n   parameters.\n\
    \   For XMSS^MT, a method similar to that for XMSS and WOTS+ can be used.\n  \
    \ The method uses PRF.  During key generation, a uniformly random\n   n-byte string\
    \ S_MT is sampled from a secure source of randomness.\n   This seed S_MT is used\
    \ to generate one n-byte value S for each XMSS\n   key pair.  This n-byte value\
    \ can be used to compute the respective\n   XMSS private key using the method\
    \ described in Section 4.1.11.  Let\n   S[x][y] be the seed for the x^th XMSS\
    \ private key on layer y.  The\n   seeds are computed as S[x][y] = PRF(PRF(S,\
    \ toByte(y, 32)), toByte(x,\n   32)).\n"
- title: 4.2.7.  Free Index Handling and Partial Private Keys
  contents:
  - "4.2.7.  Free Index Handling and Partial Private Keys\n   The content of Section\
    \ 4.1.12 also applies to XMSS^MT.\n"
- title: 5.  Parameter Sets
  contents:
  - "5.  Parameter Sets\n   This section provides basic parameter sets that are assumed\
    \ to cover\n   most relevant applications.  Parameter sets for two classical\n\
    \   security levels are defined.  Parameters with n = 32 provide a\n   classical\
    \ security level of 256 bits.  Parameters with n = 64 provide\n   a classical\
    \ security level of 512 bits.  Considering quantum-\n   computer-aided attacks,\
    \ these output sizes yield post-quantum\n   security of 128 and 256 bits, respectively.\n\
    \   While this document specifies several parameter sets, an\n   implementation\
    \ is only REQUIRED to provide support for verification\n   of all REQUIRED parameter\
    \ sets.  The REQUIRED parameter sets all use\n   SHA2-256 to instantiate all functions.\
    \  The REQUIRED parameter sets\n   are only distinguished by the tree height parameter\
    \ h (which\n   determines the number of signatures that can be done with a single\n\
    \   key pair) and the number of layers d (which defines a trade-off\n   between\
    \ speed and signature size).  An implementation MAY provide\n   support for signature\
    \ generation using any of the proposed parameter\n   sets.  For convenience, this\
    \ document defines a default option for\n   XMSS (XMSS_SHA2_20_256) and XMSS^MT\
    \ (XMSSMT-SHA2_60/3_256).  These\n   are supposed to match the most generic requirements.\n"
- title: 5.1.  Implementing the Functions
  contents:
  - "5.1.  Implementing the Functions\n   For the n = 32 setting, we give parameters\
    \ that use SHA2-256 as\n   defined in [FIPS180] and other parameters that use\
    \ the SHA3/Keccak-\n   based extendable-output function SHAKE-128 as defined in\
    \ [FIPS202].\n   For the n = 64 setting, we give parameters that use SHA2-512\
    \ as\n   defined in [FIPS180] and other parameters that use the SHA3/Keccak-\n\
    \   based extendable-output functions SHAKE-256 as defined in [FIPS202].\n   The\
    \ parameter sets using SHA2-256 are mandatory for deployment and\n   therefore\
    \ MUST be provided by any implementation.  The remaining\n   parameter sets specified\
    \ in this document are OPTIONAL.\n   SHA2 does not provide a keyed-mode itself.\
    \  To implement the keyed\n   hash functions, the following is used for SHA2 with\
    \ n = 32:\n      F: SHA2-256(toByte(0, 32) || KEY || M),\n      H: SHA2-256(toByte(1,\
    \ 32) || KEY || M),\n      H_msg: SHA2-256(toByte(2, 32) || KEY || M), and\n \
    \     PRF: SHA2-256(toByte(3, 32) || KEY || M).\n   Accordingly, for SHA2 with\
    \ n = 64 we use:\n      F: SHA2-512(toByte(0, 64) || KEY || M),\n      H: SHA2-512(toByte(1,\
    \ 64) || KEY || M),\n      H_msg: SHA2-512(toByte(2, 64) || KEY || M), and\n \
    \     PRF: SHA2-512(toByte(3, 64) || KEY || M).\n   The n-byte padding is used\
    \ for two reasons.  First, it is necessary\n   that the internal compression function\
    \ takes 2n-byte blocks, but keys\n   are n and 3n bytes long.  Second, the padding\
    \ is used to achieve\n   independence of the different function families.  Finally,\
    \ for the\n   PRF, no full-fledged Hash-Based Message Authentication Code (HMAC)\
    \ is\n   needed as the message length is fixed, meaning that standard length\n\
    \   extension attacks are not a concern here.  For that reason, the\n   simpler\
    \ construction above suffices.\n   Similar constructions are used with SHA3. \
    \ To implement the keyed\n   hash functions, the following is used for SHA3 with\
    \ n = 32:\n      F: SHAKE128(toByte(0, 32) || KEY || M, 256),\n      H: SHAKE128(toByte(1,\
    \ 32) || KEY || M, 256),\n      H_msg: SHAKE128(toByte(2, 32) || KEY || M, 256),\n\
    \      PRF: SHAKE128(toByte(3, 32) || KEY || M, 256).\n   Accordingly, for SHA3\
    \ with n = 64, we use:\n      F: SHAKE256(toByte(0, 64) || KEY || M, 512),\n \
    \     H: SHAKE256(toByte(1, 64) || KEY || M, 512),\n      H_msg: SHAKE256(toByte(2,\
    \ 64) || KEY || M, 512),\n      PRF: SHAKE256(toByte(3, 64) || KEY || M, 512).\n\
    \   As for SHA2, an initial n-byte identifier is used to achieve\n   independence\
    \ of the different function families.  While a shorter\n   identifier could be\
    \ used in case of SHA3, we use n bytes for\n   consistency with the SHA2 implementations.\n"
- title: 5.2.  WOTS+ Parameters
  contents:
  - "5.2.  WOTS+ Parameters\n   To fully describe a WOTS+ signature method, the parameters\
    \ n and w,\n   as well as the functions F and PRF, MUST be specified.  The following\n\
    \   table defines several WOTS+ signature systems, each of which is\n   identified\
    \ by a name.  Naming follows this convention:\n   WOTSP-[Hashfamily]_[n in bits].\
    \  Naming does not include w as all\n   parameter sets in this document use w=16.\
    \  Values for len are\n   provided for convenience.\n              +-----------------+----------+----+----+-----+\n\
    \              | Name            | F / PRF  |  n |  w | len |\n              +-----------------+----------+----+----+-----+\n\
    \              | REQUIRED:       |          |    |    |     |\n              |\
    \                 |          |    |    |     |\n              | WOTSP-SHA2_256\
    \  | SHA2-256 | 32 | 16 |  67 |\n              |                 |          |\
    \    |    |     |\n              | OPTIONAL:       |          |    |    |    \
    \ |\n              |                 |          |    |    |     |\n          \
    \    | WOTSP-SHA2_512  | SHA2-512 | 64 | 16 | 131 |\n              |         \
    \        |          |    |    |     |\n              | WOTSP-SHAKE_256 | SHAKE128\
    \ | 32 | 16 |  67 |\n              |                 |          |    |    |  \
    \   |\n              | WOTSP-SHAKE_512 | SHAKE256 | 64 | 16 | 131 |\n        \
    \      +-----------------+----------+----+----+-----+\n                      \
    \            Table 1\n   The implementation of the single functions is done as\
    \ described\n   above.  External Data Representation (XDR) formats for WOTS+ are\n\
    \   listed in Appendix A.\n"
- title: 5.3.  XMSS Parameters
  contents:
  - "5.3.  XMSS Parameters\n   To fully describe an XMSS signature method, the parameters\
    \ n, w, and\n   h, as well as the functions F, H, H_msg, and PRF, MUST be specified.\n\
    \   The following table defines different XMSS signature systems, each of\n  \
    \ which is identified by a name.  Naming follows this convention:\n   XMSS-[Hashfamily]_[h]_[n\
    \ in bits].  Naming does not include w as all\n   parameter sets in this document\
    \ use w=16.\n          +-------------------+-----------+----+----+-----+----+\n\
    \          | Name              | Functions |  n |  w | len |  h |\n          +-------------------+-----------+----+----+-----+----+\n\
    \          | REQUIRED:         |           |    |    |     |    |\n          |\
    \                   |           |    |    |     |    |\n          | XMSS-SHA2_10_256\
    \  | SHA2-256  | 32 | 16 |  67 | 10 |\n          |                   |       \
    \    |    |    |     |    |\n          | XMSS-SHA2_16_256  | SHA2-256  | 32 |\
    \ 16 |  67 | 16 |\n          |                   |           |    |    |     |\
    \    |\n          | XMSS-SHA2_20_256  | SHA2-256  | 32 | 16 |  67 | 20 |\n   \
    \       |                   |           |    |    |     |    |\n          | OPTIONAL:\
    \         |           |    |    |     |    |\n          |                   |\
    \           |    |    |     |    |\n          | XMSS-SHA2_10_512  | SHA2-512 \
    \ | 64 | 16 | 131 | 10 |\n          |                   |           |    |   \
    \ |     |    |\n          | XMSS-SHA2_16_512  | SHA2-512  | 64 | 16 | 131 | 16\
    \ |\n          |                   |           |    |    |     |    |\n      \
    \    | XMSS-SHA2_20_512  | SHA2-512  | 64 | 16 | 131 | 20 |\n          |     \
    \              |           |    |    |     |    |\n          | XMSS-SHAKE_10_256\
    \ | SHAKE128  | 32 | 16 |  67 | 10 |\n          |                   |        \
    \   |    |    |     |    |\n          | XMSS-SHAKE_16_256 | SHAKE128  | 32 | 16\
    \ |  67 | 16 |\n          |                   |           |    |    |     |  \
    \  |\n          | XMSS-SHAKE_20_256 | SHAKE128  | 32 | 16 |  67 | 20 |\n     \
    \     |                   |           |    |    |     |    |\n          | XMSS-SHAKE_10_512\
    \ | SHAKE256  | 64 | 16 | 131 | 10 |\n          |                   |        \
    \   |    |    |     |    |\n          | XMSS-SHAKE_16_512 | SHAKE256  | 64 | 16\
    \ | 131 | 16 |\n          |                   |           |    |    |     |  \
    \  |\n          | XMSS-SHAKE_20_512 | SHAKE256  | 64 | 16 | 131 | 20 |\n     \
    \     +-------------------+-----------+----+----+-----+----+\n               \
    \                   Table 2\n   The XDR formats for XMSS are listed in Appendix\
    \ B.\n"
- title: 5.3.1.  Parameter Guide
  contents:
  - "5.3.1.  Parameter Guide\n   In contrast to traditional signature schemes like\
    \ RSA or Digital\n   Signature Algorithm (DSA), XMSS has a tree height parameter\
    \ h that\n   determines the number of messages that can be signed with one key\n\
    \   pair.  Increasing the height allows using a key pair for more\n   signatures,\
    \ but it also increases the signature size and slows down\n   key generation,\
    \ signing, and verification.  To demonstrate the impact\n   of different values\
    \ of h, the following table shows signature size\n   and runtimes.  Runtimes are\
    \ given as the number of calls to F and H\n   when the BDS algorithm is used to\
    \ compute authentication paths for\n   the worst case.  The last column shows\
    \ the number of messages that\n   can be signed with one key pair.  The numbers\
    \ are the same for the\n   XMSS-SHAKE instances with same parameters h and n.\n\
    \    +------------------+-------+------------+--------+--------+-------+\n   \
    \ | Name             | |Sig| |     KeyGen |   Sign | Verify | #Sigs |\n    +------------------+-------+------------+--------+--------+-------+\n\
    \    | REQUIRED:        |       |            |        |        |       |\n   \
    \ |                  |       |            |        |        |       |\n    | XMSS-SHA2_10_256\
    \ | 2,500 |  1,238,016 |  5,725 |  1,149 |  2^10 |\n    |                  | \
    \      |            |        |        |       |\n    | XMSS-SHA2_16_256 | 2,692\
    \ |    79*10^6 |  9,163 |  1,155 |  2^16 |\n    |                  |       | \
    \           |        |        |       |\n    | XMSS-SHA2_20_256 | 2,820 | 1,268*10^6\
    \ | 11,455 |  1,159 |  2^20 |\n    |                  |       |            | \
    \       |        |       |\n    | OPTIONAL:        |       |            |    \
    \    |        |       |\n    |                  |       |            |       \
    \ |        |       |\n    | XMSS-SHA2_10_512 | 9,092 |  2,417,664 | 11,165 | \
    \ 2,237 |  2^10 |\n    |                  |       |            |        |    \
    \    |       |\n    | XMSS-SHA2_16_512 | 9,476 |   155*10^6 | 17,867 |  2,243\
    \ |  2^16 |\n    |                  |       |            |        |        | \
    \      |\n    | XMSS-SHA2_20_512 | 9,732 | 2,476*10^6 | 22,335 |  2,247 |  2^20\
    \ |\n    +------------------+-------+------------+--------+--------+-------+\n\
    \                                  Table 3\n   As a default, users without special\
    \ requirements should use option\n   XMSS-SHA2_20_256, which allows signing of\
    \ 2^20 messages with one key\n   pair and provides reasonable speed and signature\
    \ size.  Users that\n   require more signatures per key pair or faster key generation\
    \ should\n   consider XMSS^MT.\n"
- title: 5.4.  XMSS^MT Parameters
  contents:
  - "5.4.  XMSS^MT Parameters\n   To fully describe an XMSS^MT signature method, the\
    \ parameters n, w,\n   h, and d, as well as the functions F, H, H_msg, and PRF,\
    \ MUST be\n   specified.  The following table defines different XMSS^MT signature\n\
    \   systems, each of which is identified by a name.  Naming follows this\n   convention:\
    \ XMSSMT-[Hashfamily]_[h]/[d]_[n in bits].  Naming does not\n   include w as all\
    \ parameter sets in this document use w=16.\n     +------------------------+-----------+----+----+-----+----+----+\n\
    \     | Name                   | Functions |  n |  w | len |  h |  d |\n     +------------------------+-----------+----+----+-----+----+----+\n\
    \     | REQUIRED:              |           |    |    |     |    |    |\n     |\
    \                        |           |    |    |     |    |    |\n     | XMSSMT-SHA2_20/2_256\
    \   | SHA2-256  | 32 | 16 |  67 | 20 |  2 |\n     |                        | \
    \          |    |    |     |    |    |\n     | XMSSMT-SHA2_20/4_256   | SHA2-256\
    \  | 32 | 16 |  67 | 20 |  4 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | XMSSMT-SHA2_40/2_256   | SHA2-256  | 32 | 16\
    \ |  67 | 40 |  2 |\n     |                        |           |    |    |   \
    \  |    |    |\n     | XMSSMT-SHA2_40/4_256   | SHA2-256  | 32 | 16 |  67 | 40\
    \ |  4 |\n     |                        |           |    |    |     |    |   \
    \ |\n     | XMSSMT-SHA2_40/8_256   | SHA2-256  | 32 | 16 |  67 | 40 |  8 |\n \
    \    |                        |           |    |    |     |    |    |\n     |\
    \ XMSSMT-SHA2_60/3_256   | SHA2-256  | 32 | 16 |  67 | 60 |  3 |\n     |     \
    \                   |           |    |    |     |    |    |\n     | XMSSMT-SHA2_60/6_256\
    \   | SHA2-256  | 32 | 16 |  67 | 60 |  6 |\n     |                        | \
    \          |    |    |     |    |    |\n     | XMSSMT-SHA2_60/12_256  | SHA2-256\
    \  | 32 | 16 |  67 | 60 | 12 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | OPTIONAL:              |           |    |  \
    \  |     |    |    |\n     |                        |           |    |    |  \
    \   |    |    |\n     | XMSSMT-SHA2_20/2_512   | SHA2-512  | 64 | 16 | 131 | 20\
    \ |  2 |\n     |                        |           |    |    |     |    |   \
    \ |\n     | XMSSMT-SHA2_20/4_512   | SHA2-512  | 64 | 16 | 131 | 20 |  4 |\n \
    \    |                        |           |    |    |     |    |    |\n     |\
    \ XMSSMT-SHA2_40/2_512   | SHA2-512  | 64 | 16 | 131 | 40 |  2 |\n     |     \
    \                   |           |    |    |     |    |    |\n     | XMSSMT-SHA2_40/4_512\
    \   | SHA2-512  | 64 | 16 | 131 | 40 |  4 |\n     |                        | \
    \          |    |    |     |    |    |\n     | XMSSMT-SHA2_40/8_512   | SHA2-512\
    \  | 64 | 16 | 131 | 40 |  8 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | XMSSMT-SHA2_60/3_512   | SHA2-512  | 64 | 16\
    \ | 131 | 60 |  3 |\n     |                        |           |    |    |   \
    \  |    |    |\n     | XMSSMT-SHA2_60/6_512   | SHA2-512  | 64 | 16 | 131 | 60\
    \ |  6 |\n     |                        |           |    |    |     |    |   \
    \ |\n     | XMSSMT-SHA2_60/12_512  | SHA2-512  | 64 | 16 | 131 | 60 | 12 |\n \
    \    |                        |           |    |    |     |    |    |\n     |\
    \ XMSSMT-SHAKE_20/2_256  | SHAKE128  | 32 | 16 |  67 | 20 |  2 |\n     |     \
    \                   |           |    |    |     |    |    |\n     | XMSSMT-SHAKE_20/4_256\
    \  | SHAKE128  | 32 | 16 |  67 | 20 |  4 |\n     |                        |  \
    \         |    |    |     |    |    |\n     | XMSSMT-SHAKE_40/2_256  | SHAKE128\
    \  | 32 | 16 |  67 | 40 |  2 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | XMSSMT-SHAKE_40/4_256  | SHAKE128  | 32 | 16\
    \ |  67 | 40 |  4 |\n     |                        |           |    |    |   \
    \  |    |    |\n     | XMSSMT-SHAKE_40/8_256  | SHAKE128  | 32 | 16 |  67 | 40\
    \ |  8 |\n     |                        |           |    |    |     |    |   \
    \ |\n     | XMSSMT-SHAKE_60/3_256  | SHAKE128  | 32 | 16 |  67 | 60 |  3 |\n \
    \    |                        |           |    |    |     |    |    |\n     |\
    \ XMSSMT-SHAKE_60/6_256  | SHAKE128  | 32 | 16 |  67 | 60 |  6 |\n     |     \
    \                   |           |    |    |     |    |    |\n     | XMSSMT-SHAKE_60/12_256\
    \ | SHAKE128  | 32 | 16 |  67 | 60 | 12 |\n     |                        |   \
    \        |    |    |     |    |    |\n     | XMSSMT-SHAKE_20/2_512  | SHAKE256\
    \  | 64 | 16 | 131 | 20 |  2 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | XMSSMT-SHAKE_20/4_512  | SHAKE256  | 64 | 16\
    \ | 131 | 20 |  4 |\n     |                        |           |    |    |   \
    \  |    |    |\n     | XMSSMT-SHAKE_40/2_512  | SHAKE256  | 64 | 16 | 131 | 40\
    \ |  2 |\n     |                        |           |    |    |     |    |   \
    \ |\n     | XMSSMT-SHAKE_40/4_512  | SHAKE256  | 64 | 16 | 131 | 40 |  4 |\n \
    \    |                        |           |    |    |     |    |    |\n     |\
    \ XMSSMT-SHAKE_40/8_512  | SHAKE256  | 64 | 16 | 131 | 40 |  8 |\n     |     \
    \                   |           |    |    |     |    |    |\n     | XMSSMT-SHAKE_60/3_512\
    \  | SHAKE256  | 64 | 16 | 131 | 60 |  3 |\n     |                        |  \
    \         |    |    |     |    |    |\n     | XMSSMT-SHAKE_60/6_512  | SHAKE256\
    \  | 64 | 16 | 131 | 60 |  6 |\n     |                        |           |  \
    \  |    |     |    |    |\n     | XMSSMT-SHAKE_60/12_512 | SHAKE256  | 64 | 16\
    \ | 131 | 60 | 12 |\n     +------------------------+-----------+----+----+-----+----+----+\n\
    \                                  Table 4\n   XDR formats for XMSS^MT are listed\
    \ in Appendix C.\n"
- title: 5.4.1.  Parameter Guide
  contents:
  - "5.4.1.  Parameter Guide\n   In addition to the tree height parameter already\
    \ used for XMSS,\n   XMSS^MT has the parameter d that determines the number of\
    \ tree\n   layers.  XMSS can be understood as XMSS^MT with a single layer, i.e.,\n\
    \   d=1.  Hence, the choice of h has the same effect as for XMSS.  The\n   number\
    \ of tree layers provides a trade-off between signature size on\n   the one side\
    \ and key generation and signing speed on the other side.\n   Increasing the number\
    \ of layers reduces key generation time\n   exponentially and signing time linearly\
    \ at the cost of increasing the\n   signature size linearly.  Essentially, an\
    \ XMSS^MT signature contains\n   one WOTSP signature per layer.  Speed roughly\
    \ corresponds to d-times\n   the speed for XMSS with trees of height h/d.\n  \
    \ To demonstrate the impact of different values of h and d, the\n   following\
    \ table shows signature size and runtimes.  Runtimes are\n   given as the number\
    \ of calls to F and H when the BDS algorithm and\n   distributed signature generation\
    \ are used.  Timings are worst-case\n   times.  The last column shows the number\
    \ of messages that can be\n   signed with one key pair.  The numbers are the same\
    \ for the XMSS-\n   SHAKE instances with same parameters h and n.  Due to formatting\n\
    \   limitations, only the parameter part of the parameter set names are\n   given,\
    \ omitting the name \"XMSSMT\".\n    +----------------+---------+------------+--------+--------+-------+\n\
    \    | Name           |   |Sig| |     KeyGen |   Sign | Verify | #Sigs |\n   \
    \ +----------------+---------+------------+--------+--------+-------+\n    | REQUIRED:\
    \      |         |            |        |        |       |\n    |             \
    \   |         |            |        |        |       |\n    | SHA2_20/2_256  |\
    \   4,963 |  2,476,032 |  7,227 |  2,298 |  2^20 |\n    |                |   \
    \      |            |        |        |       |\n    | SHA2_20/4_256  |   9,251\
    \ |    154,752 |  4,170 |  4,576 |  2^20 |\n    |                |         | \
    \           |        |        |       |\n    | SHA2_40/2_256  |   5,605 | 2,535*10^6\
    \ | 13,417 |  2,318 |  2^40 |\n    |                |         |            | \
    \       |        |       |\n    | SHA2_40/4_256  |   9,893 |  4,952,064 |  7,227\
    \ |  4,596 |  2^40 |\n    |                |         |            |        | \
    \       |       |\n    | SHA2_40/8_256  |  18,469 |    309,504 |  4,170 |  9,152\
    \ |  2^40 |\n    |                |         |            |        |        | \
    \      |\n    | SHA2_60/3_256  |   8,392 | 3,803*10^6 | 13,417 |  3,477 |  2^60\
    \ |\n    |                |         |            |        |        |       |\n\
    \    | SHA2_60/6_256  |  14,824 |  7,428,096 |  7,227 |  6,894 |  2^60 |\n   \
    \ |                |         |            |        |        |       |\n    | SHA2_60/12_256\
    \ |  27,688 |    464,256 |  4,170 | 13,728 |  2^60 |\n    |                | \
    \        |            |        |        |       |\n    | OPTIONAL:      |    \
    \     |            |        |        |       |\n    |                |       \
    \  |            |        |        |       |\n    | SHA2_20/2_512  |  18,115 |\
    \  4,835,328 | 14,075 |  4,474 |  2^20 |\n    |                |         |   \
    \         |        |        |       |\n    | SHA2_20/4_512  |  34,883 |    302,208\
    \ |  8,138 |  8,928 |  2^20 |\n    |                |         |            | \
    \       |        |       |\n    | SHA2_40/2_512  |  19,397 | 4,951*10^6 | 26,025\
    \ |  4,494 |  2^40 |\n    |                |         |            |        | \
    \       |       |\n    | SHA2_40/4_512  |  36,165 |  9,670,656 | 14,075 |  8,948\
    \ |  2^40 |\n    |                |         |            |        |        | \
    \      |\n    | SHA2_40/8_512  |  69,701 |    604,416 |  8,138 | 17,856 |  2^40\
    \ |\n    |                |         |            |        |        |       |\n\
    \    | SHA2_60/3_512  |  29,064 | 7,427*10^6 | 26,025 |  6,741 |  2^60 |\n   \
    \ |                |         |            |        |        |       |\n    | SHA2_60/6_512\
    \  |  54,216 | 14,505,984 | 14,075 | 13,422 |  2^60 |\n    |                |\
    \         |            |        |        |       |\n    | SHA2_60/12_512 | 104,520\
    \ |    906,624 |  8,138 | 26,784 |  2^60 |\n    +----------------+---------+------------+--------+--------+-------+\n\
    \                                  Table 5\n   As a default, users without special\
    \ requirements should use option\n   XMSSMT-SHA2_60/3_256, which allows signing\
    \ of 2^60 messages with one\n   key pair (this is a virtually unbounded number\
    \ of signatures).  At\n   the same time, signature size and speed are well balanced.\n"
- title: 6.  Rationale
  contents:
  - "6.  Rationale\n   The goal of this note is to describe the WOTS+, XMSS, and XMSS^MT\n\
    \   algorithms based on the scientific literature.  The description is\n   done\
    \ in a modular way that allows basing a description of stateless\n   hash-based\
    \ signature algorithms like SPHINCS [BHH15] on it.\n   This note slightly deviates\
    \ from the scientific literature by using a\n   tweak that prevents multi-user\
    \ and multi-target attacks against\n   H_msg.  To this end, the public key as\
    \ well as the index of the used\n   one-time key pair become part of the hash\
    \ function key.  Thereby, we\n   achieve a domain separation that forces an attacker\
    \ to decide which\n   hash value to attack.\n   For the generation of the randomness\
    \ used for randomized message\n   hashing, we apply a PRF, keyed with a secret\
    \ value, to the index of\n   the used one-time key pair instead of the message.\
    \  The reason is\n   that this requires processing the message only once instead\
    \ of twice.\n   For long messages, this improves speed and simplifies implementations\n\
    \   on resource-constrained devices that cannot hold the entire message\n   in\
    \ storage.\n   We give one mandatory set of parameters using SHA2-256.  The reasons\n\
    \   are twofold.  On the one hand, SHA2-256 is part of most cryptographic\n  \
    \ libraries.  On the other hand, a 256-bit hash function leads to\n   parameters\
    \ that provide 128 bits of security even against quantum-\n   computer-aided attacks.\
    \  A post-quantum security level of 256 bits\n   seems overly conservative.  However,\
    \ to prepare for possible\n   cryptanalytic breakthroughs, we also provide OPTIONAL\
    \ parameter sets\n   using the less widely supported SHA2-512, SHAKE-256, and\
    \ SHAKE-512\n   functions.\n   We suggest the value w = 16 for the Winternitz\
    \ parameter.  No bigger\n   values are included since the decrease in signature\
    \ size then becomes\n   less significant.  Furthermore, the value w = 16 considerably\n\
    \   simplifies the implementations of some of the algorithms.  Please\n   note\
    \ that we do allow w = 4 but limit the specified parameter sets to\n   w = 16\
    \ for efficiency reasons.\n   The signature and public key formats are designed\
    \ so that they are\n   easy to parse.  Each format starts with a 32-bit enumeration\
    \ value\n   that indicates all of the details of the signature algorithm and\n\
    \   hence defines all of the information that is needed in order to parse\n  \
    \ the format.\n"
- title: 7.  Reference Code
  contents:
  - "7.  Reference Code\n   For testing purposes, a reference implementation in C\
    \ is available.\n   The code contains a basic implementation that closely follows\
    \ the\n   pseudocode in this document and an optimized implementation that uses\n\
    \   the BDS algorithm [BDS08] to compute authentication paths and\n   distributed\
    \ signature generation as described in [HRB13] for XMSS^MT.\n   The code is permanently\
    \ available at\n   <https://github.com/joostrijneveld/xmss-reference>.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has\
    \ created three\n   registries: one for WOTS+ signatures (as defined in Section\
    \ 3), one\n   for XMSS signatures (as defined in Section 4), and one for XMSS^MT\n\
    \   signatures (as defined in Section 4).  For the sake of clarity and\n   convenience,\
    \ the first collection of WOTS+, XMSS, and XMSS^MT\n   parameter sets is defined\
    \ in Section 5.  Additions to these\n   registries require that a specification\
    \ be documented in an RFC or\n   another permanent and readily available reference\
    \ in sufficient\n   detail as defined by the \"Specification Required\" policy\
    \ described in\n   [RFC8126] to make interoperability between independent\n  \
    \ implementations possible.  Each entry in these registries contains\n   the following\
    \ elements:\n   o  a short name, such as \"XMSS_SHA2_20_256\",\n   o  a positive\
    \ number, and\n   o  a reference to a specification that completely defines the\n\
    \      signature method test cases or provides a reference implementation\n  \
    \    that can be used to verify the correctness of an implementation\n      (or\
    \ a reference to such an implementation).\n   Requests to add an entry to these\
    \ registries MUST include the name\n   and the reference.  The number is assigned\
    \ by IANA.  These number\n   assignments SHOULD use the smallest available positive\
    \ number.\n   Submitters MUST have their requests reviewed and approved.\n   Designated\
    \ Experts for this task as requested by the \"Specification\n   Required\" policy\
    \ defined by [RFC8126] will be assigned by the\n   Internet Engineering Steering\
    \ Group (IESG).  The IESG can be\n   contacted at iesg@ietf.org.  Interested applicants\
    \ that are\n   unfamiliar with IANA processes should visit <http://www.iana.org>.\n\
    \   The number 0x00000000 (decimal 0) is Reserved.  The numbers between\n   0xDDDDDDDD\
    \ (decimal 3,722,304,989) and 0xFFFFFFFF (decimal\n   4,294,967,295) inclusive\
    \ will not be assigned by IANA and are\n   Reserved for Private Use; no attempt\
    \ will be made to prevent multiple\n   sites from using the same value in different\
    \ (and incompatible) ways\n   [RFC8126].\n   The \"WOTS+ Signatures\" registry\
    \ is as follows.\n          +--------------------+-----------------+-------------+\n\
    \          | Numeric Identifier | Name            |  Reference  |\n          +--------------------+-----------------+-------------+\n\
    \          |     0x00000000     | Reserved        |   this RFC  |\n          |\
    \                    |                 |             |\n          |     0x00000001\
    \     | WOTSP-SHA2_256  | Section 5.2 |\n          |                    |    \
    \             |             |\n          |     0x00000002     | WOTSP-SHA2_512\
    \  | Section 5.2 |\n          |                    |                 |       \
    \      |\n          |     0x00000003     | WOTSP-SHAKE_256 | Section 5.2 |\n \
    \         |                    |                 |             |\n          |\
    \     0x00000004     | WOTSP-SHAKE_512 | Section 5.2 |\n          +--------------------+-----------------+-------------+\n\
    \                                  Table 6\n   The \"XMSS Signatures\" registry\
    \ is as follows.\n         +--------------------+-------------------+-------------+\n\
    \         | Numeric Identifier | Name              |  Reference  |\n         +--------------------+-------------------+-------------+\n\
    \         |     0x00000000     | Reserved          |   this RFC  |\n         |\
    \                    |                   |             |\n         |     0x00000001\
    \     | XMSS-SHA2_10_256  | Section 5.3 |\n         |                    |   \
    \                |             |\n         |     0x00000002     | XMSS-SHA2_16_256\
    \  | Section 5.3 |\n         |                    |                   |      \
    \       |\n         |     0x00000003     | XMSS-SHA2_20_256  | Section 5.3 |\n\
    \         |                    |                   |             |\n         |\
    \     0x00000004     | XMSS-SHA2_10_512  | Section 5.3 |\n         |         \
    \           |                   |             |\n         |     0x00000005   \
    \  | XMSS-SHA2_16_512  | Section 5.3 |\n         |                    |      \
    \             |             |\n         |     0x00000006     | XMSS-SHA2_20_512\
    \  | Section 5.3 |\n         |                    |                   |      \
    \       |\n         |     0x00000007     | XMSS-SHAKE_10_256 | Section 5.3 |\n\
    \         |                    |                   |             |\n         |\
    \     0x00000008     | XMSS-SHAKE_16_256 | Section 5.3 |\n         |         \
    \           |                   |             |\n         |     0x00000009   \
    \  | XMSS-SHAKE_20_256 | Section 5.3 |\n         |                    |      \
    \             |             |\n         |     0x0000000A     | XMSS-SHAKE_10_512\
    \ | Section 5.3 |\n         |                    |                   |       \
    \      |\n         |     0x0000000B     | XMSS-SHAKE_16_512 | Section 5.3 |\n\
    \         |                    |                   |             |\n         |\
    \     0x0000000C     | XMSS-SHAKE_20_512 | Section 5.3 |\n         +--------------------+-------------------+-------------+\n\
    \                                  Table 7\n   The \"XMSS^MT Signatures\" registry\
    \ is as follows.\n       +--------------------+------------------------+-------------+\n\
    \       | Numeric Identifier | Name                   |  Reference  |\n      \
    \ +--------------------+------------------------+-------------+\n       |    \
    \ 0x00000000     | Reserved               |   this RFC  |\n       |          \
    \          |                        |             |\n       |     0x00000001 \
    \    | XMSSMT-SHA2_20/2_256   | Section 5.4 |\n       |                    | \
    \                       |             |\n       |     0x00000002     | XMSSMT-SHA2_20/4_256\
    \   | Section 5.4 |\n       |                    |                        |  \
    \           |\n       |     0x00000003     | XMSSMT-SHA2_40/2_256   | Section\
    \ 5.4 |\n       |                    |                        |             |\n\
    \       |     0x00000004     | XMSSMT-SHA2_40/4_256   | Section 5.4 |\n      \
    \ |                    |                        |             |\n       |    \
    \ 0x00000005     | XMSSMT-SHA2_40/8_256   | Section 5.4 |\n       |          \
    \          |                        |             |\n       |     0x00000006 \
    \    | XMSSMT-SHA2_60/3_256   | Section 5.4 |\n       |                    | \
    \                       |             |\n       |     0x00000007     | XMSSMT-SHA2_60/6_256\
    \   | Section 5.4 |\n       |                    |                        |  \
    \           |\n       |     0x00000008     | XMSSMT-SHA2_60/12_256  | Section\
    \ 5.4 |\n       |                    |                        |             |\n\
    \       |     0x00000009     | XMSSMT-SHA2_20/2_512   | Section 5.4 |\n      \
    \ |                    |                        |             |\n       |    \
    \ 0x0000000A     | XMSSMT-SHA2_20/4_512   | Section 5.4 |\n       |          \
    \          |                        |             |\n       |     0x0000000B \
    \    | XMSSMT-SHA2_40/2_512   | Section 5.4 |\n       |                    | \
    \                       |             |\n       |     0x0000000C     | XMSSMT-SHA2_40/4_512\
    \   | Section 5.4 |\n       |                    |                        |  \
    \           |\n       |     0x0000000D     | XMSSMT-SHA2_40/8_512   | Section\
    \ 5.4 |\n       |                    |                        |             |\n\
    \       |     0x0000000E     | XMSSMT-SHA2_60/3_512   | Section 5.4 |\n      \
    \ |                    |                        |             |\n       |    \
    \ 0x0000000F     | XMSSMT-SHA2_60/6_512   | Section 5.4 |\n       |          \
    \          |                        |             |\n       |     0x00000010 \
    \    | XMSSMT-SHA2_60/12_512  | Section 5.4 |\n       |                    | \
    \                       |             |\n       |     0x00000011     | XMSSMT-SHAKE_20/2_256\
    \  | Section 5.4 |\n       |                    |                        |   \
    \          |\n       |     0x00000012     | XMSSMT-SHAKE_20/4_256  | Section 5.4\
    \ |\n       |                    |                        |             |\n  \
    \     |     0x00000013     | XMSSMT-SHAKE_40/2_256  | Section 5.4 |\n       |\
    \                    |                        |             |\n       |     0x00000014\
    \     | XMSSMT-SHAKE_40/4_256  | Section 5.4 |\n       |                    |\
    \                        |             |\n       |     0x00000015     | XMSSMT-SHAKE_40/8_256\
    \  | Section 5.4 |\n       |                    |                        |   \
    \          |\n       |     0x00000016     | XMSSMT-SHAKE_60/3_256  | Section 5.4\
    \ |\n       |                    |                        |             |\n  \
    \     |     0x00000017     | XMSSMT-SHAKE_60/6_256  | Section 5.4 |\n       |\
    \                    |                        |             |\n       |     0x00000018\
    \     | XMSSMT-SHAKE_60/12_256 | Section 5.4 |\n       |                    |\
    \                        |             |\n       |     0x00000019     | XMSSMT-SHAKE_20/2_512\
    \  | Section 5.4 |\n       |                    |                        |   \
    \          |\n       |     0x0000001A     | XMSSMT-SHAKE_20/4_512  | Section 5.4\
    \ |\n       |                    |                        |             |\n  \
    \     |     0x0000001B     | XMSSMT-SHAKE_40/2_512  | Section 5.4 |\n       |\
    \                    |                        |             |\n       |     0x0000001C\
    \     | XMSSMT-SHAKE_40/4_512  | Section 5.4 |\n       |                    |\
    \                        |             |\n       |     0x0000001D     | XMSSMT-SHAKE_40/8_512\
    \  | Section 5.4 |\n       |                    |                        |   \
    \          |\n       |     0x0000001E     | XMSSMT-SHAKE_60/3_512  | Section 5.4\
    \ |\n       |                    |                        |             |\n  \
    \     |     0x0000001F     | XMSSMT-SHAKE_60/6_512  | Section 5.4 |\n       |\
    \                    |                        |             |\n       |     0x00000020\
    \     | XMSSMT-SHAKE_60/12_512 | Section 5.4 |\n       +--------------------+------------------------+-------------+\n\
    \                                  Table 8\n   An IANA registration of a signature\
    \ system does not constitute an\n   endorsement of that system or its security.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   A signature system is considered secure if it\
    \ prevents an attacker\n   from forging a valid signature.  More specifically,\
    \ consider a\n   setting in which an attacker gets a public key and can learn\n\
    \   signatures on arbitrary messages of its choice.  A signature system\n   is\
    \ secure if, even in this setting, the attacker cannot produce a new\n   message/signature\
    \ pair of his choosing such that the verification\n   algorithm accepts.\n   Preventing\
    \ an attacker from mounting an attack means that the attack\n   is computationally\
    \ too expensive to be carried out.  There are\n   various estimates for when a\
    \ computation is too expensive to be done.\n   For that reason, this note only\
    \ describes how expensive it is for an\n   attacker to generate a forgery.  Parameters\
    \ are accompanied by a bit\n   security value.  The meaning of bit security is\
    \ as follows.  A\n   parameter set grants b bits of security if the best attack\
    \ takes at\n   least 2^(b - 1) bit operations to achieve a success probability\
    \ of\n   1/2.  Hence, to mount a successful attack, an attacker needs to\n   perform\
    \ 2^b bit operations on average.  The given values for bit\n   security were estimated\
    \ according to [HRS16].\n"
- title: 9.1.  Security Proofs
  contents:
  - "9.1.  Security Proofs\n   A full security proof for all schemes described in\
    \ this document can\n   be found in [HRS16].  This proof shows that an attacker\
    \ has to break\n   at least one out of certain security properties of the used\
    \ hash\n   functions and PRFs to forge a signature in any of the described\n \
    \  schemes.  The proof in [HRS16] considers an initial message\n   compression\
    \ different from the randomized hashing used here.  We\n   comment on this below.\
    \  For the original schemes, these proofs show\n   that an attacker has to break\
    \ certain minimal security properties.\n   In particular, it is not sufficient\
    \ to break the collision resistance\n   of the hash functions to generate a forgery.\n\
    \   More specifically, the requirements on the used functions are that F\n   and\
    \ H are post-quantum multi-function multi-target second-preimage\n   resistant\
    \ keyed functions, F fulfills an additional statistical\n   requirement that roughly\
    \ says that most images have at least two\n   preimages, PRF is a post-quantum\
    \ pseudorandom function, and H_msg is\n   a post-quantum multi-target extended\
    \ target collision-resistant keyed\n   hash function.  For detailed definitions\
    \ of these properties see\n   [HRS16].  To give some intuition: multi-function\
    \ multi-target second-\n   preimage resistance is an extension of second-preimage\
    \ resistance to\n   keyed hash functions, covering the case where an adversary\
    \ succeeds\n   if it finds a second preimage for one out of many values.  The\
    \ same\n   holds for multi-target extended target collision resistance, which\n\
    \   just lacks the multi-function identifier as target collision\n   resistance\
    \ already considers keyed hash functions.  The proof in\n   [HRS16] splits PRF\
    \ into two functions.  When PRF is used for\n   pseudorandom key generation or\
    \ generation of randomness for\n   randomized message hashing, it is still considered\
    \ a pseudorandom\n   function.  Whenever PRF is used to generate bitmasks and\
    \ hash\n   function keys, it is modeled as a random oracle.  This is due to\n\
    \   technical reasons in the proof, and an implementation using a\n   pseudorandom\
    \ function is secure.\n   The proof in [HRS16] considers classical randomized\
    \ hashing for the\n   initial message compression, i.e., H(r, M) instead of H(r\
    \ ||\n   getRoot(PK) || index, M).  This classical randomized hashing allows\n\
    \   getting a security reduction from extended target collision\n   resistance\
    \ [HRS16], a property that is conjectured to be strictly\n   weaker than collision\
    \ resistance.  However, it turns out that in this\n   case, an attacker could\
    \ still launch a multi-target attack even\n   against multiple users at the same\
    \ time.  The reason is that the\n   adversary attacking u users at the same time\
    \ learns u * 2^h\n   randomized hashes H(r_i_j || M_i_j) with signature index\
    \ i in [0, 2^h\n   - 1] and user index j in [0, u].  It suffices to find a single\
    \ pair\n   (r*, M*) such that H(r* || M*) = H(r_i_u || M_i_u) for one out of the\n\
    \   u * 2^h learned hashes.  Hence, an attacker can do a brute-force\n   search\
    \ in time 2^n / u * 2^h instead of 2^n.\n   The indexed randomized hashing H(r\
    \ || getRoot(PK) || toByte(idx, n),\n   M) used in this work makes the hash function\
    \ calls position- and\n   user-dependent.  This thwarts the above attack because\
    \ each hash\n   function evaluation during an attack can only target one of the\n\
    \   learned randomized hash values.  More specifically, an attacker now\n   has\
    \ to decide which index idx and which root value to use for each\n   query.  If\
    \ one assumes that the used hash function is a random\n   function, it can be\
    \ shown that a multi-user existential forgery\n   attack that targets this message\
    \ compression has a complexity of 2^n\n   hash function calls.\n   The given bit\
    \ security values were estimated based on the complexity\n   of the best-known\
    \ generic attacks against the required security\n   properties of the used hash\
    \ and pseudorandom functions, assuming\n   conventional and quantum adversaries.\
    \  At the time of writing,\n   generic attacks are the best-known attacks for\
    \ the parameters\n   suggested in the classical setting.  Also, in the quantum\
    \ setting,\n   there are no dedicated attacks known that perform better than generic\n\
    \   attacks.  Nevertheless, the topic of quantum cryptanalysis of hash\n   functions\
    \ is not as well understood as in the classical setting.\n"
- title: 9.2.  Minimal Security Assumptions
  contents:
  - "9.2.  Minimal Security Assumptions\n   The assumptions one has to make to prove\
    \ security of the described\n   schemes are minimal in the following sense.  Any\
    \ signature algorithm\n   that allows arbitrary size messages relies on the security\
    \ of a\n   cryptographic hash function, either on collision resistance or on\n\
    \   extended target collision resistance if randomized hashing is used\n   for\
    \ message compression.  For the schemes described here, this is\n   already sufficient\
    \ to be secure.  In contrast, common signature\n   schemes like RSA, DSA, and\
    \ Elliptic Curve Digital Signature Algorithm\n   (ECDSA) additionally rely on\
    \ the conjectured hardness of certain\n   mathematical problems.\n"
- title: 9.3.  Post-Quantum Security
  contents:
  - "9.3.  Post-Quantum Security\n   A post-quantum cryptosystem is a system that\
    \ is secure against\n   attackers with access to a reasonably sized quantum computer.\
    \  At the\n   time of writing this note, whether or not it is feasible to build\n\
    \   such a machine is an open conjecture.  However, significant progress\n   was\
    \ made over the last few years in this regard.  Hence, we consider\n   it a matter\
    \ of risk assessment to prepare for this case.\n   In contrast to RSA, DSA, and\
    \ ECDSA, the described signature systems\n   are post-quantum-secure if they are\
    \ used with an appropriate\n   cryptographic hash function.  In particular, for\
    \ post-quantum\n   security, the size of n must be twice the size required for\
    \ classical\n   security.  This is in order to protect against quantum square-root\n\
    \   attacks due to Grover's algorithm.  [HRS16] shows that variants of\n   Grover's\
    \ algorithm are the optimal generic attacks against the\n   security properties\
    \ of hash functions required for the described\n   schemes.\n   As stated above,\
    \ we only consider generic attacks here, as\n   cryptographic hash functions should\
    \ be deprecated as soon as\n   dedicated attacks that perform significantly better\
    \ exist.  This also\n   applies to the quantum setting.  As soon as dedicated\
    \ quantum attacks\n   against the used hash function that can perform significantly\
    \ better\n   than the described generic attacks exist, these hash functions should\n\
    \   not be used anymore for the described schemes, or the computation of\n   the\
    \ security level has to be redone.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [FIPS180]  National Institute of Standards and\
    \ Technology, \"Secure\n              Hash Standard (SHS)\", FIPS PUB 180-4,\n\
    \              DOI 10.6028/NIST.FIPS.180-4, August 2015.\n   [FIPS202]  National\
    \ Institute of Standards and Technology, \"SHA-3\n              Standard: Permutation-Based\
    \ Hash and Extendable-Output\n              Functions\", FIPS PUB 202, DOI 10.6028/NIST.FIPS.202,\n\
    \              August 2015.\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC4506]  Eisler, M., Ed., \"XDR: External Data Representation\n        \
    \      Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May\n             \
    \ 2006, <https://www.rfc-editor.org/info/rfc4506>.\n   [RFC8126]  Cotton, M.,\
    \ Leiba, B., and T. Narten, \"Guidelines for\n              Writing an IANA Considerations\
    \ Section in RFCs\", BCP 26,\n              RFC 8126, DOI 10.17487/RFC8126, June\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BDH11]    Buchmann, J., Dahmen, E., and A.\
    \ Huelsing, \"XMSS - A\n              Practical Forward Secure Signature Scheme\
    \ Based on Minimal\n              Security Assumptions\", Lecture Notes in Computer\
    \ Science,\n              Volume 7071, Post-Quantum Cryptography,\n          \
    \    DOI 10.1007/978-3-642-25405-5_8, 2011.\n   [BDS08]    Buchmann, J., Dahmen,\
    \ E., and M. Schneider, \"Merkle Tree\n              Traversal Revisited\", Lecture\
    \ Notes in Computer Science,\n              Volume 5299, Post-Quantum Cryptography,\n\
    \              DOI 10.1007/978-3-540-88403-3_5, 2008.\n   [BDS09]    Buchmann,\
    \ J., Dahmen, E., and M. Szydlo, \"Hash-based\n              Digital Signature\
    \ Schemes\", Book chapter, Post-Quantum\n              Cryptography, DOI 10.1007/978-3-540-88702-7_3,\
    \ 2009.\n   [BHH15]    Bernstein, D., Hopwood, D., Huelsing, A., Lange, T.,\n\
    \              Niederhagen, R., Papachristodoulou, L., Schneider, M.,\n      \
    \        Schwabe, P., and Z. Wilcox-O'Hearn, \"SPHINCS: Practical\n          \
    \    Stateless Hash-Based Signatures\", Lecture Notes in\n              Computer\
    \ Science, Volume 9056, Advances in Cryptology -\n              EUROCRYPT, DOI\
    \ 10.1007/978-3-662-46800-5_15, 2015.\n   [HRB13]    Huelsing, A., Rausch, L.,\
    \ and J. Buchmann, \"Optimal\n              Parameters for XMSS^MT\", Lecture\
    \ Notes in Computer\n              Science, Volume 8128, CD-ARES,\n          \
    \    DOI 10.1007/978-3-642-40588-4_14, 2013.\n   [HRS16]    Huelsing, A., Rijneveld,\
    \ J., and F. Song, \"Mitigating\n              Multi-Target Attacks in Hash-based\
    \ Signatures\", Lecture\n              Notes in Computer Science, Volume 9614,\
    \ Public-Key\n              Cryptography - PKC, DOI 10.1007/978-3-662-49384-7_15,\n\
    \              2016.\n   [Huelsing13]\n              Huelsing, A., \"W-OTS+ -\
    \ Shorter Signatures for Hash-Based\n              Signature Schemes\", Lecture\
    \ Notes in Computer Science,\n              Volume 7918, Progress in Cryptology\
    \ - AFRICACRYPT,\n              DOI 10.1007/978-3-642-38553-7_10, 2013.\n   [Huelsing13a]\n\
    \              Huelsing, A., \"Practical Forward Secure Signatures using\n   \
    \           Minimal Security Assumptions\", PhD thesis TU Darmstadt,\n       \
    \       2013,\n              <http://tuprints.ulb.tu-darmstadt.de/3651/1/Thesis.pdf>.\n\
    \   [KMN14]    Knecht, M., Meier, W., and C. Nicola, \"A space- and time-\n  \
    \            efficient Implementation of the Merkle Tree Traversal\n         \
    \     Algorithm\", Computing Research Repository\n              (CoRR), arXiv:1409.4081,\
    \ 2014.\n   [MCF18]    McGrew, D., Curcio, M., and S. Fluhrer, \"Hash-Based\n\
    \              Signatures\", Work in Progress, draft-mcgrew-hash-sigs-11,\n  \
    \            April 2018.\n   [Merkle83] Merkle, R., \"Secrecy, Authentication,\
    \ and Public Key\n              Systems\", Computer Science Series, UMI Research\
    \ Press,\n              ISBN: 9780835713849, 1983.\n"
- title: Appendix A.  WOTS+ XDR Formats
  contents:
  - "Appendix A.  WOTS+ XDR Formats\n   The WOTS+ signature and public key formats\
    \ are formally defined using\n   XDR [RFC4506] in order to provide an unambiguous,\
    \ machine readable\n   definition.  Though XDR is used, these formats are simple\
    \ and easy to\n   parse without any special tools.  Note that this representation\n\
    \   includes all optional parameter sets.  The same applies for the XMSS\n   and\
    \ XMSS^MT formats below.\n"
- title: A.1.  WOTS+ Parameter Sets
  contents:
  - "A.1.  WOTS+ Parameter Sets\n   WOTS+ parameter sets are defined using XDR syntax\
    \ as follows:\n      /* ots_algorithm_type identifies a particular\n         signature\
    \ algorithm */\n      enum ots_algorithm_type {\n        wotsp_reserved  = 0x00000000,\n\
    \        wotsp-sha2_256  = 0x00000001,\n        wotsp-sha2_512  = 0x00000002,\n\
    \        wotsp-shake_256 = 0x00000003,\n        wotsp-shake_512 = 0x00000004,\n\
    \      };\n"
- title: A.2.  WOTS+ Signatures
  contents:
  - "A.2.  WOTS+ Signatures\n   WOTS+ signatures are defined using XDR syntax as follows:\n\
    \      /* Byte strings */\n      typedef opaque bytestring32[32];\n      typedef\
    \ opaque bytestring64[64];\n      union ots_signature switch (ots_algorithm_type\
    \ type) {\n        case wotsp-sha2_256:\n        case wotsp-shake_256:\n     \
    \     bytestring32 ots_sig_n32_len67[67];\n        case wotsp-sha2_512:\n    \
    \    case wotsp-shake_512:\n          bytestring64 ots_sig_n64_len18[131];\n \
    \       default:\n          void;   /* error condition */\n      };\n"
- title: A.3.  WOTS+ Public Keys
  contents:
  - "A.3.  WOTS+ Public Keys\n   WOTS+ public keys are defined using XDR syntax as\
    \ follows:\n      union ots_pubkey switch (ots_algorithm_type type) {\n      \
    \  case wotsp-sha2_256:\n        case wotsp-shake_256:\n          bytestring32\
    \ ots_pubk_n32_len67[67];\n        case wotsp-sha2_512:\n        case wotsp-shake_512:\n\
    \          bytestring64 ots_pubk_n64_len18[131];\n        default:\n         \
    \ void;   /* error condition */\n      };\n"
- title: Appendix B.  XMSS XDR Formats
  contents:
  - 'Appendix B.  XMSS XDR Formats

    '
- title: B.1.  XMSS Parameter Sets
  contents:
  - "B.1.  XMSS Parameter Sets\n   XMSS parameter sets are defined using XDR syntax\
    \ as follows:\n      /* Byte strings */\n      typedef opaque bytestring4[4];\n\
    \      /* Definition of parameter sets */\n      enum xmss_algorithm_type {\n\
    \        xmss_reserved     = 0x00000000,\n        /* 256 bit classical security,\
    \ 128 bit post-quantum security */\n        xmss-sha2_10_256  = 0x00000001,\n\
    \        xmss-sha2_16_256  = 0x00000002,\n        xmss-sha2_20_256  = 0x00000003,\n\
    \        /* 512 bit classical security, 256 bit post-quantum security */\n   \
    \     xmss-sha2_10_512  = 0x00000004,\n        xmss-sha2_16_512  = 0x00000005,\n\
    \        xmss-sha2_20_512  = 0x00000006,\n        /* 256 bit classical security,\
    \ 128 bit post-quantum security */\n        xmss-shake_10_256 = 0x00000007,\n\
    \        xmss-shake_16_256 = 0x00000008,\n        xmss-shake_20_256 = 0x00000009,\n\
    \        /* 512 bit classical security, 256 bit post-quantum security */\n   \
    \     xmss-shake_10_512 = 0x0000000A,\n        xmss-shake_16_512 = 0x0000000B,\n\
    \        xmss-shake_20_512 = 0x0000000C,\n      };\n"
- title: B.2.  XMSS Signatures
  contents:
  - "B.2.  XMSS Signatures\n   XMSS signatures are defined using XDR syntax as follows:\n\
    \      /* Authentication path types */\n      union xmss_path switch (xmss_algorithm_type\
    \ type) {\n        case xmss-sha2_10_256:\n        case xmss-shake_10_256:\n \
    \         bytestring32 path_n32_t10[10];\n        case xmss-sha2_16_256:\n   \
    \     case xmss-shake_16_256:\n          bytestring32 path_n32_t16[16];\n    \
    \    case xmss-sha2_20_256:\n        case xmss-shake_20_256:\n          bytestring32\
    \ path_n32_t20[20];\n        case xmss-sha2_10_512:\n        case xmss-shake_10_512:\n\
    \          bytestring64 path_n64_t10[10];\n        case xmss-sha2_16_512:\n  \
    \      case xmss-shake_16_512:\n          bytestring64 path_n64_t16[16];\n   \
    \     case xmss-sha2_20_512:\n        case xmss-shake_20_512:\n          bytestring64\
    \ path_n64_t20[20];\n        default:\n          void;     /* error condition\
    \ */\n      };\n      /* Types for XMSS random strings */\n      union random_string_xmss\
    \ switch (xmss_algorithm_type type) {\n        case xmss-sha2_10_256:\n      \
    \  case xmss-sha2_16_256:\n        case xmss-sha2_20_256:\n        case xmss-shake_10_256:\n\
    \        case xmss-shake_16_256:\n        case xmss-shake_20_256:\n          bytestring32\
    \ rand_n32;\n        case xmss-sha2_10_512:\n        case xmss-sha2_16_512:\n\
    \        case xmss-sha2_20_512:\n        case xmss-shake_10_512:\n        case\
    \ xmss-shake_16_512:\n        case xmss-shake_20_512:\n          bytestring64\
    \ rand_n64;\n        default:\n          void;     /* error condition */\n   \
    \   };\n      /* Corresponding WOTS+ type for given XMSS type */\n      union\
    \ xmss_ots_signature switch (xmss_algorithm_type type) {\n        case xmss-sha2_10_256:\n\
    \        case xmss-sha2_16_256:\n        case xmss-sha2_20_256:\n          wotsp-sha2_256;\n\
    \        case xmss-sha2_10_512:\n        case xmss-sha2_16_512:\n        case\
    \ xmss-sha2_20_512:\n          wotsp-sha2_512;\n        case xmss-shake_10_256:\n\
    \        case xmss-shake_16_256:\n        case xmss-shake_20_256:\n          wotsp-shake_256;\n\
    \        case xmss-shake_10_512:\n        case xmss-shake_16_512:\n        case\
    \ xmss-shake_20_512:\n          wotsp-shake_512;\n        default:\n         \
    \ void;     /* error condition */\n      };\n      /* XMSS signature structure\
    \ */\n      struct xmss_signature {\n        /* WOTS+ key pair index */\n    \
    \    bytestring4 idx_sig;\n        /* Random string for randomized hashing */\n\
    \        random_string_xmss rand_string;\n        /* WOTS+ signature */\n    \
    \    xmss_ots_signature sig_ots;\n        /* authentication path */\n        xmss_path\
    \ nodes;\n      };\n"
- title: B.3.  XMSS Public Keys
  contents:
  - "B.3.  XMSS Public Keys\n   XMSS public keys are defined using XDR syntax as follows:\n\
    \      /* Types for bitmask seed */\n      union seed switch (xmss_algorithm_type\
    \ type) {\n        case xmss-sha2_10_256:\n        case xmss-sha2_16_256:\n  \
    \      case xmss-sha2_20_256:\n        case xmss-shake_10_256:\n        case xmss-shake_16_256:\n\
    \        case xmss-shake_20_256:\n          bytestring32 seed_n32;\n        case\
    \ xmss-sha2_10_512:\n        case xmss-sha2_16_512:\n        case xmss-sha2_20_512:\n\
    \        case xmss-shake_10_512:\n        case xmss-shake_16_512:\n        case\
    \ xmss-shake_20_512:\n          bytestring64 seed_n64;\n        default:\n   \
    \       void;     /* error condition */\n      };\n      /* Types for XMSS root\
    \ node */\n      union xmss_root switch (xmss_algorithm_type type) {\n       \
    \ case xmss-sha2_10_256:\n        case xmss-sha2_16_256:\n        case xmss-sha2_20_256:\n\
    \        case xmss-shake_10_256:\n        case xmss-shake_16_256:\n        case\
    \ xmss-shake_20_256:\n          bytestring32 root_n32;\n        case xmss-sha2_10_512:\n\
    \        case xmss-sha2_16_512:\n        case xmss-sha2_20_512:\n        case\
    \ xmss-shake_10_512:\n        case xmss-shake_16_512:\n        case xmss-shake_20_512:\n\
    \          bytestring64 root_n64;\n        default:\n          void;     /* error\
    \ condition */\n      };\n      /* XMSS public key structure */\n      struct\
    \ xmss_public_key {\n        xmss_root root;  /* Root node */\n        seed SEED;\
    \  /* Seed for bitmasks */\n      };\n"
- title: Appendix C.  XMSS^MT XDR Formats
  contents:
  - 'Appendix C.  XMSS^MT XDR Formats

    '
- title: C.1.  XMSS^MT Parameter Sets
  contents:
  - "C.1.  XMSS^MT Parameter Sets\n   XMSS^MT parameter sets are defined using XDR\
    \ syntax as follows:\n      /* Byte strings */\n      typedef opaque bytestring3[3];\n\
    \      typedef opaque bytestring5[5];\n      typedef opaque bytestring8[8];\n\
    \      /* Definition of parameter sets */\n      enum xmssmt_algorithm_type {\n\
    \        xmssmt_reserved        = 0x00000000,\n        /* 256 bit classical security,\
    \ 128 bit post-quantum security */\n        xmssmt-sha2_20/2_256   = 0x00000001,\n\
    \        xmssmt-sha2_20/4_256   = 0x00000002,\n        xmssmt-sha2_40/2_256  \
    \ = 0x00000003,\n        xmssmt-sha2_40/4_256   = 0x00000004,\n        xmssmt-sha2_40/8_256\
    \   = 0x00000005,\n        xmssmt-sha2_60/3_256   = 0x00000006,\n        xmssmt-sha2_60/6_256\
    \   = 0x00000007,\n        xmssmt-sha2_60/12_256  = 0x00000008,\n        /* 512\
    \ bit classical security, 256 bit post-quantum security */\n        xmssmt-sha2_20/2_512\
    \   = 0x00000009,\n        xmssmt-sha2_20/4_512   = 0x0000000A,\n        xmssmt-sha2_40/2_512\
    \   = 0x0000000B,\n        xmssmt-sha2_40/4_512   = 0x0000000C,\n        xmssmt-sha2_40/8_512\
    \   = 0x0000000D,\n        xmssmt-sha2_60/3_512   = 0x0000000E,\n        xmssmt-sha2_60/6_512\
    \   = 0x0000000F,\n        xmssmt-sha2_60/12_512  = 0x00000010,\n        /* 256\
    \ bit classical security, 128 bit post-quantum security */\n        xmssmt-shake_20/2_256\
    \  = 0x00000011,\n        xmssmt-shake_20/4_256  = 0x00000012,\n        xmssmt-shake_40/2_256\
    \  = 0x00000013,\n        xmssmt-shake_40/4_256  = 0x00000014,\n        xmssmt-shake_40/8_256\
    \  = 0x00000015,\n        xmssmt-shake_60/3_256  = 0x00000016,\n        xmssmt-shake_60/6_256\
    \  = 0x00000017,\n        xmssmt-shake_60/12_256 = 0x00000018,\n        /* 512\
    \ bit classical security, 256 bit post-quantum security */\n        xmssmt-shake_20/2_512\
    \  = 0x00000019,\n        xmssmt-shake_20/4_512  = 0x0000001A,\n        xmssmt-shake_40/2_512\
    \  = 0x0000001B,\n        xmssmt-shake_40/4_512  = 0x0000001C,\n        xmssmt-shake_40/8_512\
    \  = 0x0000001D,\n        xmssmt-shake_60/3_512  = 0x0000001E,\n        xmssmt-shake_60/6_512\
    \  = 0x0000001F,\n        xmssmt-shake_60/12_512 = 0x00000020,\n      };\n"
- title: C.2.  XMSS^MT Signatures
  contents:
  - "C.2.  XMSS^MT Signatures\n   XMSS^MT signatures are defined using XDR syntax\
    \ as follows:\n      /* Type for XMSS^MT key pair index */\n      /* Depends solely\
    \ on h */\n      union idx_sig_xmssmt switch (xmss_algorithm_type type) {\n  \
    \      case xmssmt-sha2_20/2_256:\n        case xmssmt-sha2_20/4_256:\n      \
    \  case xmssmt-sha2_20/2_512:\n        case xmssmt-sha2_20/4_512:\n        case\
    \ xmssmt-shake_20/2_256:\n        case xmssmt-shake_20/4_256:\n        case xmssmt-shake_20/2_512:\n\
    \        case xmssmt-shake_20/4_512:\n          bytestring3 idx3;\n        case\
    \ xmssmt-sha2_40/2_256:\n        case xmssmt-sha2_40/4_256:\n        case xmssmt-sha2_40/8_256:\n\
    \        case xmssmt-sha2_40/2_512:\n        case xmssmt-sha2_40/4_512:\n    \
    \    case xmssmt-sha2_40/8_512:\n        case xmssmt-shake_40/2_256:\n       \
    \ case xmssmt-shake_40/4_256:\n        case xmssmt-shake_40/8_256:\n        case\
    \ xmssmt-shake_40/2_512:\n        case xmssmt-shake_40/4_512:\n        case xmssmt-shake_40/8_512:\n\
    \          bytestring5 idx5;\n        case xmssmt-sha2_60/3_256:\n        case\
    \ xmssmt-sha2_60/6_256:\n        case xmssmt-sha2_60/12_256:\n        case xmssmt-sha2_60/3_512:\n\
    \        case xmssmt-sha2_60/6_512:\n        case xmssmt-sha2_60/12_512:\n   \
    \     case xmssmt-shake_60/3_256:\n        case xmssmt-shake_60/6_256:\n     \
    \   case xmssmt-shake_60/12_256:\n        case xmssmt-shake_60/3_512:\n      \
    \  case xmssmt-shake_60/6_512:\n        case xmssmt-shake_60/12_512:\n       \
    \   bytestring8 idx8;\n        default:\n          void;     /* error condition\
    \ */\n      };\n      union random_string_xmssmt switch (xmssmt_algorithm_type\
    \ type) {\n        case xmssmt-sha2_20/2_256:\n        case xmssmt-sha2_20/4_256:\n\
    \        case xmssmt-sha2_40/2_256:\n        case xmssmt-sha2_40/4_256:\n    \
    \    case xmssmt-sha2_40/8_256:\n        case xmssmt-sha2_60/3_256:\n        case\
    \ xmssmt-sha2_60/6_256:\n        case xmssmt-sha2_60/12_256:\n        case xmssmt-shake_20/2_256:\n\
    \        case xmssmt-shake_20/4_256:\n        case xmssmt-shake_40/2_256:\n  \
    \      case xmssmt-shake_40/4_256:\n        case xmssmt-shake_40/8_256:\n    \
    \    case xmssmt-shake_60/3_256:\n        case xmssmt-shake_60/6_256:\n      \
    \  case xmssmt-shake_60/12_256:\n          bytestring32 rand_n32;\n        case\
    \ xmssmt-sha2_20/2_512:\n        case xmssmt-sha2_20/4_512:\n        case xmssmt-sha2_40/2_512:\n\
    \        case xmssmt-sha2_40/4_512:\n        case xmssmt-sha2_40/8_512:\n    \
    \    case xmssmt-sha2_60/3_512:\n        case xmssmt-sha2_60/6_512:\n        case\
    \ xmssmt-sha2_60/12_512:\n        case xmssmt-shake_20/2_512:\n        case xmssmt-shake_20/4_512:\n\
    \        case xmssmt-shake_40/2_512:\n        case xmssmt-shake_40/4_512:\n  \
    \      case xmssmt-shake_40/8_512:\n        case xmssmt-shake_60/3_512:\n    \
    \    case xmssmt-shake_60/6_512:\n        case xmssmt-shake_60/12_512:\n     \
    \     bytestring64 rand_n64;\n        default:\n          void;     /* error condition\
    \ */\n      };\n      /* Type for reduced XMSS signatures */\n      union xmss_reduced\
    \ (xmss_algorithm_type type) {\n        case xmssmt-sha2_20/2_256:\n        case\
    \ xmssmt-sha2_40/4_256:\n        case xmssmt-sha2_60/6_256:\n        case xmssmt-shake_20/2_256:\n\
    \        case xmssmt-shake_40/4_256:\n        case xmssmt-shake_60/6_256:\n  \
    \        bytestring32 xmss_reduced_n32_t77[77];\n        case xmssmt-sha2_20/4_256:\n\
    \        case xmssmt-sha2_40/8_256:\n        case xmssmt-sha2_60/12_256:\n   \
    \     case xmssmt-shake_20/4_256:\n        case xmssmt-shake_40/8_256:\n     \
    \   case xmssmt-shake_60/12_256:\n          bytestring32 xmss_reduced_n32_t72[72];\n\
    \        case xmssmt-sha2_40/2_256:\n        case xmssmt-sha2_60/3_256:\n    \
    \    case xmssmt-shake_40/2_256:\n        case xmssmt-shake_60/3_256:\n      \
    \    bytestring32 xmss_reduced_n32_t87[87];\n        case xmssmt-sha2_20/2_512:\n\
    \        case xmssmt-sha2_40/4_512:\n        case xmssmt-sha2_60/6_512:\n    \
    \    case xmssmt-shake_20/2_512:\n        case xmssmt-shake_40/4_512:\n      \
    \  case xmssmt-shake_60/6_512:\n          bytestring64 xmss_reduced_n32_t141[141];\n\
    \        case xmssmt-sha2_20/4_512:\n        case xmssmt-sha2_40/8_512:\n    \
    \    case xmssmt-sha2_60/12_512:\n        case xmssmt-shake_20/4_512:\n      \
    \  case xmssmt-shake_40/8_512:\n        case xmssmt-shake_60/12_512:\n       \
    \   bytestring64 xmss_reduced_n32_t136[136];\n        case xmssmt-sha2_40/2_512:\n\
    \        case xmssmt-sha2_60/3_512:\n        case xmssmt-shake_40/2_512:\n   \
    \     case xmssmt-shake_60/3_512:\n          bytestring64 xmss_reduced_n32_t151[151];\n\
    \        default:\n          void;     /* error condition */\n      };\n     \
    \ /* xmss_reduced_array depends on d */\n      union xmss_reduced_array (xmss_algorithm_type\
    \ type) {\n        case xmssmt-sha2_20/2_256:\n        case xmssmt-sha2_20/2_512:\n\
    \        case xmssmt-sha2_40/2_256:\n        case xmssmt-sha2_40/2_512:\n    \
    \    case xmssmt-shake_20/2_256:\n        case xmssmt-shake_20/2_512:\n      \
    \  case xmssmt-shake_40/2_256:\n        case xmssmt-shake_40/2_512:\n        \
    \  xmss_reduced xmss_red_arr_d2[2];\n        case xmssmt-sha2_60/3_256:\n    \
    \    case xmssmt-sha2_60/3_512:\n        case xmssmt-shake_60/3_256:\n       \
    \ case xmssmt-shake_60/3_512:\n          xmss_reduced xmss_red_arr_d3[3];\n  \
    \      case xmssmt-sha2_20/4_256:\n        case xmssmt-sha2_20/4_512:\n      \
    \  case xmssmt-sha2_40/4_256:\n        case xmssmt-sha2_40/4_512:\n        case\
    \ xmssmt-shake_20/4_256:\n        case xmssmt-shake_20/4_512:\n        case xmssmt-shake_40/4_256:\n\
    \        case xmssmt-shake_40/4_512:\n          xmss_reduced xmss_red_arr_d4[4];\n\
    \        case xmssmt-sha2_60/6_256:\n        case xmssmt-sha2_60/6_512:\n    \
    \    case xmssmt-shake_60/6_256:\n        case xmssmt-shake_60/6_512:\n      \
    \    xmss_reduced xmss_red_arr_d6[6];\n        case xmssmt-sha2_40/8_256:\n  \
    \      case xmssmt-sha2_40/8_512:\n        case xmssmt-shake_40/8_256:\n     \
    \   case xmssmt-shake_40/8_512:\n          xmss_reduced xmss_red_arr_d8[8];\n\
    \        case xmssmt-sha2_60/12_256:\n        case xmssmt-sha2_60/12_512:\n  \
    \      case xmssmt-shake_60/12_256:\n        case xmssmt-shake_60/12_512:\n  \
    \        xmss_reduced xmss_red_arr_d12[12];\n        default:\n          void;\
    \     /* error condition */\n      };\n      /* XMSS^MT signature structure */\n\
    \      struct xmssmt_signature {\n        /* WOTS+ key pair index */\n       \
    \ idx_sig_xmssmt idx_sig;\n        /* Random string for randomized hashing */\n\
    \        random_string_xmssmt randomness;\n        /* Array of d reduced XMSS\
    \ signatures */\n        xmss_reduced_array;\n      };\n"
- title: C.3.  XMSS^MT Public Keys
  contents:
  - "C.3.  XMSS^MT Public Keys\n   XMSS^MT public keys are defined using XDR syntax\
    \ as follows:\n      /* Types for bitmask seed */\n      union seed switch (xmssmt_algorithm_type\
    \ type) {\n        case xmssmt-sha2_20/2_256:\n        case xmssmt-sha2_40/4_256:\n\
    \        case xmssmt-sha2_60/6_256:\n        case xmssmt-sha2_20/4_256:\n    \
    \    case xmssmt-sha2_40/8_256:\n        case xmssmt-sha2_60/12_256:\n       \
    \ case xmssmt-sha2_40/2_256:\n        case xmssmt-sha2_60/3_256:\n        case\
    \ xmssmt-shake_20/2_256:\n        case xmssmt-shake_40/4_256:\n        case xmssmt-shake_60/6_256:\n\
    \        case xmssmt-shake_20/4_256:\n        case xmssmt-shake_40/8_256:\n  \
    \      case xmssmt-shake_60/12_256:\n        case xmssmt-shake_40/2_256:\n   \
    \     case xmssmt-shake_60/3_256:\n          bytestring32 seed_n32;\n        case\
    \ xmssmt-sha2_20/2_512:\n        case xmssmt-sha2_40/4_512:\n        case xmssmt-sha2_60/6_512:\n\
    \        case xmssmt-sha2_20/4_512:\n        case xmssmt-sha2_40/8_512:\n    \
    \    case xmssmt-sha2_60/12_512:\n        case xmssmt-sha2_40/2_512:\n       \
    \ case xmssmt-sha2_60/3_512:\n        case xmssmt-shake_20/2_512:\n        case\
    \ xmssmt-shake_40/4_512:\n        case xmssmt-shake_60/6_512:\n        case xmssmt-shake_20/4_512:\n\
    \        case xmssmt-shake_40/8_512:\n        case xmssmt-shake_60/12_512:\n \
    \       case xmssmt-shake_40/2_512:\n        case xmssmt-shake_60/3_512:\n   \
    \       bytestring64 seed_n64;\n        default:\n          void;     /* error\
    \ condition */\n      };\n      /* Types for XMSS^MT root node */\n      union\
    \ xmssmt_root switch (xmssmt_algorithm_type type) {\n        case xmssmt-sha2_20/2_256:\n\
    \        case xmssmt-sha2_20/4_256:\n        case xmssmt-sha2_40/2_256:\n    \
    \    case xmssmt-sha2_40/4_256:\n        case xmssmt-sha2_40/8_256:\n        case\
    \ xmssmt-sha2_60/3_256:\n        case xmssmt-sha2_60/6_256:\n        case xmssmt-sha2_60/12_256:\n\
    \        case xmssmt-shake_20/2_256:\n        case xmssmt-shake_20/4_256:\n  \
    \      case xmssmt-shake_40/2_256:\n        case xmssmt-shake_40/4_256:\n    \
    \    case xmssmt-shake_40/8_256:\n        case xmssmt-shake_60/3_256:\n      \
    \  case xmssmt-shake_60/6_256:\n        case xmssmt-shake_60/12_256:\n       \
    \   bytestring32 root_n32;\n        case xmssmt-sha2_20/2_512:\n        case xmssmt-sha2_20/4_512:\n\
    \        case xmssmt-sha2_40/2_512:\n        case xmssmt-sha2_40/4_512:\n    \
    \    case xmssmt-sha2_40/8_512:\n        case xmssmt-sha2_60/3_512:\n        case\
    \ xmssmt-sha2_60/6_512:\n        case xmssmt-sha2_60/12_512:\n        case xmssmt-shake_20/2_512:\n\
    \        case xmssmt-shake_20/4_512:\n        case xmssmt-shake_40/2_512:\n  \
    \      case xmssmt-shake_40/4_512:\n        case xmssmt-shake_40/8_512:\n    \
    \    case xmssmt-shake_60/3_512:\n        case xmssmt-shake_60/6_512:\n      \
    \  case xmssmt-shake_60/12_512:\n          bytestring64 root_n64;\n        default:\n\
    \          void;     /* error condition */\n      };\n      /* XMSS^MT public\
    \ key structure */\n      struct xmssmt_public_key {\n        xmssmt_root root;\
    \  /* Root node */\n        seed SEED;  /* Seed for bitmasks */\n      };\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   We would like to thank Johannes Braun, Peter Campbell, Florian\n\
    \   Caullery, Stephen Farrell, Scott Fluhrer, Burt Kaliski, Adam Langley,\n  \
    \ Marcos Manzano, David McGrew, Rafael Misoczki, Sean Parkinson,\n   Sebastian\
    \ Roland, and the Keccak team for their help and comments.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Andreas Huelsing\n   TU Eindhoven\n   P.O. Box 513\n \
    \  Eindhoven  5600 MB\n   The Netherlands\n   Email: ietf@huelsing.net\n   Denis\
    \ Butin\n   TU Darmstadt\n   Hochschulstrasse 10\n   Darmstadt  64289\n   Germany\n\
    \   Email: dbutin@cdc.informatik.tu-darmstadt.de\n   Stefan-Lukas Gazdag\n   genua\
    \ GmbH\n   Domagkstrasse 7\n   Kirchheim bei Muenchen  85551\n   Germany\n   Email:\
    \ ietf@gazdag.de\n   Joost Rijneveld\n   Radboud University\n   Toernooiveld 212\n\
    \   Nijmegen  6525 EC\n   The Netherlands\n   Email: ietf@joostrijneveld.nl\n\
    \   Aziz Mohaisen\n   University of Central Florida\n   4000 Central Florida Blvd\n\
    \   Orlando, FL  32816\n   United States of America\n   Phone: +1 407 823-1294\n\
    \   Email: mohaisen@ieee.org\n"
