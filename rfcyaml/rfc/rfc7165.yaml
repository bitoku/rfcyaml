- title: __initial_text__
  contents:
  - "                     Use Cases and Requirements for\n               JSON Object\
    \ Signing and Encryption (JOSE)\n"
- title: Abstract
  contents:
  - "Abstract\n   Many Internet applications have a need for object-based security\n\
    \   mechanisms in addition to security mechanisms at the network layer or\n  \
    \ transport layer.  For many years, the Cryptographic Message Syntax\n   (CMS)\
    \ has provided a binary secure object format based on ASN.1.\n   Over time, binary\
    \ object encodings such as ASN.1 have become less\n   common than text-based encodings,\
    \ such as the JavaScript Object\n   Notation (JSON).  This document defines a\
    \ set of use cases and\n   requirements for a secure object format encoded using\
    \ JSON, drawn\n   from a variety of application security mechanisms currently\
    \ in\n   development.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7165.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Definitions . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Basic Requirements  . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  Requirements on Application Protocols . . . . . . . . . .\
    \ . .   6\n   5.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     5.1.  Security Tokens . . . . . . . . . . . . . . . . . . . . .\
    \   7\n     5.2.  OAuth . . . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 7\n     5.3.  OpenID Connect  . . . . . . . . . . . . . . . . . . . . .   9\n\
    \     5.4.  XMPP  . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n  \
    \   5.5.  ALTO  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n    \
    \ 5.6.  Emergency Alerting  . . . . . . . . . . . . . . . . . . .  13\n     5.7.\
    \  Web Cryptography  . . . . . . . . . . . . . . . . . . . .  15\n     5.8.  Constrained\
    \ Devices . . . . . . . . . . . . . . . . . . .  16\n       5.8.1.  Example: MAC\
    \ Based on ECDH-Derived Key  . . . . . . .  16\n       5.8.2.  Object Security\
    \ for CoAP  . . . . . . . . . . . . . .  17\n   6.  Requirements  . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  18\n     6.1.  Functional Requirements\
    \ . . . . . . . . . . . . . . . . .  18\n     6.2.  Security Requirements . .\
    \ . . . . . . . . . . . . . . . .  19\n     6.3.  Desiderata  . . . . . . . .\
    \ . . . . . . . . . . . . . . .  20\n   7.  Security Considerations . . . . .\
    \ . . . . . . . . . . . . . .  20\n   8.  References  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  21\n     8.1.  Normative References  . . . . . .\
    \ . . . . . . . . . . . .  21\n     8.2.  Informative References  . . . . . .\
    \ . . . . . . . . . . .  21\n   Appendix A.  Acknowledgements . . . . . . . .\
    \ . . . . . . . . . .  25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Internet applications rest on the layered architecture of\
    \ the\n   Internet and take advantage of security mechanisms at all layers.\n\
    \   Many applications rely primarily on channel-based security\n   technologies\
    \ such as IPsec and Transport Layer Security (TLS), which\n   create a secure\
    \ channel at the IP layer or transport layer over which\n   application data can\
    \ flow [RFC4301] [RFC5246].  These mechanisms,\n   however, cannot provide end-to-end\
    \ security in some cases.  For\n   example, in protocols with application-layer\
    \ intermediaries, channel-\n   based security protocols would protect messages\
    \ from attackers\n   between intermediaries, but not from the intermediaries themselves.\n\
    \   These cases require object-based security technologies, which embed\n   application\
    \ data within a secure object that can be safely handled by\n   untrusted entities.\n\
    \   The most well-known example of such a protocol today is the use of\n   Secure/Multipurpose\
    \ Internet Mail Extensions (S/MIME) protections\n   within the email system [RFC5751]\
    \ [RFC5322].  An email message\n   typically passes through a series of intermediate\
    \ Mail Transfer\n   Agents (MTAs) en route to its destination.  While these MTAs\
    \ often\n   apply channel-based security protections to their interactions (e.g.,\n\
    \   STARTTLS [RFC3207]), these protections do not prevent the MTAs from\n   interfering\
    \ with the message.  In order to provide end-to-end\n   security protections in\
    \ the presence of untrusted MTAs, mail users\n   can use S/MIME to embed message\
    \ bodies in a secure object format that\n   can provide confidentiality, integrity,\
    \ and data origin\n   authentication.\n   S/MIME is based on the Cryptographic\
    \ Message Syntax (CMS) for secure\n   objects [RFC5652].  CMS is defined using\
    \ Abstract Syntax Notation 1\n   (ASN.1) and typically encoded using the ASN.1\
    \ Distinguished Encoding\n   Rules (DER), which define a binary encoding of the\
    \ protected message\n   and associated parameters [ITU.X690.2002].  In recent\
    \ years, usage of\n   ASN.1 has decreased (along with other binary encodings for\
    \ general\n   objects), while more applications have come to rely on text-based\n\
    \   formats such as the Extensible Markup Language (XML) [W3C.REC-xml] or\n  \
    \ the JavaScript Object Notation (JSON) [RFC7159].\n   Many current applications\
    \ thus have much more robust support for\n   processing objects in these text-based\
    \ formats than ASN.1 objects;\n   indeed, many lack the ability to process ASN.1\
    \ objects at all.  To\n   simplify the addition of object-based security features\
    \ to these\n   applications, the IETF JSON Object Signing and Encryption (JOSE)\n\
    \   working group has been chartered to develop a secure object format\n   based\
    \ on JSON.  While the basic requirements for this object format\n   are straightforward\
    \ -- namely, confidentiality and integrity\n   mechanisms encoded in JSON -- discussions\
    \ in the working group\n   indicated that different applications hoping to use\
    \ the formats\n   defined by JOSE have different requirements.  This document\n\
    \   summarizes the use cases for JOSE envisioned by those potential\n   applications\
    \ and the resulting requirements for security mechanisms\n   and object encodings.\n\
    \   Some systems that use XML have specified the use of XML-based\n   security\
    \ mechanisms for object security, namely XML Digital\n   Signatures and XML Encryption\
    \ [W3C.xmldsig-core] [W3C.xmlenc-core].\n   These mechanisms are used by several\
    \ security token systems (e.g.,\n   Security Assertion Markup Language (SAML)\
    \ [OASIS.saml-core-2.0-os],\n   Web Services Federation [WS-Federation]), and\
    \ the Common Alerting\n   Protocol (CAP) emergency alerting format [CAP].  In\
    \ practice,\n   however, XML-based secure object formats introduce similar levels\
    \ of\n   complexity to ASN.1 (e.g., due to the need for XML canonicalization),\n\
    \   so developers that lack the tools or motivation to handle ASN.1\n   aren't\
    \ likely to use XML security either.  This situation motivates\n   the creation\
    \ of a JSON-based secure object format that is simple\n   enough to implement\
    \ and deploy that it can be easily adopted by\n   developers with minimal effort\
    \ and tools.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   This document makes extensive use of standard security terminology\n\
    \   [RFC4949].  In addition, because the use cases for JOSE and CMS are\n   similar,\
    \ we will sometimes make analogies to some CMS concepts\n   [RFC5652].\n   The\
    \ JOSE working group charter calls for the group to define three\n   basic JSON\
    \ object formats:\n   1.  Integrity-protected object format\n   2.  Confidentiality-protected\
    \ object format\n   3.  A format for expressing keys\n   In this document, we\
    \ will refer to these as the \"signed object\n   format\", the \"encrypted object\
    \ format\", and the \"key format\",\n   respectively.  The JOSE working group\
    \ items intended to describe\n   these formats are JSON Web Signature [JWS], JSON\
    \ Web Encryption\n   [JWE], and JSON Web Key [JWK], respectively.  Algorithms\
    \ and\n   algorithm identifiers used by JWS, JWE, and JWK are defined in JSON\n\
    \   Web Algorithms [JWA].\n   In general, where there is no need to distinguish\
    \ between asymmetric\n   and symmetric operations, we will use the terms \"signing\"\
    ,\n   \"signature\", etc., to denote both true digital signatures involving\n\
    \   asymmetric cryptography as well as Message Authentication Codes\n   (MACs)\
    \ using symmetric keys.\n   In the lifespan of a secure object, there are two\
    \ basic roles, an\n   entity that creates the object (e.g., encrypting or signing\
    \ a\n   payload) and an entity that uses the object (decrypting and\n   verifying).\
    \  We will refer to these roles as \"sender\" and\n   \"recipient\", respectively.\
    \  Note that while some requirements and use\n   cases may refer to these as single\
    \ entities, each object may have\n   multiple entities in each role.  For example,\
    \ a message may be signed\n   by multiple senders or decrypted by multiple recipients.\n"
- title: 3.  Basic Requirements
  contents:
  - "3.  Basic Requirements\n   For the encrypted and signed object formats, the necessary\n\
    \   protections will be created using appropriate cryptographic\n   mechanisms:\
    \ symmetric or asymmetric encryption for confidentiality\n   and MACs or digital\
    \ signatures for integrity protection.  In both\n   cases, it is necessary for\
    \ the JOSE format to support both symmetric\n   and asymmetric operations.\n \
    \  o  The JOSE encrypted object format must support object encryption in\n   \
    \   the case where the sender and receiver share a symmetric key.\n   o  The JOSE\
    \ encrypted object format must support object encryption in\n      the case where\
    \ the sender has only a public key for the receiver.\n   o  The JOSE signed object\
    \ format must support integrity protection\n      using MACs, for the case where\
    \ the sender and receiver share only\n      a symmetric key.\n   o  The JOSE signed\
    \ object format must support integrity protection\n      using digital signatures,\
    \ for the case where the receiver has only\n      a public key for the sender.\n\
    \   In some applications, the key used to process a JOSE object is\n   indicated\
    \ by application context, instead of directly in the JOSE\n   object.  However,\
    \ in order to avoid confusion, endpoints that lack\n   the necessary context need\
    \ to be able to recognize this and fail\n   cleanly.  Other than keys, JOSE objects\
    \ do not support pre-\n   negotiation; all cryptographic parameters must be expressed\
    \ directly\n   in the JOSE object.\n   o  The JOSE signed and encrypted object\
    \ formats must define the\n      process by which an implementation recognizes\
    \ whether it has the\n      key required to process a given object, whether the\
    \ key is\n      specified by the object or by some out-of-band mechanism.\n  \
    \ o  Each algorithm used for JOSE must define which parameters are\n      required\
    \ to be present in a JOSE object using that algorithm.\n   In cases where two\
    \ entities are going to be exchanging several JOSE\n   objects, it might be helpful\
    \ to pre-negotiate some parameters so that\n   they do not have to be signaled\
    \ in every JOSE object.  However, so as\n   not to confuse endpoints that do not\
    \ support pre-negotiation, it is\n   useful to signal when pre-negotiated parameters\
    \ are in use in those\n   cases.\n   o  It should be possible to extend the base\
    \ JOSE signed and encrypted\n      object formats to indicate that pre-negotiated\
    \ parameters are to\n      be used to process the object.  This extension should\
    \ also provide\n      a means of indicating which parameters are to be used.\n\
    \   The purpose of the key format is to provide the recipient with\n   sufficient\
    \ information to use the encoded key to process\n   cryptographic messages.  Thus,\
    \ it is sometimes necessary to include\n   additional parameters along with the\
    \ bare key.\n   o  The JOSE key format must enable inclusion of all algorithm\n\
    \      parameters necessary to use the encoded key, including an\n      identifier\
    \ for the algorithm with which the key is used as well as\n      any additional\
    \ parameters required by the algorithm (e.g.,\n      elliptic curve parameters).\n"
- title: 4.  Requirements on Application Protocols
  contents:
  - "4.  Requirements on Application Protocols\n   The JOSE secure object formats\
    \ describe how cryptographic processing\n   is done on secured content, ensuring\
    \ that the recipient of an object\n   is able to properly decrypt an encrypted\
    \ object or verify a\n   signature.  In order to make use of JOSE, however, applications\
    \ will\n   need to specify several aspects of how JOSE is to be used:\n   o  What\
    \ application content is to be protected\n   o  Which cryptographic algorithms\
    \ are to be used\n   o  How application protocol entities establish keys\n   o\
    \  Whether keys are to be explicitly indicated in JOSE objects or\n      associated\
    \ by application context\n   o  Which serialization(s) of JOSE objects are to\
    \ be used\n"
- title: 5.  Use Cases
  contents:
  - "5.  Use Cases\n   Several IETF working groups developing application-layer protocols\n\
    \   have expressed a desire to use the JOSE data formats in their designs\n  \
    \ for end-to-end security features.  In this section, we summarize the\n   use\
    \ cases proposed by these groups and discuss the requirements that\n   they imply\
    \ for the JOSE object formats.\n"
- title: 5.1.  Security Tokens
  contents:
  - "5.1.  Security Tokens\n   Security tokens are a common use case for object-based\
    \ security, for\n   example, SAML assertions [OASIS.saml-core-2.0-os].  Security\
    \ tokens\n   are used to convey information about a subject entity (\"claims\"\
    \ or\n   \"assertions\") from an issuer to a recipient.  The security features\n\
    \   of a token format enable the recipient to verify that the claims came\n  \
    \ from the issuer and, if the object is confidentiality protected, that\n   they\
    \ were not visible to other parties.\n   Security tokens are used in federation\
    \ protocols such as SAML 2.0\n   [OASIS.saml-core-2.0-os], WS-Federation [WS-Federation],\
    \ Mozilla\n   Persona [Persona], and OpenID Connect [OpenID.Core], as well as\
    \ in\n   resource authorization protocols such as OAuth 2.0 [RFC6749],\n   including\
    \ for OAuth bearer tokens [RFC6750].  In some cases, security\n   tokens are used\
    \ for client authentication and for access control\n   [JWT-BEARER] [SAML2].\n\
    \   JSON Web Token [JWT] is a security token format based on JSON and\n   JOSE.\
    \  It is used with Mozilla Persona, OpenID Connect, and OAuth.\n   Because JWTs\
    \ are often used in contexts with limited space (e.g.,\n   HTTP query parameters),\
    \ it is a core requirement for JWTs, and thus\n   JOSE, to have a compact, URL-safe\
    \ representation.\n"
- title: 5.2.  OAuth
  contents:
  - "5.2.  OAuth\n   The OAuth protocol defines a mechanism for distributing and using\n\
    \   authorization tokens using HTTP [RFC6749].  A client that wishes to\n   access\
    \ a protected resource requests authorization from the resource\n   owner.  If\
    \ the resource owner allows this access, he directs an\n   authorization server\
    \ to issue an access token to the client.  When\n   the client wishes to access\
    \ the protected resource, he presents the\n   token to the relevant resource server,\
    \ which verifies the validity of\n   the token before providing access to the\
    \ protected resource.\n                 +---------------+          +---------------+\n\
    \                 |               |          |               |\n             \
    \    |   Resource    |<........>| Authorization |\n                 |    Server\
    \     |          |     Server    |\n                 |               |       \
    \   |               |\n                 +---------------+          +---------------+\n\
    \                              ^                |\n                          \
    \    |                |\n                              |                |\n  \
    \                            |                |\n                            \
    \  |                |\n                 +------------|--+          +--|------------+\n\
    \                 |            +----------------+            |\n             \
    \    |               |          |   Resource    |\n                 |     Client\
    \    |          |     Owner     |\n                 |               |        \
    \  |               |\n                 +---------------+          +---------------+\n\
    \                        Figure 1: The OAuth Process\n   In effect, this process\
    \ moves the token from the authorization server\n   (as a sender of the object)\
    \ to the resource server (recipient) via\n   the client as well as the resource\
    \ owner (the latter because of the\n   HTTP mechanics underlying the protocol).\
    \  As with email, we have a\n   case where an application object is transported\
    \ via untrusted\n   intermediaries.\n   This application has two essential security\
    \ requirements: integrity\n   and data origin authentication.  Integrity protection\
    \ is required so\n   that the resource owner and the client cannot modify the\
    \ permission\n   encoded in the token.  Although the resource owner is ultimately\
    \ the\n   entity that grants authorization, it is not trusted to modify the\n\
    \   authorization token, since this could, for example, grant access to\n   resources\
    \ not owned by the resource owner.\n   Data origin authentication is required\
    \ so that the resource server\n   can verify that the token was issued by a trusted\
    \ authorization\n   server.\n   Confidentiality protection may also be needed\
    \ if the authorization\n   server is concerned about the visibility of permissions\
    \ information\n   to the resource owner or client.  For example, permissions related\
    \ to\n   social networking might be considered private information.  Note,\n \
    \  however, that OAuth already requires that the underlying HTTP\n   transactions\
    \ be protected by TLS, so tokens are already\n   confidentiality protected from\
    \ entities other than the resource owner\n   and client.\n   The confidentiality\
    \ and integrity needs are met by the basic\n   requirements for signed and encrypted\
    \ object formats, whether the\n   signing and encryption are provided using asymmetric\
    \ or symmetric\n   cryptography.  The choice of which mechanism is applied will\
    \ depend\n   on the relationship between the two servers, namely whether they\n\
    \   share a symmetric key or only public keys.\n   Authentication requirements\
    \ will also depend on deployment\n   characteristics.  Where there is a relatively\
    \ strong binding between\n   the resource server and the authorization server,\
    \ it may suffice for\n   the authorization server issuing a token to be identified\
    \ by the key\n   used to sign the token.  This requires that the protocol carry\
    \ either\n   the public key of the authorization server or an identifier for the\n\
    \   public or symmetric key.  In OAuth, the \"client_id\" parameter\n   (external\
    \ to the token) identifies the key to be used.\n   There may also be more advanced\
    \ cases where the authorization\n   server's key is not known in advance to the\
    \ resource server.  This\n   may happen, for instance, if an entity instantiated\
    \ a collection of\n   authorization servers (say for load balancing), each of\
    \ which has an\n   independent key pair.  In these cases, it may be necessary\
    \ to also\n   include a certificate or certificate chain for the authorization\n\
    \   server, so that the resource server can verify that the authorization\n  \
    \ server is an entity that it trusts.\n   The HTTP transport for OAuth imposes\
    \ a particular constraint on the\n   encoding.  In the OAuth protocol, tokens\
    \ frequently need to be passed\n   as query parameters in HTTP URIs [RFC2616]\
    \ after having been\n   base64url encoded [RFC4648].  While there is no specified\
    \ limit on\n   the length of URIs (and thus of query parameters), in practice,\
    \ URIs\n   of more than 2,048 characters are rejected by some user agents.  So\n\
    \   this use case requires that JOSE objects be sufficiently small, even\n   after\
    \ being signed and possibly encrypted.\n"
- title: 5.3.  OpenID Connect
  contents:
  - "5.3.  OpenID Connect\n   The OpenID Connect protocol [OpenID.Core] is a simple,\
    \ REST/JSON-\n   based identity federation protocol layered on OAuth 2.0.  It\
    \ uses the\n   JWT and JOSE formats both to represent security tokens and to provide\n\
    \   security for other protocol messages (performing signing and\n   optionally\
    \ encryption).  OpenID Connect negotiates the algorithms to\n   be used and distributes\
    \ information about the keys to be used using\n   protocol elements that are not\
    \ part of the JWT and JOSE header\n   parameters.\n   In the OpenID Connect context,\
    \ it is possible for the recipient of a\n   JWT to accept it without integrity\
    \ protection in the JWT itself.  In\n   such cases, the recipient chooses to rely\
    \ on transport security\n   rather than object security.  For example, if the\
    \ payload is\n   delivered over a TLS-protected channel, the recipient may regard\
    \ the\n   protections provided by TLS as sufficient, so JOSE protection would\n\
    \   not be required.\n   However, even in this case, it is desirable to associate\
    \ some\n   metadata with the JWT payload (claim set), such as the content type,\n\
    \   or other application-specific metadata.  In a signed or encrypted\n   object,\
    \ these metadata values could be carried in a header with other\n   metadata required\
    \ for signing or encryption.  It would thus simplify\n   the design of OpenID\
    \ Connect if there could be a JOSE object format\n   that does not apply cryptographic\
    \ protections to its payload, but\n   allows a header to be attached to the payload\
    \ in the same way as a\n   signed or encrypted object.\n"
- title: 5.4.  XMPP
  contents:
  - "5.4.  XMPP\n   The Extensible Messaging and Presence Protocol (XMPP) routes messages\n\
    \   from one end client to another by way of XMPP servers [RFC6120].\n   There\
    \ are typically two servers involved in delivering any given\n   message: The\
    \ first client (Alice) sends a message for another client\n   (Bob) to her server\
    \ (A).  Server A uses Bob's identity and the DNS to\n   locate the server for\
    \ Bob's domain (B) and then delivers the message\n   to that server.  Server B\
    \ then routes the message to Bob.\n            +-------+   +----------+   +----------+\
    \   +-----+\n            | Alice |-->| Server A |-->| Server B |-->| Bob |\n \
    \           +-------+   +----------+   +----------+   +-----+\n              \
    \     Figure 2: Delivering an XMPP Message\n   The untrusted-intermediary problems\
    \ are especially acute for XMPP\n   because in many current deployments, the holder\
    \ of an XMPP domain\n   outsources the operation of the domain's servers to a\
    \ different\n   entity.  In this environment, there is a clear risk of exposing\
    \ the\n   domain holder's private information to the domain operator.  XMPP\n\
    \   already has a defined mechanism for end-to-end security using S/MIME,\n  \
    \ but it has failed to gain widespread deployment [RFC3923], in part\n   because\
    \ of key management challenges and in part because of the\n   difficulty of processing\
    \ S/MIME objects.\n   The XMPP working group is in the process of developing a\
    \ new\n   end-to-end encryption system with an encoding based on JOSE and a\n\
    \   clearer key management system [XMPP-E2E].  The process of sending an\n   encrypted\
    \ message in this system involves two steps: First, the\n   sender generates a\
    \ symmetric Session Master Key (SMK), encrypts the\n   message content (including\
    \ a per-message Content Master Key), and\n   sends the encrypted message to the\
    \ desired set of recipients.\n   Second, each recipient \"dials back\" to the\
    \ sender, providing his\n   public key.  The sender then responds with the relevant\
    \ SMK, wrapped\n   with the recipient's public key.\n            +-------+   +----------+\
    \   +----------+   +-----+\n            | Alice |<->| Server A |<->| Server B\
    \ |<->| Bob |\n            +-------+   +----------+   +----------+   +-----+\n\
    \                |             |              |           |\n                |------------Encrypted\
    \ message---------->|\n                |             |              |        \
    \   |\n                |<---------------Public key--------------|\n          \
    \      |             |              |           |\n                |---------------Wrapped\
    \ SMK------------->|\n                |             |              |         \
    \  |\n                Figure 3: Delivering a Secure XMPP Message\n   The main\
    \ thing that this system requires from the JOSE formats is\n   confidentiality\
    \ protection via content encryption, plus an integrity\n   check via a MAC derived\
    \ from the same symmetric key.  The separation\n   of the key exchange from the\
    \ transmission of the encrypted content,\n   however, requires that the JOSE encrypted\
    \ object format allow wrapped\n   symmetric keys to be carried separately from\
    \ the encrypted payload.\n   In addition, the encrypted object will need to have\
    \ a tag for the key\n   that was used to encrypt the content, so that the recipient\
    \ (Bob) can\n   present the tag to the sender (Alice) when requesting the wrapped\n\
    \   key.\n   Another important feature of XMPP is that it allows for the\n   simultaneous\
    \ delivery of a message to multiple recipients.  In the\n   diagrams above, Server\
    \ A could deliver the message not only to Server\n   B (for Bob) but also to Servers\
    \ C, D, E, etc., for other users.  In\n   such cases, to avoid the multiple \"\
    dial back\" transactions implied by\n   the above mechanism, XMPP systems will\
    \ likely reuse a given SMK for\n   multiple individual messages, refreshing the\
    \ SMK on a periodic and/or\n   event-driven basis (e.g., when the recipient's\
    \ presence changes).\n   They might also cache public keys for end recipients,\
    \ so that wrapped\n   keys can be sent along with content on future messages.\
    \  This implies\n   that the JOSE encrypted object format must support the provision\
    \ of\n   multiple versions of the same wrapped SMK (much as a CMS\n   EnvelopedData\
    \ structure can include multiple RecipientInfo\n   structures).\n   In the current\
    \ draft of the XMPP end-to-end security system, each\n   party is authenticated\
    \ by virtue of the other party's trust in the\n   XMPP message routing system.\
    \  The sender is authenticated to the\n   receiver because he can receive messages\
    \ for the identifier \"Alice\"\n   (in particular, the request for wrapped keys)\
    \ and can originate\n   messages for that identifier (the wrapped key).  Likewise,\
    \ the\n   receiver is authenticated to the sender because he received the\n  \
    \ original encrypted message and originated the request for a wrapped\n   key.\
    \  So, the authentication here requires not only that XMPP routing\n   be done\
    \ properly, but also that TLS be used on every hop.  Moreover,\n   it requires\
    \ that the TLS channels have strong authentication, since a\n   man in the middle\
    \ on any of the three hops can masquerade as Bob and\n   obtain the key material\
    \ for an encrypted message.\n   Because this authentication is quite weak (depending\
    \ on the use of\n   TLS on three hops) and unverifiable by the endpoints, it is\
    \ possible\n   that the XMPP working group will integrate some sort of credentials\n\
    \   for end recipients, in which case there would need to be a way to\n   associate\
    \ these credentials with JOSE objects.\n   Finally, it's worth noting that XMPP\
    \ is based on XML, not JSON.  So\n   by using JOSE, XMPP will be carrying JSON\
    \ objects within XML.  It is\n   thus a desirable property for JOSE objects to\
    \ be encoded in such a\n   way as to be safe for inclusion in XML.  Otherwise,\
    \ an explicit CDATA\n   indication must be given to the parser to indicate that\
    \ it is not to\n   be parsed as XML.  One way to meet this requirement would be\
    \ to apply\n   base64url encoding, but for XMPP messages of medium-to-large size,\n\
    \   this could impose a fair degree of overhead.\n"
- title: 5.5.  ALTO
  contents:
  - "5.5.  ALTO\n   Application-Layer Traffic Optimization (ALTO) is a system for\n\
    \   distributing network topology information to end devices, so that\n   those\
    \ devices can modify their behavior to have a lower impact on the\n   network\
    \ [RFC6708].  The ALTO protocol distributes topology\n   information in the form\
    \ of JSON objects carried in HTTP [RFC2616]\n   [ALTO].  The basic version of\
    \ ALTO is simply a client-server\n   protocol, so simple use of HTTPS suffices\
    \ for this case [RFC2818].\n   However, there is beginning to be some discussion\
    \ of use cases for\n   ALTO in which these JSON objects will be distributed through\
    \ a\n   collection of intermediate servers before reaching the client, while\n\
    \   still preserving the ability of the client to authenticate the\n   original\
    \ source of the object.  Even the base ALTO protocol notes\n   that \"ALTO Clients\
    \ obtaining ALTO information through redistribution\n   must be able to validate\
    \ the received ALTO information\" to ensure\n   that it was generated by an appropriate\
    \ ALTO server.\n   In this case, the security requirements are straightforward.\
    \  JOSE\n   objects carrying ALTO payloads will need to bear digital signatures\n\
    \   from the originating servers, which will be bound to certificates\n   attesting\
    \ to the identities of the servers.  There is no requirement\n   for confidentiality\
    \ in this case, since ALTO information is generally\n   public.\n   The more interesting\
    \ questions are encoding questions.  ALTO objects\n   are likely to be much larger\
    \ than payloads in the two cases above,\n   with sizes of up to several megabytes.\
    \  Processing of such large\n   objects can be done more quickly if it can be\
    \ done in a single pass,\n   which may be possible if JOSE objects require specific\
    \ orderings of\n   fields within the JSON structure.\n   In addition, because\
    \ ALTO objects are also encoded as JSON, they are\n   already safe for inclusion\
    \ in a JOSE object.  Signed JOSE objects\n   will likely carry the signed data\
    \ in a string alongside the\n   signature.  JSON objects have the property that\
    \ they can be safely\n   encoded in JSON strings.  All they require is that unnecessary\
    \ white\n   space be removed, a much simpler transformation than, say, base64url\n\
    \   encoding.  This raises the question of whether it might be possible\n   to\
    \ optimize the JOSE encoding for certain \"JSON-safe\" cases.\n   Finally, it\
    \ may be desirable for ALTO to have a \"detached signature\"\n   mechanism, that\
    \ is, a way to encode signature information separate\n   from the protected content.\
    \  This would allow the ALTO protocol to\n   include the signature in an HTTPS\
    \ header, with the signed content as\n   the HTTPS entity body.\n"
- title: 5.6.  Emergency Alerting
  contents:
  - "5.6.  Emergency Alerting\n   Emergency alerting is an emerging use case for IP\
    \ networks\n   [ALERT-REQ].  Alerting systems allow authorities to warn users\
    \ of\n   impending danger by sending alert messages to connected devices.  For\n\
    \   example, in the event of a hurricane or tornado, alerts might be sent\n  \
    \ to all devices in the path of the storm.\n   The most critical security requirement\
    \ for alerting systems is that\n   it must not be possible for an attacker to\
    \ send false alerts to\n   devices.  Such a capability would potentially allow\
    \ an attacker to\n   create wide-spread panic.  In practice, alert systems prevent\
    \ these\n   attacks both by controls on sending messages at points where alerts\n\
    \   are originated, and by having recipients of alerts verify that the\n   alert\
    \ was sent by an authorized source.  The former type of control\n   is implemented\
    \ with local security on hosts from which alerts can be\n   originated.  The latter\
    \ type is implemented by digital signatures on\n   alert messages (using channel-based\
    \ or object-based mechanisms).\n   With an object-based mechanism, the signature\
    \ value is encoded in a\n   secure object.  With a channel-based mechanism, the\
    \ alert is \"signed\"\n   by virtue of being sent over an authenticated, integrity-protected\n\
    \   channel.\n   Alerts typically reach end recipients via a series of intermediaries.\n\
    \   For example, while a national weather service might originate a\n   hurricane\
    \ alert, it might first be delivered to a national gateway\n   and then to network\
    \ operators, who broadcast it to end subscribers.\n           +------------+ \
    \   +------------+    +------------+\n           | Originator |    | Originator\
    \ |    | Originator |\n           +------------+    +------------+    +------------+\n\
    \                 |                 .                 .\n                 +-----------------+..................\n\
    \                                   |\n                                   V\n\
    \                              +---------+\n                              | Gateway\
    \ |\n                              +---------+\n                             \
    \      |\n                      +------------+------------+\n                \
    \      |                         |\n                      V                  \
    \       V\n                 +---------+               +---------+\n          \
    \       | Network |               | Network |\n                 +---------+  \
    \             +---------+\n                      |                         |\n\
    \               +------+-----+            +------+-----+\n               |   \
    \         |            |            |\n               V            V         \
    \   V            V\n           +--------+   +--------+   +--------+   +--------+\n\
    \           | Device |   | Device |   | Device |   | Device |\n           +--------+\
    \   +--------+   +--------+   +--------+\n                  Figure 4: Delivering\
    \ an Emergency Alert\n   In order to verify alert signatures, recipients must\
    \ be provisioned\n   with the proper public keys for trusted alert authorities.\
    \  This\n   trust may be \"piece-wise\" along the path the alert takes.  For\n\
    \   example, the alert relays operated by networks might have a full set\n   of\
    \ certificates for all alert originators, while end devices may only\n   trust\
    \ their local alert relay.  Or, devices might require that a\n   device be signed\
    \ by an authorized originator and by its local\n   network's relay.\n   This scenario\
    \ creates a need for multiple signatures on alert\n   documents, so that an alert\
    \ can bear signatures from any or all of\n   the entities that processed it along\
    \ the path.  In order to minimize\n   complexity, these signatures should be \"\
    modular\" in the sense that a\n   new signature can be added without a need to\
    \ alter or recompute\n   previous signatures.\n"
- title: 5.7.  Web Cryptography
  contents:
  - "5.7.  Web Cryptography\n   The W3C Web Cryptography API defines a standard cryptographic\
    \ API for\n   the Web [WebCrypto].  If a browser exposes this API, then JavaScript\n\
    \   provided as part of a Web page can ask the browser to perform\n   cryptographic\
    \ operations, such as digest, MAC, encryption, or digital\n   signing.\n   One\
    \ of the key reasons to have the browser perform cryptographic\n   operations\
    \ is to avoid allowing JavaScript code to access the keying\n   material used\
    \ for these operations.  For example, this separation\n   would prevent code injected\
    \ through a cross-site scripting (XSS)\n   attack from reading and exfiltrating\
    \ keys stored within a browser.\n   While the malicious code could still use the\
    \ key while running in the\n   browser, this vulnerability can only be exercised\
    \ while the malicious\n   code is active in a user's browser.\n   However, the\
    \ Web Cryptography API also provides a key export\n   functionality, which can\
    \ allow JavaScript to extract a key from the\n   API in wrapped form.  For example,\
    \ JavaScript code might provide a\n   public key for which the corresponding private\
    \ key is held by another\n   device.  The wrapped key provided by the API could\
    \ then be used to\n   safely transport the key to the new device.  While this\
    \ could\n   potentially allow malicious code to export a key, the need for an\n\
    \   explicit export operation provides a control point, allowing for user\n  \
    \ notification or consent verification.\n   The Web Cryptography API also allows\
    \ browsers to impose limitations\n   on the usage of the keys it handles.  For\
    \ example, a symmetric key\n   might be marked as usable only for encryption,\
    \ and not for MAC.  When\n   a key is exported in wrapped form, these attributes\
    \ should be carried\n   along with it.\n   The Web Cryptography API thus requires\
    \ formats to express several\n   forms of keys.  Obviously, the public key from\
    \ an asymmetric key pair\n   can be freely imported to and exported from the browser,\
    \ so there\n   needs to be a format for public keys.  There is also a need for\
    \ a\n   format to express private keys and symmetric keys.  For non-public\n \
    \  keys, the primary need is for a wrapped form, where the\n   confidentiality\
    \ and integrity of the key is assured\n   cryptographically; these protections\
    \ should also apply to any\n   attributes of the key.  It may also be useful to\
    \ define a direct,\n   unwrapped format for use within a security boundary.\n"
- title: 5.8.  Constrained Devices
  contents:
  - "5.8.  Constrained Devices\n   This section describes use cases for constrained\
    \ devices as defined\n   in [CONSTRAINED].  Typical issues with this type of device\
    \ are\n   limited memory, limited power supply, low processing power, and\n  \
    \ severe message size limitations for the communication protocols.\n"
- title: '5.8.1.  Example: MAC Based on ECDH-Derived Key'
  contents:
  - "5.8.1.  Example: MAC Based on ECDH-Derived Key\n   Suppose a small, low power\
    \ device maker has decided on using the\n   output of the JOSE working group as\
    \ their encryption and\n   authentication framework.  The device maker has a limited\
    \ budget for\n   both gates and power.  For this reason there are a number of\
    \ short\n   cuts and design decisions that have been made in order to minimize\n\
    \   these needs.\n   The design team has determined that the use of MACs is going\
    \ to be\n   sufficient to provide the necessary authentication.  However,\n  \
    \ although a MAC is going to be used, they do not want to use a single\n   long-term\
    \ shared secret.  Instead, they have adopted the following\n   proposal for computing\
    \ a shared secret that can be validated:\n   o  An Elliptic-Curve Diffie-Hellman\
    \ (ECDH) key pair is generated for\n      the device at the time of manufacturing.\
    \  (Or, as part of the\n      configuration process during installation.)\n  \
    \ o  An ECDH public key for the controller is configured at the time of\n    \
    \  configuration.\n   o  The configuration system performs the ECDH computation\
    \ and\n      configures the device with the resulting shared secret.  This\n \
    \     process eliminates the need for the device to be able to perform\n     \
    \ the required ECDH processing.  The security requirements on\n      protecting\
    \ this computed shared secret are the same as the\n      requirements on protecting\
    \ the private ECDH key.\n   o  A counter and an increment value are configured\
    \ onto the device.\n   o  When a message is to be sent by the device, the counter\
    \ is\n      incremented and a new MAC key is computed from the ECDH secret and\n\
    \      the counter value.  A custom Key Derivation Function (KDF) based\n    \
    \  on AES-CBC is used to derive the required MAC key.  The MAC key is\n      then\
    \ used to compute the MAC value for the message.\n   In a similar manner, the\
    \ KDF function can be used to compute an\n   Authenticated Encryption with Associated\
    \ Data (AEAD) algorithm key\n   when the system needs to provide confidentiality\
    \ for the message.\n   The controller, being a larger device, will perform the\
    \ ECDH step and\n   use a random number generator to generate the sender nonce\
    \ value.\n"
- title: 5.8.2.  Object Security for CoAP
  contents:
  - "5.8.2.  Object Security for CoAP\n   This use case deals with constrained devices\
    \ of class C0/C1 (see\n   [CONSTRAINED]).  These devices communicate using RESTful\
    \ requests and\n   responses transferred using the Constrained Application Protocol\n\
    \   [CoAP].  To simplify matters, all communication is assumed to be\n   unicast;\
    \ i.e., these security measures don't cover multicast or\n   broadcast.\n   In\
    \ this type of setting, it may be too costly to use session-based\n   security\
    \ (e.g., to run a 4-pass authentication protocol) since\n   receiving and in particular\
    \ sending consumes a lot of power,\n   especially for wireless devices.  Therefore,\
    \ to just secure the CoAP\n   payload by replacing a plaintext payload of a request\
    \ or response\n   with a JWE object is an important alternative solution, which\
    \ allows\n   a trade-off between protection (the CoAP headers are not protected)\n\
    \   and performance.\n   In a simple setting, consider the payload of a CoAP GET\
    \ response from\n   a sensor type device.  The information in a sensor reading\
    \ may be\n   privacy or business sensitive and needs both integrity protection\
    \ and\n   encryption.\n   However, some sensor readings are very short, say, a\
    \ few bytes, and\n   in this case, default encryption and integrity protection\
    \ algorithms\n   (such as 128-bit AES-CBC with HMAC_SHA256) may cause a dramatic\n\
    \   expansion of the payload, even disregarding JWE headers.\n   Also, the value\
    \ of certain sensor readings may decline rapidly, e.g.,\n   traffic or environmental\
    \ measurements, so it must be possible to\n   reduce the security overhead.\n\
    \   This leads to the following requirements that could be covered by\n   specific\
    \ JWE/JWS profiles:\n   o  The size of the secure object shall be as small as\
    \ possible.\n      Receiving an object may cost orders of magnitude more in terms\
    \ of\n      power than performing, say, public key cryptography on the object,\n\
    \      in particular in a wireless setting.\n   o  Integrity protection: The object\
    \ shall be able to support\n      integrity protection, i.e., have a field containing\
    \ a digital\n      signature, both public key signatures and keyed MACs shall\
    \ be\n      supported.\n   o  Encryption: The object shall be able to support\
    \ encryption as an\n      optional addition to integrity protection.  It shall\
    \ be possible\n      to exclude certain fields from encryption, which are needed\
    \ before\n      verifying integrity or decrypting the object.\n   o  Cipher suites:\
    \ It should be possible to support a variety of\n      cipher suites to support\
    \ the constrained devices' use cases.  For\n      example:\n      *  Block ciphers\
    \ with block sizes of, e.g., 96 bits, in addition\n         to the standard 128\
    \ bits.\n      *  Modes of operation for block ciphers that do not expand the\n\
    \         message size to a block boundary, such as AES-GCM.\n      *  Cipher\
    \ suites that support combined encryption and MAC\n         calculation (i.e.,\
    \ AEAD modes for block ciphers).\n"
- title: 6.  Requirements
  contents:
  - "6.  Requirements\n   This section summarizes the requirements from the above\
    \ use cases and\n   lists further requirements not directly derived from the above\
    \ use\n   cases.  There are also some constraints that are not hard\n   requirements\
    \ but that are still desirable properties for the JOSE\n   system to have.\n"
- title: 6.1.  Functional Requirements
  contents:
  - "6.1.  Functional Requirements\n   F1 Define formats for secure objects that provide\
    \ the following\n      security properties:\n      *  Digital signature (integrity/authentication\
    \ under an asymmetric\n         key pair)\n      *  Message authentication (integrity/authentication\
    \ under a\n         symmetric key)\n      *  Authenticated encryption\n   F2 Define\
    \ a format for public keys and private keys for asymmetric\n      cryptographic\
    \ algorithms, with associated attributes, including a\n      wrapped form for\
    \ private keys.\n   F3 Define a format for symmetric keys with associated attributes,\n\
    \      allowing for both wrapped and unwrapped keys.\n   F4 Define a JSON serialization\
    \ for each of the above objects.  An\n      object in this encoding must be valid\
    \ according to the JSON ABNF\n      syntax [RFC7159].\n   F5 Define a compact,\
    \ URL-safe text serialization for the encrypted\n      and signed object formats.\n\
    \   F6 Allow for attributes associated to wrapped keys to be bound to\n      them\
    \ cryptographically.\n   F7 Allow for wrapped keys to be separated from a secure\
    \ object that\n      uses a symmetric key.  In such cases, cryptographic components\
    \ of\n      the secure object other than the wrapped key (e.g., ciphertext,\n\
    \      MAC values) must be independent of the wrapped form of the key.\n     \
    \ For example, if an encrypted object is prepared for multiple\n      recipients,\
    \ then only the wrapped key may vary, not the\n      ciphertext.\n   F8 Do not\
    \ impose more overhead than is required to meet the\n      requirements in this\
    \ document, especially when a large amount of\n      application content is being\
    \ protected.\n"
- title: 6.2.  Security Requirements
  contents:
  - "6.2.  Security Requirements\n   S1 Provide mechanisms to avoid repeated use of\
    \ the same symmetric key\n      for encryption or MAC computation.  Instead, long-lived\
    \ keys\n      should be used only for key wrapping, not for direct encryption/\n\
    \      MAC.  It should be possible to use any of the key management\n      techniques\
    \ provided in CMS [RFC5652]:\n      *  Key transport (wrapping for a public key)\n\
    \      *  Key encipherment (wrapping for a symmetric key)\n      *  Key agreement\
    \ (wrapping for a Diffie-Hellman (DH) public key)\n      *  Password-based encryption\
    \ (wrapping under a key derived from a\n         password)\n   S2 Where long-lived\
    \ symmetric keys are used directly for\n      cryptographic operations (i.e.,\
    \ where requirement S1 is not met),\n      provide deployment guidance on key\
    \ management practices, such as\n      the need to limit key lifetimes.\n   S3\
    \ Use cryptographic algorithms in a manner compatible with major\n      validation\
    \ processes.  For example, if typical validation\n      standards allow algorithm\
    \ A to be used for purpose X but not\n      purpose Y, then JOSE should not recommend\
    \ using algorithm A for\n      purpose Y.\n   S4 Support operation with or without\
    \ pre-negotiation.  It must be\n      possible to create or process secure objects\
    \ without any\n      configuration beyond key provisioning.  If it is possible\
    \ for keys\n      to be derived from application context, it must be possible\
    \ for a\n      recipient to recognize when it does not have the appropriate key.\n"
- title: 6.3.  Desiderata
  contents:
  - "6.3.  Desiderata\n   D1 Maximize compatibility with the W3C Web Crypto specifications,\n\
    \      e.g., by coordinating with the Web Crypto working group to\n      encourage\
    \ alignment of algorithms and algorithm identifiers.\n   D2 Avoid JSON canonicalization\
    \ to the extent possible.  That is, all\n      other things being equal, techniques\
    \ that rely on fixing a\n      serialization of an object (e.g., by encoding it\
    \ with base64url)\n      are preferred over those that require converting an object\
    \ to a\n      canonical form.\n   D3 Maximize the extent to which the inputs and\
    \ outputs of JOSE\n      cryptographic operations can be controlled by the applications,\
    \ as\n      opposed to involving processing specific to JOSE.  This allows\n \
    \     JOSE the flexibility to address the needs of many cryptographic\n      protocols.\
    \  For example, in some cases, it might allow JOSE\n      objects to be translated\
    \ to legacy formats such as CMS without the\n      need for re-encryption or re-signing.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The primary focus of this document is the requirements\
    \ for a JSON-\n   based secure object format.  At the level of general security\n\
    \   considerations for object-based security technologies, the security\n   considerations\
    \ for this format are the same as for CMS [RFC5652].\n   The primary difference\
    \ between the JOSE format and CMS is that JOSE\n   is based on JSON, which does\
    \ not have a canonical representation.\n   The lack of a canonical form means\
    \ that it is difficult to determine\n   whether two JSON objects represent the\
    \ same information, which could\n   lead to vulnerabilities in some usages of\
    \ JOSE.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC4949]  Shirey, R., \"Internet Security Glossary,\
    \ Version 2\", RFC\n              4949, August 2007.\n   [RFC5652]  Housley, R.,\
    \ \"Cryptographic Message Syntax (CMS)\", STD 70,\n              RFC 5652, September\
    \ 2009.\n   [RFC6120]  Saint-Andre, P., \"Extensible Messaging and Presence\n\
    \              Protocol (XMPP): Core\", RFC 6120, March 2011.\n   [RFC6708]  Kiesel,\
    \ S., Previdi, S., Stiemerling, M., Woundy, R., and\n              Y. Yang, \"\
    Application-Layer Traffic Optimization (ALTO)\n              Requirements\", RFC\
    \ 6708, September 2012.\n   [RFC6749]  Hardt, D., \"The OAuth 2.0 Authorization\
    \ Framework\", RFC\n              6749, October 2012.\n   [RFC7159]  Bray, T.,\
    \ \"The JavaScript Object Notation (JSON) Data\n              Interchange Format\"\
    , RFC 7159, March 2014.\n   [W3C.REC-xml]\n              Bray, T., Maler, E.,\
    \ Paoli, J., and C. Sperberg-McQueen,\n              \"Extensible Markup Language\
    \ (XML) 1.0 (Fifth Edition)\",\n              W3C Recommendation, November 2008,\n\
    \              <http://www.w3.org/TR/2008/REC-xml-20081126/>.\n   [WebCrypto]\n\
    \              Dahl, D. and R. Sleevi, \"Web Cryptography API\", W3C\n       \
    \       Working Draft, January 2013,\n              <http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [ALERT-REQ]\n              Schulzrinne, H.,\
    \ Norreys, S., Rosen, B., and H.\n              Tschofenig, \"Requirements, Terminology\
    \ and Framework for\n              Exigent Communications\", Work in Progress,\
    \ March 2012.\n   [ALTO]     Alimi, R., Ed., Penno, R., Ed., and Y. Yang, Ed.,\
    \ \"ALTO\n              Protocol\", Work in Progress, March 2014.\n   [CAP]  \
    \    Botterell, A. and E. Jones, \"Common Alerting Protocol,\n              v1.1\"\
    , OASIS Standard CAP-V1.1, October 2005,\n              <http://www.oasis-open.org/committees/download.php/15135/\n\
    \              emergency-CAPv1.1-Corrected_DOM.pdf>.\n   [CONSTRAINED]\n     \
    \         Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n        \
    \      Constrained Node Networks\", Work in Progress, March 2014.\n   [CoAP] \
    \    Shelby, Z., Hartke, K., and C. Bormann, \"Constrained\n              Application\
    \ Protocol (CoAP)\", Work in Progress, June 2013.\n   [ITU.X690.2002]\n      \
    \        International Telecommunications Union, \"Information\n             \
    \ Technology - ASN.1 encoding rules: Specification of Basic\n              Encoding\
    \ Rules (BER), Canonical Encoding Rules (CER) and\n              Distinguished\
    \ Encoding Rules (DER)\", ITU-T Recommendation\n              X.690, July 2002.\n\
    \   [JWA]      Jones, M., \"JSON Web Algorithms (JWA)\", Work in Progress,\n \
    \             March 2014.\n   [JWE]      Jones, M. and J. Hildebrand, \"JSON Web\
    \ Encryption (JWE)\",\n              Work in Progress, March 2014.\n   [JWK] \
    \     Jones, M., \"JSON Web Key (JWK)\", Work in Progress, March\n           \
    \   2014.\n   [JWS]      Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n\
    \              Signature (JWS)\", Work in Progress, March 2014.\n   [JWT-BEARER]\n\
    \              Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token\n \
    \             (JWT) Profile for OAuth 2.0 Client Authentication and\n        \
    \      Authorization Grants\", Work in Progress, March 2014.\n   [JWT]      Jones,\
    \ M., Bradley, J., and N. Sakimura, \"JSON Web Token\n              (JWT)\", Work\
    \ in Progress, March 2014.\n   [OASIS.saml-core-2.0-os]\n              Cantor,\
    \ S., Kemp, J., Maler, E., and R. Philpott,\n              \"Assertions and Protocols\
    \ for the OASIS Security Assertion\n              Markup Language (SAML) V2.0\"\
    , Oasis Standard, March 2005,\n              <http://docs.oasis-open.org/security/saml/v2.0/\n\
    \              saml-core-2.0-os.pdf>.\n   [OpenID.Core]\n              Bradley,\
    \ J., de Medeiros, B., Jones, M., Mortimore, C.,\n              and N. Sakimura,\
    \ \"OpenID Connect Core 1.0\", December 2013,\n              <http://openid.net/specs/openid-connect-core-1_0.html>.\n\
    \   [Persona]  Mozilla Developer Network, \"Mozilla Persona\", April 2013,\n \
    \             <https://developer.mozilla.org/en-US/docs/Persona>.\n   [RFC2616]\
    \  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter,\
    \ L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol\
    \ -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC2818]  Rescorla, E., \"HTTP Over\
    \ TLS\", RFC 2818, May 2000.\n   [RFC3207]  Hoffman, P., \"SMTP Service Extension\
    \ for Secure SMTP over\n              Transport Layer Security\", RFC 3207, February\
    \ 2002.\n   [RFC3923]  Saint-Andre, P., \"End-to-End Signing and Object Encryption\n\
    \              for the Extensible Messaging and Presence Protocol\n          \
    \    (XMPP)\", RFC 3923, October 2004.\n   [RFC4301]  Kent, S. and K. Seo, \"\
    Security Architecture for the\n              Internet Protocol\", RFC 4301, December\
    \ 2005.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n\
    \              Encodings\", RFC 4648, October 2006.\n   [RFC5246]  Dierks, T.\
    \ and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol\
    \ Version 1.2\", RFC 5246, August 2008.\n   [RFC5322]  Resnick, P., Ed., \"Internet\
    \ Message Format\", RFC 5322,\n              October 2008.\n   [RFC5751]  Ramsdell,\
    \ B. and S. Turner, \"Secure/Multipurpose Internet\n              Mail Extensions\
    \ (S/MIME) Version 3.2 Message\n              Specification\", RFC 5751, January\
    \ 2010.\n   [RFC6750]  Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\n\
    \              Framework: Bearer Token Usage\", RFC 6750, October 2012.\n   [SAML2]\
    \    Campbell, B., Mortimore, C., and M. Jones, \"SAML 2.0\n              Profile\
    \ for OAuth 2.0 Client Authentication and\n              Authorization Grants\"\
    , Work in Progress, March 2014.\n   [W3C.xmldsig-core]\n              Eastlake,\
    \ D., Reagle, J., and D. Solo, \"XML-Signature\n              Syntax and Processing\"\
    , W3C Recommendation, June 2008,\n              <http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/>.\n\
    \   [W3C.xmlenc-core]\n              Eastlake, D. and J. Reagle, \"XML Encryption\
    \ Syntax and\n              Processing\", W3C Candidate Recommendation, December\
    \ 2002,\n              <http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/>.\n\
    \   [WS-Federation]\n              Goodner, M., Kaler, C., McIntosh, M., and A.\
    \ Nadalin, \"Web\n              Services Federation Language (WS-Federation) Version\
    \ 1.2\",\n              Oasis Standard, May 2009, <http://docs.oasis-open.org/\n\
    \              wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html>.\n   [XMPP-E2E]\
    \ Miller, M., \"End-to-End Object Encryption and Signatures\n              for\
    \ the Extensible Messaging and Presence Protocol\n              (XMPP)\", Work\
    \ in Progress, June 2013.\n"
- title: Appendix A.  Acknowledgements
  contents:
  - "Appendix A.  Acknowledgements\n   Thanks to Matt Miller for discussions related\
    \ to the XMPP end-to-end\n   security model and to Mike Jones for considerations\
    \ related to\n   security tokens and XML security.  Thanks to Mark Watson for\
    \ raising\n   the need for representing symmetric keys and binding attributes\
    \ to\n   them.  Thanks to Ludwig Seitz for contributing the constrained device\n\
    \   use case.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Richard Barnes\n   Mozilla\n   331 E. Evelyn Ave.\n   Mountain\
    \ View, CA  94041\n   US\n   EMail: rlb@ipv.sx\n"
