- title: __initial_text__
  contents:
  - '                      An API for Service Location

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Service Location Protocol (SLP) provides a new way for clients\
    \ to\n   dynamically discovery network services.  With SLP, it is simple to\n\
    \   offer highly available services that require no user configuration or\n  \
    \ assistance from network administrators prior to use.  This document\n   describes\
    \ standardized APIs for SLP in C and Java.  The APIs are\n   modular and are designed\
    \ to allow implementations to offer just the\n   feature set needed.  In addition,\
    \ standardized file formats for\n   configuration and serialized registrations\
    \ are defined, allowing SLP\n   agents to set network and other parameters in\
    \ a portable way.  The\n   serialized file format allows legacy services to be\
    \ registered with\n   SLP directory agents in cases where modifying the legacy\
    \ service\n   program code is difficult or impossible, and to portably exchange\
    \ a\n   registration database.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1. Introduction                                      \
    \              4\n        1.1. Goals  . . . . . . . . . . . . . . . . . . . .\
    \ . . . .    4\n        1.2. Terminology  . . . . . . . . . . . . . . . . . .\
    \ . . .    4\n    2. File Formats                                            \
    \        7\n        2.1. Configuration File Format  . . . . . . . . . . . . .\
    \ .    8\n              2.1.1. DA configuration   . . . . . . . . . . . . . .\
    \    9\n              2.1.2. Static Scope Configuration . . . . . . . . . .  \
    \  9\n              2.1.3. Tracing and Logging  . . . . . . . . . . . . .   11\n\
    \              2.1.4. Serialized Proxy Registrations . . . . . . . .   11\n  \
    \            2.1.5. Network Configuration Properties . . . . . . .   12\n    \
    \          2.1.6. SA Configuration . . . . . . . . . . . . . . .   14\n      \
    \        2.1.7. UA Configuration . . . . . . . . . . . . . . .   14\n        \
    \      2.1.8. Security   . . . . . . . . . . . . . . . . . .   15\n        2.2.\
    \ Multihomed Machines. . . . . . . . . . . . . . . . . .   16\n        2.3. Serialized\
    \ Registration File . . . . . . . . . . . . .   16\n        2.4. Processing Serialized\
    \ Registration and Configuration\n             Files  . . . . . . . . . . . .\
    \ . . . . . . . . . . . .   18\n    3. Binding Independent Implementation Considerations\
    \              18\n        3.1. Multithreading . . . . . . . . . . . . . . . .\
    \ . . . .   18\n        3.2. Asynchronous and Incremental . . . . . . . . . .\
    \ . . .   19\n        3.3. Type Checking for Service Types. . . . . . . . . .\
    \ . .   19\n        3.4. Refreshing Registrations . . . . . . . . . . . . . .\
    \ .   19\n        3.5. Configuration File Processing  . . . . . . . . . . . .\
    \   19\n        3.6. Attribute Types  . . . . . . . . . . . . . . . . . . .  \
    \ 20\n        3.7. Removal of Duplicates  . . . . . . . . . . . . . . . .   20\n\
    \        3.8. Character Set Encoding . . . . . . . . . . . . . . . .   20\n  \
    \      3.9. Error Semantics  . . . . . . . . . . . . . . . . . . .   20\n    \
    \   3.10. Modular Implementations  . . . . . . . . . . . . . . .   24\n      \
    \ 3.11. Handling Special Service Types . . . . . . . . . . . .   24\n       3.12.\
    \ Scope Discovery and Handling . . . . . . . . . . . . .   24\n    4. C Language\
    \ Binding                                             25\n        4.1. Constant\
    \ Types . . . . . . . . . . . . . . . . . . . .   26\n              4.1.1. URL\
    \ Lifetimes. . . . . . . . . . . . . . . . .   26\n              4.1.2. Error\
    \ Codes. . . . . . . . . . . . . . . . . .   26\n              4.1.3. SLPBoolean\
    \ . . . . . . . . . . . . . . . . . .   27\n        4.2. Struct Types   . . .\
    \ . . . . . . . . . . . . . . . . .   28\n              4.2.1. SLPSrvURL  . .\
    \ . . . . . . . . . . . . . . . .   28\n              4.2.2. SLPHandle  . . .\
    \ . . . . . . . . . . . . . . .   29\n        4.3. Callbacks  . . . . . . . .\
    \ . . . . . . . . . . . . . .   29\n              4.3.1. SLPRegReport   . . .\
    \ . . . . . . . . . . . . .   30\n              4.3.2. SLPSrvTypeCallback . .\
    \ . . . . . . . . . . . .   30\n              4.3.3. SLPSrvURLCallback  . . .\
    \ . . . . . . . . . . .   31\n              4.3.4. SLPAttrCallback  . . . . .\
    \ . . . . . . . . . .   33\n        4.4. Opening and Closing an SLPHandle . .\
    \ . . . . . . . . .   34\n              4.4.1. SLPOpen. . . . . . . . . . . .\
    \ . . . . . . . .   34\n              4.4.2. SLPClose . . . . . . . . . . . .\
    \ . . . . . . .   35\n        4.5. Protocol API   . . . . . . . . . . . . . .\
    \ . . . . . .   36\n              4.5.1. SLPReg . . . . . . . . . . . . . . .\
    \ . . . . .   36\n              4.5.2. SLPDereg . . . . . . . . . . . . . . .\
    \ . . . .   37\n              4.5.3. SLPDelAttrs  . . . . . . . . . . . . . .\
    \ . . .   38\n              4.5.4. SLPFindSrvTypes. . . . . . . . . . . . . .\
    \ . .   39\n              4.5.5. SLPFindSrvs  . . . . . . . . . . . . . . . .\
    \ .   41\n              4.5.6. SLPFindAttrs . . . . . . . . . . . . . . . . .\
    \   42\n        4.6. Miscellaneous Functions  . . . . . . . . . . . . . . .  \
    \ 43\n              4.6.1. SLPGetRefreshInterval  . . . . . . . . . . . .   44\n\
    \              4.6.2. SLPFindScopes  . . . . . . . . . . . . . . . .   44\n  \
    \            4.6.3. SLPParseSrvURL . . . . . . . . . . . . . . . .   45\n    \
    \          4.6.4. SLPEscape  . . . . . . . . . . . . . . . . . .   46\n      \
    \        4.6.5. SLPUnescape  . . . . . . . . . . . . . . . . .   47\n        \
    \      4.6.6. SLPFree  . . . . . . . . . . . . . . . . . . .   48\n          \
    \    4.6.7. SLPGetProperty . . . . . . . . . . . . . . . .   48\n            \
    \  4.6.8. SLPSetProperty . . . . . . . . . . . . . . . .   49\n        4.7. Implementation\
    \ Notes   . . . . . . . . . . . . . . . .   49\n              4.7.1. Refreshing\
    \ Registrations . . . . . . . . . . .   49\n              4.7.2. Syntax for String\
    \ Parameters . . . . . . . . .   49\n              4.7.3. Client Side Syntax Checking\
    \  . . . . . . . . .   50\n              4.7.4. System Properties  . . . . . .\
    \ . . . . . . . .   50\n              4.7.5. Memory Management  . . . . . . .\
    \ . . . . . . .   51\n              4.7.6. Asynchronous and Incremental Return\
    \ Semantics.   51\n        4.8. Example. . . . . . . . . . . . . . . . . . . .\
    \ . . . .   52\n    5. Java Language Binding                                 \
    \         56\n        5.1. Introduction . . . . . . . . . . . . . . . . . . .\
    \ . .   56\n        5.2. Exceptions and Errors  . . . . . . . . . . . . . . .\
    \ .   56\n              5.2.1. Class ServiceLocationException . . . . . . . .\
    \   57\n        5.3. Basic Data Structures  . . . . . . . . . . . . . . . .  \
    \ 58\n              5.3.1. Interface ServiceLocationEnumeration . . . . .   58\n\
    \              5.3.2. Class ServiceLocationAttribute   . . . . . . .   58\n  \
    \            5.3.3. Class ServiceType  . . . . . . . . . . . . . .   61\n    \
    \          5.3.4. Class ServiceURL   . . . . . . . . . . . . . .   63\n      \
    \  5.4. SLP Access Interfaces  . . . . . . . . . . . . . . . .   67\n        \
    \      5.4.1. Interface Advertiser . . . . . . . . . . . . .   67\n          \
    \    5.4.2. Interface Locator  . . . . . . . . . . . . . .   69\n        5.5.\
    \ The Service Location Manager . . . . . . . . . . . . .   72\n              5.5.1.\
    \ Class ServiceLocationManager . . . . . . . . .   72\n        5.6. Service Template\
    \ Introspection . . . . . . . . . . . .   74\n              5.6.1. Abstract Class\
    \ TemplateRegistry  . . . . . . .   74\n              5.6.2. Interface ServiceLocationAttributeVerifier\
    \ . .   77\n              5.6.3. Interface ServiceLocationAttributeDescriptor\
    \ .   79\n        5.7. Implementation Notes . . . . . . . . . . . . . . . . .\
    \   81\n              5.7.1. Refreshing Registrations . . . . . . . . . . .  \
    \ 81\n              5.7.2. Parsing Alternate Transports in ServiceURL . .   81\n\
    \              5.7.3. String Attribute Values  . . . . . . . . . . .   82\n  \
    \            5.7.4. Client Side Syntax Checking. . . . . . . . . .   82\n    \
    \          5.7.5. Language Locale Handling . . . . . . . . . . .   82\n      \
    \        5.7.6. Setting SLP System Properties. . . . . . . . .   83\n        \
    \      5.7.7. Multithreading . . . . . . . . . . . . . . . .   83\n          \
    \    5.7.8. Modular Implementations  . . . . . . . . . . .   83\n            \
    \  5.7.9. Asynchronous and Incremental Return Semantics.   84\n        5.8. Example.\
    \ . . . . . . . . . . . . . . . . . . . . . . .   85\n    6. Internationalization\
    \ Considerations                            87\n        6.1. service URL. . .\
    \ . . . . . . . . . . . . . . . . . . .   87\n        6.2. Character Set Encoding\
    \ . . . . . . . . . . . . . . . .   87\n        6.3. Language Tagging   . . .\
    \ . . . . . . . . . . . . . . .   88\n    7. Security Considerations         \
    \                               88\n    8. Acknowledgements                  \
    \                             88\n    9. References                          \
    \                           89\n   10. Authors' Addresses                    \
    \                         90\n   11. Full Copyright Statement                \
    \                       91\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The Service Location API is designed for standardized access\
    \ to the\n   Service Location Protocol (SLP). The APIs allow client and service\n\
    \   programs to be be written or modified in a very simple manner to\n   provide\
    \ dynamic service discovery and selection.  Bindings in the C\n   and Java languages\
    \ are defined in this document.  In addition,\n   standardized formats for configuration\
    \ files and for serialized\n   registration files are presented.  These files\
    \ allow SLP agents to\n   configure network parameters, to register legacy services\
    \ that have\n   not been SLP enabled, and to portably exchange registration\n\
    \   databases.\n"
- title: 1.1. Goals
  contents:
  - "1.1. Goals\n   The overall goal of the API is to enable source portability of\n\
    \   applications that use the API between different implementations of\n   SLP.\
    \ The result should facilitate the adoption of SLP, and conversion\n   of clients\
    \ and service programs to SLP.\n   The goals of the C binding are to create a\
    \ minimal but complete\n   access to the functionality of the SLP protocol, allowing\
    \ for simple\n   memory management and limited code size.\n   The Java API provides\
    \ for modular implementations (where unneeded\n   features can be omitted) and\
    \ an object oriented interface to the\n   complete set of SLP data and functionality.\n\
    \   The standardized configuration file and serialized file formats\n   provide\
    \ a simple syntax with complete functional coverage of the\n   protocol, but without\
    \ system dependent properties and secure\n   information.\n"
- title: 1.2. Terminology
  contents:
  - "1.2. Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119  [1].\n      Service Location Protocol (SLP)\n         The underlying protocol\
    \ allowing dynamic and scalable service\n         discovery.  This protocol is\
    \ specified in the Service Location\n         Protocol Version 2 [7].\n      SLP\
    \ framework\n         When a 'Service Location framework' is mentioned, it refers\
    \ to\n         both the SLP implementation and interface implementation; i.e.\n\
    \         whatever provides the SLP functionality to user level programs.\n  \
    \       This includes remote agents.\n      Directory Agent (DA)\n         A service\
    \ that automatically gathers service advertisements\n         from SAs in order\
    \ to provide them to UAs.\n      User Agent (UA)\n         This is the Service\
    \ Location process or library that allows SLP\n         requests to be made on\
    \ behalf of a client process.  UAs\n         automatically direct requests to\
    \ DAs when they exist.  In their\n         absence, UAs make requests to SAs.\n\
    \      Service Agent (SA)\n         This is the Service Location process or library\
    \ that allows\n         service software to register and deregister itself with\
    \ the SLP\n         framework.  SAs respond to UA service requests, detect DAs\
    \ and\n         register service advertisements with them.\n      SA Server\n\
    \         Many operating system platforms only allow a single process to\n   \
    \      listen on a particular port number.  Since SAs are required to\n      \
    \   listen on a multicast address for SLP service requests,\n         implementations\
    \ of the SLP framework on such platforms that\n         want to support multiple\
    \ SAs on one machine need to arrange for\n         a single process to do the\
    \ listening while the advertising SAs\n         communicate with that process\
    \ through another mechanism.  The\n         single listening process is called\
    \ an SA server.  SA servers\n         share many characteristics with DAs, but\
    \ they are not the same.\n      Service Advertisement\n         A URL possibly\
    \ combined with service attributes.  These are\n         made available to UAs\
    \ by SAs, either directly or via a DA.\n      Locale\n         The language localization\
    \ that applies to strings passed into\n         or returned from the SLP API.\
    \ The Locale is expressed using a\n         Language Tag [6].  All attribute strings\
    \ are associated with a\n         particular locale.  The locale is completely\
    \ orthogonal to the\n         ANSI C locale.  The SLP locale is mapped into the\
    \ Java locale\n         in the Java API.\n      Service Template\n         A document\
    \ that describes the syntax of the URL for a given\n         service type and\
    \ a definition of all service attributes\n         including the meaning, defaults,\
    \ and constraints on values the\n         attributes may take.  See [8] for more\
    \ information on service\n         templates.\n      The service:  URL\n     \
    \    A service of a particular type announces its availability with\n        \
    \ a service:  URL that includes its service access point (domain\n         name\
    \ or IP address, and possibly its port number) and\n         optionally basic\
    \ configuration parameters.  The syntax of the\n         service:  URL is defined\
    \ in the service template.  Other URL's\n         can be used in service advertisements\
    \ if desired.\n      Service Attributes\n         The attributes associated with\
    \ a given service.  The values\n         that can be assigned to service attributes\
    \ are defined by the\n         service template.\n      Scope\n         A string\
    \ used to control the availability of service\n         advertisements.  Every\
    \ SLP Agent is configured with one or more\n         scope strings.  Scopes are\
    \ assigned by site administrators to\n         group services for many purposes,\
    \ but chiefly as a means of\n         scalability.  DAs store only services advertised\
    \ having a scope\n         string matching the scopes with which they are configured.\n\
    \      Naming Authority (NA)\n         This is a 'suffix' to the service type\
    \ string.  It completely\n         changes the meaning of the service type.  NAs\
    \ are used for\n         private definitions of well known Service Types and\n\
    \         experimental Service Type extensions.  The default NA is\n         \"\
    IANA\", which must not be explicitly included.  Service types\n         with the\
    \ IANA naming authority are registered with the Internet\n         Assigned Numbers\
    \ Authority (see [8] for more information on the\n         registration procedure).\n"
- title: 2. File Formats
  contents:
  - "2. File Formats\n   This section describes the configuration and serialized registration\n\
    \   file formats.  Both files are defined in the UTF-8 character set [3].\n  \
    \ Attribute tags and values in the serialized registration file require\n   SLP\
    \ reserved characters to be escaped.  The SLP reserved characters\n   are `(',\
    \ `)', `,', `\\', `!', `<', `=', `>', `~' and control\n   characters (characters\
    \ with UTF codes less than 0x0020 and the\n   character 0x007f, which is US-ASCII\
    \ DEL). The escapes are formed\n   exactly as for the wire protocol, i.e.  a backslash\
    \ followed by two\n   hex digits representing the character.  For example, the\
    \ escape for '\n   ,' is '\\2c'.  In addition, the characters `\\n', `\\r', `\\\
    t', and `_'\n   are prohibited from attribute tags by the SLP wire syntax grammar.\n\
    \   [7]\n   In serialized registration files, escaped strings beginning with\n\
    \   `\\ff`, an encoding for a nonUTF-8 character, are treated as opaques.\n  \
    \ Exactly as in the wire protocol, syntactically correct opaque\n   encodings\
    \ consist of a string beginning with `\\ff` and containing\n   *only* escaped\
    \ characters that are transformed to bytes.  Such\n   strings are only syntactically\
    \ correct in the serialized registration\n   file as attribute values.  In other\
    \ cases, whenever an escape is\n   encountered and the character is not an SLP\
    \ reserved character, an\n   error is signaled.\n   Escaped characters in URLs\
    \ in serialized registration files use the\n   URL escape convention. [2].\n \
    \  Property names and values in the configuration file have a few\n   reserved\
    \ characters that are involved in file's lexical definition.\n   The characters\
    \ '.'  and '=' are reserved in property names and must\n   be escape.  The characters\
    \ ',', '(', and ')' are reserved in property\n   values and must be escaped. \
    \ In addition, scope names in the\n   net.slp.useScopes property use the SLP wire\
    \ format escape convention\n   for SLP reserved characters.  This simplifies implementation,\
    \ since\n   the same code can be used to unescape scope names as is used in\n\
    \   processing the serialized registration file or for formatting wire\n   messages.\n\
    \   On platforms that only support US-ASCII and not UTF-8, the upper bit\n   of\
    \ bytes incoming from the configuration and registration files\n   determines\
    \ whether the character is US-ASCII or not US-ASCII.\n   According to the standard\
    \ UTF-8 encoding, the upper bit is zero if\n   the character is US-ASCII and one\
    \ if the character is multibyte and\n   thus not US-ASCII. Platforms without intrinsic\
    \ UTF-8 support are\n   required to parse the multibyte character and store it\
    \ in an\n   appropriate internal format.  Support for UTF-8 is required to\n \
    \  implement the SLP protocol (see [7]), and can therefore be used in\n   file\
    \ processing as well.\n   The location and name of the configuration file is system-dependent,\n\
    \   but implementations of the API are encouraged to locate it together\n   with\
    \ other configuration files and name it consistently.\n"
- title: 2.1. Configuration File Format
  contents:
  - "2.1. Configuration File Format\n   The configuration file format consists of\
    \ a newline delimited list of\n   zero or more property definitions.  Each property\
    \ definition\n   corresponds to a particular configurable SLP, network, or other\n\
    \   parameter in one or more of the three SLP agents.  The file format\n   grammar\
    \ in ABNF [5] syntax is:\n      config-file   =  line-list\n      line-list  \
    \   =  line / line line-list\n      line          =  property-line / comment-line\n\
    \      comment-line  =  ( \"#\" / \";\" ) 1*allchar newline\n      property-line\
    \ =  property newline\n      property      =  tag \"=\" value-list\n      tag\
    \           =  prop / prop \".\" tag\n      prop          =  1*tagchar\n     \
    \ value-list    =  value / value \",\" value-list\n      value         =  int\
    \ / bool /\n                       \"(\" value-list \")\" / string\n      int\
    \           =  1*DIGIT\n      bool          =  \"true\" / \"false\" / \"TRUE\"\
    \ / \"FALSE\"\n      newline       =  CR / ( CRLF )\n      string        =  1*stringchar\n\
    \      tagchar       =  DIGIT / ALPHA / tother / escape\n      tother        =\
    \  %x21-%x2d / %x2f /\n                       %x3a / %x3c-%x40 /\n           \
    \            %x5b-%x60 / %7b-%7e\n                       ; i.e., all characters\
    \ except `.',\n                       ; and `='.\n      stringchar    =  DIGIT\
    \ / ALPHA / sother / escape\n      sother        =  %x21-%x29 / %x2a-%x2b /\n\
    \                       %x2d-%x2f / %x3a-%x40 /\n                       %x5b-%x60\
    \ / %7b-%7e\n                       ; i.e., all characters except `,'\n      allchar\
    \       =  DIGIT / ALPHA / HTAB / SP\n      escape        =  \"\\\" HEXDIG HEXDIG\n\
    \                       ; Used for reserved characters\n   With the exception\
    \ of net.slp.useScopes, net.slp.DAAddresses, and\n   net.slp.isBroadcastOnly,\
    \ all other properties can be changed through\n   property accessors in the C\
    \ and Java APIs.  The property accessors\n   only change the property values in\
    \ the running agent program and do\n   not affect the values in the configuration\
    \ file.  The\n   net.slp.useScopes and net.slp.DAAddresses properties are read-only\n\
    \   because they control the agent's view of the scopes and DAs and are\n   therefore\
    \ critical to the function of the API scope discovery\n   algorithm.  Attempts\
    \ to modify them are unlikely to yield productive\n   results, and could harm\
    \ the ability of the agent to find scopes and\n   use DAs.  The net.slp.isBroadcastOnly\
    \ property is read-only because\n   the API library needs to configure networking\
    \ upon start up and\n   changing this property might invalidate the configuration.\
    \  Whether\n   the local network uses broadcast or multicast is not likely to\
    \ change\n   during the course of the program's execution.\n   The properties\
    \ break down into the following subsections describes an\n   area and its properties.\n"
- title: 2.1.1. DA configuration
  contents:
  - "2.1.1. DA configuration\n   Important configuration properties for DAs are included\
    \ in this\n   section.  These are:\n      net.slp.isDA\n         A boolean indicating\
    \ if the SLP server is to act as a DA. If\n         false, not run as a DA. Default\
    \ is false.\n      net.slp.DAHeartBeat\n         A 32 bit integer giving the number\
    \ of seconds for the\n         DA heartbeat.  Default is 3 hours (10800 seconds).\
    \  This\n         property corresponds to the protocol specification parameter\n\
    \         CONFIG_DA_BEAT [7].  Ignored if isDA is false.\n      net.slp.DAAttributes\n\
    \         A comma-separated list of parenthesized attribute/value list\n     \
    \    pairs that the DA must advertise in DAAdverts.  The property\n         must\
    \ be in the SLP attribute list wire format, including\n         escapes for reserved\
    \ characters. [7]\n"
- title: 2.1.2. Static Scope Configuration
  contents:
  - "2.1.2. Static Scope Configuration\n   These properties allow various aspects\
    \ of scope handling to be\n   configured.\n      net.slp.useScopes\n         A\
    \ value-list of strings indicating the only scopes a UA or SA\n         is allowed\
    \ to use when making requests or registering, or the\n         scopes a DA must\
    \ support.  If not present for the DA and SA,\n         then in the absence of\
    \ scope information from DHCP, the default\n         scope \"DEFAULT\" is used.\
    \  If not present for the UA, and there\n         is no scope information available\
    \ from DHCP, then the user\n         scoping model is in force.  Active and passive\
    \ DA discovery\n         or SA discovery are used for scope discovery, and the\
    \ scope\n         \"DEFAULT\" is used if no other information is available.  If\
    \ a\n         DA or SA gets another scope in a request, a SCOPE_NOT_SUPPORTED\n\
    \         error should be returned, unless the request was multicast, in\n   \
    \      which case it should be dropped.  If a DA gets another scope in\n     \
    \    a registration, a SCOPE_NOT_SUPPORTED error must be returned.\n         Unlike\
    \ other properties, this property is \"read-only\", so\n         attempts to change\
    \ it after the configuration file has been\n         read are ignored.  See Section\
    \ 3.12 for the algorithm the API\n         uses in determining what scope information\
    \ to present.\n      net.slp.DAAddresses\n         A value-list of IP addresses\
    \ or DNS resolvable host names\n         giving the SLPv2 DAs to use for statically\
    \ configured UAs and\n         SAs.  Ignored by DAs (unless the DA is also an\
    \ SA server).\n         Default is none.  Unlike other properties, this property\
    \ is\n         \"read-only\", so attempts to change it after the configuration\n\
    \         file has been read are ignored.\n         The following grammar describes\
    \ the property:\n               addr-list     =  addr / addr \",\" addr-list\n\
    \               addr          =  fqdn / hostnumber\n               fqdn      \
    \    =  ALPHA / ALPHA *[ anum / \"-\" ] anum\n               anum          = \
    \ ALPHA / DIGIT\n               hostnumber    =  1*3DIGIT 3(\".\" 1*3DIGIT)\n\
    \         An example is:\n                sawah,mandi,sambal\n         IP addresses\
    \ can be used instead of host names in networks\n         where DNS is not deployed,\
    \ but network administrators are\n         reminded that using IP addresses will\
    \ complicate machine\n         renumbering, since the SLP configuration property\
    \ files\n         in statically configured networks will have to be changed.\n\
    \         Similarly, if host names are used, implementors must be careful\n  \
    \       that a name service is available before SLP starts, in other\n       \
    \  words, SLP cannot be used to find the name service.\n"
- title: 2.1.3. Tracing and Logging
  contents:
  - "2.1.3. Tracing and Logging\n   This section allows tracing and logging information\
    \ to be printed by\n   the various agents.\n      net.slp.traceDATraffic\n   \
    \      A boolean controlling printing of messages about traffic with\n       \
    \  DAs.  Default is false.\n      net.slp.traceMsg\n         A boolean controlling\
    \ printing of details on SLP messages.\n         The fields in all incoming messages\
    \ and outgoing replies are\n         printed.  Default is false.\n      net.slp.traceDrop\n\
    \         A boolean controlling printing details when a SLP message is\n     \
    \    dropped for any reason.  Default is false.\n      net.slp.traceReg\n    \
    \     A boolean controlling dumps of all registered services upon\n         registration\
    \ and deregistration.  If true, the contents\n         of the DA or SA server\
    \ are dumped after a registration or\n         deregistration occurs.  Default\
    \ is false.\n"
- title: 2.1.4. Serialized Proxy Registrations
  contents:
  - "2.1.4. Serialized Proxy Registrations\n   These properties control the reading\
    \ and writing of serialized\n   registrations.\n      net.slp.serializedRegURL\n\
    \         A string containing a URL pointing to a document containing\n      \
    \   serialized registrations that should be processed when the DA\n         or\
    \ SA server starts up.  Default is none.\n"
- title: 2.1.5. Network Configuration Properties
  contents:
  - "2.1.5. Network Configuration Properties\n   The properties in this section allow\
    \ various network configuration\n   properties to be set.\n      net.slp.isBroadcastOnly\n\
    \         A boolean indicating if broadcast should be used instead of\n      \
    \   multicast.  Like the net.slp.useScopes and net.slp.DAAddresses\n         properties,\
    \ this property is \"read-only\", so attempts to change\n         it after the\
    \ configuration file has been read are ignored.\n         Default is false.\n\
    \      net.slp.passiveDADetection\n         A boolean indicating whether passive\
    \ DA detection should be\n         used.  Default is true.\n      net.slp.multicastTTL\n\
    \         A positive integer less than or equal to 255, giving the\n         multicast\
    \ TTL. Default is 255.\n      net.slp.DAActiveDiscoveryInterval\n         A 16\
    \ bit positive integer giving the number of seconds\n         between DA active\
    \ discovery queries.  Default is 900 seconds\n         (15 minutes).  This property\
    \ corresponds to the protocol\n         specification parameter CONFIG_DA_FIND\
    \ [7].  If the property is\n         set to zero, active discovery is turned off.\
    \  This is useful\n         when the DAs available are explicitly restricted to\
    \ those\n         obtained from DHCP or the net.slp.DAAddresses property.\n  \
    \    net.slp.multicastMaximumWait\n         A 32 bit integer giving the maximum\
    \ amount of time to perform\n         multicast, in milliseconds.  Default is\
    \ 15000 ms (15 sec.).\n         This property corresponds to the CONFIG_MC_MAX\
    \ parameter in the\n         protocol specification [7].\n      net.slp.multicastTimeouts\n\
    \         A value-list of 32 bit integers used as timeouts, in\n         milliseconds,\
    \ to implement the multicast convergence\n         algorithm.  Each value specifies\
    \ the time to wait before\n         sending the next request, or until nothing\
    \ new has\n         been learned from two successive requests.  Default\n    \
    \     is:  3000,3000,3000,3000,3000.  In a fast network the\n         aggressive\
    \ values of 1000,1250,1500,2000,4000 allow better\n         performance.  This\
    \ property corresponds to the CONFIG_MC_RETRY\n         parameter in the protocol\
    \ specification [7].  Note that the\n         net.slp.DADiscoveryTimeouts property\
    \ must be used for active DA\n         discovery.\n      net.slp.DADiscoveryTimeouts\n\
    \         A value-list of 32 bit integers used as timeouts, in\n         milliseconds,\
    \ to implement the multicast convergence algorithm\n         during active DA\
    \ discovery.  Each value specifies the time\n         to wait before sending the\
    \ next request, or until nothing\n         new has been learned from two successive\
    \ requests.  This\n         property corresponds to the protocol specification\
    \ parameter\n         CONFIG_RETRY [7].  Default is:  2000,2000,2000,2000,3000,4000.\n\
    \      net.slp.datagramTimeouts\n         A value-list of 32 bit integers used\
    \ as timeouts, in\n         milliseconds, to implement unicast datagram transmission\
    \ to\n         DAs.  The nth value gives the time to block waiting for a reply\n\
    \         on the nth try to contact the DA. The sum of these values is\n     \
    \    the protocol specification property CONFIG_RETRY_MAX [7].\n      net.slp.randomWaitBound\n\
    \         A 32 bit integer giving the maximum value for all random\n         wait\
    \ parameters, in milliseconds.  Default is 1000 (1\n         sec.).  This value\
    \ corresponds to the protocol specification\n         parameters CONFIG_START_WAIT,\
    \ CONFIG_REG_PASSIVE, and\n         CONFIG_REG_ACTIVE [7].\n      net.slp.MTU\n\
    \         A 16 bit integer giving the network packet MTU, in bytes.\n        \
    \ This is the maximum size of any datagram to send, but the\n         implementation\
    \ might receive a larger datagram.  The maximum\n         size includes IP, and\
    \ UDP or TCP headers.  Default is 1400.\n      net.slp.interfaces\n         Value-list\
    \ of strings giving the IP addresses of network\n         interfaces on which\
    \ the DA or SA should listen on port 427 for\n         multicast, unicast UDP,\
    \ and TCP messages.  Default is empty,\n         i.e.  use the default network\
    \ interface.  The grammar for this\n         property is:\n               addr-list\
    \     =  hostnumber / hostnumber \",\" addr-list\n               hostnumber  \
    \  =  1*3DIGIT 3(\".\" 1*3DIGIT)\n         An example is:\n                  195.42.42.42,195.42.142.1,195.42.120.1\n\
    \         The example machine has three interfaces on which the DA should\n  \
    \       listen.\n         Note that since this property only takes IP addresses,\
    \ it will\n         need to be changed if the network is renumbered.\n"
- title: 2.1.6. SA Configuration
  contents:
  - "2.1.6. SA Configuration\n   This section contains configuration properties for\
    \ the SA. These\n   properties are typically set programmatically by the SA, since\
    \ they\n   are specific to each SA.\n      net.slp.SAAttributes\n         A comma-separated\
    \ list of parenthesized attribute/value list\n         pairs that the SA must\
    \ advertise in SAAdverts.  The property\n         must be in the SLP attribute\
    \ list wire format, including\n         escapes for reserved characters. [7]\n"
- title: 2.1.7. UA Configuration
  contents:
  - "2.1.7. UA Configuration\n   This section contains configuration properties for\
    \ the UA. These\n   properties can be set either programmatically by the UA or\
    \ in the\n   configuration file.\n      net.slp.locale\n         A RFC 1766 Language\
    \ Tag [6] for the language locale.  Setting\n         this property causes the\
    \ property value to become the default\n         locale for SLP messages.  Default\
    \ is \"en\".  This property is\n         also used for SA and DA configuration.\n\
    \      net.slp.maxResults\n         A 32 bit integer giving the maximum number\
    \ of results to\n         accumulate and return for a synchronous request before\
    \ the\n         timeout, or the maximum number of results to return through a\n\
    \         callback if the request results are reported asynchronously.\n     \
    \    Positive integers and -1 are legal values.  If -1, indicates\n         that\
    \ all results should be returned.  Default value is -1.\n         DAs and SAs\
    \ always return all results that match the\n         request.  This configuration\
    \ value applies only to UAs, that\n         filter incoming results and only return\
    \ as many values as\n         net.slp.maxResults indicates.\n      net.slp.typeHint\n\
    \         A value-list of service type names.  In the absence of any\n       \
    \  DAs, UAs perform SA discovery for finding scopes.  These SA\n         discovery\
    \ requests may contain a request for service types as\n         an attribute.\n\
    \         The API implementation will use the service type names supplied\n  \
    \       by this property to discover only those SAs (and their scopes)\n     \
    \    which support the desired service type or types.  For example,\n        \
    \ if net.slp.typeHint is set to \"service:imap,service:pop3\" then\n         SA\
    \ discovery requests will include the search filter:\n         (|(service-type=service:imap)(service-type=service:pop3))\n\
    \         The API library can also use unicast to contact the discovered\n   \
    \      SAs for subsequent requests for these service types, to\n         optimize\
    \ network access.\n"
- title: 2.1.8. Security
  contents:
  - "2.1.8. Security\n   The property in this section allows security for all agents\
    \ to be set\n   on or off.  When the property is true, then the agent must include\n\
    \   security information on all SLP messages transacted by that agent.\n   Since\
    \ security policy must be set network wide to be effective, a\n   single property\
    \ controls security for all agents.  Key management and\n   management of SLP\
    \ SPI strings [7] are implementation and policy\n   dependent.\n      net.slp.securityEnabled\n\
    \         A boolean indicating whether the agent should enable\n         security\
    \ for URLs, attribute lists, DAAdverts, and SAAdverts.\n         Each agent is\
    \ responsible for interpreting the property\n         appropriately.  Default\
    \ is false.\n"
- title: 2.2. Multihomed Machines
  contents:
  - "2.2. Multihomed Machines\n   On multihomed machines, the bandwidth and latency\
    \ characteristics on\n   different network interfaces may differ considerably,\
    \ to the point\n   where different configuration properties are necessary to achieve\n\
    \   optimal performance.  The net.slp.interfaces property indicates which\n  \
    \ network interfaces are SLP enabled.  An API library implementation\n   may support\
    \ configuration customization on a per network interface\n   basis by allowing\
    \ the interface IP address to be appended to the\n   property name.  In that case,\
    \ the values of the property are only\n   used for that particular interface,\
    \ the generic property (or defaults\n   if no generic property is set) applies\
    \ to all others.\n   For example, if a configuration has the following properties:\n\
    \      net.slp.interfaces=125.196.42.41,125.196.42.42,125.196.42.43\n      net.slp.multicastTTL.125.196.42.42=1\n\
    \   then the network interface on subnet 42 is restricted to a TTL of 1,\n   while\
    \ the interfaces on the other subnets have the default multicast\n   radius, 255.\n\
    \   The net.slp.interfaces property must only be set if there is no\n   routing\
    \ between the interfaces.  If the property is set, the DA (if\n   any) and SAs\
    \ should advertise with the IP address or host name\n   appropriate to the interface\
    \ on the interfaces in the list.  If\n   packets are routed between the interfaces,\
    \ then the DA and SAs should\n   only advertise on the default interface.  The\
    \ property should also be\n   set if broadcast is used rather than multicast on\
    \ the subnets\n   connected to the interfaces.  Note that even if unicast packets\
    \ are\n   not routed between the interfaces, multicast may be routed through\n\
    \   another router.  The danger in listening for multicast on multiple\n   interfaces\
    \ when multicast packets are routed is that the DA or SA may\n   receive the same\
    \ multicast request via more than one interface.\n   Since the IP address is different\
    \ on each interface, the DA or SA\n   cannot identify the request as having already\
    \ being answered via the\n   previous responder's list.  The requesting agent\
    \ will end up getting\n   URLs that refer to the same DA or service but have different\n\
    \   addresses or host names.\n"
- title: 2.3. Serialized Registration File
  contents:
  - "2.3. Serialized Registration File\n   The serialized registration file contains\
    \ a group of registrations\n   that a DA or SA server (if one exists) registers\
    \ when it starts up.\n   These registrations are primarily for older service programs\
    \ that do\n   not internally support SLP and cannot be converted, and for portably\n\
    \   exchanging registrations between SLP implementations.  The character\n   encoding\
    \ of the registrations is required to be UTF-8.\n   The syntax of the serialized\
    \ registration file, in ABNF format [5],\n   is as follows:\n      ser-file  \
    \    =  reg-list\n      reg-list      =  reg / reg reg-list\n      reg       \
    \    =  creg / ser-reg\n      creg          =  comment-line ser-reg\n      comment-line\
    \  =  ( \"#\" / \";\" ) 1*allchar newline\n      ser-reg       =  url-props [slist]\
    \ [attr-list] newline\n      url-props     =  surl \",\" lang \",\" ltime [ \"\
    ,\" type ] newline\n      surl          =  ;The registration's URL. See\n    \
    \                   ; [8] for syntax.\n      lang          =  1*8ALPHA [ \"-\"\
    \ 1*8ALPHA ]\n                       ;RFC 1766 Language Tag see [6].\n      ltime\
    \         =  1*5DIGIT\n                       ; A positive 16-bit integer\n  \
    \                     ; giving the lifetime\n                       ; of the registration.\n\
    \      type          =  ; The service type name, see [7]\n                   \
    \    ; and [8] for syntax.\n      slist         =  \"scopes\" \"=\" scope-list\
    \ newline\n      scope-list    =  scope-name / scope-name \",\" scope-list\n \
    \     scope         =  ; See grammar of [7] for\n                       ; scope-name\
    \ syntax.\n      attr-list     =  attr-def / attr-def attr-list\n      attr-def\
    \      =  ( attr / keyword ) newline\n      keyword       =  attr-id\n      attr\
    \          =  attr-id \"=\" attr-val-list\n      attr-id       =  ;Attribute id,\
    \ see [7] for syntax.\n      attr-val-list =  attr-val / attr-val \",\" attr-val-list\n\
    \      attr-val      =  ;Attribute value, see [7] for syntax.\n      allchar \
    \      =  char / WSP\n      char          =  DIGIT / ALPHA / other\n      other\
    \         =  %x21-%x2f / %x3a-%x40 /\n                       %x5b-%x60 / %7b-%7e\n\
    \                       ; All printable, nonwhitespace US-ASCII\n            \
    \           ; characters.\n      newline       =  CR / ( CRLF )\n   The syntax\
    \ for scope names, attribute tags, and attribute values\n   requires escapes for\
    \ special characters as specified in [7].  DAs and\n   SA servers that process\
    \ serialized registrations must handle them\n   exactly as if they were registered\
    \ by an SA. In the url-props\n   production, the type token is optional.  If the\
    \ type token is present\n   for a service:  URL, a warning is signaled and the\
    \ type name is\n   ignored.  If the maximum lifetime is specified (65535 sec.),\
    \ the\n   registration is taken to be permanent, and is continually refreshed\n\
    \   by the DA or SA server until it exits.  Scopes can be included in a\n   registration\
    \ by including an attribute definition with tag \"scopes\"\n   followed by a comma\
    \ separated list of scope names immediately after\n   the url-props production.\
    \  If the optional scope list is present, the\n   registrations are made in the\
    \ indicated scopes; otherwise, they are\n   registered in the scopes with which\
    \ the DA or SA server was\n   configured through the net.slp.useScopes property.\n\
    \   If the scope list contains scopes that are not in the\n   net.slp.useScopes\
    \ property (provided that property is set) or are not\n   specified by DHCP, the\
    \ API library should reject the registration and\n   issue a warning message.\n"
- title: 2.4. Processing Serialized Registration and Configuration Files
  contents:
  - "2.4. Processing Serialized Registration and Configuration Files\n   Implementations\
    \ are encouraged to make processing of configuration\n   and serialized files\
    \ as transparent as possible to clients of the\n   API. At the latest, errors\
    \ must be caught when the relevant\n   configuration item is used.  At the earliest,\
    \ errors may be caught\n   when the relevant file is loaded into the executing\
    \ agent.  Errors\n   should be reported by logging to the appropriate platform\
    \ logging\n   file, error output, or log device, and the default value substituted.\n\
    \   Serialized registration file entries should be caught and reported\n   when\
    \ the file is loaded.\n   Configuration file loading must be complete prior to\
    \ the initiation\n   of the first networking connection.  Serialized registration\
    \ must be\n   complete before the DA accepts the first network request.\n"
- title: 3. Binding Independent Implementation Considerations
  contents:
  - "3. Binding Independent Implementation Considerations\n   This section discusses\
    \ a number of implementation considerations\n   independent of language binding,\
    \ with language specific notes where\n   applicable.\n"
- title: 3.1. Multithreading
  contents:
  - "3.1. Multithreading\n   Implementations of both the C and Java APIs are required\
    \ to make API\n   calls thread-safe.  Access to data structures shared between\
    \ threads\n   must be co-ordinated to avoid corruption or invalid access.  One\
    \ way\n   to achieve this goal is to allow only one thread at a time in the\n\
    \   implementing library.  Performance in such an implementation suffers,\n  \
    \ however.  Therefore, where possible, implementations are encouraged\n   to allow\
    \ multiple threads within the SLP API library.\n"
- title: 3.2. Asynchronous and Incremental
  contents:
  - "3.2. Asynchronous and Incremental\n   The APIs are designed to encourage implementations\
    \ supporting\n   asynchronous and incremental client interaction.  The goal is\
    \ to\n   allow large numbers of returned service URLs, service types, and\n  \
    \ attributes without requiring the allocation of huge chunks of memory.\n   The\
    \ particular design features to support this goal differ in the two\n   language\
    \ bindings.\n"
- title: 3.3. Type Checking for Service Types
  contents:
  - "3.3. Type Checking for Service Types\n   Service templates [8] allow SLP registrations\
    \ to be type checked for\n   correctness.  Implementations of the API are free\
    \ to make use of\n   service type information for type checking, but are not required\
    \ to\n   do so.  If a type error occurs, the registration should terminate\n \
    \  with TYPE_ERROR.\n"
- title: 3.4. Refreshing Registrations
  contents:
  - "3.4. Refreshing Registrations\n   SLP advertisements carry an explicit lifetime\
    \ with them.  After the\n   lifetime expires, the DA flushes the registration\
    \ from its cache.  In\n   some cases, an application may want to have the URL\
    \ continue being\n   registered for the entire time during which the application\
    \ is\n   executing.  The API includes provision for clients to indicate\n   whether\
    \ they want URLs to be automatically refreshed.\n   Implementations of the SA\
    \ API must provide this automatic refreshing\n   capability.  Note that a client\
    \ which uses this facility should\n   explicitly deregister the service URL before\
    \ exiting, since the API\n   implementation may not be able to assure that the\
    \ URL is deregistered\n   when the application exits, although it will time out\
    \ in the DA\n   eventually.\n"
- title: 3.5. Configuration File Processing
  contents:
  - "3.5. Configuration File Processing\n   DAs, SAs and UAs processing the configuration\
    \ file, and DAs and SA\n   servers processing the serialized registration file\
    \ are required to\n   log any errors using whatever underlying error mechanism\
    \ is\n   appropriate for the platform.  Examples include writing error\n   messages\
    \ to the standard output, writing to a system logging device,\n   or displaying\
    \ the errors to a logging window.  After the error is\n   reported, the offending\
    \ property must be set to the default and\n   program execution continued.  An\
    \ agent MUST NOT fail if a file format\n   error occurs.\n"
- title: 3.6. Attribute Types
  contents:
  - "3.6. Attribute Types\n   String encoded attribute values do not include explicit\
    \ type\n   information.  All UA implementations and those SA and DA\n   implementations\
    \ that choose to support type checking should use the\n   type rules described\
    \ in [8] in order to convert from the string\n   representation on the wire to\
    \ an object typed appropriately.\n"
- title: 3.7. Removal of Duplicates
  contents:
  - "3.7. Removal of Duplicates\n   The UA implementation SHOULD always collate results\
    \ to remove\n   duplicates during synchronous operations and for the Java API.\
    \ During\n   asynchronous operation in C, the UA implementation SHOULD forgo\n\
    \   duplicate elimination to reduce memory requirements in the library.\n   This\
    \ allows the API library to simply take the returned attribute\n   value list\
    \ strings, URL strings, or service type list strings and\n   call the callback\
    \ function with it, without any additional\n   processing.  Naturally, the burden\
    \ of duplicate elimination is thrown\n   onto the client in this case.\n"
- title: 3.8. Character Set Encoding
  contents:
  - "3.8. Character Set Encoding\n   Character string parameters in the Java API are\
    \ all represented in\n   Unicode internally because that is the Java-supported\
    \ character set.\n   Characters buffer parameters in the C API are represented\
    \ in UTF-8 to\n   maintain maximum compatibility on platforms that only support\
    \ US-\n   ASCII and not UTF-8.  API functions are still required to handle the\n\
    \   full range of UTF-8 characters because the SLP protocol requires it,\n   but\
    \ the API implementation can represent the characters internally in\n   any convenient\
    \ way.  On the wire, all characters are converted to\n   UTF-8.  Inside URLs,\
    \ characters that are not allowed by URL syntax\n   [2] must be escaped according\
    \ to the URL escape character convention.\n   Strings that are included in SLP\
    \ messages may include SLP reserved\n   characters and can be escaped by clients\
    \ through convenience\n   functions provided by the API. The character encoding\
    \ used in escapes\n   is UTF-8.\n   Due to constraints in SLP, no string parameter\
    \ passed to the C or\n   Java API may exceed 64K bytes in length.\n"
- title: 3.9. Error Semantics
  contents:
  - "3.9. Error Semantics\n   All errors encountered processing SLP messages should\
    \ be logged.  For\n   synchronous calls, an error is only reported on a call if\
    \ no\n   successful replies were received from any SLP framework entity.  If\n\
    \   an error occurred among one of several successful replies, then the\n   error\
    \ should be logged and the successful replies returned.  For\n   asynchronous\
    \ calls, an error occurring during correspondence with a\n   particular remote\
    \ SLP agent is reported through the first callback\n   (in the C API) or enumeration\
    \ method invocation (in the Java API)\n   after the error occurs, which would\
    \ normally report the results of\n   the correspondence.  This allows the callback\
    \ or client code to\n   determine whether the operation should be terminated or\
    \ continue.  In\n   some cases, the error returned from the SLP framework may\
    \ be fatal\n   (SLP_PARSE_ERROR, etc.).  In these cases, the API library terminates\n\
    \   the operation.\n   Both the Java and C APIs contain language specific error\
    \ code\n   mechanisms for returning error information.  The names of the error\n\
    \   codes are consistent between the two implementations, however.\n   The following\
    \ error codes are returned from a remote agent (DA or SA\n   server):\n      LANGUAGE_NOT_SUPPORTED\n\
    \         No DA or SA has service advertisement or attribute information\n   \
    \      in the language requested, but at least one DA or SA indicated,\n     \
    \    via the LANGUAGE_NOT_SUPPORTED error code, that it might have\n         information\
    \ for that service in another language.\n      PARSE_ERROR\n         The SLP message\
    \ was rejected by a remote SLP agent.  The API\n         returns this error only\
    \ when no information was retrieved, and\n         at least one SA or DA indicated\
    \ a protocol error.  The data\n         supplied through the API may be malformed\
    \ or a may have been\n         damaged in transit.\n      INVALID_REGISTRATION\n\
    \         The API may return this error if an attempt to register a\n        \
    \ service was rejected by all DAs because of a malformed URL or\n         attributes.\
    \  SLP does not return the error if at least one DA\n         accepted the registration.\n\
    \      AUTHENTICATION_ABSENT\n         If the SLP framework supports authentication,\
    \ this error arises\n         when the UA or SA failed to send an authenticator\
    \ for requests\n         or registrations in a protected scope.\n      INVALID_UPDATE\n\
    \         An update for a non-existing registration was issued, or the\n     \
    \    update includes a service type or scope different than that in\n        \
    \ the initial registration, etc.\n   The following errors result from interactions\
    \ with remote agents or\n   can occur locally:\n      AUTHENTICATION_FAILED\n\
    \         If the SLP framework supports authentication, this error arises\n  \
    \       when a authentication on an SLP message failed.\n      SCOPE_NOT_SUPPORTED\n\
    \         The API returns this error if the SA has been configured with\n    \
    \     net.slp.useScopes value-list of scopes and the SA request did\n        \
    \ not specify one or more of these allowable scopes, and no\n         others.\
    \  It may be returned by a DA or SA if the scope included\n         in a request\
    \ is not supported by the DA or SA.\n      REFRESH_REJECTED\n         The SA attempted\
    \ to refresh a registration more frequently\n         than the minimum refresh\
    \ interval.  The SA should call the\n         appropriate API function to obtain\
    \ the minimum refresh interval\n         to use.\n   The following errors are\
    \ generated through a program interacting with\n   the API implementation.  They\
    \ do not involve a remote SLP agent.\n      NOT_IMPLEMENTED\n         If an unimplemented\
    \ feature is used, this error is returned.\n      NETWORK_INIT_FAILED\n      \
    \   If the network cannot initialize properly, this error is\n         returned.\n\
    \      NETWORK_TIMED_OUT\n         When no reply can be obtained in the time specified\
    \ by the\n         configured timeout interval for a unicast request, this error\n\
    \         is returned.\n      NETWORK_ERROR\n         The failure of networking\
    \ during normal operations causes this\n         error to be returned.\n     \
    \ BUFFER_OVERFLOW\n         An outgoing request overflowed the maximum network\
    \ MTU size.\n         The request should be reduced in size or broken into pieces\
    \ and\n         tried again.\n      MEMORY_ALLOC_FAILED\n         If the API fails\
    \ to allocate memory, the operation is aborted\n         and returns this.\n \
    \     PARAMETER_BAD\n         If a parameter passed into an interface is bad,\
    \ this error is\n         returned.\n      INTERNAL_SYSTEM_ERROR\n         A basic\
    \ failure of the API causes this error to be returned.\n         This occurs when\
    \ a system call or library fails.  The operation\n         could not recover.\n\
    \      HANDLE_IN_USE\n         In the C API, callback functions are not permitted\
    \ to\n         recursively call into the API on the same SLPHandle, either\n \
    \        directly or indirectly.  If an attempt is made to do so, this\n     \
    \    error is returned from the called API function.\n      TYPE_ERROR\n     \
    \    If the API supports type checking of registrations against\n         service\
    \ type templates, this error can arise if the attributes\n         in a registration\
    \ do not match the service type template for\n         the service.\n   Some error\
    \ codes are handled differently in the Java API. These\n   differences are discussed\
    \ in Section 5.\n   The SLP protocol errors OPTION_NOT_UNDERSTOOD, VERSION_NOT_SUPPORTED,\n\
    \   INTERNAL_ERROR, MSG_NOT_SUPPORTED, AUTHENTICATON_UNKNOWN, and\n   DA_BUSY_NOW\
    \ should be handled internally and not surfaced to clients\n   through the API.\n"
- title: 3.10. Modular Implementations
  contents:
  - "3.10. Modular Implementations\n   Subset implementations that do not support\
    \ the full range of\n   functionality are required to nevertheless support every\
    \ interface in\n   order to maintain link compatibility between compliant API\n\
    \   implementations and applications.  If a particular operation is not\n   supported,\
    \ a NOT_IMPLEMENTED error should be returned.  The Java API\n   has some additional\
    \ conventions for handling subsets.  Applications\n   that are expected to run\
    \ on a wide variety of platforms should be\n   prepared for subset API implementations\
    \ by checking returned error\n   codes.\n"
- title: 3.11. Handling Special Service Types
  contents:
  - "3.11. Handling Special Service Types\n   The service types service:directory-agent\
    \ and service:service-agent\n   are used internally in the SLP framework to discover\
    \ DAs and SAs.\n   The mechanism of DA and SA discovery is not normally exposed\
    \ to the\n   API client; however, the client may have interest in discovering\
    \ DAs\n   and SAs independently of their role in discovering other services.\n\
    \   For example, a network management application may want to determine\n   which\
    \ machines are running SLP DAs.  To facilitate that, API\n   implementations must\
    \ handle requests to find services and attributes\n   for these two service types\
    \ so that API clients obtain the\n   information they expect.\n   In particular,\
    \ if the UA is using a DA, SrvRqst and AttrRqst for\n   these service types must\
    \ be multicast and not unicast to the DA, as\n   is the case for other service\
    \ types.  If the requests are not\n   multicast, the DA will respond with an empty\
    \ reply to a request for\n   services of type service:service-agent and with its\
    \ URL only to a\n   request for services of type service:directory-agent.  The\
    \ UA would\n   therefore not obtain a complete picture of the available DAs and\
    \ SAs.\n"
- title: 3.12. Scope Discovery and Handling
  contents:
  - "3.12. Scope Discovery and Handling\n   Both APIs contain an operation to obtain\
    \ a list of currently known\n   scope names.  This scope information comes from\
    \ a variety of places:\n   DHCP, the net.slp.useScopes property, unicast to DAs\
    \ configured via\n   DHCP or the net.slp.DAAddresses property, and active and\
    \ passive\n   discovery.\n   The API is required to be implemented in a way that\
    \ re-enforces the\n   administrative and user scoping models described in [7].\
    \  SA clients\n   only support the administrative scoping model.  SAs must know\
    \ a\n   priori what DAs they need to register with since there is typically\n\
    \   no human intervention in scope selection for SAs.  UAs must support\n   both\
    \ administrative and user scoping because an application may\n   require human\
    \ intervention in scope selection.\n   API implementations are required to support\
    \ administrative scoping in\n   the following way.  Scopes configured by DHCP\
    \ and scopes of DAs\n   configured by DHCP have first priority (in that order)\
    \ and must be\n   returned if they are available.  The net.slp.useScopes property\
    \ has\n   second priority, and scopes discovered through the net.slp.useScopes\n\
    \   property must be returned if this property is set and there are no\n   scopes\
    \ available from DHCP. If scopes are not available from either\n   of these sources\
    \ and the net.slp.DAAddresses property is set, then\n   the scopes available from\
    \ the configured DAs must be returned.  Note\n   that if both DAs and scopes are\
    \ configured, the scopes of the\n   configured DAs must match the configured scope\
    \ list; otherwise and\n   error is signaled and agent execution is terminated.\
    \  If no\n   configured scope information is available, then an SA client has\n\
    \   default scope, \"DEFAULT\", and a UA client employs user scoping.\n   User\
    \ scoping is supported in the following way.  Scopes discovered\n   from active\
    \ DA discovery, and from passive DA discovery all must be\n   returned.  If no\
    \ information is available from active and passive DA\n   discovery, then the\
    \ API library may perform SA discovery, using the\n   service types in the net.slp.typeHint\
    \ property to limit the search to\n   SAs supporting particular service types.\
    \  If no net.slp.typeHint\n   property is set, the UA may perform SA discovery\
    \ without any service\n   type query.  In the absence of any of the above sources\
    \ of\n   information, the API must return the default scope, \"DEFAULT\".  Note\n\
    \   that the API must always return some scope information.\n   SLP requires that\
    \ SAs must perform their operations in all scopes\n   currently known to them.\
    \ [7].  The API enforces this constraint by\n   not requiring the API client to\
    \ supply any scopes as parameters to\n   API operations.  The API library must\
    \ obtain all currently known\n   scopes and use them in SA operations.  UA API\
    \ clients should use a\n   scope obtained through one of the API operations for\
    \ finding scopes.\n   Any other scope name may result in a SCOPE_NOT_SUPPORTED\
    \ error from a\n   remote agent.  The UA API library can optionally check the\
    \ scope and\n   return the error without contacting a remote agent.\n"
- title: 4. C Language Binding
  contents:
  - "4. C Language Binding\n   The C language binding presents a minimal overhead\
    \ implementation\n   that maps directly into the protocol.  There is one C language\n\
    \   function per protocol request, with the exception of the SLPDereg()\n   and\
    \ SLPDelAttrs() functions, which map into different uses of the SLP\n   deregister\
    \ request.  Parameters are for the most part character\n   buffers.  Memory management\
    \ is kept simple by having the client\n   allocate most memory and requiring that\
    \ client callback functions\n   copy incoming parameters into memory allocated\
    \ by the client code.\n   Any memory returned directly from the API functions\
    \ is deallocated\n   using the SLPFree() function.\n   To conform with standard\
    \ C practice, all character strings passed to\n   and returned through the API\
    \ are null terminated, even though the SLP\n   protocol does not use null terminated\
    \ strings.  Strings passed as\n   parameters are UTF-8 but they may still be passed\
    \ as a C string (a\n   null terminated sequence of bytes.)  Escaped characters\
    \ must be\n   encoded by the API client as UTF-8.  In the common case of US-ASCII,\n\
    \   the usual one byte per character C strings work.  API functions\n   assist\
    \ in escaping and unescaping strings.\n   Unless otherwise noted, parameters to\
    \ API functions and callbacks are\n   non-NULL. Some parameters may have other\
    \ restrictions.  If any\n   parameter fails to satisfy the restrictions on its\
    \ value, the\n   operation returns a PARAMETER_BAD error.\n"
- title: 4.1. Constant Types
  contents:
  - '4.1. Constant Types

    '
- title: 4.1.1. URL Lifetimes
  contents:
  - '4.1.1. URL Lifetimes

    '
- title: 4.1.1.1. Synopsis
  contents:
  - "4.1.1.1. Synopsis\n   typedef enum {\n     SLP_LIFETIME_DEFAULT = 10800,\n  \
    \   SLP_LIFETIME_MAXIMUM = 65535\n   } SLPURLLifetime;\n"
- title: 4.1.1.2. Description
  contents:
  - "4.1.1.2. Description\n   The SLPURLLifetime enum type contains URL lifetime values,\
    \ in\n   seconds, that are frequently used.  SLP_LIFETIME_DEFAULT is 3 hours,\n\
    \   while SLP_LIFETIME_MAXIMUM is about 18 hours and corresponds to the\n   maximum\
    \ size of the lifetime field in SLP messages.\n"
- title: 4.1.2. Error Codes
  contents:
  - '4.1.2. Error Codes

    '
- title: 4.1.2.1. Synopsis
  contents:
  - "4.1.2.1. Synopsis\n   typedef enum {\n     SLP_LAST_CALL                    =\
    \ 1,\n     SLP_OK                           = 0,\n     SLP_LANGUAGE_NOT_SUPPORTED\
    \       = -1,\n     SLP_PARSE_ERROR                  = -2,\n     SLP_INVALID_REGISTRATION\
    \         = -3,\n     SLP_SCOPE_NOT_SUPPORTED          = -4,\n     SLP_AUTHENTICATION_ABSENT\
    \        = -6,\n     SLP_AUTHENTICATION_FAILED        = -7,\n     SLP_INVALID_UPDATE\
    \               = -13,\n     SLP_REFRESH_REJECTED             = -15,\n     SLP_NOT_IMPLEMENTED\
    \              = -17,\n     SLP_BUFFER_OVERFLOW              = -18,\n     SLP_NETWORK_TIMED_OUT\
    \            = -19,\n     SLP_NETWORK_INIT_FAILED          = -20,\n     SLP_MEMORY_ALLOC_FAILED\
    \          = -21,\n     SLP_PARAMETER_BAD                = -22,\n     SLP_NETWORK_ERROR\
    \                = -23,\n     SLP_INTERNAL_SYSTEM_ERROR        = -24,\n     SLP_HANDLE_IN_USE\
    \                = -25,\n     SLP_TYPE_ERROR                   = -26\n   } SLPError\
    \ ;\n"
- title: 4.1.2.2. Description
  contents:
  - "4.1.2.2. Description\n   The SLPError enum contains error codes that are returned\
    \ from API\n   functions.\n   The SLP_OK code indicates that the no error occurred\
    \ during the\n   operation.\n   The SLP_LAST_CALL code is passed to callback functions\
    \ when the API\n   library has no more data for them and therefore no further\
    \ calls will\n   be made to the callback on the currently outstanding operation.\
    \  The\n   callback can use this to signal the main body of the client code that\n\
    \   no more data will be forthcoming on the operation, so that the main\n   body\
    \ of the client code can break out of data collection loops.  On\n   the last\
    \ call of a callback during both a synchronous and\n   asynchronous call, the\
    \ error code parameter has value SLP_LAST_CALL,\n   and the other parameters are\
    \ all NULL. If no results are returned by\n   an API operation, then only one\
    \ call is made, with the error\n   parameter set to SLP_LAST_CALL.\n"
- title: 4.1.3. SLPBoolean
  contents:
  - '4.1.3. SLPBoolean

    '
- title: 4.1.3.1. Synopsis
  contents:
  - "4.1.3.1. Synopsis\n   typedef enum {\n      SLP_FALSE = 0,\n      SLP_TRUE =\
    \ 1\n   } SLPBoolean;\n"
- title: 4.1.3.2. Description
  contents:
  - "4.1.3.2. Description\n   The SLPBoolean enum is used as a boolean flag.\n"
- title: 4.2. Struct Types
  contents:
  - '4.2. Struct Types

    '
- title: 4.2.1. SLPSrvURL
  contents:
  - '4.2.1. SLPSrvURL

    '
- title: 4.2.1.1. Synopsis
  contents:
  - "4.2.1.1. Synopsis\n   typedef struct srvurl {\n     char *s_pcSrvType;\n    \
    \ char *s_pcHost;\n     int   s_iPort;\n     char *s_pcNetFamily;\n     char *s_pcSrvPart;\n\
    \   } SLPSrvURL;\n"
- title: 4.2.1.2. Description
  contents:
  - "4.2.1.2. Description\n   The SLPSrvURL structure is filled in by the SLPParseSrvURL()\
    \ function\n   with information parsed from a character buffer containing a service\n\
    \   URL. The fields correspond to different parts of the URL. Note that\n   the\
    \ structure is in conformance with the standard Berkeley sockets\n   struct servent,\
    \ with the exception that the pointer to an array of\n   characters for aliases\
    \ (s_aliases field) is replaced by the pointer\n   to host name (s_pcHost field).\n\
    \      s_pcSrvType\n         A pointer to a character string containing the service\n\
    \         type name, including naming authority.  The service type\n         name\
    \ includes the \"service:\" if the URL is of the service:\n         scheme. [7]\n\
    \      s_pcHost\n         A pointer to a character string containing the host\n\
    \         identification information.\n      s_iPort\n         The port number,\
    \ or zero if none.  The port is only available\n         if the transport is IP.\n\
    \      s_pcNetFamily\n         A pointer to a character string containing the\
    \ network address\n         family identifier.  Possible values are \"ipx\" for\
    \ the IPX\n         family, \"at\" for the Appletalk family, and \"\" (i.e.  the\
    \ empty\n         string) for the IP address family.\n      s_pcSrvPart\n    \
    \     The remainder of the URL, after the host identification.\n   The host and\
    \ port should be sufficient to open a socket to the\n   machine hosting the service,\
    \ and the remainder of the URL should\n   allow further differentiation of the\
    \ service.\n"
- title: 4.2.2. SLPHandle
  contents:
  - '4.2.2. SLPHandle

    '
- title: 4.2.2.1. Synopsis
  contents:
  - "4.2.2.1. Synopsis\n   typedef void* SLPHandle;\n   The SLPHandle type is returned\
    \ by SLPOpen() and is a parameter to all\n   SLP functions.  It serves as a handle\
    \ for all resources allocated on\n   behalf of the process by the SLP library.\
    \  The type is opaque, since\n   the exact nature differs depending on the implementation.\n"
- title: 4.3. Callbacks
  contents:
  - "4.3. Callbacks\n   A function pointer to a callback function specific to a particular\n\
    \   API operation is included in the parameter list when the API function\n  \
    \ is invoked.  The callback function is called with the results of the\n   operation\
    \ in both the synchronous and asynchronous cases.  The memory\n   included in\
    \ the callback parameters is owned by the API library, and\n   the client code\
    \ in the callback must copy out the contents if it\n   wants to maintain the information\
    \ longer than the duration of the\n   current callback call.\n   In addition to\
    \ parameters for reporting the results of the operation,\n   each callback parameter\
    \ list contains an error code parameter and a\n   cookie parameter.  The error\
    \ code parameter reports the error status\n   of the ongoing (for asynchronous)\
    \ or completed (for synchronous)\n   operation.  The cookie parameter allows the\
    \ client code that starts\n   the operation by invoking the API function to pass\
    \ information down\n   to the callback without using global variables.  The callback\
    \ returns\n   an SLPBoolean to indicate whether the API library should continue\n\
    \   processing the operation.  If the value returned from the callback is\n  \
    \ SLP_TRUE, asynchronous operations are terminated, synchronous\n   operations\
    \ ignore the return (since the operation is already\n   complete).\n"
- title: 4.3.1. SLPRegReport
  contents:
  - '4.3.1. SLPRegReport

    '
- title: 4.3.1.1. Synopsis
  contents:
  - "4.3.1.1. Synopsis\n   typedef void SLPRegReport(SLPHandle hSLP,\n           \
    \                  SLPError errCode,\n                             void *pvCookie);\n"
- title: 4.3.1.2. Description
  contents:
  - "4.3.1.2. Description\n   The SLPRegReport callback type is the type of the callback\
    \ function\n   to the SLPReg(), SLPDereg(), and SLPDelAttrs() functions.\n"
- title: 4.3.1.3. Parameters
  contents:
  - "4.3.1.3. Parameters\n      hSLP\n         The SLPHandle used to initiate the\
    \ operation.\n      errCode\n         An error code indicating if an error occurred\
    \ during the\n         operation.\n      pvCookie\n         Memory passed down\
    \ from the client code that called the\n         original API function, starting\
    \ the operation.  May be NULL.\n"
- title: 4.3.2. SLPSrvTypeCallback
  contents:
  - '4.3.2. SLPSrvTypeCallback

    '
- title: 4.3.2.1. Synopsis
  contents:
  - "4.3.2.1. Synopsis\n   typedef SLPBoolean SLPSrvTypeCallback(SLPHandle hSLP,\n\
    \                                         const char* pcSrvTypes,\n          \
    \                               SLPError errCode,\n                          \
    \               void *pvCookie);\n"
- title: 4.3.2.2. Description
  contents:
  - "4.3.2.2. Description\n   The SLPSrvTypeCallback type is the type of the callback\
    \ function\n   parameter to SLPFindSrvTypes() function.  If the hSLP handle\n\
    \   parameter was opened asynchronously, the results returned through the\n  \
    \ callback MAY be uncollated.  If the hSLP handle parameter was opened\n   synchronously,\
    \ then the returned results must be collated and\n   duplicates eliminated.\n"
- title: 4.3.2.3. Parameters
  contents:
  - "4.3.2.3. Parameters\n      hSLP\n         The SLPHandle used to initiate the\
    \ operation.\n      pcSrvTypes\n         A character buffer containing a comma\
    \ separated, null\n         terminated list of service types.\n      errCode\n\
    \         An error code indicating if an error occurred during the\n         operation.\
    \  The callback should check this error code before\n         processing the parameters.\
    \  If the error code is other than\n         SLP_OK, then the API library may\
    \ choose to terminate the\n         outstanding operation.\n      pvCookie\n \
    \        Memory passed down from the client code that called the\n         original\
    \ API function, starting the operation.  May be NULL.\n"
- title: 4.3.2.4. Returns
  contents:
  - "4.3.2.4. Returns\n   The client code should return SLP_TRUE if more data is desired,\n\
    \   otherwise SLP_FALSE.\n"
- title: 4.3.3. SLPSrvURLCallback
  contents:
  - '4.3.3. SLPSrvURLCallback

    '
- title: 4.3.3.1. Synopsis
  contents:
  - "4.3.3.1. Synopsis\n   typedef SLPBoolean SLPSrvURLCallback(SLPHandle hSLP,\n\
    \                                        const char* pcSrvURL,\n             \
    \                           unsigned short sLifetime,\n                      \
    \                  SLPError errCode,\n                                       \
    \ void *pvCookie);\n"
- title: 4.3.3.2. Description
  contents:
  - "4.3.3.2. Description\n   The SLPSrvURLCallback type is the type of the callback\
    \ function\n   parameter to SLPFindSrvs() function.  If the hSLP handle parameter\n\
    \   was opened asynchronously, the results returned through the callback\n   MAY\
    \ be uncollated.  If the hSLP handle parameter was opened\n   synchronously, then\
    \ the returned results must be collated and\n   duplicates eliminated.\n"
- title: 4.3.3.3. Parameters
  contents:
  - "4.3.3.3. Parameters\n      hSLP\n         The SLPHandle used to initiate the\
    \ operation.\n      pcSrvURL\n         A character buffer containing the returned\
    \ service URL.\n      sLifetime\n         An unsigned short giving the life time\
    \ of the service\n         advertisement, in seconds.  The value must be an unsigned\n\
    \         integer less than or equal to SLP_LIFETIME_MAXIMUM.\n      errCode\n\
    \         An error code indicating if an error occurred during the\n         operation.\
    \  The callback should check this error code before\n         processing the parameters.\
    \  If the error code is other than\n         SLP_OK, then the API library may\
    \ choose to terminate the\n         outstanding operation.\n      pvCookie\n \
    \        Memory passed down from the client code that called the\n         original\
    \ API function, starting the operation.  May be NULL.\n"
- title: 4.3.3.4. Returns
  contents:
  - "4.3.3.4. Returns\n   The client code should return SLP_TRUE if more data is desired,\n\
    \   otherwise SLP_FALSE.\n"
- title: 4.3.4. SLPAttrCallback
  contents:
  - '4.3.4. SLPAttrCallback

    '
- title: 4.3.4.1. Synopsis
  contents:
  - "4.3.4.1. Synopsis\n   typedef SLPBoolean SLPAttrCallback(SLPHandle hSLP,\n  \
    \                                    const char* pcAttrList,\n               \
    \                       SLPError errCode,\n                                  \
    \    void *pvCookie);\n"
- title: 4.3.4.2. Description
  contents:
  - "4.3.4.2. Description\n   The SLPAttrCallback type is the type of the callback\
    \ function\n   parameter to SLPFindAttrs() function.\n   The behavior of the callback\
    \ differs depending on whether the\n   attribute request was by URL or by service\
    \ type.  If the\n   SLPFindAttrs() operation was originally called with a URL,\
    \ the\n   callback is called once regardless of whether the handle was opened\n\
    \   asynchronously or synchronously.  The pcAttrList parameter contains\n   the\
    \ requested attributes as a comma separated list (or is empty if no\n   attributes\
    \ matched the original tag list).\n   If the SLPFindAttrs() operation was originally\
    \ called with a service\n   type, the value of pcAttrList and calling behavior\
    \ depend on whether\n   the handle was opened asynchronously or synchronously.\
    \  If the handle\n   was opened asynchronously, the callback is called every time\
    \ the API\n   library has results from a remote agent.  The pcAttrList parameter\n\
    \   MAY be uncollated between calls.  It contains a comma separated list\n   with\
    \ the results from the agent that immediately returned results.\n   If the handle\
    \ was opened synchronously, the results must be collated\n   from all returning\
    \ agents and the callback is called once, with the\n   pcAttrList parameter set\
    \ to the collated result.\n"
- title: 4.3.4.3. Parameters
  contents:
  - "4.3.4.3. Parameters\n      hSLP\n         The SLPHandle used to initiate the\
    \ operation.\n      pcAttrList\n         A character buffer containing a comma\
    \ separated, null\n         terminated list of attribute id/value assignments,\
    \ in SLP wire\n         format; i.e.  \"(attr-id=attr-value-list)\" [7].\n   \
    \   errCode\n         An error code indicating if an error occurred during the\n\
    \         operation.  The callback should check this error code before\n     \
    \    processing the parameters.  If the error code is other than\n         SLP_OK,\
    \ then the API library may choose to terminate the\n         outstanding operation.\n\
    \      pvCookie\n         Memory passed down from the client code that called\
    \ the\n         original API function, starting the operation.  May be NULL.\n"
- title: 4.3.4.4. Returns
  contents:
  - "4.3.4.4. Returns\n   The client code should return SLP_TRUE if more data is desired,\n\
    \   otherwise SLP_FALSE.\n"
- title: 4.4. Opening and Closing an SLPHandle
  contents:
  - '4.4. Opening and Closing an SLPHandle

    '
- title: 4.4.1. SLPOpen
  contents:
  - '4.4.1. SLPOpen

    '
- title: 4.4.1.1. Synopsis
  contents:
  - "4.4.1.1. Synopsis\n   SLPError SLPOpen(const char *pcLang, SLPBoolean isAsync,\
    \ SLPHandle\n   *phSLP);\n"
- title: 4.4.1.2. Description
  contents:
  - "4.4.1.2. Description\n   Returns a SLPHandle handle in the phSLP parameter for\
    \ the language\n   locale passed in as the pcLang parameter.  The client indicates\
    \ if\n   operations on the handle are to be synchronous or asynchronous\n   through\
    \ the isAsync parameter.  The handle encapsulates the language\n   locale for\
    \ SLP requests issued through the handle, and any other\n   resources required\
    \ by the implementation.  However, SLP properties\n   are not encapsulated by\
    \ the handle; they are global.  The return\n   value of the function is an SLPError\
    \ code indicating the status of\n   the operation.  Upon failure, the phSLP parameter\
    \ is NULL.\n   An SLPHandle can only be used for one SLP API operation at a time.\n\
    \   If the original operation was started asynchronously, any attempt to\n   start\
    \ an additional operation on the handle while the original\n   operation is pending\
    \ results in the return of an SLP_HANDLE_IN_USE\n   error from the API function.\
    \  The SLPClose() API function terminates\n   any outstanding calls on the handle.\
    \  If an implementation is unable\n   to support a asynchronous( resp.  synchronous)\
    \ operation, due to\n   memory constraints or lack of threading support, the\n\
    \   SLP_NOT_IMPLEMENTED flag may be returned when the isAsync flag is\n   SLP_TRUE\
    \ (resp.  SLP_FALSE).\n"
- title: 4.4.1.3. Parameters
  contents:
  - "4.4.1.3. Parameters\n      pcLang\n         A pointer to an array of characters\
    \ containing the RFC 1766\n         Language Tag [6] for the natural language\
    \ locale of requests\n         and registrations issued on the handle.\n     \
    \ isAsync\n         An SLPBoolean indicating whether the SLPHandle should be opened\n\
    \         for asynchronous operation or not.\n      phSLP\n         A pointer\
    \ to an SLPHandle, in which the open SLPHandle is\n         returned.  If an error\
    \ occurs, the value upon return is NULL.\n"
- title: 4.4.2. SLPClose
  contents:
  - '4.4.2. SLPClose

    '
- title: 4.4.2.1. Synopsis
  contents:
  - "4.4.2.1. Synopsis\n   void SLPClose(SLPHandle hSLP);\n"
- title: 4.4.2.2. Description
  contents:
  - "4.4.2.2. Description\n   Frees all resources associated with the handle.  If\
    \ the handle was\n   invalid, the function returns silently.  Any outstanding\
    \ synchronous\n   or asynchronous operations are cancelled so their callback functions\n\
    \   will not be called any further.\n"
- title: 4.4.2.3. Parameters
  contents:
  - "4.4.2.3. Parameters\n      SLPHandle\n         A SLPHandle handle returned from\
    \ a call to SLPOpen().\n"
- title: 4.5. Protocol API
  contents:
  - '4.5. Protocol API

    '
- title: 4.5.1. SLPReg
  contents:
  - '4.5.1. SLPReg

    '
- title: 4.5.1.1. Synopsis
  contents:
  - "4.5.1.1. Synopsis\n   SLPError SLPReg(SLPHandle   hSLP,\n                   const\
    \ char  *pcSrvURL,\n                   const unsigned short usLifetime,\n    \
    \               const char  *pcSrvType,\n                   const char  *pcAttrs\n\
    \                   SLPBoolean  fresh,\n                   SLPRegReport callback,\n\
    \                   void *pvCookie);\n"
- title: 4.5.1.2. Description
  contents:
  - "4.5.1.2. Description\n   Registers the URL in pcSrvURL having the lifetime usLifetime\
    \ with the\n   attribute list in pcAttrs.  The pcAttrs list is a comma separated\n\
    \   list of attribute assignments in the wire format (including escaping\n   of\
    \ reserved characters).  The usLifetime parameter must be nonzero\n   and less\
    \ than or equal to SLP_LIFETIME_MAXIMUM. If the fresh flag is\n   SLP_TRUE, then\
    \ the registration is new (the SLP protocol FRESH flag\n   is set) and the registration\
    \ replaces any existing registrations.\n   The pcSrvType parameter is a service\
    \ type name and can be included\n   for service URLs that are not in the service:\
    \  scheme.  If the URL is\n   in the service:  scheme, the pcSrvType parameter\
    \ is ignored.  If the\n   fresh flag is SLP_FALSE, then an existing registration\
    \ is updated.\n   Rules for new and updated registrations, and the format for\
    \ pcAttrs\n   and pcScopeList can be found in [7].  Registrations and updates\
    \ take\n   place in the language locale of the hSLP handle.\n   The API library\
    \ is required to perform the operation in all scopes\n   obtained through configuration.\n"
- title: 4.5.1.3. Parameters
  contents:
  - "4.5.1.3. Parameters\n      hSLP\n         The language specific SLPHandle on\
    \ which to register the\n         advertisement.\n      pcSrvURL\n         The\
    \ URL to register.  May not be the empty string.\n      usLifetime\n         An\
    \ unsigned short giving the life time of the service\n         advertisement,\
    \ in seconds.  The value must be an unsigned\n         integer less than or equal\
    \ to SLP_LIFETIME_MAXIMUM and greater\n         than zero.\n      pcSrvType\n\
    \         The service type.  If pURL is a service:  URL, then this\n         parameter\
    \ is ignored.\n      pcAttrs\n         A comma separated list of attribute assignment\
    \ expressions for\n         the attributes of the advertisement.  Use empty string,\
    \ \"\" for\n         no attributes.\n      fresh\n         An SLPBoolean that\
    \ is SLP_TRUE if the registration is new or\n         SLP_FALSE if a reregistration.\n\
    \      callback\n         A callback to report the operation completion status.\n\
    \      pvCookie\n         Memory passed to the callback code from the client.\
    \  May be\n         NULL.\n"
- title: 4.5.1.4. Returns
  contents:
  - "4.5.1.4. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.5.2. SLPDereg
  contents:
  - '4.5.2. SLPDereg

    '
- title: 4.5.2.1. Synopsis
  contents:
  - "4.5.2.1. Synopsis\n   SLPError SLPDereg(SLPHandle  hSLP,\n                  \
    \   const char *pcURL,\n                     SLPRegReport callback,\n        \
    \             void *pvCookie);\n"
- title: 4.5.2.2. Description
  contents:
  - "4.5.2.2. Description\n   Deregisters the advertisement for URL pcURL in all scopes\
    \ where the\n   service is registered and all language locales.  The deregistration\n\
    \   is not just confined to the locale of the SLPHandle, it is in all\n   locales.\
    \  The API library is required to perform the operation in all\n   scopes obtained\
    \ through configuration.\n"
- title: 4.5.2.3. Parameters
  contents:
  - "4.5.2.3. Parameters\n      hSLP\n         The language specific SLPHandle to\
    \ use for deregistering.\n      pcURL\n         The URL to deregister.  May not\
    \ be the empty string.\n      callback\n         A callback to report the operation\
    \ completion status.\n      pvCookie\n         Memory passed to the callback code\
    \ from the client.  May be\n         NULL.\n"
- title: 4.5.2.4. Returns
  contents:
  - "4.5.2.4. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.5.3. SLPDelAttrs
  contents:
  - '4.5.3. SLPDelAttrs

    '
- title: 4.5.3.1. Synopsis
  contents:
  - "4.5.3.1. Synopsis\n   SLPError SLPDelAttrs(SLPHandle   hSLP,\n              \
    \          const char  *pcURL,\n                        const char  *pcAttrs,\n\
    \                        SLPRegReport callback,\n                        void\
    \ *pvCookie);\n"
- title: 4.5.3.2. Description
  contents:
  - "4.5.3.2. Description\n   Delete the selected attributes in the locale of the\
    \ SLPHandle.  The\n   API library is required to perform the operation in all\
    \ scopes\n   obtained through configuration.\n"
- title: 4.5.3.3. Parameters
  contents:
  - "4.5.3.3. Parameters\n      hSLP\n         The language specific SLPHandle to\
    \ use for deleting attributes.\n      pcURL\n         The URL of the advertisement\
    \ from which the attributes should\n         be deleted.  May not be the empty\
    \ string.\n      pcAttrs\n         A comma separated list of attribute ids for\
    \ the attributes to\n         deregister.  See Section 9.8 in [7] for a description\
    \ of the\n         list format.  May not be the empty string.\n      callback\n\
    \         A callback to report the operation completion status.\n      pvCookie\n\
    \         Memory passed to the callback code from the client.  May be\n      \
    \   NULL.\n"
- title: 4.5.3.4. Returns
  contents:
  - "4.5.3.4. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.5.4. SLPFindSrvTypes
  contents:
  - '4.5.4. SLPFindSrvTypes

    '
- title: 4.5.4.1. Synopsis
  contents:
  - "4.5.4.1. Synopsis\n   SLPError SLPFindSrvTypes(SLPHandle    hSLP,\n         \
    \                   const char  *pcNamingAuthority,\n                        \
    \    const char  *pcScopeList,\n                            SLPSrvTypeCallback\
    \ callback,\n                            void *pvCookie);\n   The SLPFindSrvType()\
    \ function issues an SLP service type request for\n   service types in the scopes\
    \ indicated by the pcScopeList.  The\n   results are returned through the callback\
    \ parameter.  The service\n   types are independent of language locale, but only\
    \ for services\n   registered in one of scopes and for the indicated naming authority.\n\
    \   If the naming authority is \"*\", then results are returned for all\n   naming\
    \ authorities.  If the naming authority is the empty string,\n   i.e.  \"\", then\
    \ the default naming authority, \"IANA\", is used.  \"IANA\"\n   is not a valid\
    \ naming authority name, and it is a PARAMETER_BAD error\n   to include it explicitly.\n\
    \   The service type names are returned with the naming authority intact.\n  \
    \ If the naming authority is the default (i.e.  empty string) then it\n   is omitted,\
    \ as is the separating \".\".  Service type names from URLs\n   of the service:\
    \  scheme are returned with the \"service:\" prefix\n   intact. [7] See [8] for\
    \ more information on the syntax of service\n   type names.\n"
- title: 4.5.4.2. Parameters
  contents:
  - "4.5.4.2. Parameters\n      hSLP\n         The SLPHandle on which to search for\
    \ types.\n      pcNamingAuthority\n         The naming authority to search.  Use\
    \ \"*\" for all naming\n         authorities and the empty string, \"\", for the\
    \ default naming\n         authority.\n      pcScopeList\n         A pointer to\
    \ a char containing comma separated list of scope\n         names to search for\
    \ service types.  May not be the empty\n         string, \"\".\n      callback\n\
    \         A callback function through which the results of the operation\n   \
    \      are reported.\n      pvCookie\n         Memory passed to the callback code\
    \ from the client.  May be\n         NULL.\n"
- title: 4.5.4.3. Returns
  contents:
  - "4.5.4.3. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.5.5. SLPFindSrvs
  contents:
  - '4.5.5. SLPFindSrvs

    '
- title: 4.5.5.1. Synopsis
  contents:
  - "4.5.5.1. Synopsis\n   SLPError SLPFindSrvs(SLPHandle  hSLP,\n               \
    \         const char *pcServiceType,\n                        const char *pcScopeList,\n\
    \                        const char *pcSearchFilter,\n                       \
    \ SLPSrvURLCallback callback,\n                        void *pvCookie);\n"
- title: 4.5.5.2. Description
  contents:
  - "4.5.5.2. Description\n   Issue the query for services on the language specific\
    \ SLPHandle and\n   return the results through the callback.  The parameters determine\n\
    \   the results\n"
- title: 4.5.5.3. Parameters
  contents:
  - "4.5.5.3. Parameters\n      hSLP\n         The language specific SLPHandle on\
    \ which to search for\n         services.\n      pcServiceType\n         The Service\
    \ Type String, including authority string if any, for\n         the request, such\
    \ as can be discovered using SLPSrvTypes().\n         This could be, for example\
    \ \"service:printer:lpr\" or\n         \"service:nfs\".  May not be the empty\
    \ string.\n      pcScopeList\n         A pointer to a char containing comma separated\
    \ list of scope\n         names.  May not be the empty string, \"\".\n      pcSearchFilter\n\
    \         A query formulated of attribute pattern matching expressions in\n  \
    \       the form of a LDAPv3 Search Filter, see [4].  If this filter\n       \
    \  is empty, i.e.  \"\", all services of the requested type in the\n         specified\
    \ scopes are returned.\n      callback\n         A callback function through which\
    \ the results of the operation\n         are reported.\n      pvCookie\n     \
    \    Memory passed to the callback code from the client.  May be\n         NULL.\n"
- title: 4.5.5.4. Returns
  contents:
  - "4.5.5.4. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.5.6. SLPFindAttrs
  contents:
  - '4.5.6. SLPFindAttrs

    '
- title: 4.5.6.1. Synopsis
  contents:
  - "4.5.6.1. Synopsis\n   SLPError SLPFindAttrs(SLPHandle   hSLP,\n             \
    \            const char *pcURLOrServiceType,\n                         const char\
    \ *pcScopeList,\n                         const char *pcAttrIds,\n           \
    \              SLPAttrCallback callback,\n                         void *pvCookie);\n"
- title: 4.5.6.2. Description
  contents:
  - "4.5.6.2. Description\n   This function returns service attributes matching the\
    \ attribute ids\n   for the indicated service URL or service type.  If pcURLOrServiceType\n\
    \   is a service URL, the attribute information returned is for that\n   particular\
    \ advertisement in the language locale of the SLPHandle.\n   If pcURLOrServiceType\
    \ is a service type name (including naming\n   authority if any), then the attributes\
    \ for all advertisements of that\n   service type are returned regardless of the\
    \ language of registration.\n   Results are returned through the callback.\n \
    \  The result is filtered with an SLP attribute request filter string\n   parameter,\
    \ the syntax of which is described in [7].  If the filter\n   string is the empty\
    \ string, i.e.  \"\", all attributes are returned.\n"
- title: 4.5.6.3. Parameters
  contents:
  - "4.5.6.3. Parameters\n      hSLP\n         The language specific SLPHandle on\
    \ which to search for\n         attributes.\n      pcURLOrServiceType\n      \
    \   The service URL or service type.  See [7] for URL and service\n         type\
    \ syntax.  May not be the empty string.\n      pcScopeList\n         A pointer\
    \ to a char containing a comma separated list of scope\n         names.  May not\
    \ be the empty string, \"\".\n      pcAttrIds\n         The filter string indicating\
    \ which attribute values to return.\n         Use empty string, \"\", to indicate\
    \ all values.  Wildcards\n         matching all attribute ids having a particular\
    \ prefix or suffix\n         are also possible.  See [7] for the exact format\
    \ of the filter\n         string.\n      callback\n         A callback function\
    \ through which the results of the operation\n         are reported.\n      pvCookie\n\
    \         Memory passed to the callback code from the client.  May be\n      \
    \   NULL.\n"
- title: 4.5.6.4. Returns
  contents:
  - "4.5.6.4. Returns\n   If an error occurs in starting the operation, one of the\
    \ SLPError\n   codes is returned.\n"
- title: 4.6. Miscellaneous Functions
  contents:
  - '4.6. Miscellaneous Functions

    '
- title: 4.6.1. SLPGetRefreshInterval
  contents:
  - '4.6.1. SLPGetRefreshInterval

    '
- title: 4.6.1.1. Synopsis
  contents:
  - "4.6.1.1. Synopsis\n   unsigned short SLPGetRefreshInterval();\n"
- title: 4.6.1.2. Description
  contents:
  - "4.6.1.2. Description\n   Returns the maximum across all DAs of the min-refresh-interval\n\
    \   attribute.  This value satisfies the advertised refresh interval\n   bounds\
    \ for all DAs, and, if used by the SA, assures that no refresh\n   registration\
    \ will be rejected.  If no DA advertises a min-refresh-\n   interval attribute,\
    \ a value of 0 is returned.\n"
- title: 4.6.1.3. Returns
  contents:
  - "4.6.1.3. Returns\n   If no error, the maximum refresh interval value allowed\
    \ by all DAs (a\n   positive integer).  If no DA advertises a min-refresh-interval\n\
    \   attribute, returns 0.  If an error occurs, returns an SLP error code.\n"
- title: 4.6.2. SLPFindScopes
  contents:
  - '4.6.2. SLPFindScopes

    '
- title: 4.6.2.1. Synopsis
  contents:
  - "4.6.2.1. Synopsis\n   SLPError SLPFindScopes(SLPHandle hSLP,\n              \
    \            char** ppcScopeList);\n"
- title: 4.6.2.2. Description
  contents:
  - "4.6.2.2. Description\n   Sets ppcScopeList parameter to a pointer to a comma\
    \ separated list\n   including all available scope values.  The list of scopes\
    \ comes from\n   a variety of sources:  the configuration file's net.slp.useScopes\n\
    \   property, unicast to DAs on the net.slp.DAAddresses property, DHCP,\n   or\
    \ through the DA discovery process.  If there is any order to the\n    scopes,\
    \ preferred scopes are listed before less desirable scopes.\n   There is always\
    \ at least one name in the list, the default scope,\n   \"DEFAULT\".\n"
- title: 4.6.2.3. Parameters
  contents:
  - "4.6.2.3. Parameters\n      hSLP\n         The SLPHandle on which to search for\
    \ scopes.\n      ppcScopeList\n         A pointer to char pointer into which the\
    \ buffer pointer is\n         placed upon return.  The buffer is null terminated.\
    \  The memory\n         should be freed by calling SLPFree().\n"
- title: 4.6.2.4. Returns
  contents:
  - "4.6.2.4. Returns\n   If no error occurs, returns SLP_OK, otherwise, the appropriate\
    \ error\n   code.\n"
- title: 4.6.3. SLPParseSrvURL
  contents:
  - '4.6.3. SLPParseSrvURL

    '
- title: 4.6.3.1. Synopsis
  contents:
  - "4.6.3.1. Synopsis\n   SLPError SLPParseSrvURL(char *pcSrvURL\n              \
    \             SLPSrvURL** ppSrvURL);\n"
- title: 4.6.3.2. Description
  contents:
  - "4.6.3.2. Description\n   Parses the URL passed in as the argument into a service\
    \ URL structure\n   and returns it in the ppSrvURL pointer.  If a parse error\
    \ occurs,\n   returns SLP_PARSE_ERROR. The input buffer pcSrvURL is destructively\n\
    \   modified during the parse and used to fill in the fields of the\n   return\
    \ structure.  The structure returned in ppSrvURL should be freed\n   with SLPFreeURL().\
    \  If the URL has no service part, the s_pcSrvPart\n   string is the empty string,\
    \ \"\", i.e.  not NULL. If pcSrvURL is not a\n   service:  URL, then the s_pcSrvType\
    \ field in the returned data\n   structure is the URL's scheme, which might not\
    \ be the same as the\n   service type under which the URL was registered.  If\
    \ the transport is\n   IP, the s_pcTransport field is the empty string.  If the\
    \ transport is\n   not IP or there is no port number, the s_iPort field is zero.\n"
- title: 4.6.3.3. Parameters
  contents:
  - "4.6.3.3. Parameters\n      pcSrvURL\n         A pointer to a character buffer\
    \ containing the null terminated\n         URL string to parse.  It is destructively\
    \ modified to produce\n         the output structure.\n      ppSrvURL\n      \
    \   A pointer to a pointer for the SLPSrvURL structure to receive\n         the\
    \ parsed URL. The memory should be freed by a call to\n         SLPFree() when\
    \ no longer needed.\n"
- title: 4.6.3.4. Returns
  contents:
  - "4.6.3.4. Returns\n   If no error occurs, the return value is SLP_OK. Otherwise,\
    \ the\n   appropriate error code is returned.\n"
- title: 4.6.4. SLPEscape
  contents:
  - '4.6.4. SLPEscape

    '
- title: 4.6.4.1. Synopsis
  contents:
  - "4.6.4.1. Synopsis\n   SLPError SLPEscape(const char* pcInbuf,\n             \
    \         char** ppcOutBuf,\n                      SLPBoolean isTag);\n"
- title: 4.6.4.2. Description
  contents:
  - "4.6.4.2. Description\n   Process the input string in pcInbuf and escape any SLP\
    \ reserved\n   characters.  If the isTag parameter is SLPTrue, then look for bad\
    \ tag\n   characters and signal an error if any are found by returning the\n \
    \  SLP_PARSE_ERROR code.  The results are put into a buffer allocated by\n   the\
    \ API library and returned in the ppcOutBuf parameter.  This buffer\n   should\
    \ be deallocated using SLPFree() when the memory is no longer\n   needed.\n"
- title: 4.6.4.3. Parameters
  contents:
  - "4.6.4.3. Parameters\n      pcInbuf\n         Pointer to he input buffer to process\
    \ for escape characters.\n      ppcOutBuf\n         Pointer to a pointer for the\
    \ output buffer with the SLP\n         reserved characters escaped.  Must be freed\
    \ using SLPFree()\n         when the memory is no longer needed.\n      isTag\n\
    \         When true, the input buffer is checked for bad tag characters.\n"
- title: 4.6.4.4. Returns
  contents:
  - "4.6.4.4. Returns\n   Return SLP_PARSE_ERROR if any characters are bad tag characters\
    \ and\n   the isTag flag is true, otherwise SLP_OK, or the appropriate error\n\
    \   code if another error occurs.\n"
- title: 4.6.5. SLPUnescape
  contents:
  - '4.6.5. SLPUnescape

    '
- title: 4.6.5.1. Synopsis
  contents:
  - "4.6.5.1. Synopsis\n   SLPError SLPUnescape(const char* pcInbuf,\n           \
    \             char** ppcOutBuf,\n                        SLPBoolean isTag);\n"
- title: 4.6.5.2. Description
  contents:
  - "4.6.5.2. Description\n   Process the input string in pcInbuf and unescape any\
    \ SLP reserved\n   characters.  If the isTag parameter is SLPTrue, then look for\
    \ bad tag\n   characters and signal an error if any are found with the\n   SLP_PARSE_ERROR\
    \ code.  No transformation is performed if the input\n   string is an opaque.\
    \  The results are put into a buffer allocated by\n   the API library and returned\
    \ in the ppcOutBuf parameter.  This buffer\n   should be deallocated using SLPFree()\
    \ when the memory is no longer\n   needed.\n"
- title: 4.6.5.3. Parameters
  contents:
  - "4.6.5.3. Parameters\n      pcInbuf\n         Pointer to he input buffer to process\
    \ for escape characters.\n      ppcOutBuf\n         Pointer to a pointer for the\
    \ output buffer with the SLP\n         reserved characters escaped.  Must be freed\
    \ using SLPFree()\n         when the memory is no longer needed.\n      isTag\n\
    \         When true, the input buffer is checked for bad tag characters.\n"
- title: 4.6.5.4. Returns
  contents:
  - "4.6.5.4. Returns\n   Return SLP_PARSE_ERROR if any characters are bad tag characters\
    \ and\n   the isTag flag is true, otherwise SLP_OK, or the appropriate error\n\
    \   code if another error occurs.\n"
- title: 4.6.6. SLPFree
  contents:
  - '4.6.6. SLPFree

    '
- title: 4.6.6.1. Synopsis
  contents:
  - "4.6.6.1. Synopsis\n      void SLPFree(void* pvMem);\n"
- title: 4.6.6.2. Description
  contents:
  - "4.6.6.2. Description\n   Frees memory returned from SLPParseSrvURL(), SLPFindScopes(),\n\
    \   SLPEscape(), and SLPUnescape().\n"
- title: 4.6.6.3. Parameters
  contents:
  - "4.6.6.3. Parameters\n      pvMem\n         A pointer to the storage allocated\
    \ by the SLPParseSrvURL(),\n         SLPEscape(), SLPUnescape(), or SLPFindScopes()\
    \ function.\n         Ignored if NULL.\n"
- title: 4.6.7. SLPGetProperty
  contents:
  - '4.6.7. SLPGetProperty

    '
- title: 4.6.7.1. Synopsis
  contents:
  - "4.6.7.1. Synopsis\n   const char* SLPGetProperty(const char* pcName);\n"
- title: 4.6.7.2. Description
  contents:
  - "4.6.7.2. Description\n   Returns the value of the corresponding SLP property\
    \ name.  The\n   returned string is owned by the library and MUST NOT be freed.\n"
- title: 4.6.7.3. Parameters
  contents:
  - "4.6.7.3. Parameters\n      pcName\n         Null terminated string with the property\
    \ name, from\n         Section 2.1.\n"
- title: 4.6.7.4. Returns
  contents:
  - "4.6.7.4. Returns\n   If no error, returns a pointer to a character buffer containing\
    \ the\n   property value.  If the property was not set, returns the default\n\
    \   value.  If an error occurs, returns NULL. The returned string MUST\n   NOT\
    \ be freed.\n"
- title: 4.6.8. SLPSetProperty
  contents:
  - '4.6.8. SLPSetProperty

    '
- title: 4.6.8.1. Synopsis
  contents:
  - "4.6.8.1. Synopsis\n      void SLPSetProperty(const char *pcName,\n          \
    \                const char *pcValue);\n"
- title: 4.6.8.2. Description
  contents:
  - "4.6.8.2. Description\n   Sets the value of the SLP property to the new value.\
    \  The pcValue\n   parameter should be the property value as a string.\n"
- title: 4.6.8.3. Parameters
  contents:
  - "4.6.8.3. Parameters\n      pcName\n         Null terminated string with the property\
    \ name, from\n         Section 2.1.\n      pcValue\n         Null terminated string\
    \ with the property value, in UTF-8\n         character encoding.\n"
- title: 4.7. Implementation Notes
  contents:
  - '4.7. Implementation Notes

    '
- title: 4.7.1. Refreshing Registrations
  contents:
  - "4.7.1. Refreshing Registrations\n   Clients indicate that they want URLs to be\
    \ automatically refreshed by\n   setting the usLifetime parameter in the SLPReg()\
    \ function call to\n   SLP_LIFETIME_MAXIMUM. This will cause the API implementation\
    \ to\n   refresh the URL before it times out.  Although using\n   SLP_LIFETIME_MAXIMUM\
    \ to designate automatic reregistration means that\n   a transient URL can't be\
    \ registered for the maximum lifetime, little\n   hardship is likely to occur,\
    \ since service URL lifetimes are measured\n   in seconds and the client can simply\
    \ use a lifetime of\n   SLP_LIFETIME_MAXIMUM - 1 if a transient URL near the maximum\
    \ lifetime\n   is desired.  API implementations MUST provide this facility.\n"
- title: 4.7.2. Syntax for String Parameters
  contents:
  - "4.7.2. Syntax for String Parameters\n   Query strings, attribute registration\
    \ lists, attribute deregistration\n   lists, scope lists, and attribute selection\
    \ lists follow the syntax\n   described in [7] for the appropriate requests. \
    \ The API directly\n   reflects the strings passed in from clients into protocol\
    \ requests,\n   and directly reflects out strings returned from protocol replies\
    \ to\n   clients.  As a consequence, clients are responsible for formatting\n\
    \   request strings, including escaping and converting opaque values to\n   escaped\
    \ byte encoded strings.  Similarly, on output, clients are\n   required to unescape\
    \ strings and convert escaped string encoded\n   opaques to binary.  The functions\
    \ SLPEscape() and SLPUnescape() can\n   be used for escaping SLP reserved characters,\
    \ but perform no opaque\n   processing.\n   Opaque values consist of a character\
    \ buffer containing a UTF-8-\n   encoded string, the first characters of which\
    \ are the nonUTF-8\n   encoding '\\ff'.  Subsequent characters are the escaped\
    \ values for the\n   original bytes in the opaque.  The escape convention is relatively\n\
    \   simple.  An escape consists of a backslash followed by the two\n   hexadecimal\
    \ digits encoding the byte.  An example is '\\2c' for the\n   byte 0x2c.  Clients\
    \ handle opaque processing themselves, since the\n   algorithm is relatively simple\
    \ and uniform.\n"
- title: 4.7.3. Client Side Syntax Checking
  contents:
  - "4.7.3. Client Side Syntax Checking\n   Client side API implementations may do\
    \ syntax checking of scope\n   names, naming authority names, and service type\
    \ names, but are not\n   required to do so.  Since the C API is designed to be\
    \ a thin layer\n   over the protocol, some low memory SA implementations may find\n\
    \   extensive syntax checking on the client side to be burdensome.  If\n   syntax\
    \ checking uncovers an error in a parameter, the\n   SLP_PARAMETER_BAD error must\
    \ be returned.  If any parameter is NULL\n   and is required to be nonNULL, SLP_PARAMETER_BAD\
    \ is returned.\n"
- title: 4.7.4. System Properties
  contents:
  - "4.7.4. System Properties\n   The system properties established in the configuration\
    \ file are\n   accessible through the SLPGetProperty() and SLPSetProperty()\n\
    \   functions.  The SLPSetProperty() function only modifies properties in\n  \
    \ the running process, not in the configuration file.  Properties are\n   global\
    \ to the process, affecting all threads and all handles created\n   with SLPOpen.\
    \  Errors are checked when the property is used and, as\n   with parsing the configuration\
    \ file, are logged.  Program execution\n   continues without interruption by substituting\
    \ the default for the\n   erroneous parameter.  With the exception of net.slp.locale,\n\
    \   net.slp.typeHint, and net.slp.maxResults, clients of the API should\n   rarely\
    \ be required to override these properties, since they reflect\n   properties\
    \ of the SLP network that are not of concern to individual\n   agents.  If changes\
    \ are required, system administrators should modify\n   the configuration file.\n"
- title: 4.7.5. Memory Management
  contents:
  - "4.7.5. Memory Management\n   The only API functions returning memory specifically\
    \ requiring\n   deallocation on the part of the client are SLPParseSrvURL(),\n\
    \   SLPFindScopes(), SLPEscape(), and SLPUnescape().  This memory should\n   be\
    \ freed using SLPFree() when no longer needed.  Character strings\n   returned\
    \ via the SLPGetProperty() function should NOT be freed, they\n   are owned by\
    \ the SLP library.\n   Memory passed to callbacks belongs to the library and MUST\
    \ NOT be\n   retained by the client code.  Otherwise, crashes are possible.\n\
    \   Clients are required to copy data out of the callback parameters.  No\n  \
    \ other use of the parameter memory in callback parameters is allowed.\n"
- title: 4.7.6. Asynchronous and Incremental Return Semantics
  contents:
  - "4.7.6. Asynchronous and Incremental Return Semantics\n   If a handle parameter\
    \ to an API function was opened asynchronously,\n   API function calls on the\
    \ handle check the other parameters, open the\n   appropriate operation and return\
    \ immediately.  In an error occurs in\n   the process of starting the operation,\
    \ an error code is returned.  If\n   the handle parameter was opened synchronously,\
    \ the API function call\n   blocks until all results are available, and returns\
    \ only after the\n   results are reported through the callback function.  The\
    \ return code\n   indicates whether any errors occurred both starting and during\
    \ the\n   operation.\n   The callback function is called whenever the API library\
    \ has results\n   to report.  The callback code is required to check the error\
    \ code\n   parameter before looking at the other parameters.  If the error code\n\
    \   is not SLP_OK, the other parameters may be invalid.  The API library\n   has\
    \ the option of terminating any outstanding operation on which an\n   error occurs.\
    \  The callback code can similarly indicate that the\n   operation should be terminated\
    \ by passing back SLP_FALSE. Callback\n   functions are not permitted to recursively\
    \ call into the API on the\n   same SLPHandle.  If an attempt is made to recursively\
    \ call into the\n   API, the API function returns SLP_HANDLE_IN_USE. Prohibiting\n\
    \   recursive callbacks on the same handle simplifies implementation of\n   thread\
    \ safe code, since locks held on the handle will not be in place\n   during a\
    \ second outcall on the handle.  On the other hand, it means\n   that handle creation\
    \ should be fairly lightweight so a client program\n   can easily support multiple\
    \ outstanding calls.\n   The total number of results received can be controlled\
    \ by setting the\n   net.slp.maxResults parameter.\n   On the last call to a callback,\
    \ whether asynchronous or synchronous,\n   the status code passed to the callback\
    \ has value SLP_LAST_CALL. There\n   are four reasons why the call can terminate:\n\
    \      DA reply received\n         A reply from a DA has been received and therefore\
    \ nothing more\n         is expected.\n      Multicast terminated\n         The\
    \ multicast convergence time has elapsed and the API library\n         multicast\
    \ code is giving up.\n      Multicast null results\n         Nothing new has been\
    \ received during multicast for a while and\n         the API library multicast\
    \ code is giving up on that (as an\n         optimization).\n      Maximum results\n\
    \         The user has set the net.slp.maxResults property and that\n        \
    \ number of replies has been collected and returned\n"
- title: 4.8. Example
  contents:
  - "4.8. Example\n   This example illustrates how to discover a mailbox.\n   A POP3\
    \ server registers itself with the SLP framework.  The\n   attributes it registers\
    \ are \"USER\", a list of all users whose mail is\n   available through the POP3\
    \ server.\n   The POP3 server code is the following:\n   SLPHandle slph;\n   SLPRegReport\
    \ errCallback = POPRegErrCallback;\n   /* Create an English SLPHandle, asynchronous\
    \ processing. */\n   SLPError err = SLPOpen(\"en\", SLP_TRUE, &slph);\n   if(\
    \ err != SLP_OK ) {\n     /* Deal with error. */\n   }\n   /* Create the service:\
    \ URL and attribute parameters. */\n   const char* surl = \"service:pop3://mail.netsurf.de\"\
    ; /* the URL */\n   const char *pcAttrs = \"(user=zaphod,trillian,roger,marvin)\"\
    \n   /* Perform the registration. */\n   err = SLPReg(slph,\n                surl,\n\
    \                SLP_LIFETIME_DEFAULT,\n                ppcAttrs,\n          \
    \      errCallback,\n                NULL);\n   if (err != SLP_OK ) {\n      /*Deal\
    \ with error.*/\n   }\n   The errCallback reports any errors:\n   void\n   POPRegErrCallback(SLPHandle\
    \ hSLP,\n                     SLPError errCode,\n                     unsigned\
    \ short usLifetime,\n                     void* pvCookie) {\n      if( errCode\
    \ != SLP_OK ) {\n        /* Report error through a dialog, message, etc. */\n\
    \      }\n      /*Use lifetime interval to update periodically. */\n    }\n  \
    \ The POP3 client locates the server for the user with the following\n   code:\n\
    \   /*\n    * The client calls SLPOpen(), exactly as above.\n    */\n   const\
    \ char *pcSrvType   = \"service:pop3\"; /* the service type  */\n   const char\
    \ *pcScopeList = \"default\";      /* the scope         */\n   const char *pcFilter\
    \    = \"(user=roger)\"; /* the search filter */\n   SLPSrvURLCallback srvCallback\
    \ =           /* the callback      */\n                                   POPSrvURLCallback;\n\
    \   err = SLPFindSrvs(slph,\n                     pcSrvType, pcScopeList, pcFilter,\n\
    \                     srvCallback, NULL);\n   if( err != SLP_OK ) {\n       /*\
    \ Deal with error. */\n   }\n   Within the callback, the client code can use the\
    \ returned POP\n   service:\n  SLPBoolean\n  POPSrvURLCallback(SLPHandle hSLP,\n\
    \                    const char* pcSrvURL,\n                    unsigned short\
    \ sLifetime,\n                    SLPError errCode,\n                    void*\
    \ pvCookie) {\n     if( errCode != SLP_OK ) {\n        /* Deal with error. */\n\
    \     }\n     SLPSrvURL* pSrvURL;\n     errCode = SLPParseSrvURL(pcSrvURL, &pSrvURL);\n\
    \     if (err != SLP_OK ) {\n       /* Deal with error. */\n     } else {\n  \
    \     /* get the server's address */\n       struct hostent *phe = gethostbyname(pSrvURL.s_pcHost);\n\
    \       /* use hostname in pSrvURL to connect to the POP3 server\n        *  \
    \   . . .\n        */\n       SLPFreeSrvURL((void*)pSrvURL);  /* Free the pSrvURL\
    \ storage */\n     }\n     return SLP_FALSE;                 /* Done! */\n   }\n\
    \   A client that wanted to discover all the users receiving mail at the\n   server\
    \ uses with the following query:\n   /*\n    * The client calls SLPOpen(), exactly\
    \ as above. We assume the\n    * service: URL was retrieved into surl.\n    */\n\
    \   const char *pcScopeList = \"default\";      /* the scope            */\n \
    \  const char *pcAttrFilter    = \"use\";      /* the attribute filter */\n  \
    \ SLPAttrCallback attrCallBack =            /* the callback         */\n     \
    \                             POPUsersCallback\n   err =\n     SLPFindAttrs(slph,\n\
    \                  surl,\n                  pcScopeList, pcAttrFilter,\n     \
    \             attrCallBack, NULL);\n   if( err != SLP_OK ) {\n        /* Deal\
    \ with error. */\n   }\n   The callback processes the attributes:\n   SLPBoolean\n\
    \   POPUsersCallback(const char* pcAttrList,\n                    SLPError errCode,\n\
    \                    void* pvCookie) {\n     if( errCode != SLP_OK ) {\n     \
    \  /* Deal with error. */\n     } else {\n       /* Parse attributes. */\n   \
    \  }\n     return SLP_FALSE;  /* Done! */\n   }\n"
- title: 5. Java Language Binding
  contents:
  - '5. Java Language Binding

    '
- title: 5.1. Introduction
  contents:
  - "5.1. Introduction\n   The Java API is designed to model the various SLP entities\
    \ in classes\n   and objects.  APIs are provided for SA, UA, and service type\
    \ template\n   access capabilities.  The ServiceLocationManager class contains\n\
    \   methods that return instances of objects implementing SA and UA\n   capability.\
    \  Each of these is modeled in an interface.  The Locator\n   interface provides\
    \ UA capability and the Advertiser interface\n   provides SA capability.  The\
    \ TemplateRegistry abstract class contains\n   methods that return objects for\
    \ template introspection and attribute\n   type checking.  The ServiceURL, ServiceType,\
    \ and\n   ServiceLocationAttribute classes model the basic SLP concepts.  A\n\
    \   concrete subclass instance of TemplateRegistry is returned by a class\n  \
    \ method.\n   All SLP classes and interfaces are located within a single package.\n\
    \   The package name should begin with the name of the implementation and\n  \
    \ conclude with the suffix \"slp\".  Thus, the name for a hypothetical\n   implementation\
    \ from the University of Michigan would look like:\n                         \
    \    edu.umich.slp\n   This follows the Java convention of prepending the top\
    \ level DNS\n   domain name for the organization implementing the package onto\
    \ the\n   organization's name and using that as the package prefix.\n"
- title: 5.2. Exceptions and Errors
  contents:
  - "5.2. Exceptions and Errors\n   Most parameters to API methods are required to\
    \ be non-null.  The API\n   description indicates if a null parameter is acceptable,\
    \ or if other\n   restrictions constrain a parameter.  When parameters are checked\
    \ for\n   validity (such as not being null) or their syntax is checked, an\n \
    \  error results in the RuntimeException subclass\n   IllegalArgumentException\
    \ being thrown.  Clients of the API are\n   reminded that IllegalArgumentException,\
    \ derived from\n   RuntimeException, is unchecked by the compiler.  Clients should\
    \ thus\n   be careful to include try/catch blocks for it if the relevant\n   parameters\
    \ could be erroneous.\n   Standard Java practice is to encode every exceptional\
    \ condition as a\n   separate subclass of Exception.  Because of the relatively\
    \ high cost\n   in code size of Exception subclasses, the API contains only a\
    \ single\n   Exception subclass with different conditions being determined by\
    \ an\n   integer error code property.  A subset, appropriate to Java, of the\n\
    \   error codes described in Section 3 are available as constants on the\n   ServiceLocationException\
    \ class.  The subset excludes error codes such\n   as MEMORY_ALLOC_FAILED.\n"
- title: 5.2.1. Class ServiceLocationException
  contents:
  - '5.2.1. Class ServiceLocationException

    '
- title: 5.2.1.1. Synopsis
  contents:
  - "5.2.1.1. Synopsis\n   public class ServiceLocationException\n   extends Exception\n"
- title: 5.2.1.2. Description
  contents:
  - "5.2.1.2. Description\n   The ServiceLocationException class is thrown by all\
    \ methods when\n   exceptional conditions occur in the SLP framework.  The error\
    \ code\n   property determines the exact nature of the condition, and an\n   optional\
    \ message may provide more information.\n"
- title: 5.2.1.3. Fields
  contents:
  - "5.2.1.3. Fields\n   public static final short LANGUAGE_NOT_SUPPORTED = 1\n  \
    \ public static final short PARSE_ERROR = 2\n   public static final short INVALID_REGISTRATION\
    \ = 3\n   public static final short SCOPE_NOT_SUPPORTED = 4\n   public static\
    \ final short AUTHENTICATION_ABSENT = 6\n   public static final short AUTHENTICATION_FAILED\
    \ = 7\n   public static final short INVALID_UPDATE = 13\n   public static final\
    \ short REFRESH_REJECTED = 15\n   public static final short NOT_IMPLEMENTED =\
    \ 16\n   public static final short NETWORK_INIT_FAILED 17\n   public static final\
    \ short NETWORK_TIMED_OUT = 18\n   public static final short NETWORK_ERROR = 19\n\
    \   public static final short INTERNAL_SYSTEM_ERROR = 20\n   public static final\
    \ short TYPE_ERROR = 21\n   public static final short BUFFER_OVERFLOW = 22\n"
- title: 5.2.1.4. Instance Methods
  contents:
  - "5.2.1.4. Instance Methods\n   public short getErrorCode()\n   Return the error\
    \ code.  The error code takes on one of the static\n   field values.\n"
- title: 5.3. Basic Data Structures
  contents:
  - '5.3. Basic Data Structures

    '
- title: 5.3.1. Interface ServiceLocationEnumeration
  contents:
  - "5.3.1. Interface ServiceLocationEnumeration\n   public interface ServiceLocationEnumeration\n\
    \    extends Enumeration\n"
- title: 5.3.1.1. Description
  contents:
  - "5.3.1.1. Description\n   The ServiceLocationEnumeration class is the return type\
    \ for all\n   Locator SLP operations.  The Java API library may implement this\n\
    \   class to block until results are available from the SLP operation, so\n  \
    \ that the client can achieve asynchronous operation by retrieving\n   results\
    \ from the enumeration in a separate thread.  Clients use the\n   superclass nextElement()\
    \ method if they are unconcerned with SLP\n   exceptions.\n"
- title: 5.3.1.2. Instance Methods
  contents:
  - "5.3.1.2. Instance Methods\n   public abstract Object next() throws ServiceLocationException\n\
    \   Return the next value or block until it becomes available.\n   Throws:\n \
    \     ServiceLocationException\n         Thrown if the SLP operation encounters\
    \ an error.\n      NoSuchElementException\n         If there are no more elements\
    \ to return.\n"
- title: 5.3.2. Class ServiceLocationAttribute
  contents:
  - '5.3.2. Class ServiceLocationAttribute

    '
- title: 5.3.2.1. Synopsis
  contents:
  - "5.3.2.1. Synopsis\n   public class ServiceLocationAttribute\n     extends Object\
    \ implements Serializable\n"
- title: 5.3.2.2. Description
  contents:
  - "5.3.2.2. Description\n   The ServiceLocationAttribute class models SLP attributes.\
    \  Instances\n   of this class are returned by Locator.findAttributes() and are\n\
    \   communicated along with register/deregister requests.\n"
- title: 5.3.2.3. Constructors
  contents:
  - "5.3.2.3. Constructors\n   public ServiceLocationAttribute(String id,Vector values)\n\
    \   Construct a service location attribute.  Errors in the id or values\n   vector\
    \ result in an IllegalArgumentException.\n   Parameters:\n      id\n         The\
    \ attribute name.  The String can consist of any Unicode\n         character.\n\
    \      values\n         A Vector of one or more attribute values.  Vector contents\n\
    \         must be uniform in type and one of Integer, String, Boolean,\n     \
    \    or byte[].  If the attribute is a keyword attribute, then the\n         parameter\
    \ should be null.  String values can consist of any\n         Unicode character.\n"
- title: 5.3.2.4. Class Methods
  contents:
  - "5.3.2.4. Class Methods\n   public static String escapeId(String id)\n   Returns\
    \ an escaped version of the id parameter, suitable for\n   inclusion in a query.\
    \  Any reserved characters as specified in [7]\n   are escaped using UTF-8 encoding.\
    \  If any characters in the tag are\n   illegal, throws IllegalArgumentException.\n\
    \   Parameters:\n      id\n         The attribute id to escape.  ServiceLocationException\
    \ is thrown\n         if any characters are illegal for an attribute tag.\n  \
    \ public static String escapeValue(Object value)\n   Returns a String containing\
    \ the escaped value parameter as a string,\n   suitable for inclusion in a query.\
    \  If the parameter is a string,\n   any reserved characters as specified in [7]\
    \ are escaped using UTF-8\n   encoding.  If the parameter is a byte array, then\
    \ the escaped string\n   begins with the nonUTF-8 sequence `\\ff` and the rest\
    \ of the string\n   consists of the escaped bytes, which is the encoding for opaques.\n\
    \   If the value parameter is a Boolean or Integer, then the returned\n   string\
    \ contains the object converted into a string.  If the value\n   is any type other\
    \ than String, Integer, Boolean or byte[], an\n   IllegalArgumentException is\
    \ thrown.\n   Parameters:\n      value\n         The attribute value to be converted\
    \ into a string and escaped.\n"
- title: 5.3.2.5. Instance Methods
  contents:
  - "5.3.2.5. Instance Methods\n   public Vector getValues()\n   Returns a cloned\
    \ vector of attribute values, or null if the attribute\n   is a keyword attribute.\
    \  If the attribute is single-valued, then the\n   vector contains only one object.\n\
    \   public String getId()\n   Returns the attribute's name.\n   public boolean\
    \ equals(Object o)\n   Overrides Object.equals().  Two attributes are equal if\
    \ their\n   identifiers are equal and their value vectors contain the same number\n\
    \   of equal values as determined by the Object equals() method.  Values\n   having\
    \ byte[] type are equal if the contents of all byte arrays in\n   both attribute\
    \ vectors match.  Note that the SLP string matching\n   algorithm [7] MUST NOT\
    \ be used for comparing attribute identifiers or\n   string values.\n   public\
    \ String toString()\n   Overrides Object.toString().  The string returned contains\
    \ a\n   formatted representation of the attribute, giving the attribute's\n  \
    \ id, values, and the Java type of the values.  The returned string is\n   suitable\
    \ for debugging purposes, but is not in SLP wire format.\n   public int hashCode()\n\
    \   Overrides Object.hashCode().  Hashes on the attribute's identifier.\n"
- title: 5.3.3. Class ServiceType
  contents:
  - '5.3.3. Class ServiceType

    '
- title: 5.3.3.1. Synopsis
  contents:
  - "5.3.3.1. Synopsis\n   public class ServiceType extends Object implements Serializable\n"
- title: 5.3.3.2. Description
  contents:
  - "5.3.3.2. Description\n   The ServiceType object models the SLP service type.\
    \  It parses a\n   string based service type specifier into its various components,\
    \ and\n   contains property accessors to return the components.  URL schemes,\n\
    \   protocol service types, and abstract service types are all handled.\n"
- title: 5.3.3.3. Constructors
  contents:
  - "5.3.3.3. Constructors\n   public ServiceType(String type)\n   Construct a service\
    \ type object from the service type specifier.\n   Throws IllegalArgumentException\
    \ if the type name is syntactically\n   incorrect.\n   Parameters:\n      type\n\
    \         The service type name as a String.  If the service type is from\n  \
    \       a service:  URL, the \"service:\" prefix must be intact.\n"
- title: 5.3.3.4. Methods
  contents:
  - "5.3.3.4. Methods\n   public boolean isServiceURL()\n   Returns true if the type\
    \ name contains the \"service:\" prefix.\n   public boolean isAbstractType()\n\
    \   Returns true if the type name is for an abstract type.\n   public boolean\
    \ isNADefault()\n   Returns true if the naming authority is the default, i.e.\
    \  is the\n   empty string.\n   public String getConcreteTypeName()\n   Returns\
    \ the concrete type name in an abstract type, or the empty\n   string if the service\
    \ type is not abstract.  For example, if the type\n   name is \"service:printing:ipp\"\
    , the method returns \"ipp\".  If the\n   type name is \"service:ftp\", the method\
    \ returns \"\".\n   public String getPrincipleTypeName()\n   Returns the abstract\
    \ type name for an abstract type, the protocol\n   name in a protocol type, or\
    \ the URL scheme for a generic URL. For\n   example, in the abstract type name\
    \ \"service:printing:ipp\", the method\n   returns \"printing\".  In the protocol\
    \ type name \"service:ftp\", the\n   method returns \"ftp\".\n   public String\
    \ getAbstractTypeName()\n   If the type is an abstract type, returns the fully\
    \ formatted abstract\n   type name including the \"service:\" and naming authority\
    \ but without\n   the concrete type name or intervening colon.  If not an abstract\n\
    \   type, returns the empty string.  For example, in the abstract type\n   name\
    \ \"service:printing:ipp\", the method returns \"service:printing\".\n   public\
    \ String getNamingAuthority()\n   Return the naming authority name, or the empty\
    \ string if the naming\n   authority is the default.\n   public boolean equals(Object\
    \ obj)\n   Overrides Object.equals().  The two objects are equal if they are\n\
    \   both ServiceType objects and the components of both are equal.\n   public\
    \ String toString()\n   Returns the fully formatted type name, including the \"\
    service:\" if\n   the type was originally from a service:  URL.\n   public int\
    \ hashCode()\n   Overrides Object.hashCode().  Hashes on the string value of the\n\
    \   \"service\" prefix, naming authority, if any, abstract and concrete\n   type\
    \ names for abstract types, protocol type name for protocol types,\n   and URL\
    \ scheme for generic URLs.\n"
- title: 5.3.4. Class ServiceURL
  contents:
  - '5.3.4. Class ServiceURL

    '
- title: 5.3.4.1. Synopsis
  contents:
  - "5.3.4.1. Synopsis\n   public class ServiceURL extends Object implements Serializable\n"
- title: 5.3.4.2. Description
  contents:
  - "5.3.4.2. Description\n   The ServiceURL object models the advertised SLP service\
    \ URL. It can\n   be either a service:  URL or a regular URL. These objects are\n\
    \   returned from service lookup requests, and describe the registered\n   services.\
    \  This class should be a subclass of java.net.URL but can't\n   since that class\
    \ is final.\n"
- title: 5.3.4.3. Class Variables
  contents:
  - "5.3.4.3. Class Variables\n   public static final int NO_PORT = 0\n   Indicates\
    \ that no port information is required or was returned for\n   this URL.\n   public\
    \ static final int LIFETIME_NONE = 0\n   Indicates that the URL has a zero lifetime.\
    \  This value is never\n   returned from the API, but can be used to create a\
    \ ServiceURL object\n   to deregister, delete attributes, or find attributes.\n\
    \   public static final int LIFETIME_DEFAULT = 10800\n   The default URL lifetime\
    \ (3 hours) in seconds.\n   public static final int LIFETIME_MAXIMUM = 65535\n\
    \   The maximum URL lifetime (about 18 hours) in seconds.\n   public static final\
    \ int LIFETIME_PERMANENT = -1\n   Indicates that the API implementation should\
    \ continuously re-register\n   the URL until the application exits.\n"
- title: 5.3.4.4. Constructors
  contents:
  - "5.3.4.4. Constructors\n   public ServiceURL(String URL,int lifetime)\n   Construct\
    \ a service URL object having the specified lifetime.\n   Parameters:\n      URL\n\
    \         The URL as a string.  Must be either a service:  URL or a valid\n  \
    \       generic URL according to RFC 2396 [2].\n      lifetime\n         The service\
    \ advertisement lifetime in seconds.  This value may\n         be between LIFETIME_NONE\
    \ and LIFETIME_MAXIMUM.\n"
- title: 5.3.4.5. Methods
  contents:
  - "5.3.4.5. Methods\n   public ServiceType getServiceType()\n   Returns the service\
    \ type object representing the service type name of\n   the URL.\n  public final\
    \ void setServiceType(ServiceType type)\n  throws ServiceLocationException\n \
    \  Set the service type name to the object.  Ignored if the URL is a\n   service:\
    \  URL.\n   Parameters:\n      type\n         The service type object.\n   public\
    \ String getTransport()\n   Get the network layer transport identifier.  If the\
    \ transport is IP,\n   an empty string, \"\", is returned.\n   public String getHost()\n\
    \   Returns the host identifier.  For IP, this will be the machine name\n   or\
    \ IP address.\n   public int getPort()\n   Returns the port number, if any.  For\
    \ non-IP transports, always\n   returns NO_PORT.\n   public String getURLPath()\n\
    \   Returns the URL path description, if any.\n   public int getLifetime()\n \
    \  Returns the service advertisement lifetime.  This will be a positive\n   int\
    \ between LIFETIME_NONE and LIFETIME_MAXIMUM.\n   public boolean equals(Object\
    \ obj)\n   Compares the object to the ServiceURL and returns true if the two are\n\
    \   the same.  Two ServiceURL objects are equal if their current service\n   types\
    \ match and they have the same host, port, transport, and URL\n   path.\n   public\
    \ String toString()\n   Returns a formatted string with the URL. Overrides Object.toString().\n\
    \   The returned URL has the original service type or URL scheme, not the\n  \
    \ current service type.\n   public int hashCode()\n   Overrides Object.hashCode().\
    \  Hashes on the current service type,\n   transport, host, port, and URL part.\n"
- title: 5.4. SLP Access Interfaces
  contents:
  - '5.4. SLP Access Interfaces

    '
- title: 5.4.1. Interface Advertiser
  contents:
  - '5.4.1. Interface Advertiser

    '
- title: 5.4.1.1. Synopsis
  contents:
  - "5.4.1.1. Synopsis\n   public interface Advertiser\n"
- title: 5.4.1.2. Description
  contents:
  - "5.4.1.2. Description\n   The Advertiser is the SA interface, allowing clients\
    \ to register new\n   service instances with SLP, to change the attributes of\
    \ existing\n   services, and to deregister service instances.  New registrations\
    \ and\n   modifications of attributes are made in the language locale with\n \
    \  which the Advertiser was created, deregistrations of service\n   instances\
    \ are made for all locales.\n"
- title: 5.4.1.3. Instance Methods
  contents:
  - "5.4.1.3. Instance Methods\n   public abstract Locale getLocale()\n   Return the\
    \ language locale with which this object was created.\n   public abstract void\
    \ register(ServiceURL URL,\n                                 Vector attributes)\n\
    \   throws ServiceLocationException\n   Register a new service with SLP having\
    \ the given attributes.\n   The API library is required to perform the operation\
    \ in all\n   scopes obtained through configuration.\n   Parameters:\n      URL\n\
    \         The URL for the service.\n      attributes\n         A vector of ServiceLocationAttribute\
    \ objects describing the\n         service.\n   public abstract void deregister(ServiceURL\
    \ URL)\n   throws ServiceLocationException\n   Deregister a service from the SLP\
    \ framework.  This has the effect\n   of deregistering the service from every\
    \ language locale.  The API\n   library is required to perform the operation in\
    \ all scopes obtained\n   through configuration.\n   Parameters:\n      URL\n\
    \         The URL for the service.\n   public abstract void\n   addAttributes(ServiceURL\
    \ URL,\n                 Vector attributes)\n   throws ServiceLocationException\n\
    \   Update the registration by adding the given attributes.  The API\n   library\
    \ is required to perform the operation in all scopes obtained\n   through configuration.\n\
    \   Parameters:\n      URL\n         The URL for the service.\n      attributes\n\
    \         A Vector of ServiceLocationAttribute objects to add to the\n       \
    \  existing registration.  Use an empty vector to update the URL\n         alone.\
    \  May not be null.\n   public abstract void\n   deleteAttributes(ServiceURL URL,\n\
    \                    Vector attributeIds)\n   throws ServiceLocationException\n\
    \   Delete the attributes from a URL for the locale with which the\n   Advertiser\
    \ was created.  The API library is required to perform the\n   operation in all\
    \ scopes obtained through configuration.\n   Parameters:\n      URL\n        \
    \ The URL for the service.\n      attributeIds\n         A vector of Strings indicating\
    \ the ids of the attributes\n         to remove.  The strings may be attribute\
    \ ids or they\n         may be wildcard patterns to match ids.  See [7] for the\n\
    \         syntax of wildcard patterns.  The strings may include SLP\n        \
    \ reserved characters, they will be escaped by the API before\n         transmission.\
    \  May not be the empty vector or null.\n"
- title: 5.4.2. Interface Locator
  contents:
  - '5.4.2. Interface Locator

    '
- title: 5.4.2.1. Synopsis
  contents:
  - "5.4.2.1. Synopsis\n   public interface Locator\n"
- title: 5.4.2.2. Description
  contents:
  - "5.4.2.2. Description\n   The Locator is the UA interface, allowing clients to\
    \ query the SLP\n   framework about existing service types, services instances,\
    \ and about\n   the attributes of an existing service instance or service type.\n\
    \   Queries for services and attributes are made in the locale with which\n  \
    \ the Locator was created, queries for service types are independent of\n   locale.\n"
- title: 5.4.2.3. Instance Methods
  contents:
  - "5.4.2.3. Instance Methods\n   public abstract Locale getLocale()\n   Return the\
    \ language locale with which this object was created.\n   public abstract ServiceLocationEnumeration\n\
    \   findServiceTypes(String namingAuthority,\n                    Vector scopes)\n\
    \   throws ServiceLocationException\n   Returns an enumeration of ServiceType\
    \ objects giving known service\n   types for the given scopes and given naming\
    \ authority.  If no service\n   types are found, an empty enumeration is returned.\n\
    \   Parameters:\n      namingAuthority\n         The naming authority.  Use \"\
    \" for the default naming authority\n         and \"*\" for all naming authorities.\n\
    \      scopes\n         A Vector of scope names.  The vector should be selected\
    \ from\n         the results of a findScopes() API invocation.  Use \"DEFAULT\"\
    \n         for the default scope.\n   public abstract ServiceLocationEnumeration\n\
    \   findServices(ServiceType type,\n                Vector scopes,\n         \
    \       String searchFilter)\n   throws ServiceLocationException\n   Returns a\
    \ vector of ServiceURL objects for services matching the\n   query, and having\
    \ a matching type in the given scopes.  If no\n   services are found, an empty\
    \ enumeration is returned.\n   Parameters:\n      type\n         The SLP service\
    \ type of the service.\n      scopes\n         A Vector of scope names.  The vector\
    \ should be selected from\n         the results of a findScopes() API invocation.\
    \  Use \"DEFAULT\"\n         for the default scope.\n      searchFilter\n    \
    \     An LDAPv3 [4] string encoded query.  If the filter is empty,\n         i.e.\
    \  \"\", all services of the requested type in the specified\n         scopes\
    \ are returned.  SLP reserved characters must be escaped\n         in the query.\
    \  Use ServiceLocationAttribute.escapeId() and\n         ServiceLocationAttribute.escapeValue()\
    \ to construct the query.\n   public abstract ServiceLocationEnumeration\n   findAttributes(ServiceURL\
    \ URL,\n                  Vector scopes,\n                  Vector attributeIds)\n\
    \   throws ServiceLocationException\n   For the URL and scope, return a Vector\
    \ of ServiceLocationAttribute\n   objects whose ids match the String patterns\
    \ in the attributeIds\n   Vector.  The request is made in the language locale\
    \ of the Locator.\n   If no attributes match, an empty enumeration is returned.\n\
    \   Parameters:\n      URL\n         The URL for which the attributes are desired.\n\
    \      scopes\n         A Vector of scope names.  The vector should be selected\
    \ from\n         the results of a findScopes() API invocation.  Use \"DEFAULT\"\
    \n         for the default scope.\n      attributeIds\n         A Vector of String\
    \ patterns identifying the desired attributes.\n         An empty vector means\
    \ return all attributes.  As described\n         in [7], the patterns may include\
    \ wildcards to match substrings.\n         The strings may include SLP reserved\
    \ characters, they will be\n         escaped by the API before transmission.\n\
    \   public abstract ServiceLocationEnumeration\n   findAttributes(ServiceType\
    \ type,\n                  Vector scopes,\n                  Vector attributeIds)\n\
    \   throws ServiceLocationException\n   For the type and scope, return a Vector\
    \ of all ServiceLocationAttribute\n   objects whose ids match the String patterns\
    \ in the attributeIds\n   Vector regardless of the Locator's locale.  The request\
    \ is made\n   independent of language locale.  If no attributes are found, an\
    \ empty\n   vector is returned.\n   Parameters:\n      serviceType\n         The\
    \ service type.\n      scopes\n         A Vector of scope names.  The vector should\
    \ be selected from\n         the results of a findScopes() API invocation.  Use\
    \ \"DEFAULT\"\n         for the default scope.\n      attributeIds\n         A\
    \ Vector of String patterns identifying the desired\n         attributes.  An\
    \ empty vector means return all attributes.\n         As described in [7], the\
    \ patterns may include wildcards to\n         match all prefixes or suffixes.\
    \  The patterns may include SLP\n         reserved characters, they will be escaped\
    \ by the API before\n         transmission.\n"
- title: 5.5. The Service Location Manager
  contents:
  - '5.5. The Service Location Manager

    '
- title: 5.5.1. Class ServiceLocationManager
  contents:
  - '5.5.1. Class ServiceLocationManager

    '
- title: 5.5.1.1. Synopsis
  contents:
  - "5.5.1.1. Synopsis\n    public class ServiceLocationManager\n    extends Object\n"
- title: 5.5.1.2. Description
  contents:
  - "5.5.1.2. Description\n   The ServiceLocationManager manages access to the service\
    \ location\n   framework.  Clients obtain the Locator and Advertiser objects for\
    \ UA\n   and SA, and a Vector of known scope names from the\n   ServiceLocationManager.\n"
- title: 5.5.1.3. Class Methods
  contents:
  - "5.5.1.3. Class Methods\n   public static int getRefreshInterval()\n   throws\
    \ ServiceLocationException\n   Returns the maximum across all DAs of the min-refresh-interval\n\
    \   attribute.  This value satisfies the advertised refresh interval\n   bounds\
    \ for all DAs, and, if used by the SA, assures that no\n   refresh registration\
    \ will be rejected.  If no DA advertises a\n   min-refresh-interval attribute,\
    \ a value of 0 is returned.\n   public static Vector findScopes()\n   throws ServiceLocationException\n\
    \   Returns an Vector of strings with all available scope names.  The\n   list\
    \ of scopes comes from a variety of sources, see Section 2.1 for\n   the scope\
    \ discovery algorithm.  There is always at least one string\n   in the Vector,\
    \ the default scope, \"DEFAULT\".\n   public static Locator\n   getLocator(Locale\
    \ locale)\n   throws ServiceLocationException\n   Return a Locator object for\
    \ the given language Locale.  If the\n   implementation does not support UA functionality,\
    \ returns null.\n   Parameters:\n      locale\n         The language locale of\
    \ the Locator.  The default SLP locale is\n         used if null.\n   public static\
    \ Advertiser\n   getAdvertiser(Locale locale)\n   throws ServiceLocationException\n\
    \   Return an Advertiser object for the given language locale.  If the\n   implementation\
    \ does not support SA functionality, returns null.\n   Parameters:\n      locale\n\
    \         The language locale of the Advertiser.  The default SLP locale\n   \
    \      is used if null.\n"
- title: 5.6. Service Template Introspection
  contents:
  - '5.6. Service Template Introspection

    '
- title: 5.6.1. Abstract Class TemplateRegistry
  contents:
  - '5.6.1. Abstract Class TemplateRegistry

    '
- title: 5.6.1.1. Synopsis
  contents:
  - "5.6.1.1. Synopsis\n   public abstract class TemplateRegistry\n"
- title: 5.6.1.2. Description
  contents:
  - "5.6.1.2. Description\n   Subclasses of the TemplateRegistry abstract class provide\
    \ access to\n   service location templates [8].  Classes implementing\n   TemplateRegistry\
    \ perform a variety of functions.  They manage the\n   registration and access\
    \ of service type template documents.  They\n   create attribute verifiers from\
    \ service templates, for verification\n   of attributes and introspection on template\
    \ documents.  Note that\n   clients of the Advertiser are not required to verify\
    \ attributes\n   before registering (though they may get a TYPE_ERROR if the\n\
    \   implementation supports type checking and there is a mismatch with\n   the\
    \ template).\n"
- title: 5.6.1.3. Class Methods
  contents:
  - "5.6.1.3. Class Methods\n   public static TemplateRegistry getTemplateRegistry();\n\
    \   Returns the distinguished TemplateRegistry object for performing\n   operations\
    \ on and with service templates.  Returns null if the\n   implementation doesn't\
    \ support TemplateRegistry functionality.\n"
- title: 5.6.1.4. Instance Methods
  contents:
  - "5.6.1.4. Instance Methods\n   public abstract void\n   registerServiceTemplate(ServiceType\
    \ type,\n                           String documentURL,\n                    \
    \       Locale locale,\n                           String version)\n   throws\
    \ ServiceLocationException\n   Register the service template with the template\
    \ registry.\n   Parameters:\n      type\n         The service type.\n      documentURL\n\
    \         A string containing the URL of the template document.  May not\n   \
    \      be the empty string.\n      locale\n         A Locale object containing\
    \ the language locale of the template.\n      version\n         The version number\
    \ identifier of template document.\n   public abstract void\n   deregisterServiceTemplate(ServiceType\
    \ type,\n                             Locale locale,\n                       \
    \      String version)\n   throws ServiceLocationException\n   Deregister the\
    \ template for the service type.\n   Parameters:\n      type\n         The service\
    \ type.\n      locale\n         A Locale object containing the language locale\
    \ of the template.\n      version\n         A String containing the version number.\
    \  Use null to indicate\n         the latest version.\n   public abstract\n  \
    \ String findTemplateURL(ServiceType type,\n                          Locale locale,\n\
    \                          String version)\n   throws ServiceLocationException\n\
    \   Returns the URL for the template document.\n   Parameters:\n      type\n \
    \        The service type.\n      locale\n         A Locale object containing\
    \ the language locale of the template.\n      version\n         A String containing\
    \ the version number.  Use null to indicate\n         the latest version.\n  \
    \ public abstract\n   ServiceLocationAttributeVerifier\n   attributeVerifier(String\
    \ documentURL)\n   throws ServiceLocationException\n   Reads the template document\
    \ URL and returns an attribute verifier\n   for the service type.  The attribute\
    \ verifier can be used for\n   verifying that registration attributes match the\
    \ template, and for\n   introspection on the template definition.\n   Parameters:\n\
    \      documentURL\n         A String containing the template document's URL.\
    \ May not be the\n         empty string.\n"
- title: 5.6.2. Interface ServiceLocationAttributeVerifier
  contents:
  - '5.6.2. Interface ServiceLocationAttributeVerifier

    '
- title: 5.6.2.1. Synopsis
  contents:
  - "5.6.2.1. Synopsis\n   public interface ServiceLocationAttributeVerifier\n"
- title: 5.6.2.2. Description
  contents:
  - "5.6.2.2. Description\n   The ServiceLocationAttributeVerifier provides access\
    \ to service\n   templates.  Classes implementing this interface parse SLP template\n\
    \   definitions, provide information on attribute definitions for service\n  \
    \ types, and verify whether a ServiceLocationAttribute object matches a\n   template\
    \ for a particular service type.  Clients obtain\n   ServiceLocationAttributeVerifier\
    \ objects for specific SLP service\n   types through the TemplateRegistry.\n"
- title: 5.6.2.3. Instance Methods
  contents:
  - "5.6.2.3. Instance Methods\n   public abstract ServiceType getServiceType()\n\
    \   Returns the SLP service type for which this is the verifier.\n   public abstract\
    \ Locale getLocale()\n   Return the language locale of the template.\n   public\
    \ abstract String getVersion()\n   Return the template version number identifier.\n\
    \   public abstract String getURLSyntax()\n   Return the URL syntax expression\
    \ for the service:  URL.\n   public abstract String getDescription()\n   Return\
    \ the descriptive help text for the template.\n   public abstract ServiceLocationAttributeDescriptor\n\
    \   getAttributeDescriptor(String attrId)\n   Return the ServiceLocationAttributeDescriptor\
    \ for the attribute\n   having the named id.  If no such attribute exists in this\
    \ template,\n   return null.  This method is primarily for GUI tools to display\n\
    \   attribute information.  Programmatic verification of attributes\n   should\
    \ use the verifyAttribute() method.\n   public abstract Enumeration\n   getAttributeDescriptors()\n\
    \   Returns an Enumeration allowing introspection on the attribute\n   definition\
    \ in the service template.  The Enumeration returns\n   ServiceLocationAttributeDescriptor\
    \ objects for the attributes.\n   This method is primarily for GUI tools to display\
    \ attribute\n   information.  Programmatic verification of attributes should use\
    \ the\n   verifyAttribute() method.\n   public abstract void\n   verifyAttribute(\n\
    \     ServiceLocationAttribute attribute)\n   throws ServiceLocationException\n\
    \   Verify that the attribute matches the template definition.  If the\n   attribute\
    \ doesn't match, ServiceLocationException is thrown with the\n   error code as\
    \ ServiceLocationException.PARSE_ERROR.\n   Parameters:\n      attribute\n   \
    \      The ServiceLocationAttribute object to be verified.\n   public abstract\
    \ void\n   verifyRegistration(\n     Vector attributeVector)\n   throws ServiceLocationException\n\
    \   Verify that the Vector of ServiceLocationAttribute objects matches\n   the\
    \ template for this service type.  The vector must contain all the\n   required\
    \ attributes, and all attributes must match their template\n   definitions.  If\
    \ the attributes don't match, ServiceLocationException\n   is thrown with the\
    \ error code as ServiceLocationException.PARSE_ERROR\n   Parameters:\n      attributeVector\n\
    \         A Vector of ServiceLocationAttribute objects for the\n         registration.\n"
- title: 5.6.3. Interface ServiceLocationAttributeDescriptor
  contents:
  - '5.6.3. Interface ServiceLocationAttributeDescriptor

    '
- title: 5.6.3.1. Synopsis
  contents:
  - "5.6.3.1. Synopsis\n   public interface\n   ServiceLocationAttributeDescriptor\n"
- title: 5.6.3.2. Description
  contents:
  - "5.6.3.2. Description\n   The ServiceLocationAttributeDescriptor interface provides\n\
    \   introspection on a template attribute definition.  Classes\n   implementing\
    \ the ServiceLocationAttributeDescriptor interface return\n   information on a\
    \ particular service location attribute definition\n   from the service template.\
    \  This information is primarily for GUI\n   tools.  Programmatic attribute verification\
    \ should be done through\n   the ServiceLocationAttributeVerifier.\n"
- title: 5.6.3.3. Instance Methods
  contents:
  - "5.6.3.3. Instance Methods\n   public abstract String getId()\n   Return a String\
    \ containing the attribute's id.\n   public abstract String getValueType()\n \
    \  Return a String containing the fully package-qualified Java type of\n   the\
    \ attribute.  SLP types are translated into Java types as follows:\n      STRING\n\
    \         \"java.lang.String\"\n      INTEGER\n         \"java.lang.Integer\"\n\
    \      BOOLEAN\n         \"java.lang.Boolean\"\n      OPAQUE\n         \"[B\"\
    \ (i.e.  array of byte, byte[])\n      KEYWORD\n         empty string, \"\"\n\
    \ public abstract String getDescription()\n   Return a String containing the attribute's\
    \ help text.\n   public abstract Enumeration\n   getAllowedValues()\n   Return\
    \ an Enumeration of allowed values for the attribute type.\n   For keyword attributes\
    \ returns null.  For no allowed values (i.e.\n   unrestricted) returns an empty\
    \ Enumeration.\n   public abstract Enumeration\n   getDefaultValues()\n   Return\
    \ an Enumeration of default values for the attribute type.\n   For keyword attributes\
    \ returns null.  For no allowed values (i.e.\n   unrestricted) returns an empty\
    \ Enumeration.\n   public abstract boolean\n   getRequiresExplicitMatch()\n  \
    \ Returns true if the \"X\"\" flag is set, indicating that the attribute\n   should\
    \ be included in an any Locator.findServices() request search\n   filter.\n  \
    \ public abstract boolean getIsMultivalued()\n   Returns true if the \"M\" flag\
    \ is set.\n   public abstract boolean getIsOptional()\n   Returns true if the\
    \ \"O\"\" flag is set.\n   public abstract boolean getIsLiteral()\n   Returns\
    \ true if the \"L\" flag is set.\n   public abstract boolean getIsKeyword()\n\
    \   Returns true if the attribute is a keyword attribute.\n"
- title: 5.7. Implementation Notes
  contents:
  - '5.7. Implementation Notes

    '
- title: 5.7.1. Refreshing Registrations
  contents:
  - "5.7.1. Refreshing Registrations\n   A special lifetime constant, ServiceURL.LIFETIME_PERMANENT,\
    \ is used\n   by clients to indicate that the URL should be automatically refreshed\n\
    \   until the application exits.  The API implementation should interpret\n  \
    \ this flag as indicating that the URL lifetime is\n   ServiceURL.LIFETIME_MAXIMUM,\
    \ and MUST arrange for automatic refresh\n   to occur.\n"
- title: 5.7.2. Parsing Alternate Transports in ServiceURL
  contents:
  - "5.7.2. Parsing Alternate Transports in ServiceURL\n   The ServiceURL class is\
    \ designed to handle multiple transports.  The\n   standard API performs no additional\
    \ processing on transports other\n   than IP except to separate out the host identifier\
    \ and the URL path.\n   However, implementations are free to subclass ServiceURL\
    \ and support\n   additional methods that provide more detailed parsing of alternate\n\
    \   transport information.  For IP transport, the port number, if any, is\n  \
    \ returned from the getPort() method.  For non-IP transports, the\n   getPort()\
    \ method returns NO_PORT.\n"
- title: 5.7.3. String Attribute Values
  contents:
  - "5.7.3. String Attribute Values\n   In general, translation between Java types\
    \ for attribute values and\n   the SLP on-the-wire string is straightforward.\
    \  However, there are\n   two corner cases.  If the Java attribute value type\
    \ is String and the\n   value of the string has an on-the-wire representation\
    \ that is\n   inferred by SLP as an integer, the registered attribute value may\
    \ not\n   be what the API client intended.  A similar problem could result if\n\
    \   the Java attribute value is the string \"true\" or \"false\", in which\n \
    \  case the on-the-wire representation is inferred to boolean.  To\n   handle\
    \ these corner cases, the Java API prepends a space onto the\n   string.  So,\
    \ for example, if the string attribute value is \"123\", the\n   Java API transforms\
    \ the value to \"123 \", which will have an on-the-\n   wire representation that\
    \ is inferred by SLP to be string.  Since\n   appended and prepended spaces have\
    \ no effect on query handling, this\n   procedure should cause no problem with\
    \ queries.  API clients need to\n   be aware, however, that the transformation\
    \ is occurring.\n"
- title: 5.7.4. Client Side Syntax Checking
  contents:
  - "5.7.4. Client Side Syntax Checking\n   The syntax of scope names, service type\
    \ names, naming authority\n   names, and URLs is described in [7] and [8].  The\
    \ various methods and\n   classes taking String parameters for these entities\
    \ SHOULD type check\n   the parameters for syntax errors on the client side, and\
    \ throw an\n   IllegalArgumentException if an error occurs.  In addition, character\n\
    \   escaping SHOULD be implemented before network transmission for\n   escapable\
    \ characters in attribute ids and String values.  This\n   reduces the number\
    \ of error messages transmitted.  The\n   ServiceLocationAttribute class provides\
    \ methods for clients to obtain\n   escaped attribute id and value strings to\
    \ facilitate query\n   construction.\n"
- title: 5.7.5. Language Locale Handling
  contents:
  - "5.7.5. Language Locale Handling\n   The Locator and Advertiser interfaces are\
    \ created with a Locale\n   parameter.  The language locale with which these objects\
    \ are created\n   is used in all SLP requests issued through the object.  If the\
    \ Locale\n   parameter is null, the default SLP locale is used.  The default SLP\n\
    \   locale is determined by, first, checking the net.slp.locale System\n   property.\
    \  If that is unset, then the default SLP locale [7] is used,\n   namely \"en\"\
    .  Note that the default SLP locale may not be the same as\n   the default Java\
    \ locale.\n"
- title: 5.7.6. Setting SLP System Properties
  contents:
  - "5.7.6. Setting SLP System Properties\n   SLP system properties that are originally\
    \ set in the configuration\n   file can be overridden programmatically in API\
    \ clients by simply\n   invoking the System.getProperties() operation to get a\
    \ copy of the\n   system properties, modifying or adding the SLP property in question,\n\
    \   then using System.setProperties() to set the properties to the\n   modified\
    \ Property object.  Program execution continues without\n   interruption by substituting\
    \ the default for the erroneous parameter.\n   Errors are checked when the property\
    \ is used and are logged.\n   The SLP configuration file cannot be read with the\n\
    \   java.util.Properties file reader because there are some syntactic\n   differences.\
    \  The SLP configuration file syntax defines a different\n   escape convention\
    \ for non-ASCII characters than the Java syntax.\n   However, after the file has\
    \ been read, the properties are stored and\n   retrieved from java.util.Properties\
    \ objects.\n   Properties are global for a process, affecting all threads and\
    \ all\n   Locator and Advertiser objects obtained through the\n   ServiceLocationManager.\
    \  With the exception of the net.slp.locale,\n   net.slp.typeHint, and net.slp.maxResults\
    \ properties, clients should\n   rarely be required to override these properties,\
    \ since they reflect\n   properties of the SLP network that are not of concern\
    \ to individual\n   agents.  If changes are required, system administrators should\
    \ modify\n   the configuration file.\n"
- title: 5.7.7. Multithreading
  contents:
  - "5.7.7. Multithreading\n   Thread-safe operation is relatively easy to achieve\
    \ in Java.  By\n   simply making each method in the classes implementing the Locator\
    \ and\n   Advertiser interfaces synchronized, and by synchronizing access to\n\
    \   any shared data structures within the class, the Locator and\n   Advertiser\
    \ interfaces are made safe.  Alternatively, finer grained\n   synchronization\
    \ is also possible within the classes implementing\n   Advertiser and Locator.\n"
- title: 5.7.8. Modular Implementations
  contents:
  - "5.7.8. Modular Implementations\n   While, at first glance, the API may look rather\
    \ heavyweight, the\n   design has been carefully arranged so that modular implementations\n\
    \   that provide only SA, only UA, or only service template access\n   capability,\
    \ or any combination of the three, are possible.\n   Because the objects returned\
    \ from the\n   ServiceLocationManager.getLocator() and\n   ServiceLocationManager.getAdvertiser()\
    \ operations are interfaces, and\n   because the objects returned through those\
    \ interfaces are in the set\n   of base data structures, an implementation is\
    \ free to omit either UA\n   or SA capability by simply returning null from the\
    \ instance creation\n   operation if the classes implementing the missing function\
    \ cannot be\n   dynamically linked.  API clients are encouraged to check for such\
    \ a\n   contingency, and to signal an exception if it occurs.  Similarly, the\n\
    \   TemplateRegistry concrete subclass can simply be omitted from an\n   implementation\
    \ that only supports UA and/or SA clients, and the\n   TemplateRegistry.getRegistry()\
    \ method can return null.  In this way,\n   the API implementation can be tailored\
    \ for the particular memory\n   requirements at hand.\n   In addition, if an implementation\
    \ only supports the minimal subset of\n   SLP [7], the unsupported Locator and\
    \ Advertiser interface operations\n   can throw an exception with ServiceLocationException.NOT_IMPLEMENTED\n\
    \   as the error code.  This supports better source portability between\n   low\
    \ and high memory platforms.\n"
- title: 5.7.9. Asynchronous and Incremental Return Semantics
  contents:
  - "5.7.9. Asynchronous and Incremental Return Semantics\n   The Java API contains\
    \ no specific support for asynchronous operation.\n   Incremental return is not\
    \ needed for the Advertiser because service\n   registrations can be broken up\
    \ into pieces when large.  Asynchronous\n   return is also not needed because\
    \ clients can always issue the\n   Advertiser operation in a separate thread if\
    \ the calling thread can't\n   block.\n   The Locator can be implemented either\
    \ synchronously or\n   asynchronously.  Since the return type for Locator calls\
    \ is\n   ServiceLocationEnumeration, a Java API implementation that supports\n\
    \   asynchronous semantics can implement ServiceLocationEnumeration to\n   dole\
    \ results out as they come in, blocking when no results are\n   available.  If\
    \ the client code needs to support other processing\n   while the results are\
    \ trickling in, the call into the enumeration to\n   retrieve the results can\
    \ be done in a separate thread.\n   Unlike the C case, collation semantics for\
    \ return of attributes when\n   an attribute request by service type is made require\
    \ that the API\n   collate returned values so that only one attribute having a\
    \ collation\n   of all returned values appear to the API client.  In practice,\
    \ this\n   may limit the amount of asynchronous processing possible with the\n\
    \   findAttributes() method.  This requirement is imposed because memory\n   management\
    \ is much easier in Java and so implementing collation as\n   part of the API\
    \ should not be as difficult as in C, and it saves the\n   client from having\
    \ to do the collation.\n"
- title: 5.8. Example
  contents:
  - "5.8. Example\n   In this example, a printer server advertises its availability\
    \ to\n   clients.  Additionally, the server advertises a service template for\n\
    \   use by client software in validating service requests:\n  //Get the Advertiser\
    \ and TemplateRegistry.\n  Advertiser adv = null;\n  TemplateRegistry tr = null\n\
    \  try {\n    adv = ServiceLocationManager.getAdvertiser(\"en\");\n    tr = TemplateRegistry.getTemplateRegistry();\n\
    \  } catch( ServiceLocationException ex ) { } //Deal with error.\n  if( adv ==\
    \ null ) {\n    //Serious error as printer can't be registered\n    //  if the\
    \ implementation doesn't support SA\n    //  functionality.\n  }\n  //Get the\
    \ printer's attributes, from a file or\n  //  otherwise. We assume that the attributes\n\
    \  //  conform to the template, otherwise, we\n  //  could register the template\
    \ here and verify\n  //  them.\n  Vector attributes = getPrinterAttributes();\n\
    \  //Create the service: URL for the printer.\n  ServiceURL printerURL =\n   \
    \ new ServiceURL(\n      \"service:printer:lpr://printshop/color2\",\n      ServiceURL.LIFETIME_MAXIMUM);\n\
    \  try {\n    //Register the printer.\n    adv.register(printerURL, attributes);\n\
    \    //If the template registry is available,\n    //  register the printer's\
    \ template.\n    if( tr != null ) {\n      tr.registerServiceTemplate(\n     \
    \   new ServiceType(\"service:printer:lpr\"),\n        \"http://shop.arv/printer/printer-lpr.slp\"\
    ,\n        new Locale(\"en\",\"\"),\n        \"1.0\");\n   }\n  } catch( ServiceLocationException\
    \ ex ) { } //Deal with error.\n   Suppose a client is looking for color printer.\
    \  The following code is\n   used to issue a request for printer advertisements:\n\
    \  Locator loc = null;\n  TemplateRegistry tr = null;\n  try {\n    loc = ServiceLocationManager.getLocator(\"\
    en\");\n  } catch( ServiceLocationException ex ) { } //Deal with error.\n  if(\
    \ loc == null ) {\n    //Serious error as client can't be located\n    //  if\
    \ the implementation doesn't support\n    //  UA functionality.\n  }\n  //We want\
    \ a color printer that does CMYK\n  //  and prints at least 600 dpi.\n  String\
    \ query = \"(&(marker-type=CMYK)(resolution=600))\";\n  //Get scopes.\n  Vector\
    \ scopes = ServiceLocationManager.findScopes();\n  Enumeration services;\n  try\
    \ {\n    services =\n      loc.findServices(new ServiceType(\"service:printer\"\
    ),scopes,query);\n  } catch { } //Deal with error.\n  if (services.hasMoreElements()\
    \ ) {\n    //Printers can now be used.\n    ServiceURL surl = (ServiceURL) services.next();\n\
    \    Socket sock = new Socket(surl.getHost, surl.getPort());\n    // Use the Socket...\n\
    \  }\n"
- title: 6. Internationalization Considerations
  contents:
  - '6. Internationalization Considerations

    '
- title: 6.1. service URL
  contents:
  - "6.1. service URL\n   The service URL itself must be encoded using the rules set\
    \ forth in\n   [2].  The character set encoding is limited to specific ranges\
    \ within\n   the UTF-8 character set [3].\n   The attribute information associated\
    \ with the service URL must be\n   expressed in UTF-8.  See [8] for attribute\
    \ internationalization\n   guidelines.\n"
- title: 6.2. Character Set Encoding
  contents:
  - "6.2. Character Set Encoding\n   Configuration and serialized registration files\
    \ are encoded in the\n   UTF-8 character set [3].  This is fully compatible with\
    \ US-ASCII\n   character values.  C platforms that do not support UTF-8 are required\n\
    \   to check the top bit of input bytes to determine whether the incoming\n  \
    \ character is multibyte.  If it is, the character should be dealt with\n   accordingly.\
    \  This should require no additional implementation\n   effort, since the SLP\
    \ wire protocol requires that strings are encoded\n   as UTF-8.  C platforms without\
    \ UTF-8 support need to supply their own\n   support, if only in the form of multibyte\
    \ string handling.\n   At the API level, the character encoding is specified to\
    \ be Unicode\n   for Java and UTF-8 for C. Unicode is the default in Java.  For\
    \ C, the\n   standard US-ASCII 8 bits per character, null terminated C strings\
    \ are\n   a subset of the UTF-8 character set, and so work in the API. Because\n\
    \   the C API is very simple, the API library needs to do a minimum of\n   processing\
    \ on UTF-8 strings.  The strings primarily just need to be\n   reflected into\
    \ the outgoing SLP messages, and reflected out of the\n   API from incoming SLP\
    \ messages.\n"
- title: 6.3. Language Tagging
  contents:
  - "6.3. Language Tagging\n   All SLP requests and registrations are tagged to indicate\
    \ in which\n   language the strings included are encoded.  This allows multiple\n\
    \   languages to be supported.  It also presents the possibility that\n   error\
    \ conditions result when a request is made in a language that is\n   not supported.\
    \  In this case, an error is only returned when there is\n   data available, but\
    \ not obtainable in the language requested.\n   The dialect portion of the Language\
    \ Tag is used on 'best effort'\n   basis for matching strings by SLP. Dialects\
    \ that match are preferred\n   over those which don't.  Dialects that do not match\
    \ will not prevent\n   string matching or comparisons from occurring.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Security is handled within the API library and\
    \ is not exposed to API\n   clients except in the form of exceptions.  The\n \
    \  net.slp.securityEnabled, property determines whether an SA client's\n   messages\
    \ are signed, but a UA client should be prepared for an\n   authentication exception\
    \ at any time, because it may contact a DA\n   with authenticated advertisements.\n\
    \   An adversary could delete valid service advertisements, provide false\n  \
    \ service information and deny UAs knowledge of existing services\n   unless the\
    \ mechanisms in SLP for authenticating SLP messages are\n   used.  These mechanisms\
    \ allow DAAdverts, SAAdverts, Service URLs and\n   Service Attributes to be verified\
    \ using digital cryptography.  For\n   this reason, all SLP agents should be configured\
    \ to use SLP SPIs.\n   See [7] for a description of how this mechanism works.\n"
- title: 8. Acknowledgements
  contents:
  - "8. Acknowledgements\n   The authors would like to thank Don Provan for his pioneering\
    \ work\n   during the initial stages of API definition.\n"
- title: 9. References
  contents:
  - "9. References\n    [1] Bradner, S., \"Key Words for Use in RFCs to Indicate\n\
    \        Requirement Levels\", BCP 14, RFC 2119, March 1997.\n    [2] Berners-Lee,\
    \ T., Fielding, R. and L. Masinter, \"Uniform\n        Resource Identifiers (URI):\
    \ Generic Syntax\", RFC 2396,\n        August 1998.\n    [3] Yergeau, F., \"UTF-8,\
    \ a transformation format of ISO 10646\",\n        RFC 2279, January 1998.\n \
    \   [4] Howes, T., \"The String Representation of LDAP Search Filters\",\n   \
    \     RFC 2254  December 1997.\n    [5] Crocker, D. and P. Overell, \"Augmented\
    \ BNF for Syntax\n        Specifications: ABNF\", RFC 2234, November 1997.\n \
    \   [6] Alvestrand, H., \"Tags for the Identification of Languages\",\n      \
    \  RFC 1766, March 1995.\n    [7] Guttman, E., Perkins, C., Veizades, J. and M.\
    \ Day, \"Service\n        Location Protocol, Version 2\", RFC 2608, June 1999.\n\
    \    [8] Guttman, E., Perkins, C. and J. Kempf, \"Service Templates and\n    \
    \    Service: Schemes\", RFC 2609, June 1999.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Questions about this memo can be directed to:\n  \
    \ James Kempf\n   Sun Microsystems\n   901 San Antonio Rd.\n   Palo Alto, CA,\
    \ 94303\n   USA\n   Phone: +1 650 786 5890\n   Fax:   +1 650 786 6445\n   EMail:\
    \ james.kempf@sun.com\n   Erik Guttman\n   Sun Microsystems\n   Bahnstr. 2\n \
    \  74915 Waibstadt\n   Germany\n   Phone: +49 7263 911 701\n   EMail: erik.guttman@sun.com\n"
- title: 11. Full Copyright Statement
  contents:
  - "11. Full Copyright Statement\n   Copyright (C) The Internet Society (1999). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\"\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
