- title: __initial_text__
  contents:
  - "              VMTP: VERSATILE MESSAGE TRANSACTION PROTOCOL\n                \
    \         Protocol Specification\nSTATUS OF THIS MEMO\nThis RFC describes a protocol\
    \ proposed as a standard for the Internet\ncommunity.  Comments are encouraged.\
    \  Distribution of this document is\nunlimited.\nOVERVIEW\nThis memo specifies\
    \ the Versatile Message Transaction Protocol (VMTP)\n[Version 0.7 of 19-Feb-88],\
    \ a transport protocol specifically designed\nto support the transaction model\
    \ of communication, as exemplified by\nremote procedure call (RPC).  The full\
    \ function of VMTP, including\nsupport for security, real-time, asynchronous message\
    \ exchanges,\nstreaming, multicast and idempotency, provides a rich selection\
    \ to the\nVMTP user level.  Subsettability allows the VMTP module for particular\n\
    clients and servers to be specialized and simplified to the services\nactually\
    \ required.  Examples of such simple clients and servers include\nRFC 1045   \
    \                    VMTP                        February 1988 \n            \
    \               Table of Contents\n1. Introduction                           \
    \                             1\n   1.1. Motivation                          \
    \                           2\n       1.1.1. Poor RPC Performance            \
    \                         2\n       1.1.2. Weak Naming                       \
    \                       3\n       1.1.3. Function Poor                       \
    \                     3\n   1.2. Relation to Other Protocols                 \
    \                   4\n   1.3. Document Overview                             \
    \                 5\n2. Protocol Overview                                    \
    \               6\n   2.1. Entities, Processes and Principals                \
    \             7\n   2.2. Entity Domains                                      \
    \           9\n   2.3. Message Transactions                                  \
    \        10\n   2.4. Request and Response Messages                           \
    \      11\n   2.5. Reliability                                               \
    \    12\n       2.5.1. Transaction Identifiers                               \
    \  13\n       2.5.2. Checksum                                                14\n\
    \       2.5.3. Request and Response Acknowledgment                     14\n  \
    \     2.5.4. Retransmissions                                         15\n    \
    \   2.5.5. Timeouts                                                15\n      \
    \ 2.5.6. Rate Control                                            18\n   2.6. Security\
    \                                                      19\n   2.7. Multicast \
    \                                                    21\n   2.8. Real-time Communication\
    \                                       22\n   2.9. Forwarded Message Transactions\
    \                                24\n   2.10. VMTP Management                \
    \                              25\n   2.11. Streamed Message Transactions    \
    \                            25\n   2.12. Fault-Tolerant Applications        \
    \                          28\n   2.13. Packet Groups                        \
    \                        29\n   2.14. Runs of Packet Groups                  \
    \                      31\n   2.15. Byte Order                               \
    \                    32\n   2.16. Minimal VMTP Implementation                \
    \                  33\n   2.17. Message vs. Procedural Request Handling      \
    \                33\n   2.18. Bibliography                                   \
    \              34\n3. VMTP Packet Formats                                    \
    \            37\n   3.1. Entity Identifier Format                            \
    \          37\n   3.2. Packet Fields                                         \
    \        38\nRFC 1045                       VMTP                        February\
    \ 1988 \n   3.3. Request Packet                                              \
    \  45\n   3.4. Response Packet                                               47\n\
    4. Client Protocol Operation                                          49\n   4.1.\
    \ Client State Record Fields                                    49\n   4.2. Client\
    \ Protocol States                                        51\n   4.3. State Transition\
    \ Diagrams                                     51\n   4.4. User Interface    \
    \                                            52\n   4.5. Event Processing    \
    \                                          53\n   4.6. Client User-invoked Events\
    \                                    54\n       4.6.1. Send                  \
    \                                  54\n       4.6.2. GetResponse             \
    \                                56\n   4.7. Packet Arrival                  \
    \                              56\n       4.7.1. Response                    \
    \                            58\n   4.8. Management Operations               \
    \                          61\n       4.8.1. HandleNoCSR                     \
    \                        62\n   4.9. Timeouts                                \
    \                      64\n5. Server Protocol Operation                      \
    \                    66\n   5.1. Remote Client State Record Fields           \
    \                  66\n   5.2. Remote Client Protocol States                 \
    \                66\n   5.3. State Transition Diagrams                       \
    \              67\n   5.4. User Interface                                    \
    \            69\n   5.5. Event Processing                                    \
    \          70\n   5.6. Server User-invoked Events                            \
    \        71\n       5.6.1. Receive                                           \
    \      71\n       5.6.2. Respond                                             \
    \    72\n       5.6.3. Forward                                               \
    \  73\n       5.6.4. Other Functions                                         74\n\
    \   5.7. Request Packet Arrival                                        74\n  \
    \ 5.8. Management Operations                                         78\n    \
    \   5.8.1. HandleRequestNoCSR                                      79\n   5.9.\
    \ Timeouts                                                      82\n6. Concluding\
    \ Remarks                                                 84\nI. Standard VMTP\
    \ Response Codes                                       85\nII. VMTP RPC Presentation\
    \ Protocol                                    87\nRFC 1045                   \
    \    VMTP                        February 1988 \n   II.1. Request Code Management\
    \                                      87\nIII. VMTP Management Procedures   \
    \                                    89\n   III.1. Entity Group Management   \
    \                                 100\n   III.2. VMTP Management Digital Signatures\
    \                         101\nIV. VMTP Entity Identifier Domains            \
    \                       102\n   IV.1. Domain 1                               \
    \                     102\n   IV.2. Domain 3                                 \
    \                   104\n   IV.3. Other Domains                              \
    \                 105\n   IV.4. Decentralized Entity Identifier Allocation   \
    \               105\nV. Authentication Domains                               \
    \             107\n   V.1. Authentication Domain 1                           \
    \           107\n   V.2. Other Authentication Domains                        \
    \         107\nVI. IP Implementation                                         \
    \       108\nVII. Implementation Notes                                       \
    \     109\n   VII.1. Mapping Data Structures                                 \
    \   109\n   VII.2. Client Data Structures                                    \
    \ 111\n   VII.3. Server Data Structures                                     111\n\
    \   VII.4. Packet Group transmission                                  112\n  \
    \ VII.5. VMTP Management Module                                     113\n   VII.6.\
    \ Timeout Handling                                           114\n   VII.7. Timeout\
    \ Values                                             114\n   VII.8. Packet Reception\
    \                                           115\n   VII.9. Streaming         \
    \                                         116\n   VII.10. Implementation Experience\
    \                                 117\nVIII. UNIX 4.3 BSD Kernel Interface for\
    \ VMTP                         118\nIndex                                    \
    \                            120\nRFC 1045                       VMTP        \
    \                February 1988 \n                            List of Figures\n\
    \   Figure 1-1:   Relation to Other Protocols                           4\n  \
    \ Figure 3-1:   Request Packet Format                                45\n   Figure\
    \ 3-2:   Response Packet Format                               47\n   Figure 4-1:\
    \   Client State Transitions                             52\n   Figure 5-1:  \
    \ Remote Client State Transitions                      68\n   Figure III-1:  \
    \ Authenticator Format                               92\n   Figure VII-1:   Mapping\
    \ Client Identifier to CSR                  109\n   Figure VII-2:   Mapping Server\
    \ Identifiers                        110\n   Figure VII-3:   Mapping Group Identifiers\
    \                         111\n1. Introduction\nThe Versatile Message Transaction\
    \ Protocol (VMTP) is a transport\nprotocol designed to support remote procedure\
    \ call (RPC) and general\ntransaction-oriented communication.  By transaction-oriented\n\
    communication, we mean that:\n   - Communication is request-response:  A client\
    \ sends a request\n     for a service to a server, the request is processed, and\
    \ the\n     server responds.  For example, a client may ask for the next\n   \
    \  page of a file as the service.  The transaction is terminated\n     by the\
    \ server responding with the next page.\n   - A transaction is initiated as part\
    \ of sending a request to a\n     server and terminated by the server responding.\
    \  There are no\n     separate operations for setting up or terminating associations\n\
    \     between clients and servers at the transport level.\n   - The server is\
    \ free to discard communication state about a\n     client between transactions\
    \ without causing incorrect behavior\n     or failures.\nThe term message transaction\
    \ (or transaction) is used in the reminder of\nthis document for a request-response\
    \ exchange in the sense described\nabove.\nVMTP handles the error detection, retransmission,\
    \ duplicate suppression\nand, optionally, security required for transport-level\
    \ end-to-end\nreliability.\nThe protocol is designed to provide a range of behaviors\
    \ within the\ntransaction model, including:\n   - Minimal two packet exchanges\
    \ for short, simple transactions.\n   - Streaming of multi-packet requests and\
    \ responses for efficient\n     data transfer.\n   - Datagram and multicast communication\
    \ as an extension of the\n     transaction model.\nExample Uses:\n   - Page-level\
    \ file access - VMTP is intended as the transport\n     level for file access,\
    \ allowing simple, efficient operation on\n     a local network.  In particular,\
    \ VMTP is appropriate for use\n     by diskless workstations accessing shared\
    \ network file\nRFC 1045                       VMTP                        February\
    \ 1988 \n     servers.\n   - Distributed programming - VMTP is intended to provide\
    \ an\n     efficient transport level protocol for remote procedure call\n    \
    \ implementations, distributed object-oriented systems plus\n     message-based\
    \ systems that conform to the request-response\n     model.\n   - Multicast communication\
    \ with groups of servers to:  locate a\n     specific object within the group,\
    \ update a replicated object,\n     synchronize the commitment of a distributed\
    \ transaction, etc.\n   - Distributed real-time control with prioritized message\n\
    \     handling, including datagrams, multicast and asynchronous\n     calls.\n\
    The protocol is designed to operate on top of a simple unreliable\ndatagram service,\
    \ such as is provided by IP.\n1.1. Motivation\nVMTP was designed to address three\
    \ categories of deficiencies with\nexisting transport protocols in the Internet\
    \ architecture.  We use TCP\nas the key current transport protocol for comparison.\n\
    1.1.1. Poor RPC Performance\nFirst, current protocols provide poor performance\
    \ for remote procedure\ncall (RPC) and network file access.  This is attributable\
    \ to three key\ncauses:\n   - TCP requires excessive packets for RPC, especially\
    \ for\n     isolated calls.  In particular, connection setup and clear\n     generates\
    \ extra packets over that needed for VMTP to support\n     RPC.\n   - TCP is difficult\
    \ to implement, speaking purely from the\n     empirical experience over the last\
    \ 10 years.  VMTP was\n     designed concurrently with its implementation, with\
    \ focus on\n     making it easy to implement and providing sensible subsets of\n\
    \     its functionality.\n   - TCP handles packet loss due to overruns poorly.\
    \  We claim that\n     overruns are the key source of packet loss in a\n     high-performance\
    \ RPC environment and, with the increasing\nRFC 1045                       VMTP\
    \                        February 1988 \n     performance of networks, will continue\
    \ to be the key source.\n     (Older machines and network interfaces cannot keep\
    \ up with new\n     machines and network interfaces.  Also, low-end network\n\
    \     interfaces for high-speed networks have limited receive\n     buffering.)\n\
    VMTP is designed for ease of implementation and efficient RPC.  In\naddition,\
    \ it provides selective retransmission with rate-based flow\ncontrol, thus addressing\
    \ all of the above issues.\n1.1.2. Weak Naming\nSecond, current protocols provide\
    \ inadequate naming of transport-level\nendpoints because the names are based\
    \ on IP addresses.  For example, a\nTCP endpoint is named by an Internet address\
    \ and port identifier.\nUnfortunately, this makes the endpoint tied to a particular\
    \ host\ninterface, not specifically the process-level state associated with the\n\
    transport-level endpoint.  In particular, this form of naming causes\nproblems\
    \ for process migration, mobile hosts and multi-homed hosts.\nVMTP provides host-address\
    \ independent names, thereby solving the above\nmentioned problems.\nIn addition,\
    \ TCP provides no security and reliability guarantees on the\ndynamically allocated\
    \ names.  In particular, other than well-known\nports, (host-addr, port-id)-tuples\
    \ can change meaning on reboot\nfollowing a crash.  VMTP provides large identifiers\
    \ with guarantee of\nstability, meaning that either the identifier never changes\
    \ in meaning\nor else remains invalid for a significant time before becoming valid\n\
    again.\n1.1.3. Function Poor\nTCP does not support multicast, real-time datagrams\
    \ or security.  In\nfact, it only supports pair-wise, long-term, streamed reliable\n\
    interchanges.  Yet, multicast is of growing importance and is being\ndeveloped\
    \ for the Internet (see RFC 966 and 988).  Also, a datagram\nfacility with the\
    \ same naming, transmission and reception facilities as\nthe normal transport\
    \ level is a powerful asset for real-time and\nparallel applications.  Finally,\
    \ security is a basic requirement in an\nincreasing number of environments.  We\
    \ note that security is natural to\nimplement at the transport level to provide\
    \ end-to-end security (as\nopposed to (inter)network level security).  Without\
    \ security at the\ntransport level, a transport level protocol cannot guarantee\
    \ the\nstandard transport level service definition in the presence of an\nintruder.\
    \  In particular, the intruder can interject packets or modify\nRFC 1045     \
    \                  VMTP                        February 1988 \npackets while updating\
    \ the checksum, making mockery out of the\ntransport-level claim of \"reliable\
    \ delivery\".\nIn contrast, VMTP provides multicast, real-time datagrams and security,\n\
    addressing precisely these weaknesses.\nIn general, VMTP is designed with the\
    \ next generation of communication\nsystems in mind.  These communication systems\
    \ are characterized as\nfollows.  RPC, page-level file access and other request-response\n\
    behavior dominates.  In addition, the communication substrate, both\nlocal and\
    \ wide-area, provides high data rates, low error rates and\nrelatively low delay.\
    \  Finally, intelligent, high-performance network\ninterfaces are common and in\
    \ fact required to achieve performance that\napproximates the network capability.\
    \  However, VMTP is also designed to\nfunction acceptably with existing networks\
    \ and network interfaces.\n1.2. Relation to Other Protocols\nVMTP is a transport\
    \ protocol that fits into the layered Internet\nprotocol environment.  Figure\
    \ 1-1 illustrates the place of VMTP in the\nprotocol hierarchy.\n +-----------+\
    \ +----+ +-----------------+ +------+\n |File Access| |Time| |Program Execution|\
    \ |Naming|... Application\n +-----------+ +----+ +-----------------+ +------+\
    \      Layer\n       |           |           |             |      |\n       +-----------+-----------+-------------+------+\n\
    \                               |\n                        +------------------+\n\
    \                        | RPC Presentation |          Presentation\n        \
    \                +------------------+          Layer\n                       \
    \           |\n            +------+          +--------+\n            |  TCP |\
    \          | VMTP   |              Transport\n            +------+          +--------+\
    \              Layer\n                |                  |\n           +-----------------------------------+\n\
    \           |       Internet Protocol & ICMP    |      Internetwork\n        \
    \   +-----------------------------------+      Layer\n               Figure 1-1:\
    \   Relation to Other Protocols\nThe RPC presentation level is not currently defined\
    \ in the Internet\nsuite of protocols.  Appendix II defines a proposed RPC presentation\n\
    level for use with VMTP and assumed for the definition of the VMTP\nmanagement\
    \ procedures.  There is also a need for the definition of the\nRFC 1045      \
    \                 VMTP                        February 1988 \nApplication layer\
    \ protocols listed above.\nIf internetwork services are not required, VMTP can\
    \ be used without the\nIP layer, layered directly on top of the network or data\
    \ link layers.\n1.3. Document Overview\nThe next chapter gives an overview of\
    \ the protocol, covering naming,\nmessage structure, reliability, flow control,\
    \ streaming, real-time,\nsecurity, byte-ordering and management.  Chapter 3 describes\
    \ the VMTP\npacket formats.  Chapter 4 describes the client VMTP protocol operation\n\
    in terms of pseudo-code for event handling.  Chapter 5 describes the\nserver VMTP\
    \ protocol operation in terms of pseudo-code for event\nhandling.  Chapter 6 summarizes\
    \ the state of the protocol, some\nremaining issues and expected directions for\
    \ the future.  Appendix I\nlists some standard Response codes.  Appendix II describes\
    \ the RPC\npresentation protocol proposed for VMTP and used with the VMTP\nmanagement\
    \ procedures.  Appendix III lists the VMTP management\nprocedures.  Appendix IV\
    \ proposes initial approaches for handling entity\nidentification for VMTP.  Appendix\
    \ V proposes initial authentication\ndomains for VMTP.  Appendix VI provides some\
    \ details for implementing\nVMTP on top of IP.  Appendix VII provides some suggestions\
    \ on host\nimplementation of VMTP, focusing on data structures and support\nfunctions.\
    \  Appendix VIII describes a proposed program interface for\nUNIX 4.3 BSD and\
    \ its descendants and related systems.\nRFC 1045                       VMTP  \
    \                      February 1988 \n2. Protocol Overview\nVMTP provides an\
    \ efficient, reliable, optionally secure transport\nservice in the message transaction\
    \ or request-response model with the\nfollowing features:\n   - Host address-independent\
    \ naming with provision for multiple\n     forms of names for endpoints as well\
    \ as associated (security)\n     principals.  (See Sections 2.1, 2.2, 3.1 and\
    \ Appendix IV.)\n   - Multi-packet request and response messages, with a maximum\n\
    \     size of 4 megaoctets per message.  (Sections 2.3 and 2.14.)\n   - Selective\
    \ retransmission. (Section 2.13.)  and rate-based flow\n     control to reduce\
    \ overrun and the cost of overruns.  (Section\n     2.5.6.)\n   - Secure message\
    \ transactions with provision for a variety of\n     encryption schemes.  (Section\
    \ 2.6.)\n   - Multicast message transactions with multiple response messages\n\
    \     per request message.  (Section 2.7.)\n   - Support for real-time communication\
    \ with idempotent message\n     transactions with minimal server overhead and\
    \ state (Section\n     2.5.3), datagram request message transactions with no\n\
    \     response, optional header-only checksum, priority processing\n     of transactions,\
    \ conditional delivery and preemptive handling\n     of requests (Section 2.8)\n\
    \   - Forwarded message transactions as an optimization for certain\n     forms\
    \ of nested remote procedure calls or message\n     transactions.  (Section 2.9.)\n\
    \   - Multiple outstanding (asynchronous) message transactions per\n     client.\
    \  (Section 2.11.)\n   - An integrated management module, defined with a remote\n\
    \     procedure call interface on top of VMTP providing a variety of\n     communication\
    \ services (Section 2.10.)\n   - Simple subset implementation for simple clients\
    \ and simple\n     servers.  (Section 2.16.)\nThis chapter provides an overview\
    \ of the protocol as introduction to the\nbasic ideas and as preparation for the\
    \ subsequent chapters that describe\nthe packet formats and event processing procedures\
    \ in detail.\nRFC 1045                       VMTP                        February\
    \ 1988 \nIn overview, VMTP provides transport communication between network-\n\
    visible entities via message transactions.  A message transaction\nconsists of\
    \ a request message sent by the client, or requestor, to a\ngroup of server entities\
    \ followed by zero or more response messages to\nthe client, at most one from\
    \ each server entity.  A message is\nstructured as a message control portion and\
    \ a segment data portion.  A\nmessage is transmitted as one or more packet groups.\
    \  A packet group  is\none or more packets (up to a maximum of 32 packets) grouped\
    \ by the\nprotocol for acknowledgment, sequencing, selective retransmission and\n\
    rate control.\nEntities and VMTP operations are managed using a VMTP management\n\
    mechanism that is accessed through a procedural interface (RPC)\nimplemented on\
    \ top of VMTP.  In particular, information about a remote\nentity is obtained\
    \ and maintained using the Probe VMTP management\noperation.  Also, acknowledgment\
    \ information and requests for\nretransmission are sent as notify requests to\
    \ the management module.\n(In the following description, reference to an \"acknowledgment\"\
    \ of a\nrequest or a response refers to a management-level notify operation that\n\
    is acknowledging the request or response.)\n2.1. Entities, Processes and Principals\n\
    VMTP defines and uses three main types of identifiers:  entity\nidentifiers, process\
    \ identifiers and principal identifiers, each 64-bits\nin length.  Communication\
    \ takes place between network-visible entities,\ntypically mapping to, or representing,\
    \ a message port or procedure\ninvocation.  Thus, entities are the VMTP communication\
    \ endpoints.  The\nprocess associated with each entity designates the agent behind\
    \ the\ncommunication activity for purposes of resource allocation and\nmanagement.\
    \  For example, when a lock is requested on a file, the lock\nis associated with\
    \ the process, not the requesting entity, allowing a\nprocess to use multiple\
    \ entity identifiers to perform operations without\nlock conflict between these\
    \ entities.  The principal associated with an\nentity specifies the permissions,\
    \ security and accounting designation\nassociated with the entity.  The process\
    \ and principal identifiers are\nincluded in VMTP solely to make these values\
    \ available to VMTP users\nwith the security and efficiency provided by VMTP.\
    \  Only the entity\nidentifiers are actively used by the protocol.\nEntity identifiers\
    \ are required to have three properties;\nUniqueness      Each entity identifier\
    \ is uniquely defined at any given\n                time.  (An entity identifier\
    \ may be reused over time.)\nStability       An entity identifier does not change\
    \ between valid\nRFC 1045                       VMTP                        February\
    \ 1988 \n                meanings without suitable provision for removing\n  \
    \              references to the entity identifier.  Certain entity\n        \
    \        identifiers are strictly stable, (i.e. never changing\n             \
    \   meaning), typically being administratively assigned\n                (although\
    \ they need not be bound to a valid entity at\n                all times), often\
    \ called well-known identifiers.  All\n                other entity identifiers\
    \ are required to be T-stable,\n                not change meaning without having\
    \ remained invalid for\n                at least a time interval T.\nHost address\
    \ independent\n                An entity identifier is unique independent of the\
    \ host\n                address of its current host.  Moreover, an entity\n  \
    \              identifier is not tied to a single Internet host\n            \
    \    address.  An entity can migrate between hosts, reside on\n              \
    \  a mobile host that changes Internet addresses or reside\n                on\
    \ a multi-homed host.  It is up to the VMTP\n                implementation to\
    \ determine and maintain up to date the\n                host addresses of entities\
    \ with which it is\n                communicating.\nThe stability of entity identifiers\
    \ guarantees that an entity identifier\nrepresents the same logical communication\
    \ entity and principal (in the\nsecurity sense) over the time that it is valid.\
    \  For example, if an\nentity identifier is authenticated as having the privileges\
    \ of a given\nuser account, it continues to have those privileges as long as it\
    \ is\ncontinuously valid (unless some explicit notice is provided otherwise).\n\
    Thus, a file server need not fully authenticate the entity on every file\naccess\
    \ request.  With T-stable identifiers, periodically checking the\nvalidity of\
    \ an entity identifier with period less than T seconds detects\na change in entity\
    \ identifier validity.\nA group of entities can form an entity group, which is\
    \ a set of zero or\nmore entities identified by a single entity identifier.  For\
    \ example,\none can have a single entity identifier that identifies the group\
    \ of\nname servers.  An entity identifier representing an entity group is\ndrawn\
    \ from the same name space as entity identifiers.  However, single\nentity identifiers\
    \ are flagged as such by a bit in the entity\nidentifier, indicating that the\
    \ identifier is known to identify at most\none entity.  In addition to the group\
    \ bit, each entity identifier\nincludes other standard type flags.  One flag indicates\
    \ whether the\nidentifier is an alias for an entity in another domain (See Section\
    \ 2.2\nbelow.).  Another flag indicates, for an entity group identifier,\nwhether\
    \ the identifier is a restricted group or not.  A restricted group\nis one in\
    \ which an entity can be added only by another entity with group\nmanagement authorization.\
    \  With an unrestricted group, an entity is\nallowed to add itself.  If an entity\
    \ identifier does not represent a\nRFC 1045                       VMTP       \
    \                 February 1988 \ngroup, a type bit indicates whether the entity\
    \ uses big-endian or\nlittle-endian data representation (corresponding to Motorola\
    \ 680X0 and\nVAX byte orders, respectively).  Further specification of the format\
    \ of\nentity identifiers is contained in Section 3.1 and Appendix IV.\nAn entity\
    \ identifier identifies a Client, a Server or a group of\nServers <1>.  A Client\
    \ is always identified by a T-stable identifier.  A\nserver or group of servers\
    \ may be identified by a a T-stable identifier\n(group or single entity) or by\
    \ strictly stable (statically assigned)\nentity group identifier.  The same T-stable\
    \ identifier can be used to\nidentify a Client and Server simultaneously as long\
    \ as both are\nlogically associated with the same entity.  The state required\
    \ for\nreliable, secure communication between entities is maintained in client\n\
    state records (CSRs), which include the entity identifier of the Client,\nits\
    \ principal, its current or next transaction identifier and so on.\n2.2. Entity\
    \ Domains\nAn entity domain is an administration or an administration mechanism\n\
    that guarantees the three required entity identifier properties of\nuniqueness,\
    \ stability and host address independence for the entities it\nadministers.  That\
    \ is, entity identifiers are only guaranteed to be\nunique and stable within one\
    \ entity domain.  For example, the set of all\nInternet hosts may function as\
    \ one domain.  Independently, the set of\nhosts local to one autonomous network\
    \ may function as a separate domain.\nEach entity domain is identified by an entity\
    \ domain identifier, Domain.\nOnly entities within the same domain may communicate\
    \ directly via VMTP.\nHowever, hosts and entities may participate in multiple\
    \ entity domains\nsimultaneously, possibly with different entity identifiers.\
    \  For\nexample, a file server may participate in multiple entity domains in\n\
    order to provide file service to each domain.  Each entity domain\nspecifies the\
    \ algorithms for allocation, interpretation and mapping of\nentity identifiers.\n\
    Domains are necessary because it does not appear feasible to specify one\nuniversal\
    \ VMTP entity identification administration that covers all\nentities for all\
    \ time.  Domains limit the number of entities that need\nto be managed to maintain\
    \ the uniqueness and stability of the entity\n_______________\n<1>   Terms such\
    \ as Client, Server, Request, Response, etc.  are\ncapitalized in this document\
    \ when they refer to their specific meaning\nin VMTP.\nRFC 1045              \
    \         VMTP                        February 1988 \nname space.  Domains can\
    \ also serve to separate entities of different\nsecurity levels.  For instance,\
    \ allocation of a unclassified entity\nidentifier cannot conflict with secret\
    \ level entity identifiers because\nthe former is interpreted only in the unclassified\
    \ domain, which is\ndisjoint from the secret domain.\nIt is intended that there\
    \ be a small number of domains.  In particular,\nthere should be one (or a few)\
    \ domains per installation \"type\", rather\nthan per installation.  For example,\
    \ the Internet is expected to use one\ndomain per security level, resulting in\
    \ at most 8 different domains.\nCluster-based internetwork architectures, those\
    \ with a local cluster\nprotocol distinct from the wide-area protocol, may use\
    \ one domain for\nlocal use and one for wide-area use.\nAdditional details on\
    \ the specification of specific domains is provided\nin Appendix IV.\n2.3. Message\
    \ Transactions\nThe message transaction is the unit of interaction between a Client\
    \ that\ninitiates the transaction and one or more Servers.  A message\ntransaction\
    \ starts with a request message  generated by a client.  At\nthe service interface,\
    \ a server becomes involved with a transaction by\nreceiving and accepting the\
    \ request.  A server terminates its\ninvolvement with a transaction by sending\
    \ a response message.  In a\ngroup message transaction, the server entity designated\
    \ by the client\ncorresponds to a group of entities.  In this case, each server\
    \ in the\ngroup receives a copy of the request.  In the client's view, the\ntransaction\
    \ is terminated when it receives the response message or, in\nthe case of a group\
    \ message transaction, when it receives the last\nresponse message.  Because it\
    \ is normally impractical to determine when\nthe last response message has been\
    \ received.  the current transaction is\nterminated by VMTP when the next transaction\
    \ is initiated.\nWithin an entity domain, a transaction is uniquely identified\
    \ by the\ntuple (Client, Transaction, ForwardCount).  where Transaction is a\n\
    32-bit number and ForwardCount is a 4-bit value.  A Client uses\nmonotonically\
    \ increasing Transaction identifiers for new message\ntransactions.  Normally,\
    \ the next higher transaction number, modulo\n2**32, is used for the next message\
    \ transaction, although there are\ncases in which it skips a small range of Transaction\
    \ identifiers.  (See\nthe description of the STI control flag.)  The ForwardCount\
    \ is used when\na message transaction is forwarded and is zero otherwise.\nA Client\
    \ generates a stream of message transactions with increasing\ntransaction identifiers,\
    \ directed at a diversity of Servers.  We say a\nRFC 1045                    \
    \   VMTP                        February 1988 \nClient has a transaction outstanding\
    \ if it has invoked a message\ntransaction, but has not received the last Response\
    \ (or possibly any\nResponse).  Normally, a Client has only one transaction outstanding\
    \ at a\ntime.  However, VMTP allows a Client to have multiple message\ntransactions\
    \ outstanding simultaneously, supporting streamed,\nasynchronous remote procedure\
    \ call invocations.  In addition, VMTP\nsupports nested calls where, for example,\
    \ procedure A calls procedure B\nwhich calls procedure C, each on a separate host\
    \ with different client\nentity identifiers for each call but identified with\
    \ the same process\nand principal.\n2.4. Request and Response Messages\nA message\
    \ transaction consists of a request message and one or more\nResponse messages.\
    \  A message is structured as message control block\n(MCB) and segment data, passed\
    \ as parameters, as suggested below.\n  +-----------------------+\n  | Message\
    \ Control Block |\n  +-----------------------+\n  +-----------------------------------+\n\
    \  |       segment data                |\n  +-----------------------------------+\n\
    In the request message, the MCB specifies control information about the\nrequest\
    \ plus an optional data segment.  The MCB has the following\nformat:\n  0    \
    \               1                   2                   3\n  0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                         ServerEntityId  (8 octets)            +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |   Flags       |         RequestCode                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                         CoresidentEntity (8 octets)           +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ >                         User Data (12 octets)                 <\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                         MsgDelivery                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                         SegmentSize                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    The ServerEntityId is the entity to which the Request MCB is to be sent\n(or was\
    \ sent, in the case of reception).  The Flags indicate various\noptions in the\
    \ request and response handling as well as whether the\nCoresidentEntity, MsgDelivery\
    \ and SegmentSize fields are in use.  The\nRequestCode field specifies the type\
    \ of Request.  It is analogous to a\npacket type field of the Ethernet, acting\
    \ as a switch for higher-level\nprotocols.  The CoresidentEntity field, if used,\
    \ designates a subgroup\nof the ServerEntityId group to which the Request should\
    \ be routed,\nnamely those members that are co-resident with the specified entity\
    \ (or\nentity group).  The primary intended use is to specify the manager for\
    \ a\nparticular service that is co-resident with a particular entity, using\n\
    the well-known entity group identifier for the service manager in the\nServerEntityId\
    \ field and the identifier for the entity in the\nCoresidentEntity field.  The\
    \ next 12 octets are user- or\napplication-specified.\nThe MsgDelivery field is\
    \ optionally used by the RPC or user level to\nspecify the portions of the segment\
    \ data to transmit and on reception,\nthe portions received.  It provides the\
    \ client and server with\n(optional) access to, and responsibility for, a simple\
    \ selective\ntransmission and reception facility.  For example, a client may request\n\
    retransmission of just those portions of the segment that it failed to\nreceive\
    \ as part of the original Response.  The primary intended use is\nto support highly\
    \ efficient multi-packet reading from a file server.\nExploiting user-level selective\
    \ retransmission using the MsgDelivery\nfield, the file server VMTP module need\
    \ not save multi-packet Responses\nfor retransmission.  Retransmissions, when\
    \ needed, are instead handled\ndirectly from the file server buffers.\nThe SegmentSize\
    \ field indicates the size of the data segment, if\npresent.  The CoresidentEntity,\
    \ MsgDelivery and SegmentSize fields are\nusable as additional user data if they\
    \ are not otherwise used.\nThe Flags field provides a simple mechanism for the\
    \ user level to\ncommunicate its use of VMTP options with the VMTP module as well\
    \ as for\nVMTP modules to communicate this use among themselves.  The use of these\n\
    options is generally fixed for each remote procedure so that an RPC\nmechanism\
    \ using VMTP can treat the Flags as an integral part of the\nRequestCode field\
    \ for the purpose of demultiplexing to the correct stub.\nA Response message control\
    \ block follows the same format except the\nResponse is sent from the Server to\
    \ the Client and there is no\nCoresident Entity field (and thus 20 octets of user\
    \ data).\n2.5. Reliability\nVMTP provides reliable, sequenced transfer of request\
    \ and response\nmessages as well as several variants, such as unreliable datagram\n\
    requests.  The reliability mechanisms include: transaction identifiers,\nRFC 1045\
    \                       VMTP                        February 1988 \nchecksums,\
    \ positive acknowledgment of messages and timeout and\nretransmission of lost\
    \ packets.\n2.5.1. Transaction Identifiers\nEach message transaction is uniquely\
    \ identified by the pair (Client,\nTransaction).  (We defer discussion of the\
    \ ForwardCount field to Section\n2.9.)  The 32-bit transaction identifier is initialized\
    \ to a random\nvalue when the Client entity is created or allocated its entity\n\
    identifier.  The transaction identifier is incremented at the end of\neach message\
    \ transaction.  All Responses with the same specified\n(Client, Transaction) pair\
    \ are associated with this Request.\nThe transaction identifier is used for duplicate\
    \ suppression at the\nServer.  A Server maintains a state record for each Client\
    \ for which it\nis processing a Request, identified by (Client, Transaction).\
    \  A Request\nwith the same (Client, Transaction) pair is discarded as a duplicate.\n\
    (The ForwardCount field must also be equal.)  Normally, this record is\nretained\
    \ for some period after the Response is sent, allowing the Server\nto filter out\
    \ subsequent duplicates of this Request.  When a Request\narrives and the Server\
    \ does not have a state record for the sending\nClient, the Server takes one of\
    \ three actions:\n   1. The Server may send a Probe request, a simple query\n\
    \      operation, to the VMTP management module associated with the\n      requesting\
    \ Client to determine the Client's current\n      Transaction identifier (and\
    \ other information), initialize a\n      new state record from this information,\
    \ and then process the\n      Request as above.\n   2. The Server may reason that\
    \ the Request must be a new request\n      because it does not have a state record\
    \ for this Client if it\n      keeps these state records for the maximum packet\
    \ lifetime of\n      packets in the network (plus the maximum VMTP retransmission\n\
    \      time) and it has not been rebooted within this time period.\n      That\
    \ is, if the Request is not new either the Request would\n      have exceeded\
    \ the maximum packet lifetime or else the Server\n      would have a state record\
    \ for the Client.\n   3. The Server may know that the Request is idempotent or\
    \ can be\n      safely redone so it need not care whether the Request is a\n \
    \     duplicate or not.  For example, a request for the current\n      time can\
    \ be responded to with the current time without being\n      concerned whether\
    \ the Request is a duplicate.  The Response\n      is discarded at the Client\
    \ if it is no longer of interest.\nRFC 1045                       VMTP       \
    \                 February 1988 \n2.5.2. Checksum\nEach VMTP packet contains a\
    \ checksum to allow the receiver to detect\ncorrupted packets independent of lower\
    \ level checks.  The checksum field\nis 32 bits, providing greater protection\
    \ than the standard 16-bit IP\nchecksum (in combination with an improved checksum\
    \ algorithm).  The\nlarge packets, high packet rates and general network characteristics\n\
    expected in the future warrant a stronger checksum mechanism.\nThe checksum normally\
    \ covers both the VMTP header and the segment data.\nOptionally (for real-time\
    \ applications), the checksum may apply only to\nthe packet header, as indicated\
    \ by the HCO control bit being set in the\nheader.  The checksum field is placed\
    \ at the end of the packet to allow\nit to be calculated as part of a software\
    \ copy or as part of a hardware\ntransmission or reception packet processing pipeline,\
    \ as expected in the\nnext generation of network interfaces.  Note that the number\
    \ of header\nand data octets is an integral multiple of 8 because VMTP requires\
    \ that\nthe segment data be padded to be a multiple of 64 bits.  The checksum\n\
    field is appended after the padding, if any.  The actual algorithm is\ndescribed\
    \ in Section 3.2.\nA zero checksum field indicates that no checksum was transmitted\
    \ with\nthe packet.  VMTP may be used without a checksum only when there is a\n\
    host-to-host error detection mechanism and the VMTP security facility is\nnot\
    \ being used.  For example, one could rely on the Ethernet CRC if\ncommunication\
    \ is restricted to hosts on the same Ethernet and the\nnetwork interfaces are\
    \ considered sufficiently reliable.\n2.5.3. Request and Response Acknowledgment\n\
    VMTP assumes an unreliable datagram network and internetwork interface.\nTo guarantee\
    \ delivery of Requests and Response, VMTP uses positive\nacknowledgments, retransmissions\
    \ and timeouts.\nA Request is normally acknowledged by receipt of a Response associated\n\
    with the Request, i.e. with the same (Client, Transaction).  With\nstreamed message\
    \ transactions, it may also be acknowledged by a\nsubsequent Response that acknowledges\
    \ previous Requests in addition to\nthe transaction it explicitly identifies.\
    \  A Response may be explicitly\nacknowledged by a NotifyVmtpServer operation\
    \ requested of the manager\nfor the Server.  In the case of streaming, this is\
    \ a cumulative\nacknowledgment, acknowledging all Responses with a lower transaction\n\
    identifier as well.)  In addition, with non-streamed communication, a\nsubsequent\
    \ Request from the same Client acknowledges Responses to all\nprevious message\
    \ transactions (at least in the sense that either the\nclient received a Response\
    \ or is no longer interested in Responses to\nRFC 1045                       VMTP\
    \                        February 1988 \nthose earlier message transactions).\
    \  Finally, a client response timeout\n(at the server) acknowledges a Response\
    \ at least in the sense that the\nserver need not be prepared to retransmit the\
    \ Response subsequently.\nNote that there is no end-to-end guarantee of the Response\
    \ being\nreceived by the client at the application level.\n2.5.4. Retransmissions\n\
    In general, a Request or Response is retransmitted periodically until\nacknowledged\
    \ as above, up to some maximum number of retransmissions.\nVMTP uses parameters\
    \ RequestRetries(Server) and ResponseRetries(Client)\nthat indicate the number\
    \ of retransmissions for the server and client\nrespectively before giving up.\
    \  We suggest the value 5 be used for both\nparameters based on our experience\
    \ with VMTP and Internet packet loss.\nSmaller values (such as 3) could be used\
    \ in low loss environments in\nwhich fast detection of failed hosts or communication\
    \ channels is\nrequired.  Larger values should be used in high loss environments\
    \ where\ntransport-level persistence is important.\nIn a low loss environment,\
    \ a retransmission only includes the MCB and\nnot the segment data of the Request\
    \ or Response, resulting in a single\n(short) packet on retransmission.  The intended\
    \ recipient of the\nretransmission can request selective retransmission of all\
    \ or part of\nthe segment data as necessary.  The selective retransmission mechanism\n\
    is described in Section 2.13.\nIf a Response is specified as idempotent, the Response\
    \ is neither\nretransmitted nor stored for retransmission.  Instead, the Client\
    \ must\nretransmit the Request to effectively get the Response retransmitted.\n\
    The server VMTP module responds to retransmissions of the Request by\npassing\
    \ the Request on to the server again to have it regenerate the\nResponse (by redoing\
    \ the operation), rather than saving a copy of the\nResponse.  Only Request packets\
    \ for the last transaction from this\nclient are passed on in this fashion; older\
    \ Request packets from this\nclient are discarded as delayed duplicates.  If a\
    \ Response is not\nidempotent, the VMTP module must ensure it has a copy of the\
    \ Response\nfor retransmission either by making a copy of the Response (either\n\
    physically or copy-on-write) or by preventing the Server from continuing\nuntil\
    \ the Response is acknowledged.\n2.5.5. Timeouts\nThere is one client timer for\
    \ each Client with an outstanding\ntransaction.  Similarly, there is one server\
    \ timer for each Client\ntransaction that is \"active\" at the server, i.e. there\
    \ is a transaction\nRFC 1045                       VMTP                      \
    \  February 1988 \nrecord for a Request from the Client.\nWhen the client transmits\
    \ a new Request (without streaming), the client\ntimer  is set to roughly the\
    \ time expected for the Response to be\nreturned.  On timeout, the Request is\
    \ retransmitted with the APG\n(Acknowledge Packet Group) bit set.  The timeout\
    \ is reset to the\nexpected roundtrip time to the Server because an acknowledgment\
    \ should\nbe returned immediately unless a Response has been sent.  The Request\n\
    may also be retransmitted in response to receipt of a VMTP management\noperation\
    \ indicating that selected portions of the Request message\nsegment need to be\
    \ retransmitted.  With streaming, the timeout applies\nto the oldest outstanding\
    \ message transaction in the run of outstanding\nmessage transactions.  Without\
    \ streaming, there is one message\ntransaction in the run, reducing to the previous\
    \ situation.  After the\nfirst packet of a Response is received, the Client resets\
    \ the timeout to\nbe the time expected before the next packet in the Response\
    \ packet group\nis received, assuming it is a multi-packet Response.  If not,\
    \ the timer\nis stopped.  Finally, the client timer is used to timeout waiting\
    \ for\nsecond and subsequent Responses to a multicast Request.\nThe client timer\
    \ is set at different times to four different values:\nTC1(Server)     The expected\
    \ time required to receive a Response from\n                the Server.  Set on\
    \ initial Request transmission plus\n                after its management module\
    \ receives a NotifyVmtpClient\n                operation, acknowledging the Request.\n\
    TC2(Server)     The estimated round trip delay between the client and\n      \
    \          the server.  Set when retransmitting after receiving no\n         \
    \       Response for TC1(Server) time and retransmitting the\n               \
    \ Request with the APG bit set.\nTC3(Server)     The estimated maximum expected\
    \ interpacket time for\n                multi-packet Responses from the Server.\
    \  Set when\n                waiting for subsequent Response packets within a\
    \ packet\n                group before timing out.\nTC4             The time to\
    \ wait for additional Responses to a group\n                Request after the\
    \ first Response is received.  This is\n                specified by the user\
    \ level.\nThese values are selected as follows.  TC1 can be set to TC2 plus a\n\
    constant, reflecting the time within which most servers respond to most\nrequests.\
    \  For example, various measurements of VMTP usage at Stanford\nindicate that\
    \ 90 percent of the servers respond in less than 200\nmilliseconds.  Setting TC1\
    \ to TC2 + 200 means that most Requests receive\na Response before timing out\
    \ and also that overhead for retransmission\nRFC 1045                       VMTP\
    \                        February 1988 \nfor long running transactions is insignificant.\
    \  A sophisticated\nimplementation may make the estimation of TC1 further specific\
    \ to the\nServer.\nTC2 may be estimated by measuring the time from when a Probe\
    \ request is\nsent to the Server to when a response is received.  TC2 can also\
    \ be\nmeasured as the time between the transmission of a Request with the APG\n\
    bit set to receipt of a management operation acknowledging receipt of\nthe Request.\n\
    When the Server is an entity group, TC1 and TC2 should be the largest of\nthe\
    \ values for the members of the group that are expected to respond.\nThis information\
    \ may be determined by probing the group on first use\n(and using the values for\
    \ the last responses to arrive).  Alternatively,\none can resort to default values.\n\
    TC3 is set initially to 10 times the transmission time for the maximum\ntransmission\
    \ unit (MTU) to be used for the Response.  A sophisticated\nimplementation may\
    \ record TC3 per Server and refine the estimate based\non measurements of actual\
    \ interpacket gaps.  However, a tighter estimate\nof TC3 only improves the reaction\
    \ time when a packet is lost in a packet\ngroup, at some cost in unnecessary retransmissions\
    \ when the estimate\nbecomes overly tight.\nThe server timer, one per active Client,\
    \ takes on the following values:\nTS1(Client)     The estimated maximum expected\
    \ interpacket time.  Set\n                when waiting for subsequent Request\
    \ packets within a\n                packet group before timing out.\nTS2(Client)\
    \     The time to wait to hear from a client before\n                terminating\
    \ the server processing of a Request.  This\n                limits the time spent\
    \ processing orphan calls, as well\n                as limiting how out of date\
    \ the server's record of the\n                Client state can be.  In particular,\
    \ TS2 should be\n                significantly less than the minimum time within\
    \ which it\n                is reasonable to reuse a transaction identifier.\n\
    TS3(Client)     Estimated roundtrip time to the Client,\nTS4(Client)     The time\
    \ to wait after sending a Response (or last\n                hearing from a client)\
    \ before discarding the state\n                associated with the Request which\
    \ allows it to filter\n                duplicate Request packets and regenerate\
    \ the Response.\nTS5(Client)     The time to wait for an acknowledgment after\
    \ sending a\n                Response before retransmitting the Response, or giving\n\
    RFC 1045                       VMTP                        February 1988 \n  \
    \              up (after some number of retransmissions).\nTS1 is set the same\
    \ as TC3.\nThe suggested value for TS2 is TC1 + 3*TC2 for this server, giving\
    \ the\nClient time to timeout waiting for a Response and retransmit 3 Request\n\
    packets, asking for acknowledgments.\nTS3 is estimated the same as TC1 except\
    \ that refinements to the estimate\nuse measurements of the Response-to-acknowledgment\
    \ times.\nIn the general case, TS4 is set large enough so that a Client issuing\
    \ a\nseries of closely-spaced Requests to the same Server reuses the same\nstate\
    \ record at the Server end and thus does not incur the overhead of\nrecreating\
    \ this state.  (The Server can recreate the state for a Client\nby performing\
    \ a Probe on the Client to get the needed information.)  It\nshould also be set\
    \ low enough so that the transaction identifier cannot\nwrap around and so that\
    \ the Server does not run out of CSR's.  We\nsuggest a value in the range of 500\
    \ milliseconds.  However, if the\nServer accepts non-idempotent Requests from\
    \ this Client without doing a\nProbe on the Client, the TS4 value for this CSR\
    \ is set to at least 4\ntimes the maximum packet lifetime.\nTS5 is TS3 plus the\
    \ expected time for transmission and reception of the\nResponse.  We suggest that\
    \ the latter be calculated as 3 times the\ntransmission time for the Response\
    \ data, allowing time for reception,\nprocessing and transmission of an acknowledgment\
    \ at the Client end.  A\nsophisticated implementation may refine this estimate\
    \ further over time\nby timing acknowledgments to Responses.\n2.5.6. Rate Control\n\
    VMTP is designed to deal with the present and future problem of packet\noverruns.\
    \  We expect overruns to be the major cause of dropped packets\nin the future.\
    \  A client is expected to estimate and adjust the\ninterpacket gap times so as\
    \ to not overrun a server or intermediate\nnodes.  The selective retransmission\
    \ mechanism allows the server to\nindicate that it is being overrun (or some intermediate\
    \ point is being\noverrun).  For example, if the server requests retransmission\
    \ of every\nKth block, the client should assume overrun is taking place and increase\n\
    the interpacket gap times.  The client passes the server an indication\nof the\
    \ interpacket gap desired for a response.  The client may have to\nincrease the\
    \ interval because packets are being dropped by an\nintermediate gateway or bridge,\
    \ even though it can handle a higher rate.\nA conservative policy is to increase\
    \ the interpacket gap whenever a\npacket is lost as part of a multi-packet packet\
    \ group.\nRFC 1045                       VMTP                        February\
    \ 1988 \nThe provision of selective retransmission allows the rate of the client\n\
    and the server to \"push up\" against the maximum rate (and thus lose\npackets)\
    \ without significant penalty.  That is, every time that packet\ntransmission\
    \ exceeds the rate of the channel or receiver, the recovery\ncost to retransmit\
    \ the dropped packets is generally far less than\nretransmitting from the first\
    \ dropped packet.\nThe interpacket gap is expressed in 1/32nd's of the MTU packet\n\
    transmission time.  The minimum interpacket gap is 0 and the maximum gap\nthat\
    \ can be described in the protocol is 8 packet times.  This places a\nlimit on\
    \ the slowest receivers that can be efficiently used on a\nnetwork, at least those\
    \ handling multi-packet Requests and Responses.\nThis scheme also limits the granularity\
    \ of adjustment.  However, the\ngranularity is relative to the speed of the network,\
    \ as opposed to an\nabsolute time.  For entities on different networks of significantly\n\
    different speed, we assume the interconnecting gateways can buffer\npackets to\
    \ compensate<2>. With different network speeds and intermediary\nnodes subject\
    \ to packet loss, a node must adjust the interpacket gap\nbased on packet loss.\
    \  The interpacket gap parameter may be of limited\nuse.\n2.6. Security\nVMTP\
    \ provides an (optional) secure mode that protects against the usual\nsecurity\
    \ threats of peeking, impostoring, message tampering and replays.\nSecure VMTP\
    \ must be used to guarantee any of the transport-level\nreliability properties\
    \ unless it is guaranteed that there are no\nintruders or agents that can modify\
    \ packets and update the packet\nchecksums.  That is, non-secure VMTP provides\
    \ no guarantees in the\npresence of an intelligent intruder.\nThe design closely\
    \ follows that described by Birrell [1].  Authenticated\ninformation about a remote\
    \ entity, including an encryption/decryption\nkey, is obtained and maintained\
    \ using a VMTP management operation, the\nauthenticated Probe operation, which\
    \ is executed as a non-secure VMTP\nmessage transaction.  If a server receives\
    \ a secure Request for which\nthe server has no entity state, it sends a Probe\
    \ request to the VMTP\n_______________\n<2>   Gateways must also employ techniques\
    \ to preserve or intelligently\nmodify (if appropriate) the interpacket gaps.\
    \  In particular, they must\nbe sure not to arbitrarily remove interpacket gaps\
    \ as a result of their\nforwarding of packets.\nRFC 1045                     \
    \  VMTP                        February 1988 \nmanagement module of the client,\
    \ \"challenging\" it to provide an\nauthenticator that both authenticates the\
    \ client as being associated\nwith a particular principal as well as providing\
    \ a key for\nencryption/decryption.  The principal can include a real and effective\n\
    principal, as used in UNIX <3>.  Namely, the real principal is the\nprincipal\
    \ on whose behalf the Request is being performed whereas the\neffective principal\
    \ is the principal of the module invoking the request\nor remote procedure call.\n\
    Peeking is prevented by encrypting every Request and Response packet\nwith a working\
    \ Key that is shared between Client and Server.\nImpostoring and replays are detected\
    \ by comparing the Transaction\nidentifier with that stored in the corresponding\
    \ entity state record\n(which is created and updated by VMTP as needed).  Message\
    \ tampering is\ndetected by encryption of the packet including the Checksum field.\
    \  An\nintruder cannot update the checksum after modifying the packet without\n\
    knowing the Key.  The cost of fully encrypting a packet is close to the\ncost\
    \ of generating a cryptographic checksum (and of course, encryption\nis needed\
    \ in the general case), so there is no explicit provision for\ncryptographic checksum\
    \ without packet encryption.\nA Client determines the Principal of the Server\
    \ and acquires an\nauthenticator for this Server and Principal using a higher\
    \ level\nprotocol.  The Server cannot decrypt the authenticator or the Request\n\
    packets unless it is in fact the Principal expected by the Client.\nAn encrypted\
    \ VMTP packet is flagged by the EPG bit  in the VMTP packet\nheader.  Thus, encrypted\
    \ packets are easily detected and demultiplexed\nfrom unencrypted packets.  An\
    \ encrypted VMTP packet is entirely\nencrypted except for the Client, Version,\
    \ Domain, Length and Packet\nFlags fields at the beginning of the packet.  Client\
    \ identifiers can be\nassigned, changed and used to have no real meaning to an\
    \ intruder or to\nonly communicate public information (such as the host Internet\
    \ address).\nThey are otherwise just a random means of identification and\ndemultiplexing\
    \ and do not therefore divulge any sensitive information.\nFurther secure measures\
    \ must be taken at the network or data link levels\nif this information or traffic\
    \ behavior is considered sensitive.\nVMTP provides multiple authentication domains\
    \  as well as an encryption\nqualifier to accommodate different encryption algorithms\
    \ and their\n_______________\n<3>   Principal group membership must be obtained,\
    \ if needed, by a\nhigher level protocol.\nRFC 1045                       VMTP\
    \                        February 1988 \ncorresponding security/performance trade-offs.\
    \  (See Appendix V.)  A\nseparate key distribution and authentication protocol\
    \ is required to\nhandle generation and distribution of authenticators and keys.\
    \  This\nprotocol can be implemented on top of VMTP and can closely follow the\n\
    Birrell design as well.\nSecurity is optional in the sense that messages may be\
    \ secure or\nnon-secure, even between consecutive message transactions from the\
    \ same\nclient.  It is also optional in that VMTP clients and servers are not\n\
    required to implement secure VMTP (although they are required to respond\nintelligently\
    \ to attempts to use secure VMTP).  At worst, a Client may\nfail to communicate\
    \ with a Server if the Server insists on secure\ncommunication and the Client\
    \ does not implement security or vice versa.\nHowever, a failure to communicate\
    \ in this case is necessary from a\nsecurity standpoint.\n2.7. Multicast\nThe\
    \ Server entity identifier in a message transaction can identify an\nentity group,\
    \ in which case the Request is multicast to every Entity in\nthis group (on a\
    \ best-efforts basis).  The Request is retransmitted\nuntil at least one Response\
    \ is received (or an error timeout occurs)\nunless it is a datagram Request. \
    \ The Client can receive multiple\nResponses to the Request.\nThe VMTP service\
    \ interface does not directly provide reliable multicast\nbecause it is expensive\
    \ to provide, rarely needed by applications, and\ncan be implemented by applications\
    \ using the multiple Response feature.\nHowever, the protocol itself is adequate\
    \ for reliable multicast using\npositive acknowledgments.  In particular, a sophisticated\
    \ Client\nimplementation could maintain a list of members for each entity group\
    \ of\ninterest and retransmit the Request until acknowledged by all members.\n\
    No modifications are required to the Server implementations.\nVMTP supports a\
    \ simple form of subgroup addressing.  If the CRE  bit is\nset in a Request, the\
    \ Request is delivered to the subgroup of entities\nin the Server group that are\
    \ co-resident with one or more entities in\nthe group (or individual entity) identified\
    \ by the CoresidentEntity\nfield of the Request.  This is commonly used to send\
    \ to the manager\nentity for a particular entity, where Server specifies the group\
    \ of such\nmanagers.  Co-resident means \"using the same VMTP module\", and logically\n\
    on the same network host.  In particular, a Probe request can be sent to\nthe\
    \ particular VMTP management module for an entity by specifying the\nVMTP management\
    \ group as the Server and the entity in question as the\nCoResidentEntity.\nRFC\
    \ 1045                       VMTP                        February 1988 \nAs an\
    \ experimental aspect of the protocol, VMTP supports the Server\nsending a group\
    \ Response which is sent to the Client as well as members\nof the destination\
    \ group of Servers to which the original Request was\nsent.  The MDG bit indicates\
    \ whether the Client is a member of this\ngroup, allowing the Server module to\
    \ determine whether separately\naddressed packet groups are required to send the\
    \ Response to both the\nClient and the Server group.  Normally, a Server accepts\
    \ a group\nResponse only if it has received the Request and not yet responded\
    \ to\nthe Client.  Also, the Server must explicitly indicate it wants to\naccept\
    \ group Responses.  Logically, this facility is analogous to\nresponding to a\
    \ mail message sent to a distribution list by sending a\ncopy of the Response\
    \ to the distribution list.\n2.8. Real-time Communication\nVMTP provides three\
    \ forms of support for real-time communication, in\naddition to its standard facilities,\
    \ which make it applicable to a wide\nrange of real-time applications.  First,\
    \ a priority is transmitted in\neach Request and Response which governs the priority\
    \ of its handling.\nThe priority levels are intended to correspond roughly to:\n\
    \   - urgent/emergency.\n   - important\n   - normal\n   - background.\nwith additional\
    \ gradations for each level.  The interpretation and\nimplementation of these\
    \ priority levels is otherwise host-specific, e.g.\nthe assignment to host processing\
    \ priorities.\nSecond, datagram Requests allow the Client to send a datagram to\
    \ another\nentity or entity group using the VMTP naming, transmission and delivery\n\
    mechanism, but without blocking, retransmissions or acknowledgment.\n(The client\
    \ can still request acknowledgment using the APG bit although\nthe Server does\
    \ not expect missing portions of a multi-packet datagram\nRequest to be retransmitted\
    \ even if some are not received.)  A datagram\nRequest in non-streamed mode supersedes\
    \ all previous Requests from the\nsame Client.  A datagram Request in stream mode\
    \ is queued (if necessary)\nafter previous datagram Requests on the same stream.\
    \  (See Section\n2.11.)\nFinally, VMTP provides several control bit flags to modify\
    \ the handling\nof Requests and Responses for real-time requirements.  First,\
    \ the\nRFC 1045                       VMTP                        February 1988\
    \ \nconditional message delivery (CMD) flag causes a Request to be discarded\n\
    if the recipient is not waiting for it when it arrives, similarly for\nthe Response.\
    \  This option allows a client to send a Request that is\ncontingent on the server\
    \ being able to process it immediately.  The\nheader checksum only (HCO) flag\
    \ indicates that the checksum has been\ncalculated only on the VMTP header and\
    \ not on the data segment.\nApplications such as voice and video can avoid the\
    \ overhead of\ncalculating the checksum on data whose utility is insensitive to\
    \ typical\nbit errors without losing protection on the header information.\nFinally,\
    \ the No Retransmission (NRT) flag indicates that the recipient\nof a message\
    \ should not ask for retransmission if part of the message is\nmissing but rather\
    \ either use what was received or discard it.\nNone of these facilities introduce\
    \ new protocol states.  In fact, the\ntotal processing overhead in the normal\
    \ case is a bit flag test for CMD,\nHCO or NRT plus assignment of priority on\
    \ packet transmission and\nreception.  (In fact, CMD and NRT are not tested in\
    \ the normal case.)\nThe additional code complexity is minimal.  We feel that\
    \ the overhead\nfor providing these real-time facilities is minimal and that these\n\
    facilities are both important and adequate for a wide class of real-time\napplications.\n\
    Several of the normal facilities of VMTP appear useful for real-time\napplications.\
    \  First, multicast is useful for distributed, replicated\n(fault-tolerant) real-time\
    \ applications, allowing efficient state query\nand update for (for example) sensors\
    \ and control state.  Second, the DGM\nor idempotent flag for Responses has some\
    \ real-time benefits, namely:  a\nRequest is redone to get the latest values when\
    \ the Response is lost,\nrather than just returning the old values.  The desirability\
    \ of this\nbehavior is illustrated by considering a request for the current time\
    \ of\nday.  An idempotent handling of this request gives better accuracy in\n\
    returning the current time in the case that a retransmission is\nnecessary.  Finally,\
    \ the request-response semantics (in the absence of\nstreaming) of each new Request\
    \ from a Client terminating the previous\nmessage transactions from that Client,\
    \ if any, provides the \"most recent\nis most important\" handling of processing\
    \ that most real-time\napplications require.\nIn general, a key design goal of\
    \ VMTP was provide an efficient\ngeneral-purpose transport protocol with the features\
    \ required for\nreal-time communication.  Further experience is required to determine\n\
    whether this goal has been achieved.\nRFC 1045                       VMTP    \
    \                    February 1988 \n2.9. Forwarded Message Transactions\nA Server\
    \ may invoke another Server to handle a Request.  It is fairly\ncommon for the\
    \ invocation of the second Server to be the last action\nperformed by the first\
    \ Server as part of handling the Request.  For\nexample, the original Server may\
    \ function primarily to select a process\nto handle the Request.  Also, the Server\
    \ may simply check the\nauthorization on the Request.  Describing this situation\
    \ in the context\nof RPC, a nested remote procedure call may be the last action\
    \ in the\nremote procedure and the return parameters are exactly those of the\n\
    nested call.  (This situation is analogous to tail recursion.)\nAs an optimization\
    \ to support this case, VMTP provides a Forward\noperation that allows the server\
    \ to send the nested Request to the other\nserver and have this other server respond\
    \ directly to the Client.\nIf the message transaction being forwarded was not\
    \ multicast, not secure\nor the two Servers are the same principal and the ForwardCount\
    \ of the\nRequest is less than the maximum forward count of 15, the Forward\n\
    operation is implemented by the Server sending a Request onto the next\nServer\
    \ with the forwarded Request identified by the same Client and\nTransaction as\
    \ the original Request and a ForwardCount one greater than\nthe Request received\
    \ from the Client.  In this case, the new Server\nresponds directly to the Client.\
    \  A forwarded Request is illustrated in\nthe following figure.\n +---------+\
    \   Request       +----------+\n | Client  +---------------->| Server 1 |\n +---------+\
    \                 +----------+\n      ^                        |\n      |    \
    \                    | forwarded Request\n      |                        V\n \
    \     |   Response           +----------+\n      +----------------------| Server\
    \ 2 |\n                             +----------+\nIf the message transaction does\
    \ not meet the above requirements, the\nServer's VMTP module issues a nested call\
    \ and simply maps the returned\nResponse to a Response to original Request without\
    \ further Server-level\nprocessing.  In this case, the only optimization over\
    \ a user-level\nnested call is one fewer VMTP service operation; the VMTP module\
    \ handles\nthe return to the invoking call directly.  The Server may also use\
    \ this\nform of forwarding when the Request is part of a stream of message\ntransactions.\
    \  Otherwise, it must wait until the forwarded message\ntransaction completes\
    \ before proceeding with the subsequent message\ntransactions in the stream.\n\
    RFC 1045                       VMTP                        February 1988 \nImplementation\
    \ of the user-level Forward operation is optional,\ndepending on whether the server\
    \ modules require this facility.  Handling\nan incoming forwarded Request is a\
    \ minor modification of handling a\nnormal incoming Request.  In particular, it\
    \ is only necessary to examine\nthe ForwardCount field when the Transaction of\
    \ the Request matches that\nof the last message transaction received from the\
    \ Client.  Thus, the\nadditional complexity in the VMTP module for the required\
    \ forwarding\nsupport is minimal; the complexity is concentrated in providing\
    \ a highly\noptimized user-level Forward primitive, and that is optional.\n2.10.\
    \ VMTP Management\nVMTP management includes operations for creating, deleting,\
    \ modifying\nand querying VMTP entities and entity groups.  VMTP management is\n\
    logically implemented by a VMTP management server module that is invoked\nusing\
    \ a message transaction addressed to the Server, VMTP_MANAGER_GROUP,\na well-known\
    \ group entity identifier, in conjunction with Coresident\nEntity mechanism introduced\
    \ in Section 2.7.  A particular Request may\naddress the local module, the module\
    \ managing a particular entity, the\nset of modules managing those entities contained\
    \ in a specific group or\nall management modules, as appropriate.\nThe VMTP management\
    \ procedures are specified in Appendix III.\n2.11. Streamed Message Transactions\n\
    Streamed message transactions refer to two or more message transactions\ninitiated\
    \ by a Client before it receives the response to the first\nmessage transaction,\
    \ with each transaction being processed and responded\nto in order but asynchronous\
    \ relative to the initiation of the\ntransactions.  A Client streams messages\
    \ transactions, and thereby has\nmultiple message transactions outstanding, by\
    \ sending them as part of a\nsingle run of message transactions.  A run  of message\
    \ transactions is a\nsequence of message transactions with the same Client and\
    \ Server and\nconsecutive Transaction identifiers, with all but the first and\
    \ last\nRequests and Responses flagged with the NSR (Not Start Run)  and NER\n\
    (Not End Run)  control bits.  (Conversely, the first Request and\nResponse does\
    \ not have the NSR set and the last Request and Response\ndoes not have the NER\
    \ bit set.)  The message transactions in a run use\nRFC 1045                 \
    \      VMTP                        February 1988 \nconsecutive transaction identifiers\
    \ (except if the STI bit <4> is used\nin one, in which case the transaction identifier\
    \ for the next message\ntransaction is 256 greater, rather than 1).\nThe Client\
    \ retains a record for each outstanding transaction until it\ngets a Response\
    \ or is timed out in error.  The record provides the\ninformation required to\
    \ retransmit the Request.  On retransmission\ntimeout, the client retransmits\
    \ the last Request for which it has not\nreceived a Response the same as is done\
    \ with non-streamed communication.\n(I.e. there need be only one timeout for all\
    \ the outstanding message\ntransactions associated with a single client.)\nThe\
    \ consecutive transaction identifiers within a run of message\ntransactions are\
    \ used as sequence numbers for error control.  The Server\nhandles each message\
    \ transaction in the sequence specified by its\ntransaction identifier.  When\
    \ it receives a message transaction that is\nnot marked as the beginning of a\
    \ run, it checks that it previously\nreceived a message transaction with the predecessor\
    \ transaction\nidentifier, either 1 less than the current one or 256 less if the\n\
    previous one had the STI bit set.  If not, the Server sends a\nNotifyVmtpClient\
    \ operation to the Client's manager indicating either:\n(1) the first message\
    \ transaction was not fully received, or else (2) it\nhas no record of the last\
    \ one received.  If the NRT control flag is set,\nit does not await nor expect\
    \ retransmission but proceeds with handling\nthis Request.  This flag is used\
    \ primarily when datagram Requests are\nused as part of a stream of message transactions.\
    \  If NRT was not\nspecified, the Client must retransmit from the first message\
    \ transaction\nnot fully received (either at all or in part) before the Server\
    \ can\nproceed with handling this run of Requests or else restart the run of\n\
    message transactions.\nThe Client expects to receive the Responses in a consecutive\
    \ sequence,\nusing the Transaction identifier to detect missing Responses.  Thus,\
    \ the\nServer must return Responses in sequence except possibly for some gaps,\n\
    as follows.  The Server can specify in the PGcount field in a Response,\nthe number\
    \ of consecutively previous Responses that this Response\n_______________\n<4>\
    \   The STI bit is used by the Client to effectively allocate 255\ntransaction\
    \ identifiers for use by the Server in returning a large\nResponse or stream of\
    \ Responses.\nRFC 1045                       VMTP                        February\
    \ 1988 \ncorresponds to, up to a maximum of 255 previous Responses <5>.  Thus,\n\
    for example, a Response with Transaction identifier 46 and PGcount 3\nrepresents\
    \ Responses 43, 44, 45 and 46.  This facility allows the Server\nto eliminate\
    \ sending Responses to Requests that require no Response,\neffectively batching\
    \ the Responses into one.  It also allows the Server\nto effectively maintain\
    \ strictly consecutive sequencing when the Client\nhas skipped 256 Transaction\
    \ identifiers using the STI bit and the Server\ndoes not have that many Responses\
    \ to return.\nIf the Client receives a Response that is not consecutive, it\n\
    retransmits the Request(s) for which the Response(s) is/are missing\n(unless,\
    \ of course, the corresponding Requests were sent as datagrams).\nThe Client should\
    \ wait at the end of a run of message transactions for\nthe last one to complete.\n\
    When a Server receives a Request with the NSR bit clear and a higher\ntransaction\
    \ identifier than it currently has for the Client, it\nterminates all processing\
    \ and discards Responses associated with the\nprevious Requests.  Thus, a stream\
    \ of message transactions is\neffectively aborted by starting a new run, even\
    \ if the Server was in the\nmiddle of handling the previous run.\nUsing a mixture\
    \ of datagram and normal Requests as part of a stream of\nmessage transactions,\
    \ particularly with the use of the NRT bit, can lead\nto complex behavior under\
    \ packet loss.  It is recommended that a run of\nmessage transactions be all of\
    \ one type to avoid problems, i.e. all\nnormal or all datagrams.  Finally, when\
    \ a Server forwards a Request that\nis part of a run, it must suspend further\
    \ processing of the subsequent\nRequests until the forwarded Request has been\
    \ handled, to preserve order\nof processing.  The simplest handling of this situation\
    \ is to use a real\nnested call when forwarding with streamed message transactions.\n\
    Flow control of streamed message transactions relies on rate control at\nthe Client\
    \ plus receipt (or non-receipt) of management notify operations\nindicating the\
    \ presence of overrunning.  A Client must reduce the number\nof outstanding message\
    \ transactions at the Server when it receives a\nNotifyVmtpServer operation with\
    \ the MSGTRANS_OVERFLOW ResponseCode.  The\ntransact parameter indicates the last\
    \ packet group that was accepted.\n_______________\n<5>  PGcount actually corresponds\
    \ to packet groups which are described\nin Section 2.13.  This (simplified) description\
    \ is accurate when there\nis one Request or Response per packet group.\nRFC 1045\
    \                       VMTP                        February 1988 \nThe implementation\
    \ of multiple outstanding message transactions requires\nthe ability to record,\
    \ timeout and buffer multiple outstanding message\ntransactions at the Client\
    \ end as well as the Server end.  However, this\nfacility is optional for both\
    \ the Client and the Server.  Client systems\nwith heavy-weight processes and\
    \ high network access cost are most likely\nto benefit from this facility.  Servers\
    \ that serve a wide variety of\nclient machines should implement streaming to\
    \ accommodate these types of\nclients.\n2.12. Fault-Tolerant Applications\nOne\
    \ approach to fault-tolerant systems is to maintain a log of all\nmessages sent\
    \ at each node and replay the messages at a node when the\nnode fails, after restarting\
    \ it from the last checkpoint <6>.  As an\nexperimental facility, VMTP provides\
    \ a Receive Sequence Number field in\nthe NotifyVmtpClient and NotifyVmtpServer\
    \ operations as well as the Next\nReceive Sequence (NRS) flag in the Response\
    \ packet to allow a sender to\nlog a receive sequence number with each message\
    \ sent, allowing the\npackets to be replayed at a recovering node in the same\
    \ sequence as they\nwere originally received, thereby recovering to the same state\
    \ as\nbefore.\nBasically, each sending node maintains a receive sequence number\
    \ for\neach receiving node.  On sending a Request to a node, it presume that\n\
    the receive sequence number is one greater than the one it has recorded\nfor that\
    \ node.  If not, the receiving node sends a notify operation\nindicating the receive\
    \ sequence number assigned the Request.  The NRS in\nthe Response confirms that\
    \ the Request message was the next receive\nsequence number, so the sender can\
    \ detect if it failed to receive the\nnotify operation in the previous case. \
    \ With Responses, the packets are\nordered by the Transaction identifier except\
    \ for multicast message\ntransactions, in which there may be multiple Responses\
    \ with the same\nidentification.  In this case, NotifyVmtpServer operations are\
    \ used to\nprovide receive sequence numbers.\nThis experimental extension of the\
    \ protocol is focused on support for\nfault-tolerant real-time distributed systems\
    \ required in various\ncritical applications.  It may be removed or extended,\
    \ depending on\nfurther investigations.\n_______________\n<6>  The sender-based\
    \ logging is being investigated by Willy Zwaenepoel\nof Rice University.\nRFC\
    \ 1045                       VMTP                        February 1988 \n2.13.\
    \ Packet Groups\nA message (whether Request or Response) is sent as one or more\
    \ packet\ngroups.  A packet group is one or more packets, each containing the\
    \ same\ntransaction identification and message control block.  Each packet is\n\
    formatted as below with the message control block logically embedded in\nthe VMTP\
    \ header.\n +------------------------------------++---------------------+\n |\
    \            VMTP Header             ||                     |\n +------------+-----------------------||\
    \   segment data      |\n |VMTP Control| Message Control Block ||            \
    \         |\n +------------+-----------------------++---------------------+\n\
    The some fields of the VMTP control portion of the packet and data\nsegment portion\
    \ can differ between packets within the same packet group.\nThe segment data portion\
    \ of a packet group represents up to 16\nkilooctets of the segment specified in\
    \ the message control block.  The\nportion contained in each packet is indicated\
    \ by the PacketDelivery\nfield contained in the VMTP header.  The PacketDelivery\
    \ field as a bit\nmask has a similar interpretation to the MsgDelivery field in\
    \ that each\nbit corresponds to a segment data block of 512 octets.  The\nPacketDelivery\
    \ field limits a packet group to 16 kilooctets and a\nmaximum of 32 VMTP packets\
    \ (with a minimum of 1 packet).  Data can be\nsent in fewer packets by sending\
    \ multiple data blocks per packet.  We\nrequire that the underlying datagram service\
    \ support delivery of (at\nminimum) the basic 580 octet VMTP packet <7>.  To illustrate\
    \ the use of\nthe PacketDelivery field, consider for example the Ethernet which\
    \ has a\nMTU of 1536 octets.  so one would send 2 512-octet segment data blocks\n\
    per packet.  (In fact, if a third block is last in the segment and less\nthan\
    \ 512 octets and fits in the packet without making it too big, an\nEthernet packet\
    \ could contain three data blocks.  Thus, an Ethernet\npacket group for a segment\
    \ of size 0x1D00 octets (14.5 blocks) and\nMsgDelivery 0x000074FF consists of\
    \ 6 packets indicated as follows <8>.\n_______________\n<7>  Note that with a\
    \ 20 octet IP header, a VMTP packet is 600\noctets.  We propose the convention\
    \ that any host implementing VMTP\nimplicitly agrees to accept IP/VMTP packets\
    \ of at least 600 octets.\n<8>  We use the C notation 0xHHHH to represent a hexadecimal\
    \ number.\nRFC 1045                       VMTP                        February\
    \ 1988 \n Packet\n Delivery  1 1  1 1  1 1  1 1  0 0  1 0  1 0  1 0  0 0 0 0 0\
    \ . . .\n           0000 0400 0800 0C00 1000 1400 1800 1C00\n          +----+----+----+----+----+----+----+-+\n\
    \ Segment  |....|....|....|....|....|....|....|.|\n          +----+----+----+----+----+----+----+-+\n\
    \          :    :    :    :    :    :  : /  /   :\n          v    v    v    v\
    \    v    v  v   /|   v\n          +----+----+----+----+    +----+  +---+\n Packets\
    \  |  1 |  2 |  3 |  4 |    |  5 |  | 6 |\n          +----+----+----+----+   \
    \ +----+  +---+\nEach '.' is 256 octets of data.  The PacketDelivery masks for\
    \ the 6\npackets are: 0x00000003, 0x0000000C, 0x00000030, 0x000000C0, 0x00001400\n\
    and 0x00006000, indicating the segment blocks contained in each of the\npackets.\
    \  (Note that the delivery bits are in little endian order.)\nA packet group is\
    \ sent as a single \"blast\" of packets with no explicit\nflow control.  However,\
    \ the sender should estimate and transmit at a\nrate of packet transmission to\
    \ avoid congesting the network or\noverwhelming the receiver, as described in\
    \ Section 2.5.6.  Packets in a\npacket group can be sent in any order with no\
    \ change in semantics.\nWhen the first packet of a packet group is received (assuming\
    \ the Server\ndoes not decide to discard the packet group), the Server saves a\
    \ copy of\nthe VMTP packet header, indicates it is currently receiving a packet\n\
    group, initializes a \"current delivery mask\" (indicating the data in the\nsegment\
    \ received so far) to 0, accepts this packet (updating the current\ndelivery mask)\
    \ and sets the timer for the packet group.  Subsequent\npackets in the packet\
    \ group update the current delivery mask.\nReception of a packet group is terminated\
    \ when either the current\ndelivery mask indicates that all the packets in the\
    \ packet group have\nbeen received or the packet group reception timer expires\
    \ (set to TC3 or\nTS1).  If the packet group reception timer expires, if the NRT\
    \ bit is\nset in the Control flags then the packet group is discarded if not\n\
    complete unless MDM is set.  In this case, the MsgDelivery field in the\nmessage\
    \ control block is set to indicate the segment data blocks\nactually received\
    \ and the message control block and segment data\nreceived is delivered to application\
    \ level.\nIf NRT is not set and not all data blocks have been received, a\nNotifyVmtpClient\
    \ (if a Request) or NotifyVmtpServer (if a Response) is\nsent back with a PacketDelivery\
    \ field indicating the blocks received.\nThe source of the packet group is then\
    \ expected to retransmit the\nmissing blocks.  If not all blocks of a Request\
    \ are received after\nRequestAckRetries(Client) retransmissions, the Request is\
    \ discarded and\nRFC 1045                       VMTP                        February\
    \ 1988 \na NotifyVmtpClient operation with an error response code is sent to the\n\
    client's manager unless MDM is set.  With a Response, there are\nResponseAckRetries(Server)\
    \ retransmissions and then, if MDM is not set,\nthe requesting entity is returned\
    \ the message control block with an\nindication of the amount of segment data\
    \ received extending contiguously\nfrom the start of the segment.  E.g. if the\
    \ sender sent 6 512-octet\nblocks and only the first two and the last two arrived,\
    \ the receiver\nwould be told that 1024 octets were received.  The ResponseCode\
    \ field is\nset to BAD_REPLY_SEGMENT.  (Note that VMTP is only able to indicate\
    \ the\nspecific segment blocks received if MDM is set.)\nThe parameters RequestAckRetries(Client)\
    \ and ResponseAckRetries(Server)\ncould be set on a per-client and per-server\
    \ basis in a sophisticated\nimplementation based on knowledge of packet loss.\n\
    If the APG flag is set, a NotifyVmtpClient or NotifyVmtpServer\noperation is sent\
    \ back at the end of the packet group reception,\ndepending on whether it is a\
    \ Request or a Response.\nAt minimum, a Server should check that each packet in\
    \ the packet group\ncontains the same Client, Server, Transaction identifier and\
    \ SegmentSize\nfields.  It is a protocol error for any field other than the Checksum,\n\
    packet group control flags, Length and PacketDelivery in the VMTP header\nto differ\
    \ between any two packets in one packet group.  A packet group\ncontaining a protocol\
    \ error of this nature should be discarded.\nNotify operations should be sent\
    \ (or invoked) in the manager whenever\nthere is a problem with a unicast packet.\
    \  i.e. negative acknowledgments\nare always sent in this case.  In the case of\
    \ problems with multicast\npackets, the default is to send nothing in response\
    \ to an error\ncondition unless there is some clear reason why no other node can\n\
    respond positively.  For example, the packet might be a Probe for an\nentity that\
    \ is known to have been recently existing on the receiving\nhost but now invalid\
    \ and could not have migrated.  In this case, the\nreceiving host responds to\
    \ the Probe indicating the entity is\nnonexistent, knowing that no other host\
    \ can respond to the Probe.  For\npackets and packet groups that are received\
    \ and processed without\nproblems, a Notify operation is invoked only if the APG\
    \ bit is set.\n2.14. Runs of Packet Groups\nA run of packet groups is a sequence\
    \ of packet groups, all Request\npackets or all Response packets, with the same\
    \ Client and consecutive\ntransaction identifiers, all but the first and last\
    \ packets flagged with\nthe NSR (Not Start Run) and NER (Not End Run) control\
    \ bits.  When each\npacket group in the run corresponds to a single Request or\
    \ Response, it\nRFC 1045                       VMTP                        February\
    \ 1988 \nis identical to a run of message transactions. (See Section 2.11)\nHowever,\
    \ a Request message or a Response message may consists of up to\n256 packet groups\
    \ within a run, for a maximum of 4 megaoctets of segment\ndata.  A message that\
    \ is continued in the next packet group in the run\nis flagged in the current\
    \ packet group by the CMG flag.  Otherwise, the\nnext packet group in the run\
    \ (if any) is treated as a separate Request\nor Response.\nNormally, each Request\
    \ and Response message is sent as a single packet\ngroup and each run consists\
    \ of a single packet group.  In this case\nneither NSR or NER are set.  For multi-packet\
    \ group messages, the\nPacketDelivery mask in the i-th packet group of a message\
    \ corresponds to\nthe portion of the segment offset by i-1 times 16 kilooctets,\n\
    designating the the first packet group to have i = 1.\n2.15. Byte Order\nFor purposes\
    \ of transmission and reception, the MCB is treated as\nconsisting of 8 32-bit\
    \ fields and the segment is a sequence of bytes.\nVMTP transmits the MCB in big-endian\
    \ order, performing byte-swapping, if\nnecessary, before transmission.  A little-endian\
    \ host must byte-swap the\nMCB on reception.  (The data segment is transmitted\
    \ as a sequence of\nbytes with no reordering.)  The byte order of the sender of\
    \ a message is\nindicated by the LEE  bit in the entity identifier for the sender,\
    \ the\nClient field if a Request and the Server field if a Response.  The\nsender\
    \ and receiver of a message are required to agree in some higher\nlevel protocol\
    \ (such as an RPC presentation protocol) on who does\nfurther swapping of the\
    \ MCB and data segment if required by the types of\nthe data actually being transmitted.\
    \  For example, the segment data may\ncontain a record with 8-bit, 16-bit and\
    \ 32-bit fields, so additional\ntransformation is required to move the segment\
    \ from a host of one byte\norder to another.\nVMTP to date has used a higher-level\
    \ presentation protocol in which\nsegment data is sent in the native order of\
    \ the sending host and\nbyte-swapped as necessary by the receiving host.  This\
    \ approach\nminimizes the byte-swapping overhead between machines of common byte\n\
    order (including when the communication is transparently local to one\nhost),\
    \ avoids a strong bias in the protocol to one byte-order, and\nallows for the\
    \ sending entity to be sending to a group of hosts with\ndifferent byte orders.\
    \  (Note that the byte-swap overhead for the MCB is\nminimal.)  The presentation-level\
    \ overhead is minimal because most\ncommon operations, such as file access operations,\
    \ have parameters that\nfit the MCB and data segment data types exactly.\nRFC\
    \ 1045                       VMTP                        February 1988 \n2.16.\
    \ Minimal VMTP Implementation\nA minimal VMTP client needs to be able to send\
    \ a Request packet group\nand receive a Response packet group as well as accept\
    \ and respond to\nRequests sent to its management module, including Probe and\
    \ NotifyClient\noperations.  It may also require the ability to invoke Probe and\
    \ Notify\noperations to locate a Server and acknowledge responses.  (the latter\n\
    only if it is involved in transactions that are not idempotent or\ndatagram message\
    \ transactions.  However, a simple sensor, for example,\ncan transmit VMTP datagram\
    \ Requests indicating its current state with\neven less mechanism.)  The minimal\
    \ client thus requires very little code\nand is suitable as a basis for (e.g.)\
    \ a network boot loader.\nA minimal VMTP server implements idempotent, non-encrypted\
    \ message\ntransactions, possibly with no segment data support.  It should use\
    \ an\nentity state record for each Request but need only retain it while\nprocessing\
    \ the Request.  Without segment data larger than a packet,\nthere is no need for\
    \ any timers, buffering (outside of immediate request\nprocessing) or queuing.\
    \  In particular, it needs only as many records as\nmessage transactions it handles\
    \ simultaneously (e.g. 1).  The entity\nstate record is required to recognize\
    \ and respond to Request\nretransmissions during request processing.\nThe minimal\
    \ server need only receive Requests and and be able to send\nResponse packets.\
    \  It need have only a minimal management module\nsupporting Probe operations.\
    \  (Support for the NotifyVmtpClient\noperation is only required if it does not\
    \ respond immediately to a\nRequest.)  Thus the VMTP support for say a time server,\
    \ sensor, or\nactuator can be extremely simple.  Note that the server need never\
    \ issue\na Probe operation if it uses the host address of the Request for the\n\
    Response and does not require the Client information returned by the\nProbe operation.\
    \  The minimal server should also support reception of\nforwarded Requests.\n\
    2.17. Message vs. Procedural Request Handling\nA request-response protocol can\
    \ be used to implement two forms of\nsemantics on reception.  With procedural\
    \ handling of a Request, a\nRequest is handled by a process associated with the\
    \ Server that\neffectively takes on the identity of the calling process, treating\
    \ the\nRequest message as invoking a procedure, and relinquishing its\nassociation\
    \ to the calling process on return.  VMTP supports multiple\nnested calls spanning\
    \ multiple machines.  In this case, the distributed\ncall stack that results is\
    \ associated with a single process from the\nstandpoint of authentication and\
    \ resource management, using the\nProcessId field supported by VMTP.  The entity\
    \ identifiers effectively\nRFC 1045                       VMTP               \
    \         February 1988 \nlink these call frames together.  That is, the Client\
    \ field in a Request\nis effectively the return link to the previous call frame.\n\
    With message handling of a Request, a Request message is queued for a\nserver\
    \ process.  The server process dequeues, reads, processes and\nresponds to the\
    \ Request message, executing as a separate process.\nSubsequent Requests to the\
    \ same server are queued until the server asks\nto receive the next Request.\n\
    Procedural semantics have the advantage of allowing each Request (up to\nthe resource\
    \ limits of the Server) to execute concurrently at the\nServer, with Request-specific\
    \ synchronization.  Message semantics have\nthe advantage that Requests are serialized\
    \ at the Server and that the\nrequest processing logically executes with the priority,\
    \ protection and\nindependent execution of a separate process.  Note that procedural\
    \ and\nmessage handling of a request appear no differently to the client\ninvoking\
    \ the message transaction, except possibly for differences in\nperformance.\n\
    We view the two Request handling approaches as appropriate under\ndifferent circumstances.\
    \  VMTP supports both models.\n2.18. Bibliography\nThe basic protocol is similar\
    \ to that used in the original form of the V\nkernel [3, 4] as well as the transport\
    \ protocol of Birrell and\nNelson's [2] remote procedure call mechanism.  An earlier\
    \ version of the\nprotocol was described in SIGCOMM'86 [6].  The rate-based flow\
    \ control\nis similar to the techniques of Netblt [9].  The support for idempotency\n\
    draws, in part, on the favorable experience with idempotency in the V\ndistributed\
    \ system.  Its use was originally inspired by the Woodstock\nFile Server [11].\
    \  The multicast support draws on the multicast\nfacilities in V [5] and is designed\
    \ to work with, and is now implemented\nusing, the multicast extensions to the\
    \ Internet [8] described in RFC 966\nand 988.  The secure version of the protocol\
    \ is similar to that\ndescribed by Birrell [1] for secure RPC.  The use of runs\
    \ of packet\ngroups is similar to Fletcher and Watson's delta-T protocol [10].\
    \  The\nuse of \"management\" operations implemented using VMTP in place of\n\
    specialized packet types is viewed as part of a general strategy of\nusing recursion\
    \ to simplify protocol architectures [7].\nFinally, this protocol was designed,\
    \ in part, to respond to the\nrequirements identified by Braden in RFC 955.  We\
    \ believe that VMTP\nsatisfies the requirements stated in RFC 955.\nRFC 1045 \
    \                      VMTP                        February 1988 \n[1]   A.D.\
    \ Birrell, \"Secure Communication using Remote Procedure\n      Calls\", ACM.\
    \ Trans. on Computer Systems 3(1), February, 1985.\n[2]   A. Birrell and B. Nelson,\
    \ \"Implementing Remote Procedure Calls\",\n      ACM Trans. on Computer Systems\
    \ 2(1), February, 1984.\n[3]   D.R. Cheriton and W. Zwaenepoel, \"The Distributed\
    \ V Kernel and its\n      Performance for Diskless Workstations\", In Proceedings\
    \ of the 9th\n      Symposium on Operating System Principles,  ACM, 1983.\n[4]\
    \   D.R. Cheriton, \"The V Kernel: A Software Base for Distributed\n      Systems\"\
    , IEEE Software 1(2), April, 1984.\n[5]   D.R. Cheriton and W. Zwaenepoel, \"\
    Distributed Process Groups in\n      the V Kernel\", ACM Trans. on Computer Systems\
    \ 3(2), May, 1985.\n[6]   D.R. Cheriton, \"VMTP: A Transport Protocol for the\
    \ Next\n      Generation of Communication Systems\", In Proceedings of\n     \
    \ SIGCOMM'86, ACM, Aug 5-7, 1986.\n[7]   D.R. Cheriton, \"Exploiting Recursion\
    \ to Simplify an RPC \n      Communication Architecture\", in preparation, 1988.\n\
    [8]   D.R. Cheriton and S.E. Deering, \"Host Groups: A Multicast \n      Extension\
    \ for Datagram Internetworks\", In 9th Data Communication \n      Symposium, IEEE\
    \ Computer Society and ACM SIGCOMM, September, 1985.\n[9]   D.D. Clark and M.\
    \ Lambert and L. Zhang, \"NETBLT: A Bulk Data \n      Transfer Protocol\", Technical\
    \ Report RFC 969, Defense Advanced \n      Research Projects Agency, 1985.\n[10]\
    \  J.G. Fletcher and R.W. Watson, \"Mechanism for a Reliable Timer-\n      based\
    \ Protocol\", Computer Networks 2:271-290, 1978.\nRFC 1045                   \
    \    VMTP                        February 1988 \n[11]  D. Swinehart and G. McDaniel\
    \ and D. Boggs, \"WFS: A Simple File \n      System for a Distributed Environment\"\
    , In Proc. 7th Symp. \n      Operating Systems Principles, 1979.\nRFC 1045   \
    \                    VMTP                        February 1988 \n3. VMTP Packet\
    \ Formats\nVMTP uses 2 basic packet formats corresponding to Request packets and\n\
    Response packets.  These packet formats are identical in most of the\nfields to\
    \ simplify the implementation.\nWe first describe the entity identifier format\
    \ and the packet fields\nthat are used in general, followed by a detailed description\
    \ of each of\nthe packet formats.  These fields are described below in detail.\
    \  The\nindividual packet formats are described in the following subsections.\n\
    The reader and VMTP implementor may wish to refer to Chapters 4 and 5\nfor a description\
    \ of VMTP event handling and only refer to this detailed\ndescription as needed.\n\
    3.1. Entity Identifier Format\nThe 64-bit non-group entity identifiers have the\
    \ following substructure.\n  0                   1                   2       \
    \            3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |R|\
    \ |L|R|\n |A|0|E|E|      Domain-specific structure\n |E| |E|S|\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Domain-specific structure                        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    The field meanings are as follows:\nRAE             Remote Alias Entity - the\
    \ entity identifier identifies\n                an entity that is acting as an\
    \ alias for some entity\n                outside this entity domain.  This bit\
    \ is used by\n                higher-level protocols.  For instance, servers may\
    \ take\n                extra security and protection measures with aliases.\n\
    GRP             Group - 0, for non-group entity identifiers.\nLEE            \
    \ Little-Endian Entity - the entity transmits data in\n                little-endian\
    \ (VAX) order.\nRES              Reserved - must be 0.\nThe 64-bit entity group\
    \ identifiers have the following substructure.\nRFC 1045                     \
    \  VMTP                        February 1988 \n  0                   1       \
    \            2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |R| |U|R|\n |A|1|G|E|      Domain-specific structure\n |E| |P|S|\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Domain-specific structure                        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    The field meanings are as follows:\nRAE             Remote Alias Entity - same\
    \ as for non-group entity\n                identifier.\nGRP             Group\
    \ - 1, for entity group identifiers.\nUGP             Unrestricted Group - no\
    \ restrictions are placed on\n                joining this group.  I.e. any entity\
    \ can join limited\n                only by implementation resources.\nRES   \
    \           Reserved - must be 0.\nThe all-zero entity identifier is reserved\
    \ and guaranteed to be\nunallocated in all domains.  In addition, a domain may\
    \ reserve part of\nthe entity identifier space for statically allocated identifiers.\n\
    However, this is domain-specific.\nDescription of currently defined entity identifier\
    \ domains is provided\nin Appendix IV.\n3.2. Packet Fields\nClient          64-bit\
    \ identifier for the client entity associated with\n                this packet.\
    \  The structure, allocation and binding of\n                this identifier is\
    \ specific to the specified Domain.  An\n                entity identifier always\
    \ includes 4 types bits as\n                specified in Section 3.1.\nVersion\
    \         The 3-bit identifier specifying the version of the\n               \
    \ protocol.  Current version is version 0.\nDomain          The 13-bit identifier\
    \ specifying the naming and\n                administration domain for the client\
    \ and server named in\n                the packet.\nRFC 1045                 \
    \      VMTP                        February 1988 \nPacket Flags: 3 bits. (The\
    \ normal case has none of the flags set.)\n  HCO           Header checksum only\
    \ - checksum has only been calculated\n                on the header.  This is\
    \ used in some real-time\n                applications where the strict correctness\
    \ of the data is\n                not needed.\n  EPG           Encrypted packet\
    \ group - part of a secure message\n                transaction.\n  MPG      \
    \     Multicast packet group - packet was multicast on\n                transmission.\n\
    Length          A 13-bit field that specifies the number of 32-bit words\n   \
    \             in the segment data portion of the packet (if any),\n          \
    \      excluding the checksum field.  (Every VMTP packet is\n                required\
    \ to be a multiple of 64 bits, possibly by\n                padding out the segment\
    \ data.)  The minimum legal Length\n                is 0, the maximum length is\
    \ 4096 and it must be an even\n                number.\nControl Flags: 9 bits.\
    \ (The normal case has none of the flags set.)\n  NRS           Next Receive Sequence\
    \ - the associated Request message\n                (in a Response) or previous\
    \ Response (if a Request) was\n                received consecutive with the last\
    \ Request from this\n                entity.  That is, there was no interfering\
    \ messages\n                received.\n  APG           Acknowledge Packet Group\
    \ - Acknowledge packet group on\n                receipt.  If a Request, send\
    \ back a Request to the\n                client's manager providing an update\
    \ on the state of the\n                transaction as soon as the request packet\
    \ group is\n                received, independent of the response being available.\n\
    \                If a Response, send an update to the server's manager as\n  \
    \              soon as possible after response packet group is received\n    \
    \            providing an update on the state of the transaction at\n        \
    \        the client\n  NSR           Not Start Run - 1 if this packet is not part\
    \ of the\n                first packet group of a run of packet groups.\n  NER\
    \           Not End Run - 1 if this packet is not part of the last\n         \
    \       packet group of a run of packet groups.\n  NRT           No Retransmission\
    \ - do not ask for retransmissions of\n                this packet group if not\
    \ all received within timeout\nRFC 1045                       VMTP           \
    \             February 1988 \n                period, just deliver or discard.\n\
    \  MDG           Member of Destination Group - this packet is sent to a\n    \
    \            group and the client is a member of this group.\n  CMG          \
    \ Continued Message - the message (Request or Response) is\n                continued\
    \ in the next packet group.  The next packet\n                group has to be\
    \ part of the same run of packet groups.\n  STI           Skip Transaction Identifiers\
    \ - the next transaction\n                identifier that the Client plans to\
    \ use is the current\n                transaction plus 256, if part of the same\
    \ run and at\n                least this big if not.  In a Request, this authorizes\n\
    \                the Server to send back up to 256 packet groups\n           \
    \     containing the Response.\n  DRT           Delay Response Transmission -\
    \ set by request sender if\n                multiple responses are expected (as\
    \ indicated by the MRD\n                flag in the RequestCode) and it may be\
    \ overrun by\n                multiple responses.  The responder(s) should then\n\
    \                introduce a short random delay in sending the Response\n    \
    \            to minimize the danger of overrunning the Client.  This\n       \
    \         is normally only used for responding to multicast\n                Requests\
    \ where the Client may be receiving a large\n                number of Responses,\
    \ as indicated by the MRD flag in the\n                Request flags.  Otherwise,\
    \ the Response is sent\n                immediately.\nRetransmitCount:\n     \
    \           3 bits - the ordinal number of transmissions of this\n           \
    \     packet group prior to this one, modulo 8.  This field is\n             \
    \   used in estimation of roundtrip times.  This count may\n                wrap\
    \ around during a message transaction.  However, it\n                should be\
    \ sufficient to match acknowledgments and\n                responses with a particular\
    \ transmission.\nForwardCount:   4 bits indicating the number of times this Request\
    \ has\n                been forwarded.  The original Request is always sent\n\
    \                with a ForwardCount of 0.\nInterpacket Gap: 8 bits.  \n     \
    \           Indicates the recommended time to use between subsequent\n       \
    \         packet transmissions within a multi-packet packet group\n          \
    \      transmission.  The Interpacket Gap time is in 1/32nd of\n             \
    \   a network packet transmission time for a packet of size\n                MTU\
    \ for the node.  (Thus, the maximum gap time is 8\n                packet times.)\n\
    RFC 1045                       VMTP                        February 1988 \nPGcount:\
    \ 8 bits \n                The number of packet groups that this packet group\n\
    \                represents in addition to that specified by the\n           \
    \     Transaction field.  This is used in acknowledging\n                multiple\
    \ packet groups in streamed communication.\nPriority        4-bit identifier for\
    \ priority for the processing of this\n                request both on transmission\
    \ and reception.  The\n                interpretation is:\n                1100\
    \            urgent/emergency\n                1000            important\n   \
    \             0000            normal\n                0100            background\n\
    \                Viewing the higher-order bit as a sign bit (with 1\n        \
    \        meaning negative), low values are high priority and high\n          \
    \      values are low priority.  The low-order 2 bits indicate\n             \
    \   additional (lower) gradations for each level.\nFunction Code: 1 bit - types\
    \ of VMTP packets.  If the low-order bit of\n                the function code\
    \ is 0, the packet is sent to the\n                Server, else it is sent to\
    \ the Client.\n                0               Request\n                1    \
    \           Response\nTransaction: 32 bits:  \n                Identifier for\
    \ this message transaction.\nPacketDelivery: 32 bits:  \n                Delivery\
    \ indicates the segment blocks contained in this\n                packet.  Each\
    \ bit corresponds to one 512-octet block of\n                segment data.  A\
    \ 1 bit in the i-th bit position\n                (counting the LSB as 0) indicates\
    \ the presence of the\n                i-th segment block.\nServer: 64 bits \n\
    \                Entity identifier for the server or server group\n          \
    \      associated with this transaction.  This is the receiver\n             \
    \   when a Request packet and the sender when a Response\n                packet.\n\
    RFC 1045                       VMTP                        February 1988 \nCode:\
    \ 32 bits   The Request Code and Response Code, set either at the\n          \
    \      user level or VMTP level depending on use and packet\n                type.\
    \  Both the Request and Response codes include 8\n                high-order bits\
    \ from the following set of control bits:\n  CMD           Conditional Message\
    \ Delivery -  only deliver the request\n                or response if the receiving\
    \ entity is waiting for it at\n                the time of delivery, otherwise\
    \ drop the message.\n  DGM           DataGram Message - indicates that the message\
    \ is being\n                sent as a datagram.  If a Request message, do not\
    \ wait\n                for reply, or retransmit.  If a Response message, treat\n\
    \                this message transaction as idempotent.\n  MDM           Message\
    \ Delivery Mask - indicates that the MsgDelivery\n                field is being\
    \ used.  Otherwise, the MsgDelivery field\n                is available for general\
    \ use.\n  SDA           Segment Data Appended - segment data is appended to the\n\
    \                message control block, with the total size of the\n         \
    \       segment specified by the SegmentSize field.  Otherwise,\n            \
    \    the segment data is null and the SegmentSize field is\n                not\
    \ used by VMTP and available for user- or RPC-level\n                uses.\n \
    \ CRE           CoResident Entity - indicates that the CoResidentEntity\n    \
    \            field in the message should be interpreted by VMTP.\n           \
    \     Otherwise, this field is available for additional user\n               \
    \ data.\n  MRD           Multiple Responses Desired - multiple Responses are\n\
    \                desired to to this Request if it is multicast.\n            \
    \    Otherwise, the VMTP module can discard subsequent\n                Responses\
    \ after the first Response.\n  PIC           Public Interface Code - Values for\
    \ Code with this bit\n                set are reserved for definition by the VMTP\n\
    \                specification and other standard protocols defined on\n     \
    \           top of VMTP.\n  RES           Reserved for future use. Must be 0.\n\
    CoResidentEntity\n                64-bit Identifier for an entity or group of\
    \ entities\n                with which the Server entity or entities must be\n\
    \                co-resident, i.e. route only to entities (identified by\n   \
    \             Server) on the same host(s) as that specified by\nRFC 1045     \
    \                  VMTP                        February 1988 \n              \
    \  CoResidentEntity, Only meaningful if CRE is set in the\n                Code\
    \ field.\nUser Data       12 octets Space in the header for the VMTP user to\n\
    \                specify user-specific control and data.\nMsgDelivery: 32 bits\
    \ \n                The segment blocks being transmitted (in total) in this\n\
    \                packet group following the conventions for the\n            \
    \    PacketDelivery field.  This field is ignored by the\n                protocol\
    \ and treated as an additional user data field if\n                MDM is 0. \
    \ On transmission, the user level sets the\n                MsgDelivery to indicate\
    \ those portions of the segment to\n                be transmitted.  On receipt,\
    \ the MsgDelivery field is\n                modified by the VMTP module to indicate\
    \ the segment data\n                blocks that were actually received before\
    \ the message\n                control block is passed to the user or RPC level.\
    \  In\n                particular, the kernel does not discard the packet group\n\
    \                if segment data blocks are missing.  A Server or Client\n   \
    \             entity receiving a message with a MsgDelivery in use\n         \
    \       must check the field to ensure adequate delivery and\n               \
    \ retry the operation if necessary.\nSegmentSize: 32 bits \n                Size\
    \ of segment in octets, up to a maximum of 16\n                kilooctets without\
    \ streaming and 4 megaoctets with\n                streaming, if SDA is set. \
    \ Otherwise, this field is\n                ignored by the protocol and treated\
    \ as an additional\n                user data field.\nSegment Data: 0-16 kilooctets\
    \ \n                0 octets if SDA is 0, else the portion of the segment\n  \
    \              corresponding to the Delivery Mask, limited by the\n          \
    \      SegmentSize and the MTU, padded out to a multiple of 64\n             \
    \   bits.\nChecksum: 32 bits.  \n                The 32-bit checksum for the header\
    \ and segment data.\nThe VMTP checksum algorithm <9> develops a 32-bit checksum\
    \ by computing\n_______________\n<9>  This algorithm and description are largely\
    \ due to Steve Deering of\nStanford University.\nRFC 1045                    \
    \   VMTP                        February 1988 \ntwo 16-bit, ones-complement sums\
    \ (like IP), each covering different\nparts of the packet.  The packet is divided\
    \ into clusters of 16 16-bit\nwords.  The first, third, fifth,... clusters are\
    \ added to the first sum,\nand the second, fourth, sixth,... clusters are added\
    \ to the second sum.\nAddition stops at the end of the packet; there is no need\
    \ to pad out to\na cluster boundary (although it is necessary that the packet\
    \ be an\nintegral multiple of 64 bits; padding octets may have any value and are\n\
    included in the checksum and in the transmitted packet).  If either of\nthe resulting\
    \ sums is zero, it is changed to 0xFFFF.  The two sums are\nappended to the transmitted\
    \ packet, with the first sum being transmitted\nfirst.  Four bytes of zero in\
    \ place of the checksum may be used to\nindicate that no checksum was computed.\n\
    The 16-bit, ones-complement addition in this algorithm is the same as\nused in\
    \ IP and, therefore, subject to the same optimizations.  In\nparticular, the words\
    \ may be added up 32-bits at a time as long as the\ncarry-out of each addition\
    \ is added to the sum on the following\naddition, using an \"add-with-carry\"\
    \ type of instruction.  (64-bit or\n128-bit additions would also work on machines\
    \ that have registers that\nbig.)\nA particular weakness of this algorithm (shared\
    \ by IP) is that it does\nnot detect the erroneous swapping of 16-bit words, which\
    \ may easily\noccur due to software errors.  A future version of VMTP is expected\
    \ to\ninclude a more secure algorithm, but such an algorithm appears to\nrequire\
    \ hardware support for efficient execution.\nNot all of these fields are used\
    \ in every packet.  The specific packet\nformats are described below.  If a field\
    \ is not mentioned in the\ndescription of a packet type, its use is assumed to\
    \ be clear from the\nabove description.\nRFC 1045                       VMTP \
    \                       February 1988 \n3.3. Request Packet\nThe Request packet\
    \ (or packet group) is sent from the client to the\nserver or group of servers\
    \ to solicit processing plus the return of zero\nor more responses.  A Request\
    \ packet is identified by a 0 in the LSB of\nthe fourth 32-bit word in the packet.\n\
    \  0                   1                   2                   3\n  0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                       Client (8 octets)                       +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |Ver  |                         |H|E|M|                         |\n |sion |\
    \          Domain         |C|P|P|      Length             |\n |     |        \
    \                 |O|G|G|                         |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |N|A|N|N|N|M|C|S|D|Retra|Forward|    Inter-     |       |R|R|R| |\n |R|P|S|E|R|D|M|T|R|nsmit|\
    \ Count |    Packet     | Prior |E|E|E|0|\n |S|G|R|R|T|G|G|I|T|Count|       |\
    \     Gap       | -ity  |S|S|S| |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                      Transaction                              |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                     PacketDelivery                            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                    Server (8 octets)                          +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |C|D|M|S|R|C|M|P|                                               |\n |M|G|D|D|E|R|R|I|\
    \        RequestCode                            |\n |D|M|M|A|S|E|D|C|        \
    \                                       |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                 CoResidentEntity (8 octets)                   +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ >                   User Data (12 octets)                       <\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                      MsgDelivery                              |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                       SegmentSize                             |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ >                  segment data, if any                         <\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                        Checksum                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 3-1:   Request Packet Format\nThe fields of the Request\
    \ packet are set according to the semantics\ndescribed in Section 3.2 with the\
    \ following qualifications.\nRFC 1045                       VMTP             \
    \           February 1988 \nInterPacketGap  The estimated interpacket gap time\
    \ the client would like\n                for the Response packet group to be sent\
    \ by the Server\n                in responding to this Request.\nTransaction \
    \    Identifier for transaction, at least one greater than\n                the\
    \ previously issued Request from this Client.\nServer          Server to which\
    \ this Request is destined.\nRequestCode     Request code for this request, indicating\
    \ the operation\n                to perform.\nRFC 1045                       VMTP\
    \                        February 1988 \n3.4. Response Packet\nThe Response packet\
    \ is sent from the Server to the Client in response to\na Request, identified\
    \ by a 1 in the LSB of the fourth 32-bit word in the\npacket.\n  0           \
    \        1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                       Client (8 octets)                       +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |Ver  |                         |H|E|M|                         |\n |sion |\
    \          Domain         |C|P|P|      Length             |\n |     |        \
    \                 |O|G|G|                         |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |N|A|N|N|N|R|C|S|R|Retra|Forward|               |       |R|R|R| |\n |R|P|S|E|R|E|M|T|E|nsmit|\
    \ Count |    PGcount    | Prior |E|E|E|1|\n |S|G|R|R|T|S|G|I|S|Count|       |\
    \               | -ity  |S|S|S| |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                      Transaction                              |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                      PacketDelivery                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ +                        Server (8 octets)                      +\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |C|D|M|S|R|R|R|R|                                               |\n |M|G|D|D|E|E|E|E|\
    \        ResponseCode                           |\n |D|M|M|A|S|S|S|S|        \
    \                                       |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ >                   UserData (20 octets)                        <\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                     MsgDelivery                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                    Segment Size                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ >                  segment data, if any                         <\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \ |                       Checksum                                |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 3-2:   Response Packet Format\nThe fields of the Response\
    \ packet are set according to the semantics\ndescribed in Section 3.2 with the\
    \ following qualifications.\nClient, Version, Domain, Transaction\n          \
    \      Match those in the Request packet group to which this is\nRFC 1045    \
    \                   VMTP                        February 1988 \n             \
    \   a response.\nSTI             1 if this Response is using one or more of the\n\
    \                transaction identifiers skipped by the Client after the\n   \
    \             Request to which this is a Response.  STI in the Request\n     \
    \           essentially allocates up to 256 transaction identifiers\n        \
    \        for the Server to use in a run of Response packet\n                groups.\n\
    RetransmitCount The retransmit count from the last Request packet\n          \
    \      received to which this is a response.\nForwardCount    The number of times\
    \ the corresponding Request was\n                forwarded before this Response\
    \ was generated.\nPGcount         The number of consecutively previous packet\
    \ groups that\n                this response is acknowledging in addition to the\
    \ one\n                identified by the Transaction identifier.\nServer     \
    \     Server sending this response.  This may differ from that\n             \
    \   originally specified in the Request packet if the\n                original\
    \ Server was a server group, or the request was\n                forwarded.\n\
    The next two chapters describes the protocol operation using these\npacket formats,\
    \ with the the Client and the Server portions described\nseparately.\nRFC 1045\
    \                       VMTP                        February 1988 \n4. Client\
    \ Protocol Operation\nThis chapter describes the operation of the client portion\
    \ of VMTP in\nterms of the procedures for handling VMTP user events, packet reception\n\
    events, management operations and timeout events.  Note that the client\nportion\
    \ of VMTP is separable from the server portion.  It is feasible to\nhave a node\
    \ that only implements the client end of VMTP.\nTo simplify the description, we\
    \ define a client state record (CSR) plus\nsome standard utility routines.\n4.1.\
    \ Client State Record Fields\nIn the following protocol description, there is\
    \ one client state record\n(CSR) per (client,transaction) outstanding message\
    \ transaction.  Here is\na suggested set of fields.\nLink            Link to next\
    \ CSR when queued in one of the transmission,\n                timeout or message\
    \ queues.\nQueuePtr        Pointer to queue head in which this CSR is contained\
    \ or\n                NULL if none.  Queue could be one of transmission queue,\n\
    \                timeout queue, server queue or response queue.\nProcessIdentification\n\
    \                The process identification and address space.\nPriority     \
    \   Priority for processing, network service, etc.\nState           One of the\
    \ client states described below.\nFinishupFunc    Procedure to be executed on\
    \ the CSR when it is completes\n                its processing in transmission\
    \ or timeout queues.\nTimeoutCount    Time to remain in timeout queue.\nTimeoutLimit\
    \    User-specified time after which the message transaction\n               \
    \ is aborted. The timeout is infinite if set to zero.\nRetransCount    Number\
    \ of retransmissions since last hearing from the\n                Server.\nLastTransmitTime\n\
    \                The time at which the last packet was sent.  This field\n   \
    \             is used to calculate roundtrip times, using the\n              \
    \  RetransmitCount to match the responding packet to a\nRFC 1045             \
    \          VMTP                        February 1988 \n                particular\
    \ transmission.  I.e. Response or management\n                NotifyVmtpClient\
    \ operation to Request and a management\n                NotifyVmtpServer operation\
    \ to a Response.\nTimetoLive      Time to live to be used on transmission of IP\
    \ packets.\nTransmissionMask\n                Bit mask indicating the portions\
    \ of the segment to\n                transmit.  Set before entering the transmission\
    \ queue\n                and cleared incrementally as the 512-byte segment blocks\n\
    \                of the segment are transmitted.\nLocalClientLink Link to next\
    \ CSR hashing to same hash index in the\n                ClientMap.\nLocalClient\
    \     Entity identifier for client when this CSR is used to\n                send\
    \ a Request packet.\nLocalTransaction\n                Transaction identifier\
    \ for current message transaction\n                the local client has outstanding.\n\
    LocalPrincipal  Account identification, possibly including key and key\n     \
    \           timeout.\nLocalDelivery   Bit mask of segment blocks that have not\
    \ been\n                acknowledged in the Request or have been received in the\n\
    \                Response, depending on the state.\nResponseQueue   Queue of CSR's\
    \ representing the queued Responses for\n                this entity.\nVMTP Header\
    \     Prototype VMTP header, used to generate and store the\n                header\
    \ portion of a Request for transmission and\n                retransmission on\
    \ timeout.\nSegmentDesc     Description of the segment data associated with the\
    \ CSR,\n                either the area storing the original Request data, the\n\
    \                area for receiving Request data, or the area storing the\n  \
    \              Response data that is returned.\nHostAddr        The network or\
    \ internetwork host address to which the\n                Client last transmitted.\
    \  This field also indicates the\n                type of the address, e.g. IP,\
    \ Ethernet, etc.\nNote: the CSR can be combined with a light-weight process descriptor\n\
    with considerable benefit if the process is designed to block when it\nRFC 1045\
    \                       VMTP                        February 1988 \nissues a message\
    \ transaction.  In particular, by combining the two\ndescriptors, the implementation\
    \ saves time because it only needs to\nlocate and queue one descriptor with various\
    \ operations (rather than\nhaving to locate two descriptors).  It also saves space,\
    \ given that the\nVMTP header prototype provides space such as the user data field\
    \ which\nmay serve to store processor state for when the process is preempted.\n\
    Non-preemptive blocking can use the process stack to store the processor\nstate\
    \ so only a program counter and stack pointer may be required in the\nprocess\
    \ descriptor beyond what we have described.  (This is the approach\nused in the\
    \ V kernel.)\n4.2. Client Protocol States\nA Client State Record records the state\
    \ of message transaction generated\nby this host, identified by the (Client, Transaction)\
    \ values in the CSR.\nAs a client originating a transaction, it is in one of the\
    \ following\nstates.\nAwaitingResponse\n                Waiting for a Response\
    \ packet group to arrive with the\n                same (Client,Transaction) identification.\n\
    ReceivingResponse\n                Waiting for additional packets in the Response\
    \ packet\n                group it is currently receiving.\n\"Other\"        \
    \ Not waiting for a response, which can be Processing or\n                some\
    \ other operating system state, or one of the Server\n                states if\
    \ it also acts as a server.\nThis covers all the states for a client.\n4.3. State\
    \ Transition Diagrams\nThe client state transitions are illustrated in Figure\
    \ 4-1.  The client\ngoes into the state AwaitingResponse on sending a request\
    \ unless it is a\ndatagram request.  In the AwaitingResponse state, it can timeout\
    \ and\nretry and eventually give up and return to the processing state unless\n\
    it receives a Response.  (A NotifyVmtpClient operation resets the\ntimeout but\
    \ does not change the state.)  On receipt of a single packet\nresponse, it returns\
    \ to the processing state.  Otherwise, it goes to\nReceivingResponse state.  After\
    \ timeout or final response packet is\nreceived, the client returns to the processing\
    \ state.  The processing\nstate also includes any other state besides those associated\
    \ with\nissuing a message transaction.\nRFC 1045                       VMTP  \
    \                      February 1988 \n   +------------+\n   | Processing |<--------------------|\n\
    \   |            |<-------------|      |\n   |            |<---|         |   \
    \   |\n   +|------^--^-+  Single    Last     |\n Transmit  |  |    Packet    Response\
    \ |\n    |      |  |    Response  Packet   |\n    |      |  |      |         |\
    \      |\n    +-DGM->+ Timeout |         |   Final timeout\n    |         |  \
    \    |         |      |\n   +V-----------+    |       +-----------+\n   |  Awaiting\
    \  |----+       | Receiving |->Response-+\n   |  Response  |->Response->| Response\
    \  |           |\n   |            |  (multi-   |           |<----------+\n   +-|--------^-+\
    \   packet)  +----------^+\n     V        |                |        |\n     +-Timeout+\
    \                +>Timeout+\n                 Figure 4-1:   Client State Transitions\n\
    4.4. User Interface\nThe RPC or user interface to VMTP is implementation-dependent\
    \ and may\nuse systems calls, functions or some other mechanism.  The list of\n\
    requests that follow is intended to suggest the basic functionality that\nshould\
    \ be available.\nSend( mcb, timeout, segptr, segsize )\n                Initiate\
    \ a message transaction to the server and request\n                message specified\
    \ by mcb and return a response in mcb,\n                if it is received within\
    \ the specified timeout period\n                (or else return USER_TIMEOUT in\
    \ the Code field).  The\n                segptr parameter specifies the location\
    \ from which the\n                segment data is sent and the location into which\
    \ the\n                response data is to be delivered.  The segsize field\n\
    \                indicates the maximum length of this area.\nGetResponse( responsemcb,\
    \ timeout, segptr, segsize )\n                Get the next response sent to this\
    \ client as part of the\n                current message transaction, returning\
    \ the segment data,\n                if any, into the memory specified by segptr\
    \ and segsize.\nThis interface assumes that there is a client entity associated\
    \ with the\ninvoking process that is to be used with these operations.  Otherwise,\n\
    the client entity must be specified as an additional parameter.\nRFC 1045    \
    \                   VMTP                        February 1988 \n4.5. Event Processing\n\
    The following events may occur in the VMTP client:\n   - User Requests\n     \
    \   * Send\n        * GetResponse\n   - Packet Arrival\n        * Response Packet\n\
    \        * Request\n     The minimal Client implementation handles Request packets\
    \ for\n     its VMTP management (server) module and sends NotifyVmtpClient\n \
    \    requests in response to others, indicating the specified\n     server does\
    \ not exist.\n   - Management Operation - NotifyVmtpClient\n   - Timeouts\n  \
    \      * Client Retransmission Timeout\nThe handling of these events is described\
    \ in detail in the following\nsubsections.\nWe first describe some conventions\
    \ and procedures used in the\ndescription.  A field of the received packet is\
    \ indicated as (for\nexample) p.Transaction, for the Transaction field.  Optional\
    \ portions of\nthe code, such as the streaming handling code are prefixed with\
    \ a \"|\" in\nthe first column.\nMapClient( client )\n                Return pointer\
    \ to CSR for client with the specified\n                clientId, else NULL.\n\
    SendPacketGroup( csr )\n                Send the packet group (Request, Response)\
    \ according to\n                that specified by the CSR.\nNotifyClient( csr,\
    \ p, code )\n                Invoke the NotifyVmtpClient operation with the\n\
    \                parameters csr.RemoteClient, p.control,\nRFC 1045           \
    \            VMTP                        February 1988 \n                csr.ReceiveSeqNumber,\
    \ csr.RemoteTransaction and\n                csr.RemoteDelivery, and code.  If\
    \ csr is NULL, use\n                p.Client, p.Transaction and p.PacketDelivery\
    \ instead and\n                the global ReceiveSequenceNumber, if supported.\
    \  This\n                function simplifies the description over calling\n  \
    \              NotifyVmtpClient directly in the procedural\n                specification\
    \ below.  (See Appendix III.)\nNotifyServer( csr, p, code )\n                Invoke\
    \ the NotifyVmtpServer operation with the\n                parameters p.Server,\
    \ csr.LocalClient,\n                csr.LocalTransaction, csr.LocalDelivery and\
    \ code.  Use\n                p.Client, P.Transaction and 0 for the clientId,\
    \ transact\n                and delivery parameters if csr is NULL.  This function\n\
    \                simplifies the description over calling NotifyVmtpServer\n  \
    \              directly in the procedural specification below.  (See\n       \
    \         Appendix III.)\nDGMset(p)       True if DGM bit set in packet (or csr)\
    \ else False.\n                (Similar functions are used for other bits.)\n\
    Timeout( csr, timeperiod, func )\n                Set or reset timer on csr record\
    \ for timeperiod later\n                and invoke func if the timeout expires.\n\
    4.6. Client User-invoked Events\nA user event occurs when a VMTP user application\
    \ invokes one of the VMTP\ninterface procedures.\n4.6.1. Send\nSend( mcb, timeout,\
    \ segptr, segsize )\n    map to main CSR for this client.\n    increment csr.LocalTransaction\n\
    \    Init csr and check parameters and segment if any.\n    Set SDA if sending\
    \ appended data.\n    Flush queued replies from previous transaction, if any.\n\
    \    if local non-group server then\n        deliver locally\n        await response\n\
    \        return\n    if GroupId(server) then\n        Check for and deliver to\
    \ local members.\n        if CRE request and non-group local CR entity then\n\
    RFC 1045                       VMTP                        February 1988 \n  \
    \         await response\n           return\n        endif\n        set MDG if\
    \ member of this group.\n    endif\n    clear csr.RetransCount\n    set csr.TransmissionMask\n\
    \    set csr.TimeLimit to timeout\n    set csr.HostAddr for csr.Server\n    SendPacketGroup(\
    \ csr )\n    if DGMset(csr) then\n       return\n    endif\n    set csr.State\
    \ to AwaitingResponse\n    Timeout( rootcsr, TC1(csr.Server), LocalClientTimeout\
    \ )\n    return\nend Send\nNotes:\n   1. Normally, the HostAddr is extracted from\
    \ the ServerHost\n      cache, which maps server entity identifiers to host\n\
    \      addresses.  However, on cache miss, the client first queries\n      the\
    \ network using the ProbeEntity operation, as specified in\n      Appendix III,\
    \ determining the host address from the Response.\n      The ProbeEntity operation\
    \ is handled as a separate message\n      transaction by the Client.\nThe stream\
    \ interface incorporates a parameter to pass a responseHandler\nprocedure that\
    \ is invoked when the message transaction completes.\nStreamSend( mcb, timeout,\
    \ segptr, segsize, responseHandler )\n    map to main CSR for this client.\n|\
    \   Allocate a new csr if root in use.\n|   lastcsr := First csr for last request.\n\
    |   if STIset(lastcsr)\n|       csr.LocalTransaction := lastcsr.LocalTransaction\
    \ + 256\n|   else\n|       csr.LocalTransaction := lastcsr.LocalTransaction +\
    \ 1\n    Init csr and check parameters and segment if any.\n    . . . ( rest is\
    \ the same as for the normal Send)\nNotes:\n   1. Each outstanding message transaction\
    \ is represented by a CSR\n      queued on the root CSR for this client entity.\
    \  The root CSR\n      is used to handle timeouts, etc.  On timeout, the last\
    \ packet\nRFC 1045                       VMTP                        February\
    \ 1988 \n      from the last packet group is retransmitted (with or without\n\
    \      the segment data).\n4.6.2. GetResponse\nGetResponse( req, timeout, segptr,\
    \ segsize )\n    csr := CurrentCSR;\n    if responses queued then return next\
    \ response\n      (in req, segptr to max of segsize )\n    if timeout is zero\
    \ then return KERNEL_TIMEOUT error\n    set state to AWAITING_RESPONSE\n    Timeout(\
    \ csr, timeout, ReturnKernelTimeout );\nend GetResponse\nNotes:\n   1. GetResponse\
    \ is only used with multicast Requests, which is\n      the only case in which\
    \ multiple (different) Responses should\n      be received.\n   2. A response\
    \ must remain queued until the next message\n      transaction is invoked to filter\
    \ out duplicates of this\n      response.\n   3. If the response is incomplete\
    \ (only relevant if a\n      multi-packet response), then the client may wait\
    \ for the\n      response to be fully received, including issuing requests for\n\
    \      retransmission (using NotifyVmtpServer operations) before\n      returning\
    \ the response.\n   4. As an optimization, a response may be stored in the CSR\
    \ of\n      the client.  In this case, the response must be transferred\n    \
    \  to a separate buffer (for duplicate suppression) before\n      waiting for\
    \ another response.  Using this optimization, a\n      response buffer is not\
    \ allocated in the common case of the\n      client receiving only one response.\n\
    4.7. Packet Arrival\nIn general, on packet reception, a packet is mapped to the\
    \ client state\nrecord, decrypted if necessary using the key in the CSR.  It then\
    \ has\nits checksum verified and then is transformed to the right byte order.\n\
    The packet is then processed fully relative to its packet function code.\nIt is\
    \ discarded immediately if it is addressed to a different domain\nthan the domain(s)\
    \ in which the receiving host participates.\nRFC 1045                       VMTP\
    \                        February 1988 \nFor each of the 2 packet types, we assume\
    \ a procedure called with a\npointer p to the VMTP packet and psize, the size\
    \ of the packet in\noctets.  Thus, generic packet reception is:\nif not LocalDomain(p.Domain)\
    \ then return;\ncsr := MapClient( p.Client )\nif csr is NULL then\n    HandleNoCsr(\
    \ p, psize )\n    return\nif Secure(p) then\n    if SecureVMTP not supported then\n\
    \        { Assume a Request. }\n        if not Multicast(p) then\n           \
    \ NotifyClient(NULL, p, SECURITY_NOT_SUPPORTED )\n        return\n    endif\n\
    |   Decrypt( csr.Key, p, psize )\nif p.Checksum not null then\n    if not VerifyChecksum(p,\
    \ psize) then return;\nif OppositeByteOrder(p) then ByteSwap( p, psize )\nif psize\
    \ not equal sizeof(VmtpHeader) + 4*p.Length then\n    NotifyClient(NULL, p, VMTP_ERROR\
    \ )\n    return\nInvoke Procedure[p.FuncCode]( csr, p, psize )\nDiscard packet\
    \ and return\nNotes:\n   1. The Procedure[p.FuncCode] refers to one of the 2 procedures\n\
    \      corresponding to the two different packet types of VMTP,\n      Requests\
    \ and Responses.\n   2. In all the following descriptions, a packet is discarded\
    \ on\n      \"return\" unless otherwise stated.\n   3. The procedure HandleNoCSR\
    \ is a management routine that\n      allocates and initializes a CSR and processes\
    \ the packet or\n      else sends an error indication to the sender of the packet.\n\
    \      This procedure is described in greater detail in Section\n      4.8.1.\n\
    RFC 1045                       VMTP                        February 1988 \n4.7.1.\
    \ Response\nThis procedure handles incoming Response packets.\nHandleResponse(\
    \ csr, p, psize )\n    if not LocalClient( csr ) then\n        if Multicast then\
    \ return\n|       if Migrated( p.Client ) then\n|           NotifyServer(csr,\
    \ p ENTITY_MIGRATED )\n|       else\n            NotifyServer(csr, p, ENTITY_NOT_HERE\
    \ )\n        return\n    endif\n    if NSRset(p) then\n        if Streaming not\
    \ supported then\n            NotifyServer(csr, p, STREAMING_NOT_SUPPORTED )\n\
    \            return STREAMED_RESPONSE\n|       Find csr corresponding to p.Transaction\n\
    |       if none found then\n|           NotifyServer(csr, p, BAD_TRANSACTION_ID\
    \ )\n|           return\n     else\n      if csr.LocalTransaction not equal p.Transaction\
    \ then\n        NotifyServer(csr, p, BAD_TRANSACTION_ID )\n        return\n  \
    \  endif\n    Locate reply buffer rb for this p.Server\n    if found then\n  \
    \      if rb.State is not ReceivingResponse then\n          { Duplicate }\n  \
    \          if APGset(p) or NERset(p) then\n                { Send Response to\
    \ stop response packets. }\n                NotifyServer(csr, p, RESPONSE_DISCARDED\
    \ )\n            endif\n            return\n         endif\n         { rb.State\
    \ is ReceivingRequest}\n         if new segment data then retain in CSR segment\
    \ area.\n         if packetgroup not complete then\n             Timeout( rb,\
    \ TC3(p.Server), LocalClientTimeout )\n             return;\n          endif\n\
    \          goto EndPacketGroup\n    endif\n    { Otherwise, a new response message.\
    \ }\nRFC 1045                       VMTP                        February 1988\
    \ \n    if (NSRset(p) or NERset(p)) and NoStreaming then\n        NotifyServer(csr,\
    \ p, VMTP_ERROR )\n        return\n|    if NSRset(p) then\n|      { Check consecutive\
    \ with previous packet group }\n|       Find last packet group CSR from p.Server.\n\
    |       if p.Transaction not\n|             lastcsr.RemoteTransaction+1 mod 2**32\
    \ then\n|         { Out of order packet group }\n|            NotifyServer(csr,\
    \ p, BAD_TRANSACTION_ID)\n|           return\n|       endif\n|       if lastcsr\
    \ not completed then\n|           NotifyServer(lastcsr, p, RETRY )\n|       endif\n\
    |       if CMG(lastcsr) then\n|           Add segment data to lastcsr Response\n\
    |           Notify lastcsr with new packet group.\n|           Clear lastcsr.VerifyInterval\n\
    |       else\n|           if lastcsr available then\n|                 use it\
    \ for this packet group\n|           else allocate and initialize new CSR\n| \
    \          Save message and segment data in new CSR area.\n|       endif\n|  \
    \ else { First packet group }\n        Allocate and init reply buffer rb for this\
    \ response.\n        if allocation fails then\n            NotifyServer(csr, p,\
    \ BUSY )\n            return\n        Set rb.State to ReceivingResponse\n    \
    \    Copy message and segment data to rb's segment area\n         and set rb.PacketDelivery\
    \ to that delivered.\n        Save p.Server host address in ServerHost cache.\n\
    \    endif\n    if packetgroup not complete then\n        Timeout( rb, TS1(p.Client),\
    \ LocalClientTimeout )\n        return;\n    endif\nendPacketGroup:\n    { We\
    \ have received last packet in packet group. }\n    if APGset(p) then NotifyServer(csr,\
    \ p, OK )\n|   if NERset(p) and CMGset(p) then\n|       Queue waiting for continuation\
    \ packet group.\n|       Timeout( rb, TC2(rb.Server), LocalClientTimeout )\n|\
    \       return\n|   endif\nRFC 1045                       VMTP               \
    \         February 1988 \n    { Deliver response message. }\n    Deliver response\
    \ to Client, or queue as appropriate.\nend HandleResponse\nNotes:\n   1. The mechanism\
    \ for handling streaming is optional and can be\n      replaced with the tests\
    \ for use of streaming.  Note that the\n      server should never stream at the\
    \ Client unless the Client\n      has streamed at the Server or has used the STI\
    \ control bit.\n      Otherwise, streamed Responses are a protocol error.\n  \
    \ 2. As an optimization, a Response can be stored into the CSR for\n      the\
    \ Client rather than allocating a separate CSR for a\n      response buffer. \
    \ However, if multiple responses are handled,\n      the code must be careful\
    \ to perform duplicate detection on\n      the Response stored there as well as\
    \ those queued.  In\n      addition, GetResponse must create a queued version\
    \ of this\n      Response before allowing it to be overwritten.\n   3. The handling\
    \ of Group Responses has been omitted for brevity.\n      Basically, a Response\
    \ is accepted if there has been a Request\n      received locally from the same\
    \ Client and same Transaction\n      that has not been responded to.  In this\
    \ case, the Response\n      is delivered to the Server or queued.\nRFC 1045  \
    \                     VMTP                        February 1988 \n4.8. Management\
    \ Operations\nVMTP uses management operations (invoked as remote procedure calls)\
    \ to\neffectively acknowledge packet groups and request retransmissions.  The\n\
    following routine is invoked by the Client's management module on\nrequest from\
    \ the Server.\nNotifyVmtpClient( clientId,ctrl,receiveSeqNumber,transact,delivery,code)\n\
    \    Get csr for clientId\n    if none then return\n    if RemoteClient( csr )\
    \ and not NotifyVmtpRemoteClient then\n       return\n|   else (for streaming)\n\
    |      Find csr with same LocalTransaction as transact\n|      if csr is NULL\
    \ then return\n    if csr.State not AwaitingResponse then return\n    if ctrl.PGcount\
    \ then ack previous packet groups.\n    select on code\n      case OK:\n     \
    \   Notify ack'ed segment blocks from delivery\n        Clear csr.RetransCount;\n\
    \        Timeout( csr, TC1(csr.Server), LocalClientTimeout )\n        return\n\
    \      case RETRY:\n        Set csr.TransmissionMask to missing segment blocks,\n\
    \            as specified by delivery\n        SendPacketGroup( csr )\n      \
    \  Timeout( csr, TC1(csr.Server), LocalClientTimeout )\n      case RETRY_ALL\n\
    \        Set csr.TransmissionMask to retransmit all blocks.\n        SendPacketGroup(\
    \ csr )\n        Timeout( csr, TC1(csr.Server), LocalClientTimeout )\n|      \
    \ if streaming then\n|          Restart transmission of packet groups,\n|    \
    \            starting from transact+1\n         return\n      case BUSY:\n   \
    \      if csr.TimeLimit exceeded then\n             Set csr.Code to USER_TIMEOUT\n\
    \             return Response to application\n             return;\n        Set\
    \ csr.TransmissionMask for full retransmission\n        Clear csr.RetransCount\n\
    \        Timeout( csr, TC1(csr.Server), LocalClientTimeout )\n        return\n\
    \      case ENTITY_MIGRATED:\n        Get new host address for entity\nRFC 1045\
    \                       VMTP                        February 1988 \n        Set\
    \ csr.TransmissionMask for full retransmission\n        Clear csr.RetransCount\n\
    \        SendPacketGroup( csr )\n        Timeout( csr, TC1(csr.Server), LocalClientTimeout\
    \ )\n        return\n      case STREAMING_NOT_SUPPORTED:\n        Record that\
    \ server does not support streaming\n        if CMG(csr) then forget this packet\
    \ group\n        else resend Request as separate packet group.\n        return\n\
    \      default:\n         Set csr.Code to code\n         return Response to application\n\
    \         return;\n    endselect\nend NotifyVmtpClient\nNotes:\n   1. The delivery\
    \ parameter indicates the segment blocks received\n      by the Server.  That\
    \ is, a 1 bit in the i-th position\n      indicates that the i-th segment block\
    \ in the segment data of\n      the Request was received.  All subsequent NotifyVmtpClient\n\
    \      operations for this transaction should be set to acknowledge\n      a superset\
    \ of the segment blocks in this packet.  In\n      particular, the Client need\
    \ not be prepared to retransmit the\n      segment data once it has been acknowledged\
    \ by a Notify\n      operation.\n4.8.1. HandleNoCSR\nHandleNoCSR is called when\
    \ a packet arrives for which there is no CSR\nmatching the client field of the\
    \ packet.\nHandleNoCSR( p, psize )\n    if Secure(p) then\n        if SecureVMTP\
    \ not supported then\n            { Assume a Request }\n            if not Multicast(p)\
    \ then\n                NotifyClient(NULL,p,SECURITY_NOT_SUPPORTED)\n        \
    \    return\n        endif\n        HandleRequestNoCSR( p, psize )\n        return\n\
    \    endif\nRFC 1045                       VMTP                        February\
    \ 1988 \n    if p.Checksum not null then\n        if not VerifyChecksum(p, psize)\
    \ then return;\n    if OppositeByteOrder(p) then ByteSwap( p, psize )\n    if\
    \ psize not equal sizeof(VmtpHeader) + 4*p.Length then\n        NotifyClient(NULL,\
    \ p, VMTP_ERROR )\n        return\n    if p.FuncCode is Response then\n|     \
    \   if Migrated( p.Client ) then\n|           NotifyServer(csr, p ENTITY_MIGRATED\
    \ )\n|       else\n            NotifyServer(csr, p, NONEXISTENT_ENTITY )\n   \
    \     return\n    endif\n    if p.FuncCode is Request then\n       HandleRequestNoCSR(\
    \ p, psize )\n    return\nend HandleNoCSR\nNotes:\n   1. The node need only check\
    \ to see if the client entity has\n      migrated if in fact it supports migration\
    \ of entities.\n   2. The procedure HandleRequestNoCSR is specified in Section\n\
    \      5.8.1.  In the minimal client version, it need only handle\n      Probe\
    \ requests and can do so directly without allocating a\n      new CSR.\nRFC 1045\
    \                       VMTP                        February 1988 \n4.9. Timeouts\n\
    A client with a message transaction in progress has a single timer\ncorresponding\
    \ to the first unacknowledged request message.  (In the\nabsence of streaming,\
    \ this request is also the last request sent.)  This\ntimeout is handled as follows:\n\
    LocalClientTimeout( csr )\n  select on csr.State\n    case AwaitingResponse:\n\
    \      if csr.RetransCount > MaxRetrans(csr.Server) then\n             terminate\
    \ Client's message transactions up to\n             and including the current\
    \ message transaction.\n             set return code to KERNEL_TIMEOUT\n     \
    \     return\n      increment csr.RetransCount\n      Resend current packet group\
    \ with APG set.\n      Timeout( csr, TC2(csr.Server), LocalClientTimeout )\n \
    \     return\n    case ReceivingResponse:\n      if DGMset(csr) or csr.RetransCount\
    \ > Max then\n         if MDMset(csr) then\n            Set MCB.MsgDeliveryMask\
    \ to blocks received.\n         else\n            Set csr.Code to BAD_REPLY_SEGMENT\n\
    \         return to user Client\n      endif\n      increment csr.RetransCount\n\
    \      NotifyServer with RETRY\n      Timeout( csr, TC3(csr.Server), LocalClientTimeout\
    \ )\n      return\n  end select\nend LocalClientTimeout\nNotes:\n   1. A Client\
    \ can only request retransmission of a Response if the\n      Response is not\
    \ idempotent.  If idempotent, it must\n      retransmit the Request.  The Server\
    \ should generally support\n      the MsgDeliveryMask for Requests that it treats\
    \ as idempotent\n      and that require multi-packet Responses.  Otherwise, there\
    \ is\n      no selective retransmission for idempotent message\n      transactions.\n\
    \   2. The current packet group is the last one transmitted.  Thus,\n      with\
    \ streaming, there may be several packet groups\n      outstanding that precede\
    \ the current packet group.\nRFC 1045                       VMTP             \
    \           February 1988 \n   3. The Request packet group should be retransmitted\
    \ without the\n      segment data, resulting in a single short packet in the\n\
    \      retransmission.  The Server must then send a\n      NotifyVmtpClient with\
    \ a RETRY or RETRY_ALL code to get the\n      segment data transmitted as needed.\
    \  This strategy minimizes\n      the overhead on the network and the server(s)\
    \ for\n      retransmissions.\nRFC 1045                       VMTP           \
    \             February 1988 \n5. Server Protocol Operation\nThis section describes\
    \ the operation of the server portion of the\nprotocol in terms of the procedures\
    \ for handling VMTP user events,\npacket reception events and timeout events.\
    \  Each server is assumed to\nimplement the client procedures described in the\
    \ previous chapter.\n(This is not strictly necessary but it simplifies the exposition.)\n\
    5.1. Remote Client State Record Fields\nThe CSR for a server is extended with\
    \ the following fields, in addition\nto the ones listed for the client version.\n\
    RemoteClient    Identifier for remote client that sent the Request that\n    \
    \            this CSR is handling.\nRemoteClientLink\n                Link to\
    \ next CSR hashing to same hash index in the\n                ClientMap.\nRemoteTransaction\n\
    \                Transaction identifier for Request from remote client.\nRemoteDelivery\
    \  The segment blocks received so far as part of a Request\n                or\
    \ yet to be acknowledged as part of a Response.\nVerifyInterval  Time interval\
    \ since there was confirmation that the\n                remote Client was still\
    \ valid.\nRemotePrincipal Account identification, possibly including key and key\n\
    \                timeout for secure communication.\n5.2. Remote Client Protocol\
    \ States\nA CSR in the server end is in one of the following states.\nAwaitingRequest\
    \ Waiting for a Request packet group.  It may be marked as\n                waiting\
    \ on a specific Client, or on any Client.\nReceivingRequest\n                Waiting\
    \ to receive additional Request packets in a\n                multi-packet group\
    \ Request.\nResponded       The Response has been sent and the CSR is timing out,\n\
    \                providing duplicate suppression and retransmission (if\nRFC 1045\
    \                       VMTP                        February 1988 \n         \
    \       the Response was not idempotent).\nResponseDiscarded\n               \
    \ Response has been acknowledged or has timed out so\n                cannot be\
    \ retransmitted.  However, duplicates are still\n                filtered and\
    \ CSR can be reused for new message\n                transaction.\nProcessing\
    \      Executing on behalf of the Client.\nForwarded       The message transaction\
    \ has been forwarded to another\n                Server that is to respond directly\
    \ to the Client.\n5.3. State Transition Diagrams\nThe CSR state transitions in\
    \ the server are illustrated in Figure 5-1.\nThe CSR generally starts in the AwaitingRequest\
    \ state.  On receipt of a\nRequest, the Server either has an up-to-date CSR for\
    \ the Client or else\nit sends a Probe request (as a separate VMTP message transaction)\
    \ to the\nVMTP management module associated with the Client.  In the latter case,\n\
    the processing of the Request is delayed until a Response to the Probe\nrequest\
    \ is received.  At that time, the CSR information is brought up to\ndate and the\
    \ Request is processed.  If the Request is a single-packet\nrequest, the CSR is\
    \ then set in the Processing state to handle the\nrequest.  Otherwise (a multi-packet\
    \ Request), the CSR is put into the\nReceivingResponse state, waiting to receive\
    \ subsequent Request packets\nthat constitute the Request message.  It exits the\
    \ ReceivingRequest\nstate on timeout or on receiving the last Request packet.\
    \  In the former\ncase, the request is delivered with an indication of the portion\n\
    received, using the MsgDelivery field if MDM is set.  After request\nprocessing\
    \ is complete, either the Response is sent and the CSR enters\nthe Responded state\
    \ or the message transaction is forwarded and the CSR\nenters the Forwarded state.\n\
    In the Responded state, if the Response is not marked as idempotent, the\nResponse\
    \ is retransmitted on receipt of a retransmission of the\ncorresponding Request,\
    \ on receipt of a NotifyVmtpServer operation\nrequesting retransmission or on\
    \ timeout at which time APG is set,\nrequesting an acknowledgment from the Client.\
    \  The Response is\nretransmitted some maximum number of times at which time the\
    \ Response is\ndiscarded and the CSR is marked accordingly.  If a Request or a\n\
    NotifyVmtpServer operation is received expecting retransmission of the\nResponse\
    \ after the CSR has entered the ResponseDiscarded state, a\nNotifyVmtpClient operation\
    \ is sent back (or invoked in the Client\nmanagement module) indicating that the\
    \ response was discarded unless the\nRequest was multicast, in which case no action\
    \ is taken.  After a\n     (Retransmit Forwarded Request and NotifyVmtpClient)\n\
    \                    Request/\n                    Ack/\n                   +Timeout+\n\
    \                   V       |\n                 +-|-------^-+\n              \
    \   |           |\n          +-Time-| Forwarded |<-------------+\n          |\
    \  out +-----------+              |\n          |                             \
    \    |\n          |          (Retransmit Response)  |\n          |           \
    \           Request    |\n          V                      Ack        |\n    \
    \      |                    +-Timeout-+  |\n          |                    V \
    \        |  |\n        +---------+ Ack/ +|---------^+ |\n +-Time-|Response |<-Timeout--|\
    \ Responded | |\n |  out |Discarded|           +----^------+ |\n |      +---------+\
    \                |        |\n |  +------------+                 |        |\n |\
    \  |            |->-Send Response-+        |\n |  |            |->-forward Request--------+\n\
    \ +->| Processing |<----------------------+\n |  |            |<----------------+\
    \     |\n |  |            |<---|            |     |\n |  +-|--------^-+    | \
    \         Last    |\n | Receive     |      |          Request |\n |    |   Timeout\
    \   Single       Packet  |\n |    |        |    Packet         |   Timeout\n |\
    \    |        |    Request        ^     ^\n |    |        |      ^           +|-----|--+\n\
    \ |  +-V--------|-+    |           |Receiving|<-+Time\n +->|  Awaiting  |->--+->Request->|\
    \ Request |--+ out\n    |  Request   |    |  (multi-  +---------+\n    +------|-----+\
    \    ^  packet)\n        Request       |\n           |        Response\n     \
    \ Send Probe     to\n           |        Probe\n       +---V----+     |\n    \
    \   |Awaiting|     ^\n       |Response|-->--+\n       |to Probe|\n       +--------+\n\
    \             Figure 5-1:   Remote Client State Transitions\nRFC 1045        \
    \               VMTP                        February 1988 \nCSR returns either\
    \ to the AwaitingRequest state or to the Processing\nstate.  Note that \"Ack\"\
    \ refers to acknowledgment by a Notify operation.\nA Request that is forwarded\
    \ leaves the CSR in the Forwarded state.  In\nthe Forwarded state, the forwarded\
    \ Request is retransmitted\nperiodically, expecting NotifyRemoteClient operations\
    \ back from the\nServer to which the Request was forwarded, analogous to the Client\n\
    behavior in the AwaitingResponse state.  In this state, a\nNotifyRemoteClient\
    \ from this Server acknowledges the Request or asks\nthat it be retransmitted\
    \ or reports an error.  A retransmission of the\nRequest from the Client causes\
    \ a NotifyVmtpClient to be returned to the\nClient if APG is set.  The CSR leaves\
    \ the Forwarded state after timing\nout in the absence of NotifyRemoteClient operations\
    \ from the forward\nServer or on receipt of a NotifyRemoteClient operation indicating\
    \ the\nforward Server has sent a Response and received an acknowledgement.  It\n\
    then enters the ResponseDiscarded state.\nReceipt of a new Request from the same\
    \ Client aborts the current\ntransaction, independent of its state, and initiates\
    \ a new transaction\nunless the new Request is part of a run of message transactions.\
    \  If it\nis part of a run of message transactions, the handling follows the state\n\
    diagram except the new Request is not Processed until there has been a\nresponse\
    \ sent to the previous transaction.\n5.4. User Interface\nThe RPC or user interface\
    \ to VMTP is implementation-dependent and may\nuse systems calls, functions or\
    \ some other mechanism.  The list of\nrequests that follow is intended to suggest\
    \ the basic functionality that\nshould be available.\nAcceptMessage( reqmcb, segptr,\
    \ segsize, client, transid, timeout ) \n                Accept a new Request message\
    \ in the specified reqmcb\n                area, placing the segment data, if\
    \ any, in the area\n                described by segptr and segsize.  This returns\
    \ the\n                Server in the entityId field of the reqmcb and actual\n\
    \                segment size in the segsize parameters.  It also returns\n  \
    \              the Client and Transaction for this message transaction\n     \
    \           in the corresponding parameters.  This procedure\n               \
    \ supports message semantics for request processing.  When\n                a\
    \ server process executes this call, it blocks until a\n                Request\
    \ message has been queued for the server.\n                AcceptMessage returns\
    \ after the specified timeout period\n                if a message has not been\
    \ received by that time.\nRespondMessage( responsemcb, client, transid, segptr\
    \ ) \nRFC 1045                       VMTP                        February 1988\
    \ \n                Respond to the client with the specified response\n      \
    \          message and segment, again with message semantics.\nRespondCall( responsemcb,\
    \ segptr ) \n                Respond to the client with the specified response\n\
    \                message and segment, with remote procedure call\n           \
    \     semantics.  This procedure does not return.  The\n                lightweight\
    \ process that executes this procedure is\n                matched to a stack,\
    \ program counter, segment area and\n                priority from the information\
    \ provided in a\n                ModifyService call, as specified in Appendix\
    \ III.\nForwardMessage( requestmcb, transid, segptr, segsize, forwardserver )\
    \ \n                Forward the client to the specified forwardserver with\n \
    \               the request specified in mcb.\nForwardCall( requestmcb, segptr,\
    \ segsize, forwardserver ) \n                Forward the client transaction to\
    \ the specified\n                forwardserver with the request specified by requestmcb.\n\
    \                This procedure does not return.\nGetRemoteClientId()\n      \
    \          Return the entityId for the remote client on whose\n              \
    \  behave the process is executing.  This is only\n                applicable\
    \ in the procedure call model of request\n                handling.\nGetForwarder(\
    \ client )\n                Return the entity that forwarded this Request, if\
    \ any.\nGetProcess( client )\n                Return an identifier for the process\
    \ associated with\n                this client entity-id.\nGetPrincipal( client\
    \ )\n                Return the principal associated with this client\n      \
    \          entity-id.\n5.5. Event Processing\nThe following events may occur in\
    \ VMTP servers.\n   - User Requests\n        * Receive\nRFC 1045             \
    \          VMTP                        February 1988 \n        * Respond\n   \
    \     * Forward\n        * GetForwarder\n        * GetProcess\n        * GetPrincipal\n\
    \   - Packet Arrival\n        * Request Packet\n   - Management Operations\n \
    \       * NotifyVmtpServer\n   - Timeouts\n        * Client State Record Timeout\n\
    The handling of these events is described in detail in the following\nsubsections.\
    \  The conventions of the previous chapter are followed,\nincluding the use of\
    \ the various subroutines in the description.\n5.6. Server User-invoked Events\n\
    A user event occurs when a VMTP server invokes one of the VMTP interface\nprocedures.\n\
    5.6.1. Receive\nAcceptMessage(reqmcb, segptr, segsize, client, transid, timeout)\n\
    \    Locate server's request queue.\n    if request is queued then\n        Remember\
    \ CSR associated with this Request.\n        return Request in reqmcb, segptr\
    \ and segsize\n               and client and transaction id.\n    Wait on server's\
    \ request queue for next request\n    up time timeout seconds.\nend ReceiveCall\n\
    Notes:\nRFC 1045                       VMTP                        February 1988\
    \ \n   1. If a multi-packet Request is partially received at the time\n      of\
    \ the AcceptMessage, the process waits until it completes.\n   2. The behavior\
    \ of a process accepting a Request as a\n      lightweight thread is similar except\
    \ that the process\n      executes using the Request data logically as part of\
    \ the\n      requesting Client process.\n5.6.2. Respond\nRespondCall is described\
    \ as one case of the Respond transmission\nprocedure; RespondMessage is similar.\n\
    RespondCall( responsemcb, responsesegptr )\n    Locate csr for this client.\n\
    \    Check segment data accessible, if any\n    if local client then\n       \
    \ Handle locally\n        return\n    endif\n    if responsemcb.Code is RESPONSE_DISCARDED\
    \ then\n        Mark as RESPONSE_DISCARDED\n        return\n    SendPacketGroup(\
    \ csr )\n    set csr.State to Responded.\n    if DGM reply then { Idempotent }\n\
    \        release segment data\n        Timeout( csr, TS4(csr.Client), FreeCsr\
    \ );\n    else { Await acknowledgement or new Request else ask for ack. }\n  \
    \      Timeout( csr, TS5(csr.Client), RemoteClientTimeout )\nend RespondCall\n\
    Notes:\n   1. RespondMessage is similar except the Server process must be\n  \
    \    synchronized with the release of the segment data (if any).\n   2. The non-idempotent\
    \ Response with segment data is sent first\n      without a request for an acknowledgement.\
    \  The Response is\n      retransmitted after time TS5(client) if no acknowledgment\
    \ or\n      new Request is received from the client in the meantime.  At\n   \
    \   this point, the APG bit is sent.\n   3. The MCB of the Response is buffered\
    \ in the client CSR, which\n      remains for TS4 seconds, sufficient to filter\
    \ old duplicates.\n      The segment data (if any) must be retained intact until:\
    \  (1)\nRFC 1045                       VMTP                        February 1988\
    \ \n      after transmission if idempotent or (2) after acknowledged or\n    \
    \  timeout has occurred if not idempotent.  Techniques such as\n      copy-on-write\
    \ might be used to keep a copy of the Response\n      segment data without incurring\
    \ the cost of a copy.\n5.6.3. Forward\nForwarding is logically initiating a new\
    \ message transaction between the\nServer (now acting as a Client) and the server\
    \ to which the Request is\nforwarded.  When the second server returns a Response,\
    \ the same Response\nis immediately returned to the Client.  The forwarding support\
    \ in VMTP\npreserves these semantics while providing some performance optimizations\n\
    in some cases.\nForwardCall( req, segptr, segsize, forwardserver )\n    Locate\
    \ csr for this client.\n    Check segment data accessible, if any\n    if local\
    \ client or Request was multicast or secure\n       or csr.ForwardCount == 15\
    \ then\n        Handle as a new Send operation\n        return\n    if forwardserver\
    \ is local then\n        Handle locally\n        return\n    Set csr.funccode\
    \ to Request\n    Increment csr.ForwardCount\n    Set csr.State to Responded\n\
    \    SendPacketGroup( csr ) { To ForwardServer }\n    Timeout( csr, TS4(csr.Client),\
    \ FreeAlien )\nend ForwardCall\nNotes:\n   1. A Forward is logically a new call\
    \ or message transaction.  It\n      must be really implemented as a new message\
    \ transaction if\n      the original Request was multicast or secure (with the\n\
    \      optional further refinement that it can be used with a secure\n      message\
    \ transaction when the Server and ForwardServer are the\n      same principal\
    \ and the Request was not multicast).\n   2. A Forward operation is never handled\
    \ as an idempotent\n      operation because it requires knowledge that the\n \
    \     ForwardServer will treat the forwarded operation as\n      idempotent as\
    \ well.  Thus, a Forward operation that includes\n      a segment should set APG\
    \ on the first transmission of the\nRFC 1045                       VMTP      \
    \                  February 1988 \n      forwarded Request to get an acknowledgement\
    \ for this data.\n      Once the acknowledgement is received, the forwarding Server\n\
    \      can discard the segment data, leaving only the basic CSR to\n      handle\
    \ retransmissions from the Client.\n5.6.4. Other Functions\nGetRemoteClient is\
    \ a simple local query of the CSR.  GetProcess and\nGetPrincipal also extract\
    \ this information from the CSR.  A server\nmodule may defer the Probe callback\
    \ to the Client to get that\ninformation until it is requested by the Server (assuming\
    \ it is not\nusing secure communication and duplicate suppression is adequate\
    \ without\ncallback.)  GetForwarder is implemented as a callback to the Client,\n\
    using a GetRequestForwarder VMTP management operation.  Additional\nmanagement\
    \ procedures for VMTP are described in Appendix III.\n5.7. Request Packet Arrival\n\
    The basic packet reception follows that described for the Client\nroutines.  A\
    \ Request packet is handled by the procedure HandleRequest.\nHandleRequest( csr,\
    \ p, psize )\n    if LocalClient(csr) then\n        { Forwarded Request on local\
    \ Client }\n        if csr.LocalTransaction != p.Transaction then return\n   \
    \     if csr.State != AwaitingResponse then return\n        if p.ForwardCount\
    \ < csr.ForwardCount then\n           Discard Request and return.\n        Find\
    \ a CSR for Client as a remote Client.\n        if not found then\n          \
    \  if packet group complete then\n                handle as a local message transaction\n\
    \                return\n            Allocate and init CSR\n            goto newTransaction\n\
    \        { Otherwise part of current transaction }\n        { Handle directly\
    \ below. }n\n    if csr.RemoteTransaction = p.Transaction then\n      { Matches\
    \ current transaction }\n        if OldForward(p.ForwardCount,csr.ForwardCount)\
    \ then\n            return\n        if p.ForwardCount > csr.ForwardCount then\n\
    \          { New forwarded transaction }\n            goto newTransaction\nRFC\
    \ 1045                       VMTP                        February 1988 \n    \
    \    { Otherwise part of current transaction }\n        if csr.State = ReceivingRequest\
    \ then\n            if new segment data then retain in CSR segment area.\n   \
    \         if Request not complete then\n               Timeout( csr, TS1(p.Client),\
    \ RemoteClientTimeout )\n               return;\n            endif\n         \
    \   goto endPacketGroup\n        endif\n        if csr.State is Responded then\n\
    \          { Duplicate }\n            if csr.Code is RESPONSE_DISCARDED\n    \
    \           and Multicast(p) then\n                return\n            endif\n\
    \            if not DGM(csr) then { Not idempotent }\n                if SegmentData(csr)\
    \ then set APG\n                { Resend Response or Request, if Forwarded }\n\
    \                SendPacketGroup( csr )\n                timeout=if SegmentData(csr)\
    \ then TS5(csr.Client)\n                          else TS4(csr.Client)\n     \
    \           Timeout( csr, timeout, RemoteClientTimeout )\n                return\n\
    \            { Else idempotent - fall thru to newTransaction }\n        else {\
    \ Presume it is a retransmission }\n            NotifyClient( csr, p, OK )\n \
    \           return\n   else if OldTransaction(csr.RemoteTransact,p.Transaction)\
    \ then\n        return\n    { Otherwise, a new message transaction. }\nnewTransaction:\n\
    \    Abort handling of previous transactions for this Client.\n    if (NSRset(p)\
    \ or NERset(p)) and NoStreaming then\n        NotifyClient( csr, p, STREAMING_NOT_SUPPORTED\
    \ )\n        return\n|   if NSRset(p) then { Streaming }\n|     { Check that consecutive\
    \ with previous packet group }\n|       Find last packet group CSR from this client.\n\
    |      if p.Transaction not lastcsr.RemoteTransaction+1 mod 2**32\n|         and\
    \ not STIset(lastcsr) or\n|        p.Transaction not lastcsr.RemoteTransaction+256\
    \ mod **32\n|        then\n|         { Out of order packet group }\n|        \
    \ NotifyClient(csr, p, BAD_TRANSACTION_ID )\n|         return\n|       endif\n\
    RFC 1045                       VMTP                        February 1988 \n| \
    \      if lastcsr not completed then\n|           NotifyClient( lastcsr, p, RETRY\
    \ )\n|       endif\n|       if lastcsr available then use it for this packet group\n\
    |       else allocate and initialize new CSR\n|       if CMG(lastcsr) then\n|\
    \          Add segment data to lastcsr Request\n|          Keep csr as record\
    \ of this packet group.\n|          Clear lastcsr.VerifyInterval\n|      endif\n\
    |   else { First packet group }\n        if MultipleRemoteClients(csr) then ScavengeCsrs(p.Client)\n\
    \        Set csr.RemoteTransaction, csr.Priority\n        Copy message and segment\
    \ data to csr's segment area\n         and set csr.PacketDelivery to that delivered.\n\
    \        Clear csr.PacketDelivery\n        Clear csr.VerifyInterval\n        SaveNetworkAddress(\
    \ csr, p )\n    endif\n    if packetgroup not complete then\n        Timeout(\
    \ csr, TS3(p.Client), RemoteClientTimeout )\n        return;\n    endif\nendPacketGroup:\n\
    \    { We have received complete packet group. }\n    if APG(p) then NotifyClient(\
    \ csr, p, OK )\n    endif\n|   if NERset(p) and CMG(p) then\n|       Queue waiting\
    \ for continuation packet group.\n|       Timeout( csr, TS3(csr.Client), RemoteClientTimeout\
    \ )\n|       return\n|   endif\n    { Deliver request message. }\n    if GroupId(csr.Server)\
    \ then\n        For each server identified by csr.Server\n            Replicate\
    \ csr and associated data segment.\n            if CMDset(csr) and Server busy\
    \ then\n               Discard csr and data\n            else\n              \
    \ Deliver or invoke csr for each Server.\n            if not DGMset(csr) then\
    \ queue for Response\n            else Timeout( csr, TS4(csr.Client), FreeCsr\
    \ )\n        endfor\n     else\n       if CMDset(csr) and Server busy then\n \
    \          Discard csr and data\n        else\nRFC 1045                      \
    \ VMTP                        February 1988 \n           Deliver or invoke csr\
    \ for this server.\n        if not DGMset(csr) then queue for Response\n     \
    \   else Timeout( csr, TS4(csr.Client), FreeCsr )\n     endif\nend HandleRequest\n\
    Notes:\n   1. A Request received that specifies a Client that is a local\n   \
    \   entity should be a Request forwarded by a remote server to a\n      local\
    \ Server.\n   2. An alternative structure for handling a Request sent to a\n \
    \     group when there are multiple local group members is to\n      create a\
    \ remote CSR for each group member on reception of the\n      first packet and\
    \ deliver a copy of each packet to each such\n      remote CSR as each packet\
    \ arrives.\nRFC 1045                       VMTP                        February\
    \ 1988 \n5.8. Management Operations\nVMTP uses management operations (invoked\
    \ as remote procedure calls) to\neffectively acknowledge packet groups and request\
    \ retransmissions.  The\nfollowing routine is invoked by the Server's management\
    \ module on\nrequest from the Client.\nNotifyVmtpServer(server,clientId,transact,delivery,code)\n\
    \    Find csr with same RemoteTransaction and RemoteClient\n    as clientId and\
    \ transact.\n    if not found or csr.State not Responded then return\n    if DGMset(csr)\
    \ then\n        if transmission of Response in progress then\n            Abort\
    \ transmission\n            if code is migrated then\n               restart transmission\
    \ with new host addr.\n        if Retry then Report protocol error\n        return\n\
    \    endif\n    select on code\n      case RETRY:\n        if csr.RetransCount\
    \ > MaxRetrans(clientId) then\n             if response data segment then\n  \
    \               Discard data and mark as RESPONSE_DISCARDED\n|               \
    \ if NERset(csr) and subsequent csr then\n|                    Deallocate csr\
    \ and use later csr for\n|                    future duplicate suppression\n|\
    \                endif\n             return\n        endif\n        increment\
    \ csr.RetransCount\n        Set csr.TransmissionMask to missing segment blocks,\n\
    \            as specified by delivery\n        SendPacketGroup( csr )\n      \
    \  Timeout( csr, TS3(csr.Client), RemoteClientTimeout )\n      case BUSY:\n  \
    \      if csr.TimeLimit exceeded then\n            if response data segment then\n\
    \                Discard data and mark as RESPONSE_DISCARDED\n|              \
    \ if NERset(csr) and subsequent csr then\n|                   Deallocate csr and\
    \ use later csr for\n|                   future duplicate suppression\n|     \
    \          endif\n             endif\n        endif\n        Set csr.TransmissionMask\
    \ for full retransmission\n        Clear csr.RetransCount\nRFC 1045          \
    \             VMTP                        February 1988 \n        Timeout( csr,\
    \ TS3(csr.Server), RemoteClientTimeout )\n        return\n      case ENTITY_MIGRATED:\n\
    \        Get new host address for entity\n        Set csr.TransmissionMask for\
    \ full retransmission\n        Clear csr.RetransCount\n        SendPacketGroup(\
    \ csr )\n        Timeout( csr, TS3(csr.Server), RemoteClientTimeout )\n      \
    \  return\n      case default:\n        Abort transmission of Response if in progress.\n\
    \        if response data segment then\n           Discard data and mark as RESPONSE_DISCARDED\n\
    \           if NERset(csr) and subsequent csr then\n               Deallocate\
    \ csr and use later csr for\n               future duplicate suppression\n   \
    \        endif\n        return\n    endselect\nend NotifyVmtpServer\nNotes:\n\
    \   1. A NotifyVmtpServer operation requesting retransmission of\n      the Response\
    \ is acceptable only if the Response was not\n      idempotent.  When the Response\
    \ is idempotent, the Client must\n      be prepared to retransmit the Request\
    \ to effectively request\n      retransmission of the Response.\n   2. A NotifyVmtpServer\
    \ operation may be received while the\n      Response is being transmitted.  If\
    \ an error return, as an\n      efficiency, the transmission should be aborted,\
    \ as suggested\n      when the Response is a datagram.\n   3. A NotifyVmtpServer\
    \ operation indicating OK or an error\n      allows the Server to discard segment\
    \ data and not provide for\n      subsequent retransmission of the Response.\n\
    5.8.1. HandleRequestNoCSR\nWhen a Request is received from a Client for which\
    \ the node has no CSR,\nthe node allocates and initializes a CSR for this Client\
    \ and does a\ncallback to the Client's VMTP management module to get the Principal,\n\
    Process and other information associated with this Client.  It also\nRFC 1045\
    \                       VMTP                        February 1988 \nchecks that\
    \ the TransactionId is correct in order to filter out\nduplicates.\nHandleRequestNoCSR(\
    \ p, psize )\n|   if Secure(p) then\n|       Allocate and init CSR\n|       SaveSourceHostAddr(\
    \ csr, p )\n|       ProbeRemoteClient( csr, p, AUTH_PROBE )\n|       if no response\
    \ or error then\n|          delete CSR\n|          return\n|       Decrypt( csr.Key,\
    \ p, psize )\n|        if p.Checksum not null then\n|       if not VerifyChecksum(p,\
    \ psize) then return;\n|       if OppositeByteOrder(p) then ByteSwap( p, psize\
    \ )\n|       if psize not equal sizeof(VmtpHeader) + 4*p.Length then\n|      \
    \    NotifyClient(NULL, p, VMTP_ERROR )\n|          return\n|       HandleRequest(\
    \ csr, p, psize )\n|       return\n    if Server does not exist then\n       \
    \ NotifyClient( csr, p, NONEXISTENT_ENTITY )\n        return\n    endif\n    if\
    \ security required by server then\n        NotifyClient(csr, p, SECURITY_REQUIRED\
    \ )\n        return\n    endif\n    Allocate and init CSR\n    SaveSourceHostAddr(\
    \ csr, p );\n    if server requires Authentication then\n        ProbeRemoteClient(\
    \ csr, p, AUTH_PROBE )\n        if no response or error then\n           delete\
    \ CSR\n           return\n    endif\n    { Setup immediately as a new message\
    \ transaction }\n    set csr.Server to p.Server\n    set csr.RemoteTransaction\
    \ to p.Transaction-1\n    HandleRequest( csr, p, psize )\n    endif\nNotes:\n\
    \   1. A Probe request is always handled as a Request not requiring\n      authentication\
    \ so it never generates a callback Probe to the\nRFC 1045                    \
    \   VMTP                        February 1988 \n      Client.\n   2. If the Server\
    \ host retains remote client CSR's for longer\n      than the maximum packet lifetime\
    \ and the Request\n      retransmission time, and the host has been running for\
    \ at\n      least that long, then it is not necessary to do a Probe\n      callback\
    \ unless the Request is secure.  A Probe callback can\n      take place when the\
    \ Server asks for the Process or\n      PrincipalId associated with the Client.\n\
    RFC 1045                       VMTP                        February 1988 \n5.9.\
    \ Timeouts\nThe server must implement a timeout for remote client CSRs.  There\
    \ is a\ntimeout for each CSR in the server.\nRemoteClientTimeout( csr )\n  select\
    \ on csr.State\n    case Responded:\n        if RESPONSE_DISCARDED then\n    \
    \        mark as timed out\n            Make a candidate for reuse.\n        \
    \    return\n        if csr.RetransCount > MaxRetrans(Client) then\n         \
    \   discard Response\n            mark CSR as RESPONSE_DISCARDED\n           \
    \ Timeout(csr, TS4(Client), RemoteClientTimeout)\n            return\n       \
    \ increment csr.RetransCount\n        { Retransmit Response or forwarded Request\
    \ }\n        Set APG to get acknowledgement.\n        SendPacketGroup( csr )\n\
    \        Timeout( csr, TS3(Client), RemoteClientTimeout )\n        return\n  \
    \  case ReceivingRequest:\n      if csr.RetransCount > MaxRetrans(csr.Client)\n\
    \         or DGMset(csr) or NRTset(csr) then\n          Modify csr.segmentSize\
    \ and csr.MsgDelivery\n          to indicate packets received.\n          if MDMset(csr)\
    \ then\n              Invoke processing on Request\n              return\n   \
    \       else\n              discard Request and reuse CSR\n              (Note:\
    \ Need not remember Request discarded.)\n              return\n      increment\
    \ csr.RetransCount\n      NotifyClient( csr, p, RETRY )\n      Timeout( csr, TS3(Client),\
    \ RemoteClientTimeout )\n      return\n    default:\n        Report error - invalid\
    \ state for RemoteClientTimeout\n    endselect\nend RemoteClientTimeout\nNotes:\n\
    \   1. When a CSR in the Responded state times out after discarding\nRFC 1045\
    \                       VMTP                        February 1988 \n      the\
    \ Response, it can be made available for reuse, either by\n      the same Client\
    \ or a different one.  The CSR should be kept\n      available for reuse by the\
    \ Client for as long as possible to\n      avoid unnecessary callback Probes.\n\
    RFC 1045                       VMTP                        February 1988 \n6.\
    \ Concluding Remarks\nThis document represents a description of the current state\
    \ of the VMTP\ndesign.  We are currently engaged in several experimental\nimplementations\
    \ to explore and refine all aspects of the protocol.\nPreliminary implementations\
    \ are running in the UNIX 4.3BSD kernel and in\nthe V kernel.\nSeveral issues\
    \ are still being discussed and explored with this\nprotocol.  First, the size\
    \ of the checksum field and the algorithm to\nuse for its calculation are undergoing\
    \ some discussion.  The author\nbelieves that the conventional 16-bit checksum\
    \ used with TCP and IP is\ntoo weak for future high-speed networks, arguing for\
    \ at least a 32-bit\nchecksum.  Unfortunately, there appears to be limited theory\
    \ covering\nchecksum algorithms that are suitable for calculation in software.\n\
    Implementation of the streaming facilities of VMTP is still in progress.\nThis\
    \ facility is expected to be important for wide-area, long delay\ncommunication.\n\
    RFC 1045                       VMTP                        February 1988 \nI.\
    \ Standard VMTP Response Codes\nThe following are the numeric values of the response\
    \ codes used in VMTP.\n0               OK\n1               RETRY\n2          \
    \     RETRY_ALL\n3               BUSY\n4               NONEXISTENT_ENTITY\n5 \
    \              ENTITY_MIGRATED\n6               NO_PERMISSION\n7             \
    \  NOT_AWAITING_MSG\n8               VMTP_ERROR\n9               MSGTRANS_OVERFLOW\n\
    10              BAD_TRANSACTION_ID\n11              STREAMING_NOT_SUPPORTED\n\
    12              NO_RUN_RECORD\n13              RETRANS_TIMEOUT\n14           \
    \   USER_TIMEOUT\n15              RESPONSE_DISCARDED\n16              SECURITY_NOT_SUPPORTED\n\
    17              BAD_REPLY_SEGMENT\n18              SECURITY_REQUIRED\n19     \
    \         STREAMED_RESPONSE\n20              TOO_MANY_RETRIES\n21            \
    \  NO_PRINCIPAL\nRFC 1045                       VMTP                        February\
    \ 1988 \n22              NO_KEY\n23              ENCRYPTION_NOT_SUPPORTED\n24\
    \              NO_AUTHENTICATOR\n25-63           Reserved for future VMTP assignment.\n\
    Other values of the codes are available for use by higher level\nprotocols.  Separate\
    \ protocol documents will specify further standard\nvalues.\nApplications are\
    \ free to use values starting at 0x00800000 (hex) for\napplication-specific return\
    \ values.\nRFC 1045                       VMTP                        February\
    \ 1988 \nII. VMTP RPC Presentation Protocol\nFor complete generality, the mapping\
    \ of the procedures and the\nparameters onto VMTP messages should be defined by\
    \ a RPC presentation\nprotocol.  In the absence of an accepted standard protocol,\
    \ we define an\nRPC presentation protocol for VMTP as follows.\nEach procedure\
    \ is assigned an identifying Request Code.  The Request\ncode serves effectively\
    \ the same as a tag field of variant record,\nidentifying the format of the Request\
    \ and associated Response as a\nvariant of the possible message formats.\nThe\
    \ format of the Request for a procedure is its Request Code followed\nby its parameters\
    \ sequentially in the message control block until it is\nfull.\nThe remaining\
    \ parameters are sent as part of the message segment data\nformatted according\
    \ to the XDR protocol (RFC ??).  In this case, the\nsize of the segment is specified\
    \ in the SegmentSize field.\nThe Response for a procedure consists of a ResponseCode\
    \ field followed\nby the return parameters sequentially in the message control\
    \ block,\nexcept if there is a parameter returned that must be transmitted as\n\
    segment data, its size is specified in the SegmentSize field and the\nparameter\
    \ is stored in the SegmentData field.\nAttributes associated with procedure definitions\
    \ should indicate the\nFlags to be used in the RequestCode.  Request Codes are\
    \ assigned as\ndescribed below.\nII.1. Request Code Management\nRequest codes\
    \ are divided into Public Interface Codes and\napplication-specific, according\
    \ to whether the PIC value is set.  An\ninterface is a set of request codes representing\
    \ one service or module\nfunction.  A public interface is one that is to be used\
    \ in multiple\nindependently developed modules.  In VMTP, public interface codes\
    \ are\nallocated in units of 256 structured as\n +-------------+----------------+-------------------+\n\
    \ | ControlFlags|  Interface     | Version/Procedure |\n +-------------+----------------+-------------------+\n\
    \    8 bits          16 bits              8 bits\nAn interface is free to allocate\
    \ the 8 bits for version and procedure as\ndesired.  For example, all 8 bits can\
    \ be used for procedures.  A module\nRFC 1045                       VMTP     \
    \                   February 1988 \nmultiple Interface values.  They need not\
    \ be consecutive Interface\nvalues.\nRFC 1045                       VMTP     \
    \                   February 1988 \nIII. VMTP Management Procedures\nStandard\
    \ procedures are defined for VMTP management, including creation,\ndeletion and\
    \ query of entities and entity groups, probing to get\ninformation about entities,\
    \ and updating message transaction information\nat the client or the server.\n\
    The procedures are implemented by the VMTP manager that constitutes a\nportion\
    \ of every complete VMTP module.  Each procedure is invoked by\nsending a Request\
    \ to the VMTP manager that handles the entity specified\nin the operation or the\
    \ local manager.  The Request sent using the\nnormal Send operation with the Server\
    \ specified as the well-known entity\ngroup VMTP_MANGER_GROUP, using the CoResident\
    \ Entity mechanism to direct\nthe request to the specific manager that should\
    \ handle the Request.\n(The ProbeEntity operation is multicast to the VMTP_MANAGER_GROUP\
    \ if the\nhost address for the entity is not known locally and the host address\
    \ is\ndetermined as the host address of the responder.  For all other\noperations,\
    \ a ProbeEntity operation is used to determine the host\naddress if it is not\
    \ known.)  Specifying co-resident entity 0 is\ninterpreted as the co-resident\
    \ with the invoking process.  The\nco-resident entity identifier may also specify\
    \ a group in which case,\nthe Request is sent to all managers with members in\
    \ this group.\nThe standard procedures with their RequestCode and parameters are\
    \ listed\nbelow with their semantics.  (The RequestCode range 0xVV000100 to\n\
    0xVV0001FF is reserved for use by the VMTP management routines, where VV\nis any\
    \ choice of control flags with the PIC bit set.  The flags are set\nbelow as required\
    \ for each procedure.)\n0x05000101 - ProbeEntity(CREntity, entityId, authDomain)\
    \ -> (code,\n                <staterec>) \n                Request and return\
    \ information on the specified entity\n                in the specified authDomain,\
    \ sending the Request to the\n                VMTP management module coresident\
    \ with CREntity.  An\n                error return is given if the requested information\n\
    \                cannot be provided in the specified authDomain.  The\n      \
    \          <staterec> returned is structured as the following\n              \
    \  fields.\n                Transaction identifier\n                         \
    \       The current or next transaction\n                                identifier\
    \ being used by the probed\n                                entity.\n        \
    \        ProcessId: 64 bits \n                                Identifier for client\
    \ process.  The\n                                meaning of this is specified\
    \ as part of\nRFC 1045                       VMTP                        February\
    \ 1988 \n                                the Domain definition.\n            \
    \    PrincipalId     The identifier for the principal or\n                   \
    \             account associated with the process\n                          \
    \      specified by ProcessId.  The meaning of\n                             \
    \   this field is specified as part of the\n                                Domain\
    \ definition.\n                EffectivePrincipalId\n                        \
    \        The identifier for the principal or\n                               \
    \ account associated with the Client port,\n                                which\
    \ may be different from the\n                                PrincipalId especially\
    \ if this is an\n                                nested call.  The meaning of\
    \ this field\n                                is specified as part of the Domain\n\
    \                                definition.\n                The code field indicates\
    \ whether this is an error\n                response or not.  The codes and their\
    \ interpretation\n                are:\n                  OK\n               \
    \ No error. Probe was completed OK.\n                  NONEXISTENT_ENTITY\n  \
    \              Specified entity does not exist.\n                  ENTITY_MIGRATED\n\
    \                The entity has migrated and is no longer at the host to\n   \
    \             which the request was sent.\n                  NO_PERMISSION\n \
    \               Entity has refused to provide ProbeResponse.\n               \
    \   VMTP_ERROR\n                The Request packet group was in error relative\
    \ to the\n                VMTP protocol specification.\n                  \"default\"\
    \n                Some type of error - discard ProbeResponse.\n0x0D000102 - AuthProbeEntity(CREntity,entityId,authDomain,randomId)\
    \ ->\n                (code,ProbeAuthenticator,EncryptType,EntityAuthenticator)\n\
    \                Request authentication of the entity specified by\n         \
    \       entityId from the VMTP manager coresident with CREntity\n            \
    \    in authDomain authentication domain, returning the\nRFC 1045            \
    \           VMTP                        February 1988 \n                information\
    \ contained in the return parameters.  The\n                fields are set the\
    \ same as that specified for the basic\n                ProbeResponse except as\
    \ noted below.\n                ProbeAuthenticator\n                         \
    \       20 bytes consisting of the EntityId, the\n                           \
    \     randomId and the probed Entity's current\n                             \
    \   Transaction value plus a 32-bit checksum\n                               \
    \ for these two fields (checksummed using\n                                the\
    \ standard packet Checksum algorithm),\n                                all encrypted\
    \ with the Key supplied in\n                                the Authenticator.\n\
    \                EncryptType     An identifier that identifies the\n         \
    \                       variant of encryption method being used\n            \
    \                    by the probed Entity for packets it\n                   \
    \             transmits and packets it is able to\n                          \
    \      receive.  (See Appendix V.)  The\n                                high-order\
    \ 8 bits of the EncryptType\n                                contain the XOR of\
    \ the 8 octets of the\n                                PrincipalId associated\
    \ with private key\n                                used to encrypt the EntityAuthenticator.\n\
    \                                This value is used by the requestor or\n    \
    \                            Client as an aid in locating the key to\n       \
    \                         decrypt the authenticator.\n                EntityAuthenticator\n\
    \                                (returned as segment data) The\n            \
    \                    ProcessId, PrincipalId,\n                               \
    \ EffectivePrincipal associated with the\n                                ProbedEntity\
    \ plus the private\n                                encryption/decryption key\
    \ and its\n                                lifetime limit to be used for\n   \
    \                             communication with the Entity.  The\n          \
    \                      authenticator is encrypted with a\n                   \
    \             private key associated with the Client\n                       \
    \         entity such that it can be neither read\n                          \
    \      nor forged by a party not trusted by the\n                            \
    \    Client Entity.  The format of the\n                                Authenticator\
    \ in the message segment is\n                                shown in detail in\
    \ Figure III-1.\n                Key: 64 bits    Encryption key to be used for\
    \ encrypting\n                                and decrypting packets sent to and\n\
    \                                received from the probed Entity.  This\n    \
    \                            is the \"working\" key for packet\n             \
    \                   transmissions.  VMTP only uses private\nRFC 1045         \
    \              VMTP                        February 1988 \n                +-----------------------------------------------+\n\
    \                |            ProcessId   (8 octets)             |\n         \
    \       +-----------------------------------------------+\n                | \
    \          PrincipalId  (8 octets)             |\n                +-----------------------------------------------+\n\
    \                |           EffectivePrincipalId  (8 octets)    |\n         \
    \       +-----------------------------------------------+\n                | \
    \           Key  (8 octets)                    |\n                +-----------------------------------------------+\n\
    \                |              KeyTimeLimit                     |\n         \
    \       +-----------------------------------------------+\n                | \
    \             AuthDomain                       |\n                +-----------------------------------------------+\n\
    \                |               AuthChecksum                    |\n         \
    \       +-----------------------------------------------+\n                  Figure\
    \ III-1:   Authenticator Format\n                                key encryption\
    \ for data transmission.\n                KeyTimeLimit: 32 bits \n           \
    \                     The time in seconds since Dec. 31st,\n                 \
    \               1969 GMT at which one should cease to\n                      \
    \          use the Key.\n                AuthDomain: 32 bits \n              \
    \                  The authentication domain in which to\n                   \
    \             interpret the principal identifiers.\n                         \
    \       This may be different from the\n                                authDomain\
    \ specified in the call if the\n                                Server cannot\
    \ provide the authentication\n                                information in the\
    \ request domain.\n                AuthChecksum: 32 bits \n                  \
    \              Contains the checksum (using the same\n                       \
    \         Checksum algorithm as for packet) of\n                             \
    \   KeyTimeLimit, Key, PrincipalId and\n                                EffectivePrincipalId.\n\
    \                Notes:\n                   1. A authentication Probe Request\
    \ and Response\n                      are sent unencrypted in general because\
    \ it is\n                      used prior to there being a secure channel.\n \
    \                     Therefore, specific fields or groups of\n              \
    \        fields checksummed and encrypted to prevent\n                      unauthorized\
    \ modification or forgery.  In\nRFC 1045                       VMTP          \
    \              February 1988 \n                      particular, the ProbeAuthenticator\
    \ is\n                      checksummed and encrypted with the Key.\n        \
    \           2. The ProbeAuthenticator authenticates the\n                    \
    \  Response as responding to the Request when\n                      its EntityId,\
    \ randomId and Transaction values\n                      match those in the Probe\
    \ request.  The\n                      ProbeAutenticator is bound to the\n   \
    \                   EntityAutenticator by being encrypted by the\n           \
    \           private Key contained in that authenticator.\n                   3.\
    \ The authenticator is encrypted such that it\n                      can be decrypted\
    \ by a private key, known to\n                      the Client.  This authenticator\
    \ is presumably\n                      obtained from a key distribution center\
    \ that\n                      the Client trusts.  The AuthChecksum prevents\n\
    \                      undetected modifications to the\n                     \
    \ authenticator.\n0x05000103 - ProbeEntityBlock( entityId ) -> ( code, entityId\
    \ ) \n                Check whether the block of 256 entity identifiers\n    \
    \            associated with this entityId are in use.  The entityId\n       \
    \         returned should match that being queried or else the\n             \
    \   return value should be ignored and the operation redone.\n0x05000104 - QueryVMTPNode(\
    \ entityId ) -> (code, MTU, flags, authdomain,\n                domains, authdomains,\
    \ domainlist) \n                Query the VMTP management module for entityId\
    \ to get\n                various module- or node-wide parameters, including:\
    \  (1)\n                MTU - Maximum transmission unit or packet size handled\n\
    \                by this node.  (2) flags- zero or more of the following\n   \
    \             bit fields:\n                1               Handles streamed Requests.\n\
    \                2               Can issue streamed message transactions\n   \
    \                             for clients.\n                4               Handles\
    \ secure Requests.\n                8               Can issue secure message transactions.\n\
    \                The authdomain indicates the primary authentication\n       \
    \         domain supported.  The domains and authdomains\n                parameters\
    \ indicate the number of entity domains and\n                authentication domains\
    \ supported by this node, which are\n                listed in the data segment\
    \ parameter domainlist if\nRFC 1045                       VMTP               \
    \         February 1988 \n                either parameter is non-zero. (All the\
    \ entity domains\n                precede the authentication domains in the data\
    \ segment.)\n0x05000105 - GetRequestForwarder( CREntity, entityId1 ) -> (code,\n\
    \                entityId2, principal, authDomain) \n                Return the\
    \ forwarding server's entity identifer and\n                principal for the\
    \ forwarder of entityId1.  CREntity\n                should be zero to get the\
    \ local VMTP management module.\n0x05000106 - CreateEntity( entityId1 ) -> ( code,\
    \ entityId2 ) \n                Create a new entity and return its entity identifier\
    \ in\n                entityId2.  The entity is created local to the entity\n\
    \                specified in entityId1 and local to the requestor if\n      \
    \          entityId1 is 0.\n0x05000107 - DeleteEntity( entityId ) -> ( code )\
    \ \n                Delete the entity specified by entityId, which may be a\n\
    \                group.  If a group, the deletion is only on a best\n        \
    \        efforts basis.  The client must take additional measures\n          \
    \      to ensure complete deletion if required.\n0x0D000108 -QueryEntity( entityId\
    \ ) -> ( code, descriptor ) \n                Return a descriptor of entityId\
    \ in arg of a maximum of\n                segmentSize bytes.\n0x05000109 - SignalEntity(\
    \ entityId, arg )->( code ) \n                Send the signal specified by arg\
    \ to the entity specified\n                by entityId.  (arg is 32 bits.)\n0x0500010A\
    \ - CreateGroup(CREntity,entityGroupId,entityId,perms)->(code)\n             \
    \   Request that the VMTP manager local to CREntity create\n                an\
    \ new entity group, using the specified entityGroupId\n                with entityId\
    \ as the first member and permissions\n                \"perms\", a 32-bit field\
    \ described later.  The invoker is\n                registered as a manager of\
    \ the new group, giving it the\n                permissions to add or remove members.\
    \  (Normally\n                CREntity is 0, indicating the VMTP manager local\
    \ to the\n                requestor.)\n0x0500010B - AddToGroup(CREntity, entityGroupId,\
    \ entityId,\n                perms)->(code) \n                Request that the\
    \ VMTP manager local to CREntity add the\n                specified entityId to\
    \ the entityGroupId with the\n                specified permissions.  If entityGroupId\
    \ specifies a\n                restricted group, the invoker must have permission\
    \ to\n                add members to the group, either because the invoker is\n\
    RFC 1045                       VMTP                        February 1988 \n  \
    \              a manager of the group or because it was added to the\n       \
    \         group with the required permissions.  If CREntity is 0,\n          \
    \      then the local VMTP manager checks permissions and\n                forwards\
    \ the request with CREntity set to entityId and\n                the entityId\
    \ field set to a digital signature (see\n                below) of the Request\
    \ by the VMTP manager, certifying\n                that the Client has the permissions\
    \ required by the\n                Request.  (If entityGroupId specifies an unrestricted\n\
    \                group, the Request can be sent directly to the handling\n   \
    \             VMTP manager by setting CREntity to entityId.)\n0x0500010C - RemoveFromGroup(CREntity,\
    \ entityGroupId, entityId)->(code) \n                Request that the VMTP manager\
    \ local to CREntity remove\n                the specified entityId from the group\
    \ specified by\n                entityGroupId.  Normally CREntity is 0, indicating\
    \ the\n                VMTP manager local to the requestor.  If CREntity is 0,\n\
    \                then the local VMTP manager checks permissions and\n        \
    \        forwards the request with CREntity set to entityId and\n            \
    \    the entityId field a digital signature of the Request by\n              \
    \  the VMTP manager, certifying that the Client has the\n                permissions\
    \ required by the Request.\n0x0500010D - QueryGroup( entityId )->( code, record\
    \ )...  \n                Return information on the specified entity.  The\n \
    \               Response from each responding VMTP manager is (code,\n       \
    \         record).  The format of the record is (memberCount,\n              \
    \  member1, member2, ...).  The Responses are returned on a\n                best\
    \ efforts basis; there is no guarantee that responses\n                from all\
    \ managers with members in the specified group\n                will be received.\n\
    0x0500010E - ModifyService(entityId,flags,count,pc,threadlist)->(code,\n     \
    \           count) \n                Modify the service associated with the entity\
    \ specified\n                by entityId.  The flags may indicate a message service\n\
    \                model, in which case the call \"count\" parameter\n         \
    \       indicates the maximum number of queued messages desired;\n           \
    \     the return \"count\" parameter indicates the number of\n               \
    \ queued message allowed.  Alternatively, the \"flags\"\n                parameters\
    \ indicates the RPC thread service model, in\n                which case \"count\"\
    \ threads are requested, each with an\n                inital program counter\
    \ as specified and stack, priority\n                and message receive area indicated\
    \ by the threadlist.\n                In particular, \"threadlist\" consists of\
    \ \"count\" records\n                of the form\n                (priority,stack,stacksize,segment,segmentsize),\
    \ each one\n                assigned to one of the threads.  Flags defined for\
    \ the\nRFC 1045                       VMTP                        February 1988\
    \ \n                \"flags\" parameter are:\n                1              \
    \ THREAD_SERVICE - otherwise the message\n                                model.\n\
    \                2               AUTHENTICATION_REQUIRED - Sent a Probe\n    \
    \                            request to determine principal\n                \
    \                associated with the Client, if not\n                        \
    \        known.\n                4               SECURITY_REQUIRED - Request must\
    \ be\n                                encrypted or else reject.\n            \
    \    8               INCREMENTAL - treat the count value as\n                \
    \                an increment (or decrement) relative to\n                   \
    \             the current value rather than an\n                             \
    \   absolute value for the maximum number of\n                               \
    \ queued messages or threads.\n                In the thread model, the count\
    \ must be a positive\n                increment or else 0, which disables the\
    \ service.  Only a\n                count of 0 terminates currently queued requests\
    \ or\n                in-progress request handling.\n0x4500010F -\n          \
    \      NotifyVmtpClient(client,cntrl,recSeq,transact,delivery,code)->()\n    \
    \            Update the state associated with the transaction\n              \
    \  specified by client and transact, an entity identifier\n                and\
    \ transaction identifier, respectively.  This\n                operation is normally\
    \ used only by another VMTP\n                management module.  (Note that it\
    \ is a datagram\n                operation.)  The other parameters are as follows:\n\
    \                ctrl            A 32-bit value corresponding to 4th\n       \
    \                         32-bit word of the VMTP header of a\n              \
    \                  Response packet that would be sent in\n                   \
    \             response to the Request that this is\n                         \
    \       responding to.  That is, the control\n                               \
    \ flags, ForwardCount, RetransmitCount and\n                                Priority\
    \ fields match those of the\n                                Request.  (The NRS\
    \ flag is set if the\n                                receiveSeqNumber field is\
    \ used.)  The\n                                PGCount subfield indicates the\
    \ number of\n                                previous Request packet groups being\n\
    \                                acknowledged by this Notify operation.\n    \
    \                            (The bit fields that are reserved in\nRFC 1045  \
    \                     VMTP                        February 1988 \n           \
    \                     this word in the header are also\n                     \
    \           reserved here and must be zero.)\n                recSeq         \
    \ Sequence number of reception at the\n                                Server\
    \ if the NRS flag is set in the\n                                ctrl parameter,\
    \ otherwise reserved and\n                                zero.  (This is used\
    \ for sender-based\n                                logging of message activity\
    \ for replay\n                                in case of failure - an optional\n\
    \                                facility.)\n                delivery        Indicates\
    \ the segment blocks of the\n                                packet group have\
    \ been received at the\n                                Server.\n            \
    \    code            indicates the action the client should\n                \
    \                take, as described below.\n                The VMTP management\
    \ module should take action on this\n                operation according to the\
    \ code, as specified below.\n                OK              Do nothing at this\
    \ time, continue\n                                waiting for the response with\
    \ a reset\n                                timer.\n                RETRY     \
    \      Retransmit the request packet group\n                                immediately\
    \ with at least the segment\n                                blocks that the Server\
    \ failed to\n                                receive, the complement of those\n\
    \                                indicated by the delivery parameter.\n      \
    \          RETRY_ALL       Retransmit the request packet group\n             \
    \                   immediately with at least the segment\n                  \
    \              blocks that the Server failed to\n                            \
    \    receive, as indicated by the delivery\n                                field\
    \ plus all subsequently transmitted\n                                packets that\
    \ are part of this packet\n                                run.  (The latter is\
    \ applicable only for\n                                streamed message transactions.)\n\
    \                BUSY            The server was unable to accept the\n       \
    \                         Request at this time.  Retry later if\n            \
    \                    desired to continue with the message\n                  \
    \              transaction.\n                NONEXISTENT_ENTITY\n            \
    \                    Specified Server entity does not exist.\nRFC 1045       \
    \                VMTP                        February 1988 \n                ENTITY_MIGRATED\
    \ The server entity has migrated and is no\n                                longer\
    \ at the host to which the request\n                                was sent.\
    \  The Server should attempt to\n                                determine the\
    \ new host address of the\n                                Client using the VMTP\
    \ management\n                                ProbeEntity operation (described\n\
    \                                earlier).\n                NO_PERMISSION   Server\
    \ has not authorized reception of\n                                messages from\
    \ this client.\n                NOT_AWAITING_MSG\n                           \
    \     The conditional message delivery bit was\n                             \
    \   set for the Request packet group and the\n                               \
    \ Server was not waiting for it so the\n                                Request\
    \ packet group was discarded.\n                VMTP_ERROR      The Request packet\
    \ group was in error\n                                relative to the VMTP protocol\n\
    \                                specification.\n                BAD_TRANSACTION_ID\n\
    \                                Transaction identifier is old relative\n    \
    \                            to the transaction identifier held for\n        \
    \                        the Client by the Server.\n                STREAMING_NOT_SUPPORTED\n\
    \                                Server does not support multiple\n          \
    \                      outstanding message transactions from\n               \
    \                 the same Client, i.e. streamed message\n                   \
    \             transactions.\n                SECURITY_NOT_SUPPORTED\n        \
    \                        The Request was secure and this Server\n            \
    \                    does not support security.\n                SECURITY_REQUIRED\n\
    \                                The Server is refusing the Request\n        \
    \                        because it was not encrypted.\n                NO_RUN_RECORD\
    \   Server has no record of previous packets\n                               \
    \ in this run of packet groups.  This can\n                                occur\
    \ if the first packet group is lost\n                                or if the\
    \ current packet group is sent\n                                significantly\
    \ later than the last one\n                                and the Server has\
    \ discarded its client\n                                state record.\nRFC 1045\
    \                       VMTP                        February 1988 \n0x45000110\
    \ - NotifyVmtpServer(server,client,transact,delivery,code)->() \n            \
    \    Update the server state associated with the transaction\n               \
    \ specified by client and transact, an entity identifier\n                and\
    \ transaction identifier, respectively.  This\n                operation is normally\
    \ used only by another VMTP\n                management module.  (Note that it\
    \ is a datagram\n                operation.)  The other parameters are as follows:\n\
    \                delivery        Indicates the segment blocks of the\n       \
    \                         Response packet group that have been\n             \
    \                   received at the Client.\n                code            indicates\
    \ the action the Server should\n                                take, as listed\
    \ below.\n                The VMTP management module should take action on this\n\
    \                operation according to the code, as specified below.\n      \
    \          OK              Client is satisfied with Response data.\n         \
    \                       The Server can discard the response\n                \
    \                data, if any.\n                RETRY           Retransmit the\
    \ Response packet group\n                                immediately with at least\
    \ the segment\n                                blocks that the Client failed to\n\
    \                                receive, as indicated by the delivery\n     \
    \                           parameter.  (The delivery parameter\n            \
    \                    indicates those segment blocks received\n               \
    \                 by the Client).\n                RETRY_ALL       Retransmit\
    \ the Response packet group\n                                immediately with\
    \ at least the segment\n                                blocks that the Client\
    \ failed to\n                                receive, as indicated by the (complement\n\
    \                                of) the delivery parameter.  Also,\n        \
    \                        retransmit all Response packet groups\n             \
    \                   send subsequent to the specified packet\n                \
    \                group.\n                NONEXISTENT_ENTITY\n                \
    \                Specified Client entity does not exist.\n                ENTITY_MIGRATED\
    \ The Client entity has migrated and is no\n                                longer\
    \ at the host to which the response\n                                was sent.\n\
    \                RESPONSE_DISCARDED\nRFC 1045                       VMTP     \
    \                   February 1988 \n                                The Response\
    \ was discarded and no longer\n                                of interest to\
    \ the Client.  This may\n                                occur if the conditional\
    \ message\n                                delivery bit was set for the Response\n\
    \                                packet group and the Client was not\n       \
    \                         waiting for it so the Response packet\n            \
    \                    group was discarded.\n                VMTP_ERROR      The\
    \ Response packet group was in error\n                                relative\
    \ to the VMTP protocol\n                                specification.\n0x41000111\
    \ -\n                NotifyRemoteVmtpClient(client,ctrl,recSeq,transact,delivery,code->()\n\
    \                The same as NotifyVmtpClient except the co-resident\n       \
    \         addressing is not used.  This operation is used to\n               \
    \ update client state that is remote when a Request is\n                forwarded.\n\
    Note the use of the CRE bit in the RequestCodes to route the request to\nthe correct\
    \ VMTP management module(s) to handle the request.\nIII.1. Entity Group Management\n\
    An entity in a group has a set of permissions associated with its\nmembership,\
    \ controling whether it can add or remove others, whether it\ncan remove itself,\
    \ and whether others can remove it from the group.  The\npermissions for entity\
    \ groups are as follows:\nVMTP_GRP_MANAGER    0x00000001 { Manager of group. }\n\
    VMTP_REM_BY_SELF    0x00000002 { Can be removed self. }\nVMTP_REM_BY_PRIN    0x00000004\
    \ { Can be rem'ed by same principal}\nVMTP_REM_BY_OTHE    0x00000008 { Can be\
    \ removed any others. }\nVMTP_ADD_PRIN       0x00000010 { Can add by same principal.\
    \ }\nVMTP_ADD_OTHE       0x00000020 { Can add any others. }\nVMTP_REM_PRIN   \
    \    0x00000040 { Can remove same principal. }\nVMTP_REM_OTHE       0x00000080\
    \ { Can remove any others. }\nTo remove an entity from a restricted group, the\
    \ invoker must have\npermission to remove that entity and the entity must have\
    \ permissions\nthat allow it to be removed by that entity.  With an unrestricted\
    \ group,\nonly the latter condition applies.\nWith a restricted group, a member\
    \ can only be added by another entity\nwith the permissions to add other entities.\
    \  The creator of a group is\ngiven full permissions on a group.  A entity adding\
    \ another entity to a\nRFC 1045                       VMTP                   \
    \     February 1988 \ngroup can only give the entity it adds a subset of its permissions.\n\
    With unrestricted groups, any entity can add itself to the group.  It\ncan also\
    \ add other entities to the group providing the entity is not\nmarked as immune\
    \ to such requests.  (This is an implementation\nrestriction that individual entities\
    \ can impose.)\nIII.2. VMTP Management Digital Signatures\nAs mentioned above,\
    \ the entityId field of the AddToGroup and\nRemoveFromGroup is used to transmit\
    \ a digital signature indicating the\npermission for the operation has been checked\
    \ by the sending kernel.\nThe digital signature procedures have not yet been defined.\
    \  This field\nshould be set to 0 for now to indicate no signature after the CREntity\n\
    parameter is set to the entity on which the operation is to be\nperformed.\nRFC\
    \ 1045                       VMTP                        February 1988 \nIV. VMTP\
    \ Entity Identifier Domains\nVMTP allows for several disjoint naming domains for\
    \ its endpoints.  The\n64-bit entity identifier is only unique and meaningful\
    \ within its\ndomain.  Each domain can define its own algorithm or mechanism for\n\
    assignment of entity identifiers, although each domain mechanism must\nensure\
    \ uniqueness, stability of identifiers and host independence.\nIV.1. Domain 1\n\
    For initial use of VMTP, we define the domain with Domain identifier 1\nas follows:\n\
    \ +-----------+----------------+------------------------+\n | TypeFlags | Discriminator\
    \  |    Internet Address    |\n +-----------+----------------+------------------------+\n\
    \    4 bits          28 bits                32 bits\nThe Internet address is the\
    \ Internet address of the host on which this\nentity-id is originally allocated.\
    \  The Discriminator is an arbitrary\nvalue that is unique relative to this Internet\
    \ host address.  In\naddition, the host must guarantee that this identifier does\
    \ not get\nreused for a long period of time after it becomes invalid.  (\"Invalid\"\
    \nmeans that no VMTP module considers in bound to an entity.)  One\ntechnique\
    \ is to use the lower order bits of a 1 second clock.  The clock\nneed not represent\
    \ real-time but must never be set back after a crash.\nIn a simple implementation,\
    \ using the low order bits of a clock as the\ntime stamp, the generation of unique\
    \ identifiers is overall limited to\nno more than 1 per second on average.  The\
    \ type flags were described in\nSection 3.1.\nAn entity may migrate between hosts.\
    \  Thus, an implementation can\nheuristically use the embedded Internet address\
    \ to locate an entity but\nshould be prepared to maintain a cache of redirects\
    \ for migrated\nentities, plus accept Notify operations indicating that migration\
    \ has\noccurred.\nEntity group identifiers in Domain 1 are structured in one of\
    \ two forms,\ndepending on whether they are well-known or dynamically allocated\n\
    identifiers.  A well-known entity identifier is structured as:\n +-----------+----------------+------------------------+\n\
    \ | TypeFlags |  Discriminator |Internet Host Group Addr|\n +-----------+----------------+------------------------+\n\
    \    4 bits          28 bits                32 bits\nRFC 1045                \
    \       VMTP                        February 1988 \nwith the second high-order\
    \ bit (GRP) set to 1.  This form of entity\nidentifier is mapped to the Internet\
    \ host group address specified in the\nlow-order 32 bits.  The Discriminator distinguishes\
    \ group identifiers\nusing the same Internet host group.  Well-known entity group\
    \ identifiers\nshould be allocated to correspond to the basic services provided\
    \ by\nhosts that are members of the group, not specifically because that\nservice\
    \ is provided by VMTP.  For example, the well-known entity group\nidentifier for\
    \ the domain name service should contain as its embedded\nInternet host group\
    \ address the host group for Domain Name servers.\nA dynamically allocated entity\
    \ identifier is structured as:\n +-----------+----------------+------------------------+\n\
    \ | TypeFlags |  Discriminator |   Internet Host Addr   |\n +-----------+----------------+------------------------+\n\
    \    4 bits          28 bits             32 bits\nwith the second high-order bit\
    \ (GRP) set to 1.  The Internet address in\nthe low-order 32 bits is a Internet\
    \ address assigned to the host that\ndynamically allocates this entity group identifier.\
    \  A dynamically\nallocated entity group identifier is mapped to Internet host\
    \ group\naddress 232.X.X.X where X.X.X are the low-order 24 bits of the\nDiscriminator\
    \ subfield of the entity group identifier.\nWe use the following notation for\
    \ Domain 1 entity identifiers <10> and\npropose it use as a standard convention.\n\
    \        <flags>-<discriminator>-<Internet address>\nwhere <flags> are [X]{BE,LE,RG,UG}[A]\n\
    \    X = reserved\n    BE = big-endian entity\n    LE = little-endian entity\n\
    \    RG = restricted group\n    UG = unrestricted group\n    A  = alias\nand <discriminator>\
    \ is a decimal integer and <Internet address> is in\nstandard dotted decimal IP\
    \ address notation.\nExamples:\n_______________\n<10>  This notation was developed\
    \ by Steve Deering.\nRFC 1045                       VMTP                     \
    \   February 1988 \nBE-25593-36.8.0.49 is big-endian entity #25593 created on\
    \ host\n                36.8.0.49.\nRG-1-224.0.1.0 is the well-known restricted\
    \ VMTP managers group.\nUG-565338-36.8.0.77 is unrestricted entity group #565338\
    \ created on host\n                36.8.0.77.\nLEA-7823-36.8.0.77 is a little-endian\
    \ alias entity #7823 created on host\n                36.8.0.77.\nThis notation\
    \ makes it easy to communicate and understand entity\nidentifiers for Domain 1.\n\
    The well-known entity identifiers specified to date are:\nVMTP_MANAGER_GROUP \
    \  RG-1-224.0.1.0\n                Managers for VMTP operations.\nVMTP_DEFAULT_BECLIENT\
    \  BE-1-224.0.1.0\n                Client entity identifier to use when a (big-endian)\
    \ host\n                has not determined or been allocated any client entity\n\
    \                identifiers.\nVMTP_DEFAULT_LECLIENT  LE-1-224.0.1.0\n       \
    \         Client entity identifier to use when a (little-endian)\n           \
    \     host has not determined or been allocated any client\n                entity\
    \ identifiers.\nNote that 224.0.1.0 is the host group address assigned to VMTP\
    \ and to\nwhich all VMTP hosts belong.\nOther well-known entity group identifiers\
    \ will be specified in\nsubsequent extensions to VMTP and in higher-level protocols\
    \ that use\nVMTP.\nIV.2. Domain 3\nDomain 3 is reserved for embedded systems that\
    \ are restricted to a\nsingle network and are independent of IP.  Entity identifiers\
    \ are\nallocated using the decentralized approach described below.  The mapping\n\
    of entity group identifiers is specific to the type of network being\nused and\
    \ not defined here.  In general, there should be a simple\nalgorithmic mapping\
    \ from entity group identifier to multicast address,\nsimilar to that described\
    \ for Domain 1.  Similarly, the values for\ndefault client identifier are specific\
    \ to the type of network and not\nRFC 1045                       VMTP        \
    \                February 1988 \ndefined here.\nIV.3. Other Domains\nDefinition\
    \ of additional VMTP domains is planned for the future.\nRequests for allocation\
    \ of VMTP Domains should be addressed to the\nInternet protocol administrator.\n\
    IV.4. Decentralized Entity Identifier Allocation\nThe ProbeEntityBlock operation\
    \ may be used to determine whether a block\nof entity identifiers is in use. \
    \ (\"In use\" means valid or reserved by a\nhost for allocation.)  This mechanism\
    \ is used to detect collisions in\nallocation of blocks of entity identifiers\
    \ as part of the implementation\nof decentralized allocation of entity identifiers.\
    \  (Decentralized\nallocation is used in local domain use of VMTP such as in embedded\n\
    systems- see Domain 3.)\nBasically, a group of hosts can form a Domain or sub-Domain,\
    \ a group of\nhosts managing their own entity identifier space or subspace,\n\
    respectively.  As an example of a sub-Domain, a group of hosts in Domain\n1 all\
    \ identified with a particular host group address can manage the\nsub-Domain corresponding\
    \ to all entity identifiers that contain that\nhost group address.  The ProbeEntityBlock\
    \ operation is used to allocate\nthe random bits of these identifiers as follows.\n\
    When a host requires a new block of entity identifiers, it selects a new\nblock\
    \ (randomly or by some choice algorithm) and then multicasts a\nProbeEntityBlock\
    \ request to the members of the (sub-)Domain some R\ntimes.  If no response is\
    \ received after R (re)transmissions, the host\nconcludes that it is free to use\
    \ this block of identifiers.  Otherwise,\nit picks another block and tries again.\n\
    Notes:\n   1. A block of 256 identifiers is specified by an entity\n      identifier\
    \ with the low-order 8 bits all zero.\n   2. When a host allocates an initial\
    \ block of entity identifiers\n      (and therefore does not yet have a specified\
    \ entity\n      identifier to use) it uses VMTP_DEFAULT_BECLIENT (if\n      big-endian,\
    \ else VMTP_DEFAULT_LECLIENT if little-endian) as\n      its client identifier\
    \ in the ProbeEntityBlock Request and a\n      transaction identifier of 0.  As\
    \ soon as it has allocated a\n      block of entity identifiers, it should use\
    \ these identifiers\n RFC 1045                       VMTP                    \
    \    February 1988 \n      for all subsequent communication.  The default client\n\
    \      identifier values are defined for each Domain.\n   3. The set of hosts\
    \ using this decentralized allocation must not\n      be subject to network partitioning.\
    \  That is, the R\n      transmissions must be sufficient to ensure that every\
    \ host\n      sees the ProbeEntityBlock request and (reliably) sends a\n     \
    \ response.  (A host that detects a collision can retransmit\n      the response\
    \ multiple times until it sees a new\n      ProbeEntityBlock operation from the\
    \ same host/Client up to a\n      maximum number of times.)  For instance, a set\
    \ of machines\n      connected by a single local network may able to use this\
    \ type\n      of allocation.\n   4. To guarantee T-stability, a host must prevent\
    \ reuse of a\n      block of identifiers if any of the identifiers in the block\n\
    \      are currently valid or have been valid less than T seconds\n      previously.\
    \  To this end, a host must remember recently used\n      identifiers and object\
    \ to their reuse in response to a\n      ProbeEntityBlock operation.\n   5. Care\
    \ is required in a VMTP implementation to ensure that\n      Probe operations\
    \ cannot be discarded due to lack of buffer\n      space or queued or delayed\
    \ so that a response is not\n      generated quickly.  This is required not only\
    \ to detect\n      collisions but also to provide accurate roundtrip estimates\n\
    \      as part of ProbeEntity operations.\nRFC 1045                       VMTP\
    \                        February 1988 \nV. Authentication Domains\nA VMTP authentication\
    \ domain defines the format and interpretation for\nprincipal identifiers and\
    \ encryption keys.  In particular, an\nauthentication domain must specify a means\
    \ by which principal\nidentifiers are allocated and guaranteed unique and stable.\
    \  The\ncurrently defined authentication domains are as follows (0 is reserved).\n\
    Ideally, all entities within one entity domain are also associated with\none authentication\
    \ domain.  However, authentication domains are\northogonal to entity domains.\
    \  Entities within one domain may have\ndifferent authentication domains.  (In\
    \ this case, it is generally\nnecessary to have some correspondence between principals\
    \ in the\ndifferent domains.)  Also, one entity identifier may be associated with\n\
    multiple authentication domains.  Finally, one authentication domain may\nbe used\
    \ across multiple entity domains.\nV.1. Authentication Domain 1\nA principal identifier\
    \ is structured as follows.\n +---------------------------+------------------------+\n\
    \ |     Internet Address      | Local User Identifier  |\n +---------------------------+------------------------+\n\
    \             32 bits                    32 bits\nThe Internet Address may specify\
    \ an individual host (such as a UNIX\nmachine) or may specify a host group address\
    \ corresponding to a cluster\nof machines operating under a single adminstration.\
    \  In both cases,\nthere is assumed to be an adminstration associated with the\
    \ embedded\nInternet address that guarantees the uniqueness and stability of the\n\
    User Identifier relative to the Internet address.  In particular, that\nadministration\
    \ is the only one authorized to allocate principal\nidentifiers with that Internet\
    \ address prefix, and it may allocate any\nof these identifiers.\nIn authentication\
    \ domain 1, the standard EncryptionQualifiers are:\n0               Clear text\
    \ - no encryption.\n1               use 64-bit CBC DES for encryption and decryption.\n\
    V.2. Other Authentication Domains\nOther authentication domains will be defined\
    \ in the future as needed.\nRFC 1045                       VMTP              \
    \          February 1988 \nVI. IP Implementation\nVMTP is designed to be implemented\
    \ on the DoD IP Internet Datagram\nProtocol (although it may also be implemented\
    \ as a local network\nprotocol directly in \"raw\" network packets.)\nVMTP is\
    \ assigned the protocol number 81.\nWith a 20 octet IP header and one segment\
    \ block, a VMTP packet is 600\noctets.  By convention, any host implementing VMTP\
    \ implicitly agrees to\naccept VMTP/IP packets of at least 600 octets.\nVMTP multicast\
    \ facilities are designed to work with, and have been\nimplemented using, the\
    \ multicast extensions to the Internet [8]\ndescribed in RFC 966 and 988.  The\
    \ wide-scale use of full VMTP/IP\ndepends on the availability of IP multicast\
    \ in this form.\nRFC 1045                       VMTP                        February\
    \ 1988 \nVII. Implementation Notes\nThe performance and reliability of a protocol\
    \ in operation is highly\ndependent on the quality of its implementation, in addition\
    \ to the\n\"intrinsic\" quality of the protocol design.  One of the design goals\
    \ of\nthe VMTP effort was to produce an efficiently implementable protocol.\n\
    The following notes and suggestions are based on experience with\nimplementing\
    \ VMTP in the V distributed system and the UNIX 4.3 BSD\nkernel.  The following\
    \ is described for a client and server handling\nonly one domain.  A multi-domain\
    \ client or server would replicate these\nstructures for each domain, although\
    \ buffer space may be shared.\nVII.1. Mapping Data Structures\nThe ClientMap procedure\
    \ is implemented using a hash table that maps to\nthe Client State Record whether\
    \ this entity is local or remote, as shown\nin Figure VII-1.\n             +---+---+--------------------------+\n\
    \ ClientMap   |   | x |                          |\n             +---+-|-+--------------------------+\n\
    \                   |   +--------------+    +--------------+\n               \
    \    +-->| LocalClient  |--->| LocalClient  |\n                       +--------------+\
    \    +--------------+\n                       | RemoteClient |    | RemoteClient\
    \ |-> ...\n                       +--------------+    +--------------+\n     \
    \                  |              |    |              |\n                    \
    \   |              |    |              |\n                       +--------------+\
    \    +--------------+\n            Figure VII-1:   Mapping Client Identifier to\
    \ CSR\nLocal clients are linked through the LocalClientLink, similarly for the\n\
    RemoteClientLink.  Once a CSR with the specified Entity Id is found,\nsome field\
    \ or flag indicates whether it is identifying a local or remote\nEntity.  Hash\
    \ collisions are handled with the overflow pointers\nLocalClientLink and RemoteClientLink\
    \ (not shown) in the CSR for the\nLocalClient and RemoteClient fields, respectively.\
    \  Note that a CSR\nrepresenting an RPC request has both a local and remote entity\n\
    identifier mapping to the same CSR.\nThe Server specified in a Request is mapped\
    \ to a server descriptor using\nthe ServerMap (with collisions handled by the\
    \ overflow pointer.).  The\nserver descriptor is the root of a queue of CSR's\
    \ for handling requests\nplus flags that modify the handling of the Request. \
    \ Flags include:\nRFC 1045                       VMTP                        February\
    \ 1988 \n                 +-------+---+-------------------------+\n  ServerMap\
    \      |       | x |                         |\n                 +-------+-|-+-------------------------+\n\
    \                           |   +--------------+\n                           |\
    \   | OverflowLink |\n                           |   +--------------+\n      \
    \                     +-->|   Server     |\n                               +--------------+\n\
    \                               | Flags | Lock |\n                           \
    \    +--------------+\n                               | Head Pointer |\n     \
    \                          +--------------+\n                               |\
    \ Tail Pointer |\n                               +--------------+\n          \
    \     Figure VII-2:   Mapping Server Identifiers\nTHREAD_QUEUE    Request is to\
    \ be invoked directly as a remote procedure\n                invocation, rather\
    \ than by a server process in the\n                message model.\nAUTHENTICATION_REQUIRED\n\
    \                Sent a Probe request to determine principal associated\n    \
    \            with the Client, if not known.\nSECURITY_REQUIRED\n             \
    \   Request must be encrypted or else reject.\nREQUESTS_QUEUED Queue contains\
    \ waiting requests, rather than free CSR's.\n                Queue this request\
    \ as well.\nSERVER_WAITING  The server is waiting and available to handle incoming\n\
    \                Request immediately, as required by CMD.\nAlternatively, the\
    \ Server identifiers can be mapped to a CSR using the\nMapToClient mechanism with\
    \ a pointer in the CSR refering to the server\ndescriptor, if any.  This scheme\
    \ is attractive if there are client CSR's\nassociated with a service to allow\
    \ it to communicate as a client using\nVMTP with other services.\nFinally, a similar\
    \ structure is used to expand entity group identifiers\nto the local membership,\
    \ as shown in Figure VII-3.  A group identifier\nis hashed to an index in the\
    \ GroupMap.  The list of group descriptors\nrooted at that index in the GroupMap\
    \ contains a group descriptor for\neach local member of the group.  The flags\
    \ are the group permissions\ndefined in Appendix III.\nRFC 1045              \
    \         VMTP                        February 1988 \n                 +-------+---+----------------------------------+\n\
    \  GroupMap       |       | x |                                  |\n         \
    \        +-------+-|-+----------------------------------+\n                  \
    \         |   +--------------+\n                           |   | OverflowLink\
    \ |\n                           |   +--------------+\n                       \
    \    +-->|EntityGroupId |\n                               +--------------+\n \
    \                              | Flags        |\n                            \
    \   +--------------+\n                               | Member Entity|\n      \
    \                         +--------------+\n               Figure VII-3:   Mapping\
    \ Group Identifiers\nNote that the same pool of descriptors could be used for\
    \ the server and\ngroup descriptors given that they are similar in size.\nVII.2.\
    \ Client Data Structures\nEach client entity is represented as a client state\
    \ record.  The CSR\ncontains a VMTP header as well as other bookkeeping fields,\
    \ including\ntimeout count, retransmission count, as described in Section 4.1.\
    \  In\naddition, there is a timeout queue, transmission queue and reception\n\
    queue.  Finally, there is a ServerHost cache that maps from server\nentity-id\
    \ records to host address, estimated round trip time,\ninterpacket gap, MTU size\
    \ and (optimally) estimated processing time for\nthis server entity.\nVII.3. Server\
    \ Data Structures\nThe server maintains a heap of client state records (CSR),\
    \ one for each\n(Client, Transaction).  (If streams are not supported, there is,\
    \ at\nworst, a CSR per Client with which the server has communicated with\nrecently.)\
    \  The CSR contains a VMTP header as well as various\nbookkeeping fields including\
    \ timeout count, retransmission count.  The\nserver maintains a hash table mapping\
    \ of Client to CSR as well as the\ntransmission, timeout and reception queues.\
    \  In a VMTP module\nimplementing both the client and server functions, the same\
    \ timeout\nqueue and transmission queue are used for both.\nRFC 1045         \
    \              VMTP                        February 1988 \nVII.4. Packet Group\
    \ transmission\nThe procedure SendPacketGroup( csr ) transmits the packet group\n\
    specified by the record CSR.  It performs:\n   1. Fragmentation of the segment\
    \ data, if any, into packets.\n      (Note, segment data flagged by SDA bit.)\n\
    \   2. Modifies the VMTP header for each packet as required e.g.\n      changing\
    \ the delivery mask as appropriate.\n   3. Computes the VMTP checksum.\n   4.\
    \ Encrypts the appropriate portion of the packet, if required.\n   5. Prepends\
    \ and appends network-level header and trailer using\n      network address from\
    \ ServerHost cache, or from the responding\n      CSR.\n   6. Transmits the packet\
    \ with the interpacket gap specified in\n      the cache.  This may involve round-robin\
    \ scheduling between\n      hosts as well as delaying transmissions slightly.\n\
    \   7. Invokes the finish-up procedure specified by the CSR record,\n      completing\
    \ the processing.  Generally, this finish-up\n      procedure adds the record\
    \ to the timeout queue with the\n      appropriate timeout queue.\nThe CSR includes\
    \ a 32-bit transmission mask that indicates the portions\nof the segment to transmit.\
    \  The SendPacketGroup procedure is assumed to\nhandle queuing at the network\
    \ transmission queue, queuing in priority\norder according to the priority field\
    \ specified in the CSR record.\n(This priority may be reflected in network transmission\
    \ behavior for\nnetworks that support priority.)\nThe SendPacketGroup procedure\
    \ only looks at the following fields of a\nCSR\n   - Transmission mask\n   - FuncCode\n\
    \   - SDA\n   - Client\n   - Server\nRFC 1045                       VMTP     \
    \                   February 1988 \n   - CoResidentEntity\n   - Key\nIt modifies\
    \ the following fields\n   - Length\n   - Delivery\n   - Checksum\nIn the case\
    \ of encrypted transmission, it encrypts the entire packet,\nnot including the\
    \ Client field and the following 32-bits.\nIf the packet group is a Response,\
    \ (i.e. lower-order bit of function\ncode is 1) the destination network address\
    \ is determined from the\nClient, otherwise the Server.  The HostAddr field is\
    \ set either from the\nServerHost cache (if a Request) or from the original Request\
    \ if a\nResponse, before SendPacketGroup is called.\nThe CSR includes a timeout\
    \ and TTL fields indicating the maximum time to\ncomplete the processing and the\
    \ time-to-live for the packets to be\ntransmitted.\nSendPacketGroup is viewed\
    \ as the right functionality to implement for\ntransmission in an \"intelligent\"\
    \ network interface.\nFinally, it appears preferable to be able to assume that\
    \ all portions of\nthe segment remain memory-resident (no page faults) during\
    \ transmission.\nIn a demand-paged systems, some form of locking is required to\
    \ keep the\nsegment data in memory.\nVII.5. VMTP Management Module\nThe implementation\
    \ should implement the management operations as a\nseparate module that is invoked\
    \ from within the VMTP module.  When a\nRequest is received, either from the local\
    \ user level or the network,\nfor the VMTP management module, the management module\
    \ is invoked as a\nremote or local procedure call to handle this request and return\
    \ a\nresponse (if not a datagram request).  By registering as a local server,\n\
    the management module should minimize the special-case code required for\nits\
    \ invocation.  The management module is basically a case statement\nthat selects\
    \ the operation based on the RequestCode and then invokes the\nspecified management\
    \ operation.  The procedure implementing the\nmanagement operation, especially\
    \ operations like NotifyVmtpClient and\nRFC 1045                       VMTP  \
    \                      February 1988 \nNotifyVmtpServer, are logically part of\
    \ the VMTP module because they\nrequire full access to the basic data structures\
    \ of the VMTP\nimplementation.\nThe management module should be implemented so\
    \ that it can respond\nquickly to all requests, particularly since the timing\
    \ of management\ninteractions is used to estimate round trip time.  To date, all\n\
    implementations of the management module have been done at the kernel\nlevel,\
    \ along with VMTP proper.\nVII.6. Timeout Handling\nThe timeout queue is a queue\
    \ of CSR records, ordered by timeout count,\nas specified in the CSR record. \
    \ On entry into the timeout queue, the\nCSR record has the timeout field set to\
    \ the time (preferable in\nmilliseconds or similar unit) to remain in the queue\
    \ plus the finishup\nfield set to the procedure to execute on removal on timeout\
    \ from the\nqueue.  The timeout field for a CSR in the queue is the time relative\
    \ to\nthe record preceding it in the queue (if any) at which it is to be\nremoved.\
    \  Some system-specific mechanism decrements the time for the\nrecord at the front\
    \ of the queue, invoking the finishup procedure when\nthe count goes to zero.\n\
    Using this scheme, a special CSR is used to timeout and scan CSR's for\nnon-recently\
    \ pinged CSR's.  That is, this CSR times out and invokes a\nfinishup procedure\
    \ that scans for non-recently pinged CSR that are\n\"AwaitingResponse\" and signals\
    \ the request processing entity and deletes\nthe CSR.  It then returns to the\
    \ timeout queue.\nThe timeout mechanism tends to be specific to an operating system.\
    \  The\nscheme described may have to be adapted to the operating system in which\n\
    VMTP is to be implemented.\nThis mechanism handles client request timeout and\
    \ client response\ntimeout.  It is not intended to handle interpacket gaps given\
    \ that these\ntimes are expected to be under 1 millisecond in general and possibly\n\
    only a few microseconds.\nVII.7. Timeout Values\nRoundtrip timeout values are\
    \ estimated by matching Responses or\nNotifyVmtpClient Requests to Request transmission,\
    \ relying on the\nretransmitCount to identify the particular transmission of the\
    \ Request\nthat generated the response.  A similar technique can be used with\n\
    Responses and NotifyVmtpServer Requests.  The retransmitCount is\nRFC 1045   \
    \                    VMTP                        February 1988 \nincremented each\
    \ time the Response is sent, whether the retransmission\nwas caused by timeout\
    \ or retransmission of the Request.\nThe ProbeEntity request is recommended as\
    \ a basic way of getting\nup-to-date information about a Client as well as predictable\
    \ host\nmachine turnaround in processing a request.  (VMTP assumes and requires\n\
    an efficient, bounded response time implementation of the ProbeEntity\noperation.)\n\
    Using this mechanism for measuring RTT, it is recommended that the\nvarious estimation\
    \ and smoothing techniques developed for TCP RTT\nestimation be adapted and used.\n\
    VII.8. Packet Reception\nLogically a network packet containing a VMTP packet is\
    \ 5 portions:\n   - network header, possibly including lower-level headers\n \
    \  - VMTP header\n   - data segment\n   - VMTP checksum\n   - network trailer,\
    \ etc.\nIt may be advantageous to receive a packet fragmented into these\nportions,\
    \ if supported by the network module.  In this case, ideally the\nVMTP header\
    \ may be received directly into a CSR, the data segment into a\npage that can\
    \ be mapped, rather than copied, to its final destination,\nwith VMTP checksum\
    \ and network header in a separate area (used to\nextract the network address\
    \ corresponding to the sender).\nPacket reception is described in detail by the\
    \ pseudo-code in Section\n4.7.\nWith a response, normally the CSR has an associated\
    \ segment area\nimmediately available so delivery of segment data is immediate.\n\
    Similarly, server entities should be \"armed\" with CSR's with segment\nareas\
    \ that provide for immediate delivery of requests.  It is reasonable\nto discard\
    \ segment data that cannot be immediately delivered in this\nway, providing that\
    \ clients and servers are able to preallocate CSR's\nwith segment areas for requests\
    \ and responses.  In particular, a client\nshould be able to provide some number\
    \ of additional CSR's for receiving\nmultiple responses to a multicast request.\n\
    RFC 1045                       VMTP                        February 1988 \nThe\
    \ CSR data structure is intended to be the interface data structure\nfor an intelligent\
    \ network interface.  For reception, the interface is\n\"armed\" with CSR's that\
    \ may point to segment areas in main memory, into\nwhich it can deliver a packet\
    \ group.  Ideally, the interface handles all\nthe processing of all packets, interacting\
    \ with the host after receiving\na complete Request or Response packet group.\
    \  An implementation should\nuse an interface based on SendPacketGroup(CSR) and\n\
    ReceivePacketGroup(CSR) to facilitate the introduction of an intelligent\nnetwork\
    \ interface.\nReceivePacketGroup(csr) provides the interface with a CSR descriptor\
    \ and\nzero or more bytes of main memory to receive segment data.  The CSR\ndescribes\
    \ whether it is to receive responses (and if so, for which\nclient) or requests\
    \ (and if so for which server).\nThe procedure ReclaimCSR(CSR) reclaims the specified\
    \ record from the\ninterface before it has been returned after receiving the specified\n\
    packet group.\nA finishup procedure is set in the CSR to be invoked when the CSR\
    \ is\nreturned to the host by the normal processing sequence in the interface.\n\
    Similarly, the timeout parameter is set to indicate the maximum time the\nhost\
    \ is providing for the routine to perform the specified function.\nThe CSR and\
    \ associated segment memory is returned to the host after the\ntimeout period\
    \ with an indication of progress after the timeout period.\nIt is not returned\
    \ earlier.\nVII.9. Streaming\nThe implementation of streaming is optional in both\
    \ VMTP clients and\nservers.  Ideally, all performance-critical servers should\
    \ implement\nstreaming.  In addition, clients that have high context switch overhead,\n\
    network access overhead or expect to be communicating over long delay\nlinks should\
    \ also implement streaming.\nA client stream is implemented by allocating a CSR\
    \ for each outstanding\nmessage transaction.  A stream of transactions is handled\
    \ similarly to\nmultiple outstanding transactions from separate clients except\
    \ for the\ninteraction between consecutive numbered transactions in a stream.\n\
    For the server VMTP module, streamed message transactions to a server\nare queued\
    \ (if accepted) subordinate to the first unprocessed CSR\ncorresponding to this\
    \ Client.  Thus, streamed transactions from a given\nClient are always performed\
    \ in the order specified by the transaction\nidentifiers.\nRFC 1045          \
    \             VMTP                        February 1988 \nIf a server does not\
    \ implement streaming, it must refuse streamed\nmessage transactions using the\
    \ NotifyVmtpClient operation.  Also, all\nclient VMTP's that support streaming\
    \ must support the streamed interface\nto a server that does not support streaming.\
    \  That is, it must perform\nthe message transactions one at a time.  Consequently,\
    \ a program that\nuses the streaming interface to a non-streaming server experiences\n\
    degraded performance, but not failure.\nVII.10. Implementation Experience\nThe\
    \ implementation experience to date includes a partial implementation\n(minus\
    \ the streaming and full security) in the V kernel plus a similar\npreliminary\
    \ implementation in the 4.3 BSD Unix kernel.  In the V kernel\nimplementation,\
    \ the CSR's are part of the (lightweight) process\ndescriptor.\nThe V kernel implementation\
    \ is able to perform a VMTP message\ntransaction with no data segment between\
    \ two Sun-3/75's connected by 10\nMb Ethernet in 2.25 milliseconds.  It is also\
    \ able to transfer data at\n4.7 megabits per second using 16 kilobyte Requests\
    \ (but null checksums.)\nThe UNIX kernel implementation running on Microvax II's\
    \ achieves a basic\nmessage transaction time of 9 milliseconds and data rate of\
    \ 1.9 megabits\nper second using 16 kilobyte Responses.  This implementation is\
    \ using\nthe standard VMTP checksum.\nWe hope to report more extensive implementation\
    \ experience in future\nrevisions of this document.\nRFC 1045                \
    \       VMTP                        February 1988 \nVIII. UNIX 4.3 BSD Kernel\
    \ Interface for VMTP\nUNIX 4.3 BSD includes a socket-based design for program\
    \ interfaces to a\nvariety of protocol families and types of protocols (streams,\n\
    datagrams).  In this appendix, we sketch an extension to this design to\nsupport\
    \ a transaction-style protocol.  (Some familiarity with UNIX 4.2/3\nIPC is assumed.)\
    \  Several extensions are required to the system\ninterface, rather than just\
    \ adding a protocol, because no provision was\nmade for supporting transaction\
    \ protocols in the original design.  These\nextensions include a new \"transaction\"\
    \ type of socket plus new system\ncalls invoke, getreply, probeentity, recreq,\
    \ sendreply and forward.\nA socket of type transaction bound to the VMTP protocol\
    \ type\nIPPROTO_VMTP is created by the call \n    s = socket(AF_INET, SOCK_TRANSACT,\
    \ VMTP);\nThis socket is bound to an entity identifier by \n    bind(s, &entityid,\
    \ sizeof(entityid));\nThe first address/port bound to a socket is considered its\
    \ primary name\nand is the one used on packet transmission.  A message transaction\
    \ is\ninvoked between the socket named by s and the Server specified by mcb by\n\
    \    invoke(s, mcb, segptr, seglen, timeout );\nThe mcb is a message control block\
    \ whose format was described in Section\n2.4.  The message control block specifies\
    \ the request to send plus the\ndestination Server.  The response message control\
    \ block returned by the\nserver is stored in mcb when invoke returns.  The invoking\
    \ process is\nblocked until a response is received or the message transaction\
    \ times\nout unless the request is a datagram request.  (Non-blocking versions\n\
    with signals on completion could also be provided, especially with a\nstreaming\
    \ implementation.)\nFor multicast message transactions (sent to an entity group),\
    \ the next\nresponse to the current message transaction (if it arrives in less\
    \ than\ntimeout milliseconds) is returned by \n    getreply( s, mcb, segptr, maxseglen,\
    \ timeout );\nThe invoke operation sent to an entity group completes as soon as\
    \ the\nfirst response is received.  A request is retransmitted until the first\n\
    reply is received (assuming the request is not a datagram).  Thus, the\nsystem\
    \ does not retransmit while getreply is timing out even if no\nreplies are available.\n\
    RFC 1045                       VMTP                        February 1988 \nThe\
    \ state of an entity associated with entityId is probed using \n    probeentity(\
    \ entityId, state );\nA UNIX process acting as a VMTP server accepts a Request\
    \ by the\noperation \n    recvreq(s, mcb, segptr, maxseglen );\nThe request message\
    \ for the next queued transaction request is returned\nin mcb, plus the segment\
    \ data of maximum length maxseglen, starting at\nsegptr in the address space.\
    \  On return, the message control block\ncontains the values as set in invoke\
    \ except: (1) the Client field\nindicates the Client that sent the received Request\
    \ message.  (2) the\nCode field indicates the type of request.  (3) the MsgDelivery\
    \ field\nindicates the portions of the segment actually received within the\n\
    specified segment size, if MDM is 1 in the Code field.  A segment block\nis marked\
    \ as missing (i.e. the corresponding bit in the MsgDelivery\nfield is 0) unless\
    \ it is received in its entirety or it is all of the\ndata in last segment contained\
    \ in the segment.\nTo complete a transaction, the reply specified by mcb is sent\
    \ to the\nclient specified by the MCB using \n    sendreply(s, mcb, segptr );\n\
    The Client field of the MCB indicates the client to respond to.\nFinally, a message\
    \ transaction specified by mcb is forwarded to\nnewserver as though it were sent\
    \ there by its original invoker using \n    forward(s, mcb, segptr, timeout );\n\
    RFC 1045                       VMTP                        February 1988 \nIndex\n\
    \          Acknowledgment   14\n          APG   16, 31, 39\n          Authentication\
    \ domain   20\n          Big-endian   9\n          Checksum   14, 43\n       \
    \   Checksum, not set   44\n          Client   7, 10, 38\n          Client timer\
    \   16\n          CMD   42, 110\n          CMG   32, 40\n          Co-resident\
    \ entity   25\n          Code   42\n          CoResidentEntity   42, 43\n    \
    \      CRE   21, 42\n          DGM   42\n          Digital signature, VMTP management\
    \   95, 101\n          Diskless workstations   2\n          Domain   9, 38\n \
    \         Domain 1   102\n          Domain 3   104\n          Entity   7\n   \
    \       Entity domain   9\n          Entity group   8\n          Entity identifier\
    \   37\n          Entity identifier allocation   105\n          Entity identifier,\
    \ all-zero   38\n          EPG   20, 39\n          Features   6\n          ForwardCount\
    \   24\n          Forwarding   24\n          FunctionCode   41\n          Group\
    \   8\n          Group message transaction   10\n          Group timeouts   16\n\
    \          GRP   37\n          HandleNoCSR   62\n          HandleRequestNoCSR\
    \   79\n          HCO   14, 23, 39\nRFC 1045                       VMTP      \
    \                  February 1988 \n          Host independence   8\n         \
    \ Idempotent   15\n          Interpacket gap   18, 40\n          IP   108\n  \
    \        Key   91\n          LEE   32, 37\n          Little-endian   9\n     \
    \     MCB   118\n          MDG   22, 40\n          MDM   30, 42\n          Message\
    \ control block   118\n          Message size   6\n          Message transaction\
    \   7, 10\n          MPG   39\n          MsgDelivery   43\n          MSGTRANS_OVERFLOW\
    \   27\n          Multicast   4, 21, 120\n          Multicast, reliable   21\n\
    \          Naming   6\n          Negative acknowledgment   31\n          NER \
    \  25, 31, 39\n          NRT   26, 30, 39\n          NSR   25, 27, 31, 39\n  \
    \        Object-oriented   2\n          Overrun   18\n          Packet group \
    \  7, 29, 39\n          Packet group run   31\n          PacketDelivery   29,\
    \ 31, 41\n          PGcount   26, 41\n          PIC   42\n          Principal\
    \   11\n          Priority   41\n          Process   11\n          ProcessId \
    \  89\n          Protocol number,IP   108\n          RAE   37\n          Rate\
    \ control   18\n          Real-time   2, 4\n          Realtime   22\nRFC 1045\
    \                       VMTP                        February 1988 \n         \
    \ Reliability   12\n          Request message   10\n          RequestAckRetries\
    \   30\n          RequestRetries   15\n          Response message   10\n     \
    \     ResponseAckRetries   31\n          ResponseRetries   15\n          Restricted\
    \ group   8\n          Retransmission   15\n          RetransmitCount   17\n \
    \         Roundtrip time   17\n          RPC   2\n          Run   31, 39\n   \
    \       Run, message transactions   25\n          SDA   42\n          Security\
    \   4, 19\n          Segment block   41\n          Segment data   43\n       \
    \   SegmentSize   42, 43\n          Selective retransmission   18\n          Server\
    \   7, 10, 41\n          Server group   8\n          Sockets, VMTP   118\n   \
    \       STI   26, 40\n          Streaming   25, 55\n          Strictly stable\
    \   8\n          Subgroups   21\n          T-stable   8\n          TC1(Server)\
    \   16\n          TC2(Server)   16\n          TC3(Server)   16\n          TC4\
    \   16\n          TCP   2\n          Timeouts   15\n          Transaction   10,\
    \ 41\n          Transaction identification   10\n          TS1(Client)   17\n\
    \          TS2(Client)   17\n          TS3(Client)   17\n          TS4(Client)\
    \   17\n          TS5(Client)   17\n          Type flags   8\n          UNIX interface\
    \   118\n          Unrestricted group   8, 38\nRFC 1045                      \
    \ VMTP                        February 1988 \n          NotifyVmtpClient   7,\
    \ 26, 27, 30\n          NotifyVmtpServer   7, 14, 30\n          User Data   43\n\
    \          Version   38\n          VMTP Management digital signature   95, 101\n"
