- contents:
  - ' HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   Web Distributed Authoring and Versioning (WebDAV) consists of a
    set\n   of methods, headers, and content-types ancillary to HTTP/1.1 for the\n
    \  management of resource properties, creation and management of\n   resource
    collections, URL namespace manipulation, and resource\n   locking (collision avoidance).\n
    \  RFC 2518 was published in February 1999, and this specification\n   obsoletes
    RFC 2518 with minor revisions mostly due to\n   interoperability experience.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................7\n
    \  2. Notational Conventions ..........................................8\n   3.
    Terminology .....................................................8\n   4. Data
    Model for Resource Properties .............................10\n      4.1. The
    Resource Property Model ...............................10\n      4.2. Properties
    and HTTP Headers ...............................10\n      4.3. Property Values
    ...........................................10\n           4.3.1. Example - Property
    with Mixed Content ..............12\n      4.4. Property Names ............................................14\n
    \     4.5. Source Resources and Output Resources .....................14\n   5.
    Collections of Web Resources ...................................14\n      5.1.
    HTTP URL Namespace Model ..................................15\n      5.2. Collection
    Resources ......................................15\n   6. Locking ........................................................17\n
    \     6.1. Lock Model ................................................18\n      6.2.
    Exclusive vs. Shared Locks ................................19\n      6.3. Required
    Support ..........................................20\n      6.4. Lock Creator
    and Privileges ...............................20\n      6.5. Lock Tokens ...............................................21\n
    \     6.6. Lock Timeout ..............................................21\n      6.7.
    Lock Capability Discovery .................................22\n      6.8. Active
    Lock Discovery .....................................22\n   7. Write Lock .....................................................23\n
    \     7.1. Write Locks and Properties ................................24\n      7.2.
    Avoiding Lost Updates .....................................24\n      7.3. Write
    Locks and Unmapped URLs .............................25\n      7.4. Write Locks
    and Collections ...............................26\n      7.5. Write Locks and
    the If Request Header .....................28\n           7.5.1. Example - Write
    Lock and COPY ......................28\n           7.5.2. Example - Deleting a
    Member of a Locked\n                  Collection .........................................29\n
    \     7.6. Write Locks and COPY/MOVE .................................30\n      7.7.
    Refreshing Write Locks ....................................30\n   8. General Request
    and Response Handling ..........................31\n      8.1. Precedence in Error
    Handling ..............................31\n      8.2. Use of XML ................................................31\n
    \     8.3. URL Handling ..............................................32\n           8.3.1.
    Example - Correct URL Handling .....................32\n      8.4. Required Bodies
    in Requests ...............................33\n      8.5. HTTP Headers for Use
    in WebDAV ............................33\n      8.6. ETag ......................................................33\n
    \     8.7. Including Error Response Bodies ...........................34\n      8.8.
    Impact of Namespace Operations on Cache Validators ........34\n   9. HTTP Methods
    for Distributed Authoring .........................35\n      9.1. PROPFIND Method
    ...........................................35\n           9.1.1. PROPFIND Status
    Codes ..............................37\n           9.1.2. Status Codes for Use
    in 'propstat' Element .........37\n           9.1.3. Example - Retrieving Named
    Properties ..............38\n           9.1.4. Example - Using 'propname' to Retrieve
    All\n                  Property Names .....................................39\n
    \          9.1.5. Example - Using So-called 'allprop' ................41\n           9.1.6.
    Example - Using 'allprop' with 'include' ...........43\n      9.2. PROPPATCH Method
    ..........................................44\n           9.2.1. Status Codes for
    Use in 'propstat' Element .........44\n           9.2.2. Example - PROPPATCH ................................45\n
    \     9.3. MKCOL Method ..............................................46\n           9.3.1.
    MKCOL Status Codes .................................47\n           9.3.2. Example
    - MKCOL ....................................47\n      9.4. GET, HEAD for Collections
    .................................48\n      9.5. POST for Collections ......................................48\n
    \     9.6. DELETE Requirements .......................................48\n           9.6.1.
    DELETE for Collections .............................49\n           9.6.2. Example
    - DELETE ...................................49\n      9.7. PUT Requirements ..........................................50\n
    \          9.7.1. PUT for Non-Collection Resources ...................50\n           9.7.2.
    PUT for Collections ................................51\n      9.8. COPY Method
    ...............................................51\n           9.8.1. COPY for
    Non-collection Resources ..................51\n           9.8.2. COPY for Properties
    ................................52\n           9.8.3. COPY for Collections ...............................52\n
    \          9.8.4. COPY and Overwriting Destination Resources .........53\n           9.8.5.
    Status Codes .......................................54\n           9.8.6. Example
    - COPY with Overwrite ......................55\n           9.8.7. Example - COPY
    with No Overwrite ...................55\n           9.8.8. Example - COPY of a
    Collection .....................56\n      9.9. MOVE Method ...............................................56\n
    \          9.9.1. MOVE for Properties ................................57\n           9.9.2.
    MOVE for Collections ...............................57\n           9.9.3. MOVE
    and the Overwrite Header ......................58\n           9.9.4. Status Codes
    .......................................59\n           9.9.5. Example - MOVE of
    a Non-Collection .................60\n           9.9.6. Example - MOVE of a Collection
    .....................60\n      9.10. LOCK Method ..............................................61\n
    \          9.10.1. Creating a Lock on an Existing Resource ...........61\n           9.10.2.
    Refreshing Locks ..................................62\n           9.10.3. Depth
    and Locking .................................62\n           9.10.4. Locking Unmapped
    URLs .............................63\n           9.10.5. Lock Compatibility Table
    ..........................63\n           9.10.6. LOCK Responses ....................................63\n
    \          9.10.7. Example - Simple Lock Request .....................64\n           9.10.8.
    Example - Refreshing a Write Lock .................65\n           9.10.9. Example
    - Multi-Resource Lock Request .............66\n      9.11. UNLOCK Method ............................................68\n
    \          9.11.1. Status Codes ......................................68\n           9.11.2.
    Example - UNLOCK ..................................69\n   10. HTTP Headers for
    Distributed Authoring ........................69\n      10.1. DAV Header ...............................................69\n
    \     10.2. Depth Header .............................................70\n      10.3.
    Destination Header .......................................71\n      10.4. If Header
    ................................................72\n           10.4.1. Purpose
    ...........................................72\n           10.4.2. Syntax ............................................72\n
    \          10.4.3. List Evaluation ...................................73\n           10.4.4.
    Matching State Tokens and ETags ...................74\n           10.4.5. If Header
    and Non-DAV-Aware Proxies ...............74\n           10.4.6. Example - No-tag
    Production .......................75\n           10.4.7. Example - Using \"Not\"
    with No-tag Production ......75\n           10.4.8. Example - Causing a Condition
    to Always\n                   Evaluate to True ..................................75\n
    \          10.4.9. Example - Tagged List If Header in COPY ...........76\n           10.4.10.
    Example - Matching Lock Tokens with\n                    Collection Locks .................................76\n
    \          10.4.11. Example - Matching ETags on Unmapped URLs ........76\n      10.5.
    Lock-Token Header ........................................77\n      10.6. Overwrite
    Header .........................................77\n      10.7. Timeout Request
    Header ...................................78\n   11. Status Code Extensions to
    HTTP/1.1 ............................78\n      11.1. 207 Multi-Status .........................................78\n
    \     11.2. 422 Unprocessable Entity .................................78\n      11.3.
    423 Locked ...............................................78\n      11.4. 424
    Failed Dependency ....................................79\n      11.5. 507 Insufficient
    Storage .................................79\n   12. Use of HTTP Status Codes ......................................79\n
    \     12.1. 412 Precondition Failed ..................................79\n      12.2.
    414 Request-URI Too Long .................................79\n   13. Multi-Status
    Response .........................................80\n      13.1. Response Headers
    .........................................80\n      13.2. Handling Redirected Child
    Resources ......................81\n      13.3. Internal Status Codes ....................................81\n
    \  14. XML Element Definitions .......................................81\n      14.1.
    activelock XML Element ...................................81\n      14.2. allprop
    XML Element ......................................82\n      14.3. collection XML
    Element ...................................82\n      14.4. depth XML Element ........................................82\n
    \     14.5. error XML Element ........................................82\n      14.6.
    exclusive XML Element ....................................83\n      14.7. href
    XML Element .........................................83\n      14.8. include XML
    Element ......................................83\n      14.9. location XML Element
    .....................................83\n      14.10. lockentry XML Element ...................................84\n
    \     14.11. lockinfo XML Element ....................................84\n      14.12.
    lockroot XML Element ....................................84\n      14.13. lockscope
    XML Element ...................................84\n      14.14. locktoken XML
    Element ...................................85\n      14.15. locktype XML Element
    ....................................85\n      14.16. multistatus XML Element .................................85\n
    \     14.17. owner XML Element .......................................85\n      14.18.
    prop XML Element ........................................86\n      14.19. propertyupdate
    XML Element ..............................86\n      14.20. propfind XML Element
    ....................................86\n      14.21. propname XML Element ....................................87\n
    \     14.22. propstat XML Element ....................................87\n      14.23.
    remove XML Element ......................................87\n      14.24. response
    XML Element ....................................88\n      14.25. responsedescription
    XML Element .........................88\n      14.26. set XML Element .........................................88\n
    \     14.27. shared XML Element ......................................89\n      14.28.
    status XML Element ......................................89\n      14.29. timeout
    XML Element .....................................89\n      14.30. write XML Element
    .......................................89\n   15. DAV Properties ................................................90\n
    \  16. Precondition/Postcondition XML Elements .......................98\n   17.
    XML Extensibility in DAV .....................................101\n   18. DAV
    Compliance Classes .......................................103\n      18.1. Class
    1 .................................................103\n      18.2. Class 2 .................................................103\n
    \     18.3. Class 3 .................................................103\n   19.
    Internationalization Considerations ..........................104\n   20. Security
    Considerations ......................................105\n      20.1. Authentication
    of Clients ...............................105\n      20.2. Denial of Service .......................................106\n
    \     20.3. Security through Obscurity ..............................106\n      20.4.
    Privacy Issues Connected to Locks .......................106\n      20.5. Privacy
    Issues Connected to Properties ..................107\n      20.6. Implications
    of XML Entities ............................107\n      20.7. Risks Connected with
    Lock Tokens ........................108\n      20.8. Hosting Malicious Content
    ...............................108\n   21. IANA Considerations ..........................................109\n
    \     21.1. New URI Schemes .........................................109\n      21.2.
    XML Namespaces ..........................................109\n      21.3. Message
    Header Fields ...................................109\n           21.3.1. DAV ..............................................109\n
    \          21.3.2. Depth ............................................110\n           21.3.3.
    Destination ......................................110\n           21.3.4. If ...............................................110\n
    \          21.3.5. Lock-Token .......................................110\n           21.3.6.
    Overwrite ........................................111\n           21.3.7. Timeout
    ..........................................111\n      21.4. HTTP Status Codes .......................................111\n
    \  22. Acknowledgements .............................................112\n   23.
    Contributors to This Specification ...........................113\n   24. Authors
    of RFC 2518 ..........................................113\n   25. References ...................................................114\n
    \     25.1. Normative References.....................................114\n      25.2.
    Informative References ..................................115\n   Appendix A.  Notes
    on Processing XML Elements ....................117\n      A.1. Notes on Empty
    XML Elements ..............................117\n      A.2. Notes on Illegal XML
    Processing ..........................117\n      A.3. Example - XML Syntax Error
    ...............................117\n      A.4. Example - Unexpected XML Element
    .........................118\n   Appendix B. Notes on HTTP Client Compatibility
    ...................119\n   Appendix C. The 'opaquelocktoken' Scheme and URIs ................120\n
    \  Appendix D. Lock-null Resources ..................................120\n      D.1.
    Guidance for Clients Using LOCK to Create Resources ......121\n   Appendix E.
    Guidance for Clients Desiring to Authenticate ........121\n   Appendix F. Summary
    of Changes from RFC 2518 .....................123\n      F.1. Changes for Both
    Client and Server Implementations .......123\n      F.2. Changes for Server Implementations
    .......................125\n      F.3. Other Changes ............................................126\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes an extension to the HTTP/1.1 protocol
    that\n   allows clients to perform remote Web content authoring operations.\n
    \  This extension provides a coherent set of methods, headers, request\n   entity
    body formats, and response entity body formats that provide\n   operations for:\n
    \  Properties: The ability to create, remove, and query information\n   about
    Web pages, such as their authors, creation dates, etc.\n   Collections: The ability
    to create sets of documents and to retrieve\n   a hierarchical membership listing
    (like a directory listing in a file\n   system).\n   Locking: The ability to keep
    more than one person from working on a\n   document at the same time.  This prevents
    the \"lost update problem\",\n   in which modifications are lost as first one
    author, then another,\n   writes changes without merging the other author's changes.\n
    \  Namespace Operations: The ability to instruct the server to copy and\n   move
    Web resources, operations that change the mapping from URLs to\n   resources.\n
    \  Requirements and rationale for these operations are described in a\n   companion
    document, \"Requirements for a Distributed Authoring and\n   Versioning Protocol
    for the World Wide Web\" [RFC2291].\n   This document does not specify the versioning
    operations suggested by\n   [RFC2291].  That work was done in a separate document,
    \"Versioning\n   Extensions to WebDAV\" [RFC3253].\n   The sections below provide
    a detailed introduction to various WebDAV\n   abstractions: resource properties
    (Section 4), collections of\n   resources (Section 5), locks (Section 6) in general,
    and write locks\n   (Section 7) specifically.\n   These abstractions are manipulated
    by the WebDAV-specific HTTP\n   methods (Section 9) and the extra HTTP headers
    (Section 10) used with\n   WebDAV methods.  General considerations for handling
    HTTP requests\n   and responses in WebDAV are found in Section 8.\n   While the
    status codes provided by HTTP/1.1 are sufficient to\n   describe most error conditions
    encountered by WebDAV methods, there\n   are some errors that do not fall neatly
    into the existing categories.\n   This specification defines extra status codes
    developed for WebDAV\n   methods (Section 11) and describes existing HTTP status
    codes\n   (Section 12) as used in WebDAV.  Since some WebDAV methods may\n   operate
    over many resources, the Multi-Status response (Section 13)\n   has been introduced
    to return status information for multiple\n   resources.  Finally, this version
    of WebDAV introduces precondition\n   and postcondition (Section 16) XML elements
    in error response bodies.\n   WebDAV uses XML ([REC-XML]) for property names and
    some values, and\n   also uses XML to marshal complicated requests and responses.
    \ This\n   specification contains DTD and text definitions of all properties\n
    \  (Section 15) and all other XML elements (Section 14) used in\n   marshalling.
    \ WebDAV includes a few special rules on extending WebDAV\n   XML marshalling
    in backwards-compatible ways (Section 17).\n   Finishing off the specification
    are sections on what it means for a\n   resource to be compliant with this specification
    (Section 18), on\n   internationalization support (Section 19), and on security\n
    \  (Section 20).\n"
  title: 1.  Introduction
- contents:
  - "2.  Notational Conventions\n   Since this document describes a set of extensions
    to the HTTP/1.1\n   protocol, the augmented BNF used herein to describe protocol
    elements\n   is exactly the same as described in Section 2.1 of [RFC2616],\n   including
    the rules about implied linear whitespace.  Since this\n   augmented BNF uses
    the basic production rules provided in Section 2.2\n   of [RFC2616], these rules
    apply to this document as well.  Note this\n   is not the standard BNF syntax
    used in other RFCs.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n   Note
    that in natural language, a property like the \"creationdate\"\n   property in
    the \"DAV:\" XML namespace is sometimes referred to as\n   \"DAV:creationdate\"
    for brevity.\n"
  title: 2.  Notational Conventions
- contents:
  - "3.  Terminology\n   URI/URL - A Uniform Resource Identifier and Uniform Resource
    Locator,\n   respectively.  These terms (and the distinction between them) are\n
    \  defined in [RFC3986].\n   URI/URL Mapping - A relation between an absolute
    URI and a resource.\n   Since a resource can represent items that are not network\n
    \  retrievable, as well as those that are, it is possible for a resource\n   to
    have zero, one, or many URI mappings.  Mapping a resource to an\n   \"http\" scheme
    URI makes it possible to submit HTTP protocol requests\n   to the resource using
    the URI.\n   Path Segment - Informally, the characters found between slashes (\"/\")\n
    \  in a URI.  Formally, as defined in Section 3.3 of [RFC3986].\n   Collection
    - Informally, a resource that also acts as a container of\n   references to child
    resources.  Formally, a resource that contains a\n   set of mappings between path
    segments and resources and meets the\n   requirements defined in Section 5.\n
    \  Internal Member (of a Collection) - Informally, a child resource of a\n   collection.
    \ Formally, a resource referenced by a path segment\n   mapping contained in the
    collection.\n   Internal Member URL (of a Collection) - A URL of an internal member,\n
    \  consisting of the URL of the collection (including trailing slash)\n   plus
    the path segment identifying the internal member.\n   Member (of a Collection)
    - Informally, a \"descendant\" of a\n   collection.  Formally, an internal member
    of the collection, or,\n   recursively, a member of an internal member.\n   Member
    URL (of a Collection) - A URL that is either an internal\n   member URL of the
    collection itself, or is an internal member URL of\n   a member of that collection.\n
    \  Property - A name/value pair that contains descriptive information\n   about
    a resource.\n   Live Property - A property whose semantics and syntax are enforced
    by\n   the server.  For example, the live property DAV:getcontentlength has\n
    \  its value, the length of the entity returned by a GET request,\n   automatically
    calculated by the server.\n   Dead Property - A property whose semantics and syntax
    are not\n   enforced by the server.  The server only records the value of a dead\n
    \  property; the client is responsible for maintaining the consistency\n   of
    the syntax and semantics of a dead property.\n   Principal - A distinct human
    or computational actor that initiates\n   access to network resources.\n   State
    Token - A URI that represents a state of a resource.  Lock\n   tokens are the
    only state tokens defined in this specification.\n"
  title: 3.  Terminology
- contents:
  - '4.  Data Model for Resource Properties

    '
  - contents:
    - "4.1.  The Resource Property Model\n   Properties are pieces of data that describe
      the state of a resource.\n   Properties are data about data.\n   Properties
      are used in distributed authoring environments to provide\n   for efficient
      discovery and management of resources.  For example, a\n   'subject' property
      might allow for the indexing of all resources by\n   their subject, and an 'author'
      property might allow for the discovery\n   of what authors have written which
      documents.\n   The DAV property model consists of name/value pairs.  The name
      of a\n   property identifies the property's syntax and semantics, and provides\n
      \  an address by which to refer to its syntax and semantics.\n   There are two
      categories of properties: \"live\" and \"dead\".  A live\n   property has its
      syntax and semantics enforced by the server.  Live\n   properties include cases
      where a) the value of a property is\n   protected and maintained by the server,
      and b) the value of the\n   property is maintained by the client, but the server
      performs syntax\n   checking on submitted values.  All instances of a given
      live property\n   MUST comply with the definition associated with that property
      name.\n   A dead property has its syntax and semantics enforced by the client;\n
      \  the server merely records the value of the property verbatim.\n"
    title: 4.1.  The Resource Property Model
  - contents:
    - "4.2.  Properties and HTTP Headers\n   Properties already exist, in a limited
      sense, in HTTP message\n   headers.  However, in distributed authoring environments,
      a\n   relatively large number of properties are needed to describe the\n   state
      of a resource, and setting/returning them all through HTTP\n   headers is inefficient.
      \ Thus, a mechanism is needed that allows a\n   principal to identify a set
      of properties in which the principal is\n   interested and to set or retrieve
      just those properties.\n"
    title: 4.2.  Properties and HTTP Headers
  - contents:
    - "4.3.  Property Values\n   The value of a property is always a (well-formed)
      XML fragment.\n   XML has been chosen because it is a flexible, self-describing,\n
      \  structured data format that supports rich schema definitions, and\n   because
      of its support for multiple character sets.  XML's self-\n   describing nature
      allows any property's value to be extended by\n   adding elements.  Clients
      will not break when they encounter\n   extensions because they will still have
      the data specified in the\n   original schema and MUST ignore elements they
      do not understand.\n   XML's support for multiple character sets allows any
      human-readable\n   property to be encoded and read in a character set familiar
      to the\n   user.  XML's support for multiple human languages, using the \"xml:\n
      \  lang\" attribute, handles cases where the same character set is\n   employed
      by multiple human languages.  Note that xml:lang scope is\n   recursive, so
      an xml:lang attribute on any element containing a\n   property name element
      applies to the property value unless it has\n   been overridden by a more locally
      scoped attribute.  Note that a\n   property only has one value, in one language
      (or language MAY be left\n   undefined); a property does not have multiple values
      in different\n   languages or a single value in multiple languages.\n   A property
      is always represented with an XML element consisting of\n   the property name,
      called the \"property name element\".  The simplest\n   example is an empty
      property, which is different from a property that\n   does not exist:\n      <R:title
      xmlns:R=\"http://www.example.com/ns/\"></R:title>\n   The value of the property
      appears inside the property name element.\n   The value may be any kind of well-formed
      XML content, including both\n   text-only and mixed content.  Servers MUST preserve
      the following XML\n   Information Items (using the terminology from [REC-XML-INFOSET])
      in\n   storage and transmission of dead properties:\n   For the property name
      Element Information Item itself:\n      [namespace name]\n      [local name]\n
      \     [attributes] named \"xml:lang\" or any such attribute in scope\n      [children]
      of type element or character\n   On all Element Information Items in the property
      value:\n      [namespace name]\n      [local name]\n      [attributes]\n      [children]
      of type element or character\n   On Attribute Information Items in the property
      value:\n      [namespace name]\n      [local name]\n      [normalized value]\n
      \  On Character Information Items in the property value:\n      [character code]\n
      \  Since prefixes are used in some XML vocabularies (XPath and XML\n   Schema,
      for example), servers SHOULD preserve, for any Information\n   Item in the value:\n
      \     [prefix]\n   XML Infoset attributes not listed above MAY be preserved
      by the\n   server, but clients MUST NOT rely on them being preserved.  The above\n
      \  rules would also apply by default to live properties, unless defined\n   otherwise.\n
      \  Servers MUST ignore the XML attribute xml:space if present and never\n   use
      it to change whitespace handling.  Whitespace in property values\n   is significant.\n"
    - contents:
      - "4.3.1.  Example - Property with Mixed Content\n   Consider a dead property
        'author' created by the client as follows:\n     <D:prop xml:lang=\"en\" xmlns:D=\"DAV:\">\n
        \      <x:author xmlns:x='http://example.com/ns'>\n         <x:name>Jane Doe</x:name>\n
        \        <!-- Jane's contact info -->\n         <x:uri type='email'\n                added='2005-11-26'>mailto:jane.doe@example.com</x:uri>\n
        \        <x:uri type='web'\n                added='2005-11-27'>http://www.example.com</x:uri>\n
        \        <x:notes xmlns:h='http://www.w3.org/1999/xhtml'>\n           Jane
        has been working way <h:em>too</h:em> long on the\n           long-awaited
        revision of <![CDATA[<RFC2518>]]>.\n         </x:notes>\n       </x:author>\n
        \    </D:prop>\n   When this property is requested, a server might return:\n
        \    <D:prop xmlns:D='DAV:'><author\n             xml:lang='en'\n             xmlns:x='http://example.com/ns'\n
        \            xmlns='http://example.com/ns'\n             xmlns:h='http://www.w3.org/1999/xhtml'>\n
        \        <x:name>Jane Doe</x:name>\n         <x:uri   added=\"2005-11-26\"
        type=\"email\"\n           >mailto:jane.doe@example.com</x:uri>\n         <x:uri
        \  added=\"2005-11-27\" type=\"web\"\n           >http://www.example.com</x:uri>\n
        \        <x:notes>\n           Jane has been working way <h:em>too</h:em>
        long on the\n           long-awaited revision of &lt;RFC2518&gt;.\n         </x:notes>\n
        \      </author>\n     </D:prop>\n   Note in this example:\n   o  The [prefix]
        for the property name itself was not preserved, being\n      non-significant,
        whereas all other [prefix] values have been\n      preserved,\n   o  attribute
        values have been rewritten with double quotes instead of\n      single quotes
        (quoting style is not significant), and attribute\n      order has not been
        preserved,\n   o  the xml:lang attribute has been returned on the property
        name\n      element itself (it was in scope when the property was set, but
        the\n      exact position in the response is not considered significant as\n
        \     long as it is in scope),\n   o  whitespace between tags has been preserved
        everywhere (whitespace\n      between attributes not so),\n   o  CDATA encapsulation
        was replaced with character escaping (the\n      reverse would also be legal),\n
        \  o  the comment item was stripped (as would have been a processing\n      instruction
        item).\n   Implementation note: there are cases such as editing scenarios
        where\n   clients may require that XML content is preserved character by\n
        \  character (such as attribute ordering or quoting style).  In this\n   case,
        clients should consider using a text-only property value by\n   escaping all
        characters that have a special meaning in XML parsing.\n"
      title: 4.3.1.  Example - Property with Mixed Content
    title: 4.3.  Property Values
  - contents:
    - "4.4.  Property Names\n   A property name is a universally unique identifier
      that is associated\n   with a schema that provides information about the syntax
      and\n   semantics of the property.\n   Because a property's name is universally
      unique, clients can depend\n   upon consistent behavior for a particular property
      across multiple\n   resources, on the same and across different servers, so
      long as that\n   property is \"live\" on the resources in question, and the\n
      \  implementation of the live property is faithful to its definition.\n   The
      XML namespace mechanism, which is based on URIs ([RFC3986]), is\n   used to
      name properties because it prevents namespace collisions and\n   provides for
      varying degrees of administrative control.\n   The property namespace is flat;
      that is, no hierarchy of properties\n   is explicitly recognized.  Thus, if
      a property A and a property A/B\n   exist on a resource, there is no recognition
      of any relationship\n   between the two properties.  It is expected that a separate\n
      \  specification will eventually be produced that will address issues\n   relating
      to hierarchical properties.\n   Finally, it is not possible to define the same
      property twice on a\n   single resource, as this would cause a collision in
      the resource's\n   property namespace.\n"
    title: 4.4.  Property Names
  - contents:
    - "4.5.  Source Resources and Output Resources\n   Some HTTP resources are dynamically
      generated by the server.  For\n   these resources, there presumably exists source
      code somewhere\n   governing how that resource is generated.  The relationship
      of source\n   files to output HTTP resources may be one to one, one to many,
      many\n   to one, or many to many.  There is no mechanism in HTTP to determine\n
      \  whether a resource is even dynamic, let alone where its source files\n   exist
      or how to author them.  Although this problem would usefully be\n   solved,
      interoperable WebDAV implementations have been widely\n   deployed without actually
      solving this problem, by dealing only with\n   static resources.  Thus, the
      source vs. output problem is not solved\n   in this specification and has been
      deferred to a separate document.\n"
    title: 4.5.  Source Resources and Output Resources
  title: 4.  Data Model for Resource Properties
- contents:
  - "5.  Collections of Web Resources\n   This section provides a description of a
    type of Web resource, the\n   collection, and discusses its interactions with
    the HTTP URL\n   namespace and with HTTP methods.  The purpose of a collection\n
    \  resource is to model collection-like objects (e.g., file system\n   directories)
    within a server's namespace.\n   All DAV-compliant resources MUST support the
    HTTP URL namespace model\n   specified herein.\n"
  - contents:
    - "5.1.  HTTP URL Namespace Model\n   The HTTP URL namespace is a hierarchical
      namespace where the\n   hierarchy is delimited with the \"/\" character.\n   An
      HTTP URL namespace is said to be consistent if it meets the\n   following conditions:
      for every URL in the HTTP hierarchy there\n   exists a collection that contains
      that URL as an internal member URL.\n   The root, or top-level collection of
      the namespace under\n   consideration, is exempt from the previous rule.  The
      top-level\n   collection of the namespace under consideration is not necessarily\n
      \  the collection identified by the absolute path '/' -- it may be\n   identified
      by one or more path segments (e.g., /servlets/webdav/...)\n   Neither HTTP/1.1
      nor WebDAV requires that the entire HTTP URL\n   namespace be consistent --
      a WebDAV-compatible resource may not have\n   a parent collection.  However,
      certain WebDAV methods are prohibited\n   from producing results that cause
      namespace inconsistencies.\n   As is implicit in [RFC2616] and [RFC3986], any
      resource, including\n   collection resources, MAY be identified by more than
      one URI.  For\n   example, a resource could be identified by multiple HTTP URLs.\n"
    title: 5.1.  HTTP URL Namespace Model
  - contents:
    - "5.2.  Collection Resources\n   Collection resources differ from other resources
      in that they also\n   act as containers.  Some HTTP methods apply only to a
      collection, but\n   some apply to some or all of the resources inside the container\n
      \  defined by the collection.  When the scope of a method is not clear,\n   the
      client can specify what depth to apply.  Depth can be either zero\n   levels
      (only the collection), one level (the collection and directly\n   contained
      resources), or infinite levels (the collection and all\n   contained resources
      recursively).\n   A collection's state consists of at least a set of mappings
      between\n   path segments and resources, and a set of properties on the\n   collection
      itself.  In this document, a resource B will be said to be\n   contained in
      the collection resource A if there is a path segment\n   mapping that maps to
      B and that is contained in A.  A collection MUST\n   contain at most one mapping
      for a given path segment, i.e., it is\n   illegal to have the same path segment
      mapped to more than one\n   resource.\n   Properties defined on collections
      behave exactly as do properties on\n   non-collection resources.  A collection
      MAY have additional state\n   such as entity bodies returned by GET.\n   For
      all WebDAV-compliant resources A and B, identified by URLs \"U\"\n   and \"V\",
      respectively, such that \"V\" is equal to \"U/SEGMENT\", A MUST\n   be a collection
      that contains a mapping from \"SEGMENT\" to B.  So, if\n   resource B with URL
      \"http://example.com/bar/blah\" is WebDAV compliant\n   and if resource A with
      URL \"http://example.com/bar/\" is WebDAV\n   compliant, then resource A must
      be a collection and must contain\n   exactly one mapping from \"blah\" to B.\n
      \  Although commonly a mapping consists of a single segment and a\n   resource,
      in general, a mapping consists of a set of segments and a\n   resource.  This
      allows a server to treat a set of segments as\n   equivalent (i.e., either all
      of the segments are mapped to the same\n   resource, or none of the segments
      are mapped to a resource).  For\n   example, a server that performs case-folding
      on segments will treat\n   the segments \"ab\", \"Ab\", \"aB\", and \"AB\" as
      equivalent.  A client can\n   then use any of these segments to identify the
      resource.  Note that a\n   PROPFIND result will select one of these equivalent
      segments to\n   identify the mapping, so there will be one PROPFIND response
      element\n   per mapping, not one per segment in the mapping.\n   Collection
      resources MAY have mappings to non-WebDAV-compliant\n   resources in the HTTP
      URL namespace hierarchy but are not required to\n   do so.  For example, if
      resource X with URL\n   \"http://example.com/bar/blah\" is not WebDAV compliant
      and resource A\n   with \"URL http://example.com/bar/\" identifies a WebDAV
      collection,\n   then A may or may not have a mapping from \"blah\" to X.\n   If
      a WebDAV-compliant resource has no WebDAV-compliant internal\n   members in
      the HTTP URL namespace hierarchy, then the WebDAV-\n   compliant resource is
      not required to be a collection.\n   There is a standing convention that when
      a collection is referred to\n   by its name without a trailing slash, the server
      MAY handle the\n   request as if the trailing slash were present.  In this case,
      it\n   SHOULD return a Content-Location header in the response, pointing to\n
      \  the URL ending with the \"/\".  For example, if a client invokes a\n   method
      on http://example.com/blah (no trailing slash), the server may\n   respond as
      if the operation were invoked on http://example.com/blah/\n   (trailing slash),
      and should return a Content-Location header with\n   the value http://example.com/blah/.
      \ Wherever a server produces a URL\n   referring to a collection, the server
      SHOULD include the trailing\n   slash.  In general, clients SHOULD use the trailing
      slash form of\n   collection names.  If clients do not use the trailing slash
      form the\n   client needs to be prepared to see a redirect response.  Clients
      will\n   find the DAV:resourcetype property more reliable than the URL to find\n
      \  out if a resource is a collection.\n   Clients MUST be able to support the
      case where WebDAV resources are\n   contained inside non-WebDAV resources.  For
      example, if an OPTIONS\n   response from \"http://example.com/servlet/dav/collection\"
      indicates\n   WebDAV support, the client cannot assume that\n   \"http://example.com/servlet/dav/\"
      or its parent necessarily are\n   WebDAV collections.\n   A typical scenario
      in which mapped URLs do not appear as members of\n   their parent collection
      is the case where a server allows links or\n   redirects to non-WebDAV resources.
      \ For instance, \"/col/link\" might\n   not appear as a member of \"/col/\",
      although the server would respond\n   with a 302 status to a GET request to
      \"/col/link\"; thus, the URL\n   \"/col/link\" would indeed be mapped.  Similarly,
      a dynamically-\n   generated page might have a URL mapping from \"/col/index.html\",
      thus\n   this resource might respond with a 200 OK to a GET request yet not\n
      \  appear as a member of \"/col/\".\n   Some mappings to even WebDAV-compliant
      resources might not appear in\n   the parent collection.  An example for this
      case are servers that\n   support multiple alias URLs for each WebDAV-compliant
      resource.  A\n   server may implement case-insensitive URLs, thus \"/col/a\"
      and\n   \"/col/A\" identify the same resource, yet only either \"a\" or \"A\"
      is\n   reported upon listing the members of \"/col\".  In cases where a server\n
      \  treats a set of segments as equivalent, the server MUST expose only\n   one
      preferred segment per mapping, consistently chosen, in PROPFIND\n   responses.\n"
    title: 5.2.  Collection Resources
  title: 5.  Collections of Web Resources
- contents:
  - "6.  Locking\n   The ability to lock a resource provides a mechanism for serializing\n
    \  access to that resource.  Using a lock, an authoring client can\n   provide
    a reasonable guarantee that another principal will not modify\n   a resource while
    it is being edited.  In this way, a client can\n   prevent the \"lost update\"
    problem.\n   This specification allows locks to vary over two client-specified\n
    \  parameters, the number of principals involved (exclusive vs. shared)\n   and
    the type of access to be granted.  This document defines locking\n   for only
    one access type, write.  However, the syntax is extensible,\n   and permits the
    eventual specification of locking for other access\n   types.\n"
  - contents:
    - "6.1.  Lock Model\n   This section provides a concise model for how locking
      behaves.  Later\n   sections will provide more detail on some of the concepts
      and refer\n   back to these model statements.  Normative statements related
      to LOCK\n   and UNLOCK method handling can be found in the sections on those\n
      \  methods, whereas normative statements that cover any method are\n   gathered
      here.\n   1.  A lock either directly or indirectly locks a resource.\n   2.
      \ A resource becomes directly locked when a LOCK request to a URL\n       of
      that resource creates a new lock.  The \"lock-root\" of the new\n       lock
      is that URL.  If at the time of the request, the URL is not\n       mapped to
      a resource, a new empty resource is created and\n       directly locked.\n   3.
      \ An exclusive lock (Section 6.2) conflicts with any other kind of\n       lock
      on the same resource, whether either lock is direct or\n       indirect.  A
      server MUST NOT create conflicting locks on a\n       resource.\n   4.  For
      a collection that is locked with a depth-infinity lock L, all\n       member
      resources are indirectly locked.  Changes in membership of\n       such a collection
      affect the set of indirectly locked resources:\n       *  If a member resource
      is added to the collection, the new\n          member resource MUST NOT already
      have a conflicting lock,\n          because the new resource MUST become indirectly
      locked by L.\n       *  If a member resource stops being a member of the collection,\n
      \         then the resource MUST no longer be indirectly locked by L.\n   5.
      \ Each lock is identified by a single globally unique lock token\n       (Section
      6.5).\n   6.  An UNLOCK request deletes the lock with the specified lock token.\n
      \      After a lock is deleted, no resource is locked by that lock.\n   7.  A
      lock token is \"submitted\" in a request when it appears in an\n       \"If\"
      header (Section 7, \"Write Lock\", discusses when token\n       submission is
      required for write locks).\n   8.  If a request causes the lock-root of any
      lock to become an\n       unmapped URL, then the lock MUST also be deleted by
      that request.\n"
    title: 6.1.  Lock Model
  - contents:
    - "6.2.  Exclusive vs. Shared Locks\n   The most basic form of lock is an exclusive
      lock.  Exclusive locks\n   avoid having to deal with content change conflicts,
      without requiring\n   any coordination other than the methods described in this\n
      \  specification.\n   However, there are times when the goal of a lock is not
      to exclude\n   others from exercising an access right but rather to provide
      a\n   mechanism for principals to indicate that they intend to exercise\n   their
      access rights.  Shared locks are provided for this case.  A\n   shared lock
      allows multiple principals to receive a lock.  Hence any\n   principal that
      has both access privileges and a valid lock can use\n   the locked resource.\n
      \  With shared locks, there are two trust sets that affect a resource.\n   The
      first trust set is created by access permissions.  Principals who\n   are trusted,
      for example, may have permission to write to the\n   resource.  Among those
      who have access permission to write to the\n   resource, the set of principals
      who have taken out a shared lock also\n   must trust each other, creating a
      (typically) smaller trust set\n   within the access permission write set.\n
      \  Starting with every possible principal on the Internet, in most\n   situations
      the vast majority of these principals will not have write\n   access to a given
      resource.  Of the small number who do have write\n   access, some principals
      may decide to guarantee their edits are free\n   from overwrite conflicts by
      using exclusive write locks.  Others may\n   decide they trust their collaborators
      will not overwrite their work\n   (the potential set of collaborators being
      the set of principals who\n   have write permission) and use a shared lock,
      which informs their\n   collaborators that a principal may be working on the
      resource.\n   The WebDAV extensions to HTTP do not need to provide all of the\n
      \  communications paths necessary for principals to coordinate their\n   activities.
      \ When using shared locks, principals may use any out-of-\n   band communication
      channel to coordinate their work (e.g., face-to-\n   face interaction, written
      notes, post-it notes on the screen,\n   telephone conversation, email, etc.)
      \ The intent of a shared lock is\n   to let collaborators know who else may
      be working on a resource.\n   Shared locks are included because experience from
      Web-distributed\n   authoring systems has indicated that exclusive locks are
      often too\n   rigid.  An exclusive lock is used to enforce a particular editing\n
      \  process: take out an exclusive lock, read the resource, perform\n   edits,
      write the resource, release the lock.  This editing process\n   has the problem
      that locks are not always properly released, for\n   example, when a program
      crashes or when a lock creator leaves without\n   unlocking a resource.  While
      both timeouts (Section 6.6) and\n   administrative action can be used to remove
      an offending lock,\n   neither mechanism may be available when needed; the timeout
      may be\n   long or the administrator may not be available.\n   A successful
      request for a new shared lock MUST result in the\n   generation of a unique
      lock associated with the requesting principal.\n   Thus, if five principals
      have taken out shared write locks on the\n   same resource, there will be five
      locks and five lock tokens, one for\n   each principal.\n"
    title: 6.2.  Exclusive vs. Shared Locks
  - contents:
    - "6.3.  Required Support\n   A WebDAV-compliant resource is not required to support
      locking in any\n   form.  If the resource does support locking, it may choose
      to support\n   any combination of exclusive and shared locks for any access
      types.\n   The reason for this flexibility is that locking policy strikes to
      the\n   very heart of the resource management and versioning systems employed\n
      \  by various storage repositories.  These repositories require control\n   over
      what sort of locking will be made available.  For example, some\n   repositories
      only support shared write locks, while others only\n   provide support for exclusive
      write locks, while yet others use no\n   locking at all.  As each system is
      sufficiently different to merit\n   exclusion of certain locking features, this
      specification leaves\n   locking as the sole axis of negotiation within WebDAV.\n"
    title: 6.3.  Required Support
  - contents:
    - "6.4.  Lock Creator and Privileges\n   The creator of a lock has special privileges
      to use the lock to\n   modify the resource.  When a locked resource is modified,
      a server\n   MUST check that the authenticated principal matches the lock creator\n
      \  (in addition to checking for valid lock token submission).\n   The server
      MAY allow privileged users other than the lock creator to\n   destroy a lock
      (for example, the resource owner or an administrator).\n   The 'unlock' privilege
      in [RFC3744] was defined to provide that\n   permission.\n   There is no requirement
      for servers to accept LOCK requests from all\n   users or from anonymous users.\n
      \  Note that having a lock does not confer full privilege to modify the\n   locked
      resource.  Write access and other privileges MUST be enforced\n   through normal
      privilege or authentication mechanisms, not based on\n   the possible obscurity
      of lock token values.\n"
    title: 6.4.  Lock Creator and Privileges
  - contents:
    - "6.5.  Lock Tokens\n   A lock token is a type of state token that identifies
      a particular\n   lock.  Each lock has exactly one unique lock token generated
      by the\n   server.  Clients MUST NOT attempt to interpret lock tokens in any\n
      \  way.\n   Lock token URIs MUST be unique across all resources for all time.\n
      \  This uniqueness constraint allows lock tokens to be submitted across\n   resources
      and servers without fear of confusion.  Since lock tokens\n   are unique, a
      client MAY submit a lock token in an If header on a\n   resource other than
      the one that returned it.\n   When a LOCK operation creates a new lock, the
      new lock token is\n   returned in the Lock-Token response header defined in
      Section 10.5,\n   and also in the body of the response.\n   Servers MAY make
      lock tokens publicly readable (e.g., in the DAV:\n   lockdiscovery property).
      \ One use case for making lock tokens\n   readable is so that a long-lived lock
      can be removed by the resource\n   owner (the client that obtained the lock
      might have crashed or\n   disconnected before cleaning up the lock).  Except
      for the case of\n   using UNLOCK under user guidance, a client SHOULD NOT use
      a lock\n   token created by another client instance.\n   This specification
      encourages servers to create Universally Unique\n   Identifiers (UUIDs) for
      lock tokens, and to use the URI form defined\n   by \"A Universally Unique Identifier
      (UUID) URN Namespace\"\n   ([RFC4122]).  However, servers are free to use any
      URI (e.g., from\n   another scheme) so long as it meets the uniqueness requirements.
      \ For\n   example, a valid lock token might be constructed using the\n   \"opaquelocktoken\"
      scheme defined in Appendix C.\n   Example: \"urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"\n"
    title: 6.5.  Lock Tokens
  - contents:
    - "6.6.  Lock Timeout\n   A lock MAY have a limited lifetime.  The lifetime is
      suggested by the\n   client when creating or refreshing the lock, but the server\n
      \  ultimately chooses the timeout value.  Timeout is measured in seconds\n   remaining
      until lock expiration.\n   The timeout counter MUST be restarted if a refresh
      lock request is\n   successful (see Section 9.10.2).  The timeout counter SHOULD
      NOT be\n   restarted at any other time.\n   If the timeout expires, then the
      lock SHOULD be removed.  In this\n   case the server SHOULD act as if an UNLOCK
      method was executed by the\n   server on the resource using the lock token of
      the timed-out lock,\n   performed with its override authority.\n   Servers are
      advised to pay close attention to the values submitted by\n   clients, as they
      will be indicative of the type of activity the\n   client intends to perform.
      \ For example, an applet running in a\n   browser may need to lock a resource,
      but because of the instability\n   of the environment within which the applet
      is running, the applet may\n   be turned off without warning.  As a result,
      the applet is likely to\n   ask for a relatively small timeout value so that
      if the applet dies,\n   the lock can be quickly harvested.  However, a document
      management\n   system is likely to ask for an extremely long timeout because
      its\n   user may be planning on going offline.\n   A client MUST NOT assume
      that just because the timeout has expired,\n   the lock has immediately been
      removed.\n   Likewise, a client MUST NOT assume that just because the timeout
      has\n   not expired, the lock still exists.  Clients MUST assume that locks\n
      \  can arbitrarily disappear at any time, regardless of the value given\n   in
      the Timeout header.  The Timeout header only indicates the\n   behavior of the
      server if extraordinary circumstances do not occur.\n   For example, a sufficiently
      privileged user may remove a lock at any\n   time, or the system may crash in
      such a way that it loses the record\n   of the lock's existence.\n"
    title: 6.6.  Lock Timeout
  - contents:
    - "6.7.  Lock Capability Discovery\n   Since server lock support is optional,
      a client trying to lock a\n   resource on a server can either try the lock and
      hope for the best,\n   or perform some form of discovery to determine what lock
      capabilities\n   the server supports.  This is known as lock capability discovery.
      \ A\n   client can determine what lock types the server supports by\n   retrieving
      the DAV:supportedlock property.\n   Any DAV-compliant resource that supports
      the LOCK method MUST support\n   the DAV:supportedlock property.\n"
    title: 6.7.  Lock Capability Discovery
  - contents:
    - "6.8.  Active Lock Discovery\n   If another principal locks a resource that
      a principal wishes to\n   access, it is useful for the second principal to be
      able to find out\n   who the first principal is.  For this purpose the DAV:lockdiscovery\n
      \  property is provided.  This property lists all outstanding locks,\n   describes
      their type, and MAY even provide the lock tokens.\n   Any DAV-compliant resource
      that supports the LOCK method MUST support\n   the DAV:lockdiscovery property.\n"
    title: 6.8.  Active Lock Discovery
  title: 6.  Locking
- contents:
  - "7.  Write Lock\n   This section describes the semantics specific to the write
    lock type.\n   The write lock is a specific instance of a lock type, and is the
    only\n   lock type described in this specification.\n   An exclusive write lock
    protects a resource: it prevents changes by\n   any principal other than the lock
    creator and in any case where the\n   lock token is not submitted (e.g., by a
    client process other than the\n   one holding the lock).\n   Clients MUST submit
    a lock-token they are authorized to use in any\n   request that modifies a write-locked
    resource.  The list of\n   modifications covered by a write-lock include:\n   1.
    \ A change to any of the following aspects of any write-locked\n       resource:\n
    \      *  any variant,\n       *  any dead property,\n       *  any live property
    that is lockable (a live property is\n          lockable unless otherwise defined.)\n
    \  2.  For collections, any modification of an internal member URI.  An\n       internal
    member URI of a collection is considered to be modified\n       if it is added,
    removed, or identifies a different resource.\n       More discussion on write
    locks and collections is found in\n       Section 7.4.\n   3.  A modification
    of the mapping of the root of the write lock,\n       either to another resource
    or to no resource (e.g., DELETE).\n   Of the methods defined in HTTP and WebDAV,
    PUT, POST, PROPPATCH,\n   LOCK, UNLOCK, MOVE, COPY (for the destination resource),
    DELETE, and\n   MKCOL are affected by write locks.  All other HTTP/WebDAV methods\n
    \  defined so far -- GET in particular -- function independently of a\n   write
    lock.\n   The next few sections describe in more specific terms how write locks\n
    \  interact with various operations.\n"
  - contents:
    - "7.1.  Write Locks and Properties\n   While those without a write lock may not
      alter a property on a\n   resource it is still possible for the values of live
      properties to\n   change, even while locked, due to the requirements of their
      schemas.\n   Only dead properties and live properties defined as lockable are\n
      \  guaranteed not to change while write locked.\n"
    title: 7.1.  Write Locks and Properties
  - contents:
    - "7.2.  Avoiding Lost Updates\n   Although the write locks provide some help
      in preventing lost\n   updates, they cannot guarantee that updates will never
      be lost.\n   Consider the following scenario:\n   Two clients A and B are interested
      in editing the resource\n   'index.html'.  Client A is an HTTP client rather
      than a WebDAV\n   client, and so does not know how to perform locking.\n   Client
      A doesn't lock the document, but does a GET, and begins\n   editing.\n   Client
      B does LOCK, performs a GET and begins editing.\n   Client B finishes editing,
      performs a PUT, then an UNLOCK.\n   Client A performs a PUT, overwriting and
      losing all of B's changes.\n   There are several reasons why the WebDAV protocol
      itself cannot\n   prevent this situation.  First, it cannot force all clients
      to use\n   locking because it must be compatible with HTTP clients that do not\n
      \  comprehend locking.  Second, it cannot require servers to support\n   locking
      because of the variety of repository implementations, some of\n   which rely
      on reservations and merging rather than on locking.\n   Finally, being stateless,
      it cannot enforce a sequence of operations\n   like LOCK / GET / PUT / UNLOCK.\n
      \  WebDAV servers that support locking can reduce the likelihood that\n   clients
      will accidentally overwrite each other's changes by requiring\n   clients to
      lock resources before modifying them.  Such servers would\n   effectively prevent
      HTTP 1.0 and HTTP 1.1 clients from modifying\n   resources.\n   WebDAV clients
      can be good citizens by using a lock / retrieve /\n   write /unlock sequence
      of operations (at least by default) whenever\n   they interact with a WebDAV
      server that supports locking.\n   HTTP 1.1 clients can be good citizens, avoiding
      overwriting other\n   clients' changes, by using entity tags in If-Match headers
      with any\n   requests that would modify resources.\n   Information managers
      may attempt to prevent overwrites by\n   implementing client-side procedures
      requiring locking before\n   modifying WebDAV resources.\n"
    title: 7.2.  Avoiding Lost Updates
  - contents:
    - "7.3.  Write Locks and Unmapped URLs\n   WebDAV provides the ability to send
      a LOCK request to an unmapped URL\n   in order to reserve the name for use.
      \ This is a simple way to avoid\n   the lost-update problem on the creation
      of a new resource (another\n   way is to use If-None-Match header specified
      in Section 14.26 of\n   [RFC2616]).  It has the side benefit of locking the
      new resource\n   immediately for use of the creator.\n   Note that the lost-update
      problem is not an issue for collections\n   because MKCOL can only be used to
      create a collection, not to\n   overwrite an existing collection.  When trying
      to lock a collection\n   upon creation, clients can attempt to increase the
      likelihood of\n   getting the lock by pipelining the MKCOL and LOCK requests
      together\n   (but because this doesn't convert two separate operations into
      one\n   atomic operation, there's no guarantee this will work).\n   A successful
      lock request to an unmapped URL MUST result in the\n   creation of a locked
      (non-collection) resource with empty content.\n   Subsequently, a successful
      PUT request (with the correct lock token)\n   provides the content for the resource.
      \ Note that the LOCK request\n   has no mechanism for the client to provide
      Content-Type or Content-\n   Language, thus the server will use defaults or
      empty values and rely\n   on the subsequent PUT request for correct values.\n
      \  A resource created with a LOCK is empty but otherwise behaves in\n   every
      way as a normal resource.  It behaves the same way as a\n   resource created
      by a PUT request with an empty body (and where a\n   Content-Type and Content-Language
      was not specified), followed by a\n   LOCK request to the same resource.  Following
      from this model, a\n   locked empty resource:\n   o  Can be read, deleted, moved,
      and copied, and in all ways behaves\n      as a regular non-collection resource.\n
      \  o  Appears as a member of its parent collection.\n   o  SHOULD NOT disappear
      when its lock goes away (clients must\n      therefore be responsible for cleaning
      up their own mess, as with\n      any other operation or any non-empty resource).\n
      \  o  MAY NOT have values for properties like DAV:getcontentlanguage\n      that
      haven't been specified yet by the client.\n   o  Can be updated (have content
      added) with a PUT request.\n   o  MUST NOT be converted into a collection.  The
      server MUST fail a\n      MKCOL request (as it would with a MKCOL request to
      any existing\n      non-collection resource).\n   o  MUST have defined values
      for DAV:lockdiscovery and DAV:\n      supportedlock properties.\n   o  The response
      MUST indicate that a resource was created, by use of\n      the \"201 Created\"
      response code (a LOCK request to an existing\n      resource instead will result
      in 200 OK).  The body must still\n      include the DAV:lockdiscovery property,
      as with a LOCK request to\n      an existing resource.\n   The client is expected
      to update the locked empty resource shortly\n   after locking it, using PUT
      and possibly PROPPATCH.\n   Alternatively and for backwards compatibility to
      [RFC2518], servers\n   MAY implement Lock-Null Resources (LNRs) instead (see
      definition in\n   Appendix D).  Clients can easily interoperate both with servers
      that\n   support the old model LNRs and the recommended model of \"locked empty\n
      \  resources\" by only attempting PUT after a LOCK to an unmapped URL,\n   not
      MKCOL or GET, and by not relying on specific properties of LNRs.\n"
    title: 7.3.  Write Locks and Unmapped URLs
  - contents:
    - "7.4.  Write Locks and Collections\n   There are two kinds of collection write
      locks.  A depth-0 write lock\n   on a collection protects the collection properties
      plus the internal\n   member URLs of that one collection, while not protecting
      the content\n   or properties of member resources (if the collection itself
      has any\n   entity bodies, those are also protected).  A depth-infinity write\n
      \  lock on a collection provides the same protection on that collection\n   and
      also provides write lock protection on every member resource.\n   Expressed
      otherwise, a write lock of either kind protects any request\n   that would create
      a new resource in a write locked collection, any\n   request that would remove
      an internal member URL of a write locked\n   collection, and any request that
      would change the segment name of any\n   internal member.\n   Thus, a collection
      write lock protects all the following actions:\n   o  DELETE a collection's
      direct internal member,\n   o  MOVE an internal member out of the collection,\n
      \  o  MOVE an internal member into the collection,\n   o  MOVE to rename an
      internal member within a collection,\n   o  COPY an internal member into a collection,
      and\n   o  PUT or MKCOL request that would create a new internal member.\n   The
      collection's lock token is required in addition to the lock token\n   on the
      internal member itself, if it is locked separately.\n   In addition, a depth-infinity
      lock affects all write operations to\n   all members of the locked collection.
      \ With a depth-infinity lock,\n   the resource identified by the root of the
      lock is directly locked,\n   and all its members are indirectly locked.\n   o
      \ Any new resource added as a descendant of a depth-infinity locked\n      collection
      becomes indirectly locked.\n   o  Any indirectly locked resource moved out of
      the locked collection\n      into an unlocked collection is thereafter unlocked.\n
      \  o  Any indirectly locked resource moved out of a locked source\n      collection
      into a depth-infinity locked target collection remains\n      indirectly locked
      but is now protected by the lock on the target\n      collection (the target
      collection's lock token will thereafter be\n      required to make further changes).\n
      \  If a depth-infinity write LOCK request is issued to a collection\n   containing
      member URLs identifying resources that are currently\n   locked in a manner
      that conflicts with the new lock (see Section 6.1,\n   point 3), the request
      MUST fail with a 423 (Locked) status code, and\n   the response SHOULD contain
      the 'no-conflicting-lock' precondition.\n   If a lock request causes the URL
      of a resource to be added as an\n   internal member URL of a depth-infinity
      locked collection, then the\n   new resource MUST be automatically protected
      by the lock.  For\n   example, if the collection /a/b/ is write locked and the
      resource /c\n   is moved to /a/b/c, then resource /a/b/c will be added to the
      write\n   lock.\n"
    title: 7.4.  Write Locks and Collections
  - contents:
    - "7.5.  Write Locks and the If Request Header\n   A user agent has to demonstrate
      knowledge of a lock when requesting\n   an operation on a locked resource.  Otherwise,
      the following scenario\n   might occur.  In the scenario, program A, run by
      User A, takes out a\n   write lock on a resource.  Program B, also run by User
      A, has no\n   knowledge of the lock taken out by program A, yet performs a PUT
      to\n   the locked resource.  In this scenario, the PUT succeeds because\n   locks
      are associated with a principal, not a program, and thus\n   program B, because
      it is acting with principal A's credential, is\n   allowed to perform the PUT.
      \ However, had program B known about the\n   lock, it would not have overwritten
      the resource, preferring instead\n   to present a dialog box describing the
      conflict to the user.  Due to\n   this scenario, a mechanism is needed to prevent
      different programs\n   from accidentally ignoring locks taken out by other programs
      with the\n   same authorization.\n   In order to prevent these collisions, a
      lock token MUST be submitted\n   by an authorized principal for all locked resources
      that a method may\n   change or the method MUST fail.  A lock token is submitted
      when it\n   appears in an If header.  For example, if a resource is to be moved\n
      \  and both the source and destination are locked, then two lock tokens\n   must
      be submitted in the If header, one for the source and the other\n   for the
      destination.\n"
    - contents:
      - "7.5.1.  Example - Write Lock and COPY\n   >>Request\n     COPY /~fielding/index.html
        HTTP/1.1\n     Host: www.example.com\n     Destination: http://www.example.com/users/f/fielding/index.html\n
        \    If: <http://www.example.com/users/f/fielding/index.html>\n         (<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>)\n
        \  >>Response\n     HTTP/1.1 204 No Content\n   In this example, even though
        both the source and destination are\n   locked, only one lock token must be
        submitted (the one for the lock\n   on the destination).  This is because
        the source resource is not\n   modified by a COPY, and hence unaffected by
        the write lock.  In this\n   example, user agent authentication has previously
        occurred via a\n   mechanism outside the scope of the HTTP protocol, in the
        underlying\n   transport layer.\n"
      title: 7.5.1.  Example - Write Lock and COPY
    - contents:
      - "7.5.2.  Example - Deleting a Member of a Locked Collection\n   Consider a
        collection \"/locked\" with an exclusive, depth-infinity\n   write lock, and
        an attempt to delete an internal member \"/locked/\n   member\":\n   >>Request\n
        \    DELETE /locked/member HTTP/1.1\n     Host: example.com\n   >>Response\n
        \    HTTP/1.1 423 Locked\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <D:error xmlns:D=\"DAV:\">\n       <D:lock-token-submitted>\n         <D:href>/locked/</D:href>\n
        \      </D:lock-token-submitted>\n     </D:error>\n   Thus, the client would
        need to submit the lock token with the request\n   to make it succeed.  To
        do that, various forms of the If header (see\n   Section 10.4) could be used.\n
        \  \"No-Tag-List\" format:\n     If: (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)\n
        \  \"Tagged-List\" format, for \"http://example.com/locked/\":\n     If: <http://example.com/locked/>\n
        \        (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)\n   \"Tagged-List\"
        format, for \"http://example.com/locked/member\":\n     If: <http://example.com/locked/member>\n
        \        (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)\n   Note that,
        for the purpose of submitting the lock token, the actual\n   form doesn't
        matter; what's relevant is that the lock token appears\n   in the If header,
        and that the If header itself evaluates to true.\n"
      title: 7.5.2.  Example - Deleting a Member of a Locked Collection
    title: 7.5.  Write Locks and the If Request Header
  - contents:
    - "7.6.  Write Locks and COPY/MOVE\n   A COPY method invocation MUST NOT duplicate
      any write locks active on\n   the source.  However, as previously noted, if
      the COPY copies the\n   resource into a collection that is locked with a depth-infinity
      lock,\n   then the resource will be added to the lock.\n   A successful MOVE
      request on a write locked resource MUST NOT move\n   the write lock with the
      resource.  However, if there is an existing\n   lock at the destination, the
      server MUST add the moved resource to\n   the destination lock scope.  For example,
      if the MOVE makes the\n   resource a child of a collection that has a depth-infinity
      lock, then\n   the resource will be added to that collection's lock.  Additionally,\n
      \  if a resource with a depth-infinity lock is moved to a destination\n   that
      is within the scope of the same lock (e.g., within the URL\n   namespace tree
      covered by the lock), the moved resource will again be\n   added to the lock.
      \ In both these examples, as specified in\n   Section 7.5, an If header must
      be submitted containing a lock token\n   for both the source and destination.\n"
    title: 7.6.  Write Locks and COPY/MOVE
  - contents:
    - "7.7.  Refreshing Write Locks\n   A client MUST NOT submit the same write lock
      request twice.  Note\n   that a client is always aware it is resubmitting the
      same lock\n   request because it must include the lock token in the If header
      in\n   order to make the request for a resource that is already locked.\n   However,
      a client may submit a LOCK request with an If header but\n   without a body.
      \ A server receiving a LOCK request with no body MUST\n   NOT create a new lock
      -- this form of the LOCK request is only to be\n   used to \"refresh\" an existing
      lock (meaning, at minimum, that any\n   timers associated with the lock MUST
      be reset).\n   Clients may submit Timeout headers of arbitrary value with their
      lock\n   refresh requests.  Servers, as always, may ignore Timeout headers\n
      \  submitted by the client, and a server MAY refresh a lock with a\n   timeout
      period that is different than the previous timeout period\n   used for the lock,
      provided it advertises the new value in the LOCK\n   refresh response.\n   If
      an error is received in response to a refresh LOCK request, the\n   client MUST
      NOT assume that the lock was refreshed.\n"
    title: 7.7.  Refreshing Write Locks
  title: 7.  Write Lock
- contents:
  - '8.  General Request and Response Handling

    '
  - contents:
    - "8.1.  Precedence in Error Handling\n   Servers MUST return authorization errors
      in preference to other\n   errors.  This avoids leaking information about protected
      resources\n   (e.g., a client that finds that a hidden resource exists by seeing
      a\n   423 Locked response to an anonymous request to the resource).\n"
    title: 8.1.  Precedence in Error Handling
  - contents:
    - "8.2.  Use of XML\n   In HTTP/1.1, method parameter information was exclusively
      encoded in\n   HTTP headers.  Unlike HTTP/1.1, WebDAV encodes method parameter\n
      \  information either in an XML ([REC-XML]) request entity body, or in\n   an
      HTTP header.  The use of XML to encode method parameters was\n   motivated by
      the ability to add extra XML elements to existing\n   structures, providing
      extensibility; and by XML's ability to encode\n   information in ISO 10646 character
      sets, providing\n   internationalization support.\n   In addition to encoding
      method parameters, XML is used in WebDAV to\n   encode the responses from methods,
      providing the extensibility and\n   internationalization advantages of XML for
      method output, as well as\n   input.\n   When XML is used for a request or response
      body, the Content-Type\n   type SHOULD be application/xml.  Implementations
      MUST accept both\n   text/xml and application/xml in request and response bodies.
      \ Use of\n   text/xml is deprecated.\n   All DAV-compliant clients and resources
      MUST use XML parsers that are\n   compliant with [REC-XML] and [REC-XML-NAMES].
      \ All XML used in either\n   requests or responses MUST be, at minimum, well
      formed and use\n   namespaces correctly.  If a server receives XML that is not
      well-\n   formed, then the server MUST reject the entire request with a 400\n
      \  (Bad Request).  If a client receives XML that is not well-formed in a\n   response,
      then the client MUST NOT assume anything about the outcome\n   of the executed
      method and SHOULD treat the server as malfunctioning.\n   Note that processing
      XML submitted by an untrusted source may cause\n   risks connected to privacy,
      security, and service quality (see\n   Section 20).  Servers MAY reject questionable
      requests (even though\n   they consist of well-formed XML), for instance, with
      a 400 (Bad\n   Request) status code and an optional response body explaining
      the\n   problem.\n"
    title: 8.2.  Use of XML
  - contents:
    - "8.3.  URL Handling\n   URLs appear in many places in requests and responses.\n
      \  Interoperability experience with [RFC2518] showed that many clients\n   parsing
      Multi-Status responses did not fully implement the full\n   Reference Resolution
      defined in Section 5 of [RFC3986].  Thus,\n   servers in particular need to
      be careful in handling URLs in\n   responses, to ensure that clients have enough
      context to be able to\n   interpret all the URLs.  The rules in this section
      apply not only to\n   resource URLs in the 'href' element in Multi-Status responses,
      but\n   also to the Destination and If header resource URLs.\n   The sender
      has a choice between two approaches: using a relative\n   reference, which is
      resolved against the Request-URI, or a full URI.\n   A server MUST ensure that
      every 'href' value within a Multi-Status\n   response uses the same format.\n
      \  WebDAV only uses one form of relative reference in its extensions,\n   the
      absolute path.\n      Simple-ref = absolute-URI | ( path-absolute [ \"?\" query
      ] )\n   The absolute-URI, path-absolute and query productions are defined in\n
      \  Sections 4.3, 3.3, and 3.4 of [RFC3986].\n   Within Simple-ref productions,
      senders MUST NOT:\n   o  use dot-segments (\".\" or \"..\"), or\n   o  have
      prefixes that do not match the Request-URI (using the\n      comparison rules
      defined in Section 3.2.3 of [RFC2616]).\n   Identifiers for collections SHOULD
      end in a '/' character.\n"
    - contents:
      - "8.3.1.  Example - Correct URL Handling\n   Consider the collection http://example.com/sample/
        with the internal\n   member URL http://example.com/sample/a%20test and the
        PROPFIND\n   request below:\n   >>Request:\n     PROPFIND /sample/ HTTP/1.1\n
        \    Host: example.com\n     Depth: 1\n   In this case, the server should
        return two 'href' elements containing\n   either\n   o  'http://example.com/sample/'
        and\n      'http://example.com/sample/a%20test', or\n   o  '/sample/' and
        '/sample/a%20test'\n   Note that even though the server may be storing the
        member resource\n   internally as 'a test', it has to be percent-encoded when
        used inside\n   a URI reference (see Section 2.1 of [RFC3986]).  Also note
        that a\n   legal URI may still contain characters that need to be escaped
        within\n   XML character data, such as the ampersand character.\n"
      title: 8.3.1.  Example - Correct URL Handling
    title: 8.3.  URL Handling
  - contents:
    - "8.4.  Required Bodies in Requests\n   Some of these new methods do not define
      bodies.  Servers MUST examine\n   all requests for a body, even when a body
      was not expected.  In cases\n   where a request body is present but would be
      ignored by a server, the\n   server MUST reject the request with 415 (Unsupported
      Media Type).\n   This informs the client (which may have been attempting to
      use an\n   extension) that the body could not be processed as the client\n   intended.\n"
    title: 8.4.  Required Bodies in Requests
  - contents:
    - "8.5.  HTTP Headers for Use in WebDAV\n   HTTP defines many headers that can
      be used in WebDAV requests and\n   responses.  Not all of these are appropriate
      in all situations and\n   some interactions may be undefined.  Note that HTTP
      1.1 requires the\n   Date header in all responses if possible (see Section 14.18,\n
      \  [RFC2616]).\n   The server MUST do authorization checks before checking any
      HTTP\n   conditional header.\n"
    title: 8.5.  HTTP Headers for Use in WebDAV
  - contents:
    - "8.6.  ETag\n   HTTP 1.1 recommends the use of ETags rather than modification
      dates,\n   for cache control, and there are even stronger reasons to prefer\n
      \  ETags for authoring.  Correct use of ETags is even more important in\n   a
      distributed authoring environment, because ETags are necessary\n   along with
      locks to avoid the lost-update problem.  A client might\n   fail to renew a
      lock, for example, when the lock times out and the\n   client is accidentally
      offline or in the middle of a long upload.\n   When a client fails to renew
      the lock, it's quite possible the\n   resource can still be relocked and the
      user can go on editing, as\n   long as no changes were made in the meantime.
      \ ETags are required for\n   the client to be able to distinguish this case.
      \ Otherwise, the\n   client is forced to ask the user whether to overwrite the
      resource on\n   the server without even being able to tell the user if it has\n
      \  changed.  Timestamps do not solve this problem nearly as well as\n   ETags.\n
      \  Strong ETags are much more useful for authoring use cases than weak\n   ETags
      (see Section 13.3.3 of [RFC2616]).  Semantic equivalence can be\n   a useful
      concept but that depends on the document type and the\n   application type,
      and interoperability might require some agreement\n   or standard outside the
      scope of this specification and HTTP.  Note\n   also that weak ETags have certain
      restrictions in HTTP, e.g., these\n   cannot be used in If-Match headers.\n
      \  Note that the meaning of an ETag in a PUT response is not clearly\n   defined
      either in this document or in RFC 2616 (i.e., whether the\n   ETag means that
      the resource is octet-for-octet equivalent to the\n   body of the PUT request,
      or whether the server could have made minor\n   changes in the formatting or
      content of the document upon storage).\n   This is an HTTP issue, not purely
      a WebDAV issue.\n   Because clients may be forced to prompt users or throw away
      changed\n   content if the ETag changes, a WebDAV server SHOULD NOT change the\n
      \  ETag (or the Last-Modified time) for a resource that has an unchanged\n   body
      and location.  The ETag represents the state of the body or\n   contents of
      the resource.  There is no similar way to tell if\n   properties have changed.\n"
    title: 8.6.  ETag
  - contents:
    - "8.7.  Including Error Response Bodies\n   HTTP and WebDAV did not use the bodies
      of most error responses for\n   machine-parsable information until the specification
      for Versioning\n   Extensions to WebDAV introduced a mechanism to include more
      specific\n   information in the body of an error response (Section 1.6 of\n
      \  [RFC3253]).  The error body mechanism is appropriate to use with any\n   error
      response that may take a body but does not already have a body\n   defined.
      \ The mechanism is particularly appropriate when a status\n   code can mean
      many things (for example, 400 Bad Request can mean\n   required headers are
      missing, headers are incorrectly formatted, or\n   much more).  This error body
      mechanism is covered in Section 16.\n"
    title: 8.7.  Including Error Response Bodies
  - contents:
    - "8.8.  Impact of Namespace Operations on Cache Validators\n   Note that the
      HTTP response headers \"Etag\" and \"Last-Modified\" (see\n   [RFC2616], Sections
      14.19 and 14.29) are defined per URL (not per\n   resource), and are used by
      clients for caching.  Therefore servers\n   must ensure that executing any operation
      that affects the URL\n   namespace (such as COPY, MOVE, DELETE, PUT, or MKCOL)
      does preserve\n   their semantics, in particular:\n   o  For any given URL,
      the \"Last-Modified\" value MUST increment every\n      time the representation
      returned upon GET changes (within the\n      limits of timestamp resolution).\n
      \  o  For any given URL, an \"ETag\" value MUST NOT be reused for\n      different
      representations returned by GET.\n   In practice this means that servers\n   o
      \ might have to increment \"Last-Modified\" timestamps for every\n      resource
      inside the destination namespace of a namespace operation\n      unless it can
      do so more selectively, and\n   o  similarly, might have to re-assign \"ETag\"
      values for these\n      resources (unless the server allocates entity tags in
      a way so\n      that they are unique across the whole URL namespace managed
      by the\n      server).\n   Note that these considerations also apply to specific
      use cases, such\n   as using PUT to create a new resource at a URL that has
      been mapped\n   before, but has been deleted since then.\n   Finally, WebDAV
      properties (such as DAV:getetag and DAV:\n   getlastmodified) that inherit their
      semantics from HTTP headers must\n   behave accordingly.\n"
    title: 8.8.  Impact of Namespace Operations on Cache Validators
  title: 8.  General Request and Response Handling
- contents:
  - '9.  HTTP Methods for Distributed Authoring

    '
  - contents:
    - "9.1.  PROPFIND Method\n   The PROPFIND method retrieves properties defined
      on the resource\n   identified by the Request-URI, if the resource does not
      have any\n   internal members, or on the resource identified by the Request-URI\n
      \  and potentially its member resources, if the resource is a collection\n   that
      has internal member URLs.  All DAV-compliant resources MUST\n   support the
      PROPFIND method and the propfind XML element\n   (Section 14.20) along with
      all XML elements defined for use with that\n   element.\n   A client MUST submit
      a Depth header with a value of \"0\", \"1\", or\n   \"infinity\" with a PROPFIND
      request.  Servers MUST support \"0\" and \"1\"\n   depth requests on WebDAV-compliant
      resources and SHOULD support\n   \"infinity\" requests.  In practice, support
      for infinite-depth\n   requests MAY be disabled, due to the performance and
      security\n   concerns associated with this behavior.  Servers SHOULD treat a\n
      \  request without a Depth header as if a \"Depth: infinity\" header was\n   included.\n
      \  A client may submit a 'propfind' XML element in the body of the\n   request
      method describing what information is being requested.  It is\n   possible to:\n
      \  o  Request particular property values, by naming the properties\n      desired
      within the 'prop' element (the ordering of properties in\n      here MAY be
      ignored by the server),\n   o  Request property values for those properties
      defined in this\n      specification (at a minimum) plus dead properties, by
      using the\n      'allprop' element (the 'include' element can be used with\n
      \     'allprop' to instruct the server to also include additional live\n      properties
      that may not have been returned otherwise),\n   o  Request a list of names of
      all the properties defined on the\n      resource, by using the 'propname' element.\n
      \  A client may choose not to submit a request body.  An empty PROPFIND\n   request
      body MUST be treated as if it were an 'allprop' request.\n   Note that 'allprop'
      does not return values for all live properties.\n   WebDAV servers increasingly
      have expensively-calculated or lengthy\n   properties (see [RFC3253] and [RFC3744])
      and do not return all\n   properties already.  Instead, WebDAV clients can use
      propname\n   requests to discover what live properties exist, and request named\n
      \  properties when retrieving values.  For a live property defined\n   elsewhere,
      that definition can specify whether or not that live\n   property would be returned
      in 'allprop' requests.\n   All servers MUST support returning a response of
      content type text/\n   xml or application/xml that contains a multistatus XML
      element that\n   describes the results of the attempts to retrieve the various\n
      \  properties.\n   If there is an error retrieving a property, then a proper
      error\n   result MUST be included in the response.  A request to retrieve the\n
      \  value of a property that does not exist is an error and MUST be noted\n   with
      a 'response' XML element that contains a 404 (Not Found) status\n   value.\n
      \  Consequently, the 'multistatus' XML element for a collection resource\n   MUST
      include a 'response' XML element for each member URL of the\n   collection,
      to whatever depth was requested.  It SHOULD NOT include\n   any 'response' elements
      for resources that are not WebDAV-compliant.\n   Each 'response' element MUST
      contain an 'href' element that contains\n   the URL of the resource on which
      the properties in the prop XML\n   element are defined.  Results for a PROPFIND
      on a collection resource\n   are returned as a flat list whose order of entries
      is not\n   significant.  Note that a resource may have only one value for a\n
      \  property of a given name, so the property may only show up once in\n   PROPFIND
      responses.\n   Properties may be subject to access control.  In the case of\n
      \  'allprop' and 'propname' requests, if a principal does not have the\n   right
      to know whether a particular property exists, then the property\n   MAY be silently
      excluded from the response.\n   Some PROPFIND results MAY be cached, with care,
      as there is no cache\n   validation mechanism for most properties.  This method
      is both safe\n   and idempotent (see Section 9.1 of [RFC2616]).\n"
    - contents:
      - "9.1.1.  PROPFIND Status Codes\n   This section, as with similar sections
        for other methods, provides\n   some guidance on error codes and preconditions
        or postconditions\n   (defined in Section 16) that might be particularly useful
        with\n   PROPFIND.\n   403 Forbidden - A server MAY reject PROPFIND requests
        on collections\n   with depth header of \"Infinity\", in which case it SHOULD
        use this\n   error with the precondition code 'propfind-finite-depth' inside
        the\n   error body.\n"
      title: 9.1.1.  PROPFIND Status Codes
    - contents:
      - "9.1.2.  Status Codes for Use in 'propstat' Element\n   In PROPFIND responses,
        information about individual properties is\n   returned inside 'propstat'
        elements (see Section 14.22), each\n   containing an individual 'status' element
        containing information\n   about the properties appearing in it.  The list
        below summarizes the\n   most common status codes used inside 'propstat';
        however, clients\n   should be prepared to handle other 2/3/4/5xx series status
        codes as\n   well.\n   200 OK - A property exists and/or its value is successfully
        returned.\n   401 Unauthorized - The property cannot be viewed without appropriate\n
        \  authorization.\n   403 Forbidden - The property cannot be viewed regardless
        of\n   authentication.\n   404 Not Found - The property does not exist.\n"
      title: 9.1.2.  Status Codes for Use in 'propstat' Element
    - contents:
      - "9.1.3.  Example - Retrieving Named Properties\n   >>Request\n     PROPFIND
        /file HTTP/1.1\n     Host: www.example.com\n     Content-type: application/xml;
        charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\"
        ?>\n     <D:propfind xmlns:D=\"DAV:\">\n       <D:prop xmlns:R=\"http://ns.example.com/boxschema/\">\n
        \        <R:bigbox/>\n         <R:author/>\n         <R:DingALing/>\n         <R:Random/>\n
        \      </D:prop>\n     </D:propfind>\n   >>Response\n     HTTP/1.1 207 Multi-Status\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     Content-Length:
        xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus
        xmlns:D=\"DAV:\">\n       <D:response xmlns:R=\"http://ns.example.com/boxschema/\">\n
        \        <D:href>http://www.example.com/file</D:href>\n         <D:propstat>\n
        \          <D:prop>\n             <R:bigbox>\n               <R:BoxType>Box
        type A</R:BoxType>\n             </R:bigbox>\n             <R:author>\n               <R:Name>J.J.
        Johnson</R:Name>\n             </R:author>\n           </D:prop>\n           <D:status>HTTP/1.1
        200 OK</D:status>\n         </D:propstat>\n         <D:propstat>\n           <D:prop><R:DingALing/><R:Random/></D:prop>\n
        \          <D:status>HTTP/1.1 403 Forbidden</D:status>\n           <D:responsedescription>
        The user does not have access to the\n      DingALing property.\n           </D:responsedescription>\n
        \        </D:propstat>\n       </D:response>\n       <D:responsedescription>
        There has been an access violation error.\n       </D:responsedescription>\n
        \    </D:multistatus>\n   In this example, PROPFIND is executed on a non-collection
        resource\n   http://www.example.com/file.  The propfind XML element specifies
        the\n   name of four properties whose values are being requested.  In this\n
        \  case, only two properties were returned, since the principal issuing\n
        \  the request did not have sufficient access rights to see the third\n   and
        fourth properties.\n"
      title: 9.1.3.  Example - Retrieving Named Properties
    - contents:
      - "9.1.4.  Example - Using 'propname' to Retrieve All Property Names\n   >>Request\n
        \    PROPFIND /container/ HTTP/1.1\n     Host: www.example.com\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <propfind xmlns=\"DAV:\">\n       <propname/>\n
        \    </propfind>\n   >>Response\n     HTTP/1.1 207 Multi-Status\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <multistatus xmlns=\"DAV:\">\n
        \      <response>\n         <href>http://www.example.com/container/</href>\n
        \        <propstat>\n           <prop xmlns:R=\"http://ns.example.com/boxschema/\">\n
        \            <R:bigbox/>\n             <R:author/>\n             <creationdate/>\n
        \            <displayname/>\n             <resourcetype/>\n             <supportedlock/>\n
        \          </prop>\n           <status>HTTP/1.1 200 OK</status>\n         </propstat>\n
        \      </response>\n       <response>\n         <href>http://www.example.com/container/front.html</href>\n
        \        <propstat>\n           <prop xmlns:R=\"http://ns.example.com/boxschema/\">\n
        \            <R:bigbox/>\n             <creationdate/>\n             <displayname/>\n
        \            <getcontentlength/>\n             <getcontenttype/>\n             <getetag/>\n
        \            <getlastmodified/>\n             <resourcetype/>\n             <supportedlock/>\n
        \          </prop>\n           <status>HTTP/1.1 200 OK</status>\n         </propstat>\n
        \      </response>\n     </multistatus>\n   In this example, PROPFIND is invoked
        on the collection resource\n   http://www.example.com/container/, with a propfind
        XML element\n   containing the propname XML element, meaning the name of all\n
        \  properties should be returned.  Since no Depth header is present, it\n
        \  assumes its default value of \"infinity\", meaning the name of the\n   properties
        on the collection and all its descendants should be\n   returned.\n   Consistent
        with the previous example, resource\n   http://www.example.com/container/
        has six properties defined on it:\n   bigbox and author in the \"http://ns.example.com/boxschema/\"\n
        \  namespace, and creationdate, displayname, resourcetype, and\n   supportedlock
        in the \"DAV:\" namespace.\n   The resource http://www.example.com/container/index.html,
        a member of\n   the \"container\" collection, has nine properties defined
        on it, bigbox\n   in the \"http://ns.example.com/boxschema/\" namespace and
        creationdate,\n   displayname, getcontentlength, getcontenttype, getetag,\n
        \  getlastmodified, resourcetype, and supportedlock in the \"DAV:\"\n   namespace.\n
        \  This example also demonstrates the use of XML namespace scoping and\n   the
        default namespace.  Since the \"xmlns\" attribute does not contain\n   a prefix,
        the namespace applies by default to all enclosed elements.\n   Hence, all
        elements that do not explicitly state the namespace to\n   which they belong
        are members of the \"DAV:\" namespace.\n"
      title: 9.1.4.  Example - Using 'propname' to Retrieve All Property Names
    - contents:
      - "9.1.5.  Example - Using So-called 'allprop'\n   Note that 'allprop', despite
        its name, which remains for backward-\n   compatibility, does not return every
        property, but only dead\n   properties and the live properties defined in
        this specification.\n   >>Request\n     PROPFIND /container/ HTTP/1.1\n     Host:
        www.example.com\n     Depth: 1\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <D:propfind xmlns:D=\"DAV:\">\n       <D:allprop/>\n     </D:propfind>\n
        \  >>Response\n     HTTP/1.1 207 Multi-Status\n     Content-Type: application/xml;
        charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\"
        ?>\n     <D:multistatus xmlns:D=\"DAV:\">\n       <D:response>\n         <D:href>/container/</D:href>\n
        \        <D:propstat>\n           <D:prop xmlns:R=\"http://ns.example.com/boxschema/\">\n
        \            <R:bigbox><R:BoxType>Box type A</R:BoxType></R:bigbox>\n             <R:author><R:Name>Hadrian</R:Name></R:author>\n
        \            <D:creationdate>1997-12-01T17:42:21-08:00</D:creationdate>\n
        \            <D:displayname>Example collection</D:displayname>\n             <D:resourcetype><D:collection/></D:resourcetype>\n
        \            <D:supportedlock>\n               <D:lockentry>\n                 <D:lockscope><D:exclusive/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \              <D:lockentry>\n                 <D:lockscope><D:shared/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \            </D:supportedlock>\n           </D:prop>\n           <D:status>HTTP/1.1
        200 OK</D:status>\n         </D:propstat>\n       </D:response>\n       <D:response>\n
        \        <D:href>/container/front.html</D:href>\n         <D:propstat>\n           <D:prop
        xmlns:R=\"http://ns.example.com/boxschema/\">\n             <R:bigbox><R:BoxType>Box
        type B</R:BoxType>\n             </R:bigbox>\n             <D:creationdate>1997-12-01T18:27:21-08:00</D:creationdate>\n
        \            <D:displayname>Example HTML resource</D:displayname>\n             <D:getcontentlength>4525</D:getcontentlength>\n
        \            <D:getcontenttype>text/html</D:getcontenttype>\n             <D:getetag>\"zzyzx\"</D:getetag>\n
        \            <D:getlastmodified\n               >Mon, 12 Jan 1998 09:25:56
        GMT</D:getlastmodified>\n             <D:resourcetype/>\n             <D:supportedlock>\n
        \              <D:lockentry>\n                 <D:lockscope><D:exclusive/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \              <D:lockentry>\n                 <D:lockscope><D:shared/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \            </D:supportedlock>\n           </D:prop>\n           <D:status>HTTP/1.1
        200 OK</D:status>\n         </D:propstat>\n       </D:response>\n     </D:multistatus>\n
        \  In this example, PROPFIND was invoked on the resource\n   http://www.example.com/container/
        with a Depth header of 1, meaning\n   the request applies to the resource
        and its children, and a propfind\n   XML element containing the allprop XML
        element, meaning the request\n   should return the name and value of all the
        dead properties defined\n   on the resources, plus the name and value of all
        the properties\n   defined in this specification.  This example illustrates
        the use of\n   relative references in the 'href' elements of the response.\n
        \  The resource http://www.example.com/container/ has six properties\n   defined
        on it: 'bigbox' and 'author in the\n   \"http://ns.example.com/boxschema/\"
        namespace, DAV:creationdate, DAV:\n   displayname, DAV:resourcetype, and DAV:supportedlock.\n
        \  The last four properties are WebDAV-specific, defined in Section 15.\n
        \  Since GET is not supported on this resource, the get* properties\n   (e.g.,
        DAV:getcontentlength) are not defined on this resource.  The\n   WebDAV-specific
        properties assert that \"container\" was created on\n   December 1, 1997,
        at 5:42:21PM, in a time zone 8 hours west of GMT\n   (DAV:creationdate), has
        a name of \"Example collection\" (DAV:\n   displayname), a collection resource
        type (DAV:resourcetype), and\n   supports exclusive write and shared write
        locks (DAV:supportedlock).\n   The resource http://www.example.com/container/front.html
        has nine\n   properties defined on it:\n   'bigbox' in the \"http://ns.example.com/boxschema/\"
        namespace (another\n   instance of the \"bigbox\" property type), DAV:creationdate,
        DAV:\n   displayname, DAV:getcontentlength, DAV:getcontenttype, DAV:getetag,\n
        \  DAV:getlastmodified, DAV:resourcetype, and DAV:supportedlock.\n   The DAV-specific
        properties assert that \"front.html\" was created on\n   December 1, 1997,
        at 6:27:21PM, in a time zone 8 hours west of GMT\n   (DAV:creationdate), has
        a name of \"Example HTML resource\" (DAV:\n   displayname), a content length
        of 4525 bytes (DAV:getcontentlength),\n   a MIME type of \"text/html\" (DAV:getcontenttype),
        an entity tag of\n   \"zzyzx\" (DAV:getetag), was last modified on Monday,
        January 12, 1998,\n   at 09:25:56 GMT (DAV:getlastmodified), has an empty
        resource type,\n   meaning that it is not a collection (DAV:resourcetype),
        and supports\n   both exclusive write and shared write locks (DAV:supportedlock).\n"
      title: 9.1.5.  Example - Using So-called 'allprop'
    - contents:
      - "9.1.6.  Example - Using 'allprop' with 'include'\n   >>Request\n     PROPFIND
        /mycol/ HTTP/1.1\n     Host: www.example.com\n     Depth: 1\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:propfind xmlns:D=\"DAV:\">\n
        \      <D:allprop/>\n       <D:include>\n         <D:supported-live-property-set/>\n
        \        <D:supported-report-set/>\n       </D:include>\n     </D:propfind>\n
        \  In this example, PROPFIND is executed on the resource\n   http://www.example.com/mycol/
        and its internal member resources.  The\n   client requests the values of
        all live properties defined in this\n   specification, plus all dead properties,
        plus two more live\n   properties defined in [RFC3253].  The response is not
        shown.\n"
      title: 9.1.6.  Example - Using 'allprop' with 'include'
    title: 9.1.  PROPFIND Method
  - contents:
    - "9.2.  PROPPATCH Method\n   The PROPPATCH method processes instructions specified
      in the request\n   body to set and/or remove properties defined on the resource\n
      \  identified by the Request-URI.\n   All DAV-compliant resources MUST support
      the PROPPATCH method and\n   MUST process instructions that are specified using
      the\n   propertyupdate, set, and remove XML elements.  Execution of the\n   directives
      in this method is, of course, subject to access control\n   constraints.  DAV-compliant
      resources SHOULD support the setting of\n   arbitrary dead properties.\n   The
      request message body of a PROPPATCH method MUST contain the\n   propertyupdate
      XML element.\n   Servers MUST process PROPPATCH instructions in document order
      (an\n   exception to the normal rule that ordering is irrelevant).\n   Instructions
      MUST either all be executed or none executed.  Thus, if\n   any error occurs
      during processing, all executed instructions MUST be\n   undone and a proper
      error result returned.  Instruction processing\n   details can be found in the
      definition of the set and remove\n   instructions in Sections 14.23 and 14.26.\n
      \  If a server attempts to make any of the property changes in a\n   PROPPATCH
      request (i.e., the request is not rejected for high-level\n   errors before
      processing the body), the response MUST be a Multi-\n   Status response as described
      in Section 9.2.1.\n   This method is idempotent, but not safe (see Section 9.1
      of\n   [RFC2616]).  Responses to this method MUST NOT be cached.\n"
    - contents:
      - "9.2.1.  Status Codes for Use in 'propstat' Element\n   In PROPPATCH responses,
        information about individual properties is\n   returned inside 'propstat'
        elements (see Section 14.22), each\n   containing an individual 'status' element
        containing information\n   about the properties appearing in it.  The list
        below summarizes the\n   most common status codes used inside 'propstat';
        however, clients\n   should be prepared to handle other 2/3/4/5xx series status
        codes as\n   well.\n   200 (OK) - The property set or change succeeded.  Note
        that if this\n   appears for one property, it appears for every property in
        the\n   response, due to the atomicity of PROPPATCH.\n   403 (Forbidden) -
        The client, for reasons the server chooses not to\n   specify, cannot alter
        one of the properties.\n   403 (Forbidden): The client has attempted to set
        a protected\n   property, such as DAV:getetag.  If returning this error, the
        server\n   SHOULD use the precondition code 'cannot-modify-protected-property'\n
        \  inside the response body.\n   409 (Conflict) - The client has provided
        a value whose semantics are\n   not appropriate for the property.\n   424
        (Failed Dependency) - The property change could not be made\n   because of
        another property change that failed.\n   507 (Insufficient Storage) - The
        server did not have sufficient space\n   to record the property.\n"
      title: 9.2.1.  Status Codes for Use in 'propstat' Element
    - contents:
      - "9.2.2.  Example - PROPPATCH\n   >>Request\n     PROPPATCH /bar.html HTTP/1.1\n
        \    Host: www.example.com\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <D:propertyupdate xmlns:D=\"DAV:\"\n             xmlns:Z=\"http://ns.example.com/standards/z39.50/\">\n
        \      <D:set>\n         <D:prop>\n           <Z:Authors>\n             <Z:Author>Jim
        Whitehead</Z:Author>\n             <Z:Author>Roy Fielding</Z:Author>\n           </Z:Authors>\n
        \        </D:prop>\n       </D:set>\n       <D:remove>\n         <D:prop><Z:Copyright-Owner/></D:prop>\n
        \      </D:remove>\n     </D:propertyupdate>\n   >>Response\n     HTTP/1.1
        207 Multi-Status\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <D:multistatus xmlns:D=\"DAV:\"\n             xmlns:Z=\"http://ns.example.com/standards/z39.50/\">\n
        \      <D:response>\n         <D:href>http://www.example.com/bar.html</D:href>\n
        \        <D:propstat>\n           <D:prop><Z:Authors/></D:prop>\n           <D:status>HTTP/1.1
        424 Failed Dependency</D:status>\n         </D:propstat>\n         <D:propstat>\n
        \          <D:prop><Z:Copyright-Owner/></D:prop>\n           <D:status>HTTP/1.1
        409 Conflict</D:status>\n         </D:propstat>\n         <D:responsedescription>
        Copyright Owner cannot be deleted or\n           altered.</D:responsedescription>\n
        \      </D:response>\n     </D:multistatus>\n   In this example, the client
        requests the server to set the value of\n   the \"Authors\" property in the\n
        \  \"http://ns.example.com/standards/z39.50/\" namespace, and to remove\n
        \  the property \"Copyright-Owner\" in the same namespace.  Since the\n   Copyright-Owner
        property could not be removed, no property\n   modifications occur.  The 424
        (Failed Dependency) status code for the\n   Authors property indicates this
        action would have succeeded if it\n   were not for the conflict with removing
        the Copyright-Owner property.\n"
      title: 9.2.2.  Example - PROPPATCH
    title: 9.2.  PROPPATCH Method
  - contents:
    - "9.3.  MKCOL Method\n   MKCOL creates a new collection resource at the location
      specified by\n   the Request-URI.  If the Request-URI is already mapped to a
      resource,\n   then the MKCOL MUST fail.  During MKCOL processing, a server MUST\n
      \  make the Request-URI an internal member of its parent collection,\n   unless
      the Request-URI is \"/\".  If no such ancestor exists, the\n   method MUST fail.
      \ When the MKCOL operation creates a new collection\n   resource, all ancestors
      MUST already exist, or the method MUST fail\n   with a 409 (Conflict) status
      code.  For example, if a request to\n   create collection /a/b/c/d/ is made,
      and /a/b/c/ does not exist, the\n   request must fail.\n   When MKCOL is invoked
      without a request body, the newly created\n   collection SHOULD have no members.\n
      \  A MKCOL request message may contain a message body.  The precise\n   behavior
      of a MKCOL request when the body is present is undefined,\n   but limited to
      creating collections, members of a collection, bodies\n   of members, and properties
      on the collections or members.  If the\n   server receives a MKCOL request entity
      type it does not support or\n   understand, it MUST respond with a 415 (Unsupported
      Media Type)\n   status code.  If the server decides to reject the request based
      on\n   the presence of an entity or the type of an entity, it should use the\n
      \  415 (Unsupported Media Type) status code.\n   This method is idempotent,
      but not safe (see Section 9.1 of\n   [RFC2616]).  Responses to this method MUST
      NOT be cached.\n"
    - contents:
      - "9.3.1.  MKCOL Status Codes\n   In addition to the general status codes possible,
        the following\n   status codes have specific applicability to MKCOL:\n   201
        (Created) - The collection was created.\n   403 (Forbidden) - This indicates
        at least one of two conditions: 1)\n   the server does not allow the creation
        of collections at the given\n   location in its URL namespace, or 2) the parent
        collection of the\n   Request-URI exists but cannot accept members.\n   405
        (Method Not Allowed) - MKCOL can only be executed on an unmapped\n   URL.\n
        \  409 (Conflict) - A collection cannot be made at the Request-URI until\n
        \  one or more intermediate collections have been created.  The server\n   MUST
        NOT create those intermediate collections automatically.\n   415 (Unsupported
        Media Type) - The server does not support the\n   request body type (although
        bodies are legal on MKCOL requests, since\n   this specification doesn't define
        any, the server is likely not to\n   support any given body type).\n   507
        (Insufficient Storage) - The resource does not have sufficient\n   space to
        record the state of the resource after the execution of this\n   method.\n"
      title: 9.3.1.  MKCOL Status Codes
    - contents:
      - "9.3.2.  Example - MKCOL\n   This example creates a collection called /webdisc/xfiles/
        on the\n   server www.example.com.\n   >>Request\n     MKCOL /webdisc/xfiles/
        HTTP/1.1\n     Host: www.example.com\n   >>Response\n     HTTP/1.1 201 Created\n"
      title: 9.3.2.  Example - MKCOL
    title: 9.3.  MKCOL Method
  - contents:
    - "9.4.  GET, HEAD for Collections\n   The semantics of GET are unchanged when
      applied to a collection,\n   since GET is defined as, \"retrieve whatever information
      (in the form\n   of an entity) is identified by the Request-URI\" [RFC2616].
      \ GET, when\n   applied to a collection, may return the contents of an \"index.html\"\n
      \  resource, a human-readable view of the contents of the collection, or\n   something
      else altogether.  Hence, it is possible that the result of\n   a GET on a collection
      will bear no correlation to the membership of\n   the collection.\n   Similarly,
      since the definition of HEAD is a GET without a response\n   message body, the
      semantics of HEAD are unmodified when applied to\n   collection resources.\n"
    title: 9.4.  GET, HEAD for Collections
  - contents:
    - "9.5.  POST for Collections\n   Since by definition the actual function performed
      by POST is\n   determined by the server and often depends on the particular\n
      \  resource, the behavior of POST when applied to collections cannot be\n   meaningfully
      modified because it is largely undefined.  Thus, the\n   semantics of POST are
      unmodified when applied to a collection.\n"
    title: 9.5.  POST for Collections
  - contents:
    - "9.6.  DELETE Requirements\n   DELETE is defined in [RFC2616], Section 9.7,
      to \"delete the resource\n   identified by the Request-URI\".  However, WebDAV
      changes some DELETE\n   handling requirements.\n   A server processing a successful
      DELETE request:\n      MUST destroy locks rooted on the deleted resource\n      MUST
      remove the mapping from the Request-URI to any resource.\n   Thus, after a successful
      DELETE operation (and in the absence of\n   other actions), a subsequent GET/HEAD/PROPFIND
      request to the target\n   Request-URI MUST return 404 (Not Found).\n"
    - contents:
      - "9.6.1.  DELETE for Collections\n   The DELETE method on a collection MUST
        act as if a \"Depth: infinity\"\n   header was used on it.  A client MUST
        NOT submit a Depth header with\n   a DELETE on a collection with any value
        but infinity.\n   DELETE instructs that the collection specified in the Request-URI
        and\n   all resources identified by its internal member URLs are to be\n   deleted.\n
        \  If any resource identified by a member URL cannot be deleted, then\n   all
        of the member's ancestors MUST NOT be deleted, so as to maintain\n   URL namespace
        consistency.\n   Any headers included with DELETE MUST be applied in processing
        every\n   resource to be deleted.\n   When the DELETE method has completed
        processing, it MUST result in a\n   consistent URL namespace.\n   If an error
        occurs deleting a member resource (a resource other than\n   the resource
        identified in the Request-URI), then the response can be\n   a 207 (Multi-Status).
        \ Multi-Status is used here to indicate which\n   internal resources could
        NOT be deleted, including an error code,\n   which should help the client
        understand which resources caused the\n   failure.  For example, the Multi-Status
        body could include a response\n   with status 423 (Locked) if an internal
        resource was locked.\n   The server MAY return a 4xx status response, rather
        than a 207, if\n   the request failed completely.\n   424 (Failed Dependency)
        status codes SHOULD NOT be in the 207 (Multi-\n   Status) response for DELETE.
        \ They can be safely left out because the\n   client will know that the ancestors
        of a resource could not be\n   deleted when the client receives an error for
        the ancestor's progeny.\n   Additionally, 204 (No Content) errors SHOULD NOT
        be returned in the\n   207 (Multi-Status).  The reason for this prohibition
        is that 204 (No\n   Content) is the default success code.\n"
      title: 9.6.1.  DELETE for Collections
    - contents:
      - "9.6.2.  Example - DELETE\n   >>Request\n     DELETE  /container/ HTTP/1.1\n
        \    Host: www.example.com\n   >>Response\n     HTTP/1.1 207 Multi-Status\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     Content-Length:
        xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <d:multistatus
        xmlns:d=\"DAV:\">\n       <d:response>\n         <d:href>http://www.example.com/container/resource3</d:href>\n
        \        <d:status>HTTP/1.1 423 Locked</d:status>\n         <d:error><d:lock-token-submitted/></d:error>\n
        \      </d:response>\n     </d:multistatus>\n   In this example, the attempt
        to delete\n   http://www.example.com/container/resource3 failed because it
        is\n   locked, and no lock token was submitted with the request.\n   Consequently,
        the attempt to delete http://www.example.com/container/\n   also failed.  Thus,
        the client knows that the attempt to delete\n   http://www.example.com/container/
        must have also failed since the\n   parent cannot be deleted unless its child
        has also been deleted.\n   Even though a Depth header has not been included,
        a depth of infinity\n   is assumed because the method is on a collection.\n"
      title: 9.6.2.  Example - DELETE
    title: 9.6.  DELETE Requirements
  - contents:
    - '9.7.  PUT Requirements

      '
    - contents:
      - "9.7.1.  PUT for Non-Collection Resources\n   A PUT performed on an existing
        resource replaces the GET response\n   entity of the resource.  Properties
        defined on the resource may be\n   recomputed during PUT processing but are
        not otherwise affected.  For\n   example, if a server recognizes the content
        type of the request body,\n   it may be able to automatically extract information
        that could be\n   profitably exposed as properties.\n   A PUT that would result
        in the creation of a resource without an\n   appropriately scoped parent collection
        MUST fail with a 409\n   (Conflict).\n   A PUT request allows a client to
        indicate what media type an entity\n   body has, and whether it should change
        if overwritten.  Thus, a\n   client SHOULD provide a Content-Type for a new
        resource if any is\n   known.  If the client does not provide a Content-Type
        for a new\n   resource, the server MAY create a resource with no Content-Type\n
        \  assigned, or it MAY attempt to assign a Content-Type.\n   Note that although
        a recipient ought generally to treat metadata\n   supplied with an HTTP request
        as authoritative, in practice there's\n   no guarantee that a server will
        accept client-supplied metadata\n   (e.g., any request header beginning with
        \"Content-\").  Many servers\n   do not allow configuring the Content-Type
        on a per-resource basis in\n   the first place.  Thus, clients can't always
        rely on the ability to\n   directly influence the content type by including
        a Content-Type\n   request header.\n"
      title: 9.7.1.  PUT for Non-Collection Resources
    - contents:
      - "9.7.2.  PUT for Collections\n   This specification does not define the behavior
        of the PUT method for\n   existing collections.  A PUT request to an existing
        collection MAY be\n   treated as an error (405 Method Not Allowed).\n   The
        MKCOL method is defined to create collections.\n"
      title: 9.7.2.  PUT for Collections
    title: 9.7.  PUT Requirements
  - contents:
    - "9.8.  COPY Method\n   The COPY method creates a duplicate of the source resource
      identified\n   by the Request-URI, in the destination resource identified by
      the URI\n   in the Destination header.  The Destination header MUST be present.\n
      \  The exact behavior of the COPY method depends on the type of the\n   source
      resource.\n   All WebDAV-compliant resources MUST support the COPY method.\n
      \  However, support for the COPY method does not guarantee the ability\n   to
      copy a resource.  For example, separate programs may control\n   resources on
      the same server.  As a result, it may not be possible to\n   copy a resource
      to a location that appears to be on the same server.\n   This method is idempotent,
      but not safe (see Section 9.1 of\n   [RFC2616]).  Responses to this method MUST
      NOT be cached.\n"
    - contents:
      - "9.8.1.  COPY for Non-collection Resources\n   When the source resource is
        not a collection, the result of the COPY\n   method is the creation of a new
        resource at the destination whose\n   state and behavior match that of the
        source resource as closely as\n   possible.  Since the environment at the
        destination may be different\n   than at the source due to factors outside
        the scope of control of the\n   server, such as the absence of resources required
        for correct\n   operation, it may not be possible to completely duplicate
        the\n   behavior of the resource at the destination.  Subsequent alterations\n
        \  to the destination resource will not modify the source resource.\n   Subsequent
        alterations to the source resource will not modify the\n   destination resource.\n"
      title: 9.8.1.  COPY for Non-collection Resources
    - contents:
      - "9.8.2.  COPY for Properties\n   After a successful COPY invocation, all dead
        properties on the source\n   resource SHOULD be duplicated on the destination
        resource.  Live\n   properties described in this document SHOULD be duplicated
        as\n   identically behaving live properties at the destination resource, but\n
        \  not necessarily with the same values.  Servers SHOULD NOT convert\n   live
        properties into dead properties on the destination resource,\n   because clients
        may then draw incorrect conclusions about the state\n   or functionality of
        a resource.  Note that some live properties are\n   defined such that the
        absence of the property has a specific meaning\n   (e.g., a flag with one
        meaning if present, and the opposite if\n   absent), and in these cases, a
        successful COPY might result in the\n   property being reported as \"Not Found\"
        in subsequent requests.\n   When the destination is an unmapped URL, a COPY
        operation creates a\n   new resource much like a PUT operation does.  Live
        properties that\n   are related to resource creation (such as DAV:creationdate)
        should\n   have their values set accordingly.\n"
      title: 9.8.2.  COPY for Properties
    - contents:
      - "9.8.3.  COPY for Collections\n   The COPY method on a collection without
        a Depth header MUST act as if\n   a Depth header with value \"infinity\" was
        included.  A client may\n   submit a Depth header on a COPY on a collection
        with a value of \"0\"\n   or \"infinity\".  Servers MUST support the \"0\"
        and \"infinity\" Depth\n   header behaviors on WebDAV-compliant resources.\n
        \  An infinite-depth COPY instructs that the collection resource\n   identified
        by the Request-URI is to be copied to the location\n   identified by the URI
        in the Destination header, and all its internal\n   member resources are to
        be copied to a location relative to it,\n   recursively through all levels
        of the collection hierarchy.  Note\n   that an infinite-depth COPY of /A/
        into /A/B/ could lead to infinite\n   recursion if not handled correctly.\n
        \  A COPY of \"Depth: 0\" only instructs that the collection and its\n   properties,
        but not resources identified by its internal member URLs,\n   are to be copied.\n
        \  Any headers included with a COPY MUST be applied in processing every\n
        \  resource to be copied with the exception of the Destination header.\n   The
        Destination header only specifies the destination URI for the\n   Request-URI.
        \ When applied to members of the collection identified by\n   the Request-URI,
        the value of Destination is to be modified to\n   reflect the current location
        in the hierarchy.  So, if the Request-\n   URI is /a/ with Host header value
        http://example.com/ and the\n   Destination is http://example.com/b/, then
        when\n   http://example.com/a/c/d is processed, it must use a Destination
        of\n   http://example.com/b/c/d.\n   When the COPY method has completed processing,
        it MUST have created a\n   consistent URL namespace at the destination (see
        Section 5.1 for the\n   definition of namespace consistency).  However, if
        an error occurs\n   while copying an internal collection, the server MUST
        NOT copy any\n   resources identified by members of this collection (i.e.,
        the server\n   must skip this subtree), as this would create an inconsistent\n
        \  namespace.  After detecting an error, the COPY operation SHOULD try\n   to
        finish as much of the original copy operation as possible (i.e.,\n   the server
        should still attempt to copy other subtrees and their\n   members that are
        not descendants of an error-causing collection).\n   So, for example, if an
        infinite-depth copy operation is performed on\n   collection /a/, which contains
        collections /a/b/ and /a/c/, and an\n   error occurs copying /a/b/, an attempt
        should still be made to copy\n   /a/c/.  Similarly, after encountering an
        error copying a non-\n   collection resource as part of an infinite-depth
        copy, the server\n   SHOULD try to finish as much of the original copy operation
        as\n   possible.\n   If an error in executing the COPY method occurs with
        a resource other\n   than the resource identified in the Request-URI, then
        the response\n   MUST be a 207 (Multi-Status), and the URL of the resource
        causing the\n   failure MUST appear with the specific error.\n   The 424 (Failed
        Dependency) status code SHOULD NOT be returned in the\n   207 (Multi-Status)
        response from a COPY method.  These responses can\n   be safely omitted because
        the client will know that the progeny of a\n   resource could not be copied
        when the client receives an error for\n   the parent.  Additionally, 201 (Created)/204
        (No Content) status\n   codes SHOULD NOT be returned as values in 207 (Multi-Status)\n
        \  responses from COPY methods.  They, too, can be safely omitted\n   because
        they are the default success codes.\n"
      title: 9.8.3.  COPY for Collections
    - contents:
      - "9.8.4.  COPY and Overwriting Destination Resources\n   If a COPY request
        has an Overwrite header with a value of \"F\", and a\n   resource exists at
        the Destination URL, the server MUST fail the\n   request.\n   When a server
        executes a COPY request and overwrites a destination\n   resource, the exact
        behavior MAY depend on many factors, including\n   WebDAV extension capabilities
        (see particularly [RFC3253]).  For\n   example, when an ordinary resource
        is overwritten, the server could\n   delete the target resource before doing
        the copy, or could do an in-\n   place overwrite to preserve live properties.\n
        \  When a collection is overwritten, the membership of the destination\n   collection
        after the successful COPY request MUST be the same\n   membership as the source
        collection immediately before the COPY.\n   Thus, merging the membership of
        the source and destination\n   collections together in the destination is
        not a compliant behavior.\n   In general, if clients require the state of
        the destination URL to be\n   wiped out prior to a COPY (e.g., to force live
        properties to be\n   reset), then the client could send a DELETE to the destination
        before\n   the COPY request to ensure this reset.\n"
      title: 9.8.4.  COPY and Overwriting Destination Resources
    - contents:
      - "9.8.5.  Status Codes\n   In addition to the general status codes possible,
        the following\n   status codes have specific applicability to COPY:\n   201
        (Created) - The source resource was successfully copied.  The\n   COPY operation
        resulted in the creation of a new resource.\n   204 (No Content) - The source
        resource was successfully copied to a\n   preexisting destination resource.\n
        \  207 (Multi-Status) - Multiple resources were to be affected by the\n   COPY,
        but errors on some of them prevented the operation from taking\n   place.
        \ Specific error messages, together with the most appropriate\n   of the source
        and destination URLs, appear in the body of the multi-\n   status response.
        \ For example, if a destination resource was locked\n   and could not be overwritten,
        then the destination resource URL\n   appears with the 423 (Locked) status.\n
        \  403 (Forbidden) - The operation is forbidden.  A special case for\n   COPY
        could be that the source and destination resources are the same\n   resource.\n
        \  409 (Conflict) - A resource cannot be created at the destination\n   until
        one or more intermediate collections have been created.  The\n   server MUST
        NOT create those intermediate collections automatically.\n   412 (Precondition
        Failed) - A precondition header check failed, e.g.,\n   the Overwrite header
        is \"F\" and the destination URL is already mapped\n   to a resource.\n   423
        (Locked) - The destination resource, or resource within the\n   destination
        collection, was locked.  This response SHOULD contain the\n   'lock-token-submitted'
        precondition element.\n   502 (Bad Gateway) - This may occur when the destination
        is on another\n   server, repository, or URL namespace.  Either the source
        namespace\n   does not support copying to the destination namespace, or the\n
        \  destination namespace refuses to accept the resource.  The client may\n
        \  wish to try GET/PUT and PROPFIND/PROPPATCH instead.\n   507 (Insufficient
        Storage) - The destination resource does not have\n   sufficient space to
        record the state of the resource after the\n   execution of this method.\n"
      title: 9.8.5.  Status Codes
    - contents:
      - "9.8.6.  Example - COPY with Overwrite\n   This example shows resource\n   http://www.example.com/~fielding/index.html
        being copied to the\n   location http://www.example.com/users/f/fielding/index.html.
        \ The 204\n   (No Content) status code indicates that the existing resource
        at the\n   destination was overwritten.\n   >>Request\n     COPY /~fielding/index.html
        HTTP/1.1\n     Host: www.example.com\n     Destination: http://www.example.com/users/f/fielding/index.html\n
        \  >>Response\n     HTTP/1.1 204 No Content\n"
      title: 9.8.6.  Example - COPY with Overwrite
    - contents:
      - "9.8.7.  Example - COPY with No Overwrite\n   The following example shows
        the same copy operation being performed,\n   but with the Overwrite header
        set to \"F.\" A response of 412\n   (Precondition Failed) is returned because
        the destination URL is\n   already mapped to a resource.\n   >>Request\n     COPY
        /~fielding/index.html HTTP/1.1\n     Host: www.example.com\n     Destination:
        http://www.example.com/users/f/fielding/index.html\n     Overwrite: F\n   >>Response\n
        \    HTTP/1.1 412 Precondition Failed\n"
      title: 9.8.7.  Example - COPY with No Overwrite
    - contents:
      - "9.8.8.  Example - COPY of a Collection\n   >>Request\n     COPY /container/
        HTTP/1.1\n     Host: www.example.com\n     Destination: http://www.example.com/othercontainer/\n
        \    Depth: infinity\n   >>Response\n     HTTP/1.1 207 Multi-Status\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <d:multistatus xmlns:d=\"DAV:\">\n
        \      <d:response>\n         <d:href>http://www.example.com/othercontainer/R2/</d:href>\n
        \        <d:status>HTTP/1.1 423 Locked</d:status>\n         <d:error><d:lock-token-submitted/></d:error>\n
        \      </d:response>\n     </d:multistatus>\n   The Depth header is unnecessary
        as the default behavior of COPY on a\n   collection is to act as if a \"Depth:
        infinity\" header had been\n   submitted.  In this example, most of the resources,
        along with the\n   collection, were copied successfully.  However, the collection
        R2\n   failed because the destination R2 is locked.  Because there was an\n
        \  error copying R2, none of R2's members were copied.  However, no\n   errors
        were listed for those members due to the error minimization\n   rules.\n"
      title: 9.8.8.  Example - COPY of a Collection
    title: 9.8.  COPY Method
  - contents:
    - "9.9.  MOVE Method\n   The MOVE operation on a non-collection resource is the
      logical\n   equivalent of a copy (COPY), followed by consistency maintenance\n
      \  processing, followed by a delete of the source, where all three\n   actions
      are performed in a single operation.  The consistency\n   maintenance step allows
      the server to perform updates caused by the\n   move, such as updating all URLs,
      other than the Request-URI that\n   identifies the source resource, to point
      to the new destination\n   resource.\n   The Destination header MUST be present
      on all MOVE methods and MUST\n   follow all COPY requirements for the COPY part
      of the MOVE method.\n   All WebDAV-compliant resources MUST support the MOVE
      method.\n   Support for the MOVE method does not guarantee the ability to move
      a\n   resource to a particular destination.  For example, separate programs\n
      \  may actually control different sets of resources on the same server.\n   Therefore,
      it may not be possible to move a resource within a\n   namespace that appears
      to belong to the same server.\n   If a resource exists at the destination, the
      destination resource\n   will be deleted as a side-effect of the MOVE operation,
      subject to\n   the restrictions of the Overwrite header.\n   This method is
      idempotent, but not safe (see Section 9.1 of\n   [RFC2616]).  Responses to this
      method MUST NOT be cached.\n"
    - contents:
      - "9.9.1.  MOVE for Properties\n   Live properties described in this document
        SHOULD be moved along with\n   the resource, such that the resource has identically
        behaving live\n   properties at the destination resource, but not necessarily
        with the\n   same values.  Note that some live properties are defined such
        that\n   the absence of the property has a specific meaning (e.g., a flag
        with\n   one meaning if present, and the opposite if absent), and in these\n
        \  cases, a successful MOVE might result in the property being reported\n
        \  as \"Not Found\" in subsequent requests.  If the live properties will\n
        \  not work the same way at the destination, the server MAY fail the\n   request.\n
        \  MOVE is frequently used by clients to rename a file without changing\n
        \  its parent collection, so it's not appropriate to reset all live\n   properties
        that are set at resource creation.  For example, the DAV:\n   creationdate
        property value SHOULD remain the same after a MOVE.\n   Dead properties MUST
        be moved along with the resource.\n"
      title: 9.9.1.  MOVE for Properties
    - contents:
      - "9.9.2.  MOVE for Collections\n   A MOVE with \"Depth: infinity\" instructs
        that the collection\n   identified by the Request-URI be moved to the address
        specified in\n   the Destination header, and all resources identified by its
        internal\n   member URLs are to be moved to locations relative to it, recursively\n
        \  through all levels of the collection hierarchy.\n   The MOVE method on
        a collection MUST act as if a \"Depth: infinity\"\n   header was used on it.
        \ A client MUST NOT submit a Depth header on a\n   MOVE on a collection with
        any value but \"infinity\".\n   Any headers included with MOVE MUST be applied
        in processing every\n   resource to be moved with the exception of the Destination
        header.\n   The behavior of the Destination header is the same as given for
        COPY\n   on collections.\n   When the MOVE method has completed processing,
        it MUST have created a\n   consistent URL namespace at both the source and
        destination (see\n   Section 5.1 for the definition of namespace consistency).
        \ However,\n   if an error occurs while moving an internal collection, the
        server\n   MUST NOT move any resources identified by members of the failed\n
        \  collection (i.e., the server must skip the error-causing subtree), as\n
        \  this would create an inconsistent namespace.  In this case, after\n   detecting
        the error, the move operation SHOULD try to finish as much\n   of the original
        move as possible (i.e., the server should still\n   attempt to move other
        subtrees and the resources identified by their\n   members that are not descendants
        of an error-causing collection).\n   So, for example, if an infinite-depth
        move is performed on collection\n   /a/, which contains collections /a/b/
        and /a/c/, and an error occurs\n   moving /a/b/, an attempt should still be
        made to try moving /a/c/.\n   Similarly, after encountering an error moving
        a non-collection\n   resource as part of an infinite-depth move, the server
        SHOULD try to\n   finish as much of the original move operation as possible.\n
        \  If an error occurs with a resource other than the resource identified\n
        \  in the Request-URI, then the response MUST be a 207 (Multi-Status),\n   and
        the errored resource's URL MUST appear with the specific error.\n   The 424
        (Failed Dependency) status code SHOULD NOT be returned in the\n   207 (Multi-Status)
        response from a MOVE method.  These errors can be\n   safely omitted because
        the client will know that the progeny of a\n   resource could not be moved
        when the client receives an error for the\n   parent.  Additionally, 201 (Created)/204
        (No Content) responses\n   SHOULD NOT be returned as values in 207 (Multi-Status)
        responses from\n   a MOVE.  These responses can be safely omitted because
        they are the\n   default success codes.\n"
      title: 9.9.2.  MOVE for Collections
    - contents:
      - "9.9.3.  MOVE and the Overwrite Header\n   If a resource exists at the destination
        and the Overwrite header is\n   \"T\", then prior to performing the move,
        the server MUST perform a\n   DELETE with \"Depth: infinity\" on the destination
        resource.  If the\n   Overwrite header is set to \"F\", then the operation
        will fail.\n"
      title: 9.9.3.  MOVE and the Overwrite Header
    - contents:
      - "9.9.4.  Status Codes\n   In addition to the general status codes possible,
        the following\n   status codes have specific applicability to MOVE:\n   201
        (Created) - The source resource was successfully moved, and a new\n   URL
        mapping was created at the destination.\n   204 (No Content) - The source
        resource was successfully moved to a\n   URL that was already mapped.\n   207
        (Multi-Status) - Multiple resources were to be affected by the\n   MOVE, but
        errors on some of them prevented the operation from taking\n   place.  Specific
        error messages, together with the most appropriate\n   of the source and destination
        URLs, appear in the body of the multi-\n   status response.  For example,
        if a source resource was locked and\n   could not be moved, then the source
        resource URL appears with the 423\n   (Locked) status.\n   403 (Forbidden)
        - Among many possible reasons for forbidding a MOVE\n   operation, this status
        code is recommended for use when the source\n   and destination resources
        are the same.\n   409 (Conflict) - A resource cannot be created at the destination\n
        \  until one or more intermediate collections have been created.  The\n   server
        MUST NOT create those intermediate collections automatically.\n   Or, the
        server was unable to preserve the behavior of the live\n   properties and
        still move the resource to the destination (see\n   'preserved-live-properties'
        postcondition).\n   412 (Precondition Failed) - A condition header failed.
        \ Specific to\n   MOVE, this could mean that the Overwrite header is \"F\"
        and the\n   destination URL is already mapped to a resource.\n   423 (Locked)
        - The source or the destination resource, the source or\n   destination resource
        parent, or some resource within the source or\n   destination collection,
        was locked.  This response SHOULD contain the\n   'lock-token-submitted' precondition
        element.\n   502 (Bad Gateway) - This may occur when the destination is on
        another\n   server and the destination server refuses to accept the resource.\n
        \  This could also occur when the destination is on another sub-section\n
        \  of the same server namespace.\n"
      title: 9.9.4.  Status Codes
    - contents:
      - "9.9.5.  Example - MOVE of a Non-Collection\n   This example shows resource\n
        \  http://www.example.com/~fielding/index.html being moved to the\n   location
        http://www.example.com/users/f/fielding/index.html.  The\n   contents of the
        destination resource would have been overwritten if\n   the destination URL
        was already mapped to a resource.  In this case,\n   since there was nothing
        at the destination resource, the response\n   code is 201 (Created).\n   >>Request\n
        \    MOVE /~fielding/index.html HTTP/1.1\n     Host: www.example.com\n     Destination:
        http://www.example/users/f/fielding/index.html\n   >>Response\n     HTTP/1.1
        201 Created\n     Location: http://www.example.com/users/f/fielding/index.html\n"
      title: 9.9.5.  Example - MOVE of a Non-Collection
    - contents:
      - "9.9.6.  Example - MOVE of a Collection\n   >>Request\n     MOVE /container/
        HTTP/1.1\n     Host: www.example.com\n     Destination: http://www.example.com/othercontainer/\n
        \    Overwrite: F\n     If: (<urn:uuid:fe184f2e-6eec-41d0-c765-01adc56e6bb4>)\n
        \       (<urn:uuid:e454f3f3-acdc-452a-56c7-00a5c91e4b77>)\n   >>Response\n
        \    HTTP/1.1 207 Multi-Status\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <d:multistatus xmlns:d='DAV:'>\n       <d:response>\n         <d:href>http://www.example.com/othercontainer/C2/</d:href>\n
        \        <d:status>HTTP/1.1 423 Locked</d:status>\n         <d:error><d:lock-token-submitted/></d:error>\n
        \      </d:response>\n     </d:multistatus>\n   In this example, the client
        has submitted a number of lock tokens\n   with the request.  A lock token
        will need to be submitted for every\n   resource, both source and destination,
        anywhere in the scope of the\n   method, that is locked.  In this case, the
        proper lock token was not\n   submitted for the destination\n   http://www.example.com/othercontainer/C2/.
        \ This means that the\n   resource /container/C2/ could not be moved.  Because
        there was an\n   error moving /container/C2/, none of /container/C2's members
        were\n   moved.  However, no errors were listed for those members due to the\n
        \  error minimization rules.  User agent authentication has previously\n   occurred
        via a mechanism outside the scope of the HTTP protocol, in\n   an underlying
        transport layer.\n"
      title: 9.9.6.  Example - MOVE of a Collection
    title: 9.9.  MOVE Method
  - contents:
    - "9.10.  LOCK Method\n   The following sections describe the LOCK method, which
      is used to\n   take out a lock of any access type and to refresh an existing
      lock.\n   These sections on the LOCK method describe only those semantics that\n
      \  are specific to the LOCK method and are independent of the access\n   type
      of the lock being requested.\n   Any resource that supports the LOCK method
      MUST, at minimum, support\n   the XML request and response formats defined herein.\n
      \  This method is neither idempotent nor safe (see Section 9.1 of\n   [RFC2616]).
      \ Responses to this method MUST NOT be cached.\n"
    - contents:
      - "9.10.1.  Creating a Lock on an Existing Resource\n   A LOCK request to an
        existing resource will create a lock on the\n   resource identified by the
        Request-URI, provided the resource is not\n   already locked with a conflicting
        lock.  The resource identified in\n   the Request-URI becomes the root of
        the lock.  LOCK method requests\n   to create a new lock MUST have an XML
        request body.  The server MUST\n   preserve the information provided by the
        client in the 'owner'\n   element in the LOCK request.  The LOCK request MAY
        have a Timeout\n   header.\n   When a new lock is created, the LOCK response:\n
        \  o  MUST contain a body with the value of the DAV:lockdiscovery\n      property
        in a prop XML element.  This MUST contain the full\n      information about
        the lock just granted, while information about\n      other (shared) locks
        is OPTIONAL.\n   o  MUST include the Lock-Token response header with the token\n
        \     associated with the new lock.\n"
      title: 9.10.1.  Creating a Lock on an Existing Resource
    - contents:
      - "9.10.2.  Refreshing Locks\n   A lock is refreshed by sending a LOCK request
        to the URL of a\n   resource within the scope of the lock.  This request MUST
        NOT have a\n   body and it MUST specify which lock to refresh by using the
        'If'\n   header with a single lock token (only one lock may be refreshed at
        a\n   time).  The request MAY contain a Timeout header, which a server MAY\n
        \  accept to change the duration remaining on the lock to the new value.\n
        \  A server MUST ignore the Depth header on a LOCK refresh.\n   If the resource
        has other (shared) locks, those locks are unaffected\n   by a lock refresh.
        \ Additionally, those locks do not prevent the\n   named lock from being refreshed.\n
        \  The Lock-Token header is not returned in the response for a\n   successful
        refresh LOCK request, but the LOCK response body MUST\n   contain the new
        value for the DAV:lockdiscovery property.\n"
      title: 9.10.2.  Refreshing Locks
    - contents:
      - "9.10.3.  Depth and Locking\n   The Depth header may be used with the LOCK
        method.  Values other than\n   0 or infinity MUST NOT be used with the Depth
        header on a LOCK\n   method.  All resources that support the LOCK method MUST
        support the\n   Depth header.\n   A Depth header of value 0 means to just
        lock the resource specified\n   by the Request-URI.\n   If the Depth header
        is set to infinity, then the resource specified\n   in the Request-URI along
        with all its members, all the way down the\n   hierarchy, are to be locked.
        \ A successful result MUST return a\n   single lock token.  Similarly, if
        an UNLOCK is successfully executed\n   on this token, all associated resources
        are unlocked.  Hence, partial\n   success is not an option for LOCK or UNLOCK.
        \ Either the entire\n   hierarchy is locked or no resources are locked.\n
        \  If the lock cannot be granted to all resources, the server MUST\n   return
        a Multi-Status response with a 'response' element for at least\n   one resource
        that prevented the lock from being granted, along with a\n   suitable status
        code for that failure (e.g., 403 (Forbidden) or 423\n   (Locked)).  Additionally,
        if the resource causing the failure was not\n   the resource requested, then
        the server SHOULD include a 'response'\n   element for the Request-URI as
        well, with a 'status' element\n   containing 424 Failed Dependency.\n   If
        no Depth header is submitted on a LOCK request, then the request\n   MUST
        act as if a \"Depth:infinity\" had been submitted.\n"
      title: 9.10.3.  Depth and Locking
    - contents:
      - "9.10.4.  Locking Unmapped URLs\n   A successful LOCK method MUST result in
        the creation of an empty\n   resource that is locked (and that is not a collection)
        when a\n   resource did not previously exist at that URL.  Later on, the lock\n
        \  may go away but the empty resource remains.  Empty resources MUST\n   then
        appear in PROPFIND responses including that URL in the response\n   scope.
        \ A server MUST respond successfully to a GET request to an\n   empty resource,
        either by using a 204 No Content response, or by\n   using 200 OK with a Content-Length
        header indicating zero length\n"
      title: 9.10.4.  Locking Unmapped URLs
    - contents:
      - "9.10.5.  Lock Compatibility Table\n   The table below describes the behavior
        that occurs when a lock\n   request is made on a resource.\n     +--------------------------+----------------+-------------------+\n
        \    | Current State            | Shared Lock OK | Exclusive Lock OK |\n     +--------------------------+----------------+-------------------+\n
        \    | None                     | True           | True              |\n     |
        Shared Lock              | True           | False             |\n     | Exclusive
        Lock           | False          | False*            |\n     +--------------------------+----------------+-------------------+\n
        \  Legend: True = lock may be granted.  False = lock MUST NOT be\n   granted.
        *=It is illegal for a principal to request the same lock\n   twice.\n   The
        current lock state of a resource is given in the leftmost column,\n   and
        lock requests are listed in the first row.  The intersection of a\n   row
        and column gives the result of a lock request.  For example, if a\n   shared
        lock is held on a resource, and an exclusive lock is\n   requested, the table
        entry is \"false\", indicating that the lock must\n   not be granted.\n"
      title: 9.10.5.  Lock Compatibility Table
    - contents:
      - "9.10.6.  LOCK Responses\n   In addition to the general status codes possible,
        the following\n   status codes have specific applicability to LOCK:\n   200
        (OK) - The LOCK request succeeded and the value of the DAV:\n   lockdiscovery
        property is included in the response body.\n   201 (Created) - The LOCK request
        was to an unmapped URL, the request\n   succeeded and resulted in the creation
        of a new resource, and the\n   value of the DAV:lockdiscovery property is
        included in the response\n   body.\n   409 (Conflict) - A resource cannot
        be created at the destination\n   until one or more intermediate collections
        have been created.  The\n   server MUST NOT create those intermediate collections
        automatically.\n   423 (Locked), potentially with 'no-conflicting-lock' precondition\n
        \  code - There is already a lock on the resource that is not compatible\n
        \  with the requested lock (see lock compatibility table above).\n   412 (Precondition
        Failed), with 'lock-token-matches-request-uri'\n   precondition code - The
        LOCK request was made with an If header,\n   indicating that the client wishes
        to refresh the given lock.\n   However, the Request-URI did not fall within
        the scope of the lock\n   identified by the token.  The lock may have a scope
        that does not\n   include the Request-URI, or the lock could have disappeared,
        or the\n   token may be invalid.\n"
      title: 9.10.6.  LOCK Responses
    - contents:
      - "9.10.7.  Example - Simple Lock Request\n   >>Request\n     LOCK /workspace/webdav/proposal.doc
        HTTP/1.1\n     Host: example.com\n     Timeout: Infinite, Second-4100000000\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     Content-Length:
        xxxx\n     Authorization: Digest username=\"ejw\",\n       realm=\"ejw@example.com\",
        nonce=\"...\",\n       uri=\"/workspace/webdav/proposal.doc\",\n       response=\"...\",
        opaque=\"...\"\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:lockinfo
        xmlns:D='DAV:'>\n       <D:lockscope><D:exclusive/></D:lockscope>\n       <D:locktype><D:write/></D:locktype>\n
        \      <D:owner>\n         <D:href>http://example.org/~ejw/contact.html</D:href>\n
        \      </D:owner>\n     </D:lockinfo>\n   >>Response\n     HTTP/1.1 200 OK\n
        \    Lock-Token: <urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:prop xmlns:D=\"DAV:\">\n       <D:lockdiscovery>\n
        \        <D:activelock>\n           <D:locktype><D:write/></D:locktype>\n
        \          <D:lockscope><D:exclusive/></D:lockscope>\n           <D:depth>infinity</D:depth>\n
        \          <D:owner>\n             <D:href>http://example.org/~ejw/contact.html</D:href>\n
        \          </D:owner>\n           <D:timeout>Second-604800</D:timeout>\n           <D:locktoken>\n
        \            <D:href\n             >urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href>\n
        \          </D:locktoken>\n           <D:lockroot>\n             <D:href\n
        \            >http://example.com/workspace/webdav/proposal.doc</D:href>\n
        \          </D:lockroot>\n         </D:activelock>\n       </D:lockdiscovery>\n
        \    </D:prop>\n   This example shows the successful creation of an exclusive
        write lock\n   on resource http://example.com/workspace/webdav/proposal.doc.
        \ The\n   resource http://example.org/~ejw/contact.html contains contact\n
        \  information for the creator of the lock.  The server has an activity-\n
        \  based timeout policy in place on this resource, which causes the lock\n
        \  to automatically be removed after 1 week (604800 seconds).  Note that\n
        \  the nonce, response, and opaque fields have not been calculated in\n   the
        Authorization request header.\n"
      title: 9.10.7.  Example - Simple Lock Request
    - contents:
      - "9.10.8.  Example - Refreshing a Write Lock\n   >>Request\n     LOCK /workspace/webdav/proposal.doc
        HTTP/1.1\n     Host: example.com\n     Timeout: Infinite, Second-4100000000\n
        \    If: (<urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>)\n     Authorization:
        Digest username=\"ejw\",\n       realm=\"ejw@example.com\", nonce=\"...\",\n
        \      uri=\"/workspace/webdav/proposal.doc\",\n       response=\"...\", opaque=\"...\"\n
        \  >>Response\n     HTTP/1.1 200 OK\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \    <D:prop xmlns:D=\"DAV:\">\n       <D:lockdiscovery>\n         <D:activelock>\n
        \          <D:locktype><D:write/></D:locktype>\n           <D:lockscope><D:exclusive/></D:lockscope>\n
        \          <D:depth>infinity</D:depth>\n           <D:owner>\n             <D:href>http://example.org/~ejw/contact.html</D:href>\n
        \          </D:owner>\n           <D:timeout>Second-604800</D:timeout>\n           <D:locktoken>\n
        \            <D:href\n             >urn:uuid:e71d4fae-5dec-22d6-fea5-00a0c91e6be4</D:href>\n
        \          </D:locktoken>\n           <D:lockroot>\n             <D:href\n
        \            >http://example.com/workspace/webdav/proposal.doc</D:href>\n
        \          </D:lockroot>\n         </D:activelock>\n       </D:lockdiscovery>\n
        \    </D:prop>\n   This request would refresh the lock, attempting to reset
        the timeout\n   to the new value specified in the timeout header.  Notice
        that the\n   client asked for an infinite time out but the server choose to
        ignore\n   the request.  In this example, the nonce, response, and opaque
        fields\n   have not been calculated in the Authorization request header.\n"
      title: 9.10.8.  Example - Refreshing a Write Lock
    - contents:
      - "9.10.9.  Example - Multi-Resource Lock Request\n   >>Request\n     LOCK /webdav/
        HTTP/1.1\n     Host: example.com\n     Timeout: Infinite, Second-4100000000\n
        \    Depth: infinity\n     Content-Type: application/xml; charset=\"utf-8\"\n
        \    Content-Length: xxxx\n     Authorization: Digest username=\"ejw\",\n
        \      realm=\"ejw@example.com\", nonce=\"...\",\n       uri=\"/workspace/webdav/proposal.doc\",\n
        \      response=\"...\", opaque=\"...\"\n     <?xml version=\"1.0\" encoding=\"utf-8\"
        ?>\n     <D:lockinfo xmlns:D=\"DAV:\">\n       <D:locktype><D:write/></D:locktype>\n
        \      <D:lockscope><D:exclusive/></D:lockscope>\n       <D:owner>\n         <D:href>http://example.org/~ejw/contact.html</D:href>\n
        \      </D:owner>\n     </D:lockinfo>\n   >>Response\n     HTTP/1.1 207 Multi-Status\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     Content-Length:
        xxxx\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus
        xmlns:D=\"DAV:\">\n       <D:response>\n         <D:href>http://example.com/webdav/secret</D:href>\n
        \        <D:status>HTTP/1.1 403 Forbidden</D:status>\n       </D:response>\n
        \      <D:response>\n         <D:href>http://example.com/webdav/</D:href>\n
        \        <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n       </D:response>\n
        \    </D:multistatus>\n   This example shows a request for an exclusive write
        lock on a\n   collection and all its children.  In this request, the client
        has\n   specified that it desires an infinite-length lock, if available,\n
        \  otherwise a timeout of 4.1 billion seconds, if available.  The\n   request
        entity body contains the contact information for the\n   principal taking
        out the lock -- in this case, a Web page URL.\n   The error is a 403 (Forbidden)
        response on the resource\n   http://example.com/webdav/secret.  Because this
        resource could not be\n   locked, none of the resources were locked.  Note
        also that the a\n   'response' element for the Request-URI itself has been
        included as\n   required.\n   In this example, the nonce, response, and opaque
        fields have not been\n   calculated in the Authorization request header.\n"
      title: 9.10.9.  Example - Multi-Resource Lock Request
    title: 9.10.  LOCK Method
  - contents:
    - "9.11.  UNLOCK Method\n   The UNLOCK method removes the lock identified by the
      lock token in\n   the Lock-Token request header.  The Request-URI MUST identify
      a\n   resource within the scope of the lock.\n   Note that use of the Lock-Token
      header to provide the lock token is\n   not consistent with other state-changing
      methods, which all require\n   an If header with the lock token.  Thus, the
      If header is not needed\n   to provide the lock token.  Naturally, when the
      If header is present,\n   it has its normal meaning as a conditional header.\n
      \  For a successful response to this method, the server MUST delete the\n   lock
      entirely.\n   If all resources that have been locked under the submitted lock
      token\n   cannot be unlocked, then the UNLOCK request MUST fail.\n   A successful
      response to an UNLOCK method does not mean that the\n   resource is necessarily
      unlocked.  It means that the specific lock\n   corresponding to the specified
      token no longer exists.\n   Any DAV-compliant resource that supports the LOCK
      method MUST support\n   the UNLOCK method.\n   This method is idempotent, but
      not safe (see Section 9.1 of\n   [RFC2616]).  Responses to this method MUST
      NOT be cached.\n"
    - contents:
      - "9.11.1.  Status Codes\n   In addition to the general status codes possible,
        the following\n   status codes have specific applicability to UNLOCK:\n   204
        (No Content) - Normal success response (rather than 200 OK, since\n   200
        OK would imply a response body, and an UNLOCK success response\n   does not
        normally contain a body).\n   400 (Bad Request) - No lock token was provided.\n
        \  403 (Forbidden) - The currently authenticated principal does not have\n
        \  permission to remove the lock.\n   409 (Conflict), with 'lock-token-matches-request-uri'
        precondition -\n   The resource was not locked, or the request was made to
        a Request-URI\n   that was not within the scope of the lock.\n"
      title: 9.11.1.  Status Codes
    - contents:
      - "9.11.2.  Example - UNLOCK\n   >>Request\n     UNLOCK /workspace/webdav/info.doc
        HTTP/1.1\n     Host: example.com\n     Lock-Token: <urn:uuid:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7>\n
        \    Authorization: Digest username=\"ejw\"\n       realm=\"ejw@example.com\",
        nonce=\"...\",\n       uri=\"/workspace/webdav/proposal.doc\",\n       response=\"...\",
        opaque=\"...\"\n   >>Response\n     HTTP/1.1 204 No Content\n   In this example,
        the lock identified by the lock token\n   \"urn:uuid:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7\"
        is successfully\n   removed from the resource\n   http://example.com/workspace/webdav/info.doc.
        \ If this lock included\n   more than just one resource, the lock is removed
        from all resources\n   included in the lock.\n   In this example, the nonce,
        response, and opaque fields have not been\n   calculated in the Authorization
        request header.\n"
      title: 9.11.2.  Example - UNLOCK
    title: 9.11.  UNLOCK Method
  title: 9.  HTTP Methods for Distributed Authoring
- contents:
  - "10.  HTTP Headers for Distributed Authoring\n   All DAV headers follow the same
    basic formatting rules as HTTP\n   headers.  This includes rules like line continuation
    and how to\n   combine (or separate) multiple instances of the same header using\n
    \  commas.\n   WebDAV adds two new conditional headers to the set defined in HTTP:\n
    \  the If and Overwrite headers.\n"
  - contents:
    - "10.1.  DAV Header\n    DAV              = \"DAV\" \":\" #( compliance-class
      )\n    compliance-class = ( \"1\" | \"2\" | \"3\" | extend )\n    extend           =
      Coded-URL | token\n                       ; token is defined in RFC 2616, Section
      2.2\n    Coded-URL        = \"<\" absolute-URI \">\"\n                       ;
      No linear whitespace (LWS) allowed in Coded-URL\n                       ; absolute-URI
      defined in RFC 3986, Section 4.3\n   This general-header appearing in the response
      indicates that the\n   resource supports the DAV schema and protocol as specified.
      \ All DAV-\n   compliant resources MUST return the DAV header with compliance-class\n
      \  \"1\" on all OPTIONS responses.  In cases where WebDAV is only\n   supported
      in part of the server namespace, an OPTIONS request to non-\n   WebDAV resources
      (including \"/\") SHOULD NOT advertise WebDAV support.\n   The value is a comma-separated
      list of all compliance class\n   identifiers that the resource supports.  Class
      identifiers may be\n   Coded-URLs or tokens (as defined by [RFC2616]).  Identifiers
      can\n   appear in any order.  Identifiers that are standardized through the\n
      \  IETF RFC process are tokens, but other identifiers SHOULD be Coded-\n   URLs
      to encourage uniqueness.\n   A resource must show class 1 compliance if it shows
      class 2 or 3\n   compliance.  In general, support for one compliance class does
      not\n   entail support for any other, and in particular, support for\n   compliance
      class 3 does not require support for compliance class 2.\n   Please refer to
      Section 18 for more details on compliance classes\n   defined in this specification.\n
      \  Note that many WebDAV servers do not advertise WebDAV support in\n   response
      to \"OPTIONS *\".\n   As a request header, this header allows the client to
      advertise\n   compliance with named features when the server needs that\n   information.
      \ Clients SHOULD NOT send this header unless a standards\n   track specification
      requires it.  Any extension that makes use of\n   this as a request header will
      need to carefully consider caching\n   implications.\n"
    title: 10.1.  DAV Header
  - contents:
    - "10.2.  Depth Header\n      Depth = \"Depth\" \":\" (\"0\" | \"1\" | \"infinity\")\n
      \  The Depth request header is used with methods executed on resources\n   that
      could potentially have internal members to indicate whether the\n   method is
      to be applied only to the resource (\"Depth: 0\"), to the\n   resource and its
      internal members only (\"Depth: 1\"), or the resource\n   and all its members
      (\"Depth: infinity\").\n   The Depth header is only supported if a method's
      definition\n   explicitly provides for such support.\n   The following rules
      are the default behavior for any method that\n   supports the Depth header.
      \ A method may override these defaults by\n   defining different behavior in
      its definition.\n   Methods that support the Depth header may choose not to
      support all\n   of the header's values and may define, on a case-by-case basis,
      the\n   behavior of the method if a Depth header is not present.  For\n   example,
      the MOVE method only supports \"Depth: infinity\", and if a\n   Depth header
      is not present, it will act as if a \"Depth: infinity\"\n   header had been
      applied.\n   Clients MUST NOT rely upon methods executing on members of their\n
      \  hierarchies in any particular order or on the execution being atomic\n   unless
      the particular method explicitly provides such guarantees.\n   Upon execution,
      a method with a Depth header will perform as much of\n   its assigned task as
      possible and then return a response specifying\n   what it was able to accomplish
      and what it failed to do.\n   So, for example, an attempt to COPY a hierarchy
      may result in some of\n   the members being copied and some not.\n   By default,
      the Depth header does not interact with other headers.\n   That is, each header
      on a request with a Depth header MUST be applied\n   only to the Request-URI
      if it applies to any resource, unless\n   specific Depth behavior is defined
      for that header.\n   If a source or destination resource within the scope of
      the Depth\n   header is locked in such a way as to prevent the successful execution\n
      \  of the method, then the lock token for that resource MUST be\n   submitted
      with the request in the If request header.\n   The Depth header only specifies
      the behavior of the method with\n   regards to internal members.  If a resource
      does not have internal\n   members, then the Depth header MUST be ignored.\n"
    title: 10.2.  Depth Header
  - contents:
    - "10.3.  Destination Header\n   The Destination request header specifies the
      URI that identifies a\n   destination resource for methods such as COPY and
      MOVE, which take\n   two URIs as parameters.\n      Destination = \"Destination\"
      \":\" Simple-ref\n   If the Destination value is an absolute-URI (Section 4.3
      of\n   [RFC3986]), it may name a different server (or different port or\n   scheme).
      \ If the source server cannot attempt a copy to the remote\n   server, it MUST
      fail the request.  Note that copying and moving\n   resources to remote servers
      is not fully defined in this\n   specification (e.g., specific error conditions).\n
      \  If the Destination value is too long or otherwise unacceptable, the\n   server
      SHOULD return 400 (Bad Request), ideally with helpful\n   information in an
      error body.\n"
    title: 10.3.  Destination Header
  - contents:
    - "10.4.  If Header\n   The If request header is intended to have similar functionality
      to\n   the If-Match header defined in Section 14.24 of [RFC2616].  However,\n
      \  the If header handles any state token as well as ETags.  A typical\n   example
      of a state token is a lock token, and lock tokens are the\n   only state tokens
      defined in this specification.\n"
    - contents:
      - "10.4.1.  Purpose\n   The If header has two distinct purposes:\n   o  The
        first purpose is to make a request conditional by supplying a\n      series
        of state lists with conditions that match tokens and ETags\n      to a specific
        resource.  If this header is evaluated and all state\n      lists fail, then
        the request MUST fail with a 412 (Precondition\n      Failed) status.  On
        the other hand, the request can succeed only\n      if one of the described
        state lists succeeds.  The success\n      criteria for state lists and matching
        functions are defined in\n      Sections 10.4.3 and 10.4.4.\n   o  Additionally,
        the mere fact that a state token appears in an If\n      header means that
        it has been \"submitted\" with the request.  In\n      general, this is used
        to indicate that the client has knowledge of\n      that state token.  The
        semantics for submitting a state token\n      depend on its type (for lock
        tokens, please refer to Section 6).\n   Note that these two purposes need
        to be treated distinctly: a state\n   token counts as being submitted independently
        of whether the server\n   actually has evaluated the state list it appears
        in, and also\n   independently of whether or not the condition it expressed
        was found\n   to be true.\n"
      title: 10.4.1.  Purpose
    - contents:
      - "10.4.2.  Syntax\n     If = \"If\" \":\" ( 1*No-tag-list | 1*Tagged-list )\n
        \    No-tag-list = List\n     Tagged-list = Resource-Tag 1*List\n     List
        = \"(\" 1*Condition \")\"\n     Condition = [\"Not\"] (State-token | \"[\"
        entity-tag \"]\")\n     ; entity-tag: see Section 3.11 of [RFC2616]\n     ;
        No LWS allowed between \"[\", entity-tag and \"]\"\n     State-token = Coded-URL\n
        \    Resource-Tag = \"<\" Simple-ref \">\"\n     ; Simple-ref: see Section
        8.3\n     ; No LWS allowed in Resource-Tag\n   The syntax distinguishes between
        untagged lists (\"No-tag-list\") and\n   tagged lists (\"Tagged-list\").  Untagged
        lists apply to the resource\n   identified by the Request-URI, while tagged
        lists apply to the\n   resource identified by the preceding Resource-Tag.\n
        \  A Resource-Tag applies to all subsequent Lists, up to the next\n   Resource-Tag.\n
        \  Note that the two list types cannot be mixed within an If header.\n   This
        is not a functional restriction because the No-tag-list syntax\n   is just
        a shorthand notation for a Tagged-list production with a\n   Resource-Tag
        referring to the Request-URI.\n   Each List consists of one or more Conditions.
        \ Each Condition is\n   defined in terms of an entity-tag or state-token,
        potentially negated\n   by the prefix \"Not\".\n   Note that the If header
        syntax does not allow multiple instances of\n   If headers in a single request.
        \ However, the HTTP header syntax\n   allows extending single header values
        across multiple lines, by\n   inserting a line break followed by whitespace
        (see [RFC2616], Section\n   4.2).\n"
      title: 10.4.2.  Syntax
    - contents:
      - "10.4.3.  List Evaluation\n   A Condition that consists of a single entity-tag
        or state-token\n   evaluates to true if the resource matches the described
        state (where\n   the individual matching functions are defined below in\n
        \  Section 10.4.4).  Prefixing it with \"Not\" reverses the result of the\n
        \  evaluation (thus, the \"Not\" applies only to the subsequent entity-tag\n
        \  or state-token).\n   Each List production describes a series of conditions.
        \ The whole\n   list evaluates to true if and only if each condition evaluates
        to\n   true (that is, the list represents a logical conjunction of\n   Conditions).\n
        \  Each No-tag-list and Tagged-list production may contain one or more\n   Lists.
        \ They evaluate to true if and only if any of the contained\n   lists evaluates
        to true (that is, if there's more than one List, that\n   List sequence represents
        a logical disjunction of the Lists).\n   Finally, the whole If header evaluates
        to true if and only if at\n   least one of the No-tag-list or Tagged-list
        productions evaluates to\n   true.  If the header evaluates to false, the
        server MUST reject the\n   request with a 412 (Precondition Failed) status.
        \ Otherwise,\n   execution of the request can proceed as if the header wasn't
        present.\n"
      title: 10.4.3.  List Evaluation
    - contents:
      - "10.4.4.  Matching State Tokens and ETags\n   When performing If header processing,
        the definition of a matching\n   state token or entity tag is as follows:\n
        \  Identifying a resource: The resource is identified by the URI along\n   with
        the token, in tagged list production, or by the Request-URI in\n   untagged
        list production.\n   Matching entity tag: Where the entity tag matches an
        entity tag\n   associated with the identified resource.  Servers MUST use
        either the\n   weak or the strong comparison function defined in Section 13.3.3
        of\n   [RFC2616].\n   Matching state token: Where there is an exact match
        between the state\n   token in the If header and any state token on the identified\n
        \  resource.  A lock state token is considered to match if the resource\n
        \  is anywhere in the scope of the lock.\n   Handling unmapped URLs: For both
        ETags and state tokens, treat as if\n   the URL identified a resource that
        exists but does not have the\n   specified state.\n"
      title: 10.4.4.  Matching State Tokens and ETags
    - contents:
      - "10.4.5.  If Header and Non-DAV-Aware Proxies\n   Non-DAV-aware proxies will
        not honor the If header, since they will\n   not understand the If header,
        and HTTP requires non-understood\n   headers to be ignored.  When communicating
        with HTTP/1.1 proxies, the\n   client MUST use the \"Cache-Control: no-cache\"
        request header so as to\n   prevent the proxy from improperly trying to service
        the request from\n   its cache.  When dealing with HTTP/1.0 proxies, the \"Pragma:
        no-\n   cache\" request header MUST be used for the same reason.\n   Because
        in general clients may not be able to reliably detect non-\n   DAV-aware intermediates,
        they are advised to always prevent caching\n   using the request directives
        mentioned above.\n"
      title: 10.4.5.  If Header and Non-DAV-Aware Proxies
    - contents:
      - "10.4.6.  Example - No-tag Production\n     If: (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>\n
        \      [\"I am an ETag\"])\n       ([\"I am another ETag\"])\n   The previous
        header would require that the resource identified in the\n   Request-URI be
        locked with the specified lock token and be in the\n   state identified by
        the \"I am an ETag\" ETag or in the state\n   identified by the second ETag
        \"I am another ETag\".\n   To put the matter more plainly one can think of
        the previous If\n   header as expressing the condition below:\n     (\n       is-locked-with(urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2)
        AND\n       matches-etag(\"I am an ETag\")\n     )\n     OR\n     (\n       matches-etag(\"I
        am another ETag\")\n     )\n"
      title: 10.4.6.  Example - No-tag Production
    - contents:
      - "10.4.7.  Example - Using \"Not\" with No-tag Production\n     If: (Not <urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>\n
        \    <urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092>)\n   This If header requires
        that the resource must not be locked with a\n   lock having the lock token\n
        \  urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 and must be locked by a\n
        \  lock with the lock token\n   urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092.\n"
      title: 10.4.7.  Example - Using "Not" with No-tag Production
    - contents:
      - "10.4.8.  Example - Causing a Condition to Always Evaluate to True\n   There
        may be cases where a client wishes to submit state tokens, but\n   doesn't
        want the request to fail just because the state token isn't\n   current anymore.
        \ One simple way to do this is to include a Condition\n   that is known to
        always evaluate to true, such as in:\n     If: (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>)\n
        \      (Not <DAV:no-lock>)\n   \"DAV:no-lock\" is known to never represent
        a current lock token.  Lock\n   tokens are assigned by the server, following
        the uniqueness\n   requirements described in Section 6.5, therefore cannot
        use the\n   \"DAV:\" scheme.  Thus, by applying \"Not\" to a state token that
        is\n   known not to be current, the Condition always evaluates to true.\n
        \  Consequently, the whole If header will always evaluate to true, and\n   the
        lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be\n   submitted
        in any case.\n"
      title: 10.4.8.  Example - Causing a Condition to Always Evaluate to True
    - contents:
      - "10.4.9.  Example - Tagged List If Header in COPY\n   >>Request\n     COPY
        /resource1 HTTP/1.1\n     Host: www.example.com\n     Destination: /resource2\n
        \    If: </resource1>\n       (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>\n
        \      [W/\"A weak ETag\"]) ([\"strong ETag\"])\n   In this example, http://www.example.com/resource1
        is being copied to\n   http://www.example.com/resource2.  When the method
        is first applied\n   to http://www.example.com/resource1, resource1 must be
        in the state\n   specified by \"(<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>
        [W/\"A\n   weak ETag\"]) ([\"strong ETag\"])\".  That is, either it must be
        locked\n   with a lock token of \"urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2\"\n
        \  and have a weak entity tag W/\"A weak ETag\" or it must have a strong\n
        \  entity tag \"strong ETag\".\n"
      title: 10.4.9.  Example - Tagged List If Header in COPY
    - contents:
      - "10.4.10.  Example - Matching Lock Tokens with Collection Locks\n     DELETE
        /specs/rfc2518.txt HTTP/1.1\n     Host: www.example.com\n     If: <http://www.example.com/specs/>\n
        \      (<urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2>)\n   For this example,
        the lock token must be compared to the identified\n   resource, which is the
        'specs' collection identified by the URL in\n   the tagged list production.
        \ If the 'specs' collection is not locked\n   by a lock with the specified
        lock token, the request MUST fail.\n   Otherwise, this request could succeed,
        because the If header\n   evaluates to true, and because the lock token for
        the lock affecting\n   the affected resource has been submitted.\n"
      title: 10.4.10.  Example - Matching Lock Tokens with Collection Locks
    - contents:
      - "10.4.11.  Example - Matching ETags on Unmapped URLs\n   Consider a collection
        \"/specs\" that does not contain the member\n   \"/specs/rfc2518.doc\".  In
        this case, the If header\n     If: </specs/rfc2518.doc> ([\"4217\"])\n   will
        evaluate to false (the URI isn't mapped, thus the resource\n   identified
        by the URI doesn't have an entity matching the ETag\n   \"4217\").\n   On
        the other hand, an If header of\n     If: </specs/rfc2518.doc> (Not [\"4217\"])\n
        \  will consequently evaluate to true.\n   Note that, as defined above in
        Section 10.4.4, the same\n   considerations apply to matching state tokens.\n"
      title: 10.4.11.  Example - Matching ETags on Unmapped URLs
    title: 10.4.  If Header
  - contents:
    - "10.5.  Lock-Token Header\n      Lock-Token = \"Lock-Token\" \":\" Coded-URL\n
      \  The Lock-Token request header is used with the UNLOCK method to\n   identify
      the lock to be removed.  The lock token in the Lock-Token\n   request header
      MUST identify a lock that contains the resource\n   identified by Request-URI
      as a member.\n   The Lock-Token response header is used with the LOCK method
      to\n   indicate the lock token created as a result of a successful LOCK\n   request
      to create a new lock.\n"
    title: 10.5.  Lock-Token Header
  - contents:
    - "10.6.  Overwrite Header\n      Overwrite = \"Overwrite\" \":\" (\"T\" | \"F\")\n
      \  The Overwrite request header specifies whether the server should\n   overwrite
      a resource mapped to the destination URL during a COPY or\n   MOVE.  A value
      of \"F\" states that the server must not perform the\n   COPY or MOVE operation
      if the destination URL does map to a resource.\n   If the overwrite header is
      not included in a COPY or MOVE request,\n   then the resource MUST treat the
      request as if it has an overwrite\n   header of value \"T\".  While the Overwrite
      header appears to duplicate\n   the functionality of using an \"If-Match: *\"
      header (see [RFC2616]),\n   If-Match applies only to the Request-URI, and not
      to the Destination\n   of a COPY or MOVE.\n   If a COPY or MOVE is not performed
      due to the value of the Overwrite\n   header, the method MUST fail with a 412
      (Precondition Failed) status\n   code.  The server MUST do authorization checks
      before checking this\n   or any conditional header.\n   All DAV-compliant resources
      MUST support the Overwrite header.\n"
    title: 10.6.  Overwrite Header
  - contents:
    - "10.7.  Timeout Request Header\n      TimeOut = \"Timeout\" \":\" 1#TimeType\n
      \     TimeType = (\"Second-\" DAVTimeOutVal | \"Infinite\")\n                 ;
      No LWS allowed within TimeType\n      DAVTimeOutVal = 1*DIGIT\n   Clients MAY
      include Timeout request headers in their LOCK requests.\n   However, the server
      is not required to honor or even consider these\n   requests.  Clients MUST
      NOT submit a Timeout request header with any\n   method other than a LOCK method.\n
      \  The \"Second\" TimeType specifies the number of seconds that will\n   elapse
      between granting of the lock at the server, and the automatic\n   removal of
      the lock.  The timeout value for TimeType \"Second\" MUST\n   NOT be greater
      than 2^32-1.\n   See Section 6.6 for a description of lock timeout behavior.\n"
    title: 10.7.  Timeout Request Header
  title: 10.  HTTP Headers for Distributed Authoring
- contents:
  - "11.  Status Code Extensions to HTTP/1.1\n   The following status codes are added
    to those defined in HTTP/1.1\n   [RFC2616].\n"
  - contents:
    - "11.1.  207 Multi-Status\n   The 207 (Multi-Status) status code provides status
      for multiple\n   independent operations (see Section 13 for more information).\n"
    title: 11.1.  207 Multi-Status
  - contents:
    - "11.2.  422 Unprocessable Entity\n   The 422 (Unprocessable Entity) status code
      means the server\n   understands the content type of the request entity (hence
      a\n   415(Unsupported Media Type) status code is inappropriate), and the\n   syntax
      of the request entity is correct (thus a 400 (Bad Request)\n   status code is
      inappropriate) but was unable to process the contained\n   instructions.  For
      example, this error condition may occur if an XML\n   request body contains
      well-formed (i.e., syntactically correct), but\n   semantically erroneous, XML
      instructions.\n"
    title: 11.2.  422 Unprocessable Entity
  - contents:
    - "11.3.  423 Locked\n   The 423 (Locked) status code means the source or destination
      resource\n   of a method is locked.  This response SHOULD contain an appropriate\n
      \  precondition or postcondition code, such as 'lock-token-submitted' or\n   'no-conflicting-lock'.\n"
    title: 11.3.  423 Locked
  - contents:
    - "11.4.  424 Failed Dependency\n   The 424 (Failed Dependency) status code means
      that the method could\n   not be performed on the resource because the requested
      action\n   depended on another action and that action failed.  For example,
      if a\n   command in a PROPPATCH method fails, then, at minimum, the rest of\n
      \  the commands will also fail with 424 (Failed Dependency).\n"
    title: 11.4.  424 Failed Dependency
  - contents:
    - "11.5.  507 Insufficient Storage\n   The 507 (Insufficient Storage) status code
      means the method could not\n   be performed on the resource because the server
      is unable to store\n   the representation needed to successfully complete the
      request.  This\n   condition is considered to be temporary.  If the request
      that\n   received this status code was the result of a user action, the\n   request
      MUST NOT be repeated until it is requested by a separate user\n   action.\n"
    title: 11.5.  507 Insufficient Storage
  title: 11.  Status Code Extensions to HTTP/1.1
- contents:
  - "12.  Use of HTTP Status Codes\n   These HTTP codes are not redefined, but their
    use is somewhat\n   extended by WebDAV methods and requirements.  In general,
    many HTTP\n   status codes can be used in response to any request, not just in\n
    \  cases described in this document.  Note also that WebDAV servers are\n   known
    to use 300-level redirect responses (and early interoperability\n   tests found
    clients unprepared to see those responses).  A 300-level\n   response MUST NOT
    be used when the server has created a new resource\n   in response to the request.\n"
  - contents:
    - "12.1.  412 Precondition Failed\n   Any request can contain a conditional header
      defined in HTTP (If-\n   Match, If-Modified-Since, etc.) or the \"If\" or \"Overwrite\"\n
      \  conditional headers defined in this specification.  If the server\n   evaluates
      a conditional header, and if that condition fails to hold,\n   then this error
      code MUST be returned.  On the other hand, if the\n   client did not include
      a conditional header in the request, then the\n   server MUST NOT use this status
      code.\n"
    title: 12.1.  412 Precondition Failed
  - contents:
    - "12.2.  414 Request-URI Too Long\n   This status code is used in HTTP 1.1 only
      for Request-URIs, not URIs\n   in other locations.\n"
    title: 12.2.  414 Request-URI Too Long
  title: 12.  Use of HTTP Status Codes
- contents:
  - "13.  Multi-Status Response\n   A Multi-Status response conveys information about
    multiple resources\n   in situations where multiple status codes might be appropriate.
    \ The\n   default Multi-Status response body is a text/xml or application/xml\n
    \  HTTP entity with a 'multistatus' root element.  Further elements\n   contain
    200, 300, 400, and 500 series status codes generated during\n   the method invocation.
    100 series status codes SHOULD NOT be recorded\n   in a 'response' XML element.\n
    \  Although '207' is used as the overall response status code, the\n   recipient
    needs to consult the contents of the multistatus response\n   body for further
    information about the success or failure of the\n   method execution.  The response
    MAY be used in success, partial\n   success and also in failure situations.\n
    \  The 'multistatus' root element holds zero or more 'response' elements\n   in
    any order, each with information about an individual resource.\n   Each 'response'
    element MUST have an 'href' element to identify the\n   resource.\n   A Multi-Status
    response uses one out of two distinct formats for\n   representing the status:\n
    \  1.  A 'status' element as child of the 'response' element indicates\n       the
    status of the message execution for the identified resource\n       as a whole
    (for instance, see Section 9.6.2).  Some method\n       definitions provide information
    about specific status codes\n       clients should be prepared to see in a response.
    \ However,\n       clients MUST be able to handle other status codes, using the\n
    \      generic rules defined in Section 10 of [RFC2616].\n   2.  For PROPFIND
    and PROPPATCH, the format has been extended using\n       the 'propstat' element
    instead of 'status', providing information\n       about individual properties
    of a resource.  This format is\n       specific to PROPFIND and PROPPATCH, and
    is described in detail in\n       Sections 9.1 and 9.2.\n"
  - contents:
    - "13.1.  Response Headers\n   HTTP defines the Location header to indicate a
      preferred URL for the\n   resource that was addressed in the Request-URI (e.g.,
      in response to\n   successful PUT requests or in redirect responses).  However,
      use of\n   this header creates ambiguity when there are URLs in the body of
      the\n   response, as with Multi-Status.  Thus, use of the Location header\n
      \  with the Multi-Status response is intentionally undefined.\n"
    title: 13.1.  Response Headers
  - contents:
    - "13.2.  Handling Redirected Child Resources\n   Redirect responses (300-303,
      305, and 307) defined in HTTP 1.1\n   normally take a Location header to indicate
      the new URI for the\n   single resource redirected from the Request-URI.  Multi-Status\n
      \  responses contain many resource addresses, but the original\n   definition
      in [RFC2518] did not have any place for the server to\n   provide the new URI
      for redirected resources.  This specification\n   does define a 'location' element
      for this information (see\n   Section 14.9).  Servers MUST use this new element
      with redirect\n   responses in Multi-Status.\n   Clients encountering redirected
      resources in Multi-Status MUST NOT\n   rely on the 'location' element being
      present with a new URI.  If the\n   element is not present, the client MAY reissue
      the request to the\n   individual redirected resource, because the response
      to that request\n   can be redirected with a Location header containing the
      new URI.\n"
    title: 13.2.  Handling Redirected Child Resources
  - contents:
    - "13.3.  Internal Status Codes\n   Sections 9.2.1, 9.1.2, 9.6.1, 9.8.3, and 9.9.2
      define various status\n   codes used in Multi-Status responses.  This specification
      does not\n   define the meaning of other status codes that could appear in these\n
      \  responses.\n"
    title: 13.3.  Internal Status Codes
  title: 13.  Multi-Status Response
- contents:
  - "14.  XML Element Definitions\n   In this section, the final line of each section
    gives the element\n   type declaration using the format defined in [REC-XML].
    \ The \"Value\"\n   field, where present, specifies further restrictions on the
    allowable\n   contents of the XML element using BNF (i.e., to further restrict
    the\n   values of a PCDATA element).  Note that all of the elements defined\n
    \  here may be extended according to the rules defined in Section 17.\n   All
    elements defined here are in the \"DAV:\" namespace.\n"
  - contents:
    - "14.1.  activelock XML Element\n   Name:   activelock\n   Purpose:   Describes
      a lock on a resource.\n   <!ELEMENT activelock (lockscope, locktype, depth,
      owner?, timeout?,\n             locktoken?, lockroot)>\n"
    title: 14.1.  activelock XML Element
  - contents:
    - "14.2.  allprop XML Element\n   Name:   allprop\n   Purpose:   Specifies that
      all names and values of dead properties and\n      the live properties defined
      by this document existing on the\n      resource are to be returned.\n   <!ELEMENT
      allprop EMPTY >\n"
    title: 14.2.  allprop XML Element
  - contents:
    - "14.3.  collection XML Element\n   Name:   collection\n   Purpose:   Identifies
      the associated resource as a collection.  The\n      DAV:resourcetype property
      of a collection resource MUST contain\n      this element.  It is normally empty
      but extensions may add sub-\n      elements.\n   <!ELEMENT collection EMPTY
      >\n"
    title: 14.3.  collection XML Element
  - contents:
    - "14.4.  depth XML Element\n   Name:   depth\n   Purpose:   Used for representing
      depth values in XML content (e.g.,\n      in lock information).\n   Value:   \"0\"
      | \"1\" | \"infinity\"\n   <!ELEMENT depth (#PCDATA) >\n"
    title: 14.4.  depth XML Element
  - contents:
    - "14.5.  error XML Element\n   Name:   error\n   Purpose:   Error responses,
      particularly 403 Forbidden and 409\n      Conflict, sometimes need more information
      to indicate what went\n      wrong.  In these cases, servers MAY return an XML
      response body\n      with a document element of 'error', containing child elements\n
      \     identifying particular condition codes.\n   Description:   Contains at
      least one XML element, and MUST NOT\n      contain text or mixed content.  Any
      element that is a child of the\n      'error' element is considered to be a
      precondition or\n      postcondition code.  Unrecognized elements MUST be ignored.\n
      \  <!ELEMENT error ANY >\n"
    title: 14.5.  error XML Element
  - contents:
    - "14.6.  exclusive XML Element\n   Name:   exclusive\n   Purpose:   Specifies
      an exclusive lock.\n   <!ELEMENT exclusive EMPTY >\n"
    title: 14.6.  exclusive XML Element
  - contents:
    - "14.7.  href XML Element\n   Name:   href\n   Purpose:   MUST contain a URI
      or a relative reference.\n   Description:   There may be limits on the value
      of 'href' depending\n      on the context of its use.  Refer to the specification
      text where\n      'href' is used to see what limitations apply in each case.\n
      \  Value:   Simple-ref\n   <!ELEMENT href (#PCDATA)>\n"
    title: 14.7.  href XML Element
  - contents:
    - "14.8.  include XML Element\n   Name:   include\n   Purpose:   Any child element
      represents the name of a property to be\n      included in the PROPFIND response.
      \ All elements inside an\n      'include' XML element MUST define properties
      related to the\n      resource, although possible property names are in no way
      limited\n      to those property names defined in this document or other\n      standards.
      \ This element MUST NOT contain text or mixed content.\n   <!ELEMENT include
      ANY >\n"
    title: 14.8.  include XML Element
  - contents:
    - "14.9.  location XML Element\n   Name:   location\n   Purpose:   HTTP defines
      the \"Location\" header (see [RFC2616], Section\n      14.30) for use with some
      status codes (such as 201 and the 300\n      series codes).  When these codes
      are used inside a 'multistatus'\n      element, the 'location' element can be
      used to provide the\n      accompanying Location header value.\n   Description:
      \  Contains a single href element with the same value\n      that would be used
      in a Location header.\n   <!ELEMENT location (href)>\n"
    title: 14.9.  location XML Element
  - contents:
    - "14.10.  lockentry XML Element\n   Name:   lockentry\n   Purpose:   Defines
      the types of locks that can be used with the\n      resource.\n   <!ELEMENT
      lockentry (lockscope, locktype) >\n"
    title: 14.10.  lockentry XML Element
  - contents:
    - "14.11.  lockinfo XML Element\n   Name:   lockinfo\n   Purpose:   The 'lockinfo'
      XML element is used with a LOCK method to\n      specify the type of lock the
      client wishes to have created.\n   <!ELEMENT lockinfo (lockscope, locktype,
      owner?)  >\n"
    title: 14.11.  lockinfo XML Element
  - contents:
    - "14.12.  lockroot XML Element\n   Name:   lockroot\n   Purpose:   Contains the
      root URL of the lock, which is the URL\n      through which the resource was
      addressed in the LOCK request.\n   Description:   The href element contains
      the root of the lock.  The\n      server SHOULD include this in all DAV:lockdiscovery
      property\n      values and the response to LOCK requests.\n   <!ELEMENT lockroot
      (href) >\n"
    title: 14.12.  lockroot XML Element
  - contents:
    - "14.13.  lockscope XML Element\n   Name:   lockscope\n   Purpose:   Specifies
      whether a lock is an exclusive lock, or a shared\n      lock.\n     <!ELEMENT
      lockscope (exclusive | shared) >\n"
    title: 14.13.  lockscope XML Element
  - contents:
    - "14.14.  locktoken XML Element\n   Name:   locktoken\n   Purpose:   The lock
      token associated with a lock.\n   Description:   The href contains a single
      lock token URI, which\n      refers to the lock.\n   <!ELEMENT locktoken (href)
      >\n"
    title: 14.14.  locktoken XML Element
  - contents:
    - "14.15.  locktype XML Element\n   Name:   locktype\n   Purpose:   Specifies
      the access type of a lock.  At present, this\n      specification only defines
      one lock type, the write lock.\n   <!ELEMENT locktype (write) >\n"
    title: 14.15.  locktype XML Element
  - contents:
    - "14.16.  multistatus XML Element\n   Name:   multistatus\n   Purpose:   Contains
      multiple response messages.\n   Description:   The 'responsedescription' element
      at the top level is\n      used to provide a general message describing the
      overarching\n      nature of the response.  If this value is available, an\n
      \     application may use it instead of presenting the individual\n      response
      descriptions contained within the responses.\n   <!ELEMENT multistatus (response*,
      responsedescription?)  >\n"
    title: 14.16.  multistatus XML Element
  - contents:
    - "14.17.  owner XML Element\n   Name:   owner\n   Purpose:   Holds client-supplied
      information about the creator of a\n      lock.\n   Description:   Allows a
      client to provide information sufficient for\n      either directly contacting
      a principal (such as a telephone number\n      or Email URI), or for discovering
      the principal (such as the URL\n      of a homepage) who created a lock.  The
      value provided MUST be\n      treated as a dead property in terms of XML Information
      Item\n      preservation.  The server MUST NOT alter the value unless the\n
      \     owner value provided by the client is empty.  For a certain amount\n      of
      interoperability between different client implementations, if\n      clients
      have URI-formatted contact information for the lock\n      creator suitable
      for user display, then clients SHOULD put those\n      URIs in 'href' child
      elements of the 'owner' element.\n   Extensibility:   MAY be extended with child
      elements, mixed content,\n      text content or attributes.\n   <!ELEMENT owner
      ANY >\n"
    title: 14.17.  owner XML Element
  - contents:
    - "14.18.  prop XML Element\n   Name:   prop\n   Purpose:   Contains properties
      related to a resource.\n   Description:   A generic container for properties
      defined on\n      resources.  All elements inside a 'prop' XML element MUST
      define\n      properties related to the resource, although possible property\n
      \     names are in no way limited to those property names defined in\n      this
      document or other standards.  This element MUST NOT contain\n      text or mixed
      content.\n   <!ELEMENT prop ANY >\n"
    title: 14.18.  prop XML Element
  - contents:
    - "14.19.  propertyupdate XML Element\n   Name:   propertyupdate\n   Purpose:
      \  Contains a request to alter the properties on a resource.\n   Description:
      \  This XML element is a container for the information\n      required to modify
      the properties on the resource.\n   <!ELEMENT propertyupdate (remove | set)+
      >\n"
    title: 14.19.  propertyupdate XML Element
  - contents:
    - "14.20.  propfind XML Element\n   Name:   propfind\n   Purpose:   Specifies
      the properties to be returned from a PROPFIND\n      method.  Four special elements
      are specified for use with\n      'propfind': 'prop', 'allprop', 'include',
      and 'propname'.  If\n      'prop' is used inside 'propfind', it MUST NOT contain
      property\n      values.\n   <!ELEMENT propfind ( propname | (allprop, include?)
      | prop ) >\n"
    title: 14.20.  propfind XML Element
  - contents:
    - "14.21.  propname XML Element\n   Name:   propname\n   Purpose:   Specifies
      that only a list of property names on the\n      resource is to be returned.\n
      \  <!ELEMENT propname EMPTY >\n"
    title: 14.21.  propname XML Element
  - contents:
    - "14.22.  propstat XML Element\n   Name:   propstat\n   Purpose:   Groups together
      a prop and status element that is\n      associated with a particular 'href'
      element.\n   Description:   The propstat XML element MUST contain one prop XML\n
      \     element and one status XML element.  The contents of the prop XML\n      element
      MUST only list the names of properties to which the result\n      in the status
      element applies.  The optional precondition/\n      postcondition element and
      'responsedescription' text also apply to\n      the properties named in 'prop'.\n
      \  <!ELEMENT propstat (prop, status, error?, responsedescription?) >\n"
    title: 14.22.  propstat XML Element
  - contents:
    - "14.23.  remove XML Element\n   Name:   remove\n   Purpose:   Lists the properties
      to be removed from a resource.\n   Description:   Remove instructs that the
      properties specified in prop\n      should be removed.  Specifying the removal
      of a property that does\n      not exist is not an error.  All the XML elements
      in a 'prop' XML\n      element inside of a 'remove' XML element MUST be empty,
      as only\n      the names of properties to be removed are required.\n   <!ELEMENT
      remove (prop) >\n"
    title: 14.23.  remove XML Element
  - contents:
    - "14.24.  response XML Element\n   Name:   response\n   Purpose:   Holds a single
      response describing the effect of a method\n      on resource and/or its properties.\n
      \  Description:   The 'href' element contains an HTTP URL pointing to a\n      WebDAV
      resource when used in the 'response' container.  A\n      particular 'href'
      value MUST NOT appear more than once as the\n      child of a 'response' XML
      element under a 'multistatus' XML\n      element.  This requirement is necessary
      in order to keep\n      processing costs for a response to linear time.  Essentially,
      this\n      prevents having to search in order to group together all the\n      responses
      by 'href'.  There are, however, no requirements\n      regarding ordering based
      on 'href' values.  The optional\n      precondition/postcondition element and
      'responsedescription' text\n      can provide additional information about this
      resource relative to\n      the request or result.\n   <!ELEMENT response (href,
      ((href*, status)|(propstat+)),\n                       error?, responsedescription?
      , location?) >\n"
    title: 14.24.  response XML Element
  - contents:
    - "14.25.  responsedescription XML Element\n   Name:   responsedescription\n   Purpose:
      \  Contains information about a status response within a\n      Multi-Status.\n
      \  Description:   Provides information suitable to be presented to a\n      user.\n
      \  <!ELEMENT responsedescription (#PCDATA) >\n"
    title: 14.25.  responsedescription XML Element
  - contents:
    - "14.26.  set XML Element\n   Name:   set\n   Purpose:   Lists the property values
      to be set for a resource.\n   Description:   The 'set' element MUST contain
      only a 'prop' element.\n      The elements contained by the 'prop' element inside
      the 'set'\n      element MUST specify the name and value of properties that
      are set\n      on the resource identified by Request-URI.  If a property already\n
      \     exists, then its value is replaced.  Language tagging information\n      appearing
      in the scope of the 'prop' element (in the \"xml:lang\"\n      attribute, if
      present) MUST be persistently stored along with the\n      property, and MUST
      be subsequently retrievable using PROPFIND.\n   <!ELEMENT set (prop) >\n"
    title: 14.26.  set XML Element
  - contents:
    - "14.27.  shared XML Element\n   Name:   shared\n   Purpose:   Specifies a shared
      lock.\n   <!ELEMENT shared EMPTY >\n"
    title: 14.27.  shared XML Element
  - contents:
    - "14.28.  status XML Element\n   Name:   status\n   Purpose:   Holds a single
      HTTP status-line.\n   Value:   status-line (defined in Section 6.1 of [RFC2616])\n
      \  <!ELEMENT status (#PCDATA) >\n"
    title: 14.28.  status XML Element
  - contents:
    - "14.29.  timeout XML Element\n   Name:   timeout\n   Purpose:   The number of
      seconds remaining before a lock expires.\n   Value:   TimeType (defined in Section
      10.7)\n      <!ELEMENT timeout (#PCDATA) >\n"
    title: 14.29.  timeout XML Element
  - contents:
    - "14.30.  write XML Element\n   Name:   write\n   Purpose:   Specifies a write
      lock.\n   <!ELEMENT write EMPTY >\n"
    title: 14.30.  write XML Element
  title: 14.  XML Element Definitions
- contents:
  - "15.  DAV Properties\n   For DAV properties, the name of the property is also
    the same as the\n   name of the XML element that contains its value.  In the section\n
    \  below, the final line of each section gives the element type\n   declaration
    using the format defined in [REC-XML].  The \"Value\"\n   field, where present,
    specifies further restrictions on the allowable\n   contents of the XML element
    using BNF (i.e., to further restrict the\n   values of a PCDATA element).\n   A
    protected property is one that cannot be changed with a PROPPATCH\n   request.
    \ There may be other requests that would result in a change\n   to a protected
    property (as when a LOCK request affects the value of\n   DAV:lockdiscovery).
    \ Note that a given property could be protected on\n   one type of resource, but
    not protected on another type of resource.\n   A computed property is one with
    a value defined in terms of a\n   computation (based on the content and other
    properties of that\n   resource, or even of some other resource).  A computed
    property is\n   always a protected property.\n   COPY and MOVE behavior refers
    to local COPY and MOVE operations.\n   For properties defined based on HTTP GET
    response headers (DAV:get*),\n   the header value could include LWS as defined
    in [RFC2616], Section\n   4.2.  Server implementors SHOULD strip LWS from these
    values before\n   using as WebDAV property values.\n"
  - contents:
    - "15.1.  creationdate Property\n   Name:   creationdate\n   Purpose:   Records
      the time and date the resource was created.\n   Value:   date-time (defined
      in [RFC3339], see the ABNF in Section\n      5.6.)\n   Protected:   MAY be protected.
      \ Some servers allow DAV:creationdate\n      to be changed to reflect the time
      the document was created if that\n      is more meaningful to the user (rather
      than the time it was\n      uploaded).  Thus, clients SHOULD NOT use this property
      in\n      synchronization logic (use DAV:getetag instead).\n   COPY/MOVE behavior:
      \  This property value SHOULD be kept during a\n      MOVE operation, but is
      normally re-initialized when a resource is\n      created with a COPY.  It should
      not be set in a COPY.\n   Description:   The DAV:creationdate property SHOULD
      be defined on all\n      DAV compliant resources.  If present, it contains a
      timestamp of\n      the moment when the resource was created.  Servers that
      are\n      incapable of persistently recording the creation date SHOULD\n      instead
      leave it undefined (i.e. report \"Not Found\").\n   <!ELEMENT creationdate (#PCDATA)
      >\n"
    title: 15.1.  creationdate Property
  - contents:
    - "15.2.  displayname Property\n   Name:   displayname\n   Purpose:   Provides
      a name for the resource that is suitable for\n      presentation to a user.\n
      \  Value:   Any text.\n   Protected:   SHOULD NOT be protected.  Note that servers
      implementing\n      [RFC2518] might have made this a protected property as this
      is a\n      new requirement.\n   COPY/MOVE behavior:   This property value SHOULD
      be preserved in COPY\n      and MOVE operations.\n   Description:   Contains
      a description of the resource that is\n      suitable for presentation to a
      user.  This property is defined on\n      the resource, and hence SHOULD have
      the same value independent of\n      the Request-URI used to retrieve it (thus,
      computing this property\n      based on the Request-URI is deprecated).  While
      generic clients\n      might display the property value to end users, client
      UI designers\n      must understand that the method for identifying resources
      is still\n      the URL.  Changes to DAV:displayname do not issue moves or copies\n
      \     to the server, but simply change a piece of meta-data on the\n      individual
      resource.  Two resources can have the same DAV:\n      displayname value even
      within the same collection.\n   <!ELEMENT displayname (#PCDATA) >\n"
    title: 15.2.  displayname Property
  - contents:
    - "15.3.  getcontentlanguage Property\n   Name:   getcontentlanguage\n   Purpose:
      \  Contains the Content-Language header value (from Section\n      14.12 of
      [RFC2616]) as it would be returned by a GET without\n      accept headers.\n
      \  Value:   language-tag (language-tag is defined in Section 3.10 of\n      [RFC2616])\n
      \  Protected:   SHOULD NOT be protected, so that clients can reset the\n      language.
      \ Note that servers implementing [RFC2518] might have\n      made this a protected
      property as this is a new requirement.\n   COPY/MOVE behavior:   This property
      value SHOULD be preserved in COPY\n      and MOVE operations.\n   Description:
      \  The DAV:getcontentlanguage property MUST be defined on\n      any DAV-compliant
      resource that returns the Content-Language\n      header on a GET.\n   <!ELEMENT
      getcontentlanguage (#PCDATA) >\n"
    title: 15.3.  getcontentlanguage Property
  - contents:
    - "15.4.  getcontentlength Property\n   Name:   getcontentlength\n   Purpose:
      \  Contains the Content-Length header returned by a GET\n      without accept
      headers.\n   Value:   See Section 14.13 of [RFC2616].\n   Protected:   This
      property is computed, therefore protected.\n   Description:   The DAV:getcontentlength
      property MUST be defined on\n      any DAV-compliant resource that returns the
      Content-Length header\n      in response to a GET.\n   COPY/MOVE behavior:   This
      property value is dependent on the size of\n      the destination resource,
      not the value of the property on the\n      source resource.\n   <!ELEMENT getcontentlength
      (#PCDATA) >\n"
    title: 15.4.  getcontentlength Property
  - contents:
    - "15.5.  getcontenttype Property\n   Name:   getcontenttype\n   Purpose:   Contains
      the Content-Type header value (from Section 14.17\n      of [RFC2616]) as it
      would be returned by a GET without accept\n      headers.\n   Value:   media-type
      (defined in Section 3.7 of [RFC2616])\n   Protected:   Potentially protected
      if the server prefers to assign\n      content types on its own (see also discussion
      in Section 9.7.1).\n   COPY/MOVE behavior:   This property value SHOULD be preserved
      in COPY\n      and MOVE operations.\n   Description:   This property MUST be
      defined on any DAV-compliant\n      resource that returns the Content-Type header
      in response to a\n      GET.\n   <!ELEMENT getcontenttype (#PCDATA) >\n"
    title: 15.5.  getcontenttype Property
  - contents:
    - "15.6.  getetag Property\n   Name:   getetag\n   Purpose:   Contains the ETag
      header value (from Section 14.19 of\n      [RFC2616]) as it would be returned
      by a GET without accept\n      headers.\n   Value:   entity-tag (defined in
      Section 3.11 of [RFC2616])\n   Protected:  MUST be protected because this value
      is created and\n      controlled by the server.\n   COPY/MOVE behavior:   This
      property value is dependent on the final\n      state of the destination resource,
      not the value of the property\n      on the source resource.  Also note the
      considerations in\n      Section 8.8.\n   Description:   The getetag property
      MUST be defined on any DAV-\n      compliant resource that returns the Etag
      header.  Refer to Section\n      3.11 of RFC 2616 for a complete definition
      of the semantics of an\n      ETag, and to Section 8.6 for a discussion of ETags
      in WebDAV.\n   <!ELEMENT getetag (#PCDATA) >\n"
    title: 15.6.  getetag Property
  - contents:
    - "15.7.  getlastmodified Property\n   Name:   getlastmodified\n   Purpose:   Contains
      the Last-Modified header value (from Section\n      14.29 of [RFC2616]) as it
      would be returned by a GET method\n      without accept headers.\n   Value:
      \  rfc1123-date (defined in Section 3.3.1 of [RFC2616])\n   Protected:   SHOULD
      be protected because some clients may rely on the\n      value for appropriate
      caching behavior, or on the value of the\n      Last-Modified header to which
      this property is linked.\n   COPY/MOVE behavior:   This property value is dependent
      on the last\n      modified date of the destination resource, not the value
      of the\n      property on the source resource.  Note that some server\n      implementations
      use the file system date modified value for the\n      DAV:getlastmodified value,
      and this can be preserved in a MOVE\n      even when the HTTP Last-Modified
      value SHOULD change.  Note that\n      since [RFC2616] requires clients to use
      ETags where provided, a\n      server implementing ETags can count on clients
      using a much better\n      mechanism than modification dates for offline synchronization
      or\n      cache control.  Also note the considerations in Section 8.8.\n   Description:
      \  The last-modified date on a resource SHOULD only\n      reflect changes in
      the body (the GET responses) of the resource.\n      A change in a property
      only SHOULD NOT cause the last-modified\n      date to change, because clients
      MAY rely on the last-modified date\n      to know when to overwrite the existing
      body.  The DAV:\n      getlastmodified property MUST be defined on any DAV-compliant\n
      \     resource that returns the Last-Modified header in response to a\n      GET.\n
      \  <!ELEMENT getlastmodified (#PCDATA) >\n"
    title: 15.7.  getlastmodified Property
  - contents:
    - "15.8.  lockdiscovery Property\n   Name:   lockdiscovery\n   Purpose:   Describes
      the active locks on a resource\n   Protected:   MUST be protected.  Clients
      change the list of locks\n      through LOCK and UNLOCK, not through PROPPATCH.\n
      \  COPY/MOVE behavior:   The value of this property depends on the lock\n      state
      of the destination, not on the locks of the source resource.\n      Recall that
      locks are not moved in a MOVE operation.\n   Description:   Returns a listing
      of who has a lock, what type of lock\n      he has, the timeout type and the
      time remaining on the timeout,\n      and the associated lock token.  Owner
      information MAY be omitted\n      if it is considered sensitive.  If there are
      no locks, but the\n      server supports locks, the property will be present
      but contain\n      zero 'activelock' elements.  If there are one or more locks,
      an\n      'activelock' element appears for each lock on the resource.  This\n
      \     property is NOT lockable with respect to write locks (Section 7).\n   <!ELEMENT
      lockdiscovery (activelock)* >\n"
    - contents:
      - "15.8.1.  Example - Retrieving DAV:lockdiscovery\n   >>Request\n     PROPFIND
        /container/ HTTP/1.1\n     Host: www.example.com\n     Content-Length: xxxx\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n     <D:propfind xmlns:D='DAV:'>\n       <D:prop><D:lockdiscovery/></D:prop>\n
        \    </D:propfind>\n   >>Response\n     HTTP/1.1 207 Multi-Status\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus xmlns:D='DAV:'>\n
        \      <D:response>\n         <D:href>http://www.example.com/container/</D:href>\n
        \        <D:propstat>\n           <D:prop>\n             <D:lockdiscovery>\n
        \             <D:activelock>\n               <D:locktype><D:write/></D:locktype>\n
        \              <D:lockscope><D:exclusive/></D:lockscope>\n               <D:depth>0</D:depth>\n
        \              <D:owner>Jane Smith</D:owner>\n               <D:timeout>Infinite</D:timeout>\n
        \              <D:locktoken>\n                 <D:href\n             >urn:uuid:f81de2ad-7f3d-a1b2-4f3c-00a0c91a9d76</D:href>\n
        \              </D:locktoken>\n               <D:lockroot>\n                 <D:href>http://www.example.com/container/</D:href>\n
        \              </D:lockroot>\n              </D:activelock>\n             </D:lockdiscovery>\n
        \          </D:prop>\n           <D:status>HTTP/1.1 200 OK</D:status>\n         </D:propstat>\n
        \      </D:response>\n     </D:multistatus>\n   This resource has a single
        exclusive write lock on it, with an\n   infinite timeout.\n"
      title: 15.8.1.  Example - Retrieving DAV:lockdiscovery
    title: 15.8.  lockdiscovery Property
  - contents:
    - "15.9.  resourcetype Property\n   Name:   resourcetype\n   Purpose:   Specifies
      the nature of the resource.\n   Protected:   SHOULD be protected.  Resource
      type is generally decided\n      through the operation creating the resource
      (MKCOL vs PUT), not by\n      PROPPATCH.\n   COPY/MOVE behavior:   Generally
      a COPY/MOVE of a resource results in\n      the same type of resource at the
      destination.\n   Description:   MUST be defined on all DAV-compliant resources.
      \ Each\n      child element identifies a specific type the resource belongs
      to,\n      such as 'collection', which is the only resource type defined by\n
      \     this specification (see Section 14.3).  If the element contains\n      the
      'collection' child element plus additional unrecognized\n      elements, it
      should generally be treated as a collection.  If the\n      element contains
      no recognized child elements, it should be\n      treated as a non-collection
      resource.  The default value is empty.\n      This element MUST NOT contain
      text or mixed content.  Any custom\n      child element is considered to be
      an identifier for a resource\n      type.\n   Example: (fictional example to
      show extensibility)\n       <x:resourcetype xmlns:x=\"DAV:\">\n           <x:collection/>\n
      \          <f:search-results xmlns:f=\"http://www.example.com/ns\"/>\n       </x:resourcetype>\n"
    title: 15.9.  resourcetype Property
  - contents:
    - "15.10.  supportedlock Property\n   Name:   supportedlock\n   Purpose:   To
      provide a listing of the lock capabilities supported by\n      the resource.\n
      \  Protected:   MUST be protected.  Servers, not clients, determine what\n      lock
      mechanisms are supported.\n   COPY/MOVE behavior:   This property value is dependent
      on the kind of\n      locks supported at the destination, not on the value of
      the\n      property at the source resource.  Servers attempting to COPY to a\n
      \     destination should not attempt to set this property at the\n      destination.\n
      \  Description:   Returns a listing of the combinations of scope and\n      access
      types that may be specified in a lock request on the\n      resource.  Note
      that the actual contents are themselves controlled\n      by access controls,
      so a server is not required to provide\n      information the client is not
      authorized to see.  This property is\n      NOT lockable with respect to write
      locks (Section 7).\n   <!ELEMENT supportedlock (lockentry)* >\n"
    - contents:
      - "15.10.1.  Example - Retrieving DAV:supportedlock\n   >>Request\n     PROPFIND
        /container/ HTTP/1.1\n     Host: www.example.com\n     Content-Length: xxxx\n
        \    Content-Type: application/xml; charset=\"utf-8\"\n     <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n     <D:propfind xmlns:D=\"DAV:\">\n       <D:prop><D:supportedlock/></D:prop>\n
        \    </D:propfind>\n   >>Response\n     HTTP/1.1 207 Multi-Status\n     Content-Type:
        application/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n     <?xml
        version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus xmlns:D=\"DAV:\">\n
        \      <D:response>\n         <D:href>http://www.example.com/container/</D:href>\n
        \        <D:propstat>\n           <D:prop>\n             <D:supportedlock>\n
        \              <D:lockentry>\n                 <D:lockscope><D:exclusive/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \              <D:lockentry>\n                 <D:lockscope><D:shared/></D:lockscope>\n
        \                <D:locktype><D:write/></D:locktype>\n               </D:lockentry>\n
        \            </D:supportedlock>\n           </D:prop>\n           <D:status>HTTP/1.1
        200 OK</D:status>\n         </D:propstat>\n       </D:response>\n     </D:multistatus>\n"
      title: 15.10.1.  Example - Retrieving DAV:supportedlock
    title: 15.10.  supportedlock Property
  title: 15.  DAV Properties
- contents:
  - "16.  Precondition/Postcondition XML Elements\n   As introduced in Section 8.7,
    extra information on error conditions\n   can be included in the body of many
    status responses.  This section\n   makes requirements on the use of the error
    body mechanism and\n   introduces a number of precondition and postcondition codes.\n
    \  A \"precondition\" of a method describes the state of the server that\n   must
    be true for that method to be performed.  A \"postcondition\" of a\n   method
    describes the state of the server that must be true after that\n   method has
    been completed.\n   Each precondition and postcondition has a unique XML element\n
    \  associated with it.  In a 207 Multi-Status response, the XML element\n   MUST
    appear inside an 'error' element in the appropriate 'propstat or\n   'response'
    element depending on whether the condition applies to one\n   or more properties
    or to the resource as a whole.  In all other error\n   responses where this specification's
    'error' body is used, the\n   precondition/postcondition XML element MUST be returned
    as the child\n   of a top-level 'error' element in the response body, unless otherwise\n
    \  negotiated by the request, along with an appropriate response status.\n   The
    most common response status codes are 403 (Forbidden) if the\n   request should
    not be repeated because it will always fail, and 409\n   (Conflict) if it is expected
    that the user might be able to resolve\n   the conflict and resubmit the request.
    \ The 'error' element MAY\n   contain child elements with specific error information
    and MAY be\n   extended with any custom child elements.\n   This mechanism does
    not take the place of using a correct numeric\n   status code as defined here
    or in HTTP, because the client must\n   always be able to take a reasonable course
    of action based only on\n   the numeric code.  However, it does remove the need
    to define new\n   numeric codes.  The new machine-readable codes used for this
    purpose\n   are XML elements classified as preconditions and postconditions, so\n
    \  naturally, any group defining a new condition code can use their own\n   namespace.
    \ As always, the \"DAV:\" namespace is reserved for use by\n   IETF-chartered
    WebDAV working groups.\n   A server supporting this specification SHOULD use the
    XML error\n   whenever a precondition or postcondition defined in this document
    is\n   violated.  For error conditions not specified in this document, the\n   server
    MAY simply choose an appropriate numeric status and leave the\n   response body
    blank.  However, a server MAY instead use a custom\n   condition code and other
    supporting text, because even when clients\n   do not automatically recognize
    condition codes, they can be quite\n   useful in interoperability testing and
    debugging.\n   Example - Response with precondition code\n   >>Response\n      HTTP/1.1
    423 Locked\n      Content-Type: application/xml; charset=\"utf-8\"\n      Content-Length:
    xxxx\n      <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n      <D:error xmlns:D=\"DAV:\">\n
    \       <D:lock-token-submitted>\n          <D:href>/workspace/webdav/</D:href>\n
    \       </D:lock-token-submitted>\n      </D:error>\n   In this example, a client
    unaware of a depth-infinity lock on the\n   parent collection \"/workspace/webdav/\"
    attempted to modify the\n   collection member \"/workspace/webdav/proposal.doc\".\n
    \  Some other useful preconditions and postconditions have been defined\n   in
    other specifications extending WebDAV, such as [RFC3744] (see\n   particularly
    Section 7.1.1), [RFC3253], and [RFC3648].\n   All these elements are in the \"DAV:\"
    namespace.  If not specified\n   otherwise, the content for each condition's XML
    element is defined to\n   be empty.\n   Name:  lock-token-matches-request-uri\n
    \  Use with:  409 Conflict\n   Purpose:  (precondition) -- A request may include
    a Lock-Token header\n      to identify a lock for the UNLOCK method.  However,
    if the\n      Request-URI does not fall within the scope of the lock identified\n
    \     by the token, the server SHOULD use this error.  The lock may have\n      a
    scope that does not include the Request-URI, or the lock could\n      have disappeared,
    or the token may be invalid.\n   Name:  lock-token-submitted (precondition)\n
    \  Use with:  423 Locked\n   Purpose:  The request could not succeed because a
    lock token should\n      have been submitted.  This element, if present, MUST
    contain at\n      least one URL of a locked resource that prevented the request.
    \ In\n      cases of MOVE, COPY, and DELETE where collection locks are\n      involved,
    it can be difficult for the client to find out which\n      locked resource made
    the request fail -- but the server is only\n      responsible for returning one
    such locked resource.  The server\n      MAY return every locked resource that
    prevented the request from\n      succeeding if it knows them all.\n   <!ELEMENT
    lock-token-submitted (href+) >\n   Name:  no-conflicting-lock (precondition)\n
    \  Use with:  Typically 423 Locked\n   Purpose:  A LOCK request failed due the
    presence of an already\n      existing conflicting lock.  Note that a lock can
    be in conflict\n      although the resource to which the request was directed
    is only\n      indirectly locked.  In this case, the precondition code can be\n
    \     used to inform the client about the resource that is the root of\n      the
    conflicting lock, avoiding a separate lookup of the\n      \"lockdiscovery\" property.\n
    \  <!ELEMENT no-conflicting-lock (href)* >\n   Name:  no-external-entities\n   Use
    with:  403 Forbidden\n   Purpose:  (precondition) -- If the server rejects a client
    request\n      because the request body contains an external entity, the server\n
    \     SHOULD use this error.\n   Name:  preserved-live-properties\n   Use with:
    \ 409 Conflict\n   Purpose:  (postcondition) -- The server received an otherwise-valid\n
    \     MOVE or COPY request, but cannot maintain the live properties with\n      the
    same behavior at the destination.  It may be that the server\n      only supports
    some live properties in some parts of the\n      repository, or simply has an
    internal error.\n   Name:  propfind-finite-depth\n   Use with:  403 Forbidden\n
    \  Purpose:  (precondition) -- This server does not allow infinite-depth\n      PROPFIND
    requests on collections.\n   Name:  cannot-modify-protected-property\n   Use with:
    \ 403 Forbidden\n   Purpose:  (precondition) -- The client attempted to set a
    protected\n      property in a PROPPATCH (such as DAV:getetag).  See also\n      [RFC3253],
    Section 3.12.\n"
  title: 16.  Precondition/Postcondition XML Elements
- contents:
  - "17.  XML Extensibility in DAV\n   The XML namespace extension ([REC-XML-NAMES])
    is used in this\n   specification in order to allow for new XML elements to be
    added\n   without fear of colliding with other element names.  Although WebDAV\n
    \  request and response bodies can be extended by arbitrary XML\n   elements,
    which can be ignored by the message recipient, an XML\n   element in the \"DAV:\"
    namespace SHOULD NOT be used in the request or\n   response body unless that XML
    element is explicitly defined in an\n   IETF RFC reviewed by a WebDAV working
    group.\n   For WebDAV to be both extensible and backwards-compatible, both\n   clients
    and servers need to know how to behave when unexpected or\n   unrecognized command
    extensions are received.  For XML processing,\n   this means that clients and
    servers MUST process received XML\n   documents as if unexpected elements and
    attributes (and all children\n   of unrecognized elements) were not there.  An
    unexpected element or\n   attribute includes one that may be used in another context
    but is not\n   expected here.  Ignoring such items for purposes of processing
    can of\n   course be consistent with logging all information or presenting for\n
    \  debugging.\n   This restriction also applies to the processing, by clients,
    of DAV\n   property values where unexpected XML elements SHOULD be ignored\n   unless
    the property's schema declares otherwise.\n   This restriction does not apply
    to setting dead DAV properties on the\n   server where the server MUST record
    all XML elements.\n   Additionally, this restriction does not apply to the use
    of XML where\n   XML happens to be the content type of the entity body, for example,\n
    \  when used as the body of a PUT.\n   Processing instructions in XML SHOULD be
    ignored by recipients.\n   Thus, specifications extending WebDAV SHOULD NOT use
    processing\n   instructions to define normative behavior.\n   XML DTD fragments
    are included for all the XML elements defined in\n   this specification.  However,
    correct XML will not be valid according\n   to any DTD due to namespace usage
    and extension rules.  In\n   particular:\n   o  Elements (from this specification)
    are in the \"DAV:\" namespace,\n   o  Element ordering is irrelevant unless otherwise
    stated,\n   o  Extension attributes MAY be added,\n   o  For element type definitions
    of \"ANY\", the normative text\n      definition for that element defines what
    can be in it and what\n      that means.\n   o  For element type definitions of
    \"#PCDATA\", extension elements MUST\n      NOT be added.\n   o  For other element
    type definitions, including \"EMPTY\", extension\n      elements MAY be added.\n
    \  Note that this means that elements containing elements cannot be\n   extended
    to contain text, and vice versa.\n   With DTD validation relaxed by the rules
    above, the constraints\n   described by the DTD fragments are normative (see for
    example\n   Appendix A).  A recipient of a WebDAV message with an XML body MUST\n
    \  NOT validate the XML document according to any hard-coded or\n   dynamically-declared
    DTD.\n   Note that this section describes backwards-compatible extensibility\n
    \  rules.  There might also be times when an extension is designed not\n   to
    be backwards-compatible, for example, defining an extension that\n   reuses an
    XML element defined in this document but omitting one of\n   the child elements
    required by the DTDs in this specification.\n"
  title: 17.  XML Extensibility in DAV
- contents:
  - "18.  DAV Compliance Classes\n   A DAV-compliant resource can advertise several
    classes of compliance.\n   A client can discover the compliance classes of a resource
    by\n   executing OPTIONS on the resource and examining the \"DAV\" header\n   which
    is returned.  Note particularly that resources, rather than\n   servers, are spoken
    of as being compliant.  That is because\n   theoretically some resources on a
    server could support different\n   feature sets.  For example, a server could
    have a sub-repository\n   where an advanced feature like versioning was supported,
    even if that\n   feature was not supported on all sub-repositories.\n   Since
    this document describes extensions to the HTTP/1.1 protocol,\n   minimally all
    DAV-compliant resources, clients, and proxies MUST be\n   compliant with [RFC2616].\n
    \  A resource that is class 2 or class 3 compliant must also be class 1\n   compliant.\n"
  - contents:
    - "18.1.  Class 1\n   A class 1 compliant resource MUST meet all \"MUST\" requirements
      in all\n   sections of this document.\n   Class 1 compliant resources MUST return,
      at minimum, the value \"1\" in\n   the DAV header on all responses to the OPTIONS
      method.\n"
    title: 18.1.  Class 1
  - contents:
    - "18.2.  Class 2\n   A class 2 compliant resource MUST meet all class 1 requirements
      and\n   support the LOCK method, the DAV:supportedlock property, the DAV:\n
      \  lockdiscovery property, the Time-Out response header and the Lock-\n   Token
      request header.  A class 2 compliant resource SHOULD also\n   support the Timeout
      request header and the 'owner' XML element.\n   Class 2 compliant resources
      MUST return, at minimum, the values \"1\"\n   and \"2\" in the DAV header on
      all responses to the OPTIONS method.\n"
    title: 18.2.  Class 2
  - contents:
    - "18.3.  Class 3\n   A resource can explicitly advertise its support for the
      revisions to\n   [RFC2518] made in this document.  Class 1 MUST be supported
      as well.\n   Class 2 MAY be supported.  Advertising class 3 support in addition
      to\n   class 1 and 2 means that the server supports all the requirements in\n
      \  this specification.  Advertising class 3 and class 1 support, but not\n   class
      2, means that the server supports all the requirements in this\n   specification
      except possibly those that involve locking support.\n   Example:\n            DAV:
      1, 3\n"
    title: 18.3.  Class 3
  title: 18.  DAV Compliance Classes
- contents:
  - "19.  Internationalization Considerations\n   In the realm of internationalization,
    this specification complies\n   with the IETF Character Set Policy [RFC2277].
    \ In this specification,\n   human-readable fields can be found either in the
    value of a property,\n   or in an error message returned in a response entity
    body.  In both\n   cases, the human-readable content is encoded using XML, which
    has\n   explicit provisions for character set tagging and encoding, and\n   requires
    that XML processors read XML elements encoded, at minimum,\n   using the UTF-8
    [RFC3629] and UTF-16 [RFC2781] encodings of the ISO\n   10646 multilingual plane.
    \ XML examples in this specification\n   demonstrate use of the charset parameter
    of the Content-Type header\n   (defined in [RFC3023]), as well as XML charset
    declarations.\n   XML also provides a language tagging capability for specifying
    the\n   language of the contents of a particular XML element.  The \"xml:lang\"\n
    \  attribute appears on an XML element to identify the language of its\n   content
    and attributes.  See [REC-XML] for definitions of values and\n   scoping.\n   WebDAV
    applications MUST support the character set tagging, character\n   set encoding,
    and the language tagging functionality of the XML\n   specification.  Implementors
    of WebDAV applications are strongly\n   encouraged to read \"XML Media Types\"
    [RFC3023] for instruction on\n   which MIME media type to use for XML transport,
    and on use of the\n   charset parameter of the Content-Type header.\n   Names
    used within this specification fall into four categories: names\n   of protocol
    elements such as methods and headers, names of XML\n   elements, names of properties,
    and names of conditions.  Naming of\n   protocol elements follows the precedent
    of HTTP, using English names\n   encoded in US-ASCII for methods and headers.
    \ Since these protocol\n   elements are not visible to users, and are simply long
    token\n   identifiers, they do not need to support multiple languages.\n   Similarly,
    the names of XML elements used in this specification are\n   not visible to the
    user and hence do not need to support multiple\n   languages.\n   WebDAV property
    names are qualified XML names (pairs of XML namespace\n   name and local name).
    \ Although some applications (e.g., a generic\n   property viewer) will display
    property names directly to their users,\n   it is expected that the typical application
    will use a fixed set of\n   properties, and will provide a mapping from the property
    name and\n   namespace to a human-readable field when displaying the property
    name\n   to a user.  It is only in the case where the set of properties is not\n
    \  known ahead of time that an application need display a property name\n   to
    a user.  We recommend that applications provide human-readable\n   property names
    wherever feasible.\n   For error reporting, we follow the convention of HTTP/1.1
    status\n   codes, including with each status code a short, English description\n
    \  of the code (e.g., 423 (Locked)).  While the possibility exists that\n   a
    poorly crafted user agent would display this message to a user,\n   internationalized
    applications will ignore this message, and display\n   an appropriate message
    in the user's language and character set.\n   Since interoperation of clients
    and servers does not require locale\n   information, this specification does not
    specify any mechanism for\n   transmission of this information.\n"
  title: 19.  Internationalization Considerations
- contents:
  - "20.  Security Considerations\n   This section is provided to detail issues concerning
    security\n   implications of which WebDAV applications need to be aware.\n   All
    of the security considerations of HTTP/1.1 (discussed in\n   [RFC2616]) and XML
    (discussed in [RFC3023]) also apply to WebDAV.  In\n   addition, the security
    risks inherent in remote authoring require\n   stronger authentication technology,
    introduce several new privacy\n   concerns, and may increase the hazards from
    poor server design.\n   These issues are detailed below.\n"
  - contents:
    - "20.1.  Authentication of Clients\n   Due to their emphasis on authoring, WebDAV
      servers need to use\n   authentication technology to protect not just access
      to a network\n   resource, but the integrity of the resource as well.  Furthermore,\n
      \  the introduction of locking functionality requires support for\n   authentication.\n
      \  A password sent in the clear over an insecure channel is an\n   inadequate
      means for protecting the accessibility and integrity of a\n   resource as the
      password may be intercepted.  Since Basic\n   authentication for HTTP/1.1 performs
      essentially clear text\n   transmission of a password, Basic authentication
      MUST NOT be used to\n   authenticate a WebDAV client to a server unless the
      connection is\n   secure.  Furthermore, a WebDAV server MUST NOT send a Basic\n
      \  authentication challenge in a WWW-Authenticate header unless the\n   connection
      is secure.  An example of a secure connection would be a\n   Transport Layer
      Security (TLS) connection employing a strong cipher\n   suite and server authentication.\n
      \  WebDAV applications MUST support the Digest authentication scheme\n   [RFC2617].
      \ Since Digest authentication verifies that both parties to\n   a communication
      know a shared secret, a password, without having to\n   send that secret in
      the clear, Digest authentication avoids the\n   security problems inherent in
      Basic authentication while providing a\n   level of authentication that is useful
      in a wide range of scenarios.\n"
    title: 20.1.  Authentication of Clients
  - contents:
    - "20.2.  Denial of Service\n   Denial-of-service attacks are of special concern
      to WebDAV servers.\n   WebDAV plus HTTP enables denial-of-service attacks on
      every part of a\n   system's resources.\n   o  The underlying storage can be
      attacked by PUTting extremely large\n      files.\n   o  Asking for recursive
      operations on large collections can attack\n      processing time.\n   o  Making
      multiple pipelined requests on multiple connections can\n      attack network
      connections.\n   WebDAV servers need to be aware of the possibility of a denial-of-\n
      \  service attack at all levels.  The proper response to such an attack\n   MAY
      be to simply drop the connection.  Or, if the server is able to\n   make a response,
      the server MAY use a 400-level status request such\n   as 400 (Bad Request)
      and indicate why the request was refused (a 500-\n   level status response would
      indicate that the problem is with the\n   server, whereas unintentional DoS
      attacks are something the client is\n   capable of remedying).\n"
    title: 20.2.  Denial of Service
  - contents:
    - "20.3.  Security through Obscurity\n   WebDAV provides, through the PROPFIND
      method, a mechanism for listing\n   the member resources of a collection.  This
      greatly diminishes the\n   effectiveness of security or privacy techniques that
      rely only on the\n   difficulty of discovering the names of network resources.
      \ Users of\n   WebDAV servers are encouraged to use access control techniques
      to\n   prevent unwanted access to resources, rather than depending on the\n
      \  relative obscurity of their resource names.\n"
    title: 20.3.  Security through Obscurity
  - contents:
    - "20.4.  Privacy Issues Connected to Locks\n   When submitting a lock request,
      a user agent may also submit an\n   'owner' XML field giving contact information
      for the person taking\n   out the lock (for those cases where a person, rather
      than a robot, is\n   taking out the lock).  This contact information is stored
      in a DAV:\n   lockdiscovery property on the resource, and can be used by other\n
      \  collaborators to begin negotiation over access to the resource.\n   However,
      in many cases, this contact information can be very private,\n   and should
      not be widely disseminated.  Servers SHOULD limit read\n   access to the DAV:lockdiscovery
      property as appropriate.\n   Furthermore, user agents SHOULD provide control
      over whether contact\n   information is sent at all, and if contact information
      is sent,\n   control over exactly what information is sent.\n"
    title: 20.4.  Privacy Issues Connected to Locks
  - contents:
    - "20.5.  Privacy Issues Connected to Properties\n   Since property values are
      typically used to hold information such as\n   the author of a document, there
      is the possibility that privacy\n   concerns could arise stemming from widespread
      access to a resource's\n   property data.  To reduce the risk of inadvertent
      release of private\n   information via properties, servers are encouraged to
      develop access\n   control mechanisms that separate read access to the resource
      body and\n   read access to the resource's properties.  This allows a user to\n
      \  control the dissemination of their property data without overly\n   restricting
      access to the resource's contents.\n"
    title: 20.5.  Privacy Issues Connected to Properties
  - contents:
    - "20.6.  Implications of XML Entities\n   XML supports a facility known as \"external
      entities\", defined in\n   Section 4.2.2 of [REC-XML], which instructs an XML
      processor to\n   retrieve and include additional XML.  An external XML entity
      can be\n   used to append or modify the document type declaration (DTD)\n   associated
      with an XML document.  An external XML entity can also be\n   used to include
      XML within the content of an XML document.  For non-\n   validating XML, such
      as the XML used in this specification, including\n   an external XML entity
      is not required by XML.  However, XML does\n   state that an XML processor may,
      at its discretion, include the\n   external XML entity.\n   External XML entities
      have no inherent trustworthiness and are\n   subject to all the attacks that
      are endemic to any HTTP GET request.\n   Furthermore, it is possible for an
      external XML entity to modify the\n   DTD, and hence affect the final form of
      an XML document, in the worst\n   case, significantly modifying its semantics
      or exposing the XML\n   processor to the security risks discussed in [RFC3023].
      \ Therefore,\n   implementers must be aware that external XML entities should
      be\n   treated as untrustworthy.  If a server chooses not to handle external\n
      \  XML entities, it SHOULD respond to requests containing external\n   entities
      with the 'no-external-entities' condition code.\n   There is also the scalability
      risk that would accompany a widely\n   deployed application that made use of
      external XML entities.  In this\n   situation, it is possible that there would
      be significant numbers of\n   requests for one external XML entity, potentially
      overloading any\n   server that fields requests for the resource containing
      the external\n   XML entity.\n   Furthermore, there's also a risk based on the
      evaluation of \"internal\n   entities\" as defined in Section 4.2.2 of [REC-XML].
      \ A small,\n   carefully crafted request using nested internal entities may
      require\n   enormous amounts of memory and/or processing time to process.  Server\n
      \  implementers should be aware of this risk and configure their XML\n   parsers
      so that requests like these can be detected and rejected as\n   early as possible.\n"
    title: 20.6.  Implications of XML Entities
  - contents:
    - "20.7.  Risks Connected with Lock Tokens\n   This specification encourages the
      use of \"A Universally Unique\n   Identifier (UUID) URN Namespace\" ([RFC4122])
      for lock tokens\n   (Section 6.5), in order to guarantee their uniqueness across
      space\n   and time.  Version 1 UUIDs (defined in Section 4) MAY contain a\n
      \  \"node\" field that \"consists of an IEEE 802 MAC address, usually the\n
      \  host address.  For systems with multiple IEEE addresses, any\n   available
      one can be used\".  Since a WebDAV server will issue many\n   locks over its
      lifetime, the implication is that it may also be\n   publicly exposing its IEEE
      802 address.\n   There are several risks associated with exposure of IEEE 802\n
      \  addresses.  Using the IEEE 802 address:\n   o  It is possible to track the
      movement of hardware from subnet to\n      subnet.\n   o  It may be possible
      to identify the manufacturer of the hardware\n      running a WebDAV server.\n
      \  o  It may be possible to determine the number of each type of\n      computer
      running WebDAV.\n   This risk only applies to host-address-based UUID versions.
      \ Section\n   4 of [RFC4122] describes several other mechanisms for generating\n
      \  UUIDs that do not involve the host address and therefore do not\n   suffer
      from this risk.\n"
    title: 20.7.  Risks Connected with Lock Tokens
  - contents:
    - "20.8.  Hosting Malicious Content\n   HTTP has the ability to host programs
      that are executed on client\n   machines.  These programs can take many forms
      including Web scripts,\n   executables, plug-in modules, and macros in documents.
      \ WebDAV does\n   not change any of the security concerns around these programs,
      yet\n   often WebDAV is used in contexts where a wide range of users can\n   publish
      documents on a server.  The server might not have a close\n   trust relationship
      with the author that is publishing the document.\n   Servers that allow clients
      to publish arbitrary content can usefully\n   implement precautions to check
      that content published to the server\n   is not harmful to other clients.  Servers
      could do this by techniques\n   such as restricting the types of content that
      is allowed to be\n   published and running virus and malware detection software
      on\n   published content.  Servers can also mitigate the risk by having\n   appropriate
      access restriction and authentication of users that are\n   allowed to publish
      content to the server.\n"
    title: 20.8.  Hosting Malicious Content
  title: 20.  Security Considerations
- contents:
  - '21.  IANA Considerations

    '
  - contents:
    - "21.1.  New URI Schemes\n   This specification defines two URI schemes:\n   1.
      \ the \"opaquelocktoken\" scheme defined in Appendix C, and\n   2.  the \"DAV\"
      URI scheme, which historically was used in [RFC2518] to\n       disambiguate
      WebDAV property and XML element names and which\n       continues to be used
      for that purpose in this specification and\n       others extending WebDAV.
      \ Creation of identifiers in the \"DAV:\"\n       namespace is controlled by
      the IETF.\n   Note that defining new URI schemes for XML namespaces is now\n
      \  discouraged.  \"DAV:\" was defined before standard best practices\n   emerged.\n"
    title: 21.1.  New URI Schemes
  - contents:
    - "21.2.  XML Namespaces\n   XML namespaces disambiguate WebDAV property names
      and XML elements.\n   Any WebDAV user or application can define a new namespace
      in order to\n   create custom properties or extend WebDAV XML syntax.  IANA
      does not\n   need to manage such namespaces, property names, or element names.\n"
    title: 21.2.  XML Namespaces
  - contents:
    - "21.3.  Message Header Fields\n   The message header fields below should be
      added to the permanent\n   registry (see [RFC3864]).\n"
    - contents:
      - "21.3.1.  DAV\n   Header field name: DAV\n   Applicable protocol: http\n   Status:
        standard\n   Author/Change controller: IETF\n   Specification document: this
        specification (Section 10.1)\n"
      title: 21.3.1.  DAV
    - contents:
      - "21.3.2.  Depth\n   Header field name: Depth\n   Applicable protocol: http\n
        \  Status: standard\n   Author/Change controller: IETF\n   Specification document:
        this specification (Section 10.2)\n"
      title: 21.3.2.  Depth
    - contents:
      - "21.3.3.  Destination\n   Header field name: Destination\n   Applicable protocol:
        http\n   Status: standard\n   Author/Change controller: IETF\n   Specification
        document: this specification (Section 10.3)\n"
      title: 21.3.3.  Destination
    - contents:
      - "21.3.4.  If\n   Header field name: If\n   Applicable protocol: http\n   Status:
        standard\n   Author/Change controller: IETF\n   Specification document: this
        specification (Section 10.4)\n"
      title: 21.3.4.  If
    - contents:
      - "21.3.5.  Lock-Token\n   Header field name: Lock-Token\n   Applicable protocol:
        http\n   Status: standard\n   Author/Change controller: IETF\n   Specification
        document: this specification (Section 10.5)\n"
      title: 21.3.5.  Lock-Token
    - contents:
      - "21.3.6.  Overwrite\n   Header field name: Overwrite\n   Applicable protocol:
        http\n   Status: standard\n   Author/Change controller: IETF\n   Specification
        document: this specification (Section 10.6)\n"
      title: 21.3.6.  Overwrite
    - contents:
      - "21.3.7.  Timeout\n   Header field name: Timeout\n   Applicable protocol:
        http\n   Status: standard\n   Author/Change controller: IETF\n   Specification
        document: this specification (Section 10.7)\n"
      title: 21.3.7.  Timeout
    title: 21.3.  Message Header Fields
  - contents:
    - "21.4.  HTTP Status Codes\n   This specification defines the HTTP status codes\n
      \  o  207 Multi-Status (Section 11.1)\n   o  422 Unprocessable Entity (Section
      11.2),\n   o  423 Locked (Section 11.3),\n   o  424 Failed Dependency (Section
      11.4) and\n   o  507 Insufficient Storage (Section 11.5),\n   to be updated
      in the registry at\n   <http://www.iana.org/assignments/http-status-codes>.\n
      \  Note: the HTTP status code 102 (Processing) has been removed in this\n   specification;
      its IANA registration should continue to reference RFC\n   2518.\n"
    title: 21.4.  HTTP Status Codes
  title: 21.  IANA Considerations
- contents:
  - "22.  Acknowledgements\n   A specification such as this thrives on piercing critical
    review and\n   withers from apathetic neglect.  The authors gratefully acknowledge\n
    \  the contributions of the following people, whose insights were so\n   valuable
    at every stage of our work.\n   Contributors to RFC 2518\n   Terry Allen, Harald
    Alvestrand, Jim Amsden, Becky Anderson, Alan\n   Babich, Sanford Barr, Dylan Barrell,
    Bernard Chester, Tim Berners-\n   Lee, Dan Connolly, Jim Cunningham, Ron Daniel,
    Jr., Jim Davis, Keith\n   Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand,
    Lee\n   Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan\n   Freier,
    George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis\n   Hamilton, Steve
    Henning, Mead Himelstein, Alex Hopmann, Andre van der\n   Hoek, Ben Laurie, Paul
    Leach, Ora Lassila, Karen MacArthur, Steven\n   Martin, Larry Masinter, Michael
    Mealling, Keith Moore, Thomas Narten,\n   Henrik Nielsen, Kenji Ota, Bob Parker,
    Glenn Peterson, Jon Radoff,\n   Saveen Reddy, Henry Sanders, Christopher Seiwald,
    Judith Slein, Mike\n   Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, Kenji
    Takahashi,\n   Richard N. Taylor, Robert Thau, John Turner, Sankar Virdhagriswaran,\n
    \  Fabio Vitali, Gregory Woodhouse, and Lauren Wood.\n   Two from this list deserve
    special mention.  The contributions by\n   Larry Masinter have been invaluable;
    he both helped the formation of\n   the working group and patiently coached the
    authors along the way.\n   In so many ways he has set high standards that we have
    toiled to\n   meet.  The contributions of Judith Slein were also invaluable; by\n
    \  clarifying the requirements and in patiently reviewing version after\n   version,
    she both improved this specification and expanded our minds\n   on document management.\n
    \  We would also like to thank John Turner for developing the XML DTD.\n   The
    authors of RFC 2518 were Yaron Goland, Jim Whitehead, A. Faizi,\n   Steve Carter,
    and D. Jensen.  Although their names had to be removed\n   due to IETF author
    count restrictions, they can take credit for the\n   majority of the design of
    WebDAV.\n   Additional Acknowledgements for This Specification\n   Significant
    contributors of text for this specification are listed as\n   contributors in
    the section below.  We must also gratefully\n   acknowledge Geoff Clemm, Joel
    Soderberg, and Dan Brotsky for hashing\n   out specific text on the list or in
    meetings.  Joe Hildebrand and\n   Cullen Jennings helped close many issues.  Barry
    Lind described an\n   additional security consideration and Cullen Jennings provided
    text\n   for that consideration.  Jason Crawford tracked issue status for this\n
    \  document for a period of years, followed by Elias Sinderson.\n"
  title: 22.  Acknowledgements
- contents:
  - "23.  Contributors to This Specification\n   Julian Reschke\n   <green/>bytes
    GmbH\n   Hafenweg 16, 48155 Muenster, Germany\n   EMail: julian.reschke@greenbytes.de\n
    \  Elias Sinderson\n   University of California, Santa Cruz\n   1156 High Street,
    Santa Cruz, CA 95064\n   EMail: elias@cse.ucsc.edu\n   Jim Whitehead\n   University
    of California, Santa Cruz\n   1156 High Street, Santa Cruz, CA 95064\n   EMail:
    ejw@soe.ucsc.edu\n"
  title: 23.  Contributors to This Specification
- contents:
  - "24.  Authors of RFC 2518\n   Y. Y. Goland\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA 98052-6399\n   EMail: yarong@microsoft.com\n   E. J. Whitehead,
    Jr.\n   Dept. Of Information and Computer Science\n   University of California,
    Irvine\n   Irvine, CA 92697-3425\n   EMail: ejw@ics.uci.edu\n   A. Faizi\n   Netscape\n
    \  685 East Middlefield Road\n   Mountain View, CA 94043\n   EMail: asad@netscape.com\n
    \  S. R. Carter\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem,
    UT 84097-2399\n   EMail: srcarter@novell.com\n   D. Jensen\n   Novell\n   1555
    N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   EMail: dcjensen@novell.com\n"
  title: 24.  Authors of RFC 2518
- contents:
  - '25.  References

    '
  - contents:
    - "25.1.  Normative References\n   [REC-XML]          Bray, T., Paoli, J., Sperberg-McQueen,
      C., Maler,\n                      E., and F. Yergeau, \"Extensible Markup Language\n
      \                     (XML) 1.0 (Fourth Edition)\", W3C REC-xml-20060816,\n
      \                     August 2006,\n                      <http://www.w3.org/TR/2006/REC-xml-20060816/>.\n
      \  [REC-XML-INFOSET]  Cowan, J. and R. Tobin, \"XML Information Set\n                      (Second
      Edition)\", W3C REC-xml-infoset-20040204,\n                      February 2004,
      <http://www.w3.org/TR/2004/\n                      REC-xml-infoset-20040204/>.\n
      \  [REC-XML-NAMES]    Bray, T., Hollander, D., Layman, A., and R. Tobin,\n                      \"Namespaces
      in XML 1.0 (Second Edition)\", W3C REC-\n                      xml-names-20060816,
      August 2006, <http://\n                      www.w3.org/TR/2006/REC-xml-names-20060816/>.\n
      \  [RFC2119]          Bradner, S., \"Key words for use in RFCs to\n                      Indicate
      Requirement Levels\", BCP 14, RFC 2119,\n                      March 1997.\n
      \  [RFC2277]          Alvestrand, H., \"IETF Policy on Character Sets and\n
      \                     Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC2616]
      \         Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n                      Masinter,
      L., Leach, P., and T. Berners-Lee,\n                      \"Hypertext Transfer
      Protocol -- HTTP/1.1\",\n                      RFC 2616, June 1999.\n   [RFC2617]
      \         Franks, J., Hallam-Baker, P., Hostetler, J.,\n                      Lawrence,
      S., Leach, P., Luotonen, A., and L.\n                      Stewart, \"HTTP Authentication:
      Basic and Digest\n                      Access Authentication\", RFC 2617, June
      1999.\n   [RFC3339]          Klyne, G., Ed. and C. Newman, \"Date and Time on\n
      \                     the Internet: Timestamps\", RFC 3339, July 2002.\n   [RFC3629]
      \         Yergeau, F., \"UTF-8, a transformation format of\n                      ISO
      10646\", STD 63, RFC 3629, November 2003.\n   [RFC3986]          Berners-Lee,
      T., Fielding, R., and L. Masinter,\n                      \"Uniform Resource
      Identifier (URI): Generic\n                      Syntax\", STD 66, RFC 3986,
      January 2005.\n   [RFC4122]          Leach, P., Mealling, M., and R. Salz, \"A\n
      \                     Universally Unique IDentifier (UUID) URN\n                      Namespace\",
      RFC 4122, July 2005.\n"
    title: 25.1.  Normative References
  - contents:
    - "25.2.  Informative References\n   [RFC2291]          Slein, J., Vitali, F.,
      Whitehead, E., and D.\n                      Durand, \"Requirements for a Distributed
      Authoring\n                      and Versioning Protocol for the World Wide
      Web\",\n                      RFC 2291, February 1998.\n   [RFC2518]          Goland,
      Y., Whitehead, E., Faizi, A., Carter, S.,\n                      and D. Jensen,
      \"HTTP Extensions for Distributed\n                      Authoring -- WEBDAV\",
      RFC 2518, February 1999.\n   [RFC2781]          Hoffman, P. and F. Yergeau,
      \"UTF-16, an encoding\n                      of ISO 10646\", RFC 2781, February
      2000.\n   [RFC3023]          Murata, M., St. Laurent, S., and D. Kohn, \"XML\n
      \                     Media Types\", RFC 3023, January 2001.\n   [RFC3253]          Clemm,
      G., Amsden, J., Ellison, T., Kaler, C., and\n                      J. Whitehead,
      \"Versioning Extensions to WebDAV\n                      (Web Distributed Authoring
      and Versioning)\",\n                      RFC 3253, March 2002.\n   [RFC3648]
      \         Whitehead, J. and J. Reschke, Ed., \"Web\n                      Distributed
      Authoring and Versioning (WebDAV)\n                      Ordered Collections
      Protocol\", RFC 3648,\n                      December 2003.\n   [RFC3744]          Clemm,
      G., Reschke, J., Sedlar, E., and J.\n                      Whitehead, \"Web
      Distributed Authoring and\n                      Versioning (WebDAV) Access
      Control Protocol\",\n                      RFC 3744, May 2004.\n   [RFC3864]
      \         Klyne, G., Nottingham, M., and J. Mogul,\n                      \"Registration
      Procedures for Message Header\n                      Fields\", BCP 90, RFC 3864,
      September 2004.\n"
    title: 25.2.  Informative References
  title: 25.  References
- contents:
  - 'Appendix A.  Notes on Processing XML Elements

    '
  - contents:
    - "A.1.  Notes on Empty XML Elements\n   XML supports two mechanisms for indicating
      that an XML element does\n   not have any content.  The first is to declare
      an XML element of the\n   form <A></A>.  The second is to declare an XML element
      of the form\n   <A/>.  The two XML elements are semantically identical.\n"
    title: A.1.  Notes on Empty XML Elements
  - contents:
    - "A.2.  Notes on Illegal XML Processing\n   XML is a flexible data format that
      makes it easy to submit data that\n   appears legal but in fact is not.  The
      philosophy of \"Be flexible in\n   what you accept and strict in what you send\"
      still applies, but it\n   must not be applied inappropriately.  XML is extremely
      flexible in\n   dealing with issues of whitespace, element ordering, inserting
      new\n   elements, etc.  This flexibility does not require extension,\n   especially
      not in the area of the meaning of elements.\n   There is no kindness in accepting
      illegal combinations of XML\n   elements.  At best, it will cause an unwanted
      result and at worst it\n   can cause real damage.\n"
    title: A.2.  Notes on Illegal XML Processing
  - contents:
    - "A.3.  Example - XML Syntax Error\n   The following request body for a PROPFIND
      method is illegal.\n      <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n      <D:propfind
      xmlns:D=\"DAV:\">\n       <D:allprop/>\n       <D:propname/>\n      </D:propfind>\n
      \  The definition of the propfind element only allows for the allprop or\n   the
      propname element, not both.  Thus, the above is an error and must\n   be responded
      to with a 400 (Bad Request).\n   Imagine, however, that a server wanted to be
      \"kind\" and decided to\n   pick the allprop element as the true element and
      respond to it.  A\n   client running over a bandwidth limited line who intended
      to execute\n   a propname would be in for a big surprise if the server treated
      the\n   command as an allprop.\n   Additionally, if a server were lenient and
      decided to reply to this\n   request, the results would vary randomly from server
      to server, with\n   some servers executing the allprop directive, and others
      executing\n   the propname directive.  This reduces interoperability rather
      than\n   increasing it.\n"
    title: A.3.  Example - XML Syntax Error
  - contents:
    - "A.4.  Example - Unexpected XML Element\n   The previous example was illegal
      because it contained two elements\n   that were explicitly banned from appearing
      together in the propfind\n   element.  However, XML is an extensible language,
      so one can imagine\n   new elements being defined for use with propfind.  Below
      is the\n   request body of a PROPFIND and, like the previous example, must be\n
      \  rejected with a 400 (Bad Request) by a server that does not\n   understand
      the expired-props element.\n      <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
      \     <D:propfind xmlns:D=\"DAV:\"\n      xmlns:E=\"http://www.example.com/standards/props/\">\n
      \      <E:expired-props/>\n      </D:propfind>\n   To understand why a 400 (Bad
      Request) is returned, let us look at the\n   request body as the server unfamiliar
      with expired-props sees it.\n      <?xml version=\"1.0\" encoding=\"utf-8\"
      ?>\n      <D:propfind xmlns:D=\"DAV:\"\n                  xmlns:E=\"http://www.example.com/standards/props/\">\n
      \     </D:propfind>\n   As the server does not understand the 'expired-props'
      element,\n   according to the WebDAV-specific XML processing rules specified
      in\n   Section 17, it must process the request as if the element were not\n
      \  there.  Thus, the server sees an empty propfind, which by the\n   definition
      of the propfind element is illegal.\n   Please note that had the extension been
      additive, it would not\n   necessarily have resulted in a 400 (Bad Request).
      \ For example,\n   imagine the following request body for a PROPFIND:\n      <?xml
      version=\"1.0\" encoding=\"utf-8\" ?>\n      <D:propfind xmlns:D=\"DAV:\"\n
      \                 xmlns:E=\"http://www.example.com/standards/props/\">\n       <D:propname/>\n
      \      <E:leave-out>*boss*</E:leave-out>\n      </D:propfind>\n   The previous
      example contains the fictitious element leave-out.  Its\n   purpose is to prevent
      the return of any property whose name matches\n   the submitted pattern.  If
      the previous example were submitted to a\n   server unfamiliar with 'leave-out',
      the only result would be that the\n   'leave-out' element would be ignored and
      a propname would be\n   executed.\n"
    title: A.4.  Example - Unexpected XML Element
  title: Appendix A.  Notes on Processing XML Elements
- contents:
  - "Appendix B.  Notes on HTTP Client Compatibility\n   WebDAV was designed to be,
    and has been found to be, backward-\n   compatible with HTTP 1.1.  The PUT and
    DELETE methods are defined in\n   HTTP and thus may be used by HTTP clients as
    well as WebDAV-aware\n   clients, but the responses to PUT and DELETE have been
    extended in\n   this specification in ways that only a WebDAV client would be\n
    \  entirely prepared for.  Some theoretical concerns were raised about\n   whether
    those responses would cause interoperability problems with\n   HTTP-only clients,
    and this section addresses those concerns.\n   Since any HTTP client ought to
    handle unrecognized 400-level and 500-\n   level status codes as errors, the following
    new status codes should\n   not present any issues: 422, 423, and 507 (424 is
    also a new status\n   code but it appears only in the body of a Multistatus response.)
    \ So,\n   for example, if an HTTP client attempted to PUT or DELETE a locked\n
    \  resource, the 423 Locked response ought to result in a generic error\n   presented
    to the user.\n   The 207 Multistatus response is interesting because an HTTP client\n
    \  issuing a DELETE request to a collection might interpret a 207\n   response
    as a success, even though it does not realize the resource\n   is a collection
    and cannot understand that the DELETE operation might\n   have been a complete
    or partial failure.  That interpretation isn't\n   entirely justified, because
    a 200-level response indicates that the\n   server \"received, understood, and
    accepted\" the request, not that the\n   request resulted in complete success.\n
    \  One option is that a server could treat a DELETE of a collection as\n   an
    atomic operation, and use either 204 No Content in case of\n   success, or some
    appropriate error response (400 or 500 level) for an\n   error.  This approach
    would indeed maximize backward compatibility.\n   However, since interoperability
    tests and working group discussions\n   have not turned up any instances of HTTP
    clients issuing a DELETE\n   request against a WebDAV collection, this concern
    is more theoretical\n   than practical.  Thus, servers are likely to be completely
    successful\n   at interoperating with HTTP clients even if they treat any collection\n
    \  DELETE request as a WebDAV request and send a 207 Multi-Status\n   response.\n
    \  In general, server implementations are encouraged to use the detailed\n   responses
    and other mechanisms defined in this document rather than\n   make changes for
    theoretical interoperability concerns.\n"
  title: Appendix B.  Notes on HTTP Client Compatibility
- contents:
  - "Appendix C.  The 'opaquelocktoken' Scheme and URIs\n   The 'opaquelocktoken'
    URI scheme was defined in [RFC2518] (and\n   registered by IANA) in order to create
    syntactically correct and\n   easy-to-generate URIs out of UUIDs, intended to
    be used as lock\n   tokens and to be unique across all resources for all time.\n
    \  An opaquelocktoken URI is constructed by concatenating the\n   'opaquelocktoken'
    scheme with a UUID, along with an optional\n   extension.  Servers can create
    new UUIDs for each new lock token.  If\n   a server wishes to reuse UUIDs, the
    server MUST add an extension, and\n   the algorithm generating the extension MUST
    guarantee that the same\n   extension will never be used twice with the associated
    UUID.\n     OpaqueLockToken-URI = \"opaquelocktoken:\" UUID [Extension]\n       ;
    UUID is defined in Section 3 of [RFC4122].  Note that LWS\n       ; is not allowed
    between elements of\n       ; this production.\n     Extension = path\n       ;
    path is defined in Section 3.3 of [RFC3986]\n"
  title: Appendix C.  The 'opaquelocktoken' Scheme and URIs
- contents:
  - "Appendix D.  Lock-null Resources\n   The original WebDAV model for locking unmapped
    URLs created \"lock-\n   null resources\".  This model was over-complicated and
    some\n   interoperability and implementation problems were discovered.  The\n
    \  new WebDAV model for locking unmapped URLs (see Section 7.3) creates\n   \"locked
    empty resources\".  Lock-null resources are deprecated.  This\n   section discusses
    the original model briefly because clients MUST be\n   able to handle either model.\n
    \  In the original \"lock-null resource\" model, which is no longer\n   recommended
    for implementation:\n   o  A lock-null resource sometimes appeared as \"Not Found\".
    \ The\n      server responds with a 404 or 405 to any method except for PUT,\n
    \     MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.\n   o  A lock-null resource does
    however show up as a member of its\n      parent collection.\n   o  The server
    removes the lock-null resource entirely (its URI\n      becomes unmapped) if its
    lock goes away before it is converted to\n      a regular resource.  Recall that
    locks go away not only when they\n      expire or are unlocked, but are also removed
    if a resource is\n      renamed or moved, or if any parent collection is renamed
    or moved.\n   o  The server converts the lock-null resource into a regular resource\n
    \     if a PUT request to the URL is successful.\n   o  The server converts the
    lock-null resource into a collection if a\n      MKCOL request to the URL is successful
    (though interoperability\n      experience showed that not all servers followed
    this requirement).\n   o  Property values were defined for DAV:lockdiscovery and
    DAV:\n      supportedlock properties but not necessarily for other properties\n
    \     like DAV:getcontenttype.\n   Clients can easily interoperate both with servers
    that support the\n   old model \"lock-null resources\" and the recommended model
    of \"locked\n   empty resources\" by only attempting PUT after a LOCK to an unmapped\n
    \  URL, not MKCOL or GET.\n"
  - contents:
    - "D.1.  Guidance for Clients Using LOCK to Create Resources\n   A WebDAV client
      implemented to this specification might find servers\n   that create lock-null
      resources (implemented before this\n   specification using [RFC2518]) as well
      as servers that create locked\n   empty resources.  The response to the LOCK
      request will not indicate\n   what kind of resource was created.  There are
      a few techniques that\n   help the client deal with either type.\n      If the
      client wishes to avoid accidentally creating either lock-\n      null or empty
      locked resources, an \"If-Match: *\" header can be\n      included with LOCK
      requests to prevent the server from creating a\n      new resource.\n      If
      a LOCK request creates a resource and the client subsequently\n      wants to
      overwrite that resource using a COPY or MOVE request, the\n      client should
      include an \"Overwrite: T\" header.\n      If a LOCK request creates a resource
      and the client then decides\n      to get rid of that resource, a DELETE request
      is supposed to fail\n      on a lock-null resource and UNLOCK should be used
      instead.  But\n      with a locked empty resource, UNLOCK doesn't make the resource\n
      \     disappear.  Therefore, the client might have to try both requests\n      and
      ignore an error in one of the two requests.\n"
    title: D.1.  Guidance for Clients Using LOCK to Create Resources
  title: Appendix D.  Lock-null Resources
- contents:
  - "Appendix E.  Guidance for Clients Desiring to Authenticate\n   Many WebDAV clients
    that have already been implemented have account\n   settings (similar to the way
    email clients store IMAP account\n   settings).  Thus, the WebDAV client would
    be able to authenticate\n   with its first couple requests to the server, provided
    it had a way\n   to get the authentication challenge from the server with realm
    name,\n   nonce, and other challenge information.  Note that the results of\n
    \  some requests might vary according to whether or not the client is\n   authenticated
    -- a PROPFIND might return more visible resources if\n   the client is authenticated,
    yet not fail if the client is anonymous.\n   There are a number of ways the client
    might be able to trigger the\n   server to provide an authentication challenge.
    \ This appendix\n   describes a couple approaches that seem particularly likely
    to work.\n   The first approach is to perform a request that ought to require\n
    \  authentication.  However, it's possible that a server might handle\n   any
    request even without authentication, so to be entirely safe, the\n   client could
    add a conditional header to ensure that even if the\n   request passes permissions
    checks, it's not actually handled by the\n   server.  An example of following
    this approach would be to use a PUT\n   request with an \"If-Match\" header with
    a made-up ETag value.  This\n   approach might fail to result in an authentication
    challenge if the\n   server does not test authorization before testing conditionals
    as is\n   required (see Section 8.5), or if the server does not need to test\n
    \  authorization.\n   Example - forcing auth challenge with write request\n   >>Request\n
    \    PUT /forceauth.txt HTTP/1.1\n     Host: www.example.com\n     If-Match: \"xxx\"\n
    \    Content-Type: text/plain\n     Content-Length: 0\n   The second approach
    is to use an Authorization header (defined in\n   [RFC2617]), which is likely
    to be rejected by the server but which\n   will then prompt a proper authentication
    challenge.  For example, the\n   client could start with a PROPFIND request containing
    an\n   Authorization header containing a made-up Basic userid:password\n   string
    or with actual plausible credentials.  This approach relies on\n   the server
    responding with a \"401 Unauthorized\" along with a\n   challenge if it receives
    an Authorization header with an unrecognized\n   username, invalid password, or
    if it doesn't even handle Basic\n   authentication.  This seems likely to work
    because of the\n   requirements of RFC 2617:\n   \"If the origin server does not
    wish to accept the credentials sent\n   with a request, it SHOULD return a 401
    (Unauthorized) response.  The\n   response MUST include a WWW-Authenticate header
    field containing at\n   least one (possibly new) challenge applicable to the requested\n
    \  resource.\"\n   There's a slight problem with implementing that recommendation
    in\n   some cases, because some servers do not even have challenge\n   information
    for certain resources.  Thus, when there's no way to\n   authenticate to a resource
    or the resource is entirely publicly\n   available over all accepted methods,
    the server MAY ignore the\n   Authorization header, and the client will presumably
    try again later.\n   Example - forcing auth challenge with Authorization header\n
    \  >>Request\n     PROPFIND /docs/ HTTP/1.1\n     Host: www.example.com\n     Authorization:
    Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n     Content-type: application/xml; charset=\"utf-8\"\n
    \    Content-Length: xxxx\n     [body omitted]\n"
  title: Appendix E.  Guidance for Clients Desiring to Authenticate
- contents:
  - "Appendix F.  Summary of Changes from RFC 2518\n   This section lists major changes
    between this document and RFC 2518,\n   starting with those that are likely to
    result in implementation\n   changes.  Servers will advertise support for all
    changes in this\n   specification by returning the compliance class \"3\" in the
    DAV\n   response header (see Sections 10.1 and 18.3).\n"
  - contents:
    - "F.1.  Changes for Both Client and Server Implementations\n   Collections and
      Namespace Operations\n   o  The semantics of PROPFIND 'allprop' (Section 9.1)
      have been\n      relaxed so that servers return results including, at a minimum,\n
      \     the live properties defined in this specification, but not\n      necessarily
      return other live properties.  The 'allprop' directive\n      therefore means
      something more like \"return all properties that\n      are supposed to be returned
      when 'allprop' is requested\" -- a set\n      of properties that may include
      custom properties and properties\n      defined in other specifications if those
      other specifications so\n      require.  Related to this, 'allprop' requests
      can now be extended\n      with the 'include' syntax to include specific named
      properties,\n      thereby avoiding additional requests due to changed 'allprop'\n
      \     semantics.\n   o  Servers are now allowed to reject PROPFIND requests
      with Depth:\n      Infinity.  Clients that used this will need to be able to
      do a\n      series of Depth:1 requests instead.\n   o  Multi-Status response
      bodies now can transport the value of HTTP's\n      Location response header
      in the new 'location' element.  Clients\n      may use this to avoid additional
      roundtrips to the server when\n      there is a 'response' element with a 3xx
      status (see\n      Section 14.24).\n   o  The definition of COPY has been relaxed
      so that it doesn't require\n      servers to first delete the target resources
      anymore (this was a\n      known incompatibility with [RFC3253]).  See Section
      9.8.\n   Headers and Marshalling\n   o  The Destination and If request headers
      now allow absolute paths in\n      addition to full URIs (see Section 8.3).
      \ This may be useful for\n      clients operating through a reverse proxy that
      does rewrite the\n      Host request header, but not WebDAV-specific headers.\n
      \  o  This specification adopts the error marshalling extensions and the\n      \"precondition/postcondition\"
      terminology defined in [RFC3253] (see\n      Section 16).  Related to that,
      it adds the \"error\" XML element\n      inside multistatus response bodies
      (see Section 14.5, however note\n      that it uses a format different from
      the one recommended in RFC\n      3253).\n   o  Senders and recipients are now
      required to support the UTF-16\n      character encoding in XML message bodies
      (see Section 19).\n   o  Clients are now required to send the Depth header on
      PROPFIND\n      requests, although servers are still encouraged to support clients\n
      \     that don't.\n   Locking\n   o  RFC 2518's concept of \"lock-null resources\"
      (LNRs) has been\n      replaced by a simplified approach, the \"locked empty
      resources\"\n      (see Section 7.3).  There are some aspects of lock-null resources\n
      \     clients cannot rely on anymore, namely, the ability to use them to\n      create
      a locked collection or the fact that they disappear upon\n      UNLOCK when
      no PUT or MKCOL request was issued.  Note that servers\n      are still allowed
      to implement LNRs as per RFC 2518.\n   o  There is no implicit refresh of locks
      anymore.  Locks are only\n      refreshed upon explicit request (see Section
      9.10.2).\n   o  Clarified that the DAV:owner value supplied in the LOCK request\n
      \     must be preserved by the server just like a dead property\n      (Section
      14.17).  Also added the DAV:lockroot element\n      (Section 14.12), which allows
      clients to discover the root of\n      lock.\n"
    title: F.1.  Changes for Both Client and Server Implementations
  - contents:
    - "F.2.  Changes for Server Implementations\n   Collections and Namespace Operations\n
      \  o  Due to interoperability problems, allowable formats for contents\n      of
      'href' elements in multistatus responses have been limited (see\n      Section
      8.3).\n   o  Due to lack of implementation, support for the 'propertybehavior'\n
      \     request body for COPY and MOVE has been removed.  Instead,\n      requirements
      for property preservation have been clarified (see\n      Sections 9.8 and 9.9).\n
      \  Properties\n   o  Strengthened server requirements for storage of property
      values,\n      in particular persistence of language information (xml:lang),\n
      \     whitespace, and XML namespace information (see Section 4.3).\n   o  Clarified
      requirements on which properties should be writable by\n      the client; in
      particular, setting \"DAV:displayname\" should be\n      supported by servers
      (see Section 15).\n   o  Only 'rfc1123-date' productions are legal as values
      for DAV:\n      getlastmodified (see Section 15.7).\n   Headers and Marshalling\n
      \  o  Servers are now required to do authorization checks before\n      processing
      conditional headers (see Section 8.5).\n   Locking\n   o  Strengthened requirement
      to check identity of lock creator when\n      accessing locked resources (see
      Section 6.4).  Clients should be\n      aware that lock tokens returned to other
      principals can only be\n      used to break a lock, if at all.\n   o  Section
      8.10.4 of [RFC2518] incorrectly required servers to return\n      a 409 status
      where a 207 status was really appropriate.  This has\n      been corrected (Section
      9.10).\n"
    title: F.2.  Changes for Server Implementations
  - contents:
    - "F.3.  Other Changes\n   The definition of collection state has been fixed so
      it doesn't vary\n   anymore depending on the Request-URI (see Section 5.2).\n
      \  The DAV:source property introduced in Section 4.6 of [RFC2518] was\n   removed
      due to lack of implementation experience.\n   The DAV header now allows non-IETF
      extensions through URIs in\n   addition to compliance class tokens.  It also
      can now be used in\n   requests, although this specification does not define
      any associated\n   semantics for the compliance classes defined in here (see\n
      \  Section 10.1).\n   In RFC 2518, the definition of the Depth header (Section
      9.2)\n   required that, by default, request headers would be applied to each\n
      \  resource in scope.  Based on implementation experience, the default\n   has
      now been reversed (see Section 10.2).\n   The definitions of HTTP status code
      102 ([RFC2518], Section 10.1) and\n   the Status-URI response header (Section
      9.7) have been removed due to\n   lack of implementation.\n   The TimeType format
      used in the Timeout request header and the\n   \"timeout\" XML element used
      to be extensible.  Now, only the two\n   formats defined by this specification
      are allowed (see Section 10.7).\n"
    title: F.3.  Other Changes
  title: Appendix F.  Summary of Changes from RFC 2518
- contents:
  - "Author's Address\n   Lisa Dusseault (editor)\n   CommerceNet\n   2064 Edgewood
    Dr.\n   Palo Alto, CA  94303\n   US\n   EMail: ldusseault@commerce.net\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
