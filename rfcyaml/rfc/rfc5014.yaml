- title: __initial_text__
  contents:
  - '              IPv6 Socket API for Source Address Selection

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The IPv6 default address selection document (RFC 3484) describes\
    \ the\n   rules for selecting source and destination IPv6 addresses, and\n   indicates\
    \ that applications should be able to reverse the sense of\n   some of the address\
    \ selection rules through some unspecified API.\n   However, no such socket API\
    \ exists in the basic (RFC 3493) or\n   advanced (RFC 3542) IPv6 socket API documents.\
    \  This document fills\n   that gap partially by specifying new socket-level options\
    \ for source\n   address selection and flags for the getaddrinfo() API to specify\n\
    \   address selection based on the source address preference in\n   accordance\
    \ with the socket-level options that modify the default\n   source address selection\
    \ algorithm.  The socket API described in this\n   document will be particularly\
    \ useful for IPv6 applications that want\n   to choose between temporary and public\
    \ addresses, and for Mobile IPv6\n   aware applications that want to use the care-of\
    \ address for\n   communication.  It also specifies socket options and flags for\n\
    \   selecting Cryptographically Generated Address (CGA) or non-CGA source\n  \
    \ addresses.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Definition Of Terms  . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n   3.  Usage Scenario . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  6\n   4.  Design Alternatives  . . . . . . . . . . . . . . . . . .\
    \ . . .  6\n   5.  Address Preference Flags . . . . . . . . . . . . . . . . .\
    \ . .  7\n   6.  Additions to the Socket Interface  . . . . . . . . . . . . .\
    \ .  9\n   7.  Additions to the Protocol-Independent Nodename Translation . .\
    \ 10\n   8.  Application Requirements . . . . . . . . . . . . . . . . . . . 11\n\
    \   9.  Usage Example  . . . . . . . . . . . . . . . . . . . . . . . . 13\n  \
    \ 10. Implementation Notes . . . . . . . . . . . . . . . . . . . . . 13\n   11.\
    \ Mapping to Default Address Selection Rules . . . . . . . . . . 14\n   12. IPv4-Mapped\
    \ IPv6 Addresses . . . . . . . . . . . . . . . . . . 16\n   13. Validating Source\
    \ Address Preferences  . . . . . . . . . . . . 16\n   14. Summary of New Definitions\
    \ . . . . . . . . . . . . . . . . . . 19\n   15. Security Considerations  . .\
    \ . . . . . . . . . . . . . . . . . 19\n   16. Acknowledgments  . . . . . . .\
    \ . . . . . . . . . . . . . . . . 19\n   17. References . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 20\n     17.1.  Normative References  . . . .\
    \ . . . . . . . . . . . . . . 20\n     17.2.  Informative References  . . . .\
    \ . . . . . . . . . . . . . 20\n   Appendix A.  Per-Packet Address Selection Preference\
    \ . . . . . . . 21\n   Appendix B.  Intellectual Property Statement . . . . .\
    \ . . . . . . 22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC3484] specifies the default address selection rules\
    \ for IPv6\n   [RFC2460].  This document defines socket API extensions that allow\n\
    \   applications to override the default choice of source address\n   selection.\
    \  It therefore indirectly affects the destination address\n   selection through\
    \ getaddrinfo().  Privacy considerations [RFC3041]\n   have introduced \"public\"\
    \ and \"temporary\" addresses.  IPv6 Mobility\n   [RFC3775] introduces \"home\
    \ address\" and \"care-of address\" definitions\n   in the mobile systems.\n \
    \  The default address selection rules in [RFC3484], in summary, are\n   that\
    \ a public address is preferred over a temporary address, that a\n   mobile IPv6\
    \ home address is preferred over a care-of address, and\n   that a larger scope\
    \ address is preferred over a smaller scope\n   address.  Although it is desirable\
    \ to have default rules for address\n   selection, an application may want to\
    \ reverse certain address\n   selection rules for efficiency and other application-specific\n\
    \   reasons.\n   Currently, IPv6 socket API extensions provide mechanisms to choose\
    \ a\n   specific source address through simple bind() operation or\n   IPV6_PKTINFO\
    \ socket option [RFC3542].  However, in order to use\n   bind() or IPV6_PKTINFO\
    \ socket option, the application itself must\n   make sure that the source address\
    \ is appropriate for the destination\n   address (e.g., with respect to the interface\
    \ used to send packets to\n   the destination).  The application also needs to\
    \ verify the\n   appropriateness of the source address scope with respect to the\n\
    \   destination address and so on.  This can be quite complex for the\n   application,\
    \ since in effect, it needs to implement all the default\n   address selection\
    \ rules in order to change its preference with\n   respect to one of the rules.\n\
    \   The mechanism presented in this document allows the application to\n   specify\
    \ attributes of the source addresses it prefers while still\n   having the system\
    \ perform the rest of the address selection rules.\n   For instance, if an application\
    \ specifies that it prefers to use a\n   care-of address over a home address as\
    \ the source address and if the\n   host has two care-of addresses, one public\
    \ and one temporary, then\n   the host would select the public care-of address\
    \ by following the\n   default address selection rule for preferring a public\
    \ over a\n   temporary address.\n   A socket option has been deemed useful for\
    \ this purpose, as it\n   enables an application to specify address selection\
    \ preferences on a\n   per-socket basis.  It can also provide the flexibility\
    \ of enabling\n   and disabling address selection preferences in non-connected\
    \ (UDP)\n   sockets.  The socket option uses a set of flags for specifying\n \
    \  address selection preferences.  Since the API should not assume a\n   particular\
    \ implementation method of the address selection [RFC3484]\n   in the network\
    \ layer or in getaddrinfo(), the corresponding set of\n   flags are also defined\
    \ for getaddrinfo(), as it depends on the source\n   address selection.\n   As\
    \ a result, this document introduces several flags for address\n   selection preferences\
    \ that alter the default address selection\n   [RFC3484] for a number of rules.\
    \  It analyzes the usefulness of\n   providing API functionality for different\
    \ default address selection\n   rules; it provides API to alter only those rules\
    \ that are possibly\n   used by certain classes of applications.  In addition,\
    \ it also\n   considers CGA [RFC3972] and non-CGA source addresses when CGA\n\
    \   addresses are available in the system.  In the future, more source\n   flags\
    \ may be added to expand the API as the needs may arise.\n   The approach in this\
    \ document is to allow the application to specify\n   preferences for address\
    \ selection and not to be able to specify hard\n   requirements.  For instance,\
    \ an application can set a flag to prefer\n   a temporary source address, but\
    \ if no temporary source addresses are\n   available at the node, a public address\
    \ would be chosen instead.\n   Specifying hard requirements for address selection\
    \ would be\n   problematic for several reasons.  The major one is that, in the\
    \ vast\n   majority of cases, the application would like to be able to\n   communicate\
    \ even if an address with the 'optimal' attributes is not\n   available.  For\
    \ instance, an application that performs very short,\n   e.g., UDP, transactional\
    \ exchanges (e.g., DNS queries), might prefer\n   to use a care-of address when\
    \ running on a mobile host that is away\n   from home since this provides a short\
    \ roundtrip time in many cases.\n   But if the application is running on a mobile\
    \ host that is at home,\n   or running on a host that isn't providing Mobile IPv6,\
    \ then it\n   doesn't make sense for the application to fail due to no care-of\n\
    \   address being available.  Also, in particular, when using UDP sockets\n  \
    \ and the sendto() or sendmsg() primitives, the use of hard\n   requirements would\
    \ have been problematic, since the set of available\n   IP addresses might very\
    \ well have changed from when the application\n   called getaddrinfo() until it\
    \ called sendto() or sendmsg(), which\n   would introduce new failure modes.\n\
    \   For the few applications that have hard requirements on the\n   attributes\
    \ of the IP addresses they use, this document defines a\n   verification function\
    \ that allows such applications to properly fail\n   to communicate when their\
    \ address selection requirements are not met.\n   Furthermore, the approach is\
    \ to define two flags for each rule that\n   can be modified so that an application\
    \ can specify its preference for\n   addresses selected as per the rule, the opposite\
    \ preference (i.e., an\n   address selected as per the rule reverted), or choose\
    \ not to set\n   either of the flags relating to that rule and leave it up to\
    \ the\n   system default (Section 4).  This approach allows different\n   implementations\
    \ to have different system defaults, and works with\n   getaddrinfo() as well\
    \ as setsockopt().  (For setsockopt, a different\n   approach could have been\
    \ chosen, but that would still require the\n   same approach for getaddrinfo.)\n\
    \   Note that this document does not directly modify the destination\n   address\
    \ selection rules described in [RFC3484].  An analysis has been\n   done to see\
    \ which destination address rules may be altered by the\n   applications.  Rule\
    \ number 4(prefer home address), 8(prefer smaller\n   scope), 7(prefer native\
    \ interfaces) of default address selection\n   document [RFC3484] were taken into\
    \ consideration for destination\n   address alteration.  But as of this writing,\
    \ there was not enough\n   practical usage for applications to alter destination\
    \ address\n   selection rules directly by applying the setsockopt() with a\n \
    \  preferred destination type of address flag.  However, this document\n   does\
    \ not rule out any possibility of adding flags for preferred\n   destination address\
    \ selection.  However, [RFC3484] destination\n   address selection rules are dependent\
    \ on source address selections,\n   thus by altering the default source address\
    \ selection by using the\n   methods described in this document, one indirectly\
    \ influences the\n   choice of destination address selection.  Hence, this document\n\
    \   explains how getaddrinfo() can be used to select the destination\n   address\
    \ while taking the preferred source addresses into\n   consideration (Section\
    \ 11).\n   This document specifies extensions only to the Basic IPv6 socket API\n\
    \   specified in [RFC3493].  The intent is that this document serves as a\n  \
    \ model for expressing preferences for attributes of IP addresses that\n   also\
    \ need to be expressible in other networking API, such as those\n   found in middleware\
    \ systems and the Java environment.  A similar\n   model is also applicable for\
    \ other socket families.\n"
- title: 2.  Definition Of Terms
  contents:
  - "2.  Definition Of Terms\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   Address preference flag:\n      A flag expressing a preference\
    \ for a particular type of address\n      (e.g., temporary, public).\n   Opposite\
    \ flags:\n      Each flag expressing an address preference has an \"opposite flag\"\
    \n      expressing the opposite preference:\n      *  Home address preference\
    \ flag is the opposite of the care-of\n         address preference flag.\n   \
    \   *  Temporary address preference flag is the opposite of the public\n     \
    \    address preference flag.\n      *  CGA address preference flag is the opposite\
    \ of the non-CGA\n         address preference flag.\n   Contradictory flags:\n\
    \      Any combination of flags including both a flag expressing a given\n   \
    \   address preference and a flag expressing the opposite preference\n      constitutes\
    \ contradictory flags.  Such flags are contradictory by\n      definition of their\
    \ usefulness with respect to source address\n      selection.  For example, consider\
    \ a set of flags, including both\n      the home address preference flag and the\
    \ care-of address\n      preference flag.  When considering source address selection,\
    \ the\n      selected address can be a home address, or a care-of address, but\n\
    \      it cannot be both at the same time.  Hence, to prefer an address\n    \
    \  that is both a home address and a care-of address is\n      contradictory.\n"
- title: 3.  Usage Scenario
  contents:
  - "3.  Usage Scenario\n   The examples discussed here are limited to applications\
    \ supporting\n   Mobile IPv6, IPv6 Privacy Extensions, and Cryptographically Generated\n\
    \   Addresses.  Address selection document [RFC3484] recommends that home\n  \
    \ addresses should be preferred over care-of address when both are\n   configured.\
    \  However, a mobile node may want to prefer a care-of\n   address as the source\
    \ address for a DNS query in the foreign network,\n   as it normally means a shorter\
    \ and local return path compared to the\n   route via the mobile node's home-agent\
    \ when the query contains a home\n   address as the source address.  Another example\
    \ is the IKE\n   application, which requires a care-of address as its source address\n\
    \   for the initial security association pair with a Home Agent [RFC3775]\n  \
    \ while the mobile node boots up at the foreign network and wants to do\n   the\
    \ key exchange before a successful home-registration.  Also, a\n   Mobile IPv6\
    \ aware application may want to toggle between the home\n   address and care-of\
    \ address, depending on its location and state of\n   the application.  It may\
    \ also want to open different sockets and use\n   the home address as the source\
    \ address for one socket and a care-of\n   address for the others.\n   In a non-mobile\
    \ environment, an application may similarly prefer to\n   use a temporary address\
    \ as the source address for certain cases.  By\n   default, the source address\
    \ selection rule selects \"public\" address\n   when both are available.  For\
    \ example, an application supporting Web\n   browser and mail-server may want\
    \ to use a \"temporary\" address for the\n   former and a \"public\" address for\
    \ the mail-server, as a mail-server\n   may require a reverse path for DNS records\
    \ for anti-spam rules.\n   Similarly, a node may be configured to use Cryptographically\n\
    \   Generated Addresses [RFC3972] by default, as in Secure Neighbor\n   Discovery\
    \ [RFC3971], but an application may prefer not to use it; for\n   instance, fping\
    \ [FPING], a debugging tool that tests basic\n   reachability of multiple destinations\
    \ by sending packets in parallel.\n   These packets may end up initiating neighbor\
    \ discovery signaling that\n   uses SEND if used with a CGA source address.  SEND\
    \ performs some\n   cryptographic operations to prove ownership of the said CGA\
    \ address.\n   If the application does not require this feature, it would like\
    \ to\n   use a non-CGA address to avoid potentially expensive computations\n \
    \  performed by SEND.  On the other hand, when a node is not configured\n   for\
    \ CGA as default, an application may prefer using CGA by setting\n   the corresponding\
    \ preference.\n"
- title: 4.  Design Alternatives
  contents:
  - "4.  Design Alternatives\n   Some suggested to have per-application flags instead\
    \ of per-socket\n   and per-packet flags.  However, this design stays with per-socket\
    \ and\n   per-packet flags for the following reasons:\n   o  While some systems\
    \ have per-environment/application flags (such as\n      environment variables\
    \ in Unix systems) this might not be available\n      in all systems that implement\
    \ the socket API.\n   o  When an application links with some standard library,\
    \ that library\n      might use the socket API while the application is unaware\
    \ of that\n      fact.  Mechanisms that would provide per-application flags may\n\
    \      affect not only the application itself but also the libraries,\n      hence,\
    \ creating risks of unintended consequences.\n   Instead of the pair of 'flag'\
    \ and 'opposite flag' for each rule that\n   can be modified, the socket option\
    \ could have been defined to use a\n   single 'flag' value for each rule.  This\
    \ would still have allowed\n   different implementations to have different default\
    \ settings as long\n   as the applications were coded to first retrieve the default\
    \ setting\n   (using getsockopt()), and then clear or set the 'flag' according\
    \ to\n   their preferences, and finally set the new value with setsockopt().\n\
    \   But such an approach would not be possible for getaddrinfo() because\n   all\
    \ the preferences would need to be expressible in the parameters\n   that are\
    \ passed with a single getaddrinfo() call.  Hence, for\n   consistency, the 'flag'\
    \ and 'opposite flag' approach is used for both\n   getaddrinfo() and setsockopt().\n\
    \   Thus, in this API document, an application has three choices on\n   source\
    \ address selection:\n      a) The application wants to use an address with flag\
    \ X: Set flag\n      X; unset opposite/contradictory flags of X if they are set\
    \ before.\n      b) The application wants to use an address with 'opposite' or\n\
    \      contradictory flag of X: Set opposite or contradictory flag of X;\n   \
    \   unset flag X, if already set.\n      c) The application does not care about\
    \ the presence of flag X and\n      would like to use default: No need to set\
    \ any address preference\n      flags through setsockopt() or getaddrinfo(); unset\
    \ any address\n      preference flags if they are set before by the same socket.\n"
- title: 5.  Address Preference Flags
  contents:
  - "5.  Address Preference Flags\n   The following flags are defined to alter or\
    \ set the default rule of\n   source address selection rules discussed in default\
    \ address selection\n   specification [RFC3484].\n      IPV6_PREFER_SRC_HOME /*\
    \ Prefer Home address as source */\n      IPV6_PREFER_SRC_COA /* Prefer Care-of\
    \ address as source */\n      IPV6_PREFER_SRC_TMP /* Prefer Temporary address\
    \ as source */\n      IPV6_PREFER_SRC_PUBLIC /* Prefer Public address as source\
    \ */\n      IPV6_PREFER_SRC_CGA /* Prefer CGA address as source */\n      IPV6_PREFER_SRC_NONCGA\
    \ /* Prefer a non-CGA address as source */\n   These flags can be combined together\
    \ in a flag-set to express more\n   complex address preferences.  However, such\
    \ combinations can result\n   in a contradictory flag-set, for example:\n    \
    \  IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP\n      IPV6_PREFER_SRC_HOME |\
    \ IPV6_PREFER_SRC_COA\n      IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA | IPV6_PREFER_SRC_TMP\n\
    \      IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA\n      Etc.\n   Examples of\
    \ valid combinations of address selection flags are given\n   below:\n      IPV6_PREFER_SRC_HOME\
    \ | IPV6_PREFER_SRC_PUBLIC\n      IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_CGA\n\
    \      IPV6_PREFER_SRC_COA | IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_CGA\n  \
    \    IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_NONCGA\n   If a flag-set includes\
    \ a combination of 'X' and 'Y', and if 'Y' is\n   not applicable or available\
    \ in the system, then the selected address\n   has attribute 'X' and system default\
    \ for the attribute 'Y'.  For\n   example, on a system that has only public addresses,\
    \ the valid\n   combination of flags:\n      IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_HOME\n\
    \   would result in the selected address being a public home address,\n   since\
    \ no temporary addresses are available.\n"
- title: 6.  Additions to the Socket Interface
  contents:
  - "6.  Additions to the Socket Interface\n   The IPv6 Basic Socket API [RFC3493]\
    \ defines socket options for IPv6.\n   To allow applications to influence address\
    \ selection mechanisms, this\n   document adds a new socket option at the IPPROTO_IPV6\
    \ level.  This\n   socket option is called IPV6_ADDR_PREFERENCES.  It can be used\
    \ with\n   setsockopt() and getsockopt() calls to set and get the address\n  \
    \ selection preferences affecting all packets sent via a given socket.\n   The\
    \ socket option value (optval) is a 32-bit unsigned integer\n   argument.  The\
    \ argument consists of a number of flags where each flag\n   indicates an address\
    \ selection preference that modifies one of the\n   rules in the default address\
    \ selection specification.\n   The following flags are defined to alter or set\
    \ the default rule of\n   source address selection rules discussed in default\
    \ address selection\n   specification [RFC3484].  They are defined as a result\
    \ of including\n   the <netinet/in.h> header:\n      IPV6_PREFER_SRC_HOME /* Prefer\
    \ Home address as source */\n      IPV6_PREFER_SRC_COA /* Prefer Care-of address\
    \ as source */\n      IPV6_PREFER_SRC_TMP /* Prefer Temporary address as source\
    \ */\n      IPV6_PREFER_SRC_PUBLIC /* Prefer Public address as source */\n   \
    \   IPV6_PREFER_SRC_CGA /* Prefer CGA address as source */\n      IPV6_PREFER_SRC_NONCGA\
    \ /* Prefer a non-CGA address as source */\n   NOTE: No source preference flag\
    \ for the longest matching prefix is\n   defined here because it is believed to\
    \ be handled by the policy table\n   defined in the default address selection\
    \ specification.\n   When the IPV6_ADDR_PREFERENCES is successfully set with setsockopt(),\n\
    \   the option value given is used to specify the address preference for\n   any\
    \ connection initiation through the socket and all subsequent\n   packets sent\
    \ via that socket.  If no option is set, the system\n   selects a default value\
    \ as per default address selection algorithm or\n   by some other equivalent means.\n\
    \   Setting contradictory flags at the same time results in the error\n   EINVAL.\n"
- title: 7.  Additions to the Protocol-Independent Nodename Translation
  contents:
  - "7.  Additions to the Protocol-Independent Nodename Translation\n   Section 8\
    \ of the Default Address Selection [RFC3484] document\n   indicates possible implementation\
    \ strategies for getaddrinfo()\n   [RFC3493].  One of them suggests that getaddrinfo()\
    \ collects\n   available source/destination pairs from the network layer after\
    \ being\n   sorted at the network layer with full knowledge of source address\n\
    \   selection.  Another strategy is to call down to the network layer to\n   retrieve\
    \ source address information and then sort the list in the\n   context of getaddrinfo().\n\
    \   This implies that getaddrinfo() should be aware of the address\n   selection\
    \ preferences of the application, since getaddrinfo() is\n   independent of any\
    \ socket the application might be using.\n   Thus, if an application alters the\
    \ default address selection rules by\n   using setsockopt() with the IPV6_ADDR_PREFERENCES\
    \ option, the\n   application should also use the corresponding address selection\n\
    \   preference flags with its getaddrinfo() call.\n   For that purpose, the addrinfo\
    \ data structure defined in Basic IPV6\n   Socket API Extension [RFC3493] has\
    \ been extended with an extended\n   \"ai_eflags\" flag-set field to provide the\
    \ designers freedom from\n   adding more flags as necessary without crowding the\
    \ valuable bit\n   space in the \"ai_flags\" flag-set field.  The extended addrinfo\
    \ data\n   structure is defined as a result of including the <netdb.h> header:\n\
    \    struct addrinfo {\n        int ai_flags;             /* input flags */\n\
    \        int ai_family;            /* protocol family for socket */\n        int\
    \ ai_socktype;          /* socket type */\n        int ai_protocol;          /*\
    \ protocol for socket */\n        socklen_t ai_addrlen;     /* length of socket\
    \ address */\n        char *ai_canonname;       /* canonical name for hostname\
    \ */\n        struct sockaddr *ai_addr; /* socket address for socket */\n    \
    \    struct addrinfo *ai_next; /* pointer to next in list */\n        int ai_eflags;\
    \            /* Extended flags for special usage */\n    };\n   Note that the\
    \ additional field for extended flags are added at the\n   bottom of the addrinfo\
    \ structure to preserve binary compatibility of\n   the new functionality with\
    \ the old applications that use the existing\n   addrinfo data structure.\n  \
    \ A new flag (AI_EXTFLAGS) is defined for the \"ai_flags\" flag-set field\n  \
    \ of the addrinfo data structure to tell the system to look for the\n   \"ai_eflags\"\
    \ extended flag-set field in the addrinfo structure.  It is\n   defined in the\
    \ <netdb.h> header:\n      AI_EXTFLAGS /* extended flag-set present */\n   If\
    \ the AI_EXTFLAGS flag is set in \"ai_flags\" flag-set field of the\n   addrinfo\
    \ data structure, then the getaddrinfo() implementation MUST\n   look for the\
    \ \"ai_eflags\" values stored in the extended flag-set field\n   \"ai_eflags\"\
    \ of the addrinfo data structure.  The flags stored in the\n   \"ai_eflags\" field\
    \ are only meaningful if the AI_EXTFLAGS flag is set\n   in the \"ai_flags\" flag-set\
    \ field of the addrinfo data structure.  By\n   default, AI_EXTFLAGS is not set\
    \ in the \"ai_flags\" flag-set field.  If\n   AI_EXTFLAGS is set in the \"ai_flags\"\
    \ flag-set field, and the\n   \"ai_eflags\" extended flag-set field is 0 (zero)\
    \ or undefined, then\n   AI_EXTFLAGS is ignored.\n   The IPV6 source address preference\
    \ values (IPV6_PREFER_SRC_*) defined\n   for the IPV6_ADDR_PREFERENCES socket\
    \ option are also defined as\n   address selection preference flags for the \"\
    ai_eflags\" extended flag-\n   set field of the addrinfo data structure, so that\
    \ getaddrinfo() can\n   return matching destination addresses corresponding to\
    \ the source\n   address preferences expressed by the caller application.\n  \
    \ Thus, an application passes source address selection hints to\n   getaddrinfo\
    \ by setting AI_EXTFLAGS in the \"ai_flags\" field of the\n   addrinfo structure,\
    \ and the corresponding address selection\n   preference flags (IPV6_PREFER_SRC_*)\
    \ in the \"ai_eflags\" field.\n   Currently, AI_EXTFLAGS is defined for the AF_INET6\
    \ socket protocol\n   family only.  But its usage should be extendable to other\
    \ socket\n   protocol families -- such as AF_INET or as appropriate.\n   If contradictory\
    \ flags, such as IPV6_PREFER_SRC_HOME and\n   IPV6_PREFER_SRC_COA, are set in\
    \ ai_eflags, the getaddrinfo() fails\n   and return the value EAI_BADEXTFLAGS,\
    \ defined as a result of\n   including the <netdb.h> header.  This error value\
    \ MUST be interpreted\n   into a descriptive text string when passed to the gai_strerror()\n\
    \   function [RFC3493].\n"
- title: 8.  Application Requirements
  contents:
  - "8.  Application Requirements\n   An application should call getsockopt() prior\
    \ to calling setsockopt()\n   if the application needs to be able to restore the\
    \ socket back to the\n   system default preferences.  Note that this is suggested\
    \ for\n   portability.  An application that does not have this requirement can\n\
    \   just use getaddrinfo() while specifying its preferences, followed by:\n  \
    \    uint32_t flags = IPV6_PREFER_SRC_TMP;\n      if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_ADDR_PREFERENCES,\n                     (void *) &flags, sizeof (flags))\
    \ == -1) {\n          perror(\"setsockopt IPV6_ADDR_REFERENCES\");\n         \
    \ }\n   An application that needs to be able to restore the default settings\n\
    \   on the socket would instead do this:\n      uint32_t save_flags, flags;\n\
    \      int optlen = sizeof (save_flags);\n      /* Save the existing IPv6_ADDR_PREFERENCE\
    \ flags now */\n      if (getsockopt(s, IPPROTO_IPV6, IPV6_ADDR_PREFERENCES,\n\
    \                     (void *) &save_flags, &optlen) == -1 {\n          perror(\"\
    getsockopt IPV6_ADDR_REFERENCES\");\n          }\n      /* Set the new flags */\n\
    \      flags = IPV6_PREFER_SRC_TMP;\n      if (setsockopt(s, IPPROTO_IPV6, IPV6_ADDR_PREFERENCES,\n\
    \                  (void *) &flags, sizeof (flags)) == -1) {\n          perror(\"\
    setsockopt IPV6_ADDR_REFERENCES\");\n          }\n      /*\n       *\n       *\
    \  Do some work with the socket here.\n       *\n       */\n      /* Restore the\
    \ flags */\n      if (setsockopt(s, IPPROTO_IPV6, IPV6_ADDR_PREFERENCES,\n   \
    \               (void *) &save_flags, sizeof (save_flags)) == -1) {\n        \
    \  perror(\"setsockopt IPV6_ADDR_REFERENCES\");\n          }\n   Applications\
    \ should not set contradictory flags at the same time.\n   In order to allow different\
    \ implementations to do different parts of\n   address selection in getaddrinfo()\
    \ and in the protocol stack, this\n   specification requires that applications\
    \ set the semantically\n   equivalent flags when calling getaddrinfo() and setsockopt().\
    \  For\n   example, if the application sets the IPV6_PREFER_SRC_COA flag, it\n\
    \   MUST use the same for the \"ai_eflag\" field of the addrinfo data\n   structure\
    \ when calling getaddrinfo().  If applications are not\n   setting the semantically\
    \ equivalent flags, the behavior of the\n   implementation is undefined.\n"
- title: 9.  Usage Example
  contents:
  - "9.  Usage Example\n   An example of usage of this API is given below:\n    struct\
    \ addrinfo hints, *ai, *ai0;\n    uint32_t preferences;\n    preferences = IPV6_PREFER_SRC_TMP;\n\
    \    hints.ai_flags |= AI_EXTFLAGS;\n    hints.ai_eflags = preferences;  /* Chosen\
    \ address preference flag */\n    /* Fill in other hints fields */\n    getaddrinfo(....,&hints,.\
    \ &ai0..);\n    /* Loop over all returned addresses and do connect  */\n    for\
    \ (ai = ai0; ai; ai = ai->ai_next) {\n        s = socket(ai->ai_family, ...);\n\
    \        setsockopt(s, IPV6_ADDR_PREFERENCES, (void *) &preferences,\n       \
    \            sizeof (preferences));\n        if (connect(s, ai->ai_addr, ai->ai_addrlen)\
    \ == -1){\n            close (s);\n            s = -1;\n            continue;\n\
    \            }\n        break;\n        }\n    freeaddrinfo(ai0);\n"
- title: 10.  Implementation Notes
  contents:
  - "10.  Implementation Notes\n   o  Within the same application, if a specific source\
    \ address is set\n      by either bind() or IPV6_PKTINFO socket option, while\
    \ at the same\n      time an address selection preference is expressed with the\n\
    \      IPV6_ADDR_PREFERENCES socket option, then the source address\n      setting\
    \ carried by bind() or IPV6_PKTINFO takes precedence over\n      the address selection\
    \ setting.\n   o  setsockopt() and getaddrinfo() should silently ignore any address\n\
    \      preference flags that are not supported in the system.  For\n      example,\
    \ a host that does not implement Mobile IPv6, should not\n      fail setsockopt()\
    \ or getaddrinfo() that specify preferences for\n      home or care-of addresses.\
    \  The socket option calls should return\n      error (-1) and set errno to EINVAL\
    \ when contradictory flags values\n      are passed to them.\n   o  If an implementation\
    \ supports both stream and datagram sockets, it\n      should implement the address\
    \ preference mechanism API described in\n      this document on both types of\
    \ sockets.\n   o  An implementation supporting this API MUST implement both\n\
    \      getaddrinfo() extension flags and socket option flags processing\n    \
    \  for portability of applications.\n   o  The following flags are set as default\
    \ values on a system (which\n      is consistent with [RFC3484] defaults):\n \
    \     IPV6_PREFER_SRC_HOME\n      IPV6_PREFER_SRC_PUBLIC\n      IPV6_PREFER_SRC_CGA\n"
- title: 11.  Mapping to Default Address Selection Rules
  contents:
  - "11.  Mapping to Default Address Selection Rules\n   This API defines only those\
    \ flags that are deemed to be useful by the\n   applications to alter default\
    \ address selection rules.  Thus, we\n   discuss the mapping of each set of flags\
    \ to the corresponding rule\n   number in the address selection document [RFC3484].\n\
    \      Source address selection rule #4 (prefer home address):\n      IPV6_PREFER_SRC_HOME\
    \ (default)\n      IPV6_PREFER_SRC_COA\n      Source address selection rule #7\
    \ (prefer public address):\n      IPV6_PREFER_SRC_PUBLIC (default)\n      IPV6_PREFER_SRC_TMP\n\
    \   At this time, this document does not define flags to alter source\n   address\
    \ selection rule #2 (prefer appropriate scope for destination)\n   and destination\
    \ address selection rule #8 (prefer smaller scope), as\n   the implementers felt\
    \ that there were no practical applications that\n   can take advantage of reverting\
    \ the scoping rules of IPv6 default\n   address selection.  Flags altering other\
    \ destination address\n   selection rules (#4, prefer home address and #7, prefer\
    \ native\n   transport) could have applications, but the problem is that the local\n\
    \   system cannot systematically determine whether a destination address\n   is\
    \ a tunnel address for destination rule #7 (although it can when the\n   destination\
    \ address is one of its own, or can be syntactically\n   recognized as a tunnel\
    \ address, e.g., a 6-to-4 address.)  The flags\n   defined for source address\
    \ selection rule #4 (prefer home address)\n   should also take care of destination\
    \ address selection rule #4.\n   Thus, at this point, it was decided not to define\
    \ flags for these\n   destination rules.\n   Also, note that there is no corresponding\
    \ destination address\n   selection rule for source address selection rule #7\
    \ (prefer public\n   addresses) of default address selection document [RFC3484].\
    \  However,\n   this API provides a way for an application to make sure that the\n\
    \   source address preference set in setsockopt() is taken into account\n   by\
    \ the getaddrinfo() function.  Let's consider an example to\n   understand this\
    \ scenario.  DA and DB are two global destination\n   addresses and the node has\
    \ two global source addresses SA and SB\n   through interface A and B respectively.\
    \  SA is a temporary address\n   while SB is a public address.  The application\
    \ has set\n   IPV6_PREFER_SRC_TMP in the setsockopt() flag.  The route to DA points\n\
    \   to interface A and the route to DB points to interface B. Thus, when\n   AI_EXTFLAGS\
    \ in ai_flags and IPV6_PREFER_SRC_TMP in ai_eflags are set,\n   getaddrinfo()\
    \ returns DA before DB in the list of destination\n   addresses and thus, SA will\
    \ be used to communicate with the\n   destination DA.  Similarly, getaddrinfo()\
    \ returns DB before DA when\n   AI_EXTFLAGS and ai_eflags are set to IPV6_PREFER_SRC_PUBLIC.\
    \  Thus,\n   the source address preference is taking effect into destination\n\
    \   address selection as well as source address selection by the\n   getaddrinfo()\
    \ function.\n   The following numerical example clarifies the above further.\n\
    \   Imagine a host with two addresses:\n      1234::1:1 public\n      9876::1:2\
    \ temporary\n   The destination has the following two addresses:\n      1234::9:3\n\
    \      9876::9:4\n   By default, getaddrinfo() will return the destination addresses\
    \ in\n   the following order:\n      1234::9:3\n      9876::9:4\n   because the\
    \ public source is preferred and 1234 matches more bits\n   with the public source\
    \ address.  On the other hand, if ai_flags is\n   set to AI_EXTFLAGS and ai_eflags\
    \ to IPV6_PREFER_SRC_TMP, getaddrinfo\n   will return the addresses in the reverse\
    \ order since the temporary\n   source address will be preferred.\n   Other source\
    \ address rules (that are not mentioned here) were also\n   deemed not applicable\
    \ for changing its default on a per-application\n   basis.\n"
- title: 12.  IPv4-Mapped IPv6 Addresses
  contents:
  - "12.  IPv4-Mapped IPv6 Addresses\n   IPv4-mapped IPv6 addresses for AF_INET6 sockets\
    \ are supported in this\n   API.  In some cases, the application of IPv4-mapped\
    \ addresses are\n   limited because the API attributes are IPv6 specific.  For\
    \ example,\n   IPv6 temporary addresses and cryptographically generated addresses\n\
    \   have no IPv4 counterparts.  Thus, the IPV6_PREFER_SRC_TMP or\n   IPV6_PREFER_SRC_CGA\
    \ are not directly applicable to an IPv4-mapped\n   IPv6 address.  However, the\
    \ IPv4-mapped address support may be useful\n   for mobile-IPv4 applications shifting\
    \ the source address between the\n   home address and the care-of address.  Thus,\
    \ the IPV6_PREFER_SRC_COA\n   and IPV6_PREFER_SRC_HOME are applicable to an IPv4-mapped\
    \ IPv6\n   address.  At this point, it is not well understood whether this\n \
    \  particular API has any value to IPv4 addresses or AF_INET family of\n   sockets,\
    \ but a similar model still applies to AF_INET socket family\n   if corresponding\
    \ address flags are defined.\n"
- title: 13.  Validating Source Address Preferences
  contents:
  - "13.  Validating Source Address Preferences\n   Sometimes an application may have\
    \ a requirement to only use addresses\n   with some particular attribute, and\
    \ if no such address is available,\n   the application should fail to communicate\
    \ instead of communicating\n   using the 'wrong' address.  In that situation,\
    \ address selection\n   preferences do not guarantee that the application requirements\
    \ are\n   met.  Instead, the application has to use a new call that binds a\n\
    \   socket to the source address that would be selected to communicate\n   with\
    \ a given destination address, according to its preferences, and\n   then explicitly\
    \ verify that the chosen address satisfies its\n   requirements using a validation\
    \ function.  Such an application would\n   go through the following steps:\n \
    \  1.  The application specifies one or more IPV6_PREFER_SRC_* flags and\n   \
    \    AI_EXTFLAGS ai_flags with getaddrinfo().\n   2.  The application specifies\
    \ the same IPV6_PREFER_SRC_* flags with\n       setsockopt().\n   3.  The application\
    \ calls the stack to select a source address to\n       communicate with the specified\
    \ destination address, according to\n       the expressed address selection preferences.\
    \  This is achieved\n       with a connect() call, or a bind2addrsel() call as\
    \ specified\n       below.  The connect() function must not be used when the\n\
    \       application uses connection-oriented communication (e.g., TCP)\n     \
    \  and want to ensure that no single packet (e.g., TCP SYN) is sent\n       before\
    \ the application could verify that its requirements were\n       fulfilled. \
    \ Instead, the application must use the newly\n       introduced bind2addrsel()\
    \ call, which binds a socket to the\n       source address that would be selected\
    \ to communicate with a given\n       destination address, according to the application's\
    \ preferences.\n       For datagram-oriented communications (e.g., UDP), the connect()\n\
    \       call can be used since it results in the stack selecting a source\n  \
    \     address without sending any packets.\n   4.  Retrieve the selected source\
    \ address using the getsockname() API\n       call.\n   5.  Verify with the validation\
    \ function that the retrieved address is\n       satisfactory as specified below.\
    \  If not, abort the\n       communication, e.g., by closing the socket.\n   The\
    \ binding of the socket to the address that would be selected to\n   communicate\
    \ with a given destination address, according to the\n   application preferences,\
    \ is accomplished via a new binding function\n   defined for this purpose:\n \
    \     #include <netinet/in.h>\n      int bind2addrsel(int s, const struct sockaddr\
    \ *dstaddr,\n                       socklen_t dstaddrlen);\n   where s is the\
    \ socket that source address selection preferences have\n   been expressed by\
    \ the application, the dstaddr is a non-NULL pointer\n   to a sockaddr_in6 structure\
    \ initialized as follows:\n   o  sin6_addr is a 128-bit IPv6 destination address\
    \ with which the\n      local node wants to communicate;\n   o  sin6_family MUST\
    \ be set to AF_INET6;\n   o  sin6_scope_id MUST be set if the address is link-local;\n\
    \   and dstaddrlen is the size of the sockaddr structure passed as\n   argument.\n\
    \   The bind2addrsel() call is defined to return the same values as the\n   bind()\
    \ call, i.e., 0 if successful, -1 otherwise while the global\n   variable errno\
    \ is set to indicate the error.  The bind2addrsel() call\n   fails for the same\
    \ reasons that the bind() call.\n   The verification of temporary vs. public,\
    \ home vs. care-of, CGA vs.\n   not, are performed by a new validation function\
    \ defined for this\n   purpose:\n      #include <netinet/in.h>\n      short inet6_is_srcaddr(struct\
    \ sockaddr_in6 *srcaddr,\n                             uint32_t flags);\n   where\
    \ the flags contain the specified IPV6_PREFER_SRC_* source\n   preference flags,\
    \ and the srcaddr is a non-NULL pointer to a\n   sockaddr_in6 structure initialized\
    \ as follows:\n   o  sin6_addr is a 128-bit IPv6 address of the local node.\n\
    \   o  sin6_family MUST be set to AF_INET6.\n   o  sin6_scope_id MUST be set if\
    \ the address is link-local.\n   inet6_is_srcaddr() is defined to return three\
    \ possible values (0, 1,\n   -1): The function returns true (1) when the IPv6\
    \ address corresponds\n   to a valid address in the node and satisfies the given\
    \ preference\n   flags.  If the IPv6 address input value does not correspond to\
    \ any\n   address in the node or if the flags are not one of the valid\n   preference\
    \ flags, it returns a failure (-1).  If the input address\n   does not match an\
    \ address that satisfies the preference flags\n   indicated, the function returns\
    \ false (0.)\n   This function can handle multiple valid preference flag combinations\n\
    \   as its second parameter, for example, IPV6_PREFER_SRC_COA |\n   IPV6_PREFER_SRC_TMP,\
    \ which means that all flags MUST be satisfied for\n   the result to be true.\
    \  Contradictory flag values result in a false\n   return value.\n   The function\
    \ will return true for IPV6_PREFER_SRC_HOME even if the\n   host is not implementing\
    \ mobile IPv6, as well as for a mobile node\n   that is at home (i.e., does not\
    \ have any care-of address).\n"
- title: 14.  Summary of New Definitions
  contents:
  - "14.  Summary of New Definitions\n   The following list summarizes the constants,\
    \ structure, and extern\n   definitions discussed in this memo, sorted by header.\n\
    \   <netdb.h>        AI_EXTFLAGS\n   <netdb.h>        IPV6_PREFER_SRC_HOME\n \
    \  <netdb.h>        IPV6_PREFER_SRC_COA\n   <netdb.h>        IPV6_PREFER_SRC_TMP\n\
    \   <netdb.h>        IPV6_PREFER_SRC_PUBLIC\n   <netdb.h>        IPV6_PREFER_SRC_CGA\n\
    \   <netdb.h>        IPV6_PREFER_SRC_NONCGA\n   <netdb.h>        EAI_BADEXTFLAGS\n\
    \   <netdb.h>        struct addrinfo{};\n   <netinet/in.h>   IPV6_PREFER_SRC_HOME\n\
    \   <netinet/in.h>   IPV6_PREFER_SRC_COA\n   <netinet/in.h>   IPV6_PREFER_SRC_TMP\n\
    \   <netinet/in.h>   IPV6_PREFER_SRC_PUBLIC\n   <netinet/in.h>   IPV6_PREFER_SRC_CGA\n\
    \   <netinet/in.h>   IPV6_PREFER_SRC_NONCGA\n   <netinet/in.h>   short inet6_is_srcaddr(struct\
    \ sockaddr_in6 *,\n                                                 uint32_t);\n\
    \   <netinet/in.h>   int bind2addrsel(int, const struct sockaddr *,\n        \
    \                                   socklen_t);\n"
- title: 15.  Security Considerations
  contents:
  - "15.  Security Considerations\n   This document conforms to the same security\
    \ implications as specified\n   in the Basic IPv6 socket API [RFC3493] and address\
    \ selection rules\n   [RFC3484].  Allowing applications to specify a preference\
    \ for\n   temporary addresses provides per-application (and per-socket) ability\n\
    \   to use the privacy benefits of the temporary addresses.  The setting\n   of\
    \ certain address preferences (e.g., not using a CGA address, or not\n   using\
    \ a temporary address) may be restricted to privileged processes\n   because of\
    \ security implications.\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   The authors like to thank members of Mobile-IP and IPV6\
    \ working\n   groups for useful discussion on this topic.  Richard Draves and\
    \ Dave\n   Thaler suggested that getaddrinfo also needs to be considered along\n\
    \   with the new socket option.  Gabriel Montenegro suggested that CGAs\n   may\
    \ also be considered in this document.  Thanks to Alain Durand,\n   Renee Danson,\
    \ Alper Yegin, Francis Dupont, Keiichi Shima, Michael\n   Hunter, Sebastien Roy,\
    \ Robert Elz, Pekka Savola, Itojun, Jim Bound,\n   Jeff Boote, Steve Cipolli,\
    \ Vlad Yasevich, Mika Liljeberg, Ted Hardie,\n   Vidya Narayanan, and Lars Eggert\
    \ for useful discussions and\n   suggestions.  Thanks to Remi Denis-Courmont,\
    \ Brian Haberman, Brian\n   Haley, Bob Gilligan, Jack McCann, Jim Bound, Jinmei\
    \ Tatuya, Suresh\n   Krishnan, Hilarie Orman, Geoff Houston, Marcelo Bungulo,\
    \ and Jari\n   Arkko for the review of this document and suggestions for\n   improvement.\n"
- title: 17.  References
  contents:
  - '17.  References

    '
- title: 17.1.  Normative References
  contents:
  - "17.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3484]  Draves, R., \"Default Address Selection for Internet\n\
    \              Protocol version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC3493]\
    \  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.\n              Stevens,\
    \ \"Basic Socket Interface Extensions for IPv6\",\n              RFC 3493, February\
    \ 2003.\n"
- title: 17.2.  Informative References
  contents:
  - "17.2.  Informative References\n   [FPING]    \"Fping - a program to ping hosts\
    \ in parallel\", Online web\n              site http://www.fping.com.\n   [RFC2460]\
    \  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)\
    \ Specification\", RFC 2460, December 1998.\n   [RFC3041]  Narten, T. and R. Draves,\
    \ \"Privacy Extensions for\n              Stateless Address Autoconfiguration\
    \ in IPv6\", RFC 3041,\n              January 2001.\n   [RFC3542]  Stevens, W.,\
    \ Thomas, M., Nordmark, E., and T. Jinmei,\n              \"Advanced Sockets Application\
    \ Program Interface (API) for\n              IPv6\", RFC 3542, May 2003.\n   [RFC3775]\
    \  Johnson, D., Perkins, C., and J. Arkko, \"Mobility Support\n              in\
    \ IPv6\", RFC 3775, June 2004.\n   [RFC3971]  Arkko, J., Kempf, J., Zill, B.,\
    \ and P. Nikander, \"SEcure\n              Neighbor Discovery (SEND)\", RFC 3971,\
    \ March 2005.\n   [RFC3972]  Aura, T., \"Cryptographically Generated Addresses\
    \ (CGA)\",\n              RFC 3972, March 2005.\n"
- title: Appendix A.  Per-Packet Address Selection Preference
  contents:
  - "Appendix A.  Per-Packet Address Selection Preference\n   This document discusses\
    \ setting source address selection preferences\n   on a per-socket basis with\
    \ the new IPV6_ADDR_PREFERENCES socket\n   option used in setsockopt().  The document\
    \ does not encourage setting\n   the source address selection preference on a\
    \ per-packet basis through\n   the use of ancillary data objects with sendmsg(),\
    \ or setsockopt()\n   with unconnected datagram sockets.\n   Per-packet source\
    \ address selection is expensive, as the system will\n   have to determine the\
    \ source address indicated by the application\n   preference before sending each\
    \ packet, while setsockopt() address\n   preference on a connected socket makes\
    \ the selection once and uses\n   that source address for all packets transmitted\
    \ through that socket\n   endpoint, as long as the socket option is set.\n   However,\
    \ this document provides guidelines for those implementations\n   that like to\
    \ have an option on implementing transmit-side ancillary\n   data object support\
    \ for altering default source address selection.\n   Therefore, if an application\
    \ chooses to use the per-packet source\n   address selection, then the implementation\
    \ should process at the\n   IPPROTO_IPV6 level (cmsg_level) ancillary data object\
    \ of type\n   (cmsg_type) IPV6_ADDR_PREFERENCES containing as data (cmsg_data[])\
    \ a\n   32-bit unsigned integer encoding the source address selection\n   preference\
    \ flags (e.g., IPV6_PREFER_SRC_COA | IPV6_PREFER_SRC_PUBLIC)\n   in a fashion\
    \ similar to the advanced IPV6 Socket API [RFC3542].  This\n   address selection\
    \ preference ancillary data object may be present\n   along with other ancillary\
    \ data objects.\n   The implementation processing the ancillary data object is\n\
    \   responsible for the selection of the preferred source address as\n   indicated\
    \ in the ancillary data object.  Thus, an application can use\n   sendmsg() to\
    \ pass an address selection preference ancillary data\n   object to the IPv6 layer.\
    \  The following example shows usage of the\n   ancillary data API for setting\
    \ address preferences:\n   void *extptr;\n   socklen_t extlen;\n   struct msghdr\
    \ msg;\n   struct cmsghdr *cmsgptr;\n   int cmsglen;\n   struct sockaddr_in6 dest;\n\
    \   uint32_t flags;\n   extlen = sizeof(flags);\n   cmsglen = CMSG_SPACE(extlen);\n\
    \   cmsgptr = malloc(cmsglen);\n   cmsgptr->cmsg_len = CMSG_LEN(extlen);\n   cmsgptr->cmsg_level\
    \ = IPPROTO_IPV6;\n   cmsgptr->cmsg_type = IPV6_ADDR_PREFERENCES;\n   extptr =\
    \ CMSG_DATA(cmsgptr);\n   flags = IPV6_PREFER_SRC_COA;\n   memcpy(extptr, &flags,\
    \ extlen);\n   msg.msg_control = cmsgptr;\n   msg.msg_controllen = cmsglen;\n\
    \   /* finish filling in msg{} */\n   msg.msg_name = dest;\n   sendmsg(s, &msg,\
    \ 0);\n   Thus, when an IPV6_ADDR_PREFERENCES ancillary data object is passed\n\
    \   to sendmsg(), the value included in the object is used to specify\n   address\
    \ preference for the packet being sent by sendmsg().\n"
- title: Appendix B.  Intellectual Property Statement
  contents:
  - "Appendix B.  Intellectual Property Statement\n   This document only defines a\
    \ source preference flag to choose\n   Cryptographically Generated Address (CGA)\
    \ as the source address when\n   applicable.  CGAs are obtained using public keys\
    \ and hashes to prove\n   address ownership.  Several IPR claims have been made\
    \ about such\n   methods.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Erik Nordmark\n   Sun Microsystems, Inc.\n   17 Network\
    \ Circle\n   Menlo Park, CA 94025\n   USA\n   EMail: Erik.Nordmark@Sun.com\n \
    \  Samita Chakrabarti\n   Azaire Networks\n   3121 Jay Street, Suite 210\n   Santa\
    \ Clara, CA 95054\n   USA\n   EMail: samitac2@gmail.com\n   Julien Laganier\n\
    \   DoCoMo Euro-Labs\n   Landsbergerstrasse 312\n   D-80687 Muenchen\n   Germany\n\
    \   EMail: julien.IETF@laposte.net\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
