- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                         S. Josefsson
  contents:
  - "Internet Research Task Force (IRTF)                         S. Josefsson\n  \
    \         Edwards-Curve Digital Signature Algorithm (EdDSA)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes elliptic curve signature scheme Edwards-curve\n\
    \   Digital Signature Algorithm (EdDSA).  The algorithm is instantiated\n   with\
    \ recommended parameters for the edwards25519 and edwards448\n   curves.  An example\
    \ implementation and test vectors are provided.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not a candidate for\
    \ any\n   level of Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8032.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Notation and Conventions  . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  EdDSA Algorithm . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     3.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   7\n     3.2.  Keys  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     3.3.  Sign  . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \   8\n     3.4.  Verify  . . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 8\n   4.  PureEdDSA, HashEdDSA, and Naming  . . . . . . . . . . . . . .   8\n\
    \   5.  EdDSA Instances . . . . . . . . . . . . . . . . . . . . . . .   9\n  \
    \   5.1.  Ed25519ph, Ed25519ctx, and Ed25519  . . . . . . . . . . .   9\n    \
    \   5.1.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  10\n      \
    \ 5.1.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  10\n       5.1.3.\
    \  Decoding  . . . . . . . . . . . . . . . . . . . . . .  11\n       5.1.4.  Point\
    \ Addition  . . . . . . . . . . . . . . . . . . .  11\n       5.1.5.  Key Generation\
    \  . . . . . . . . . . . . . . . . . . .  13\n       5.1.6.  Sign  . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  13\n       5.1.7.  Verify  . . . . . .\
    \ . . . . . . . . . . . . . . . . .  14\n     5.2.  Ed448ph and Ed448 . . . .\
    \ . . . . . . . . . . . . . . . .  15\n       5.2.1.  Modular Arithmetic  . .\
    \ . . . . . . . . . . . . . . .  16\n       5.2.2.  Encoding  . . . . . . . .\
    \ . . . . . . . . . . . . . .  16\n       5.2.3.  Decoding  . . . . . . . . .\
    \ . . . . . . . . . . . . .  16\n       5.2.4.  Point Addition  . . . . . . .\
    \ . . . . . . . . . . . .  17\n       5.2.5.  Key Generation  . . . . . . . .\
    \ . . . . . . . . . . .  18\n       5.2.6.  Sign  . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  19\n       5.2.7.  Verify  . . . . . . . . . . . . . .\
    \ . . . . . . . . .  19\n   6.  Ed25519 Python Illustration . . . . . . . . .\
    \ . . . . . . . .  20\n   7.  Test Vectors  . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  23\n     7.1.  Test Vectors for Ed25519  . . . . . . . . . .\
    \ . . . . . .  24\n     7.2.  Test Vectors for Ed25519ctx . . . . . . . . . .\
    \ . . . . .  27\n     7.3.  Test Vectors for Ed25519ph  . . . . . . . . . . .\
    \ . . . .  30\n     7.4.  Test Vectors for Ed448  . . . . . . . . . . . . . .\
    \ . . .  30\n     7.5.  Test Vectors for Ed448ph  . . . . . . . . . . . . . .\
    \ . .  38\n   8.  Security Considerations . . . . . . . . . . . . . . . . . .\
    \ .  40\n     8.1.  Side-Channel Leaks  . . . . . . . . . . . . . . . . . . .\
    \  40\n     8.2.  Randomness Considerations . . . . . . . . . . . . . . . .  40\n\
    \     8.3.  Use of Contexts . . . . . . . . . . . . . . . . . . . . .  41\n  \
    \   8.4.  Signature Malleability  . . . . . . . . . . . . . . . . .  41\n    \
    \ 8.5.  Choice of Signature Primitive . . . . . . . . . . . . . .  41\n     8.6.\
    \  Mixing Different Prehashes  . . . . . . . . . . . . . . .  42\n     8.7.  Signing\
    \ Large Amounts of Data at Once . . . . . . . . . .  42\n     8.8.  Multiplication\
    \ by Cofactor in Verification  . . . . . . .  43\n     8.9.  Use of SHAKE256 as\
    \ a Hash Function  . . . . . . . . . . .  43\n   9.  References  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  43\n     9.1.  Normative References  .\
    \ . . . . . . . . . . . . . . . . .  43\n     9.2.  Informative References  .\
    \ . . . . . . . . . . . . . . . .  44\n   Appendix A.  Ed25519/Ed448 Python Library\
    \ . . . . . . . . . . . .  46\n   Appendix B.  Library Driver . . . . . . . .\
    \ . . . . . . . . . . .  58\n   Acknowledgements  . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  60\n   Authors' Addresses  . . . . . . . . . . . . . .\
    \ . . . . . . . . .  60\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Edwards-curve Digital Signature Algorithm (EdDSA) is\
    \ a variant of\n   Schnorr's signature system with (possibly twisted) Edwards\
    \ curves.\n   EdDSA needs to be instantiated with certain parameters, and this\n\
    \   document describes some recommended variants.\n   To facilitate adoption of\
    \ EdDSA in the Internet community, this\n   document describes the signature scheme\
    \ in an implementation-oriented\n   way and provides sample code and test vectors.\n\
    \   The advantages with EdDSA are as follows:\n   1.  EdDSA provides high performance\
    \ on a variety of platforms;\n   2.  The use of a unique random number for each\
    \ signature is not\n       required;\n   3.  It is more resilient to side-channel\
    \ attacks;\n   4.  EdDSA uses small public keys (32 or 57 bytes) and signatures\
    \ (64\n       or 114 bytes) for Ed25519 and Ed448, respectively;\n   5.  The formulas\
    \ are \"complete\", i.e., they are valid for all points\n       on the curve,\
    \ with no exceptions.  This obviates the need for\n       EdDSA to perform expensive\
    \ point validation on untrusted public\n       values; and\n   6.  EdDSA provides\
    \ collision resilience, meaning that hash-function\n       collisions do not break\
    \ this system (only holds for PureEdDSA).\n   The original EdDSA paper [EDDSA]\
    \ and the generalized version\n   described in \"EdDSA for more curves\" [EDDSA2]\
    \ provide further\n   background.  RFC 7748 [RFC7748] discusses specific curves,\
    \ including\n   Curve25519 [CURVE25519] and Ed448-Goldilocks [ED448].\n   Ed25519\
    \ is intended to operate at around the 128-bit security level\n   and Ed448 at\
    \ around the 224-bit security level.  A sufficiently large\n   quantum computer\
    \ would be able to break both.  Reasonable projections\n   of the abilities of\
    \ classical computers conclude that Ed25519 is\n   perfectly safe.  Ed448 is provided\
    \ for those applications with\n   relaxed performance requirements and where there\
    \ is a desire to hedge\n   against analytical attacks on elliptic curves.\n"
- title: 2.  Notation and Conventions
  contents:
  - "2.  Notation and Conventions\n   The following notation is used throughout the\
    \ document:\n   p              Denotes the prime number defining the underlying\
    \ field\n   GF(p)          Finite field with p elements\n   x^y            x multiplied\
    \ by itself y times\n   B              Generator of the group or subgroup of interest\n\
    \   [n]X           X added to itself n times\n   h[i]           The i'th octet\
    \ of octet string\n   h_i            The i'th bit of h\n   a || b         (bit-)string\
    \ a concatenated with (bit-)string b\n   a <= b         a is less than or equal\
    \ to b\n   a >= b         a is greater than or equal to b\n   i+j            Sum\
    \ of i and j\n   i*j            Multiplication of i and j\n   i-j            Subtraction\
    \ of j from i\n   i/j            Division of i by j\n   i x j          Cartesian\
    \ product of i and j\n   (u,v)          Elliptic curve point with x-coordinate\
    \ u and\n                  y-coordinate v\n   SHAKE256(x, y) The y first octets\
    \ of SHAKE256 [FIPS202] output for\n                  input x\n   OCTET(x)   \
    \    The octet with value x\n   OLEN(x)        The number of octets in string\
    \ x\n   dom2(x, y)     The blank octet string when signing or verifying\n    \
    \              Ed25519.  Otherwise, the octet string: \"SigEd25519 no\n      \
    \            Ed25519 collisions\" || octet(x) || octet(OLEN(y)) ||\n         \
    \         y, where x is in range 0-255 and y is an octet string\n            \
    \      of at most 255 octets.  \"SigEd25519 no Ed25519\n                  collisions\"\
    \ is in ASCII (32 octets).\n   dom4(x, y)     The octet string \"SigEd448\" ||\
    \ octet(x) ||\n                  octet(OLEN(y)) || y, where x is in range 0-255\
    \ and y\n                  is an octet string of at most 255 octets.  \"SigEd448\"\
    \n                  is in ASCII (8 octets).\n   Parentheses (i.e., '(' and ')')\
    \ are used to group expressions, in\n   order to avoid having the description\
    \ depend on a binding order\n   between operators.\n   Bit strings are converted\
    \ to octet strings by taking bits from left\n   to right, packing those from the\
    \ least significant bit of each octet\n   to the most significant bit, and moving\
    \ to the next octet when each\n   octet fills up.  The conversion from octet string\
    \ to bit string is\n   the reverse of this process; for example, the 16-bit bit\
    \ string\n             b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15\n\
    \   is converted into two octets x0 and x1 (in this order) as\n             x0\
    \ = b7*128+b6*64+b5*32+b4*16+b3*8+b2*4+b1*2+b0\n             x1 = b15*128+b14*64+b13*32+b12*16+b11*8+b10*4+b9*2+b8\n\
    \   Little-endian encoding into bits places bits from left to right and\n   from\
    \ least significant to most significant.  If combined with\n   bit-string-to-octet-string\
    \ conversion defined above, this results in\n   little-endian encoding into octets\
    \ (if length is not a multiple of 8,\n   the most significant bits of the last\
    \ octet remain unused).\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \
    \ \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  EdDSA Algorithm
  contents:
  - "3.  EdDSA Algorithm\n   EdDSA is a digital signature system with 11 parameters.\n\
    \   The generic EdDSA digital signature system with its 11 input\n   parameters\
    \ is not intended to be implemented directly.  Choosing\n   parameters is critical\
    \ for secure and efficient operation.  Instead,\n   you would implement a particular\
    \ parameter choice for EdDSA (such as\n   Ed25519 or Ed448), sometimes slightly\
    \ generalized to achieve code\n   reuse to cover Ed25519 and Ed448.\n   Therefore,\
    \ a precise explanation of the generic EdDSA is thus not\n   particularly useful\
    \ for implementers.  For background and\n   completeness, a succinct description\
    \ of the generic EdDSA algorithm\n   is given here.\n   The definition of some\
    \ parameters, such as n and c, may help to\n   explain some steps of the algorithm\
    \ that are not intuitive.\n   This description closely follows [EDDSA2].\n   EdDSA\
    \ has 11 parameters:\n   1.   An odd prime power p.  EdDSA uses an elliptic curve\
    \ over the\n        finite field GF(p).\n   2.   An integer b with 2^(b-1) > p.\
    \  EdDSA public keys have exactly b\n        bits, and EdDSA signatures have exactly\
    \ 2*b bits.  b is\n        recommended to be a multiple of 8, so public key and\
    \ signature\n        lengths are an integral number of octets.\n   3.   A (b-1)-bit\
    \ encoding of elements of the finite field GF(p).\n   4.   A cryptographic hash\
    \ function H producing 2*b-bit output.\n        Conservative hash functions (i.e.,\
    \ hash functions where it is\n        infeasible to create collisions) are recommended\
    \ and do not have\n        much impact on the total cost of EdDSA.\n   5.   An\
    \ integer c that is 2 or 3.  Secret EdDSA scalars are multiples\n        of 2^c.\
    \  The integer c is the base-2 logarithm of the so-called\n        cofactor.\n\
    \   6.   An integer n with c <= n < b.  Secret EdDSA scalars have exactly\n  \
    \      n + 1 bits, with the top bit (the 2^n position) always set and\n      \
    \  the bottom c bits always cleared.\n   7.   A non-square element d of GF(p).\
    \  The usual recommendation is to\n        take it as the value nearest to zero\
    \ that gives an acceptable\n        curve.\n   8.   A non-zero square element\
    \ a of GF(p).  The usual recommendation\n        for best performance is a = -1\
    \ if p mod 4 = 1, and a = 1 if\n        p mod 4 = 3.\n   9.   An element B !=\
    \ (0,1) of the set E = { (x,y) is a member of\n        GF(p) x GF(p) such that\
    \ a * x^2 + y^2 = 1 + d * x^2 * y^2 }.\n   10.  An odd prime L such that [L]B\
    \ = 0 and 2^c * L = #E.  The number\n        #E (the number of points on the curve)\
    \ is part of the standard\n        data provided for an elliptic curve E, or it\
    \ can be computed as\n        cofactor * order.\n   11.  A \"prehash\" function\
    \ PH.  PureEdDSA means EdDSA where PH is the\n        identity function, i.e.,\
    \ PH(M) = M.  HashEdDSA means EdDSA where\n        PH generates a short output,\
    \ no matter how long the message is;\n        for example, PH(M) = SHA-512(M).\n\
    \   Points on the curve form a group under addition, (x3, y3) = (x1, y1)\n   +\
    \ (x2, y2), with the formulas\n             x1 * y2 + x2 * y1                y1\
    \ * y2 - a * x1 * x2\n   x3 = --------------------------,   y3 = ---------------------------\n\
    \         1 + d * x1 * x2 * y1 * y2          1 - d * x1 * x2 * y1 * y2\n   The\
    \ neutral element in the group is (0,1).\n   Unlike many other curves used for\
    \ cryptographic applications, these\n   formulas are \"complete\"; they are valid\
    \ for all points on the curve,\n   with no exceptions.  In particular, the denominators\
    \ are non-zero for\n   all input points.\n   There are more efficient formulas,\
    \ which are still complete, that use\n   homogeneous coordinates to avoid the\
    \ expensive modulo p inversions.\n   See [Faster-ECC] and [Edwards-revisited].\n"
- title: 3.1.  Encoding
  contents:
  - "3.1.  Encoding\n   An integer 0 < S < L - 1 is encoded in little-endian form\
    \ as a b-bit\n   string ENC(S).\n   An element (x,y) of E is encoded as a b-bit\
    \ string called ENC(x,y),\n   which is the (b-1)-bit encoding of y concatenated\
    \ with one bit that\n   is 1 if x is negative and 0 if x is not negative.\n  \
    \ The encoding of GF(p) is used to define \"negative\" elements of GF(p):\n  \
    \ specifically, x is negative if the (b-1)-bit encoding of x is\n   lexicographically\
    \ larger than the (b-1)-bit encoding of -x.\n"
- title: 3.2.  Keys
  contents:
  - "3.2.  Keys\n   An EdDSA private key is a b-bit string k.  Let the hash H(k) =\n\
    \   (h_0, h_1, ..., h_(2b-1)) determine an integer s, which is 2^n plus\n   the\
    \ sum of m = 2^i * h_i for all integer i, c <= i < n.  Let s\n   determine the\
    \ multiple A = [s]B.  The EdDSA public key is ENC(A).\n   The bits h_b, ..., h_(2b-1)\
    \ are used below during signing.\n"
- title: 3.3.  Sign
  contents:
  - "3.3.  Sign\n   The EdDSA signature of a message M under a private key k is defined\n\
    \   as the PureEdDSA signature of PH(M).  In other words, EdDSA simply\n   uses\
    \ PureEdDSA to sign PH(M).\n   The PureEdDSA signature of a message M under a\
    \ private key k is the\n   2*b-bit string ENC(R) || ENC(S).  R and S are derived\
    \ as follows.\n   First define r = H(h_b || ... || h_(2b-1) || M) interpreting\
    \ 2*b-bit\n   strings in little-endian form as integers in {0, 1, ..., 2^(2*b)\
    \ -\n   1}.  Let R = [r]B and S = (r + H(ENC(R) || ENC(A) || PH(M)) * s) mod\n\
    \   L.  The s used here is from the previous section.\n"
- title: 3.4.  Verify
  contents:
  - "3.4.  Verify\n   To verify a PureEdDSA signature ENC(R) || ENC(S) on a message\
    \ M under\n   a public key ENC(A), proceed as follows.  Parse the inputs so that\
    \ A\n   and R are elements of E, and S is a member of the set {0, 1, ...,\n  \
    \ L-1}.  Compute h = H(ENC(R) || ENC(A) || M), and check the group\n   equation\
    \ [2^c * S] B = 2^c * R + [2^c * h] A in E.  The signature is\n   rejected if\
    \ parsing fails (including S being out of range) or if the\n   group equation\
    \ does not hold.\n   EdDSA verification for a message M is defined as PureEdDSA\n\
    \   verification for PH(M).\n"
- title: 4.  PureEdDSA, HashEdDSA, and Naming
  contents:
  - "4.  PureEdDSA, HashEdDSA, and Naming\n   One of the parameters of the EdDSA algorithm\
    \ is the \"prehash\"\n   function.  This may be the identity function, resulting\
    \ in an\n   algorithm called PureEdDSA, or a collision-resistant hash function\n\
    \   such as SHA-512, resulting in an algorithm called HashEdDSA.\n   Choosing\
    \ which variant to use depends on which property is deemed to\n   be more important\
    \ between 1) collision resilience and 2) a single-\n   pass interface for creating\
    \ signatures.  The collision resilience\n   property means EdDSA is secure even\
    \ if it is feasible to compute\n   collisions for the hash function.  The single-pass\
    \ interface property\n   means that only one pass over the input message is required\
    \ to create\n   a signature.  PureEdDSA requires two passes over the input.  Many\n\
    \   existing APIs, protocols, and environments assume digital signature\n   algorithms\
    \ only need one pass over the input and may have API or\n   bandwidth concerns\
    \ supporting anything else.\n   Note that single-pass verification is not possible\
    \ with most uses of\n   signatures, no matter which signature algorithm is chosen.\
    \  This is\n   because most of the time, one can't process the message until the\n\
    \   signature is validated, which needs a pass on the entire message.\n   This\
    \ document specifies parameters resulting in the HashEdDSA\n   variants Ed25519ph\
    \ and Ed448ph and the PureEdDSA variants Ed25519 and\n   Ed448.\n"
- title: 5.  EdDSA Instances
  contents:
  - "5.  EdDSA Instances\n   This section instantiates the general EdDSA algorithm\
    \ for the\n   edwards25519 and edwards448 curves, each for the PureEdDSA and\n\
    \   HashEdDSA variants (plus a contextualized extension of the Ed25519\n   scheme).\
    \  Thus, five different parameter sets are described.\n"
- title: 5.1.  Ed25519ph, Ed25519ctx, and Ed25519
  contents:
  - "5.1.  Ed25519ph, Ed25519ctx, and Ed25519\n   Ed25519 is EdDSA instantiated with:\n\
    \   +-----------+-------------------------------------------------------+\n  \
    \ | Parameter | Value                                                 |\n   +-----------+-------------------------------------------------------+\n\
    \   |     p     | p of edwards25519 in [RFC7748] (i.e., 2^255 - 19)     |\n  \
    \ |     b     | 256                                                   |\n   |\
    \  encoding | 255-bit little-endian encoding of {0, 1, ..., p-1}    |\n   |  of\
    \ GF(p) |                                                       |\n   |    H(x)\
    \   | SHA-512(dom2(phflag,context)||x) [RFC6234]            |\n   |     c    \
    \ | base 2 logarithm of cofactor of edwards25519 in       |\n   |           |\
    \ [RFC7748] (i.e., 3)                                   |\n   |     n     | 254\
    \                                                   |\n   |     d     | d of edwards25519\
    \ in [RFC7748] (i.e., -121665/121666  |\n   |           | = 370957059346694393431380835087545651895421138798432\
    \ |\n   |           | 19016388785533085940283555)                           |\n\
    \   |     a     | -1                                                    |\n  \
    \ |     B     | (X(P),Y(P)) of edwards25519 in [RFC7748] (i.e., (1511 |\n   |\
    \           | 22213495354007725011514095885315114540126930418572060 |\n   |  \
    \         | 46113283949847762202, 4631683569492647816942839400347 |\n   |    \
    \       | 5163141307993866256225615783033603165251855960))      |\n   |     L\
    \     | order of edwards25519 in [RFC7748] (i.e.,             |\n   |        \
    \   | 2^252+27742317777372353535851937790883648493).        |\n   |   PH(x)  \
    \ | x (i.e., the identity function)                       |\n   +-----------+-------------------------------------------------------+\n\
    \                      Table 1: Parameters of Ed25519\n   For Ed25519, dom2(f,c)\
    \ is the empty string.  The phflag value is\n   irrelevant.  The context (if present\
    \ at all) MUST be empty.  This\n   causes the scheme to be one and the same with\
    \ the Ed25519 scheme\n   published earlier.\n   For Ed25519ctx, phflag=0.  The\
    \ context input SHOULD NOT be empty.\n   For Ed25519ph, phflag=1 and PH is SHA512\
    \ instead.  That is, the input\n   is hashed using SHA-512 before signing with\
    \ Ed25519.\n   Value of context is set by the signer and verifier (maximum of\
    \ 255\n   octets; the default is empty string, except for Ed25519, which can't\n\
    \   have context) and has to match octet by octet for verification to be\n   successful.\n\
    \   The curve used is equivalent to Curve25519 [CURVE25519], under a\n   change\
    \ of coordinates, which means that the difficulty of the\n   discrete logarithm\
    \ problem is the same as for Curve25519.\n"
- title: 5.1.1.  Modular Arithmetic
  contents:
  - "5.1.1.  Modular Arithmetic\n   For advice on how to implement arithmetic modulo\
    \ p = 2^255 - 19\n   efficiently and securely, see Curve25519 [CURVE25519].  For\
    \ inversion\n   modulo p, it is recommended to use the identity x^-1 = x^(p-2)\
    \ (mod\n   p).  Inverting zero should never happen, as it would require invalid\n\
    \   input, which would have been detected before, or would be a\n   calculation\
    \ error.\n   For point decoding or \"decompression\", square roots modulo p are\n\
    \   needed.  They can be computed using the Tonelli-Shanks algorithm or\n   the\
    \ special case for p = 5 (mod 8).  To find a square root of a,\n   first compute\
    \ the candidate root x = a^((p+3)/8) (mod p).  Then there\n   are three cases:\n\
    \      x^2 = a (mod p).  Then x is a square root.\n      x^2 = -a (mod p).  Then\
    \ 2^((p-1)/4) * x is a square root.\n      a is not a square modulo p.\n"
- title: 5.1.2.  Encoding
  contents:
  - "5.1.2.  Encoding\n   All values are coded as octet strings, and integers are\
    \ coded using\n   little-endian convention, i.e., a 32-octet string h h[0],...h[31]\n\
    \   represents the integer h[0] + 2^8 * h[1] + ... + 2^248 * h[31].\n   A curve\
    \ point (x,y), with coordinates in the range 0 <= x,y < p, is\n   coded as follows.\
    \  First, encode the y-coordinate as a little-endian\n   string of 32 octets.\
    \  The most significant bit of the final octet is\n   always zero.  To form the\
    \ encoding of the point, copy the least\n   significant bit of the x-coordinate\
    \ to the most significant bit of\n   the final octet.\n"
- title: 5.1.3.  Decoding
  contents:
  - "5.1.3.  Decoding\n   Decoding a point, given as a 32-octet string, is a little\
    \ more\n   complicated.\n   1.  First, interpret the string as an integer in little-endian\n\
    \       representation.  Bit 255 of this number is the least significant\n   \
    \    bit of the x-coordinate and denote this value x_0.  The\n       y-coordinate\
    \ is recovered simply by clearing this bit.  If the\n       resulting value is\
    \ >= p, decoding fails.\n   2.  To recover the x-coordinate, the curve equation\
    \ implies\n       x^2 = (y^2 - 1) / (d y^2 + 1) (mod p).  The denominator is always\n\
    \       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 + 1.  To compute\n    \
    \   the square root of (u/v), the first step is to compute the\n       candidate\
    \ root x = (u/v)^((p+3)/8).  This can be done with the\n       following trick,\
    \ using a single modular powering for both the\n       inversion of v and the\
    \ square root:\n                          (p+3)/8      3        (p-5)/8\n    \
    \             x = (u/v)        = u v  (u v^7)         (mod p)\n   3.  Again, there\
    \ are three cases:\n       1.  If v x^2 = u (mod p), x is a square root.\n   \
    \    2.  If v x^2 = -u (mod p), set x <-- x * 2^((p-1)/4), which is a\n      \
    \     square root.\n       3.  Otherwise, no square root exists for modulo p,\
    \ and decoding\n           fails.\n   4.  Finally, use the x_0 bit to select the\
    \ right square root.  If\n       x = 0, and x_0 = 1, decoding fails.  Otherwise,\
    \ if x_0 != x mod\n       2, set x <-- p - x.  Return the decoded point (x,y).\n"
- title: 5.1.4.  Point Addition
  contents:
  - "5.1.4.  Point Addition\n   For point addition, the following method is recommended.\
    \  A point\n   (x,y) is represented in extended homogeneous coordinates (X, Y,\
    \ Z,\n   T), with x = X/Z, y = Y/Z, x * y = T/Z.\n   The neutral point is (0,1),\
    \ or equivalently in extended homogeneous\n   coordinates (0, Z, Z, 0) for any\
    \ non-zero Z.\n   The following formulas for adding two points, (x3,y3) =\n  \
    \ (x1,y1)+(x2,y2), on twisted Edwards curves with a=-1, square a, and\n   non-square\
    \ d are described in Section 3.1 of [Edwards-revisited] and\n   in [EFD-TWISTED-ADD].\
    \  They are complete, i.e., they work for any\n   pair of valid input points.\n\
    \                 A = (Y1-X1)*(Y2-X2)\n                 B = (Y1+X1)*(Y2+X2)\n\
    \                 C = T1*2*d*T2\n                 D = Z1*2*Z2\n              \
    \   E = B-A\n                 F = D-C\n                 G = D+C\n            \
    \     H = B+A\n                 X3 = E*F\n                 Y3 = G*H\n        \
    \         T3 = E*H\n                 Z3 = F*G\n   For point doubling, (x3,y3)\
    \ = (x1,y1)+(x1,y1), one could just\n   substitute equal points in the above (because\
    \ of completeness, such\n   substitution is valid) and observe that four multiplications\
    \ turn\n   into squares.  However, using the formulas described in Section 3.2\n\
    \   of [Edwards-revisited] and in [EFD-TWISTED-DBL] saves a few smaller\n   operations.\n\
    \                 A = X1^2\n                 B = Y1^2\n                 C = 2*Z1^2\n\
    \                 H = A+B\n                 E = H-(X1+Y1)^2\n                \
    \ G = A-B\n                 F = C+G\n                 X3 = E*F\n             \
    \    Y3 = G*H\n                 T3 = E*H\n                 Z3 = F*G\n"
- title: 5.1.5.  Key Generation
  contents:
  - "5.1.5.  Key Generation\n   The private key is 32 octets (256 bits, corresponding\
    \ to b) of\n   cryptographically secure random data.  See [RFC4086] for a discussion\n\
    \   about randomness.\n   The 32-byte public key is generated by the following\
    \ steps.\n   1.  Hash the 32-byte private key using SHA-512, storing the digest\
    \ in\n       a 64-octet large buffer, denoted h.  Only the lower 32 bytes are\n\
    \       used for generating the public key.\n   2.  Prune the buffer: The lowest\
    \ three bits of the first octet are\n       cleared, the highest bit of the last\
    \ octet is cleared, and the\n       second highest bit of the last octet is set.\n\
    \   3.  Interpret the buffer as the little-endian integer, forming a\n       secret\
    \ scalar s.  Perform a fixed-base scalar multiplication\n       [s]B.\n   4. \
    \ The public key A is the encoding of the point [s]B.  First,\n       encode the\
    \ y-coordinate (in the range 0 <= y < p) as a little-\n       endian string of\
    \ 32 octets.  The most significant bit of the\n       final octet is always zero.\
    \  To form the encoding of the point\n       [s]B, copy the least significant\
    \ bit of the x coordinate to the\n       most significant bit of the final octet.\
    \  The result is the\n       public key.\n"
- title: 5.1.6.  Sign
  contents:
  - "5.1.6.  Sign\n   The inputs to the signing procedure is the private key, a 32-octet\n\
    \   string, and a message M of arbitrary size.  For Ed25519ctx and\n   Ed25519ph,\
    \ there is additionally a context C of at most 255 octets\n   and a flag F, 0\
    \ for Ed25519ctx and 1 for Ed25519ph.\n   1.  Hash the private key, 32 octets,\
    \ using SHA-512.  Let h denote the\n       resulting digest.  Construct the secret\
    \ scalar s from the first\n       half of the digest, and the corresponding public\
    \ key A, as\n       described in the previous section.  Let prefix denote the\
    \ second\n       half of the hash digest, h[32],...,h[63].\n   2.  Compute SHA-512(dom2(F,\
    \ C) || prefix || PH(M)), where M is the\n       message to be signed.  Interpret\
    \ the 64-octet digest as a little-\n       endian integer r.\n   3.  Compute the\
    \ point [r]B.  For efficiency, do this by first\n       reducing r modulo L, the\
    \ group order of B.  Let the string R be\n       the encoding of this point.\n\
    \   4.  Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the\n   \
    \    64-octet digest as a little-endian integer k.\n   5.  Compute S = (r + k\
    \ * s) mod L.  For efficiency, again reduce k\n       modulo L first.\n   6. \
    \ Form the signature of the concatenation of R (32 octets) and the\n       little-endian\
    \ encoding of S (32 octets; the three most\n       significant bits of the final\
    \ octet are always zero).\n"
- title: 5.1.7.  Verify
  contents:
  - "5.1.7.  Verify\n   1.  To verify a signature on a message M using public key\
    \ A, with F\n       being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx\
    \ or\n       Ed25519ph is being used, C being the context, first split the\n \
    \      signature into two 32-octet halves.  Decode the first half as a\n     \
    \  point R, and the second half as an integer S, in the range\n       0 <= s <\
    \ L.  Decode the public key A as point A'.  If any of the\n       decodings fail\
    \ (including S being out of range), the signature is\n       invalid.\n   2. \
    \ Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the\n       64-octet\
    \ digest as a little-endian integer k.\n   3.  Check the group equation [8][S]B\
    \ = [8]R + [8][k]A'.  It's\n       sufficient, but not required, to instead check\
    \ [S]B = R + [k]A'.\n"
- title: 5.2.  Ed448ph and Ed448
  contents:
  - "5.2.  Ed448ph and Ed448\n   Ed448 is EdDSA instantiated with:\n   +-----------+-------------------------------------------------------+\n\
    \   | Parameter | Value                                                 |\n  \
    \ +-----------+-------------------------------------------------------+\n   |\
    \     p     | p of edwards448 in [RFC7748] (i.e., 2^448 - 2^224 -   |\n   |  \
    \         | 1)                                                    |\n   |    \
    \ b     | 456                                                   |\n   |  encoding\
    \ | 455-bit little-endian encoding of {0, 1, ..., p-1}    |\n   |  of GF(p) |\
    \                                                       |\n   |    H(x)   | SHAKE256(dom4(phflag,context)||x,\
    \ 114)                |\n   |   phflag  | 0                                  \
    \                   |\n   |     c     | base 2 logarithm of cofactor of edwards448\
    \ in         |\n   |           | [RFC7748] (i.e., 2)                         \
    \          |\n   |     n     | 447                                           \
    \        |\n   |     d     | d of edwards448 in [RFC7748] (i.e., -39081)     \
    \      |\n   |     a     | 1                                                 \
    \    |\n   |     B     | (X(P),Y(P)) of edwards448 in [RFC7748] (i.e., (224580\
    \ |\n   |           | 04029592430018760433409989603624678964163256413424612 |\n\
    \   |           | 54616869504154674060329090291928693579532825780320751 |\n  \
    \ |           | 46446173674602635247710, 2988192100784814926760179304 |\n   |\
    \           | 43930673437544040154080242095928241372331506189835876 |\n   |  \
    \         | 00353687865541878473398230323350346250053154506283266 |\n   |    \
    \       | 0))                                                   |\n   |     L\
    \     | order of edwards448 in [RFC7748] (i.e., 2^446 - 13818 |\n   |        \
    \   | 06680989511535200738674851542688033669247488217860989 |\n   |          \
    \ | 4547503885).                                          |\n   |   PH(x)   |\
    \ x (i.e., the identity function)                       |\n   +-----------+-------------------------------------------------------+\n\
    \                       Table 2: Parameters of Ed448\n   Ed448ph is the same but\
    \ with PH being SHAKE256(x, 64) and phflag\n   being 1, i.e., the input is hashed\
    \ before signing with Ed448 with a\n   hash constant modified.\n   Value of context\
    \ is set by signer and verifier (maximum of 255\n   octets; the default is empty\
    \ string) and has to match octet by octet\n   for verification to be successful.\n\
    \   The curve is equivalent to Ed448-Goldilocks under change of the\n   basepoint,\
    \ which preserves difficulty of the discrete logarithm.\n"
- title: 5.2.1.  Modular Arithmetic
  contents:
  - "5.2.1.  Modular Arithmetic\n   For advice on how to implement arithmetic modulo\
    \ p = 2^448 - 2^224 -\n   1 efficiently and securely, see [ED448].  For inversion\
    \ modulo p, it\n   is recommended to use the identity x^-1 = x^(p-2) (mod p).\
    \  Inverting\n   zero should never happen, as it would require invalid input,\
    \ which\n   would have been detected before, or would be a calculation error.\n\
    \   For point decoding or \"decompression\", square roots modulo p are\n   needed.\
    \  They can be computed by first computing candidate root\n   x = a ^ (p+1)/4\
    \ (mod p) and then checking if x^2 = a.  If it is, then\n   x is the square root\
    \ of a; if it isn't, then a does not have a square\n   root.\n"
- title: 5.2.2.  Encoding
  contents:
  - "5.2.2.  Encoding\n   All values are coded as octet strings, and integers are\
    \ coded using\n   little-endian convention, i.e., a 57-octet string h h[0],...h[56]\n\
    \   represents the integer h[0] + 2^8 * h[1] + ... + 2^448 * h[56].\n   A curve\
    \ point (x,y), with coordinates in the range 0 <= x,y < p, is\n   coded as follows.\
    \  First, encode the y-coordinate as a little-endian\n   string of 57 octets.\
    \  The final octet is always zero.  To form the\n   encoding of the point, copy\
    \ the least significant bit of the\n   x-coordinate to the most significant bit\
    \ of the final octet.\n"
- title: 5.2.3.  Decoding
  contents:
  - "5.2.3.  Decoding\n   Decoding a point, given as a 57-octet string, is a little\
    \ more\n   complicated.\n   1.  First, interpret the string as an integer in little-endian\n\
    \       representation.  Bit 455 of this number is the least significant\n   \
    \    bit of the x-coordinate, and denote this value x_0.  The\n       y-coordinate\
    \ is recovered simply by clearing this bit.  If the\n       resulting value is\
    \ >= p, decoding fails.\n   2.  To recover the x-coordinate, the curve equation\
    \ implies\n       x^2 = (y^2 - 1) / (d y^2 - 1) (mod p).  The denominator is always\n\
    \       non-zero mod p.  Let u = y^2 - 1 and v = d y^2 - 1.  To compute\n    \
    \   the square root of (u/v), the first step is to compute the\n       candidate\
    \ root x = (u/v)^((p+1)/4).  This can be done using the\n       following trick,\
    \ to use a single modular powering for both the\n       inversion of v and the\
    \ square root:\n                          (p+1)/4    3            (p-3)/4\n  \
    \               x = (u/v)        = u  v (u^5 v^3)         (mod p)\n   3.  If v\
    \ * x^2 = u, the recovered x-coordinate is x.  Otherwise, no\n       square root\
    \ exists, and the decoding fails.\n   4.  Finally, use the x_0 bit to select the\
    \ right square root.  If\n       x = 0, and x_0 = 1, decoding fails.  Otherwise,\
    \ if x_0 != x mod\n       2, set x <-- p - x.  Return the decoded point (x,y).\n"
- title: 5.2.4.  Point Addition
  contents:
  - "5.2.4.  Point Addition\n   For point addition, the following method is recommended.\
    \  A point\n   (x,y) is represented in projective coordinates (X, Y, Z), with\n\
    \   x = X/Z, y = Y/Z.\n   The neutral point is (0,1), or equivalently in projective\
    \ coordinates\n   (0, Z, Z) for any non-zero Z.\n   The following formulas for\
    \ adding two points, (x3,y3) =\n   (x1,y1)+(x2,y2) on untwisted Edwards curve\
    \ (i.e., a=1) with non-\n   square d, are described in Section 4 of [Faster-ECC]\
    \ and in\n   [EFD-ADD].  They are complete, i.e., they work for any pair of valid\n\
    \   input points.\n                 A = Z1*Z2\n                 B = A^2\n    \
    \             C = X1*X2\n                 D = Y1*Y2\n                 E = d*C*D\n\
    \                 F = B-E\n                 G = B+E\n                 H = (X1+Y1)*(X2+Y2)\n\
    \                 X3 = A*F*(H-C-D)\n                 Y3 = A*G*(D-C)\n        \
    \         Z3 = F*G\n   Again, similar to the other curve, doubling formulas can\
    \ be obtained\n   by substituting equal points, turning four multiplications into\n\
    \   squares.  However, this is not even nearly optimal; the following\n   formulas\
    \ described in Section 4 of [Faster-ECC] and in [EFD-DBL] save\n   multiple multiplications.\n\
    \                 B = (X1+Y1)^2\n                 C = X1^2\n                 D\
    \ = Y1^2\n                 E = C+D\n                 H = Z1^2\n              \
    \   J = E-2*H\n                 X3 = (B-E)*J\n                 Y3 = E*(C-D)\n\
    \                 Z3 = E*J\n"
- title: 5.2.5.  Key Generation
  contents:
  - "5.2.5.  Key Generation\n   The private key is 57 octets (456 bits, corresponding\
    \ to b) of\n   cryptographically secure random data.  See [RFC4086] for a discussion\n\
    \   about randomness.\n   The 57-byte public key is generated by the following\
    \ steps:\n   1.  Hash the 57-byte private key using SHAKE256(x, 114), storing\
    \ the\n       digest in a 114-octet large buffer, denoted h.  Only the lower 57\n\
    \       bytes are used for generating the public key.\n   2.  Prune the buffer:\
    \ The two least significant bits of the first\n       octet are cleared, all eight\
    \ bits the last octet are cleared, and\n       the highest bit of the second to\
    \ last octet is set.\n   3.  Interpret the buffer as the little-endian integer,\
    \ forming a\n       secret scalar s.  Perform a known-base-point scalar\n    \
    \   multiplication [s]B.\n   4.  The public key A is the encoding of the point\
    \ [s]B.  First encode\n       the y-coordinate (in the range 0 <= y < p) as a\
    \ little-endian\n       string of 57 octets.  The most significant bit of the\
    \ final octet\n       is always zero.  To form the encoding of the point [s]B,\
    \ copy the\n       least significant bit of the x coordinate to the most significant\n\
    \       bit of the final octet.  The result is the public key.\n"
- title: 5.2.6.  Sign
  contents:
  - "5.2.6.  Sign\n   The inputs to the signing procedure is the private key, a 57-octet\n\
    \   string, a flag F, which is 0 for Ed448, 1 for Ed448ph, context C of\n   at\
    \ most 255 octets, and a message M of arbitrary size.\n   1.  Hash the private\
    \ key, 57 octets, using SHAKE256(x, 114).  Let h\n       denote the resulting\
    \ digest.  Construct the secret scalar s from\n       the first half of the digest,\
    \ and the corresponding public key A,\n       as described in the previous section.\
    \  Let prefix denote the\n       second half of the hash digest, h[57],...,h[113].\n\
    \   2.  Compute SHAKE256(dom4(F, C) || prefix || PH(M), 114), where M is\n   \
    \    the message to be signed, F is 1 for Ed448ph, 0 for Ed448, and C\n      \
    \ is the context to use.  Interpret the 114-octet digest as a\n       little-endian\
    \ integer r.\n   3.  Compute the point [r]B.  For efficiency, do this by first\n\
    \       reducing r modulo L, the group order of B.  Let the string R be\n    \
    \   the encoding of this point.\n   4.  Compute SHAKE256(dom4(F, C) || R || A\
    \ || PH(M), 114), and\n       interpret the 114-octet digest as a little-endian\
    \ integer k.\n   5.  Compute S = (r + k * s) mod L.  For efficiency, again reduce\
    \ k\n       modulo L first.\n   6.  Form the signature of the concatenation of\
    \ R (57 octets) and the\n       little-endian encoding of S (57 octets; the ten\
    \ most significant\n       bits of the final octets are always zero).\n"
- title: 5.2.7.  Verify
  contents:
  - "5.2.7.  Verify\n   1.  To verify a signature on a message M using context C and\
    \ public\n       key A, with F being 0 for Ed448 and 1 for Ed448ph, first split\n\
    \       the signature into two 57-octet halves.  Decode the first half as\n  \
    \     a point R, and the second half as an integer S, in the range 0 <=\n    \
    \   s < L.  Decode the public key A as point A'.  If any of the\n       decodings\
    \ fail (including S being out of range), the signature is\n       invalid.\n \
    \  2.  Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and\n       interpret\
    \ the 114-octet digest as a little-endian integer k.\n   3.  Check the group equation\
    \ [4][S]B = [4]R + [4][k]A'.  It's\n       sufficient, but not required, to instead\
    \ check [S]B = R + [k]A'.\n"
- title: 6.  Ed25519 Python Illustration
  contents:
  - "6.  Ed25519 Python Illustration\n   The rest of this section describes how Ed25519\
    \ can be implemented in\n   Python (version 3.2 or later) for illustration.  See\
    \ Appendix A for\n   the complete implementation and Appendix B for a test-driver\
    \ to run\n   it through some test vectors.\n   Note that this code is not intended\
    \ for production as it is not\n   proven to be correct for all inputs, nor does\
    \ it protect against\n   side-channel attacks.  The purpose is to illustrate the\
    \ algorithm to\n   help implementers with their own implementation.\n"
- title: '## First, some preliminaries that will be needed.'
  contents:
  - '## First, some preliminaries that will be needed.

    '
- title: import hashlib
  contents:
  - 'import hashlib

    '
- title: 'def sha512(s):'
  contents:
  - "def sha512(s):\n    return hashlib.sha512(s).digest()\n"
- title: '# Base field Z_p'
  contents:
  - '# Base field Z_p

    '
- title: p = 2**255 - 19
  contents:
  - 'p = 2**255 - 19

    '
- title: 'def modp_inv(x):'
  contents:
  - "def modp_inv(x):\n    return pow(x, p-2, p)\n"
- title: '# Curve constant'
  contents:
  - '# Curve constant

    '
- title: d = -121665 * modp_inv(121666) % p
  contents:
  - 'd = -121665 * modp_inv(121666) % p

    '
- title: '# Group order'
  contents:
  - '# Group order

    '
- title: q = 2**252 + 27742317777372353535851937790883648493
  contents:
  - 'q = 2**252 + 27742317777372353535851937790883648493

    '
- title: 'def sha512_modq(s):'
  contents:
  - "def sha512_modq(s):\n    return int.from_bytes(sha512(s), \"little\") % q\n"
- title: '## Then follows functions to perform point operations.'
  contents:
  - '## Then follows functions to perform point operations.

    '
- title: '# Points are represented as tuples (X, Y, Z, T) of extended'
  contents:
  - '# Points are represented as tuples (X, Y, Z, T) of extended

    '
- title: '# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z'
  contents:
  - '# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z

    '
- title: 'def point_add(P, Q):'
  contents:
  - "def point_add(P, Q):\n    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) *\
    \ (Q[1]+Q[0]) % p;\n    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;\n\
    \    E, F, G, H = B-A, D-C, D+C, B+A;\n    return (E*F, G*H, F*G, E*H);\n"
- title: '# Computes Q = s * Q'
  contents:
  - '# Computes Q = s * Q

    '
- title: 'def point_mul(s, P):'
  contents:
  - "def point_mul(s, P):\n    Q = (0, 1, 1, 0)  # Neutral element\n    while s >\
    \ 0:\n        if s & 1:\n            Q = point_add(Q, P)\n        P = point_add(P,\
    \ P)\n        s >>= 1\n    return Q\n"
- title: 'def point_equal(P, Q):'
  contents:
  - "def point_equal(P, Q):\n    # x1 / z1 == x2 / z2  <==>  x1 * z2 == x2 * z1\n\
    \    if (P[0] * Q[2] - Q[0] * P[2]) % p != 0:\n        return False\n    if (P[1]\
    \ * Q[2] - Q[1] * P[2]) % p != 0:\n        return False\n    return True\n"
- title: '## Now follows functions for point compression.'
  contents:
  - '## Now follows functions for point compression.

    '
- title: '# Square root of -1'
  contents:
  - '# Square root of -1

    '
- title: modp_sqrt_m1 = pow(2, (p-1) // 4, p)
  contents:
  - 'modp_sqrt_m1 = pow(2, (p-1) // 4, p)

    '
- title: '# Compute corresponding x-coordinate, with low bit corresponding to'
  contents:
  - '# Compute corresponding x-coordinate, with low bit corresponding to

    '
- title: '# sign, or return None on failure'
  contents:
  - '# sign, or return None on failure

    '
- title: 'def recover_x(y, sign):'
  contents:
  - "def recover_x(y, sign):\n    if y >= p:\n        return None\n    x2 = (y*y-1)\
    \ * modp_inv(d*y*y+1)\n    if x2 == 0:\n        if sign:\n            return None\n\
    \        else:\n            return 0\n    # Compute square root of x2\n    x =\
    \ pow(x2, (p+3) // 8, p)\n    if (x*x - x2) % p != 0:\n        x = x * modp_sqrt_m1\
    \ % p\n    if (x*x - x2) % p != 0:\n        return None\n    if (x & 1) != sign:\n\
    \        x = p - x\n    return x\n"
- title: '# Base point'
  contents:
  - '# Base point

    '
- title: g_y = 4 * modp_inv(5) % p
  contents:
  - 'g_y = 4 * modp_inv(5) % p

    '
- title: g_x = recover_x(g_y, 0)
  contents:
  - 'g_x = recover_x(g_y, 0)

    '
- title: G = (g_x, g_y, 1, g_x * g_y % p)
  contents:
  - 'G = (g_x, g_y, 1, g_x * g_y % p)

    '
- title: 'def point_compress(P):'
  contents:
  - "def point_compress(P):\n    zinv = modp_inv(P[2])\n    x = P[0] * zinv % p\n\
    \    y = P[1] * zinv % p\n    return int.to_bytes(y | ((x & 1) << 255), 32, \"\
    little\")\n"
- title: 'def point_decompress(s):'
  contents:
  - "def point_decompress(s):\n    if len(s) != 32:\n        raise Exception(\"Invalid\
    \ input length for decompression\")\n    y = int.from_bytes(s, \"little\")\n \
    \   sign = y >> 255\n    y &= (1 << 255) - 1\n    x = recover_x(y, sign)\n   \
    \ if x is None:\n        return None\n    else:\n        return (x, y, 1, x*y\
    \ % p)\n"
- title: '## These are functions for manipulating the private key.'
  contents:
  - '## These are functions for manipulating the private key.

    '
- title: 'def secret_expand(secret):'
  contents:
  - "def secret_expand(secret):\n    if len(secret) != 32:\n        raise Exception(\"\
    Bad size of private key\")\n    h = sha512(secret)\n    a = int.from_bytes(h[:32],\
    \ \"little\")\n    a &= (1 << 254) - 8\n    a |= (1 << 254)\n    return (a, h[32:])\n"
- title: 'def secret_to_public(secret):'
  contents:
  - "def secret_to_public(secret):\n    (a, dummy) = secret_expand(secret)\n    return\
    \ point_compress(point_mul(a, G))\n"
- title: '## The signature function works as below.'
  contents:
  - '## The signature function works as below.

    '
- title: 'def sign(secret, msg):'
  contents:
  - "def sign(secret, msg):\n    a, prefix = secret_expand(secret)\n    A = point_compress(point_mul(a,\
    \ G))\n    r = sha512_modq(prefix + msg)\n    R = point_mul(r, G)\n    Rs = point_compress(R)\n\
    \    h = sha512_modq(Rs + A + msg)\n    s = (r + h * a) % q\n    return Rs + int.to_bytes(s,\
    \ 32, \"little\")\n"
- title: '## And finally the verification function.'
  contents:
  - '## And finally the verification function.

    '
- title: 'def verify(public, msg, signature):'
  contents:
  - "def verify(public, msg, signature):\n    if len(public) != 32:\n        raise\
    \ Exception(\"Bad public key length\")\n    if len(signature) != 64:\n       \
    \ Exception(\"Bad signature length\")\n    A = point_decompress(public)\n    if\
    \ not A:\n        return False\n    Rs = signature[:32]\n    R = point_decompress(Rs)\n\
    \    if not R:\n        return False\n    s = int.from_bytes(signature[32:], \"\
    little\")\n    if s >= q: return False\n    h = sha512_modq(Rs + public + msg)\n\
    \    sB = point_mul(s, G)\n    hA = point_mul(h, A)\n    return point_equal(sB,\
    \ point_add(R, hA))\n"
- title: 7.  Test Vectors
  contents:
  - "7.  Test Vectors\n   This section contains test vectors for Ed25519ph, Ed25519ctx,\n\
    \   Ed448ph, Ed25519, and Ed448.\n   Each section contains a sequence of test\
    \ vectors.  The octets are hex\n   encoded, and whitespace is inserted for readability.\
    \  Ed25519,\n   Ed25519ctx, and Ed25519ph private and public keys are 32 octets;\n\
    \   signatures are 64 octets.  Ed448 and Ed448ph private and public keys\n   are\
    \ 57 octets; signatures are 114 octets.  Messages are of arbitrary\n   length.\
    \  If the context is non-empty, it is given as 1-255 octets.\n"
- title: 7.1.  Test Vectors for Ed25519
  contents:
  - "7.1.  Test Vectors for Ed25519\n   These test vectors are taken from [ED25519-TEST-VECTORS]\
    \ (but we\n   removed the public key as a suffix of the private key and removed\
    \ the\n   message from the signature) and [ED25519-LIBGCRYPT-TEST-VECTORS].\n\
    \   -----TEST 1\n   ALGORITHM:\n   Ed25519\n   SECRET KEY:\n   9d61b19deffd5a60ba844af492ec2cc4\n\
    \   4449c5697b326919703bac031cae7f60\n   PUBLIC KEY:\n   d75a980182b10ab7d54bfed3c964073a\n\
    \   0ee172f3daa62325af021a68f707511a\n   MESSAGE (length 0 bytes):\n   SIGNATURE:\n\
    \   e5564300c360ac729086e2cc806e828a\n   84877f1eb8e5d974d873e06522490155\n  \
    \ 5fb8821590a33bacc61e39701cf9b46b\n   d25bf5f0595bbe24655141438e7a100b\n   -----TEST\
    \ 2\n   ALGORITHM:\n   Ed25519\n   SECRET KEY:\n   4ccd089b28ff96da9db6c346ec114e0f\n\
    \   5b8a319f35aba624da8cf6ed4fb8a6fb\n   PUBLIC KEY:\n   3d4017c3e843895a92b70aa74d1b7ebc\n\
    \   9c982ccf2ec4968cc0cd55f12af4660c\n   MESSAGE (length 1 byte):\n   72\n   SIGNATURE:\n\
    \   92a009a9f0d4cab8720e820b5f642540\n   a2b27b5416503f8fb3762223ebdb69da\n  \
    \ 085ac1e43e15996e458f3613d0f11d8c\n   387b2eaeb4302aeeb00d291612bb0c00\n   -----TEST\
    \ 3\n   ALGORITHM:\n   Ed25519\n   SECRET KEY:\n   c5aa8df43f9f837bedb7442f31dcb7b1\n\
    \   66d38535076f094b85ce3a2e0b4458f7\n   PUBLIC KEY:\n   fc51cd8e6218a1a38da47ed00230f058\n\
    \   0816ed13ba3303ac5deb911548908025\n   MESSAGE (length 2 bytes):\n   af82\n\
    \   SIGNATURE:\n   6291d657deec24024827e69c3abe01a3\n   0ce548a284743a445e3680d7db5ac3ac\n\
    \   18ff9b538d16f290ae67f760984dc659\n   4a7c15e9716ed28dc027beceea1ec40a\n  \
    \ -----TEST 1024\n   ALGORITHM:\n   Ed25519\n   SECRET KEY:\n   f5e5767cf153319517630f226876b86c\n\
    \   8160cc583bc013744c6bf255f5cc0ee5\n   PUBLIC KEY:\n   278117fc144c72340f67d0f2316e8386\n\
    \   ceffbf2b2428c9c51fef7c597f1d426e\n   MESSAGE (length 1023 bytes):\n   08b8b2b733424243760fe426a4b54908\n\
    \   632110a66c2f6591eabd3345e3e4eb98\n   fa6e264bf09efe12ee50f8f54e9f77b1\n  \
    \ e355f6c50544e23fb1433ddf73be84d8\n   79de7c0046dc4996d9e773f4bc9efe57\n   38829adb26c81b37c93a1b270b20329d\n\
    \   658675fc6ea534e0810a4432826bf58c\n   941efb65d57a338bbd2e26640f89ffbc\n  \
    \ 1a858efcb8550ee3a5e1998bd177e93a\n   7363c344fe6b199ee5d02e82d522c4fe\n   ba15452f80288a821a579116ec6dad2b\n\
    \   3b310da903401aa62100ab5d1a36553e\n   06203b33890cc9b832f79ef80560ccb9\n  \
    \ a39ce767967ed628c6ad573cb116dbef\n   efd75499da96bd68a8a97b928a8bbc10\n   3b6621fcde2beca1231d206be6cd9ec7\n\
    \   aff6f6c94fcd7204ed3455c68c83f4a4\n   1da4af2b74ef5c53f1d8ac70bdcb7ed1\n  \
    \ 85ce81bd84359d44254d95629e9855a9\n   4a7c1958d1f8ada5d0532ed8a5aa3fb2\n   d17ba70eb6248e594e1a2297acbbb39d\n\
    \   502f1a8c6eb6f1ce22b3de1a1f40cc24\n   554119a831a9aad6079cad88425de6bd\n  \
    \ e1a9187ebb6092cf67bf2b13fd65f270\n   88d78b7e883c8759d2c4f5c65adb7553\n   878ad575f9fad878e80a0c9ba63bcbcc\n\
    \   2732e69485bbc9c90bfbd62481d9089b\n   eccf80cfe2df16a2cf65bd92dd597b07\n  \
    \ 07e0917af48bbb75fed413d238f5555a\n   7a569d80c3414a8d0859dc65a46128ba\n   b27af87a71314f318c782b23ebfe808b\n\
    \   82b0ce26401d2e22f04d83d1255dc51a\n   ddd3b75a2b1ae0784504df543af8969b\n  \
    \ e3ea7082ff7fc9888c144da2af58429e\n   c96031dbcad3dad9af0dcbaaaf268cb8\n   fcffead94f3c7ca495e056a9b47acdb7\n\
    \   51fb73e666c6c655ade8297297d07ad1\n   ba5e43f1bca32301651339e22904cc8c\n  \
    \ 42f58c30c04aafdb038dda0847dd988d\n   cda6f3bfd15c4b4c4525004aa06eeff8\n   ca61783aacec57fb3d1f92b0fe2fd1a8\n\
    \   5f6724517b65e614ad6808d6f6ee34df\n   f7310fdc82aebfd904b01e1dc54b2927\n  \
    \ 094b2db68d6f903b68401adebf5a7e08\n   d78ff4ef5d63653a65040cf9bfd4aca7\n   984a74d37145986780fc0b16ac451649\n\
    \   de6188a7dbdf191f64b5fc5e2ab47b57\n   f7f7276cd419c17a3ca8e1b939ae49e4\n  \
    \ 88acba6b965610b5480109c8b17b80e1\n   b7b750dfc7598d5d5011fd2dcc5600a3\n   2ef5b52a1ecc820e308aa342721aac09\n\
    \   43bf6686b64b2579376504ccc493d97e\n   6aed3fb0f9cd71a43dd497f01f17c0e2\n  \
    \ cb3797aa2a2f256656168e6c496afc5f\n   b93246f6b1116398a346f1a641f3b041\n   e989f7914f90cc2c7fff357876e506b5\n\
    \   0d334ba77c225bc307ba537152f3f161\n   0e4eafe595f6d9d90d11faa933a15ef1\n  \
    \ 369546868a7f3a45a96768d40fd9d034\n   12c091c6315cf4fde7cb68606937380d\n   b2eaaa707b4c4185c32eddcdd306705e\n\
    \   4dc1ffc872eeee475a64dfac86aba41c\n   0618983f8741c5ef68d3a101e8a3b8ca\n  \
    \ c60c905c15fc910840b94c00a0b9d0\n   SIGNATURE:\n   0aab4c900501b3e24d7cdf4663326a3a\n\
    \   87df5e4843b2cbdb67cbf6e460fec350\n   aa5371b1508f9f4528ecea23c436d94b\n  \
    \ 5e8fcd4f681e30a6ac00a9704a188a03\n   -----TEST SHA(abc)\n   ALGORITHM:\n   Ed25519\n\
    \   SECRET KEY:\n   833fe62409237b9d62ec77587520911e\n   9a759cec1d19755b7da901b96dca3d42\n\
    \   PUBLIC KEY:\n   ec172b93ad5e563bf4932c70e1245034\n   c35467ef2efd4d64ebf819683467e2bf\n\
    \   MESSAGE (length 64 bytes):\n   ddaf35a193617abacc417349ae204131\n   12e6fa4e89a97ea20a9eeee64b55d39a\n\
    \   2192992a274fc1a836ba3c23a3feebbd\n   454d4423643ce80e2a9ac94fa54ca49f\n  \
    \ SIGNATURE:\n   dc2a4459e7369633a52b1bf277839a00\n   201009a3efbf3ecb69bea2186c26b589\n\
    \   09351fc9ac90b3ecfdfbc7c66431e030\n   3dca179c138ac17ad9bef1177331a704\n  \
    \ -----\n"
- title: 7.2.  Test Vectors for Ed25519ctx
  contents:
  - "7.2.  Test Vectors for Ed25519ctx\n   -----foo\n   ALGORITHM:\n   Ed25519ctx\n\
    \   SECRET KEY:\n   0305334e381af78f141cb666f6199f57\n   bc3495335a256a95bd2a55bf546663f6\n\
    \   PUBLIC KEY:\n   dfc9425e4f968f7f0c29f0259cf5f9ae\n   d6851c2bb4ad8bfb860cfee0ab248292\n\
    \   MESSAGE (length 16 bytes):\n   f726936d19c800494e3fdaff20b276a8\n   CONTEXT:\n\
    \   666f6f\n   SIGNATURE:\n   55a4cc2f70a54e04288c5f4cd1e45a7b\n   b520b36292911876cada7323198dd87a\n\
    \   8b36950b95130022907a7fb7c4e9b2d5\n   f6cca685a587b4b21f4b888e4e7edb0d\n  \
    \ -----bar\n   ALGORITHM:\n   Ed25519ctx\n   SECRET KEY:\n   0305334e381af78f141cb666f6199f57\n\
    \   bc3495335a256a95bd2a55bf546663f6\n   PUBLIC KEY:\n   dfc9425e4f968f7f0c29f0259cf5f9ae\n\
    \   d6851c2bb4ad8bfb860cfee0ab248292\n   MESSAGE (length 16 bytes):\n   f726936d19c800494e3fdaff20b276a8\n\
    \   CONTEXT:\n   626172\n   SIGNATURE:\n   fc60d5872fc46b3aa69f8b5b4351d580\n\
    \   8f92bcc044606db097abab6dbcb1aee3\n   216c48e8b3b66431b5b186d1d28f8ee1\n  \
    \ 5a5ca2df6668346291c2043d4eb3e90d\n   -----foo2\n   ALGORITHM:\n   Ed25519ctx\n\
    \   SECRET KEY:\n   0305334e381af78f141cb666f6199f57\n   bc3495335a256a95bd2a55bf546663f6\n\
    \   PUBLIC KEY:\n   dfc9425e4f968f7f0c29f0259cf5f9ae\n   d6851c2bb4ad8bfb860cfee0ab248292\n\
    \   MESSAGE (length 16 bytes):\n   508e9e6882b979fea900f62adceaca35\n   CONTEXT:\n\
    \   666f6f\n   SIGNATURE:\n   8b70c1cc8310e1de20ac53ce28ae6e72\n   07f33c3295e03bb5c0732a1d20dc6490\n\
    \   8922a8b052cf99b7c4fe107a5abb5b2c\n   4085ae75890d02df26269d8945f84b0b\n  \
    \ -----foo3\n   ALGORITHM:\n   Ed25519ctx\n   SECRET KEY:\n   ab9c2853ce297ddab85c993b3ae14bca\n\
    \   d39b2c682beabc27d6d4eb20711d6560\n   PUBLIC KEY:\n   0f1d1274943b91415889152e893d80e9\n\
    \   3275a1fc0b65fd71b4b0dda10ad7d772\n   MESSAGE (length 16 bytes):\n   f726936d19c800494e3fdaff20b276a8\n\
    \   CONTEXT:\n   666f6f\n   SIGNATURE:\n   21655b5f1aa965996b3f97b3c849eafb\n\
    \   a922a0a62992f73b3d1b73106a84ad85\n   e9b86a7b6005ea868337ff2d20a7f5fb\n  \
    \ d4cd10b0be49a68da2b2e0dc0ad8960f\n   -----\n"
- title: 7.3.  Test Vectors for Ed25519ph
  contents:
  - "7.3.  Test Vectors for Ed25519ph\n   -----TEST abc\n   ALGORITHM:\n   Ed25519ph\n\
    \   SECRET KEY:\n   833fe62409237b9d62ec77587520911e\n   9a759cec1d19755b7da901b96dca3d42\n\
    \   PUBLIC KEY:\n   ec172b93ad5e563bf4932c70e1245034\n   c35467ef2efd4d64ebf819683467e2bf\n\
    \   MESSAGE (length 3 bytes):\n   616263\n   SIGNATURE:\n   98a70222f0b8121aa9d30f813d683f80\n\
    \   9e462b469c7ff87639499bb94e6dae41\n   31f85042463c2a355a2003d062adf5aa\n  \
    \ a10b8c61e636062aaad11c2a26083406\n   -----\n"
- title: 7.4.  Test Vectors for Ed448
  contents:
  - "7.4.  Test Vectors for Ed448\n   -----Blank\n   ALGORITHM:\n   Ed448\n   SECRET\
    \ KEY:\n   6c82a562cb808d10d632be89c8513ebf\n   6c929f34ddfa8c9f63c9960ef6e348a3\n\
    \   528c8a3fcc2f044e39a3fc5b94492f8f\n   032e7549a20098f95b\n   PUBLIC KEY:\n\
    \   5fd7449b59b461fd2ce787ec616ad46a\n   1da1342485a70e1f8a0ea75d80e96778\n  \
    \ edf124769b46c7061bd6783df1e50f6c\n   d1fa1abeafe8256180\n   MESSAGE (length\
    \ 0 bytes):\n   SIGNATURE:\n   533a37f6bbe457251f023c0d88f976ae\n   2dfb504a843e34d2074fd823d41a591f\n\
    \   2b233f034f628281f2fd7a22ddd47d78\n   28c59bd0a21bfd3980ff0d2028d4b18a\n  \
    \ 9df63e006c5d1c2d345b925d8dc00b41\n   04852db99ac5c7cdda8530a113a0f4db\n   b61149f05a7363268c71d95808ff2e65\n\
    \   2600\n   -----1 octet\n   ALGORITHM:\n   Ed448\n   SECRET KEY:\n   c4eab05d357007c632f3dbb48489924d\n\
    \   552b08fe0c353a0d4a1f00acda2c463a\n   fbea67c5e8d2877c5e3bc397a659949e\n  \
    \ f8021e954e0a12274e\n   PUBLIC KEY:\n   43ba28f430cdff456ae531545f7ecd0a\n  \
    \ c834a55d9358c0372bfa0c6c6798c086\n   6aea01eb00742802b8438ea4cb82169c\n   235160627b4c3a9480\n\
    \   MESSAGE (length 1 byte):\n   03\n   SIGNATURE:\n   26b8f91727bd62897af15e41eb43c377\n\
    \   efb9c610d48f2335cb0bd0087810f435\n   2541b143c4b981b7e18f62de8ccdf633\n  \
    \ fc1bf037ab7cd779805e0dbcc0aae1cb\n   cee1afb2e027df36bc04dcecbf154336\n   c19f0af7e0a6472905e799f1953d2a0f\n\
    \   f3348ab21aa4adafd1d234441cf807c0\n   3a00\n   -----1 octet (with context)\n\
    \   ALGORITHM:\n   Ed448\n   SECRET KEY:\n   c4eab05d357007c632f3dbb48489924d\n\
    \   552b08fe0c353a0d4a1f00acda2c463a\n   fbea67c5e8d2877c5e3bc397a659949e\n  \
    \ f8021e954e0a12274e\n   PUBLIC KEY:\n   43ba28f430cdff456ae531545f7ecd0a\n  \
    \ c834a55d9358c0372bfa0c6c6798c086\n   6aea01eb00742802b8438ea4cb82169c\n   235160627b4c3a9480\n\
    \   MESSAGE (length 1 byte):\n   03\n   CONTEXT:\n   666f6f\n   SIGNATURE:\n \
    \  d4f8f6131770dd46f40867d6fd5d5055\n   de43541f8c5e35abbcd001b32a89f7d2\n   151f7647f11d8ca2ae279fb842d60721\n\
    \   7fce6e042f6815ea000c85741de5c8da\n   1144a6a1aba7f96de42505d7a7298524\n  \
    \ fda538fccbbb754f578c1cad10d54d0d\n   5428407e85dcbc98a49155c13764e66c\n   3c00\n\
    \   -----11 octets\n   ALGORITHM:\n   Ed448\n   SECRET KEY:\n   cd23d24f714274e744343237b93290f5\n\
    \   11f6425f98e64459ff203e8985083ffd\n   f60500553abc0e05cd02184bdb89c4cc\n  \
    \ d67e187951267eb328\n   PUBLIC KEY:\n   dcea9e78f35a1bf3499a831b10b86c90\n  \
    \ aac01cd84b67a0109b55a36e9328b1e3\n   65fce161d71ce7131a543ea4cb5f7e9f\n   1d8b00696447001400\n\
    \   MESSAGE (length 11 bytes):\n   0c3e544074ec63b0265e0c\n   SIGNATURE:\n   1f0a8888ce25e8d458a21130879b840a\n\
    \   9089d999aaba039eaf3e3afa090a09d3\n   89dba82c4ff2ae8ac5cdfb7c55e94d5d\n  \
    \ 961a29fe0109941e00b8dbdeea6d3b05\n   1068df7254c0cdc129cbe62db2dc957d\n   bb47b51fd3f213fb8698f064774250a5\n\
    \   028961c9bf8ffd973fe5d5c206492b14\n   0e00\n   -----12 octets\n   ALGORITHM:\n\
    \   Ed448\n   SECRET KEY:\n   258cdd4ada32ed9c9ff54e63756ae582\n   fb8fab2ac721f2c8e676a72768513d93\n\
    \   9f63dddb55609133f29adf86ec9929dc\n   cb52c1c5fd2ff7e21b\n   PUBLIC KEY:\n\
    \   3ba16da0c6f2cc1f30187740756f5e79\n   8d6bc5fc015d7c63cc9510ee3fd44adc\n  \
    \ 24d8e968b6e46e6f94d19b945361726b\n   d75e149ef09817f580\n   MESSAGE (length\
    \ 12 bytes):\n   64a65f3cdedcdd66811e2915\n   SIGNATURE:\n   7eeeab7c4e50fb799b418ee5e3197ff6\n\
    \   bf15d43a14c34389b59dd1a7b1b85b4a\n   e90438aca634bea45e3a2695f1270f07\n  \
    \ fdcdf7c62b8efeaf00b45c2c96ba457e\n   b1a8bf075a3db28e5c24f6b923ed4ad7\n   47c3c9e03c7079efb87cb110d3a99861\n\
    \   e72003cbae6d6b8b827e4e6c143064ff\n   3c00\n   -----13 octets\n   ALGORITHM:\n\
    \   Ed448\n   SECRET KEY:\n   7ef4e84544236752fbb56b8f31a23a10\n   e42814f5f55ca037cdcc11c64c9a3b29\n\
    \   49c1bb60700314611732a6c2fea98eeb\n   c0266a11a93970100e\n   PUBLIC KEY:\n\
    \   b3da079b0aa493a5772029f0467baebe\n   e5a8112d9d3a22532361da294f7bb381\n  \
    \ 5c5dc59e176b4d9f381ca0938e13c6c0\n   7b174be65dfa578e80\n   MESSAGE (length\
    \ 13 bytes):\n   64a65f3cdedcdd66811e2915e7\n   SIGNATURE:\n   6a12066f55331b6c22acd5d5bfc5d712\n\
    \   28fbda80ae8dec26bdd306743c5027cb\n   4890810c162c027468675ecf645a8317\n  \
    \ 6c0d7323a2ccde2d80efe5a1268e8aca\n   1d6fbc194d3f77c44986eb4ab4177919\n   ad8bec33eb47bbb5fc6e28196fd1caf5\n\
    \   6b4e7e0ba5519234d047155ac727a105\n   3100\n   -----64 octets\n   ALGORITHM:\n\
    \   Ed448\n   SECRET KEY:\n   d65df341ad13e008567688baedda8e9d\n   cdc17dc024974ea5b4227b6530e339bf\n\
    \   f21f99e68ca6968f3cca6dfe0fb9f4fa\n   b4fa135d5542ea3f01\n   PUBLIC KEY:\n\
    \   df9705f58edbab802c7f8363cfe5560a\n   b1c6132c20a9f1dd163483a26f8ac53a\n  \
    \ 39d6808bf4a1dfbd261b099bb03b3fb5\n   0906cb28bd8a081f00\n   MESSAGE (length\
    \ 64 bytes):\n   bd0f6a3747cd561bdddf4640a332461a\n   4a30a12a434cd0bf40d766d9c6d458e5\n\
    \   512204a30c17d1f50b5079631f64eb31\n   12182da3005835461113718d1a5ef944\n  \
    \ SIGNATURE:\n   554bc2480860b49eab8532d2a533b7d5\n   78ef473eeb58c98bb2d0e1ce488a98b1\n\
    \   8dfde9b9b90775e67f47d4a1c3482058\n   efc9f40d2ca033a0801b63d45b3b722e\n  \
    \ f552bad3b4ccb667da350192b61c508c\n   f7b6b5adadc2c8d9a446ef003fb05cba\n   5f30e88e36ec2703b349ca229c267083\n\
    \   3900\n   -----256 octets\n   ALGORITHM:\n   Ed448\n   SECRET KEY:\n   2ec5fe3c17045abdb136a5e6a913e32a\n\
    \   b75ae68b53d2fc149b77e504132d3756\n   9b7e766ba74a19bd6162343a21c8590a\n  \
    \ a9cebca9014c636df5\n   PUBLIC KEY:\n   79756f014dcfe2079f5dd9e718be4171\n  \
    \ e2ef2486a08f25186f6bff43a9936b9b\n   fe12402b08ae65798a3d81e22e9ec80e\n   7690862ef3d4ed3a00\n\
    \   MESSAGE (length 256 bytes):\n   15777532b0bdd0d1389f636c5f6b9ba7\n   34c90af572877e2d272dd078aa1e567c\n\
    \   fa80e12928bb542330e8409f31745041\n   07ecd5efac61ae7504dabe2a602ede89\n  \
    \ e5cca6257a7c77e27a702b3ae39fc769\n   fc54f2395ae6a1178cab4738e543072f\n   c1c177fe71e92e25bf03e4ecb72f47b6\n\
    \   4d0465aaea4c7fad372536c8ba516a60\n   39c3c2a39f0e4d832be432dfa9a706a6\n  \
    \ e5c7e19f397964ca4258002f7c0541b5\n   90316dbc5622b6b2a6fe7a4abffd9610\n   5eca76ea7b98816af0748c10df048ce0\n\
    \   12d901015a51f189f3888145c03650aa\n   23ce894c3bd889e030d565071c59f409\n  \
    \ a9981b51878fd6fc110624dcbcde0bf7\n   a69ccce38fabdf86f3bef6044819de11\n   SIGNATURE:\n\
    \   c650ddbb0601c19ca11439e1640dd931\n   f43c518ea5bea70d3dcde5f4191fe53f\n  \
    \ 00cf966546b72bcc7d58be2b9badef28\n   743954e3a44a23f880e8d4f1cfce2d7a\n   61452d26da05896f0a50da66a239a8a1\n\
    \   88b6d825b3305ad77b73fbac0836ecc6\n   0987fd08527c1a8e80d5823e65cafe2a\n  \
    \ 3d00\n   -----1023 octets\n   ALGORITHM:\n   Ed448\n   SECRET KEY:\n   872d093780f5d3730df7c212664b37b8\n\
    \   a0f24f56810daa8382cd4fa3f77634ec\n   44dc54f1c2ed9bea86fafb7632d8be19\n  \
    \ 9ea165f5ad55dd9ce8\n   PUBLIC KEY:\n   a81b2e8a70a5ac94ffdbcc9badfc3feb\n  \
    \ 0801f258578bb114ad44ece1ec0e799d\n   a08effb81c5d685c0c56f64eecaef8cd\n   f11cc38737838cf400\n\
    \   MESSAGE (length 1023 bytes):\n   6ddf802e1aae4986935f7f981ba3f035\n   1d6273c0a0c22c9c0e8339168e675412\n\
    \   a3debfaf435ed651558007db4384b650\n   fcc07e3b586a27a4f7a00ac8a6fec2cd\n  \
    \ 86ae4bf1570c41e6a40c931db27b2faa\n   15a8cedd52cff7362c4e6e23daec0fbc\n   3a79b6806e316efcc7b68119bf46bc76\n\
    \   a26067a53f296dafdbdc11c77f7777e9\n   72660cf4b6a9b369a6665f02e0cc9b6e\n  \
    \ dfad136b4fabe723d2813db3136cfde9\n   b6d044322fee2947952e031b73ab5c60\n   3349b307bdc27bc6cb8b8bbd7bd32321\n\
    \   9b8033a581b59eadebb09b3c4f3d2277\n   d4f0343624acc817804728b25ab79717\n  \
    \ 2b4c5c21a22f9c7839d64300232eb66e\n   53f31c723fa37fe387c7d3e50bdf9813\n   a30e5bb12cf4cd930c40cfb4e1fc6225\n\
    \   92a49588794494d56d24ea4b40c89fc0\n   596cc9ebb961c8cb10adde976a5d602b\n  \
    \ 1c3f85b9b9a001ed3c6a4d3b1437f520\n   96cd1956d042a597d561a596ecd3d173\n   5a8d570ea0ec27225a2c4aaff26306d1\n\
    \   526c1af3ca6d9cf5a2c98f47e1c46db9\n   a33234cfd4d81f2c98538a09ebe76998\n  \
    \ d0d8fd25997c7d255c6d66ece6fa56f1\n   1144950f027795e653008f4bd7ca2dee\n   85d8e90f3dc315130ce2a00375a318c7\n\
    \   c3d97be2c8ce5b6db41a6254ff264fa6\n   155baee3b0773c0f497c573f19bb4f42\n  \
    \ 40281f0b1f4f7be857a4e59d416c06b4\n   c50fa09e1810ddc6b1467baeac5a3668\n   d11b6ecaa901440016f389f80acc4db9\n\
    \   77025e7f5924388c7e340a732e554440\n   e76570f8dd71b7d640b3450d1fd5f041\n  \
    \ 0a18f9a3494f707c717b79b4bf75c984\n   00b096b21653b5d217cf3565c9597456\n   f70703497a078763829bc01bb1cbc8fa\n\
    \   04eadc9a6e3f6699587a9e75c94e5bab\n   0036e0b2e711392cff0047d0d6b05bd2\n  \
    \ a588bc109718954259f1d86678a579a3\n   120f19cfb2963f177aeb70f2d4844826\n   262e51b80271272068ef5b3856fa8535\n\
    \   aa2a88b2d41f2a0e2fda7624c2850272\n   ac4a2f561f8f2f7a318bfd5caf969614\n  \
    \ 9e4ac824ad3460538fdc25421beec2cc\n   6818162d06bbed0c40a387192349db67\n   a118bada6cd5ab0140ee273204f628aa\n\
    \   d1c135f770279a651e24d8c14d75a605\n   9d76b96a6fd857def5e0b354b27ab937\n  \
    \ a5815d16b5fae407ff18222c6d1ed263\n   be68c95f32d908bd895cd76207ae7264\n   87567f9a67dad79abec316f683b17f2d\n\
    \   02bf07e0ac8b5bc6162cf94697b3c27c\n   d1fea49b27f23ba2901871962506520c\n  \
    \ 392da8b6ad0d99f7013fbc06c2c17a56\n   9500c8a7696481c1cd33e9b14e40b82e\n   79a5f5db82571ba97bae3ad3e0479515\n\
    \   bb0e2b0f3bfcd1fd33034efc6245eddd\n   7ee2086ddae2600d8ca73e214e8c2b0b\n  \
    \ db2b047c6a464a562ed77b73d2d841c4\n   b34973551257713b753632efba348169\n   abc90a68f42611a40126d7cb21b58695\n\
    \   568186f7e569d2ff0f9e745d0487dd2e\n   b997cafc5abf9dd102e62ff66cba87\n   SIGNATURE:\n\
    \   e301345a41a39a4d72fff8df69c98075\n   a0cc082b802fc9b2b6bc503f926b65bd\n  \
    \ df7f4c8f1cb49f6396afc8a70abe6d8a\n   ef0db478d4c6b2970076c6a0484fe76d\n   76b3a97625d79f1ce240e7c576750d29\n\
    \   5528286f719b413de9ada3e8eb78ed57\n   3603ce30d8bb761785dc30dbc320869e\n  \
    \ 1a00\n   -----\n"
- title: 7.5.  Test Vectors for Ed448ph
  contents:
  - "7.5.  Test Vectors for Ed448ph\n   -----TEST abc\n   ALGORITHM:\n   Ed448ph\n\
    \   SECRET KEY:\n   833fe62409237b9d62ec77587520911e\n   9a759cec1d19755b7da901b96dca3d42\n\
    \   ef7822e0d5104127dc05d6dbefde69e3\n   ab2cec7c867c6e2c49\n   PUBLIC KEY:\n\
    \   259b71c19f83ef77a7abd26524cbdb31\n   61b590a48f7d17de3ee0ba9c52beb743\n  \
    \ c09428a131d6b1b57303d90d8132c276\n   d5ed3d5d01c0f53880\n   MESSAGE (length\
    \ 3 bytes):\n   616263\n   SIGNATURE:\n   822f6901f7480f3d5f562c592994d969\n \
    \  3602875614483256505600bbc281ae38\n   1f54d6bce2ea911574932f52a4e6cadd\n   78769375ec3ffd1b801a0d9b3f4030cd\n\
    \   433964b6457ea39476511214f97469b5\n   7dd32dbc560a9a94d00bff07620464a3\n  \
    \ ad203df7dc7ce360c3cd3696d9d9fab9\n   0f00\n   -----TEST abc (with context)\n\
    \   ALGORITHM:\n   Ed448ph\n   SECRET KEY:\n   833fe62409237b9d62ec77587520911e\n\
    \   9a759cec1d19755b7da901b96dca3d42\n   ef7822e0d5104127dc05d6dbefde69e3\n  \
    \ ab2cec7c867c6e2c49\n   PUBLIC KEY:\n   259b71c19f83ef77a7abd26524cbdb31\n  \
    \ 61b590a48f7d17de3ee0ba9c52beb743\n   c09428a131d6b1b57303d90d8132c276\n   d5ed3d5d01c0f53880\n\
    \   MESSAGE (length 3 bytes):\n   616263\n   CONTEXT:\n   666f6f\n   SIGNATURE:\n\
    \   c32299d46ec8ff02b54540982814dce9\n   a05812f81962b649d528095916a2aa48\n  \
    \ 1065b1580423ef927ecf0af5888f90da\n   0f6a9a85ad5dc3f280d91224ba9911a3\n   653d00e484e2ce232521481c8658df30\n\
    \   4bb7745a73514cdb9bf3e15784ab7128\n   4f8d0704a608c54a6b62d97beb511d13\n  \
    \ 2100\n   -----\n"
- title: 8.  Security Considerations
  contents:
  - '8.  Security Considerations

    '
- title: 8.1.  Side-Channel Leaks
  contents:
  - "8.1.  Side-Channel Leaks\n   For implementations performing signatures, secrecy\
    \ of the private key\n   is fundamental.  It is possible to protect against some\
    \ side-channel\n   attacks by ensuring that the implementation executes exactly\
    \ the same\n   sequence of instructions and performs exactly the same memory\n\
    \   accesses, for any value of the private key.\n   To make an implementation\
    \ side-channel silent in this way, the modulo\n   p arithmetic must not use any\
    \ data-dependent branches, e.g., related\n   to carry propagation.  Side-channel\
    \ silent point addition is\n   straightforward, thanks to the unified formulas.\n\
    \   Scalar multiplication, multiplying a point by an integer, needs some\n   additional\
    \ effort to implement in a side-channel silent manner.  One\n   simple approach\
    \ is to implement a side-channel silent conditional\n   assignment, and use it\
    \ together with the binary algorithm to examine\n   one bit of the integer at\
    \ a time.\n   Compared to other signature schemes, avoiding data-dependent branches\n\
    \   is easier due to side-channel silent modulo p arithmetic being easier\n  \
    \ (with recommended curves) and having complete addition formulas\n   instead\
    \ of having a number of special cases.\n   Note that the example implementations\
    \ in this document do not attempt\n   to be side-channel silent.\n"
- title: 8.2.  Randomness Considerations
  contents:
  - "8.2.  Randomness Considerations\n   EdDSA signatures are deterministic.  This\
    \ protects against attacks\n   arising from signing with bad randomness; the effects\
    \ of which can,\n   depending on the algorithm, range up to full private key compromise.\n\
    \   It can be surprisingly hard to ensure good-quality random numbers,\n   and\
    \ there have been numerous security failures relating to this.\n   Obviously,\
    \ private key generation requires randomness, but due to the\n   fact that the\
    \ private key is hashed before use, a few missing bits of\n   entropy doesn't\
    \ constitute a disaster.\n   The basic signature verification is also deterministic.\
    \  However,\n   some speedups by verifying multiple signatures at once do require\n\
    \   random numbers.\n"
- title: 8.3.  Use of Contexts
  contents:
  - "8.3.  Use of Contexts\n   Contexts can be used to separate uses of the protocol\
    \ between\n   different protocols (which is very hard to reliably do otherwise)\
    \ and\n   between different uses within the same protocol.  However, the\n   following\
    \ SHOULD be kept in mind when using this facility:\n      The context SHOULD be\
    \ a constant string specified by the protocol\n      using it.  It SHOULD NOT\
    \ incorporate variable elements from the\n      message itself.\n      Contexts\
    \ SHOULD NOT be used opportunistically, as that kind of use\n      is very error\
    \ prone.  If contexts are used, one SHOULD require all\n      signature schemes\
    \ available for use in that purpose support\n      contexts.\n      Contexts are\
    \ an extra input, which percolate out of APIs; as such,\n      even if the signature\
    \ scheme supports contexts, those may not be\n      available for use.  This problem\
    \ is compounded by the fact that\n      many times the application is not invoking\
    \ the signing and\n      verification functions directly but via some other protocol.\n"
- title: 8.4.  Signature Malleability
  contents:
  - "8.4.  Signature Malleability\n   Some systems assume signatures are not malleable:\
    \ that is, given a\n   valid signature for some message under some key, the attacker\
    \ can't\n   produce another valid signature for the same message and key.\n  \
    \ Ed25519 and Ed448 signatures are not malleable due to the\n   verification check\
    \ that decoded S is smaller than l.  Without this\n   check, one can add a multiple\
    \ of l into a scalar part and still pass\n   signature verification, resulting\
    \ in malleable signatures.\n"
- title: 8.5.  Choice of Signature Primitive
  contents:
  - "8.5.  Choice of Signature Primitive\n   Ed25519 and Ed25519ph have a nominal\
    \ strength of 128 bits, whereas\n   Ed448 and Ed448ph have the strength of 224.\
    \  While the lower strength\n   is sufficient for the foreseeable future, the\
    \ higher level brings\n   some defense against possible future cryptographic advances.\
    \  Both\n   are demolished by quantum computers just about the same.\n   The Ed25519ph\
    \ and Ed448ph variants are prehashed.  This is mainly\n   useful for interoperation\
    \ with legacy APIs, since in most of the\n   cases, either the amount of data\
    \ signed is not large or the protocol\n   is in the position to do digesting in\
    \ ways better than just\n   prehashing (e.g., tree hashing or splitting the data).\
    \  The\n   prehashing also makes the functions greatly more vulnerable to\n  \
    \ weaknesses in hash functions used.  These variants SHOULD NOT be\n   used.\n\
    \   Ed25519ctx and Ed448 have contexts.  However, this is balanced by the\n  \
    \ problems noted in Section 8.3 about contexts.\n   On the implementation front,\
    \ Ed25519 is widely implemented and has\n   many high-quality implementations.\
    \  The others have much worse\n   support.\n   In summary, if a high 128-bit security\
    \ level is enough, use of\n   Ed25519 is RECOMMENDED; otherwise, Ed448 is RECOMMENDED.\n"
- title: 8.6.  Mixing Different Prehashes
  contents:
  - "8.6.  Mixing Different Prehashes\n   The schemes described in this document are\
    \ designed to be resistant\n   to mixing prehashes.  That is, it is infeasible\
    \ to find a message\n   that verifies using the same signature under another scheme,\
    \ even if\n   the original signed message was chosen.  Thus, one can use the same\n\
    \   key pair for Ed25519, Ed25519ctx, and Ed25519ph and correspondingly\n   with\
    \ Ed448 and Ed448ph.\n   The \"SigEd25519 no Ed25519 collisions\" constant is\
    \ chosen to be a\n   textual string such that it does not decode as a point. \
    \ Because the\n   inner hash input in the Ed25519 signature always starts with\
    \ a valid\n   point, there is no way trivial collision can be constructed.  In\
    \ the\n   case of seed hash, trivial collisions are so unlikely, even with an\n\
    \   attacker choosing all inputs, that it is much more probable that\n   something\
    \ else goes catastrophically wrong.\n"
- title: 8.7.  Signing Large Amounts of Data at Once
  contents:
  - "8.7.  Signing Large Amounts of Data at Once\n   Avoid signing large amounts of\
    \ data at once (where \"large\" depends on\n   the expected verifier).  In particular,\
    \ unless the underlying\n   protocol does not require it, the receiver MUST buffer\
    \ the entire\n   message (or enough information to reconstruct it, e.g., compressed\
    \ or\n   encrypted version) to be verified.\n   This is needed because most of\
    \ the time, it is unsafe to process\n   unverified data, and verifying the signature\
    \ makes a pass through the\n   whole message, causing ultimately at least two\
    \ passes through.\n   As an API consideration, this means that any Initialize\
    \ Update\n   Finalize (IFU) verification interface is prone to misuse.\n   It\
    \ is a bad idea to modify Ed25519 or Ed448 signing to be able to\n   create valid\
    \ Ed25519/Ed448 signatures using an IUF interface with\n   only constant buffering.\
    \  Pretty much any error in such would cause\n   catastrophic security failure.\n"
- title: 8.8.  Multiplication by Cofactor in Verification
  contents:
  - "8.8.  Multiplication by Cofactor in Verification\n   The given verification formulas\
    \ for both Ed25519 and Ed448 multiply\n   points by the cofactor.  While this\
    \ is not strictly necessary for\n   security (in fact, any signature that meets\
    \ the non-multiplied\n   equation will satisfy the multiplied one), in some applications\
    \ it is\n   undesirable for implementations to disagree about the exact set of\n\
    \   valid signatures.  Such disagreements could open up, e.g.,\n   fingerprinting\
    \ attacks.\n"
- title: 8.9.  Use of SHAKE256 as a Hash Function
  contents:
  - "8.9.  Use of SHAKE256 as a Hash Function\n   Ed448 uses SHAKE256 as a hash function,\
    \ even if SHAKE256 is\n   specifically defined not to be a hash function.\n  \
    \ The first potentially troublesome property is that shorter outputs\n   are prefixes\
    \ of longer ones.  This is acceptable because output\n   lengths are fixed.\n\
    \   The second potentially troublesome property is failing to meet\n   standard\
    \ hash security notions (especially with preimages).  However,\n   the estimated\
    \ 256-bit security level against collisions and preimages\n   is sufficient to\
    \ pair with a 224-bit level elliptic curve.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [FIPS202]  National Institute of Standards and\
    \ Technology, \"SHA-3\n              Standard: Permutation-Based Hash and Extendable-Output\n\
    \              Functions\", FIPS PUB 202, August 2015,\n              <http://dx.doi.org/10.6028/NIST.FIPS.202>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, DOI\n              10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC6234]\
    \  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n             \
    \ (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI 10.17487/RFC6234,\
    \ May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n   [RFC7748]\
    \  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n              for\
    \ Security\", RFC 7748, DOI 10.17487/RFC7748, January\n              2016, <http://www.rfc-editor.org/info/rfc7748>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [CURVE25519]\n              Bernstein, D., \"\
    Curve25519: new Diffie-Hellman speed\n              records\", DOI 10.1007/11745853_14,\
    \ February 2006,\n              <http://cr.yp.to/ecdh.html>.\n   [ED25519-LIBGCRYPT-TEST-VECTORS]\n\
    \              Koch, W., \"Ed25519 Libgcrypt test vectors\", July 2014,\n    \
    \          <http://git.gnupg.org/cgi-bin/\n              gitweb.cgi?p=libgcrypt.git;a=blob;f=tests/t-ed25519.inp;\n\
    \              h=e13566f826321eece65e02c593bc7d885b3dbe23;hb=refs/\n         \
    \     heads/master>.\n   [ED25519-TEST-VECTORS]\n              Bernstein, D.,\
    \ Duif, N., Lange, T., Schwabe, P., and B.\n              Yang, \"Ed25519 test\
    \ vectors\", July 2011,\n              <http://ed25519.cr.yp.to/python/sign.input>.\n\
    \   [ED448]    Hamburg, M., \"Ed448-Goldilocks, a new elliptic curve\",\n    \
    \          June 2015, <http://eprint.iacr.org/2015/625>.\n   [EDDSA]    Bernstein,\
    \ D., Duif, N., Lange, T., Schwabe, P., and B.\n              Yang, \"High-speed\
    \ high-security signatures\",\n              DOI 10.1007/978-3-642-23951-9_9,\
    \ September 2011,\n              <http://ed25519.cr.yp.to/ed25519-20110926.pdf>.\n\
    \   [EDDSA2]   Bernstein, D., Josefsson, S., Lange, T., Schwabe, P., and\n   \
    \           B. Yang, \"EdDSA for more curves\", July 2015,\n              <http://ed25519.cr.yp.to/eddsa-20150704.pdf>.\n\
    \   [Edwards-revisited]\n              Hisil, H., Wong, K., Carter, G., and E.\
    \ Dawson, \"Twisted\n              Edwards Curves Revisited\",\n             \
    \ DOI 10.1007/978-3-540-89255-7_20, December 2008,\n              <http://eprint.iacr.org/2008/522>.\n\
    \   [EFD-ADD]  Bernstein, D. and T. Lange, \"Projective coordinates for\n    \
    \          Edwards curves\", The 'add-2007-bl' addition formulas,\n          \
    \    2007, <http://www.hyperelliptic.org/EFD/g1p/\n              auto-edwards-projective.html#addition-add-2007-bl>.\n\
    \   [EFD-DBL]  Bernstein, D. and T. Lange, \"Projective coordinates for\n    \
    \          Edwards curves\", The 'dbl-2007-bl' doubling formulas,\n          \
    \    2007, <http://www.hyperelliptic.org/EFD/g1p/\n              auto-edwards-projective.html#doubling-dbl-2007-bl>.\n\
    \   [EFD-TWISTED-ADD]\n              Hisil, H., Wong, K., Carter, G., and E. Dawson,\
    \ \"Extended\n              coordinates with a=-1 for twisted Edwards curves\"\
    , The\n              'add-2008-hwcd-3' addition formulas, December 2008,\n   \
    \           <http://www.hyperelliptic.org/EFD/g1p/\n              auto-twisted-extended-1.html#addition-add-2008-hwcd-3>.\n\
    \   [EFD-TWISTED-DBL]\n              Hisil, H., Wong, K., Carter, G., and E. Dawson,\
    \ \"Extended\n              coordinates with a=-1 for twisted Edwards curves\"\
    , The\n              'dbl-2008-hwcd' doubling formulas, December 2008,\n     \
    \         <http://www.hyperelliptic.org/EFD/g1p/\n              auto-twisted-extended-1.html#doubling-dbl-2008-hwcd>.\n\
    \   [Faster-ECC]\n              Bernstein, D. and T. Lange, \"Faster addition\
    \ and doubling\n              on elliptic curves\", DOI 10.1007/978-3-540-76900-2_3,\n\
    \              July 2007, <http://eprint.iacr.org/2007/286>.\n   [RFC4086]  Eastlake\
    \ 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness Requirements\
    \ for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086, June\
    \ 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n"
- title: Appendix A.  Ed25519/Ed448 Python Library
  contents:
  - "Appendix A.  Ed25519/Ed448 Python Library\n   Below is an example implementation\
    \ of Ed25519/Ed448 written in\n   Python; version 3.2 or higher is required.\n\
    \   Note: This code is not intended for production.  Although it should\n   produce\
    \ correct results for every input, it is slow and makes no\n   attempt to avoid\
    \ side-channel attacks.\n"
- title: import hashlib;
  contents:
  - 'import hashlib;

    '
- title: import os;
  contents:
  - 'import os;

    '
- title: '#Compute candidate square root of x modulo p, with p = 3 (mod 4).'
  contents:
  - '#Compute candidate square root of x modulo p, with p = 3 (mod 4).

    '
- title: 'def sqrt4k3(x,p): return pow(x,(p + 1)//4,p)'
  contents:
  - 'def sqrt4k3(x,p): return pow(x,(p + 1)//4,p)

    '
- title: '#Compute candidate square root of x modulo p, with p = 5 (mod 8).'
  contents:
  - '#Compute candidate square root of x modulo p, with p = 5 (mod 8).

    '
- title: 'def sqrt8k5(x,p):'
  contents:
  - "def sqrt8k5(x,p):\n    y = pow(x,(p+3)//8,p)\n    #If the square root exists,\
    \ it is either y or y*2^(p-1)/4.\n    if (y * y) % p == x % p: return y\n    else:\n\
    \        z = pow(2,(p - 1)//4,p)\n        return (y * z) % p\n"
- title: '#Decode a hexadecimal string representation of the integer.'
  contents:
  - '#Decode a hexadecimal string representation of the integer.

    '
- title: 'def hexi(s): return int.from_bytes(bytes.fromhex(s),byteorder="big")'
  contents:
  - 'def hexi(s): return int.from_bytes(bytes.fromhex(s),byteorder="big")

    '
- title: '#Rotate a word x by b places to the left.'
  contents:
  - '#Rotate a word x by b places to the left.

    '
- title: 'def rol(x,b): return ((x << b) | (x >> (64 - b))) & (2**64-1)'
  contents:
  - 'def rol(x,b): return ((x << b) | (x >> (64 - b))) & (2**64-1)

    '
- title: '#From little endian.'
  contents:
  - '#From little endian.

    '
- title: 'def from_le(s): return int.from_bytes(s, byteorder="little")'
  contents:
  - 'def from_le(s): return int.from_bytes(s, byteorder="little")

    '
- title: '#Do the SHA-3 state transform on state s.'
  contents:
  - '#Do the SHA-3 state transform on state s.

    '
- title: 'def sha3_transform(s):'
  contents:
  - "def sha3_transform(s):\n    ROTATIONS = [0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,\\\
    \n                 21,8,18,2,61,56,14]\n    PERMUTATION = [1,6,9,22,14,20,2,12,13,19,23,15,4,24,21,8,16,5,3,\\\
    \n                   18,17,11,7,10]\n    RC = [0x0000000000000001,0x0000000000008082,0x800000000000808a,\\\
    \n          0x8000000080008000,0x000000000000808b,0x0000000080000001,\\\n    \
    \      0x8000000080008081,0x8000000000008009,0x000000000000008a,\\\n         \
    \ 0x0000000000000088,0x0000000080008009,0x000000008000000a,\\\n          0x000000008000808b,0x800000000000008b,0x8000000000008089,\\\
    \n          0x8000000000008003,0x8000000000008002,0x8000000000000080,\\\n    \
    \      0x000000000000800a,0x800000008000000a,0x8000000080008081,\\\n         \
    \ 0x8000000000008080,0x0000000080000001,0x8000000080008008]\n    for rnd in range(0,24):\n\
    \        #AddColumnParity (Theta)\n        c = [0]*5;\n        d = [0]*5;\n  \
    \      for i in range(0,25): c[i%5]^=s[i]\n        for i in range(0,5): d[i]=c[(i+4)%5]^rol(c[(i+1)%5],1)\n\
    \        for i in range(0,25): s[i]^=d[i%5]\n        #RotateWords (Rho)\n    \
    \    for i in range(0,25): s[i]=rol(s[i],ROTATIONS[i])\n        #PermuteWords\
    \ (Pi)\n        t = s[PERMUTATION[0]]\n        for i in range(0,len(PERMUTATION)-1):\n\
    \            s[PERMUTATION[i]]=s[PERMUTATION[i+1]]\n        s[PERMUTATION[-1]]=t;\n\
    \        #NonlinearMixRows (Chi)\n        for i in range(0,25,5):\n          \
    \  t=[s[i],s[i+1],s[i+2],s[i+3],s[i+4],s[i],s[i+1]]\n            for j in range(0,5):\
    \ s[i+j]=t[j]^((~t[j+1])&(t[j+2]))\n        #AddRoundConstant (Iota)\n       \
    \ s[0]^=RC[rnd]\n"
- title: '#Reinterpret octet array b to word array and XOR it to state s.'
  contents:
  - '#Reinterpret octet array b to word array and XOR it to state s.

    '
- title: 'def reinterpret_to_words_and_xor(s,b):'
  contents:
  - "def reinterpret_to_words_and_xor(s,b):\n    for j in range(0,len(b)//8):\n  \
    \      s[j]^=from_le(b[8*j:][:8])\n"
- title: '#Reinterpret word array w to octet array and return it.'
  contents:
  - '#Reinterpret word array w to octet array and return it.

    '
- title: 'def reinterpret_to_octets(w):'
  contents:
  - "def reinterpret_to_octets(w):\n    mp=bytearray()\n    for j in range(0,len(w)):\n\
    \        mp+=w[j].to_bytes(8,byteorder=\"little\")\n    return mp\n"
- title: '#(semi-)generic SHA-3 implementation'
  contents:
  - '#(semi-)generic SHA-3 implementation

    '
- title: 'def sha3_raw(msg,r_w,o_p,e_b):'
  contents:
  - "def sha3_raw(msg,r_w,o_p,e_b):\n    r_b=8*r_w\n    s=[0]*25\n    #Handle whole\
    \ blocks.\n    idx=0\n    blocks=len(msg)//r_b\n    for i in range(0,blocks):\n\
    \        reinterpret_to_words_and_xor(s,msg[idx:][:r_b])\n        idx+=r_b\n \
    \       sha3_transform(s)\n    #Handle last block padding.\n    m=bytearray(msg[idx:])\n\
    \    m.append(o_p)\n    while len(m) < r_b: m.append(0)\n    m[len(m)-1]|=128\n\
    \    #Handle padded last block.\n    reinterpret_to_words_and_xor(s,m)\n    sha3_transform(s)\n\
    \    #Output.\n    out = bytearray()\n    while len(out)<e_b:\n        out+=reinterpret_to_octets(s[:r_w])\n\
    \        sha3_transform(s)\n    return out[:e_b]\n"
- title: '#Implementation of SHAKE256 functions.'
  contents:
  - '#Implementation of SHAKE256 functions.

    '
- title: 'def shake256(msg,olen): return sha3_raw(msg,17,31,olen)'
  contents:
  - 'def shake256(msg,olen): return sha3_raw(msg,17,31,olen)

    '
- title: '#A (prime) field element.'
  contents:
  - '#A (prime) field element.

    '
- title: 'class Field:'
  contents:
  - "class Field:\n    #Construct number x (mod p).\n    def __init__(self,x,p):\n\
    \        self.__x=x%p\n        self.__p=p\n    #Check that fields of self and\
    \ y are the same.\n    def __check_fields(self,y):\n        if type(y) is not\
    \ Field or self.__p!=y.__p:\n            raise ValueError(\"Fields don't match\"\
    )\n    #Field addition.  The fields must match.\n    def __add__(self,y):\n  \
    \      self.__check_fields(y)\n        return Field(self.__x+y.__x,self.__p)\n\
    \    #Field subtraction.  The fields must match.\n    def __sub__(self,y):\n \
    \       self.__check_fields(y)\n        return Field(self.__p+self.__x-y.__x,self.__p)\n\
    \    #Field negation.\n    def __neg__(self):\n        return Field(self.__p-self.__x,self.__p)\n\
    \    #Field multiplication.  The fields must match.\n    def __mul__(self,y):\n\
    \        self.__check_fields(y)\n        return Field(self.__x*y.__x,self.__p)\n\
    \    #Field division.  The fields must match.\n    def __truediv__(self,y):\n\
    \        return self*y.inv()\n    #Field inverse (inverse of 0 is 0).\n    def\
    \ inv(self):\n        return Field(pow(self.__x,self.__p-2,self.__p),self.__p)\n\
    \    #Field square root.  Returns none if square root does not exist.\n    #Note:\
    \ not presently implemented for p mod 8 = 1 case.\n    def sqrt(self):\n     \
    \   #Compute candidate square root.\n        if self.__p%4==3: y=sqrt4k3(self.__x,self.__p)\n\
    \        elif self.__p%8==5: y=sqrt8k5(self.__x,self.__p)\n        else: raise\
    \ NotImplementedError(\"sqrt(_,8k+1)\")\n        _y=Field(y,self.__p);\n     \
    \   #Check square root candidate valid.\n        return _y if _y*_y==self else\
    \ None\n    #Make the field element with the same field as this, but\n    #with\
    \ a different value.\n    def make(self,ival): return Field(ival,self.__p)\n \
    \   #Is the field element the additive identity?\n    def iszero(self): return\
    \ self.__x==0\n    #Are field elements equal?\n    def __eq__(self,y): return\
    \ self.__x==y.__x and self.__p==y.__p\n    #Are field elements not equal?\n  \
    \  def __ne__(self,y): return not (self==y)\n    #Serialize number to b-1 bits.\n\
    \    def tobytes(self,b):\n        return self.__x.to_bytes(b//8,byteorder=\"\
    little\")\n    #Unserialize number from bits.\n    def frombytes(self,x,b):\n\
    \        rv=from_le(x)%(2**(b-1))\n        return Field(rv,self.__p) if rv<self.__p\
    \ else None\n    #Compute sign of number, 0 or 1.  The sign function\n    #has\
    \ the following property:\n    #sign(x) = 1 - sign(-x) if x != 0.\n    def sign(self):\
    \ return self.__x%2\n"
- title: '#A point on (twisted) Edwards curve.'
  contents:
  - '#A point on (twisted) Edwards curve.

    '
- title: 'class EdwardsPoint:'
  contents:
  - "class EdwardsPoint:\n    #base_field = None\n    #x = None\n    #y = None\n \
    \   #z = None\n    def initpoint(self, x, y):\n        self.x=x\n        self.y=y\n\
    \        self.z=self.base_field.make(1)\n    def decode_base(self,s,b):\n    \
    \    #Check that point encoding is the correct length.\n        if len(s)!=b//8:\
    \ return (None,None)\n        #Extract signbit.\n        xs=s[(b-1)//8]>>((b-1)&7)\n\
    \        #Decode y.  If this fails, fail.\n        y = self.base_field.frombytes(s,b)\n\
    \        if y is None: return (None,None)\n        #Try to recover x.  If it does\
    \ not exist, or if zero and xs\n        #are wrong, fail.\n        x=self.solve_x2(y).sqrt()\n\
    \        if x is None or (x.iszero() and xs!=x.sign()):\n            return (None,None)\n\
    \        #If sign of x isn't correct, flip it.\n        if x.sign()!=xs: x=-x\n\
    \        # Return the constructed point.\n        return (x,y)\n    def encode_base(self,b):\n\
    \        xp,yp=self.x/self.z,self.y/self.z\n        #Encode y.\n        s=bytearray(yp.tobytes(b))\n\
    \        #Add sign bit of x to encoding.\n        if xp.sign()!=0: s[(b-1)//8]|=1<<(b-1)%8\n\
    \        return s\n    def __mul__(self,x):\n        r=self.zero_elem()\n    \
    \    s=self\n        while x > 0:\n            if (x%2)>0:\n                r=r+s\n\
    \            s=s.double()\n            x=x//2\n        return r\n    #Check that\
    \ two points are equal.\n    def __eq__(self,y):\n        #Need to check x1/z1\
    \ == x2/z2 and similarly for y, so cross\n        #multiply to eliminate divisions.\n\
    \        xn1=self.x*y.z\n        xn2=y.x*self.z\n        yn1=self.y*y.z\n    \
    \    yn2=y.y*self.z\n        return xn1==xn2 and yn1==yn2\n    #Check if two points\
    \ are not equal.\n    def __ne__(self,y): return not (self==y)\n"
- title: '#A point on Edwards25519.'
  contents:
  - '#A point on Edwards25519.

    '
- title: 'class Edwards25519Point(EdwardsPoint):'
  contents:
  - "class Edwards25519Point(EdwardsPoint):\n    #Create a new point on the curve.\n\
    \    base_field=Field(1,2**255-19)\n    d=-base_field.make(121665)/base_field.make(121666)\n\
    \    f0=base_field.make(0)\n    f1=base_field.make(1)\n    xb=base_field.make(hexi(\"\
    216936D3CD6E53FEC0A4E231FDD6DC5C692CC76\"+\\\n        \"09525A7B2C9562D608F25D51A\"\
    ))\n    yb=base_field.make(hexi(\"666666666666666666666666666666666666666\"+\\\
    \n        \"6666666666666666666666658\"))\n    #The standard base point.\n   \
    \ @staticmethod\n    def stdbase():\n        return Edwards25519Point(Edwards25519Point.xb,\\\
    \n            Edwards25519Point.yb)\n    def __init__(self,x,y):\n        #Check\
    \ the point is actually on the curve.\n        if y*y-x*x!=self.f1+self.d*x*x*y*y:\n\
    \            raise ValueError(\"Invalid point\")\n        self.initpoint(x, y)\n\
    \        self.t=x*y\n    #Decode a point representation.\n    def decode(self,s):\n\
    \        x,y=self.decode_base(s,256);\n        return Edwards25519Point(x, y)\
    \ if x is not None else None\n    #Encode a point representation.\n    def encode(self):\n\
    \        return self.encode_base(256)\n    #Construct a neutral point on this\
    \ curve.\n    def zero_elem(self):\n        return Edwards25519Point(self.f0,self.f1)\n\
    \    #Solve for x^2.\n    def solve_x2(self,y):\n        return ((y*y-self.f1)/(self.d*y*y+self.f1))\n\
    \    #Point addition.\n    def __add__(self,y):\n        #The formulas are from\
    \ EFD.\n        tmp=self.zero_elem()\n        zcp=self.z*y.z\n        A=(self.y-self.x)*(y.y-y.x)\n\
    \        B=(self.y+self.x)*(y.y+y.x)\n        C=(self.d+self.d)*self.t*y.t\n \
    \       D=zcp+zcp\n        E,H=B-A,B+A\n        F,G=D-C,D+C\n        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H\n\
    \        return tmp\n    #Point doubling.\n    def double(self):\n        #The\
    \ formulas are from EFD (with assumption a=-1 propagated).\n        tmp=self.zero_elem()\n\
    \        A=self.x*self.x\n        B=self.y*self.y\n        Ch=self.z*self.z\n\
    \        C=Ch+Ch\n        H=A+B\n        xys=self.x+self.y\n        E=H-xys*xys\n\
    \        G=A-B\n        F=C+G\n        tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H\n\
    \        return tmp\n    #Order of basepoint.\n    def l(self):\n        return\
    \ hexi(\"1000000000000000000000000000000014def9dea2f79cd\"+\\\n            \"\
    65812631a5cf5d3ed\")\n    #The logarithm of cofactor.\n    def c(self): return\
    \ 3\n    #The highest set bit\n    def n(self): return 254\n    #The coding length\n\
    \    def b(self): return 256\n    #Validity check (for debugging)\n    def is_valid_point(self):\n\
    \        x,y,z,t=self.x,self.y,self.z,self.t\n        x2=x*x\n        y2=y*y\n\
    \        z2=z*z\n        lhs=(y2-x2)*z2\n        rhs=z2*z2+self.d*x2*y2\n    \
    \    assert(lhs == rhs)\n        assert(t*z == x*y)\n"
- title: '#A point on Edwards448.'
  contents:
  - '#A point on Edwards448.

    '
- title: 'class Edwards448Point(EdwardsPoint):'
  contents:
  - "class Edwards448Point(EdwardsPoint):\n    #Create a new point on the curve.\n\
    \    base_field=Field(1,2**448-2**224-1)\n    d=base_field.make(-39081)\n    f0=base_field.make(0)\n\
    \    f1=base_field.make(1)\n    xb=base_field.make(hexi(\"4F1970C66BED0DED221D15A622BF36DA9E14657\"\
    +\\\n        \"0470F1767EA6DE324A3D3A46412AE1AF72AB66511433B80E18B00938E26\"+\\\
    \n        \"26A82BC70CC05E\"))\n    yb=base_field.make(hexi(\"693F46716EB6BC248876203756C9C7624BEA737\"\
    +\\\n        \"36CA3984087789C1E05A0C2D73AD3FF1CE67C39C4FDBD132C4ED7C8AD98\"+\\\
    \n        \"08795BF230FA14\"))\n    #The standard base point.\n    @staticmethod\n\
    \    def stdbase():\n        return Edwards448Point(Edwards448Point.xb,Edwards448Point.yb)\n\
    \    def __init__(self,x,y):\n        #Check that the point is actually on the\
    \ curve.\n        if y*y+x*x!=self.f1+self.d*x*x*y*y:\n            raise ValueError(\"\
    Invalid point\")\n        self.initpoint(x, y)\n    #Decode a point representation.\n\
    \    def decode(self,s):\n        x,y=self.decode_base(s,456);\n        return\
    \ Edwards448Point(x, y) if x is not None else None\n    #Encode a point representation.\n\
    \    def encode(self):\n        return self.encode_base(456)\n    #Construct a\
    \ neutral point on this curve.\n    def zero_elem(self):\n        return Edwards448Point(self.f0,self.f1)\n\
    \    #Solve for x^2.\n    def solve_x2(self,y):\n        return ((y*y-self.f1)/(self.d*y*y-self.f1))\n\
    \    #Point addition.\n    def __add__(self,y):\n        #The formulas are from\
    \ EFD.\n        tmp=self.zero_elem()\n        xcp,ycp,zcp=self.x*y.x,self.y*y.y,self.z*y.z\n\
    \        B=zcp*zcp\n        E=self.d*xcp*ycp\n        F,G=B-E,B+E\n        tmp.x=zcp*F*((self.x+self.y)*(y.x+y.y)-xcp-ycp)\n\
    \        tmp.y,tmp.z=zcp*G*(ycp-xcp),F*G\n        return tmp\n    #Point doubling.\n\
    \    def double(self):\n        #The formulas are from EFD.\n        tmp=self.zero_elem()\n\
    \        x1s,y1s,z1s=self.x*self.x,self.y*self.y,self.z*self.z\n        xys=self.x+self.y\n\
    \        F=x1s+y1s\n        J=F-(z1s+z1s)\n        tmp.x,tmp.y,tmp.z=(xys*xys-x1s-y1s)*J,F*(x1s-y1s),F*J\n\
    \        return tmp\n    #Order of basepoint.\n    def l(self):\n        return\
    \ hexi(\"3ffffffffffffffffffffffffffffffffffffffffffffff\"+\\\n            \"\
    fffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c2\"+\\\n            \"92ab5844f3\"\
    )\n    #The logarithm of cofactor.\n    def c(self): return 2\n    #The highest\
    \ set bit.\n    def n(self): return 447\n    #The coding length.\n    def b(self):\
    \ return 456\n    #Validity check (for debugging).\n    def is_valid_point(self):\n\
    \        x,y,z=self.x,self.y,self.z\n        x2=x*x\n        y2=y*y\n        z2=z*z\n\
    \        lhs=(x2+y2)*z2\n        rhs=z2*z2+self.d*x2*y2\n        assert(lhs ==\
    \ rhs)\n"
- title: '#Simple self-check.'
  contents:
  - '#Simple self-check.

    '
- title: 'def curve_self_check(point):'
  contents:
  - "def curve_self_check(point):\n    p=point\n    q=point.zero_elem()\n    z=q\n\
    \    l=p.l()+1\n    p.is_valid_point()\n    q.is_valid_point()\n    for i in range(0,point.b()):\n\
    \        if (l>>i)&1 != 0:\n            q=q+p\n            q.is_valid_point()\n\
    \        p=p.double()\n        p.is_valid_point()\n    assert q.encode() == point.encode()\n\
    \    assert q.encode() != p.encode()\n    assert q.encode() != z.encode()\n"
- title: '#Simple self-check.'
  contents:
  - '#Simple self-check.

    '
- title: 'def self_check_curves():'
  contents:
  - "def self_check_curves():\n    curve_self_check(Edwards25519Point.stdbase())\n\
    \    curve_self_check(Edwards448Point.stdbase())\n"
- title: '#PureEdDSA scheme.'
  contents:
  - '#PureEdDSA scheme.

    '
- title: '#Limitation: only b mod 8 = 0 is handled.'
  contents:
  - '#Limitation: only b mod 8 = 0 is handled.

    '
- title: 'class PureEdDSA:'
  contents:
  - "class PureEdDSA:\n    #Create a new object.\n    def __init__(self,properties):\n\
    \        self.B=properties[\"B\"]\n        self.H=properties[\"H\"]\n        self.l=self.B.l()\n\
    \        self.n=self.B.n()\n        self.b=self.B.b()\n        self.c=self.B.c()\n\
    \    #Clamp a private scalar.\n    def __clamp(self,a):\n        _a = bytearray(a)\n\
    \        for i in range(0,self.c): _a[i//8]&=~(1<<(i%8))\n        _a[self.n//8]|=1<<(self.n%8)\n\
    \        for i in range(self.n+1,self.b): _a[i//8]&=~(1<<(i%8))\n        return\
    \ _a\n    #Generate a key.  If privkey is None, a random one is generated.\n \
    \   #In any case, the (privkey, pubkey) pair is returned.\n    def keygen(self,privkey):\n\
    \        #If no private key data is given, generate random.\n        if privkey\
    \ is None: privkey=os.urandom(self.b//8)\n        #Expand key.\n        khash=self.H(privkey,None,None)\n\
    \        a=from_le(self.__clamp(khash[:self.b//8]))\n        #Return the key pair\
    \ (public key is A=Enc(aB).\n        return privkey,(self.B*a).encode()\n    #Sign\
    \ with key pair.\n    def sign(self,privkey,pubkey,msg,ctx,hflag):\n        #Expand\
    \ key.\n        khash=self.H(privkey,None,None)\n        a=from_le(self.__clamp(khash[:self.b//8]))\n\
    \        seed=khash[self.b//8:]\n        #Calculate r and R (R only used in encoded\
    \ form).\n        r=from_le(self.H(seed+msg,ctx,hflag))%self.l\n        R=(self.B*r).encode()\n\
    \        #Calculate h.\n        h=from_le(self.H(R+pubkey+msg,ctx,hflag))%self.l\n\
    \        #Calculate s.\n        S=((r+h*a)%self.l).to_bytes(self.b//8,byteorder=\"\
    little\")\n        #The final signature is a concatenation of R and S.\n     \
    \   return R+S\n    #Verify signature with public key.\n    def verify(self,pubkey,msg,sig,ctx,hflag):\n\
    \        #Sanity-check sizes.\n        if len(sig)!=self.b//4: return False\n\
    \        if len(pubkey)!=self.b//8: return False\n        #Split signature into\
    \ R and S, and parse.\n        Rraw,Sraw=sig[:self.b//8],sig[self.b//8:]\n   \
    \     R,S=self.B.decode(Rraw),from_le(Sraw)\n        #Parse public key.\n    \
    \    A=self.B.decode(pubkey)\n        #Check parse results.\n        if (R is\
    \ None) or (A is None) or S>=self.l: return False\n        #Calculate h.\n   \
    \     h=from_le(self.H(Rraw+pubkey+msg,ctx,hflag))%self.l\n        #Calculate\
    \ left and right sides of check eq.\n        rhs=R+(A*h)\n        lhs=self.B*S\n\
    \        for i in range(0, self.c):\n            lhs = lhs.double()\n        \
    \    rhs = rhs.double()\n        #Check eq. holds?\n        return lhs==rhs\n"
- title: 'def Ed25519_inthash(data,ctx,hflag):'
  contents:
  - "def Ed25519_inthash(data,ctx,hflag):\n    if (ctx is not None and len(ctx) >\
    \ 0) or hflag:\n        raise ValueError(\"Contexts/hashes not supported\")\n\
    \    return hashlib.sha512(data).digest()\n"
- title: '#The base PureEdDSA schemes.'
  contents:
  - '#The base PureEdDSA schemes.

    '
- title: pEd25519=PureEdDSA({\
  contents:
  - "pEd25519=PureEdDSA({\\\n    \"B\":Edwards25519Point.stdbase(),\\\n    \"H\":Ed25519_inthash\\\
    \n"
- title: '})'
  contents:
  - '})

    '
- title: 'def Ed25519ctx_inthash(data,ctx,hflag):'
  contents:
  - "def Ed25519ctx_inthash(data,ctx,hflag):\n    dompfx = b\"\"\n    PREFIX=b\"SigEd25519\
    \ no Ed25519 collisions\"\n    if ctx is not None:\n        if len(ctx) > 255:\
    \ raise ValueError(\"Context too big\")\n        dompfx=PREFIX+bytes([1 if hflag\
    \ else 0,len(ctx)])+ctx\n    return hashlib.sha512(dompfx+data).digest()\n"
- title: pEd25519ctx=PureEdDSA({\
  contents:
  - "pEd25519ctx=PureEdDSA({\\\n    \"B\":Edwards25519Point.stdbase(),\\\n    \"H\"\
    :Ed25519ctx_inthash\\\n"
- title: '})'
  contents:
  - '})

    '
- title: 'def Ed448_inthash(data,ctx,hflag):'
  contents:
  - "def Ed448_inthash(data,ctx,hflag):\n    dompfx = b\"\"\n    if ctx is not None:\n\
    \        if len(ctx) > 255: raise ValueError(\"Context too big\")\n        dompfx=b\"\
    SigEd448\"+bytes([1 if hflag else 0,len(ctx)])+ctx\n    return shake256(dompfx+data,114)\n"
- title: pEd448 = PureEdDSA({\
  contents:
  - "pEd448 = PureEdDSA({\\\n    \"B\":Edwards448Point.stdbase(),\\\n    \"H\":Ed448_inthash\\\
    \n"
- title: '})'
  contents:
  - '})

    '
- title: '#EdDSA scheme.'
  contents:
  - '#EdDSA scheme.

    '
- title: 'class EdDSA:'
  contents:
  - "class EdDSA:\n    #Create a new scheme object, with the specified PureEdDSA base\n\
    \    #scheme and specified prehash.\n    def __init__(self,pure_scheme,prehash):\n\
    \        self.__pflag = True\n        self.__pure=pure_scheme\n        self.__prehash=prehash\n\
    \        if self.__prehash is None:\n            self.__prehash = lambda x,y:x\n\
    \            self.__pflag = False\n    # Generate a key.  If privkey is none,\
    \ it generates a random\n    # privkey key, otherwise it uses a specified private\
    \ key.\n    # Returns pair (privkey, pubkey).\n    def keygen(self,privkey): return\
    \ self.__pure.keygen(privkey)\n    # Sign message msg using specified key pair.\n\
    \    def sign(self,privkey,pubkey,msg,ctx=None):\n        if ctx is None: ctx=b\"\
    \";\n        return self.__pure.sign(privkey,pubkey,self.__prehash(msg,ctx),\\\
    \n            ctx,self.__pflag)\n    # Verify signature sig on message msg using\
    \ public key pubkey.\n    def verify(self,pubkey,msg,sig,ctx=None):\n        if\
    \ ctx is None: ctx=b\"\";\n        return self.__pure.verify(pubkey,self.__prehash(msg,ctx),sig,\\\
    \n            ctx,self.__pflag)\n"
- title: 'def Ed448ph_prehash(data,ctx):'
  contents:
  - "def Ed448ph_prehash(data,ctx):\n    return shake256(data,64)\n"
- title: '#Our signature schemes.'
  contents:
  - '#Our signature schemes.

    '
- title: Ed25519 = EdDSA(pEd25519,None)
  contents:
  - 'Ed25519 = EdDSA(pEd25519,None)

    '
- title: Ed25519ctx = EdDSA(pEd25519ctx,None)
  contents:
  - 'Ed25519ctx = EdDSA(pEd25519ctx,None)

    '
- title: Ed25519ph = EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest())
  contents:
  - 'Ed25519ph = EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest())

    '
- title: Ed448 = EdDSA(pEd448,None)
  contents:
  - 'Ed448 = EdDSA(pEd448,None)

    '
- title: Ed448ph = EdDSA(pEd448,Ed448ph_prehash)
  contents:
  - 'Ed448ph = EdDSA(pEd448,Ed448ph_prehash)

    '
- title: 'def eddsa_obj(name):'
  contents:
  - "def eddsa_obj(name):\n    if name == \"Ed25519\": return Ed25519\n    if name\
    \ == \"Ed25519ctx\": return Ed25519ctx\n    if name == \"Ed25519ph\": return Ed25519ph\n\
    \    if name == \"Ed448\": return Ed448\n    if name == \"Ed448ph\": return Ed448ph\n\
    \    raise NotImplementedError(\"Algorithm not implemented\")\n"
- title: Appendix B.  Library Driver
  contents:
  - "Appendix B.  Library Driver\n   Below is a command-line tool that uses the library\
    \ above to perform\n   computations for interactive use or for self-checking.\n"
- title: import sys
  contents:
  - 'import sys

    '
- title: import binascii
  contents:
  - 'import binascii

    '
- title: from eddsa2 import Ed25519
  contents:
  - 'from eddsa2 import Ed25519

    '
- title: 'def munge_string(s, pos, change):'
  contents:
  - "def munge_string(s, pos, change):\n    return (s[:pos] +\n            int.to_bytes(s[pos]\
    \ ^ change, 1, \"little\") +\n            s[pos+1:])\n"
- title: '# Read a file in the format of'
  contents:
  - '# Read a file in the format of

    '
- title: '# http://ed25519.cr.yp.to/python/sign.input'
  contents:
  - '# http://ed25519.cr.yp.to/python/sign.input

    '
- title: lineno = 0
  contents:
  - 'lineno = 0

    '
- title: 'while True:'
  contents:
  - "while True:\n    line = sys.stdin.readline()\n    if not line:\n        break\n\
    \    lineno = lineno + 1\n    print(lineno)\n    fields = line.split(\":\")\n\
    \    secret = (binascii.unhexlify(fields[0]))[:32]\n    public = binascii.unhexlify(fields[1])\n\
    \    msg = binascii.unhexlify(fields[2])\n    signature = binascii.unhexlify(fields[3])[:64]\n\
    \    privkey,pubkey = Ed25519.keygen(secret)\n    assert public == pubkey\n  \
    \  assert signature == Ed25519.sign(privkey, pubkey, msg)\n    assert Ed25519.verify(public,\
    \ msg, signature)\n    if len(msg) == 0:\n        bad_msg = b\"x\"\n    else:\n\
    \        bad_msg = munge_string(msg, len(msg) // 3, 4)\n    assert not Ed25519.verify(public,bad_msg,signature)\n\
    \    assert not Ed25519.verify(public, msg, munge_string(signature,20,8))\n  \
    \  assert not Ed25519.verify(public,msg,munge_string(signature,40,16))\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   EdDSA and Ed25519 were initially described in a paper due\
    \ to Daniel\n   J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin\n\
    \   Yang.  The Ed448 curve is due to Mike Hamburg.\n   An earlier draft version\
    \ of this document was coauthored by Niels\n   Moeller.\n   Feedback on this document\
    \ was received from Werner Koch, Damien\n   Miller, Bob Bradley, Franck Rondepierre,\
    \ Alexey Melnikov, Kenny\n   Paterson, and Robert Edmonds.\n   The Ed25519 test\
    \ vectors were double checked by Bob Bradley using\n   three separate implementations\
    \ (one based on TweetNaCl and two\n   different implementations based on code\
    \ from SUPERCOP).\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Simon Josefsson\n   SJD AB\n   Email: simon@josefsson.org\n\
    \   URI:   http://josefsson.org/\n   Ilari Liusvaara\n   Independent\n   Email:\
    \ ilariliusvaara@welho.com\n"
