- contents:
  - '         Remote Network Monitoring Management Information Base

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo defines a portion of the Management Information Base (MIB)\n
    \  for use with network management protocols in TCP/IP-based internets.\n   In
    particular, it defines objects for managing remote network\n   monitoring devices.\n
    \  This memo obsoletes RFC 1757. This memo extends that specification by\n   documenting
    the RMON MIB in SMIv2 format while remaining semantically\n   identical to the
    existing SMIv1-based MIB.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1 The SNMP Management Framework ..............................
    \  2\n   2 Overview ...................................................   3\n
    \  2.1 Remote Network Management Goals ..........................   4\n   2.2
    Textual Conventions ......................................   5\n   2.3 Structure
    of MIB .........................................   5\n   2.3.1 The Ethernet Statistics
    Group ..........................   6\n   2.3.2 The History Control Group ..............................
    \  6\n   2.3.3 The Ethernet History Group .............................   6\n
    \  2.3.4 The Alarm Group ........................................   7\n   2.3.5
    The Host Group .........................................   7\n   2.3.6 The HostTopN
    Group .....................................   7\n   2.3.7 The Matrix Group .......................................
    \  7\n   2.3.8 The Filter Group .......................................   7\n
    \  2.3.9 The Packet Capture Group ...............................   8\n   2.3.10
    The Event Group .......................................   8\n   3 Control of Remote
    Network Monitoring Devices ...............   8\n   3.1  Resource  Sharing  Among
    Multiple Management Stations ...   9\n   3.2 Row Addition Among Multiple Management
    Stations ..........  10\n   4 Conventions ................................................
    \ 11\n   5 Definitions ................................................  12\n
    \  6 Security Considerations ....................................  94\n   7 Acknowledgments
    ............................................  95\n   8 Author's Address ...........................................
    \ 95\n   9 References .................................................  95\n
    \  10 Intellectual Property .....................................  97\n   11 Full
    Copyright Statement ..................................  98\n"
  title: Table of Contents
- contents:
  - "1.  The SNMP Management Framework\n   The SNMP Management Framework presently
    consists of five major\n   components:\n   o  An overall architecture, described
    in RFC 2571 [1].\n   o  Mechanisms for describing and naming objects and events
    for the\n      purpose of management. The first version of this Structure of\n
    \     Management Information (SMI) is called SMIv1 and described in STD\n      16,
    RFC 1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4]. The\n      second version,
    called SMIv2, is described in STD 58, RFC 2578\n      [5], RFC 2579 [6] and RFC
    2580 [7].\n   o  Message protocols for transferring management information. The\n
    \     first version of the SNMP message protocol is called SNMPv1 and\n      described
    in STD 15, RFC 1157 [8]. A second version of the SNMP\n      message protocol,
    which is not an Internet standards track\n      protocol, is called SNMPv2c and
    described in RFC 1901 [9] and RFC\n      1906 [10]. The third version of the message
    protocol is called\n      SNMPv3 and described in RFC 1906 [10], RFC 2572 [11]
    and RFC 2574\n      [12].\n   o  Protocol operations for accessing management
    information. The\n      first set of protocol operations and associated PDU formats
    is\n      described in STD 15, RFC 1157 [8]. A second set of protocol\n      operations
    and associated PDU formats is described in RFC 1905\n      [13].\n   o  A set
    of fundamental applications described in RFC 2573 [14] and\n      the view-based
    access control mechanism described in RFC 2575\n      [15].\n   A more detailed
    introduction to the current SNMP Management Framework\n   can be found in RFC
    2570 [22].\n   Managed objects are accessed via a virtual information store, termed\n
    \  the Management Information Base or MIB.  Objects in the MIB are\n   defined
    using the mechanisms defined in the SMI.\n   This memo specifies a MIB module
    that is compliant to the SMIv2. A\n   MIB conforming to the SMIv1 can be produced
    through the appropriate\n   translations. The resulting translated MIB must be
    semantically\n   equivalent, except where objects or events are omitted because
    no\n   translation is possible (use of Counter64). Some machine readable\n   information
    in SMIv2 will be converted into textual descriptions in\n   SMIv1 during the translation
    process.  However, this loss of machine\n   readable information is not considered
    to change the semantics of the\n   MIB.\n"
  title: 1.  The SNMP Management Framework
- contents:
  - "2.  Overview\n   Remote network monitoring devices, often called monitors or
    probes,\n   are instruments that exist for the purpose of managing a network.\n
    \  Often these remote probes are stand-alone devices and devote\n   significant
    internal resources for the sole purpose of managing a\n   network.  An organization
    may employ many of these devices, one per\n   network segment, to manage its internet.
    \ In addition, these devices\n   may be used for a network management service
    provider to access a\n   client network, often geographically remote.\n   The
    objects defined in this document are intended as an interface\n   between an RMON
    agent and an RMON management application and are not\n   intended for direct manipulation
    by humans.  While some users may\n   tolerate the direct display of some of these
    objects, few will\n   tolerate the complexity of manually manipulating objects
    to\n   accomplish row creation.  These functions should be handled by the\n   management
    application.\n   While most of the objects in this document are suitable for the\n
    \  management of any type of network, there are some which are specific\n   to
    managing Ethernet networks.  These are the objects in the\n   etherStatsTable,
    the etherHistoryTable, and some attributes of the\n   filterPktStatus and capturBufferPacketStatus
    objects.  The design of\n   this MIB allows similar objects to be defined for
    other network\n   types.  It is intended that future versions of this document
    and\n   additional documents will define extensions for other network types.\n
    \  There are a number of companion documents to the RMON MIB. The Token\n   Ring
    RMON MIB [19] provides objects specific to managing Token Ring\n   networks. The
    RMON-2 MIB [20] extends RMON by providing RMON analysis\n   up to the application
    layer. The SMON MIB [21] extends RMON by\n   providing RMON analysis for switched
    networks.\n"
  - contents:
    - "2.1.  Remote Network Management Goals\n   o  Offline Operation\n        There
      are sometimes conditions when a management station will\n        not be in constant
      contact with its remote monitoring devices.\n        This is sometimes by design
      in an attempt to lower\n        communications costs (especially when communicating
      over a WAN\n        or dialup link), or by accident as network failures affect
      the\n        communications between the management station and the probe.\n
      \       For this reason, this MIB allows a probe to be configured to\n        perform
      diagnostics and to collect statistics continuously, even\n        when communication
      with the management station may not be\n        possible or efficient.  The
      probe may then attempt to notify the\n        management station when an exceptional
      condition occurs.  Thus,\n        even in circumstances where communication
      between management\n        station and probe is not continuous, fault, performance,
      and\n        configuration information may be continuously accumulated and\n
      \       communicated to the management station conveniently and\n        efficiently.\n
      \  o  Proactive Monitoring\n        Given the resources available on the monitor,
      it is potentially\n        helpful for it continuously to run diagnostics and
      to log\n        network performance.  The monitor is always available at the\n
      \       onset of any failure.  It can notify the management station of\n        the
      failure and can store historical statistical information\n        about the
      failure.  This historical information can be played\n        back by the management
      station in an attempt to perform further\n        diagnosis into the cause of
      the problem.\n   o  Problem Detection and Reporting\n        The monitor can
      be configured to recognize conditions, most\n        notably error conditions,
      and continuously to check for them.\n        When one of these conditions occurs,
      the event may be logged,\n        and management stations may be notified in
      a number of ways.\n   o  Value Added Data\n        Because a remote monitoring
      device represents a network resource\n        dedicated exclusively to network
      management functions, and\n        because it is located directly on the monitored
      portion of the\n        network, the remote network monitoring device has the\n
      \       opportunity to add significant value to the data it collects.\n        For
      instance, by highlighting those hosts on the network that\n        generate
      the most traffic or errors, the probe can give the\n        management station
      precisely the information it needs to solve a\n        class of problems.\n
      \  o  Multiple Managers\n        An organization may have multiple management
      stations for\n        different units of the organization, for different functions\n
      \       (e.g. engineering and operations), and in an attempt to provide\n        disaster
      recovery.  Because environments with multiple\n        management stations are
      common, the remote network monitoring\n        device has to deal with more
      than own management station,\n        potentially using its resources concurrently.\n"
    title: 2.1.  Remote Network Management Goals
  - contents:
    - "2.2.  Textual Conventions\n   Two new data types are introduced as a textual
      convention in this MIB\n   document, OwnerString and EntryStatus.\n"
    title: 2.2.  Textual Conventions
  - contents:
    - "2.3.  Structure of MIB\n   The objects are arranged into the following groups:\n
      \        - ethernet statistics\n         - history control\n         - ethernet
      history\n         - alarm\n         - host\n         - hostTopN\n         -
      matrix\n         - filter\n         - packet capture\n         - event\n   These
      groups are the basic unit of conformance.  If a remote\n   monitoring device
      implements a group, then it must implement all\n   objects in that group.  For
      example, a managed agent that implements\n   the host group must implement the
      hostControlTable, the hostTable and\n   the hostTimeTable. While this section
      provides an overview of\n   grouping and conformance information for this MIB,
      the authoritative\n   reference for such information is contained in the MODULE-COMPLIANCE\n
      \  and OBJECT-GROUP macros later in this MIB.\n   All groups in this MIB are
      optional.  Implementations of this MIB\n   must also implement the system group
      of MIB-II [16] and the IF-MIB\n   [17].  MIB-II may also mandate the implementation
      of additional\n   groups.\n   These groups are defined to provide a means of
      assigning object\n   identifiers, and to provide a method for implementors of
      managed\n   agents to know which objects they must implement.\n"
    - contents:
      - "2.3.1.  The Ethernet Statistics Group\n   The ethernet statistics group contains
        statistics measured by the\n   probe for each monitored Ethernet interface
        on this device.  This\n   group consists of the etherStatsTable.\n"
      title: 2.3.1.  The Ethernet Statistics Group
    - contents:
      - "2.3.2.  The History Control Group\n   The history control group controls
        the periodic statistical sampling\n   of data from various types of networks.
        \ This group consists of the\n   historyControlTable.\n"
      title: 2.3.2.  The History Control Group
    - contents:
      - "2.3.3.  The Ethernet History Group\n   The ethernet history group records
        periodic statistical samples from\n   an ethernet network and stores them
        for later retrieval.  This group\n   consists of the etherHistoryTable.\n"
      title: 2.3.3.  The Ethernet History Group
    - contents:
      - "2.3.4.  The Alarm Group\n   The alarm group periodically takes statistical
        samples from variables\n   in the probe and compares them to previously configured
        thresholds.\n   If the monitored variable crosses a threshold, an event is
        generated.\n   A hysteresis mechanism is implemented to limit the generation
        of\n   alarms.  This group consists of the alarmTable and requires the\n   implementation
        of the event group.\n"
      title: 2.3.4.  The Alarm Group
    - contents:
      - "2.3.5.  The Host Group\n   The host group contains statistics associated
        with each host\n   discovered on the network.  This group discovers hosts
        on the network\n   by keeping a list of source and destination MAC Addresses
        seen in\n   good packets promiscuously received from the network.  This group\n
        \  consists of the hostControlTable, the hostTable, and the\n   hostTimeTable.\n"
      title: 2.3.5.  The Host Group
    - contents:
      - "2.3.6.  The HostTopN Group\n   The hostTopN group is used to prepare reports
        that describe the hosts\n   that top a list ordered by one of their statistics.
        \ The available\n   statistics are samples of one of their base statistics
        over an\n   interval specified by the management station.  Thus, these statistics\n
        \  are rate based.  The management station also selects how many such\n   hosts
        are reported.  This group consists of the hostTopNControlTable\n   and the
        hostTopNTable, and requires the implementation of the host\n   group.\n"
      title: 2.3.6.  The HostTopN Group
    - contents:
      - "2.3.7.  The Matrix Group\n   The matrix group stores statistics for conversations
        between sets of\n   two addresses.  As the device detects a new conversation,
        it creates\n   a new entry in its tables.  This group consists of the\n   matrixControlTable,
        the matrixSDTable and the matrixDSTable.\n"
      title: 2.3.7.  The Matrix Group
    - contents:
      - "2.3.8.  The Filter Group\n   The filter group allows packets to be matched
        by a filter equation.\n   These matched packets form a data stream that may
        be captured or may\n   generate events.  This group consists of the filterTable
        and the\n   channelTable.\n"
      title: 2.3.8.  The Filter Group
    - contents:
      - "2.3.9.  The Packet Capture Group\n   The Packet Capture group allows packets
        to be captured after they\n   flow through a channel.  This group consists
        of the\n   bufferControlTable and the captureBufferTable, and requires the\n
        \  implementation of the filter group.\n"
      title: 2.3.9.  The Packet Capture Group
    - contents:
      - "2.3.10.  The Event Group\n   The event group controls the generation and
        notification of events\n   from this device.  This group consists of the eventTable
        and the\n   logTable.\n"
      title: 2.3.10.  The Event Group
    title: 2.3.  Structure of MIB
  title: 2.  Overview
- contents:
  - "3.  Control of Remote Network Monitoring Devices\n   Due to the complex nature
    of the available functions in these\n   devices, the functions often need user
    configuration.  In many cases,\n   the function requires parameters to be set
    up for a data collection\n   operation.  The operation can proceed only after
    these parameters are\n   fully set up.\n   Many functional groups in this MIB
    have one or more tables in which\n   to set up control parameters, and one or
    more data tables in which to\n   place the results of the operation.  The control
    tables are typically\n   read-write in nature, while the data tables are typically
    read-only.\n   Because the parameters in the control table often describe resulting\n
    \  data in the data table, many of the parameters can be modified only\n   when
    the control entry is invalid.  Thus, the method for modifying\n   these parameters
    is to invalidate the control entry, causing its\n   deletion and the deletion
    of any associated data entries, and then\n   create a new control entry with the
    proper parameters.  Deleting the\n   control entry also gives a convenient method
    for reclaiming the\n   resources used by the associated data.\n   Some objects
    in this MIB provide a mechanism to execute an action on\n   the remote monitoring
    device.  These objects may execute an action as\n   a result of a change in the
    state of the object.  For those objects\n   in this MIB, a request to set an object
    to the same value as it\n   currently holds would thus cause no action to occur.\n
    \  To facilitate control by multiple managers, resources have to be\n   shared
    among the managers.  These resources are typically the memory\n   and computation
    resources that a function requires.\n"
  - contents:
    - "3.1.  Resource Sharing Among Multiple Management Stations\n   When multiple
      management stations wish to use functions that compete\n   for a finite amount
      of resources on a device, a method to facilitate\n   this sharing of resources
      is required.  Potential conflicts include:\n      o  Two management stations
      wish to simultaneously use resources\n         that together would exceed the
      capability of the device.\n      o  A management station uses a significant
      amount of resources for\n         a long period of time.\n      o  A management
      station uses resources and then crashes,\n         forgetting to free the resources
      so others may use them.\n   A mechanism is provided for each management station
      initiated\n   function in this MIB to avoid these conflicts and to help resolve\n
      \  them when they occur.  Each function has a label identifying the\n   initiator
      (owner) of the function.  This label is set by the\n   initiator to provide
      for the following possibilities:\n      o  A management station may recognize
      resources it owns and no\n         longer needs.\n      o  A network operator
      can find the management station that owns\n         the resource and negotiate
      for it to be freed.\n      o  A network operator may decide to unilaterally
      free resources\n         another network operator has reserved.\n      o  Upon
      initialization, a management station may recognize\n         resources it had
      reserved in the past.  With this information\n         it may free the resources
      if it no longer needs them.\n   Management stations and probes should support
      any format of the owner\n   string dictated by the local policy of the organization.
      \ It is\n   suggested that this name contain one or more of the following: IP\n
      \  address, management station name, network manager's name, location,\n   or
      phone number.  This information will help users to share the\n   resources more
      effectively.\n   There is often default functionality that the device or the\n
      \  administrator of the probe (often the network administrator) wishes\n   to
      set up.  The resources associated with this functionality are then\n   owned
      by the device itself or by the network administrator, and are\n   intended to
      be long-lived.  In this case, the device or the\n   administrator will set the
      relevant owner object to a string starting\n   with 'monitor'.  Indiscriminate
      modification of the monitor-owned\n   configuration by network management stations
      is discouraged.  In\n   fact, a network management station should only modify
      these objects\n   under the direction of the administrator of the probe.\n   Resources
      on a probe are scarce and are typically allocated when\n   control rows are
      created by an application.  Since many applications\n   may be using a probe
      simultaneously, indiscriminate allocation of\n   resources to particular applications
      is very likely to cause resource\n   shortages in the probe.\n   When a network
      management station wishes to utilize a function in a\n   monitor, it is encouraged
      to first scan the control table of that\n   function to find an instance with
      similar parameters to share.  This\n   is especially true for those instances
      owned by the monitor, which\n   can be assumed to change infrequently.  If a
      management station\n   decides to share an instance owned by another management
      station, it\n   should understand that the management station that owns the
      instance\n   may indiscriminately modify or delete it.\n   It should be noted
      that a management application should have the most\n   trust in a monitor-owned
      row because it should be changed very\n   infrequently.  A row owned by the
      management application is less\n   long-lived because a network administrator
      is more likely to re-\n   assign resources from a row that is in use by one
      user than from a\n   monitor-owned row that is potentially in use by many users.
      \ A row\n   owned by another application would be even less long-lived because\n
      \  the other application may delete or modify that row completely at its\n   discretion.\n"
    title: 3.1.  Resource Sharing Among Multiple Management Stations
  - contents:
    - "3.2.  Row Addition Among Multiple Management Stations\n   The addition of new
      rows is achieved using the method described in\n   RFC 1905 [13].  In this MIB,
      rows are often added to a table in order\n   to configure a function.  This
      configuration usually involves\n   parameters that control the operation of
      the function.  The agent\n   must check these parameters to make sure they are
      appropriate given\n   restrictions defined in this MIB as well as any implementation\n
      \  specific restrictions such as lack of resources.  The agent\n   implementor
      may be confused as to when to check these parameters and\n   when to signal
      to the management station that the parameters are\n   invalid.  There are two
      opportunities:\n      o  When the management station sets each parameter object.\n
      \     o  When the management station sets the entry status object to\n         valid.\n
      \  If the latter is chosen, it would be unclear to the management\n   station
      which of the several parameters was invalid and caused the\n   badValue error
      to be emitted.  Thus, wherever possible, the\n   implementor should choose the
      former as it will provide more\n   information to the management station.\n
      \  A problem can arise when multiple management stations attempt to set\n   configuration
      information simultaneously using SNMP.  When this\n   involves the addition
      of a new conceptual row in the same control\n   table, the managers may collide,
      attempting to create the same entry.\n   To guard against these collisions,
      each such control entry contains a\n   status object with special semantics
      that help to arbitrate among the\n   managers.  If an attempt is made with the
      row addition mechanism to\n   create such a status object and that object already
      exists, an error\n   is returned.  When more than one manager simultaneously
      attempts to\n   create the same conceptual row, only the first can succeed.
      \ The\n   others will receive an error.\n   When a manager wishes to create
      a new control entry, it needs to\n   choose an index for that row.  It may choose
      this index in a variety\n   of ways, hopefully minimizing the chances that the
      index is in use by\n   another manager.  If the index is in use, the mechanism
      mentioned\n   previously will guard against collisions.  Examples of schemes
      to\n   choose index values include random selection or scanning the control\n
      \  table looking for the first unused index.  Because index values may\n   be
      any valid value in the range and they are chosen by the manager,\n   the agent
      must allow a row to be created with any unused index value\n   if it has the
      resources to create a new row.\n   Some tables in this MIB reference other tables
      within this MIB.  When\n   creating or deleting entries in these tables, it
      is generally\n   allowable for dangling references to exist.  There is no defined\n
      \  order for creating or deleting entries in these tables.\n"
    title: 3.2.  Row Addition Among Multiple Management Stations
  title: 3.  Control of Remote Network Monitoring Devices
- contents:
  - "4.  Conventions\n   The following conventions are used throughout the RMON MIB
    and its\n   companion documents.\n   Good Packets\n   Good packets are error-free
    packets that have a valid frame length.\n   For example, on Ethernet, good packets
    are error-free packets that\n   are between 64 octets long and 1518 octets long.
    \ They follow the\n   form defined in IEEE 802.3 section 3.2.all.\n   Bad Packets\n
    \  Bad packets are packets that have proper framing and are therefore\n   recognized
    as packets, but contain errors within the packet or have\n   an invalid length.
    \ For example, on Ethernet, bad packets have a\n   valid preamble and SFD, but
    have a bad CRC, or are either shorter\n   than 64 octets or longer than 1518 octets.\n"
  title: 4.  Conventions
- contents:
  - "5.  Definitions\n RMON-MIB DEFINITIONS ::= BEGIN\n     IMPORTS\n         MODULE-IDENTITY,
    OBJECT-TYPE, OBJECT-IDENTITY,\n         NOTIFICATION-TYPE, mib-2, Counter32,\n
    \        Integer32, TimeTicks                   FROM SNMPv2-SMI\n         TEXTUAL-CONVENTION,
    DisplayString      FROM SNMPv2-TC\n         MODULE-COMPLIANCE, OBJECT-GROUP,\n
    \        NOTIFICATION-GROUP                     FROM SNMPv2-CONF;\n --  Remote
    Network Monitoring MIB\n rmonMibModule MODULE-IDENTITY\n     LAST-UPDATED \"200005110000Z\"
    \ -- 11 May, 2000\n     ORGANIZATION \"IETF RMON MIB Working Group\"\n     CONTACT-INFO\n
    \        \"Steve Waldbusser\n         Phone: +1-650-948-6500\n         Fax:   +1-650-745-0671\n
    \        Email: waldbusser@nextbeacon.com\"\n     DESCRIPTION\n         \"Remote
    network monitoring devices, often called\n         monitors or probes, are instruments
    that exist for\n         the purpose of managing a network. This MIB defines\n
    \        objects for managing remote network monitoring devices.\"\n     REVISION
    \"200005110000Z\"    -- 11 May, 2000\n     DESCRIPTION\n         \"Reformatted
    into SMIv2 format.\n         This version published as RFC 2819.\"\n     REVISION
    \"199502010000Z\" -- 1 Feb, 1995\n     DESCRIPTION\n         \"Bug fixes, clarifications
    and minor changes based on\n         implementation experience, published as RFC1757
    [18].\n         Two changes were made to object definitions:\n         1) A new
    status bit has been defined for the\n         captureBufferPacketStatus object,
    indicating that the\n         packet order within the capture buffer may not be
    identical to\n         the packet order as received off the wire.  This bit may
    only\n         be used for packets transmitted by the probe.  Older NMS\n         applications
    can safely ignore this status bit, which might be\n         used by newer agents.\n
    \        2) The packetMatch trap has been removed.  This trap was never\n         actually
    'approved' and was not added to this document along\n         with the risingAlarm
    and fallingAlarm traps. The packetMatch\n         trap could not be throttled,
    which could cause disruption of\n         normal network traffic under some circumstances.
    An NMS should\n         configure a risingAlarm threshold on the appropriate\n
    \        channelMatches instance if a trap is desired for a packetMatch\n         event.
    Note that logging of packetMatch events is still\n         supported--only trap
    generation for such events has been\n         removed.\n         In addition,
    several clarifications to individual object\n         definitions have been added
    to assist agent and NMS\n         implementors:\n         - global definition
    of 'good packets' and 'bad packets'\n         - more detailed text governing conceptual
    row creation and\n           modification\n         - instructions for probes
    relating to interface changes and\n           disruptions\n         - clarification
    of some ethernet counter definitions\n         - recommended formula for calculating
    network utilization\n         - clarification of channel and captureBuffer behavior
    for some\n           unusual conditions\n         - examples of proper instance
    naming for each table\"\n     REVISION \"199111010000Z\"    -- 1 Nov, 1991\n     DESCRIPTION\n
    \        \"The original version of this MIB, published as RFC1271.\"\n     ::=
    { rmonConformance 8 }\n     rmon    OBJECT IDENTIFIER ::= { mib-2 16 }\n     --
    textual conventions\n OwnerString ::= TEXTUAL-CONVENTION\n     STATUS current\n
    \    DESCRIPTION\n         \"This data type is used to model an administratively\n
    \        assigned name of the owner of a resource. Implementations\n         must
    accept values composed of well-formed NVT ASCII\n         sequences. In addition,
    implementations should accept\n         values composed of well-formed UTF-8 sequences.\n
    \        It is suggested that this name contain one or more of\n         the following:
    IP address, management station name,\n         network manager's name, location,
    or phone number.\n         In some cases the agent itself will be the owner of\n
    \        an entry.  In these cases, this string shall be set\n         to a string
    starting with 'monitor'.\n         SNMP access control is articulated entirely
    in terms\n         of the contents of MIB views; access to a particular\n         SNMP
    object instance depends only upon its presence\n         or absence in a particular
    MIB view and never upon\n         its value or the value of related object instances.\n
    \        Thus, objects of this type afford resolution of\n         resource contention
    only among cooperating\n         managers; they realize no access control function\n
    \        with respect to uncooperative parties.\"\n     SYNTAX OCTET STRING (SIZE
    (0..127))\n EntryStatus ::= TEXTUAL-CONVENTION\n     STATUS current\n     DESCRIPTION\n
    \        \"The status of a table entry.\n         Setting this object to the value
    invalid(4) has the\n         effect of invalidating the corresponding entry.\n
    \        That is, it effectively disassociates the mapping\n         identified
    with said entry.\n         It is an implementation-specific matter as to whether\n
    \        the agent removes an invalidated entry from the table.\n         Accordingly,
    management stations must be prepared to\n         receive tabular information
    from agents that corresponds\n         to entries currently not in use.  Proper\n
    \        interpretation of such entries requires examination\n         of the
    relevant EntryStatus object.\n         An existing instance of this object cannot
    be set to\n         createRequest(2).  This object may only be set to\n         createRequest(2)
    when this instance is created.  When\n         this object is created, the agent
    may wish to create\n         supplemental object instances with default values\n
    \        to complete a conceptual row in this table.  Because the\n         creation
    of these default objects is entirely at the option\n         of the agent, the
    manager must not assume that any will be\n         created, but may make use of
    any that are created.\n         Immediately after completing the create operation,
    the agent\n         must set this object to underCreation(3).\n         When in
    the underCreation(3) state, an entry is allowed to\n         exist in a possibly
    incomplete, possibly inconsistent state,\n         usually to allow it to be modified
    in multiple PDUs.  When in\n         this state, an entry is not fully active.\n
    \        Entries shall exist in the underCreation(3) state until\n         the
    management station is finished configuring the entry\n         and sets this object
    to valid(1) or aborts, setting this\n         object to invalid(4).  If the agent
    determines that an\n         entry has been in the underCreation(3) state for
    an\n         abnormally long time, it may decide that the management\n         station
    has crashed.  If the agent makes this decision,\n         it may set this object
    to invalid(4) to reclaim the\n         entry.  A prudent agent will understand
    that the\n         management station may need to wait for human input\n         and
    will allow for that possibility in its\n         determination of this abnormally
    long period.\n         An entry in the valid(1) state is fully configured and\n
    \        consistent and fully represents the configuration or\n         operation
    such a row is intended to represent.  For\n         example, it could be a statistical
    function that is\n         configured and active, or a filter that is available\n
    \        in the list of filters processed by the packet capture\n         process.\n
    \        A manager is restricted to changing the state of an entry in\n         the
    following ways:\n              To:       valid  createRequest  underCreation  invalid\n
    \        From:\n         valid             OK             NO             OK       OK\n
    \        createRequest    N/A            N/A            N/A      N/A\n         underCreation
    \    OK             NO             OK       OK\n         invalid           NO
    \            NO             NO       OK\n         nonExistent       NO             OK
    \            NO       OK\n         In the table above, it is not applicable to
    move the state\n         from the createRequest state to any other state because
    the\n         manager will never find the variable in that state.  The\n         nonExistent
    state is not a value of the enumeration, rather\n         it means that the entryStatus
    variable does not exist at all.\n         An agent may allow an entryStatus variable
    to change state in\n         additional ways, so long as the semantics of the
    states are\n         followed.  This allowance is made to ease the implementation
    of\n         the agent and is made despite the fact that managers should\n         never
    exercise these additional state transitions.\"\n     SYNTAX INTEGER {\n                valid(1),\n
    \               createRequest(2),\n                underCreation(3),\n                invalid(4)\n
    \           }\n     statistics        OBJECT IDENTIFIER ::= { rmon 1 }\n     history
    \          OBJECT IDENTIFIER ::= { rmon 2 }\n     alarm             OBJECT IDENTIFIER
    ::= { rmon 3 }\n     hosts             OBJECT IDENTIFIER ::= { rmon 4 }\n     hostTopN
    \         OBJECT IDENTIFIER ::= { rmon 5 }\n     matrix            OBJECT IDENTIFIER
    ::= { rmon 6 }\n     filter            OBJECT IDENTIFIER ::= { rmon 7 }\n     capture
    \          OBJECT IDENTIFIER ::= { rmon 8 }\n     event             OBJECT IDENTIFIER
    ::= { rmon 9 }\n     rmonConformance   OBJECT IDENTIFIER ::= { rmon 20 }\n --
    The Ethernet Statistics Group\n --\n -- Implementation of the Ethernet Statistics
    group is optional.\n -- Consult the MODULE-COMPLIANCE macro for the authoritative\n
    -- conformance information for this MIB.\n --\n -- The ethernet statistics group
    contains statistics measured by the\n -- probe for each monitored interface on
    this device.  These\n -- statistics take the form of free running counters that
    start from\n -- zero when a valid entry is created.\n --\n -- This group currently
    has statistics defined only for\n -- Ethernet interfaces.  Each etherStatsEntry
    contains statistics\n -- for one Ethernet interface.  The probe must create one\n
    -- etherStats entry for each monitored Ethernet interface\n -- on the device.\n
    etherStatsTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF EtherStatsEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A list of
    Ethernet statistics entries.\"\n     ::= { statistics 1 }\n etherStatsEntry OBJECT-TYPE\n
    \    SYNTAX     EtherStatsEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n
    \    DESCRIPTION\n         \"A collection of statistics kept for a particular\n
    \        Ethernet interface.  As an example, an instance of the\n         etherStatsPkts
    object might be named etherStatsPkts.1\"\n     INDEX { etherStatsIndex }\n     ::=
    { etherStatsTable 1 }\n EtherStatsEntry ::= SEQUENCE {\n     etherStatsIndex                    Integer32,\n
    \    etherStatsDataSource               OBJECT IDENTIFIER,\n     etherStatsDropEvents
    \              Counter32,\n     etherStatsOctets                   Counter32,\n
    \    etherStatsPkts                     Counter32,\n     etherStatsBroadcastPkts
    \           Counter32,\n     etherStatsMulticastPkts            Counter32,\n     etherStatsCRCAlignErrors
    \          Counter32,\n     etherStatsUndersizePkts            Counter32,\n     etherStatsOversizePkts
    \            Counter32,\n     etherStatsFragments                Counter32,\n
    \    etherStatsJabbers                  Counter32,\n     etherStatsCollisions
    \              Counter32,\n     etherStatsPkts64Octets             Counter32,\n
    \    etherStatsPkts65to127Octets        Counter32,\n     etherStatsPkts128to255Octets
    \      Counter32,\n     etherStatsPkts256to511Octets       Counter32,\n     etherStatsPkts512to1023Octets
    \     Counter32,\n     etherStatsPkts1024to1518Octets     Counter32,\n     etherStatsOwner
    \                   OwnerString,\n     etherStatsStatus                   EntryStatus\n
    }\n etherStatsIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The value of
    this object uniquely identifies this\n         etherStats entry.\"\n     ::= {
    etherStatsEntry 1 }\n etherStatsDataSource OBJECT-TYPE\n     SYNTAX     OBJECT
    IDENTIFIER\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"This object identifies the source of the data that\n         this etherStats
    entry is configured to analyze.  This\n         source can be any ethernet interface
    on this device.\n         In order to identify a particular interface, this object\n
    \        shall identify the instance of the ifIndex object,\n         defined
    in RFC 2233 [17], for the desired interface.\n         For example, if an entry
    were to receive data from\n         interface #1, this object would be set to
    ifIndex.1.\n         The statistics in this group reflect all packets\n         on
    the local network segment attached to the identified\n         interface.\n         An
    agent may or may not be able to tell if fundamental\n         changes to the media
    of the interface have occurred and\n         necessitate an invalidation of this
    entry.  For example, a\n         hot-pluggable ethernet card could be pulled out
    and replaced\n         by a token-ring card.  In such a case, if the agent has
    such\n         knowledge of the change, it is recommended that it\n         invalidate
    this entry.\n         This object may not be modified if the associated\n         etherStatsStatus
    object is equal to valid(1).\"\n     ::= { etherStatsEntry 2 }\n etherStatsDropEvents
    OBJECT-TYPE\n     SYNTAX     Counter32\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The total number of events in which
    packets\n         were dropped by the probe due to lack of resources.\n         Note
    that this number is not necessarily the number of\n         packets dropped; it
    is just the number of times this\n         condition has been detected.\"\n     ::=
    { etherStatsEntry 3 }\n etherStatsOctets OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Octets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The total number of octets of data (including\n         those
    in bad packets) received on the\n         network (excluding framing bits but
    including\n         FCS octets).\n         This object can be used as a reasonable
    estimate of\n         10-Megabit ethernet utilization.  If greater precision is\n
    \        desired, the etherStatsPkts and etherStatsOctets objects\n         should
    be sampled before and after a common interval.  The\n         differences in the
    sampled values are Pkts and Octets,\n         respectively, and the number of
    seconds in the interval is\n         Interval.  These values are used to calculate
    the Utilization\n         as follows:\n                          Pkts * (9.6 +
    6.4) + (Octets * .8)\n          Utilization = -------------------------------------\n
    \                                 Interval * 10,000\n         The result of this
    equation is the value Utilization which\n         is the percent utilization of
    the ethernet segment on a\n         scale of 0 to 100 percent.\"\n     ::= { etherStatsEntry
    4 }\n etherStatsPkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    total number of packets (including bad packets,\n         broadcast packets, and
    multicast packets) received.\"\n     ::= { etherStatsEntry 5 }\n etherStatsBroadcastPkts
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of good packets received that were\n         directed to the broadcast address.
    \ Note that this\n         does not include multicast packets.\"\n     ::= { etherStatsEntry
    6 }\n etherStatsMulticastPkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The total number of good packets received that were\n         directed
    to a multicast address.  Note that this number\n         does not include packets
    directed to the broadcast\n         address.\"\n     ::= { etherStatsEntry 7 }\n
    etherStatsCRCAlignErrors OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    total number of packets received that\n         had a length (excluding framing
    bits, but\n         including FCS octets) of between 64 and 1518\n         octets,
    inclusive, but had either a bad\n         Frame Check Sequence (FCS) with an integral\n
    \        number of octets (FCS Error) or a bad FCS with\n         a non-integral
    number of octets (Alignment Error).\"\n     ::= { etherStatsEntry 8 }\n etherStatsUndersizePkts
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets received that were\n         less than 64 octets long (excluding framing
    bits,\n         but including FCS octets) and were otherwise well\n         formed.\"\n
    \    ::= { etherStatsEntry 9 }\n etherStatsOversizePkts OBJECT-TYPE\n     SYNTAX
    \    Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The total number of packets received
    that were\n         longer than 1518 octets (excluding framing bits,\n         but
    including FCS octets) and were otherwise\n         well formed.\"\n     ::= {
    etherStatsEntry 10 }\n etherStatsFragments OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The total number of packets received that were less
    than\n         64 octets in length (excluding framing bits but including\n         FCS
    octets) and had either a bad Frame Check Sequence\n         (FCS) with an integral
    number of octets (FCS Error) or a\n         bad FCS with a non-integral number
    of octets (Alignment\n         Error).\n         Note that it is entirely normal
    for etherStatsFragments to\n         increment.  This is because it counts both
    runts (which are\n         normal occurrences due to collisions) and noise hits.\"\n
    \    ::= { etherStatsEntry 11 }\n etherStatsJabbers OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The total number of packets received that were\n
    \        longer than 1518 octets (excluding framing bits,\n         but including
    FCS octets), and had either a bad\n         Frame Check Sequence (FCS) with an
    integral number\n         of octets (FCS Error) or a bad FCS with a non-integral\n
    \        number of octets (Alignment Error).\n         Note that this definition
    of jabber is different\n         than the definition in IEEE-802.3 section 8.2.1.5\n
    \        (10BASE5) and section 10.3.1.4 (10BASE2).  These\n         documents
    define jabber as the condition where any\n         packet exceeds 20 ms.  The
    allowed range to detect\n         jabber is between 20 ms and 150 ms.\"\n     ::=
    { etherStatsEntry 12 }\n etherStatsCollisions OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Collisions\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The best estimate of the total number of collisions\n
    \        on this Ethernet segment.\n         The value returned will depend on
    the location of the\n         RMON probe. Section 8.2.1.3 (10BASE-5) and section\n
    \        10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a\n         station
    must detect a collision, in the receive mode, if\n         three or more stations
    are transmitting simultaneously.  A\n         repeater port must detect a collision
    when two or more\n         stations are transmitting simultaneously.  Thus a probe\n
    \        placed on a repeater port could record more collisions\n         than
    a probe connected to a station on the same segment\n         would.\n         Probe
    location plays a much smaller role when considering\n         10BASE-T.  14.2.1.4
    (10BASE-T) of IEEE standard 802.3\n         defines a collision as the simultaneous
    presence of signals\n         on the DO and RD circuits (transmitting and receiving\n
    \        at the same time).  A 10BASE-T station can only detect\n         collisions
    when it is transmitting.  Thus probes placed on\n         a station and a repeater,
    should report the same number of\n         collisions.\n         Note also that
    an RMON probe inside a repeater should\n         ideally report collisions between
    the repeater and one or\n         more other hosts (transmit collisions as defined
    by IEEE\n         802.3k) plus receiver collisions observed on any coax\n         segments
    to which the repeater is connected.\"\n     ::= { etherStatsEntry 13 }\n etherStatsPkts64Octets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets (including bad\n         packets) received that were 64 octets in length\n
    \        (excluding framing bits but including FCS octets).\"\n     ::= { etherStatsEntry
    14 }\n etherStatsPkts65to127Octets OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The total number of packets (including bad\n         packets) received
    that were between\n         65 and 127 octets in length inclusive\n         (excluding
    framing bits but including FCS octets).\"\n     ::= { etherStatsEntry 15 }\n etherStatsPkts128to255Octets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets (including bad\n         packets) received that were between\n         128
    and 255 octets in length inclusive\n         (excluding framing bits but including
    FCS octets).\"\n     ::= { etherStatsEntry 16 }\n etherStatsPkts256to511Octets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets (including bad\n         packets) received that were between\n         256
    and 511 octets in length inclusive\n         (excluding framing bits but including
    FCS octets).\"\n     ::= { etherStatsEntry 17 }\n etherStatsPkts512to1023Octets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets (including bad\n         packets) received that were between\n         512
    and 1023 octets in length inclusive\n         (excluding framing bits but including
    FCS octets).\"\n     ::= { etherStatsEntry 18 }\n etherStatsPkts1024to1518Octets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The total number
    of packets (including bad\n         packets) received that were between\n         1024
    and 1518 octets in length inclusive\n         (excluding framing bits but including
    FCS octets).\"\n     ::= { etherStatsEntry 19 }\n etherStatsOwner OBJECT-TYPE\n
    \    SYNTAX     OwnerString\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The entity that configured this entry and is therefore\n
    \        using the resources assigned to it.\"\n     ::= { etherStatsEntry 20
    }\n etherStatsStatus OBJECT-TYPE\n     SYNTAX     EntryStatus\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The status
    of this etherStats entry.\"\n     ::= { etherStatsEntry 21 }\n -- The History
    Control Group\n -- Implementation of the History Control group is optional.\n
    -- Consult the MODULE-COMPLIANCE macro for the authoritative\n -- conformance
    information for this MIB.\n --\n -- The history control group controls the periodic
    statistical\n -- sampling of data from various types of networks.  The\n -- historyControlTable
    stores configuration entries that each\n -- define an interface, polling period,
    and other parameters.\n -- Once samples are taken, their data is stored in an
    entry\n -- in a media-specific table.  Each such entry defines one\n -- sample,
    and is associated with the historyControlEntry that\n -- caused the sample to
    be taken.  Each counter in the\n -- etherHistoryEntry counts the same event as
    its similarly-named\n -- counterpart in the etherStatsEntry, except that each
    value here\n -- is a cumulative sum during a sampling period.\n --\n -- If the
    probe keeps track of the time of day, it should start\n -- the first sample of
    the history at a time such that\n -- when the next hour of the day begins, a sample
    is\n -- started at that instant.  This tends to make more\n -- user-friendly reports,
    and enables comparison of reports\n -- from different probes that have relatively
    accurate time\n -- of day.\n --\n -- The probe is encouraged to add two history
    control entries\n -- per monitored interface upon initialization that describe
    a short\n -- term and a long term polling period.  Suggested parameters are 30\n
    -- seconds for the short term polling period and 30 minutes for\n -- the long
    term period.\n historyControlTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF HistoryControlEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    list of history control entries.\"\n     ::= { history 1 }\n historyControlEntry
    OBJECT-TYPE\n     SYNTAX     HistoryControlEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of parameters that
    set up a periodic sampling of\n         statistics.  As an example, an instance
    of the\n         historyControlInterval object might be named\n         historyControlInterval.2\"\n
    \    INDEX { historyControlIndex }\n     ::= { historyControlTable 1 }\n HistoryControlEntry
    ::= SEQUENCE {\n     historyControlIndex             Integer32,\n     historyControlDataSource
    \       OBJECT IDENTIFIER,\n     historyControlBucketsRequested  Integer32,\n
    \    historyControlBucketsGranted    Integer32,\n     historyControlInterval          Integer32,\n
    \    historyControlOwner             OwnerString,\n     historyControlStatus            EntryStatus\n
    }\n historyControlIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An index that
    uniquely identifies an entry in the\n         historyControl table.  Each such
    entry defines a\n         set of samples at a particular interval for an\n         interface
    on the device.\"\n     ::= { historyControlEntry 1 }\n historyControlDataSource
    OBJECT-TYPE\n     SYNTAX     OBJECT IDENTIFIER\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"This object identifies the
    source of the data for\n         which historical data was collected and\n         placed
    in a media-specific table on behalf of this\n         historyControlEntry.  This
    source can be any\n         interface on this device.  In order to identify\n
    \        a particular interface, this object shall identify\n         the instance
    of the ifIndex object, defined\n         in  RFC 2233 [17], for the desired interface.\n
    \        For example, if an entry were to receive data from\n         interface
    #1, this object would be set to ifIndex.1.\n         The statistics in this group
    reflect all packets\n         on the local network segment attached to the identified\n
    \        interface.\n         An agent may or may not be able to tell if fundamental\n
    \        changes to the media of the interface have occurred and\n         necessitate
    an invalidation of this entry.  For example, a\n         hot-pluggable ethernet
    card could be pulled out and replaced\n         by a token-ring card.  In such
    a case, if the agent has such\n         knowledge of the change, it is recommended
    that it\n         invalidate this entry.\n         This object may not be modified
    if the associated\n         historyControlStatus object is equal to valid(1).\"\n
    \    ::= { historyControlEntry 2 }\n historyControlBucketsRequested OBJECT-TYPE\n
    \    SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"The requested number of discrete time
    intervals\n         over which data is to be saved in the part of the\n         media-specific
    table associated with this\n         historyControlEntry.\n         When this
    object is created or modified, the probe\n         should set historyControlBucketsGranted
    as closely to\n         this object as is possible for the particular probe\n
    \        implementation and available resources.\"\n     DEFVAL { 50 }\n     ::=
    { historyControlEntry 3 }\n historyControlBucketsGranted OBJECT-TYPE\n     SYNTAX
    \    Integer32 (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of discrete sampling intervals\n         over
    which data shall be saved in the part of\n         the media-specific table associated
    with this\n         historyControlEntry.\n         When the associated historyControlBucketsRequested\n
    \        object is created or modified, the probe\n         should set this object
    as closely to the requested\n         value as is possible for the particular\n
    \        probe implementation and available resources.  The\n         probe must
    not lower this value except as a result\n         of a modification to the associated\n
    \        historyControlBucketsRequested object.\n         There will be times
    when the actual number of\n         buckets associated with this entry is less
    than\n         the value of this object.  In this case, at the\n         end of
    each sampling interval, a new bucket will\n         be added to the media-specific
    table.\n         When the number of buckets reaches the value of\n         this
    object and a new bucket is to be added to the\n         media-specific table,
    the oldest bucket associated\n         with this historyControlEntry shall be
    deleted by\n         the agent so that the new bucket can be added.\n         When
    the value of this object changes to a value less\n         than the current value,
    entries are deleted\n         from the media-specific table associated with this\n
    \        historyControlEntry.  Enough of the oldest of these\n         entries
    shall be deleted by the agent so that their\n         number remains less than
    or equal to the new value of\n         this object.\n         When the value of
    this object changes to a value greater\n         than the current value, the number
    of associated media-\n         specific entries may be allowed to grow.\"\n     ::=
    { historyControlEntry 4 }\n historyControlInterval OBJECT-TYPE\n     SYNTAX     Integer32
    (1..3600)\n     UNITS      \"Seconds\"\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"The interval in seconds over which
    the data is\n         sampled for each bucket in the part of the\n         media-specific
    table associated with this\n         historyControlEntry.  This interval can\n
    \        be set to any number of seconds between 1 and\n         3600 (1 hour).\n
    \        Because the counters in a bucket may overflow at their\n         maximum
    value with no indication, a prudent manager will\n         take into account the
    possibility of overflow in any of\n         the associated counters.  It is important
    to consider the\n         minimum time in which any counter could overflow on
    a\n         particular media type and set the historyControlInterval\n         object
    to a value less than this interval.  This is\n         typically most important
    for the 'octets' counter in any\n         media-specific table.  For example,
    on an Ethernet\n         network, the etherHistoryOctets counter could overflow\n
    \        in about one hour at the Ethernet's maximum\n         utilization.\n
    \        This object may not be modified if the associated\n         historyControlStatus
    object is equal to valid(1).\"\n     DEFVAL { 1800 }\n     ::= { historyControlEntry
    5 }\n historyControlOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The entity
    that configured this entry and is therefore\n         using the resources assigned
    to it.\"\n     ::= { historyControlEntry 6 }\n historyControlStatus OBJECT-TYPE\n
    \    SYNTAX     EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The status of this historyControl entry.\n         Each
    instance of the media-specific table associated\n         with this historyControlEntry
    will be deleted by the agent\n         if this historyControlEntry is not equal
    to valid(1).\"\n     ::= { historyControlEntry 7 }\n -- The Ethernet History Group\n
    -- Implementation of the Ethernet History group is optional.\n -- Consult the
    MODULE-COMPLIANCE macro for the authoritative\n -- conformance information for
    this MIB.\n --\n -- The Ethernet History group records periodic statistical samples\n
    -- from a network and stores them for later retrieval.\n -- Once samples are taken,
    their data is stored in an entry\n -- in a media-specific table.  Each such entry
    defines one\n -- sample, and is associated with the historyControlEntry that\n
    -- caused the sample to be taken.  This group defines the\n -- etherHistoryTable,
    for Ethernet networks.\n --\n etherHistoryTable OBJECT-TYPE\n     SYNTAX     SEQUENCE
    OF EtherHistoryEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n
    \    DESCRIPTION\n         \"A list of Ethernet history entries.\"\n     ::= {
    history 2 }\n etherHistoryEntry OBJECT-TYPE\n     SYNTAX     EtherHistoryEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"An
    historical sample of Ethernet statistics on a particular\n         Ethernet interface.
    \ This sample is associated with the\n         historyControlEntry which set up
    the parameters for\n         a regular collection of these samples.  As an example,
    an\n         instance of the etherHistoryPkts object might be named\n         etherHistoryPkts.2.89\"\n
    \    INDEX { etherHistoryIndex , etherHistorySampleIndex }\n     ::= { etherHistoryTable
    1 }\n EtherHistoryEntry ::= SEQUENCE {\n     etherHistoryIndex                 Integer32,\n
    \    etherHistorySampleIndex           Integer32,\n     etherHistoryIntervalStart
    \        TimeTicks,\n     etherHistoryDropEvents            Counter32,\n     etherHistoryOctets
    \               Counter32,\n     etherHistoryPkts                  Counter32,\n
    \    etherHistoryBroadcastPkts         Counter32,\n     etherHistoryMulticastPkts
    \        Counter32,\n     etherHistoryCRCAlignErrors        Counter32,\n     etherHistoryUndersizePkts
    \        Counter32,\n     etherHistoryOversizePkts          Counter32,\n     etherHistoryFragments
    \            Counter32,\n     etherHistoryJabbers               Counter32,\n     etherHistoryCollisions
    \           Counter32,\n     etherHistoryUtilization           Integer32\n }\n
    etherHistoryIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The history of
    which this entry is a part.  The\n         history identified by a particular
    value of this\n         index is the same history as identified\n         by the
    same value of historyControlIndex.\"\n     ::= { etherHistoryEntry 1 }\n etherHistorySampleIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..2147483647)\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"An index that uniquely identifies
    the particular\n         sample this entry represents among all samples\n         associated
    with the same historyControlEntry.\n         This index starts at 1 and increases
    by one\n         as each new sample is taken.\"\n     ::= { etherHistoryEntry
    2 }\n etherHistoryIntervalStart OBJECT-TYPE\n     SYNTAX     TimeTicks\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The value of
    sysUpTime at the start of the interval\n         over which this sample was measured.
    \ If the probe\n         keeps track of the time of day, it should start\n         the
    first sample of the history at a time such that\n         when the next hour of
    the day begins, a sample is\n         started at that instant.  Note that following
    this\n         rule may require the probe to delay collecting the\n         first
    sample of the history, as each sample must be\n         of the same interval.
    \ Also note that the sample which\n         is currently being collected is not
    accessible in this\n         table until the end of its interval.\"\n     ::=
    { etherHistoryEntry 3 }\n etherHistoryDropEvents OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    total number of events in which packets\n         were dropped by the probe due
    to lack of resources\n         during this sampling interval.  Note that this
    number\n         is not necessarily the number of packets dropped, it\n         is
    just the number of times this condition has been\n         detected.\"\n     ::=
    { etherHistoryEntry 4 }\n etherHistoryOctets OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Octets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The total number of octets of data (including\n         those
    in bad packets) received on the\n         network (excluding framing bits but
    including\n         FCS octets).\"\n     ::= { etherHistoryEntry 5 }\n etherHistoryPkts
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    packets (including bad packets)\n         received during this sampling interval.\"\n
    \    ::= { etherHistoryEntry 6 }\n etherHistoryBroadcastPkts OBJECT-TYPE\n     SYNTAX
    \    Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The number of good packets received
    during this\n         sampling interval that were directed to the\n         broadcast
    address.\"\n     ::= { etherHistoryEntry 7 }\n etherHistoryMulticastPkts OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of good packets
    received during this\n         sampling interval that were directed to a\n         multicast
    address.  Note that this number does not\n         include packets addressed to
    the broadcast address.\"\n     ::= { etherHistoryEntry 8 }\n etherHistoryCRCAlignErrors
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    packets received during this\n         sampling interval that had a length (excluding\n
    \        framing bits but including FCS octets) between\n         64 and 1518
    octets, inclusive, but had either a bad Frame\n         Check Sequence (FCS) with
    an integral number of octets\n         (FCS Error) or a bad FCS with a non-integral
    number\n         of octets (Alignment Error).\"\n     ::= { etherHistoryEntry
    9 }\n etherHistoryUndersizePkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The number of packets received during this\n         sampling interval
    that were less than 64 octets\n         long (excluding framing bits but including
    FCS\n         octets) and were otherwise well formed.\"\n     ::= { etherHistoryEntry
    10 }\n etherHistoryOversizePkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The number of packets received during this\n         sampling interval
    that were longer than 1518\n         octets (excluding framing bits but including\n
    \        FCS octets) but were otherwise well formed.\"\n     ::= { etherHistoryEntry
    11 }\n etherHistoryFragments OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The total number of packets received during this\n         sampling
    interval that were less than 64 octets in\n         length (excluding framing
    bits but including FCS\n         octets) had either a bad Frame Check Sequence
    (FCS)\n         with an integral number of octets (FCS Error) or a bad\n         FCS
    with a non-integral number of octets (Alignment\n         Error).\n         Note
    that it is entirely normal for etherHistoryFragments to\n         increment.  This
    is because it counts both runts (which are\n         normal occurrences due to
    collisions) and noise hits.\"\n     ::= { etherHistoryEntry 12 }\n etherHistoryJabbers
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    packets received during this\n         sampling interval that were longer than
    1518 octets\n         (excluding framing bits but including FCS octets),\n         and
    \ had either a bad Frame Check Sequence (FCS)\n         with an integral number
    of octets (FCS Error) or\n         a bad FCS with a non-integral number of octets\n
    \        (Alignment Error).\n         Note that this definition of jabber is different\n
    \        than the definition in IEEE-802.3 section 8.2.1.5\n         (10BASE5)
    and section 10.3.1.4 (10BASE2).  These\n         documents define jabber as the
    condition where any\n         packet exceeds 20 ms.  The allowed range to detect\n
    \        jabber is between 20 ms and 150 ms.\"\n     ::= { etherHistoryEntry 13
    }\n etherHistoryCollisions OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Collisions\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The best estimate of the total number of collisions\n         on this
    Ethernet segment during this sampling\n         interval.\n         The value
    returned will depend on the location of the\n         RMON probe. Section 8.2.1.3
    (10BASE-5) and section\n         10.3.1.3 (10BASE-2) of IEEE standard 802.3 states
    that a\n         station must detect a collision, in the receive mode, if\n         three
    or more stations are transmitting simultaneously.  A\n         repeater port must
    detect a collision when two or more\n         stations are transmitting simultaneously.
    \ Thus a probe\n         placed on a repeater port could record more collisions\n
    \        than a probe connected to a station on the same segment\n         would.\n
    \        Probe location plays a much smaller role when considering\n         10BASE-T.
    \ 14.2.1.4 (10BASE-T) of IEEE standard 802.3\n         defines a collision as
    the simultaneous presence of signals\n         on the DO and RD circuits (transmitting
    and receiving\n         at the same time).  A 10BASE-T station can only detect\n
    \        collisions when it is transmitting.  Thus probes placed on\n         a
    station and a repeater, should report the same number of\n         collisions.\n
    \        Note also that an RMON probe inside a repeater should\n         ideally
    report collisions between the repeater and one or\n         more other hosts (transmit
    collisions as defined by IEEE\n         802.3k) plus receiver collisions observed
    on any coax\n         segments to which the repeater is connected.\"\n     ::=
    { etherHistoryEntry 14 }\n etherHistoryUtilization OBJECT-TYPE\n     SYNTAX     Integer32
    (0..10000)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The best estimate of the mean physical layer\n         network utilization
    on this interface during this\n         sampling interval, in hundredths of a
    percent.\"\n     ::= { etherHistoryEntry 15 }\n -- The Alarm Group\n -- Implementation
    of the Alarm group is optional. The Alarm Group\n -- requires the implementation
    of the Event group.\n -- Consult the MODULE-COMPLIANCE macro for the authoritative\n
    -- conformance information for this MIB.\n --\n -- The Alarm group periodically
    takes statistical samples from\n -- variables in the probe and compares them to
    thresholds that have\n -- been configured.  The alarm table stores configuration\n
    -- entries that each define a variable, polling period, and\n -- threshold parameters.
    \ If a sample is found to cross the\n -- threshold values, an event is generated.
    \ Only variables that\n -- resolve to an ASN.1 primitive type of INTEGER (INTEGER,
    Integer32,\n -- Counter32, Counter64, Gauge32, or TimeTicks) may be monitored
    in\n -- this way.\n --\n -- This function has a hysteresis mechanism to limit
    the generation\n -- of events.  This mechanism generates one event as a threshold\n
    -- is crossed in the appropriate direction.  No more events are\n -- generated
    for that threshold until the opposite threshold is\n -- crossed.\n --\n -- In
    the case of a sampling a deltaValue, a probe may implement\n -- this mechanism
    with more precision if it takes a delta sample\n -- twice per period, each time
    comparing the sum of the latest two\n -- samples to the threshold.  This allows
    the detection of threshold\n -- crossings that span the sampling boundary.  Note
    that this does\n -- not require any special configuration of the threshold value.\n
    -- It is suggested that probes implement this more precise algorithm.\n alarmTable
    OBJECT-TYPE\n     SYNTAX     SEQUENCE OF AlarmEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of alarm entries.\"\n
    \    ::= { alarm 1 }\n alarmEntry OBJECT-TYPE\n     SYNTAX     AlarmEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A list of
    parameters that set up a periodic checking\n         for alarm conditions.  For
    example, an instance of the\n         alarmValue object might be named alarmValue.8\"\n
    \    INDEX { alarmIndex }\n     ::= { alarmTable 1 }\n AlarmEntry ::= SEQUENCE
    {\n     alarmIndex                    Integer32,\n     alarmInterval                 Integer32,\n
    \    alarmVariable                 OBJECT IDENTIFIER,\n     alarmSampleType               INTEGER,\n
    \    alarmValue                    Integer32,\n     alarmStartupAlarm             INTEGER,\n
    \    alarmRisingThreshold          Integer32,\n     alarmFallingThreshold         Integer32,\n
    \    alarmRisingEventIndex         Integer32,\n     alarmFallingEventIndex        Integer32,\n
    \    alarmOwner                    OwnerString,\n     alarmStatus                   EntryStatus\n
    }\n alarmIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An index that
    uniquely identifies an entry in the\n         alarm table.  Each such entry defines
    a\n         diagnostic sample at a particular interval\n         for an object
    on the device.\"\n     ::= { alarmEntry 1 }\n alarmInterval OBJECT-TYPE\n     SYNTAX
    \    Integer32\n     UNITS      \"Seconds\"\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"The interval in seconds over which
    the data is\n         sampled and compared with the rising and falling\n         thresholds.
    \ When setting this variable, care\n         should be taken in the case of deltaValue\n
    \        sampling - the interval should be set short enough\n         that the
    sampled variable is very unlikely to\n         increase or decrease by more than
    2^31 - 1 during\n         a single sampling interval.\n         This object may
    not be modified if the associated\n         alarmStatus object is equal to valid(1).\"\n
    \    ::= { alarmEntry 2 }\n alarmVariable OBJECT-TYPE\n     SYNTAX     OBJECT
    IDENTIFIER\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The object identifier of the particular variable to be\n         sampled.
    \ Only variables that resolve to an ASN.1 primitive\n         type of INTEGER
    (INTEGER, Integer32, Counter32, Counter64,\n         Gauge, or TimeTicks) may
    be sampled.\n         Because SNMP access control is articulated entirely\n         in
    terms of the contents of MIB views, no access\n         control mechanism exists
    that can restrict the value of\n         this object to identify only those objects
    that exist\n         in a particular MIB view.  Because there is thus no\n         acceptable
    means of restricting the read access that\n         could be obtained through
    the alarm mechanism, the\n         probe must only grant write access to this
    object in\n         those views that have read access to all objects on\n         the
    probe.\n         During a set operation, if the supplied variable name is\n         not
    available in the selected MIB view, a badValue error\n         must be returned.
    \ If at any time the variable name of\n         an established alarmEntry is no
    longer available in the\n         selected MIB view, the probe must change the
    status of\n         this alarmEntry to invalid(4).\n         This object may not
    be modified if the associated\n         alarmStatus object is equal to valid(1).\"\n
    \    ::= { alarmEntry 3 }\n alarmSampleType OBJECT-TYPE\n     SYNTAX     INTEGER
    {\n                  absoluteValue(1),\n                  deltaValue(2)\n                }\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    method of sampling the selected variable and\n         calculating the value to
    be compared against the\n         thresholds.  If the value of this object is\n
    \        absoluteValue(1), the value of the selected variable\n         will be
    compared directly with the thresholds at the\n         end of the sampling interval.
    \ If the value of this\n         object is deltaValue(2), the value of the selected\n
    \        variable at the last sample will be subtracted from\n         the current
    value, and the difference compared with\n         the thresholds.\n         This
    object may not be modified if the associated\n         alarmStatus object is equal
    to valid(1).\"\n     ::= { alarmEntry 4 }\n alarmValue OBJECT-TYPE\n     SYNTAX
    \    Integer32\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The value of the statistic during the last sampling\n         period.
    \ For example, if the sample type is deltaValue,\n         this value will be
    the difference between the samples\n         at the beginning and end of the period.
    \ If the sample\n         type is absoluteValue, this value will be the sampled\n
    \        value at the end of the period.\n         This is the value that is compared
    with the rising and\n         falling thresholds.\n         The value during the
    current sampling period is not\n         made available until the period is completed
    and will\n         remain available until the next period completes.\"\n     ::=
    { alarmEntry 5 }\n alarmStartupAlarm OBJECT-TYPE\n     SYNTAX     INTEGER {\n
    \                 risingAlarm(1),\n                  fallingAlarm(2),\n                  risingOrFallingAlarm(3)\n
    \               }\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The alarm that may be sent when this entry is first\n         set to
    valid.  If the first sample after this entry\n         becomes valid is greater
    than or equal to the\n         risingThreshold and alarmStartupAlarm is equal
    to\n         risingAlarm(1) or risingOrFallingAlarm(3), then a single\n         rising
    alarm will be generated.  If the first sample\n         after this entry becomes
    valid is less than or equal\n         to the fallingThreshold and alarmStartupAlarm
    is equal\n         to fallingAlarm(2) or risingOrFallingAlarm(3), then a\n         single
    falling alarm will be generated.\n         This object may not be modified if
    the associated\n         alarmStatus object is equal to valid(1).\"\n     ::=
    { alarmEntry 6 }\n alarmRisingThreshold OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"A
    threshold for the sampled statistic.  When the current\n         sampled value
    is greater than or equal to this threshold,\n         and the value at the last
    sampling interval was less than\n         this threshold, a single event will
    be generated.\n         A single event will also be generated if the first\n         sample
    after this entry becomes valid is greater than or\n         equal to this threshold
    and the associated\n         alarmStartupAlarm is equal to risingAlarm(1) or\n
    \        risingOrFallingAlarm(3).\n         After a rising event is generated,
    another such event\n         will not be generated until the sampled value\n         falls
    below this threshold and reaches the\n         alarmFallingThreshold.\n         This
    object may not be modified if the associated\n         alarmStatus object is equal
    to valid(1).\"\n     ::= { alarmEntry 7 }\n alarmFallingThreshold OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"A threshold for the sampled statistic.  When the
    current\n         sampled value is less than or equal to this threshold,\n         and
    the value at the last sampling interval was greater than\n         this threshold,
    a single event will be generated.\n         A single event will also be generated
    if the first\n         sample after this entry becomes valid is less than or\n
    \        equal to this threshold and the associated\n         alarmStartupAlarm
    is equal to fallingAlarm(2) or\n         risingOrFallingAlarm(3).\n         After
    a falling event is generated, another such event\n         will not be generated
    until the sampled value\n         rises above this threshold and reaches the\n
    \        alarmRisingThreshold.\n         This object may not be modified if the
    associated\n         alarmStatus object is equal to valid(1).\"\n     ::= { alarmEntry
    8 }\n alarmRisingEventIndex OBJECT-TYPE\n     SYNTAX     Integer32 (0..65535)\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    index of the eventEntry that is\n         used when a rising threshold is crossed.
    \ The\n         eventEntry identified by a particular value of\n         this
    index is the same as identified by the same value\n         of the eventIndex
    object.  If there is no\n         corresponding entry in the eventTable, then\n
    \        no association exists.  In particular, if this value\n         is zero,
    no associated event will be generated, as\n         zero is not a valid event
    index.\n         This object may not be modified if the associated\n         alarmStatus
    object is equal to valid(1).\"\n     ::= { alarmEntry 9 }\n alarmFallingEventIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (0..65535)\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The index of the eventEntry
    that is\n         used when a falling threshold is crossed.  The\n         eventEntry
    identified by a particular value of\n         this index is the same as identified
    by the same value\n         of the eventIndex object.  If there is no\n         corresponding
    entry in the eventTable, then\n         no association exists.  In particular,
    if this value\n         is zero, no associated event will be generated, as\n         zero
    is not a valid event index.\n         This object may not be modified if the associated\n
    \        alarmStatus object is equal to valid(1).\"\n     ::= { alarmEntry 10
    }\n alarmOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The entity that configured
    this entry and is therefore\n         using the resources assigned to it.\"\n
    \    ::= { alarmEntry 11 }\n alarmStatus OBJECT-TYPE\n     SYNTAX     EntryStatus\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    status of this alarm entry.\"\n     ::= { alarmEntry 12 }\n -- The Host Group\n
    -- Implementation of the Host group is optional.\n -- Consult the MODULE-COMPLIANCE
    macro for the authoritative\n -- conformance information for this MIB.\n --\n
    -- The host group discovers new hosts on the network by\n -- keeping a list of
    source and destination MAC Addresses seen\n -- in good packets.  For each of these
    addresses, the host group\n -- keeps a set of statistics.  The hostControlTable
    controls\n -- which interfaces this function is performed on, and contains\n --
    some information about the process.  On behalf of each\n -- hostControlEntry,
    data is collected on an interface and placed\n -- in both the hostTable and the
    hostTimeTable.  If the\n -- monitoring device finds itself short of resources,
    it may\n -- delete entries as needed.  It is suggested that the device\n -- delete
    the least recently used entries first.\n -- The hostTable contains entries for
    each address discovered on\n -- a particular interface.  Each entry contains statistical\n
    -- data about that host.  This table is indexed by the\n -- MAC address of the
    host, through which a random access\n -- may be achieved.\n -- The hostTimeTable
    contains data in the same format as the\n -- hostTable, and must contain the same
    set of hosts, but is\n -- indexed using hostTimeCreationOrder rather than hostAddress.\n
    -- The hostTimeCreationOrder is an integer which reflects\n -- the relative order
    in which a particular entry was discovered\n -- and thus inserted into the table.
    \ As this order, and thus\n -- the index, is among those entries currently in
    the table,\n -- the index for a particular entry may change if an\n -- (earlier)
    entry is deleted.  Thus the association between\n -- hostTimeCreationOrder and
    hostTimeEntry may be broken at\n -- any time.\n -- The hostTimeTable has two important
    uses.  The first is the\n -- fast download of this potentially large table.  Because
    the\n -- index of this table runs from 1 to the size of the table,\n -- inclusive,
    its values are predictable.  This allows very\n -- efficient packing of variables
    into SNMP PDU's and allows\n -- a table transfer to have multiple packets outstanding.\n
    -- These benefits increase transfer rates tremendously.\n -- The second use of
    the hostTimeTable is the efficient discovery\n -- by the management station of
    new entries added to the table.\n -- After the management station has downloaded
    the entire table,\n -- it knows that new entries will be added immediately after
    the\n -- end of the current table.  It can thus detect new entries there\n --
    and retrieve them easily.\n -- Because the association between hostTimeCreationOrder
    and\n -- hostTimeEntry may be broken at any time, the management\n -- station
    must monitor the related hostControlLastDeleteTime\n -- object.  When the management
    station thus detects a deletion,\n -- it must assume that any such associations
    have been broken,\n -- and invalidate any it has stored locally.  This includes\n
    -- restarting any download of the hostTimeTable that may have been\n -- in progress,
    as well as rediscovering the end of the\n -- hostTimeTable so that it may detect
    new entries.  If the\n -- management station does not detect the broken association,\n
    -- it may continue to refer to a particular host by its\n -- creationOrder while
    unwittingly retrieving the data associated\n -- with another host entirely.  If
    this happens while downloading\n -- the host table, the management station may
    fail to download\n -- all of the entries in the table.\n hostControlTable OBJECT-TYPE\n
    \    SYNTAX     SEQUENCE OF HostControlEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of host table control
    entries.\"\n     ::= { hosts 1 }\n hostControlEntry OBJECT-TYPE\n     SYNTAX     HostControlEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    list of parameters that set up the discovery of hosts\n         on a particular
    interface and the collection of statistics\n         about these hosts.  For example,
    an instance of the\n         hostControlTableSize object might be named\n         hostControlTableSize.1\"\n
    \    INDEX { hostControlIndex }\n     ::= { hostControlTable 1 }\n HostControlEntry
    ::= SEQUENCE {\n     hostControlIndex            Integer32,\n     hostControlDataSource
    \      OBJECT IDENTIFIER,\n     hostControlTableSize        Integer32,\n     hostControlLastDeleteTime
    \  TimeTicks,\n     hostControlOwner            OwnerString,\n     hostControlStatus
    \          EntryStatus\n }\n hostControlIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"An index that uniquely identifies an entry in the\n         hostControl
    table.  Each such entry defines\n         a function that discovers hosts on a
    particular interface\n         and places statistics about them in the hostTable
    and\n         the hostTimeTable on behalf of this hostControlEntry.\"\n     ::=
    { hostControlEntry 1 }\n hostControlDataSource OBJECT-TYPE\n     SYNTAX     OBJECT
    IDENTIFIER\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"This object identifies the source of the data for\n         this instance
    of the host function.  This source\n         can be any interface on this device.
    \ In order\n         to identify a particular interface, this object shall\n         identify
    the instance of the ifIndex object, defined\n         in RFC 2233 [17], for the
    desired interface.\n         For example, if an entry were to receive data from\n
    \        interface #1, this object would be set to ifIndex.1.\n         The statistics
    in this group reflect all packets\n         on the local network segment attached
    to the identified\n         interface.\n         An agent may or may not be able
    to tell if fundamental\n         changes to the media of the interface have occurred
    and\n         necessitate an invalidation of this entry.  For example, a\n         hot-pluggable
    ethernet card could be pulled out and replaced\n         by a token-ring card.
    \ In such a case, if the agent has such\n         knowledge of the change, it
    is recommended that it\n         invalidate this entry.\n         This object
    may not be modified if the associated\n         hostControlStatus object is equal
    to valid(1).\"\n     ::= { hostControlEntry 2 }\n hostControlTableSize OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of hostEntries in the hostTable and the\n
    \        hostTimeTable associated with this hostControlEntry.\"\n     ::= { hostControlEntry
    3 }\n hostControlLastDeleteTime OBJECT-TYPE\n     SYNTAX     TimeTicks\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The value of
    sysUpTime when the last entry\n         was deleted from the portion of the hostTable\n
    \        associated with this hostControlEntry.  If no\n         deletions have
    occurred, this value shall be zero.\"\n     ::= { hostControlEntry 4 }\n hostControlOwner
    OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"The entity that configured this entry
    and is therefore\n         using the resources assigned to it.\"\n     ::= { hostControlEntry
    5 }\n hostControlStatus OBJECT-TYPE\n     SYNTAX     EntryStatus\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The status
    of this hostControl entry.\n         If this object is not equal to valid(1),
    all associated\n         entries in the hostTable, hostTimeTable, and the\n         hostTopNTable
    shall be deleted by the agent.\"\n     ::= { hostControlEntry 6 }\n hostTable
    OBJECT-TYPE\n     SYNTAX     SEQUENCE OF HostEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of host entries.\"\n
    \    ::= { hosts 2 }\n hostEntry OBJECT-TYPE\n     SYNTAX     HostEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A collection
    of statistics for a particular host that has\n         been discovered on an interface
    of this device.  For example,\n         an instance of the hostOutBroadcastPkts
    object might be\n         named hostOutBroadcastPkts.1.6.8.0.32.27.3.176\"\n     INDEX
    { hostIndex, hostAddress }\n     ::= { hostTable 1 }\n HostEntry ::= SEQUENCE
    {\n     hostAddress             OCTET STRING,\n     hostCreationOrder       Integer32,\n
    \    hostIndex               Integer32,\n     hostInPkts              Counter32,\n
    \    hostOutPkts             Counter32,\n     hostInOctets            Counter32,\n
    \    hostOutOctets           Counter32,\n     hostOutErrors           Counter32,\n
    \    hostOutBroadcastPkts    Counter32,\n     hostOutMulticastPkts    Counter32\n
    }\n hostAddress OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The physical address of
    this host.\"\n     ::= { hostEntry 1 }\n hostCreationOrder OBJECT-TYPE\n     SYNTAX
    \    Integer32 (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"An index that defines the relative ordering of\n
    \        the creation time of hosts captured for a\n         particular hostControlEntry.
    \ This index shall\n         be between 1 and N, where N is the value of\n         the
    associated hostControlTableSize.  The ordering\n         of the indexes is based
    on the order of each entry's\n         insertion into the table, in which entries
    added earlier\n         have a lower index value than entries added later.\n         It
    is important to note that the order for a\n         particular entry may change
    as an (earlier) entry\n         is deleted from the table.  Because this order
    may\n         change, management stations should make use of the\n         hostControlLastDeleteTime
    variable in the\n         hostControlEntry associated with the relevant\n         portion
    of the hostTable.  By observing\n         this variable, the management station
    may detect\n         the circumstances where a previous association\n         between
    a value of hostCreationOrder\n         and a hostEntry may no longer hold.\"\n
    \    ::= { hostEntry 2 }\n hostIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    set of collected host statistics of which\n         this entry is a part.  The
    set of hosts\n         identified by a particular value of this\n         index
    is associated with the hostControlEntry\n         as identified by the same value
    of hostControlIndex.\"\n     ::= { hostEntry 3 }\n hostInPkts OBJECT-TYPE\n     SYNTAX
    \    Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The number of good packets transmitted
    to this\n         address since it was added to the hostTable.\"\n     ::= { hostEntry
    4 }\n hostOutPkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    number of packets, including bad packets, transmitted\n         by this address
    since it was added to the hostTable.\"\n     ::= { hostEntry 5 }\n hostInOctets
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Octets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    octets transmitted to this address since\n         it was added to the hostTable
    (excluding framing\n         bits but including FCS octets), except for those\n
    \        octets in bad packets.\"\n     ::= { hostEntry 6 }\n hostOutOctets OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of octets transmitted
    by this address since\n         it was added to the hostTable (excluding framing\n
    \        bits but including FCS octets), including those\n         octets in bad
    packets.\"\n     ::= { hostEntry 7 }\n hostOutErrors OBJECT-TYPE\n     SYNTAX
    \    Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The number of bad packets transmitted
    by this address\n         since this host was added to the hostTable.\"\n     ::=
    { hostEntry 8 }\n hostOutBroadcastPkts OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of good packets transmitted by this\n
    \        address that were directed to the broadcast address\n         since this
    host was added to the hostTable.\"\n     ::= { hostEntry 9 }\n hostOutMulticastPkts
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    good packets transmitted by this\n         address that were directed to a multicast
    address\n         since this host was added to the hostTable.\n         Note that
    this number does not include packets\n         directed to the broadcast address.\"\n
    \    ::= { hostEntry 10 }\n -- host Time Table\n hostTimeTable OBJECT-TYPE\n     SYNTAX
    \    SEQUENCE OF HostTimeEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n
    \    DESCRIPTION\n         \"A list of time-ordered host table entries.\"\n     ::=
    { hosts 3 }\n hostTimeEntry OBJECT-TYPE\n     SYNTAX     HostTimeEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A collection
    of statistics for a particular host that has\n         been discovered on an interface
    of this device.  This\n         collection includes the relative ordering of the
    creation\n         time of this object.  For example, an instance of the\n         hostTimeOutBroadcastPkts
    object might be named\n         hostTimeOutBroadcastPkts.1.687\"\n     INDEX {
    hostTimeIndex, hostTimeCreationOrder }\n     ::= { hostTimeTable 1 }\n HostTimeEntry
    ::= SEQUENCE {\n     hostTimeAddress              OCTET STRING,\n     hostTimeCreationOrder
    \       Integer32,\n     hostTimeIndex                Integer32,\n     hostTimeInPkts
    \              Counter32,\n     hostTimeOutPkts              Counter32,\n     hostTimeInOctets
    \            Counter32,\n     hostTimeOutOctets            Counter32,\n     hostTimeOutErrors
    \           Counter32,\n     hostTimeOutBroadcastPkts     Counter32,\n     hostTimeOutMulticastPkts
    \    Counter32\n }\n hostTimeAddress OBJECT-TYPE\n     SYNTAX     OCTET STRING\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    physical address of this host.\"\n     ::= { hostTimeEntry 1 }\n hostTimeCreationOrder
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"An index that uniquely identifies
    an entry in\n         the hostTime table among those entries associated\n         with
    the same hostControlEntry.  This index shall\n         be between 1 and N, where
    N is the value of\n         the associated hostControlTableSize.  The ordering\n
    \        of the indexes is based on the order of each entry's\n         insertion
    into the table, in which entries added earlier\n         have a lower index value
    than entries added later.\n         Thus the management station has the ability
    to\n         learn of new entries added to this table without\n         downloading
    the entire table.\n         It is important to note that the index for a\n         particular
    entry may change as an (earlier) entry\n         is deleted from the table.  Because
    this order may\n         change, management stations should make use of the\n
    \        hostControlLastDeleteTime variable in the\n         hostControlEntry
    associated with the relevant\n         portion of the hostTimeTable.  By observing\n
    \        this variable, the management station may detect\n         the circumstances
    where a download of the table\n         may have missed entries, and where a previous\n
    \        association between a value of hostTimeCreationOrder\n         and a
    hostTimeEntry may no longer hold.\"\n     ::= { hostTimeEntry 2 }\n hostTimeIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The set of collected host
    statistics of which\n         this entry is a part.  The set of hosts\n         identified
    by a particular value of this\n         index is associated with the hostControlEntry\n
    \        as identified by the same value of hostControlIndex.\"\n     ::= { hostTimeEntry
    3 }\n hostTimeInPkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    number of good packets transmitted to this\n         address since it was added
    to the hostTimeTable.\"\n     ::= { hostTimeEntry 4 }\n hostTimeOutPkts OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of packets, including
    bad packets, transmitted\n         by this address since it was added to the hostTimeTable.\"\n
    \    ::= { hostTimeEntry 5 }\n hostTimeInOctets OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Octets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of octets transmitted to this address
    since\n         it was added to the hostTimeTable (excluding framing\n         bits
    but including FCS octets), except for those\n         octets in bad packets.\"\n
    \    ::= { hostTimeEntry 6 }\n hostTimeOutOctets OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Octets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of octets transmitted by this address
    since\n         it was added to the hostTimeTable (excluding framing\n         bits
    but including FCS octets), including those\n         octets in bad packets.\"\n
    \    ::= { hostTimeEntry 7 }\n hostTimeOutErrors OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of bad packets transmitted by this address\n
    \        since this host was added to the hostTimeTable.\"\n     ::= { hostTimeEntry
    8 }\n hostTimeOutBroadcastPkts OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS
    \     \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The number of good packets transmitted by this\n         address that
    were directed to the broadcast address\n         since this host was added to
    the hostTimeTable.\"\n     ::= { hostTimeEntry 9 }\n hostTimeOutMulticastPkts
    OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    good packets transmitted by this\n         address that were directed to a multicast
    address\n         since this host was added to the hostTimeTable.\n         Note
    that this number does not include packets directed\n         to the broadcast
    address.\"\n     ::= { hostTimeEntry 10 }\n -- The Host Top \"N\" Group\n -- Implementation
    of the Host Top N group is optional. The Host Top N\n -- group requires the implementation
    of the host group.\n -- Consult the MODULE-COMPLIANCE macro for the authoritative\n
    -- conformance information for this MIB.\n --\n -- The Host Top N group is used
    to prepare reports that describe\n -- the hosts that top a list ordered by one
    of their statistics.\n -- The available statistics are samples of one of their\n
    -- base statistics, over an interval specified by the management\n -- station.
    \ Thus, these statistics are rate based.  The management\n -- station also selects
    how many such hosts are reported.\n -- The hostTopNControlTable is used to initiate
    the generation of\n -- such a report.  The management station may select the parameters\n
    -- of such a report, such as which interface, which statistic,\n -- how many hosts,
    and the start and stop times of the sampling.\n -- When the report is prepared,
    entries are created in the\n -- hostTopNTable associated with the relevant hostTopNControlEntry.\n
    -- These entries are static for each report after it has been\n -- prepared.\n
    hostTopNControlTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF HostTopNControlEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    list of top N host control entries.\"\n     ::= { hostTopN 1 }\n hostTopNControlEntry
    OBJECT-TYPE\n     SYNTAX     HostTopNControlEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A set of parameters that
    control the creation of a report\n         of the top N hosts according to several
    metrics.  For\n         example, an instance of the hostTopNDuration object might\n
    \        be named hostTopNDuration.3\"\n     INDEX { hostTopNControlIndex }\n
    \    ::= { hostTopNControlTable 1 }\n HostTopNControlEntry ::= SEQUENCE {\n     hostTopNControlIndex
    \   Integer32,\n     hostTopNHostIndex       Integer32,\n     hostTopNRateBase
    \       INTEGER,\n     hostTopNTimeRemaining   Integer32,\n     hostTopNDuration
    \       Integer32,\n     hostTopNRequestedSize   Integer32,\n     hostTopNGrantedSize
    \    Integer32,\n     hostTopNStartTime       TimeTicks,\n     hostTopNOwner           OwnerString,\n
    \    hostTopNStatus          EntryStatus\n }\n hostTopNControlIndex OBJECT-TYPE\n
    \    SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"An index that uniquely identifies an entry\n         in
    the hostTopNControl table.  Each such\n         entry defines one top N report
    prepared for\n         one interface.\"\n     ::= { hostTopNControlEntry 1 }\n
    hostTopNHostIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The host table
    for which a top N report will be prepared\n         on behalf of this entry.  The
    host table identified by a\n         particular value of this index is associated
    with the same\n         host table as identified by the same value of\n         hostIndex.\n
    \        This object may not be modified if the associated\n         hostTopNStatus
    object is equal to valid(1).\"\n     ::= { hostTopNControlEntry 2 }\n hostTopNRateBase
    OBJECT-TYPE\n     SYNTAX     INTEGER {\n                  hostTopNInPkts(1),\n
    \                 hostTopNOutPkts(2),\n                  hostTopNInOctets(3),\n
    \                 hostTopNOutOctets(4),\n                  hostTopNOutErrors(5),\n
    \                 hostTopNOutBroadcastPkts(6),\n                  hostTopNOutMulticastPkts(7)\n
    \               }\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The variable for each host that the hostTopNRate\n         variable
    is based upon.\n         This object may not be modified if the associated\n         hostTopNStatus
    object is equal to valid(1).\"\n     ::= { hostTopNControlEntry 3 }\n hostTopNTimeRemaining
    OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS      \"Seconds\"\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The number
    of seconds left in the report currently being\n         collected.  When this
    object is modified by the management\n         station, a new collection is started,
    possibly aborting\n         a currently running report.  The new value is used\n
    \        as the requested duration of this report, which is\n         loaded into
    the associated hostTopNDuration object.\n         When this object is set to a
    non-zero value, any\n         associated hostTopNEntries shall be made\n         inaccessible
    by the monitor.  While the value of this\n         object is non-zero, it decrements
    by one per second until\n         it reaches zero.  During this time, all associated\n
    \        hostTopNEntries shall remain inaccessible.  At the time\n         that
    this object decrements to zero, the report is made\n         accessible in the
    hostTopNTable.  Thus, the hostTopN\n         table needs to be created only at
    the end of the collection\n         interval.\"\n     DEFVAL { 0 }\n     ::= {
    hostTopNControlEntry 4 }\n hostTopNDuration OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    UNITS      \"Seconds\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of seconds that this report has collected\n
    \        during the last sampling interval, or if this\n         report is currently
    being collected, the number\n         of seconds that this report is being collected\n
    \        during this sampling interval.\n         When the associated hostTopNTimeRemaining
    object is set,\n         this object shall be set by the probe to the same value\n
    \        and shall not be modified until the next time\n         the hostTopNTimeRemaining
    is set.\n         This value shall be zero if no reports have been\n         requested
    for this hostTopNControlEntry.\"\n     DEFVAL { 0 }\n     ::= { hostTopNControlEntry
    5 }\n hostTopNRequestedSize OBJECT-TYPE\n     SYNTAX     Integer32\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The maximum
    number of hosts requested for the top N\n         table.\n         When this object
    is created or modified, the probe\n         should set hostTopNGrantedSize as
    closely to this\n         object as is possible for the particular probe\n         implementation
    and available resources.\"\n     DEFVAL { 10 }\n     ::= { hostTopNControlEntry
    6 }\n hostTopNGrantedSize OBJECT-TYPE\n     SYNTAX     Integer32\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The maximum number
    of hosts in the top N table.\n         When the associated hostTopNRequestedSize
    object is\n         created or modified, the probe should set this\n         object
    as closely to the requested value as is possible\n         for the particular
    implementation and available\n         resources. The probe must not lower this
    value except\n         as a result of a set to the associated\n         hostTopNRequestedSize
    object.\n         Hosts with the highest value of hostTopNRate shall be\n         placed
    in this table in decreasing order of this rate\n         until there is no more
    room or until there are no more\n         hosts.\"\n     ::= { hostTopNControlEntry
    7 }\n hostTopNStartTime OBJECT-TYPE\n     SYNTAX     TimeTicks\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The value of
    sysUpTime when this top N report was\n         last started.  In other words,
    this is the time that\n         the associated hostTopNTimeRemaining object was\n
    \        modified to start the requested report.\"\n     ::= { hostTopNControlEntry
    8 }\n hostTopNOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The entity
    that configured this entry and is therefore\n         using the resources assigned
    to it.\"\n     ::= { hostTopNControlEntry 9 }\n hostTopNStatus OBJECT-TYPE\n     SYNTAX
    \    EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The status of this hostTopNControl entry.\n         If this object
    is not equal to valid(1), all associated\n         hostTopNEntries shall be deleted
    by the agent.\"\n     ::= { hostTopNControlEntry 10 }\n hostTopNTable OBJECT-TYPE\n
    \    SYNTAX     SEQUENCE OF HostTopNEntry\n     MAX-ACCESS not-accessible\n     STATUS
    \    current\n     DESCRIPTION\n         \"A list of top N host entries.\"\n     ::=
    { hostTopN 2 }\n hostTopNEntry OBJECT-TYPE\n     SYNTAX     HostTopNEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A set of
    statistics for a host that is part of a top N\n         report.  For example,
    an instance of the hostTopNRate\n         object might be named hostTopNRate.3.10\"\n
    \    INDEX { hostTopNReport, hostTopNIndex }\n     ::= { hostTopNTable 1 }\n HostTopNEntry
    ::= SEQUENCE {\n     hostTopNReport                Integer32,\n     hostTopNIndex
    \                Integer32,\n     hostTopNAddress               OCTET STRING,\n
    \    hostTopNRate                  Integer32\n }\n hostTopNReport OBJECT-TYPE\n
    \    SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"This object identifies the top N report of which\n
    \        this entry is a part.  The set of hosts\n         identified by a particular
    value of this\n         object is part of the same report as identified\n         by
    the same value of the hostTopNControlIndex object.\"\n     ::= { hostTopNEntry
    1 }\n hostTopNIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An index that
    uniquely identifies an entry in\n         the hostTopN table among those in the
    same report.\n         This index is between 1 and N, where N is the\n         number
    of entries in this table.  Increasing values\n         of hostTopNIndex shall
    be assigned to entries with\n         decreasing values of hostTopNRate until
    index N\n         is assigned to the entry with the lowest value of\n         hostTopNRate
    or there are no more hostTopNEntries.\"\n     ::= { hostTopNEntry 2 }\n hostTopNAddress
    OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The physical address of this host.\"\n
    \    ::= { hostTopNEntry 3 }\n hostTopNRate OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    amount of change in the selected variable\n         during this sampling interval.
    \ The selected\n         variable is this host's instance of the object\n         selected
    by hostTopNRateBase.\"\n     ::= { hostTopNEntry 4 }\n -- The Matrix Group\n --
    Implementation of the Matrix group is optional.\n -- Consult the MODULE-COMPLIANCE
    macro for the authoritative\n -- conformance information for this MIB.\n --\n
    -- The Matrix group consists of the matrixControlTable, matrixSDTable\n -- and
    the matrixDSTable.  These tables store statistics for a\n -- particular conversation
    between two addresses.  As the device\n -- detects a new conversation, including
    those to a non-unicast\n -- address, it creates a new entry in both of the matrix
    tables.\n -- It must only create new entries based on information\n -- received
    in good packets.  If the monitoring device finds\n -- itself short of resources,
    it may delete entries as needed.\n -- It is suggested that the device delete the
    least recently used\n -- entries first.\n matrixControlTable OBJECT-TYPE\n     SYNTAX
    \    SEQUENCE OF MatrixControlEntry\n     MAX-ACCESS not-accessible\n     STATUS
    \    current\n     DESCRIPTION\n         \"A list of information entries for the\n
    \        traffic matrix on each interface.\"\n     ::= { matrix 1 }\n matrixControlEntry
    OBJECT-TYPE\n     SYNTAX     MatrixControlEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"Information about a traffic
    matrix on a particular\n         interface.  For example, an instance of the\n
    \        matrixControlLastDeleteTime object might be named\n         matrixControlLastDeleteTime.1\"\n
    \    INDEX { matrixControlIndex }\n     ::= { matrixControlTable 1 }\n MatrixControlEntry
    ::= SEQUENCE {\n     matrixControlIndex           Integer32,\n     matrixControlDataSource
    \     OBJECT IDENTIFIER,\n     matrixControlTableSize       Integer32,\n     matrixControlLastDeleteTime
    \ TimeTicks,\n     matrixControlOwner           OwnerString,\n     matrixControlStatus
    \         EntryStatus\n }\n matrixControlIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"An index that uniquely identifies an entry in the\n         matrixControl
    table.  Each such entry defines\n         a function that discovers conversations
    on a particular\n         interface and places statistics about them in the\n
    \        matrixSDTable and the matrixDSTable on behalf of this\n         matrixControlEntry.\"\n
    \    ::= { matrixControlEntry 1 }\n matrixControlDataSource OBJECT-TYPE\n     SYNTAX
    \    OBJECT IDENTIFIER\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"This object identifies the source of\n         the
    data from which this entry creates a traffic matrix.\n         This source can
    be any interface on this device.  In\n         order to identify a particular
    interface, this object\n         shall identify the instance of the ifIndex object,\n
    \        defined in RFC 2233 [17], for the desired\n         interface.  For example,
    if an entry were to receive data\n         from interface #1, this object would
    be set to ifIndex.1.\n         The statistics in this group reflect all packets\n
    \        on the local network segment attached to the identified\n         interface.\n
    \        An agent may or may not be able to tell if fundamental\n         changes
    to the media of the interface have occurred and\n         necessitate an invalidation
    of this entry.  For example, a\n         hot-pluggable ethernet card could be
    pulled out and replaced\n         by a token-ring card.  In such a case, if the
    agent has such\n         knowledge of the change, it is recommended that it\n
    \        invalidate this entry.\n         This object may not be modified if the
    associated\n         matrixControlStatus object is equal to valid(1).\"\n     ::=
    { matrixControlEntry 2 }\n matrixControlTableSize OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    number of matrixSDEntries in the matrixSDTable\n         for this interface.  This
    must also be the value of\n         the number of entries in the matrixDSTable
    for this\n         interface.\"\n     ::= { matrixControlEntry 3 }\n matrixControlLastDeleteTime
    OBJECT-TYPE\n     SYNTAX     TimeTicks\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The value of sysUpTime when the last
    entry\n         was deleted from the portion of the matrixSDTable\n         or
    matrixDSTable associated with this matrixControlEntry.\n         If no deletions
    have occurred, this value shall be\n         zero.\"\n     ::= { matrixControlEntry
    4 }\n matrixControlOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The entity
    that configured this entry and is therefore\n         using the resources assigned
    to it.\"\n     ::= { matrixControlEntry 5 }\n matrixControlStatus OBJECT-TYPE\n
    \    SYNTAX     EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The status of this matrixControl entry.\n         If
    this object is not equal to valid(1), all associated\n         entries in the
    matrixSDTable and the matrixDSTable\n         shall be deleted by the agent.\"\n
    \    ::= { matrixControlEntry 6 }\n matrixSDTable OBJECT-TYPE\n     SYNTAX     SEQUENCE
    OF MatrixSDEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n
    \        \"A list of traffic matrix entries indexed by\n         source and destination
    MAC address.\"\n     ::= { matrix 2 }\n matrixSDEntry OBJECT-TYPE\n     SYNTAX
    \    MatrixSDEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n
    \    DESCRIPTION\n         \"A collection of statistics for communications between\n
    \        two addresses on a particular interface.  For example,\n         an instance
    of the matrixSDPkts object might be named\n         matrixSDPkts.1.6.8.0.32.27.3.176.6.8.0.32.10.8.113\"\n
    \    INDEX { matrixSDIndex,\n             matrixSDSourceAddress, matrixSDDestAddress
    }\n     ::= { matrixSDTable 1 }\n MatrixSDEntry ::= SEQUENCE {\n     matrixSDSourceAddress
    \      OCTET STRING,\n     matrixSDDestAddress         OCTET STRING,\n     matrixSDIndex
    \              Integer32,\n     matrixSDPkts                Counter32,\n     matrixSDOctets
    \             Counter32,\n     matrixSDErrors              Counter32\n }\n matrixSDSourceAddress
    OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The source physical address.\"\n     ::=
    { matrixSDEntry 1 }\n matrixSDDestAddress OBJECT-TYPE\n     SYNTAX     OCTET STRING\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    destination physical address.\"\n     ::= { matrixSDEntry 2 }\n matrixSDIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The set of collected matrix
    statistics of which\n         this entry is a part.  The set of matrix statistics\n
    \        identified by a particular value of this index\n         is associated
    with the same matrixControlEntry\n         as identified by the same value of
    matrixControlIndex.\"\n     ::= { matrixSDEntry 3 }\n matrixSDPkts OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of packets transmitted
    from the source\n         address to the destination address (this number includes\n
    \        bad packets).\"\n     ::= { matrixSDEntry 4 }\n matrixSDOctets OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of octets (excluding
    framing bits but\n         including FCS octets) contained in all packets\n         transmitted
    from the source address to the\n         destination address.\"\n     ::= { matrixSDEntry
    5 }\n matrixSDErrors OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    number of bad packets transmitted from\n         the source address to the destination
    address.\"\n     ::= { matrixSDEntry 6 }\n -- Traffic matrix tables from destination
    to source\n matrixDSTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF MatrixDSEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    list of traffic matrix entries indexed by\n         destination and source MAC
    address.\"\n     ::= { matrix 3 }\n matrixDSEntry OBJECT-TYPE\n     SYNTAX     MatrixDSEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    collection of statistics for communications between\n         two addresses on
    a particular interface.  For example,\n         an instance of the matrixSDPkts
    object might be named\n         matrixSDPkts.1.6.8.0.32.10.8.113.6.8.0.32.27.3.176\"\n
    \    INDEX { matrixDSIndex,\n             matrixDSDestAddress, matrixDSSourceAddress
    }\n     ::= { matrixDSTable 1 }\n MatrixDSEntry ::= SEQUENCE {\n     matrixDSSourceAddress
    \      OCTET STRING,\n     matrixDSDestAddress         OCTET STRING,\n     matrixDSIndex
    \              Integer32,\n     matrixDSPkts                Counter32,\n     matrixDSOctets
    \             Counter32,\n     matrixDSErrors              Counter32\n }\n matrixDSSourceAddress
    OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The source physical address.\"\n     ::=
    { matrixDSEntry 1 }\n matrixDSDestAddress OBJECT-TYPE\n     SYNTAX     OCTET STRING\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    destination physical address.\"\n     ::= { matrixDSEntry 2 }\n matrixDSIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The set of collected matrix
    statistics of which\n         this entry is a part.  The set of matrix statistics\n
    \        identified by a particular value of this index\n         is associated
    with the same matrixControlEntry\n         as identified by the same value of
    matrixControlIndex.\"\n     ::= { matrixDSEntry 3 }\n matrixDSPkts OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Packets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of packets transmitted
    from the source\n         address to the destination address (this number includes\n
    \        bad packets).\"\n     ::= { matrixDSEntry 4 }\n matrixDSOctets OBJECT-TYPE\n
    \    SYNTAX     Counter32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-only\n
    \    STATUS     current\n     DESCRIPTION\n         \"The number of octets (excluding
    framing bits\n         but including FCS octets) contained in all packets\n         transmitted
    from the source address to the\n         destination address.\"\n     ::= { matrixDSEntry
    5 }\n matrixDSErrors OBJECT-TYPE\n     SYNTAX     Counter32\n     UNITS      \"Packets\"\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    number of bad packets transmitted from\n         the source address to the destination
    address.\"\n     ::= { matrixDSEntry 6 }\n -- The Filter Group\n -- Implementation
    of the Filter group is optional.\n -- Consult the MODULE-COMPLIANCE macro for
    the authoritative\n -- conformance information for this MIB.\n --\n -- The Filter
    group allows packets to be captured with an\n -- arbitrary filter expression.
    \ A logical data and\n -- event stream or \"channel\" is formed by the packets\n
    -- that match the filter expression.\n --\n -- This filter mechanism allows the
    creation of an arbitrary\n -- logical expression with which to filter packets.
    \ Each\n -- filter associated with a channel is OR'ed with the others.\n -- Within
    a filter, any bits checked in the data and status are\n -- AND'ed with respect
    to other bits in the same filter.  The\n -- NotMask also allows for checking for
    inequality.  Finally,\n -- the channelAcceptType object allows for inversion of
    the\n -- whole equation.\n --\n -- If a management station wishes to receive a
    trap to alert it\n -- that new packets have been captured and are available for\n
    -- download, it is recommended that it set up an alarm entry that\n -- monitors
    the value of the relevant channelMatches instance.\n --\n -- The channel can be
    turned on or off, and can also\n -- generate events when packets pass through
    it.\n filterTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF FilterEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A list of
    packet filter entries.\"\n     ::= { filter 1 }\n filterEntry OBJECT-TYPE\n     SYNTAX
    \    FilterEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n
    \        \"A set of parameters for a packet filter applied on a\n         particular
    interface.  As an example, an instance of the\n         filterPktData object might
    be named filterPktData.12\"\n     INDEX { filterIndex }\n     ::= { filterTable
    1 }\n FilterEntry ::= SEQUENCE {\n     filterIndex                 Integer32,\n
    \    filterChannelIndex          Integer32,\n     filterPktDataOffset         Integer32,\n
    \    filterPktData               OCTET STRING,\n     filterPktDataMask           OCTET
    STRING,\n     filterPktDataNotMask        OCTET STRING,\n     filterPktStatus
    \            Integer32,\n     filterPktStatusMask         Integer32,\n     filterPktStatusNotMask
    \     Integer32,\n     filterOwner                 OwnerString,\n     filterStatus
    \               EntryStatus\n }\n filterIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"An index that uniquely identifies an entry\n         in the filter
    table.  Each such entry defines\n         one filter that is to be applied to
    every packet\n         received on an interface.\"\n     ::= { filterEntry 1 }\n
    filterChannelIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"This object
    identifies the channel of which this filter\n         is a part.  The filters
    identified by a particular value\n         of this object are associated with
    the same channel as\n         identified by the same value of the channelIndex
    object.\"\n     ::= { filterEntry 2 }\n filterPktDataOffset OBJECT-TYPE\n     SYNTAX
    \    Integer32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"The offset from the beginning of each
    packet where\n         a match of packet data will be attempted.  This offset\n
    \        is measured from the point in the physical layer\n         packet after
    the framing bits, if any.  For example,\n         in an Ethernet frame, this point
    is at the beginning of\n         the destination MAC address.\n         This object
    may not be modified if the associated\n         filterStatus object is equal to
    valid(1).\"\n     DEFVAL { 0 }\n     ::= { filterEntry 3 }\n filterPktData OBJECT-TYPE\n
    \    SYNTAX     OCTET STRING\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The data that is to be matched with the input packet.\n
    \        For each packet received, this filter and the accompanying\n         filterPktDataMask
    and filterPktDataNotMask will be\n         adjusted for the offset.  The only
    bits relevant to this\n         match algorithm are those that have the corresponding\n
    \        filterPktDataMask bit equal to one.  The following three\n         rules
    are then applied to every packet:\n         (1) If the packet is too short and
    does not have data\n             corresponding to part of the filterPktData, the
    packet\n             will fail this data match.\n         (2) For each relevant
    bit from the packet with the\n             corresponding filterPktDataNotMask
    bit set to zero, if\n             the bit from the packet is not equal to the
    corresponding\n             bit from the filterPktData, then the packet will fail\n
    \            this data match.\n         (3) If for every relevant bit from the
    packet with the\n             corresponding filterPktDataNotMask bit set to one,
    the\n             bit from the packet is equal to the corresponding bit\n             from
    the filterPktData, then the packet will fail this\n             data match.\n
    \        Any packets that have not failed any of the three matches\n         above
    have passed this data match.  In particular, a zero\n         length filter will
    match any packet.\n         This object may not be modified if the associated\n
    \        filterStatus object is equal to valid(1).\"\n     ::= { filterEntry 4
    }\n filterPktDataMask OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The mask that
    is applied to the match process.\n         After adjusting this mask for the offset,
    only those\n         bits in the received packet that correspond to bits set\n
    \        in this mask are relevant for further processing by the\n         match
    algorithm.  The offset is applied to filterPktDataMask\n         in the same way
    it is applied to the filter.  For the\n         purposes of the matching algorithm,
    if the associated\n         filterPktData object is longer than this mask, this
    mask is\n         conceptually extended with '1' bits until it reaches the\n         length
    of the filterPktData object.\n         This object may not be modified if the
    associated\n         filterStatus object is equal to valid(1).\"\n     ::= { filterEntry
    5 }\n filterPktDataNotMask OBJECT-TYPE\n     SYNTAX     OCTET STRING\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The inversion
    mask that is applied to the match\n         process.  After adjusting this mask
    for the offset,\n         those relevant bits in the received packet that correspond\n
    \        to bits cleared in this mask must all be equal to their\n         corresponding
    bits in the filterPktData object for the packet\n         to be accepted.  In
    addition, at least one of those relevant\n         bits in the received packet
    that correspond to bits set in\n         this mask must be different to its corresponding
    bit in the\n         filterPktData object.\n         For the purposes of the matching
    algorithm, if the associated\n         filterPktData object is longer than this
    mask, this mask is\n         conceptually extended with '0' bits until it reaches
    the\n         length of the filterPktData object.\n         This object may not
    be modified if the associated\n         filterStatus object is equal to valid(1).\"\n
    \    ::= { filterEntry 6 }\n filterPktStatus OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    status that is to be matched with the input packet.\n         The only bits relevant
    to this match algorithm are those that\n         have the corresponding filterPktStatusMask
    bit equal to one.\n         The following two rules are then applied to every
    packet:\n         (1) For each relevant bit from the packet status with the\n
    \            corresponding filterPktStatusNotMask bit set to zero, if\n             the
    bit from the packet status is not equal to the\n             corresponding bit
    from the filterPktStatus, then the\n             packet will fail this status
    match.\n         (2) If for every relevant bit from the packet status with the\n
    \            corresponding filterPktStatusNotMask bit set to one, the\n             bit
    from the packet status is equal to the corresponding\n             bit from the
    filterPktStatus, then the packet will fail\n             this status match.\n
    \        Any packets that have not failed either of the two matches\n         above
    have passed this status match.  In particular, a zero\n         length status
    filter will match any packet's status.\n         The value of the packet status
    is a sum.  This sum\n         initially takes the value zero.  Then, for each\n
    \        error, E, that has been discovered in this packet,\n         2 raised
    to a value representing E is added to the sum.\n         The errors and the bits
    that represent them are dependent\n         on the media type of the interface
    that this channel\n         is receiving packets from.\n         The errors defined
    for a packet captured off of an\n         Ethernet interface are as follows:\n
    \            bit #    Error\n                 0    Packet is longer than 1518
    octets\n                 1    Packet is shorter than 64 octets\n                 2
    \   Packet experienced a CRC or Alignment error\n         For example, an Ethernet
    fragment would have a\n         value of 6 (2^1 + 2^2).\n         As this MIB
    is expanded to new media types, this object\n         will have other media-specific
    errors defined.\n         For the purposes of this status matching algorithm,
    if the\n         packet status is longer than this filterPktStatus object,\n         this
    object is conceptually extended with '0' bits until it\n         reaches the size
    of the packet status.\n         This object may not be modified if the associated\n
    \        filterStatus object is equal to valid(1).\"\n     ::= { filterEntry 7
    }\n filterPktStatusMask OBJECT-TYPE\n     SYNTAX     Integer32\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The mask that
    is applied to the status match process.\n         Only those bits in the received
    packet that correspond to\n         bits set in this mask are relevant for further
    processing\n         by the status match algorithm.  For the purposes\n         of
    the matching algorithm, if the associated filterPktStatus\n         object is
    longer than this mask, this mask is conceptually\n         extended with '1' bits
    until it reaches the size of the\n         filterPktStatus.  In addition, if a
    packet status is longer\n         than this mask, this mask is conceptually extended
    with '0'\n         bits until it reaches the size of the packet status.\n         This
    object may not be modified if the associated\n         filterStatus object is
    equal to valid(1).\"\n     ::= { filterEntry 8 }\n filterPktStatusNotMask OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The inversion mask that is applied to the status
    match\n         process.  Those relevant bits in the received packet status\n
    \        that correspond to bits cleared in this mask must all be\n         equal
    to their corresponding bits in the filterPktStatus\n         object for the packet
    to be accepted.  In addition, at least\n         one of those relevant bits in
    the received packet status\n         that correspond to bits set in this mask
    must be different\n         to its corresponding bit in the filterPktStatus object
    for\n         the packet to be accepted.\n         For the purposes of the matching
    algorithm, if the associated\n         filterPktStatus object or a packet status
    is longer than this\n         mask, this mask is conceptually extended with '0'
    bits until\n         it reaches the longer of the lengths of the filterPktStatus\n
    \        object and the packet status.\n         This object may not be modified
    if the associated\n         filterStatus object is equal to valid(1).\"\n     ::=
    { filterEntry 9 }\n filterOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The entity
    that configured this entry and is therefore\n         using the resources assigned
    to it.\"\n     ::= { filterEntry 10 }\n filterStatus OBJECT-TYPE\n     SYNTAX
    \    EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The status of this filter entry.\"\n     ::= { filterEntry 11 }\n channelTable
    OBJECT-TYPE\n     SYNTAX     SEQUENCE OF ChannelEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of packet channel
    entries.\"\n     ::= { filter 2 }\n channelEntry OBJECT-TYPE\n     SYNTAX     ChannelEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    set of parameters for a packet channel applied on a\n         particular interface.
    \ As an example, an instance of the\n         channelMatches object might be named
    channelMatches.3\"\n     INDEX { channelIndex }\n     ::= { channelTable 1 }\n
    ChannelEntry ::= SEQUENCE {\n     channelIndex                 Integer32,\n     channelIfIndex
    \              Integer32,\n     channelAcceptType            INTEGER,\n     channelDataControl
    \          INTEGER,\n     channelTurnOnEventIndex      Integer32,\n     channelTurnOffEventIndex
    \    Integer32,\n     channelEventIndex            Integer32,\n     channelEventStatus
    \          INTEGER,\n     channelMatches               Counter32,\n     channelDescription
    \          DisplayString,\n     channelOwner                 OwnerString,\n     channelStatus
    \               EntryStatus\n }\n channelIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"An index that uniquely identifies an entry in the channel\n         table.
    \ Each such entry defines one channel, a logical\n         data and event stream.\n
    \        It is suggested that before creating a channel, an\n         application
    should scan all instances of the\n         filterChannelIndex object to make sure
    that there are no\n         pre-existing filters that would be inadvertently be
    linked\n         to the channel.\"\n     ::= { channelEntry 1 }\n channelIfIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The value of this object
    uniquely identifies the\n         interface on this remote network monitoring
    device to which\n         the associated filters are applied to allow data into
    this\n         channel.  The interface identified by a particular value\n         of
    this object is the same interface as identified by the\n         same value of
    the ifIndex object, defined in RFC 2233 [17].\n         The filters in this group
    are applied to all packets on\n         the local network segment attached to
    the identified\n         interface.\n         An agent may or may not be able
    to tell if fundamental\n         changes to the media of the interface have occurred
    and\n         necessitate an invalidation of this entry.  For example, a\n         hot-pluggable
    ethernet card could be pulled out and replaced\n         by a token-ring card.
    \ In such a case, if the agent has such\n         knowledge of the change, it
    is recommended that it\n         invalidate this entry.\n         This object
    may not be modified if the associated\n         channelStatus object is equal
    to valid(1).\"\n     ::= { channelEntry 2 }\n channelAcceptType OBJECT-TYPE\n
    \    SYNTAX     INTEGER {\n                  acceptMatched(1),\n                  acceptFailed(2)\n
    \               }\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"This object controls the action of the filters\n         associated
    with this channel.  If this object is equal\n         to acceptMatched(1), packets
    will be accepted to this\n         channel if they are accepted by both the packet
    data and\n         packet status matches of an associated filter.  If\n         this
    object is equal to acceptFailed(2), packets will\n         be accepted to this
    channel only if they fail either\n         the packet data match or the packet
    status match of\n         each of the associated filters.\n         In particular,
    a channel with no associated filters will\n         match no packets if set to
    acceptMatched(1) case and will\n         match all packets in the acceptFailed(2)
    case.\n         This object may not be modified if the associated\n         channelStatus
    object is equal to valid(1).\"\n     ::= { channelEntry 3 }\n channelDataControl
    OBJECT-TYPE\n     SYNTAX     INTEGER {\n                  on(1),\n                  off(2)\n
    \               }\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"This object controls the flow of data through this channel.\n         If
    this object is on(1), data, status and events flow\n         through this channel.
    \ If this object is off(2), data,\n         status and events will not flow through
    this channel.\"\n     DEFVAL { off }\n     ::= { channelEntry 4 }\n channelTurnOnEventIndex
    OBJECT-TYPE\n     SYNTAX     Integer32 (0..65535)\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The value of this object
    identifies the event\n         that is configured to turn the associated\n         channelDataControl
    from off to on when the event is\n         generated.  The event identified by
    a particular value\n         of this object is the same event as identified by
    the\n         same value of the eventIndex object.  If there is no\n         corresponding
    entry in the eventTable, then no\n         association exists.  In fact, if no
    event is intended\n         for this channel, channelTurnOnEventIndex must be\n
    \        set to zero, a non-existent event index.\n         This object may not
    be modified if the associated\n         channelStatus object is equal to valid(1).\"\n
    \    ::= { channelEntry 5 }\n channelTurnOffEventIndex OBJECT-TYPE\n     SYNTAX
    \    Integer32 (0..65535)\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The value of this object identifies the event\n         that
    is configured to turn the associated\n         channelDataControl from on to off
    when the event is\n         generated.  The event identified by a particular value\n
    \        of this object is the same event as identified by the\n         same
    value of the eventIndex object.  If there is no\n         corresponding entry
    in the eventTable, then no\n         association exists.  In fact, if no event
    is intended\n         for this channel, channelTurnOffEventIndex must be\n         set
    to zero, a non-existent event index.\n         This object may not be modified
    if the associated\n         channelStatus object is equal to valid(1).\"\n     ::=
    { channelEntry 6 }\n channelEventIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (0..65535)\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The value of this object identifies the event\n         that is configured
    to be generated when the\n         associated channelDataControl is on and a packet\n
    \        is matched.  The event identified by a particular value\n         of
    this object is the same event as identified by the\n         same value of the
    eventIndex object.  If there is no\n         corresponding entry in the eventTable,
    then no\n         association exists.  In fact, if no event is intended\n         for
    this channel, channelEventIndex must be\n         set to zero, a non-existent
    event index.\n         This object may not be modified if the associated\n         channelStatus
    object is equal to valid(1).\"\n     ::= { channelEntry 7 }\n channelEventStatus
    OBJECT-TYPE\n     SYNTAX     INTEGER {\n                  eventReady(1),\n                  eventFired(2),\n
    \                 eventAlwaysReady(3)\n                }\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The event status of this
    channel.\n         If this channel is configured to generate events\n         when
    packets are matched, a means of controlling\n         the flow of those events
    is often needed.  When\n         this object is equal to eventReady(1), a single\n
    \        event may be generated, after which this object\n         will be set
    by the probe to eventFired(2).  While\n         in the eventFired(2) state, no
    events will be\n         generated until the object is modified to\n         eventReady(1)
    (or eventAlwaysReady(3)).  The\n         management station can thus easily respond
    to a\n         notification of an event by re-enabling this object.\n         If
    the management station wishes to disable this\n         flow control and allow
    events to be generated\n         at will, this object may be set to\n         eventAlwaysReady(3).
    \ Disabling the flow control\n         is discouraged as it can result in high
    network\n         traffic or other performance problems.\"\n     DEFVAL { eventReady
    }\n     ::= { channelEntry 8 }\n channelMatches OBJECT-TYPE\n     SYNTAX     Counter32\n
    \    UNITS      \"Packets\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of times this channel has matched a packet.\n
    \        Note that this object is updated even when\n         channelDataControl
    is set to off.\"\n     ::= { channelEntry 9 }\n channelDescription OBJECT-TYPE\n
    \    SYNTAX     DisplayString (SIZE (0..127))\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"A comment describing this channel.\"\n
    \    ::= { channelEntry 10 }\n channelOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    entity that configured this entry and is therefore\n         using the resources
    assigned to it.\"\n     ::= { channelEntry 11 }\n channelStatus OBJECT-TYPE\n
    \    SYNTAX     EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The status of this channel entry.\"\n     ::= { channelEntry
    12 }\n -- The Packet Capture Group\n -- Implementation of the Packet Capture group
    is optional. The Packet\n -- Capture Group requires implementation of the Filter
    Group.\n -- Consult the MODULE-COMPLIANCE macro for the authoritative\n -- conformance
    information for this MIB.\n --\n -- The Packet Capture group allows packets to
    be captured\n -- upon a filter match.  The bufferControlTable controls\n -- the
    captured packets output from a channel that is\n -- associated with it.  The captured
    packets are placed\n -- in entries in the captureBufferTable.  These entries are\n
    -- associated with the bufferControlEntry on whose behalf they\n -- were stored.\n
    bufferControlTable OBJECT-TYPE\n     SYNTAX     SEQUENCE OF BufferControlEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    list of buffers control entries.\"\n     ::= { capture 1 }\n bufferControlEntry
    OBJECT-TYPE\n     SYNTAX     BufferControlEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A set of parameters that
    control the collection of a stream\n         of packets that have matched filters.
    \ As an example, an\n         instance of the bufferControlCaptureSliceSize object
    might\n         be named bufferControlCaptureSliceSize.3\"\n     INDEX { bufferControlIndex
    }\n     ::= { bufferControlTable 1 }\n BufferControlEntry ::= SEQUENCE {\n     bufferControlIndex
    \               Integer32,\n     bufferControlChannelIndex         Integer32,\n
    \    bufferControlFullStatus           INTEGER,\n     bufferControlFullAction
    \          INTEGER,\n     bufferControlCaptureSliceSize     Integer32,\n     bufferControlDownloadSliceSize
    \   Integer32,\n     bufferControlDownloadOffset       Integer32,\n     bufferControlMaxOctetsRequested
    \  Integer32,\n     bufferControlMaxOctetsGranted     Integer32,\n     bufferControlCapturedPackets
    \     Integer32,\n     bufferControlTurnOnTime           TimeTicks,\n     bufferControlOwner
    \               OwnerString,\n     bufferControlStatus               EntryStatus\n
    }\n bufferControlIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An index that
    uniquely identifies an entry\n         in the bufferControl table.  The value
    of this\n         index shall never be zero.  Each such\n         entry defines
    one set of packets that is\n         captured and controlled by one or more filters.\"\n
    \    ::= { bufferControlEntry 1 }\n bufferControlChannelIndex OBJECT-TYPE\n     SYNTAX
    \    Integer32 (1..65535)\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"An index that identifies the channel that is the\n
    \        source of packets for this bufferControl table.\n         The channel
    identified by a particular value of this\n         index is the same as identified
    by the same value of\n         the channelIndex object.\n         This object
    may not be modified if the associated\n         bufferControlStatus object is
    equal to valid(1).\"\n     ::= { bufferControlEntry 2 }\n bufferControlFullStatus
    OBJECT-TYPE\n     SYNTAX     INTEGER {\n                  spaceAvailable(1),\n
    \                 full(2)\n                }\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"This object shows whether the buffer
    has room to\n         accept new packets or if it is full.\n         If the status
    is spaceAvailable(1), the buffer is\n         accepting new packets normally.
    \ If the status is\n         full(2) and the associated bufferControlFullAction\n
    \        object is wrapWhenFull, the buffer is accepting new\n         packets
    by deleting enough of the oldest packets\n         to make room for new ones as
    they arrive.  Otherwise,\n         if the status is full(2) and the\n         bufferControlFullAction
    object is lockWhenFull,\n         then the buffer has stopped collecting packets.\n
    \        When this object is set to full(2) the probe must\n         not later
    set it to spaceAvailable(1) except in the\n         case of a significant gain
    in resources such as\n         an increase of bufferControlOctetsGranted.  In\n
    \        particular, the wrap-mode action of deleting old\n         packets to
    make room for newly arrived packets\n         must not affect the value of this
    object.\"\n     ::= { bufferControlEntry 3 }\n bufferControlFullAction OBJECT-TYPE\n
    \    SYNTAX     INTEGER {\n                  lockWhenFull(1),\n                  wrapWhenFull(2)
    \   -- FIFO\n                }\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"Controls the action of the buffer when it\n         reaches
    the full status.  When in the lockWhenFull(1)\n         state and a packet is
    added to the buffer that\n         fills the buffer, the bufferControlFullStatus
    will\n         be set to full(2) and this buffer will stop capturing\n         packets.\"\n
    \    ::= { bufferControlEntry 4 }\n bufferControlCaptureSliceSize OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The maximum number of octets
    of each packet\n         that will be saved in this capture buffer.\n         For
    example, if a 1500 octet packet is received by\n         the probe and this object
    is set to 500, then only\n         500 octets of the packet will be stored in
    the\n         associated capture buffer.  If this variable is set\n         to
    0, the capture buffer will save as many octets\n         as is possible.\n         This
    object may not be modified if the associated\n         bufferControlStatus object
    is equal to valid(1).\"\n     DEFVAL { 100 }\n     ::= { bufferControlEntry 5
    }\n bufferControlDownloadSliceSize OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS
    \     \"Octets\"\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The maximum number of octets of each packet\n         in this capture
    buffer that will be returned in\n         an SNMP retrieval of that packet.  For
    example,\n         if 500 octets of a packet have been stored in the\n         associated
    capture buffer, the associated\n         bufferControlDownloadOffset is 0, and
    this\n         object is set to 100, then the captureBufferPacket\n         object
    that contains the packet will contain only\n         the first 100 octets of the
    packet.\n         A prudent manager will take into account possible\n         interoperability
    or fragmentation problems that may\n         occur if the download slice size
    is set too large.\n         In particular, conformant SNMP implementations are
    not\n         required to accept messages whose length exceeds 484\n         octets,
    although they are encouraged to support larger\n         datagrams whenever feasible.\"\n
    \    DEFVAL { 100 }\n     ::= { bufferControlEntry 6 }\n bufferControlDownloadOffset
    OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS      \"Octets\"\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The offset
    of the first octet of each packet\n         in this capture buffer that will be
    returned in\n         an SNMP retrieval of that packet.  For example,\n         if
    500 octets of a packet have been stored in the\n         associated capture buffer
    and this object is set to\n         100, then the captureBufferPacket object that\n
    \        contains the packet will contain bytes starting\n         100 octets
    into the packet.\"\n     DEFVAL { 0 }\n     ::= { bufferControlEntry 7 }\n bufferControlMaxOctetsRequested
    OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS      \"Octets\"\n     MAX-ACCESS
    read-create\n     STATUS     current\n     DESCRIPTION\n         \"The requested
    maximum number of octets to be\n         saved in this captureBuffer, including
    any\n         implementation-specific overhead. If this variable\n         is
    set to -1, the capture buffer will save as many\n         octets as is possible.\n
    \        When this object is created or modified, the probe\n         should set
    bufferControlMaxOctetsGranted as closely\n         to this object as is possible
    for the particular probe\n         implementation and available resources.  However,
    if\n         the object has the special value of -1, the probe\n         must
    set bufferControlMaxOctetsGranted to -1.\"\n     DEFVAL { -1 }\n     ::= { bufferControlEntry
    8 }\n bufferControlMaxOctetsGranted OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS
    \     \"Octets\"\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The maximum number of octets that can be\n         saved in this captureBuffer,
    including overhead.\n         If this variable is -1, the capture buffer will
    save\n         as many octets as possible.\n         When the bufferControlMaxOctetsRequested
    object is\n         created or modified, the probe should set this object\n         as
    closely to the requested value as is possible for the\n         particular probe
    implementation and available resources.\n         However, if the request object
    has the special value\n         of -1, the probe must set this object to -1.\n
    \        The probe must not lower this value except as a result of\n         a
    modification to the associated\n         bufferControlMaxOctetsRequested object.\n
    \        When this maximum number of octets is reached\n         and a new packet
    is to be added to this\n         capture buffer and the corresponding\n         bufferControlFullAction
    is set to wrapWhenFull(2),\n         enough of the oldest packets associated with
    this\n         capture buffer shall be deleted by the agent so\n         that
    the new packet can be added.  If the corresponding\n         bufferControlFullAction
    is set to lockWhenFull(1),\n         the new packet shall be discarded.  In either
    case,\n         the probe must set bufferControlFullStatus to\n         full(2).\n
    \        When the value of this object changes to a value less\n         than
    the current value, entries are deleted from\n         the captureBufferTable associated
    with this\n         bufferControlEntry.  Enough of the\n         oldest of these
    captureBufferEntries shall be\n         deleted by the agent so that the number
    of octets\n         used remains less than or equal to the new value of\n         this
    object.\n         When the value of this object changes to a value greater\n         than
    the current value, the number of associated\n         captureBufferEntries may
    be allowed to grow.\"\n     ::= { bufferControlEntry 9 }\n bufferControlCapturedPackets
    OBJECT-TYPE\n     SYNTAX     Integer32\n     UNITS      \"Packets\"\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The number of
    packets currently in this captureBuffer.\"\n     ::= { bufferControlEntry 10 }\n
    bufferControlTurnOnTime OBJECT-TYPE\n     SYNTAX     TimeTicks\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The value of
    sysUpTime when this capture buffer was\n         first turned on.\"\n     ::=
    { bufferControlEntry 11 }\n bufferControlOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    entity that configured this entry and is therefore\n         using the resources
    assigned to it.\"\n     ::= { bufferControlEntry 12 }\n bufferControlStatus OBJECT-TYPE\n
    \    SYNTAX     EntryStatus\n     MAX-ACCESS read-create\n     STATUS     current\n
    \    DESCRIPTION\n         \"The status of this buffer Control Entry.\"\n     ::=
    { bufferControlEntry 13 }\n captureBufferTable OBJECT-TYPE\n     SYNTAX     SEQUENCE
    OF CaptureBufferEntry\n     MAX-ACCESS not-accessible\n     STATUS     current\n
    \    DESCRIPTION\n         \"A list of packets captured off of a channel.\"\n
    \    ::= { capture 2 }\n captureBufferEntry OBJECT-TYPE\n     SYNTAX     CaptureBufferEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    packet captured off of an attached network.  As an\n         example, an instance
    of the captureBufferPacketData\n         object might be named captureBufferPacketData.3.1783\"\n
    \    INDEX { captureBufferControlIndex, captureBufferIndex }\n     ::= { captureBufferTable
    1 }\n CaptureBufferEntry ::= SEQUENCE {\n     captureBufferControlIndex   Integer32,\n
    \    captureBufferIndex          Integer32,\n     captureBufferPacketID       Integer32,\n
    \    captureBufferPacketData     OCTET STRING,\n     captureBufferPacketLength
    \  Integer32,\n     captureBufferPacketTime     Integer32,\n     captureBufferPacketStatus
    \  Integer32\n }\n captureBufferControlIndex OBJECT-TYPE\n     SYNTAX     Integer32
    (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n
    \        \"The index of the bufferControlEntry with which\n         this packet
    is associated.\"\n     ::= { captureBufferEntry 1 }\n captureBufferIndex OBJECT-TYPE\n
    \    SYNTAX     Integer32 (1..2147483647)\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"An index that uniquely identifies an
    entry\n         in the captureBuffer table associated with a\n         particular
    bufferControlEntry.  This index will\n         start at 1 and increase by one
    for each new packet\n         added with the same captureBufferControlIndex.\n
    \        Should this value reach 2147483647, the next packet\n         added with
    the same captureBufferControlIndex shall\n         cause this value to wrap around
    to 1.\"\n     ::= { captureBufferEntry 2 }\n captureBufferPacketID OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"An index that describes the order of packets\n         that
    are received on a particular interface.\n         The packetID of a packet captured
    on an\n         interface is defined to be greater than the\n         packetID's
    of all packets captured previously on\n         the same interface.  As the captureBufferPacketID\n
    \        object has a maximum positive value of 2^31 - 1,\n         any captureBufferPacketID
    object shall have the\n         value of the associated packet's packetID mod
    2^31.\"\n     ::= { captureBufferEntry 3 }\n captureBufferPacketData OBJECT-TYPE\n
    \    SYNTAX     OCTET STRING\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The data inside the packet, starting at the beginning\n
    \        of the packet plus any offset specified in the\n         associated bufferControlDownloadOffset,
    including any\n         link level headers.  The length of the data in this object\n
    \        is the minimum of the length of the captured packet minus\n         the
    offset, the length of the associated\n         bufferControlCaptureSliceSize minus
    the offset, and the\n         associated bufferControlDownloadSliceSize.  If this
    minimum\n         is less than zero, this object shall have a length of zero.\"\n
    \    ::= { captureBufferEntry 4 }\n captureBufferPacketLength OBJECT-TYPE\n     SYNTAX
    \    Integer32\n     UNITS      \"Octets\"\n     MAX-ACCESS read-only\n     STATUS
    \    current\n     DESCRIPTION\n         \"The actual length (off the wire) of
    the packet stored\n         in this entry, including FCS octets.\"\n     ::= {
    captureBufferEntry 5 }\n captureBufferPacketTime OBJECT-TYPE\n     SYNTAX     Integer32\n
    \    UNITS      \"Milliseconds\"\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"The number of milliseconds that had passed since\n
    \        this capture buffer was first turned on when this\n         packet was
    captured.\"\n     ::= { captureBufferEntry 6 }\n captureBufferPacketStatus OBJECT-TYPE\n
    \    SYNTAX     Integer32\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"A value which indicates the error status of this
    packet.\n         The value of this object is defined in the same way as\n         filterPktStatus.
    \ The value is a sum.  This sum\n         initially takes the value zero.  Then,
    for each\n         error, E, that has been discovered in this packet,\n         2
    raised to a value representing E is added to the sum.\n         The errors defined
    for a packet captured off of an\n         Ethernet interface are as follows:\n
    \            bit #    Error\n                 0    Packet is longer than 1518
    octets\n                 1    Packet is shorter than 64 octets\n                 2
    \   Packet experienced a CRC or Alignment error\n                 3    First packet
    in this capture buffer after\n                      it was detected that some
    packets were\n                      not processed correctly.\n                 4
    \   Packet's order in buffer is only approximate\n                      (May only
    be set for packets sent from\n                      the probe)\n         For example,
    an Ethernet fragment would have a\n         value of 6 (2^1 + 2^2).\n         As
    this MIB is expanded to new media types, this object\n         will have other
    media-specific errors defined.\"\n     ::= { captureBufferEntry 7 }\n -- The Event
    Group\n -- Implementation of the Event group is optional.\n -- Consult the MODULE-COMPLIANCE
    macro for the authoritative\n -- conformance information for this MIB.\n --\n
    -- The Event group controls the generation and notification\n -- of events from
    this device.  Each entry in the eventTable\n -- describes the parameters of the
    event that can be triggered.\n -- Each event entry is fired by an associated condition
    located\n -- elsewhere in the MIB.  An event entry may also be associated\n --
    with a function elsewhere in the MIB that will be executed\n -- when the event
    is generated.  For example, a channel may\n -- be turned on or off by the firing
    of an event.\n --\n -- Each eventEntry may optionally specify that a log entry\n
    -- be created on its behalf whenever the event occurs.\n -- Each entry may also
    specify that notification should\n -- occur by way of SNMP trap messages.  In
    this case, the\n -- community for the trap message is given in the associated\n
    -- eventCommunity object.  The enterprise and specific trap\n -- fields of the
    trap are determined by the condition that\n -- triggered the event.  Two traps
    are defined: risingAlarm and\n -- fallingAlarm.  If the eventTable is triggered
    by a condition\n -- specified elsewhere, the enterprise and specific trap fields\n
    -- must be specified for traps generated for that condition.\n eventTable OBJECT-TYPE\n
    \    SYNTAX     SEQUENCE OF EventEntry\n     MAX-ACCESS not-accessible\n     STATUS
    \    current\n     DESCRIPTION\n         \"A list of events to be generated.\"\n
    \    ::= { event 1 }\n eventEntry OBJECT-TYPE\n     SYNTAX     EventEntry\n     MAX-ACCESS
    not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A set of
    parameters that describe an event to be generated\n         when certain conditions
    are met.  As an example, an instance\n         of the eventLastTimeSent object
    might be named\n         eventLastTimeSent.6\"\n     INDEX { eventIndex }\n     ::=
    { eventTable 1 }\n EventEntry ::= SEQUENCE {\n     eventIndex          Integer32,\n
    \    eventDescription    DisplayString,\n     eventType           INTEGER,\n     eventCommunity
    \     OCTET STRING,\n     eventLastTimeSent   TimeTicks,\n     eventOwner          OwnerString,\n
    \    eventStatus         EntryStatus\n }\n eventIndex OBJECT-TYPE\n     SYNTAX
    \    Integer32 (1..65535)\n     MAX-ACCESS read-only\n     STATUS     current\n
    \    DESCRIPTION\n         \"An index that uniquely identifies an entry in the\n
    \        event table.  Each such entry defines one event that\n         is to
    be generated when the appropriate conditions\n         occur.\"\n     ::= { eventEntry
    1 }\n eventDescription OBJECT-TYPE\n     SYNTAX     DisplayString (SIZE (0..127))\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"A
    comment describing this event entry.\"\n     ::= { eventEntry 2 }\n eventType
    OBJECT-TYPE\n     SYNTAX     INTEGER {\n                  none(1),\n                  log(2),\n
    \                 snmptrap(3),    -- send an SNMP trap\n                  logandtrap(4)\n
    \               }\n     MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n
    \        \"The type of notification that the probe will make\n         about this
    event.  In the case of log, an entry is\n         made in the log table for each
    event.  In the case of\n         snmp-trap, an SNMP trap is sent to one or more\n
    \        management stations.\"\n     ::= { eventEntry 3 }\n eventCommunity OBJECT-TYPE\n
    \    SYNTAX     OCTET STRING (SIZE (0..127))\n     MAX-ACCESS read-create\n     STATUS
    \    current\n     DESCRIPTION\n         \"If an SNMP trap is to be sent, it will
    be sent to\n         the SNMP community specified by this octet string.\"\n     ::=
    { eventEntry 4 }\n eventLastTimeSent OBJECT-TYPE\n     SYNTAX     TimeTicks\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    value of sysUpTime at the time this event\n         entry last generated an event.
    \ If this entry has\n         not generated any events, this value will be\n         zero.\"\n
    \    ::= { eventEntry 5 }\n eventOwner OBJECT-TYPE\n     SYNTAX     OwnerString\n
    \    MAX-ACCESS read-create\n     STATUS     current\n     DESCRIPTION\n         \"The
    entity that configured this entry and is therefore\n         using the resources
    assigned to it.\n         If this object contains a string starting with 'monitor'\n
    \        and has associated entries in the log table, all connected\n         management
    stations should retrieve those log entries,\n         as they may have significance
    to all management stations\n         connected to this device\"\n     ::= { eventEntry
    6 }\n eventStatus OBJECT-TYPE\n     SYNTAX     EntryStatus\n     MAX-ACCESS read-create\n
    \    STATUS     current\n     DESCRIPTION\n         \"The status of this event
    entry.\n         If this object is not equal to valid(1), all associated\n         log
    entries shall be deleted by the agent.\"\n     ::= { eventEntry 7 }\n --\n logTable
    OBJECT-TYPE\n     SYNTAX     SEQUENCE OF LogEntry\n     MAX-ACCESS not-accessible\n
    \    STATUS     current\n     DESCRIPTION\n         \"A list of events that have
    been logged.\"\n     ::= { event 2 }\n logEntry OBJECT-TYPE\n     SYNTAX     LogEntry\n
    \    MAX-ACCESS not-accessible\n     STATUS     current\n     DESCRIPTION\n         \"A
    set of data describing an event that has been\n         logged.  For example,
    an instance of the logDescription\n         object might be named logDescription.6.47\"\n
    \    INDEX { logEventIndex, logIndex }\n     ::= { logTable 1 }\n LogEntry ::=
    SEQUENCE {\n     logEventIndex           Integer32,\n     logIndex                Integer32,\n
    \    logTime                 TimeTicks,\n     logDescription          DisplayString\n
    }\n logEventIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..65535)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"The event entry
    that generated this log\n         entry.  The log identified by a particular\n
    \        value of this index is associated with the same\n         eventEntry
    as identified by the same value\n         of eventIndex.\"\n     ::= { logEntry
    1 }\n logIndex OBJECT-TYPE\n     SYNTAX     Integer32 (1..2147483647)\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An index that
    uniquely identifies an entry\n         in the log table amongst those generated
    by the\n         same eventEntries.  These indexes are\n         assigned beginning
    with 1 and increase by one\n         with each new log entry.  The association\n
    \        between values of logIndex and logEntries\n         is fixed for the
    lifetime of each logEntry.\n         The agent may choose to delete the oldest\n
    \        instances of logEntry as required because of\n         lack of memory.
    \ It is an implementation-specific\n         matter as to when this deletion may
    occur.\"\n     ::= { logEntry 2 }\n logTime OBJECT-TYPE\n     SYNTAX     TimeTicks\n
    \    MAX-ACCESS read-only\n     STATUS     current\n     DESCRIPTION\n         \"The
    value of sysUpTime when this log entry was created.\"\n     ::= { logEntry 3 }\n
    logDescription OBJECT-TYPE\n     SYNTAX     DisplayString (SIZE (0..255))\n     MAX-ACCESS
    read-only\n     STATUS     current\n     DESCRIPTION\n         \"An implementation
    dependent description of the\n         event that activated this log entry.\"\n
    \    ::= { logEntry 4 }\n --  Remote Network Monitoring Traps\n rmonEventsV2 OBJECT-IDENTITY\n
    \    STATUS      current\n     DESCRIPTION \"Definition point for RMON notifications.\"\n
    \    ::= { rmon 0 }\n risingAlarm NOTIFICATION-TYPE\n     OBJECTS  { alarmIndex,
    alarmVariable, alarmSampleType,\n                alarmValue, alarmRisingThreshold
    }\n     STATUS   current\n     DESCRIPTION\n         \"The SNMP trap that is generated
    when an alarm\n         entry crosses its rising threshold and generates\n         an
    event that is configured for sending SNMP\n         traps.\"\n     ::= { rmonEventsV2
    1 }\n fallingAlarm NOTIFICATION-TYPE\n     OBJECTS { alarmIndex, alarmVariable,
    alarmSampleType,\n               alarmValue, alarmFallingThreshold }\n     STATUS
    \   current\n     DESCRIPTION\n         \"The SNMP trap that is generated when
    an alarm\n         entry crosses its falling threshold and generates\n         an
    event that is configured for sending SNMP\n         traps.\"\n     ::= { rmonEventsV2
    2 }\n -- Conformance information\n rmonCompliances OBJECT IDENTIFIER ::= { rmonConformance
    9 }\n rmonGroups      OBJECT IDENTIFIER ::= { rmonConformance 10 }\n -- Compliance
    Statements\n rmonCompliance MODULE-COMPLIANCE\n     STATUS current\n     DESCRIPTION\n
    \        \"The requirements for conformance to the RMON MIB. At least\n         one
    of the groups in this module must be implemented to\n         conform to the RMON
    MIB. Implementations of this MIB\n         must also implement the system group
    of MIB-II [16] and the\n         IF-MIB [17].\"\n     MODULE -- this module\n
    \      GROUP rmonEtherStatsGroup\n           DESCRIPTION\n               \"The
    RMON Ethernet Statistics Group is optional.\"\n       GROUP rmonHistoryControlGroup\n
    \          DESCRIPTION\n               \"The RMON History Control Group is optional.\"\n
    \      GROUP rmonEthernetHistoryGroup\n           DESCRIPTION\n               \"The
    RMON Ethernet History Group is optional.\"\n       GROUP rmonAlarmGroup\n           DESCRIPTION\n
    \              \"The RMON Alarm Group is optional.\"\n       GROUP rmonHostGroup\n
    \          DESCRIPTION\n               \"The RMON Host Group is mandatory when
    the\n               rmonHostTopNGroup is implemented.\"\n       GROUP rmonHostTopNGroup\n
    \          DESCRIPTION\n               \"The RMON Host Top N Group is optional.\"\n
    \      GROUP rmonMatrixGroup\n           DESCRIPTION\n               \"The RMON
    Matrix Group is optional.\"\n       GROUP rmonFilterGroup\n           DESCRIPTION\n
    \              \"The RMON Filter Group is mandatory when the\n               rmonPacketCaptureGroup
    is implemented.\"\n       GROUP rmonPacketCaptureGroup\n           DESCRIPTION\n
    \              \"The RMON Packet Capture Group is optional.\"\n       GROUP rmonEventGroup\n
    \          DESCRIPTION\n               \"The RMON Event Group is mandatory when
    the\n               rmonAlarmGroup is implemented.\"\n     ::= { rmonCompliances
    1 }\n     rmonEtherStatsGroup OBJECT-GROUP\n         OBJECTS {\n             etherStatsIndex,
    etherStatsDataSource,\n             etherStatsDropEvents, etherStatsOctets, etherStatsPkts,\n
    \            etherStatsBroadcastPkts, etherStatsMulticastPkts,\n             etherStatsCRCAlignErrors,
    etherStatsUndersizePkts,\n             etherStatsOversizePkts, etherStatsFragments,\n
    \            etherStatsJabbers, etherStatsCollisions,\n             etherStatsPkts64Octets,
    etherStatsPkts65to127Octets,\n             etherStatsPkts128to255Octets,\n             etherStatsPkts256to511Octets,\n
    \            etherStatsPkts512to1023Octets,\n             etherStatsPkts1024to1518Octets,\n
    \            etherStatsOwner, etherStatsStatus\n         }\n         STATUS current\n
    \        DESCRIPTION\n             \"The RMON Ethernet Statistics Group.\"\n         ::=
    { rmonGroups 1 }\n     rmonHistoryControlGroup OBJECT-GROUP\n         OBJECTS
    {\n             historyControlIndex, historyControlDataSource,\n             historyControlBucketsRequested,\n
    \            historyControlBucketsGranted, historyControlInterval,\n             historyControlOwner,
    historyControlStatus\n         }\n         STATUS current\n         DESCRIPTION\n
    \            \"The RMON History Control Group.\"\n         ::= { rmonGroups 2
    }\n     rmonEthernetHistoryGroup OBJECT-GROUP\n         OBJECTS {\n             etherHistoryIndex,
    etherHistorySampleIndex,\n             etherHistoryIntervalStart, etherHistoryDropEvents,\n
    \            etherHistoryOctets, etherHistoryPkts,\n             etherHistoryBroadcastPkts,
    etherHistoryMulticastPkts,\n             etherHistoryCRCAlignErrors, etherHistoryUndersizePkts,\n
    \            etherHistoryOversizePkts, etherHistoryFragments,\n             etherHistoryJabbers,
    etherHistoryCollisions,\n             etherHistoryUtilization\n         }\n         STATUS
    current\n         DESCRIPTION\n             \"The RMON Ethernet History Group.\"\n
    \        ::= { rmonGroups 3 }\n     rmonAlarmGroup OBJECT-GROUP\n         OBJECTS
    {\n             alarmIndex, alarmInterval, alarmVariable,\n             alarmSampleType,
    alarmValue, alarmStartupAlarm,\n             alarmRisingThreshold, alarmFallingThreshold,\n
    \            alarmRisingEventIndex, alarmFallingEventIndex,\n             alarmOwner,
    alarmStatus\n         }\n         STATUS current\n         DESCRIPTION\n             \"The
    RMON Alarm Group.\"\n         ::= { rmonGroups 4 }\n     rmonHostGroup OBJECT-GROUP\n
    \        OBJECTS {\n             hostControlIndex, hostControlDataSource,\n             hostControlTableSize,
    hostControlLastDeleteTime,\n             hostControlOwner, hostControlStatus,\n
    \            hostAddress, hostCreationOrder, hostIndex,\n             hostInPkts,
    hostOutPkts, hostInOctets,\n             hostOutOctets, hostOutErrors, hostOutBroadcastPkts,\n
    \            hostOutMulticastPkts, hostTimeAddress,\n             hostTimeCreationOrder,
    hostTimeIndex,\n             hostTimeInPkts, hostTimeOutPkts, hostTimeInOctets,\n
    \            hostTimeOutOctets, hostTimeOutErrors,\n             hostTimeOutBroadcastPkts,
    hostTimeOutMulticastPkts\n         }\n         STATUS current\n         DESCRIPTION\n
    \            \"The RMON Host Group.\"\n         ::= { rmonGroups 5 }\n     rmonHostTopNGroup
    OBJECT-GROUP\n         OBJECTS {\n             hostTopNControlIndex, hostTopNHostIndex,\n
    \            hostTopNRateBase, hostTopNTimeRemaining,\n             hostTopNDuration,
    hostTopNRequestedSize,\n             hostTopNGrantedSize, hostTopNStartTime,\n
    \            hostTopNOwner, hostTopNStatus,\n             hostTopNReport, hostTopNIndex,\n
    \            hostTopNAddress, hostTopNRate\n         }\n         STATUS current\n
    \        DESCRIPTION\n             \"The RMON Host Top 'N' Group.\"\n         ::=
    { rmonGroups 6 }\n     rmonMatrixGroup OBJECT-GROUP\n         OBJECTS {\n             matrixControlIndex,
    matrixControlDataSource,\n             matrixControlTableSize, matrixControlLastDeleteTime,\n
    \            matrixControlOwner, matrixControlStatus,\n             matrixSDSourceAddress,
    matrixSDDestAddress,\n             matrixSDIndex, matrixSDPkts,\n             matrixSDOctets,
    matrixSDErrors,\n             matrixDSSourceAddress, matrixDSDestAddress,\n             matrixDSIndex,
    matrixDSPkts,\n             matrixDSOctets, matrixDSErrors\n         }\n         STATUS
    current\n         DESCRIPTION\n             \"The RMON Matrix Group.\"\n         ::=
    { rmonGroups 7 }\n     rmonFilterGroup OBJECT-GROUP\n         OBJECTS {\n             filterIndex,
    filterChannelIndex, filterPktDataOffset,\n             filterPktData, filterPktDataMask,\n
    \            filterPktDataNotMask, filterPktStatus,\n             filterPktStatusMask,
    filterPktStatusNotMask,\n             filterOwner, filterStatus,\n             channelIndex,
    channelIfIndex, channelAcceptType,\n             channelDataControl, channelTurnOnEventIndex,\n
    \            channelTurnOffEventIndex, channelEventIndex,\n             channelEventStatus,
    channelMatches,\n             channelDescription, channelOwner, channelStatus\n
    \        }\n         STATUS current\n         DESCRIPTION\n             \"The
    RMON Filter Group.\"\n         ::= { rmonGroups 8 }\n     rmonPacketCaptureGroup
    OBJECT-GROUP\n         OBJECTS {\n             bufferControlIndex, bufferControlChannelIndex,\n
    \            bufferControlFullStatus, bufferControlFullAction,\n             bufferControlCaptureSliceSize,\n
    \            bufferControlDownloadSliceSize,\n             bufferControlDownloadOffset,\n
    \            bufferControlMaxOctetsRequested,\n             bufferControlMaxOctetsGranted,\n
    \            bufferControlCapturedPackets,\n             bufferControlTurnOnTime,\n
    \            bufferControlOwner, bufferControlStatus,\n             captureBufferControlIndex,
    captureBufferIndex,\n             captureBufferPacketID, captureBufferPacketData,\n
    \            captureBufferPacketLength, captureBufferPacketTime,\n             captureBufferPacketStatus\n
    \        }\n         STATUS current\n         DESCRIPTION\n             \"The
    RMON Packet Capture Group.\"\n         ::= { rmonGroups 9 }\n     rmonEventGroup
    OBJECT-GROUP\n         OBJECTS {\n             eventIndex, eventDescription, eventType,\n
    \            eventCommunity, eventLastTimeSent,\n             eventOwner, eventStatus,\n
    \            logEventIndex, logIndex, logTime,\n             logDescription\n
    \        }\n         STATUS current\n         DESCRIPTION\n             \"The
    RMON Event Group.\"\n         ::= { rmonGroups 10 }\n     rmonNotificationGroup
    NOTIFICATION-GROUP\n         NOTIFICATIONS { risingAlarm, fallingAlarm }\n         STATUS
    \       current\n         DESCRIPTION\n             \"The RMON Notification Group.\"\n
    \        ::= { rmonGroups 11 }\n END\n"
  title: 5.  Definitions
- contents:
  - "6.  Security Considerations\n   In order to implement this MIB, a probe must
    capture all packets on\n   the locally-attached network, including packets between
    third\n   parties.  These packets are analyzed to collect network addresses,\n
    \  protocol usage information, and conversation statistics. Data of this\n   nature
    may be considered sensitive in some environments. In such\n   environments the
    administrator may wish to restrict SNMP access to\n   the probe.\n   This MIB
    also includes functions for returning the contents of\n   captured packets, potentially
    including sensitive user data or\n   passwords. It is recommended that SNMP access
    to these functions be\n   restricted.\n   There are a number of management objects
    defined in this MIB that\n   have a MAX-ACCESS clause of read-write and/or read-create.
    \ Such\n   objects may be considered sensitive or vulnerable in some network\n
    \  environments.  The support for SET operations in a non-secure\n   environment
    without proper protection can have a negative effect on\n   network operations.\n
    \  SNMPv1 by itself is not a secure environment.  Even if the network\n   itself
    is secure (for example by using IPSec), even then, there is no\n   control as
    to who on the secure network is allowed to access and\n   GET/SET (read/change/create/delete)
    the objects in this MIB.\n   It is recommended that the implementors consider
    the security\n   features as provided by the SNMPv3 framework.  Specifically,
    the use\n   of the User-based Security Model RFC 2574 [12] and the View-based\n
    \  Access Control Model RFC 2575 [15] is recommended.\n   It is then a customer/user
    responsibility to ensure that the SNMP\n   entity giving access to an instance
    of this MIB, is properly\n   configured to give access to the objects only to
    those principals\n   (users) that have legitimate rights to indeed GET or SET\n
    \  (change/create/delete) them.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgments\n   This document was produced by the IETF Remote Network
    Monitoring\n   Working Group.\n"
  title: 7.  Acknowledgments
- contents:
  - "8.  Author's Address\n   Steve Waldbusser\n   Phone: +1-650-948-6500\n   Fax:
    \  +1-650-745-0671\n   Email: waldbusser@nextbeacon.com\n"
  title: 8.  Author's Address
- contents:
  - "9.  References\n   [1]  Harrington, D., Presuhn, R., and B. Wijnen, \"An Architecture
    for\n        Describing SNMP Management Frameworks\", RFC 2571, April 1999.\n
    \  [2]  Rose, M. and K. McCloghrie, \"Structure and Identification of\n        Management
    Information for TCP/IP-based Internets\", STD 16, RFC\n        1155, May 1990.\n
    \  [3]  Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n        RFC
    1212, March 1991.\n   [4]  Rose, M., \"A Convention for Defining Traps for use
    with the\n        SNMP\", RFC 1215, March 1991.\n   [5]  McCloghrie, K., Perkins,
    D., Schoenwaelder, J., Case, J., Rose,\n        M. and S. Waldbusser, \"Structure
    of Management Information\n        Version 2 (SMIv2)\", STD 58, RFC 2578, April
    1999.\n   [6]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose,\n
    \       M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58,\n        RFC
    2579, April 1999.\n   [7]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case,
    J., Rose,\n        M. and S. Waldbusser, \"Conformance Statements for SMIv2\",
    STD\n        58, RFC 2580, April 1999.\n   [8]  Case, J., Fedor, M., Schoffstall,
    M. and J. Davin, \"Simple\n        Network Management Protocol\", STD 15, RFC
    1157, May 1990.\n   [9]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n
    \       \"Introduction to Community-based SNMPv2\", RFC 1901, January\n        1996.\n
    \  [10] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Transport\n        Mappings
    for Version 2 of the Simple Network Management Protocol\n        (SNMPv2)\", RFC
    1906, January 1996.\n   [11] Case, J., Harrington D., Presuhn R. and B. Wijnen,
    \"Message\n        Processing and Dispatching for the Simple Network Management\n
    \       Protocol (SNMP)\", RFC 2572, April 1999.\n   [12] Blumenthal, U. and B.
    Wijnen, \"User-based Security Model (USM)\n        for version 3 of the Simple
    Network Management Protocol\n        (SNMPv3)\", RFC 2574, April 1999.\n   [13]
    Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol\n        Operations
    for Version 2 of the Simple Network Management\n        Protocol (SNMPv2)\", RFC
    1905, January 1996.\n   [14] Levi, D., Meyer, P. and B. Stewart, \"SNMPv3 Applications\",
    RFC\n        2573, April 1999.\n   [15] Wijnen, B., Presuhn, R. and K. McCloghrie,
    \"View-based Access\n        Control Model (VACM) for the Simple Network Management
    Protocol\n        (SNMP)\", RFC 2575, April 1999.\n   [16] McCloghrie, K. and
    M. Rose, Editors, \"Management Information\n        Base for Network Management
    of TCP/IP-based internets: MIB-II\",\n        STD 17, RFC 1213, March 1991.\n
    \  [17] McCloghrie, K. and F. Kastenholz, \"The Interfaces Group MIB\n        using
    SMIv2\", RFC 2233, November 1997.\n   [18] Waldbusser, S., \"Remote Network Monitoring
    MIB\", RFC 1757,\n        February 1995.\n   [19] Waldbusser, S., \"Token Ring
    Extensions to the Remote Network\n        Monitoring MIB\", RFC 1513, September
    1993.\n   [20] Waldbusser, S., \"Remote Network Monitoring Management\n        Information
    Base Version 2 using SMIv2\", RFC 2021, January 1997.\n   [21] Waterman, R., Lahaye,
    B., Romascanu, D. and S.  Waldbusser,\n        \"Remote Network Monitoring MIB
    Extensions for Switched Networks\n        Version 1.0\", RFC 2613, June 1999.\n
    \  [22] Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction\n        to
    Version 3 of the Internet-standard Network Management\n        Framework\", RFC
    2570, April 1999.\n"
  title: 9.  References
- contents:
  - "10.  Intellectual Property\n   The IETF takes no position regarding the validity
    or scope of any\n   intellectual property or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; neither does it represent that it\n   has made any effort to
    identify any such rights.  Information on the\n   IETF's procedures with respect
    to rights in standards-track and\n   standards-related documentation can be found
    in BCP-11.  Copies of\n   claims of rights made available for publication and
    any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 10.  Intellectual Property
- contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 11.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
