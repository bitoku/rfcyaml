- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                       A. Rundgren
  contents:
  - "Independent Submission                                       A. Rundgren\n  \
    \                 JSON Canonicalization Scheme (JCS)\n"
- title: Abstract
  contents:
  - "Abstract\n   Cryptographic operations like hashing and signing need the data\
    \ to be\n   expressed in an invariant format so that the operations are reliably\n\
    \   repeatable.  One way to address this is to create a canonical\n   representation\
    \ of the data.  Canonicalization also permits data to be\n   exchanged in its\
    \ original form on the \"wire\" while cryptographic\n   operations performed on\
    \ the canonicalized counterpart of the data in\n   the producer and consumer endpoints\
    \ generate consistent results.\n   This document describes the JSON Canonicalization\
    \ Scheme (JCS).  This\n   specification defines how to create a canonical representation\
    \ of\n   JSON data by building on the strict serialization methods for JSON\n\
    \   primitives defined by ECMAScript, constraining JSON data to the\n   Internet\
    \ JSON (I-JSON) subset, and by using deterministic property\n   sorting.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not candidates for any level of Internet\
    \ Standard;\n   see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8785.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Terminology\n   3.  Detailed Operation\n\
    \     3.1.  Creation of Input Data\n     3.2.  Generation of Canonical JSON Data\n\
    \       3.2.1.  Whitespace\n       3.2.2.  Serialization of Primitive Data Types\n\
    \         3.2.2.1.  Serialization of Literals\n         3.2.2.2.  Serialization\
    \ of Strings\n         3.2.2.3.  Serialization of Numbers\n       3.2.3.  Sorting\
    \ of Object Properties\n       3.2.4.  UTF-8 Generation\n   4.  IANA Considerations\n\
    \   5.  Security Considerations\n   6.  References\n     6.1.  Normative References\n\
    \     6.2.  Informative References\n   Appendix A.  ECMAScript Sample Canonicalizer\n\
    \   Appendix B.  Number Serialization Samples\n   Appendix C.  Canonicalized JSON\
    \ as \"Wire Format\"\n   Appendix D.  Dealing with Big Numbers\n   Appendix E.\
    \  String Subtype Handling\n     E.1.  Subtypes in Arrays\n   Appendix F.  Implementation\
    \ Guidelines\n   Appendix G.  Open-Source Implementations\n   Appendix H.  Other\
    \ JSON Canonicalization Efforts\n   Appendix I.  Development Portal\n   Acknowledgements\n\
    \   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the JSON Canonicalization Scheme\
    \ (JCS).  This\n   specification defines how to create a canonical representation\
    \ of\n   JSON [RFC8259] data by building on the strict serialization methods\n\
    \   for JSON primitives defined by ECMAScript [ECMA-262], constraining\n   JSON\
    \ data to the I-JSON [RFC7493] subset, and by using deterministic\n   property\
    \ sorting.  The output from JCS is a \"hashable\" representation\n   of JSON data\
    \ that can be used by cryptographic methods.  The\n   subsequent paragraphs outline\
    \ the primary design considerations.\n   Cryptographic operations like hashing\
    \ and signing need the data to be\n   expressed in an invariant format so that\
    \ the operations are reliably\n   repeatable.  One way to accomplish this is to\
    \ convert the data into a\n   format that has a simple and fixed representation,\
    \ like base64url\n   [RFC4648].  This is how JSON Web Signature (JWS) [RFC7515]\
    \ addressed\n   this issue.  Another solution is to create a canonical version\
    \ of the\n   data, similar to what was done for the XML signature [XMLDSIG]\n\
    \   standard.\n   The primary advantage with a canonicalizing scheme is that data\
    \ can\n   be kept in its original form.  This is the core rationale behind JCS.\n\
    \   Put another way, using canonicalization enables a JSON object to\n   remain\
    \ a JSON object even after being signed.  This can simplify\n   system design,\
    \ documentation, and logging.\n   To avoid \"reinventing the wheel\", JCS relies\
    \ on the serialization of\n   JSON primitives (strings, numbers, and literals),\
    \ as defined by\n   ECMAScript (aka JavaScript) [ECMA-262] beginning with version\
    \ 6.\n   Seasoned XML developers may recall difficulties getting XML\n   signatures\
    \ to validate.  This was usually due to different\n   interpretations of the quite\
    \ intricate XML canonicalization rules as\n   well as of the equally complex Web\
    \ Services security standards.  The\n   reasons why JCS should not suffer from\
    \ similar issues are:\n   *  JSON does not have a namespace concept and default\
    \ values.\n   *  Data is constrained to the I-JSON [RFC7493] subset.  This\n \
    \     eliminates the need for specific parsers for dealing with\n      canonicalization.\n\
    \   *  JCS-compatible serialization of JSON primitives is currently\n      supported\
    \ by most web browsers as well as by Node.js [NODEJS].\n   *  The full JCS specification\
    \ is currently supported by multiple\n      open-source implementations (see Appendix\
    \ G).  See also Appendix F\n      for implementation guidelines.\n   JCS is compatible\
    \ with some existing systems relying on JSON\n   canonicalization such as JSON\
    \ Web Key (JWK) Thumbprint [RFC7638] and\n   Keybase [KEYBASE].\n   For potential\
    \ uses outside of cryptography, see [JSONCOMP].\n   The intended audiences of\
    \ this document are JSON tool vendors as well\n   as designers of JSON-based cryptographic\
    \ solutions.  The reader is\n   assumed to be knowledgeable in ECMAScript, including\
    \ the \"JSON\"\n   object.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   Note that this document is not on the IETF standards track.\
    \  However,\n   a conformant implementation is supposed to adhere to the specified\n\
    \   behavior for security and interoperability reasons.  This text uses\n   BCP\
    \ 14 to describe that necessary behavior.\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 3.  Detailed Operation
  contents:
  - "3.  Detailed Operation\n   This section describes the details related to creating\
    \ a canonical\n   JSON representation and how they are addressed by JCS.\n   Appendix\
    \ F describes the RECOMMENDED way of adding JCS support to\n   existing JSON tools.\n"
- title: 3.1.  Creation of Input Data
  contents:
  - "3.1.  Creation of Input Data\n   Data to be canonically serialized is usually\
    \ created by:\n   *  Parsing previously generated JSON data.\n   *  Programmatically\
    \ creating data.\n   Irrespective of the method used, the data to be serialized\
    \ MUST be\n   adapted for I-JSON [RFC7493] formatting, which implies the following:\n\
    \   *  JSON objects MUST NOT exhibit duplicate property names.\n   *  JSON string\
    \ data MUST be expressible as Unicode [UNICODE].\n   *  JSON number data MUST\
    \ be expressible as IEEE 754 [IEEE754] double-\n      precision values.  For applications\
    \ needing higher precision or\n      longer integers than offered by IEEE 754\
    \ double precision, it is\n      RECOMMENDED to represent such numbers as JSON\
    \ strings; see\n      Appendix D for details on how this can be performed in an\n\
    \      interoperable and extensible way.\n   An additional constraint is that\
    \ parsed JSON string data MUST NOT be\n   altered during subsequent serializations.\
    \  For more information, see\n   Appendix E.\n   Note: Although the Unicode standard\
    \ offers the possibility of\n   rearranging certain character sequences, referred\
    \ to as \"Unicode\n   Normalization\" [UCNORM], JCS-compliant string processing\
    \ does not\n   take this into consideration.  That is, all components involved\
    \ in a\n   scheme depending on JCS MUST preserve Unicode string data \"as is\"\
    .\n"
- title: 3.2.  Generation of Canonical JSON Data
  contents:
  - "3.2.  Generation of Canonical JSON Data\n   The following subsections describe\
    \ the steps required to create a\n   canonical JSON representation of the data\
    \ elaborated on in the\n   previous section.\n   Appendix A shows sample code\
    \ for an ECMAScript-based canonicalizer,\n   matching the JCS specification.\n"
- title: 3.2.1.  Whitespace
  contents:
  - "3.2.1.  Whitespace\n   Whitespace between JSON tokens MUST NOT be emitted.\n"
- title: 3.2.2.  Serialization of Primitive Data Types
  contents:
  - "3.2.2.  Serialization of Primitive Data Types\n   Assume the following JSON object\
    \ is parsed:\n     {\n       \"numbers\": [333333333.33333329, 1E30, 4.50,\n \
    \                  2e-3, 0.000000000000000000000000001],\n       \"string\": \"\
    \\u20ac$\\u000F\\u000aA'\\u0042\\u0022\\u005c\\\\\\\"\\/\",\n       \"literals\"\
    : [null, true, false]\n     }\n   If the parsed data is subsequently serialized\
    \ using a serializer\n   compliant with ECMAScript's \"JSON.stringify()\", the\
    \ result would\n   (with a line wrap added for display purposes only) be rather\n\
    \   divergent with respect to the original data:\n     {\"numbers\":[333333333.3333333,1e+30,4.5,0.002,1e-27],\"\
    string\":\n     \"\u20AC$\\u000f\\nA'B\\\"\\\\\\\\\\\"/\",\"literals\":[null,true,false]}\n\
    \   The reason for the difference between the parsed data and its\n   serialized\
    \ counterpart is due to a wide tolerance on input data (as\n   defined by JSON\
    \ [RFC8259]), while output data (as defined by\n   ECMAScript) has a fixed representation.\
    \  As can be seen in the\n   example, numbers are subject to rounding as well.\n\
    \   The following subsections describe the serialization of primitive\n   JSON\
    \ data types according to JCS.  This part is identical to that of\n   ECMAScript.\
    \  In the (unlikely) event that a future version of\n   ECMAScript would invalidate\
    \ any of the following serialization\n   methods, it will be up to the developer\
    \ community to either stick to\n   this specification or create a new specification.\n"
- title: 3.2.2.1.  Serialization of Literals
  contents:
  - "3.2.2.1.  Serialization of Literals\n   In accordance with JSON [RFC8259], the\
    \ literals \"null\", \"true\", and\n   \"false\" MUST be serialized as null, true,\
    \ and false, respectively.\n"
- title: 3.2.2.2.  Serialization of Strings
  contents:
  - "3.2.2.2.  Serialization of Strings\n   For JSON string data (which includes JSON\
    \ object property names as\n   well), each Unicode code point MUST be serialized\
    \ as described below\n   (see Section 24.3.2.2 of [ECMA-262]):\n   *  If the Unicode\
    \ value falls within the traditional ASCII control\n      character range (U+0000\
    \ through U+001F), it MUST be serialized\n      using lowercase hexadecimal Unicode\
    \ notation (\\uhhhh) unless it is\n      in the set of predefined JSON control\
    \ characters U+0008, U+0009,\n      U+000A, U+000C, or U+000D, which MUST be serialized\
    \ as \\b, \\t, \\n,\n      \\f, and \\r, respectively.\n   *  If the Unicode value\
    \ is outside of the ASCII control character\n      range, it MUST be serialized\
    \ \"as is\" unless it is equivalent to\n      U+005C (\\) or U+0022 (\"), which\
    \ MUST be serialized as \\\\ and \\\",\n      respectively.\n   Finally, the resulting\
    \ sequence of Unicode code points MUST be\n   enclosed in double quotes (\").\n\
    \   Note: Since invalid Unicode data like \"lone surrogates\" (e.g.,\n   U+DEAD)\
    \ may lead to interoperability issues including broken\n   signatures, occurrences\
    \ of such data MUST cause a compliant JCS\n   implementation to terminate with\
    \ an appropriate error.\n"
- title: 3.2.2.3.  Serialization of Numbers
  contents:
  - "3.2.2.3.  Serialization of Numbers\n   ECMAScript builds on the IEEE 754 [IEEE754]\
    \ double-precision standard\n   for representing JSON number data.  Such data\
    \ MUST be serialized\n   according to Section 7.1.12.1 of [ECMA-262], including\
    \ the \"Note 2\"\n   enhancement.\n   Due to the relative complexity of this part,\
    \ the algorithm itself is\n   not included in this document.  For implementers\
    \ of JCS-compliant\n   number serialization, Google's implementation in V8 [V8]\
    \ may serve as\n   a reference.  Another compatible number serialization reference\n\
    \   implementation is Ryu [RYU], which is used by the JCS open-source\n   Java\
    \ implementation mentioned in Appendix G.  Appendix B holds a set\n   of IEEE\
    \ 754 sample values and their corresponding JSON serialization.\n   Note: Since\
    \ Not a Number (NaN) and Infinity are not permitted in\n   JSON, occurrences of\
    \ NaN or Infinity MUST cause a compliant JCS\n   implementation to terminate with\
    \ an appropriate error.\n"
- title: 3.2.3.  Sorting of Object Properties
  contents:
  - "3.2.3.  Sorting of Object Properties\n   Although the previous step normalized\
    \ the representation of primitive\n   JSON data types, the result would not yet\
    \ qualify as \"canonical\"\n   since JSON object properties are not in lexicographic\
    \ (alphabetical)\n   order.\n   Applied to the sample in Section 3.2.2, a properly\
    \ canonicalized\n   version should (with a line wrap added for display purposes\
    \ only)\n   read as:\n     {\"literals\":[null,true,false],\"numbers\":[333333333.3333333,\n\
    \     1e+30,4.5,0.002,1e-27],\"string\":\"\u20AC$\\u000f\\nA'B\\\"\\\\\\\\\\\"\
    /\"}\n   The rules for lexicographic sorting of JSON object properties\n   according\
    \ to JCS are as follows:\n   *  JSON object properties MUST be sorted recursively,\
    \ which means\n      that JSON child Objects MUST have their properties sorted\
    \ as well.\n   *  JSON array data MUST also be scanned for the presence of JSON\n\
    \      objects (if an object is found, then its properties MUST be\n      sorted),\
    \ but array element order MUST NOT be changed.\n   When a JSON object is about\
    \ to have its properties sorted, the\n   following measures MUST be adhered to:\n\
    \   *  The sorting process is applied to property name strings in their\n    \
    \  \"raw\" (unescaped) form.  That is, a newline character is treated\n      as\
    \ U+000A.\n   *  Property name strings to be sorted are formatted as arrays of\n\
    \      UTF-16 [UNICODE] code units.  The sorting is based on pure value\n    \
    \  comparisons, where code units are treated as unsigned integers,\n      independent\
    \ of locale settings.\n   *  Property name strings either have different values\
    \ at some index\n      that is a valid index for both strings, or their lengths\
    \ are\n      different, or both.  If they have different values at one or more\n\
    \      index positions, let k be the smallest such index; then, the\n      string\
    \ whose value at position k has the smaller value, as\n      determined by using\
    \ the \"<\" operator, lexicographically precedes\n      the other string.  If\
    \ there is no index position at which they\n      differ, then the shorter string\
    \ lexicographically precedes the\n      longer string.\n      In plain English,\
    \ this means that property names are sorted in\n      ascending order like the\
    \ following:\n              \"\"\n              \"a\"\n              \"aa\"\n\
    \              \"ab\"\n   The rationale for basing the sorting algorithm on UTF-16\
    \ code units\n   is that it maps directly to the string type in ECMAScript (featured\n\
    \   in web browsers and Node.js), Java, and .NET.  In addition, JSON only\n  \
    \ supports escape sequences expressed as UTF-16 code units, making\n   knowledge\
    \ and handling of such data a necessity anyway.  Systems\n   using another internal\
    \ representation of string data will need to\n   convert JSON property name strings\
    \ into arrays of UTF-16 code units\n   before sorting.  The conversion from UTF-8\
    \ or UTF-32 to UTF-16 is\n   defined by the Unicode [UNICODE] standard.\n   The\
    \ following JSON test data can be used for verifying the\n   correctness of the\
    \ sorting scheme in a JCS implementation:\n     {\n       \"\\u20ac\": \"Euro\
    \ Sign\",\n       \"\\r\": \"Carriage Return\",\n       \"\\ufb33\": \"Hebrew\
    \ Letter Dalet With Dagesh\",\n       \"1\": \"One\",\n       \"\\ud83d\\ude00\"\
    : \"Emoji: Grinning Face\",\n       \"\\u0080\": \"Control\",\n       \"\\u00f6\"\
    : \"Latin Small Letter O With Diaeresis\"\n     }\n   Expected argument order\
    \ after sorting property strings:\n     \"Carriage Return\"\n     \"One\"\n  \
    \   \"Control\"\n     \"Latin Small Letter O With Diaeresis\"\n     \"Euro Sign\"\
    \n     \"Emoji: Grinning Face\"\n     \"Hebrew Letter Dalet With Dagesh\"\n  \
    \ Note: For the purpose of obtaining a deterministic property order,\n   sorting\
    \ of data encoded in UTF-8 or UTF-32 would also work, but the\n   outcome for\
    \ JSON data like above would differ and thus be\n   incompatible with this specification.\
    \  However, in practice, property\n   names are rarely defined outside of 7-bit\
    \ ASCII, making it possible\n   to sort string data in UTF-8 or UTF-32 format\
    \ without conversion to\n   UTF-16 and still be compatible with JCS.  Whether\
    \ or not this is a\n   viable option depends on the environment JCS is used in.\n"
- title: 3.2.4.  UTF-8 Generation
  contents:
  - "3.2.4.  UTF-8 Generation\n   Finally, in order to create a platform-independent\
    \ representation,\n   the result of the preceding step MUST be encoded in UTF-8.\n\
    \   Applied to the sample in Section 3.2.3, this should yield the\n   following\
    \ bytes, here shown in hexadecimal notation:\n     7b 22 6c 69 74 65 72 61 6c\
    \ 73 22 3a 5b 6e 75 6c 6c 2c 74 72\n     75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75\
    \ 6d 62 65 72 73 22 3a\n     5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33\
    \ 33 2c 31\n     65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37\n\
    \     5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30\n     30 66\
    \ 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d\n   This data is intended to\
    \ be usable as input to cryptographic methods.\n"
- title: 4.  IANA Considerations
  contents:
  - "4.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   It is crucial to perform sanity checks on input\
    \ data to avoid\n   overflowing buffers and similar things that could affect the\n\
    \   integrity of the system.\n   When JCS is applied to signature schemes like\
    \ the one described in\n   Appendix F, applications MUST perform the following\
    \ operations before\n   acting upon received data:\n   1.  Parse the JSON data\
    \ and verify that it adheres to I-JSON.\n   2.  Verify the data for correctness\
    \ according to the conventions\n       defined by the ecosystem where it is to\
    \ be used.  This also\n       includes locating the property holding the signature\
    \ data.\n   3.  Verify the signature.\n   If any of these steps fail, the operation\
    \ in progress MUST be\n   aborted.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [ECMA-262] ECMA International, \"ECMAScript 2019\
    \ Language\n              Specification\", Standard ECMA-262 10th Edition, June\
    \ 2019,\n              <https://www.ecma-international.org/ecma-262/10.0/\n  \
    \            index.html>.\n   [IEEE754]  IEEE, \"IEEE Standard for Floating-Point\
    \ Arithmetic\", IEEE\n              754-2019, DOI 10.1109/IEEESTD.2019.8766229,\n\
    \              <https://ieeexplore.ieee.org/document/8766229>.\n   [RFC2119] \
    \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC7493]  Bray,\
    \ T., Ed., \"The I-JSON Message Format\", RFC 7493,\n              DOI 10.17487/RFC7493,\
    \ March 2015,\n              <https://www.rfc-editor.org/info/rfc7493>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8259]  Bray, T., Ed., \"\
    The JavaScript Object Notation (JSON) Data\n              Interchange Format\"\
    , STD 90, RFC 8259,\n              DOI 10.17487/RFC8259, December 2017,\n    \
    \          <https://www.rfc-editor.org/info/rfc8259>.\n   [UCNORM]   The Unicode\
    \ Consortium, \"Unicode Normalization Forms\",\n              <https://www.unicode.org/reports/tr15/>.\n\
    \   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n           \
    \   <https://www.unicode.org/versions/latest/>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [JSONCOMP] Rundgren, A., \"\"Comparable\" JSON\
    \ (JSONCOMP)\", Work in\n              Progress, Internet-Draft, draft-rundgren-comparable-json-\n\
    \              04, 13 February 2019, <https://tools.ietf.org/html/draft-\n   \
    \           rundgren-comparable-json-04>.\n   [KEYBASE]  Keybase, \"Canonical\
    \ Packings for JSON and Msgpack\",\n              <https://keybase.io/docs/api/1.0/canonical_packings>.\n\
    \   [NODEJS]   OpenJS Foundation, \"Node.js\", <https://nodejs.org>.\n   [OPENAPI]\
    \  OpenAPI Initiative, \"The OpenAPI Specification: a broadly\n              adopted\
    \ industry standard for describing modern APIs\",\n              <https://www.openapis.org/>.\n\
    \   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n        \
    \      Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n          \
    \    <https://www.rfc-editor.org/info/rfc4648>.\n   [RFC7515]  Jones, M., Bradley,\
    \ J., and N. Sakimura, \"JSON Web\n              Signature (JWS)\", RFC 7515,\
    \ DOI 10.17487/RFC7515, May\n              2015, <https://www.rfc-editor.org/info/rfc7515>.\n\
    \   [RFC7638]  Jones, M. and N. Sakimura, \"JSON Web Key (JWK)\n             \
    \ Thumbprint\", RFC 7638, DOI 10.17487/RFC7638, September\n              2015,\
    \ <https://www.rfc-editor.org/info/rfc7638>.\n   [RYU]      \"Ryu floating point\
    \ number serializing algorithm\", commit\n              27d3c55, May 2020, <https://github.com/ulfjack/ryu>.\n\
    \   [V8]       Google LLC, \"What is V8?\", <https://v8.dev/>.\n   [XMLDSIG] \
    \ W3C, \"XML Signature Syntax and Processing Version 1.1\",\n              W3C\
    \ Recommendation, April 2013,\n              <https://www.w3.org/TR/xmldsig-core1/>.\n"
- title: Appendix A.  ECMAScript Sample Canonicalizer
  contents:
  - "Appendix A.  ECMAScript Sample Canonicalizer\n   Below is an example of a JCS\
    \ canonicalizer for usage with ECMAScript-\n   based systems:\n     // Since the\
    \ primary purpose of this code is highlighting //\n     // the core of the JCS\
    \ algorithm, error handling and      //\n     // UTF-8 generation were not implemented.\
    \                 //\n     var canonicalize = function(object) {\n         var\
    \ buffer = '';\n         serialize(object);\n         return buffer;\n       \
    \  function serialize(object) {\n             if (object === null || typeof object\
    \ !== 'object' ||\n                 object.toJSON != null) {\n               \
    \  // Primitive type or toJSON, use \"JSON\"        //\n                 buffer\
    \ += JSON.stringify(object);\n             } else if (Array.isArray(object)) {\n\
    \                 // Array - Maintain element order              //\n        \
    \         buffer += '[';\n                 let next = false;\n               \
    \  object.forEach((element) => {\n                     if (next) {\n         \
    \                buffer += ',';\n                     }\n                    \
    \ next = true;\n                     // Array element - Recursive expansion //\n\
    \                     serialize(element);\n                 });\n            \
    \     buffer += ']';\n             } else {\n                 // Object - Sort\
    \ properties before serializing //\n                 buffer += '{';\n        \
    \         let next = false;\n                 Object.keys(object).sort().forEach((property)\
    \ => {\n                     if (next) {\n                         buffer += ',';\n\
    \                     }\n                     next = true;\n                 \
    \    // Property names are strings, use \"JSON\"  //\n                     buffer\
    \ += JSON.stringify(property);\n                     buffer += ':';\n        \
    \             // Property value - Recursive expansion //\n                   \
    \  serialize(object[property]);\n                 });\n                 buffer\
    \ += '}';\n             }\n         }\n     };\n"
- title: Appendix B.  Number Serialization Samples
  contents:
  - "Appendix B.  Number Serialization Samples\n   The following table holds a set\
    \ of ECMAScript-compatible number\n   serialization samples, including some edge\
    \ cases.  The column \"IEEE\n   754\" refers to the internal ECMAScript representation\
    \ of the \"Number\"\n   data type, which is based on the IEEE 754 [IEEE754] standard\
    \ using\n   64-bit (double-precision) values, here expressed in hexadecimal.\n\
    \   |     IEEE 754     |    JSON Representation    |      Comment       |\n  \
    \ | 0000000000000000 | 0                         | Zero               |\n   |\
    \ 8000000000000000 | 0                         | Minus zero         |\n   | 0000000000000001\
    \ | 5e-324                    | Min pos number     |\n   | 8000000000000001 |\
    \ -5e-324                   | Min neg number     |\n   | 7fefffffffffffff | 1.7976931348623157e+308\
    \   | Max pos number     |\n   | ffefffffffffffff | -1.7976931348623157e+308 \
    \ | Max neg number     |\n   | 4340000000000000 | 9007199254740992          |\
    \ Max pos int    (1) |\n   | c340000000000000 | -9007199254740992         | Max\
    \ neg int    (1) |\n   | 4430000000000000 | 295147905179352830000     | ~2**68\
    \         (2) |\n   | 7fffffffffffffff |                           | NaN     \
    \       (3) |\n   | 7ff0000000000000 |                           | Infinity  \
    \     (3) |\n   | 44b52d02c7e14af5 | 9.999999999999997e+22     |             \
    \       |\n   | 44b52d02c7e14af6 | 1e+23                     |               \
    \     |\n   | 44b52d02c7e14af7 | 1.0000000000000001e+23    |                 \
    \   |\n   | 444b1ae4d6e2ef4e | 999999999999999700000     |                   \
    \ |\n   | 444b1ae4d6e2ef4f | 999999999999999900000     |                    |\n\
    \   | 444b1ae4d6e2ef50 | 1e+21                     |                    |\n  \
    \ | 3eb0c6f7a0b5ed8c | 9.999999999999997e-7      |                    |\n   |\
    \ 3eb0c6f7a0b5ed8d | 0.000001                  |                    |\n   | 41b3de4355555553\
    \ | 333333333.3333332         |                    |\n   | 41b3de4355555554 |\
    \ 333333333.33333325        |                    |\n   | 41b3de4355555555 | 333333333.3333333\
    \         |                    |\n   | 41b3de4355555556 | 333333333.3333334  \
    \       |                    |\n   | 41b3de4355555557 | 333333333.33333343   \
    \     |                    |\n   | becbf647612f3696 | -0.0000033333333333333333\
    \ |                    |\n   | 43143ff3c1cb0959 | 1424953923781206.2        |\
    \ Round to even  (4) |\n      Table 1: ECMAScript-Compatible JSON Number Serialization\
    \ Samples\n   Notes:\n   (1)  For maximum compliance with the ECMAScript \"JSON\"\
    \ object, values\n        that are to be interpreted as true integers SHOULD be\
    \ in the\n        range -9007199254740991 to 9007199254740991.  However, how\n\
    \        numbers are used in applications does not affect the JCS\n        algorithm.\n\
    \   (2)  Although a set of specific integers like 2**68 could be regarded\n  \
    \      as having extended precision, the JCS/ECMAScript number\n        serialization\
    \ algorithm does not take this into consideration.\n   (3)  Values out of range\
    \ are not permitted in JSON.  See\n        Section 3.2.2.3.\n   (4)  This number\
    \ is exactly 1424953923781206.25 but will, after the\n        \"Note 2\" rule\
    \ mentioned in Section 3.2.2.3, be truncated and\n        rounded to the closest\
    \ even value.\n   For a more exhaustive validation of a JCS number serializer,\
    \ you may\n   test against a file (currently) available in the development portal\n\
    \   (see Appendix I) containing a large set of sample values.  Another\n   option\
    \ is running V8 [V8] as a live reference together with a program\n   generating\
    \ a substantial amount of random IEEE 754 values.\n"
- title: Appendix C.  Canonicalized JSON as "Wire Format"
  contents:
  - "Appendix C.  Canonicalized JSON as \"Wire Format\"\n   Since the result from\
    \ the canonicalization process (see\n   Section 3.2.4) is fully valid JSON, it\
    \ can also be used as \"Wire\n   Format\".  However, this is just an option since\
    \ cryptographic schemes\n   based on JCS, in most cases, would not depend on that\
    \ externally\n   supplied JSON data already being canonicalized.\n   In fact,\
    \ the ECMAScript standard way of serializing objects using\n   \"JSON.stringify()\"\
    \ produces a more \"logical\" format, where properties\n   are kept in the order\
    \ they were created or received.  The example\n   below shows an address record\
    \ that could benefit from ECMAScript\n   standard serialization:\n     {\n   \
    \    \"name\": \"John Doe\",\n       \"address\": \"2000 Sunset Boulevard\",\n\
    \       \"city\": \"Los Angeles\",\n       \"zip\": \"90001\",\n       \"state\"\
    : \"CA\"\n     }\n   Using canonicalization, the properties above would be output\
    \ in the\n   order \"address\", \"city\", \"name\", \"state\", and \"zip\", which\
    \ adds\n   fuzziness to the data from a human (developer or technical support)\n\
    \   perspective.  Canonicalization also converts JSON data into a single\n   line\
    \ of text, which may be less than ideal for debugging and logging.\n"
- title: Appendix D.  Dealing with Big Numbers
  contents:
  - "Appendix D.  Dealing with Big Numbers\n   There are several issues associated\
    \ with the JSON number type, here\n   illustrated by the following sample object:\n\
    \     {\n       \"giantNumber\": 1.4e+9999,\n       \"payMeThis\": 26000.33,\n\
    \       \"int64Max\": 9223372036854775807\n     }\n   Although the sample above\
    \ conforms to JSON [RFC8259], applications\n   would normally use different native\
    \ data types for storing\n   \"giantNumber\" and \"int64Max\".  In addition, monetary\
    \ data like\n   \"payMeThis\" would presumably not rely on floating-point data\
    \ types\n   due to rounding issues with respect to decimal arithmetic.\n   The\
    \ established way of handling this kind of \"overloading\" of the\n   JSON number\
    \ type (at least in an extensible manner) is through\n   mapping mechanisms, instructing\
    \ parsers what to do with different\n   properties based on their name.  However,\
    \ this greatly limits the\n   value of using the JSON number type outside of its\
    \ original, somewhat\n   constrained JavaScript context.  The ECMAScript \"JSON\"\
    \ object does\n   not support mappings to the JSON number type either.\n   Due\
    \ to the above, numbers that do not have a natural place in the\n   current JSON\
    \ ecosystem MUST be wrapped using the JSON string type.\n   This is close to a\
    \ de facto standard for open systems.  This is also\n   applicable for other data\
    \ types that do not have direct support in\n   JSON, like \"DateTime\" objects\
    \ as described in Appendix E.\n   Aided by a system using the JSON string type,\
    \ be it programmatic like\n     var obj = JSON.parse('{\"giantNumber\": \"1.4e+9999\"\
    }');\n     var biggie = new BigNumber(obj.giantNumber);\n   or declarative schemes\
    \ like OpenAPI [OPENAPI], JCS imposes no limits\n   on applications, including\
    \ when using ECMAScript.\n"
- title: Appendix E.  String Subtype Handling
  contents:
  - "Appendix E.  String Subtype Handling\n   Due to the limited set of data types\
    \ featured in JSON, the JSON\n   string type is commonly used for holding subtypes.\
    \  This can,\n   depending on JSON parsing method, lead to interoperability problems,\n\
    \   which MUST be dealt with by JCS-compliant applications targeting a\n   wider\
    \ audience.\n   Assume you want to parse a JSON object where the schema designer\n\
    \   assigned the property \"big\" for holding a \"BigInt\" subtype and \"time\"\
    \n   for holding a \"DateTime\" subtype, while \"val\" is supposed to be a\n \
    \  JSON number compliant with JCS.  The following example shows such an\n   object:\n\
    \     {\n       \"time\": \"2019-01-28T07:45:10Z\",\n       \"big\": \"055\",\n\
    \       \"val\": 3.5\n     }\n   Parsing of this object can be accomplished by\
    \ the following\n   ECMAScript statement:\n     var object = JSON.parse(JSON_object_featured_as_a_string);\n\
    \   After parsing, the actual data can be extracted, which for subtypes,\n   also\
    \ involves a conversion step using the result of the parsing\n   process (an ECMAScript\
    \ object) as input:\n     ... = new Date(object.time); // Date object\n     ...\
    \ = BigInt(object.big);    // Big integer\n     ... = object.val;            //\
    \ JSON/JS number\n   Note that the \"BigInt\" data type is currently only natively\
    \ supported\n   by V8 [V8].\n   Canonicalization of \"object\" using the sample\
    \ code in Appendix A\n   would return the following string:\n     {\"big\":\"\
    055\",\"time\":\"2019-01-28T07:45:10Z\",\"val\":3.5}\n   Although this is (with\
    \ respect to JCS) technically correct, there is\n   another way of parsing JSON\
    \ data, which also can be used with\n   ECMAScript as shown below:\n     // \"\
    BigInt\" requires the following code to become JSON serializable\n     BigInt.prototype.toJSON\
    \ = function() {\n         return this.toString();\n     };\n     // JSON parsing\
    \ using a \"stream\"-based method\n     var object = JSON.parse(JSON_object_featured_as_a_string,\n\
    \         (k,v) => k == 'time' ? new Date(v) : k == 'big' ? BigInt(v) : v\n  \
    \   );\n   If you now apply the canonicalizer in Appendix A to \"object\", the\n\
    \   following string would be generated:\n     {\"big\":\"55\",\"time\":\"2019-01-28T07:45:10.000Z\"\
    ,\"val\":3.5}\n   In this case, the string arguments for \"big\" and \"time\"\
    \ have changed\n   with respect to the original, presumably making an application\n\
    \   depending on JCS fail.\n   The reason for the deviation is that in stream-\
    \ and schema-based JSON\n   parsers, the original string argument is typically\
    \ replaced on the\n   fly by the native subtype that, when serialized, may exhibit\
    \ a\n   different and platform-dependent pattern.\n   That is, stream- and schema-based\
    \ parsing MUST treat subtypes as\n   \"pure\" (immutable) JSON string types and\
    \ perform the actual\n   conversion to the designated native type in a subsequent\
    \ step.  In\n   modern programming platforms like Go, Java, and C#, this can be\n\
    \   achieved with moderate efforts by combining annotations, getters, and\n  \
    \ setters.  Below is an example in C#/Json.NET showing a part of a\n   class that\
    \ is serializable as a JSON object:\n     // The \"pure\" string solution uses\
    \ a local\n     // string variable for JSON serialization while\n     // exposing\
    \ another type to the application\n     [JsonProperty(\"amount\")]\n     private\
    \ string _amount;\n     [JsonIgnore]\n     public decimal Amount {\n         get\
    \ { return decimal.Parse(_amount); }\n         set { _amount = value.ToString();\
    \ }\n     }\n   In an application, \"Amount\" can be accessed as any other property\n\
    \   while it is actually represented by a quoted string in JSON contexts.\n  \
    \ Note: The example above also addresses the constraints on numeric\n   data implied\
    \ by I-JSON (the C# \"decimal\" data type has quite\n   different characteristics\
    \ compared to IEEE 754 double precision).\n"
- title: E.1.  Subtypes in Arrays
  contents:
  - "E.1.  Subtypes in Arrays\n   Since the JSON array construct permits mixing arbitrary\
    \ JSON data\n   types, custom parsing and serialization code may be required to\
    \ cope\n   with subtypes anyway.\n"
- title: Appendix F.  Implementation Guidelines
  contents:
  - "Appendix F.  Implementation Guidelines\n   The optimal solution is integrating\
    \ support for JCS directly in JSON\n   serializers (parsers need no changes).\
    \  That is, canonicalization\n   would just be an additional \"mode\" for a JSON\
    \ serializer.  However,\n   this is currently not the case.  Fortunately, JCS\
    \ support can be\n   introduced through externally supplied canonicalizer software\
    \ acting\n   as a post processor to existing JSON serializers.  This arrangement\n\
    \   also relieves the JCS implementer from having to deal with how\n   underlying\
    \ data is to be represented in JSON.\n   The post processor concept enables signature\
    \ creation schemes like\n   the following:\n   1.  Create the data to be signed.\n\
    \   2.  Serialize the data using existing JSON tools.\n   3.  Let the external\
    \ canonicalizer process the serialized data and\n       return canonicalized result\
    \ data.\n   4.  Sign the canonicalized data.\n   5.  Add the resulting signature\
    \ value to the original JSON data\n       through a designated signature property.\n\
    \   6.  Serialize the completed (now signed) JSON object using existing\n    \
    \   JSON tools.\n   A compatible signature verification scheme would then be as\
    \ follows:\n   1.  Parse the signed JSON data using existing JSON tools.\n   2.\
    \  Read and save the signature value from the designated signature\n       property.\n\
    \   3.  Remove the signature property from the parsed JSON object.\n   4.  Serialize\
    \ the remaining JSON data using existing JSON tools.\n   5.  Let the external\
    \ canonicalizer process the serialized data and\n       return canonicalized result\
    \ data.\n   6.  Verify that the canonicalized data matches the saved signature\n\
    \       value using the algorithm and key used for creating the\n       signature.\n\
    \   A canonicalizer like above is effectively only a \"filter\",\n   potentially\
    \ usable with a multitude of quite different cryptographic\n   schemes.\n   Using\
    \ a JSON serializer with integrated JCS support, the\n   serialization performed\
    \ before the canonicalization step could be\n   eliminated for both processes.\n"
- title: Appendix G.  Open-Source Implementations
  contents:
  - "Appendix G.  Open-Source Implementations\n   The following open-source implementations\
    \ have been verified to be\n   compatible with JCS:\n   *  JavaScript: <https://www.npmjs.com/package/canonicalize>\n\
    \   *  Java: <https://github.com/erdtman/java-json-canonicalization>\n   *  Go:\
    \ <https://github.com/cyberphone/json-\n      canonicalization/tree/master/go>\n\
    \   *  .NET/C#: <https://github.com/cyberphone/json-\n      canonicalization/tree/master/dotnet>\n\
    \   *  Python: <https://github.com/cyberphone/json-\n      canonicalization/tree/master/python3>\n"
- title: Appendix H.  Other JSON Canonicalization Efforts
  contents:
  - "Appendix H.  Other JSON Canonicalization Efforts\n   There are (and have been)\
    \ other efforts creating \"Canonical JSON\".\n   Below is a list of URLs to some\
    \ of them:\n   *  <https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-\n\
    \      00>\n   *  <https://gibson042.github.io/canonicaljson-spec/>\n   *  <http://wiki.laptop.org/go/Canonical_JSON>\n\
    \   The listed efforts all build on text-level JSON-to-JSON\n   transformations.\
    \  The primary feature of text-level canonicalization\n   is that it can be made\
    \ neutral to the flavor of JSON used.  However,\n   such schemes also imply major\
    \ changes to the JSON parsing process,\n   which is a likely hurdle for adoption.\
    \  Albeit at the expense of\n   certain JSON and application constraints, JCS\
    \ was designed to be\n   compatible with existing JSON tools.\n"
- title: Appendix I.  Development Portal
  contents:
  - "Appendix I.  Development Portal\n   The JCS specification is currently developed\
    \ at:\n   <https://github.com/cyberphone/ietf-json-canon>.\n   JCS source code\
    \ and extensive test data is available at:\n   <https://github.com/cyberphone/json-canonicalization>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Building on ECMAScript number serialization was originally\
    \ proposed\n   by James Manger.  This ultimately led to the adoption of the entire\n\
    \   ECMAScript serialization scheme for JSON primitives.\n   Other people who\
    \ have contributed with valuable input to this\n   specification include Scott\
    \ Ananian, Tim Bray, Ben Campbell, Adrian\n   Farell, Richard Gibson, Bron Gondwana,\
    \ John-Mark Gurney, Mike Jones,\n   John Levine, Mark Miller, Matthew Miller,\
    \ Mark Nottingham, Mike\n   Samuel, Jim Schaad, Robert Tupelo-Schneck, and Michal\
    \ Wadas.\n   For carrying out real-world concept verification, the software and\n\
    \   support for number serialization provided by Ulf Adams, Tanner\n   Gooding,\
    \ and Remy Oudompheng was very helpful.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Anders Rundgren\n   Independent\n   Montpellier\n   France\n\
    \   Email: anders.rundgren.net@gmail.com\n   URI:   https://www.linkedin.com/in/andersrundgren/\n\
    \   Bret Jordan\n   Broadcom\n   1320 Ridder Park Drive\n   San Jose, CA 95131\n\
    \   United States of America\n   Email: bret.jordan@broadcom.com\n   Samuel Erdtman\n\
    \   Spotify AB\n   Birger Jarlsgatan 61, 4tr\n   SE-113 56 Stockholm\n"
