- title: __initial_text__
  contents:
  - ''
- title: Minimal Internet Key Exchange Version 2 (IKEv2) Initiator Implementation
  contents:
  - 'Minimal Internet Key Exchange Version 2 (IKEv2) Initiator Implementation

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a minimal initiator version of the Internet\n\
    \   Key Exchange version 2 (IKEv2) protocol for constrained nodes.  IKEv2\n  \
    \ is a component of IPsec used for performing mutual authentication and\n   establishing\
    \ and maintaining Security Associations (SAs).  IKEv2\n   includes several optional\
    \ features, which are not needed in minimal\n   implementations.  This document\
    \ describes what is required from the\n   minimal implementation and also describes\
    \ various optimizations that\n   can be done.  The protocol described here is\
    \ interoperable with a\n   full IKEv2 implementation using shared secret authentication\
    \ (IKEv2\n   does not require the use of certificate authentication).  This\n\
    \   minimal initiator implementation can only talk to a full IKEv2\n   implementation\
    \ acting as the responder; thus, two minimal initiator\n   implementations cannot\
    \ talk to each other.\n   This document does not update or modify RFC 7296 but\
    \ provides a more\n   compact description of the minimal version of the protocol.\
    \  If this\n   document and RFC 7296 conflict, then RFC 7296 is the authoritative\n\
    \   description.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7815.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Use Cases . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   2.  Exchanges . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     2.1.  Initial Exchange  . . . . . . . . . . . . . . . . . .\
    \ . .   5\n     2.2.  Other Exchanges . . . . . . . . . . . . . . . . . . . .\
    \ .  12\n     2.3.  Generating Keying Material  . . . . . . . . . . . . . . .\
    \  12\n   3.  Conformance Requirements  . . . . . . . . . . . . . . . . . .  13\n\
    \   4.  Implementation Status . . . . . . . . . . . . . . . . . . . .  14\n  \
    \ 5.  Security Considerations . . . . . . . . . . . . . . . . . . .  14\n   6.\
    \  References  . . . . . . . . . . . . . . . . . . . . . . . . .  15\n     6.1.\
    \  Normative References  . . . . . . . . . . . . . . . . . .  15\n     6.2.  Informative\
    \ References  . . . . . . . . . . . . . . . . .  15\n   Appendix A.  Header and\
    \ Payload Formats . . . . . . . . . . . . .  17\n     A.1.  The IKE Header  .\
    \ . . . . . . . . . . . . . . . . . . . .  17\n     A.2.  Generic Payload Header\
    \  . . . . . . . . . . . . . . . . .  19\n     A.3.  Security Association Payload\
    \  . . . . . . . . . . . . . .  21\n       A.3.1.  Proposal Substructure . . .\
    \ . . . . . . . . . . . . .  23\n       A.3.2.  Transform Substructure  . . .\
    \ . . . . . . . . . . . .  24\n       A.3.3.  Valid Transform Types by Protocol\
    \ . . . . . . . . . .  26\n       A.3.4.  Transform Attributes  . . . . . . .\
    \ . . . . . . . . .  26\n     A.4.  Key Exchange Payload  . . . . . . . . . .\
    \ . . . . . . . .  27\n     A.5.  Identification Payloads . . . . . . . . . .\
    \ . . . . . . .  27\n     A.6.  Certificate Payload . . . . . . . . . . . . .\
    \ . . . . . .  29\n     A.7.  Certificate Request Payload . . . . . . . . . .\
    \ . . . . .  30\n     A.8.  Authentication Payload  . . . . . . . . . . . . .\
    \ . . . .  31\n     A.9.  Nonce Payload . . . . . . . . . . . . . . . . . . .\
    \ . . .  31\n     A.10. Notify Payload  . . . . . . . . . . . . . . . . . . .\
    \ . .  32\n       A.10.1.  Notify Message Types . . . . . . . . . . . . . . .\
    \ .  33\n     A.11. Traffic Selector Payload  . . . . . . . . . . . . . . . .\
    \  34\n       A.11.1.  Traffic Selector . . . . . . . . . . . . . . . . . .  36\n\
    \     A.12. Encrypted Payload . . . . . . . . . . . . . . . . . . . .  37\n  \
    \ Appendix B.  Useful Optional Features . . . . . . . . . . . . . .  39\n    \
    \ B.1.  IKE SA Delete Notification  . . . . . . . . . . . . . . .  39\n     B.2.\
    \  Raw Public Keys . . . . . . . . . . . . . . . . . . . . .  40\n   Acknowledgements\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  41\n   Author's Address  .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Internet Protocol Suite is increasingly used on small\
    \ devices\n   with severe constraints on power, memory, and processing resources.\n\
    \   This document describes a minimal IKEv2 implementation designed for\n   use\
    \ on such constrained nodes that is interoperable with \"Internet\n   Key Exchange\
    \ Protocol Version 2 (IKEv2)\" [RFC7296].\n   A minimal IKEv2 implementation only\
    \ supports the initiator end of the\n   protocol.  It only supports the initial\
    \ IKE_SA_INIT and IKE_AUTH\n   exchanges and does not initiate any other exchanges.\
    \  It also replies\n   with an empty (or error) message to all incoming requests.\n\
    \   This means that most of the optional features of IKEv2 are left out:\n   NAT\
    \ traversal, IKE SA rekey, Child SA rekey, multiple Child SAs,\n   deleting Child\
    \ / IKE SAs, Configuration payloads, Extensible\n   Authentication Protocol (EAP)\
    \ authentication, COOKIEs, etc.\n   Some optimizations can be done because of\
    \ the limited set of\n   supported features, and this text should not be considered\
    \ for\n   generic IKEv2 implementations (for example, Message IDs can be done\n\
    \   as specified because minimal implementation is only sending out an\n   IKE_SA_INIT\
    \ and IKE_AUTH request and not any other request).\n   This document is intended\
    \ to be standalone, meaning everything needed\n   to implement IKEv2 is copied\
    \ here except the description of the\n   cryptographic algorithms.  The IKEv2\
    \ specification has lots of\n   background information and rationale that has\
    \ been omitted from this\n   document.\n   Numerous additional numeric values\
    \ from IANA registries have been\n   omitted from this document; only those which\
    \ are of interest for a\n   minimal implementation are listed.\n   The main body\
    \ of this document describes how to use the shared secret\n   authentication in\
    \ IKEv2, as it is easiest to implement.  In some\n   cases, that is not enough,\
    \ and Appendix B.2 describes how to use raw\n   public keys instead of shared\
    \ secret authentication.\n   For more information, check the full IKEv2 specification\
    \ in [RFC7296]\n   and [IKEV2IANA].\n   The key words \"MUST\", \"MUST NOT\",\
    \ \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].  The term\n   \"Constrained Node\" is defined in \"Terminology\
    \ for Constrained-Node\n   Networks\" [RFC7228].\n"
- title: 1.1.  Use Cases
  contents:
  - "1.1.  Use Cases\n   One use case for this kind of minimal implementation is in\
    \ small\n   devices doing machine-to-machine communication.  In such\n   environments,\
    \ the node initiating connections can be very small, and\n   the other end of\
    \ the communication channel is some kind of larger\n   device.\n   An example\
    \ of the small initiating node could be a remote garage door\n   opener device,\
    \ i.e., a device having buttons that open and close a\n   garage door and that\
    \ connects to the home area network server over a\n   wireless link.\n   Another\
    \ example of such a device is some kind of sensor device, for\n   example, a room\
    \ temperature sensor, which sends periodic temperature\n   data to some centralized\
    \ node.\n   Those devices usually sleep for a long time and only wake up\n   periodically\
    \ or because of user interaction.  The data transfer is\n   always initiated from\
    \ that sleeping node when they wake up; after\n   they send packets, there might\
    \ be ACKs or other packets coming back\n   before they go back to sleep.  If some\
    \ data needs to be transferred\n   from a server node to the small device, it\
    \ can be implemented by\n   polling, i.e., the small node periodically polls for\
    \ the server to\n   see if it, for example, has some configuration changes or\
    \ similar.\n   While the device is sleeping, it will not maintain the IKEv2 SA.\n\
    \   That is, it will always create the IKEv2 SA again when it wakes up.\n   This\
    \ means there is no need to do liveness checks for the server, as\n   after the\
    \ device wakes up again, the minimal implementation will\n   start from the beginning\
    \ again.\n"
- title: 2.  Exchanges
  contents:
  - '2.  Exchanges

    '
- title: 2.1.  Initial Exchange
  contents:
  - "2.1.  Initial Exchange\n   All IKEv2 communications consist of pairs of messages:\
    \ a request and\n   a response.  The pair is called an \"exchange\" and is sometimes\
    \ called\n   a \"request/response pair\".  Every request requires a response.\n\
    \   For every pair of IKEv2 messages, the initiator is responsible for\n   retransmission\
    \ in the event of a timeout.  The responder MUST never\n   retransmit a response\
    \ unless it receives a retransmission of the\n   request.\n   IKEv2 is a reliable\
    \ protocol: the initiator MUST retransmit a request\n   until it either receives\
    \ a corresponding response or deems the IKE SA\n   to have failed.  A retransmission\
    \ from the initiator MUST be bitwise\n   identical to the original request.  Retransmission\
    \ times MUST\n   increase exponentially.\n   IKEv2 is run over UDP port 500. \
    \ All IKEv2 implementations MUST be\n   able to send, receive, and process IKEv2\
    \ messages that are up to 1280\n   octets long.  An implementation MUST accept\
    \ incoming requests even if\n   the source port is not 500 and MUST respond to\
    \ the address and port\n   from which the request was received.\n   The minimal\
    \ implementation of IKEv2 only uses the first two\n   exchanges, called IKE_SA_INIT\
    \ and IKE_AUTH.  These are used to create\n   the IKE SA and the first Child SA.\
    \  In addition to those messages, a\n   minimal IKEv2 implementation needs to\
    \ understand the CREATE_CHILD_SA\n   request enough to generate a CREATE_CHILD_SA\
    \ response containing the\n   NO_ADDITIONAL_SAS error notify.  It needs to understand\
    \ the\n   INFORMATIONAL request enough to generate an empty INFORMATIONAL\n  \
    \ response to it.  There is no requirement to be able to respond to any\n   other\
    \ requests.\n   All messages following the IKE_SA_INIT exchange are cryptographically\n\
    \   protected using the cryptographic algorithms and keys negotiated in\n   the\
    \ IKE_SA_INIT exchange.\n   Every IKEv2 message contains a Message ID as part\
    \ of its fixed\n   header.  This Message ID is used to match up requests and responses\n\
    \   and to identify retransmissions of messages.\n   Minimal implementations only\
    \ need to support the role of initiator,\n   so it typically only sends an IKE_SA_INIT\
    \ request that, when\n   answered, is followed by an IKE_AUTH.  As those messages\
    \ have fixed\n   Message IDs (0 and 1), it does not need to keep track of its\
    \ own\n   Message IDs for outgoing requests after that.\n   Minimal implementations\
    \ can also optimize Message ID handling of the\n   incoming requests, as they\
    \ do not need to protect incoming requests\n   against replays.  This is possible\
    \ because minimal implementations\n   will only return error or empty notification\
    \ replies to incoming\n   requests.  This means that any of those incoming requests\
    \ do not have\n   any effect on the minimal implementation, thus processing them\
    \ again\n   does not cause any harm.  Because of this, a minimal implementation\n\
    \   can always answer a request coming in, with the same Message ID than\n   what\
    \ the request had, and then forget the request/response pair\n   immediately.\
    \  This means there is no need to keep track of Message\n   IDs of the incoming\
    \ requests.\n   In the following descriptions, the payloads contained in the message\n\
    \   are indicated by the names listed below.\n   Notation    Payload\n   -----------------------------------------\n\
    \   AUTH        Authentication\n   CERTREQ     Certificate Request\n   D     \
    \      Delete\n   HDR         IKE header (not a payload)\n   IDi         Identification\
    \ - Initiator\n   IDr         Identification - Responder\n   KE          Key Exchange\n\
    \   Ni, Nr      Nonce\n   N           Notify\n   SA          Security Association\n\
    \   SK          Encrypted and Authenticated\n   TSi         Traffic Selector -\
    \ Initiator\n   TSr         Traffic Selector - Responder\n   The initial exchanges\
    \ are as follows:\n   Initiator                         Responder\n   -------------------------------------------------------------------\n\
    \   HDR(SPIi=xxx, SPIr=0, IKE_SA_INIT,\n       Flags: Initiator, Message ID=0),\n\
    \       SAi1, KEi, Ni  -->\n                      <--  HDR(SPIi=xxx, SPIr=yyy,\
    \ IKE_SA_INIT,\n                               Flags: Response, Message ID=0),\n\
    \                               SAr1, KEr, Nr, [CERTREQ]\n   HDR contains the\
    \ Security Parameter Indexes (SPIs), version numbers,\n   and flags of various\
    \ sorts.  Each endpoint chooses one of the two\n   SPIs and MUST choose them so\
    \ as to be unique identifiers of an IKE\n   SA.  An SPI value of zero is special:\
    \ it indicates that the remote\n   SPI value is not yet known by the sender.\n\
    \   Incoming IKEv2 packets are mapped to an IKE SA using only the\n   packet's\
    \ SPI, not using (for example) the source IP address of the\n   packet.\n   The\
    \ SAi1 payload states the cryptographic algorithms the initiator\n   supports\
    \ for the IKE SA.  The KEi and KEr payloads contain Diffie-\n   Hellman values,\
    \ and Ni and Nr are the nonces.  The SAr1 contains the\n   chosen cryptographic\
    \ suite from the initiator's offered choices.  A\n   minimal implementation using\
    \ shared secrets will ignore the CERTREQ\n   payload.\n   Minimal implementation\
    \ will most likely support exactly one set of\n   cryptographic algorithms, meaning\
    \ the SAi1 payload will be static.\n   It needs to check that the SAr1 received\
    \ matches the proposal it\n   sent.\n   At this point in the negotiation, each\
    \ party can generate SKEYSEED,\n   from which all keys are derived for that IKE\
    \ SA.\n   SKEYSEED = prf(Ni | Nr, g^ir)\n   {SK_d | SK_ai | SK_ar | SK_ei | SK_er\
    \ | SK_pi | SK_pr }\n                   = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr\
    \ )\n   prf+ (K,S) = T1 | T2 | T3 | T4 | ...\n   where:\n   T1 = prf (K, S | 0x01)\n\
    \   T2 = prf (K, T1 | S | 0x02)\n   T3 = prf (K, T2 | S | 0x03)\n   T4 = prf (K,\
    \ T3 | S | 0x04)\n   ...\n   (indicating that the quantities SK_d, SK_ai, SK_ar,\
    \ SK_ei, SK_er,\n   SK_pi, and SK_pr are taken in order from the generated bits\
    \ of the\n   prf+). g^ir is the shared secret from the ephemeral Diffie-Hellman\n\
    \   exchange. g^ir is represented as a string of octets in big endian\n   order\
    \ padded with zeros if necessary to make it the length of the\n   modulus.  Ni\
    \ and Nr are the nonces, stripped of any headers.\n   The SK_d is used for deriving\
    \ new keys for the Child SAs.  The SK_ai\n   and SK_ar are used as a key to the\
    \ integrity protection algorithm for\n   authenticating the component messages\
    \ of subsequent exchanges.  The\n   SK_ei and SK_er are used for encrypting (and\
    \ of course decrypting)\n   all subsequent exchanges.  The SK_pi and SK_pr are\
    \ used when\n   generating an AUTH payload.  The lengths of SK_d, SK_pi, and SK_pr\n\
    \   MUST be the preferred key length of the Pseudorandom Function (PRF)\n   agreed\
    \ upon.\n   A separate SK_e and SK_a is computed for each direction.  The keys\n\
    \   used to protect messages from the original initiator are SK_ai and\n   SK_ei.\
    \  The keys used to protect messages in the other direction are\n   SK_ar and\
    \ SK_er.  The notation SK { ... } indicates that these\n   payloads are encrypted\
    \ and integrity protected using that direction's\n   SK_e and SK_a.\n   Initiator\
    \                         Responder\n   -------------------------------------------------------------------\n\
    \   HDR(SPIi=xxx, SPIr=yyy, IKE_AUTH,\n       Flags: Initiator, Message ID=1),\n\
    \       SK {IDi, AUTH, SAi2, TSi, TSr,\n           N(INITIAL_CONTACT)}  -->\n\
    \                     <--  HDR(SPIi=xxx, SPIr=yyy, IKE_AUTH, Flags:\n        \
    \                         Response, Message ID=1),\n                         \
    \        SK {IDr, AUTH, SAr2, TSi, TSr}\n   The initiator asserts its identity\
    \ with the IDi payload, proves\n   knowledge of the secret corresponding to IDi,\
    \ and integrity protects\n   the contents of the first message using the AUTH\
    \ payload.  The\n   responder asserts its identity with the IDr payload, authenticates\n\
    \   its identity, and protects the integrity of the second message with\n   the\
    \ AUTH payload.\n   As minimal implementation usually has only one host where\
    \ it\n   connects, that means it has only one shared secret.  This means it\n\
    \   does not need to care about the IDr payload that much.  If the other\n   end\
    \ sends an AUTH payload that the initiator can verify using the\n   shared secret\
    \ it has, then it knows the other end is the peer it was\n   configured to talk\
    \ to.\n   In the IKE_AUTH request, the initiator sends the SA offer(s) in the\n\
    \   SAi2 payload and the proposed Traffic Selectors (TSs) for the Child\n   SA\
    \ in the TSi and TSr payloads.  The responder replies with the\n   accepted offer\
    \ in an SAr2 payload and with the selected Traffic\n   Selectors.  The selected\
    \ Traffic Selectors may be a subset of what\n   the initiator proposed.\n   In\
    \ the minimal implementation, both SA payloads and TS payloads are\n   going to\
    \ be mostly static.  The SA payload will have the SPI value\n   used in the Encapsulating\
    \ Security Payload (ESP), but the algorithms\n   are most likely going to be the\
    \ one and only supported set.  The TS\n   payloads on the initiator end will most\
    \ likely say from any to any,\n   i.e., full wildcard ranges, or from the local\
    \ IP to the remote IP.\n   In the wildcard case, the responder quite often narrows\
    \ the range\n   down to the one IP address pair.  Using a single IP address pair\
    \ as\n   the Traffic Selectors when sending the IKE_AUTH request will simplify\n\
    \   processing as the responder will either accept the IP address pair or\n  \
    \ return an error.  If wildcard ranges are used, there is a possibility\n   that\
    \ the responder will narrow the Traffic Selector range to range\n   that is not\
    \ acceptable by the initiator.\n   The IKE_AUTH (and IKE_SA_INIT) response may\
    \ contain multiple status\n   notification payloads that can be ignored by minimal\
    \ implementations.\n   There can also be Vendor ID, Certificate, Certificate Request,\
    \ or\n   Configuration payloads, but any payload unknown to minimal\n   implementations\
    \ can simply be skipped over (response messages cannot\n   have critical unsupported\
    \ payloads).\n   The exchange above includes N(INITIAL_CONTACT) notification in\
    \ the\n   request as that is quite commonly sent by a minimal implementation.\n\
    \   It indicates to the other end that the initiator does not have any\n   other\
    \ IKE SAs between it and the responder, and if there is any left\n   from previous\
    \ runs, those can be deleted by the responder.  As\n   minimal implementations\
    \ delete IKE SAs without sending IKE SA delete\n   requests, this will help the\
    \ responder to clean up leftover state.\n   When using shared secret authentication,\
    \ the peers are authenticated\n   by having each calculating a Message Authentication\
    \ Code (MAC) over a\n   block of data:\n   For the initiator:\n      AUTH = prf(\
    \ prf(Shared Secret, \"Key Pad for IKEv2\"),\n                       <InitiatorSignedOctets>)\n\
    \   For the responder:\n      AUTH = prf( prf(Shared Secret, \"Key Pad for IKEv2\"\
    ),\n                       <ResponderSignedOctets>)\n   The string \"Key Pad for\
    \ IKEv2\" is 17 ASCII characters without null\n   termination.  The implementation\
    \ can precalculate the inner prf and\n   only store the output of it.  This is\
    \ possible because a minimal\n   IKEv2 implementation usually only supports one\
    \ PRF.\n   In the following calculations, IDi' and IDr' are the entire ID\n  \
    \ payloads excluding the fixed header, and the Ni and Nr are only the\n   values,\
    \ not the payloads containing it.  Note that neither the nonce\n   Ni/Nr nor the\
    \ value prf(SK_pr, IDr')/prf(SK_pi, IDi') are\n   transmitted.\n   The initiator\
    \ signs the first message (IKE_SA_INIT request), starting\n   with the first octet\
    \ of the first SPI in the header and ending with\n   the last octet of the last\
    \ payload in that first message.  Appended\n   to this (for purposes of computing\
    \ the signature) are the responder's\n   nonce Nr and the value prf(SK_pi, IDi').\n\
    \   For the responder, the octets to be signed start with the first octet\n  \
    \ of the first SPI in the header of the second message (IKE_SA_INIT\n   response)\
    \ and end with the last octet of the last payload in that\n   second message.\
    \  Appended to this are the initiator's nonce Ni and\n   the value prf(SK_pr,\
    \ IDr').\n   The initiator's signed octets can be described as:\n   InitiatorSignedOctets\
    \ = RealMessage1 | NonceRData | MACedIDForI\n   RealIKEHDR =  SPIi | SPIr |  .\
    \ . . | Length\n   RealMessage1 = RealIKEHDR | RestOfMessage1\n   NonceRPayload\
    \ = PayloadHeader | NonceRData\n   InitiatorIDPayload = PayloadHeader | RestOfInitIDPayload\n\
    \   RestOfInitIDPayload = IDType | RESERVED | InitIDData\n   MACedIDForI = prf(SK_pi,\
    \ RestOfInitIDPayload)\n   The responder's signed octets can be described as:\n\
    \   ResponderSignedOctets = RealMessage2 | NonceIData | MACedIDForR\n   RealIKEHDR\
    \ =  SPIi | SPIr |  . . . | Length\n   RealMessage2 = RealIKEHDR | RestOfMessage2\n\
    \   NonceIPayload = PayloadHeader | NonceIData\n   ResponderIDPayload = PayloadHeader\
    \ | RestOfRespIDPayload\n   RestOfRespIDPayload = IDType | RESERVED | RespIDData\n\
    \   MACedIDForR = prf(SK_pr, RestOfRespIDPayload)\n   Note that all of the payloads\
    \ inside the RestOfMessageX are included\n   under the signature, including any\
    \ payload types not listed in this\n   document.\n   The initiator might also\
    \ get an unauthenticated response back that\n   has a notification payload with\
    \ an error code inside.  As that error\n   code will be unauthenticated and may\
    \ be faked, there is no need to do\n   anything for those.  A minimal implementation\
    \ can simply ignore those\n   errors and retransmit its request until it times\
    \ out, and if that\n   happens, then the IKE SA (and Child SA) creation failed.\n\
    \   The responder might also reply with an IKE_AUTH response packet that\n   does\
    \ not contain the payloads needed to set up a Child SA (SAr2, TSi,\n   and TSr)\
    \ but instead contain AUTH payload and an error.  Minimal\n   implementation that\
    \ does not support the CREATE_CHILD_SA exchange\n   cannot recover from this scenario.\
    \  It can delete the IKE SA and\n   start over from the beginning (which might\
    \ fail again if this is a\n   configuration error, or it might succeed if this\
    \ was temporal\n   failure).\n"
- title: 2.2.  Other Exchanges
  contents:
  - "2.2.  Other Exchanges\n   Minimal implementations MUST be able to reply to INFORMATIONAL\n\
    \   requests by sending back an empty INFORMATIONAL response:\n   Minimal implementation\
    \            Other end\n   -------------------------------------------------------------------\n\
    \                      <--  HDR(SPIi=xxx, SPIr=yyy, INFORMATIONAL,\n         \
    \                         Flags: none,  Message ID=m),\n                     \
    \             SK {...}\n   HDR(SPIi=xxx, SPIr=yyy, INFORMATIONAL,\n       Flags:\
    \ Initiator | Response,\n       Message ID=m),\n       SK {}  -->\n   Minimal\
    \ implementations MUST be able to reply to incoming\n   CREATE_CHILD_SA requests.\
    \  A typical implementation will reject the\n   CREATE_CHILD_SA exchanges by sending\
    \ a NO_ADDITIONAL_SAS error notify\n   back:\n   Minimal implementation      \
    \      Other end\n   -------------------------------------------------------------------\n\
    \                      <--  HDR(SPIi=xxx, SPIy=yyy, CREATE_CHILD_SA,\n       \
    \                           Flags: none, Message ID=m),\n                    \
    \              SK {...}\n   HDR(SPIi=xxx, SPIr=yyy, CREATE_CHILD_SA,\n       Flags:\
    \ Initiator | Response, Message ID=m),\n       SK {N(NO_ADDITIONAL_SAS)}  -->\n\
    \   Note that INFORMATIONAL and CREATE_CHILD_SA requests might contain\n   unsupported\
    \ critical payloads, in which case a compliant\n   implementation MUST ignore\
    \ the request and send a response message\n   back that has the UNSUPPORTED_CRITICAL_PAYLOAD\
    \ notification.  That\n   notification payload data contains a 1-octet payload\
    \ type of the\n   unsupported critical payload.\n"
- title: 2.3.  Generating Keying Material
  contents:
  - "2.3.  Generating Keying Material\n   The keying material for the Child SA created\
    \ by the IKE_AUTH exchange\n   is generated as follows:\n   KEYMAT = prf+(SK_d,\
    \ Ni | Nr)\n   Where Ni and Nr are the nonces from the IKE_SA_INIT exchange.\n\
    \   A single CHILD_SA negotiation may result in multiple Security\n   Associations.\
    \  ESP and Authentication Header (AH) SAs exist in pairs\n   (one in each direction),\
    \ so two SAs are created in a single Child SA\n   negotiation for them.  The keying\
    \ material for each Child SA MUST be\n   taken from the expanded KEYMAT using\
    \ the following rules:\n   o  All keys for SAs carrying data from the initiator\
    \ to the responder\n      are taken before SAs going from the responder to the\
    \ initiator.\n   o  If an IPsec protocol requires multiple keys, the order in\
    \ which\n      they are taken from the SA's keying material needs to be described\n\
    \      in the protocol's specification.  For ESP and AH, [IPSECARCH]\n      defines\
    \ the order, namely: the encryption key (if any) MUST be\n      taken from the\
    \ first bits, and the integrity key (if any) MUST be\n      taken from the remaining\
    \ bits.\n   Each cryptographic algorithm takes a fixed number of bits of keying\n\
    \   material specified as part of the algorithm or negotiated in SA\n   payloads.\n"
- title: 3.  Conformance Requirements
  contents:
  - "3.  Conformance Requirements\n   For an implementation to be called conforming\
    \ to the RFC 7296\n   specification, it MUST be possible to configure it to accept\
    \ the\n   following:\n   o  Public Key Infrastructure using X.509 (PKIX) Certificates\n\
    \      containing and signed by RSA keys of size 1024 or 2048 bits, where\n  \
    \    the ID passed is any of ID_KEY_ID, ID_FQDN, ID_RFC822_ADDR, or\n      ID_DER_ASN1_DN.\n\
    \   o  Shared key authentication where the ID passed is any of ID_KEY_ID,\n  \
    \    ID_FQDN, or ID_RFC822_ADDR.\n   o  Authentication where the responder is\
    \ authenticated using PKIX\n      Certificates, and the initiator is authenticated\
    \ using shared key\n      authentication.\n   This document only supports the\
    \ second bullet; it does not support\n   PKIX Certificates at all.  As full RFC\
    \ 7296 responders must also\n   support that shared key authentication, this allows\
    \ a minimal\n   implementation to be able to interoperate with all implementations\n\
    \   that are compliant with RFC 7296.\n   PKIX Certificates are left out from\
    \ the minimal implementation as\n   those would add quite a lot of complexity\
    \ to the implementation.  The\n   actual code changes needed in the IKEv2 protocol\
    \ are small, but the\n   certificate validation code would be more complex than\
    \ the whole\n   minimal IKEv2 implementation itself.  If public-key-based\n  \
    \ authentication is needed for scalability reasons, then raw public\n   keys would\
    \ probably be the best compromise (see Appendix B.2).\n"
- title: 4.  Implementation Status
  contents:
  - "4.  Implementation Status\n   This document describes a minimal implementation\
    \ written by the\n   author of this document.  The minimal implementation supported\
    \ the\n   base IKE_SA_INIT and IKE_AUTH exchanges and successfully\n   interoperated\
    \ with a full IKEv2 server.  This minimal implementation\n   was presented in\
    \ the Interconnecting Smart Objects with Internet\n   Workshop in Prague in March\
    \ 2011 [Kiv11].  This implementation was\n   written as proof of concept in perl.\n\
    \   There was another proof-of-concept implementation written in python,\n   which\
    \ also interoperated with a full IKEv2 server.\n   Both implementations were written\
    \ just for demonstration purposes and\n   included fixed configuration built into\
    \ the code, and both also\n   implemented ESP, ICMP, and IP layers to the level\
    \ that was needed to\n   send and receive one ICMP echo packet.  Both implementations\
    \ were\n   about 1000 lines of code excluding cryptographic libraries but\n  \
    \ including ESP, ICMP, and IP layers.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   As this implements the same protocol as RFC 7296,\
    \ this means all\n   security considerations from it also apply to this document.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n       \
    \       Kivinen, \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\"\
    , STD 79, RFC 7296, DOI 10.17487/RFC7296, October\n              2014, <http://www.rfc-editor.org/info/rfc7296>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [EAI]      Yang, A., Steele, S., and N. Freed,\
    \ \"Internationalized\n              Email Headers\", RFC 6532, DOI 10.17487/RFC6532,\
    \ February\n              2012, <http://www.rfc-editor.org/info/rfc6532>.\n  \
    \ [IDNA]     Klensin, J., \"Internationalized Domain Names for\n             \
    \ Applications (IDNA): Definitions and Document Framework\",\n              RFC\
    \ 5890, DOI 10.17487/RFC5890, August 2010,\n              <http://www.rfc-editor.org/info/rfc5890>.\n\
    \   [IKEV2IANA]\n              IANA, \"Internet Key Exchange Version 2 (IKEv2)\n\
    \              Parameters\",\n              <http://www.iana.org/assignments/ikev2-parameters>.\n\
    \   [IPSEARCH] Kent, S. and K. Seo, \"Security Architecture for the\n        \
    \      Internet Protocol\", RFC 4301, DOI 10.17487/RFC4301,\n              December\
    \ 2005, <http://www.rfc-editor.org/info/rfc4301>.\n   [Kiv11]    Kivinen, T.,\
    \ \"Interconnecting Smart Objects with Internet\n              Workshop 2011-03025;\
    \ IKEv2 and Smart Objects\", March 2011,\n              <https://www.iab.org/wp-content/IAB-uploads/2011/04/\n\
    \              Kivinen.pdf>.\n   [MODES]    National Institute of Standards and\
    \ Technology, U.S.\n              Department of Commerce, \"Recommendation for\
    \ Block Cipher\n              Modes of Operation\", SP 800-38A, 2001.\n   [PKCS1]\
    \    Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n              Standards\
    \ (PKCS) #1: RSA Cryptography Specifications\n              Version 2.1\", RFC\
    \ 3447, DOI 10.17487/RFC3447, February\n              2003, <http://www.rfc-editor.org/info/rfc3447>.\n\
    \   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n         \
    \     Housley, R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure\
    \ Certificate and Certificate Revocation List\n              (CRL) Profile\",\
    \ RFC 5280, DOI 10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC5322]  Resnick, P., Ed., \"Internet Message Format\", RFC 5322,\n    \
    \          DOI 10.17487/RFC5322, October 2008,\n              <http://www.rfc-editor.org/info/rfc5322>.\n\
    \   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n   \
    \           Constrained-Node Networks\", RFC 7228,\n              DOI 10.17487/RFC7228,\
    \ May 2014,\n              <http://www.rfc-editor.org/info/rfc7228>.\n   [RFC7619]\
    \  Smyslov, V. and P. Wouters, \"The NULL Authentication\n              Method\
    \ in the Internet Key Exchange Protocol Version 2\n              (IKEv2)\", RFC\
    \ 7619, DOI 10.17487/RFC7619, August 2015,\n              <http://www.rfc-editor.org/info/rfc7619>.\n\
    \   [RFC7670]  Kivinen, T., Wouters, P., and H. Tschofenig, \"Generic Raw\n  \
    \            Public-Key Support for IKEv2\", RFC 7670,\n              DOI 10.17487/RFC7670,\
    \ January 2016,\n              <http://www.rfc-editor.org/info/rfc7670>.\n"
- title: Appendix A.  Header and Payload Formats
  contents:
  - "Appendix A.  Header and Payload Formats\n   This appendix describes actual packet\
    \ payload formats.  This is\n   required to make the document self-contained.\
    \  The descriptions are\n   mostly copied from RFC 7296, and more information\
    \ can be found from\n   there.\n   Various payloads contain RESERVED fields, and\
    \ those MUST be sent as\n   zero and MUST be ignored on receipt.\n   All multi-octet\
    \ fields representing integers are laid out in big\n   endian order (also known\
    \ as \"most significant byte first\" or \"network\n   byte order\").\n"
- title: A.1.  The IKE Header
  contents:
  - "A.1.  The IKE Header\n   Each IKEv2 message begins with the IKE header, denoted\
    \ HDR in this\n   document.  Following the header are one or more IKE payloads\
    \ each\n   identified by a Next Payload field in the preceding payload.\n   Payloads\
    \ are identified in the order in which they appear in an IKE\n   message by looking\
    \ in the Next Payload field in the IKE header and,\n   subsequently, according\
    \ to the Next Payload field in the IKE payload\n   itself until a Next Payload\
    \ field of zero indicates that no payloads\n   follow.  If a payload of type \"\
    Encrypted\" is found, that payload is\n   decrypted and its contents parsed as\
    \ additional payloads.  An\n   Encrypted payload MUST be the last payload in a\
    \ packet, and an\n   Encrypted payload MUST NOT contain another Encrypted payload.\n\
    \   The format of the IKE header is shown in Figure 1.\n                     \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       IKE SA Initiator's SPI                  |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       IKE SA Responder's SPI                  |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Payload | MjVer | MnVer | Exchange Type |     Flags     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Message ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Length                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 1:  IKE Header Format\n   o  Initiator's SPI (8 octets)\
    \ - A value chosen by the initiator to\n      identify a unique IKE Security Association.\
    \  This value MUST NOT\n      be zero.\n   o  Responder's SPI (8 octets) - A value\
    \ chosen by the responder to\n      identify a unique IKE Security Association.\
    \  This value MUST be\n      zero in the first message of an IKE initial exchange.\n\
    \   o  Next Payload (1 octet) - Indicates the type of payload that\n      immediately\
    \ follows the header.  The format and value of each\n      payload are defined\
    \ below.\n   o  Major Version (4 bits) - Indicates the major version of the IKE\n\
    \      protocol in use.  Implementations based on this version of IKE\n      MUST\
    \ set the major version to 2 and MUST drop the messages with a\n      higher major\
    \ version number.\n   o  Minor Version (4 bits) - Indicates the minor version\
    \ of the IKE\n      protocol in use.  Implementations based on this version of\
    \ IKE\n      MUST set the minor version to zero.  They MUST ignore the minor\n\
    \      version number of received messages.\n   o  Exchange Type (1 octet) - Indicates\
    \ the type of exchange being\n      used.  This constrains the payloads sent in\
    \ each message in an\n      exchange.\n      Exchange Type             Value\n\
    \      ----------------------------------\n      IKE_SA_INIT               34\n\
    \      IKE_AUTH                  35\n      CREATE_CHILD_SA           36\n    \
    \  INFORMATIONAL             37\n   o  Flags (1 octet) - Indicates specific options\
    \ that are set for the\n      message.  Presence of options is indicated by the\
    \ appropriate bit\n      in the flags field being set.  The bits are as follows:\n\
    \        +-+-+-+-+-+-+-+-+\n        |X|X|R|V|I|X|X|X|\n        +-+-+-+-+-+-+-+-+\n\
    \      In the description below, a bit being 'set' means its value is\n      '1',\
    \ while 'cleared' means its value is '0'.  'X' bits MUST be\n      cleared when\
    \ sending and MUST be ignored on receipt.\n      *  R (Response) - This bit indicates\
    \ that this message is a\n         response to a message containing the same Message\
    \ ID.  This bit\n         MUST be cleared in all request messages and MUST be\
    \ set in all\n         responses.  An IKEv2 endpoint MUST NOT generate a response\
    \ to a\n         message that is marked as being a response.\n      *  V (Version)\
    \ - This bit indicates that the transmitter is\n         capable of speaking a\
    \ higher major version number of the\n         protocol than the one indicated\
    \ in the Major Version field.\n         Implementations of IKEv2 MUST clear this\
    \ bit when sending and\n         MUST ignore it in incoming messages.\n      *\
    \  I (Initiator) - This bit MUST be set in messages sent by the\n         original\
    \ initiator of the IKE SA and MUST be cleared in\n         messages sent by the\
    \ original responder.  It is used by the\n         recipient to determine which\
    \ 8 octets of the SPI were generated\n         by the recipient.  This bit changes\
    \ to reflect who initiated\n         the last rekey of the IKE SA.\n   o  Message\
    \ ID (4 octets, unsigned integer) - Message identifier used\n      to control\
    \ retransmission of lost packets and matching of requests\n      and responses.\
    \  It is essential to the security of the protocol\n      because it is used to\
    \ prevent message replay attacks.\n   o  Length (4 octets, unsigned integer) -\
    \ Length of the total message\n      (header + payloads) in octets.\n"
- title: A.2.  Generic Payload Header
  contents:
  - "A.2.  Generic Payload Header\n   Each IKE payload begins with a generic payload\
    \ header, as shown in\n   Figure 2.  Figures for each payload below will include\
    \ the generic\n   payload header, but for brevity, the description of each field\
    \ will\n   be omitted.\n                        1                   2        \
    \           3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 2:  Generic Payload Header\n   The Generic Payload\
    \ Header fields are defined as follows:\n   o  Next Payload (1 octet) - Identifier\
    \ for the payload type of the\n      next payload in the message.  If the current\
    \ payload is the last\n      in the message, then this field will be zero.  This\
    \ field provides\n      a \"chaining\" capability whereby additional payloads\
    \ can be added\n      to a message by appending each one to the end of the message\
    \ and\n      setting the Next Payload field of the preceding payload to\n    \
    \  indicate the new payload's type.  An Encrypted payload, which must\n      always\
    \ be the last payload of a message, is an exception.  It\n      contains data\
    \ structures in the format of additional payloads.  In\n      the header of an\
    \ Encrypted payload, the Next Payload field is set\n      to the payload type\
    \ of the first contained payload (instead of\n      zero); conversely, the Next\
    \ Payload field of the last contained\n      payload is set to zero).  The payload\
    \ type values needed for\n      minimal implementations are listed here.\n   \
    \   Next Payload Type                Notation  Value\n      --------------------------------------------------\n\
    \      No Next Payload                             0\n      Security Association\
    \             SA         33\n      Key Exchange                     KE       \
    \  34\n      Identification - Initiator       IDi        35\n      Identification\
    \ - Responder       IDr        36\n      Certificate                      CERT\
    \       37\n      Certificate Request              CERTREQ    38\n      Authentication\
    \                   AUTH       39\n      Nonce                            Ni,\
    \ Nr     40\n      Notify                           N          41\n      Delete\
    \                           D          42\n      Traffic Selector - Initiator\
    \     TSi        44\n      Traffic Selector - Responder     TSr        45\n  \
    \    Encrypted and Authenticated      SK         46\n   o  Critical (1 bit) -\
    \ MUST be set to zero if the sender wants the\n      recipient to skip this payload\
    \ if it does not understand the\n      payload type code in the Next Payload field\
    \ of the previous\n      payload.  MUST be set to 1 if the sender wants the recipient\
    \ to\n      reject this entire message if it does not understand the payload\n\
    \      type.  MUST be ignored by the recipient if the recipient\n      understands\
    \ the payload type code.  MUST be set to zero for\n      payload types defined\
    \ in this document.  Note that the critical\n      bit applies to the current\
    \ payload rather than the \"next\" payload\n      whose type code appears in the\
    \ first octet.\n   o  Payload Length (2 octets, unsigned integer) - Length in\
    \ octets of\n      the current payload, including the generic payload header.\n"
- title: A.3.  Security Association Payload
  contents:
  - "A.3.  Security Association Payload\n   The Security Association payload, denoted\
    \ SA in this document, is\n   used to negotiate attributes of a Security Association.\n\
    \   An SA payload consists of one or more proposals.  Each proposal\n   includes\
    \ one protocol.  Each protocol contains one or more transforms\n   -- each specifying\
    \ a cryptographic algorithm.  Each transform\n   contains zero or more attributes\
    \ (attributes are needed only if the\n   Transform ID does not completely specify\
    \ the cryptographic algorithm;\n   currently, the only attribute is the Key Length\
    \ attribute for\n   variable-length ciphers, meaning there is exactly zero or\
    \ one\n   attribute).\n   The responder MUST choose a single suite, which may\
    \ be any subset of\n   the SA proposal following the rules below.\n   Each proposal\
    \ contains one protocol.  If a proposal is accepted, the\n   SA response MUST\
    \ contain the same protocol.  Each IPsec protocol\n   proposal contains one or\
    \ more transforms.  Each transform contains a\n   Transform Type.  The accepted\
    \ cryptographic suite MUST contain\n   exactly one transform of each type included\
    \ in the proposal.  For\n   example: if an ESP proposal includes transforms ENCR_3DES,\
    \ ENCR_AES\n   w/keysize 128, ENCR_AES w/keysize 256, AUTH_HMAC_MD5, and\n   AUTH_HMAC_SHA,\
    \ the accepted suite MUST contain one of the ENCR_\n   transforms and one of the\
    \ AUTH_ transforms.  Thus, six combinations\n   are acceptable.\n   Minimal implementation\
    \ can create very simple SA proposal, i.e.,\n   include one proposal, which contains\
    \ exactly one transform for each\n   Transform Type.  It is important to only\
    \ include one Diffie-Hellman\n   group in the proposal, so there is no need to\
    \ do INVALID_KE_PAYLOAD\n   processing in responses.\n   When parsing an SA, an\
    \ implementation MUST check that the total\n   Payload Length is consistent with\
    \ the payload's internal lengths and\n   counts.  Proposals, Transforms, and Attributes\
    \ each have their own\n   variable-length encodings.  They are nested such that\
    \ the Payload\n   Length of an SA includes the combined contents of the SA, Proposal,\n\
    \   Transform, and Attribute information.  The length of a Proposal\n   includes\
    \ the lengths of all Transforms and Attributes it contains.\n   The length of\
    \ a Transform includes the lengths of all Attributes it\n   contains.\n   Each\
    \ Proposal/Protocol structure is followed by one or more transform\n   structures.\
    \  The number of different transforms is generally\n   determined by the Protocol.\
    \  AH generally has two transforms:\n   Extended Sequence Numbers (ESNs) and an\
    \ integrity check algorithm.\n   ESP generally has three: ESN, an encryption algorithm,\
    \ and an\n   integrity check algorithm.  IKEv2 generally has four transforms:\
    \ a\n   Diffie-Hellman group, an integrity check algorithm, a PRF algorithm,\n\
    \   and an encryption algorithm.  For each Protocol, the set of\n   permissible\
    \ transforms is assigned Transform ID numbers, which appear\n   in the header\
    \ of each transform.\n   If there are multiple transforms with the same Transform\
    \ Type, the\n   proposal is an OR of those transforms.  If there are multiple\n\
    \   transforms with different Transform Types, the proposal is an AND of\n   the\
    \ different groups.\n   A given transform MAY have one or more Attributes.  Attributes\
    \ are\n   necessary when the transform can be used in more than one way, as\n\
    \   when an encryption algorithm has a variable key size.  The transform\n   would\
    \ specify the algorithm, and the attribute would specify the key\n   size.  To\
    \ propose alternate values for an attribute (for example,\n   multiple key sizes\
    \ for the AES encryption algorithm), an\n   implementation MUST include multiple\
    \ transforms with the same\n   Transform Type each with a single Attribute.\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                        <Proposals>                          ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 3:  Security Association Payload\n   o  Proposals (variable)\
    \ - One or more proposal substructures.\n"
- title: A.3.1.  Proposal Substructure
  contents:
  - "A.3.1.  Proposal Substructure\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 0 (last) or 2 |   RESERVED    |         Proposal Length       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Proposal Num  |  Protocol ID  |    SPI Size   |Num  Transforms|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                        SPI (variable)                         ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                      <Transforms>                           ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 4:  Proposal Substructure\n   o  0 (last) or 2 (more) (1 octet)\
    \ - Specifies whether this is the\n      last Proposal Substructure in the SA.\n\
    \   o  Proposal Length (2 octets, unsigned integer) - Length of this\n      proposal,\
    \ including all transforms and attributes that follow.\n   o  Proposal Num (1\
    \ octet) - When a proposal is made, the first\n      proposal in an SA payload\
    \ MUST be 1, and subsequent proposals MUST\n      be one more than the previous\
    \ proposal.  When a proposal is\n      accepted, the proposal number in the SA\
    \ payload MUST match the\n      number on the proposal sent that was accepted.\n\
    \   o  Protocol ID (1 octet) - Specifies the IPsec protocol identifier\n     \
    \ for the current negotiation.\n      Protocol                Protocol ID\n  \
    \    -----------------------------------\n      IKE                     1\n  \
    \    AH                      2\n      ESP                     3\n   o  SPI Size\
    \ (1 octet) - For an initial IKE SA negotiation, this field\n      MUST be zero;\
    \ the SPI is obtained from the outer header.  During\n      subsequent negotiations,\
    \ it is equal to the size, in octets, of\n      the SPI of the corresponding protocol\
    \ (8 for IKE and 4 for ESP and\n      AH).\n   o  Num Transforms (1 octet) - Specifies\
    \ the number of transforms in\n      this proposal.\n   o  SPI (variable) - The\
    \ sending entity's SPI.  When the SPI Size\n      field is zero, this field is\
    \ not present in the Security\n      Association payload.\n   o  Transforms (variable)\
    \ - One or more transform substructures.\n"
- title: A.3.2.  Transform Substructure
  contents:
  - "A.3.2.  Transform Substructure\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 0 (last) or 3 |   RESERVED    |        Transform Length       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Transform Type |   RESERVED    |          Transform ID         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                    Transform Attributes                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 5:  Transform Substructure\n   o  0 (last) or 3 (more) (1\
    \ octet) - Specifies whether this is the\n      last Transform Substructure in\
    \ the Proposal.\n   o  Transform Length - The length (in octets) of the Transform\n\
    \      Substructure including Header and Attributes.\n   o  Transform Type (1\
    \ octet) - The type of transform being specified\n      in this transform.  Different\
    \ protocols support different\n      Transform Types.  For some protocols, some\
    \ of the transforms may\n      be optional.  If a transform is optional and the\
    \ initiator wishes\n      to propose that the transform be omitted, no transform\
    \ of the\n      given type is included in the proposal.  If the initiator wishes\n\
    \      to make use of the transform optional to the responder, it\n      includes\
    \ a transform substructure with Transform ID = 0 as one of\n      the options.\n\
    \   o  Transform ID (2 octets) - The specific instance of the Transform\n    \
    \  Type being proposed.\n   The relevant Transform Type values are listed below.\
    \  For more\n   information see [RFC7296].\n   Description                   \
    \  Trans.  Used In\n                                   Type\n   ------------------------------------------------------------------\n\
    \   Encryption Algorithm (ENCR)     1       IKE and ESP\n   Pseudorandom Function\
    \ (PRF)     2       IKE\n   Integrity Algorithm (INTEG)     3       IKE, AH, optional\
    \ in ESP\n   Diffie-Hellman group (D-H)      4       IKE, optional in AH & ESP\n\
    \   Extended Sequence Numbers (ESN) 5       AH and ESP\n   For Transform Type\
    \ 1 (Encryption Algorithm), the relevant Transform\n   IDs are listed below.\n\
    \   Name                 Number\n   ---------------------------\n   ENCR_AES_CBC\
    \         12\n   ENCR_AES-CCM_8       14\n   For Transform Type 2 (Pseudorandom\
    \ Function), the relevant Transform\n   IDs are listed below.\n   Name       \
    \                 Number\n   ----------------------------------\n   PRF_HMAC_SHA1\
    \               2\n   For Transform Type 3 (Integrity Algorithm), the relevant\
    \ Transform\n   IDs are listed below.\n   Name                 Number\n   ---------------------------\n\
    \   AUTH_HMAC_SHA1_96    2\n   AUTH_AES_XCBC_96     5\n   For Transform Type 4\
    \ (Diffie-Hellman group), the relevant Transform\n   IDs are listed below.\n \
    \  Name               Number\n   -------------------------\n   1536-bit MODP \
    \     5\n   2048-bit MODP      14\n   For Transform Type 5 (Extended Sequence\
    \ Numbers), the relevant\n   Transform IDs are listed below.\n   Name        \
    \                       Number\n   --------------------------------------------\n\
    \   No Extended Sequence Numbers       0\n   Extended Sequence Numbers       \
    \   1\n   Note that an initiator who supports ESNs will usually include two ESN\n\
    \   transforms, with values \"0\" and \"1\", in its proposals.  A proposal\n \
    \  containing a single ESN transform with value \"1\" means that using\n   normal\
    \ (non-extended) sequence numbers is not acceptable.\n"
- title: A.3.3.  Valid Transform Types by Protocol
  contents:
  - "A.3.3.  Valid Transform Types by Protocol\n   The number and type of transforms\
    \ that accompany an SA payload are\n   dependent on the protocol in the SA itself.\
    \  An SA payload proposing\n   the establishment of an SA has the following mandatory\
    \ and optional\n   Transform Types.  A compliant implementation MUST understand\
    \ all\n   mandatory and optional types for each protocol it supports (though it\n\
    \   need not accept proposals with unacceptable suites).  A proposal MAY\n   omit\
    \ the optional types if the only value for them it will accept is\n   NONE.\n\
    \   Protocol    Mandatory Types          Optional Types\n   ---------------------------------------------------\n\
    \   IKE         ENCR, PRF, INTEG, D-H\n   ESP         ENCR, ESN              \
    \  INTEG, D-H\n   AH          INTEG, ESN               D-H\n"
- title: A.3.4.  Transform Attributes
  contents:
  - "A.3.4.  Transform Attributes\n   Transform Type 1 (Encryption Algorithm) transforms\
    \ might include one\n   transform attribute: Key Length.\n                   \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1|       Attribute Type        |        Attribute Value        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 6:  Data Attributes\n   o  Attribute Type (15 bits)\
    \ - Unique identifier for each type of\n      attribute (see below).\n   o  Attribute\
    \ Value - Value of the attribute associated with the\n      attribute type.\n\
    \   Attribute Type         Value\n   ----------------------------\n   Key Length\
    \ (in bits)   14\n   The Key Length attribute specifies the key length in bits\
    \ (MUST use\n   network byte order) for certain transforms as follows:\n   o \
    \ The Key Length attribute MUST NOT be used with transforms that use\n      a\
    \ fixed-length key.\n   o  Some transforms specify that the Key Length attribute\
    \ MUST be\n      always included.  For example, ENCR_AES_CBC.\n"
- title: A.4.  Key Exchange Payload
  contents:
  - "A.4.  Key Exchange Payload\n                        1                   2   \
    \                3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Diffie-Hellman Group Num    |           RESERVED            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     Key Exchange Data                       ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 7:  Key Exchange Payload Format\n   A Key Exchange payload\
    \ is constructed by copying one's Diffie-Hellman\n   public value into the \"\
    Key Exchange Data\" portion of the payload.\n   The length of the Diffie-Hellman\
    \ public value for modular\n   exponentiation groups (MODPs) MUST be equal to\
    \ the length of the\n   prime modulus over which the exponentiation was performed,\
    \ prepending\n   zero bits to the value if necessary.\n   The Diffie-Hellman Group\
    \ Num identifies the Diffie-Hellman group in\n   which the Key Exchange Data was\
    \ computed.  This Diffie-Hellman Group\n   Num MUST match a Diffie-Hellman group\
    \ specified in a proposal in the\n   SA payload that is sent in the same message.\n"
- title: A.5.  Identification Payloads
  contents:
  - "A.5.  Identification Payloads\n   The Identification payloads, denoted IDi and\
    \ IDr in this document,\n   allow peers to assert an identity to one another.\
    \  When using the\n   ID_IPV4_ADDR/ID_IPV6_ADDR identity types in IDi/IDr payloads,\
    \ IKEv2\n   does not require this address to match the address in the IP header\n\
    \   of IKEv2 packets or anything in the TSi/TSr payloads.  The contents\n   of\
    \ IDi/IDr are used purely to fetch the policy and authentication\n   data related\
    \ to the other party.  In minimal implementation, it might\n   be easiest to always\
    \ use KEY_ID type.  This allows the ID payload to\n   be static.  Using an IP\
    \ address has problems in environments where IP\n   addresses are dynamically\
    \ allocated.\n                        1                   2                  \
    \ 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   ID Type     |                 RESERVED                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                 Identification Data                         ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 8:  Identification Payload Format\n   o  ID Type (1 octet)\
    \ - Specifies the type of Identification being\n      used.\n   o  Identification\
    \ Data (variable length) - Value, as indicated by the\n      Identification Type.\
    \  The length of the Identification Data is\n      computed from the size in the\
    \ ID payload header.\n   The following table lists the assigned semantics for\
    \ the\n   Identification Type field.\n   ID Type                           Value\n\
    \   -------------------------------------------------------------------\n   ID_IPV4_ADDR\
    \                        1\n      A single four (4) octet IPv4 address.\n   ID_FQDN\
    \                             2\n      A fully qualified domain name string. \
    \ An example of an ID_FQDN\n      is \"example.com\".  The string MUST NOT contain\
    \ any terminators\n      (e.g., NULL, CR, etc.). All characters in the ID_FQDN\
    \ are ASCII;\n      for an \"internationalized domain name\", the syntax is as\
    \ defined\n      in [IDNA], for example, \"xn--tmonesimerkki-bfbb.example.net\"\
    .\n   ID_RFC822_ADDR                      3\n      A fully qualified RFC 822 email\
    \ address string based [RFC5322].\n      An example of an ID_RFC822_ADDR is \"\
    jsmith@example.com\".  The\n      string MUST NOT contain any terminators.  Because\
    \ of [EAI],\n      implementations would be wise to treat this field as\n    \
    \  UTF-8-encoded text, not as pure ASCII.\n   ID_IPV6_ADDR                   \
    \     5\n      A single sixteen (16) octet IPv6 address.\n   ID_KEY_ID       \
    \                    11\n      An opaque octet stream that may be used to pass\
    \ vendor-\n      specific information necessary to do certain proprietary\n  \
    \    types of identification.  Minimal implementation might use\n      this type\
    \ to send out a serial number or similar device-specific\n      unique static\
    \ Identification Data for the device.\n"
- title: A.6.  Certificate Payload
  contents:
  - "A.6.  Certificate Payload\n                        1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Cert Encoding |                                               |\n   +-+-+-+-+-+-+-+-+\
    \                                               |\n   ~                      \
    \ Certificate Data                        ~\n   |                            \
    \                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 9:  Certificate Payload Format\n   o  Certificate Encoding\
    \ (1 octet) - This field indicates the type of\n      certificate or certificate-related\
    \ information contained in the\n      Certificate Data field.\n      Certificate\
    \ Encoding                 Value\n      ----------------------------------------------------\n\
    \      X.509 Certificate - Signature        4\n      Raw Public Key          \
    \             15\n   o  Certificate Data (variable length) - Actual encoding of\n\
    \      certificate data.  The type of certificate is indicated by the\n      Certificate\
    \ Encoding field.\n   The syntax of the types above are:\n   o  \"X.509 Certificate\
    \ - Signature\" contains a DER-encoded X.509\n      certificate whose public key\
    \ is used to validate the sender's AUTH\n      payload.  Note that with this encoding,\
    \ if a chain of certificates\n      needs to be sent, multiple CERT payloads are\
    \ used, only the first\n      of which holds the public key used to validate the\
    \ sender's AUTH\n      payload.\n   o  \"Raw Public Key\" contains a raw public\
    \ key.  In essence, the\n      Certificate Payload contains the SubjectPublicKeyInfo\
    \ part of the\n      PKIX Certificate (see Section 4.1.2.7 of [RFC5280]).  This\
    \ is a\n      quite simple ASN.1 object that contains mostly static parts before\n\
    \      the actual public key values.  See [RFC7670] for more information.\n"
- title: A.7.  Certificate Request Payload
  contents:
  - "A.7.  Certificate Request Payload\n                        1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Cert Encoding |                                               |\n   +-+-+-+-+-+-+-+-+\
    \                                               |\n   ~                    Certification\
    \ Authority (CA)               ~\n   |                                       \
    \                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 10:  Certificate Request Payload Format\n   o  Certificate Encoding\
    \ (1 octet) - Contains an encoding of the type\n      or format of certificate\
    \ requested.\n   o  Certification Authority (variable length) - Contains an encoding\n\
    \      of an acceptable certification authority for the type of\n      certificate\
    \ requested.\n   The Certificate Encoding field has the same values as those defined\n\
    \   by the certificate payload.  The Certification Authority field\n   contains\
    \ an indicator of trusted authorities for this certificate\n   type.  The Certification\
    \ Authority value is a concatenated list of\n   SHA-1 hashes of the public keys\
    \ of trusted Certification Authorities.\n   Each is encoded as the SHA-1 hash\
    \ of the Subject Public Key Info\n   element (see Section 4.1.2.7 of [RFC5280])\
    \ from each Trust Anchor\n   certificate.  The 20-octet hashes are concatenated\
    \ and included with\n   no other formatting.\n"
- title: A.8.  Authentication Payload
  contents:
  - "A.8.  Authentication Payload\n                        1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Auth Method   |                RESERVED                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                    Authentication Data                      ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 11:  Authentication Payload Format\n   o  Auth Method (1\
    \ octet) - Specifies the method of authentication\n      used.\n   Mechanism \
    \                             Value\n   -----------------------------------------------------------------\n\
    \   RSA Digital Signature                  1\n      Using an RSA private key with\
    \ an RSASSA-PKCS1-v1_5 signature\n      scheme specified in [PKCS1]; see Section\
    \ 2.15 of [RFC7296] for\n      details.\n   Shared Key Message Integrity Code\
    \      2\n      Computed as specified earlier using the shared key associated\n\
    \      with the identity in the ID payload and the negotiated PRF.\n   o  Authentication\
    \ Data (variable length) - see Section 2.1.\n"
- title: A.9.  Nonce Payload
  contents:
  - "A.9.  Nonce Payload\n                        1                   2          \
    \         3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                          Nonce Data                         ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 12:  Nonce Payload Format\n   o  Nonce Data (variable\
    \ length) - Contains the random data generated\n      by the transmitting entity.\n\
    \   The size of the Nonce Data MUST be between 16 and 256 octets,\n   inclusive.\
    \  Nonce values MUST NOT be reused.\n"
- title: A.10.  Notify Payload
  contents:
  - "A.10.  Notify Payload\n   The Notify payload, denoted N in this document, is\
    \ used to transmit\n   informational data, such as error conditions and state\
    \ transitions,\n   to an IKE peer.  A Notify payload may appear in a response\
    \ message\n   (usually specifying why a request was rejected), in an INFORMATIONAL\n\
    \   exchange (to report an error not in an IKE request), or in any other\n   message\
    \ to indicate sender capabilities or to modify the meaning of\n   the request.\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Protocol ID  |   SPI Size    |      Notify Message Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \              Security Parameter Index (SPI)                 ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     Notification Data                       ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 13:  Notify Payload Format\n   o  Protocol ID (1 octet) -\
    \ If this notification concerns an existing\n      SA whose SPI is given in the\
    \ SPI field, this field indicates the\n      type of that SA.  If the SPI field\
    \ is empty, this field MUST be\n      sent as zero and MUST be ignored on receipt.\n\
    \   o  SPI Size (1 octet) - Length in octets of the SPI as defined by the\n  \
    \    IPsec protocol ID or zero if no SPI is applicable.  For a\n      notification\
    \ concerning the IKE SA, the SPI Size MUST be zero and\n      the SPI field must\
    \ be empty.\n   o  Notify Message Type (2 octets) - Specifies the type of\n  \
    \    notification message.\n   o  SPI (variable length) - Security Parameter Index.\n\
    \   o  Notification Data (variable length) - Status or error data\n      transmitted\
    \ in addition to the Notify Message Type.  Values for\n      this field are type\
    \ specific.\n"
- title: A.10.1.  Notify Message Types
  contents:
  - "A.10.1.  Notify Message Types\n   Notification information can be error messages\
    \ specifying why an SA\n   could not be established.  It can also be status data\
    \ that a process\n   managing an SA database wishes to communicate with a peer\
    \ process.\n   Types in the range 0 - 16383 are intended for reporting errors.\
    \  An\n   implementation receiving a Notify payload with one of these types\n\
    \   that it does not recognize in a response MUST assume that the\n   corresponding\
    \ request has failed entirely.  Unrecognized error types\n   in a request and\
    \ status types in a request or response MUST be\n   ignored, and they should be\
    \ logged.\n   Notify payloads with status types MAY be added to any message and\n\
    \   MUST be ignored if not recognized.  They are intended to indicate\n   capabilities\
    \ and, as part of SA negotiation, are used to negotiate\n   non-cryptographic\
    \ parameters.\n   NOTIFY messages: error types              Value\n   -------------------------------------------------------------------\n\
    \   UNSUPPORTED_CRITICAL_PAYLOAD              1\n       Indicates that the 1-octet\
    \ payload type included in the\n       Notification Data field is unknown.\n \
    \  INVALID_SYNTAX                            7\n       Indicates the IKE message\
    \ that was received was invalid because\n       some type, length, or value was\
    \ out of range or because the\n       request was rejected for policy reasons.\
    \  To avoid a\n       Denial-of-Service (DoS) attack using forged messages, this\n\
    \       status may only be returned for and in an encrypted packet if\n      \
    \ the Message ID and cryptographic checksum were valid.  To avoid\n       leaking\
    \ information to someone probing a node, this status MUST\n       be sent in response\
    \ to any error not covered by one of the other\n       status types.  To aid debugging,\
    \ more detailed error information\n       should be written to a console or log.\n\
    \   NO_PROPOSAL_CHOSEN                       14\n       None of the proposed crypto\
    \ suites was acceptable.  This can be\n       sent in any case where the offered\
    \ proposals are not acceptable\n       for the responder.\n   NO_ADDITIONAL_SAS\
    \                        35\n       Specifies that the node is unwilling to accept\
    \ any more Child\n       SAs.\n   NOTIFY messages: status types            Value\n\
    \   -------------------------------------------------------------------\n   INITIAL_CONTACT\
    \                          16384\n       Asserts that this IKE SA is the only\
    \ IKE SA currently active\n       between the authenticated identities.\n"
- title: A.11.  Traffic Selector Payload
  contents:
  - "A.11.  Traffic Selector Payload\n   Traffic Selector (TS) payloads allow endpoints\
    \ to communicate some of\n   the information from their Security Policy Database\
    \ (SPD) to their\n   peers.  TS payloads specify the selection criteria for packets\
    \ that\n   will be forwarded over the newly set up SA.\n                     \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Number of TSs |                 RESERVED                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     <Traffic Selectors>                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 14:  Traffic Selectors Payload Format\n   o  Number of TSs\
    \ (1 octet) - Number of Traffic Selectors being\n      provided.\n   o  Traffic\
    \ Selectors (variable length) - One or more individual\n      Traffic Selectors.\n\
    \   The length of the Traffic Selector payload includes the TS header and\n  \
    \ all the Traffic Selectors.\n   There is no requirement that TSi and TSr contain\
    \ the same number of\n   individual Traffic Selectors.  Thus, they are interpreted\
    \ as follows:\n   a packet matches a given TSi/TSr if it matches at least one\
    \ of the\n   individual selectors in TSi and at least one of the individual\n\
    \   selectors in TSr.\n   Two TS payloads appear in each of the messages in the\
    \ exchange that\n   creates a Child SA pair.  Each TS payload contains one or\
    \ more\n   Traffic Selectors.  Each Traffic Selector consists of an address\n\
    \   range (IPv4 or IPv6), a port range, and an IP protocol ID.\n   The first of\
    \ the two TS payloads is known as TSi (Traffic Selector -\n   initiator).  The\
    \ second is known as TSr (Traffic Selector -\n   responder).  TSi specifies the\
    \ source address of traffic forwarded\n   from (or the destination address of\
    \ traffic forwarded to) the\n   initiator of the Child SA pair.  TSr specifies\
    \ the destination\n   address of the traffic forwarded to (or the source address\
    \ of the\n   traffic forwarded from) the responder of the Child SA pair.\n   IKEv2\
    \ allows the responder to choose a subset of the traffic proposed\n   by the initiator.\n\
    \   When the responder chooses a subset of the traffic proposed by the\n   initiator,\
    \ it narrows the Traffic Selectors to some subset of the\n   initiator's proposal\
    \ (provided the set does not become the null set).\n   If the type of Traffic\
    \ Selector proposed is unknown, the responder\n   ignores that Traffic Selector,\
    \ so that the unknown type is not\n   returned in the narrowed set.\n   To enable\
    \ the responder to choose the appropriate range, if the\n   initiator has requested\
    \ the SA due to a data packet, the initiator\n   SHOULD include as the first Traffic\
    \ Selector in each TSi and TSr a\n   very specific Traffic Selector including\
    \ the addresses in the packet\n   triggering the request.  If the initiator creates\
    \ the Child SA pair\n   not in response to an arriving packet, but rather, say,\
    \ upon startup,\n   then there may be no specific addresses the initiator prefers\
    \ for the\n   initial tunnel over any other.  In that case, the first values in\
    \ TSi\n   and TSr can be ranges rather than specific values.\n   As minimal implementations\
    \ might only support one SA, the Traffic\n   Selectors will usually be from the\
    \ initiator's IP address to the\n   responder's IP address (i.e., no port or protocol\
    \ selectors and only\n   one range).\n"
- title: A.11.1.  Traffic Selector
  contents:
  - "A.11.1.  Traffic Selector\n                        1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   TS Type     |IP Protocol ID |       Selector Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Start Port          |           End Port            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                       Starting Address                      ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                       Ending Address                        ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 15: Traffic Selector\n   o  TS Type (1 octet) - Specifies\
    \ the type of Traffic Selector.\n   o  IP protocol ID (1 octet) - Value specifying\
    \ an associated IP\n      protocol ID (such as UDP, TCP, and ICMP).  A value of\
    \ zero means\n      that the protocol ID is not relevant to this Traffic Selector\
    \ --\n      the SA can carry all protocols.\n   o  Selector Length - Specifies\
    \ the length of this Traffic Selector\n      substructure including the header.\n\
    \   o  Start Port (2 octets, unsigned integer) - Value specifying the\n      smallest\
    \ port number allowed by this Traffic Selector.  For\n      protocols for which\
    \ port is undefined (including protocol 0), or\n      if all ports are allowed,\
    \ this field MUST be zero.\n   o  End Port (2 octets, unsigned integer) - Value\
    \ specifying the\n      largest port number allowed by this Traffic Selector.\
    \  For\n      protocols for which port is undefined (including protocol 0), or\n\
    \      if all ports are allowed, this field MUST be 65535.\n   o  Starting Address\
    \ - The smallest address included in this Traffic\n      Selector (length determined\
    \ by TS Type).\n   o  Ending Address - The largest address included in this Traffic\n\
    \      Selector (length determined by TS Type).\n   The following table lists\
    \ values for the Traffic Selector Type field\n   and the corresponding Address\
    \ Selector Data.\n   TS Type                            Value\n   -------------------------------------------------------------------\n\
    \   TS_IPV4_ADDR_RANGE                  7\n       A range of IPv4 addresses, represented\
    \ by two 4-octet\n       values.  The first value is the beginning IPv4 address\n\
    \       (inclusive), and the second value is the ending IPv4 address\n       (inclusive).\
    \  All addresses falling between the two specified\n       addresses are considered\
    \ to be within the list.\n   TS_IPV6_ADDR_RANGE                  8\n       A range\
    \ of IPv6 addresses, represented by two 16-octet\n       values.  The first value\
    \ is the beginning IPv6 address\n       (inclusive), and the second value is the\
    \ ending IPv6 address\n       (inclusive).  All addresses falling between the\
    \ two specified\n       addresses are considered to be within the list.\n"
- title: A.12.  Encrypted Payload
  contents:
  - "A.12.  Encrypted Payload\n   The Encrypted payload, denoted as SK{...} in this\
    \ document, contains\n   other payloads in encrypted form.\n                 \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Initialization Vector                     |\n   |  \
    \     (length is block size for the encryption algorithm)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Encrypted IKE Payloads                     ~\n   +  \
    \             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        \
    \       |             Padding (0-255 octets)            |\n   +-+-+-+-+-+-+-+-+\
    \                               +-+-+-+-+-+-+-+-+\n   |                      \
    \                         |  Pad Length   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Integrity Checksum Data                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 16:  Encrypted Payload Format\n   o  Next Payload - The payload\
    \ type of the first embedded payload.\n      Note that this is an exception in\
    \ the standard header format,\n      since the Encrypted payload is the last payload\
    \ in the message;\n      therefore, the Next Payload field would normally be zero.\
    \  But\n      because the content of this payload is embedded payloads and there\n\
    \      was no natural place to put the type of the first one, that type\n    \
    \  is placed here.\n   o  Payload Length - Includes the lengths of the header,\n\
    \      initialization vector (IV), Encrypted IKE payloads, Padding, Pad\n    \
    \  Length, and Integrity Checksum Data.\n   o  Initialization Vector - For Cipher\
    \ Block Chaining (CBC) mode\n      ciphers, the length of the initialization vector\
    \ (IV) is equal to\n      the block length of the underlying encryption algorithm.\
    \  Senders\n      MUST select a new unpredictable IV for every message; recipients\n\
    \      MUST accept any value.  The reader is encouraged to consult\n      [MODES]\
    \ for advice on IV generation.  In particular, using the\n      final ciphertext\
    \ block of the previous message is not considered\n      unpredictable.  For modes\
    \ other than CBC, the IV format and\n      processing is specified in the document\
    \ specifying the encryption\n      algorithm and mode.\n   o  IKE payloads are\
    \ as specified earlier in this section.  This field\n      is encrypted with the\
    \ negotiated cipher.\n   o  Padding MAY contain any value chosen by the sender\
    \ and MUST have a\n      length that makes the combination of the payloads, the\
    \ Padding,\n      and the Pad Length to be a multiple of the encryption block\
    \ size.\n      This field is encrypted with the negotiated cipher.\n   o  Pad\
    \ Length is the length of the Padding field.  The sender SHOULD\n      set the\
    \ Pad Length to the minimum value that makes the combination\n      of the payloads,\
    \ the Padding, and the Pad Length a multiple of the\n      block size, but the\
    \ recipient MUST accept any length that results\n      in proper alignment.  This\
    \ field is encrypted with the negotiated\n      cipher.\n   o  Integrity Checksum\
    \ Data is the cryptographic checksum of the\n      entire message starting with\
    \ the Fixed IKE header through the Pad\n      Length.  The checksum MUST be computed\
    \ over the encrypted message.\n      Its length is determined by the integrity\
    \ algorithm negotiated.\n"
- title: Appendix B.  Useful Optional Features
  contents:
  - "Appendix B.  Useful Optional Features\n   There are some optional features of\
    \ IKEv2, which might be useful for\n   minimal implementations in some scenarios.\
    \  Such features include raw\n   public keys authentication and sending an IKE\
    \ SA delete notification.\n"
- title: B.1.  IKE SA Delete Notification
  contents:
  - "B.1.  IKE SA Delete Notification\n   In some scenarios, a minimal implementation\
    \ device creates an IKE SA,\n   sends one or few packets, perhaps gets some packets\
    \ back, and then\n   the device goes back to sleep, forgetting the IKE SA.  In\
    \ such\n   scenarios, it would be nice for the minimal implementation to send\n\
    \   the IKE SA delete notification to tell the other end that the IKE SA\n   is\
    \ going away, so it can free the resources.\n   Deleting the IKE SA can be done\
    \ by sending one packet with a fixed\n   Message ID and with only one payload\
    \ inside the Encrypted payload.\n   The other end will send back an empty response:\n\
    \   Initiator                         Responder\n   -------------------------------------------------------------------\n\
    \   HDR(SPIi=xxx, SPIr=yyy, INFORMATIONAL,\n       Flags: Initiator, Message ID=2),\n\
    \       SK {D}  -->\n                      <--  HDR(SPIi=xxx, SPIr=yyy, INFORMATIONAL,\n\
    \                               Flags: Response, Message ID=2),\n            \
    \                   SK {}\n   The Delete payload format is:\n                \
    \        1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Protocol ID   |   SPI Size    |          Num of SPIs          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \             Security Parameter Index(es) (SPI)              ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 17:  Delete Payload Format\n   o  Protocol ID (1 octet)\
    \ - Must be 1 for an IKE SA.\n   o  SPI Size (1 octet) - Length in octets of the\
    \ SPI as defined by the\n      protocol ID.  It MUST be zero for IKE (SPI is in\
    \ the message\n      header).\n   o  Num of SPIs (2 octets, unsigned integer)\
    \ - The number of SPIs\n      contained in the Delete payload.  This MUST be zero\
    \ for IKE.\n   o  Security Parameter Index(es) (variable length) - Identifies\
    \ the\n      specific Security Association(s) to delete.  The length of this\n\
    \      field is determined by the SPI Size and Num of SPIs fields.  This\n   \
    \   field is empty for the IKE SA delete.\n"
- title: B.2.  Raw Public Keys
  contents:
  - "B.2.  Raw Public Keys\n   In some scenarios, the shared secret authentication\
    \ is not safe\n   enough, as anybody who knows the secret can impersonate the\
    \ server.\n   If the shared secret is printed on the side of the device, then\n\
    \   anybody who gets physical access to the device can read it.  In such\n   environments,\
    \ public key authentication allows stronger\n   authentication with minimal operational\
    \ overhead.  Certificate\n   support is quite complex, and minimal implementations\
    \ do not usually\n   have need for them.  Using Raw Public Keys is much simpler,\
    \ and it\n   scales similar to certificates.  The fingerprint of the raw public\n\
    \   key can still be distributed by, for example, printing it on the side\n  \
    \ of the device allowing setup similar to using a shared secret.\n   Raw public\
    \ keys can also be used in a \"leap of faith\" or baby duck\n   style initial\
    \ setup, where the device imprints itself to the first\n   device it sees when\
    \ it boots up the first time.  After that initial\n   connection, it stores the\
    \ fingerprint of the Raw Public Key of the\n   server in its own configuration\
    \ and verifies that it never changes\n   (unless a \"reset to factory settings\"\
    \ or similar command is issued).\n   This changes the initial IKE_AUTH payloads\
    \ as follows:\n   Initiator                         Responder\n   -------------------------------------------------------------------\n\
    \   HDR(SPIi=xxx, SPIr=yyy, IKE_AUTH,\n       Flags: Initiator, Message ID=1),\n\
    \       SK {IDi, CERT, AUTH, SAi2, TSi, TSr,\n           N(INITIAL_CONTACT)} \
    \ -->\n                     <--  HDR(SPIi=xxx, SPIr=yyy, IKE_AUTH, Flags:\n  \
    \                               Response, Message ID=1),\n                   \
    \              SK {IDr, CERT, AUTH, SAr2, TSi, TSr}\n   The CERT payloads contain\
    \ the raw public keys used to sign the hash\n   of the InitiatorSignedOctects/ResponderSignedOctects\
    \ when generating\n   an AUTH payload.  Minimal implementations should use SHA-1\
    \ as the\n   hash function as that is the \"SHOULD\" support algorithm specified\
    \ in\n   RFC 7296, so it is the most likely one that is supported by all\n   devices.\n\
    \   Note that RFC 7296 already obsoleted the old Raw RSA Key method, and\n   \"\
    Generic Raw Public-Key Support for IKEv2\" [RFC7670] adds a new\n   format to\
    \ allow using any types of raw public keys with IKEv2.  This\n   document only\
    \ specifies how to use the new format.\n   In these setups, it might be possible\
    \ that authenticating the server\n   is not needed at all.  If a minimal device\
    \ is sending, for example,\n   sensor information to the server, the server wants\
    \ to verify that the\n   sensor is who it claims to be using raw public keys,\
    \ but the sensor\n   does not really care who the server is.  In such cases, the\
    \ NULL\n   authentication method [RFC7619] would be useful, as it allows devices\n\
    \   to do one-way authentication.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Most of the content of this document is copied from RFC\
    \ 7296.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Tero Kivinen\n   INSIDE Secure\n   Eerikinkatu 28\n   HELSINKI\
    \  FI-00180\n   FINLAND\n   Email: kivinen@iki.fi\n"
