- contents:
  - '                  A Border Gateway Protocol 4 (BGP-4)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document discusses the Border Gateway Protocol (BGP), which
    is\n   an inter-Autonomous System routing protocol.\n   The primary function of
    a BGP speaking system is to exchange network\n   reachability information with
    other BGP systems.  This network\n   reachability information includes information
    on the list of\n   Autonomous Systems (ASes) that reachability information traverses.\n
    \  This information is sufficient for constructing a graph of AS\n   connectivity
    for this reachability from which routing loops may be\n   pruned, and, at the
    AS level, some policy decisions may be enforced.\n   BGP-4 provides a set of mechanisms
    for supporting Classless Inter-\n   Domain Routing (CIDR).  These mechanisms include
    support for\n   advertising a set of destinations as an IP prefix, and eliminating\n
    \  the concept of network \"class\" within BGP.  BGP-4 also introduces\n   mechanisms
    that allow aggregation of routes, including aggregation of\n   AS paths.\n   This
    document obsoletes RFC 1771.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Definition of Commonly Used Terms ..........................4\n      1.2.
    Specification of Requirements ..............................6\n   2. Acknowledgements
    ................................................6\n   3. Summary of Operation
    ............................................7\n      3.1. Routes: Advertisement
    and Storage ..........................9\n      3.2. Routing Information Base ..................................10\n
    \  4. Message Formats ................................................11\n      4.1.
    Message Header Format .....................................12\n      4.2. OPEN
    Message Format .......................................13\n      4.3. UPDATE Message
    Format .....................................14\n      4.4. KEEPALIVE Message Format
    ..................................21\n      4.5. NOTIFICATION Message Format ...............................21\n
    \  5. Path Attributes ................................................23\n      5.1.
    Path Attribute Usage ......................................25\n           5.1.1.
    ORIGIN .............................................25\n           5.1.2. AS_PATH
    ............................................25\n           5.1.3. NEXT_HOP ...........................................26\n
    \          5.1.4. MULTI_EXIT_DISC ....................................28\n           5.1.5.
    LOCAL_PREF .........................................29\n           5.1.6. ATOMIC_AGGREGATE
    ...................................29\n           5.1.7. AGGREGATOR .........................................30\n
    \  6. BGP Error Handling. ............................................30\n      6.1.
    Message Header Error Handling .............................31\n      6.2. OPEN
    Message Error Handling ...............................31\n      6.3. UPDATE Message
    Error Handling .............................32\n      6.4. NOTIFICATION Message
    Error Handling .......................34\n      6.5. Hold Timer Expired Error
    Handling .........................34\n      6.6. Finite State Machine Error Handling
    .......................35\n      6.7. Cease .....................................................35\n
    \     6.8. BGP Connection Collision Detection ........................35\n   7.
    BGP Version Negotiation ........................................36\n   8. BGP
    Finite State Machine (FSM) .................................37\n      8.1. Events
    for the BGP FSM ....................................38\n           8.1.1. Optional
    Events Linked to Optional Session\n                  Attributes .........................................38\n
    \          8.1.2. Administrative Events ..............................42\n           8.1.3.
    Timer Events .......................................46\n           8.1.4. TCP
    Connection-Based Events ........................47\n           8.1.5. BGP Message-Based
    Events ...........................49\n      8.2. Description of FSM ........................................51\n
    \          8.2.1. FSM Definition .....................................51\n                  8.2.1.1.
    Terms \"active\" and \"passive\" ..............52\n                  8.2.1.2.
    FSM and Collision Detection ...............52\n                  8.2.1.3. FSM
    and Optional Session Attributes .......52\n                  8.2.1.4. FSM Event
    Numbers .........................53\n                  8.2.1.5. FSM Actions that
    are Implementation\n                           Dependent .................................53\n
    \          8.2.2. Finite State Machine ...............................53\n   9.
    UPDATE Message Handling ........................................75\n      9.1.
    Decision Process ..........................................76\n           9.1.1.
    Phase 1: Calculation of Degree of Preference .......77\n           9.1.2. Phase
    2: Route Selection ...........................77\n                  9.1.2.1. Route
    Resolvability Condition .............79\n                  9.1.2.2. Breaking Ties
    (Phase 2) ...................80\n           9.1.3. Phase 3: Route Dissemination
    .......................82\n           9.1.4. Overlapping Routes .................................83\n
    \     9.2. Update-Send Process .......................................84\n           9.2.1.
    Controlling Routing Traffic Overhead ...............85\n                  9.2.1.1.
    Frequency of Route Advertisement ..........85\n                  9.2.1.2. Frequency
    of Route Origination ............85\n           9.2.2. Efficient Organization
    of Routing Information ......86\n                  9.2.2.1. Information Reduction
    .....................86\n                  9.2.2.2. Aggregating Routing Information
    ...........87\n      9.3. Route Selection Criteria ..................................89\n
    \     9.4. Originating BGP routes ....................................89\n   10.
    BGP Timers ....................................................90\n   Appendix
    A.  Comparison with RFC 1771 .............................92\n   Appendix B.  Comparison
    with RFC 1267 .............................93\n   Appendix C.  Comparison with
    RFC 1163 .............................93\n   Appendix D.  Comparison with RFC
    1105 .............................94\n   Appendix E.  TCP Options that May Be
    Used with BGP ................94\n   Appendix F.  Implementation Recommendations
    .......................95\n                Appendix F.1.  Multiple Networks Per
    Message .........95\n                Appendix F.2.  Reducing Route Flapping ...............96\n
    \               Appendix F.3.  Path Attribute Ordering ...............96\n                Appendix
    F.4.  AS_SET Sorting ........................96\n                Appendix F.5.
    \ Control Over Version Negotiation ......96\n                Appendix F.6.  Complex
    AS_PATH Aggregation ...........96\n   Security Considerations ...........................................97\n
    \  IANA Considerations ...............................................99\n   Normative
    References .............................................101\n   Informative References
    ...........................................101\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Border Gateway Protocol (BGP) is an inter-Autonomous
    System\n   routing protocol.\n   The primary function of a BGP speaking system
    is to exchange network\n   reachability information with other BGP systems.  This
    network\n   reachability information includes information on the list of\n   Autonomous
    Systems (ASes) that reachability information traverses.\n   This information is
    sufficient for constructing a graph of AS\n   connectivity for this reachability,
    from which routing loops may be\n   pruned and, at the AS level, some policy decisions
    may be enforced.\n   BGP-4 provides a set of mechanisms for supporting Classless
    Inter-\n   Domain Routing (CIDR) [RFC1518, RFC1519].  These mechanisms include\n
    \  support for advertising a set of destinations as an IP prefix and\n   eliminating
    the concept of network \"class\" within BGP.  BGP-4 also\n   introduces mechanisms
    that allow aggregation of routes, including\n   aggregation of AS paths.\n   Routing
    information exchanged via BGP supports only the destination-\n   based forwarding
    paradigm, which assumes that a router forwards a\n   packet based solely on the
    destination address carried in the IP\n   header of the packet.  This, in turn,
    reflects the set of policy\n   decisions that can (and cannot) be enforced using
    BGP.  BGP can\n   support only those policies conforming to the destination-based\n
    \  forwarding paradigm.\n"
  - contents:
    - "1.1.  Definition of Commonly Used Terms\n   This section provides definitions
      for terms that have a specific\n   meaning to the BGP protocol and that are
      used throughout the text.\n   Adj-RIB-In\n      The Adj-RIBs-In contains unprocessed
      routing information that has\n      been advertised to the local BGP speaker
      by its peers.\n   Adj-RIB-Out\n      The Adj-RIBs-Out contains the routes for
      advertisement to specific\n      peers by means of the local speaker's UPDATE
      messages.\n   Autonomous System (AS)\n      The classic definition of an Autonomous
      System is a set of routers\n      under a single technical administration, using
      an interior gateway\n      protocol (IGP) and common metrics to determine how
      to route\n      packets within the AS, and using an inter-AS routing protocol
      to\n      determine how to route packets to other ASes.  Since this classic\n
      \     definition was developed, it has become common for a single AS to\n      use
      several IGPs and, sometimes, several sets of metrics within an\n      AS.  The
      use of the term Autonomous System stresses the fact that,\n      even when multiple
      IGPs and metrics are used, the administration\n      of an AS appears to other
      ASes to have a single coherent interior\n      routing plan, and presents a
      consistent picture of the\n      destinations that are reachable through it.\n
      \  BGP Identifier\n      A 4-octet unsigned integer that indicates the BGP Identifier
      of\n      the sender of BGP messages.  A given BGP speaker sets the value of\n
      \     its BGP Identifier to an IP address assigned to that BGP speaker.\n      The
      value of the BGP Identifier is determined upon startup and is\n      the same
      for every local interface and BGP peer.\n   BGP speaker\n      A router that
      implements BGP.\n   EBGP\n      External BGP (BGP connection between external
      peers).\n   External peer\n      Peer that is in a different Autonomous System
      than the local\n      system.\n   Feasible route\n      An advertised route
      that is available for use by the recipient.\n   IBGP\n      Internal BGP (BGP
      connection between internal peers).\n   Internal peer\n      Peer that is in
      the same Autonomous System as the local system.\n   IGP\n      Interior Gateway
      Protocol - a routing protocol used to exchange\n      routing information among
      routers within a single Autonomous\n      System.\n   Loc-RIB\n      The Loc-RIB
      contains the routes that have been selected by the\n      local BGP speaker's
      Decision Process.\n   NLRI\n      Network Layer Reachability Information.\n
      \  Route\n      A unit of information that pairs a set of destinations with
      the\n      attributes of a path to those destinations.  The set of\n      destinations
      are systems whose IP addresses are contained in one\n      IP address prefix
      carried in the Network Layer Reachability\n      Information (NLRI) field of
      an UPDATE message.  The path is the\n      information reported in the path
      attributes field of the same\n      UPDATE message.\n   RIB\n      Routing Information
      Base.\n   Unfeasible route\n      A previously advertised feasible route that
      is no longer available\n      for use.\n"
    title: 1.1.  Definition of Commonly Used Terms
  - contents:
    - "1.2.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in RFC 2119 [RFC2119].\n"
    title: 1.2.  Specification of Requirements
  title: 1.  Introduction
- contents:
  - "2.  Acknowledgements\n   This document was originally published as [RFC1267]
    in October 1991,\n   jointly authored by Kirk Lougheed and Yakov Rekhter.\n   We
    would like to express our thanks to Guy Almes, Len Bosack, and\n   Jeffrey C.
    Honig for their contributions to the earlier version\n   (BGP-1) of this document.\n
    \  We would like to specially acknowledge numerous contributions by\n   Dennis
    Ferguson to the earlier version of this document.\n   We would like to explicitly
    thank Bob Braden for the review of the\n   earlier version (BGP-2) of this document,
    and for his constructive\n   and valuable comments.\n   We would also like to
    thank Bob Hinden, Director for Routing of the\n   Internet Engineering Steering
    Group, and the team of reviewers he\n   assembled to review the earlier version
    (BGP-2) of this document.\n   This team, consisting of Deborah Estrin, Milo Medin,
    John Moy, Radia\n   Perlman, Martha Steenstrup, Mike St. Johns, and Paul Tsuchiya,
    acted\n   with a strong combination of toughness, professionalism, and\n   courtesy.\n
    \  Certain sections of the document borrowed heavily from IDRP\n   [IS10747],
    which is the OSI counterpart of BGP.  For this, credit\n   should be given to
    the ANSI X3S3.3 group chaired by Lyman Chapin and\n   to Charles Kunzinger, who
    was the IDRP editor within that group.\n   We would also like to thank Benjamin
    Abarbanel, Enke Chen, Edward\n   Crabbe, Mike Craren, Vincent Gillet, Eric Gray,
    Jeffrey Haas, Dimitry\n   Haskin, Stephen Kent, John Krawczyk, David LeRoy, Dan
    Massey,\n   Jonathan Natale, Dan Pei, Mathew Richardson, John Scudder, John\n
    \  Stewart III, Dave Thaler, Paul Traina, Russ White, Curtis Villamizar,\n   and
    Alex Zinin for their comments.\n   We would like to specially acknowledge Andrew
    Lange for his help in\n   preparing the final version of this document.\n   Finally,
    we would like to thank all the members of the IDR Working\n   Group for their
    ideas and the support they have given to this\n   document.\n"
  title: 2.  Acknowledgements
- contents:
  - "3.  Summary of Operation\n   The Border Gateway Protocol (BGP) is an inter-Autonomous
    System\n   routing protocol.  It is built on experience gained with EGP (as\n
    \  defined in [RFC904]) and EGP usage in the NSFNET Backbone (as\n   described
    in [RFC1092] and [RFC1093]).  For more BGP-related\n   information, see [RFC1772],
    [RFC1930], [RFC1997], and [RFC2858].\n   The primary function of a BGP speaking
    system is to exchange network\n   reachability information with other BGP systems.
    \ This network\n   reachability information includes information on the list of\n
    \  Autonomous Systems (ASes) that reachability information traverses.\n   This
    information is sufficient for constructing a graph of AS\n   connectivity, from
    which routing loops may be pruned, and, at the AS\n   level, some policy decisions
    may be enforced.\n   In the context of this document, we assume that a BGP speaker\n
    \  advertises to its peers only those routes that it uses itself (in\n   this
    context, a BGP speaker is said to \"use\" a BGP route if it is the\n   most preferred
    BGP route and is used in forwarding).  All other cases\n   are outside the scope
    of this document.\n   In the context of this document, the term \"IP address\"
    refers to an\n   IP Version 4 address [RFC791].\n   Routing information exchanged
    via BGP supports only the destination-\n   based forwarding paradigm, which assumes
    that a router forwards a\n   packet based solely on the destination address carried
    in the IP\n   header of the packet.  This, in turn, reflects the set of policy\n
    \  decisions that can (and cannot) be enforced using BGP.  Note that\n   some
    policies cannot be supported by the destination-based forwarding\n   paradigm,
    and thus require techniques such as source routing (aka\n   explicit routing)
    to be enforced.  Such policies cannot be enforced\n   using BGP either.  For example,
    BGP does not enable one AS to send\n   traffic to a neighboring AS for forwarding
    to some destination\n   (reachable through but) beyond that neighboring AS, intending
    that\n   the traffic take a different route to that taken by the traffic\n   originating
    in the neighboring AS (for that same destination).  On\n   the other hand, BGP
    can support any policy conforming to the\n   destination-based forwarding paradigm.\n
    \  BGP-4 provides a new set of mechanisms for supporting Classless\n   Inter-Domain
    Routing (CIDR) [RFC1518, RFC1519].  These mechanisms\n   include support for advertising
    a set of destinations as an IP prefix\n   and eliminating the concept of a network
    \"class\" within BGP.  BGP-4\n   also introduces mechanisms that allow aggregation
    of routes,\n   including aggregation of AS paths.\n   This document uses the term
    `Autonomous System' (AS) throughout.  The\n   classic definition of an Autonomous
    System is a set of routers under\n   a single technical administration, using
    an interior gateway protocol\n   (IGP) and common metrics to determine how to
    route packets within the\n   AS, and using an inter-AS routing protocol to determine
    how to route\n   packets to other ASes.  Since this classic definition was developed,\n
    \  it has become common for a single AS to use several IGPs and,\n   sometimes,
    several sets of metrics within an AS.  The use of the term\n   Autonomous System
    stresses the fact that, even when multiple IGPs and\n   metrics are used, the
    administration of an AS appears to other ASes\n   to have a single coherent interior
    routing plan and presents a\n   consistent picture of the destinations that are
    reachable through it.\n   BGP uses TCP [RFC793] as its transport protocol.  This
    eliminates the\n   need to implement explicit update fragmentation, retransmission,\n
    \  acknowledgement, and sequencing.  BGP listens on TCP port 179.  The\n   error
    notification mechanism used in BGP assumes that TCP supports a\n   \"graceful\"
    close (i.e., that all outstanding data will be delivered\n   before the connection
    is closed).\n   A TCP connection is formed between two systems.  They exchange\n
    \  messages to open and confirm the connection parameters.\n   The initial data
    flow is the portion of the BGP routing table that is\n   allowed by the export
    policy, called the Adj-Ribs-Out (see 3.2).\n   Incremental updates are sent as
    the routing tables change.  BGP does\n   not require a periodic refresh of the
    routing table.  To allow local\n   policy changes to have the correct effect without
    resetting any BGP\n   connections, a BGP speaker SHOULD either (a) retain the
    current\n   version of the routes advertised to it by all of its peers for the\n
    \  duration of the connection, or (b) make use of the Route Refresh\n   extension
    [RFC2918].\n   KEEPALIVE messages may be sent periodically to ensure that the\n
    \  connection is live.  NOTIFICATION messages are sent in response to\n   errors
    or special conditions.  If a connection encounters an error\n   condition, a NOTIFICATION
    message is sent and the connection is\n   closed.\n   A peer in a different AS
    is referred to as an external peer, while a\n   peer in the same AS is referred
    to as an internal peer.  Internal BGP\n   and external BGP are commonly abbreviated
    as IBGP and EBGP.\n   If a particular AS has multiple BGP speakers and is providing
    transit\n   service for other ASes, then care must be taken to ensure a\n   consistent
    view of routing within the AS.  A consistent view of the\n   interior routes of
    the AS is provided by the IGP used within the AS.\n   For the purpose of this
    document, it is assumed that a consistent\n   view of the routes exterior to the
    AS is provided by having all BGP\n   speakers within the AS maintain IBGP with
    each other.\n   This document specifies the base behavior of the BGP protocol.
    \ This\n   behavior can be, and is, modified by extension specifications.  When\n
    \  the protocol is extended, the new behavior is fully documented in the\n   extension
    specifications.\n"
  - contents:
    - "3.1.  Routes: Advertisement and Storage\n   For the purpose of this protocol,
      a route is defined as a unit of\n   information that pairs a set of destinations
      with the attributes of a\n   path to those destinations.  The set of destinations
      are systems\n   whose IP addresses are contained in one IP address prefix that
      is\n   carried in the Network Layer Reachability Information (NLRI) field of\n
      \  an UPDATE message, and the path is the information reported in the\n   path
      attributes field of the same UPDATE message.\n   Routes are advertised between
      BGP speakers in UPDATE messages.\n   Multiple routes that have the same path
      attributes can be advertised\n   in a single UPDATE message by including multiple
      prefixes in the NLRI\n   field of the UPDATE message.\n   Routes are stored
      in the Routing Information Bases (RIBs): namely,\n   the Adj-RIBs-In, the Loc-RIB,
      and the Adj-RIBs-Out, as described in\n   Section 3.2.\n   If a BGP speaker
      chooses to advertise a previously received route, it\n   MAY add to, or modify,
      the path attributes of the route before\n   advertising it to a peer.\n   BGP
      provides mechanisms by which a BGP speaker can inform its peers\n   that a previously
      advertised route is no longer available for use.\n   There are three methods
      by which a given BGP speaker can indicate\n   that a route has been withdrawn
      from service:\n      a) the IP prefix that expresses the destination for a previously\n
      \        advertised route can be advertised in the WITHDRAWN ROUTES\n         field
      in the UPDATE message, thus marking the associated route\n         as being
      no longer available for use,\n      b) a replacement route with the same NLRI
      can be advertised, or\n      c) the BGP speaker connection can be closed, which
      implicitly\n         removes all routes the pair of speakers had advertised
      to each\n         other from service.\n   Changing the attribute(s) of a route
      is accomplished by advertising a\n   replacement route.  The replacement route
      carries new (changed)\n   attributes and has the same address prefix as the
      original route.\n"
    title: '3.1.  Routes: Advertisement and Storage'
  - contents:
    - "3.2.  Routing Information Base\n   The Routing Information Base (RIB) within
      a BGP speaker consists of\n   three distinct parts:\n      a) Adj-RIBs-In: The
      Adj-RIBs-In stores routing information learned\n         from inbound UPDATE
      messages that were received from other BGP\n         speakers.  Their contents
      represent routes that are available\n         as input to the Decision Process.\n
      \     b) Loc-RIB: The Loc-RIB contains the local routing information the\n         BGP
      speaker selected by applying its local policies to the\n         routing information
      contained in its Adj-RIBs-In.  These are\n         the routes that will be used
      by the local BGP speaker.  The\n         next hop for each of these routes MUST
      be resolvable via the\n         local BGP speaker's Routing Table.\n      c)
      Adj-RIBs-Out: The Adj-RIBs-Out stores information the local BGP\n         speaker
      selected for advertisement to its peers.  The routing\n         information
      stored in the Adj-RIBs-Out will be carried in the\n         local BGP speaker's
      UPDATE messages and advertised to its\n         peers.\n   In summary, the Adj-RIBs-In
      contains unprocessed routing information\n   that has been advertised to the
      local BGP speaker by its peers; the\n   Loc-RIB contains the routes that have
      been selected by the local BGP\n   speaker's Decision Process; and the Adj-RIBs-Out
      organizes the routes\n   for advertisement to specific peers (by means of the
      local speaker's\n   UPDATE messages).\n   Although the conceptual model distinguishes
      between Adj-RIBs-In,\n   Loc-RIB, and Adj-RIBs-Out, this neither implies nor
      requires that an\n   implementation must maintain three separate copies of the
      routing\n   information.  The choice of implementation (for example, 3 copies
      of\n   the information vs 1 copy with pointers) is not constrained by the\n
      \  protocol.\n   Routing information that the BGP speaker uses to forward packets
      (or\n   to construct the forwarding table used for packet forwarding) is\n   maintained
      in the Routing Table.  The Routing Table accumulates\n   routes to directly
      connected networks, static routes, routes learned\n   from the IGP protocols,
      and routes learned from BGP.  Whether a\n   specific BGP route should be installed
      in the Routing Table, and\n   whether a BGP route should override a route to
      the same destination\n   installed by another source, is a local policy decision,
      and is not\n   specified in this document.  In addition to actual packet forwarding,\n
      \  the Routing Table is used for resolution of the next-hop addresses\n   specified
      in BGP updates (see Section 5.1.3).\n"
    title: 3.2.  Routing Information Base
  title: 3.  Summary of Operation
- contents:
  - "4.  Message Formats\n   This section describes message formats used by BGP.\n
    \  BGP messages are sent over TCP connections.  A message is processed\n   only
    after it is entirely received.  The maximum message size is 4096\n   octets.  All
    implementations are required to support this maximum\n   message size.  The smallest
    message that may be sent consists of a\n   BGP header without a data portion (19
    octets).\n   All multi-octet fields are in network byte order.\n"
  - contents:
    - "4.1.  Message Header Format\n   Each message has a fixed-size header.  There
      may or may not be a data\n   portion following the header, depending on the
      message type.  The\n   layout of these fields is shown below:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      +
      \                                                              +\n      |                                                               |\n
      \     +                                                               +\n      |
      \                          Marker                              |\n      +                                                               +\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |          Length               |      Type     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Marker:\n         This 16-octet field is included for compatibility; it
      MUST be\n         set to all ones.\n      Length:\n         This 2-octet unsigned
      integer indicates the total length of the\n         message, including the header
      in octets.  Thus, it allows one\n         to locate the (Marker field of the)
      next message in the TCP\n         stream.  The value of the Length field MUST
      always be at least\n         19 and no greater than 4096, and MAY be further
      constrained,\n         depending on the message type.  \"padding\" of extra
      data after\n         the message is not allowed.  Therefore, the Length field
      MUST\n         have the smallest value required, given the rest of the\n         message.\n
      \     Type:\n         This 1-octet unsigned integer indicates the type code
      of the\n         message.  This document defines the following type codes:\n
      \                             1 - OPEN\n                              2 - UPDATE\n
      \                             3 - NOTIFICATION\n                              4
      - KEEPALIVE\n         [RFC2918] defines one more type code.\n"
    title: 4.1.  Message Header Format
  - contents:
    - "4.2.  OPEN Message Format\n   After a TCP connection is established, the first
      message sent by each\n   side is an OPEN message.  If the OPEN message is acceptable,
      a\n   KEEPALIVE message confirming the OPEN is sent back.\n   In addition to
      the fixed-size BGP header, the OPEN message contains\n   the following fields:\n
      \      0                   1                   2                   3\n       0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+\n
      \      |    Version    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
      \    My Autonomous System      |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |           Hold Time           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                         BGP Identifier                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      | Opt Parm Len  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                                                               |\n       |
      \            Optional Parameters (variable)                    |\n       |                                                               |\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Version:\n
      \        This 1-octet unsigned integer indicates the protocol version\n         number
      of the message.  The current BGP version number is 4.\n      My Autonomous System:\n
      \        This 2-octet unsigned integer indicates the Autonomous System\n         number
      of the sender.\n      Hold Time:\n         This 2-octet unsigned integer indicates
      the number of seconds\n         the sender proposes for the value of the Hold
      Timer.  Upon\n         receipt of an OPEN message, a BGP speaker MUST calculate
      the\n         value of the Hold Timer by using the smaller of its configured\n
      \        Hold Time and the Hold Time received in the OPEN message.  The\n         Hold
      Time MUST be either zero or at least three seconds.  An\n         implementation
      MAY reject connections on the basis of the Hold\n         Time.  The calculated
      value indicates the maximum number of\n         seconds that may elapse between
      the receipt of successive\n         KEEPALIVE and/or UPDATE messages from the
      sender.\n      BGP Identifier:\n         This 4-octet unsigned integer indicates
      the BGP Identifier of\n         the sender.  A given BGP speaker sets the value
      of its BGP\n         Identifier to an IP address that is assigned to that BGP\n
      \        speaker.  The value of the BGP Identifier is determined upon\n         startup
      and is the same for every local interface and BGP peer.\n      Optional Parameters
      Length:\n         This 1-octet unsigned integer indicates the total length of
      the\n         Optional Parameters field in octets.  If the value of this\n         field
      is zero, no Optional Parameters are present.\n      Optional Parameters:\n         This
      field contains a list of optional parameters, in which\n         each parameter
      is encoded as a <Parameter Type, Parameter\n         Length, Parameter Value>
      triplet.\n         0                   1\n         0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n         |  Parm.
      Type   | Parm. Length  |  Parameter Value (variable)\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n
      \        Parameter Type is a one octet field that unambiguously\n         identifies
      individual parameters.  Parameter Length is a one\n         octet field that
      contains the length of the Parameter Value\n         field in octets.  Parameter
      Value is a variable length field\n         that is interpreted according to
      the value of the Parameter\n         Type field.\n         [RFC3392] defines
      the Capabilities Optional Parameter.\n   The minimum length of the OPEN message
      is 29 octets (including the\n   message header).\n"
    title: 4.2.  OPEN Message Format
  - contents:
    - "4.3.  UPDATE Message Format\n   UPDATE messages are used to transfer routing
      information between BGP\n   peers.  The information in the UPDATE message can
      be used to\n   construct a graph that describes the relationships of the various\n
      \  Autonomous Systems.  By applying rules to be discussed, routing\n   information
      loops and some other anomalies may be detected and\n   removed from inter-AS
      routing.\n   An UPDATE message is used to advertise feasible routes that share\n
      \  common path attributes to a peer, or to withdraw multiple unfeasible\n   routes
      from service (see 3.1).  An UPDATE message MAY simultaneously\n   advertise
      a feasible route and withdraw multiple unfeasible routes\n   from service.  The
      UPDATE message always includes the fixed-size BGP\n   header, and also includes
      the other fields, as shown below (note,\n   some of the shown fields may not
      be present in every UPDATE message):\n      +-----------------------------------------------------+\n
      \     |   Withdrawn Routes Length (2 octets)                |\n      +-----------------------------------------------------+\n
      \     |   Withdrawn Routes (variable)                       |\n      +-----------------------------------------------------+\n
      \     |   Total Path Attribute Length (2 octets)            |\n      +-----------------------------------------------------+\n
      \     |   Path Attributes (variable)                        |\n      +-----------------------------------------------------+\n
      \     |   Network Layer Reachability Information (variable) |\n      +-----------------------------------------------------+\n
      \     Withdrawn Routes Length:\n         This 2-octets unsigned integer indicates
      the total length of\n         the Withdrawn Routes field in octets.  Its value
      allows the\n         length of the Network Layer Reachability Information field
      to\n         be determined, as specified below.\n         A value of 0 indicates
      that no routes are being withdrawn from\n         service, and that the WITHDRAWN
      ROUTES field is not present in\n         this UPDATE message.\n      Withdrawn
      Routes:\n         This is a variable-length field that contains a list of IP\n
      \        address prefixes for the routes that are being withdrawn from\n         service.
      \ Each IP address prefix is encoded as a 2-tuple of the\n         form <length,
      prefix>, whose fields are described below:\n                  +---------------------------+\n
      \                 |   Length (1 octet)        |\n                  +---------------------------+\n
      \                 |   Prefix (variable)       |\n                  +---------------------------+\n
      \        The use and the meaning of these fields are as follows:\n         a)
      Length:\n            The Length field indicates the length in bits of the IP\n
      \           address prefix.  A length of zero indicates a prefix that\n            matches
      all IP addresses (with prefix, itself, of zero\n            octets).\n         b)
      Prefix:\n            The Prefix field contains an IP address prefix, followed
      by\n            the minimum number of trailing bits needed to make the end\n
      \           of the field fall on an octet boundary.  Note that the value\n            of
      trailing bits is irrelevant.\n      Total Path Attribute Length:\n         This
      2-octet unsigned integer indicates the total length of the\n         Path Attributes
      field in octets.  Its value allows the length\n         of the Network Layer
      Reachability field to be determined as\n         specified below.\n         A
      value of 0 indicates that neither the Network Layer\n         Reachability Information
      field nor the Path Attribute field is\n         present in this UPDATE message.\n
      \     Path Attributes:\n         A variable-length sequence of path attributes
      is present in\n         every UPDATE message, except for an UPDATE message that
      carries\n         only the withdrawn routes.  Each path attribute is a triple\n
      \        <attribute type, attribute length, attribute value> of variable\n         length.\n
      \        Attribute Type is a two-octet field that consists of the\n         Attribute
      Flags octet, followed by the Attribute Type Code\n         octet.\n               0
      \                  1\n               0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \              |  Attr. Flags  |Attr. Type Code|\n               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        The high-order bit (bit 0) of the Attribute Flags octet is the\n         Optional
      bit.  It defines whether the attribute is optional (if\n         set to 1) or
      well-known (if set to 0).\n         The second high-order bit (bit 1) of the
      Attribute Flags octet\n         is the Transitive bit.  It defines whether an
      optional\n         attribute is transitive (if set to 1) or non-transitive (if
      set\n         to 0).\n         For well-known attributes, the Transitive bit
      MUST be set to 1.\n         (See Section 5 for a discussion of transitive attributes.)\n
      \        The third high-order bit (bit 2) of the Attribute Flags octet\n         is
      the Partial bit.  It defines whether the information\n         contained in
      the optional transitive attribute is partial (if\n         set to 1) or complete
      (if set to 0).  For well-known attributes\n         and for optional non-transitive
      attributes, the Partial bit\n         MUST be set to 0.\n         The fourth
      high-order bit (bit 3) of the Attribute Flags octet\n         is the Extended
      Length bit.  It defines whether the Attribute\n         Length is one octet
      (if set to 0) or two octets (if set to 1).\n         The lower-order four bits
      of the Attribute Flags octet are\n         unused.  They MUST be zero when sent
      and MUST be ignored when\n         received.\n         The Attribute Type Code
      octet contains the Attribute Type Code.\n         Currently defined Attribute
      Type Codes are discussed in Section\n         5.\n         If the Extended Length
      bit of the Attribute Flags octet is set\n         to 0, the third octet of the
      Path Attribute contains the length\n         of the attribute data in octets.\n
      \        If the Extended Length bit of the Attribute Flags octet is set\n         to
      1, the third and fourth octets of the path attribute contain\n         the length
      of the attribute data in octets.\n         The remaining octets of the Path
      Attribute represent the\n         attribute value and are interpreted according
      to the Attribute\n         Flags and the Attribute Type Code.  The supported
      Attribute\n         Type Codes, and their attribute values and uses are as follows:\n
      \        a) ORIGIN (Type Code 1):\n            ORIGIN is a well-known mandatory
      attribute that defines the\n            origin of the path information.  The
      data octet can assume\n            the following values:\n               Value
      \     Meaning\n               0         IGP - Network Layer Reachability Information\n
      \                           is interior to the originating AS\n               1
      \        EGP - Network Layer Reachability Information\n                            learned
      via the EGP protocol [RFC904]\n               2         INCOMPLETE - Network
      Layer Reachability\n                            Information learned by some
      other means\n            Usage of this attribute is defined in 5.1.1.\n         b)
      AS_PATH (Type Code 2):\n            AS_PATH is a well-known mandatory attribute
      that is composed\n            of a sequence of AS path segments.  Each AS path
      segment is\n            represented by a triple <path segment type, path segment\n
      \           length, path segment value>.\n            The path segment type
      is a 1-octet length field with the\n            following values defined:\n
      \              Value      Segment Type\n               1         AS_SET: unordered
      set of ASes a route in the\n                            UPDATE message has traversed\n
      \              2         AS_SEQUENCE: ordered set of ASes a route in\n                            the
      UPDATE message has traversed\n            The path segment length is a 1-octet
      length field,\n            containing the number of ASes (not the number of
      octets) in\n            the path segment value field.\n            The path
      segment value field contains one or more AS\n            numbers, each encoded
      as a 2-octet length field.\n            Usage of this attribute is defined in
      5.1.2.\n         c) NEXT_HOP (Type Code 3):\n            This is a well-known
      mandatory attribute that defines the\n            (unicast) IP address of the
      router that SHOULD be used as\n            the next hop to the destinations
      listed in the Network Layer\n            Reachability Information field of the
      UPDATE message.\n            Usage of this attribute is defined in 5.1.3.\n
      \        d) MULTI_EXIT_DISC (Type Code 4):\n            This is an optional
      non-transitive attribute that is a\n            four-octet unsigned integer.
      \ The value of this attribute\n            MAY be used by a BGP speaker's Decision
      Process to\n            discriminate among multiple entry points to a neighboring\n
      \           autonomous system.\n            Usage of this attribute is defined
      in 5.1.4.\n         e) LOCAL_PREF (Type Code 5):\n            LOCAL_PREF is
      a well-known attribute that is a four-octet\n            unsigned integer.  A
      BGP speaker uses it to inform its other\n            internal peers of the advertising
      speaker's degree of\n            preference for an advertised route.\n            Usage
      of this attribute is defined in 5.1.5.\n         f) ATOMIC_AGGREGATE (Type Code
      6)\n            ATOMIC_AGGREGATE is a well-known discretionary attribute of\n
      \           length 0.\n            Usage of this attribute is defined in 5.1.6.\n
      \        g) AGGREGATOR (Type Code 7)\n            AGGREGATOR is an optional
      transitive attribute of length 6.\n            The attribute contains the last
      AS number that formed the\n            aggregate route (encoded as 2 octets),
      followed by the IP\n            address of the BGP speaker that formed the aggregate
      route\n            (encoded as 4 octets).  This SHOULD be the same address as\n
      \           the one used for the BGP Identifier of the speaker.\n            Usage
      of this attribute is defined in 5.1.7.\n      Network Layer Reachability Information:\n
      \        This variable length field contains a list of IP address\n         prefixes.
      \ The length, in octets, of the Network Layer\n         Reachability Information
      is not encoded explicitly, but can be\n         calculated as:\n               UPDATE
      message Length - 23 - Total Path Attributes Length\n               - Withdrawn
      Routes Length\n         where UPDATE message Length is the value encoded in
      the fixed-\n         size BGP header, Total Path Attribute Length, and Withdrawn\n
      \        Routes Length are the values encoded in the variable part of\n         the
      UPDATE message, and 23 is a combined length of the fixed-\n         size BGP
      header, the Total Path Attribute Length field, and the\n         Withdrawn Routes
      Length field.\n         Reachability information is encoded as one or more 2-tuples
      of\n         the form <length, prefix>, whose fields are described below:\n
      \                 +---------------------------+\n                  |   Length
      (1 octet)        |\n                  +---------------------------+\n                  |
      \  Prefix (variable)       |\n                  +---------------------------+\n
      \        The use and the meaning of these fields are as follows:\n         a)
      Length:\n            The Length field indicates the length in bits of the IP\n
      \           address prefix.  A length of zero indicates a prefix that\n            matches
      all IP addresses (with prefix, itself, of zero\n            octets).\n         b)
      Prefix:\n            The Prefix field contains an IP address prefix, followed
      by\n            enough trailing bits to make the end of the field fall on an\n
      \           octet boundary.  Note that the value of the trailing bits is\n            irrelevant.\n
      \  The minimum length of the UPDATE message is 23 octets -- 19 octets\n   for
      the fixed header + 2 octets for the Withdrawn Routes Length + 2\n   octets for
      the Total Path Attribute Length (the value of Withdrawn\n   Routes Length is
      0 and the value of Total Path Attribute Length is\n   0).\n   An UPDATE message
      can advertise, at most, one set of path attributes,\n   but multiple destinations,
      provided that the destinations share these\n   attributes.  All path attributes
      contained in a given UPDATE message\n   apply to all destinations carried in
      the NLRI field of the UPDATE\n   message.\n   An UPDATE message can list multiple
      routes that are to be withdrawn\n   from service.  Each such route is identified
      by its destination\n   (expressed as an IP prefix), which unambiguously identifies
      the route\n   in the context of the BGP speaker - BGP speaker connection to
      which\n   it has been previously advertised.\n   An UPDATE message might advertise
      only routes that are to be\n   withdrawn from service, in which case the message
      will not include\n   path attributes or Network Layer Reachability Information.\n
      \  Conversely, it may advertise only a feasible route, in which case the\n   WITHDRAWN
      ROUTES field need not be present.\n   An UPDATE message SHOULD NOT include the
      same address prefix in the\n   WITHDRAWN ROUTES and Network Layer Reachability
      Information fields.\n   However, a BGP speaker MUST be able to process UPDATE
      messages in\n   this form.  A BGP speaker SHOULD treat an UPDATE message of
      this form\n   as though the WITHDRAWN ROUTES do not contain the address prefix.\n"
    title: 4.3.  UPDATE Message Format
  - contents:
    - "4.4.  KEEPALIVE Message Format\n   BGP does not use any TCP-based, keep-alive
      mechanism to determine if\n   peers are reachable.  Instead, KEEPALIVE messages
      are exchanged\n   between peers often enough not to cause the Hold Timer to
      expire.  A\n   reasonable maximum time between KEEPALIVE messages would be one
      third\n   of the Hold Time interval.  KEEPALIVE messages MUST NOT be sent more\n
      \  frequently than one per second.  An implementation MAY adjust the\n   rate
      at which it sends KEEPALIVE messages as a function of the Hold\n   Time interval.\n
      \  If the negotiated Hold Time interval is zero, then periodic KEEPALIVE\n   messages
      MUST NOT be sent.\n   A KEEPALIVE message consists of only the message header
      and has a\n   length of 19 octets.\n"
    title: 4.4.  KEEPALIVE Message Format
  - contents:
    - "4.5.  NOTIFICATION Message Format\n   A NOTIFICATION message is sent when an
      error condition is detected.\n   The BGP connection is closed immediately after
      it is sent.\n   In addition to the fixed-size BGP header, the NOTIFICATION message\n
      \  contains the following fields:\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     | Error code    | Error subcode |   Data (variable)             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Error Code:\n         This 1-octet unsigned integer indicates the type
      of\n         NOTIFICATION.  The following Error Codes have been defined:\n            Error
      Code       Symbolic Name               Reference\n              1         Message
      Header Error             Section 6.1\n              2         OPEN Message Error
      \              Section 6.2\n              3         UPDATE Message Error             Section
      6.3\n              4         Hold Timer Expired               Section 6.5\n
      \             5         Finite State Machine Error       Section 6.6\n              6
      \        Cease                            Section 6.7\n      Error subcode:\n
      \        This 1-octet unsigned integer provides more specific\n         information
      about the nature of the reported error.  Each Error\n         Code may have
      one or more Error Subcodes associated with it.\n         If no appropriate Error
      Subcode is defined, then a zero\n         (Unspecific) value is used for the
      Error Subcode field.\n      Message Header Error subcodes:\n               1
      - Connection Not Synchronized.\n               2 - Bad Message Length.\n               3
      - Bad Message Type.\n      OPEN Message Error subcodes:\n               1 -
      Unsupported Version Number.\n               2 - Bad Peer AS.\n               3
      - Bad BGP Identifier.\n               4 - Unsupported Optional Parameter.\n
      \              5 - [Deprecated - see Appendix A].\n               6 - Unacceptable
      Hold Time.\n      UPDATE Message Error subcodes:\n               1 - Malformed
      Attribute List.\n               2 - Unrecognized Well-known Attribute.\n               3
      - Missing Well-known Attribute.\n               4 - Attribute Flags Error.\n
      \              5 - Attribute Length Error.\n               6 - Invalid ORIGIN
      Attribute.\n               7 - [Deprecated - see Appendix A].\n               8
      - Invalid NEXT_HOP Attribute.\n               9 - Optional Attribute Error.\n
      \             10 - Invalid Network Field.\n              11 - Malformed AS_PATH.\n
      \     Data:\n         This variable-length field is used to diagnose the reason
      for\n         the NOTIFICATION.  The contents of the Data field depend upon\n
      \        the Error Code and Error Subcode.  See Section 6 for more\n         details.\n
      \        Note that the length of the Data field can be determined from\n         the
      message Length field by the formula:\n                  Message Length = 21
      + Data Length\n   The minimum length of the NOTIFICATION message is 21 octets\n
      \  (including message header).\n"
    title: 4.5.  NOTIFICATION Message Format
  title: 4.  Message Formats
- contents:
  - "5.  Path Attributes\n   This section discusses the path attributes of the UPDATE
    message.\n   Path attributes fall into four separate categories:\n         1.
    Well-known mandatory.\n         2. Well-known discretionary.\n         3. Optional
    transitive.\n         4. Optional non-transitive.\n   BGP implementations MUST
    recognize all well-known attributes.  Some\n   of these attributes are mandatory
    and MUST be included in every\n   UPDATE message that contains NLRI.  Others are
    discretionary and MAY\n   or MAY NOT be sent in a particular UPDATE message.\n
    \  Once a BGP peer has updated any well-known attributes, it MUST pass\n   these
    attributes to its peers in any updates it transmits.\n   In addition to well-known
    attributes, each path MAY contain one or\n   more optional attributes.  It is
    not required or expected that all\n   BGP implementations support all optional
    attributes.  The handling of\n   an unrecognized optional attribute is determined
    by the setting of\n   the Transitive bit in the attribute flags octet.  Paths
    with\n   unrecognized transitive optional attributes SHOULD be accepted.  If a\n
    \  path with an unrecognized transitive optional attribute is accepted\n   and
    passed to other BGP peers, then the unrecognized transitive\n   optional attribute
    of that path MUST be passed, along with the path,\n   to other BGP peers with
    the Partial bit in the Attribute Flags octet\n   set to 1.  If a path with a recognized,
    transitive optional attribute\n   is accepted and passed along to other BGP peers
    and the Partial bit\n   in the Attribute Flags octet is set to 1 by some previous
    AS, it MUST\n   NOT be set back to 0 by the current AS.  Unrecognized non-transitive\n
    \  optional attributes MUST be quietly ignored and not passed along to\n   other
    BGP peers.\n   New, transitive optional attributes MAY be attached to the path
    by\n   the originator or by any other BGP speaker in the path.  If they are\n
    \  not attached by the originator, the Partial bit in the Attribute\n   Flags
    octet is set to 1.  The rules for attaching new non-transitive\n   optional attributes
    will depend on the nature of the specific\n   attribute.  The documentation of
    each new non-transitive optional\n   attribute will be expected to include such
    rules (the description of\n   the MULTI_EXIT_DISC attribute gives an example).
    \ All optional\n   attributes (both transitive and non-transitive), MAY be updated
    (if\n   appropriate) by BGP speakers in the path.\n   The sender of an UPDATE
    message SHOULD order path attributes within\n   the UPDATE message in ascending
    order of attribute type.  The\n   receiver of an UPDATE message MUST be prepared
    to handle path\n   attributes within UPDATE messages that are out of order.\n
    \  The same attribute (attribute with the same type) cannot appear more\n   than
    once within the Path Attributes field of a particular UPDATE\n   message.\n   The
    mandatory category refers to an attribute that MUST be present in\n   both IBGP
    and EBGP exchanges if NLRI are contained in the UPDATE\n   message.  Attributes
    classified as optional for the purpose of the\n   protocol extension mechanism
    may be purely discretionary,\n   discretionary, required, or disallowed in certain
    contexts.\n        attribute           EBGP                    IBGP\n         ORIGIN
    \            mandatory               mandatory\n         AS_PATH            mandatory
    \              mandatory\n         NEXT_HOP           mandatory               mandatory\n
    \        MULTI_EXIT_DISC    discretionary           discretionary\n         LOCAL_PREF
    \        see Section 5.1.5       required\n         ATOMIC_AGGREGATE   see Section
    5.1.6 and 9.1.4\n         AGGREGATOR         discretionary           discretionary\n"
  - contents:
    - "5.1.  Path Attribute Usage\n   The usage of each BGP path attribute is described
      in the following\n   clauses.\n"
    - contents:
      - "5.1.1.  ORIGIN\n   ORIGIN is a well-known mandatory attribute.  The ORIGIN
        attribute is\n   generated by the speaker that originates the associated routing\n
        \  information.  Its value SHOULD NOT be changed by any other speaker.\n"
      title: 5.1.1.  ORIGIN
    - contents:
      - "5.1.2.  AS_PATH\n   AS_PATH is a well-known mandatory attribute.  This attribute\n
        \  identifies the autonomous systems through which routing information\n   carried
        in this UPDATE message has passed.  The components of this\n   list can be
        AS_SETs or AS_SEQUENCEs.\n   When a BGP speaker propagates a route it learned
        from another BGP\n   speaker's UPDATE message, it modifies the route's AS_PATH
        attribute\n   based on the location of the BGP speaker to which the route
        will be\n   sent:\n      a) When a given BGP speaker advertises the route
        to an internal\n         peer, the advertising speaker SHALL NOT modify the
        AS_PATH\n         attribute associated with the route.\n      b) When a given
        BGP speaker advertises the route to an external\n         peer, the advertising
        speaker updates the AS_PATH attribute as\n         follows:\n         1) if
        the first path segment of the AS_PATH is of type\n            AS_SEQUENCE,
        the local system prepends its own AS number as\n            the last element
        of the sequence (put it in the leftmost\n            position with respect
        to the position of octets in the\n            protocol message).  If the act
        of prepending will cause an\n            overflow in the AS_PATH segment (i.e.,
        more than 255 ASes),\n            it SHOULD prepend a new segment of type
        AS_SEQUENCE and\n            prepend its own AS number to this new segment.\n
        \        2) if the first path segment of the AS_PATH is of type AS_SET,\n
        \           the local system prepends a new path segment of type\n            AS_SEQUENCE
        to the AS_PATH, including its own AS number in\n            that segment.\n
        \        3) if the AS_PATH is empty, the local system creates a path\n            segment
        of type AS_SEQUENCE, places its own AS into that\n            segment, and
        places that segment into the AS_PATH.\n   When a BGP speaker originates a
        route then:\n      a) the originating speaker includes its own AS number in
        a path\n         segment, of type AS_SEQUENCE, in the AS_PATH attribute of
        all\n         UPDATE messages sent to an external peer.  In this case, the
        AS\n         number of the originating speaker's autonomous system will be\n
        \        the only entry the path segment, and this path segment will be\n
        \        the only segment in the AS_PATH attribute.\n      b) the originating
        speaker includes an empty AS_PATH attribute in\n         all UPDATE messages
        sent to internal peers.  (An empty AS_PATH\n         attribute is one whose
        length field contains the value zero).\n   Whenever the modification of the
        AS_PATH attribute calls for\n   including or prepending the AS number of the
        local system, the local\n   system MAY include/prepend more than one instance
        of its own AS\n   number in the AS_PATH attribute.  This is controlled via
        local\n   configuration.\n"
      title: 5.1.2.  AS_PATH
    - contents:
      - "5.1.3.  NEXT_HOP\n   The NEXT_HOP is a well-known mandatory attribute that
        defines the IP\n   address of the router that SHOULD be used as the next hop
        to the\n   destinations listed in the UPDATE message.  The NEXT_HOP attribute
        is\n   calculated as follows:\n      1) When sending a message to an internal
        peer, if the route is not\n         locally originated, the BGP speaker SHOULD
        NOT modify the\n         NEXT_HOP attribute unless it has been explicitly
        configured to\n         announce its own IP address as the NEXT_HOP.  When
        announcing a\n         locally-originated route to an internal peer, the BGP
        speaker\n         SHOULD use the interface address of the router through which\n
        \        the announced network is reachable for the speaker as the\n         NEXT_HOP.
        \ If the route is directly connected to the speaker,\n         or if the interface
        address of the router through which the\n         announced network is reachable
        for the speaker is the internal\n         peer's address, then the BGP speaker
        SHOULD use its own IP\n         address for the NEXT_HOP attribute (the address
        of the\n         interface that is used to reach the peer).\n      2) When
        sending a message to an external peer, X, and the peer is\n         one IP
        hop away from the speaker:\n         - If the route being announced was learned
        from an internal\n           peer or is locally originated, the BGP speaker
        can use an\n           interface address of the internal peer router (or the\n
        \          internal router) through which the announced network is\n           reachable
        for the speaker for the NEXT_HOP attribute,\n           provided that peer
        X shares a common subnet with this\n           address.  This is a form of
        \"third party\" NEXT_HOP attribute.\n         - Otherwise, if the route being
        announced was learned from an\n           external peer, the speaker can use
        an IP address of any\n           adjacent router (known from the received
        NEXT_HOP attribute)\n           that the speaker itself uses for local route
        calculation in\n           the NEXT_HOP attribute, provided that peer X shares
        a common\n           subnet with this address.  This is a second form of \"third\n
        \          party\" NEXT_HOP attribute.\n         - Otherwise, if the external
        peer to which the route is being\n           advertised shares a common subnet
        with one of the interfaces\n           of the announcing BGP speaker, the
        speaker MAY use the IP\n           address associated with such an interface
        in the NEXT_HOP\n           attribute.  This is known as a \"first party\"
        NEXT_HOP\n           attribute.\n         - By default (if none of the above
        conditions apply), the BGP\n           speaker SHOULD use the IP address of
        the interface that the\n           speaker uses to establish the BGP connection
        to peer X in the\n           NEXT_HOP attribute.\n      3) When sending a
        message to an external peer X, and the peer is\n         multiple IP hops
        away from the speaker (aka \"multihop EBGP\"):\n         - The speaker MAY
        be configured to propagate the NEXT_HOP\n           attribute.  In this case,
        when advertising a route that the\n           speaker learned from one of
        its peers, the NEXT_HOP attribute\n           of the advertised route is exactly
        the same as the NEXT_HOP\n           attribute of the learned route (the speaker
        does not modify\n           the NEXT_HOP attribute).\n         - By default,
        the BGP speaker SHOULD use the IP address of the\n           interface that
        the speaker uses in the NEXT_HOP attribute to\n           establish the BGP
        connection to peer X.\n   Normally, the NEXT_HOP attribute is chosen such
        that the shortest\n   available path will be taken.  A BGP speaker MUST be
        able to support\n   the disabling advertisement of third party NEXT_HOP attributes
        in\n   order to handle imperfectly bridged media.\n   A route originated by
        a BGP speaker SHALL NOT be advertised to a peer\n   using an address of that
        peer as NEXT_HOP.  A BGP speaker SHALL NOT\n   install a route with itself
        as the next hop.\n   The NEXT_HOP attribute is used by the BGP speaker to
        determine the\n   actual outbound interface and immediate next-hop address
        that SHOULD\n   be used to forward transit packets to the associated destinations.\n
        \  The immediate next-hop address is determined by performing a\n   recursive
        route lookup operation for the IP address in the NEXT_HOP\n   attribute, using
        the contents of the Routing Table, selecting one\n   entry if multiple entries
        of equal cost exist.  The Routing Table\n   entry that resolves the IP address
        in the NEXT_HOP attribute will\n   always specify the outbound interface.
        \ If the entry specifies an\n   attached subnet, but does not specify a next-hop
        address, then the\n   address in the NEXT_HOP attribute SHOULD be used as
        the immediate\n   next-hop address.  If the entry also specifies the next-hop
        address,\n   this address SHOULD be used as the immediate next-hop address
        for\n   packet forwarding.\n"
      title: 5.1.3.  NEXT_HOP
    - contents:
      - "5.1.4.  MULTI_EXIT_DISC\n   The MULTI_EXIT_DISC is an optional non-transitive
        attribute that is\n   intended to be used on external (inter-AS) links to
        discriminate\n   among multiple exit or entry points to the same neighboring
        AS.  The\n   value of the MULTI_EXIT_DISC attribute is a four-octet unsigned\n
        \  number, called a metric.  All other factors being equal, the exit\n   point
        with the lower metric SHOULD be preferred.  If received over\n   EBGP, the
        MULTI_EXIT_DISC attribute MAY be propagated over IBGP to\n   other BGP speakers
        within the same AS (see also 9.1.2.2).  The\n   MULTI_EXIT_DISC attribute
        received from a neighboring AS MUST NOT be\n   propagated to other neighboring
        ASes.\n   A BGP speaker MUST implement a mechanism (based on local\n   configuration)
        that allows the MULTI_EXIT_DISC attribute to be\n   removed from a route.
        \ If a BGP speaker is configured to remove the\n   MULTI_EXIT_DISC attribute
        from a route, then this removal MUST be\n   done prior to determining the
        degree of preference of the route and\n   prior to performing route selection
        (Decision Process phases 1 and\n   2).\n   An implementation MAY also (based
        on local configuration) alter the\n   value of the MULTI_EXIT_DISC attribute
        received over EBGP.  If a BGP\n   speaker is configured to alter the value
        of the MULTI_EXIT_DISC\n   attribute received over EBGP, then altering the
        value MUST be done\n   prior to determining the degree of preference of the
        route and prior\n   to performing route selection (Decision Process phases
        1 and 2).  See\n   Section 9.1.2.2 for necessary restrictions on this.\n"
      title: 5.1.4.  MULTI_EXIT_DISC
    - contents:
      - "5.1.5.  LOCAL_PREF\n   LOCAL_PREF is a well-known attribute that SHALL be
        included in all\n   UPDATE messages that a given BGP speaker sends to other
        internal\n   peers.  A BGP speaker SHALL calculate the degree of preference
        for\n   each external route based on the locally-configured policy, and\n
        \  include the degree of preference when advertising a route to its\n   internal
        peers.  The higher degree of preference MUST be preferred.\n   A BGP speaker
        uses the degree of preference learned via LOCAL_PREF in\n   its Decision Process
        (see Section 9.1.1).\n   A BGP speaker MUST NOT include this attribute in
        UPDATE messages it\n   sends to external peers, except in the case of BGP
        Confederations\n   [RFC3065].  If it is contained in an UPDATE message that
        is received\n   from an external peer, then this attribute MUST be ignored
        by the\n   receiving speaker, except in the case of BGP Confederations\n   [RFC3065].\n"
      title: 5.1.5.  LOCAL_PREF
    - contents:
      - "5.1.6.  ATOMIC_AGGREGATE\n   ATOMIC_AGGREGATE is a well-known discretionary
        attribute.\n   When a BGP speaker aggregates several routes for the purpose
        of\n   advertisement to a particular peer, the AS_PATH of the aggregated\n
        \  route normally includes an AS_SET formed from the set of ASes from\n   which
        the aggregate was formed.  In many cases, the network\n   administrator can
        determine if the aggregate can safely be advertised\n   without the AS_SET,
        and without forming route loops.\n   If an aggregate excludes at least some
        of the AS numbers present in\n   the AS_PATH of the routes that are aggregated
        as a result of dropping\n   the AS_SET, the aggregated route, when advertised
        to the peer, SHOULD\n   include the ATOMIC_AGGREGATE attribute.\n   A BGP
        speaker that receives a route with the ATOMIC_AGGREGATE\n   attribute SHOULD
        NOT remove the attribute when propagating the route\n   to other speakers.\n
        \  A BGP speaker that receives a route with the ATOMIC_AGGREGATE\n   attribute
        MUST NOT make any NLRI of that route more specific (as\n   defined in 9.1.4)
        when advertising this route to other BGP speakers.\n   A BGP speaker that
        receives a route with the ATOMIC_AGGREGATE\n   attribute needs to be aware
        of the fact that the actual path to\n   destinations, as specified in the
        NLRI of the route, while having the\n   loop-free property, may not be the
        path specified in the AS_PATH\n   attribute of the route.\n"
      title: 5.1.6.  ATOMIC_AGGREGATE
    - contents:
      - "5.1.7.  AGGREGATOR\n   AGGREGATOR is an optional transitive attribute, which
        MAY be included\n   in updates that are formed by aggregation (see Section
        9.2.2.2).  A\n   BGP speaker that performs route aggregation MAY add the AGGREGATOR\n
        \  attribute, which SHALL contain its own AS number and IP address.  The\n
        \  IP address SHOULD be the same as the BGP Identifier of the speaker.\n"
      title: 5.1.7.  AGGREGATOR
    title: 5.1.  Path Attribute Usage
  title: 5.  Path Attributes
- contents:
  - "6.  BGP Error Handling.\n   This section describes actions to be taken when errors
    are detected\n   while processing BGP messages.\n   When any of the conditions
    described here are detected, a\n   NOTIFICATION message, with the indicated Error
    Code, Error Subcode,\n   and Data fields, is sent, and the BGP connection is closed
    (unless it\n   is explicitly stated that no NOTIFICATION message is to be sent
    and\n   the BGP connection is not to be closed).  If no Error Subcode is\n   specified,
    then a zero MUST be used.\n   The phrase \"the BGP connection is closed\" means
    the TCP connection\n   has been closed, the associated Adj-RIB-In has been cleared,
    and all\n   resources for that BGP connection have been deallocated.  Entries
    in\n   the Loc-RIB associated with the remote peer are marked as invalid.\n   The
    local system recalculates its best routes for the destinations of\n   the routes
    marked as invalid.  Before the invalid routes are deleted\n   from the system,
    it advertises, to its peers, either withdraws for\n   the routes marked as invalid,
    or the new best routes before the\n   invalid routes are deleted from the system.\n
    \  Unless specified explicitly, the Data field of the NOTIFICATION\n   message
    that is sent to indicate an error is empty.\n"
  - contents:
    - "6.1.  Message Header Error Handling\n   All errors detected while processing
      the Message Header MUST be\n   indicated by sending the NOTIFICATION message
      with the Error Code\n   Message Header Error.  The Error Subcode elaborates
      on the specific\n   nature of the error.\n   The expected value of the Marker
      field of the message header is all\n   ones.  If the Marker field of the message
      header is not as expected,\n   then a synchronization error has occurred and
      the Error Subcode MUST\n   be set to Connection Not Synchronized.\n   If at
      least one of the following is true:\n      - if the Length field of the message
      header is less than 19 or\n        greater than 4096, or\n      - if the Length
      field of an OPEN message is less than the minimum\n        length of the OPEN
      message, or\n      - if the Length field of an UPDATE message is less than the\n
      \       minimum length of the UPDATE message, or\n      - if the Length field
      of a KEEPALIVE message is not equal to 19,\n        or\n      - if the Length
      field of a NOTIFICATION message is less than the\n        minimum length of
      the NOTIFICATION message,\n   then the Error Subcode MUST be set to Bad Message
      Length.  The Data\n   field MUST contain the erroneous Length field.\n   If
      the Type field of the message header is not recognized, then the\n   Error Subcode
      MUST be set to Bad Message Type.  The Data field MUST\n   contain the erroneous
      Type field.\n"
    title: 6.1.  Message Header Error Handling
  - contents:
    - "6.2.  OPEN Message Error Handling\n   All errors detected while processing
      the OPEN message MUST be\n   indicated by sending the NOTIFICATION message with
      the Error Code\n   OPEN Message Error.  The Error Subcode elaborates on the
      specific\n   nature of the error.\n   If the version number in the Version field
      of the received OPEN\n   message is not supported, then the Error Subcode MUST
      be set to\n   Unsupported Version Number.  The Data field is a 2-octet unsigned\n
      \  integer, which indicates the largest, locally-supported version\n   number
      less than the version the remote BGP peer bid (as indicated in\n   the received
      OPEN message), or if the smallest, locally-supported\n   version number is greater
      than the version the remote BGP peer bid,\n   then the smallest, locally-supported
      version number.\n   If the Autonomous System field of the OPEN message is unacceptable,\n
      \  then the Error Subcode MUST be set to Bad Peer AS.  The determination\n   of
      acceptable Autonomous System numbers is outside the scope of this\n   protocol.\n
      \  If the Hold Time field of the OPEN message is unacceptable, then the\n   Error
      Subcode MUST be set to Unacceptable Hold Time.  An\n   implementation MUST reject
      Hold Time values of one or two seconds.\n   An implementation MAY reject any
      proposed Hold Time.  An\n   implementation that accepts a Hold Time MUST use
      the negotiated value\n   for the Hold Time.\n   If the BGP Identifier field
      of the OPEN message is syntactically\n   incorrect, then the Error Subcode MUST
      be set to Bad BGP Identifier.\n   Syntactic correctness means that the BGP Identifier
      field represents\n   a valid unicast IP host address.\n   If one of the Optional
      Parameters in the OPEN message is not\n   recognized, then the Error Subcode
      MUST be set to Unsupported\n   Optional Parameters.\n   If one of the Optional
      Parameters in the OPEN message is recognized,\n   but is malformed, then the
      Error Subcode MUST be set to 0\n   (Unspecific).\n"
    title: 6.2.  OPEN Message Error Handling
  - contents:
    - "6.3.  UPDATE Message Error Handling\n   All errors detected while processing
      the UPDATE message MUST be\n   indicated by sending the NOTIFICATION message
      with the Error Code\n   UPDATE Message Error.  The error subcode elaborates
      on the specific\n   nature of the error.\n   Error checking of an UPDATE message
      begins by examining the path\n   attributes.  If the Withdrawn Routes Length
      or Total Attribute Length\n   is too large (i.e., if Withdrawn Routes Length
      + Total Attribute\n   Length + 23 exceeds the message Length), then the Error
      Subcode MUST\n   be set to Malformed Attribute List.\n   If any recognized attribute
      has Attribute Flags that conflict with\n   the Attribute Type Code, then the
      Error Subcode MUST be set to\n   Attribute Flags Error.  The Data field MUST
      contain the erroneous\n   attribute (type, length, and value).\n   If any recognized
      attribute has an Attribute Length that conflicts\n   with the expected length
      (based on the attribute type code), then the\n   Error Subcode MUST be set to
      Attribute Length Error.  The Data field\n   MUST contain the erroneous attribute
      (type, length, and value).\n   If any of the well-known mandatory attributes
      are not present, then\n   the Error Subcode MUST be set to Missing Well-known
      Attribute.  The\n   Data field MUST contain the Attribute Type Code of the missing,\n
      \  well-known attribute.\n   If any of the well-known mandatory attributes are
      not recognized,\n   then the Error Subcode MUST be set to Unrecognized Well-known\n
      \  Attribute.  The Data field MUST contain the unrecognized attribute\n   (type,
      length, and value).\n   If the ORIGIN attribute has an undefined value, then
      the Error Sub-\n   code MUST be set to Invalid Origin Attribute.  The Data field
      MUST\n   contain the unrecognized attribute (type, length, and value).\n   If
      the NEXT_HOP attribute field is syntactically incorrect, then the\n   Error
      Subcode MUST be set to Invalid NEXT_HOP Attribute.  The Data\n   field MUST
      contain the incorrect attribute (type, length, and value).\n   Syntactic correctness
      means that the NEXT_HOP attribute represents a\n   valid IP host address.\n
      \  The IP address in the NEXT_HOP MUST meet the following criteria to be\n   considered
      semantically correct:\n      a) It MUST NOT be the IP address of the receiving
      speaker.\n      b) In the case of an EBGP, where the sender and receiver are
      one\n         IP hop away from each other, either the IP address in the\n         NEXT_HOP
      MUST be the sender's IP address that is used to\n         establish the BGP
      connection, or the interface associated with\n         the NEXT_HOP IP address
      MUST share a common subnet with the\n         receiving BGP speaker.\n   If
      the NEXT_HOP attribute is semantically incorrect, the error SHOULD\n   be logged,
      and the route SHOULD be ignored.  In this case, a\n   NOTIFICATION message SHOULD
      NOT be sent, and the connection SHOULD\n   NOT be closed.\n   The AS_PATH attribute
      is checked for syntactic correctness.  If the\n   path is syntactically incorrect,
      then the Error Subcode MUST be set\n   to Malformed AS_PATH.\n   If the UPDATE
      message is received from an external peer, the local\n   system MAY check whether
      the leftmost (with respect to the position\n   of octets in the protocol message)
      AS in the AS_PATH attribute is\n   equal to the autonomous system number of
      the peer that sent the\n   message.  If the check determines this is not the
      case, the Error\n   Subcode MUST be set to Malformed AS_PATH.\n   If an optional
      attribute is recognized, then the value of this\n   attribute MUST be checked.
      \ If an error is detected, the attribute\n   MUST be discarded, and the Error
      Subcode MUST be set to Optional\n   Attribute Error.  The Data field MUST contain
      the attribute (type,\n   length, and value).\n   If any attribute appears more
      than once in the UPDATE message, then\n   the Error Subcode MUST be set to Malformed
      Attribute List.\n   The NLRI field in the UPDATE message is checked for syntactic\n
      \  validity.  If the field is syntactically incorrect, then the Error\n   Subcode
      MUST be set to Invalid Network Field.\n   If a prefix in the NLRI field is semantically
      incorrect (e.g., an\n   unexpected multicast IP address), an error SHOULD be
      logged locally,\n   and the prefix SHOULD be ignored.\n   An UPDATE message
      that contains correct path attributes, but no NLRI,\n   SHALL be treated as
      a valid UPDATE message.\n"
    title: 6.3.  UPDATE Message Error Handling
  - contents:
    - "6.4.  NOTIFICATION Message Error Handling\n   If a peer sends a NOTIFICATION
      message, and the receiver of the\n   message detects an error in that message,
      the receiver cannot use a\n   NOTIFICATION message to report this error back
      to the peer.  Any such\n   error (e.g., an unrecognized Error Code or Error
      Subcode) SHOULD be\n   noticed, logged locally, and brought to the attention
      of the\n   administration of the peer.  The means to do this, however, lies\n
      \  outside the scope of this document.\n"
    title: 6.4.  NOTIFICATION Message Error Handling
  - contents:
    - "6.5.  Hold Timer Expired Error Handling\n   If a system does not receive successive
      KEEPALIVE, UPDATE, and/or\n   NOTIFICATION messages within the period specified
      in the Hold Time\n   field of the OPEN message, then the NOTIFICATION message
      with the\n   Hold Timer Expired Error Code is sent and the BGP connection is\n
      \  closed.\n"
    title: 6.5.  Hold Timer Expired Error Handling
  - contents:
    - "6.6.  Finite State Machine Error Handling\n   Any error detected by the BGP
      Finite State Machine (e.g., receipt of\n   an unexpected event) is indicated
      by sending the NOTIFICATION message\n   with the Error Code Finite State Machine
      Error.\n"
    title: 6.6.  Finite State Machine Error Handling
  - contents:
    - "6.7.  Cease\n   In the absence of any fatal errors (that are indicated in this\n
      \  section), a BGP peer MAY choose, at any given time, to close its BGP\n   connection
      by sending the NOTIFICATION message with the Error Code\n   Cease.  However,
      the Cease NOTIFICATION message MUST NOT be used when\n   a fatal error indicated
      by this section does exist.\n   A BGP speaker MAY support the ability to impose
      a locally-configured,\n   upper bound on the number of address prefixes the
      speaker is willing\n   to accept from a neighbor.  When the upper bound is reached,
      the\n   speaker, under control of local configuration, either (a) discards\n
      \  new address prefixes from the neighbor (while maintaining the BGP\n   connection
      with the neighbor), or (b) terminates the BGP connection\n   with the neighbor.
      \ If the BGP speaker decides to terminate its BGP\n   connection with a neighbor
      because the number of address prefixes\n   received from the neighbor exceeds
      the locally-configured, upper\n   bound, then the speaker MUST send the neighbor
      a NOTIFICATION message\n   with the Error Code Cease.  The speaker MAY also
      log this locally.\n"
    title: 6.7.  Cease
  - contents:
    - "6.8.  BGP Connection Collision Detection\n   If a pair of BGP speakers try
      to establish a BGP connection with each\n   other simultaneously, then two parallel
      connections well be formed.\n   If the source IP address used by one of these
      connections is the same\n   as the destination IP address used by the other,
      and the destination\n   IP address used by the first connection is the same
      as the source IP\n   address used by the other, connection collision has occurred.
      \ In the\n   event of connection collision, one of the connections MUST be closed.\n
      \  Based on the value of the BGP Identifier, a convention is established\n   for
      detecting which BGP connection is to be preserved when a\n   collision occurs.
      \ The convention is to compare the BGP Identifiers\n   of the peers involved
      in the collision and to retain only the\n   connection initiated by the BGP
      speaker with the higher-valued BGP\n   Identifier.\n   Upon receipt of an OPEN
      message, the local system MUST examine all of\n   its connections that are in
      the OpenConfirm state.  A BGP speaker MAY\n   also examine connections in an
      OpenSent state if it knows the BGP\n   Identifier of the peer by means outside
      of the protocol.  If, among\n   these connections, there is a connection to
      a remote BGP speaker\n   whose BGP Identifier equals the one in the OPEN message,
      and this\n   connection collides with the connection over which the OPEN message\n
      \  is received, then the local system performs the following collision\n   resolution
      procedure:\n      1) The BGP Identifier of the local system is compared to the
      BGP\n         Identifier of the remote system (as specified in the OPEN\n         message).
      \ Comparing BGP Identifiers is done by converting them\n         to host byte
      order and treating them as 4-octet unsigned\n         integers.\n      2) If
      the value of the local BGP Identifier is less than the\n         remote one,
      the local system closes the BGP connection that\n         already exists (the
      one that is already in the OpenConfirm\n         state), and accepts the BGP
      connection initiated by the remote\n         system.\n      3) Otherwise, the
      local system closes the newly created BGP\n         connection (the one associated
      with the newly received OPEN\n         message), and continues to use the existing
      one (the one that\n         is already in the OpenConfirm state).\n   Unless
      allowed via configuration, a connection collision with an\n   existing BGP connection
      that is in the Established state causes\n   closing of the newly created connection.\n
      \  Note that a connection collision cannot be detected with connections\n   that
      are in Idle, Connect, or Active states.\n   Closing the BGP connection (that
      results from the collision\n   resolution procedure) is accomplished by sending
      the NOTIFICATION\n   message with the Error Code Cease.\n"
    title: 6.8.  BGP Connection Collision Detection
  title: 6.  BGP Error Handling.
- contents:
  - "7.  BGP Version Negotiation\n   BGP speakers MAY negotiate the version of the
    protocol by making\n   multiple attempts at opening a BGP connection, starting
    with the\n   highest version number each BGP speaker supports.  If an open attempt\n
    \  fails with an Error Code, OPEN Message Error, and an Error Subcode,\n   Unsupported
    Version Number, then the BGP speaker has available the\n   version number it tried,
    the version number its peer tried, the\n   version number passed by its peer in
    the NOTIFICATION message, and\n   the version numbers it supports.  If the two
    peers do support one or\n   more common versions, then this will allow them to
    rapidly determine\n   the highest common version.  In order to support BGP version\n
    \  negotiation, future versions of BGP MUST retain the format of the\n   OPEN
    and NOTIFICATION messages.\n"
  title: 7.  BGP Version Negotiation
- contents:
  - "8.  BGP Finite State Machine (FSM)\n   The data structures and FSM described
    in this document are conceptual\n   and do not have to be implemented precisely
    as described here, as\n   long as the implementations support the described functionality
    and\n   they exhibit the same externally visible behavior.\n   This section specifies
    the BGP operation in terms of a Finite State\n   Machine (FSM).  The section falls
    into two parts:\n      1) Description of Events for the State machine (Section
    8.1)\n      2) Description of the FSM (Section 8.2)\n   Session attributes required
    (mandatory) for each connection are:\n      1) State\n      2) ConnectRetryCounter\n
    \     3) ConnectRetryTimer\n      4) ConnectRetryTime\n      5) HoldTimer\n      6)
    HoldTime\n      7) KeepaliveTimer\n      8) KeepaliveTime\n   The state session
    attribute indicates the current state of the BGP\n   FSM.  The ConnectRetryCounter
    indicates the number of times a BGP\n   peer has tried to establish a peer session.\n
    \  The mandatory attributes related to timers are described in Section\n   10.
    \ Each timer has a \"timer\" and a \"time\" (the initial value).\n   The optional
    Session attributes are listed below.  These optional\n   attributes may be supported,
    either per connection or per local\n   system:\n      1) AcceptConnectionsUnconfiguredPeers\n
    \     2) AllowAutomaticStart\n      3) AllowAutomaticStop\n      4) CollisionDetectEstablishedState\n
    \     5) DampPeerOscillations\n      6) DelayOpen\n      7) DelayOpenTime\n      8)
    DelayOpenTimer\n      9) IdleHoldTime\n     10) IdleHoldTimer\n     11) PassiveTcpEstablishment\n
    \    12) SendNOTIFICATIONwithoutOPEN\n     13) TrackTcpState\n   The optional
    session attributes support different features of the BGP\n   functionality that
    have implications for the BGP FSM state\n   transitions.  Two groups of the attributes
    which relate to timers\n   are:\n      group 1: DelayOpen, DelayOpenTime, DelayOpenTimer\n
    \     group 2: DampPeerOscillations, IdleHoldTime, IdleHoldTimer\n   The first
    parameter (DelayOpen, DampPeerOscillations) is an optional\n   attribute that
    indicates that the Timer function is active.  The\n   \"Time\" value specifies
    the initial value for the \"Timer\"\n   (DelayOpenTime, IdleHoldTime).  The \"Timer\"
    specifies the actual\n   timer.\n   Please refer to Section 8.1.1 for an explanation
    of the interaction\n   between these optional attributes and the events signaled
    to the\n   state machine.  Section 8.2.1.3 also provides a short overview of the\n
    \  different types of optional attributes (flags or timers).\n"
  - contents:
    - '8.1.  Events for the BGP FSM

      '
    - contents:
      - "8.1.1.  Optional Events Linked to Optional Session Attributes\n   The Inputs
        to the BGP FSM are events.  Events can either be mandatory\n   or optional.
        \ Some optional events are linked to optional session\n   attributes.  Optional
        session attributes enable several groups of FSM\n   functionality.\n   The
        linkage between FSM functionality, events, and the optional\n   session attributes
        are described below.\n      Group 1: Automatic Administrative Events (Start/Stop)\n
        \        Optional Session Attributes: AllowAutomaticStart,\n                                      AllowAutomaticStop,\n
        \                                     DampPeerOscillations,\n                                      IdleHoldTime,
        IdleHoldTimer\n         Option 1:    AllowAutomaticStart\n         Description:
        A BGP peer connection can be started and stopped\n                      by
        administrative control.  This administrative\n                      control
        can either be manual, based on operator\n                      intervention,
        or under the control of logic that\n                      is specific to a
        BGP implementation.  The term\n                      \"automatic\" refers
        to a start being issued to the\n                      BGP peer connection
        FSM when such logic determines\n                      that the BGP peer connection
        should be restarted.\n                      The AllowAutomaticStart attribute
        specifies that\n                      this BGP connection supports automatic
        starting of\n                      the BGP connection.\n                      If
        the BGP implementation supports\n                      AllowAutomaticStart,
        the peer may be repeatedly\n                      restarted.  Three other
        options control the rate\n                      at which the automatic restart
        occurs:\n                      DampPeerOscillations, IdleHoldTime, and the\n
        \                     IdleHoldTimer.\n                      The DampPeerOscillations
        option specifies that the\n                      implementation engages additional
        logic to damp\n                      the oscillations of BGP peers in the
        face of\n                      sequences of automatic start and automatic
        stop.\n                      IdleHoldTime specifies the length of time the
        BGP\n                      peer is held in the Idle state prior to allowing\n
        \                     the next automatic restart.  The IdleHoldTimer is\n
        \                     the timer that holds the peer in Idle state.\n                      An
        example of DampPeerOscillations logic is an\n                      increase
        of the IdleHoldTime value if a BGP peer\n                      oscillates
        connectivity (connected/disconnected)\n                      repeatedly within
        a time period.  To engage this\n                      logic, a peer could
        connect and disconnect 10\n                      times within 5 minutes.  The
        IdleHoldTime value\n                      would be reset from 0 to 120 seconds.\n
        \        Values:      TRUE or FALSE\n         Option 2:    AllowAutomaticStop\n
        \        Description: This BGP peer session optional attribute indicates\n
        \                     that the BGP connection allows \"automatic\"\n                      stopping
        of the BGP connection.  An \"automatic\"\n                      stop is defined
        as a stop under the control of\n                      implementation-specific
        logic.  The\n                      implementation-specific logic is outside
        the scope\n                      of this specification.\n         Values:
        \     TRUE or FALSE\n         Option 3:    DampPeerOscillations\n         Description:
        The DampPeerOscillations optional session\n                      attribute
        indicates that the BGP connection is\n                      using logic that
        damps BGP peer oscillations in\n                      the Idle State.\n         Value:
        \      TRUE or FALSE\n         Option 4:    IdleHoldTime\n         Description:
        The IdleHoldTime is the value that is set in the\n                      IdleHoldTimer.\n
        \        Values:      Time in seconds\n         Option 5:    IdleHoldTimer\n
        \        Description: The IdleHoldTimer aids in controlling BGP peer\n                      oscillation.
        \ The IdleHoldTimer is used to keep\n                      the BGP peer in
        Idle for a particular duration.\n                      The IdleHoldTimer_Expires
        event is described in\n                      Section 8.1.3.\n         Values:
        \     Time in seconds\n      Group 2: Unconfigured Peers\n         Optional
        Session Attributes: AcceptConnectionsUnconfiguredPeers\n         Option 1:
        \   AcceptConnectionsUnconfiguredPeers\n         Description: The BGP FSM
        optionally allows the acceptance of\n                      BGP peer connections
        from neighbors that are not\n                      pre-configured.  The\n
        \                     \"AcceptConnectionsUnconfiguredPeers\" optional\n                      session
        attribute allows the FSM to support the\n                      state transitions
        that allow the implementation to\n                      accept or reject these
        unconfigured peers.\n                      The AcceptConnectionsUnconfiguredPeers
        has\n                      security implications.  Please refer to the BGP\n
        \                     Vulnerabilities document [RFC4272] for details.\n         Value:
        \      True or False\n      Group 3: TCP processing\n         Optional Session
        Attributes: PassiveTcpEstablishment,\n                                      TrackTcpState\n
        \        Option 1:    PassiveTcpEstablishment\n         Description: This
        option indicates that the BGP FSM will\n                      passively wait
        for the remote BGP peer to\n                      establish the BGP TCP connection.\n
        \        value:       TRUE or FALSE\n         Option 2:    TrackTcpState\n
        \        Description: The BGP FSM normally tracks the end result of a\n                      TCP
        connection attempt rather than individual TCP\n                      messages.
        \ Optionally, the BGP FSM can support\n                      additional interaction
        with the TCP connection\n                      negotiation.  The interaction
        with the TCP events\n                      may increase the amount of logging
        the BGP peer\n                      connection requires and the number of
        BGP FSM\n                      changes.\n         Value:       TRUE or FALSE\n
        \     Group 4:  BGP Message Processing\n         Optional Session Attributes:
        DelayOpen, DelayOpenTime,\n                                      DelayOpenTimer,\n
        \                                     SendNOTIFICATIONwithoutOPEN,\n                                      CollisionDetectEstablishedState\n
        \        Option 1:     DelayOpen\n         Description: The DelayOpen optional
        session attribute allows\n                      implementations to be configured
        to delay sending\n                      an OPEN message for a specific time
        period\n                      (DelayOpenTime).  The delay allows the remote
        BGP\n                      Peer time to send the first OPEN message.\n         Value:
        \      TRUE or FALSE\n         Option 2:    DelayOpenTime\n         Description:
        The DelayOpenTime is the initial value set in the\n                      DelayOpenTimer.\n
        \        Value:       Time in seconds\n         Option 3:    DelayOpenTimer\n
        \        Description: The DelayOpenTimer optional session attribute is\n                      used
        to delay the sending of an OPEN message on a\n                      connection.
        \ The DelayOpenTimer_Expires event\n                      (Event 12) is described
        in Section 8.1.3.\n         Value:       Time in seconds\n         Option
        4:    SendNOTIFICATIONwithoutOPEN\n         Description: The SendNOTIFICATIONwithoutOPEN
        allows a peer to\n                      send a NOTIFICATION without first
        sending an OPEN\n                      message.  Without this optional session
        attribute,\n                      the BGP connection assumes that an OPEN
        message\n                      must be sent by a peer prior to the peer sending
        a\n                      NOTIFICATION message.\n         Value:       True
        or False\n         Option 5:    CollisionDetectEstablishedState\n         Description:
        Normally, a Detect Collision (see Section 6.8)\n                      will
        be ignored in the Established state.  This\n                      optional
        session attribute indicates that this BGP\n                      connection
        processes collisions in the Established\n                      state.\n         Value:
        \      True or False\n      Note: The optional session attributes clarify
        the BGP FSM\n            description for existing features of BGP implementations.\n
        \           The optional session attributes may be pre-defined for an\n            implementation
        and not readable via management interfaces\n            for existing correct
        implementations.  As newer BGP MIBs\n            (version 2 and beyond) are
        supported, these fields will be\n            accessible via a management interface.\n"
      title: 8.1.1.  Optional Events Linked to Optional Session Attributes
    - contents:
      - "8.1.2.  Administrative Events\n   An administrative event is an event in
        which the operator interface\n   and BGP Policy engine signal the BGP-finite
        state machine to start or\n   stop the BGP state machine.  The basic start
        and stop indications are\n   augmented by optional connection attributes that
        signal a certain\n   type of start or stop mechanism to the BGP FSM.  An example
        of this\n   combination is Event 5, AutomaticStart_with_PassiveTcpEstablishment.\n
        \  With this event, the BGP implementation signals to the BGP FSM that\n   the
        implementation is using an Automatic Start with the option to use\n   a Passive
        TCP Establishment.  The Passive TCP establishment signals\n   that this BGP
        FSM will wait for the remote side to start the TCP\n   establishment.\n   Note
        that only Event 1 (ManualStart) and Event 2 (ManualStop) are\n   mandatory
        administrative events.  All other administrative events are\n   optional (Events
        3-8).  Each event below has a name, definition,\n   status (mandatory or optional),
        and the optional session attributes\n   that SHOULD be set at each stage.
        \ When generating Event 1 through\n   Event 8 for the BGP FSM, the conditions
        specified in the \"Optional\n   Attribute Status\" section are verified.  If
        any of these conditions\n   are not satisfied, then the local system should
        log an FSM error.\n   The settings of optional session attributes may be implicit
        in some\n   implementations, and therefore may not be set explicitly by an\n
        \  external operator action.  Section 8.2.1.5 describes these implicit\n   settings
        of the optional session attributes.  The administrative\n   states described
        below may also be implicit in some implementations\n   and not directly configurable
        by an external operator.\n      Event 1: ManualStart\n         Definition:
        Local system administrator manually starts the peer\n                     connection.\n
        \        Status:     Mandatory\n         Optional\n         Attribute\n         Status:
        \    The PassiveTcpEstablishment attribute SHOULD be set\n                     to
        FALSE.\n      Event 2: ManualStop\n         Definition: Local system administrator
        manually stops the peer\n                     connection.\n         Status:
        \    Mandatory\n         Optional\n         Attribute\n         Status:     No
        interaction with any optional attributes.\n      Event 3: AutomaticStart\n
        \        Definition: Local system automatically starts the BGP\n                     connection.\n
        \        Status:     Optional, depending on local system\n         Optional\n
        \        Attribute\n         Status:     1) The AllowAutomaticStart attribute
        SHOULD be set\n                        to TRUE if this event occurs.\n                     2)
        If the PassiveTcpEstablishment optional session\n                        attribute
        is supported, it SHOULD be set to\n                        FALSE.\n                     3)
        If the DampPeerOscillations is supported, it\n                        SHOULD
        be set to FALSE when this event occurs.\n      Event 4: ManualStart_with_PassiveTcpEstablishment\n
        \        Definition: Local system administrator manually starts the peer\n
        \                    connection, but has PassiveTcpEstablishment\n                     enabled.
        \ The PassiveTcpEstablishment optional\n                     attribute indicates
        that the peer will listen prior\n                     to establishing the
        connection.\n         Status:     Optional, depending on local system\n         Optional\n
        \        Attribute\n         Status:     1) The PassiveTcpEstablishment attribute
        SHOULD be\n                        set to TRUE if this event occurs.\n                     2)
        The DampPeerOscillations attribute SHOULD be set\n                        to
        FALSE when this event occurs.\n      Event 5: AutomaticStart_with_PassiveTcpEstablishment\n
        \        Definition: Local system automatically starts the BGP\n                     connection
        with the PassiveTcpEstablishment\n                     enabled.  The PassiveTcpEstablishment
        optional\n                     attribute indicates that the peer will listen
        prior\n                     to establishing a connection.\n         Status:
        \    Optional, depending on local system\n         Optional\n         Attribute\n
        \        Status:     1) The AllowAutomaticStart attribute SHOULD be set\n
        \                       to TRUE.\n                     2) The PassiveTcpEstablishment
        attribute SHOULD be\n                        set to TRUE.\n                     3)
        If the DampPeerOscillations attribute is\n                        supported,
        the DampPeerOscillations SHOULD be\n                        set to FALSE.\n
        \     Event 6: AutomaticStart_with_DampPeerOscillations\n         Definition:
        Local system automatically starts the BGP peer\n                     connection
        with peer oscillation damping enabled.\n                     The exact method
        of damping persistent peer\n                     oscillations is determined
        by the implementation\n                     and is outside the scope of this
        document.\n         Status:     Optional, depending on local system.\n         Optional\n
        \        Attribute\n         Status:     1) The AllowAutomaticStart attribute
        SHOULD be set\n                        to TRUE.\n                     2) The
        DampPeerOscillations attribute SHOULD be set\n                        to TRUE.\n
        \                    3) The PassiveTcpEstablishment attribute SHOULD be\n
        \                       set to FALSE.\n      Event 7: AutomaticStart_with_DampPeerOscillations_and_\n
        \     PassiveTcpEstablishment\n         Definition: Local system automatically
        starts the BGP peer\n                     connection with peer oscillation
        damping enabled\n                     and PassiveTcpEstablishment enabled.
        \ The exact\n                     method of damping persistent peer oscillations
        is\n                     determined by the implementation and is outside the\n
        \                    scope of this document.\n         Status:     Optional,
        depending on local system\n         Optional\n         Attributes\n         Status:
        \    1) The AllowAutomaticStart attribute SHOULD be set\n                        to
        TRUE.\n                     2) The DampPeerOscillations attribute SHOULD be
        set\n                        to TRUE.\n                     3) The PassiveTcpEstablishment
        attribute SHOULD be\n                        set to TRUE.\n      Event 8:
        AutomaticStop\n         Definition: Local system automatically stops the BGP\n
        \                    connection.\n                     An example of an automatic
        stop event is exceeding\n                     the number of prefixes for a
        given peer and the\n                     local system automatically disconnecting
        the peer.\n         Status:     Optional, depending on local system\n         Optional\n
        \        Attribute\n         Status:     1) The AllowAutomaticStop attribute
        SHOULD be TRUE.\n"
      title: 8.1.2.  Administrative Events
    - contents:
      - "8.1.3.  Timer Events\n      Event 9: ConnectRetryTimer_Expires\n         Definition:
        An event generated when the ConnectRetryTimer\n                     expires.\n
        \        Status:     Mandatory\n      Event 10: HoldTimer_Expires\n         Definition:
        An event generated when the HoldTimer expires.\n         Status:     Mandatory\n
        \     Event 11: KeepaliveTimer_Expires\n         Definition: An event generated
        when the KeepaliveTimer expires.\n         Status:     Mandatory\n      Event
        12: DelayOpenTimer_Expires\n         Definition: An event generated when the
        DelayOpenTimer expires.\n                     Status:     Optional\n         Optional\n
        \        Attribute\n         Status:     If this event occurs,\n                     1)
        DelayOpen attribute SHOULD be set to TRUE,\n                     2) DelayOpenTime
        attribute SHOULD be supported,\n                     3) DelayOpenTimer SHOULD
        be supported.\n      Event 13: IdleHoldTimer_Expires\n         Definition:
        An event generated when the IdleHoldTimer expires,\n                     indicating
        that the BGP connection has completed\n                     waiting for the
        back-off period to prevent BGP peer\n                     oscillation.\n                     The
        IdleHoldTimer is only used when the persistent\n                     peer
        oscillation damping function is enabled by\n                     setting the
        DampPeerOscillations optional attribute\n                     to TRUE.\n                     Implementations
        not implementing the persistent\n                     peer oscillation damping
        function may not have the\n                     IdleHoldTimer.\n         Status:
        \    Optional\n         Optional\n         Attribute\n         Status:     If
        this event occurs:\n                     1) DampPeerOscillations attribute
        SHOULD be set to\n                        TRUE.\n                     2) IdleHoldTimer
        SHOULD have just expired.\n"
      title: 8.1.3.  Timer Events
    - contents:
      - "8.1.4.  TCP Connection-Based Events\n      Event 14: TcpConnection_Valid\n
        \        Definition: Event indicating the local system reception of a\n                     TCP
        connection request with a valid source IP\n                     address, TCP
        port, destination IP address, and TCP\n                     Port.  The definition
        of invalid source and invalid\n                     destination IP address
        is determined by the\n                     implementation.\n                     BGP's
        destination port SHOULD be port 179, as\n                     defined by IANA.\n
        \                    TCP connection request is denoted by the local\n                     system
        receiving a TCP SYN.\n         Status:     Optional\n         Optional\n         Attribute\n
        \        Status:     1) The TrackTcpState attribute SHOULD be set to\n                        TRUE
        if this event occurs.\n      Event 15: Tcp_CR_Invalid\n         Definition:
        Event indicating the local system reception of a\n                     TCP
        connection request with either an invalid\n                     source address
        or port number, or an invalid\n                     destination address or
        port number.\n                     BGP destination port number SHOULD be 179,
        as\n                     defined by IANA.\n                     A TCP connection
        request occurs when the local\n                     system receives a TCP
        SYN.\n         Status:     Optional\n         Optional\n         Attribute\n
        \        Status:     1) The TrackTcpState attribute should be set to\n                        TRUE
        if this event occurs.\n      Event 16: Tcp_CR_Acked\n         Definition:
        Event indicating the local system's request to\n                     establish
        a TCP connection to the remote peer.\n                     The local system's
        TCP connection sent a TCP SYN,\n                     received a TCP SYN/ACK
        message, and sent a TCP ACK.\n         Status:     Mandatory\n      Event
        17: TcpConnectionConfirmed\n         Definition: Event indicating that the
        local system has received\n                     a confirmation that the TCP
        connection has been\n                     established by the remote site.\n
        \                    The remote peer's TCP engine sent a TCP SYN.  The\n                     local
        peer's TCP engine sent a SYN, ACK message and\n                     now has
        received a final ACK.\n         Status:     Mandatory\n      Event 18: TcpConnectionFails\n
        \        Definition: Event indicating that the local system has received\n
        \                    a TCP connection failure notice.\n                     The
        remote BGP peer's TCP machine could have sent a\n                     FIN.
        \ The local peer would respond with a FIN-ACK.\n                     Another
        possibility is that the local peer\n                     indicated a timeout
        in the TCP connection and\n                     downed the connection.\n         Status:
        \    Mandatory\n"
      title: 8.1.4.  TCP Connection-Based Events
    - contents:
      - "8.1.5.  BGP Message-Based Events\n      Event 19: BGPOpen\n         Definition:
        An event is generated when a valid OPEN message has\n                     been
        received.\n         Status:     Mandatory\n         Optional\n         Attribute\n
        \        Status:     1) The DelayOpen optional attribute SHOULD be set\n                        to
        FALSE.\n                     2) The DelayOpenTimer SHOULD not be running.\n
        \     Event 20: BGPOpen with DelayOpenTimer running\n         Definition:
        An event is generated when a valid OPEN message has\n                     been
        received for a peer that has a successfully\n                     established
        transport connection and is currently\n                     delaying the sending
        of a BGP open message.\n         Status:     Optional\n         Optional\n
        \        Attribute\n         Status:     1) The DelayOpen attribute SHOULD
        be set to TRUE.\n                     2) The DelayOpenTimer SHOULD be running.\n
        \     Event 21: BGPHeaderErr\n         Definition: An event is generated when
        a received BGP message\n                     header is not valid.\n         Status:
        \    Mandatory\n      Event 22: BGPOpenMsgErr\n         Definition: An event
        is generated when an OPEN message has been\n                     received
        with errors.\n         Status:     Mandatory\n      Event 23: OpenCollisionDump\n
        \        Definition: An event generated administratively when a\n                     connection
        collision has been detected while\n                     processing an incoming
        OPEN message and this\n                     connection has been selected to
        be disconnected.\n                     See Section 6.8 for more information
        on collision\n                     detection.\n                     Event
        23 is an administrative action generated by\n                     implementation
        logic that determines whether this\n                     connection needs
        to be dropped per the rules in\n                     Section 6.8.  This event
        may occur if the FSM is\n                     implemented as two linked state
        machines.\n         Status:     Optional\n         Optional\n         Attribute\n
        \        Status:     If the state machine is to process this event in\n                     the
        Established state,\n                     1) CollisionDetectEstablishedState
        optional\n                        attribute SHOULD be set to TRUE.\n                     Please
        note: The OpenCollisionDump event can occur\n                     in Idle,
        Connect, Active, OpenSent, and OpenConfirm\n                     without any
        optional attributes being set.\n      Event 24: NotifMsgVerErr\n         Definition:
        An event is generated when a NOTIFICATION message\n                     with
        \"version error\" is received.\n         Status:     Mandatory\n      Event
        25: NotifMsg\n         Definition: An event is generated when a NOTIFICATION
        message\n                     is received and the error code is anything but\n
        \                    \"version error\".\n         Status:     Mandatory\n
        \     Event 26: KeepAliveMsg\n         Definition: An event is generated when
        a KEEPALIVE message is\n                     received.\n         Status:     Mandatory\n
        \     Event 27: UpdateMsg\n         Definition: An event is generated when
        a valid UPDATE message\n                     is received.\n         Status:
        \    Mandatory\n      Event 28: UpdateMsgErr\n         Definition: An event
        is generated when an invalid UPDATE\n                     message is received.\n
        \        Status:     Mandatory\n"
      title: 8.1.5.  BGP Message-Based Events
    title: 8.1.  Events for the BGP FSM
  - contents:
    - '8.2.  Description of FSM

      '
    - contents:
      - "8.2.1.  FSM Definition\n   BGP MUST maintain a separate FSM for each configured
        peer.  Each BGP\n   peer paired in a potential connection will attempt to
        connect to the\n   other, unless configured to remain in the idle state, or
        configured\n   to remain passive.  For the purpose of this discussion, the
        active or\n   connecting side of the TCP connection (the side of a TCP connection\n
        \  sending the first TCP SYN packet) is called outgoing.  The passive or\n
        \  listening side (the sender of the first SYN/ACK) is called an\n   incoming
        connection.  (See Section 8.2.1.1 for information on the\n   terms active
        and passive used below.)\n   A BGP implementation MUST connect to and listen
        on TCP port 179 for\n   incoming connections in addition to trying to connect
        to peers.  For\n   each incoming connection, a state machine MUST be instantiated.\n
        \  There exists a period in which the identity of the peer on the other\n
        \  end of an incoming connection is known, but the BGP identifier is not\n
        \  known.  During this time, both an incoming and outgoing connection\n   may
        exist for the same configured peering.  This is referred to as a\n   connection
        collision (see Section 6.8).\n   A BGP implementation will have, at most,
        one FSM for each configured\n   peering, plus one FSM for each incoming TCP
        connection for which the\n   peer has not yet been identified.  Each FSM corresponds
        to exactly\n   one TCP connection.\n   There may be more than one connection
        between a pair of peers if the\n   connections are configured to use a different
        pair of IP addresses.\n   This is referred to as multiple \"configured peerings\"
        to the same\n   peer.\n"
      - contents:
        - "8.2.1.1.  Terms \"active\" and \"passive\"\n   The terms active and passive
          have been in the Internet operator's\n   vocabulary for almost a decade
          and have proven useful.  The words\n   active and passive have slightly
          different meanings when applied to a\n   TCP connection or a peer.  There
          is only one active side and one\n   passive side to any one TCP connection,
          per the definition above and\n   the state machine below.  When a BGP speaker
          is configured as active,\n   it may end up on either the active or passive
          side of the connection\n   that eventually gets established.  Once the TCP
          connection is\n   completed, it doesn't matter which end was active and
          which was\n   passive.  The only difference is in which side of the TCP
          connection\n   has port number 179.\n"
        title: 8.2.1.1.  Terms "active" and "passive"
      - contents:
        - "8.2.1.2.  FSM and Collision Detection\n   There is one FSM per BGP connection.
          \ When the connection collision\n   occurs prior to determining what peer
          a connection is associated\n   with, there may be two connections for one
          peer.  After the\n   connection collision is resolved (see Section 6.8),
          the FSM for the\n   connection that is closed SHOULD be disposed.\n"
        title: 8.2.1.2.  FSM and Collision Detection
      - contents:
        - "8.2.1.3.  FSM and Optional Session Attributes\n   Optional Session Attributes
          specify either attributes that act as\n   flags (TRUE or FALSE) or optional
          timers.  For optional attributes\n   that act as flags, if the optional
          session attribute can be set to\n   TRUE on the system, the corresponding
          BGP FSM actions must be\n   supported.  For example, if the following options
          can be set in a BGP\n   implementation: AutoStart and PassiveTcpEstablishment,
          then Events 3,\n   4 and 5 must be supported.  If an Optional Session attribute
          cannot\n   be set to TRUE, the events supporting that set of options do
          not have\n   to be supported.\n   Each of the optional timers (DelayOpenTimer
          and IdleHoldTimer) has a\n   group of attributes that are:\n      - flag
          indicating support,\n      - Time set in Timer\n      - Timer.\n   The two
          optional timers show this format:\n      DelayOpenTimer: DelayOpen, DelayOpenTime,
          DelayOpenTimer\n      IdleHoldTimer:  DampPeerOscillations, IdleHoldTime,\n
          \                     IdleHoldTimer\n   If the flag indicating support for
          an optional timer (DelayOpen or\n   DampPeerOscillations) cannot be set
          to TRUE, the timers and events\n   supporting that option do not have to
          be supported.\n"
        title: 8.2.1.3.  FSM and Optional Session Attributes
      - contents:
        - "8.2.1.4.  FSM Event Numbers\n   The Event numbers (1-28) utilized in this
          state machine description\n   aid in specifying the behavior of the BGP
          state machine.\n   Implementations MAY use these numbers to provide network
          management\n   information.  The exact form of an FSM or the FSM events
          are specific\n   to each implementation.\n"
        title: 8.2.1.4.  FSM Event Numbers
      - contents:
        - "8.2.1.5.  FSM Actions that are Implementation Dependent\n   At certain
          points, the BGP FSM specifies that BGP initialization will\n   occur or
          that BGP resources will be deleted.  The initialization of\n   the BGP FSM
          and the associated resources depend on the policy portion\n   of the BGP
          implementation.  The details of these actions are outside\n   the scope
          of the FSM document.\n"
        title: 8.2.1.5.  FSM Actions that are Implementation Dependent
      title: 8.2.1.  FSM Definition
    - contents:
      - "8.2.2.  Finite State Machine\n   Idle state:\n      Initially, the BGP peer
        FSM is in the Idle state.  Hereafter, the\n      BGP peer FSM will be shortened
        to BGP FSM.\n      In this state, BGP FSM refuses all incoming BGP connections
        for\n      this peer.  No resources are allocated to the peer.  In response\n
        \     to a ManualStart event (Event 1) or an AutomaticStart event (Event\n
        \     3), the local system:\n        - initializes all BGP resources for the
        peer connection,\n        - sets ConnectRetryCounter to zero,\n        - starts
        the ConnectRetryTimer with the initial value,\n        - initiates a TCP connection
        to the other BGP peer,\n        - listens for a connection that may be initiated
        by the remote\n          BGP peer, and\n        - changes its state to Connect.\n
        \     The ManualStop event (Event 2) and AutomaticStop (Event 8) event\n      are
        ignored in the Idle state.\n      In response to a ManualStart_with_PassiveTcpEstablishment
        event\n      (Event 4) or AutomaticStart_with_PassiveTcpEstablishment event\n
        \     (Event 5), the local system:\n        - initializes all BGP resources,\n
        \       - sets the ConnectRetryCounter to zero,\n        - starts the ConnectRetryTimer
        with the initial value,\n        - listens for a connection that may be initiated
        by the remote\n          peer, and\n        - changes its state to Active.\n
        \     The exact value of the ConnectRetryTimer is a local matter, but it\n
        \     SHOULD be sufficiently large to allow TCP initialization.\n      If
        the DampPeerOscillations attribute is set to TRUE, the\n      following three
        additional events may occur within the Idle state:\n        - AutomaticStart_with_DampPeerOscillations
        (Event 6),\n        - AutomaticStart_with_DampPeerOscillations_and_\n          PassiveTcpEstablishment
        (Event 7),\n        - IdleHoldTimer_Expires (Event 13).\n      Upon receiving
        these 3 events, the local system will use these\n      events to prevent peer
        oscillations.  The method of preventing\n      persistent peer oscillation
        is outside the scope of this document.\n      Any other event (Events 9-12,
        15-28) received in the Idle state\n      does not cause change in the state
        of the local system.\n   Connect State:\n      In this state, BGP FSM is waiting
        for the TCP connection to be\n      completed.\n      The start events (Events
        1, 3-7) are ignored in the Connect state.\n      In response to a ManualStop
        event (Event 2), the local system:\n        - drops the TCP connection,\n
        \       - releases all BGP resources,\n        - sets ConnectRetryCounter
        to zero,\n        - stops the ConnectRetryTimer and sets ConnectRetryTimer
        to\n          zero, and\n        - changes its state to Idle.\n      In response
        to the ConnectRetryTimer_Expires event (Event 9), the\n      local system:\n
        \       - drops the TCP connection,\n        - restarts the ConnectRetryTimer,\n
        \       - stops the DelayOpenTimer and resets the timer to zero,\n        -
        initiates a TCP connection to the other BGP peer,\n        - continues to
        listen for a connection that may be initiated by\n          the remote BGP
        peer, and\n        - stays in the Connect state.\n      If the DelayOpenTimer_Expires
        event (Event 12) occurs in the\n      Connect state, the local system:\n        -
        sends an OPEN message to its peer,\n        - sets the HoldTimer to a large
        value, and\n        - changes its state to OpenSent.\n      If the BGP FSM
        receives a TcpConnection_Valid event (Event 14),\n      the TCP connection
        is processed, and the connection remains in the\n      Connect state.\n      If
        the BGP FSM receives a Tcp_CR_Invalid event (Event 15), the\n      local system
        rejects the TCP connection, and the connection\n      remains in the Connect
        state.\n      If the TCP connection succeeds (Event 16 or Event 17), the local\n
        \     system checks the DelayOpen attribute prior to processing.  If the\n
        \     DelayOpen attribute is set to TRUE, the local system:\n        - stops
        the ConnectRetryTimer (if running) and sets the\n          ConnectRetryTimer
        to zero,\n        - sets the DelayOpenTimer to the initial value, and\n        -
        stays in the Connect state.\n      If the DelayOpen attribute is set to FALSE,
        the local system:\n        - stops the ConnectRetryTimer (if running) and
        sets the\n          ConnectRetryTimer to zero,\n        - completes BGP initialization\n
        \       - sends an OPEN message to its peer,\n        - sets the HoldTimer
        to a large value, and\n        - changes its state to OpenSent.\n      A HoldTimer
        value of 4 minutes is suggested.\n      If the TCP connection fails (Event
        18), the local system checks\n      the DelayOpenTimer.  If the DelayOpenTimer
        is running, the local\n      system:\n        - restarts the ConnectRetryTimer
        with the initial value,\n        - stops the DelayOpenTimer and resets its
        value to zero,\n        - continues to listen for a connection that may be
        initiated by\n          the remote BGP peer, and\n        - changes its state
        to Active.\n      If the DelayOpenTimer is not running, the local system:\n
        \       - stops the ConnectRetryTimer to zero,\n        - drops the TCP connection,\n
        \       - releases all BGP resources, and\n        - changes its state to
        Idle.\n      If an OPEN message is received while the DelayOpenTimer is running\n
        \     (Event 20), the local system:\n        - stops the ConnectRetryTimer
        (if running) and sets the\n          ConnectRetryTimer to zero,\n        -
        completes the BGP initialization,\n        - stops and clears the DelayOpenTimer
        (sets the value to zero),\n        - sends an OPEN message,\n        - sends
        a KEEPALIVE message,\n        - if the HoldTimer initial value is non-zero,\n
        \           - starts the KeepaliveTimer with the initial value and\n            -
        resets the HoldTimer to the negotiated value,\n          else, if the HoldTimer
        initial value is zero,\n            - resets the KeepaliveTimer and\n            -
        resets the HoldTimer value to zero,\n        - and changes its state to OpenConfirm.\n
        \     If the value of the autonomous system field is the same as the\n      local
        Autonomous System number, set the connection status to an\n      internal
        connection; otherwise it will be \"external\".\n      If BGP message header
        checking (Event 21) or OPEN message checking\n      detects an error (Event
        22) (see Section 6.2), the local system:\n        - (optionally) If the SendNOTIFICATIONwithoutOPEN
        attribute is\n          set to TRUE, then the local system first sends a NOTIFICATION\n
        \         message with the appropriate error code, and then\n        - stops
        the ConnectRetryTimer (if running) and sets the\n          ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If a NOTIFICATION
        message is received with a version error (Event\n      24), the local system
        checks the DelayOpenTimer.  If the\n      DelayOpenTimer is running, the local
        system:\n        - stops the ConnectRetryTimer (if running) and sets the\n
        \         ConnectRetryTimer to zero,\n        - stops and resets the DelayOpenTimer
        (sets to zero),\n        - releases all BGP resources,\n        - drops the
        TCP connection, and\n        - changes its state to Idle.\n      If the DelayOpenTimer
        is not running, the local system:\n        - stops the ConnectRetryTimer and
        sets the ConnectRetryTimer to\n          zero,\n        - releases all BGP
        resources,\n        - drops the TCP connection,\n        - increments the
        ConnectRetryCounter by 1,\n        - performs peer oscillation damping if
        the DampPeerOscillations\n          attribute is set to True, and\n        -
        changes its state to Idle.\n      In response to any other events (Events
        8, 10-11, 13, 19, 23,\n      25-28), the local system:\n        - if the ConnectRetryTimer
        is running, stops and resets the\n          ConnectRetryTimer (sets to zero),\n
        \       - if the DelayOpenTimer is running, stops and resets the\n          DelayOpenTimer
        (sets to zero),\n        - releases all BGP resources,\n        - drops the
        TCP connection,\n        - increments the ConnectRetryCounter by 1,\n        -
        performs peer oscillation damping if the DampPeerOscillations\n          attribute
        is set to True, and\n        - changes its state to Idle.\n   Active State:\n
        \     In this state, BGP FSM is trying to acquire a peer by listening\n      for,
        and accepting, a TCP connection.\n      The start events (Events 1, 3-7) are
        ignored in the Active state.\n      In response to a ManualStop event (Event
        2), the local system:\n        - If the DelayOpenTimer is running and the\n
        \         SendNOTIFICATIONwithoutOPEN session attribute is set, the\n          local
        system sends a NOTIFICATION with a Cease,\n        - releases all BGP resources
        including stopping the\n          DelayOpenTimer\n        - drops the TCP
        connection,\n        - sets ConnectRetryCounter to zero,\n        - stops
        the ConnectRetryTimer and sets the ConnectRetryTimer to\n          zero, and\n
        \       - changes its state to Idle.\n      In response to a ConnectRetryTimer_Expires
        event (Event 9), the\n      local system:\n        - restarts the ConnectRetryTimer
        (with initial value),\n        - initiates a TCP connection to the other BGP
        peer,\n        - continues to listen for a TCP connection that may be initiated\n
        \         by a remote BGP peer, and\n        - changes its state to Connect.\n
        \     If the local system receives a DelayOpenTimer_Expires event (Event\n
        \     12), the local system:\n        - sets the ConnectRetryTimer to zero,\n
        \       - stops and clears the DelayOpenTimer (set to zero),\n        - completes
        the BGP initialization,\n        - sends the OPEN message to its remote peer,\n
        \       - sets its hold timer to a large value, and\n        - changes its
        state to OpenSent.\n      A HoldTimer value of 4 minutes is also suggested
        for this state\n      transition.\n      If the local system receives a TcpConnection_Valid
        event (Event\n      14), the local system processes the TCP connection flags
        and stays\n      in the Active state.\n      If the local system receives
        a Tcp_CR_Invalid event (Event 15),\n      the local system rejects the TCP
        connection and stays in the\n      Active State.\n      In response to the
        success of a TCP connection (Event 16 or Event\n      17), the local system
        checks the DelayOpen optional attribute\n      prior to processing.\n        If
        the DelayOpen attribute is set to TRUE, the local system:\n          - stops
        the ConnectRetryTimer and sets the ConnectRetryTimer\n            to zero,\n
        \         - sets the DelayOpenTimer to the initial value\n            (DelayOpenTime),
        and\n          - stays in the Active state.\n        If the DelayOpen attribute
        is set to FALSE, the local system:\n          - sets the ConnectRetryTimer
        to zero,\n          - completes the BGP initialization,\n          - sends
        the OPEN message to its peer,\n          - sets its HoldTimer to a large value,
        and\n          - changes its state to OpenSent.\n      A HoldTimer value of
        4 minutes is suggested as a \"large value\" for\n      the HoldTimer.\n      If
        the local system receives a TcpConnectionFails event (Event\n      18), the
        local system:\n        - restarts the ConnectRetryTimer (with the initial
        value),\n        - stops and clears the DelayOpenTimer (sets the value to
        zero),\n        - releases all BGP resource,\n        - increments the ConnectRetryCounter
        by 1,\n        - optionally performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      If
        an OPEN message is received and the DelayOpenTimer is running\n      (Event
        20), the local system:\n        - stops the ConnectRetryTimer (if running)
        and sets the\n          ConnectRetryTimer to zero,\n        - stops and clears
        the DelayOpenTimer (sets to zero),\n        - completes the BGP initialization,\n
        \       - sends an OPEN message,\n        - sends a KEEPALIVE message,\n        -
        if the HoldTimer value is non-zero,\n            - starts the KeepaliveTimer
        to initial value,\n            - resets the HoldTimer to the negotiated value,\n
        \         else if the HoldTimer is zero\n            - resets the KeepaliveTimer
        (set to zero),\n            - resets the HoldTimer to zero, and\n        -
        changes its state to OpenConfirm.\n      If the value of the autonomous system
        field is the same as the\n      local Autonomous System number, set the connection
        status to an\n      internal connection; otherwise it will be external.\n
        \     If BGP message header checking (Event 21) or OPEN message checking\n
        \     detects an error (Event 22) (see Section 6.2), the local system:\n        -
        (optionally) sends a NOTIFICATION message with the appropriate\n          error
        code if the SendNOTIFICATIONwithoutOPEN attribute is set\n          to TRUE,\n
        \       - sets the ConnectRetryTimer to zero,\n        - releases all BGP
        resources,\n        - drops the TCP connection,\n        - increments the
        ConnectRetryCounter by 1,\n        - (optionally) performs peer oscillation
        damping if the\n          DampPeerOscillations attribute is set to TRUE, and\n
        \       - changes its state to Idle.\n      If a NOTIFICATION message is received
        with a version error (Event\n      24), the local system checks the DelayOpenTimer.
        \ If the\n      DelayOpenTimer is running, the local system:\n        - stops
        the ConnectRetryTimer (if running) and sets the\n          ConnectRetryTimer
        to zero,\n        - stops and resets the DelayOpenTimer (sets to zero),\n
        \       - releases all BGP resources,\n        - drops the TCP connection,
        and\n        - changes its state to Idle.\n      If the DelayOpenTimer is
        not running, the local system:\n        - sets the ConnectRetryTimer to zero,\n
        \       - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      In response
        to any other event (Events 8, 10-11, 13, 19, 23,\n      25-28), the local
        system:\n        - sets the ConnectRetryTimer to zero,\n        - releases
        all BGP resources,\n        - drops the TCP connection,\n        - increments
        the ConnectRetryCounter by one,\n        - (optionally) performs peer oscillation
        damping if the\n          DampPeerOscillations attribute is set to TRUE, and\n
        \       - changes its state to Idle.\n   OpenSent:\n      In this state, BGP
        FSM waits for an OPEN message from its peer.\n      The start events (Events
        1, 3-7) are ignored in the OpenSent\n      state.\n      If a ManualStop event
        (Event 2) is issued in the OpenSent state,\n      the local system:\n        -
        sends the NOTIFICATION with a Cease,\n        - sets the ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - sets the ConnectRetryCounter to zero, and\n        - changes its
        state to Idle.\n      If an AutomaticStop event (Event 8) is issued in the
        OpenSent\n      state, the local system:\n        - sends the NOTIFICATION
        with a Cease,\n        - sets the ConnectRetryTimer to zero,\n        - releases
        all the BGP resources,\n        - drops the TCP connection,\n        - increments
        the ConnectRetryCounter by 1,\n        - (optionally) performs peer oscillation
        damping if the\n          DampPeerOscillations attribute is set to TRUE, and\n
        \       - changes its state to Idle.\n      If the HoldTimer_Expires (Event
        10), the local system:\n        - sends a NOTIFICATION message with the error
        code Hold Timer\n          Expired,\n        - sets the ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter,\n        - (optionally) performs
        peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If a TcpConnection_Valid
        (Event 14), Tcp_CR_Acked (Event 16), or a\n      TcpConnectionConfirmed event
        (Event 17) is received, a second TCP\n      connection may be in progress.
        \ This second TCP connection is\n      tracked per Connection Collision processing
        (Section 6.8) until an\n      OPEN message is received.\n      A TCP Connection
        Request for an Invalid port (Tcp_CR_Invalid\n      (Event 15)) is ignored.\n
        \     If a TcpConnectionFails event (Event 18) is received, the local\n      system:\n
        \       - closes the BGP connection,\n        - restarts the ConnectRetryTimer,\n
        \       - continues to listen for a connection that may be initiated by\n
        \         the remote BGP peer, and\n        - changes its state to Active.\n
        \     When an OPEN message is received, all fields are checked for\n      correctness.
        \ If there are no errors in the OPEN message (Event\n      19), the local
        system:\n        - resets the DelayOpenTimer to zero,\n        - sets the
        BGP ConnectRetryTimer to zero,\n        - sends a KEEPALIVE message, and\n
        \       - sets a KeepaliveTimer (via the text below)\n        - sets the HoldTimer
        according to the negotiated value (see\n          Section 4.2),\n        -
        changes its state to OpenConfirm.\n      If the negotiated hold time value
        is zero, then the HoldTimer and\n      KeepaliveTimer are not started.  If
        the value of the Autonomous\n      System field is the same as the local Autonomous
        System number,\n      then the connection is an \"internal\" connection; otherwise,
        it is\n      an \"external\" connection.  (This will impact UPDATE processing
        as\n      described below.)\n      If the BGP message header checking (Event
        21) or OPEN message\n      checking detects an error (Event 22)(see Section
        6.2), the local\n      system:\n        - sends a NOTIFICATION message with
        the appropriate error code,\n        - sets the ConnectRetryTimer to zero,\n
        \       - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is TRUE, and\n        - changes its state to Idle.\n      Collision detection
        mechanisms (Section 6.8) need to be applied\n      when a valid BGP OPEN message
        is received (Event 19 or Event 20).\n      Please refer to Section 6.8 for
        the details of the comparison.  A\n      CollisionDetectDump event occurs
        when the BGP implementation\n      determines, by means outside the scope
        of this document, that a\n      connection collision has occurred.\n      If
        a connection in the OpenSent state is determined to be the\n      connection
        that must be closed, an OpenCollisionDump (Event 23) is\n      signaled to
        the state machine.  If such an event is received in\n      the OpenSent state,
        the local system:\n        - sends a NOTIFICATION with a Cease,\n        -
        sets the ConnectRetryTimer to zero,\n        - releases all BGP resources,\n
        \       - drops the TCP connection,\n        - increments the ConnectRetryCounter
        by 1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      If
        a NOTIFICATION message is received with a version error (Event\n      24),
        the local system:\n        - sets the ConnectRetryTimer to zero,\n        -
        releases all BGP resources,\n        - drops the TCP connection, and\n        -
        changes its state to Idle.\n      In response to any other event (Events 9,
        11-13, 20, 25-28), the\n      local system:\n        - sends the NOTIFICATION
        with the Error Code Finite State\n          Machine Error,\n        - sets
        the ConnectRetryTimer to zero,\n        - releases all BGP resources,\n        -
        drops the TCP connection,\n        - increments the ConnectRetryCounter by
        1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n   OpenConfirm
        State:\n      In this state, BGP waits for a KEEPALIVE or NOTIFICATION message.\n
        \     Any start event (Events 1, 3-7) is ignored in the OpenConfirm\n      state.\n
        \     In response to a ManualStop event (Event 2) initiated by the\n      operator,
        the local system:\n        - sends the NOTIFICATION message with a Cease,\n
        \       - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - sets the ConnectRetryCounter to zero,\n        - sets the ConnectRetryTimer
        to zero, and\n        - changes its state to Idle.\n      In response to the
        AutomaticStop event initiated by the system\n      (Event 8), the local system:\n
        \       - sends the NOTIFICATION message with a Cease,\n        - sets the
        ConnectRetryTimer to zero,\n        - releases all BGP resources,\n        -
        drops the TCP connection,\n        - increments the ConnectRetryCounter by
        1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      If
        the HoldTimer_Expires event (Event 10) occurs before a\n      KEEPALIVE message
        is received, the local system:\n        - sends the NOTIFICATION message with
        the Error Code Hold Timer\n          Expired,\n        - sets the ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If the local
        system receives a KeepaliveTimer_Expires event (Event\n      11), the local
        system:\n        - sends a KEEPALIVE message,\n        - restarts the KeepaliveTimer,
        and\n        - remains in the OpenConfirmed state.\n      In the event of
        a TcpConnection_Valid event (Event 14), or the\n      success of a TCP connection
        (Event 16 or Event 17) while in\n      OpenConfirm, the local system needs
        to track the second\n      connection.\n      If a TCP connection is attempted
        with an invalid port (Event 15),\n      the local system will ignore the second
        connection attempt.\n      If the local system receives a TcpConnectionFails
        event (Event 18)\n      from the underlying TCP or a NOTIFICATION message
        (Event 25), the\n      local system:\n        - sets the ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If the local
        system receives a NOTIFICATION message with a version\n      error (NotifMsgVerErr
        (Event 24)), the local system:\n        - sets the ConnectRetryTimer to zero,\n
        \       - releases all BGP resources,\n        - drops the TCP connection,
        and\n        - changes its state to Idle.\n      If the local system receives
        a valid OPEN message (BGPOpen (Event\n      19)), the collision detect function
        is processed per Section 6.8.\n      If this connection is to be dropped due
        to connection collision,\n      the local system:\n        - sends a NOTIFICATION
        with a Cease,\n        - sets the ConnectRetryTimer to zero,\n        - releases
        all BGP resources,\n        - drops the TCP connection (send TCP FIN),\n        -
        increments the ConnectRetryCounter by 1,\n        - (optionally) performs
        peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If an OPEN
        message is received, all fields are checked for\n      correctness.  If the
        BGP message header checking (BGPHeaderErr\n      (Event 21)) or OPEN message
        checking detects an error (see Section\n      6.2) (BGPOpenMsgErr (Event 22)),
        the local system:\n        - sends a NOTIFICATION message with the appropriate
        error code,\n        - sets the ConnectRetryTimer to zero,\n        - releases
        all BGP resources,\n        - drops the TCP connection,\n        - increments
        the ConnectRetryCounter by 1,\n        - (optionally) performs peer oscillation
        damping if the\n          DampPeerOscillations attribute is set to TRUE, and\n
        \       - changes its state to Idle.\n      If, during the processing of another
        OPEN message, the BGP\n      implementation determines, by a means outside
        the scope of this\n      document, that a connection collision has occurred
        and this\n      connection is to be closed, the local system will issue an\n
        \     OpenCollisionDump event (Event 23).  When the local system\n      receives
        an OpenCollisionDump event (Event 23), the local system:\n        - sends
        a NOTIFICATION with a Cease,\n        - sets the ConnectRetryTimer to zero,\n
        \       - releases all BGP resources\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n      If the local
        system receives a KEEPALIVE message (KeepAliveMsg\n      (Event 26)), the
        local system:\n        - restarts the HoldTimer and\n        - changes its
        state to Established.\n      In response to any other event (Events 9, 12-13,
        20, 27-28), the\n      local system:\n        - sends a NOTIFICATION with
        a code of Finite State Machine\n          Error,\n        - sets the ConnectRetryTimer
        to zero,\n        - releases all BGP resources,\n        - drops the TCP connection,\n
        \       - increments the ConnectRetryCounter by 1,\n        - (optionally)
        performs peer oscillation damping if the\n          DampPeerOscillations attribute
        is set to TRUE, and\n        - changes its state to Idle.\n   Established
        State:\n      In the Established state, the BGP FSM can exchange UPDATE,\n
        \     NOTIFICATION, and KEEPALIVE messages with its peer.\n      Any Start
        event (Events 1, 3-7) is ignored in the Established\n      state.\n      In
        response to a ManualStop event (initiated by an operator)\n      (Event 2),
        the local system:\n        - sends the NOTIFICATION message with a Cease,\n
        \       - sets the ConnectRetryTimer to zero,\n        - deletes all routes
        associated with this connection,\n        - releases BGP resources,\n        -
        drops the TCP connection,\n        - sets the ConnectRetryCounter to zero,
        and\n         - changes its state to Idle.\n      In response to an AutomaticStop
        event (Event 8), the local system:\n        - sends a NOTIFICATION with a
        Cease,\n        - sets the ConnectRetryTimer to zero\n        - deletes all
        routes associated with this connection,\n        - releases all BGP resources,\n
        \       - drops the TCP connection,\n        - increments the ConnectRetryCounter
        by 1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      One
        reason for an AutomaticStop event is: A BGP receives an UPDATE\n      messages
        with a number of prefixes for a given peer such that the\n      total prefixes
        received exceeds the maximum number of prefixes\n      configured.  The local
        system automatically disconnects the peer.\n      If the HoldTimer_Expires
        event occurs (Event 10), the local\n      system:\n        - sends a NOTIFICATION
        message with the Error Code Hold Timer\n          Expired,\n        - sets
        the ConnectRetryTimer to zero,\n        - releases all BGP resources,\n        -
        drops the TCP connection,\n        - increments the ConnectRetryCounter by
        1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      If
        the KeepaliveTimer_Expires event occurs (Event 11), the local\n      system:\n
        \       - sends a KEEPALIVE message, and\n        - restarts its KeepaliveTimer,
        unless the negotiated HoldTime\n          value is zero.\n      Each time
        the local system sends a KEEPALIVE or UPDATE message, it\n      restarts its
        KeepaliveTimer, unless the negotiated HoldTime value\n      is zero.\n      A
        TcpConnection_Valid (Event 14), received for a valid port, will\n      cause
        the second connection to be tracked.\n      An invalid TCP connection (Tcp_CR_Invalid
        event (Event 15)) will\n      be ignored.\n      In response to an indication
        that the TCP connection is\n      successfully established (Event 16 or Event
        17), the second\n      connection SHALL be tracked until it sends an OPEN
        message.\n      If a valid OPEN message (BGPOpen (Event 19)) is received,
        and if\n      the CollisionDetectEstablishedState optional attribute is TRUE,\n
        \     the OPEN message will be checked to see if it collides (Section\n      6.8)
        with any other connection.  If the BGP implementation\n      determines that
        this connection needs to be terminated, it will\n      process an OpenCollisionDump
        event (Event 23).  If this connection\n      needs to be terminated, the local
        system:\n        - sends a NOTIFICATION with a Cease,\n        - sets the
        ConnectRetryTimer to zero,\n        - deletes all routes associated with this
        connection,\n        - releases all BGP resources,\n        - drops the TCP
        connection,\n        - increments the ConnectRetryCounter by 1,\n        -
        (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        is set to TRUE, and\n        - changes its state to Idle.\n      If the local
        system receives a NOTIFICATION message (Event 24 or\n      Event 25) or a
        TcpConnectionFails (Event 18) from the underlying\n      TCP, the local system:\n
        \       - sets the ConnectRetryTimer to zero,\n        - deletes all routes
        associated with this connection,\n        - releases all the BGP resources,\n
        \       - drops the TCP connection,\n        - increments the ConnectRetryCounter
        by 1,\n        - changes its state to Idle.\n      If the local system receives
        a KEEPALIVE message (Event 26), the\n      local system:\n        - restarts
        its HoldTimer, if the negotiated HoldTime value is\n          non-zero, and\n
        \       - remains in the Established state.\n      If the local system receives
        an UPDATE message (Event 27), the\n      local system:\n        - processes
        the message,\n        - restarts its HoldTimer, if the negotiated HoldTime
        value is\n          non-zero, and\n        - remains in the Established state.\n
        \     If the local system receives an UPDATE message, and the UPDATE\n      message
        error handling procedure (see Section 6.3) detects an\n      error (Event
        28), the local system:\n        - sends a NOTIFICATION message with an Update
        error,\n        - sets the ConnectRetryTimer to zero,\n        - deletes all
        routes associated with this connection,\n        - releases all BGP resources,\n
        \       - drops the TCP connection,\n        - increments the ConnectRetryCounter
        by 1,\n        - (optionally) performs peer oscillation damping if the\n          DampPeerOscillations
        attribute is set to TRUE, and\n        - changes its state to Idle.\n      In
        response to any other event (Events 9, 12-13, 20-22), the local\n      system:\n
        \       - sends a NOTIFICATION message with the Error Code Finite State\n
        \         Machine Error,\n        - deletes all routes associated with this
        connection,\n        - sets the ConnectRetryTimer to zero,\n        - releases
        all BGP resources,\n        - drops the TCP connection,\n        - increments
        the ConnectRetryCounter by 1,\n        - (optionally) performs peer oscillation
        damping if the\n          DampPeerOscillations attribute is set to TRUE, and\n
        \       - changes its state to Idle.\n"
      title: 8.2.2.  Finite State Machine
    title: 8.2.  Description of FSM
  title: 8.  BGP Finite State Machine (FSM)
- contents:
  - "9.  UPDATE Message Handling\n   An UPDATE message may be received only in the
    Established state.\n   Receiving an UPDATE message in any other state is an error.
    \ When an\n   UPDATE message is received, each field is checked for validity,
    as\n   specified in Section 6.3.\n   If an optional non-transitive attribute is
    unrecognized, it is\n   quietly ignored.  If an optional transitive attribute
    is\n   unrecognized, the Partial bit (the third high-order bit) in the\n   attribute
    flags octet is set to 1, and the attribute is retained for\n   propagation to
    other BGP speakers.\n   If an optional attribute is recognized and has a valid
    value, then,\n   depending on the type of the optional attribute, it is processed\n
    \  locally, retained, and updated, if necessary, for possible\n   propagation
    to other BGP speakers.\n   If the UPDATE message contains a non-empty WITHDRAWN
    ROUTES field,\n   the previously advertised routes, whose destinations (expressed
    as IP\n   prefixes) are contained in this field, SHALL be removed from the\n   Adj-RIB-In.
    \ This BGP speaker SHALL run its Decision Process because\n   the previously advertised
    route is no longer available for use.\n   If the UPDATE message contains a feasible
    route, the Adj-RIB-In will\n   be updated with this route as follows: if the NLRI
    of the new route\n   is identical to the one the route currently has stored in
    the Adj-\n   RIB-In, then the new route SHALL replace the older route in the Adj-\n
    \  RIB-In, thus implicitly withdrawing the older route from service.\n   Otherwise,
    if the Adj-RIB-In has no route with NLRI identical to the\n   new route, the new
    route SHALL be placed in the Adj-RIB-In.\n   Once the BGP speaker updates the
    Adj-RIB-In, the speaker SHALL run\n   its Decision Process.\n"
  - contents:
    - "9.1.  Decision Process\n   The Decision Process selects routes for subsequent
      advertisement by\n   applying the policies in the local Policy Information Base
      (PIB) to\n   the routes stored in its Adj-RIBs-In.  The output of the Decision\n
      \  Process is the set of routes that will be advertised to peers; the\n   selected
      routes will be stored in the local speaker's Adj-RIBs-Out,\n   according to
      policy.\n   The BGP Decision Process described here is conceptual, and does
      not\n   have to be implemented precisely as described, as long as the\n   implementations
      support the described functionality and they exhibit\n   the same externally
      visible behavior.\n   The selection process is formalized by defining a function
      that takes\n   the attribute of a given route as an argument and returns either
      (a)\n   a non-negative integer denoting the degree of preference for the\n   route,
      or (b) a value denoting that this route is ineligible to be\n   installed in
      Loc-RIB and will be excluded from the next phase of\n   route selection.\n   The
      function that calculates the degree of preference for a given\n   route SHALL
      NOT use any of the following as its inputs: the existence\n   of other routes,
      the non-existence of other routes, or the path\n   attributes of other routes.
      \ Route selection then consists of the\n   individual application of the degree
      of preference function to each\n   feasible route, followed by the choice of
      the one with the highest\n   degree of preference.\n   The Decision Process
      operates on routes contained in the Adj-RIBs-In,\n   and is responsible for:\n
      \     - selection of routes to be used locally by the speaker\n      - selection
      of routes to be advertised to other BGP peers\n      - route aggregation and
      route information reduction\n   The Decision Process takes place in three distinct
      phases, each\n   triggered by a different event:\n      a) Phase 1 is responsible
      for calculating the degree of preference\n         for each route received from
      a peer.\n      b) Phase 2 is invoked on completion of phase 1.  It is responsible\n
      \        for choosing the best route out of all those available for each\n         distinct
      destination, and for installing each chosen route into\n         the Loc-RIB.\n
      \     c) Phase 3 is invoked after the Loc-RIB has been modified.  It is\n         responsible
      for disseminating routes in the Loc-RIB to each\n         peer, according to
      the policies contained in the PIB.  Route\n         aggregation and information
      reduction can optionally be\n         performed within this phase.\n"
    - contents:
      - "9.1.1.  Phase 1: Calculation of Degree of Preference\n   The Phase 1 decision
        function is invoked whenever the local BGP\n   speaker receives, from a peer,
        an UPDATE message that advertises a\n   new route, a replacement route, or
        withdrawn routes.\n   The Phase 1 decision function is a separate process,f
        which completes\n   when it has no further work to do.\n   The Phase 1 decision
        function locks an Adj-RIB-In prior to operating\n   on any route contained
        within it, and unlocks it after operating on\n   all new or unfeasible routes
        contained within it.\n   For each newly received or replacement feasible route,
        the local BGP\n   speaker determines a degree of preference as follows:\n
        \     If the route is learned from an internal peer, either the value of\n
        \     the LOCAL_PREF attribute is taken as the degree of preference, or\n
        \     the local system computes the degree of preference of the route\n      based
        on preconfigured policy information.  Note that the latter\n      may result
        in formation of persistent routing loops.\n      If the route is learned from
        an external peer, then the local BGP\n      speaker computes the degree of
        preference based on preconfigured\n      policy information.  If the return
        value indicates the route is\n      ineligible, the route MAY NOT serve as
        an input to the next phase\n      of route selection; otherwise, the return
        value MUST be used as\n      the LOCAL_PREF value in any IBGP readvertisement.\n
        \     The exact nature of this policy information, and the computation\n      involved,
        is a local matter.\n"
      title: '9.1.1.  Phase 1: Calculation of Degree of Preference'
    - contents:
      - "9.1.2.  Phase 2: Route Selection\n   The Phase 2 decision function is invoked
        on completion of Phase 1.\n   The Phase 2 function is a separate process,
        which completes when it\n   has no further work to do.  The Phase 2 process
        considers all routes\n   that are eligible in the Adj-RIBs-In.\n   The Phase
        2 decision function is blocked from running while the Phase\n   3 decision
        function is in process.  The Phase 2 function locks all\n   Adj-RIBs-In prior
        to commencing its function, and unlocks them on\n   completion.\n   If the
        NEXT_HOP attribute of a BGP route depicts an address that is\n   not resolvable,
        or if it would become unresolvable if the route was\n   installed in the routing
        table, the BGP route MUST be excluded from\n   the Phase 2 decision function.\n
        \  If the AS_PATH attribute of a BGP route contains an AS loop, the BGP\n
        \  route should be excluded from the Phase 2 decision function.  AS loop\n
        \  detection is done by scanning the full AS path (as specified in the\n   AS_PATH
        attribute), and checking that the autonomous system number of\n   the local
        system does not appear in the AS path.  Operations of a BGP\n   speaker that
        is configured to accept routes with its own autonomous\n   system number in
        the AS path are outside the scope of this document.\n   It is critical that
        BGP speakers within an AS do not make conflicting\n   decisions regarding
        route selection that would cause forwarding loops\n   to occur.\n   For each
        set of destinations for which a feasible route exists in the\n   Adj-RIBs-In,
        the local BGP speaker identifies the route that has:\n      a) the highest
        degree of preference of any route to the same set\n         of destinations,
        or\n      b) is the only route to that destination, or\n      c) is selected
        as a result of the Phase 2 tie breaking rules\n         specified in Section
        9.1.2.2.\n   The local speaker SHALL then install that route in the Loc-RIB,\n
        \  replacing any route to the same destination that is currently being\n   held
        in the Loc-RIB.  When the new BGP route is installed in the\n   Routing Table,
        care must be taken to ensure that existing routes to\n   the same destination
        that are now considered invalid are removed from\n   the Routing Table.  Whether
        the new BGP route replaces an existing\n   non-BGP route in the Routing Table
        depends on the policy configured\n   on the BGP speaker.\n   The local speaker
        MUST determine the immediate next-hop address from\n   the NEXT_HOP attribute
        of the selected route (see Section 5.1.3).  If\n   either the immediate next-hop
        or the IGP cost to the NEXT_HOP (where\n   the NEXT_HOP is resolved through
        an IGP route) changes, Phase 2 Route\n   Selection MUST be performed again.\n
        \  Notice that even though BGP routes do not have to be installed in the\n
        \  Routing Table with the immediate next-hop(s), implementations MUST\n   take
        care that, before any packets are forwarded along a BGP route,\n   its associated
        NEXT_HOP address is resolved to the immediate\n   (directly connected) next-hop
        address, and that this address (or\n   multiple addresses) is finally used
        for actual packet forwarding.\n   Unresolvable routes SHALL be removed from
        the Loc-RIB and the routing\n   table.  However, corresponding unresolvable
        routes SHOULD be kept in\n   the Adj-RIBs-In (in case they become resolvable).\n"
      - contents:
        - "9.1.2.1.  Route Resolvability Condition\n   As indicated in Section 9.1.2,
          BGP speakers SHOULD exclude\n   unresolvable routes from the Phase 2 decision.
          \ This ensures that\n   only valid routes are installed in Loc-RIB and the
          Routing Table.\n   The route resolvability condition is defined as follows:\n
          \     1) A route Rte1, referencing only the intermediate network\n         address,
          is considered resolvable if the Routing Table contains\n         at least
          one resolvable route Rte2 that matches Rte1's\n         intermediate network
          address and is not recursively resolved\n         (directly or indirectly)
          through Rte1.  If multiple matching\n         routes are available, only
          the longest matching route SHOULD be\n         considered.\n      2) Routes
          referencing interfaces (with or without intermediate\n         addresses)
          are considered resolvable if the state of the\n         referenced interface
          is up and if IP processing is enabled on\n         this interface.\n   BGP
          routes do not refer to interfaces, but can be resolved through\n   the routes
          in the Routing Table that can be of both types (those that\n   specify interfaces
          or those that do not).  IGP routes and routes to\n   directly connected
          networks are expected to specify the outbound\n   interface.  Static routes
          can specify the outbound interface, the\n   intermediate address, or both.\n
          \  Note that a BGP route is considered unresolvable in a situation where\n
          \  the BGP speaker's Routing Table contains no route matching the BGP\n
          \  route's NEXT_HOP.  Mutually recursive routes (routes resolving each\n
          \  other or themselves) also fail the resolvability check.\n   It is also
          important that implementations do not consider feasible\n   routes that
          would become unresolvable if they were installed in the\n   Routing Table,
          even if their NEXT_HOPs are resolvable using the\n   current contents of
          the Routing Table (an example of such routes\n   would be mutually recursive
          routes).  This check ensures that a BGP\n   speaker does not install routes
          in the Routing Table that will be\n   removed and not used by the speaker.
          \ Therefore, in addition to local\n   Routing Table stability, this check
          also improves behavior of the\n   protocol in the network.\n   Whenever
          a BGP speaker identifies a route that fails the\n   resolvability check
          because of mutual recursion, an error message\n   SHOULD be logged.\n"
        title: 9.1.2.1.  Route Resolvability Condition
      - contents:
        - "9.1.2.2.  Breaking Ties (Phase 2)\n   In its Adj-RIBs-In, a BGP speaker
          may have several routes to the same\n   destination that have the same degree
          of preference.  The local\n   speaker can select only one of these routes
          for inclusion in the\n   associated Loc-RIB.  The local speaker considers
          all routes with the\n   same degrees of preference, both those received
          from internal peers,\n   and those received from external peers.\n   The
          following tie-breaking procedure assumes that, for each candidate\n   route,
          all the BGP speakers within an autonomous system can ascertain\n   the cost
          of a path (interior distance) to the address depicted by the\n   NEXT_HOP
          attribute of the route, and follow the same route selection\n   algorithm.\n
          \  The tie-breaking algorithm begins by considering all equally\n   preferable
          routes to the same destination, and then selects routes to\n   be removed
          from consideration.  The algorithm terminates as soon as\n   only one route
          remains in consideration.  The criteria MUST be\n   applied in the order
          specified.\n   Several of the criteria are described using pseudo-code.
          \ Note that\n   the pseudo-code shown was chosen for clarity, not efficiency.
          \ It is\n   not intended to specify any particular implementation.  BGP\n
          \  implementations MAY use any algorithm that produces the same results\n
          \  as those described here.\n      a) Remove from consideration all routes
          that are not tied for\n         having the smallest number of AS numbers
          present in their\n         AS_PATH attributes.  Note that when counting
          this number, an\n         AS_SET counts as 1, no matter how many ASes are
          in the set.\n      b) Remove from consideration all routes that are not
          tied for\n         having the lowest Origin number in their Origin attribute.\n
          \     c) Remove from consideration routes with less-preferred\n         MULTI_EXIT_DISC
          attributes.  MULTI_EXIT_DISC is only comparable\n         between routes
          learned from the same neighboring AS (the\n         neighboring AS is determined
          from the AS_PATH attribute).\n         Routes that do not have the MULTI_EXIT_DISC
          attribute are\n         considered to have the lowest possible MULTI_EXIT_DISC
          value.\n         This is also described in the following procedure:\n       for
          m = all routes still under consideration\n           for n = all routes
          still under consideration\n               if (neighborAS(m) == neighborAS(n))
          and (MED(n) < MED(m))\n                   remove route m from consideration\n
          \        In the pseudo-code above, MED(n) is a function that returns the\n
          \        value of route n's MULTI_EXIT_DISC attribute.  If route n has\n
          \        no MULTI_EXIT_DISC attribute, the function returns the lowest\n
          \        possible MULTI_EXIT_DISC value (i.e., 0).\n         Similarly,
          neighborAS(n) is a function that returns the\n         neighbor AS from
          which the route was received.  If the route is\n         learned via IBGP,
          and the other IBGP speaker didn't originate\n         the route, it is the
          neighbor AS from which the other IBGP\n         speaker learned the route.
          \ If the route is learned via IBGP,\n         and the other IBGP speaker
          either (a) originated the route, or\n         (b) created the route by aggregation
          and the AS_PATH attribute\n         of the aggregate route is either empty
          or begins with an\n         AS_SET, it is the local AS.\n         If a MULTI_EXIT_DISC
          attribute is removed before re-advertising\n         a route into IBGP,
          then comparison based on the received EBGP\n         MULTI_EXIT_DISC attribute
          MAY still be performed.  If an\n         implementation chooses to remove
          MULTI_EXIT_DISC, then the\n         optional comparison on MULTI_EXIT_DISC,
          if performed, MUST be\n         performed only among EBGP-learned routes.
          \ The best EBGP-\n         learned route may then be compared with IBGP-learned
          routes\n         after the removal of the MULTI_EXIT_DISC attribute.  If\n
          \        MULTI_EXIT_DISC is removed from a subset of EBGP-learned\n         routes,
          and the selected \"best\" EBGP-learned route will not\n         have MULTI_EXIT_DISC
          removed, then the MULTI_EXIT_DISC must be\n         used in the comparison
          with IBGP-learned routes.  For IBGP-\n         learned routes, the MULTI_EXIT_DISC
          MUST be used in route\n         comparisons that reach this step in the
          Decision Process.\n         Including the MULTI_EXIT_DISC of an EBGP-learned
          route in the\n         comparison with an IBGP-learned route, then removing
          the\n         MULTI_EXIT_DISC attribute, and advertising the route has been\n
          \        proven to cause route loops.\n      d) If at least one of the candidate
          routes was received via EBGP,\n         remove from consideration all routes
          that were received via\n         IBGP.\n      e) Remove from consideration
          any routes with less-preferred\n         interior cost.  The interior cost
          of a route is determined by\n         calculating the metric to the NEXT_HOP
          for the route using the\n         Routing Table.  If the NEXT_HOP hop for
          a route is reachable,\n         but no cost can be determined, then this
          step should be skipped\n         (equivalently, consider all routes to have
          equal costs).\n         This is also described in the following procedure.\n
          \        for m = all routes still under consideration\n             for
          n = all routes in still under consideration\n                 if (cost(n)
          is lower than cost(m))\n                     remove m from consideration\n
          \        In the pseudo-code above, cost(n) is a function that returns\n
          \        the cost of the path (interior distance) to the address given\n
          \        in the NEXT_HOP attribute of the route.\n      f) Remove from consideration
          all routes other than the route that\n         was advertised by the BGP
          speaker with the lowest BGP\n         Identifier value.\n      g) Prefer
          the route received from the lowest peer address.\n"
        title: 9.1.2.2.  Breaking Ties (Phase 2)
      title: '9.1.2.  Phase 2: Route Selection'
    - contents:
      - "9.1.3.  Phase 3: Route Dissemination\n   The Phase 3 decision function is
        invoked on completion of Phase 2, or\n   when any of the following events
        occur:\n      a) when routes in the Loc-RIB to local destinations have changed\n
        \     b) when locally generated routes learned by means outside of BGP\n         have
        changed\n      c) when a new BGP speaker connection has been established\n
        \  The Phase 3 function is a separate process that completes when it has\n
        \  no further work to do.  The Phase 3 Routing Decision function is\n   blocked
        from running while the Phase 2 decision function is in\n   process.\n   All
        routes in the Loc-RIB are processed into Adj-RIBs-Out according\n   to configured
        policy.  This policy MAY exclude a route in the Loc-RIB\n   from being installed
        in a particular Adj-RIB-Out.  A route SHALL NOT\n   be installed in the Adj-Rib-Out
        unless the destination, and NEXT_HOP\n   described by this route, may be forwarded
        appropriately by the\n   Routing Table.  If a route in Loc-RIB is excluded
        from a particular\n   Adj-RIB-Out, the previously advertised route in that
        Adj-RIB-Out MUST\n   be withdrawn from service by means of an UPDATE message
        (see 9.2).\n   Route aggregation and information reduction techniques (see
        Section\n   9.2.2.1) may optionally be applied.\n   Any local policy that
        results in routes being added to an Adj-RIB-Out\n   without also being added
        to the local BGP speaker's forwarding table\n   is outside the scope of this
        document.\n   When the updating of the Adj-RIBs-Out and the Routing Table
        is\n   complete, the local BGP speaker runs the Update-Send process of 9.2.\n"
      title: '9.1.3.  Phase 3: Route Dissemination'
    - contents:
      - "9.1.4.  Overlapping Routes\n   A BGP speaker may transmit routes with overlapping
        Network Layer\n   Reachability Information (NLRI) to another BGP speaker.
        \ NLRI overlap\n   occurs when a set of destinations are identified in non-matching\n
        \  multiple routes.  Because BGP encodes NLRI using IP prefixes, overlap\n
        \  will always exhibit subset relationships.  A route describing a\n   smaller
        set of destinations (a longer prefix) is said to be more\n   specific than
        a route describing a larger set of destinations (a\n   shorter prefix); similarly,
        a route describing a larger set of\n   destinations is said to be less specific
        than a route describing a\n   smaller set of destinations.\n   The precedence
        relationship effectively decomposes less specific\n   routes into two parts:\n
        \     - a set of destinations described only by the less specific route,\n
        \       and\n      - a set of destinations described by the overlap of the
        less\n        specific and the more specific routes\n   The set of destinations
        described by the overlap represents a portion\n   of the less specific route
        that is feasible, but is not currently in\n   use.  If a more specific route
        is later withdrawn, the set of\n   destinations described by the overlap will
        still be reachable using\n   the less specific route.\n   If a BGP speaker
        receives overlapping routes, the Decision Process\n   MUST consider both routes
        based on the configured acceptance policy.\n   If both a less and a more specific
        route are accepted, then the\n   Decision Process MUST install, in Loc-RIB,
        either both the less and\n   the more specific routes or aggregate the two
        routes and install, in\n   Loc-RIB, the aggregated route, provided that both
        routes have the\n   same value of the NEXT_HOP attribute.\n   If a BGP speaker
        chooses to aggregate, then it SHOULD either include\n   all ASes used to form
        the aggregate in an AS_SET, or add the\n   ATOMIC_AGGREGATE attribute to the
        route.  This attribute is now\n   primarily informational.  With the elimination
        of IP routing\n   protocols that do not support classless routing, and the
        elimination\n   of router and host implementations that do not support classless\n
        \  routing, there is no longer a need to de-aggregate.  Routes SHOULD\n   NOT
        be de-aggregated.  In particular, a route that carries the\n   ATOMIC_AGGREGATE
        attribute MUST NOT be de-aggregated.  That is, the\n   NLRI of this route
        cannot be more specific.  Forwarding along such a\n   route does not guarantee
        that IP packets will actually traverse only\n   ASes listed in the AS_PATH
        attribute of the route.\n"
      title: 9.1.4.  Overlapping Routes
    title: 9.1.  Decision Process
  - contents:
    - "9.2.  Update-Send Process\n   The Update-Send process is responsible for advertising
      UPDATE\n   messages to all peers.  For example, it distributes the routes chosen\n
      \  by the Decision Process to other BGP speakers, which may be located\n   in
      either the same autonomous system or a neighboring autonomous\n   system.\n
      \  When a BGP speaker receives an UPDATE message from an internal peer,\n   the
      receiving BGP speaker SHALL NOT re-distribute the routing\n   information contained
      in that UPDATE message to other internal peers\n   (unless the speaker acts
      as a BGP Route Reflector [RFC2796]).\n   As part of Phase 3 of the route selection
      process, the BGP speaker\n   has updated its Adj-RIBs-Out.  All newly installed
      routes and all\n   newly unfeasible routes for which there is no replacement
      route SHALL\n   be advertised to its peers by means of an UPDATE message.\n
      \  A BGP speaker SHOULD NOT advertise a given feasible BGP route from\n   its
      Adj-RIB-Out if it would produce an UPDATE message containing the\n   same BGP
      route as was previously advertised.\n   Any routes in the Loc-RIB marked as
      unfeasible SHALL be removed.\n   Changes to the reachable destinations within
      its own autonomous\n   system SHALL also be advertised in an UPDATE message.\n
      \  If, due to the limits on the maximum size of an UPDATE message (see\n   Section
      4), a single route doesn't fit into the message, the BGP\n   speaker MUST not
      advertise the route to its peers and MAY choose to\n   log an error locally.\n"
    - contents:
      - "9.2.1.  Controlling Routing Traffic Overhead\n   The BGP protocol constrains
        the amount of routing traffic (that is,\n   UPDATE messages), in order to
        limit both the link bandwidth needed to\n   advertise UPDATE messages and
        the processing power needed by the\n   Decision Process to digest the information
        contained in the UPDATE\n   messages.\n"
      - contents:
        - "9.2.1.1.  Frequency of Route Advertisement\n   The parameter MinRouteAdvertisementIntervalTimer
          determines the\n   minimum amount of time that must elapse between an advertisement\n
          \  and/or withdrawal of routes to a particular destination by a BGP\n   speaker
          to a peer.  This rate limiting procedure applies on a per-\n   destination
          basis, although the value of\n   MinRouteAdvertisementIntervalTimer is set
          on a per BGP peer basis.\n   Two UPDATE messages sent by a BGP speaker to
          a peer that advertise\n   feasible routes and/or withdrawal of unfeasible
          routes to some common\n   set of destinations MUST be separated by at least\n
          \  MinRouteAdvertisementIntervalTimer.  This can only be achieved by\n   keeping
          a separate timer for each common set of destinations.  This\n   would be
          unwarranted overhead.  Any technique that ensures that the\n   interval
          between two UPDATE messages sent from a BGP speaker to a\n   peer that advertise
          feasible routes and/or withdrawal of unfeasible\n   routes to some common
          set of destinations will be at least\n   MinRouteAdvertisementIntervalTimer,
          and will also ensure that a\n   constant upper bound on the interval is
          acceptable.\n   Since fast convergence is needed within an autonomous system,
          either\n   (a) the MinRouteAdvertisementIntervalTimer used for internal
          peers\n   SHOULD be shorter than the MinRouteAdvertisementIntervalTimer
          used\n   for external peers, or (b) the procedure describe in this section\n
          \  SHOULD NOT apply to routes sent to internal peers.\n   This procedure
          does not limit the rate of route selection, but only\n   the rate of route
          advertisement.  If new routes are selected multiple\n   times while awaiting
          the expiration of\n   MinRouteAdvertisementIntervalTimer, the last route
          selected SHALL be\n   advertised at the end of MinRouteAdvertisementIntervalTimer.\n"
        title: 9.2.1.1.  Frequency of Route Advertisement
      - contents:
        - "9.2.1.2.  Frequency of Route Origination\n   The parameter MinASOriginationIntervalTimer
          determines the minimum\n   amount of time that must elapse between successive
          advertisements of\n   UPDATE messages that report changes within the advertising
          BGP\n   speaker's own autonomous systems.\n"
        title: 9.2.1.2.  Frequency of Route Origination
      title: 9.2.1.  Controlling Routing Traffic Overhead
    - contents:
      - "9.2.2.  Efficient Organization of Routing Information\n   Having selected
        the routing information it will advertise, a BGP\n   speaker may avail itself
        of several methods to organize this\n   information in an efficient manner.\n"
      - contents:
        - "9.2.2.1.  Information Reduction\n   Information reduction may imply a reduction
          in granularity of policy\n   control - after information is collapsed, the
          same policies will\n   apply to all destinations and paths in the equivalence
          class.\n   The Decision Process may optionally reduce the amount of information\n
          \  that it will place in the Adj-RIBs-Out by any of the following\n   methods:\n
          \     a) Network Layer Reachability Information (NLRI):\n         Destination
          IP addresses can be represented as IP address\n         prefixes.  In cases
          where there is a correspondence between the\n         address structure
          and the systems under control of an\n         autonomous system administrator,
          it will be possible to reduce\n         the size of the NLRI carried in
          the UPDATE messages.\n      b) AS_PATHs:\n         AS path information can
          be represented as ordered AS_SEQUENCEs\n         or unordered AS_SETs.  AS_SETs
          are used in the route\n         aggregation algorithm described in Section
          9.2.2.2.  They\n         reduce the size of the AS_PATH information by listing
          each AS\n         number only once, regardless of how many times it may
          have\n         appeared in multiple AS_PATHs that were aggregated.\n         An
          AS_SET implies that the destinations listed in the NLRI can\n         be
          reached through paths that traverse at least some of the\n         constituent
          autonomous systems.  AS_SETs provide sufficient\n         information to
          avoid routing information looping; however,\n         their use may prune
          potentially feasible paths because such\n         paths are no longer listed
          individually in the form of\n         AS_SEQUENCEs.  In practice, this is
          not likely to be a problem\n         because once an IP packet arrives at
          the edge of a group of\n         autonomous systems, the BGP speaker is
          likely to have more\n         detailed path information and can distinguish
          individual paths\n         from destinations.\n"
        title: 9.2.2.1.  Information Reduction
      - contents:
        - "9.2.2.2.  Aggregating Routing Information\n   Aggregation is the process
          of combining the characteristics of\n   several different routes in such
          a way that a single route can be\n   advertised.  Aggregation can occur
          as part of the Decision Process to\n   reduce the amount of routing information
          that will be placed in the\n   Adj-RIBs-Out.\n   Aggregation reduces the
          amount of information that a BGP speaker must\n   store and exchange with
          other BGP speakers.  Routes can be aggregated\n   by applying the following
          procedure, separately, to path attributes\n   of the same type and to the
          Network Layer Reachability Information.\n   Routes that have different MULTI_EXIT_DISC
          attributes SHALL NOT be\n   aggregated.\n   If the aggregated route has
          an AS_SET as the first element in its\n   AS_PATH attribute, then the router
          that originates the route SHOULD\n   NOT advertise the MULTI_EXIT_DISC attribute
          with this route.\n   Path attributes that have different type codes cannot
          be aggregated\n   together.  Path attributes of the same type code may be
          aggregated,\n   according to the following rules:\n      NEXT_HOP:\n         When
          aggregating routes that have different NEXT_HOP\n         attributes, the
          NEXT_HOP attribute of the aggregated route\n         SHALL identify an interface
          on the BGP speaker that performs\n         the aggregation.\n      ORIGIN
          attribute:\n         If at least one route among routes that are aggregated
          has\n         ORIGIN with the value INCOMPLETE, then the aggregated route\n
          \        MUST have the ORIGIN attribute with the value INCOMPLETE.\n         Otherwise,
          if at least one route among routes that are\n         aggregated has ORIGIN
          with the value EGP, then the aggregated\n         route MUST have the ORIGIN
          attribute with the value EGP.  In\n         all other cases,, the value
          of the ORIGIN attribute of the\n         aggregated route is IGP.\n      AS_PATH
          attribute:\n         If routes to be aggregated have identical AS_PATH attributes,\n
          \        then the aggregated route has the same AS_PATH attribute as\n         each
          individual route.\n         For the purpose of aggregating AS_PATH attributes,
          we model\n         each AS within the AS_PATH attribute as a tuple <type,
          value>,\n         where \"type\" identifies a type of the path segment the
          AS\n         belongs to (e.g., AS_SEQUENCE, AS_SET), and \"value\" identifies\n
          \        the AS number.  If the routes to be aggregated have different\n
          \        AS_PATH attributes, then the aggregated AS_PATH attribute SHALL\n
          \        satisfy all of the following conditions:\n           - all tuples
          of type AS_SEQUENCE in the aggregated AS_PATH\n             SHALL appear
          in all of the AS_PATHs in the initial set of\n             routes to be
          aggregated.\n           - all tuples of type AS_SET in the aggregated AS_PATH
          SHALL\n             appear in at least one of the AS_PATHs in the initial
          set\n             (they may appear as either AS_SET or AS_SEQUENCE types).\n
          \          - for any tuple X of type AS_SEQUENCE in the aggregated\n             AS_PATH,
          which precedes tuple Y in the aggregated AS_PATH,\n             X precedes
          Y in each AS_PATH in the initial set, which\n             contains Y, regardless
          of the type of Y.\n           - No tuple of type AS_SET with the same value
          SHALL appear\n             more than once in the aggregated AS_PATH.\n           -
          Multiple tuples of type AS_SEQUENCE with the same value may\n             appear
          in the aggregated AS_PATH only when adjacent to\n             another tuple
          of the same type and value.\n         An implementation may choose any algorithm
          that conforms to\n         these rules.  At a minimum, a conformant implementation
          SHALL\n         be able to perform the following algorithm that meets all
          of\n         the above conditions:\n           - determine the longest leading
          sequence of tuples (as\n             defined above) common to all the AS_PATH
          attributes of the\n             routes to be aggregated.  Make this sequence
          the leading\n             sequence of the aggregated AS_PATH attribute.\n
          \          - set the type of the rest of the tuples from the AS_PATH\n             attributes
          of the routes to be aggregated to AS_SET, and\n             append them
          to the aggregated AS_PATH attribute.\n           - if the aggregated AS_PATH
          has more than one tuple with the\n             same value (regardless of
          tuple's type), eliminate all but\n             one such tuple by deleting
          tuples of the type AS_SET from\n             the aggregated AS_PATH attribute.\n
          \          - for each pair of adjacent tuples in the aggregated AS_PATH,\n
          \            if both tuples have the same type, merge them together, as\n
          \            long as doing so will not cause a segment with a length\n             greater
          than 255 to be generated.\n         Appendix F, Section F.6 presents another
          algorithm that\n         satisfies the conditions and allows for more complex
          policy\n         configurations.\n      ATOMIC_AGGREGATE:\n         If at
          least one of the routes to be aggregated has\n         ATOMIC_AGGREGATE
          path attribute, then the aggregated route\n         SHALL have this attribute
          as well.\n      AGGREGATOR:\n         Any AGGREGATOR attributes from the
          routes to be aggregated MUST\n         NOT be included in the aggregated
          route.  The BGP speaker\n         performing the route aggregation MAY attach
          a new AGGREGATOR\n         attribute (see Section 5.1.7).\n"
        title: 9.2.2.2.  Aggregating Routing Information
      title: 9.2.2.  Efficient Organization of Routing Information
    title: 9.2.  Update-Send Process
  - contents:
    - "9.3.  Route Selection Criteria\n   Generally, additional rules for comparing
      routes among several\n   alternatives are outside the scope of this document.
      \ There are two\n   exceptions:\n      - If the local AS appears in the AS path
      of the new route being\n        considered, then that new route cannot be viewed
      as better than\n        any other route (provided that the speaker is configured
      to\n        accept such routes).  If such a route were ever used, a routing\n
      \       loop could result.\n      - In order to achieve a successful distributed
      operation, only\n        routes with a likelihood of stability can be chosen.
      \ Thus, an\n        AS SHOULD avoid using unstable routes, and it SHOULD NOT
      make\n        rapid, spontaneous changes to its choice of route.  Quantifying\n
      \       the terms \"unstable\" and \"rapid\" (from the previous sentence)\n
      \       will require experience, but the principle is clear.  Routes\n        that
      are unstable can be \"penalized\" (e.g., by using the\n        procedures described
      in [RFC2439]).\n"
    title: 9.3.  Route Selection Criteria
  - contents:
    - "9.4.  Originating BGP routes\n   A BGP speaker may originate BGP routes by
      injecting routing\n   information acquired by some other means (e.g., via an
      IGP) into BGP.\n   A BGP speaker that originates BGP routes assigns the degree
      of\n   preference (e.g., according to local configuration) to these routes\n
      \  by passing them through the Decision Process (see Section 9.1).\n   These
      routes MAY also be distributed to other BGP speakers within the\n   local AS
      as part of the update process (see Section 9.2).  The\n   decision of whether
      to distribute non-BGP acquired routes within an\n   AS via BGP depends on the
      environment within the AS (e.g., type of\n   IGP) and SHOULD be controlled via
      configuration.\n"
    title: 9.4.  Originating BGP routes
  title: 9.  UPDATE Message Handling
- contents:
  - "10.  BGP Timers\n   BGP employs five timers: ConnectRetryTimer (see Section 8),
    HoldTimer\n   (see Section 4.2), KeepaliveTimer (see Section 8),\n   MinASOriginationIntervalTimer
    (see Section 9.2.1.2), and\n   MinRouteAdvertisementIntervalTimer (see Section
    9.2.1.1).\n   Two optional timers MAY be supported: DelayOpenTimer, IdleHoldTimer\n
    \  by BGP (see Section 8).  Section 8 describes their use.  The full\n   operation
    of these optional timers is outside the scope of this\n   document.\n   ConnectRetryTime
    is a mandatory FSM attribute that stores the initial\n   value for the ConnectRetryTimer.
    \ The suggested default value for the\n   ConnectRetryTime is 120 seconds.\n   HoldTime
    is a mandatory FSM attribute that stores the initial value\n   for the HoldTimer.
    \ The suggested default value for the HoldTime is\n   90 seconds.\n   During some
    portions of the state machine (see Section 8), the\n   HoldTimer is set to a large
    value.  The suggested default for this\n   large value is 4 minutes.\n   The KeepaliveTime
    is a mandatory FSM attribute that stores the\n   initial value for the KeepaliveTimer.
    \ The suggested default value\n   for the KeepaliveTime is 1/3 of the HoldTime.\n
    \  The suggested default value for the MinASOriginationIntervalTimer is\n   15
    seconds.\n   The suggested default value for the\n   MinRouteAdvertisementIntervalTimer
    on EBGP connections is 30 seconds.\n   The suggested default value for the\n   MinRouteAdvertisementIntervalTimer
    on IBGP connections is 5 seconds.\n   An implementation of BGP MUST allow the
    HoldTimer to be configurable\n   on a per-peer basis, and MAY allow the other
    timers to be\n   configurable.\n   To minimize the likelihood that the distribution
    of BGP messages by a\n   given BGP speaker will contain peaks, jitter SHOULD be
    applied to the\n   timers associated with MinASOriginationIntervalTimer, KeepaliveTimer,\n
    \  MinRouteAdvertisementIntervalTimer, and ConnectRetryTimer.  A given\n   BGP
    speaker MAY apply the same jitter to each of these quantities,\n   regardless
    of the destinations to which the updates are being sent;\n   that is, jitter need
    not be configured on a per-peer basis.\n   The suggested default amount of jitter
    SHALL be determined by\n   multiplying the base value of the appropriate timer
    by a random\n   factor, which is uniformly distributed in the range from 0.75
    to 1.0.\n   A new random value SHOULD be picked each time the timer is set.  The\n
    \  range of the jitter's random value MAY be configurable.\n"
  title: 10.  BGP Timers
- contents:
  - "Appendix A.  Comparison with RFC 1771\n   There are numerous editorial changes
    in comparison to [RFC1771] (too\n   many to list here).\n   The following list
    the technical changes:\n      Changes to reflect the usage of features such as
    TCP MD5\n      [RFC2385], BGP Route Reflectors [RFC2796], BGP Confederations\n
    \     [RFC3065], and BGP Route Refresh [RFC2918].\n      Clarification of the
    use of the BGP Identifier in the AGGREGATOR\n      attribute.\n      Procedures
    for imposing an upper bound on the number of prefixes\n      that a BGP speaker
    would accept from a peer.\n      The ability of a BGP speaker to include more
    than one instance of\n      its own AS in the AS_PATH attribute for the purpose
    of inter-AS\n      traffic engineering.\n      Clarification of the various types
    of NEXT_HOPs.\n      Clarification of the use of the ATOMIC_AGGREGATE attribute.\n
    \     The relationship between the immediate next hop, and the next hop\n      as
    specified in the NEXT_HOP path attribute.\n      Clarification of the tie-breaking
    procedures.\n      Clarification of the frequency of route advertisements.\n      Optional
    Parameter Type 1 (Authentication Information) has been\n      deprecated.\n      UPDATE
    Message Error subcode 7 (AS Routing Loop) has been\n      deprecated.\n      OPEN
    Message Error subcode 5 (Authentication Failure) has been\n      deprecated.\n
    \     Use of the Marker field for authentication has been deprecated.\n      Implementations
    MUST support TCP MD5 [RFC2385] for authentication.\n      Clarification of BGP
    FSM.\n"
  title: Appendix A.  Comparison with RFC 1771
- contents:
  - "Appendix B.  Comparison with RFC 1267\n   All the changes listed in Appendix
    A, plus the following.\n   BGP-4 is capable of operating in an environment where
    a set of\n   reachable destinations may be expressed via a single IP prefix.  The\n
    \  concept of network classes, or subnetting, is foreign to BGP-4.  To\n   accommodate
    these capabilities, BGP-4 changes the semantics and\n   encoding associated with
    the AS_PATH attribute.  New text has been\n   added to define semantics associated
    with IP prefixes.  These\n   abilities allow BGP-4 to support the proposed supernetting
    scheme\n   [RFC1518, RFC1519].\n   To simplify configuration, this version introduces
    a new attribute,\n   LOCAL_PREF, that facilitates route selection procedures.\n
    \  The INTER_AS_METRIC attribute has been renamed MULTI_EXIT_DISC.\n   A new attribute,
    ATOMIC_AGGREGATE, has been introduced to insure that\n   certain aggregates are
    not de-aggregated.  Another new attribute,\n   AGGREGATOR, can be added to aggregate
    routes to advertise which AS\n   and which BGP speaker within that AS caused the
    aggregation.\n   To ensure that Hold Timers are symmetric, the Hold Timer is now\n
    \  negotiated on a per-connection basis.  Hold Timers of zero are now\n   supported.\n"
  title: Appendix B.  Comparison with RFC 1267
- contents:
  - "Appendix C.  Comparison with RFC 1163\n   All of the changes listed in Appendices
    A and B, plus the following.\n   To detect and recover from BGP connection collision,
    a new field (BGP\n   Identifier) has been added to the OPEN message.  New text
    (Section\n   6.8) has been added to specify the procedure for detecting and\n
    \  recovering from collision.\n   The new document no longer restricts the router
    that is passed in the\n   NEXT_HOP path attribute to be part of the same Autonomous
    System as\n   the BGP Speaker.\n   The new document optimizes and simplifies the
    exchange of information\n   about previously reachable routes.\n"
  title: Appendix C.  Comparison with RFC 1163
- contents:
  - "Appendix D.  Comparison with RFC 1105\n   All of the changes listed in Appendices
    A, B, and C, plus the\n   following.\n   Minor changes to the [RFC1105] Finite
    State Machine were necessary to\n   accommodate the TCP user interface provided
    by BSD version 4.3.\n   The notion of Up/Down/Horizontal relations presented in
    RFC 1105 has\n   been removed from the protocol.\n   The changes in the message
    format from RFC 1105 are as follows:\n      1. The Hold Time field has been removed
    from the BGP header and\n         added to the OPEN message.\n      2. The version
    field has been removed from the BGP header and\n         added to the OPEN message.\n
    \     3. The Link Type field has been removed from the OPEN message.\n      4.
    The OPEN CONFIRM message has been eliminated and replaced with\n         implicit
    confirmation, provided by the KEEPALIVE message.\n      5. The format of the UPDATE
    message has been changed\n         significantly.  New fields were added to the
    UPDATE message to\n         support multiple path attributes.\n      6. The Marker
    field has been expanded and its role broadened to\n         support authentication.\n
    \  Note that quite often BGP, as specified in RFC 1105, is referred to\n   as
    BGP-1; BGP, as specified in [RFC1163], is referred to as BGP-2;\n   BGP, as specified
    in RFC 1267 is referred to as BGP-3; and BGP, as\n   specified in this document
    is referred to as BGP-4.\n"
  title: Appendix D.  Comparison with RFC 1105
- contents:
  - "Appendix E.  TCP Options that May Be Used with BGP\n   If a local system TCP
    user interface supports the TCP PUSH function,\n   then each BGP message SHOULD
    be transmitted with PUSH flag set.\n   Setting PUSH flag forces BGP messages to
    be transmitted to the\n   receiver promptly.\n   If a local system TCP user interface
    supports setting the DSCP field\n   [RFC2474] for TCP connections, then the TCP
    connection used by BGP\n   SHOULD be opened with bits 0-2 of the DSCP field set
    to 110 (binary).\n   An implementation MUST support the TCP MD5 option [RFC2385].\n"
  title: Appendix E.  TCP Options that May Be Used with BGP
- contents:
  - "Appendix F.  Implementation Recommendations\n   This section presents some implementation
    recommendations.\n"
  title: Appendix F.  Implementation Recommendations
- contents:
  - "Appendix F.1.  Multiple Networks Per Message\n   The BGP protocol allows for
    multiple address prefixes with the same\n   path attributes to be specified in
    one message.  Using this\n   capability is highly recommended.  With one address
    prefix per\n   message there is a substantial increase in overhead in the receiver.\n
    \  Not only does the system overhead increase due to the reception of\n   multiple
    messages, but the overhead of scanning the routing table for\n   updates to BGP
    peers and other routing protocols (and sending the\n   associated messages) is
    incurred multiple times as well.\n   One method of building messages that contain
    many address prefixes\n   per path attribute set from a routing table that is
    not organized on\n   a per path attribute set basis is to build many messages
    as the\n   routing table is scanned.  As each address prefix is processed, a\n
    \  message for the associated set of path attributes is allocated, if it\n   does
    not exist, and the new address prefix is added to it.  If such a\n   message exists,
    the new address prefix is appended to it.  If the\n   message lacks the space
    to hold the new address prefix, it is\n   transmitted, a new message is allocated,
    and the new address prefix\n   is inserted into the new message.  When the entire
    routing table has\n   been scanned, all allocated messages are sent and their
    resources are\n   released.  Maximum compression is achieved when all destinations\n
    \  covered by the address prefixes share a common set of path\n   attributes,
    making it possible to send many address prefixes in one\n   4096-byte message.\n
    \  When peering with a BGP implementation that does not compress\n   multiple
    address prefixes into one message, it may be necessary to\n   take steps to reduce
    the overhead from the flood of data received\n   when a peer is acquired or when
    a significant network topology change\n   occurs.  One method of doing this is
    to limit the rate of updates.\n   This will eliminate the redundant scanning of
    the routing table to\n   provide flash updates for BGP peers and other routing
    protocols.  A\n   disadvantage of this approach is that it increases the propagation\n
    \  latency of routing information.  By choosing a minimum flash update\n   interval
    that is not much greater than the time it takes to process\n   the multiple messages,
    this latency should be minimized.  A better\n   method would be to read all received
    messages before sending updates.\n"
  title: Appendix F.1.  Multiple Networks Per Message
- contents:
  - "Appendix F.2.  Reducing Route Flapping\n   To avoid excessive route flapping,
    a BGP speaker that needs to\n   withdraw a destination and send an update about
    a more specific or\n   less specific route should combine them into the same UPDATE
    message.\n"
  title: Appendix F.2.  Reducing Route Flapping
- contents:
  - "Appendix F.3.  Path Attribute Ordering\n   Implementations that combine update
    messages (as described above in\n   Section 6.1) may prefer to see all path attributes
    presented in a\n   known order.  This permits them to quickly identify sets of\n
    \  attributes from different update messages that are semantically\n   identical.
    \ To facilitate this, it is a useful optimization to order\n   the path attributes
    according to type code.  This optimization is\n   entirely optional.\n"
  title: Appendix F.3.  Path Attribute Ordering
- contents:
  - "Appendix F.4.  AS_SET Sorting\n   Another useful optimization that can be done
    to simplify this\n   situation is to sort the AS numbers found in an AS_SET.  This\n
    \  optimization is entirely optional.\n"
  title: Appendix F.4.  AS_SET Sorting
- contents:
  - "Appendix F.5.  Control Over Version Negotiation\n   Because BGP-4 is capable
    of carrying aggregated routes that cannot be\n   properly represented in BGP-3,
    an implementation that supports BGP-4\n   and another BGP version should provide
    the capability to only speak\n   BGP-4 on a per-peer basis.\n"
  title: Appendix F.5.  Control Over Version Negotiation
- contents:
  - "Appendix F.6.  Complex AS_PATH Aggregation\n   An implementation that chooses
    to provide a path aggregation\n   algorithm retaining significant amounts of path
    information may wish\n   to use the following procedure:\n      For the purpose
    of aggregating AS_PATH attributes of two routes,\n      we model each AS as a
    tuple <type, value>, where \"type\" identifies\n      a type of the path segment
    the AS belongs to (e.g., AS_SEQUENCE,\n      AS_SET), and \"value\" is the AS
    number.  Two ASes are said to be\n      the same if their corresponding <type,
    value> tuples are the same.\n      The algorithm to aggregate two AS_PATH attributes
    works as\n      follows:\n         a) Identify the same ASes (as defined above)
    within each\n            AS_PATH attribute that are in the same relative order
    within\n            both AS_PATH attributes.  Two ASes, X and Y, are said to be\n
    \           in the same order if either:\n              - X precedes Y in both
    AS_PATH attributes, or\n              - Y precedes X in both AS_PATH attributes.\n
    \        b) The aggregated AS_PATH attribute consists of ASes identified\n            in
    (a), in exactly the same order as they appear in the\n            AS_PATH attributes
    to be aggregated.  If two consecutive\n            ASes identified in (a) do not
    immediately follow each other\n            in both of the AS_PATH attributes to
    be aggregated, then the\n            intervening ASes (ASes that are between the
    two consecutive\n            ASes that are the same) in both attributes are combined
    into\n            an AS_SET path segment that consists of the intervening ASes\n
    \           from both AS_PATH attributes.  This segment is then placed\n            between
    the two consecutive ASes identified in (a) of the\n            aggregated attribute.
    \ If two consecutive ASes identified in\n            (a) immediately follow each
    other in one attribute, but do\n            not follow in another, then the intervening
    ASes of the\n            latter are combined into an AS_SET path segment.  This\n
    \           segment is then placed between the two consecutive ASes\n            identified
    in (a) of the aggregated attribute.\n         c) For each pair of adjacent tuples
    in the aggregated AS_PATH,\n            if both tuples have the same type, merge
    them together if\n            doing so will not cause a segment of a length greater
    than\n            255 to be generated.\n      If, as a result of the above procedure,
    a given AS number appears\n      more than once within the aggregated AS_PATH
    attribute, all but\n      the last instance (rightmost occurrence) of that AS
    number should\n      be removed from the aggregated AS_PATH attribute.\n"
  title: Appendix F.6.  Complex AS_PATH Aggregation
- contents:
  - "Security Considerations\n   A BGP implementation MUST support the authentication
    mechanism\n   specified in RFC 2385 [RFC2385].  The authentication provided by
    this\n   mechanism could be done on a per-peer basis.\n   BGP makes use of TCP
    for reliable transport of its traffic between\n   peer routers.  To provide connection-oriented
    integrity and data\n   origin authentication on a point-to-point basis, BGP specifies
    use of\n   the mechanism defined in RFC 2385.  These services are intended to\n
    \  detect and reject active wiretapping attacks against the inter-router\n   TCP
    connections.  Absent the use of mechanisms that effect these\n   security services,
    attackers can disrupt these TCP connections and/or\n   masquerade as a legitimate
    peer router.  Because the mechanism\n   defined in the RFC does not provide peer-entity
    authentication, these\n   connections may be subject to some forms of replay attacks
    that will\n   not be detected at the TCP layer.  Such attacks might result in\n
    \  delivery (from TCP) of \"broken\" or \"spoofed\" BGP messages.\n   The mechanism
    defined in RFC 2385 augments the normal TCP checksum\n   with a 16-byte message
    authentication code (MAC) that is computed\n   over the same data as the TCP checksum.
    \ This MAC is based on a one-\n   way hash function (MD5) and use of a secret
    key.  The key is shared\n   between peer routers and is used to generate MAC values
    that are not\n   readily computed by an attacker who does not have access to the
    key.\n   A compliant implementation must support this mechanism, and must\n   allow
    a network administrator to activate it on a per-peer basis.\n   RFC 2385 does
    not specify a means of managing (e.g., generating,\n   distributing, and replacing)
    the keys used to compute the MAC.  RFC\n   3562 [RFC3562] (an informational document)
    provides some guidance in\n   this area, and provides rationale to support this
    guidance.  It notes\n   that a distinct key should be used for communication with
    each\n   protected peer.  If the same key is used for multiple peers, the\n   offered
    security services may be degraded, e.g., due to an increased\n   risk of compromise
    at one router that adversely affects other\n   routers.\n   The keys used for
    MAC computation should be changed periodically, to\n   minimize the impact of
    a key compromise or successful cryptanalytic\n   attack.  RFC 3562 suggests a
    crypto period (the interval during which\n   a key is employed) of, at most, 90
    days.  More frequent key changes\n   reduce the likelihood that replay attacks
    (as described above) will\n   be feasible.  However, absent a standard mechanism
    for effecting such\n   changes in a coordinated fashion between peers, one cannot
    assume\n   that BGP-4 implementations complying with this RFC will support\n   frequent
    key changes.\n   Obviously, each should key also be chosen to be difficult for
    an\n   attacker to guess.  The techniques specified in RFC 1750 for random\n   number
    generation provide a guide for generation of values that could\n   be used as
    keys.  RFC 2385 calls for implementations to support keys\n   \"composed of a
    string of printable ASCII of 80 bytes or less.\"  RFC\n   3562 suggests keys used
    in this context be 12 to 24 bytes of random\n   (pseudo-random) bits.  This is
    fairly consistent with suggestions for\n   analogous MAC algorithms, which typically
    employ keys in the range of\n   16 to 20 bytes.  To provide enough random bits
    at the low end of this\n   range, RFC 3562 also observes that a typical ACSII
    text string would\n   have to be close to the upper bound for the key length specified
    in\n   RFC 2385.\n   BGP vulnerabilities analysis is discussed in [RFC4272].\n"
  title: Security Considerations
- contents:
  - "IANA Considerations\n   All the BGP messages contain an 8-bit message type, for
    which IANA\n   has created and is maintaining a registry entitled \"BGP Message\n
    \  Types\".  This document defines the following message types:\n         Name
    \            Value       Definition\n         ----             -----       ----------\n
    \        OPEN             1           See Section 4.2\n         UPDATE           2
    \          See Section 4.3\n         NOTIFICATION     3           See Section
    4.5\n         KEEPALIVE        4           See Section 4.4\n   Future assignments
    are to be made using either the Standards Action\n   process defined in [RFC2434],
    or the Early IANA Allocation process\n   defined in [RFC4020].  Assignments consist
    of a name and the value.\n   The BGP UPDATE messages may carry one or more Path
    Attributes, where\n   each Attribute contains an 8-bit Attribute Type Code.  IANA
    is\n   already maintaining such a registry, entitled \"BGP Path Attributes\".\n
    \  This document defines the following Path Attributes Type Codes:\n        Name
    \              Value       Definition\n        ----               -----       ----------\n
    \       ORIGIN              1          See Section 5.1.1\n        AS_PATH             2
    \         See Section 5.1.2\n        NEXT_HOP            3          See Section
    5.1.3\n        MULTI_EXIT_DISC     4          See Section 5.1.4\n        LOCAL_PREF
    \         5          See Section 5.1.5\n        ATOMIC_AGGREGATE    6          See
    Section 5.1.6\n        AGGREGATOR          7          See Section 5.1.7\n   Future
    assignments are to be made using either the Standards Action\n   process defined
    in [RFC2434], or the Early IANA Allocation process\n   defined in [RFC4020].  Assignments
    consist of a name and the value.\n   The BGP NOTIFICATION message carries an 8-bit
    Error Code, for which\n   IANA has created and is maintaining a registry entitled
    \"BGP Error\n   Codes\".  This document defines the following Error Codes:\n         Name
    \                      Value      Definition\n         ------------               -----
    \     ----------\n         Message Header Error       1          Section 6.1\n
    \        OPEN Message Error         2          Section 6.2\n         UPDATE Message
    Error       3          Section 6.3\n         Hold Timer Expired         4          Section
    6.5\n         Finite State Machine Error 5          Section 6.6\n         Cease
    \                     6          Section 6.7\n   Future assignments are to be
    made using either the Standards Action\n   process defined in [RFC2434], or the
    Early IANA Allocation process\n   defined in [RFC4020].  Assignments consist of
    a name and the value.\n   The BGP NOTIFICATION message carries an 8-bit Error
    Subcode, where\n   each Subcode has to be defined within the context of a particular\n
    \  Error Code, and thus has to be unique only within that context.\n   IANA has
    created and is maintaining a set of registries, \"Error\n   Subcodes\", with a
    separate registry for each BGP Error Code.  Future\n   assignments are to be made
    using either the Standards Action process\n   defined in [RFC2434], or the Early
    IANA Allocation process defined in\n   [RFC4020].  Assignments consist of a name
    and the value.\n   This document defines the following Message Header Error subcodes:\n
    \        Name                         Value        Definition\n         --------------------
    \        -----        ----------\n         Connection Not Synchronized   1           See
    Section 6.1\n         Bad Message Length            2           See Section 6.1\n
    \        Bad Message Type              3           See Section 6.1\n   This document
    defines the following OPEN Message Error subcodes:\n         Name                         Value
    \       Definition\n         --------------------         -----        ----------\n
    \        Unsupported Version Number     1          See Section 6.2\n         Bad
    Peer AS                    2          See Section 6.2\n         Bad BGP Identifier
    \            3          See Section 6.2\n         Unsupported Optional Parameter
    4          See Section 6.2\n         [Deprecated]                   5          See
    Appendix A\n         Unacceptable Hold Time         6          See Section 6.2\n
    \   This document defines the following UPDATE Message Error subcodes:\n         Name
    \                            Value    Definition\n         --------------------
    \             ---     ----------\n         Malformed Attribute List           1
    \     See Section 6.3\n         Unrecognized Well-known Attribute  2      See
    Section 6.3\n         Missing Well-known Attribute       3      See Section 6.3\n
    \        Attribute Flags Error              4      See Section 6.3\n         Attribute
    Length Error             5      See Section 6.3\n         Invalid ORIGIN Attribute
    \          6      See Section 6.3\n         [Deprecated]                       7
    \     See Appendix A\n         Invalid NEXT_HOP Attribute         8      See Section
    6.3\n         Optional Attribute Error           9      See Section 6.3\n         Invalid
    Network Field             10      See Section 6.3\n         Malformed AS_PATH
    \                11      See Section 6.3\n"
  title: IANA Considerations
- contents:
  - "Normative References\n   [RFC791]  Postel, J., \"Internet Protocol\", STD 5,
    RFC 791, September\n             1981.\n   [RFC793]  Postel, J., \"Transmission
    Control Protocol\", STD 7, RFC\n             793, September 1981.\n   [RFC2119]
    Bradner, S., \"Key words for use in RFCs to Indicate\n             Requirement
    Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2385] Heffernan, A., \"Protection
    of BGP Sessions via the TCP MD5\n             Signature Option\", RFC 2385, August
    1998.\n   [RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n
    \            IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n             October
    1998.\n"
  title: Normative References
- contents:
  - "Informative References\n   [RFC904]  Mills, D., \"Exterior Gateway Protocol formal\n
    \            specification\", RFC 904, April 1984.\n   [RFC1092] Rekhter, J.,
    \"EGP and policy based routing in the new\n             NSFNET backbone\", RFC
    1092, February 1989.\n   [RFC1093] Braun, H., \"NSFNET routing architecture\",
    RFC 1093,\n             February 1989.\n   [RFC1105] Lougheed, K. and Y. Rekhter,
    \"Border Gateway Protocol\n             (BGP)\", RFC 1105, June 1989.\n   [RFC1163]
    Lougheed, K. and Y. Rekhter, \"Border Gateway Protocol\n             (BGP)\",
    RFC 1163, June 1990.\n   [RFC1267] Lougheed, K. and Y. Rekhter, \"Border Gateway
    Protocol 3\n             (BGP-3)\", RFC 1267, October 1991.\n   [RFC1771] Rekhter,
    Y. and T. Li, \"A Border Gateway Protocol 4 (BGP-\n             4)\", RFC 1771,
    March 1995.\n   [RFC1772] Rekhter, Y. and P. Gross, \"Application of the Border\n
    \            Gateway Protocol in the Internet\", RFC 1772, March 1995.\n   [RFC1518]
    Rekhter, Y. and T. Li, \"An Architecture for IP Address\n             Allocation
    with CIDR\", RFC 1518, September 1993.\n   [RFC1519] Fuller, V., Li, T., Yu, J.,
    and K. Varadhan, \"Classless\n             Inter-Domain Routing (CIDR): an Address
    Assignment and\n             Aggregation Strategy\", RFC 1519, September 1993.\n
    \  [RFC1930] Hawkinson, J. and T. Bates, \"Guidelines for creation,\n             selection,
    and registration of an Autonomous System (AS)\",\n             BCP 6, RFC 1930,
    March 1996.\n   [RFC1997] Chandra, R., Traina, P., and T. Li, \"BGP Communities\n
    \            Attribute\", RFC 1997, August 1996.\n   [RFC2439] Villamizar, C.,
    Chandra, R., and R. Govindan, \"BGP Route\n             Flap Damping\", RFC 2439,
    November 1998.\n   [RFC2474] Nichols, K., Blake, S., Baker, F., and D. Black,\n
    \            \"Definition of the Differentiated Services Field (DS Field)\n             in
    the IPv4 and IPv6 Headers\", RFC 2474, December 1998.\n   [RFC2796] Bates, T.,
    Chandra, R., and E. Chen, \"BGP Route Reflection\n             - An Alternative
    to Full Mesh IBGP\", RFC 2796, April 2000.\n   [RFC2858] Bates, T., Rekhter, Y.,
    Chandra, R., and D. Katz,\n             \"Multiprotocol Extensions for BGP-4\",
    RFC 2858, June 2000.\n   [RFC3392] Chandra, R. and J. Scudder, \"Capabilities
    Advertisement\n             with BGP-4\", RFC 3392, November 2002.\n   [RFC2918]
    Chen, E., \"Route Refresh Capability for BGP-4\", RFC 2918,\n             September
    2000.\n   [RFC3065] Traina, P., McPherson, D., and J. Scudder, \"Autonomous\n
    \            System Confederations for BGP\", RFC 3065, February 2001.\n   [RFC3562]
    Leech, M., \"Key Management Considerations for the TCP MD5\n             Signature
    Option\", RFC 3562, July 2003.\n   [IS10747] \"Information Processing Systems
    - Telecommunications and\n             Information Exchange between Systems -
    Protocol for\n             Exchange of Inter-domain Routeing Information among\n
    \            Intermediate Systems to Support Forwarding of ISO 8473\n             PDUs\",
    ISO/IEC IS10747, 1993.\n   [RFC4272] Murphy, S., \"BGP Security Vulnerabilities
    Analysis\", RFC\n             4272, January 2006\n   [RFC4020] Kompella, K. and
    A. Zinin, \"Early IANA Allocation of\n             Standards Track Code Points\",
    BCP 100, RFC 4020, February\n             2005.\n"
  title: Informative References
- contents:
  - "Editors' Addresses\n   Yakov Rekhter\n   Juniper Networks\n   EMail: yakov@juniper.net\n
    \  Tony Li\n   EMail: tony.li@tony.li\n   Susan Hares\n   NextHop Technologies,
    Inc.\n   825 Victors Way\n   Ann Arbor, MI 48108\n   Phone: (734)222-1610\n   EMail:
    skh@nexthop.com\n"
  title: Editors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n
    \  Administrative Support Activity (IASA).\n"
  title: Acknowledgement
