- contents:
  - '                    HTTP State Management Mechanism

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines the HTTP Cookie and Set-Cookie header fields.\n
    \  These header fields can be used by HTTP servers to store state\n   (called
    cookies) at HTTP user agents, letting the servers maintain a\n   stateful session
    over the mostly stateless HTTP protocol.  Although\n   cookies have many historical
    infelicities that degrade their security\n   and privacy, the Cookie and Set-Cookie
    header fields are widely used\n   on the Internet.  This document obsoletes RFC
    2965.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6265.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions .....................................................4\n      2.1.
    Conformance Criteria .......................................4\n      2.2. Syntax
    Notation ............................................5\n      2.3. Terminology
    ................................................5\n   3. Overview ........................................................6\n
    \     3.1. Examples ...................................................6\n   4.
    Server Requirements .............................................8\n      4.1.
    Set-Cookie .................................................8\n           4.1.1.
    Syntax ..............................................8\n           4.1.2. Semantics
    (Non-Normative) ..........................10\n      4.2. Cookie ....................................................13\n
    \          4.2.1. Syntax .............................................13\n           4.2.2.
    Semantics ..........................................13\n   5. User Agent Requirements
    ........................................14\n      5.1. Subcomponent Algorithms
    ...................................14\n           5.1.1. Dates ..............................................14\n
    \          5.1.2. Canonicalized Host Names ...........................16\n           5.1.3.
    Domain Matching ....................................16\n           5.1.4. Paths
    and Path-Match ...............................16\n      5.2. The Set-Cookie Header
    .....................................17\n           5.2.1. The Expires Attribute
    ..............................19\n           5.2.2. The Max-Age Attribute ..............................20\n
    \          5.2.3. The Domain Attribute ...............................20\n           5.2.4.
    The Path Attribute .................................21\n           5.2.5. The
    Secure Attribute ...............................21\n           5.2.6. The HttpOnly
    Attribute .............................21\n      5.3. Storage Model .............................................21\n
    \     5.4. The Cookie Header .........................................25\n   6.
    Implementation Considerations ..................................27\n      6.1.
    Limits ....................................................27\n      6.2. Application
    Programming Interfaces ........................27\n      6.3. IDNA Dependency
    and Migration .............................27\n   7. Privacy Considerations .........................................28\n
    \     7.1. Third-Party Cookies .......................................28\n      7.2.
    User Controls .............................................28\n      7.3. Expiration
    Dates ..........................................29\n   8. Security Considerations
    ........................................29\n      8.1. Overview ..................................................29\n
    \     8.2. Ambient Authority .........................................30\n      8.3.
    Clear Text ................................................30\n      8.4. Session
    Identifiers .......................................31\n      8.5. Weak Confidentiality
    ......................................32\n      8.6. Weak Integrity ............................................32\n
    \     8.7. Reliance on DNS ...........................................33\n   9.
    IANA Considerations ............................................33\n      9.1.
    Cookie ....................................................34\n      9.2. Set-Cookie
    ................................................34\n      9.3. Cookie2 ...................................................34\n
    \     9.4. Set-Cookie2 ...............................................34\n   10.
    References ....................................................35\n      10.1.
    Normative References .....................................35\n      10.2. Informative
    References ...................................35\n   Appendix A. Acknowledgements
    ......................................37\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines the HTTP Cookie and Set-Cookie header
    fields.\n   Using the Set-Cookie header field, an HTTP server can pass name/value\n
    \  pairs and associated metadata (called cookies) to a user agent.  When\n   the
    user agent makes subsequent requests to the server, the user\n   agent uses the
    metadata and other information to determine whether to\n   return the name/value
    pairs in the Cookie header.\n   Although simple on their surface, cookies have
    a number of\n   complexities.  For example, the server indicates a scope for each\n
    \  cookie when sending it to the user agent.  The scope indicates the\n   maximum
    amount of time in which the user agent should return the\n   cookie, the servers
    to which the user agent should return the cookie,\n   and the URI schemes for
    which the cookie is applicable.\n   For historical reasons, cookies contain a
    number of security and\n   privacy infelicities.  For example, a server can indicate
    that a\n   given cookie is intended for \"secure\" connections, but the Secure\n
    \  attribute does not provide integrity in the presence of an active\n   network
    attacker.  Similarly, cookies for a given host are shared\n   across all the ports
    on that host, even though the usual \"same-origin\n   policy\" used by web browsers
    isolates content retrieved via different\n   ports.\n   There are two audiences
    for this specification: developers of cookie-\n   generating servers and developers
    of cookie-consuming user agents.\n   To maximize interoperability with user agents,
    servers SHOULD limit\n   themselves to the well-behaved profile defined in Section
    4 when\n   generating cookies.\n   User agents MUST implement the more liberal
    processing rules defined\n   in Section 5, in order to maximize interoperability
    with existing\n   servers that do not conform to the well-behaved profile defined
    in\n   Section 4.\n   This document specifies the syntax and semantics of these
    headers as\n   they are actually used on the Internet.  In particular, this document\n
    \  does not create new syntax or semantics beyond those in use today.\n   The
    recommendations for cookie generation provided in Section 4\n   represent a preferred
    subset of current server behavior, and even the\n   more liberal cookie processing
    algorithm provided in Section 5 does\n   not recommend all of the syntactic and
    semantic variations in use\n   today.  Where some existing software differs from
    the recommended\n   protocol in significant ways, the document contains a note
    explaining\n   the difference.\n   Prior to this document, there were at least
    three descriptions of\n   cookies: the so-called \"Netscape cookie specification\"
    [Netscape],\n   RFC 2109 [RFC2109], and RFC 2965 [RFC2965].  However, none of
    these\n   documents describe how the Cookie and Set-Cookie headers are actually\n
    \  used on the Internet (see [Kri2001] for historical context).  In\n   relation
    to previous IETF specifications of HTTP state management\n   mechanisms, this
    document requests the following actions:\n   1.  Change the status of [RFC2109]
    to Historic (it has already been\n       obsoleted by [RFC2965]).\n   2.  Change
    the status of [RFC2965] to Historic.\n   3.  Indicate that [RFC2965] has been
    obsoleted by this document.\n   In particular, in moving RFC 2965 to Historic
    and obsoleting it, this\n   document deprecates the use of the Cookie2 and Set-Cookie2
    header\n   fields.\n"
  title: 1.  Introduction
- contents:
  - '2.  Conventions

    '
  - contents:
    - "2.1.  Conformance Criteria\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n   Requirements phrased in the imperative as part of algorithms
      (such as\n   \"strip any leading space characters\" or \"return false and abort
      these\n   steps\") are to be interpreted with the meaning of the key word\n
      \  (\"MUST\", \"SHOULD\", \"MAY\", etc.) used in introducing the algorithm.\n
      \  Conformance requirements phrased as algorithms or specific steps can\n   be
      implemented in any manner, so long as the end result is\n   equivalent.  In
      particular, the algorithms defined in this\n   specification are intended to
      be easy to understand and are not\n   intended to be performant.\n"
    title: 2.1.  Conformance Criteria
  - contents:
    - "2.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234].\n   The following core rules are included
      by reference, as defined in\n   [RFC5234], Appendix B.1: ALPHA (letters), CR
      (carriage return), CRLF\n   (CR LF), CTLs (controls), DIGIT (decimal 0-9), DQUOTE
      (double quote),\n   HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), NUL (null
      octet),\n   OCTET (any 8-bit sequence of data except NUL), SP (space), HTAB\n
      \  (horizontal tab), CHAR (any [USASCII] character), VCHAR (any visible\n   [USASCII]
      character), and WSP (whitespace).\n   The OWS (optional whitespace) rule is
      used where zero or more linear\n   whitespace characters MAY appear:\n   OWS
      \           = *( [ obs-fold ] WSP )\n                    ; \"optional\" whitespace\n
      \  obs-fold       = CRLF\n   OWS SHOULD either not be produced or be produced
      as a single SP\n   character.\n"
    title: 2.2.  Syntax Notation
  - contents:
    - "2.3.  Terminology\n   The terms user agent, client, server, proxy, and origin
      server have\n   the same meaning as in the HTTP/1.1 specification ([RFC2616],
      Section\n   1.3).\n   The request-host is the name of the host, as known by
      the user agent,\n   to which the user agent is sending an HTTP request or from
      which it\n   is receiving an HTTP response (i.e., the name of the host to which
      it\n   sent the corresponding HTTP request).\n   The term request-uri is defined
      in Section 5.1.2 of [RFC2616].\n   Two sequences of octets are said to case-insensitively
      match each\n   other if and only if they are equivalent under the i;ascii-casemap\n
      \  collation defined in [RFC4790].\n   The term string means a sequence of non-NUL
      octets.\n"
    title: 2.3.  Terminology
  title: 2.  Conventions
- contents:
  - "3.  Overview\n   This section outlines a way for an origin server to send state\n
    \  information to a user agent and for the user agent to return the\n   state
    information to the origin server.\n   To store state, the origin server includes
    a Set-Cookie header in an\n   HTTP response.  In subsequent requests, the user
    agent returns a\n   Cookie request header to the origin server.  The Cookie header\n
    \  contains cookies the user agent received in previous Set-Cookie\n   headers.
    \ The origin server is free to ignore the Cookie header or\n   use its contents
    for an application-defined purpose.\n   Origin servers MAY send a Set-Cookie response
    header with any\n   response.  User agents MAY ignore Set-Cookie headers contained
    in\n   responses with 100-level status codes but MUST process Set-Cookie\n   headers
    contained in other responses (including responses with 400-\n   and 500-level
    status codes).  An origin server can include multiple\n   Set-Cookie header fields
    in a single response.  The presence of a\n   Cookie or a Set-Cookie header field
    does not preclude HTTP caches\n   from storing and reusing a response.\n   Origin
    servers SHOULD NOT fold multiple Set-Cookie header fields into\n   a single header
    field.  The usual mechanism for folding HTTP headers\n   fields (i.e., as defined
    in [RFC2616]) might change the semantics of\n   the Set-Cookie header field because
    the %x2C (\",\") character is used\n   by Set-Cookie in a way that conflicts with
    such folding.\n"
  - contents:
    - "3.1.  Examples\n   Using the Set-Cookie header, a server can send the user
      agent a short\n   string in an HTTP response that the user agent will return
      in future\n   HTTP requests that are within the scope of the cookie.  For example,\n
      \  the server can send the user agent a \"session identifier\" named SID\n   with
      the value 31d4d96e407aad42.  The user agent then returns the\n   session identifier
      in subsequent requests.\n   == Server -> User Agent ==\n   Set-Cookie: SID=31d4d96e407aad42\n
      \  == User Agent -> Server ==\n   Cookie: SID=31d4d96e407aad42\n   The server
      can alter the default scope of the cookie using the Path\n   and Domain attributes.
      \ For example, the server can instruct the user\n   agent to return the cookie
      to every path and every subdomain of\n   example.com.\n   == Server -> User
      Agent ==\n   Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com\n
      \  == User Agent -> Server ==\n   Cookie: SID=31d4d96e407aad42\n   As shown
      in the next example, the server can store multiple cookies\n   at the user agent.
      \ For example, the server can store a session\n   identifier as well as the
      user's preferred language by returning two\n   Set-Cookie header fields.  Notice
      that the server uses the Secure and\n   HttpOnly attributes to provide additional
      security protections for\n   the more sensitive session identifier (see Section
      4.1.2.)\n   == Server -> User Agent ==\n   Set-Cookie: SID=31d4d96e407aad42;
      Path=/; Secure; HttpOnly\n   Set-Cookie: lang=en-US; Path=/; Domain=example.com\n
      \  == User Agent -> Server ==\n   Cookie: SID=31d4d96e407aad42; lang=en-US\n
      \  Notice that the Cookie header above contains two cookies, one named\n   SID
      and one named lang.  If the server wishes the user agent to\n   persist the
      cookie over multiple \"sessions\" (e.g., user agent\n   restarts), the server
      can specify an expiration date in the Expires\n   attribute.  Note that the
      user agent might delete the cookie before\n   the expiration date if the user
      agent's cookie store exceeds its\n   quota or if the user manually deletes the
      server's cookie.\n   == Server -> User Agent ==\n   Set-Cookie: lang=en-US;
      Expires=Wed, 09 Jun 2021 10:18:14 GMT\n   == User Agent -> Server ==\n   Cookie:
      SID=31d4d96e407aad42; lang=en-US\n   Finally, to remove a cookie, the server
      returns a Set-Cookie header\n   with an expiration date in the past.  The server
      will be successful\n   in removing the cookie only if the Path and the Domain
      attribute in\n   the Set-Cookie header match the values used when the cookie
      was\n   created.\n   == Server -> User Agent ==\n   Set-Cookie: lang=; Expires=Sun,
      06 Nov 1994 08:49:37 GMT\n   == User Agent -> Server ==\n   Cookie: SID=31d4d96e407aad42\n"
    title: 3.1.  Examples
  title: 3.  Overview
- contents:
  - "4.  Server Requirements\n   This section describes the syntax and semantics of
    a well-behaved\n   profile of the Cookie and Set-Cookie headers.\n"
  - contents:
    - "4.1.  Set-Cookie\n   The Set-Cookie HTTP response header is used to send cookies
      from the\n   server to the user agent.\n"
    - contents:
      - "4.1.1.  Syntax\n   Informally, the Set-Cookie response header contains the
        header name\n   \"Set-Cookie\" followed by a \":\" and a cookie.  Each cookie
        begins with\n   a name-value-pair, followed by zero or more attribute-value
        pairs.\n   Servers SHOULD NOT send Set-Cookie headers that fail to conform
        to\n   the following grammar:\n set-cookie-header = \"Set-Cookie:\" SP set-cookie-string\n
        set-cookie-string = cookie-pair *( \";\" SP cookie-av )\n cookie-pair       =
        cookie-name \"=\" cookie-value\n cookie-name       = token\n cookie-value
        \     = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      =
        %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII
        characters excluding CTLs,\n                       ; whitespace DQUOTE, comma,
        semicolon,\n                       ; and backslash\n token             = <token,
        defined in [RFC2616], Section 2.2>\n cookie-av         = expires-av / max-age-av
        / domain-av /\n                     path-av / secure-av / httponly-av /\n
        \                    extension-av\n expires-av        = \"Expires=\" sane-cookie-date\n
        sane-cookie-date  = <rfc1123-date, defined in [RFC2616], Section 3.3.1>\n
        max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ;
        In practice, both expires-av and max-age-av\n                       ; are
        limited to dates representable by the\n                       ; user agent.\n
        non-zero-digit    = %x31-39\n                       ; digits 1 through 9\n
        domain-av         = \"Domain=\" domain-value\n domain-value      = <subdomain>\n
        \                      ; defined in [RFC1034], Section 3.5, as\n                       ;
        enhanced by [RFC1123], Section 2.1\n path-av           = \"Path=\" path-value\n
        path-value        = <any CHAR except CTLs or \";\">\n secure-av         =
        \"Secure\"\n httponly-av       = \"HttpOnly\"\n extension-av      = <any CHAR
        except CTLs or \";\">\n   Note that some of the grammatical terms above reference
        documents\n   that use different grammatical notations than this document
        (which\n   uses ABNF from [RFC5234]).\n   The semantics of the cookie-value
        are not defined by this document.\n   To maximize compatibility with user
        agents, servers that wish to\n   store arbitrary data in a cookie-value SHOULD
        encode that data, for\n   example, using Base64 [RFC4648].\n   The portions
        of the set-cookie-string produced by the cookie-av term\n   are known as attributes.
        \ To maximize compatibility with user agents,\n   servers SHOULD NOT produce
        two attributes with the same name in the\n   same set-cookie-string.  (See
        Section 5.3 for how user agents handle\n   this case.)\n   Servers SHOULD
        NOT include more than one Set-Cookie header field in\n   the same response
        with the same cookie-name.  (See Section 5.2 for\n   how user agents handle
        this case.)\n   If a server sends multiple responses containing Set-Cookie
        headers\n   concurrently to the user agent (e.g., when communicating with
        the\n   user agent over multiple sockets), these responses create a \"race\n
        \  condition\" that can lead to unpredictable behavior.\n   NOTE: Some existing
        user agents differ in their interpretation of\n   two-digit years.  To avoid
        compatibility issues, servers SHOULD use\n   the rfc1123-date format, which
        requires a four-digit year.\n   NOTE: Some user agents store and process dates
        in cookies as 32-bit\n   UNIX time_t values.  Implementation bugs in the libraries
        supporting\n   time_t processing on some systems might cause such user agents
        to\n   process dates after the year 2038 incorrectly.\n"
      title: 4.1.1.  Syntax
    - contents:
      - "4.1.2.  Semantics (Non-Normative)\n   This section describes simplified semantics
        of the Set-Cookie header.\n   These semantics are detailed enough to be useful
        for understanding\n   the most common uses of cookies by servers.  The full
        semantics are\n   described in Section 5.\n   When the user agent receives
        a Set-Cookie header, the user agent\n   stores the cookie together with its
        attributes.  Subsequently, when\n   the user agent makes an HTTP request,
        the user agent includes the\n   applicable, non-expired cookies in the Cookie
        header.\n   If the user agent receives a new cookie with the same cookie-name,\n
        \  domain-value, and path-value as a cookie that it has already stored,\n
        \  the existing cookie is evicted and replaced with the new cookie.\n   Notice
        that servers can delete cookies by sending the user agent a\n   new cookie
        with an Expires attribute with a value in the past.\n   Unless the cookie's
        attributes indicate otherwise, the cookie is\n   returned only to the origin
        server (and not, for example, to any\n   subdomains), and it expires at the
        end of the current session (as\n   defined by the user agent).  User agents
        ignore unrecognized cookie\n   attributes (but not the entire cookie).\n"
      - contents:
        - "4.1.2.1.  The Expires Attribute\n   The Expires attribute indicates the
          maximum lifetime of the cookie,\n   represented as the date and time at
          which the cookie expires.  The\n   user agent is not required to retain
          the cookie until the specified\n   date has passed.  In fact, user agents
          often evict cookies due to\n   memory pressure or privacy concerns.\n"
        title: 4.1.2.1.  The Expires Attribute
      - contents:
        - "4.1.2.2.  The Max-Age Attribute\n   The Max-Age attribute indicates the
          maximum lifetime of the cookie,\n   represented as the number of seconds
          until the cookie expires.  The\n   user agent is not required to retain
          the cookie for the specified\n   duration.  In fact, user agents often evict
          cookies due to memory\n   pressure or privacy concerns.\n      NOTE: Some
          existing user agents do not support the Max-Age\n      attribute.  User
          agents that do not support the Max-Age attribute\n      ignore the attribute.\n
          \  If a cookie has both the Max-Age and the Expires attribute, the Max-\n
          \  Age attribute has precedence and controls the expiration date of the\n
          \  cookie.  If a cookie has neither the Max-Age nor the Expires\n   attribute,
          the user agent will retain the cookie until \"the current\n   session is
          over\" (as defined by the user agent).\n"
        title: 4.1.2.2.  The Max-Age Attribute
      - contents:
        - "4.1.2.3.  The Domain Attribute\n   The Domain attribute specifies those
          hosts to which the cookie will\n   be sent.  For example, if the value of
          the Domain attribute is\n   \"example.com\", the user agent will include
          the cookie in the Cookie\n   header when making HTTP requests to example.com,
          www.example.com, and\n   www.corp.example.com.  (Note that a leading %x2E
          (\".\"), if present,\n   is ignored even though that character is not permitted,
          but a\n   trailing %x2E (\".\"), if present, will cause the user agent to
          ignore\n   the attribute.)  If the server omits the Domain attribute, the
          user\n   agent will return the cookie only to the origin server.\n      WARNING:
          Some existing user agents treat an absent Domain\n      attribute as if
          the Domain attribute were present and contained\n      the current host
          name.  For example, if example.com returns a Set-\n      Cookie header without
          a Domain attribute, these user agents will\n      erroneously send the cookie
          to www.example.com as well.\n   The user agent will reject cookies unless
          the Domain attribute\n   specifies a scope for the cookie that would include
          the origin\n   server.  For example, the user agent will accept a cookie
          with a\n   Domain attribute of \"example.com\" or of \"foo.example.com\"
          from\n   foo.example.com, but the user agent will not accept a cookie with
          a\n   Domain attribute of \"bar.example.com\" or of \"baz.foo.example.com\".\n
          \  NOTE: For security reasons, many user agents are configured to reject\n
          \  Domain attributes that correspond to \"public suffixes\".  For example,\n
          \  some user agents will reject Domain attributes of \"com\" or \"co.uk\".\n
          \  (See Section 5.3 for more information.)\n"
        title: 4.1.2.3.  The Domain Attribute
      - contents:
        - "4.1.2.4.  The Path Attribute\n   The scope of each cookie is limited to
          a set of paths, controlled by\n   the Path attribute.  If the server omits
          the Path attribute, the user\n   agent will use the \"directory\" of the
          request-uri's path component as\n   the default value.  (See Section 5.1.4
          for more details.)\n   The user agent will include the cookie in an HTTP
          request only if the\n   path portion of the request-uri matches (or is a
          subdirectory of) the\n   cookie's Path attribute, where the %x2F (\"/\")
          character is\n   interpreted as a directory separator.\n   Although seemingly
          useful for isolating cookies between different\n   paths within a given
          host, the Path attribute cannot be relied upon\n   for security (see Section
          8).\n"
        title: 4.1.2.4.  The Path Attribute
      - contents:
        - "4.1.2.5.  The Secure Attribute\n   The Secure attribute limits the scope
          of the cookie to \"secure\"\n   channels (where \"secure\" is defined by
          the user agent).  When a\n   cookie has the Secure attribute, the user agent
          will include the\n   cookie in an HTTP request only if the request is transmitted
          over a\n   secure channel (typically HTTP over Transport Layer Security
          (TLS)\n   [RFC2818]).\n   Although seemingly useful for protecting cookies
          from active network\n   attackers, the Secure attribute protects only the
          cookie's\n   confidentiality.  An active network attacker can overwrite
          Secure\n   cookies from an insecure channel, disrupting their integrity
          (see\n   Section 8.6 for more details).\n"
        title: 4.1.2.5.  The Secure Attribute
      - contents:
        - "4.1.2.6.  The HttpOnly Attribute\n   The HttpOnly attribute limits the
          scope of the cookie to HTTP\n   requests.  In particular, the attribute
          instructs the user agent to\n   omit the cookie when providing access to
          cookies via \"non-HTTP\" APIs\n   (such as a web browser API that exposes
          cookies to scripts).\n   Note that the HttpOnly attribute is independent
          of the Secure\n   attribute: a cookie can have both the HttpOnly and the
          Secure\n   attribute.\n"
        title: 4.1.2.6.  The HttpOnly Attribute
      title: 4.1.2.  Semantics (Non-Normative)
    title: 4.1.  Set-Cookie
  - contents:
    - '4.2.  Cookie

      '
    - contents:
      - "4.2.1.  Syntax\n   The user agent sends stored cookies to the origin server
        in the\n   Cookie header.  If the server conforms to the requirements in\n
        \  Section 4.1 (and the user agent conforms to the requirements in\n   Section
        5), the user agent will send a Cookie header that conforms to\n   the following
        grammar:\n   cookie-header = \"Cookie:\" OWS cookie-string OWS\n   cookie-string
        = cookie-pair *( \";\" SP cookie-pair )\n"
      title: 4.2.1.  Syntax
    - contents:
      - "4.2.2.  Semantics\n   Each cookie-pair represents a cookie stored by the
        user agent.  The\n   cookie-pair contains the cookie-name and cookie-value
        the user agent\n   received in the Set-Cookie header.\n   Notice that the
        cookie attributes are not returned.  In particular,\n   the server cannot
        determine from the Cookie header alone when a\n   cookie will expire, for
        which hosts the cookie is valid, for which\n   paths the cookie is valid,
        or whether the cookie was set with the\n   Secure or HttpOnly attributes.\n
        \  The semantics of individual cookies in the Cookie header are not\n   defined
        by this document.  Servers are expected to imbue these\n   cookies with application-specific
        semantics.\n   Although cookies are serialized linearly in the Cookie header,\n
        \  servers SHOULD NOT rely upon the serialization order.  In particular,\n
        \  if the Cookie header contains two cookies with the same name (e.g.,\n   that
        were set with different Path or Domain attributes), servers\n   SHOULD NOT
        rely upon the order in which these cookies appear in the\n   header.\n"
      title: 4.2.2.  Semantics
    title: 4.2.  Cookie
  title: 4.  Server Requirements
- contents:
  - "5.  User Agent Requirements\n   This section specifies the Cookie and Set-Cookie
    headers in\n   sufficient detail that a user agent implementing these requirements\n
    \  precisely can interoperate with existing servers (even those that do\n   not
    conform to the well-behaved profile described in Section 4).\n   A user agent
    could enforce more restrictions than those specified\n   herein (e.g., for the
    sake of improved security); however,\n   experiments have shown that such strictness
    reduces the likelihood\n   that a user agent will be able to interoperate with
    existing servers.\n"
  - contents:
    - "5.1.  Subcomponent Algorithms\n   This section defines some algorithms used
      by user agents to process\n   specific subcomponents of the Cookie and Set-Cookie
      headers.\n"
    - contents:
      - "5.1.1.  Dates\n   The user agent MUST use an algorithm equivalent to the
        following\n   algorithm to parse a cookie-date.  Note that the various boolean\n
        \  flags defined as a part of the algorithm (i.e., found-time, found-\n   day-of-month,
        found-month, found-year) are initially \"not set\".\n   1.  Using the grammar
        below, divide the cookie-date into date-tokens.\n   cookie-date     = *delimiter
        date-token-list *delimiter\n   date-token-list = date-token *( 1*delimiter
        date-token )\n   date-token      = 1*non-delimiter\n   delimiter       = %x09
        / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E\n   non-delimiter   = %x00-08 / %x0A-1F
        / DIGIT / \":\" / ALPHA / %x7F-FF\n   non-digit       = %x00-2F / %x3A-FF\n
        \  day-of-month    = 1*2DIGIT ( non-digit *OCTET )\n   month           = (
        \"jan\" / \"feb\" / \"mar\" / \"apr\" /\n                       \"may\" /
        \"jun\" / \"jul\" / \"aug\" /\n                       \"sep\" / \"oct\" /
        \"nov\" / \"dec\" ) *OCTET\n   year            = 2*4DIGIT ( non-digit *OCTET
        )\n   time            = hms-time ( non-digit *OCTET )\n   hms-time        =
        time-field \":\" time-field \":\" time-field\n   time-field      = 1*2DIGIT\n
        \  2.  Process each date-token sequentially in the order the date-tokens\n
        \      appear in the cookie-date:\n       1.  If the found-time flag is not
        set and the token matches the\n           time production, set the found-time
        flag and set the hour-\n           value, minute-value, and second-value to
        the numbers denoted\n           by the digits in the date-token, respectively.
        \ Skip the\n           remaining sub-steps and continue to the next date-token.\n
        \      2.  If the found-day-of-month flag is not set and the date-token\n
        \          matches the day-of-month production, set the found-day-of-\n           month
        flag and set the day-of-month-value to the number\n           denoted by the
        date-token.  Skip the remaining sub-steps and\n           continue to the
        next date-token.\n       3.  If the found-month flag is not set and the date-token
        matches\n           the month production, set the found-month flag and set
        the\n           month-value to the month denoted by the date-token.  Skip
        the\n           remaining sub-steps and continue to the next date-token.\n
        \      4.  If the found-year flag is not set and the date-token matches\n
        \          the year production, set the found-year flag and set the\n           year-value
        to the number denoted by the date-token.  Skip the\n           remaining sub-steps
        and continue to the next date-token.\n   3.  If the year-value is greater
        than or equal to 70 and less than or\n       equal to 99, increment the year-value
        by 1900.\n   4.  If the year-value is greater than or equal to 0 and less
        than or\n       equal to 69, increment the year-value by 2000.\n       1.
        \ NOTE: Some existing user agents interpret two-digit years\n           differently.\n
        \  5.  Abort these steps and fail to parse the cookie-date if:\n       *  at
        least one of the found-day-of-month, found-month, found-\n          year,
        or found-time flags is not set,\n       *  the day-of-month-value is less
        than 1 or greater than 31,\n       *  the year-value is less than 1601,\n
        \      *  the hour-value is greater than 23,\n       *  the minute-value is
        greater than 59, or\n       *  the second-value is greater than 59.\n       (Note
        that leap seconds cannot be represented in this syntax.)\n   6.  Let the parsed-cookie-date
        be the date whose day-of-month, month,\n       year, hour, minute, and second
        (in UTC) are the day-of-month-\n       value, the month-value, the year-value,
        the hour-value, the\n       minute-value, and the second-value, respectively.
        \ If no such\n       date exists, abort these steps and fail to parse the
        cookie-date.\n   7.  Return the parsed-cookie-date as the result of this algorithm.\n"
      title: 5.1.1.  Dates
    - contents:
      - "5.1.2.  Canonicalized Host Names\n   A canonicalized host name is the string
        generated by the following\n   algorithm:\n   1.  Convert the host name to
        a sequence of individual domain name\n       labels.\n   2.  Convert each
        label that is not a Non-Reserved LDH (NR-LDH) label,\n       to an A-label
        (see Section 2.3.2.1 of [RFC5890] for the former\n       and latter), or to
        a \"punycode label\" (a label resulting from the\n       \"ToASCII\" conversion
        in Section 4 of [RFC3490]), as appropriate\n       (see Section 6.3 of this
        specification).\n   3.  Concatenate the resulting labels, separated by a %x2E
        (\".\")\n       character.\n"
      title: 5.1.2.  Canonicalized Host Names
    - contents:
      - "5.1.3.  Domain Matching\n   A string domain-matches a given domain string
        if at least one of the\n   following conditions hold:\n   o  The domain string
        and the string are identical.  (Note that both\n      the domain string and
        the string will have been canonicalized to\n      lower case at this point.)\n
        \  o  All of the following conditions hold:\n      *  The domain string is
        a suffix of the string.\n      *  The last character of the string that is
        not included in the\n         domain string is a %x2E (\".\") character.\n
        \     *  The string is a host name (i.e., not an IP address).\n"
      title: 5.1.3.  Domain Matching
    - contents:
      - "5.1.4.  Paths and Path-Match\n   The user agent MUST use an algorithm equivalent
        to the following\n   algorithm to compute the default-path of a cookie:\n
        \  1.  Let uri-path be the path portion of the request-uri if such a\n       portion
        exists (and empty otherwise).  For example, if the\n       request-uri contains
        just a path (and optional query string),\n       then the uri-path is that
        path (without the %x3F (\"?\") character\n       or query string), and if
        the request-uri contains a full\n       absoluteURI, the uri-path is the path
        component of that URI.\n   2.  If the uri-path is empty or if the first character
        of the uri-\n       path is not a %x2F (\"/\") character, output %x2F (\"/\")
        and skip\n       the remaining steps.\n   3.  If the uri-path contains no
        more than one %x2F (\"/\") character,\n       output %x2F (\"/\") and skip
        the remaining step.\n   4.  Output the characters of the uri-path from the
        first character up\n       to, but not including, the right-most %x2F (\"/\").\n
        \  A request-path path-matches a given cookie-path if at least one of\n   the
        following conditions holds:\n   o  The cookie-path and the request-path are
        identical.\n   o  The cookie-path is a prefix of the request-path, and the
        last\n      character of the cookie-path is %x2F (\"/\").\n   o  The cookie-path
        is a prefix of the request-path, and the first\n      character of the request-path
        that is not included in the cookie-\n      path is a %x2F (\"/\") character.\n"
      title: 5.1.4.  Paths and Path-Match
    title: 5.1.  Subcomponent Algorithms
  - contents:
    - "5.2.  The Set-Cookie Header\n   When a user agent receives a Set-Cookie header
      field in an HTTP\n   response, the user agent MAY ignore the Set-Cookie header
      field in\n   its entirety.  For example, the user agent might wish to block\n
      \  responses to \"third-party\" requests from setting cookies (see\n   Section
      7.1).\n   If the user agent does not ignore the Set-Cookie header field in its\n
      \  entirety, the user agent MUST parse the field-value of the Set-Cookie\n   header
      field as a set-cookie-string (defined below).\n   NOTE: The algorithm below
      is more permissive than the grammar in\n   Section 4.1.  For example, the algorithm
      strips leading and trailing\n   whitespace from the cookie name and value (but
      maintains internal\n   whitespace), whereas the grammar in Section 4.1 forbids
      whitespace in\n   these positions.  User agents use this algorithm so as to\n
      \  interoperate with servers that do not follow the recommendations in\n   Section
      4.\n   A user agent MUST use an algorithm equivalent to the following\n   algorithm
      to parse a \"set-cookie-string\":\n   1.  If the set-cookie-string contains
      a %x3B (\";\") character:\n          The name-value-pair string consists of
      the characters up to,\n          but not including, the first %x3B (\";\"),
      and the unparsed-\n          attributes consist of the remainder of the set-cookie-string\n
      \         (including the %x3B (\";\") in question).\n       Otherwise:\n          The
      name-value-pair string consists of all the characters\n          contained in
      the set-cookie-string, and the unparsed-\n          attributes is the empty
      string.\n   2.  If the name-value-pair string lacks a %x3D (\"=\") character,\n
      \      ignore the set-cookie-string entirely.\n   3.  The (possibly empty) name
      string consists of the characters up\n       to, but not including, the first
      %x3D (\"=\") character, and the\n       (possibly empty) value string consists
      of the characters after\n       the first %x3D (\"=\") character.\n   4.  Remove
      any leading or trailing WSP characters from the name\n       string and the
      value string.\n   5.  If the name string is empty, ignore the set-cookie-string\n
      \      entirely.\n   6.  The cookie-name is the name string, and the cookie-value
      is the\n       value string.\n   The user agent MUST use an algorithm equivalent
      to the following\n   algorithm to parse the unparsed-attributes:\n   1.  If
      the unparsed-attributes string is empty, skip the rest of\n       these steps.\n
      \  2.  Discard the first character of the unparsed-attributes (which\n       will
      be a %x3B (\";\") character).\n   3.  If the remaining unparsed-attributes contains
      a %x3B (\";\")\n       character:\n          Consume the characters of the unparsed-attributes
      up to, but\n          not including, the first %x3B (\";\") character.\n       Otherwise:\n
      \         Consume the remainder of the unparsed-attributes.\n       Let the
      cookie-av string be the characters consumed in this step.\n   4.  If the cookie-av
      string contains a %x3D (\"=\") character:\n          The (possibly empty) attribute-name
      string consists of the\n          characters up to, but not including, the first
      %x3D (\"=\")\n          character, and the (possibly empty) attribute-value
      string\n          consists of the characters after the first %x3D (\"=\")\n
      \         character.\n       Otherwise:\n          The attribute-name string
      consists of the entire cookie-av\n          string, and the attribute-value
      string is empty.\n   5.  Remove any leading or trailing WSP characters from
      the attribute-\n       name string and the attribute-value string.\n   6.  Process
      the attribute-name and attribute-value according to the\n       requirements
      in the following subsections.  (Notice that\n       attributes with unrecognized
      attribute-names are ignored.)\n   7.  Return to Step 1 of this algorithm.\n
      \  When the user agent finishes parsing the set-cookie-string, the user\n   agent
      is said to \"receive a cookie\" from the request-uri with name\n   cookie-name,
      value cookie-value, and attributes cookie-attribute-\n   list.  (See Section
      5.3 for additional requirements triggered by\n   receiving a cookie.)\n"
    - contents:
      - "5.2.1.  The Expires Attribute\n   If the attribute-name case-insensitively
        matches the string\n   \"Expires\", the user agent MUST process the cookie-av
        as follows.\n   Let the expiry-time be the result of parsing the attribute-value
        as\n   cookie-date (see Section 5.1.1).\n   If the attribute-value failed
        to parse as a cookie date, ignore the\n   cookie-av.\n   If the expiry-time
        is later than the last date the user agent can\n   represent, the user agent
        MAY replace the expiry-time with the last\n   representable date.\n   If the
        expiry-time is earlier than the earliest date the user agent\n   can represent,
        the user agent MAY replace the expiry-time with the\n   earliest representable
        date.\n   Append an attribute to the cookie-attribute-list with an attribute-\n
        \  name of Expires and an attribute-value of expiry-time.\n"
      title: 5.2.1.  The Expires Attribute
    - contents:
      - "5.2.2.  The Max-Age Attribute\n   If the attribute-name case-insensitively
        matches the string \"Max-\n   Age\", the user agent MUST process the cookie-av
        as follows.\n   If the first character of the attribute-value is not a DIGIT
        or a \"-\"\n   character, ignore the cookie-av.\n   If the remainder of attribute-value
        contains a non-DIGIT character,\n   ignore the cookie-av.\n   Let delta-seconds
        be the attribute-value converted to an integer.\n   If delta-seconds is less
        than or equal to zero (0), let expiry-time\n   be the earliest representable
        date and time.  Otherwise, let the\n   expiry-time be the current date and
        time plus delta-seconds seconds.\n   Append an attribute to the cookie-attribute-list
        with an attribute-\n   name of Max-Age and an attribute-value of expiry-time.\n"
      title: 5.2.2.  The Max-Age Attribute
    - contents:
      - "5.2.3.  The Domain Attribute\n   If the attribute-name case-insensitively
        matches the string \"Domain\",\n   the user agent MUST process the cookie-av
        as follows.\n   If the attribute-value is empty, the behavior is undefined.
        \ However,\n   the user agent SHOULD ignore the cookie-av entirely.\n   If
        the first character of the attribute-value string is %x2E (\".\"):\n      Let
        cookie-domain be the attribute-value without the leading %x2E\n      (\".\")
        character.\n   Otherwise:\n      Let cookie-domain be the entire attribute-value.\n
        \  Convert the cookie-domain to lower case.\n   Append an attribute to the
        cookie-attribute-list with an attribute-\n   name of Domain and an attribute-value
        of cookie-domain.\n"
      title: 5.2.3.  The Domain Attribute
    - contents:
      - "5.2.4.  The Path Attribute\n   If the attribute-name case-insensitively matches
        the string \"Path\",\n   the user agent MUST process the cookie-av as follows.\n
        \  If the attribute-value is empty or if the first character of the\n   attribute-value
        is not %x2F (\"/\"):\n      Let cookie-path be the default-path.\n   Otherwise:\n
        \     Let cookie-path be the attribute-value.\n   Append an attribute to the
        cookie-attribute-list with an attribute-\n   name of Path and an attribute-value
        of cookie-path.\n"
      title: 5.2.4.  The Path Attribute
    - contents:
      - "5.2.5.  The Secure Attribute\n   If the attribute-name case-insensitively
        matches the string \"Secure\",\n   the user agent MUST append an attribute
        to the cookie-attribute-list\n   with an attribute-name of Secure and an empty
        attribute-value.\n"
      title: 5.2.5.  The Secure Attribute
    - contents:
      - "5.2.6.  The HttpOnly Attribute\n   If the attribute-name case-insensitively
        matches the string\n   \"HttpOnly\", the user agent MUST append an attribute
        to the cookie-\n   attribute-list with an attribute-name of HttpOnly and an
        empty\n   attribute-value.\n"
      title: 5.2.6.  The HttpOnly Attribute
    title: 5.2.  The Set-Cookie Header
  - contents:
    - "5.3.  Storage Model\n   The user agent stores the following fields about each
      cookie: name,\n   value, expiry-time, domain, path, creation-time, last-access-time,\n
      \  persistent-flag, host-only-flag, secure-only-flag, and http-only-\n   flag.\n
      \  When the user agent \"receives a cookie\" from a request-uri with name\n
      \  cookie-name, value cookie-value, and attributes cookie-attribute-\n   list,
      the user agent MUST process the cookie as follows:\n   1.   A user agent MAY
      ignore a received cookie in its entirety.  For\n        example, the user agent
      might wish to block receiving cookies\n        from \"third-party\" responses
      or the user agent might not wish to\n        store cookies that exceed some
      size.\n   2.   Create a new cookie with name cookie-name, value cookie-value.\n
      \       Set the creation-time and the last-access-time to the current\n        date
      and time.\n   3.   If the cookie-attribute-list contains an attribute with an\n
      \       attribute-name of \"Max-Age\":\n           Set the cookie's persistent-flag
      to true.\n           Set the cookie's expiry-time to attribute-value of the
      last\n           attribute in the cookie-attribute-list with an attribute-name\n
      \          of \"Max-Age\".\n        Otherwise, if the cookie-attribute-list
      contains an attribute\n        with an attribute-name of \"Expires\" (and does
      not contain an\n        attribute with an attribute-name of \"Max-Age\"):\n
      \          Set the cookie's persistent-flag to true.\n           Set the cookie's
      expiry-time to attribute-value of the last\n           attribute in the cookie-attribute-list
      with an attribute-name\n           of \"Expires\".\n        Otherwise:\n           Set
      the cookie's persistent-flag to false.\n           Set the cookie's expiry-time
      to the latest representable\n           date.\n   4.   If the cookie-attribute-list
      contains an attribute with an\n        attribute-name of \"Domain\":\n           Let
      the domain-attribute be the attribute-value of the last\n           attribute
      in the cookie-attribute-list with an attribute-name\n           of \"Domain\".\n
      \       Otherwise:\n           Let the domain-attribute be the empty string.\n
      \  5.   If the user agent is configured to reject \"public suffixes\" and\n
      \       the domain-attribute is a public suffix:\n           If the domain-attribute
      is identical to the canonicalized\n           request-host:\n              Let
      the domain-attribute be the empty string.\n           Otherwise:\n              Ignore
      the cookie entirely and abort these steps.\n           NOTE: A \"public suffix\"
      is a domain that is controlled by a\n           public registry, such as \"com\",
      \"co.uk\", and \"pvt.k12.wy.us\".\n           This step is essential for preventing
      attacker.com from\n           disrupting the integrity of example.com by setting
      a cookie\n           with a Domain attribute of \"com\".  Unfortunately, the
      set of\n           public suffixes (also known as \"registry controlled domains\")\n
      \          changes over time.  If feasible, user agents SHOULD use an\n           up-to-date
      public suffix list, such as the one maintained by\n           the Mozilla project
      at <http://publicsuffix.org/>.\n   6.   If the domain-attribute is non-empty:\n
      \          If the canonicalized request-host does not domain-match the\n           domain-attribute:\n
      \             Ignore the cookie entirely and abort these steps.\n           Otherwise:\n
      \             Set the cookie's host-only-flag to false.\n              Set the
      cookie's domain to the domain-attribute.\n        Otherwise:\n           Set
      the cookie's host-only-flag to true.\n           Set the cookie's domain to
      the canonicalized request-host.\n   7.   If the cookie-attribute-list contains
      an attribute with an\n        attribute-name of \"Path\", set the cookie's path
      to attribute-\n        value of the last attribute in the cookie-attribute-list
      with an\n        attribute-name of \"Path\".  Otherwise, set the cookie's path
      to\n        the default-path of the request-uri.\n   8.   If the cookie-attribute-list
      contains an attribute with an\n        attribute-name of \"Secure\", set the
      cookie's secure-only-flag to\n        true.  Otherwise, set the cookie's secure-only-flag
      to false.\n   9.   If the cookie-attribute-list contains an attribute with an\n
      \       attribute-name of \"HttpOnly\", set the cookie's http-only-flag to\n
      \       true.  Otherwise, set the cookie's http-only-flag to false.\n   10.
      \ If the cookie was received from a \"non-HTTP\" API and the\n        cookie's
      http-only-flag is set, abort these steps and ignore the\n        cookie entirely.\n
      \  11.  If the cookie store contains a cookie with the same name,\n        domain,
      and path as the newly created cookie:\n        1.  Let old-cookie be the existing
      cookie with the same name,\n            domain, and path as the newly created
      cookie.  (Notice that\n            this algorithm maintains the invariant that
      there is at most\n            one such cookie.)\n        2.  If the newly created
      cookie was received from a \"non-HTTP\"\n            API and the old-cookie's
      http-only-flag is set, abort these\n            steps and ignore the newly created
      cookie entirely.\n        3.  Update the creation-time of the newly created
      cookie to\n            match the creation-time of the old-cookie.\n        4.
      \ Remove the old-cookie from the cookie store.\n   12.  Insert the newly created
      cookie into the cookie store.\n   A cookie is \"expired\" if the cookie has
      an expiry date in the past.\n   The user agent MUST evict all expired cookies
      from the cookie store\n   if, at any time, an expired cookie exists in the cookie
      store.\n   At any time, the user agent MAY \"remove excess cookies\" from the\n
      \  cookie store if the number of cookies sharing a domain field exceeds\n   some
      implementation-defined upper bound (such as 50 cookies).\n   At any time, the
      user agent MAY \"remove excess cookies\" from the\n   cookie store if the cookie
      store exceeds some predetermined upper\n   bound (such as 3000 cookies).\n   When
      the user agent removes excess cookies from the cookie store, the\n   user agent
      MUST evict cookies in the following priority order:\n   1.  Expired cookies.\n
      \  2.  Cookies that share a domain field with more than a predetermined\n       number
      of other cookies.\n   3.  All cookies.\n   If two cookies have the same removal
      priority, the user agent MUST\n   evict the cookie with the earliest last-access
      date first.\n   When \"the current session is over\" (as defined by the user
      agent),\n   the user agent MUST remove from the cookie store all cookies with
      the\n   persistent-flag set to false.\n"
    title: 5.3.  Storage Model
  - contents:
    - "5.4.  The Cookie Header\n   The user agent includes stored cookies in the Cookie
      HTTP request\n   header.\n   When the user agent generates an HTTP request,
      the user agent MUST\n   NOT attach more than one Cookie header field.\n   A
      user agent MAY omit the Cookie header in its entirety.  For\n   example, the
      user agent might wish to block sending cookies during\n   \"third-party\" requests
      from setting cookies (see Section 7.1).\n   If the user agent does attach a
      Cookie header field to an HTTP\n   request, the user agent MUST send the cookie-string
      (defined below)\n   as the value of the header field.\n   The user agent MUST
      use an algorithm equivalent to the following\n   algorithm to compute the \"cookie-string\"
      from a cookie store and a\n   request-uri:\n   1.  Let cookie-list be the set
      of cookies from the cookie store that\n       meets all of the following requirements:\n
      \      *  Either:\n             The cookie's host-only-flag is true and the
      canonicalized\n             request-host is identical to the cookie's domain.\n
      \         Or:\n             The cookie's host-only-flag is false and the canonicalized\n
      \            request-host domain-matches the cookie's domain.\n       *  The
      request-uri's path path-matches the cookie's path.\n       *  If the cookie's
      secure-only-flag is true, then the request-\n          uri's scheme must denote
      a \"secure\" protocol (as defined by\n          the user agent).\n             NOTE:
      The notion of a \"secure\" protocol is not defined by\n             this document.
      \ Typically, user agents consider a protocol\n             secure if the protocol
      makes use of transport-layer\n             security, such as SSL or TLS.  For
      example, most user\n             agents consider \"https\" to be a scheme that
      denotes a\n             secure protocol.\n       *  If the cookie's http-only-flag
      is true, then exclude the\n          cookie if the cookie-string is being generated
      for a \"non-\n          HTTP\" API (as defined by the user agent).\n   2.  The
      user agent SHOULD sort the cookie-list in the following\n       order:\n       *
      \ Cookies with longer paths are listed before cookies with\n          shorter
      paths.\n       *  Among cookies that have equal-length path fields, cookies
      with\n          earlier creation-times are listed before cookies with later\n
      \         creation-times.\n       NOTE: Not all user agents sort the cookie-list
      in this order, but\n       this order reflects common practice when this document
      was\n       written, and, historically, there have been servers that\n       (erroneously)
      depended on this order.\n   3.  Update the last-access-time of each cookie in
      the cookie-list to\n       the current date and time.\n   4.  Serialize the
      cookie-list into a cookie-string by processing each\n       cookie in the cookie-list
      in order:\n       1.  Output the cookie's name, the %x3D (\"=\") character,
      and the\n           cookie's value.\n       2.  If there is an unprocessed cookie
      in the cookie-list, output\n           the characters %x3B and %x20 (\"; \").\n
      \  NOTE: Despite its name, the cookie-string is actually a sequence of\n   octets,
      not a sequence of characters.  To convert the cookie-string\n   (or components
      thereof) into a sequence of characters (e.g., for\n   presentation to the user),
      the user agent might wish to try using the\n   UTF-8 character encoding [RFC3629]
      to decode the octet sequence.\n   This decoding might fail, however, because
      not every sequence of\n   octets is valid UTF-8.\n"
    title: 5.4.  The Cookie Header
  title: 5.  User Agent Requirements
- contents:
  - '6.  Implementation Considerations

    '
  - contents:
    - "6.1.  Limits\n   Practical user agent implementations have limits on the number
      and\n   size of cookies that they can store.  General-use user agents SHOULD\n
      \  provide each of the following minimum capabilities:\n   o  At least 4096
      bytes per cookie (as measured by the sum of the\n      length of the cookie's
      name, value, and attributes).\n   o  At least 50 cookies per domain.\n   o  At
      least 3000 cookies total.\n   Servers SHOULD use as few and as small cookies
      as possible to avoid\n   reaching these implementation limits and to minimize
      network\n   bandwidth due to the Cookie header being included in every request.\n
      \  Servers SHOULD gracefully degrade if the user agent fails to return\n   one
      or more cookies in the Cookie header because the user agent might\n   evict
      any cookie at any time on orders from the user.\n"
    title: 6.1.  Limits
  - contents:
    - "6.2.  Application Programming Interfaces\n   One reason the Cookie and Set-Cookie
      headers use such esoteric syntax\n   is that many platforms (both in servers
      and user agents) provide a\n   string-based application programming interface
      (API) to cookies,\n   requiring application-layer programmers to generate and
      parse the\n   syntax used by the Cookie and Set-Cookie headers, which many\n
      \  programmers have done incorrectly, resulting in interoperability\n   problems.\n
      \  Instead of providing string-based APIs to cookies, platforms would be\n   well-served
      by providing more semantic APIs.  It is beyond the scope\n   of this document
      to recommend specific API designs, but there are\n   clear benefits to accepting
      an abstract \"Date\" object instead of a\n   serialized date string.\n"
    title: 6.2.  Application Programming Interfaces
  - contents:
    - "6.3.  IDNA Dependency and Migration\n   IDNA2008 [RFC5890] supersedes IDNA2003
      [RFC3490].  However, there are\n   differences between the two specifications,
      and thus there can be\n   differences in processing (e.g., converting) domain
      name labels that\n   have been registered under one from those registered under
      the other.\n   There will be a transition period of some time during which IDNA2003-\n
      \  based domain name labels will exist in the wild.  User agents SHOULD\n   implement
      IDNA2008 [RFC5890] and MAY implement [UTS46] or [RFC5895]\n   in order to facilitate
      their IDNA transition.  If a user agent does\n   not implement IDNA2008, the
      user agent MUST implement IDNA2003\n   [RFC3490].\n"
    title: 6.3.  IDNA Dependency and Migration
  title: 6.  Implementation Considerations
- contents:
  - "7.  Privacy Considerations\n   Cookies are often criticized for letting servers
    track users.  For\n   example, a number of \"web analytics\" companies use cookies
    to\n   recognize when a user returns to a web site or visits another web\n   site.
    \ Although cookies are not the only mechanism servers can use to\n   track users
    across HTTP requests, cookies facilitate tracking because\n   they are persistent
    across user agent sessions and can be shared\n   between hosts.\n"
  - contents:
    - "7.1.  Third-Party Cookies\n   Particularly worrisome are so-called \"third-party\"
      cookies.  In\n   rendering an HTML document, a user agent often requests resources\n
      \  from other servers (such as advertising networks).  These third-party\n   servers
      can use cookies to track the user even if the user never\n   visits the server
      directly.  For example, if a user visits a site\n   that contains content from
      a third party and then later visits\n   another site that contains content from
      the same third party, the\n   third party can track the user between the two
      sites.\n   Some user agents restrict how third-party cookies behave.  For\n
      \  example, some of these user agents refuse to send the Cookie header\n   in
      third-party requests.  Others refuse to process the Set-Cookie\n   header in
      responses to third-party requests.  User agents vary widely\n   in their third-party
      cookie policies.  This document grants user\n   agents wide latitude to experiment
      with third-party cookie policies\n   that balance the privacy and compatibility
      needs of their users.\n   However, this document does not endorse any particular
      third-party\n   cookie policy.\n   Third-party cookie blocking policies are
      often ineffective at\n   achieving their privacy goals if servers attempt to
      work around their\n   restrictions to track users.  In particular, two collaborating\n
      \  servers can often track users without using cookies at all by\n   injecting
      identifying information into dynamic URLs.\n"
    title: 7.1.  Third-Party Cookies
  - contents:
    - "7.2.  User Controls\n   User agents SHOULD provide users with a mechanism for
      managing the\n   cookies stored in the cookie store.  For example, a user agent
      might\n   let users delete all cookies received during a specified time period\n
      \  or all the cookies related to a particular domain.  In addition, many\n   user
      agents include a user interface element that lets users examine\n   the cookies
      stored in their cookie store.\n   User agents SHOULD provide users with a mechanism
      for disabling\n   cookies.  When cookies are disabled, the user agent MUST NOT
      include\n   a Cookie header in outbound HTTP requests and the user agent MUST
      NOT\n   process Set-Cookie headers in inbound HTTP responses.\n   Some user
      agents provide users the option of preventing persistent\n   storage of cookies
      across sessions.  When configured thusly, user\n   agents MUST treat all received
      cookies as if the persistent-flag were\n   set to false.  Some popular user
      agents expose this functionality via\n   \"private browsing\" mode [Aggarwal2010].\n
      \  Some user agents provide users with the ability to approve individual\n   writes
      to the cookie store.  In many common usage scenarios, these\n   controls generate
      a large number of prompts.  However, some privacy-\n   conscious users find
      these controls useful nonetheless.\n"
    title: 7.2.  User Controls
  - contents:
    - "7.3.  Expiration Dates\n   Although servers can set the expiration date for
      cookies to the\n   distant future, most user agents do not actually retain cookies
      for\n   multiple decades.  Rather than choosing gratuitously long expiration\n
      \  periods, servers SHOULD promote user privacy by selecting reasonable\n   cookie
      expiration periods based on the purpose of the cookie.  For\n   example, a typical
      session identifier might reasonably be set to\n   expire in two weeks.\n"
    title: 7.3.  Expiration Dates
  title: 7.  Privacy Considerations
- contents:
  - '8.  Security Considerations

    '
  - contents:
    - "8.1.  Overview\n   Cookies have a number of security pitfalls.  This section
      overviews a\n   few of the more salient issues.\n   In particular, cookies encourage
      developers to rely on ambient\n   authority for authentication, often becoming
      vulnerable to attacks\n   such as cross-site request forgery [CSRF].  Also,
      when storing\n   session identifiers in cookies, developers often create session\n
      \  fixation vulnerabilities.\n   Transport-layer encryption, such as that employed
      in HTTPS, is\n   insufficient to prevent a network attacker from obtaining or
      altering\n   a victim's cookies because the cookie protocol itself has various\n
      \  vulnerabilities (see \"Weak Confidentiality\" and \"Weak Integrity\",\n   below).
      \ In addition, by default, cookies do not provide\n   confidentiality or integrity
      from network attackers, even when used\n   in conjunction with HTTPS.\n"
    title: 8.1.  Overview
  - contents:
    - "8.2.  Ambient Authority\n   A server that uses cookies to authenticate users
      can suffer security\n   vulnerabilities because some user agents let remote
      parties issue\n   HTTP requests from the user agent (e.g., via HTTP redirects
      or HTML\n   forms).  When issuing those requests, user agents attach cookies
      even\n   if the remote party does not know the contents of the cookies,\n   potentially
      letting the remote party exercise authority at an unwary\n   server.\n   Although
      this security concern goes by a number of names (e.g.,\n   cross-site request
      forgery, confused deputy), the issue stems from\n   cookies being a form of
      ambient authority.  Cookies encourage server\n   operators to separate designation
      (in the form of URLs) from\n   authorization (in the form of cookies).  Consequently,
      the user agent\n   might supply the authorization for a resource designated
      by the\n   attacker, possibly causing the server or its clients to undertake\n
      \  actions designated by the attacker as though they were authorized by\n   the
      user.\n   Instead of using cookies for authorization, server operators might\n
      \  wish to consider entangling designation and authorization by treating\n   URLs
      as capabilities.  Instead of storing secrets in cookies, this\n   approach stores
      secrets in URLs, requiring the remote entity to\n   supply the secret itself.
      \ Although this approach is not a panacea,\n   judicious application of these
      principles can lead to more robust\n   security.\n"
    title: 8.2.  Ambient Authority
  - contents:
    - "8.3.  Clear Text\n   Unless sent over a secure channel (such as TLS), the information
      in\n   the Cookie and Set-Cookie headers is transmitted in the clear.\n   1.
      \ All sensitive information conveyed in these headers is exposed to\n       an
      eavesdropper.\n   2.  A malicious intermediary could alter the headers as they
      travel\n       in either direction, with unpredictable results.\n   3.  A malicious
      client could alter the Cookie header before\n       transmission, with unpredictable
      results.\n   Servers SHOULD encrypt and sign the contents of cookies (using\n
      \  whatever format the server desires) when transmitting them to the\n   user
      agent (even when sending the cookies over a secure channel).\n   However, encrypting
      and signing cookie contents does not prevent an\n   attacker from transplanting
      a cookie from one user agent to another\n   or from replaying the cookie at
      a later time.\n   In addition to encrypting and signing the contents of every
      cookie,\n   servers that require a higher level of security SHOULD use the Cookie\n
      \  and Set-Cookie headers only over a secure channel.  When using\n   cookies
      over a secure channel, servers SHOULD set the Secure\n   attribute (see Section
      4.1.2.5) for every cookie.  If a server does\n   not set the Secure attribute,
      the protection provided by the secure\n   channel will be largely moot.\n   For
      example, consider a webmail server that stores a session\n   identifier in a
      cookie and is typically accessed over HTTPS.  If the\n   server does not set
      the Secure attribute on its cookies, an active\n   network attacker can intercept
      any outbound HTTP request from the\n   user agent and redirect that request
      to the webmail server over HTTP.\n   Even if the webmail server is not listening
      for HTTP connections, the\n   user agent will still include cookies in the request.
      \ The active\n   network attacker can intercept these cookies, replay them against
      the\n   server, and learn the contents of the user's email.  If, instead, the\n
      \  server had set the Secure attribute on its cookies, the user agent\n   would
      not have included the cookies in the clear-text request.\n"
    title: 8.3.  Clear Text
  - contents:
    - "8.4.  Session Identifiers\n   Instead of storing session information directly
      in a cookie (where it\n   might be exposed to or replayed by an attacker), servers
      commonly\n   store a nonce (or \"session identifier\") in a cookie.  When the
      server\n   receives an HTTP request with a nonce, the server can look up state\n
      \  information associated with the cookie using the nonce as a key.\n   Using
      session identifier cookies limits the damage an attacker can\n   cause if the
      attacker learns the contents of a cookie because the\n   nonce is useful only
      for interacting with the server (unlike non-\n   nonce cookie content, which
      might itself be sensitive).  Furthermore,\n   using a single nonce prevents
      an attacker from \"splicing\" together\n   cookie content from two interactions
      with the server, which could\n   cause the server to behave unexpectedly.\n
      \  Using session identifiers is not without risk.  For example, the\n   server
      SHOULD take care to avoid \"session fixation\" vulnerabilities.\n   A session
      fixation attack proceeds in three steps.  First, the\n   attacker transplants
      a session identifier from his or her user agent\n   to the victim's user agent.
      \ Second, the victim uses that session\n   identifier to interact with the server,
      possibly imbuing the session\n   identifier with the user's credentials or confidential
      information.\n   Third, the attacker uses the session identifier to interact
      with\n   server directly, possibly obtaining the user's authority or\n   confidential
      information.\n"
    title: 8.4.  Session Identifiers
  - contents:
    - "8.5.  Weak Confidentiality\n   Cookies do not provide isolation by port.  If
      a cookie is readable by\n   a service running on one port, the cookie is also
      readable by a\n   service running on another port of the same server.  If a
      cookie is\n   writable by a service on one port, the cookie is also writable
      by a\n   service running on another port of the same server.  For this reason,\n
      \  servers SHOULD NOT both run mutually distrusting services on\n   different
      ports of the same host and use cookies to store security-\n   sensitive information.\n
      \  Cookies do not provide isolation by scheme.  Although most commonly\n   used
      with the http and https schemes, the cookies for a given host\n   might also
      be available to other schemes, such as ftp and gopher.\n   Although this lack
      of isolation by scheme is most apparent in non-\n   HTTP APIs that permit access
      to cookies (e.g., HTML's document.cookie\n   API), the lack of isolation by
      scheme is actually present in\n   requirements for processing cookies themselves
      (e.g., consider\n   retrieving a URI with the gopher scheme via HTTP).\n   Cookies
      do not always provide isolation by path.  Although the\n   network-level protocol
      does not send cookies stored for one path to\n   another, some user agents expose
      cookies via non-HTTP APIs, such as\n   HTML's document.cookie API.  Because
      some of these user agents (e.g.,\n   web browsers) do not isolate resources
      received from different paths,\n   a resource retrieved from one path might
      be able to access cookies\n   stored for another path.\n"
    title: 8.5.  Weak Confidentiality
  - contents:
    - "8.6.  Weak Integrity\n   Cookies do not provide integrity guarantees for sibling
      domains (and\n   their subdomains).  For example, consider foo.example.com and\n
      \  bar.example.com.  The foo.example.com server can set a cookie with a\n   Domain
      attribute of \"example.com\" (possibly overwriting an existing\n   \"example.com\"
      cookie set by bar.example.com), and the user agent will\n   include that cookie
      in HTTP requests to bar.example.com.  In the\n   worst case, bar.example.com
      will be unable to distinguish this cookie\n   from a cookie it set itself.  The
      foo.example.com server might be\n   able to leverage this ability to mount an
      attack against\n   bar.example.com.\n   Even though the Set-Cookie header supports
      the Path attribute, the\n   Path attribute does not provide any integrity protection
      because the\n   user agent will accept an arbitrary Path attribute in a Set-Cookie\n
      \  header.  For example, an HTTP response to a request for\n   http://example.com/foo/bar
      can set a cookie with a Path attribute of\n   \"/qux\".  Consequently, servers
      SHOULD NOT both run mutually\n   distrusting services on different paths of
      the same host and use\n   cookies to store security-sensitive information.\n
      \  An active network attacker can also inject cookies into the Cookie\n   header
      sent to https://example.com/ by impersonating a response from\n   http://example.com/
      and injecting a Set-Cookie header.  The HTTPS\n   server at example.com will
      be unable to distinguish these cookies\n   from cookies that it set itself in
      an HTTPS response.  An active\n   network attacker might be able to leverage
      this ability to mount an\n   attack against example.com even if example.com
      uses HTTPS\n   exclusively.\n   Servers can partially mitigate these attacks
      by encrypting and\n   signing the contents of their cookies.  However, using
      cryptography\n   does not mitigate the issue completely because an attacker
      can replay\n   a cookie he or she received from the authentic example.com server
      in\n   the user's session, with unpredictable results.\n   Finally, an attacker
      might be able to force the user agent to delete\n   cookies by storing a large
      number of cookies.  Once the user agent\n   reaches its storage limit, the user
      agent will be forced to evict\n   some cookies.  Servers SHOULD NOT rely upon
      user agents retaining\n   cookies.\n"
    title: 8.6.  Weak Integrity
  - contents:
    - "8.7.  Reliance on DNS\n   Cookies rely upon the Domain Name System (DNS) for
      security.  If the\n   DNS is partially or fully compromised, the cookie protocol
      might fail\n   to provide the security properties required by applications.\n"
    title: 8.7.  Reliance on DNS
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   The permanent message header field registry (see
    [RFC3864]) has been\n   updated with the following registrations.\n"
  - contents:
    - "9.1.  Cookie\n   Header field name: Cookie\n   Applicable protocol: http\n
      \  Status: standard\n   Author/Change controller: IETF\n   Specification document:
      this specification (Section 5.4)\n"
    title: 9.1.  Cookie
  - contents:
    - "9.2.  Set-Cookie\n   Header field name: Set-Cookie\n   Applicable protocol:
      http\n   Status: standard\n   Author/Change controller: IETF\n   Specification
      document: this specification (Section 5.2)\n"
    title: 9.2.  Set-Cookie
  - contents:
    - "9.3.  Cookie2\n   Header field name: Cookie2\n   Applicable protocol: http\n
      \  Status: obsoleted\n   Author/Change controller: IETF\n   Specification document:
      [RFC2965]\n"
    title: 9.3.  Cookie2
  - contents:
    - "9.4.  Set-Cookie2\n   Header field name: Set-Cookie2\n   Applicable protocol:
      http\n   Status: obsoleted\n   Author/Change controller: IETF\n   Specification
      document: [RFC2965]\n"
    title: 9.4.  Set-Cookie2
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names
      - concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n
      \  [RFC1123]  Braden, R., \"Requirements for Internet Hosts - Application\n
      \             and Support\", STD 3, RFC 1123, October 1989.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2616]  Fielding, R., Gettys, J., Mogul,
      J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee,
      \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n
      \  [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,\n              \"Internationalizing
      Domain Names in Applications (IDNA)\",\n              RFC 3490, March 2003.\n
      \             See Section 6.3 for an explanation why the normative\n              reference
      to an obsoleted specification is needed.\n   [RFC4790]  Newman, C., Duerst,
      M., and A. Gulbrandsen, \"Internet\n              Application Protocol Collation
      Registry\", RFC 4790,\n              March 2007.\n   [RFC5234]  Crocker, D.,
      Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC5890]  Klensin, J., \"Internationalized
      Domain Names for\n              Applications (IDNA): Definitions and Document
      Framework\",\n              RFC 5890, August 2010.\n   [USASCII]  American National
      Standards Institute, \"Coded Character\n              Set -- 7-bit American
      Standard Code for Information\n              Interchange\", ANSI X3.4, 1986.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC2109]  Kristol, D. and L. Montulli, \"HTTP
      State Management\n              Mechanism\", RFC 2109, February 1997.\n   [RFC2965]
      \ Kristol, D. and L. Montulli, \"HTTP State Management\n              Mechanism\",
      RFC 2965, October 2000.\n   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC
      2818, May 2000.\n   [Netscape] Netscape Communications Corp., \"Persistent Client
      State --\n              HTTP Cookies\", 1999, <http://web.archive.org/web/\n
      \             20020803110822/http://wp.netscape.com/newsref/std/\n              cookie_spec.html>.\n
      \  [Kri2001]  Kristol, D., \"HTTP Cookies: Standards, Privacy, and\n              Politics\",
      ACM Transactions on Internet Technology Vol. 1,\n              #2, November
      2001, <http://arxiv.org/abs/cs.SE/0105018>.\n   [RFC3629]  Yergeau, F., \"UTF-8,
      a transformation format of ISO\n              10646\", STD 63, RFC 3629, November
      2003.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n
      \             Encodings\", RFC 4648, October 2006.\n   [RFC3864]  Klyne, G.,
      Nottingham, M., and J. Mogul, \"Registration\n              Procedures for Message
      Header Fields\", BCP 90, RFC 3864,\n              September 2004.\n   [RFC5895]
      \ Resnick, P. and P. Hoffman, \"Mapping Characters for\n              Internationalized
      Domain Names in Applications (IDNA)\n              2008\", RFC 5895, September
      2010.\n   [UTS46]    Davis, M. and M. Suignard, \"Unicode IDNA Compatibility\n
      \             Processing\", Unicode Technical Standards # 46, 2010,\n              <http://unicode.org/reports/tr46/>.\n
      \  [CSRF]     Barth, A., Jackson, C., and J. Mitchell, \"Robust Defenses\n              for
      Cross-Site Request Forgery\", 2008,\n              <http://portal.acm.org/citation.cfm?id=1455770.1455782>.\n
      \  [Aggarwal2010]\n              Aggarwal, G., Burzstein, E., Jackson, C., and
      D. Boneh,\n              \"An Analysis of Private Browsing Modes in Modern\n
      \             Browsers\", 2010, <http://www.usenix.org/events/sec10/tech/\n
      \             full_papers/Aggarwal.pdf>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Acknowledgements\n   This document borrows heavily from RFC 2109
    [RFC2109].  We are\n   indebted to David M. Kristol and Lou Montulli for their
    efforts to\n   specify cookies.  David M. Kristol, in particular, provided\n   invaluable
    advice on navigating the IETF process.  We would also like\n   to thank Thomas
    Broyer, Tyler Close, Alissa Cooper, Bil Corry,\n   corvid, Lisa Dusseault, Roy
    T. Fielding, Blake Frantz, Anne van\n   Kesteren, Eran Hammer-Lahav, Jeff Hodges,
    Bjoern Hoehrmann, Achim\n   Hoffmann, Georg Koppen, Dean McNamee, Alexey Melnikov,
    Mark Miller,\n   Mark Pauley, Yngve N. Pettersen, Julian Reschke, Peter Saint-Andre,\n
    \  Mark Seaborn, Maciej Stachowiak, Daniel Stenberg, Tatsuhiro\n   Tsujikawa,
    David Wagner, Dan Winship, and Dan Witte for their\n   valuable feedback on this
    document.\n"
  title: Appendix A.  Acknowledgements
- contents:
  - "Author's Address\n   Adam Barth\n   University of California, Berkeley\n   EMail:
    abarth@eecs.berkeley.edu\n   URI:   http://www.adambarth.com/\n"
  title: Author's Address
