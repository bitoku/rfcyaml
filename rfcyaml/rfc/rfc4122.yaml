- contents:
  - '          A Universally Unique IDentifier (UUID) URN Namespace

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This specification defines a Uniform Resource Name namespace for\n
    \  UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally\n   Unique
    IDentifier).  A UUID is 128 bits long, and can guarantee\n   uniqueness across
    space and time.  UUIDs were originally used in the\n   Apollo Network Computing
    System and later in the Open Software\n   Foundation's (OSF) Distributed Computing
    Environment (DCE), and then\n   in Microsoft Windows platforms.\n   This specification
    is derived from the DCE specification with the\n   kind permission of the OSF
    (now known as The Open Group).\n   Information from earlier versions of the DCE
    specification have been\n   incorporated into this document.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction . . . . . . . . . . . . . . . . . . . .
    . . . . .  2\n   2. Motivation . . . . . . . . . . . . . . . . . . . . . . . .
    . .  3\n   3. Namespace Registration Template  . . . . . . . . . . . . . . .  3\n
    \  4. Specification  . . . . . . . . . . . . . . . . . . . . . . . .  5\n      4.1.
    Format. . . . . . . . . . . . . . . . . . . . . . . . . .  5\n           4.1.1.
    Variant. . . . . . . . . . . . . . . . . . . . . .  6\n           4.1.2. Layout
    and Byte Order. . . . . . . . . . . . . . .  6\n           4.1.3. Version. . .
    . . . . . . . . . . . . . . . . . . .  7\n           4.1.4. Timestamp. . . . .
    . . . . . . . . . . . . . . . .  8\n           4.1.5. Clock Sequence . . . . .
    . . . . . . . . . . . . .  8\n           4.1.6. Node . . . . . . . . . . . . .
    . . . . . . . . . .  9\n           4.1.7. Nil UUID . . . . . . . . . . . . . .
    . . . . . . .  9\n      4.2. Algorithms for Creating a Time-Based UUID . . . .
    . . . .  9\n           4.2.1. Basic Algorithm. . . . . . . . . . . . . . . . .
    . 10\n           4.2.2. Generation Details . . . . . . . . . . . . . . . . 12\n
    \     4.3. Algorithm for Creating a Name-Based UUID. . . . . . . . . 13\n      4.4.
    Algorithms for Creating a UUID from Truly Random or\n           Pseudo-Random
    Numbers . . . . . . . . . . . . . . . . . . 14\n      4.5. Node IDs that Do Not
    Identify the Host. . . . . . . . . . 15\n   5. Community Considerations . . .
    . . . . . . . . . . . . . . . . 15\n   6. Security Considerations  . . . . . .
    . . . . . . . . . . . . . 16\n   7. Acknowledgments  . . . . . . . . . . . . .
    . . . . . . . . . . 16\n   8. Normative References . . . . . . . . . . . . . .
    . . . . . . . 16\n   A. Appendix A - Sample Implementation . . . . . . . . . .
    . . . . 18\n   B. Appendix B - Sample Output of utest  . . . . . . . . . . . .
    . 29\n   C. Appendix C - Some Name Space IDs . . . . . . . . . . . . . . . 30\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This specification defines a Uniform Resource Name namespace
    for\n   UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally\n
    \  Unique IDentifier).  A UUID is 128 bits long, and requires no central\n   registration
    process.\n   The information here is meant to be a concise guide for those wishing\n
    \  to implement services using UUIDs as URNs.  Nothing in this document\n   should
    be construed to override the DCE standards that defined UUIDs.\n   There is an
    ITU-T Recommendation and ISO/IEC Standard [3] that are\n   derived from earlier
    versions of this document.  Both sets of\n   specifications have been aligned,
    and are fully technically\n   compatible.  In addition, a global registration
    function is being\n   provided by the Telecommunications Standardisation Bureau
    of ITU-T;\n   for details see <http://www.itu.int/ITU-T/asn1/uuid.html>.\n"
  title: 1.  Introduction
- contents:
  - "2.  Motivation\n   One of the main reasons for using UUIDs is that no centralized\n
    \  authority is required to administer them (although one format uses\n   IEEE
    802 node identifiers, others do not).  As a result, generation\n   on demand can
    be completely automated, and used for a variety of\n   purposes.  The UUID generation
    algorithm described here supports very\n   high allocation rates of up to 10 million
    per second per machine if\n   necessary, so that they could even be used as transaction
    IDs.\n   UUIDs are of a fixed size (128 bits) which is reasonably small\n   compared
    to other alternatives.  This lends itself well to sorting,\n   ordering, and hashing
    of all sorts, storing in databases, simple\n   allocation, and ease of programming
    in general.\n   Since UUIDs are unique and persistent, they make excellent Uniform\n
    \  Resource Names.  The unique ability to generate a new UUID without a\n   registration
    process allows for UUIDs to be one of the URNs with the\n   lowest minting cost.\n"
  title: 2.  Motivation
- contents:
  - "3.  Namespace Registration Template\n   Namespace ID:  UUID\n   Registration
    Information:\n      Registration date: 2003-10-01\n   Declared registrant of the
    namespace:\n      JTC 1/SC6 (ASN.1 Rapporteur Group)\n   Declaration of syntactic
    structure:\n      A UUID is an identifier that is unique across both space and
    time,\n      with respect to the space of all UUIDs.  Since a UUID is a fixed\n
    \     size and contains a time field, it is possible for values to\n      rollover
    (around A.D. 3400, depending on the specific algorithm\n      used).  A UUID can
    be used for multiple purposes, from tagging\n      objects with an extremely short
    lifetime, to reliably identifying\n      very persistent objects across a network.\n
    \     The internal representation of a UUID is a specific sequence of\n      bits
    in memory, as described in Section 4.  To accurately\n      represent a UUID as
    a URN, it is necessary to convert the bit\n      sequence to a string representation.\n
    \     Each field is treated as an integer and has its value printed as a\n      zero-filled
    hexadecimal digit string with the most significant\n      digit first.  The hexadecimal
    values \"a\" through \"f\" are output as\n      lower case characters and are
    case insensitive on input.\n      The formal definition of the UUID string representation
    is\n      provided by the following ABNF [7]:\n      UUID                   =
    time-low \"-\" time-mid \"-\"\n                               time-high-and-version
    \"-\"\n                               clock-seq-and-reserved\n                               clock-seq-low
    \"-\" node\n      time-low               = 4hexOctet\n      time-mid               =
    2hexOctet\n      time-high-and-version  = 2hexOctet\n      clock-seq-and-reserved
    = hexOctet\n      clock-seq-low          = hexOctet\n      node                   =
    6hexOctet\n      hexOctet               = hexDigit hexDigit\n      hexDigit =\n
    \           \"0\" / \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\"
    / \"9\" /\n            \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\" /\n            \"A\"
    / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n   The following is an example of the
    string representation of a UUID as\n   a URN:\n   urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\n
    \  Relevant ancillary documentation:\n      [1][2]\n   Identifier uniqueness considerations:\n
    \     This document specifies three algorithms to generate UUIDs: the\n      first
    leverages the unique values of 802 MAC addresses to\n      guarantee uniqueness,
    the second uses pseudo-random number\n      generators, and the third uses cryptographic
    hashing and\n      application-provided text strings.  As a result, the UUIDs\n
    \     generated according to the mechanisms here will be unique from all\n      other
    UUIDs that have been or will be assigned.\n   Identifier persistence considerations:\n
    \     UUIDs are inherently very difficult to resolve in a global sense.\n      This,
    coupled with the fact that UUIDs are temporally unique\n      within their spatial
    context, ensures that UUIDs will remain as\n      persistent as possible.\n   Process
    of identifier assignment:\n      Generating a UUID does not require that a registration
    authority\n      be contacted.  One algorithm requires a unique value over space\n
    \     for each generator.  This value is typically an IEEE 802 MAC\n      address,
    usually already available on network-connected hosts.\n      The address can be
    assigned from an address block obtained from\n      the IEEE registration authority.
    \ If no such address is available,\n      or privacy concerns make its use undesirable,
    Section 4.5\n      specifies two alternatives.  Another approach is to use version
    3\n      or version 4 UUIDs as defined below.\n   Process for identifier resolution:\n
    \     Since UUIDs are not globally resolvable, this is not applicable.\n   Rules
    for Lexical Equivalence:\n      Consider each field of the UUID to be an unsigned
    integer as shown\n      in the table in section Section 4.1.2.  Then, to compare
    a pair of\n      UUIDs, arithmetically compare the corresponding fields from each\n
    \     UUID in order of significance and according to their data type.\n      Two
    UUIDs are equal if and only if all the corresponding fields\n      are equal.\n
    \     As an implementation note, equality comparison can be performed on\n      many
    systems by doing the appropriate byte-order canonicalization,\n      and then
    treating the two UUIDs as 128-bit unsigned integers.\n      UUIDs, as defined
    in this document, can also be ordered\n      lexicographically.  For a pair of
    UUIDs, the first one follows the\n      second if the most significant field in
    which the UUIDs differ is\n      greater for the first UUID.  The second precedes
    the first if the\n      most significant field in which the UUIDs differ is greater
    for\n      the second UUID.\n   Conformance with URN Syntax:\n      The string
    representation of a UUID is fully compatible with the\n      URN syntax.  When
    converting from a bit-oriented, in-memory\n      representation of a UUID into
    a URN, care must be taken to\n      strictly adhere to the byte order issues mentioned
    in the string\n      representation section.\n   Validation mechanism:\n      Apart
    from determining whether the timestamp portion of the UUID\n      is in the future
    and therefore not yet assignable, there is no\n      mechanism for determining
    whether a UUID is 'valid'.\n   Scope:\n      UUIDs are global in scope.\n"
  title: 3.  Namespace Registration Template
- contents:
  - '4.  Specification

    '
  - contents:
    - "4.1.  Format\n   The UUID format is 16 octets; some bits of the eight octet
      variant\n   field specified below determine finer structure.\n"
    - contents:
      - "4.1.1.  Variant\n   The variant field determines the layout of the UUID.
        \ That is, the\n   interpretation of all other bits in the UUID depends on
        the setting\n   of the bits in the variant field.  As such, it could more
        accurately\n   be called a type field; we retain the original term for\n   compatibility.
        \ The variant field consists of a variable number of\n   the most significant
        bits of octet 8 of the UUID.\n   The following table lists the contents of
        the variant field, where\n   the letter \"x\" indicates a \"don't-care\" value.\n
        \  Msb0  Msb1  Msb2  Description\n    0     x     x    Reserved, NCS backward
        compatibility.\n    1     0     x    The variant specified in this document.\n
        \   1     1     0    Reserved, Microsoft Corporation backward\n                     compatibility\n
        \   1     1     1    Reserved for future definition.\n   Interoperability,
        in any form, with variants other than the one\n   defined here is not guaranteed,
        and is not likely to be an issue in\n   practice.\n"
      title: 4.1.1.  Variant
    - contents:
      - "4.1.2.  Layout and Byte Order\n   To minimize confusion about bit assignments
        within octets, the UUID\n   record definition is defined only in terms of
        fields that are\n   integral numbers of octets.  The fields are presented
        with the most\n   significant one first.\n   Field                  Data Type
        \    Octet  Note\n                                        #\n   time_low               unsigned
        32   0-3    The low field of the\n                          bit integer          timestamp\n
        \  time_mid               unsigned 16   4-5    The middle field of the\n                          bit
        integer          timestamp\n   time_hi_and_version    unsigned 16   6-7    The
        high field of the\n                          bit integer          timestamp
        multiplexed\n                                               with the version
        number\n   clock_seq_hi_and_rese  unsigned 8    8      The high field of the\n
        \  rved                   bit integer          clock sequence\n                                               multiplexed
        with the\n                                               variant\n   clock_seq_low
        \         unsigned 8    9      The low field of the\n                          bit
        integer          clock sequence\n   node                   unsigned 48   10-15
        \ The spatially unique\n                          bit integer          node
        identifier\n   In the absence of explicit application or presentation protocol\n
        \  specification to the contrary, a UUID is encoded as a 128-bit object,\n
        \  as follows:\n   The fields are encoded as 16 octets, with the sizes and
        order of the\n   fields defined above, and with each field encoded with the
        Most\n   Significant Byte first (known as network byte order).  Note that
        the\n   field names, particularly for multiplexed fields, follow historical\n
        \  practice.\n   0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          time_low                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |       time_mid                |         time_hi_and_version   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                         node (2-5)                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
      title: 4.1.2.  Layout and Byte Order
    - contents:
      - "4.1.3.  Version\n   The version number is in the most significant 4 bits
        of the time\n   stamp (bits 4 through 7 of the time_hi_and_version field).\n
        \  The following table lists the currently-defined versions for this\n   UUID
        variant.\n   Msb0  Msb1  Msb2  Msb3   Version  Description\n    0     0     0
        \    1        1     The time-based version\n                                     specified
        in this document.\n    0     0     1     0        2     DCE Security version,
        with\n                                     embedded POSIX UIDs.\n    0     0
        \    1     1        3     The name-based version\n                                     specified
        in this document\n                                     that uses MD5 hashing.\n
        \   0     1     0     0        4     The randomly or pseudo-\n                                     randomly
        generated version\n                                     specified in this
        document.\n    0     1     0     1        5     The name-based version\n                                     specified
        in this document\n                                     that uses SHA-1 hashing.\n
        \  The version is more accurately a sub-type; again, we retain the term\n
        \  for compatibility.\n"
      title: 4.1.3.  Version
    - contents:
      - "4.1.4.  Timestamp\n   The timestamp is a 60-bit value.  For UUID version
        1, this is\n   represented by Coordinated Universal Time (UTC) as a count
        of 100-\n   nanosecond intervals since 00:00:00.00, 15 October 1582 (the date
        of\n   Gregorian reform to the Christian calendar).\n   For systems that do
        not have UTC available, but do have the local\n   time, they may use that
        instead of UTC, as long as they do so\n   consistently throughout the system.
        \ However, this is not recommended\n   since generating the UTC from local
        time only needs a time zone\n   offset.\n   For UUID version 3 or 5, the timestamp
        is a 60-bit value constructed\n   from a name as described in Section 4.3.\n
        \  For UUID version 4, the timestamp is a randomly or pseudo-randomly\n   generated
        60-bit value, as described in Section 4.4.\n"
      title: 4.1.4.  Timestamp
    - contents:
      - "4.1.5.  Clock Sequence\n   For UUID version 1, the clock sequence is used
        to help avoid\n   duplicates that could arise when the clock is set backwards
        in time\n   or if the node ID changes.\n   If the clock is set backwards,
        or might have been set backwards\n   (e.g., while the system was powered off),
        and the UUID generator can\n   not be sure that no UUIDs were generated with
        timestamps larger than\n   the value to which the clock was set, then the
        clock sequence has to\n   be changed.  If the previous value of the clock
        sequence is known, it\n   can just be incremented; otherwise it should be
        set to a random or\n   high-quality pseudo-random value.\n   Similarly, if
        the node ID changes (e.g., because a network card has\n   been moved between
        machines), setting the clock sequence to a random\n   number minimizes the
        probability of a duplicate due to slight\n   differences in the clock settings
        of the machines.  If the value of\n   clock sequence associated with the changed
        node ID were known, then\n   the clock sequence could just be incremented,
        but that is unlikely.\n   The clock sequence MUST be originally (i.e., once
        in the lifetime of\n   a system) initialized to a random number to minimize
        the correlation\n   across systems.  This provides maximum protection against
        node\n   identifiers that may move or switch from system to system rapidly.\n
        \  The initial value MUST NOT be correlated to the node identifier.\n   For
        UUID version 3 or 5, the clock sequence is a 14-bit value\n   constructed
        from a name as described in Section 4.3.\n   For UUID version 4, clock sequence
        is a randomly or pseudo-randomly\n   generated 14-bit value as described in
        Section 4.4.\n"
      title: 4.1.5.  Clock Sequence
    - contents:
      - "4.1.6.  Node\n   For UUID version 1, the node field consists of an IEEE 802
        MAC\n   address, usually the host address.  For systems with multiple IEEE\n
        \  802 addresses, any available one can be used.  The lowest addressed\n   octet
        (octet number 10) contains the global/local bit and the\n   unicast/multicast
        bit, and is the first octet of the address\n   transmitted on an 802.3 LAN.\n
        \  For systems with no IEEE address, a randomly or pseudo-randomly\n   generated
        value may be used; see Section 4.5.  The multicast bit must\n   be set in
        such addresses, in order that they will never conflict with\n   addresses
        obtained from network cards.\n   For UUID version 3 or 5, the node field is
        a 48-bit value constructed\n   from a name as described in Section 4.3.\n
        \  For UUID version 4, the node field is a randomly or pseudo-randomly\n   generated
        48-bit value as described in Section 4.4.\n"
      title: 4.1.6.  Node
    - contents:
      - "4.1.7.  Nil UUID\n   The nil UUID is special form of UUID that is specified
        to have all\n   128 bits set to zero.\n"
      title: 4.1.7.  Nil UUID
    title: 4.1.  Format
  - contents:
    - "4.2.  Algorithms for Creating a Time-Based UUID\n   Various aspects of the
      algorithm for creating a version 1 UUID are\n   discussed in the following sections.\n"
    - contents:
      - "4.2.1.  Basic Algorithm\n   The following algorithm is simple, correct, and
        inefficient:\n   o  Obtain a system-wide global lock\n   o  From a system-wide
        shared stable store (e.g., a file), read the\n      UUID generator state:
        the values of the timestamp, clock sequence,\n      and node ID used to generate
        the last UUID.\n   o  Get the current time as a 60-bit count of 100-nanosecond
        intervals\n      since 00:00:00.00, 15 October 1582.\n   o  Get the current
        node ID.\n   o  If the state was unavailable (e.g., non-existent or corrupted),
        or\n      the saved node ID is different than the current node ID, generate\n
        \     a random clock sequence value.\n   o  If the state was available, but
        the saved timestamp is later than\n      the current timestamp, increment
        the clock sequence value.\n   o  Save the state (current timestamp, clock
        sequence, and node ID)\n      back to the stable store.\n   o  Release the
        global lock.\n   o  Format a UUID from the current timestamp, clock sequence,
        and node\n      ID values according to the steps in Section 4.2.2.\n   If
        UUIDs do not need to be frequently generated, the above algorithm\n   may
        be perfectly adequate.  For higher performance requirements,\n   however,
        issues with the basic algorithm include:\n   o  Reading the state from stable
        storage each time is inefficient.\n   o  The resolution of the system clock
        may not be 100-nanoseconds.\n   o  Writing the state to stable storage each
        time is inefficient.\n   o  Sharing the state across process boundaries may
        be inefficient.\n   Each of these issues can be addressed in a modular fashion
        by local\n   improvements in the functions that read and write the state and
        read\n   the clock.  We address each of them in turn in the following\n   sections.\n"
      - contents:
        - "4.2.1.1.  Reading Stable Storage\n   The state only needs to be read from
          stable storage once at boot\n   time, if it is read into a system-wide shared
          volatile store (and\n   updated whenever the stable store is updated).\n
          \  If an implementation does not have any stable store available, then\n
          \  it can always say that the values were unavailable.  This is the\n   least
          desirable implementation because it will increase the frequency\n   of creation
          of new clock sequence numbers, which increases the\n   probability of duplicates.\n
          \  If the node ID can never change (e.g., the net card is inseparable\n
          \  from the system), or if any change also reinitializes the clock\n   sequence
          to a random value, then instead of keeping it in stable\n   store, the current
          node ID may be returned.\n"
        title: 4.2.1.1.  Reading Stable Storage
      - contents:
        - "4.2.1.2.  System Clock Resolution\n   The timestamp is generated from the
          system time, whose resolution may\n   be less than the resolution of the
          UUID timestamp.\n   If UUIDs do not need to be frequently generated, the
          timestamp can\n   simply be the system time multiplied by the number of
          100-nanosecond\n   intervals per system time interval.\n   If a system overruns
          the generator by requesting too many UUIDs\n   within a single system time
          interval, the UUID service MUST either\n   return an error, or stall the
          UUID generator until the system clock\n   catches up.\n   A high resolution
          timestamp can be simulated by keeping a count of\n   the number of UUIDs
          that have been generated with the same value of\n   the system time, and
          using it to construct the low order bits of the\n   timestamp.  The count
          will range between zero and the number of\n   100-nanosecond intervals per
          system time interval.\n   Note: If the processors overrun the UUID generation
          frequently,\n   additional node identifiers can be allocated to the system,
          which\n   will permit higher speed allocation by making multiple UUIDs\n
          \  potentially available for each time stamp value.\n"
        title: 4.2.1.2.  System Clock Resolution
      - contents:
        - "4.2.1.3.  Writing Stable Storage\n   The state does not always need to
          be written to stable store every\n   time a UUID is generated.  The timestamp
          in the stable store can be\n   periodically set to a value larger than any
          yet used in a UUID.  As\n   long as the generated UUIDs have timestamps
          less than that value, and\n   the clock sequence and node ID remain unchanged,
          only the shared\n   volatile copy of the state needs to be updated.  Furthermore,
          if the\n   timestamp value in stable store is in the future by less than
          the\n   typical time it takes the system to reboot, a crash will not cause
          a\n   reinitialization of the clock sequence.\n"
        title: 4.2.1.3.  Writing Stable Storage
      - contents:
        - "4.2.1.4.  Sharing State Across Processes\n   If it is too expensive to
          access shared state each time a UUID is\n   generated, then the system-wide
          generator can be implemented to\n   allocate a block of time stamps each
          time it is called; a per-\n   process generator can allocate from that block
          until it is exhausted.\n"
        title: 4.2.1.4.  Sharing State Across Processes
      title: 4.2.1.  Basic Algorithm
    - contents:
      - "4.2.2.  Generation Details\n   Version 1 UUIDs are generated according to
        the following algorithm:\n   o  Determine the values for the UTC-based timestamp
        and clock\n      sequence to be used in the UUID, as described in Section
        4.2.1.\n   o  For the purposes of this algorithm, consider the timestamp to
        be a\n      60-bit unsigned integer and the clock sequence to be a 14-bit\n
        \     unsigned integer.  Sequentially number the bits in a field,\n      starting
        with zero for the least significant bit.\n   o  Set the time_low field equal
        to the least significant 32 bits\n      (bits zero through 31) of the timestamp
        in the same order of\n      significance.\n   o  Set the time_mid field equal
        to bits 32 through 47 from the\n      timestamp in the same order of significance.\n
        \  o  Set the 12 least significant bits (bits zero through 11) of the\n      time_hi_and_version
        field equal to bits 48 through 59 from the\n      timestamp in the same order
        of significance.\n   o  Set the four most significant bits (bits 12 through
        15) of the\n      time_hi_and_version field to the 4-bit version number\n
        \     corresponding to the UUID version being created, as shown in the\n      table
        above.\n   o  Set the clock_seq_low field to the eight least significant bits\n
        \     (bits zero through 7) of the clock sequence in the same order of\n      significance.\n
        \  o  Set the 6 least significant bits (bits zero through 5) of the\n      clock_seq_hi_and_reserved
        field to the 6 most significant bits\n      (bits 8 through 13) of the clock
        sequence in the same order of\n      significance.\n   o  Set the two most
        significant bits (bits 6 and 7) of the\n      clock_seq_hi_and_reserved to
        zero and one, respectively.\n   o  Set the node field to the 48-bit IEEE address
        in the same order of\n      significance as the address.\n"
      title: 4.2.2.  Generation Details
    title: 4.2.  Algorithms for Creating a Time-Based UUID
  - contents:
    - "4.3.  Algorithm for Creating a Name-Based UUID\n   The version 3 or 5 UUID
      is meant for generating UUIDs from \"names\"\n   that are drawn from, and unique
      within, some \"name space\".  The\n   concept of name and name space should
      be broadly construed, and not\n   limited to textual names.  For example, some
      name spaces are the\n   domain name system, URLs, ISO Object IDs (OIDs), X.500
      Distinguished\n   Names (DNs), and reserved words in a programming language.
      \ The\n   mechanisms or conventions used for allocating names and ensuring\n
      \  their uniqueness within their name spaces are beyond the scope of\n   this
      specification.\n   The requirements for these types of UUIDs are as follows:\n
      \  o  The UUIDs generated at different times from the same name in the\n      same
      namespace MUST be equal.\n   o  The UUIDs generated from two different names
      in the same namespace\n      should be different (with very high probability).\n
      \  o  The UUIDs generated from the same name in two different namespaces\n      should
      be different with (very high probability).\n   o  If two UUIDs that were generated
      from names are equal, then they\n      were generated from the same name in
      the same namespace (with very\n      high probability).\n   The algorithm for
      generating a UUID from a name and a name space are\n   as follows:\n   o  Allocate
      a UUID to use as a \"name space ID\" for all UUIDs\n      generated from names
      in that name space; see Appendix C for some\n      pre-defined values.\n   o
      \ Choose either MD5 [4] or SHA-1 [8] as the hash algorithm; If\n      backward
      compatibility is not an issue, SHA-1 is preferred.\n   o  Convert the name to
      a canonical sequence of octets (as defined by\n      the standards or conventions
      of its name space); put the name\n      space ID in network byte order.\n   o
      \ Compute the hash of the name space ID concatenated with the name.\n   o  Set
      octets zero through 3 of the time_low field to octets zero\n      through 3
      of the hash.\n   o  Set octets zero and one of the time_mid field to octets
      4 and 5 of\n      the hash.\n   o  Set octets zero and one of the time_hi_and_version
      field to octets\n      6 and 7 of the hash.\n   o  Set the four most significant
      bits (bits 12 through 15) of the\n      time_hi_and_version field to the appropriate
      4-bit version number\n      from Section 4.1.3.\n   o  Set the clock_seq_hi_and_reserved
      field to octet 8 of the hash.\n   o  Set the two most significant bits (bits
      6 and 7) of the\n      clock_seq_hi_and_reserved to zero and one, respectively.\n
      \  o  Set the clock_seq_low field to octet 9 of the hash.\n   o  Set octets
      zero through five of the node field to octets 10\n      through 15 of the hash.\n
      \  o  Convert the resulting UUID to local byte order.\n"
    title: 4.3.  Algorithm for Creating a Name-Based UUID
  - contents:
    - "4.4.  Algorithms for Creating a UUID from Truly Random or\n      Pseudo-Random
      Numbers\n   The version 4 UUID is meant for generating UUIDs from truly-random
      or\n   pseudo-random numbers.\n   The algorithm is as follows:\n   o  Set the
      two most significant bits (bits 6 and 7) of the\n      clock_seq_hi_and_reserved
      to zero and one, respectively.\n   o  Set the four most significant bits (bits
      12 through 15) of the\n      time_hi_and_version field to the 4-bit version
      number from\n      Section 4.1.3.\n   o  Set all the other bits to randomly
      (or pseudo-randomly) chosen\n      values.\n   See Section 4.5 for a discussion
      on random numbers.\n"
    title: 4.4.  Algorithms for Creating a UUID from Truly Random or
  - contents:
    - "4.5.  Node IDs that Do Not Identify the Host\n   This section describes how
      to generate a version 1 UUID if an IEEE\n   802 address is not available, or
      its use is not desired.\n   One approach is to contact the IEEE and get a separate
      block of\n   addresses.  At the time of writing, the application could be found
      at\n   <http://standards.ieee.org/regauth/oui/pilot-ind.html>, and the cost\n
      \  was US$550.\n   A better solution is to obtain a 47-bit cryptographic quality
      random\n   number and use it as the low 47 bits of the node ID, with the least\n
      \  significant bit of the first octet of the node ID set to one.  This\n   bit
      is the unicast/multicast bit, which will never be set in IEEE 802\n   addresses
      obtained from network cards.  Hence, there can never be a\n   conflict between
      UUIDs generated by machines with and without network\n   cards.  (Recall that
      the IEEE 802 spec talks about transmission\n   order, which is the opposite
      of the in-memory representation that is\n   discussed in this document.)\n   For
      compatibility with earlier specifications, note that this\n   document uses
      the unicast/multicast bit, instead of the arguably more\n   correct local/global
      bit.\n   Advice on generating cryptographic-quality random numbers can be\n
      \  found in RFC1750 [5].\n   In addition, items such as the computer's name
      and the name of the\n   operating system, while not strictly speaking random,
      will help\n   differentiate the results from those obtained by other systems.\n
      \  The exact algorithm to generate a node ID using these data is system\n   specific,
      because both the data available and the functions to obtain\n   them are often
      very system specific.  A generic approach, however, is\n   to accumulate as
      many sources as possible into a buffer, use a\n   message digest such as MD5
      [4] or SHA-1 [8], take an arbitrary 6\n   bytes from the hash value, and set
      the multicast bit as described\n   above.\n"
    title: 4.5.  Node IDs that Do Not Identify the Host
  title: 4.  Specification
- contents:
  - "5.  Community Considerations\n   The use of UUIDs is extremely pervasive in computing.
    \ They comprise\n   the core identifier infrastructure for many operating systems\n
    \  (Microsoft Windows) and applications (the Mozilla browser) and in\n   many
    cases, become exposed to the Web in many non-standard ways.\n   This specification
    attempts to standardize that practice as openly as\n   possible and in a way that
    attempts to benefit the entire Internet.\n"
  title: 5.  Community Considerations
- contents:
  - "6.  Security Considerations\n   Do not assume that UUIDs are hard to guess; they
    should not be used\n   as security capabilities (identifiers whose mere possession
    grants\n   access), for example.  A predictable random number source will\n   exacerbate
    the situation.\n   Do not assume that it is easy to determine if a UUID has been\n
    \  slightly transposed in order to redirect a reference to another\n   object.
    \ Humans do not have the ability to easily check the integrity\n   of a UUID by
    simply glancing at it.\n   Distributed applications generating UUIDs at a variety
    of hosts must\n   be willing to rely on the random number source at all hosts.
    \ If this\n   is not feasible, the namespace variant should be used.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgments\n   This document draws heavily on the OSF DCE specification
    for UUIDs.\n   Ted Ts'o provided helpful comments, especially on the byte ordering\n
    \  section which we mostly plagiarized from a proposed wording he\n   supplied
    (all errors in that section are our responsibility,\n   however).\n   We are also
    grateful to the careful reading and bit-twiddling of Ralf\n   S. Engelschall,
    John Larmouth, and Paul Thorpe.  Professor Larmouth\n   was also invaluable in
    achieving coordination with ISO/IEC.\n"
  title: 7.  Acknowledgments
- contents:
  - "8.  Normative References\n   [1]  Zahn, L., Dineen, T., and P. Leach, \"Network
    Computing\n        Architecture\", ISBN 0-13-611674-4, January 1990.\n   [2]  \"DCE:
    Remote Procedure Call\", Open Group CAE Specification C309,\n        ISBN 1-85912-041-5,
    August 1994.\n   [3]  ISO/IEC 9834-8:2004 Information Technology, \"Procedures
    for the\n        operation of OSI Registration Authorities: Generation and\n        registration
    of Universally Unique Identifiers (UUIDs) and their\n        use as ASN.1 Object
    Identifier components\" ITU-T Rec. X.667,\n        2004.\n   [4]  Rivest, R.,
    \"The MD5 Message-Digest Algorithm \", RFC 1321, April\n        1992.\n   [5]
    \ Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness\n        Requirements
    for Security\", BCP 106, RFC 4086, June 2005.\n   [6]  Moats, R., \"URN Syntax\",
    RFC 2141, May 1997.\n   [7]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n
    \       Specifications: ABNF\", RFC 2234, November 1997.\n   [8]  National Institute
    of Standards and Technology, \"Secure Hash\n        Standard\", FIPS PUB 180-1,
    April 1995,\n        <http://www.itl.nist.gov/fipspubs/fip180-1.htm>.\n"
  title: 8.  Normative References
- contents:
  - "Appendix A.  Appendix A - Sample Implementation\n   This implementation consists
    of 5 files: uuid.h, uuid.c, sysdep.h,\n   sysdep.c and utest.c.  The uuid.* files
    are the system independent\n   implementation of the UUID generation algorithms
    described above,\n   with all the optimizations described above except efficient
    state\n   sharing across processes included.  The code has been tested on Linux\n
    \  (Red Hat 4.0) with GCC (2.7.2), and Windows NT 4.0 with VC++ 5.0.\n   The code
    assumes 64-bit integer support, which makes it much clearer.\n   All the following
    source files should have the following copyright\n   notice included:\n"
  - 'copyrt.h

    '
  - '/*

    '
  - '** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.

    '
  - '** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &

    '
  - '** Digital Equipment Corporation, Maynard, Mass.

    '
  - '** Copyright (c) 1998 Microsoft.

    '
  - '** To anyone who acknowledges that this file is provided "AS IS"

    '
  - '** without any express or implied warranty: permission to use, copy,

    '
  - '** modify, and distribute this file for any purpose is hereby

    '
  - '** granted without fee, provided that the above copyright notices and

    '
  - '** this notice appears in all source code copies, and that none of

    '
  - '** the names of Open Software Foundation, Inc., Hewlett-Packard

    '
  - '** Company, Microsoft, or Digital Equipment Corporation be used in

    '
  - '** advertising or publicity pertaining to distribution of the software

    '
  - '** without specific, written prior permission. Neither Open Software

    '
  - '** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital

    '
  - '** Equipment Corporation makes any representations about the

    '
  - '** suitability of this software for any purpose.

    '
  - '*/

    '
  - 'uuid.h

    '
  - '#include "copyrt.h"

    '
  - '#undef uuid_t

    '
  - "typedef struct {\n    unsigned32  time_low;\n    unsigned16  time_mid;\n    unsigned16
    \ time_hi_and_version;\n    unsigned8   clock_seq_hi_and_reserved;\n    unsigned8
    \  clock_seq_low;\n    byte        node[6];\n"
  - '} uuid_t;

    '
  - '/* uuid_create -- generate a UUID */

    '
  - 'int uuid_create(uuid_t * uuid);

    '
  - "/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a\n   \"name\"
    from a \"name space\" */\n"
  - "void uuid_create_md5_from_name(\n    uuid_t *uuid,         /* resulting UUID
    */\n    uuid_t nsid,          /* UUID of the namespace */\n    void *name,           /*
    the name from which to generate a UUID */\n    int namelen           /* the length
    of the name */\n"
  - ');

    '
  - "/* uuid_create_sha1_from_name -- create a version 5 (SHA-1) UUID\n   using a
    \"name\" from a \"name space\" */\n"
  - "void uuid_create_sha1_from_name(\n    uuid_t *uuid,         /* resulting UUID
    */\n    uuid_t nsid,          /* UUID of the namespace */\n    void *name,           /*
    the name from which to generate a UUID */\n    int namelen           /* the length
    of the name */\n"
  - ');

    '
  - "/* uuid_compare --  Compare two UUID's \"lexically\" and return\n        -1   u1
    is lexically before u2\n         0   u1 is equal to u2\n         1   u1 is lexically
    after u2\n   Note that lexical ordering is not temporal ordering!\n"
  - '*/

    '
  - 'int uuid_compare(uuid_t *u1, uuid_t *u2);

    '
  - 'uuid.c

    '
  - '#include "copyrt.h"

    '
  - '#include <string.h>

    '
  - '#include <stdio.h>

    '
  - '#include <stdlib.h>

    '
  - '#include <time.h>

    '
  - '#include "sysdep.h"

    '
  - '#include "uuid.h"

    '
  - '/* various forward declarations */

    '
  - "static int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,\n    uuid_node_t
    *node);\n"
  - "static void write_state(unsigned16 clockseq, uuid_time_t timestamp,\n    uuid_node_t
    node);\n"
  - "static void format_uuid_v1(uuid_t *uuid, unsigned16 clockseq,\n    uuid_time_t
    timestamp, uuid_node_t node);\n"
  - "static void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16],\n    int
    v);\n"
  - 'static void get_current_time(uuid_time_t *timestamp);

    '
  - 'static unsigned16 true_random(void);

    '
  - '/* uuid_create -- generator a UUID */

    '
  - 'int uuid_create(uuid_t *uuid)

    '
  - "{\n     uuid_time_t timestamp, last_time;\n     unsigned16 clockseq;\n     uuid_node_t
    node;\n     uuid_node_t last_node;\n     int f;\n     /* acquire system-wide lock
    so we're alone */\n     LOCK;\n     /* get time, node ID, saved state from non-volatile
    storage */\n     get_current_time(&timestamp);\n     get_ieee_node_identifier(&node);\n
    \    f = read_state(&clockseq, &last_time, &last_node);\n     /* if no NV state,
    or if clock went backwards, or node ID\n        changed (e.g., new network card)
    change clockseq */\n     if (!f || memcmp(&node, &last_node, sizeof node))\n         clockseq
    = true_random();\n     else if (timestamp < last_time)\n         clockseq++;\n
    \    /* save the state for next time */\n     write_state(clockseq, timestamp,
    node);\n     UNLOCK;\n     /* stuff fields into the UUID */\n     format_uuid_v1(uuid,
    clockseq, timestamp, node);\n     return 1;\n"
  - '}

    '
  - "/* format_uuid_v1 -- make a UUID from the timestamp, clockseq,\n                     and
    node ID */\n"
  - "void format_uuid_v1(uuid_t* uuid, unsigned16 clock_seq,\n                    uuid_time_t
    timestamp, uuid_node_t node)\n"
  - "{\n    /* Construct a version 1 uuid with the information we've gathered\n       plus
    a few constants. */\n    uuid->time_low = (unsigned long)(timestamp & 0xFFFFFFFF);\n
    \   uuid->time_mid = (unsigned short)((timestamp >> 32) & 0xFFFF);\n    uuid->time_hi_and_version
    =\n        (unsigned short)((timestamp >> 48) & 0x0FFF);\n    uuid->time_hi_and_version
    |= (1 << 12);\n    uuid->clock_seq_low = clock_seq & 0xFF;\n    uuid->clock_seq_hi_and_reserved
    = (clock_seq & 0x3F00) >> 8;\n    uuid->clock_seq_hi_and_reserved |= 0x80;\n    memcpy(&uuid->node,
    &node, sizeof uuid->node);\n"
  - '}

    '
  - '/* data type for UUID generator persistent state */

    '
  - "typedef struct {\n    uuid_time_t  ts;       /* saved timestamp */\n    uuid_node_t
    \ node;     /* saved node ID */\n    unsigned16   cs;       /* saved clock sequence
    */\n"
  - '} uuid_state;

    '
  - 'static uuid_state st;

    '
  - '/* read_state -- read UUID generator state from non-volatile store */

    '
  - "int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,\n               uuid_node_t
    *node)\n"
  - "{\n    static int inited = 0;\n    FILE *fp;\n    /* only need to read state
    once per boot */\n    if (!inited) {\n        fp = fopen(\"state\", \"rb\");\n
    \       if (fp == NULL)\n            return 0;\n        fread(&st, sizeof st,
    1, fp);\n        fclose(fp);\n        inited = 1;\n    }\n    *clockseq = st.cs;\n
    \   *timestamp = st.ts;\n    *node = st.node;\n    return 1;\n"
  - '}

    '
  - "/* write_state -- save UUID generator state back to non-volatile\n   storage
    */\n"
  - "void write_state(unsigned16 clockseq, uuid_time_t timestamp,\n                 uuid_node_t
    node)\n"
  - "{\n    static int inited = 0;\n    static uuid_time_t next_save;\n    FILE* fp;\n
    \   if (!inited) {\n        next_save = timestamp;\n        inited = 1;\n    }\n
    \   /* always save state to volatile shared state */\n    st.cs = clockseq;\n
    \   st.ts = timestamp;\n    st.node = node;\n    if (timestamp >= next_save) {\n
    \       fp = fopen(\"state\", \"wb\");\n        fwrite(&st, sizeof st, 1, fp);\n
    \       fclose(fp);\n        /* schedule next save for 10 seconds from now */\n
    \       next_save = timestamp + (10 * 10 * 1000 * 1000);\n    }\n"
  - '}

    '
  - "/* get-current_time -- get time as 60-bit 100ns ticks since UUID epoch.\n   Compensate
    for the fact that real clock resolution is\n   less than 100ns. */\n"
  - 'void get_current_time(uuid_time_t *timestamp)

    '
  - "{\n    static int inited = 0;\n    static uuid_time_t time_last;\n    static
    unsigned16 uuids_this_tick;\n    uuid_time_t time_now;\n    if (!inited) {\n        get_system_time(&time_now);\n
    \       uuids_this_tick = UUIDS_PER_TICK;\n        inited = 1;\n    }\n    for
    ( ; ; ) {\n        get_system_time(&time_now);\n        /* if clock reading changed
    since last UUID generated, */\n        if (time_last != time_now) {\n            /*
    reset count of uuids gen'd with this clock reading */\n            uuids_this_tick
    = 0;\n            time_last = time_now;\n            break;\n        }\n        if
    (uuids_this_tick < UUIDS_PER_TICK) {\n            uuids_this_tick++;\n            break;\n
    \       }\n        /* going too fast for our clock; spin */\n    }\n    /* add
    the count of uuids to low order bits of the clock reading */\n    *timestamp =
    time_now + uuids_this_tick;\n"
  - '}

    '
  - "/* true_random -- generate a crypto-quality random number.\n   **This sample
    doesn't do that.** */\n"
  - 'static unsigned16 true_random(void)

    '
  - "{\n    static int inited = 0;\n    uuid_time_t time_now;\n    if (!inited) {\n
    \       get_system_time(&time_now);\n        time_now = time_now / UUIDS_PER_TICK;\n
    \       srand((unsigned int)\n               (((time_now >> 32) ^ time_now) &
    0xffffffff));\n        inited = 1;\n    }\n    return rand();\n"
  - '}

    '
  - "/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a\n   \"name\"
    from a \"name space\" */\n"
  - "void uuid_create_md5_from_name(uuid_t *uuid, uuid_t nsid, void *name,\n                               int
    namelen)\n"
  - "{\n    MD5_CTX c;\n    unsigned char hash[16];\n    uuid_t net_nsid;\n    /*
    put name space ID in network byte order so it hashes the same\n       no matter
    what endian machine we're on */\n    net_nsid = nsid;\n    net_nsid.time_low =
    htonl(net_nsid.time_low);\n    net_nsid.time_mid = htons(net_nsid.time_mid);\n
    \   net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);\n    MD5Init(&c);\n
    \   MD5Update(&c, &net_nsid, sizeof net_nsid);\n    MD5Update(&c, name, namelen);\n
    \   MD5Final(hash, &c);\n    /* the hash is in network byte order at this point
    */\n    format_uuid_v3or5(uuid, hash, 3);\n"
  - '}

    '
  - "void uuid_create_sha1_from_name(uuid_t *uuid, uuid_t nsid, void *name,\n                                int
    namelen)\n"
  - "{\n    SHA_CTX c;\n    unsigned char hash[20];\n    uuid_t net_nsid;\n    /*
    put name space ID in network byte order so it hashes the same\n       no matter
    what endian machine we're on */\n    net_nsid = nsid;\n    net_nsid.time_low =
    htonl(net_nsid.time_low);\n    net_nsid.time_mid = htons(net_nsid.time_mid);\n
    \   net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);\n    SHA1_Init(&c);\n
    \   SHA1_Update(&c, &net_nsid, sizeof net_nsid);\n    SHA1_Update(&c, name, namelen);\n
    \   SHA1_Final(hash, &c);\n    /* the hash is in network byte order at this point
    */\n    format_uuid_v3or5(uuid, hash, 5);\n"
  - '}

    '
  - "/* format_uuid_v3or5 -- make a UUID from a (pseudo)random 128-bit\n   number
    */\n"
  - 'void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16], int v)

    '
  - "{\n    /* convert UUID to local byte order */\n    memcpy(uuid, hash, sizeof
    *uuid);\n    uuid->time_low = ntohl(uuid->time_low);\n    uuid->time_mid = ntohs(uuid->time_mid);\n
    \   uuid->time_hi_and_version = ntohs(uuid->time_hi_and_version);\n    /* put
    in the variant and version bits */\n    uuid->time_hi_and_version &= 0x0FFF;\n
    \   uuid->time_hi_and_version |= (v << 12);\n    uuid->clock_seq_hi_and_reserved
    &= 0x3F;\n    uuid->clock_seq_hi_and_reserved |= 0x80;\n"
  - '}

    '
  - '/* uuid_compare --  Compare two UUID''s "lexically" and return */

    '
  - '#define CHECK(f1, f2) if (f1 != f2) return f1 < f2 ? -1 : 1;

    '
  - 'int uuid_compare(uuid_t *u1, uuid_t *u2)

    '
  - "{\n    int i;\n    CHECK(u1->time_low, u2->time_low);\n    CHECK(u1->time_mid,
    u2->time_mid);\n    CHECK(u1->time_hi_and_version, u2->time_hi_and_version);\n
    \   CHECK(u1->clock_seq_hi_and_reserved, u2->clock_seq_hi_and_reserved);\n    CHECK(u1->clock_seq_low,
    u2->clock_seq_low)\n    for (i = 0; i < 6; i++) {\n        if (u1->node[i] < u2->node[i])\n
    \           return -1;\n        if (u1->node[i] > u2->node[i])\n            return
    1;\n    }\n    return 0;\n"
  - '}

    '
  - '#undef CHECK

    '
  - 'sysdep.h

    '
  - '#include "copyrt.h"

    '
  - '/* remove the following define if you aren''t running WIN32 */

    '
  - '#define WININC 0

    '
  - '#ifdef WININC

    '
  - '#include <windows.h>

    '
  - '#else

    '
  - '#include <sys/types.h>

    '
  - '#include <sys/time.h>

    '
  - '#include <sys/sysinfo.h>

    '
  - '#endif

    '
  - '#include "global.h"

    '
  - "/* change to point to where MD5 .h's live; RFC 1321 has sample\n   implementation
    */\n"
  - '#include "md5.h"

    '
  - "/* set the following to the number of 100ns ticks of the actual\n   resolution
    of your system's clock */\n"
  - '#define UUIDS_PER_TICK 1024

    '
  - '/* Set the following to a calls to get and release a global lock */

    '
  - '#define LOCK

    '
  - '#define UNLOCK

    '
  - 'typedef unsigned long   unsigned32;

    '
  - 'typedef unsigned short  unsigned16;

    '
  - 'typedef unsigned char   unsigned8;

    '
  - 'typedef unsigned char   byte;

    '
  - '/* Set this to what your compiler uses for 64-bit data type */

    '
  - '#ifdef WININC

    '
  - '#define unsigned64_t unsigned __int64

    '
  - '#define I64(C) C

    '
  - '#else

    '
  - '#define unsigned64_t unsigned long long

    '
  - '#define I64(C) C##LL

    '
  - '#endif

    '
  - 'typedef unsigned64_t uuid_time_t;

    '
  - "typedef struct {\n    char nodeID[6];\n"
  - '} uuid_node_t;

    '
  - 'void get_ieee_node_identifier(uuid_node_t *node);

    '
  - 'void get_system_time(uuid_time_t *uuid_time);

    '
  - 'void get_random_info(char seed[16]);

    '
  - 'sysdep.c

    '
  - '#include "copyrt.h"

    '
  - '#include <stdio.h>

    '
  - '#include "sysdep.h"

    '
  - "/* system dependent call to get IEEE node ID.\n   This sample implementation
    generates a random node ID. */\n"
  - 'void get_ieee_node_identifier(uuid_node_t *node)

    '
  - "{\n    static inited = 0;\n    static uuid_node_t saved_node;\n    char seed[16];\n
    \   FILE *fp;\n    if (!inited) {\n        fp = fopen(\"nodeid\", \"rb\");\n        if
    (fp) {\n            fread(&saved_node, sizeof saved_node, 1, fp);\n            fclose(fp);\n
    \       }\n        else {\n            get_random_info(seed);\n            seed[0]
    |= 0x01;\n            memcpy(&saved_node, seed, sizeof saved_node);\n            fp
    = fopen(\"nodeid\", \"wb\");\n            if (fp) {\n                fwrite(&saved_node,
    sizeof saved_node, 1, fp);\n                fclose(fp);\n            }\n        }\n
    \       inited = 1;\n    }\n    *node = saved_node;\n"
  - '}

    '
  - "/* system dependent call to get the current system time. Returned as\n   100ns
    ticks since UUID epoch, but resolution may be less than\n   100ns. */\n"
  - '#ifdef _WINDOWS_

    '
  - 'void get_system_time(uuid_time_t *uuid_time)

    '
  - "{\n    ULARGE_INTEGER time;\n    /* NT keeps time in FILETIME format which is
    100ns ticks since\n       Jan 1, 1601. UUIDs use time in 100ns ticks since Oct
    15, 1582.\n       The difference is 17 Days in Oct + 30 (Nov) + 31 (Dec)\n       +
    18 years and 5 leap days. */\n    GetSystemTimeAsFileTime((FILETIME *)&time);\n
    \   time.QuadPart +=\n          (unsigned __int64) (1000*1000*10)       // seconds\n
    \       * (unsigned __int64) (60 * 60 * 24)       // days\n        * (unsigned
    __int64) (17+30+31+365*18+5); // # of days\n    *uuid_time = time.QuadPart;\n"
  - '}

    '
  - '/* Sample code, not for use in production; see RFC 1750 */

    '
  - 'void get_random_info(char seed[16])

    '
  - "{\n    MD5_CTX c;\n    struct {\n        MEMORYSTATUS m;\n        SYSTEM_INFO
    s;\n        FILETIME t;\n        LARGE_INTEGER pc;\n        DWORD tc;\n        DWORD
    l;\n        char hostname[MAX_COMPUTERNAME_LENGTH + 1];\n    } r;\n    MD5Init(&c);\n
    \   GlobalMemoryStatus(&r.m);\n    GetSystemInfo(&r.s);\n    GetSystemTimeAsFileTime(&r.t);\n
    \   QueryPerformanceCounter(&r.pc);\n    r.tc = GetTickCount();\n    r.l = MAX_COMPUTERNAME_LENGTH
    + 1;\n    GetComputerName(r.hostname, &r.l);\n    MD5Update(&c, &r, sizeof r);\n
    \   MD5Final(seed, &c);\n"
  - '}

    '
  - '#else

    '
  - 'void get_system_time(uuid_time_t *uuid_time)

    '
  - "{\n    struct timeval tp;\n    gettimeofday(&tp, (struct timezone *)0);\n    /*
    Offset between UUID formatted times and Unix formatted times.\n       UUID UTC
    base time is October 15, 1582.\n       Unix base time is January 1, 1970.*/\n
    \   *uuid_time = ((unsigned64)tp.tv_sec * 10000000)\n        + ((unsigned64)tp.tv_usec
    * 10)\n        + I64(0x01B21DD213814000);\n"
  - '}

    '
  - '/* Sample code, not for use in production; see RFC 1750 */

    '
  - 'void get_random_info(char seed[16])

    '
  - "{\n    MD5_CTX c;\n    struct {\n        struct sysinfo s;\n        struct timeval
    t;\n        char hostname[257];\n    } r;\n    MD5Init(&c);\n    sysinfo(&r.s);\n
    \   gettimeofday(&r.t, (struct timezone *)0);\n    gethostname(r.hostname, 256);\n
    \   MD5Update(&c, &r, sizeof r);\n    MD5Final(seed, &c);\n"
  - '}

    '
  - '#endif

    '
  - 'utest.c

    '
  - '#include "copyrt.h"

    '
  - '#include "sysdep.h"

    '
  - '#include <stdio.h>

    '
  - '#include "uuid.h"

    '
  - "uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */\n    0x6ba7b810,\n
    \   0x9dad,\n    0x11d1,\n    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n"
  - '};

    '
  - '/* puid -- print a UUID */

    '
  - 'void puid(uuid_t u)

    '
  - "{\n    int i;\n    printf(\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-\", u.time_low, u.time_mid,\n
    \   u.time_hi_and_version, u.clock_seq_hi_and_reserved,\n    u.clock_seq_low);\n
    \   for (i = 0; i < 6; i++)\n        printf(\"%2.2x\", u.node[i]);\n    printf(\"\\n\");\n"
  - '}

    '
  - '/* Simple driver for UUID generator */

    '
  - 'void main(int argc, char **argv)

    '
  - "{\n    uuid_t u;\n    int f;\n    uuid_create(&u);\n    printf(\"uuid_create():
    \"); puid(u);\n    f = uuid_compare(&u, &u);\n    printf(\"uuid_compare(u,u):
    %d\\n\", f);     /* should be 0 */\n    f = uuid_compare(&u, &NameSpace_DNS);\n
    \   printf(\"uuid_compare(u, NameSpace_DNS): %d\\n\", f); /* s.b. 1 */\n    f
    = uuid_compare(&NameSpace_DNS, &u);\n    printf(\"uuid_compare(NameSpace_DNS,
    u): %d\\n\", f); /* s.b. -1 */\n    uuid_create_md5_from_name(&u, NameSpace_DNS,
    \"www.widgets.com\", 15);\n    printf(\"uuid_create_md5_from_name(): \"); puid(u);\n"
  - '}

    '
  title: Appendix A.  Appendix A - Sample Implementation
- contents:
  - "Appendix B.  Appendix B - Sample Output of utest\n     uuid_create(): 7d444840-9dc0-11d1-b245-5ffdce74fad2\n
    \    uuid_compare(u,u): 0\n     uuid_compare(u, NameSpace_DNS): 1\n     uuid_compare(NameSpace_DNS,
    u): -1\n     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f\n"
  title: Appendix B.  Appendix B - Sample Output of utest
- contents:
  - "Appendix C.  Appendix C - Some Name Space IDs\n   This appendix lists the name
    space IDs for some potentially\n   interesting name spaces, as initialized C structures
    and in the\n   string representation defined above.\n   /* Name string is a fully-qualified
    domain name */\n   uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8
    */\n       0x6ba7b810,\n       0x9dad,\n       0x11d1,\n       0x80, 0xb4, 0x00,
    0xc0, 0x4f, 0xd4, 0x30, 0xc8\n   };\n   /* Name string is a URL */\n   uuid_t
    NameSpace_URL = { /* 6ba7b811-9dad-11d1-80b4-00c04fd430c8 */\n       0x6ba7b811,\n
    \      0x9dad,\n       0x11d1,\n       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
    0xc8\n   };\n   /* Name string is an ISO OID */\n   uuid_t NameSpace_OID = { /*
    6ba7b812-9dad-11d1-80b4-00c04fd430c8 */\n       0x6ba7b812,\n       0x9dad,\n
    \      0x11d1,\n       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n   };\n
    \  /* Name string is an X.500 DN (in DER or a text output format) */\n   uuid_t
    NameSpace_X500 = { /* 6ba7b814-9dad-11d1-80b4-00c04fd430c8 */\n       0x6ba7b814,\n
    \      0x9dad,\n       0x11d1,\n       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
    0xc8\n   };\n"
  title: Appendix C.  Appendix C - Some Name Space IDs
- contents:
  - "Authors' Addresses\n   Paul J. Leach\n   Microsoft\n   1 Microsoft Way\n   Redmond,
    WA  98052\n   US\n   Phone: +1 425-882-8080\n   EMail: paulle@microsoft.com\n
    \  Michael Mealling\n   Refactored Networks, LLC\n   1635 Old Hwy 41\n   Suite
    112, Box 138\n   Kennesaw, GA 30152\n   US\n   Phone: +1-678-581-9656\n   EMail:
    michael@refactored-networks.com\n   URI: http://www.refactored-networks.com\n
    \  Rich Salz\n   DataPower Technology, Inc.\n   1 Alewife Center\n   Cambridge,
    MA  02142\n   US\n   Phone: +1 617-864-0455\n   EMail: rsalz@datapower.com\n   URI:
    \  http://www.datapower.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
