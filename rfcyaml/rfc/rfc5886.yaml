- contents:
  - "                     A Set of Monitoring Tools for\n           Path Computation
    Element (PCE)-Based Architecture\n"
  title: __initial_text__
- contents:
  - "Abstract\n   A Path Computation Element (PCE)-based architecture has been\n   specified
    for the computation of Traffic Engineering (TE) Label\n   Switched Paths (LSPs)
    in Multiprotocol Label Switching (MPLS) and\n   Generalized MPLS (GMPLS) networks
    in the context of single or\n   multiple domains (where a domain refers to a collection
    of network\n   elements within a common sphere of address management or path\n
    \  computational responsibility such as Interior Gateway Protocol (IGP)\n   areas
    and Autonomous Systems).  Path Computation Clients (PCCs) send\n   computation
    requests to PCEs, and these may forward the requests to\n   and cooperate with
    other PCEs forming a \"path computation chain\".\n   In PCE-based environments,
    it is thus critical to monitor the state\n   of the path computation chain for
    troubleshooting and performance\n   monitoring purposes: liveness of each element
    (PCE) involved in the\n   PCE chain and detection of potential resource contention
    states and\n   statistics in terms of path computation times are examples of such\n
    \  metrics of interest.  This document specifies procedures and\n   extensions
    to the Path Computation Element Protocol (PCEP) in order\n   to gather such information.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5886.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Requirements Language ......................................5\n   2.
    Terminology .....................................................5\n   3. Path
    Computation Monitoring Messages ............................6\n      3.1. Path
    Computation Monitoring Request (PCMonReq) Message .....6\n      3.2. Path Monitoring
    Reply (PCMonRep) Message ...................9\n   4. Path Computation Monitoring
    Objects ............................11\n      4.1. MONITORING Object .........................................11\n
    \     4.2. PCC-ID-REQ Object .........................................13\n      4.3.
    PCE-ID Object .............................................14\n      4.4. PROC-TIME
    Object ..........................................15\n      4.5. OVERLOAD Object
    ...........................................17\n   5. Policy .........................................................18\n
    \  6. Elements of Procedure ..........................................18\n   7.
    Manageability Considerations ...................................20\n      7.1.
    Control of Function and Policy ............................20\n      7.2. Information
    and Data Models ...............................20\n      7.3. Liveness Detection
    and Monitoring .........................20\n      7.4. Verify Correct Operations
    .................................20\n      7.5. Requirements on Other Protocols
    ...........................21\n      7.6. Impact on Network Operations ..............................21\n
    \  8. Guidelines to Avoid Overload Thrashing .........................21\n   9.
    IANA Considerations ............................................22\n      9.1.
    New PCEP Message ..........................................22\n      9.2. New
    PCEP Objects ..........................................22\n      9.3. New Error-Values
    ..........................................23\n      9.4. MONITORING Object Flag
    Field ..............................23\n      9.5. PROC-TIME Object Flag Field
    ...............................24\n      9.6. OVERLOAD Object Flag Field ................................24\n
    \  10. Security Considerations .......................................24\n   11.
    Acknowledgments ...............................................25\n   12. References
    ....................................................25\n      12.1. Normative
    References .....................................25\n      12.2. Informative References
    ...................................25\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Path Computation Element (PCE)-based architecture has
    been\n   specified in [RFC4655] for the computation of Traffic Engineering\n   (TE)
    Label Switched Paths (LSPs) in Multiprotocol Label Switching\n   (MPLS) and Generalized
    MPLS (GMPLS) networks in the context of single\n   or multiple domains where a
    domain refers to a collection of network\n   elements within a common sphere of
    address management or path\n   computational responsibility such Interior Gateway
    Protocol (IGP)\n   areas and Autonomous Systems.\n   Path Computation Clients
    (PCCs) send computation requests to PCEs\n   using PCReq messages, and these may
    forward the requests to and\n   cooperate with other PCEs forming a \"path computation
    chain\".  In the\n   case of successful path computation, the computed paths are
    then\n   provided to the requesting PCC using PCRep messages.  The PCReq and\n
    \  PCRep messages are defined in [RFC5440].\n   In PCE-based environments, it
    is critical to monitor the state of the\n   path computation chain for troubleshooting
    and performance monitoring\n   purposes: liveness of each element (PCE) involved
    in the PCE chain\n   and detection of potential resource contention states and
    statistics\n   in terms of path computation times are examples of such metrics
    of\n   interest.\n   As defined in [RFC4655], there are circumstances in which
    more than\n   one PCE is involved in the computation of a TE LSP.  A typical\n
    \  example is when the PCC requires the computation of a TE LSP where\n   the
    head-end and the tail-end of the TE LSP do not reside in adjacent\n   domains
    and there is no single PCE with the visibility of both the\n   head-end and tail-end
    domain.  We call the set of PCEs involved in\n   the computation of a TE LSP a
    \"path computation chain\".  As further\n   discussed in Section 3.1, the path
    computation chain may either be\n   static (pre-configured) or dynamically determined
    during the path\n   computation process.\n   As discussed in [RFC4655], a TE LSP
    may be computed by one PCE\n   (referred to as single PCE path computation) or
    several PCEs\n   (referred to as multiple PCE path computation).  In the former
    case,\n   the PCC may be able to use IGP extensions to check the liveness of\n
    \  the PCE (see [RFC5088] and [RFC5089]) or PCEP using Keepalive\n   messages.
    \ In contrast, when multiple PCEs are involved in the path\n   computation chain,
    an example of which is the Backward Recursive PCE-\n   based Computation (BRPC)
    procedure defined in [RFC5441], the PCC's\n   visibility may be limited to the
    first PCE involved in the path\n   computation chain.  Thus, it is critical to
    define mechanisms in\n   order to monitor the state of the path computation chain.\n
    \  This document specifies PCEP extensions in order to gather various\n   state
    metrics along the path computation chain.  In this document, we\n   call a \"state
    metric\" a metric that characterizes a PCE state.  For\n   example, such a metric
    can have a form of a boolean (PCE is alive or\n   not, PCE is congested or not)
    or a performance metric (path\n   computation time at each PCE).\n   PCE state
    metrics can be gathered in two different contexts: in band\n   or out of band.
    \ By \"in band\" we refer to the situation whereby a PCC\n   requests to gather
    metrics in the context of a path computation\n   request.  For example, a PCC
    may send a path computation request to a\n   PCE and may want to know the processing
    time of that request in\n   addition to the computed path.  Conversely, if the
    request is \"out of\n   band\", PCE state metric collection is performed as a
    standalone\n   request (e.g., check the liveness of a specific path computation\n
    \  chain, collect the average processing time computed over the last\n   5-minute
    period on one or more PCEs).\n   In this document, we define two monitoring request
    types: general and\n   specific.  A general monitoring request relates to the
    collection of\n   a PCE state metrics that is not coupled to a particular path\n
    \  computation request (e.g., average CPU load on a PCE).  Conversely, a\n   specific
    monitoring request relates to a particular path computation\n   request (processing
    time to complete the path computation for a TE\n   LSP).\n   This document specifies
    procedures and extensions to the Path\n   Computation Element Protocol (PCEP)
    ([RFC5440]), including new\n   objects and new PCEP messages, in order to monitor
    the path\n   computation chain and gather various performance metrics.\n   The
    message formats in this document are specified using Backus Naur\n   Format (BNF)
    encoding as specified in [RFC5511].\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   PCC (Path Computation Client): any client application requesting
    a\n   path computation to be performed by a Path Computation Element.\n   PCE
    (Path Computation Element): an entity (component, application, or\n   network
    node) that is capable of computing a network path or route\n   based on a network
    graph and applying computational constraints.\n   TE LSP: Traffic Engineering
    Label Switched Path.\n"
  title: 2.  Terminology
- contents:
  - "3.  Path Computation Monitoring Messages\n   As defined in [RFC5440], a PCEP
    message consists of a common header\n   followed by a variable-length body made
    of a set of objects that can\n   be either mandatory or optional.  As a reminder,
    an object is said to\n   be mandatory in a PCEP message when the object must be
    included for\n   the message to be considered valid.  The P flag (defined in\n
    \  [RFC5440]) is located in the common header of each PCEP object and\n   can
    be set by a PCEP peer to require a PCE to take into account the\n   related information
    during the path computation.  Because the P flag\n   exclusively relates to a
    path computation request, it MUST be cleared\n   in the two PCEP messages (PCMonReq
    and PCMonRep message) defined in\n   this document.\n   For each PCEP message
    type, a set of rules is defined that specify\n   the set of objects that the message
    can carry.  An implementation\n   MUST form the PCEP messages using the object
    ordering specified in\n   this document.\n   In this document, we define two PCEP
    messages referred to as the Path\n   Computation Monitoring Request (PCMonReq)
    and Path Computation\n   Monitoring Reply (PCMonRep) messages so as to handle
    out-of-band\n   monitoring requests.  The aim of the PCMonReq message sent by
    a PCC\n   to a PCE is to gather one or more PCE state metrics on a set of PCEs\n
    \  involved in a path computation chain.  The PCMonRep message sent by a\n   PCE
    to a PCC is used to provide such data.\n"
  - contents:
    - "3.1.  Path Computation Monitoring Request (PCMonReq) Message\n   The Message-Type
      field of the PCEP common header for the PCMonReq\n   message is set to 8.\n
      \  There is one mandatory object that MUST be included within a PCMonReq\n   message:
      the MONITORING object (see Section 4.1).  If the MONITORING\n   object is missing,
      the receiving PCE MUST send a PCErr message with\n   Error-type=6 (Mandatory
      Object missing) and Error-value=4 (MONITORING\n   object missing).  Other objects
      are optional.\n   Format of a PCMonReq message (out-of-band request):\n   <PCMonReq
      Message>::= <Common Header>\n                         <MONITORING>\n                         <PCC-ID-REQ>\n
      \                        [<pce-list>]\n                         [<svec-list>]\n
      \                        [<request-list>]\n   where:\n   <pce-list>::=<PCE-ID>[<pce-list>]\n
      \  <svec-list>::=<SVEC>\n                 [<OF>]\n                 [<svec-list>]\n
      \  <request-list>::=<request>[<request-list>]\n   <request>::= <RP>\n                <END-POINTS>\n
      \               [<LSPA>]\n                [<BANDWIDTH>]\n                [<metric-list>]\n
      \               [<RRO>]\n                [<IRO>]\n                [<LOAD-BALANCING>]\n
      \               [<XRO>]\n   <metric-list>::=<METRIC>[<metric-list>]\n   Format
      of a PCReq message with monitoring data requested (in-band\n   request):\n   <PCReq
      Message>::= <Common Header>\n                      <MONITORING>\n                      <PCC-ID-REQ>\n
      \                     [<pce-list>]\n                      [<svec-list>]\n                      <request-list>\n
      \  where:\n      <pce-list>::=<PCE-ID>[<pce-list>]\n      <svec-list>::=<SVEC>[<svec-list>]\n
      \     <request-list>::=<request>[<request-list>]\n      <request>::= <RP>\n
      \                  <END-POINTS>\n                   [<LSPA>]\n                   [<BANDWIDTH>]\n
      \                  [<metric-list>]\n                   [<RRO>[<BANDWIDTH>]]\n
      \                  [<IRO>]\n                   [<LOAD-BALANCING>]\n   where:\n
      \  <metric-list>::=<METRIC>[<metric-list>]\n   The SVEC, RP, END-POINTS, LSPA,
      BANDWIDTH, METRIC, RRO, IRO, and\n   LOAD-BALANCING objects are defined in [RFC5440].
      \ The XRO object is\n   defined in [RFC5521] and the OF object is defined in
      [RFC5541].  The\n   PCC-ID-REQ object is defined in Section 4.2.\n   The PCMonReq
      message is used to gather various PCE state metrics\n   along a path computation
      chain.  The path computation chain may be\n   determined by the PCC (in the
      form of a series of a series of PCE-ID\n   objects defined in Section 4.3) according
      to policy specified on the\n   PCC or alternatively may be determined by the
      path computation\n   procedure.  For example, if the BRPC procedure ([RFC5441])
      is used to\n   compute an inter-domain TE LSP, the path computation chain may
      be\n   determined dynamically.  In that case, the PCC sends a PCMonReq\n   message
      that contains the PCEP objects that characterize the TE LSP\n   attributes along
      with the MONITORING object (see Section 4.1) that\n   lists the set of metrics
      of interest.  If a list of PCEs is present\n   in the monitoring request, it
      takes precedence over mechanisms used\n   to dynamically determine the path
      computation chain.  If a PCE\n   receives a monitoring request that specifies
      a next-hop PCE in the\n   PCE list that is unreachable, the request MUST be
      silently discarded.\n   Several PCE state metrics may be requested that are
      specified by a\n   set of objects defined in Section 4.  Note that this set
      of objects\n   may be extended in the future.\n   As pointed out in [RFC5440],
      several situations can arise in the form\n   of:\n   o  a bundle of a set of
      independent and non-synchronized path\n      computation requests,\n   o  a
      bundle of a set of independent and synchronized path computation\n      requests
      (SVEC object defined below required), or\n   o  a bundle of a set of dependent
      and synchronized path computation\n      requests (SVEC object defined below
      required).\n   In the case of a bundle of a set of requests, the MONITORING
      object\n   SHOULD only be present in the first PCReq or PCMonReq message, and\n
      \  the monitoring request applies to all the requests of the bundle,\n   even
      in the case of dependent and/or synchronized requests sent using\n   more than
      one PCReq or PCMonReq message.\n   Examples of requests.  For the sake of illustration,
      consider the\n   three following examples:\n   Example 1 (out-of-band request):
      PCC1 makes a request to check the\n   path computation chain that would be used
      should it request a path\n   computation for a specific TE LSP named T1.  A
      PCMonReq message is\n   sent that contains a MONITORING object specifying a
      path computation\n   check, along with the appropriate set of objects (e.g.,
      RP, END-\n   POINTS, etc.) that would be included in a PCReq message for T1.\n
      \  Example 2 (in-band request): PCC1 requests a path computation for a\n   TE
      LSP and also makes a request to gather the processing time along\n   the path
      computation chain selected for the computation of T1.  A\n   PCReq message is
      sent that also contains a MONITORING object that\n   specifies the performance
      metrics of interest.\n   Example 3 (out-of-band request): PCC2 requests to gather
      performance\n   metrics along the specific path computation chain <pce1, pce2,
      pce3,\n   pce7>.  A PCMonReq message is sent to PCE1 that contains a MONITORING\n
      \  object and a sequence of PCE-ID objects that identify PCE1, PCE2,\n   PCE3,
      and PCE7, respectively.\n   In all of the examples above, a PCRep message (in-band
      request) or\n   PCMonReq message (out-of-band request) is sent in response to
      the\n   request that reports the computed metrics.\n"
    title: 3.1.  Path Computation Monitoring Request (PCMonReq) Message
  - contents:
    - "3.2.  Path Monitoring Reply (PCMonRep) Message\n   The PCMonRep message is
      used to provide PCE state metrics back to the\n   requester for out-of-band
      monitoring requests.  The Message-Type\n   field of the PCEP common header for
      the PCMonRep message is set to 9.\n   There is one mandatory object that MUST
      be included within a PCMonRep\n   message: the MONITORING object (see Section
      4.1).  If the MONITORING\n   object is missing, the receiving PCE MUST send
      a PCErr message with\n   Error-type=6 (Mandatory Object missing) and Error-value=4
      (MONITORING\n   object missing).\n   Other objects are optional.\n   Format
      of a PCMonRep (out-of-band request):\n   <PCMonRep Message>::= <Common Header>\n
      \                        <MONITORING>\n                         <PCC-ID-REQ>\n
      \                        [<RP>]\n                         [<metric-pce-list>]\n
      \  where:\n   <metric-pce-list>::=<metric-pce>[<metric-pce-list>]\n   <metric-pce>::=<PCE-ID>\n
      \                 [<PROC-TIME>]\n                  [<OVERLOAD>]\n   Format of
      a PCRep message with monitoring data (in band):\n   <PCRep Message> ::= <Common
      Header>\n                       <response-list>\n   where:\n      <response-list>::=<response>[<response-list>]\n
      \     <response>::=<RP>\n                   <MONITORING>\n                   <PCC-ID-REQ>\n
      \                 [<NO-PATH>]\n                  [<attribute-list>]\n                  [<path-list>]\n
      \                 [<metric-pce-list>]\n      <path-list>::=<path>[<path-list>]\n
      \     <path>::= <ERO><attribute-list>\n   where:\n    <attribute-list>::=[<LSPA>]\n
      \                      [<BANDWIDTH>]\n                       [<metric-list>]\n
      \                      [<IRO>]\n    <metric-list>::=<METRIC>[<metric-list>]\n
      \   <metric-pce-list>::=<metric-pce>[<metric-pce-list>]\n    <metric-pce>::=<PCE-ID>\n
      \                 [<PROC-TIME>]\n                  [<OVERLOAD>]\n   The RP and
      the NO-PATH objects are defined in [RFC5440].  The PCC-ID-\n   REQ object is
      defined in Section 4.2.\n   If the path computation chain has been statically
      specified in the\n   corresponding monitoring request using the series of a
      series of PCE-\n   ID objects defined in Section 4.3, the monitoring request
      MUST use\n   the same path computation chain (using the PCE list but in the\n
      \  reverse order).\n"
    title: 3.2.  Path Monitoring Reply (PCMonRep) Message
  title: 3.  Path Computation Monitoring Messages
- contents:
  - "4.  Path Computation Monitoring Objects\n   The PCEP objects defined in the document
    are compliant with the PCEP\n   object format defined in [RFC5440].  The P flag
    and the I flag of the\n   PCEP objects defined in this document SHOULD always
    be set to 0 on\n   transmission and MUST be ignored on receipt since these flags
    are\n   exclusively related to path computation requests.\n   Several objects
    are defined in this section that can be carried\n   within the PCEP PCReq or PCRep
    messages defined in [RFC5440] in the\n   case of in-band monitoring requests (the
    PCC requests the computation\n   of the TE LSP in addition to gathering PCE state
    metrics).  In the\n   case of out-of-band monitoring requests, the objects defined
    in this\n   section are carried within PCMonReq and PCMonRep messages.\n   All
    TLVs carried in objects defined in this document have the TLV\n   format defined
    in [RFC5440]:\n   o  Type: 2 bytes\n   o  Length: 2 bytes\n   o  Value: variable\n
    \  A PCEP object TLV is comprised of 2 bytes for the type, 2 bytes\n   specifying
    the TLV length, and a value field.  The Length field\n   defines the length of
    the value portion in bytes.  The TLV is padded\n   to 4-byte alignment; padding
    is not included in the Length field (so\n   a 3-byte value would have a length
    of 3, but the total size of the\n   TLV would be 8 bytes).  Unrecognized TLVs
    MUST be ignored.\n"
  - contents:
    - "4.1.  MONITORING Object\n   The MONITORING object MUST be present within PCMonReq
      and PCMonRep\n   messages (out-of-band monitoring requests) and MAY be carried
      within\n   PCRep and PCReq messages (in-band monitoring requests).  There SHOULD\n
      \  NOT be more than one instance of the MONITORING object in a PCMonReq\n   or
      PCMonRep message: if more than one instance of the MONITORING\n   object is
      present, the recipient MUST process the first instance and\n   MUST ignore other
      instances.\n   The MONITORING object is used to specify the set of requested
      PCE\n   state metrics.\n   The MONITORING Object-Class (19) has been assigned
      by IANA.\n   The MONITORING Object-Type (1) has been assigned by IANA.\n   The
      format of the MONITORING object body is as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |    Reserved   |                  Flags              |I|C|P|G|L|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                     Monitoring-id-number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                     Optional TLV(s)                        //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Flags:
      24 bits\n   The following flags are currently defined:\n   L (Liveness) - 1
      bit: when set, this indicates that the state metric\n   of interest is the PCE's
      liveness and thus the PCE MUST include a\n   PCE-ID object in the corresponding
      reply.  The L bit MUST always be\n   ignored in a PCMonRep or PCRep message.\n
      \  G (General) - 1 bit: when set, this indicates that the monitoring\n   request
      is a general monitoring request.  When the requested\n   performance metric
      is specific, the G bit MUST be cleared.  The G bit\n   MUST always be ignored
      in a PCMonRep or PCRep message.\n   P (Processing Time) - 1 bit: the P bit of
      the MONITORING object\n   carried in a PCMonReq or a PCReq message is set to
      indicate that the\n   processing times is a metric of interest.  If allowed
      by policy, a\n   PROC-TIME object MUST be inserted in the corresponding PCMonRep
      or\n   PCRep message.  The P bit MUST always be ignored in a PCMonRep or\n   PCRep
      message.\n   C (Overload) - 1 bit: The C bit of the MONITORING object carried
      in a\n   PCMonReq or a PCReq message is set to indicate that the overload\n
      \  status is a metric of interest, in which case an OVERLOAD object MUST\n   be
      inserted in the corresponding PCMonRep or PCRep message.  The C\n   bit MUST
      always be ignored in a PCMonRep or PCRep message.\n   I (Incomplete) - 1 bit:
      If a PCE supports a received PCMonReq message\n   and that message does not
      trigger any policy violation, but the PCE\n   cannot provide any of the set
      of requested performance metrics for\n   unspecified reasons, the PCE MUST set
      the I bit.  The I bit has no\n   meaning in a request and SHOULD be ignored
      on receipt.\n   Monitoring-id-number (32 bits): The monitoring-id-number value\n
      \  combined with the PCC-REQ-ID identifying the requesting PCC uniquely\n   identifies
      the monitoring request context.  The monitoring-id-number\n   MUST start at
      a non-zero value and MUST be incremented each time a\n   new monitoring request
      is sent to a PCE.  Each increment SHOULD have\n   a value of 1 and may cause
      a wrap back to zero.  If no reply to a\n   monitoring request is received from
      the PCE, and the PCC wishes to\n   resend its path computation monitoring request,
      the same monitoring-\n   id-number MUST be used.  Conversely, a different monitoring-id-number\n
      \  MUST be used for different requests sent to a PCE.  A PCEP\n   implementation
      SHOULD checkpoint the Monitoring-id-number of pending\n   monitoring requests
      in case of restart thus avoiding the reuse of a\n   Monitoring-id-number of
      an in-process monitoring request.\n   Unassigned bits are considered as reserved
      and MUST be set to zero on\n   transmission and ignored on reception.\n   No
      optional TLVs are currently defined.\n"
    title: 4.1.  MONITORING Object
  - contents:
    - "4.2.  PCC-ID-REQ Object\n   The PCC-ID-REQ object is used to specify the IP
      address of the\n   requesting PCC.\n   The PCC-ID-REQ MUST be inserted within
      a PCReq or a PCMonReq message\n   to specify the IP address of the requesting
      PCC.\n   Two PCC-ID-REQ objects (for IPv4 and IPv6) are defined.  PCC-ID-REQ\n
      \  Object-Class (20) has been assigned by IANA.  PCC-ID-REQ Object-Type\n   (1
      for IPv4 and 2 for IPv6) has been assigned by IANA.\n   The format of the PCC-ID-REQ
      object body for IPv4 and IPv6 are as\n   follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                           IPv4 Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   |                           IPv6
      Address                        |\n   |                                                               |\n
      \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The PCC-ID-REQ object body has a fixed length of 4 octets for IPv4\n   and
      16 octets for IPv6.\n"
    title: 4.2.  PCC-ID-REQ Object
  - contents:
    - "4.3.  PCE-ID Object\n   The PCE-ID object is used to specify a PCE's IP address.
      \ The PCE-ID\n   object can either be used to specify the list of PCEs for which\n
      \  monitoring data is requested and to specify the IP address of the\n   requesting
      PCC.\n   A set of PCE-ID objects may be inserted within a PCReq or a PCMonReq\n
      \  message to specify the PCE for which PCE state metrics are requested\n   and
      in a PCMonRep or a PCRep message to record the IP address of the\n   PCE reporting
      PCE state metrics or that was involved in the path\n   computation chain.\n
      \  Two PCE-ID objects (for IPv4 and IPv6) are defined.  PCE-ID Object-\n   Class
      (25) has been assigned by IANA.  PCE-ID Object-Type (1 for IPv4\n   and 2 for
      IPv6) has been assigned by IANA.\n   The format of the PCE-ID object body for
      IPv4 and IPv6 are as\n   follows:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                           IPv4 Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   |                           IPv6
      Address                        |\n   |                                                               |\n
      \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The PCE-ID object body has a fixed length of 4 octets for IPv4 and 16\n   octets
      for IPv6.\n   When a dynamic discovery mechanism is used for PCE discovery,
      a PCE\n   advertises its PCE address in the PCE-ADDRESS sub-TLV defined in\n
      \  [RFC5088] and [RFC5089].  A PCC MUST use this address in PCReq and\n   PCMonReq
      messages and a PCE MUST also use this address in PCRep and\n   PCMonRep messages.\n"
    title: 4.3.  PCE-ID Object
  - contents:
    - "4.4.  PROC-TIME Object\n   If allowed by policy, the PCE includes a PROC-TIME
      object within a\n   PCMonRep or a PCRep message if the P bit of the MONITORING
      object\n   carried within the corresponding PCMonReq or PCReq message is set.\n
      \  The PROC-TIME object is used to report various processing time\n   related
      metrics.\n   1) Case of general monitoring requests\n      A PCC may request
      processing time metrics for general monitoring\n      requests (e.g., the PCC
      may want to know the minimum, maximum, and\n      average processing times on
      a particular PCE).  In this case,\n      general requests can only be made by
      using PCMonReq/PCMonRep\n      messages.  The Current-processing-time field
      (as explained below)\n      is exclusively used for specific monitoring requests
      and MUST be\n      cleared for general monitoring requests.  The algorithms
      used by a\n      PCE to compute the minimum, maximum, average, and variance
      of the\n      processing times are out of the scope of this document (a PCE
      may\n      decide to compute the minimum processing time over a period of\n
      \     time, for the last N path computation requests, etc.).\n   2) Case of
      specific monitoring requests\n      In the case of a specific request, the algorithms
      used by a PCE to\n      compute the Processing-time metrics are out of the scope
      of this\n      document, but a flag is specified that is used to indicate to
      the\n      requester whether the processing time value was estimated or\n      computed.
      \ The PCE may either (1) estimate the processing time\n      without performing
      an actual path computation or (2) effectively\n      perform the computation
      to report the processing time.  In the\n      former case, the E bit of the
      PROC-TIME object MUST be set.  The G\n      bit MUST be cleared and the Min-processing-time,
      Max-processing-\n      time, Average-processing-time, and Variance-processing-time
      MUST\n      be set to 0x00000000.\n      When the processing time is requested
      in addition to a path\n      computation (case where the MONITORING object is
      carried within a\n      PCReq message), the PROC-TIME object always reports
      the actual\n      processing time for that request and thus the E bit MUST be\n
      \     cleared.\n   The PROC-TIME Object-Class (26) has been assigned by IANA.\n
      \  The PROC-TIME Object-Type (1) has been assigned by IANA.\n   The format of
      the PROC-TIME object body is as follows:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |       Reserved                |           Flags             |E|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                     Current-processing-time                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Min-processing-time                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Max-processing-time                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Average-processing time                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Variance-processing-time                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Flags: 16 bits - one flag is currently defined:\n   E (Estimated) - 1 bit:
      when set, this indicates that the reported\n   metric value is based on estimated
      processing time as opposed to\n   actual computations.\n   Unassigned bits are
      considered as reserved and MUST be set to zero on\n   transmission.\n   Current-processing-time:
      This field indicates, in milliseconds, the\n   processing time for the path
      computation of interest characterized in\n   the corresponding PCMonReq message.\n
      \  Min-processing-time: This field indicates, in milliseconds, the\n   minimum
      processing time.\n   Max-processing-time: This field indicates, in milliseconds,
      the\n   maximum processing time.\n   Average-processing-time: This field indicates,
      in milliseconds, the\n   average processing time.\n   Variance-processing-time:
      This field indicates, in milliseconds, the\n   variance of the processing times.\n
      \  Since the PCC may potentially use monitoring metrics as input to\n   their
      PCE selection, it MAY be required to normalize how time metrics\n   (along with
      others metrics described in further revision of this\n   document) are computed
      to ensure consistency between the monitoring\n   metrics computed by a set of
      PCEs.\n"
    title: 4.4.  PROC-TIME Object
  - contents:
    - "4.5.  OVERLOAD Object\n   The OVERLOAD object is used to report a PCE processing
      congestion\n   state.  Note that \"overload\" as indicated by this object refers
      to\n   the processing state of the PCE and its ability to handle new PCEP\n
      \  requests.  A PCE is overloaded when it has a backlog of PCEP requests\n   such
      that it cannot immediately start to process a new request thus\n   leading to
      waiting times.  The overload duration is quantified as\n   being the (estimated)
      time until the PCE expects to be able to\n   immediately process a new PCEP
      request.\n   The OVERLOAD object MUST be present within a PCMonRep or a PCRep\n
      \  message if the C bit of the MONITORING object carried within the\n   corresponding
      PCMonReq or PCReq message is set and the PCE is\n   experiencing a congested
      state.  The OVERLOAD Object-Class (27) has\n   been assigned by IANA.  The overload
      Object-Type (1) has been\n   assigned by IANA.\n   The format of the CONGESTION
      object body is as follows:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Flags       |   Reserved    |      Overload Duration        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Flags: 8 bits - No flag is currently defined.\n   Overload duration - 16
      bits: This field indicates the amount of time,\n   in seconds, that the responding
      PCE expects that it may continue to\n   be overloaded from the time that the
      response message was generated.\n   The receiver MAY use this value to decide
      whether or not to send\n   further requests to the same PCE.\n   It is worth
      noting that a PCE along a path computation chain involved\n   in the monitoring
      request may decide to learn from the overload\n   information received by one
      of downstream PCEs in the chain.\n"
    title: 4.5.  OVERLOAD Object
  title: 4.  Path Computation Monitoring Objects
- contents:
  - "5.  Policy\n   The receipt of a PCMonReq message may trigger a policy violation
    on\n   some PCE; in which case, the PCE MUST send a PCErr message with\n   Error-type=5
    and Error-value=6.\n"
  title: 5.  Policy
- contents:
  - "6.  Elements of Procedure\n   I bit processing: as indicated in Section 4.1,
    if a PCE supports a\n   received PCMonReq message and that message does not trigger
    any\n   policy violation, but the PCE cannot provide any of the set of\n   requested
    performance metrics for unspecified reasons, the PCE MUST\n   set the I bit.  Once
    set, the I bit MUST NOT be changed by a\n   receiving PCE.\n   Upon receiving
    a PCMonReq message:\n   1) As specified in [RFC5440], if the PCE does not support
    the\n      PCMonReq message, the PCE peer MUST send a PCErr message with\n      Error-value=2
    (capability not supported).  According to the\n      procedure defined in Section
    6.9 of [RFC5440], if a PCC/PCE\n      receives unrecognized messages at a rate
    equal of greater than\n      specified rate, the PCC/PCE must send a PCEP CLOSE
    message with\n      close value=5 \"Reception of an unacceptable number of unrecognized\n
    \     PCEP messages\".  In this case, the PCC/PCE must also close the TCP\n      session
    and must not send any further PCEP messages on the PCEP\n      session.\n   2)
    If the PCE supports the PCMonReq message but the monitoring\n      request is
    prohibited by policy, the PCE must follow the procedure\n      specified in Section
    5.  As pointed out in Section 4.3, a PCE may\n      still partially satisfy a
    request, leaving out some of the\n      required data if not allowed by policy.\n
    \  3) If the PCE supports the PCMonReq and the monitoring request is not\n      prohibited
    by policy, the receiving PCE MUST first determine\n      whether it is the last
    PCE of the path computation chain.  If the\n      PCE is not the last element
    of the path computation chain, the\n      PCMonReq message is relayed to the next-hop
    PCE: such a next hop\n      may be either specified by means of a PCE-ID object
    present in the\n      PCMonReq message or dynamically determined by means of a
    procedure\n      outside of the scope of this document.  Conversely, if the PCE
    is\n      the last PCE of the path computation chain, the PCE originates a\n      PCMonRep
    message that contains the requested objects according to\n      the set of requested
    PCE states metrics listed in the MONITORING\n      object carried in the corresponding
    PCMonReq message.\n   Upon receiving a PCReq message that carries a MONITORING
    and\n   potentially other monitoring objects (e.g., PCE-ID object):\n   1) As
    specified in [RFC5440], if the PCE does not support (in-band)\n      monitoring,
    the PCE peer MUST send a PCErr message with Error-\n      value=2 (capability
    not supported).  According to the procedure\n      defined in Section 6.9 of [RFC5440],
    if a PCC/PCE receives\n      unrecognized messages at a rate equal or greater
    than a specified\n      rate, the PCC/PCE must send a PCEP CLOSE message with
    close\n      value=5 \"Reception of an unacceptable number of unrecognized PCEP\n
    \     messages\".  In this case, the PCC/PCE must also close the TCP\n      session
    and must not send any further PCEP messages on the PCEP\n      session.\n   2)
    If the PCE supports the monitoring request but the monitoring\n      request is
    prohibited by policy, the PCE must follow the procedure\n      specified in Section
    5.  As pointed out in Section 4.3, a PCE may\n      still partially satisfy a
    request, leaving out some of the\n      required data if not allowed by policy.\n
    \  3) If the PCE supports the monitoring request and that request is not\n      prohibited
    by policy, the receiving PCE MUST first determine\n      whether it is the last
    PCE of the path computation chain.  If the\n      PCE is not the last element
    of the path computation chain, the\n      PCReq message (with the MONITORING object
    and potentially other\n      monitoring objects such as the PCE-ID) is relayed
    to the next-hop\n      PCE: such a next hop may be either specified by means of
    a PCE-ID\n      object present in the PCReq message or dynamically determined
    by\n      means of a procedure outside of the scope of this document.\n      Conversely,
    if the PCE is the last PCE of the path computation\n      chain, the PCE originates
    a PCRep message that contains the\n      requested objects according to the set
    of requested PCE states\n      metrics listed in the MONITORING and potentially
    other monitoring\n      objects carried in the corresponding PCReq message.\n
    \  Upon receiving a PCMonRep message, the PCE processes the request,\n   adds
    the relevant objects to the PCMonRep message and forwards the\n   PCMonRep message
    to the upstream requesting PCE or PCC.\n   Upon receiving a PCRep message that
    carries monitoring data, the\n   message is processed, additional monitoring data
    is added according\n   to this specification, and the message is forwarded upstream
    to the\n   requesting PCE or PCC.\n"
  title: 6.  Elements of Procedure
- contents:
  - '7.  Manageability Considerations

    '
  - contents:
    - "7.1.  Control of Function and Policy\n   It MUST be possible to configure the
      activation/deactivation of PCEP\n   monitoring on a PCEP speaker.  In addition
      to the parameters already\n   listed in Section 8.1 of [RFC5440], a PCEP implementation
      SHOULD\n   allow configuring on a PCE whether or not specific, generic, in-band\n
      \  and out-of-band monitoring requests are allowed.  Also, a PCEP\n   implementation
      SHOULD allow configuring on a PCE a list of authorized\n   state metrics (aliveness,
      overload, processing time, etc.).  This may\n   apply to any session in which
      the PCEP speaker participates, to a\n   specific session with a given PCEP peer
      or to a specific group of\n   sessions with a specific group of PCEP peers,
      for instance, the PCEP\n   peers of a neighbor AS.\n"
    title: 7.1.  Control of Function and Policy
  - contents:
    - "7.2.  Information and Data Models\n   A new MIB Module may be defined that
      provides local PCE state\n   metrics, as well as state metrics of other PCEs
      gathered using\n   mechanisms defined in this document.\n"
    title: 7.2.  Information and Data Models
  - contents:
    - "7.3.  Liveness Detection and Monitoring\n   This document provides mechanisms
      to monitor the liveliness and\n   performances of a given path computation chain.\n"
    title: 7.3.  Liveness Detection and Monitoring
  - contents:
    - "7.4.  Verify Correct Operations\n   Mechanisms defined in this document do
      not imply any new operation\n   verification requirements in addition to those
      already listed in\n   [RFC5440].\n"
    title: 7.4.  Verify Correct Operations
  - contents:
    - "7.5.  Requirements on Other Protocols\n   Mechanisms defined in this document
      do not imply any requirements on\n   other protocols in addition to those already
      listed in [RFC5440].\n"
    title: 7.5.  Requirements on Other Protocols
  - contents:
    - "7.6.  Impact on Network Operations\n   The frequency of PCMonReq messages may
      impact the operations of PCEs.\n   An implementation SHOULD allow a limit to
      be placed on the rate of\n   PCMonReq messages sent by a PCEP speaker and processed
      from a peer.\n   It SHOULD also allow sending a notification when a rate threshold
      is\n   reached.  An implementation SHOULD allow handling PCReq messages with\n
      \  a higher priority than PCMonReq messages.  An implementation SHOULD\n   allow
      the configuration of a second limit for the PCReq message\n   requesting monitoring
      data.\n"
    title: 7.6.  Impact on Network Operations
  title: 7.  Manageability Considerations
- contents:
  - "8.  Guidelines to Avoid Overload Thrashing\n   An important concern while processing
    overload information is to\n   prevent the overload condition on one PCE simply
    being moved to\n   another PCE.  Indeed, there is a risk that the reaction to
    an\n   indication of overload will act to increase the amount of overload\n   within
    the network.  Furthermore, this may lead to oscillations\n   between PCEs if the
    overload information is not handled properly.\n   This section presents some brief
    guidance on how a PCC (which term\n   includes a PCE making requests of another
    PCE) should react when it\n   receives an indication that a PCE is overloaded.\n
    \  When an overload indication is received (on a PCRep message or on a\n   PCMonRep
    message), it identifies that new PCReq messages sent to the\n   PCE might be subject
    to a delay equal to the value in the Overload\n   Duration field (when present).\n
    \  It also indicates that PCReq messages already queued at the PCE might\n   be
    subject to a delay.  The PCC must decide how to handle new PCReq\n   messages
    and what to do about PCReq messages already queued at the\n   PCE.\n   It is RECOMMENDED
    that a PCC does not cancel a queued PCReq and\n   reissue it to another PCE because
    of the PCE being overloaded.\n   Such behavior is likely to result in overload
    thrashing as multiple\n   PCCs move the PCE queue to another PCE.  This would
    simply introduce\n   additional delay in the processing of all requests.  A PCC
    MAY choose\n   to cancel a queued PCE request if it is willing to sacrifice the\n
    \  request, maybe reissuing it later (after the overload condition has\n   been
    determined to have cleared by use of a PCMonReq/Rep exchange).\n   It is then
    RECOMMENDED to send the cancellation request with a higher\n   priority in order
    for the overloaded PCE to detect the request\n   cancellation before processing
    the related request.\n   A PCC that is aware of PCE overload at one PCE MAY select
    a different\n   PCE to service its next PCReq message.  In doing so, it is\n   RECOMMENDED
    that the PCC consider whether the other PCE is overloaded\n   or might be likely
    to become overloaded by other PCCs similarly\n   directing new PCReq messages.\n
    \  Furthermore, should the second PCE be also overloaded, it is\n   RECOMMENDED
    not to make any attempt to switch back to the other PCE\n   without knowing that
    the first PCE is no longer overloaded.\n"
  title: 8.  Guidelines to Avoid Overload Thrashing
- contents:
  - '9.  IANA Considerations

    '
  - contents:
    - "9.1.  New PCEP Message\n   Each PCEP message has a message type value.\n   Two
      new PCEP (specified in [RFC5440]) messages are defined in this\n   document:\n
      \  Value  Description                                      Reference\n     8
      \   Path Computation Monitoring Request (PCMonReq)   This document\n     9    Path
      Computation Monitoring Reply (PCMonRep)     This document\n"
    title: 9.1.  New PCEP Message
  - contents:
    - "9.2.  New PCEP Objects\n   Each PCEP object has an Object-Class and an Object-Type.
      \ The\n   following new PCEP objects are defined in this document:\n   Object-Class
      Value Name        Object-Type             Reference\n          19          MONITORING
      \ 1                       This document\n          20          PCC-REQ-ID  1:
      IPv4 addresses       This document\n                                  2: IPv6
      addresses\n          25          PCE-ID      1: IPv4 addresses       This document\n
      \                                 2: IPv6 addresses       This document\n          26
      \         PROC-TIME   1                       This document\n          27          OVERLOAD
      \   1: overload             This document\n"
    title: 9.2.  New PCEP Objects
  - contents:
    - "9.3.  New Error-Values\n   A registry was created for the Error-type and Error-value
      of the PCEP\n   Error Object.\n   A new Error-value for the PCErr message Error-type=5
      (Policy\n   Violation) (see [RFC5440]) is defined in this document.\n   Error-type
      \ Meaning           Error-value             Reference\n      5        Policy
      violation  6: Monitoring message   This document\n                                 supported
      but rejected\n                                 due to policy violation\n   A
      new Error-value for the PCErr message Error-type=6 (Mandatory\n   object missing)
      (see [RFC5440]) is defined in this document.\n   Error-type  Meaning           Error-value
      \            Reference\n      6        Mandatory Object  4: MONITORING object
      \   This document\n               missing           missing\n"
    title: 9.3.  New Error-Values
  - contents:
    - "9.4.  MONITORING Object Flag Field\n   IANA has created a registry to manage
      the Flag field of\n   the MONITORING object.\n   New bit numbers may be allocated
      only by an IETF Review.  Each bit\n   should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      Description\n   o  Defining RFC\n   Several bits are defined for the MONITORING
      Object flag field in this\n   document:\n   Codespace of the Flag field (MONITORING
      Object)\n    Bit      Description         Reference\n   0-18      Unassigned\n
      \    19      Incomplete          This document\n     20      Overload            This
      document\n     21      Processing Time     This document\n     22      General
      \            This document\n     23      Liveness            This document\n"
    title: 9.4.  MONITORING Object Flag Field
  - contents:
    - "9.5.  PROC-TIME Object Flag Field\n   IANA has created a registry to manage
      the Flag field of the PROC-TIME\n   object.\n   New bit numbers may be allocated
      only by an IETF Review.  Each bit\n   should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      Description\n   o  Defining RFC\n   One bit is defined for the PROC-TIME Object
      flag field in this\n   document:\n   Codespace of the Flag field (PROC-TIME
      Object)\n    Bit      Description             Reference\n   0-14      Unassigned\n
      \    15      Estimated               This document\n"
    title: 9.5.  PROC-TIME Object Flag Field
  - contents:
    - "9.6.  OVERLOAD Object Flag Field\n   IANA has created a registry to manage
      the Flag field of the OVERLOAD\n   object.\n   New bit numbers may be allocated
      only by an IETF Review.  Each bit\n   should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      Description\n   o  Defining RFC\n   No Flag is currently defined for the OVERLOAD
      Object flag field in\n   this document.\n   Codespace of the Flag field (OVERLOAD
      Object)\n     Bit      Description             Reference\n     0-7      Unassigned\n"
    title: 9.6.  OVERLOAD Object Flag Field
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   The use of monitoring data can be used for various
    attacks such as\n   denial-of-service (DoS) attacks (for example, by setting the
    C bit\n   and overload duration field of the OVERLOAD object to stop PCCs from\n
    \  using a PCE).  Thus, it is recommended to make use of the security\n   mechanisms
    discussed in [RFC5440] to secure a PCEP session\n   (authenticity, integrity,
    privacy, and DoS protection, etc.) to\n   secure the PCMonReq and PCMonRep messages
    and PCE state metric\n   objects defined in this document.  An implementation
    SHOULD allow\n   limiting the rate at which PCMonReq or PCReq messages carrying\n
    \  monitoring requests received from a specific peer are processed\n   (input
    shaping) as discussed in Section 10.7.2 of [RFC5440], or from\n   another domain
    (see also Section 7.6).\n"
  title: 10.  Security Considerations
- contents:
  - "11.  Acknowledgments\n   The authors would like to thank Eiji Oki, Mach Chen,
    Fabien\n   Verhaeghe, Dimitri Papadimitriou, and Francis Dupont for their useful\n
    \  comments.  Special thanks to Adrian Farrel for his detailed review.\n"
  title: 11.  Acknowledgments
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC5440]  Vasseur, JP., Ed., and JL. Le Roux, Ed., \"Path Computation\n
      \             Element (PCE) Communication Protocol (PCEP)\", RFC 5440,\n              March
      2009.\n   [RFC5511]  Farrel, A., \"Routing Backus-Naur Form (RBNF): A Syntax\n
      \             Used to Form Encoding Rules in Various Routing Protocol\n              Specifications\",
      RFC 5511, April 2009.\n   [RFC5521]  Oki, E., Takeda, T., and A. Farrel, \"Extensions
      to the\n              Path Computation Element Communication Protocol (PCEP)
      for\n              Route Exclusions\", RFC 5521, April 2009.\n   [RFC5541]  Le
      Roux, JL., Vasseur, JP., and Y. Lee, \"Encoding of\n              Objective
      Functions in the Path Computation Element\n              Communication Protocol
      (PCEP)\", RFC 5541, June 2009.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC4655]  Farrel, A., Vasseur, J.-P., and
      J. Ash, \"A Path\n              Computation Element (PCE)-Based Architecture\",
      RFC 4655,\n              August 2006.\n   [RFC5088]  Le Roux, JL., Ed., Vasseur,
      JP., Ed., Ikejiri, Y., and R.\n              Zhang, \"OSPF Protocol Extensions
      for Path Computation\n              Element (PCE) Discovery\", RFC 5088, January
      2008.\n   [RFC5089]  Le Roux, JL., Ed., Vasseur, JP., Ed., Ikejiri, Y., and
      R.\n              Zhang, \"IS-IS Protocol Extensions for Path Computation\n
      \             Element (PCE) Discovery\", RFC 5089, January 2008.\n   [RFC5441]
      \ Vasseur, JP., Ed., Zhang, R., Bitar, N., and JL. Le Roux,\n              \"A
      Backward-Recursive PCE-Based Computation (BRPC)\n              Procedure to
      Compute Shortest Constrained Inter-Domain\n              Traffic Engineering
      Label Switched Paths\", RFC 5441, April\n              2009.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Authors' Addresses\n   JP. Vasseur (editor)\n   Cisco Systems, Inc.\n   1414
    Massachusetts Avenue\n   Boxborough, MA 01719\n   USA\n   EMail: jpv@cisco.com\n
    \  JL. Le Roux\n   France Telecom\n   2, Avenue Pierre-Marzin\n   Lannion 22307\n
    \  France\n   EMail: jeanlouis.leroux@orange-ftgroup.com\n   Yuichi Ikejiri\n
    \  NTT Communications Corporation\n   1-1-6, Uchisaiwai-cho, Chiyoda-ku\n   Tokyo
    100-8019\n   Japan\n   EMail: y.ikejiri@ntt.com\n"
  title: Authors' Addresses
