- title: __initial_text__
  contents:
  - '             Signaling Compression (SigComp) Torture Tests

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document provides a set of \"torture tests\" for implementers\
    \ of\n   the Signaling Compression (SigComp) protocol.  The torture tests\n  \
    \ check each of the SigComp Universal Decompressor Virtual Machine\n   instructions\
    \ in turn, focusing in particular on the boundary and\n   error cases that are\
    \ not generally encountered when running\n   well-behaved compression algorithms.\
    \  Tests are also provided for\n   other SigComp entities such as the dispatcher\
    \ and the state handler.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Torture Tests for UDVM ..........................................4\n  \
    \    2.1. Bit Manipulation ...........................................4\n    \
    \  2.2. Arithmetic .................................................5\n      2.3.\
    \ Sorting ....................................................7\n      2.4. SHA-1\
    \ ......................................................8\n      2.5. LOAD and\
    \ MULTILOAD .........................................9\n      2.6. COPY ......................................................11\n\
    \      2.7. COPY-LITERAL and COPY-OFFSET ..............................12\n  \
    \    2.8. MEMSET ....................................................14\n    \
    \  2.9. CRC .......................................................15\n      2.10.\
    \ INPUT-BITS ...............................................16\n      2.11. INPUT-HUFFMAN\
    \ ............................................17\n      2.12. INPUT-BYTES ..............................................19\n\
    \      2.13. Stack Manipulation .......................................20\n  \
    \    2.14. Program Flow .............................................22\n    \
    \  2.15. State Creation ...........................................23\n      2.16.\
    \ STATE-ACCESS .............................................26\n   3. Torture\
    \ Tests for Dispatcher ...................................28\n      3.1. Useful\
    \ Values .............................................28\n      3.2. Cycles Checking\
    \ ...........................................31\n      3.3. Message-based Transport\
    \ ...................................32\n      3.4. Stream-based Transport ....................................34\n\
    \      3.5. Input Past the End of a Message ...........................36\n  \
    \ 4. Torture Tests for State Handler ................................38\n    \
    \  4.1. SigComp Feedback Mechanism ................................38\n      4.2.\
    \ State Memory Management ...................................41\n      4.3. Multiple\
    \ Compartments .....................................44\n      4.4. Accessing RFC\
    \ 3485 State ..................................49\n      4.5. Bytecode State Creation\
    \ ...................................50\n   5. Security Considerations ........................................53\n\
    \   6. Acknowledgements ...............................................53\n  \
    \ 7. Normative References ...........................................53\n   Appendix\
    \ A.  UDVM Bytecode for the Torture Tests ..................54\n      A.1. Instructions\
    \ ..............................................54\n           A.1.1. Bit Manipulation\
    \ ...................................54\n           A.1.2. Arithmetic .........................................55\n\
    \           A.1.3. Sorting ............................................55\n  \
    \         A.1.4. SHA-1 ..............................................56\n    \
    \       A.1.5. LOAD and MULTILOAD .................................56\n      \
    \     A.1.6. COPY ...............................................56\n        \
    \   A.1.7. COPY-LITERAL and COPY-OFFSET .......................57\n          \
    \ A.1.8. MEMSET .............................................57\n           A.1.9.\
    \ CRC ................................................57\n           A.1.10. INPUT-BITS\
    \ ........................................57\n           A.1.11. INPUT-HUFFMAN\
    \ .....................................58\n           A.1.12. INPUT-BYTES .......................................58\n\
    \           A.1.13. Stack Manipulation ................................58\n  \
    \         A.1.14. Program Flow ......................................59\n    \
    \       A.1.15. State Creation ....................................59\n      \
    \     A.1.16. STATE-ACCESS ......................................60\n      A.2.\
    \ Dispatcher Tests ..........................................61\n           A.2.1.\
    \ Useful Values ......................................61\n           A.2.2. Cycles\
    \ Checking  ...................................62\n           A.2.3. Message-based\
    \ Transport ............................62\n           A.2.4. Stream-based Transport\
    \ .............................62\n           A.2.5. Input Past the End of a Message\
    \ ....................63\n      A.3. State Handler Tests .......................................64\n\
    \           A.3.1. SigComp Feedback Mechanism .........................64\n  \
    \         A.3.2. State Memory Management ............................64\n    \
    \       A.3.3. Multiple Compartments ..............................65\n      \
    \     A.3.4. Accessing RFC 3485 State ...........................66\n        \
    \   A.3.5. Bytecode State Creation ............................66\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document provides a set of \"torture tests\" for implementers\
    \ of\n   the SigComp protocol, RFC 3320 [2].  The idea behind SigComp is to\n\
    \   standardize a Universal Decompressor Virtual Machine (UDVM) that can\n   be\
    \ programmed to understand the output of many well-known compressors\n   including\
    \ DEFLATE and LZW.  The bytecode for the chosen decompressor\n   is uploaded to\
    \ the UDVM as part of the SigComp message flow.\n   The SigComp User's Guide [1]\
    \ gives examples of a number of different\n   algorithms that can be used by the\
    \ SigComp protocol.  However, the\n   bytecode for the corresponding decompressors\
    \ is relatively well\n   behaved and does not test the boundary and error cases\
    \ that may\n   potentially be exploited by malicious SigComp messages.\n   This\
    \ document is divided into a number of sections, each containing a\n   piece of\
    \ code designed to test a particular function of one of the\n   SigComp entities\
    \ (UDVM, dispatcher, and state handler).  The specific\n   boundary and error\
    \ cases tested by the bytecode are also listed, as\n   are the output the code\
    \ should produce and the number of UDVM cycles\n   that should be used.\n   Each\
    \ test runs in the SigComp minimum decompression memory size (that\n   is, 2K),\
    \ within the minimum number of cycles per bit (that is, 16)\n   and in tests where\
    \ state is stored 2K state memory size is needed.\n"
- title: 2.  Torture Tests for UDVM
  contents:
  - "2.  Torture Tests for UDVM\n   The following sections each provide code to test\
    \ one or more UDVM\n   instructions.  In the interests of readability, the code\
    \ is given\n   using the SigComp assembly language: a description of how to convert\n\
    \   this assembly code into UDVM bytecode can be found in the SigComp\n   User's\
    \ Guide [1].\n   The raw UDVM bytecode for each torture test is given in Appendix\
    \ A.\n   Each section also lists the number of UDVM cycles required to execute\n\
    \   the code.  Note that this figure only takes into account the cost of\n   executing\
    \ each UDVM instruction (in particular, it ignores the fact\n   that the UDVM\
    \ can gain extra cycles as a result of inputting more\n   data).\n"
- title: 2.1.  Bit Manipulation
  contents:
  - "2.1.  Bit Manipulation\n   This section gives assembly code to test the AND,\
    \ OR, NOT, LSHIFT,\n   and RSHIFT instructions.  When the instructions have a\
    \ multitype\n   operand, the code tests the case where the multitype contains\
    \ a fixed\n   integer value, and the case where it contains a memory address at\n\
    \   which the 2-byte operand value can be found.  In addition, the code\n   is\
    \ designed to test that the following boundary cases have been\n   correctly implemented:\n\
    \   1.  The instructions overwrite themselves with the result of the bit\n   \
    \    manipulation operation, in which case execution continues\n       normally.\n\
    \   2.  The LSHIFT or RSHIFT instructions shift bits beyond the 2-byte\n     \
    \  boundary, in which case the bits must be discarded.\n   3.  The UDVM registers\
    \ byte_copy_left and byte_copy_right are used to\n       store the results of\
    \ the bit manipulation operations.  Since no\n       byte copying is taking place,\
    \ these registers should behave in\n       exactly the same manner as ordinary\
    \ UDVM memory addresses.\n   at (64)\n   :a                              pad (2)\n\
    \   :b                              pad (2)\n   at (128)\n   JUMP (start)    \
    \        ; Jump to address 255\n   at (255)\n   :start\n   ; The multitypes are\
    \ values\n                           ; $start = 448 (first 2 bytes of AND instr)\n\
    \   AND ($start, 21845)     ; 448 & 21845 = 320 = 0x0140\n   OR ($a, 42)     \
    \        ; 0 | 42 = 42 = 0x002a\n   NOT ($b)                ; ~0 = 65535 = 0xffff\n\
    \   LSHIFT ($a, 3)          ; 42 << 3 = 336 = 0x0150\n   RSHIFT ($b, 65535)  \
    \    ; 65535 >> 65535 = 0 = 0x0000\n   OUTPUT (64, 4)          ; Output 0x0150\
    \ 0000\n   ; The multitypes are references\n   AND ($a, $start)        ; 336 &\
    \ 320 = 320 = 0x0140\n   OR ($a, $a)             ; 320 | 320 = 320 = 0x0140\n\
    \   NOT ($a)                ; ~320 = 65215 = 0xfebf\n   LSHIFT ($b, $a)      \
    \   ; 0 << 65215 = 0 = 0x0000\n   RSHIFT ($a, $b)         ; 65215 >> 0 = 65215\
    \ = 0xfebf\n   OUTPUT (64, 4)          ; Output 0xfebf 0000\n   END-MESSAGE (0,\
    \ 0, 0, 0, 0, 0, 0)\n   The output of the code is 0x0150 0000 febf 0000.  Executing\
    \ the code\n   costs a total of 22 UDVM cycles.\n"
- title: 2.2.  Arithmetic
  contents:
  - "2.2.  Arithmetic\n   This section gives assembly code to test the ADD, SUBTRACT,\
    \ MULTIPLY,\n   DIVIDE, and REMAINDER instructions.  The code is designed to test\n\
    \   that the following boundary cases have been correctly implemented:\n   1.\
    \  The instructions overwrite themselves with the result of the\n       arithmetic\
    \ operation, resulting in continuation as if the bytes\n       were not bytecode.\n\
    \   2.  The result does not lie between 0 and 2^16 - 1 inclusive, in\n       which\
    \ case it must be taken modulo 2^16.\n   3.  The divisor in the DIVIDE or REMAINDER\
    \ instructions is 0 (in\n       which case decompression failure must occur).\n\
    \   at (64)\n   :a                              pad (2)\n   :b               \
    \               pad (2)\n   :type                           pad (1)\n   :type_lsb\
    \                       pad (1)\n   at (128)\n   INPUT-BYTES (1, type_lsb, decomp_failure)\n\
    \   SUBTRACT ($type, 1)\n   JUMP (start)\n   :decomp_failure\n   DECOMPRESSION-FAILURE\n\
    \   ; Now the value in $type should be 0xffff, 0x0000, or 0x0001\n   ; according\
    \ to whether the input was 0x00, 0x01, or 0x02.\n   at (255)\n   :start\n   ;\
    \ The multitypes are values\n                           ; For all three messages\n\
    \                           ; $start = 1728 (first 2 bytes of ADD instr)\n   ADD\
    \ ($start, 63809)     ; 1728 + 63809 = 1 = 0x0001\n   SUBTRACT ($a, 1)       \
    \ ; 0 - 1 = 65535 = 0xffff\n   MULTIPLY ($a, 1001)     ; 65535 * 1001 = 64535\
    \ = 0xfc17\n   DIVIDE ($a, 101)        ; 64535 / 101 = 638 = 0x027e\n   REMAINDER\
    \ ($a, 11)      ; 638 % 11 = 0 = 0x0000\n   OUTPUT (64, 4)          ; output 0x0000\
    \ 0000\n   ; The multitypes are references\n   ADD ($b, $start)        ; 0 + 1\
    \ = 1 = 0x0001\n                           ; If the message is 0x00\n   SUBTRACT\
    \ ($b, $type)    ; 1 - 65535 = 2 = 0x0002\n   MULTIPLY ($b, $b)       ; 2 * 2\
    \ = 4 = 0x0004\n   DIVIDE ($a, $b)         ; 0 / 4 = 0 = 0x0000\n   REMAINDER\
    \ ($b, $type)   ; 4 % 65535 = 4 = 0x0004\n   OUTPUT (64, 4)          ; output\
    \ 0x0000 0004\n                           ; If the message is 0x01, $type = 0\n\
    \                           ; so decompression failure occurs at\n           \
    \                ; REMAINDER ($b, $type)\n                           ; If the\
    \ message is 0x02, $type = 1 so\n                           ; $b becomes 0 and\
    \ decompression failure\n                           ; occurs at DIVIDE ($a, $b)\n\
    \   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   If the compressed message is 0x00, then\
    \ the output of the code is\n   0x0000 0000 0000 0004 and the execution cost should\
    \ be 25 UDVM\n   cycles.  However, if the compressed message is 0x01 or 0x02,\
    \ then\n   decompression failure occurs.\n"
- title: 2.3.  Sorting
  contents:
  - "2.3.  Sorting\n   This section gives assembly code to test the SORT-ASCENDING\
    \ and SORT-\n   DESCENDING instructions.  The code is designed to test that the\n\
    \   following boundary cases have been correctly implemented:\n   1.  The sorting\
    \ instructions sort integers with the same value, in\n       which case the original\
    \ ordering of the integers must be\n       preserved.\n   at (128)\n   SORT-DESCENDING\
    \ (256, 2, 23)\n   SORT-ASCENDING (256, 2, 23)\n   OUTPUT (302, 45)\n   END-MESSAGE\
    \ (0, 0, 0, 0, 0, 0, 0)\n   at (256)\n   word (10, 10, 17, 7, 22, 3, 3, 3, 19,\
    \ 1, 16, 14, 8, 2, 13, 20, 18,\n   23, 15, 21, 12, 6, 9)\n   word (28263, 8297,\
    \ 30057, 8308, 26996, 11296, 31087, 29991, 8275,\n   18031, 28263, 24864, 30066,\
    \ 29284, 28448, 29807, 28206, 11776, 28773,\n   28704, 28276, 29285, 28265)\n\
    \   The output of the code is 0x466f 7264 2c20 796f 7527 7265 2074 7572\n   6e69\
    \ 6e67 2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 7020 6974\n   2e, and\
    \ the number of cycles required is 371.\n"
- title: 2.4.  SHA-1
  contents:
  - "2.4.  SHA-1\n   This section gives assembly code to test the SHA-1 instruction.\
    \  The\n   code performs four tests on the SHA-1 algorithm itself and, in\n  \
    \ addition, checks the following boundary cases specific to the UDVM:\n   1. \
    \ The input string for the SHA-1 hash is obtained by byte copying\n       over\
    \ an area of the UDVM memory.\n   2.  The SHA-1 hash overwrites its own input\
    \ string.\n   at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right\
    \                pad (2)\n   :hash_value                     pad (20)\n   at (128)\n\
    \   SHA-1 (test_one, 3, hash_value)\n   OUTPUT (hash_value, 20)\n   SHA-1 (test_two,\
    \ 56, hash_value)\n   OUTPUT (hash_value, 20)\n   ; Set up a 1-byte buffer\n \
    \  LOAD (byte_copy_left, test_three)\n   LOAD (byte_copy_right, test_four)\n \
    \  ; Perform SHA-1 over 16384 bytes in a 1-byte buffer\n   SHA-1 (test_three,\
    \ 16384, hash_value)\n   OUTPUT (hash_value, 20)\n   ; Set up an 8-byte buffer\n\
    \   LOAD (byte_copy_left, test_four)\n   LOAD (byte_copy_right, test_end)\n  \
    \ ; Perform SHA-1 over 640 bytes in an 8-byte buffer\n   SHA-1 (test_four, 640,\
    \ test_four)\n   OUTPUT (test_four, 20)\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n\
    \   :test_one\n   byte (97, 98, 99)\n   :test_two\n   byte (97, 98, 99, 100, 98,\
    \ 99, 100, 101, 99, 100, 101, 102, 100, 101,\n   102, 103, 101, 102, 103, 104,\
    \ 102, 103, 104, 105, 103, 104, 105, 106,\n   104, 105, 106, 107, 105, 106, 107,\
    \ 108, 106, 107, 108, 109, 107, 108,\n   109, 110, 108, 109, 110, 111, 109, 110,\
    \ 111, 112, 110, 111, 112, 113)\n   :test_three\n   byte (97)\n   :test_four\n\
    \   byte (48, 49, 50, 51, 52, 53, 54, 55)\n   :test_end\n   The output of the\
    \ code is as follows:\n   0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0 d89d\n\
    \   0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1\n   0x12ff 347b 4f27 d69e\
    \ 1f32 8e6f 4b55 73e3 666e 122f\n   0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393\
    \ 4f46 0452\n   Executing the code costs a total of 17176 UDVM cycles.\n"
- title: 2.5.  LOAD and MULTILOAD
  contents:
  - "2.5.  LOAD and MULTILOAD\n   This section gives assembly code to test the LOAD\
    \ and MULTILOAD\n   instructions.  The code is designed to test the following\
    \ boundary\n   cases:\n   1.  The MULTILOAD instruction overwrites itself or any\
    \ of its\n       operands, in which case decompression failure occurs.\n   2.\
    \  The memory references of MULTILOAD instruction operands are\n       evaluated\
    \ step-by-step rather than all at once before starting to\n       copy data.\n\
    \   at (64)\n   :start                          pad (1)\n   :start_lsb       \
    \               pad (1)\n   at (128)\n   set (location_a, 128)\n   set (location_b,\
    \ 132)\n   LOAD (128, 132)                 ; address 128 contains 132 = 0x0084\n\
    \   LOAD (130, $location_a)         ; address 130 contains 132 = 0x0084\n   LOAD\
    \ ($location_a, 134)         ; address 132 contains 134 = 0x0086\n   LOAD ($location_b,\
    \ $location_b) ; address 134 contains 134 = 0x0086\n   OUTPUT (128, 8)       \
    \          ; output 0x0084 0084 0086 0086\n   INPUT-BYTES (1, start_lsb, decompression_failure)\n\
    \   MULTIPLY ($start, 2)\n   ADD ($start, 60)\n   MULTILOAD ($start, 3, overlap_start,\
    \ overlap_end, 128)\n   :position\n   set (overlap_start, (position - 7))\n  \
    \ MULTILOAD ($start, 4, 42, 128, $location_a, $location_b)\n   :end\n   set (overlap_end,\
    \ (end - 1))\n   OUTPUT (128, 8)\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   :decompression_failure\n\
    \   DECOMPRESSION-FAILURE\n   The INPUT-BYTES, MULTIPLY, and ADD instructions\
    \ give the following\n   values for $start = $64 just before the MULTILOADs begin:\n\
    \   Input     $start before 1st MULTILOAD\n   0x00            60\n   0x01    \
    \        62\n   0x02            64\n   Consequently, after the first MULTILOAD\
    \ the values of $start are the\n   following:\n   Input     $start before 2nd\
    \ MULTILOAD\n   0x00      128\n   0x01      overlap_end = 177 = last byte of 2nd\
    \ MULTILOAD instruction\n   0x02      overlap_start = 162 = 7 bytes before 2nd\
    \ MULTILOAD\n             instruction\n   Consequently, execution of the 2nd MULTILOAD\
    \ (and any remaining code)\n   gives the following:\n   Input   Outcome\n   0x00\
    \    MULTILOAD reads and writes operand by operand.  The output is\n         \
    \  0x0084 0084 0086 0086 002a 0080 002a 002a, and the cost of\n           executing\
    \ the code is 36 UDVM cycles.\n   0x01    The first write of the MULTILOAD instruction\
    \ would overwrite\n           the last byte of the final MULTILOAD operand, so\n\
    \           decompression failure occurs.\n   0x02    The last write of the MULTILOAD\
    \ would overwrite the MULTILOAD\n           opcode, so decompression failure occurs.\n"
- title: 2.6.  COPY
  contents:
  - "2.6.  COPY\n   This section gives assembly code to test the COPY instruction.\
    \  The\n   code is designed to test that the following boundary cases have been\n\
    \   correctly implemented:\n   1.  The COPY instruction copies data from both\
    \ outside the circular\n       buffer and inside the circular buffer within the\
    \ same operation.\n   2.  The COPY instruction performs byte-by-byte copying (i.e.,\
    \ some of\n       the later bytes to be copied are themselves written into the\
    \ UDVM\n       memory by the COPY instruction currently being executed).\n   3.\
    \  The COPY instruction overwrites itself and continues executing.\n   4.  The\
    \ COPY instruction overwrites the UDVM registers byte_copy_left\n       and byte_copy_right.\n\
    \   5.  The COPY instruction writes to and reads from the right of the\n     \
    \  buffer beginning at byte_copy_right.\n   6.  The COPY instruction implements\
    \ byte copying rules when the\n       destination wraps around the buffer.\n \
    \  at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right  \
    \              pad (2)\n   at (128)\n                           ; Set up buffer\
    \ between addresses 64 & 128\n   LOAD (32, 16384)\n   LOAD (byte_copy_left, 64)\n\
    \   LOAD (byte_copy_right, 128)\n   COPY (32, 128, 33)      ; Copy byte by byte\
    \ starting to the left of\n                           ; the buffer, into the buffer\
    \ and wrapping\n                           ; the buffer (inc overwriting the\n\
    \                           ; boundaries)\n   LOAD (64, 16640)        ; Change\
    \ the start of the buffer to be\n                           ; beyond bytecode\n\
    \   COPY (64, 85, 65)       ; Copy to the left of the buffer,\n              \
    \             ; overwriting this instruction\n   OUTPUT (32, 119)        ; Output\
    \ 32 * 0x40 + 86 * 0x41 + 0x55,\n                           ; which is 32 * '@'\
    \ + 86 'A' + 'U'\n                           ; Set a new small buffer\n   LOAD\
    \ (byte_copy_left, 32)\n   LOAD (byte_copy_right, 48)\n   MEMSET (32, 4, 65, 1)\
    \   ; Set first 4 bytes of the buffer to be\n                           ; 'ABCD'\n\
    \   COPY (32, 4, 48)        ; Copy from byte_copy_right (i.e., not\n         \
    \                  ; in buffer)\n   OUTPUT (48, 4)          ; Output 0x4142 4344,\
    \ which is 'ABCD'\n   COPY (48, 4, 46)        ; Copy from two before byte_copy_right\
    \ to\n                           ; wrap around the buffer\n   OUTPUT (32, 2) \
    \         ; Output 0x4344, which is 'CD'\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n\
    \   The output is above, and executing the code costs a total of 365 UDVM\n  \
    \ cycles.\n"
- title: 2.7.  COPY-LITERAL and COPY-OFFSET
  contents:
  - "2.7.  COPY-LITERAL and COPY-OFFSET\n   This section gives assembly code to test\
    \ the COPY-LITERAL and COPY-\n   OFFSET instructions.  The code is designed to\
    \ test similar boundary\n   cases to the code for the COPY instruction, as well\
    \ as the following\n   condition specific to COPY-LITERAL and COPY-OFFSET:\n \
    \  1.  The COPY-LITERAL or COPY-OFFSET instruction overwrites the value\n    \
    \   of its destination.\n   2.  The COPY-OFFSET instruction reads from an offset\
    \ that wraps\n       around the buffer (i.e., the offset is larger than the distance\n\
    \       between byte_copy_left and the destination).\n   at (64)\n   :byte_copy_left\
    \                 pad (2)\n   :byte_copy_right                pad (2)\n   :destination\
    \                    pad (2)\n   :offset                         pad (2)\n   at\
    \ (128)\n                                   ; Set up circular buffer, source,\
    \ and\n                                   ; destination\n   LOAD (32, 16640)\n\
    \   LOAD (byte_copy_left, 64)\n   LOAD (byte_copy_right, 128)\n   LOAD (destination,\
    \ 33)\n   COPY-LITERAL (32, 128, $destination)    ; Copy from the left of the\n\
    \                           ; buffer overwriting bcl, bcr, and\n             \
    \              ; destination wrapping around the buffer\n   OUTPUT (64, 8)   \
    \       ; Check destination has been updated\n                           ; Output\
    \ 0x4141 4141 0061 4141\n   LOAD (destination, copy)\n   :copy               \
    \    ; Overwrite the copy instruction\n   COPY-LITERAL (32, 2, $destination)\n\
    \   OUTPUT (copy, 2)        ; Output 0x4141\n   LOAD (byte_copy_left, 72)    \
    \   ; Set up new circular buffer\n   LOAD (byte_copy_right, 82)\n   LOAD (destination,\
    \ 82)          ; Set destination to byte_copy_right\n   MEMSET (72, 10, 65, 1)\
    \          ; Fill the buffer with 0x41 - 4A\n   COPY-OFFSET (2, 6, $destination)\
    \    ; Copy from within circular\n                                       ; buffer\
    \ to outside buffer\n   LOAD (offset, 6)\n   COPY-OFFSET ($offset, 4, $destination)\n\
    \                                   ; Copy from byte_copy_right\n            \
    \                       ; so reading outside buffer\n   OUTPUT ($byte_copy_right,\
    \ 10)   ; Output 0x494A 4142 4344 494A 4142,\n                               \
    \    ; which is 'IJABCDIJAB'\n   LOAD (destination, 80)              ; Put destination\
    \ within the\n                                       ; buffer\n   COPY-OFFSET\
    \ (4, 4, $destination)    ; Copy where destination wraps\n   OUTPUT (destination,\
    \ 2)             ; Output 0x004A\n   COPY-OFFSET (5, 4, $destination)    ; Copy\
    \ where offset wraps from\n                                       ; left back\
    \ around to the right\n   OUTPUT (destination, 2)             ; Output 0x004E\n\
    \   OUTPUT ($byte_copy_left, 10)        ; Output the circular buffer\n       \
    \                                ; 0x4748 4845 4647 4748 4546,\n             \
    \                          ; which is 'GHHEFGGHEF'\n   END-MESSAGE (0, 0, 0, 0,\
    \ 0, 0, 0)\n   The output of the code is above, and the cost of execution is 216\n\
    \   UDVM cycles.\n"
- title: 2.8.  MEMSET
  contents:
  - "2.8.  MEMSET\n   This section gives assembly code to test the MEMSET instruction.\
    \  The\n   code is designed to test that the following boundary cases have been\n\
    \   correctly implemented:\n   1.  The MEMSET instruction overwrites the registers\
    \ byte_copy_left\n       and byte_copy_right.\n   2.  The output values of the\
    \ MEMSET instruction do not lie between 0\n       and 255 inclusive (in which\
    \ case they must be taken modulo 2^8).\n   at (64)\n   :byte_copy_left       \
    \          pad (2)\n   :byte_copy_right                pad (2)\n   at (128)\n\
    \   LOAD (byte_copy_left, 128)  ; sets up a circular buffer\n   LOAD (byte_copy_right,\
    \ 129) ; of 1 byte between 0x0080 and 0x0081\n   MEMSET (64, 129, 0, 1)  ; fills\
    \ up the memory in the range\n                        ; 0x0040-0x007f with 0x00,\
    \ ... 0x3f;\n                        ; then it writes successively at\n      \
    \                  ; 0x0080 the following values 0x40, ... 0x80\n            \
    \            ; as a side effect, the values of\n                        ; bcl\
    \ and bcr are modified.\n                        ; before and during the MEMSET:\n\
    \                        ; byte_copy_left: 0x0080 byte_copy_right: 0x0081\n  \
    \                      ; after the MEMSET:\n                        ; byte_copy_left:\
    \ 0x0001 byte_copy_right: 0x0203\n   MEMSET (129, 15, 64, 15)     ; fills the\
    \ memory range 0x0080-0x008f\n                         ; with values 0x40, 0x4f,\
    \ ... 0xf4, 0x03, 0x12.\n                         ; as a side effect, it overwrites\
    \ a\n                         ; part of the code including itself\n   OUTPUT (128,\
    \ 16)      ; outputs 0x8040 4f5e 6d7c 8b9a\n                         ; a9b8 c7d6\
    \ e5f4 0312\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   The output of the code is\
    \ 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312.\n   Executing the code costs 166\
    \ UDVM cycles.\n"
- title: 2.9.  CRC
  contents:
  - "2.9.  CRC\n   This section gives assembly code to test the CRC instruction. \
    \ The\n   code does not test any specific boundary cases (as there do not\n  \
    \ appear to be any) but focuses instead on verifying the CRC algorithm.\n   at\
    \ (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right      \
    \          pad (2)\n   :crc_value                      pad (2)\n   :crc_string_a\
    \                   pad (24)\n   :crc_string_b                   pad (20)\n  \
    \ at (128)\n   MEMSET (crc_string_a, 24, 1, 1)  ; sets up between 0x0046 and 0x005d\n\
    \                                    ; a byte string containing 0x01,\n      \
    \                              ; 0x02, ... 0x18\n   MEMSET (crc_string_b, 20,\
    \ 128, 1) ; sets up between 0x005e and 0x0071\n                              \
    \       ; a byte string containing 0x80,\n                                   \
    \  ; 0x81, ... 0x93\n   INPUT-BYTES (2, crc_value, decompression_failure)\n  \
    \                                  ; reads in 2 bytes representing\n         \
    \                           ; the CRC value of the byte string\n             \
    \                       ; of 44 bytes starting at 0x0046\n   CRC ($crc_value,\
    \ crc_string_a, 44, decompression_failure)\n                                 \
    \     ; computes the CRC value of the\n                                      ;\
    \ byte string crc_string_a\n                                      ; concatenated\
    \ with byte string\n                                      ; crc_string_b (with\
    \ a total\n                                      ; length of 44 bytes).\n    \
    \                                  ; if the computed value does\n            \
    \                          ; not match the 2-byte value read\n               \
    \                       ; previously, the program ends\n                     \
    \                 ; with DECOMPRESSION-FAILURE.\n   END-MESSAGE (0, 0, 0, 0, 0,\
    \ 0, 0)\n   :decompression_failure\n   DECOMPRESSION-FAILURE\n   If the compressed\
    \ message is 0x62cb, then the code should\n   successfully terminate with no output,\
    \ and with a total execution\n   cost of 95 UDVM cycles.  For different 2-byte\
    \ compressed messages,\n   the code should terminate with a decompression failure.\n"
- title: 2.10.  INPUT-BITS
  contents:
  - "2.10.  INPUT-BITS\n   This section gives assembly code to test the INPUT-BITS\
    \ instruction.\n   The code is designed to test that the following boundary cases\
    \ have\n   been correctly implemented:\n   1.  The INPUT-BITS instruction changes\
    \ between any of the four\n       possible bit orderings defined by the input_bit_order\
    \ register.\n   2.  The INPUT-BITS instruction inputs 0 bits.\n   3.  The INPUT-BITS\
    \ instruction requests data that lies beyond the end\n       of the compressed\
    \ message.\n   at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right\
    \                pad (2)\n   :input_bit_order                pad (2)\n   :result\
    \                         pad (2)\n   at (128)\n   :start\n   INPUT-BITS ($input_bit_order,\
    \ result, end_of_message) ; reads in\n                                 ; exactly\
    \ as many bits as the 2-byte\n                                 ; value written\
    \ in the input_bit_order\n                                 ; register, get out\
    \ of the loop when\n                                 ; no more bits are available\
    \ at input.\n   OUTPUT (result, 2) ; outputs as a 2-byte integer\n           \
    \           ; the previously read bits\n   ADD ($input_bit_order, 1)      ; if\
    \ at the beginning of this loop the\n                                  ; register\
    \ input_bit_order is 0,\n   REMAINDER ($input_bit_order, 7) ; then its value varies\
    \ periodically\n                                  ; like this: 2, 4, 6, 1, 3,\
    \ 5, 7.\n   ADD ($input_bit_order, 1)      ; that gives for the FHP bits: 010,\n\
    \                                  ; 100, 110, 001, 011, 101, 111\n   JUMP (start)\
    \                    ; run the loop once more\n   :end_of_message\n   END-MESSAGE\
    \ (0, 0, 0, 0, 0, 0, 0)\n   An example of a compressed message is 0x932e ac71,\
    \ which decompresses\n   to give the output 0x0000 0002 0002 0013 0000 0003 001a\
    \ 0038.\n   Executing the code costs 66 UDVM cycles.\n"
- title: 2.11.  INPUT-HUFFMAN
  contents:
  - "2.11.  INPUT-HUFFMAN\n   This section gives assembly code to test the INPUT-HUFFMAN\n\
    \   instruction.  The code is designed to test that the following\n   boundary\
    \ cases have been correctly implemented:\n   1.  The INPUT-HUFFMAN instruction\
    \ changes between any of the four\n       possible bit orderings defined by the\
    \ input_bit_order register.\n   2.  The INPUT-HUFFMAN instruction inputs 0 bits.\n\
    \   3.  The INPUT-HUFFMAN instruction requests data that lies beyond the\n   \
    \    end of the compressed message.\n   at (64)\n   :byte_copy_left          \
    \       pad (2)\n   :byte_copy_right                pad (2)\n   :input_bit_order\
    \                pad (2)\n   :result                         pad (2)\n   at (128)\n\
    \   :start\n   INPUT-HUFFMAN (result, end_of_message, 2, $input_bit_order, 0,\n\
    \   $input_bit_order, $input_bit_order, $input_bit_order, 0, 65535, 0)\n   OUTPUT\
    \ (result, 2)\n   ADD ($input_bit_order, 1)\n   REMAINDER ($input_bit_order, 7)\n\
    \   ADD ($input_bit_order, 1)\n   JUMP (start)\n   :end_of_message\n   END-MESSAGE\
    \ (0, 0, 0, 0, 0, 0, 0)\n   An example of a compressed message is 0x932e ac71\
    \ 66d8 6f, which\n   decompresses to give the output 0x0000 0003 0008 04d7 0002\
    \ 0003 0399\n   30fe.  Executing the code costs 84 UDVM cycles.\n   As the code\
    \ is run, the input_bit_order changes through all possible\n   values to check\
    \ usage of the H and P bits.  The number of bits to\n   input each time is taken\
    \ from the value of input_bit_order.  The\n   sequence is the following:\n   Input_bit_order\
    \ (bin)   Total bits input by Huffman             Value\n   000              \
    \       0                                       0\n   010                    \
    \ 2                                       3\n   100                     4    \
    \                                   8\n   110                     12         \
    \                             1239\n   001\n   P-bit changed, throw away 6 bits\n\
    \   001                     1                                       2\n   011\
    \                     3                                       3\n   101      \
    \               10                                      921\n   111          \
    \           14                                      12542\n   010\n   P-bit changed,\
    \ throw away 4 bits\n   010                     0 - not enough bits so terminate\n"
- title: 2.12.  INPUT-BYTES
  contents:
  - "2.12.  INPUT-BYTES\n   This section gives assembly code to test the INPUT-BYTES\
    \ instruction.\n   The code is designed to test that the following boundary cases\
    \ have\n   been correctly implemented:\n   1.  The INPUT-BYTES instruction inputs\
    \ 0 bytes.\n   2.  The INPUT-BYTES instruction requests data that lies beyond\
    \ the\n       end of the compressed message.\n   3.  The INPUT-BYTES instruction\
    \ is used after part of a byte has been\n       input (e.g., by the INPUT-BITS\
    \ instruction).\n   at (64)\n   :byte_copy_left                 pad (2)\n   :byte_copy_right\
    \                pad (2)\n   :input_bit_order                pad (2)\n   :result\
    \                         pad (2)\n   :output_start                   pad (4)\n\
    \   :output_end\n   at (128)\n   LOAD (byte_copy_left, output_start)\n   LOAD\
    \ (byte_copy_right, output_end)\n   :start\n   INPUT-BITS ($input_bit_order, result,\
    \ end_of_message)\n   OUTPUT (result, 2)\n   ADD ($input_bit_order, 2)\n   REMAINDER\
    \ ($input_bit_order, 7)\n   INPUT-BYTES ($input_bit_order, output_start, end_of_message)\n\
    \   OUTPUT (output_start, $input_bit_order)\n   ADD ($input_bit_order, 1)\n  \
    \ JUMP (start)\n   :end_of_message\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   An\
    \ example of a compressed message is 0x932e ac71 66d8 6fb1 592b dc9a\n   9734\
    \ d847 a733 874e 1bcb cd51 b5dc 9659 9d6a, which decompresses to\n   give the\
    \ output 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8\n   0007 0001 3387\
    \ 4e00 08dc 9651 b5dc 9600 599d 6a.  Executing the code\n   costs 130 UDVM cycles.\n\
    \   As the code is run, the input_bit_order changes through all possible\n   values\
    \ to check usage of the F and P bits.  The number of bits or\n   bytes to input\
    \ each time is taken from the value of input_bit_order.\n   For each INPUT-BYTES\
    \ instruction, the remaining bits of the byte are\n   thrown away.  The P-bit\
    \ always changes on the byte boundary so no\n   bits are thrown away.  The sequence\
    \ is the following:\n   Input_bit_order (bin)   Input bits  Input bytes   Output\n\
    \   000                     0                         0x0000\n   010         \
    \                        2             0x932e\n   011                     3  \
    \                       0x0001\n   101                                 5     \
    \        0xb166 d866 b1\n   110                     6                        \
    \ 0x001a\n   001                                 1             0x2b\n   010  \
    \                   2                         0x0003\n   100                 \
    \                4             0x9a97 34d8\n   101                     5     \
    \                    0x0007\n   000                                 0\n   001\
    \                     1                         0x0001\n   011               \
    \                  3             0x3384 4e\n   100                     4     \
    \                    0x0008\n   110                                 6        \
    \     0xdc96 51b5 dc96\n   111                     7                         0x0059\n\
    \   010                                 2             0x9d6a\n   011         \
    \            3 - no bits left so terminate\n"
- title: 2.13.  Stack Manipulation
  contents:
  - "2.13.  Stack Manipulation\n   This section gives assembly code to test the PUSH,\
    \ POP, CALL, and\n   RETURN instructions.  The code is designed to test that the\
    \ following\n   boundary cases have been correctly implemented:\n   1.  The stack\
    \ manipulation instructions overwrite the UDVM register\n       stack_location.\n\
    \   2.  The CALL instruction specifies a reference operand rather than an\n  \
    \     absolute value.\n   3.  The PUSH instruction pushes the value contained\
    \ in stack_fill\n       onto the stack.\n   4.  The stack_location register contains\
    \ an odd integer.\n   at (64)\n   :byte_copy_left                 pad (2)\n  \
    \ :byte_copy_right                pad (2)\n   :input_bit_order               \
    \ pad (2)\n   :stack_location                 pad (2)\n   :next_address      \
    \             pad (2)\n   at (128)\n   LOAD (stack_location, 64)\n   PUSH (2)\n\
    \   PUSH ($64)\n   PUSH (66)               ; Stack now contains 2, 1, 66\n   \
    \                        ; so $stack_location = 66\n   OUTPUT (64, 8)        \
    \  ; Output 0x0003 0002 0001 0042\n   POP (64)                ; Pop value 66 from\
    \ address 70 to address 64\n   POP ($stack_location)   ; Pop value 1 from address\
    \ 68 to address 66\n                           ; so stack_fill is overwritten\
    \ to be 1\n   POP (stack_location)    ; Pop value 1 from address 68 to address\
    \ 70\n   OUTPUT (64, 8)          ; Output 0x0042 0000 0001 0001\n   JUMP (address_a)\n\
    \   at (192)\n   :address_a\n   LOAD (stack_location, 32)\n   LOAD (next_address,\
    \ address_c)\n   SUBTRACT ($next_address, address_b)  ; next_address = 64\n  \
    \ CALL (address_b)                     ; push 204 on stack\n   at (256)\n   :address_b\n\
    \   CALL ($next_address)                 ; push 256 on stack\n   at (320)\n  \
    \ :address_c\n   LOAD (stack_location, 383)\n   LOAD (383, 26)               \
    \    ; overwrite $stack_location with 26\n   MULTILOAD (432, 3, 1, 49153, 32768)\n\
    \                                    ; write bytes so that 433 and 434\n     \
    \                               ; contain 0x01c0 = 448 and\n                 \
    \                   ; 435 and 436 contain 0x0180 = 384\n   RETURN            \
    \               ; pop 383 from the stack and jump\n                          \
    \          ; there = 384, which is lsb of\n                                  \
    \  ; stack_fill, which now contains 25,\n                                    ;\
    \ which is UDVM instruction RETURN\n                                    ; pop\
    \ 448 from the stack and jump\n                                    ; there\n \
    \  at (448)\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   The output of the code is\
    \ 0x0003 0002 0001 0042 0042 0000 0001 0001,\n   and a total of 40 UDVM cycles\
    \ are used.\n"
- title: 2.14.  Program Flow
  contents:
  - "2.14.  Program Flow\n   This section gives assembly code to test the JUMP, COMPARE,\
    \ and\n   SWITCH instructions.  The code is designed to test that the following\n\
    \   boundary cases have been correctly implemented:\n   1.  The address operands\
    \ are specified as references to memory\n       addresses rather than as absolute\
    \ values.\n   at (64)\n   :next_address                   pad (2)\n   :counter\
    \                        pad (1)\n   :counter_lsb                    pad (1)\n\
    \   :switch_counter                 pad (2)\n   at (128)\n   LOAD (switch_counter,\
    \ 4)\n   :address_a\n   LOAD (next_address, address_c)\n   SUBTRACT ($next_address,\
    \ address_b)     ; address_c - address_b\n   OUTPUT (counter_lsb, 1)\n   :address_b\n\
    \   JUMP ($next_address)                    ; Jump to address_c\n   :address_c\n\
    \   ADD ($counter, 1)\n   LOAD (next_address, address_a)\n   SUBTRACT ($next_address,\
    \ address_d)     ; address_a - address_d\n   OUTPUT (counter_lsb, 1)\n   :address_d\n\
    \   COMPARE ($counter, 6, $next_address, address_c, address_e)\n             \
    \                      ; counter < 6, $next_address gives\n                  \
    \                 ; jump to address_a\n   :address_e\n   SUBTRACT ($switch_counter,\
    \ 1)           ; switch_counter = 3\n   LOAD (next_address, address_a)\n   SUBTRACT\
    \ ($next_address, address_f)     ; address_a - address_f\n   OUTPUT (counter_lsb,\
    \ 1)\n   :address_f\n   SWITCH (4, $switch_counter, address_g, $next_address,\
    \ address_c,\n   address_e)\n                                   ; when $switch_counter\
    \ = 1,\n                                   ; $next_address gives jump to\n   \
    \                                ; address_a\n   :address_g\n   END-MESSAGE (0,\
    \ 0, 0, 0, 0, 0, 0)\n   The output of the code is 0x0001 0102 0203 0304 0405 0506\
    \ 0707 0708\n   0808 0909, and a total of 131 UDVM cycles are used.\n"
- title: 2.15.  State Creation
  contents:
  - "2.15.  State Creation\n   This section gives assembly code to test the STATE-CREATE\
    \ and STATE-\n   FREE instructions.  The code is designed to test that the following\n\
    \   boundary cases have been correctly implemented:\n   1.  An item of state is\
    \ created that duplicates an existing state\n       item.\n   2.  An item of state\
    \ is freed when the state has not been created.\n   3.  An item of state is created\
    \ and then freed by the same message.\n   4.  The STATE-FREE instruction frees\
    \ a state item by sending fewer\n       bytes of the state_identifier than the\
    \ minimum_access_length.\n   5.  The STATE-FREE instruction has partial_identifier_length\
    \ operand\n       shorter than 6 or longer than 20.\n   6.  The STATE-FREE instruction\
    \ specifies a partial_identifier that\n       matches with two state items in\
    \ the compartment.\n   7.  The bytes of the identifier are written to the position\
    \ specified\n       in the STATE-FREE instruction after the STATE-FREE instruction\n\
    \       has been run (and before END-MESSAGE).\n   at (64)\n   :byte_copy_left\
    \                 pad (2)\n   :byte_copy_right                pad (2)\n   :states\
    \                         pad (1)\n   :states_lsb                     pad (1)\n\
    \   :min_len                        pad (1)\n   :min_len_lsb                 \
    \   pad (1)\n   :state_identifier       pad (20)\n   set (state_length, 10)\n\
    \   at (127)\n   :decompression_failure\n   at (128)\n   INPUT-BYTES (1, states_lsb,\
    \ decompression_failure)\n   :test_one\n   LSHIFT ($states, 11)\n   COMPARE ($states,\
    \ 32768, test_two, create_state_a2, create_state_a2)\n   :create_state_a2\n  \
    \ STATE-CREATE (state_length, state_address2, 0, 20, 0)\n   :test_two\n   LSHIFT\
    \ ($states, 1)\n   COMPARE ($states, 32768, test_three, create_state_a, create_state_a)\n\
    \   :create_state_a\n   STATE-CREATE (state_length, state_address, 0, 20, 0)\n\
    \   :test_three\n   LSHIFT ($states, 1)\n   COMPARE ($states, 32768, test_four,\
    \ free_state, free_state)\n   :free_state\n   INPUT-BYTES (1, min_len_lsb, decompression_failure)\n\
    \   STATE-FREE (state_identifier, $min_len)\n   COPY (identifier1, $min_len, state_identifier)\n\
    \   :test_four\n   LSHIFT ($states, 1)\n   COMPARE ($states, 32768, test_five,\
    \ free_state2, free_state2)\n   :free_state2\n   STATE-FREE (identifier1, 6)\n\
    \   :test_five\n   LSHIFT ($states, 1)\n   COMPARE ($states, 32768, end, create_state_b,\
    \ create_state_b)\n   :create_state_b\n   END-MESSAGE (0, 0, state_length, state_address,\
    \ 0, 20, 0)\n   :end\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   :identifier1\n\
    \   byte (67, 122, 232, 10, 15, 220, 30, 106, 135, 193, 182, 42, 118,\n   118,\
    \ 185, 115, 49, 140, 14, 245)\n   at (256)\n   :state_address\n   byte (192, 204,\
    \ 63, 238, 121, 188, 252, 143, 209, 8)\n   :state_address2\n   byte (101, 232,\
    \ 3, 82, 238, 41, 119, 23, 223, 87)\n   Upon reaching the END-MESSAGE instruction,\
    \ the UDVM does not output\n   any decompressed data, but instead may make one\
    \ or more state\n   creation or state free requests to the state handler.  Assuming\
    \ that\n   the application does not veto the state creation request (and that\n\
    \   sufficient state memory is available) the code results in 0, 1, or 2\n   state\
    \ items being present in the compartment.\n   The following table lists ten different\
    \ compressed messages, the\n   states created and freed by each, the number of\
    \ states left after\n   each message, and the number of UDVM cycles used.  There\
    \ are 3 state\n   creation instructions:\n      create state_a, which has hash\
    \ identifier1\n      create state_b (in END-MESSAGE), which is identical to state_a\n\
    \      create state_a2, which has a different identifier, but the first 6\n  \
    \    bytes are the same as those of identifier1.\n   Message:   Effect:      \
    \                     # state items:  #cycles:\n   0x01       create state_b \
    \                            1           23\n   0x02       free (id1, 6) = state_b\
    \                    0           14\n   0x03       free (id1, 6) = state_b; create\
    \ state_b    1           24\n   0x0405     free (id1, 5)                     \
    \  Decompression failure\n   0x0415     free (id1, 21)                      Decompression\
    \ failure\n   0x0406     free (id1, 6) = state_b                    0        \
    \   23\n   0x09       create state_a; create state_b             1           34\n\
    \   0x1e06     create state_a2; create state_a;\n              free (id1, 6) =\
    \ matches both so no free;\n              free (id1, 6) = matches both so no free;\
    \   2           46\n   0x1e07     create state_a2; create state_a;\n         \
    \     free (id1, 7) = state_a;\n              free (id1, 6) = state_a2       \
    \            0           47\n   0x1e14     create state_a2; create state_a;\n\
    \              free (id1, 20) = state_a;\n              free (id1, 6) = state_a2\
    \                   0           60\n"
- title: 2.16.  STATE-ACCESS
  contents:
  - "2.16.  STATE-ACCESS\n   This section gives assembly code to test the STATE-ACCESS\n\
    \   instruction.  The code is designed to test that the following\n   boundary\
    \ cases have been correctly implemented:\n   1.  A subset of the bytes contained\
    \ in a state item is copied to the\n       UDVM memory.\n   2.  Bytes are copied\
    \ from beyond the end of the state value.\n   3.  The state_instruction operand\
    \ is set to 0.\n   4.  The state cannot be accessed because the partial state\
    \ identifier\n       is too short.\n   5.  The state identifier is overwritten\
    \ by the state item being\n       accessed.\n   The following bytecode needs to\
    \ be run first to set up the state for\n   the rest of the test.\n   at (128)\n\
    \   END-MESSAGE (0, 0, state_length, state_start, 0, 20, 0)\n   ; The bytes between\
    \ state_start and state_end are derived from\n   ; translation of the following\
    \ mnemonic code:\n   ;\n   ; at (512)\n   ; OUTPUT (data, 4)\n   ; END-MESSAGE\
    \ (0,0,0,0,0,0,0)\n   ; :data\n   ; byte (116, 101, 115, 116)\n   at (512)\n \
    \  :state_start\n   byte (34, 162, 12,4, 35, 0, 0, 0, 0, 0, 0, 0, 116, 101, 115,\
    \ 116)\n   :state_end\n   set (state_length, (state_end - state_start))\n   This\
    \ is the bytecode for the rest of the test.\n   at (64)\n   :byte_copy_left  \
    \               pad (2)\n   :byte_copy_right                pad (2)\n   :type\
    \                           pad (1)\n   :type_lsb                       pad (1)\n\
    \   :state_value                    pad (4)\n   at (127)\n   :decompression_failure\n\
    \   at (128)\n   INPUT-BYTES (1, type_lsb, decompression_failure)\n   COMPARE\
    \ ($type, 1, execute_state, extract_state, error_conditions)\n   :execute_state\n\
    \   STATE-ACCESS (state_identifier, 20, 0, 0, 0, 512)\n   :extract_state\n   STATE-ACCESS\
    \ (state_identifier, 20, 12, 4, state_value, 0)\n   OUTPUT (state_value, 4)\n\
    \   JUMP (end)\n   :error_conditions\n   COMPARE ($type, 3, state_not_found, id_too_short,\
    \ state_too_short)\n   :state_not_found\n   STATE-ACCESS (128, 20, 0, 0, 0, 0)\n\
    \   JUMP (end)\n   :id_too_short\n   STATE-ACCESS (state_identifier, 19, 6, 4,\
    \ state_value, 0)\n   JUMP (end)\n   :state_too_short\n   STATE-ACCESS (state_identifier,\
    \ 20, 12, 5, state_value, 0)\n   JUMP (end)\n   at (484)\n   :end\n   END-MESSAGE\
    \ (0, 0, 0, 0, 0, 0, 0)\n   at (512)\n   :state_identifier\n   byte (0x5d, 0xf8,\
    \ 0xbc, 0x3e, 0x20, 0x93, 0xb5, 0xab, 0xe1, 0xf1,\n   0x70, 0x13, 0x42, 0x4c,\
    \ 0xe7, 0xfe, 0x05, 0xe0, 0x69, 0x39)\n   If the compressed message is 0x00, then\
    \ the output of the code is\n   0x7465 7374, and a total of 26 UDVM cycles are\
    \ used.  If the\n   compressed message is 0x01, then the output of the code is\
    \ also\n   0x7465 7374 but in this case using a total of 15 UDVM cycles.  If the\n\
    \   compressed message is 0x02, 0x03, or 0x04, then decompression failure\n  \
    \ occurs.\n"
- title: 3.  Torture Tests for Dispatcher
  contents:
  - "3.  Torture Tests for Dispatcher\n   The following sections give code to test\
    \ the various functions of the\n   SigComp dispatcher.\n"
- title: 3.1.  Useful Values
  contents:
  - "3.1.  Useful Values\n   This section gives assembly code to test that the SigComp\
    \ \"Useful\n   Values\" are correctly initialized in the UDVM memory.  It also\
    \ tests\n   that the UDVM is correctly terminated if the bytecode uses too many\n\
    \   UDVM cycles or tries to write beyond the end of the available memory.\n  \
    \ The code tests that the following boundary cases have been correctly\n   implemented:\n\
    \   1.  The bytecode uses exactly as many UDVM cycles as are available\n     \
    \  (in which case no problems should arise) or one cycle too many\n       (in\
    \ which case decompression failure should occur).  A liberal\n       implementation\
    \ could allow more cycles to be used than are\n       strictly available, in which\
    \ case decompression failure will not\n       occur.  This is an implementation\
    \ choice.  If this choice is\n       made, the implementer must be sure that the\
    \ cycles are checked\n       eventually and that decompression failure does occur\
    \ when\n       bytecode uses an excessive number of cycles.  This is tested in\n\
    \       Section 3.2.\n   2.  The bytecode writes to the highest memory address\
    \ available (in\n       which case no problems should arise) or to the memory\
    \ address\n       immediately following the highest available address (in which\n\
    \       case decompression failure must occur).\n   :udvm_memory_size        \
    \       pad (2)\n   :cycles_per_bit                 pad (2)\n   :sigcomp_version\
    \                pad (2)\n   :partial_state_id_length        pad (2)\n   :state_length\
    \                   pad (2)\n   at (64)\n   :byte_copy_left                 pad\
    \ (2)\n   :byte_copy_right                pad (2)\n   :remaining_cycles      \
    \         pad (2)\n   :check_memory                   pad (1)\n   :check_memory_lsb\
    \               pad (1)\n   :check_cycles                   pad (1)\n   :check_cycles_lsb\
    \               pad (1)\n   at (127)\n   :decompression_failure\n   at (128)\n\
    \                               ; Set up a 1-byte buffer\n   LOAD (byte_copy_left,\
    \ 32)\n   LOAD (byte_copy_right, 33)\n   :test_version\n   ; Input a byte containing\
    \ the version of SigComp being run\n   INPUT-BYTES (1, check_memory_lsb, decompression_failure)\n\
    \   COMPARE ($sigcomp_version, $check_memory, decompression_failure,\n   test_state_access,\
    \ decompression_failure)\n   :test_state_access\n   COMPARE ($partial_state_id_length,\
    \ 0, decompression_failure,\n   test_length_equals_zero, test_state_length)\n\
    \   :test_length_equals_zero\n                               ; No state was accessed\
    \ so state_length\n                               ; should be zero (first message)\n\
    \   COMPARE ($state_length, 0, decompression_failure, end,\n   decompression_failure)\n\
    \   :test_state_length\n                               ; State was accessed so\
    \ state_length\n                               ; should be 960\n   COMPARE ($state_length,\
    \ 960, decompression_failure, test_udvm_memory,\n   decompression_failure)\n \
    \  :test_udvm_memory\n                               ; Copy one byte to\n    \
    \                           ; udvm_memory_size + input - 1\n                 \
    \              ; Succeed when input byte is 0x00\n                           \
    \    ; Fail when input byte is 0x01\n   INPUT-BYTES (1, check_memory_lsb, decompression_failure)\n\
    \   ADD ($check_memory, $udvm_memory_size)\n   SUBTRACT ($check_memory, 1)\n \
    \  COPY (32, 1, $check_memory)\n   :test_udvm_cycles\n   INPUT-BYTES (1, check_cycles_lsb,\
    \ decompression_failure)\n   ; Work out the total number of cycles available to\
    \ the UDVM\n   ; total_UDVM_cycles = cycles_per_bit * (8 * message_size + 1000)\n\
    \   ;\n   ;       = cycles_per_bit * (8 * (partial_state_id_length + 3) + 1000)\n\
    \   LOAD (remaining_cycles, $partial_state_id_length)\n   ADD ($remaining_cycles,\
    \ 3)\n   MULTIPLY ($remaining_cycles, 8)\n   ADD ($remaining_cycles, 1000)\n \
    \  MULTIPLY ($remaining_cycles, $cycles_per_bit)\n   ADD ($remaining_cycles, $check_cycles)\n\
    \   set (cycles_used_by_bytecode, 856)\n   SUBTRACT ($remaining_cycles, cycles_used_by_bytecode)\n\
    \   COPY (32, $remaining_cycles, 32)\n                   ; Copy to use up all\
    \ cycles available + input byte\n                   ; Succeeds when input byte\
    \ = 0x00\n                   ; Fail when input byte = 0x01\n   :end\n        \
    \                       ; Create 960 bytes of state for future\n             \
    \                  ; reference\n   END-MESSAGE (0, 0, 960, 64, 128, 6, 0)\n  \
    \ The bytecode must be executed a total of four times in order to fully\n   test\
    \ the SigComp Useful Values.  In the first case, the bytecode is\n   uploaded\
    \ as part of the SigComp message with a 1-byte compressed\n   message corresponding\
    \ to the version of SigComp being run.  This\n   causes the UDVM to request creation\
    \ of a new state item and uses a\n   total of 968 UDVM cycles.\n   Subsequent\
    \ tests access this state by uploading the state identifier\n   as part of the\
    \ SigComp message.  Note that the SigComp message should\n   not contain a returned\
    \ feedback item (as this would cause the\n   bytecode to calculate the total number\
    \ of available UDVM cycles\n   incorrectly).\n   A 3-byte compressed message is\
    \ required for the second and subsequent\n   cases, the first byte of which is\
    \ the version of SigComp in use,\n   0xnn.  If the message is 0xnn0000, then the\
    \ UDVM should successfully\n   terminate using exactly the number of available\
    \ UDVM cycles.\n   However, if the message is 0xnn0001, then the UDVM should use\
    \ too\n   many cycles and hence terminate with decompression failure.\n   Furthermore,\
    \ if the message is 0xnn0100, then decompression failure\n   must occur because\
    \ the UDVM attempts to write beyond its available\n   memory.\n"
- title: 3.2.  Cycles Checking
  contents:
  - "3.2.  Cycles Checking\n   As discussed in Section 3.1, it is possible to write\
    \ an\n   implementation that takes a liberal approach to checking the cycles\n\
    \   used and allows some extra cycles.  The implementer must be sure that\n  \
    \ decompression failure does not occur too early and that in the case\n   of excessive\
    \ use of cycles, decompression failure does eventually\n   occur.  This test checks\
    \ that:\n   1.  Decompression failure occurs eventually when there is an infinite\n\
    \       loop.\n   at (64)\n   :byte_copy_left           pad (2)\n   :byte_copy_right\
    \          pad (2)\n   :value                    pad (2)\n   :copy_next      \
    \          pad (2)\n   at(128)\n   MULTILOAD (byte_copy_left, 4, 32, 41, 0, 34)\n\
    \                                   ; Set up a 10-byte buffer\n              \
    \                     ; Set the value to copy\n                              \
    \     ; Copy it 100 times,\n                                   ; output the value,\n\
    \                                   ; increment the counter\n   :loop\n   COPY\
    \ (value, 2, $byte_copy_left)\n   COPY-OFFSET (2, 100, $copy_next)\n   OUTPUT\
    \ (value, 2)\n   ADD ($value, 1)\n   JUMP (loop)\n   If the cycles are counted\
    \ exactly and cycles per bit (cpb) = 16, then\n   decompression failure will occur\
    \ at COPY-OFFSET when value = 180 =\n   0xB4.  If cpb = 32, then decompression\
    \ failure will occur when value\n   = 361 = 0x0169.  If they are not counted exactly,\
    \ then decompression\n   failure MUST occur eventually.\n"
- title: 3.3.  Message-based Transport
  contents:
  - "3.3.  Message-based Transport\n   This section provides a set of messages to\
    \ test the SigComp header\n   over a message-based transport such as UDP.  The\
    \ messages test that\n   the following boundary cases have been correctly implemented:\n\
    \   1.  The UDVM bytecode is copied to different areas of the UDVM\n       memory.\n\
    \   2.  The decompression memory size is set to an incorrect value.\n   3.  The\
    \ SigComp message is too short.\n   4.  The destination address is invalid.\n\
    \   The basic version of the code used in the test is given below.  Note\n   that\
    \ the code is designed to calculate the decompression memory size\n   based on\
    \ the Useful Values provided to the UDVM:\n   :udvm_memory_size              \
    \ pad (2)\n   :cycles_per_bit                 pad (2)\n   :sigcomp_version   \
    \             pad (2)\n   :partial_state_id_length        pad (2)\n   :state_length\
    \                   pad (2)\n   at (128)\n   :code_start\n   ; udvm_memory_size\
    \ for message-based transport\n   ;    = DMS - total_message_size\n   ADD ($udvm_memory_size,\
    \ total_message_size)\n   OUTPUT (udvm_memory_size, 2)\n   END-MESSAGE (0, 0,\
    \ 0, 0, 0, 0, 1)\n   :code_end\n   set (header_size, 3)\n   set (code_size, (code_end\
    \ - code_start))\n   set (total_message_size, (header_size + code_size))\n   A\
    \ number of complete SigComp messages are given below, each\n   containing some\
    \ or all of the above code.  In each case, it is\n   indicated whether the message\
    \ will successfully output the\n   decompression memory size or whether it will\
    \ cause a decompression\n   failure to occur (together with the reason for the\
    \ failure):\n   SigComp message:                Effect:\n   0xf8             \
    \               Fails (message too short)\n   0xf800                         \
    \ Fails (message too short)\n   0xf800 e106 0011 2200 0223      Outputs the decompression_memory_size\n\
    \   0x0000 0000 0000 01\n   0xf800 f106 0011 2200 0223      Fails (message too\
    \ short)\n   0x0000 0000 0000 01\n   0xf800 e006 0011 2200 0223      Fails (invalid\
    \ destination address)\n   0x0000 0000 0000 01\n   0xf800 ee06 0011 2200 0223\
    \      Outputs the decompression_memory_size\n   0x0000 0000 0000 01\n   The messages\
    \ should be decompressed in the order given to check that\n   an error in one\
    \ message does not interfere with the successful\n   decompression of subsequent\
    \ messages.\n   The two messages that successfully decompress each use a total\
    \ of 5\n   UDVM cycles.\n"
- title: 3.4.  Stream-based Transport
  contents:
  - "3.4.  Stream-based Transport\n   This section provides a byte stream to test\
    \ the SigComp header and\n   delimiters over a stream-based transport such as\
    \ TCP.  The byte\n   stream tests all of the boundary cases covered in Section\
    \ 3.2, as\n   well as the following cases specific to stream-based transports:\n\
    \   1.  Quoted bytes are used by the record marking scheme.\n   2.  Multiple delimiters\
    \ are used between the same pair of messages.\n   3.  Unnecessary delimiters are\
    \ included at the start of the stream.\n   The basic version of the code used\
    \ in the test is given below.  Note\n   that the code is designed to calculate\
    \ the decompression memory size\n   based on the Useful Values provided to the\
    \ UDVM:\n   :udvm_memory_size               pad (2)\n   :cycles_per_bit      \
    \           pad (2)\n   :sigcomp_version                pad (2)\n   :partial_state_id_length\
    \        pad (2)\n   :state_length                   pad (2)\n   at (128)\n  \
    \ ; udvm_memory_size for stream based transport = DMS / 2\n   MULTIPLY ($udvm_memory_size,\
    \ 2)\n   OUTPUT (udvm_memory_size, 2)\n   OUTPUT (test_record_marking, 5)\n  \
    \ END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   :test_record_marking\n   byte (255, 255,\
    \ 255, 255, 255)\n   The above assembly code has been compiled and used to generate\
    \ the\n   following byte stream:\n   0xffff f801 7108 0002 2200 0222 a092 0523\
    \ 0000 0000 0000 00ff 00ff\n   0x03ff ffff ffff ffff f801 7e08 0002 2200 0222\
    \ a3d2 0523 0000 0000\n   0x0000 00ff 04ff ffff ffff ffff ffff ff\n   Note that\
    \ this byte stream can be divided into five distinct portions\n   (two SigComp\
    \ messages and three sets of delimiters) as illustrated\n   below:\n   Portion\
    \ of byte stream:                                Meaning:\n   0xffff         \
    \                                        Delimiter\n   0xf801 7108 0002 2200 0222\
    \ a092 0523                   First message\n   0x0000 0000 0000 00ff 00ff 03ff\
    \ ffff\n   0xffff ffff                                            Delimiter\n\
    \   0xf801 7e08 0002 2200 0222 a3d2 0523                   Second message\n  \
    \ 0x0000 0000 0000 00ff 04ff ffff ff\n   0xffff ffff ffff                    \
    \                   Delimiter\n   When the complete byte stream is supplied to\
    \ the decompressor\n   dispatcher, the record marking scheme must use the delimiters\
    \ to\n   partition the stream into two distinct SigComp messages.  Both of\n \
    \  these messages successfully output the decompression memory size (as\n   a\
    \ 2-byte value), followed by 5 consecutive 0xff bytes to test that\n   the record\
    \ marking scheme is working correctly.  A total of 11 UDVM\n   cycles are used\
    \ in each case.\n   It must also be checked that the dispatcher can handle the\
    \ same error\n   cases as covered in Section 3.2.  Each of the following byte\
    \ streams\n   should cause a decompression failure to occur for the reason stated:\n\
    \   Byte stream:                                      Reason for failure:\n  \
    \ 0xf8ff ff                                         Message too short\n   0xf800\
    \ ffff                                       Message too short\n   0xf801 8108\
    \ 0002 2200 0222 a092 0523 ffff         Message too short\n   0x0000 0000 0000\
    \ 00ff 00ff 03ff ffff\n   0xf801 7008 0002 2200 0222 a092 0523 ffff         Invalid\
    \ destination\n   0x0000 0000 0000 00ff 04ff ffff ff\n"
- title: 3.5.  Input Past the End of a Message
  contents:
  - "3.5.  Input Past the End of a Message\n   This section gives assembly code to\
    \ test that the implementation\n   correctly handles input past the end of a SigComp\
    \ message.  The code\n   is designed to test that the following boundary cases\
    \ have been\n   correctly implemented:\n   1.  An INPUT instruction requests data\
    \ that lies beyond the end of\n       the message.  In this case, the dispatcher\
    \ should not return any\n       data to the UDVM.  Moreover, the message bytes\
    \ held by the\n       dispatcher should still be available for retrieval by subsequent\n\
    \       INPUT instructions.\n   2.  The INPUT-BYTES instruction is used after\
    \ part of a byte has been\n       input (e.g., by the INPUT-BITS instruction).\
    \  In this case, the\n       remaining partial byte must be discarded, even if\
    \ the INPUT-BYTES\n       instruction requests data that lies beyond the end of\
    \ the\n       message.\n   at (64)\n   :byte_copy_left                 pad (2)\n\
    \   :byte_copy_right                pad (2)\n   :input_bit_order             \
    \   pad (2)\n   :result                         pad (1)\n   :result_lsb      \
    \               pad (6)\n   :right\n   at (128)\n   LOAD (byte_copy_left, result)\n\
    \   LOAD (byte_copy_right, right)\n   :start\n   ; Input bits to ensure that the\
    \ remaining message is not byte aligned\n   INPUT-BITS (9, result, decompression_failure1)\
    \ ; Input 0x1FF (9 bits)\n   ; Attempt to read 7 bytes\n   INPUT-BYTES (7, result,\
    \ next_bytes) ; This should fail, throw away\n                               \
    \        ; 7 bits with value Ox7a and\n                                      \
    \ ; jump to next_bytes\n   :decompression_failure1\n   DECOMPRESSION-FAILURE \
    \              ; This instruction is never\n                                 \
    \      ; executed but is used to\n                                       ; separate\
    \ success and failure\n                                       ; to input bytes.\n\
    \   :next_bytes\n   ; Read 7 bits - this removes the byte alignment of the message\n\
    \   ; If the bits have not been thrown away where they should be, then\n   ; the\
    \ message will be 1 byte longer than necessary and the output\n   ; will be incorrect.\n\
    \   INPUT-BITS (7, result, decompression_failure1) ; Input 0x00 (7 bits)\n   ;\
    \ Read 2 bytes\n   INPUT-BYTES (2, result, decompression_failure1)\n         \
    \                              ; Throw away 1 bit value 0\n                  \
    \                     ; Input 0x6869\n   OUTPUT (result, 2)                  ;\
    \ Output 0x6869\n                                       ; Attempt to read more\
    \ bits than\n   INPUT-BITS (16, result, bits)       ; there are to ensure they\n\
    \                                       ; remain available\n   :decompression_failure2\n\
    \   DECOMPRESSION-FAILURE               ; This instruction is never\n        \
    \                               ; executed but is used to\n                  \
    \                     ; separate success and failure\n                       \
    \                ; to input bits.\n   :bits\n   ; Read 8 bits\n   INPUT-BITS (8,\
    \ result, decompression_failure2) ; Input 0x21 or fail\n   OUTPUT (result_lsb,\
    \ 1)              ; Output 0x21\n   :end_message\n   END-MESSAGE (0, 0, 0, 0,\
    \ 0, 0, 0)\n   If the compressed message is 0xfffa 0068 6921, then the code\n\
    \   terminates successfully with the output 0x6869 21, and a total of 23\n   UDVM\
    \ cycles are used.  However, if the compressed message is 0xfffa\n   0068 69,\
    \ then decompression failure occurs (at the final INPUT-BITS).\n"
- title: 4.  Torture Tests for State Handler
  contents:
  - "4.  Torture Tests for State Handler\n   The following sections give code to test\
    \ the various functions of the\n   SigComp state handler.\n"
- title: 4.1.  SigComp Feedback Mechanism
  contents:
  - "4.1.  SigComp Feedback Mechanism\n   This section gives assembly code to test\
    \ the SigComp feedback\n   mechanism.  The code is designed to test that the following\
    \ boundary\n   cases have been correctly implemented:\n   1.  Both the short and\
    \ the long versions of the SigComp feedback item\n       are used.\n   2.  The\
    \ chain of returned SigComp parameters is terminated by a non-\n       zero value.\n\
    \   at (64)\n   :type                           pad (1)\n   :type_lsb        \
    \               pad (1)\n   :requested_feedback_location    pad (1)\n   :requested_feedback_length\
    \      pad (1)\n   :requested_feedback_bytes       pad (127)\n   :returned_parameters_location\
    \   pad (2)\n   :length_of_partial_state_id_a   pad (1)\n   :partial_state_identifier_a\
    \     pad (6)\n   :length_of_partial_state_id_b   pad (1)\n   :partial_state_identifier_b\
    \     pad (12)\n   :length_of_partial_state_id_c   pad (1)\n   :partial_state_identifier_c\
    \     pad (20)\n   :terminate_returned_parameters  pad (1)\n   align (128)\n \
    \  set (q_bit, 1)\n   set (s_bit, 0)\n   set (i_bit, 0)\n   set (flags, (((4 *\
    \ q_bit) + (2 * s_bit)) + i_bit))\n   INPUT-BYTES (1, type_lsb, decompression_failure)\n\
    \   COMPARE ($type, 1, short_feedback_item, long_feedback_item,\n   decompression_failure)\n\
    \   :short_feedback_item\n   set (requested_feedback_data, 127)\n   set (short_feedback_value,\
    \ ((flags * 256) + requested_feedback_data))\n   LOAD (requested_feedback_location,\
    \ short_feedback_value)\n   JUMP (return_sigcomp_parameters)\n   :long_feedback_item\n\
    \   set (requested_feedback_field, 255)\n   set (long_feedback_value, ((flags\
    \ * 256) + requested_feedback_field))\n   LOAD (requested_feedback_location, long_feedback_value)\n\
    \   MEMSET (requested_feedback_bytes, 127, 1, 1)\n   :return_sigcomp_parameters\n\
    \   set (cpb, 0)\n   set (dms, 1)\n   set (sms, 0)\n   set (sigcomp_version, 1)\n\
    \   set (parameters_msb, (((64 * cpb) + (8 * dms)) + sms))\n   set (sigcomp_parameters,\
    \ ((256 * parameters_msb) + sigcomp_version))\n   LOAD (returned_parameters_location,\
    \ sigcomp_parameters)\n   LOAD (length_of_partial_state_id_a, 1536)   ; length\
    \ 6 first byte 0\n   LOAD (length_of_partial_state_id_b, 3072)   ; length 12 first\
    \ byte 0\n   LOAD (length_of_partial_state_id_c, 5120)   ; length 20 first byte\
    \ 0\n   LOAD (terminate_returned_parameters, 5376)  ; length 21\n            \
    \                                   ; used to terminate the\n                \
    \                               ; returned parameters\n   MEMSET (partial_state_identifier_a,\
    \ 6, 0, 1)\n   MEMSET (partial_state_identifier_b, 12, 0, 1)\n   MEMSET (partial_state_identifier_c,\
    \ 20, 0, 1)\n   END-MESSAGE (requested_feedback_location,\n   returned_parameters_location,\
    \ 0, 0, 0, 0, 0)\n   :decompression_failure\n   DECOMPRESSION-FAILURE\n   When\
    \ the above code is executed, it supplies a requested feedback\n   item to the\
    \ state handler.  If the compressed message is 0x00, then\n   the short (1-byte)\
    \ version of the feedback is used.  Executing the\n   bytecode in this case costs\
    \ a total of 52 UDVM cycles.  Assuming that\n   the feedback request is successful,\
    \ the feedback item should be\n   returned in the first SigComp message to be\
    \ sent in the reverse\n   direction.  The SigComp message returning the feedback\
    \ should begin\n   as follows:\n   +---+---+---+---+---+---+---+---+\n   | 1 \
    \  1   1   1   1   1 |   X   |   first header byte\n   +---+---+---+---+---+---+---+---+\n\
    \   | 0 |            127            |   returned feedback field\n   +---+---+---+---+---+---+---+---+\n\
    \   So the first 2 bytes of the returning SigComp message should be\n   0xfn7f\
    \ where n = c, d, e, or f (the choice of n is determined by the\n   compressor\
    \ generating the returning SigComp message, which is not\n   under the control\
    \ of the above code).\n   If the compressed message is 0x01, then the long version\
    \ of the\n   feedback item is used.  Executing the bytecode in this case costs\
    \ a\n   total of 179 UDVM cycles and the SigComp message returning the\n   feedback\
    \ should begin as follows:\n   +---+---+---+---+---+---+---+---+\n   | 1   1 \
    \  1   1   1   1 |   X   |   first header byte\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1 |            127            |   returned feedback length\n   +---+---+---+---+---+---+---+---+\n\
    \   |               1               |              ^\n   +---+---+---+---+---+---+---+---+\
    \              |\n   |               2               |              |\n   +---+---+---+---+---+---+---+---+\n\
    \   |               3               |   returned feedback field\n   +---+---+---+---+---+---+---+---+\n\
    \   So the first 129 bytes of the SigComp message should be 0xfnff 0102\n   0304\
    \ ... 7e7f where n = c, d, e, or f as above.\n   As well as testing the requested\
    \ and returned feedback items, the\n   above code also announces values for each\
    \ of the SigComp parameters.\n   The supplied version of the code announces only\
    \ the minimum possible\n   values for the cycles_per_bit, decompression_memory_size,\n\
    \   state_memory_size, and SigComp_version (although this can easily be\n   adjusted\
    \ to test different values for these parameters).\n   The code should also announce\
    \ the availability of state items with\n   the following partial state identifiers:\n\
    \   0x0001 0203 0405\n   0x0001 0203 0405 0607 0809 0a0b\n   0x0001 0203 0405\
    \ 0607 0809 0a0b 0c0d 0e0f 1011 1213\n   Note that different implementations may\
    \ make use of the announcement\n   information in different ways.  It is a valid\
    \ implementation choice\n   to simply ignore all of the announcement data and\
    \ use only the\n   minimum resources that are guaranteed to be available to all\n\
    \   endpoints.  However, the above code is useful for checking that an\n   endpoint\
    \ interprets the announcement data correctly (in particular\n   ensuring that\
    \ it does not mistakenly use resources that have not in\n   fact been announced).\n"
- title: 4.2.  State Memory Management
  contents:
  - "4.2.  State Memory Management\n   The following section gives assembly code to\
    \ test the memory\n   management features of the state handler.  The code checks\
    \ that the\n   correct states are retained by the state handler when insufficient\n\
    \   memory is available to store all of the requested states.\n   The code is\
    \ designed to test that the following boundary cases have\n   been correctly implemented:\n\
    \   1.  A state item is created that exceeds the total state_memory_size\n   \
    \    for the compartment.\n   2.  States are created with a non-zero state_retention_priority.\n\
    \   3.  A new state item is created that has a lower\n       state_retention_priority\
    \ than existing state items in the\n       compartment.\n   For the duration of\
    \ this test, it is assumed that all states will be\n   saved in a single compartment\
    \ with a state_memory_size of 2048 bytes.\n   at (64)\n   :byte_copy_left    \
    \             pad (2)\n   :byte_copy_right                pad (2)\n   :order \
    \                         pad (2)\n   :type                           pad (1)\n\
    \   :type_lsb                       pad (1)\n   :state_length                \
    \   pad (2)\n   :state_retention_priority       pad (2)\n   at(127)\n   :decompression_failure\n\
    \   at (128)\n   MULTILOAD (byte_copy_left, 2, state_start, order_data)\n   INPUT-BYTES\
    \ (1, type_lsb, decompression_failure)\n   COMPARE ($type, 5, general_test, large_state,\
    \ verify_state)\n   :general_test\n   COMPARE ($type, 3, start, state_present,\
    \ state_not_present)\n   :start\n   MULTIPLY ($type, 6)\n   ADD ($type, order_data)\n\
    \   LOAD (order, $type)\n   ADD ($type, 6)\n   ; Finish with the value (order_data\
    \ + 6*n) in order where\n   ; n is the input value 0x00, 0x01, or 0x02\n   ; type\
    \ = order + 6\n   ; These values are used to index into the 'order_data'\n   ;\
    \ that is used to work out state retention priorities and lengths\n   :loop\n\
    \   COPY ($order, 2, state_retention_priority)\n   COMPARE ($order, $type, continue,\
    \ end, decompression_failure)\n   :continue\n   ;  Set up a state creation each\
    \ time through the loop\n   LOAD (state_length, $state_retention_priority)\n \
    \  MULTIPLY ($state_length, 256)\n   STATE-CREATE ($state_length, state_start,\
    \ 0, 6,\n   $state_retention_priority)\n   ADD ($order, 2)\n   JUMP (loop)\n \
    \  :state_present\n   ; Access the states that should be present\n   STATE-ACCESS\
    \ (state_identifier_a, 6, 0, 0, 0, 0)\n   STATE-ACCESS (state_identifier_b, 6,\
    \ 0, 0, 0, 0)\n   STATE-ACCESS (state_identifier_c, 6, 0, 0, 0, 0)\n   STATE-ACCESS\
    \ (state_identifier_e, 6, 0, 0, 0, 0)\n   JUMP (end)\n   :state_not_present\n\
    \   ; Check that the state that shouldn't be present is not present.\n   STATE-ACCESS\
    \ (state_identifier_d, 6, 0, 0, 0, 0)\n   JUMP (end)\n   :large_state\n   STATE-CREATE\
    \ (2048, state_start, 0, 6, 0)\n   JUMP (end)\n   :verify_state\n   STATE-ACCESS\
    \ (large_state_identifier, 6, 0, 0, 0, 0)\n   JUMP (end)\n   :end\n   END-MESSAGE\
    \ (0, 0, 0, 0, 0, 0, 0)\n   at (512)\n   :state_start\n   byte (116, 101, 115,\
    \ 116)\n   :order_data\n   ; This data is used to generate the retention priority\n\
    \   ; and state length of each state creation.\n   word (0, 1, 2, 3, 4, 3, 2,\
    \ 1, 0)\n   :state_identifier_a\n   byte (142, 234, 75, 67, 167, 135)\n   :state_identifier_b\n\
    \   byte (249, 1, 14, 239, 86, 123)\n   :state_identifier_c\n   byte (35, 154,\
    \ 52, 107, 21, 166)\n   :state_identifier_d\n   byte (180, 15, 192, 228, 77, 44)\n\
    \   :state_identifier_e\n   byte (212, 162, 33, 71, 230, 10)\n   :large_state_identifier\n\
    \   byte (239, 242, 188, 15, 182, 175)\n   The above code must be executed a total\
    \ of 7 times in order to\n   complete the test.  Each time the code is executed,\
    \ a 1-byte\n   compressed message should be provided as below.  The effects of\
    \ the\n   messages are given below.  States are described in the form (name, x,\n\
    \   y) where name corresponds to the name of the identifier in the\n   mnemonic\
    \ code, x is the length of the state, and y is the retention\n   priority of the\
    \ state.\n   Message:   Effect:                                           #cycles:\n\
    \   0x00       create states:                                       811\n    \
    \               (a,0,0),\n                   (b,256,1),\n                   (c,512,2)\n\
    \   0x01       create states:                                      2603\n    \
    \               (d,768,3),\n                   (e,1024,4) - deleting a, b, c\n\
    \   0x02       create states:                                       811\n    \
    \               (c,512,2), - deleting d\n                   (b,256,1),\n     \
    \              (a,0,0)\n   0x03       access states a,b,c,e                  \
    \             1805\n   0x04       access state d - not present so decompression\
    \ failure\n   0x05       create states:                                      2057\n\
    \                   (large, 2048,0) - deleting a, b, c, e\n   0x06       access\
    \ large state                                  1993\n   Note that as new states\
    \ are created, some of the existing states will\n   be pushed out of the compartment\
    \ due to lack of memory.\n"
- title: 4.3.  Multiple Compartments
  contents:
  - "4.3.  Multiple Compartments\n   This section gives assembly code to test the\
    \ interaction between\n   multiple SigComp compartments.  The code is designed\
    \ to test that the\n   following boundary cases have been correctly implemented:\n\
    \   1.  The same state item is saved in more than one compartment.\n   2.  A state\
    \ item stored in multiple compartments has the same state\n       identifier but\
    \ a different state_retention_priority in each case.\n   3.  A state item is deleted\
    \ from one compartment but still belongs to\n       a different compartment.\n\
    \   4.  A state item belonging to multiple compartments is deleted from\n    \
    \   every compartment to which it belongs.\n   The test requires a total of three\
    \ compartments to be available,\n   which will be referred to as Compartment 0,\
    \ Compartment 1, and\n   Compartment 2.  Each of the three compartments should\
    \ have a\n   state_memory_size of 2048 bytes.\n   The assembly code for the test\
    \ is given below:\n   at (64)\n   :byte_copy_left                 pad (2)\n  \
    \ :byte_copy_right                pad (2)\n   :type                          \
    \ pad (1)\n   :type_lsb                       pad (1)\n   at (127)\n   :decompression_failure\n\
    \   at (128)\n   MULTILOAD (byte_copy_left, 2, state_start, state_end)\n   INPUT-BYTES\
    \ (1, type_lsb, decompression_failure)\n   COMPARE ($type, 3, create_state, overwrite_state,\
    \ temp)\n   :temp\n   COMPARE ($type, 5, overwrite_state, access_state, error_conditions)\n\
    \   :create_state\n   ; starting byte identified by $type according to input:\n\
    \   ; Input     0x00        0x01        0x02\n   ; $type      512         513\
    \         514\n   ADD ($type, state_start)\n   STATE-CREATE (448, $type, 0, 6,\
    \ 0)\n   ; create state again, beginning in different place in buffer\n   ; starting\
    \ byte identified by $type according to input:\n   ; Input     0x00        0x01\
    \        0x02\n   ; $type      515         516         517\n   ADD ($type, 3)\n\
    \   STATE-CREATE (448, $type, 0, 6, 0)\n   ; create a third time beginning in\
    \ different place again\n   ; starting byte identified by $type according to input:\n\
    \   ; Input     0x00        0x01        0x02\n   ; $type      516         517\
    \         515\n   SUBTRACT ($type, temp_one)\n   REMAINDER ($type, 3)\n   ADD\
    \ ($type, temp_two)\n   STATE-CREATE (448, $type, 0, 6, 0)\n   :common_state\n\
    \   STATE-CREATE (448, temp_three, 0, 6, $type)\n   JUMP (end)\n   :overwrite_state\n\
    \   STATE-CREATE (1984, 32, 0, 6, 0)\n   JUMP (end)\n   :access_state\n   STATE-ACCESS\
    \ (state_identifier_c, 6, 0, 0, 0, 0)\n   STATE-ACCESS (state_identifier_d, 6,\
    \ 0, 0, 0, 0)\n   STATE-ACCESS (state_identifier_f, 6, 0, 0, 0, 0)\n   STATE-ACCESS\
    \ (state_identifier_g, 6, 0, 0, 0, 0)\n   :end\n   END-MESSAGE (0, 0, 0, 0, 0,\
    \ 0, 0)\n   :error_conditions\n   COMPARE ($type, 7, access_a, access_b, access_e)\n\
    \   :access_a\n   STATE-ACCESS (state_identifier_a, 6, 0, 0, 0, 0)\n   JUMP (end)\n\
    \   :access_b\n   STATE-ACCESS (state_identifier_b, 6, 0, 0, 0, 0)\n   JUMP (end)\n\
    \   :access_e\n   STATE-ACCESS (state_identifier_e, 6, 0, 0, 0, 0)\n   JUMP (end)\n\
    \   at (512)\n   :state_start\n   byte (0, 1, 2, 3, 4, 5, 6)\n   :state_end\n\
    \   set (temp_one, (state_start + 2))   ; = 514\n   set (temp_two, (state_start\
    \ + 3))   ; = 515\n   set (temp_three, (state_end - 1))   ; = 518\n   :state_identifier_a\
    \         ; start state at 512\n   byte (172, 166, 11, 142, 178, 131)\n   :state_identifier_b\
    \         ; start state at 513\n   byte (157, 191, 175, 198, 61, 210)\n   :state_identifier_c\
    \         ; start state at 514\n   byte (52, 197, 217, 29, 83, 97)\n   :state_identifier_d\
    \         ; start state at 515\n   byte (189, 214, 186, 42, 198, 90)\n   :state_identifier_e\
    \         ; start state at 516\n   byte (71, 194, 24, 20, 238, 7)\n   :state_identifier_f\
    \         ; start state at 517\n   byte (194, 117, 148, 29, 215, 161)\n   :state_identifier_g\
    \         ; start state at 518\n   byte (72, 135, 156, 141, 233, 14)\n   The above\
    \ code must be executed a total of 9 times in order to\n   complete the test.\
    \  Each time the code is executed, a 1-byte\n   compressed message N should be\
    \ provided, taking the values 0x00 to\n   0x08 in ascending order (so the compressed\
    \ message should be 0x00 the\n   first time the code is run, 0x01 the second,\
    \ and so on).\n   If the code makes a state creation request, then the state must\
    \ be\n   saved in Compartment (N modulo 3).\n   When the compressed message is\
    \ 0x00, 0x01, or 0x02, the code makes\n   four state creation requests in compartments\
    \ 0, 1, and 2,\n   respectively.  This creates a total of seven distinct state\
    \ items\n   referred to as State a through State g.  The states should be\n  \
    \ distributed among the three compartments as illustrated in Figure 1\n   (note\
    \ that some states belong to more than one compartment).\n   When the compressed\
    \ message is 0x03 or 0x04, the code overwrites all\n   of the states in Compartments\
    \ 0 and 1, respectively.  This means that\n   States a, b, and e will be unavailable\
    \ because they are no longer\n   present in any of the three compartments.\n \
    \  When the compressed message is 0x05, the code checks that the States\n   c,\
    \ d, f, and g are still available.  Decompression should terminate\n   successfully\
    \ in this case.\n   When the compressed message is 0x06, 0x07, or 0x08, the code\
    \ attempts\n   to access States a, b, and e, respectively.  Decompression failure\n\
    \   should occur in this case because the relevant states are no longer\n   available.\n\
    \   The cost in UDVM cycles for each compressed message is given below\n   (except\
    \ for messages 0x06, 0x07, and 0x08 where decompression failure\n   should to\
    \ occur):\n   Compressed message: 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08\n\
    \   Cost in UDVM cycles: 1809 1809 1809 1993 1994 1804 N/A N/A N/A\n         \
    \            +-----------------------------+\n                     |        Compartment\
    \ 0        |\n                     |                             |\n         \
    \            |                             |\n                     |         \
    \  State a           |\n                     |                             |\n\
    \                     |         +-------------------+---------+\n            \
    \         |         |                   |         |\n                     |  \
    \       |                   |         |\n                     |         |    \
    \       State d |         |\n                     |         |                \
    \   |         |\n                     |         |                   |        \
    \ |\n           +---------+---------+---------+         |         |\n        \
    \   |         |         |         |         |         |\n           |        \
    \ |         |         |         |         |\n           |         | State e |\
    \ State g |         | State c |\n           |         |         |         |  \
    \       |         |\n           |         |         |         |         |    \
    \     |\n           |         +---------+---------+---------+         |\n    \
    \       |                   |         |                   |\n           |    \
    \               |         |                   |\n           |           State\
    \ b | State f |                   |\n           |                   |        \
    \ |                   |\n           |                   |         |   Compartment\
    \ 2   |\n           |                   +---------+-------------------+\n    \
    \       |                             |\n           |                        \
    \     |\n           |                             |\n           |            \
    \                 |\n           |        Compartment 1        |\n           +-----------------------------+\n\
    \            Figure 1: States created in the three compartments\n"
- title: 4.4.  Accessing RFC 3485 State
  contents:
  - "4.4.  Accessing RFC 3485 State\n   This section gives assembly code to test accessing\
    \ SIP-SDP static\n   dictionary state [3].  The code first accesses the state\
    \ and then\n   outputs the result.\n   at (32)\n   :input      pad (1)\n   :input2\
    \     pad (1)\n   :input3     pad (1)\n   at (128)\n   STATE-ACCESS (sip_dictionary,\
    \ 20, 0xcfe, 1, input, 0)\n   STATE-ACCESS (sip_dictionary, 6, 0xcff, 1, input2,\
    \ 0)\n   STATE-ACCESS (sip_dictionary, 12, 0xd00, 1, input3, 0)\n   OUTPUT (input,\
    \ 3)\n   END-MESSAGE (0, 0, 0, 0, 0, 0, 0)\n   :sip_dictionary\n   byte (0xfb,\
    \ 0xe5, 0x07, 0xdf, 0xe5, 0xe6)\n   byte (0xaa, 0x5a, 0xf2, 0xab, 0xb9, 0x14)\n\
    \   byte (0xce, 0xaa, 0x05, 0xf9, 0x9c, 0xe6)\n   byte (0x1b, 0xa5)\n   The output\
    \ of the code is 0x5349 50, and the cost is 11 UDVM cycles.\n"
- title: 4.5.  Bytecode State Creation
  contents:
  - "4.5.  Bytecode State Creation\n   This section gives assembly code to test storing\
    \ bytecode using\n   END-MESSAGE and later loading the bytecode using a partial\
    \ state\n   identifier within the SigComp header.  The assembly code is designed\n\
    \   to test the following cases:\n   1.  The bytes to be saved are changed after\
    \ the state create request\n       has been made.\n   2.  The uploaded bytecode\
    \ is modified before execution.\n   3.  The bytecode is loaded using the partial\
    \ state identifier and is\n       modified before execution.\n   4.  The bytecode\
    \ is loaded to an address lower than 128, using the\n       partial state identifier.\n\
    \   5.  The bytecode is loaded using the partial state identifier.  Part\n   \
    \    of the loaded memory is reserved area, which is overwritten after\n     \
    \  loading the bytecode.\n   6.  The loading of the bytecode fails because the\
    \ partial state\n       identifier is too short.\n   at (30)\n   :save_area1\n\
    \   set (saved_instr1, (save_area1 + (code_start2 - start_saved))) ; = 33\n  \
    \ at (80)\n   :save_area2\n   set (saved_instr2, (save_area2 + (code_start2 -\
    \ start_saved))) ; = 83\n   at (128)\n   :code_start\n   COPY (start_saved, saved_len,\
    \ save_area1)\n                       ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE\n\
    \                       ; to position 30 and create as state\n   STATE-CREATE\
    \ (saved_len, save_area1, saved_instr1, 6, 10)\n   set (modify1, (save_area1 +\
    \ 5)) ; = 35\n   LOAD (modify1, 0x1e03)\n                       ; modify save_area2\
    \ to be save_area1 in the\n                       ; created state\n   COPY (start_saved,\
    \ saved_len, save_area2)\n   STATE-CREATE (saved_len, save_area2, saved_instr2,\
    \ 20, 10)\n   STATE-CREATE (saved_len, save_area2, saved_instr2, 12, 10)\n   \
    \                    ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE\n       \
    \                ; to position 80 and create as state twice with\n           \
    \            ; min access len 20 and 12\n   JUMP (modify)\n   :ok1\n   byte (0x4f,\
    \ 0x4b, 0x31)\n   set (after_output_minus1, (after_output - 1))\n   :modify\n\
    \   INPUT-BYTES (1, after_output_minus1, decompression_failure)\n            \
    \           ; Input overwrites the next instruction\n   OUTPUT (ok1, 3)     ;\
    \ Now is OUTPUT (ok1, 2) so output is 0x4f4b\n   :after_output\n   ; Save from\
    \ ok1 to the opcode of END-MESSAGE\n   set (modify_len, ((after_output + 1) -\
    \ ok1)) ; = 13\n   END-MESSAGE (0, 0, modify_len, ok1, modify, 6, 10)\n      \
    \                 ; Save 'ok1', INPUT-BYTES, OUTPUT as state\n   set (saved_len,\
    \ (end_saved - start_saved)) ; = 8\n   :start_saved\n   byte (0x4f, 0x4b, 0x32)\n\
    \   :code_start2\n   ; Translated bytecode for OUTPUT (save_area2, 3)\n   byte\
    \ (0x22, 0xa0, 0x50, 0x03)\n   ; Translated bytecode for END-MESSAGE (0, 0, 0,\
    \ 0, 0, 0, 0)\n   ; The zeros do not need to be sent because UDVM is initialised\
    \ to 0\n   byte (0x23)\n   :end_saved\n   :decompression_failure\n   The outputs\
    \ and cycle usages are:\n   Message              Output                  Cycles\n\
    \   1                    0x4f4b                  66\n   2                    0x4f4b\
    \ 31               7\n   3                    0x4f4b 32               5\n   4\
    \                    0x0000 32               5\n   5                    None \
    \                   Decompression failure\n   First message: mnemonic code annotated\
    \ above\n   0xf804 6112 a0be 081e 2008 1e21 060a 0e23 be03 12a0 be08 a050 2008\n\
    \   0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f 4b31 1c01 a0b3 fc22\n   0xa0a8\
    \ 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003 2302\n   Second message: access\
    \ and run last state saved by previous message -\n   'ok1', INPUT-BYTES, OUTPUT,\
    \ END-MESSAGE.\n   0xf905 b88c e72c 9103\n   Third message: access and run state\
    \ from save_area2 with 12 bytes of\n   state identifier - 'ok2', INPUT-BYTES,\
    \ OUTPUT, END-MESSAGE.\n   0xfb24 63cd ff5c f8c7 6df6 a289 ff\n   Fourth message:\
    \ access and run state from save_area1.  The state is\n   'ok2', INPUT-BYTES,\
    \ OUTPUT, END-MESSAGE but the first two bytes\n   should be overwritten when initialising\
    \ UDVM memory.\n   0xf95b 4b43 d567 83\n   Fifth message: attempt to access state\
    \ from save_area2 with fewer\n   than 20 bytes of state identifier.\n   0xf9de\
    \ 8126 1199 1f\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document describes torture tests for the\
    \ SigComp protocol RFC\n   3320 [2].  Consequently, the security considerations\
    \ for this\n   document match those of SigComp.\n   In addition, the torture tests\
    \ include tests for a significant number\n   of \"boundary and error cases\" for\
    \ execution of the UDVM bytecode.\n   Boundary and error problems are common vectors\
    \ for security attacks,\n   so ensuring that a UDVM implementation executes this\
    \ set of torture\n   tests correctly should contribute to the security of the\n\
    \   implementation.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   Thanks to Richard Price and Pekka Pessi for test contributions\
    \ and to\n   Pekka Pessi and Cristian Constantin, who served as committed working\n\
    \   group document reviewers.\n"
- title: 7.  Normative References
  contents:
  - "7.  Normative References\n   [1]  Surtees, A. and M. West, \"Signaling Compression\
    \ (SigComp) Users'\n        Guide\", RFC 4464, May 2006.\n   [2]  Price, R., Bormann,\
    \ C., Christoffersson, J., Hannu, H., Liu, Z.,\n        and J. Rosenberg, \"Signaling\
    \ Compression (SigComp)\", RFC 3320,\n        January 2003.\n   [3]  Garcia-Martin,\
    \ M., Bormann, C., Ott, J., Price, R., and A.B.\n        Roach, \"The Session\
    \ Initiation Protocol (SIP) and Session\n        Description Protocol (SDP) Static\
    \ Dictionary for Signaling\n        Compression (SigComp)\", RFC 3485, February\
    \ 2003.\n   [4]  Roach, A.B., \"A Negative Acknowledgement Mechanism for Signaling\n\
    \        Compression\", RFC 4077, May 2005.\n"
- title: Appendix A.  UDVM Bytecode for the Torture Tests
  contents:
  - "Appendix A.  UDVM Bytecode for the Torture Tests\n   The following sections list\
    \ the raw UDVM bytecode generated for each\n   test.  The bytecode is presented\
    \ in the form of a complete SigComp\n   message, including the appropriate header.\
    \  It is followed by input\n   messages, the output they produce, and where the\
    \ decompression\n   succeeds the number of cycles used.\n   In some cases, the\
    \ test is designed to be run several times with\n   different compressed messages\
    \ appended to the code.  In the cases\n   where multiple whole messages are used\
    \ for a test, e.g.,\n   Appendix A.2.3, these are supplied.  In the case where\
    \ decompression\n   failure occurs, the high-level reason for it is given as a\
    \ reason\n   code defined in NACK [4].\n   Note that the different assemblers\
    \ can output different bytecode for\n   the same piece of assembly code, so a\
    \ valid assembler can produce\n   results different from those presented below.\
    \  However, the following\n   bytecode should always generate the same results\
    \ on any UDVM.\n"
- title: A.1.  Instructions
  contents:
  - 'A.1.  Instructions

    '
- title: A.1.1.  Bit Manipulation
  contents:
  - "A.1.1.  Bit Manipulation\n   0xf80a 7116 a07f 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x01c0\
    \ 00ff 8055 5502 202a 0321 0420 0305 21ff 2286 0401 20c0 ff02\n   0x2060 0320\
    \ 0421 6005 2061 2286 0423\n   Input: None\n   Output: 0x0150 0000 febf 0000\n\
    \   Cycles: 22\n"
- title: A.1.2.  Arithmetic
  contents:
  - "A.1.2.  Arithmetic\n   0xf80a a11c 01a0 450b 0722 0116 a077 0000 0000 0000 0000\
    \ 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x06c0 00ff\
    \ 9941 0720 0108 20a3 e909 20a0 650a 200b 2286 0406 21c0\n   0xff07 2162 0821\
    \ 6109 2061 0a21 6222 8604 23\n   Input: 0x00\n   Output: 0x0000 0000 0000 0004\n\
    \   Cycles: 25\n   Input: 0x01\n   DECOMPRESSION-FAILURE           DIV_BY_ZERO\n\
    \   Input: 0x02\n   DECOMPRESSION-FAILURE           DIV_BY_ZERO\n"
- title: A.1.3.  Sorting
  contents:
  - "A.1.3.  Sorting\n   0xf80d c10c 8802 170b 8802 1722 a12e 2d23 0000 0000 0000\
    \ 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0a00\
    \ 0a00 1100 0700 1600 0300 0300 0300 1300 0100 1000 0e00\n   0x0800 0200 0d00\
    \ 1400 1200 1700 0f00 1500 0c00 0600 096e 6720 6975\n   0x6920 7469 742c 2079\
    \ 6f75 2720 5346 6f6e 6761 2075 7272 646f 2074\n   0x6f6e 2e2e 0070 6570 206e\
    \ 7472 656e 69\n   Input: None\n   Output: 0x466f 7264 2c20 796f 7527 7265 2074\
    \ 7572 6e69 6e67\n           0x2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f\n\
    \           0x7020 6974 2e\n   Cycles: 371\n"
- title: A.1.4.  SHA-1
  contents:
  - "A.1.4.  SHA-1\n   0xf808 710d a0c3 03a0 4422 a044 140d a0c6 38a0 4422 a044 140e\
    \ 86a0\n   0xfe0e a042 a0ff 0da0 fe8e a044 22a0 4414 0e86 a0ff 0ea0 42a1 070d\n\
    \   0xa0ff a280 a0ff 22a0 ff14 2300 0000 0000 0000 6162 6361 6263 6462\n   0x6364\
    \ 6563 6465 6664 6566 6765 6667 6866 6768 6967 6869 6a68 696a\n   0x6b69 6a6b\
    \ 6c6a 6b6c 6d6b 6c6d 6e6c 6d6e 6f6d 6e6f 706e 6f70 7161\n   0x3031 3233 3435\
    \ 3637\n   Input: None\n   Output: 0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0\
    \ d89d\n           0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1\n     \
    \      0x12ff 347b 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122f\n           0x4f46\
    \ 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452\n   Cycles: 17176\n"
- title: A.1.5.  LOAD and MULTILOAD
  contents:
  - "A.1.5.  LOAD and MULTILOAD\n   0xf803 610e 87a0 840e a082 c080 0ec0 80a0 860e\
    \ c084 c084 2287 081c\n   0x01a0 4127 0820 0206 203c 0f60 03a0 a2a0 b187 0f60\
    \ 042a 87c0 80c0\n   0x8422 8708 23\n   Input: 0x00\n   Output: 0x0084 0084 0086\
    \ 0086 002a 0080 002a 002a\n   Cycles: 36\n   Input: 0x01\n   DECOMPRESSION-FAILURE\
    \           MULTILOAD_OVERWRITTEN\n   Input: 0x02\n   DECOMPRESSION-FAILURE  \
    \         MULTILOAD_OVERWRITTEN\n"
- title: A.1.6.  COPY
  contents:
  - "A.1.6.  COPY\n   0xf803 910e 208e 0e86 860e a042 8712 2087 210e 8680 4100 1286\
    \ a055\n   0xa041 2220 a077 0e86 200e a042 3015 2004 a041 0112 2004 3022 3004\n\
    \   0x1230 042e 2220 0223\n   Input: None\n   Output: 0x4040 4040 4040 4040 4040\
    \ 4040 4040 4040 4040 4040\n           0x4040 4040 4040 4040 4040 4040 4141 4141\
    \ 4141 4141\n           0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141\n\
    \           0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141\n           0x4141\
    \ 4141 4141 4141 4141 4141 4141 4141 4141 4141\n           0x4141 4141 4141 4141\
    \ 4141 4141 4141 4141 4141 5541\n           0x4243 4443 44\n   Cycles: 365\n"
- title: A.1.7.  COPY-LITERAL and COPY-OFFSET
  contents:
  - "A.1.7.  COPY-LITERAL and COPY-OFFSET\n   0xf806 110e 2080 4100 0e86 860e a042\
    \ 870e a044 2113 2087 2222 8608\n   0x0ea0 44a0 9c13 2002 2222 a09c 020e 86a0\
    \ 480e a042 a052 0ea0 44a0\n   0x5215 a048 0aa0 4101 1402 0622 0ea0 4606 1463\
    \ 0422 2261 0a0e a044\n   0xa050 1404 0422 22a0 4402 1405 0422 22a0 4402 2260\
    \ 0a23\n   Input: None\n   Output: 0x4141 4141 0061 4141 4141 494A 4142 4344 494A\
    \ 4142\n           0x004A 004E 4748 4845 4647 4748 4546\n   Cycles: 216\n"
- title: A.1.8.  MEMSET
  contents:
  - "A.1.8.  MEMSET\n   0xf801 810e 8687 0ea0 42a0 8115 86a0 8100 0115 a081 0f86 0f22\
    \ 8710\n   0x23\n   Input: None\n   Output: 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4\
    \ 0312\n   Cycles: 166\n"
- title: A.1.9.  CRC
  contents:
  - "A.1.9.  CRC\n   0xf801 8115 a046 1801 0115 a05e 1487 011c 02a0 4413 1b62 a046\
    \ 2c0e\n   0x23\n   Input: 0x62cb\n   Output: None\n   Cycles: 95\n   Input: 0xabcd\n\
    \   DECOMPRESSION FAILURE           USER_REQUESTED (CRC mismatch)\n"
- title: A.1.10.  INPUT-BITS
  contents:
  - "A.1.10.  INPUT-BITS\n   0xf801 511d 62a0 4614 22a0 4602 0622 010a 2207 0622 0116\
    \ ee23\n   Input: 0x932e ac71\n   Output: 0x0000 0002 0002 0013 0000 0003 001a\
    \ 0038\n   Cycles: 66\n"
- title: A.1.11.  INPUT-HUFFMAN
  contents:
  - "A.1.11.  INPUT-HUFFMAN\n   0xf801 d11e a046 1c02 6200 6262 6200 ff00 22a0 4602\
    \ 0622 010a 2207\n   0x0622 0116 e623\n   Input: 0x932e ac71 66d8 6f\n   Output:\
    \ 0x0000 0003 0008 04d7 0002 0003 0399 30fe\n   Cycles: 84\n"
- title: A.1.12.  INPUT-BYTES
  contents:
  - "A.1.12.  INPUT-BYTES\n   0xf802 710e 86a0 480e a042 a04c 1d62 a046 1d22 a046\
    \ 0206 2202 0a22\n   0x071c 62a0 480e 22a0 4862 0622 0116 e523\n   Input: 0x932e\
    \ ac71 66d8 6fb1 592b dc9a 9734 d847 a733 874e\n         0x1bcb cd51 b5dc 9659\
    \ 9d6a\n   Output: 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8\n     \
    \     0x0007 0001 3387 4e00 08dc 9651 b5dc 9600 599d 6a\n   Cycles: 130\n"
- title: A.1.13.  Stack Manipulation
  contents:
  - "A.1.13.  Stack Manipulation\n   0xf814 110e a046 8610 0210 6010 a042 2286 0811\
    \ 8611 6311 a046 2286\n   0x0816 2800 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 000e a046 200e a048\
    \ a140 0724\n   0x8818 3400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0018 6400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000\
    \ 0000 0000 0000 0000 000e a046 a17f 0ea1 7f1a 0fa1 b003\n   0x0180 c001 8f19\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0023\n   Input:\
    \ None\n   Output: 0x0003 0002 0001 0042 0042 0000 0001 0001\n   Cycles: 40\n"
- title: A.1.14.  Program Flow
  contents:
  - "A.1.14.  Program Flow\n   0xf803 f10e a044 040e 86a0 9207 20a0 9022 a043 0116\
    \ 6006 2101 0e86\n   0xa084 0720 a0a1 22a0 4301 1761 0660 f106 0722 010e 86a0\
    \ 8407 20a0\n   0xb622 a043 011a 0462 0860 9fdc f123\n   Input: None\n   Output:\
    \ 0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909\n   Cycles: 131\n"
- title: A.1.15.  State Creation
  contents:
  - "A.1.15.  State Creation\n   0xf809 411c 01a0 45ff 0422 0b17 628f 0d06 0620 0aa1\
    \ 0a00 1400 0422\n   0x0117 628f 0c06 0620 0a88 0014 0004 2201 1762 8f16 0606\
    \ 1c01 a047\n   0x9fd2 21a0 4863 12a0 e363 a048 0422 0117 628f 0a06 0621 a0e3\
    \ 0604\n   0x2201 1762 8f0e 0606 2300 000a 8800 1400 2300 0000 0000 0000 437a\n\
    \   0xe80a 0fdc 1e6a 87c1 b62a 7676 b973 318c 0ef5 0000 0000 0000 0000\n   0x00c0\
    \ cc3f ee79 bcfc 8fd1 0865 e803 52ee 2977 17df 57\n   Input: 0x01\n   Output:\
    \ None\n   Cycles: 23\n   Input: 0x02\n   Output: None\n   Cycles: 14\n   Input:\
    \ 0x03\n   Output: None\n   Cycles: 24\n   Input: 0x0405\n   DECOMPRESSION-FAILURE\
    \           INVALID_STATE_ID_LENGTH\n   Input: 0x0415\n   DECOMPRESSION-FAILURE\
    \           INVALID_STATE_ID_LENGTH\n   Input: 0x0406\n   Output: None\n   Cycles:\
    \ 23\n   Input: 0x09\n   Output: None\n   Cycles: 34\n   Input: 0x1e06\n   Output:\
    \ None\n   Cycles: 46\n   Input: 0x1e07\n   Output: None\n   Cycles: 47\n   Input:\
    \ 0x1e14\n   Output: None\n   Cycles: 60\n"
- title: A.1.16.  STATE-ACCESS
  contents:
  - "A.1.16.  STATE-ACCESS\n   Set up bytecode:\n   0xf819 0123 0000 1089 0014 0000\
    \ 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0022 a20c\n   0x0423 0000 0000 0000 0074 6573 74\n\
    \   Input: None\n   0xf819 411c 01a0 45ff 1762 0106 0d1c 1f89 1400 0000 891f 8914\
    \ 0c04\n   0xa046 0022 a046 0416 a146 1762 0306 101b 1f87 1400 0000 0016 a136\n\
    \   0x1f89 1306 04a0 4600 16a1 2b1f 8914 0c05 a046 0016 a120 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0023\
    \ 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 005d\
    \ f8bc\n   0x3e20 93b5 abe1 f170 1342 4ce7 fe05 e069 39\n   Input: 0x00\n   Output:\
    \ 0x7465 7374\n   Cycles: 26\n   Input: 0x01\n   Output: 0x7465 7374\n   Cycles:\
    \ 15\n   Input: 0x02\n   DECOMPRESSION-FAILURE           STATE_NOT_FOUND\n   Input:\
    \ 0x03\n   DECOMPRESSION-FAILURE           STATE_NOT_FOUND (len < min_acc_len)\n\
    \   Input: 0x04\n   DECOMPRESSION-FAILURE           STATE_TOO_SHORT\n"
- title: A.2.  Dispatcher Tests
  contents:
  - 'A.2.  Dispatcher Tests

    '
- title: A.2.1.  Useful Values
  contents:
  - "A.2.1.  Useful Values\n   0xf805 f10e 8620 0ea0 4221 1c01 a047 f817 4263 f306\
    \ f317 4300 ed06\n   0x0c17 4400 e73f e717 44a3 c0e1 07e1 1c01 a047 9fda 0623\
    \ 4007 2301\n   0x1220 0163 1c01 a049 9fca 0ea0 4443 0622 0308 2208 0622 a3e8\
    \ 0822\n   0x4106 2264 0722 a358 1220 6220 2300 00a3 c086 8706\n   Input: 1 byte\
    \ of SigComp version\n   Output: None\n   Cycles: 968\n   0xf93a db1d 3d20 aa\n\
    \   Input: 1 byte of SigComp version then 0x0000\n   Output: None\n   Cycles:\
    \ cycles_per_bit * 1080\n   Input: 1 byte of SigComp version then 0x0001\n   DECOMPRESSION-FAILURE\
    \           CYCLES_EXHAUSTED\n   Input: 1 byte of SigComp version then 0x0100\n\
    \   DECOMPRESSION-FAILURE           SEGFAULT\n"
- title: A.2.2.  Cycles Checking
  contents:
  - "A.2.2.  Cycles Checking\n   0xf801 a10f 8604 2029 0022 12a0 4402 6014 02a0 6423\
    \ 22a0 4402 0622\n   0x0116 ef\n   Input: None\n   DECOMPRESSION-FAILURE     \
    \      CYCLES_EXHAUSTED\n"
- title: A.2.3.  Message-based Transport
  contents:
  - "A.2.3.  Message-based Transport\n   0xf8\n   Input: None\n   DECOMPRESSION-FAILURE\
    \           MESSAGE_TOO_SHORT\n   0xf800\n   Input: None\n   DECOMPRESSION-FAILURE\
    \           MESSAGE_TOO_SHORT\n   0xf800 e106 0011 2200 0223 0000 0000 0000 01\n\
    \   Input: None\n   Output: decompression_memory_size\n   Cycles: 5\n   0xf800\
    \ f106 0011 2200 0223 0000 0000 0000 01\n   Input: None\n   DECOMPRESSION-FAILURE\
    \           MESSAGE_TOO_SHORT\n   0xf800 e006 0011 2200 0223 0000 0000 0000 01\n\
    \   Input: None\n   DECOMPRESSION-FAILURE           INVALID_CODE_LOCATION\n  \
    \ 0xf800 ee06 0011 2200 0223 0000 0000 0000 01\n   Input: None\n   Output: decompression_memory_size\n\
    \   Cycles: 5\n"
- title: A.2.4.  Stream-based Transport
  contents:
  - "A.2.4.  Stream-based Transport\n   0xffff f801 7108 0002 2200 0222 a092 0523\
    \ 0000 0000 0000 00ff 00ff\n   0x03ff ffff ffff ffff f801 7e08 0002 2200 0222\
    \ a3d2 0523 0000 0000\n   0x0000 00ff 04ff ffff ffff ffff ffff ff\n   The above\
    \ stream contains two messages:\n   Output: decompression_memory_size\n   Cycles:\
    \ 11\n   Output: decompression_memory_size\n   Cycles: 11\n   0xf8ff ff\n   Input:\
    \ None\n   DECOMPRESSION-FAILURE           MESSAGE_TOO_SHORT\n   0xf800 ffff\n\
    \   Input: None\n   DECOMPRESSION-FAILURE           MESSAGE_TOO_SHORT\n   0xf801\
    \ 8108 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 00ff\n   0x03ff ffff\n\
    \   Input: None\n   DECOMPRESSION-FAILURE           MESSAGE_TOO_SHORT\n   0xf801\
    \ 7008 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 04ff\n   0xffff ff\n\
    \   Input: None\n   DECOMPRESSION-FAILURE           INVALID_CODE_LOCATION\n"
- title: A.2.5.  Input Past the End of a Message
  contents:
  - "A.2.5.  Input Past the End of a Message\n   0xf803 210e 86a0 460e a042 a04d 1d09\
    \ a046 0a1c 07a0 4606 001d 07a0\n   0x46ff 1c02 a046 fa22 a046 021d 10a0 4606\
    \ 001d 08a0 46ff 22a0 4701\n   0x23\n   Input: 0xfffa 0068 6921\n   Output: 0x6869\
    \ 21\n   Cycles: 23\n   Input: 0xfffa 0068 69\n   DECOMPRESSION-FAILURE      \
    \     USER_REQUESTED  (not enough bits)\n"
- title: A.3.  State Handler Tests
  contents:
  - 'A.3.  State Handler Tests

    '
- title: A.3.1.  SigComp Feedback Mechanism
  contents:
  - "A.3.1.  SigComp Feedback Mechanism\n   0xf805 031c 01a0 41a0 5517 6001 070e a04f\
    \ 0ea0 42a4 7f16 0e0e a042\n   0xa4ff 15a0 44a0 7f01 010e a0c3 a801 0ea0 c5a6\
    \ 000e a0cc ac00 0ea0\n   0xd9b4 000e a0ee b500 15a0 c606 0001 15a0 cd0c 0001\
    \ 15a0 da14 0001\n   0x23a0 42a0 c3\n   Input: 0x00\n   Output: None\n   Cycles:\
    \ 52\n   Input: 0x01\n   Output: None\n   Cycles: 179\n"
- title: A.3.2.  State Memory Management
  contents:
  - "A.3.2.  State Memory Management\n   0xf81b a10f 8602 89a2 041c 01a0 47f9 1763\
    \ 0508 a068 a070 1763 0307\n   0x34a0 5608 2306 0623 a204 0ea0 4463 0623 0612\
    \ 6202 a04a 1762 6308\n   0xa058 9fd2 0ea0 4865 0824 8820 6489 0006 6506 2202\
    \ 16e3 1fa2 1606\n   0x0000 0000 1fa2 1c06 0000 0000 1fa2 2206 0000 0000 1fa2\
    \ 2e06 0000\n   0x0000 161e 1fa2 2806 0000 0000 1614 208b 8900 0600 160c 1fa2\
    \ 3406\n   0x0000 0000 1602 2300 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\
    \   0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0074 6573\n   0x7400 0000 0100 0200 0300 0400 0300 0200 0100\
    \ 008e ea4b 43a7 87f9\n   0x010e ef56 7b23 9a34 6b15 a6b4 0fc0 e44d 2cd4 a221\
    \ 47e6 0aef f2bc\n   0x0fb6 af\n   Input: 0x00\n   Output: None\n   Cycles: 811\n\
    \   Input: 0x01\n   Output: None\n   Cycles: 2603\n   Input: 0x02\n   Output:\
    \ None\n   Cycles: 811\n   Input: 0x03\n   Output: None\n   Cycles: 1805\n   Input:\
    \ 0x04\n   DECOMPRESSION-FAILURE           STATE_NOT_FOUND\n   Input: 0x05\n \
    \  Output: None\n   Cycles: 2057\n   Input: 0x06\n   Output: None\n   Cycles:\
    \ 1993\n"
- title: A.3.3.  Multiple Compartments
  contents:
  - "A.3.3.  Multiple Compartments\n   0xf81b 110f 8602 89a2 071c 01a0 45f9 1762 030d\
    \ 3d06 1762 0537 86a0\n   0x6806 2289 20a1 c062 0006 0006 2203 20a1 c062 0006\
    \ 0007 22a2 020a\n   0x2203 0622 a203 20a1 c062 0006 0020 a1c0 a206 0006 6216\
    \ 2b20 a7c0\n   0x2000 0600 1622 1fa2 1306 0000 0000 1fa2 1906 0000 0000 1fa2\
    \ 2506\n   0x0000 0000 1fa2 2b06 0000 0000 2300 0000 0000 0000 1762 0706 101a\n\
    \   0x1fa2 0706 0000 0000 16ea 1fa2 0d06 0000 0000 16e0 1fa2 1f06 0000\n   0x0000\
    \ 169f d600 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0000 0000\n   0x0000 0000 0000 0000 0000 0000 0000 0000 0000\
    \ 0000 0000 0000 0102\n   0x0304 0506 aca6 0b8e b283 9dbf afc6 3dd2 34c5 d91d\
    \ 5361 bdd6 ba2a\n   0xc65a 47c2 1814 ee07 c275 941d d7a1 4887 9c8d e90e\n   Input:\
    \ 0x00\n   Output: None\n   Cycles: 1809\n   Input: 0x01\n   Output: None\n  \
    \ Cycles: 1809\n   Input: 0x02\n   Output: None\n   Cycles: 1809\n   Input: 0x03\n\
    \   Output: None\n   Cycles: 1993\n   Input: 0x04\n   Output: None\n   Cycles:\
    \ 1994\n   Input: 0x05\n   Output: None\n   Cycles: 1804\n   Input: 0x06\n   DECOMPRESSION-FAILURE\
    \           STATE_NOT_FOUND\n   Input: 0x07\n   DECOMPRESSION-FAILURE        \
    \   STATE_NOT_FOUND\n   Input: 0x08\n   DECOMPRESSION-FAILURE           STATE_NOT_FOUND\n"
- title: A.3.4.  Accessing RFC 3485 State
  contents:
  - "A.3.4.  Accessing RFC 3485 State\n   0xf803 a11f a0a6 14ac fe01 2000 1fa0 a606\
    \ acff 0121 001f a0a6 0cad\n   0x0001 2200 2220 0323 0000 0000 0000 00fb e507\
    \ dfe5 e6aa 5af2 abb9\n   0x14ce aa05 f99c e61b a5\n   Input: None\n   Output:\
    \ 0x5349 50\n   Cycles: 11\n"
- title: A.3.5.  Bytecode State Creation
  contents:
  - "A.3.5.  Bytecode State Creation\n   0xf804 6112 a0be 081e 2008 1e21 060a 0e23\
    \ be03 12a0 be08 a050 2008\n   0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f\
    \ 4b31 1c01 a0b3 fc22\n   0xa0a8 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003\
    \ 2302\n   Input: None\n   Output: 0x4f4b\n   Cycles: 66\n   0xf905 b88c e72c\
    \ 9103\n   Input: None\n   Output: 0x4f4b 31\n   Cycles: 7\n   0xfb24 63cd ff5c\
    \ f8c7 6df6 a289 ff\n   Input: None\n   Output: 0x4f4b 32\n   Cycles: 5\n   0xf95b\
    \ 4b43 d567 83\n   Input: None\n   Output: 0x0000 32\n   Cycles: 5\n   0xf9de\
    \ 8126 1199 1f\n   Input: None\n   DECOMPRESSION-FAILURE           STATE_NOT_FOUND\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Abigail Surtees\n   Siemens/Roke Manor Research\n   Roke\
    \ Manor Research Ltd.\n   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794\
    \ 833131\n   EMail: abigail.surtees@roke.co.uk\n   URI:   http://www.roke.co.uk\n\
    \   Mark A. West\n   Siemens/Roke Manor Research\n   Roke Manor Research Ltd.\n\
    \   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794 833311\n   EMail: mark.a.west@roke.co.uk\n\
    \   URI:   http://www.roke.co.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
