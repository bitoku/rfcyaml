- title: __initial_text__
  contents:
  - '               INTRODUCTION TO PROPOSED DOD STANDARD H-FP

    '
- title: Status Of This Memo
  contents:
  - "Status Of This Memo\n   This RFC suggests a proposed protocol for the ARPA-Internet\n\
    \   community, and requests discussion and suggestions for improvements.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: Important Prefatory Note
  contents:
  - "Important Prefatory Note\n   The broad outline of the Host-Front End Protocol\
    \ introduced here and\n   described in RFC 929 is the result of the deliberations\
    \ of a number\n   of experienced H-FP designers, who sat as a committee of the\
    \ DoD\n   Protocol Standards Technical Panel under the author's chairmanship.\n\
    \   The particular protocol to be described is, however, the result of\n   the\
    \ deliberations of a small, ad hoc group, who sat as a de facto\n   subcommittee\
    \ of the H-FP committee, also under the author's\n   chairmanship. The protocol,\
    \ then, follows the consensus of the full\n   group as to what the new H-FP should\
    \ \"look like,\" but has not\n   benefitted from painstaking study by a large\
    \ number of experienced\n   H-FP designers and implementers.  (It has been looked\
    \ at before\n   release as an RFC by several of them, though.) Even if that were\
    \ not\n   the case, it would still be the intent of the designers that the\n \
    \  protocol be subjected to multiple test implementations and probable\n   iteration\
    \ before being agreed upon as any sort of \"standard\".\n   Therefore, the first\
    \ order of business is to declare that THIS IS A\n   PROPOSAL, NOT A FINAL STANDARD,\
    \ and the second order of business is\n   to request that any readers of these\
    \ documents who are able to do\n   test implementations (a) do so and (b) coordinate\
    \ their efforts with\n   the author (617-271-2978 or Padlipsky@USC-ISI.ARPA.).\n"
- title: Historical/Philosophical Context
  contents:
  - "Historical/Philosophical Context\n   Late in May of 1971, the author was presenting\
    \ a status report on\n   whether the Multics ARPANET implementation would be ready\
    \ by the\n   July 1 deadline declared by the sponsor earlier that month.  Some\n\
    \   controversy developed over the fact that the Multics \"NCP\" (Network\n  \
    \ Control Program--actually a blanket term covering the Host-Host and\n   Host-IMP\
    \ protocol interpreters) did not queue requests for\n   connections.  As the specification\
    \ explicitly declared the topic to\n   be one of implementors' choice, the author\
    \ attempted to avoid the\n   argument by asking the interrogator what he was up\
    \ to these days.\n   The answer was, \"Oh, I'm working on the High-Speed Modular\
    \ IMP now\"\n   (later the Pluribus IMP).  And the proverbial coin dropped:  The\n\
    \   author replied, \"I've got a great idea.  Now that we've got some\n   space\
    \ to program in the IMP, why don't we separate out most of the\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   NCP and do it outboard: the only thing that really matters\
    \ in the\n   Host is associating sockets with processes, and if we had common\n\
    \   implementations of all the bit-diddling stuff in the IMPs, we\n   wouldn't\
    \ have disputes over the interpretation of the spec and we'd\n   also save a lot\
    \ of Host CPU cycles!\"\n   As far as the author knows, that incident was the\
    \ beginning of what\n   came to be called \"Network Front-Ends\" and, more recently,\
    \ \"Outboard\n   Processing Environments.\"  (The name change, by the way, was\n\
    \   motivated by a desire to prevent further confusion between NETWORK\n   Front\
    \ Ends--always conceived of as distributed processing mechanisms\n   for the offloading\
    \ of intercomputer networking protocols from\n   Hosts--and traditional communications\
    \ front-ends, which have no\n   connotation of bearing protocol interpreters invokable\
    \ by Host-side\n   programs.)  At least, the idea was original to him and he later\
    \ was a\n   principal designer and the primary author of the first Host-Front\
    \ End\n   Protocol.  So, on the one hand, the present document might be marred\n\
    \   for some readers by undertones of parental pride, but on the other\n   hand,\
    \ if you like primary sources....\n   The evolution of the outboard processing\
    \ idea has been dealt with\n   elsewhere [1]. For present purposes, it should\
    \ suffice to observe\n   that some half-a-dozen implementors of \"NFE's\" of various\
    \ sorts are\n   known to the author to have met with success.  The topic of why\
    \ use\n   an explicit protocol in the first place (as opposed to emulating a\n\
    \   device, or devices, already known to the Host/operating system)\n   deserves\
    \ a word or two here, however.  ([2] deals with it in more\n   general terms.)\
    \  The crucial consideration is that in the general\n   case you wind up \"not\
    \ doing real networking\" if you attach a Host to\n   a network by known device\
    \ emulation, where real networking is taken\n   to mean what has been called \"\
    resource sharing\" in the ARPANET\n   literature, and what appears to be dubbed\
    \ \"open system\n   interconnection\" in the ISO literature: Operating systems'\
    \ built-in\n   assumptions about known devices--whether terminals, terminal\n\
    \   controllers, or RJE stations--tend to get in the way of the sort of\n   process-process\
    \ and eventually procedure-procedure communications\n   that serve as the basis\
    \ for applications more interesting than simple\n   remote login.  To those unfamiliar\
    \ with the outboard processing\n   approach, the premise that the way to attach\
    \ is via an explicit\n   protocol may be difficult to accept, but to those who\
    \ have done it,\n   it makes almost perfect sense.\n   To those, by the way, who\
    \ have worked in intercomputer networking\n   from the perspective of inboard\
    \ (Host-side) implementations of\n   protocol suites, the outboard processing\
    \ idea often seems to lead to\n   less than optimal results, especially as to\
    \ maximizing throughput.\n   And it is difficult to argue that if a given Host\
    \ were well and truly\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   fine-tuned to \"do networking\" the insertion of an\
    \ extra processor\n   could somehow lead to better networking.  However, for Hosts\
    \ where\n   conservation of CPU cycles is an issue, or even where memory is\n\
    \   scarce (i.e., where it's desirable to conserve the resources being\n   shared),\
    \ outboarding is clearly the way to go.  For that matter,\n   viewing outboard\
    \ processing aright (as a form of distributed\n   processing) it can be argued\
    \ that even for extremely powerful\n   \"intelligent work stations\"/\"personal\
    \ computers\" which have the\n   resources to spare it still makes sense to outboard\
    \ in order not to\n   have to do new implementations of entire protocol suites\
    \ for each new\n   such system--always assuming, of course, that the Host-Front\
    \ End\n   protocol in play is noticeably less complex than the offloaded\n   protocols.\n\
    \   None of this is meant to imply that outboard processing is the ONLY\n   way\
    \ to do intercomputer networking, of course.  It is, however, meant\n   to suggest\
    \ that outboard processing can be advantageous in a number\n   of contexts.  Indeed,\
    \ given the joint advents of microprocessors and\n   Local Area Networks, a generic\
    \ bus interface unit which also plays\n   the role of a NFE (that is, is an Outboard\
    \ Processing Environment)\n   even allows for the original intent of \"offloading\
    \ to the IMP\" to be\n   realized, so that a free-standing, possibly fairly expensive\
    \ NFE need\n   not be interposed between Host and net.  Note, by the way, that\n\
    \   nothing in the OPE approach requires that ALL Hosts employ OPEs. That\n  \
    \ is, the only protocols \"seen\" beyond the Comm Subnet Processor are\n   the\
    \ common intercomputer networking protocols (e.g., all DDN IMPs see\n   and read\
    \ IP datagrams). H-FP is strictly a matter between a Host and\n   its OPE.\n \
    \  It is also important to be aware that, given the advent of several\n   different\
    \ suites of protocols in the networking world, it might well\n   be the case that\
    \ the only reasonable way to achieve\n   \"interoperability\" might well be to\
    \ use a suitable H-FP (such as the\n   one to be presented in the companion RFC)\
    \ and an Outboard Processing\n   Environment which is capable of parallel invocation\
    \ of protcol suites\n   (with the choice of suite for a given connection being\
    \ dependent, of\n   course, on the native suite of the desired target Host and/or\n\
    \   application).\n   The unquestionable advantages, then, of the approach, based\
    \ on ten or\n   more years of experience and analysis, would seem to be as\n \
    \  follows--always recalling the assumption that the work to implement\n   and\
    \ execute the H-FP in play is small compared to the full protocol\n   suite in\
    \ question:  As noted, common implementation of a protocol\n   suite has the automatic\
    \ advantage of mutual consistency; further,\n   particularly in the DOD context,\
    \ it's far easier to procure common\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   implementations of standard protocols than to procure\
    \ different ones\n   on a per-Host type basis.  Also as noted, if the resources\
    \ to be\n   shared are viewed as being the participating Hosts'\n   CPU cycles\
    \ and memories, these resources are conserved by doing  as\n   much as possible\
    \ of the networking protocols in an OPE rather than in\n   the mainframe.  Another,\
    \ less evident advantage is that having an OPE\n   effectively insulates a Host\
    \ against changes in the\n   outboarded/offloaded protocols--or even changes of\
    \ the protocols,\n   should the nascent international protocol standards ever\
    \ mature\n   sufficiently to supplant the in-place DOD standards.  (That is, given\n\
    \   an abstract enough interface--in the spirit of the Principle of\n   Layering--a\
    \ Host could, for example, go from doing TCP as its\n   \"Host-Host\" protocol\
    \ to, say, ECMA Class 4 as its \"Transport\"\n   protocol without taking any particular\
    \ cognizance of the change,\n   however unattractive such a change would be to\
    \ advocates of the\n   APRANET Reference Model such as the author. See [3] for\
    \ more on the\n   implied \"Reference Model\" issues.) Finally, although a few\
    \ rather\n   specialized points could also be adduced, it should be noted that\
    \ for\n   network security architectures which are predicated on the ability to\n\
    \   control all means of egress from and ingress to \"the net\", uniform\n   use\
    \ of OPEs is clearly desirable.\n   If we can stipulate that an OPE is/can be\
    \ a good thing, then the\n   remaining problem is just what the protocol interpreted\
    \ by a Host and\n   its OPE ought to be, once it's observed that a standard protocol\
    \ is\n   desirable in order to allow for as much commonality as possible among\n\
    \   Host-side interpreters of the protocol.  That is, we envision the\n   evolution\
    \ of paradigmatic H-FP PIs which can more or less\n   straightforwardly be integrated\
    \ with  various operating systems, on\n   the one hand, and the ability simply\
    \ to transplant an H-FP PI from\n   one instance of a given operating system to\
    \ other instances of the\n   same system, much as is currently being attempted\
    \ in the DODIIS NFE\n   program.  Again, the major motivation in the DOD context\
    \ is the\n   minimizing of procurement problems.\n"
- title: Technical Context
  contents:
  - "Technical Context\n   As noted, some half-a-dozen Host-Front End protocols have\
    \ been seen\n   by the author.  Indeed, in December of 1982, a meeting was convened\n\
    \   to allow the developers of those H-FPs to compare their experiences,\n   with\
    \ an eye to coming up with a proposal for a DOD standard H-FP;\n   this paper\
    \ is a direct result of that meeting.  In the current\n   section, we present\
    \ the consensus of the meeting as to the broad\n   outline of the protocol; in\
    \ the accompanying document, the current\n   version of the proposed protocol\
    \ will be presented, as detailed by\n   the author and Richard Mandell and Joel\
    \ Lilienkamp (both of SDC).\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   Note, by the way, that in some sense we should probably\
    \ have changed\n   the name from H-FP to H-OPEP (or something), but the habit\
    \ of saying\n   \"H-FP\" seems too deeply engrained, despite the fact that it\
    \ does seem\n   worthwhile to stop saying \"NFE\" and start saying \"OPE.\"  (Besides,\n\
    \   H-OPEP looks rather silly.)\n   A final preliminary:  all the designers and\
    \ implementors of H-FPs\n   present at the December meeting concurred that the\
    \ true test of any\n   protocol is how well it implements.  Therefore, until several\n\
    \   implementations of the \"new\" protocol have been performed and\n   assessed,\
    \ it must be understood that the proposed protocol is\n   precisely that:  a proposal,\
    \ not a standard.\n   Not too surprisingly, the first point on which consensus\
    \ was reached\n   is that there are three separable aspects (or \"layers\") to\
    \ an H-FP:\n   At bottom, there must be some physical means for conveying bits\
    \ from\n   Host to OPE and from OPE to Host.  As it has always been a premise\
    \ of\n   outboard processing that the Host's convenience is paramount, just\n\
    \   what this physical layer is can vary:  typically, a bit-serial\n   interface\
    \ is customary, but parallel/DMA interfaces, if available for\n   the Host and\
    \ interfaceable to a given OPE, are fair game.  (So would\n   teleporting the\
    \ bits be, for that matter.)\n   In the middle, there must be a layer to manage\
    \ the multiplexing of\n   network \"connections\" and the control of the flow\
    \ between Host and\n   OPE.  If we agree to call the lowest layer the Link and\
    \ the middle\n   layer the Channel, one thing which must be noted is that between\
    \ the\n   two of them, the Link and Channel layers must be responsible for\n \
    \  reliably conveying the bits between Host and OPE. After all, an OPE'd\n   Host\
    \ should not be \"weaker\" than one with an inboard implementation\n   of a robust\
    \ Host-Host protocol such as TCP.  It should be noted that\n   any Host which\
    \ \"comes with\" a suitable implementation of the X.25\n   interface protocol\
    \ (where the definition of \"suitable\" is rather too\n   complex to deal with\
    \ here) could, given an OPE conditioned to accept\n   it, quite cheerfully satisfy\
    \ the requirements of the lower two\n   layers. This is not to say that X.25 \"\
    is\" the mechanization of H-FP's\n   Link and Channel layers, however; merely\
    \ that it could be used.  The\n   protocol spec itself will detail an alternative,\
    \ less cumbersome\n   channel layer for Hosts which don't have or want X.25.\n\
    \   The top layer of H-FP is the most important:  we refer to it as the\n   Command\
    \ layer.  Here is where the peer H-FP modules in a given Host\n   and OPE communicate\
    \ with each other. Indeed, the segregation of JUST\n   multiplexing and flow control\
    \ (plus reliability) into the Channel\n   Layer is done--in addition to making\
    \ it easier for Hosts that possess\n   preexisting software/hardware which could\
    \ be turned to the\n   purpose--so as to clarify \"what the H-FP is\":  it's the\
    \ commands and\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   responses of the Command layer wherewith the Host's\
    \ processes are\n   able to manipulate the outboard implementations of the members\
    \ of a\n   protocol suite. The use of the phrase \"commands and responses\" is\n\
    \   rather significant, as it happens. For in the protocol to be proposed\n  \
    \ for DOD standardization, unlike all but one of its predecessors,\n   binary\
    \ encoded \"headers\" are not employed; rather, the H-FP commands\n   are indeed\
    \ ASCII strings, and the responses (following the practice\n   of ARPANET FTP)\
    \ ASCII-encoded numbers.\n   There are various reasons for this departure, which\
    \ initially stemmed\n   from a desire to have the same NFE be usable for terminal\
    \ traffic as\n   well as Host offloading, but the one that seemed to dominate\
    \ when\n   consensus was arrived on it as the basis for the new standard is that\n\
    \   it is very much in the original spirit of H-FP.  That is, if you want\n  \
    \ to \"make things as easy as possible for the Host\", it makes a great\n   deal\
    \ of sense to offload in a fashion that only requires some sort of\n   scenario\
    \ or script (\"exec-com\"/\"command file\"/\"shell command\" are\n   approximations\
    \ on some systems) in the Host, rather than requiring a\n   program, possibly\
    \ of more complexity than we would like. This is not\n   to say that we envision\
    \ all--or even most--Hosts will take the\n   scenario approach to H-FP mechanization,\
    \ but rather that the command\n   orientation chosen allows for the possibility.\
    \ (It would be useful to\n   recall that the Channel layer does all the necessary\n\
    \   multiplexing/demultiplexing, so that each channel's  metaphorical\n   state\
    \ machine--at least on the Host side--really has very little to\n   worry about\
    \ other than \"doing its thing.\")\n   It should be noted that the proposed protocol\
    \ provides a mechanism\n   for offloading \"all\" protocols.  That is, although\
    \ most \"first\n   generation NFEs\" only handled ARPANET Reference Model Layers\
    \ II and I\n   (Host-Host and Network Interface--approximately ISO levels 4-1,\
    \ with\n   some of L5's functionality included when it comes to service\n   identifications\
    \ being handled via Well-Known Sockets in L II), it is\n   assumed that OPEs will\
    \ be evolved to handle L III offloading as well\n   (ISO 5-7).  Indeed, it should\
    \ also be noted that what is being\n   addressed here is \"the protocol\", not\
    \ \"the\" OPE.  More will be said\n   on this topic below, and in the protocol\
    \ spec itself, but it is\n   important to realize from the outset that the H-FP\
    \ being proposed is\n   intended to be implementable by any number of OPE suppliers/vendors,\n\
    \   so \"an\" OPE may or may not choose to implement, say, a given file\n   transfer\
    \ protocol, but provided it says so in proper H-FP terms and\n   does offload\
    \ some other protocols it's still an OPE in our sense of\n   the term. (Cf. \"\
    Issues\" and \"Non-Issues\", below.)\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - 'Introduction to H-FP

    '
- title: Issues
  contents:
  - "Issues\n   The following items are either in some sense still open issues or\n\
    \   bear special emphasis:\n   Command Approach\n      The most striking feature\
    \ of the new H-FP, especially to those who\n      have seen older H-FPs, is the\
    \ decision to employ\n      character-oriented commands rather than the more conventional\n\
    \      binary-oriented headers at the Command Layer.  As noted, the\n      primary\
    \ motivation was the report that the approach worked well\n      when it was employed\
    \ in an H-FP for the Platform Network called\n      NAP (Network Access Protocol)\
    \ [4]. In discussions with NAP's\n      originator, Gerry Bailey, the author was\
    \ convinced of the\n      fundamental reasonableness of the approach, but of course\
    \ that\n      doesn't have to convince others.  Additional rationales emerged\
    \ in\n      discussions with Gary Grossman, the originator of the DCA/DTI\n  \
    \    H-FP [5], which is probably the best-known current H-FP and which\n     \
    \ furnished the default Channel Layer for the new one:  In the first\n      place,\
    \ the text approach makes parsing for the ends of\n      variable-length parameters\
    \ easier.  In the second place, it allows\n      for the possibility of creating\
    \ a terminal-supporting OPE in a\n      very straightforward fashion should any\
    \ OPE developer elect to do\n      so.  (See below for more on the distinction\
    \ between OPE developers\n      and H-FP implementors.) Finally, there's nothing\
    \ sacred about\n      binary headers anyway, and just because the text approach\
    \ is\n      different doesn't make it \"wrong\".  So, although it's not out of\n\
    \      the question that the new protocol should back off from the text\n    \
    \  approach if reviewers and/or implementors come up with compelling\n      reasons\
    \ for doing so, the already frequently encountered reaction\n      of \"it feels\
    \ funny\" isn't compelling.  (It was, indeed, the\n      author's own initial\
    \ reaction.)  Besides, \"nobody\" (not even Gary)\n      really liked the top\
    \ layer of the DCA/DTI H-FP.\n   X.25 Appropriateness\n      Of more concern than\
    \ how text \"feels\" is whether X.25 \"works\".\n      That is, we understand\
    \ that many system proprietors would greatly\n      prefer being able to use \"\
    off-the-shelf\" software and hardware to\n      the greatest extent feasible and\
    \ still be able to do intercomputer\n      networking according to DOD Standards,\
    \ which is a major reason why\n      we decided to take the H-FP commands out\
    \ of the Channel Layer of\n      the DCA/DTI H-FP even before we decided to encode\
    \ them as text.\n      However, it is by no means clear that any old vendor supplied\n\
    \      \"X.25\" will automatically be usable as a new H-FP Channel and Link\n\
    \      layer mechanization.  As noted, it all depends upon how Host\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n      programs (the Command Layer/H-FP Protocol Interpreter\
    \ in\n      particular) are able to invoke X.25 on particular systems.  Also,\n\
    \      there might be peculiarities in the handling of some constructs\n     \
    \ (the Group and Member fields--or whatever they're called--are a\n      strong\
    \ candidate) which could militate against getting JUST\n      demultiplexing and\
    \ flow control out of X.25-as-Channel\n      Link/Layers.  For that matter, it's\
    \ conceivable that on some\n      systems only one process can \"own\" the presumed\
    \ DCE, but there's\n      no interprocess communication available between it and\
    \ the\n      processes that want to use H-FP.  What that all amounts to, then,\n\
    \      is that we don't pretend to be sufficiently versed in the vagaries\n  \
    \    of vendor-idiosyncratic X.25 implementations to claim more than\n      that\
    \ we THINK the new H-FP Command Layer should fit \"on top of\"\n      X.25 in\
    \ a Host such that a suitably crafted OPE could look like a\n      DCE to the\
    \ low-level Host software and still be an OPE in our\n      sense of the term.\
    \  Finally, some reports on bit-transfer rates\n      attainable through typical\
    \ X.25 interfaces give rise to concern as\n      to whether such a lash-up would\
    \ be \"good\" even if it were\n      feasible.\n      DCA/DTI Channel Layer Appropriateness\n\
    \      The Channel Layer of the DCA/DTI H-FP has been implemented for a\n    \
    \  few Host types already, and is being implemented for others (in\n      particular,\
    \ as part of the DODIIS NFE project). A delicate\n      decision is whether to\
    \ alter the header structure (e.g.--and\n      perhaps i.e.--to remove the now-superfluous\
    \ command and response\n      fields).  On the \"con\" side are the considerations\
    \ that\n      implementations DO exist, and that it's well specified.  On the\n\
    \      \"pro\" side are that keeping the header as it is is in some sense\n  \
    \    \"wasteful\" and that somebody's going to have to go over the spec\n    \
    \  again anyway, to remove that which no longer applies.  (It should\n      be\
    \ noted that Gary Grossman was initially tempted to scuttle the\n      Group and\
    \ Member trick, but the presence of a similar\n      dichotomizing in X.25 seems\
    \ to rule that out.)  One of the\n      interesting issues during the review phase\
    \ of the new H-FP, then,\n      will be the decision about which way to go on\
    \ the Channel Layer\n      header in its non-X.25 version.  (NOBODY considers\
    \ going X.25\n      only, be it noted.)  By the time the protocol is finalized,\
    \ it\n      will, of course, be made clear in the protocol spec, but I'll\n  \
    \    probably leave this in the final version of the Introduction just\n     \
    \ for historical interest anyway.\n   Syntax\n      Another point which probably\
    \ needs close scrutiny during the\n      review process is the \"syntax\" of the\
    \ command lines.  Basically,\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n      we just took our best shot, but without any claims\
    \ that it's the\n      best possible way to express things.  So comments and/or\n\
    \      alternatives are earnestly solicited on this one.\n   L III Offloading\n\
    \      Contrary to the expectations of some, we are allowing for the\n      offloading\
    \ of Process/Applications Layer (ARPANET Reference Model\n      L III) protocols.\
    \  Both Bailey and Grossman reported favorably on\n      the feasibility of this.\
    \ Two points should be made, however: It's\n      perfectly fair for a GIVEN OPE\
    \ implementation not to offload a\n      given L III protocol, although it would\
    \ presumably not sell as\n      well as ones which did.  That is, we're not claiming\
    \ that by\n      inventing a mechanization of the feature in the spec we levy\
    \ a\n      constraint on everybody who implements \"the protocol\", (Cf.\n   \
    \   Fabrication under Non-Issues, below). Just as we were feeling our\n      way\
    \ on syntax in general, we're really feeling our way when it\n      comes to the\
    \ L III stuff.  (I'm not even sure I managed to convey\n      what I meant for\
    \ \"mediation level\" to Joel and Dick.)  Again,\n      suggestions are solicited.\n\
    \   Security\n      During the detailed design pass, we had an intensive discussion\n\
    \      with some of the Blacker design team on the interplay between the\n   \
    \   new H-FP and a meant-to-be multilevel-secure OPE such as Blacker.\n      The\
    \ conclusion was that by and large \"Security\" is to be an aspect\n      of an\
    \ enhanced H-FP, rather than the standard one. The reasoning\n      was rather\
    \ involved, but seems to amount to the following:  Hosts\n      that are NOT MLS\
    \ (or \"Compartmented\") have two significant\n      properties in our context:\
    \ They're in the vast majority of\n      present-day systems.  They have no legitimate\
    \ need even to tell\n      their OPEs what they \"think\" their current System\
    \ High or\n      Dedicated Mode level is; that information should be furnished\
    \ by\n      some trusted portion of a network security architecture (e.g., a\n\
    \      security enhanced OPE, or a table in a \"secure\" comm subnet\n      processor).\n\
    \      Thus, even having the optional security label/level field in the\n    \
    \  Begin command is in some sense overkill, because we're not sure of\n      any\
    \ sensible circumstances in which it would be useful, but we put\n      it in\
    \ \"just in case\".  On the other hand, Hosts that ARE\n      MLS/Compartmented\
    \ by definition can be permitted to assert what\n      the level of a given transmission\
    \ (or perhaps of a given\n      connection) should be, and their OPEs need to\
    \ have a mechanism for\n      learning this.  But it is by no means clear that\
    \ a given Host (or\n      even a given OPE) will be so structured as to make the\
    \ H-FP PI,\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n      the Channel PI, and the Link PI ALL trustworthy--as\
    \ they'd have to\n      be if the security labeling were part of H-FP.  So, we\
    \ envision\n      the labeling's being handled by trusted code in both Host and\
    \ OPE\n      that will be inserted into the normal processing route at the\n \
    \     appropriate point for the given architecture (presumably \"at the\n    \
    \  very bottom\" of the Host, and \"the very top\" of the OPE), and that\n   \
    \   will place the label in a convenient, known position in the\n      Host-OPE\
    \ transmission \"chunk\" (block/packet/data unit) as the\n      circumstances\
    \ dictate. (It's likely--but we wouldn't swear to\n      it--that a good place\
    \ would be just before the H-FP command, and\n      if that's the case then semi-clearly\
    \ the security enhanced H-FP\n      PIs would have to \"make room\" for it in\
    \ the sense of handing the\n      Channel Layer a suitably lengthened \"chunk\"\
    .)\n      The Host and its OPE should be viewed as a single entity with\n    \
    \  regard to labeling requirements in the non-MLS/C case, and either\n      the\
    \ OPE will be conditioned to emit the right label or the CSNP\n      will \"know\"\
    \ anyway; in the MLS/C Host and OPE case (and it should\n      be noted that it's\
    \ just about impossible to envision a MLS/C Host\n      which IS outboarded which\
    \ DOESN'T have a MLS/C OPE) it will depend\n      on the given security architectures\
    \ as to whether each \"chunk\"\n      needs labeling (i.e., there COULD be trusted\
    \ H-FP, Channel, and\n      Link PIs, so that only at channel establishment time\
    \ does the\n      label need to be passed), but it seems likely each \"chunk\"\
    \ would\n      need labeling, and we can see how that would happen (as sketched\n\
    \      above).\n      This is all, of course, subject to reappraisal when the\
    \ full-time\n      Security folks get in the act, but for now, H-FP per se is\
    \ viewed\n      as playing no direct role in \"Security\"--except indirectly,\
    \ as\n      noted below under the Symmetric Begins Non-Issue.  (In case\n    \
    \  anybody's worrying about the case where the OPE is physically\n      remote\
    \ from its Host, by the way, that line would have to be\n      protected anyway,\
    \ so the Host/OPE-asa-single-unit view should hold\n      up.)\n   How It Implements\n\
    \      The final issue to take note of is that one of the central\n      premises\
    \ of the Outboard Processing approach has always been that\n      H-FPs can be\
    \ invented which implement more compactly on the Host\n      side than the code\
    \ they're allowing to be offloaded.  We certainly\n      think the new H-FP will\
    \ fulfill that condition, but we'd certainly\n      like to hear of any evidence\
    \ to the contrary.\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - 'Introduction to H-FP

    '
- title: Non-Issues
  contents:
  - "Non-Issues\n   The following items are declared to be non-issues, in the sense\
    \ that\n   even though some people have expressed concern over them we believe\n\
    \   that they are either \"not part of the protocol\" or resolved already\n  \
    \ for reasons that were overlooked by those worried about them:\n   Fabrication\n\
    \      Who builds OPEs isn't within our purview, except to the extent of\n   \
    \   hoping a few volunteers come forward to do testcase\n      implementations\
    \ of what is, at present, only a paper protocol.\n      However, beyond agreeing\
    \ that a few points should be marked as\n      \"Notes to Entrepreneurs\" in the\
    \ spec, we didn't attempt to dictate\n      how an OPE vendor would behave, beyond\
    \ the explicit and implicit\n      dictates of the protocol per se. For example,\
    \ if a given OPE\n      doesn't offload SMTP, it jolly well ought to respond with\
    \ the\n      appropriate \"Function not implemented\" code, and if a vendor\n\
    \      claims to accept X.25 for Channel and Link disagreements over what\n  \
    \    X.25 \"is\" are the province of the vendor and the customer, not of\n   \
    \   the H-FP spec.  As OPE'S are supposed to be offloading COMMON\n      protocols\
    \ in a COMMON fashion, a given OPE should be able to\n      interoperate with\
    \ another Host irrespective of whether that Host\n      even has an OPE, much\
    \ less whose OPE it is if it's there. Thus,\n      for example, even though you'd\
    \ expect to find OPEs that \"come\n      with\" their own LANs as a fairly frequent\
    \ product, we don't appeal\n      to the notion in the conceptual model; nor do\
    \ we attempt to\n      dictate \"chunk\" sizes at the Channel level. A protocol\
    \ spec isn't\n      an implementation spec.\n   Symmetric Begins\n      For almost\
    \ as long as there have been H-FPs, there has been\n      disagreement over whether\
    \ only the Host can begin a connection or\n      if the OPE can also take the\
    \ initiative.  I am delighted to be\n      able to resolve this one finally: \
    \ It turns out there IS a\n      compelling reason for insisting that THE PROTOCOL\
    \ include\n      provision for OPE --> Host Begins, so it's \"in\" the protocol--but\n\
    \      any Host that doesn't need to deal with them doesn't have to (just\n  \
    \    \"spell\" the \"Function not implemented\" response code correctly).\n  \
    \    (In case anybody cares, the compelling reason is that if you HAD\n      an\
    \ MLS OPE which happened to use a security kernel and a process\n      per level,\
    \ you'd need IT to be listening for incoming connection\n      requests \"from\
    \ the net\" rather than having the Host tell it to do\n      so, for various esoteric\
    \ reasons--but in order to cater to the\n      possibility, we want the function\
    \ in the protocol from the\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n      beginning, on the grounds that we can envision SOME\
    \ other uses for\n      it even in non-MLS environments [unlike the security labeling\n\
    \      trick discussed above, which only seems to make sense for MLS\n      Hosts/OPEs--that\
    \ is, it doesn't burden the Host to reject a Begin\n      every once in a while\
    \ but it would to go around labeling \"chunks\"\n      unnecessarily all the time].)\n\
    \   Routing\n      Concern has been voiced over the issue of what provisions the\n\
    \      protocol should make to deal with the situation where a Host,\n      probably\
    \ for traffic/load reasons, has multiple OPEs and the\n      question arises of\
    \ which OPE to use/route to.  I claim this is a\n      non-issue at the protocol\
    \ level.  If the Host-side H-FP PI gets a\n      \"No resources\" response to\
    \ a Begin, it can go off to another OPE\n      if it wants to.  \"Not our department\"\
    .  The conceptual model is\n      that of a Host and AN OPE--which \"ought to\"\
    \ be expandable to carry\n      more load at some level.  If you want multiple\
    \ links for some\n      reason, the simplest solution would seem to be to have\
    \ multiple\n      Channel Layers as well, but the whole thing just gets too iffy\
    \ to\n      have anything sensible to prescribe in the protocol.  In other\n \
    \     words, extending the concept to deal with discrete multiple OPEs\n     \
    \ is either a Fabrication sort of thing, or a Notes to Host-side\n      Implementors\
    \ sort of thing on a per specific OPE basis.\n   Operator Interface\n      It's\
    \ probably implicit in the foregoing, but it might be worth\n      saying explicitly\
    \ that the operator interface to a specific OPE is\n      a non-issue in terms\
    \ of the protocol, beyond the provision we're\n      made for \"Shutdown coming\"\
    \ responses as a reflection of a probable\n      operator interface action we\
    \ imagine most operator interfaces\n      would provide.  (It might also be worth\
    \ noting that if your Host\n      does \"color changes\", your OPE had better\
    \ have a trustworthy way\n      of being told to change the label it plops on\
    \ all IP datagrams it\n      emits, but that comes under the heading of an Aside\
    \ to Specialized\n      Implementors.)\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - 'Introduction to H-FP

    '
- title: Fine Points
  contents:
  - "Fine Points\n   There are a couple of known \"loose ends\" which are exceedingly\
    \ fine\n   points in some sense that do bear separate mention:\n   The Allocate\
    \ Event\n      While mentally testing to see if the new H-FP would indeed\n  \
    \    off-load TCP, we came up against an interesting question: Viewing\n     \
    \ H-FP as \"just an interface at a distance\" to a TCP PI, what about\n      the\
    \ Allocate \"Interface Event\" in the TCP spec?  As far as I'm\n      concerned,\
    \ this could be classed as a non-issue, because I submit\n      that the spec\
    \ is wrong in declaring that there is such a thing as\n      a MANDATORY Interface\
    \ Event whereby the user of a TCP PI lets the\n      PI know how much data it\
    \ can take. Granted, you might find such a\n      thing in most implementations,\
    \ but what if you were in a virtual\n      memory environment with segment sharing\
    \ (or a distributed\n      supervisor) and you wanted to avoid copies, so all\
    \ that passed at\n      the interface to the PI (or even at the interface from\
    \ the PI) was\n      a pointer?  That is, the \"DOD version\" of the TCP spec\
    \ has fallen\n      into the trap of assuming things about the execution environment\n\
    \      that it shouldn't have.\n      One moral of this is that\n         AN INTERFACE\
    \ TO AN INTERPRETER OF A PROTOCOL IS N*O*T \"THE\n         PROTOCOL\".\n     \
    \ Another moral is that the interface to the Host-side H-FP PI is\n      hard\
    \ to say much about, but is where the equivalent functionality\n      will be\
    \ found if you've offloaded TCP.  That is, it's reasonable\n      to let the user\
    \ \"tell\" the outboard PI at Begin time if big or\n      small buffers are expected\
    \ to be in play \"net-ward\" as part of the\n      protocol, but the outboard\
    \ PI is expected to deliver bits to the\n      Host as they come unless throttled\
    \ by the Channel Layer, or by\n      some to-be-invented other discipline to force\
    \ the OPE to buffer.\n      (For present purposes, we envision letting the Channel\
    \ Layer\n      handle it, but nifty mechanizations of encouraging the OPE to\n\
    \      \"make like a buffer\" would be at least looked at.)  As a\n      Fabrication\
    \ issue, it is the case that \"equity\" has to be dealt\n      with with regard\
    \ to the use of the OPE's resources (especially\n      buffers) across H-FP connections/channels,\
    \ but that's a different\n      issue anyway, touched upon in the final fine point.\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   Precedence\n      Clearly, the existence of a notion\
    \ of Precedence in DOD protocols\n      has to get reflected in the outboard PI's\
    \ implementations. Just\n      what, if any, role it has in the H-FP, per se,\
    \ is, however, by no\n      means clear.  That is, if the Host doesn't take Begins\
    \ from the\n      OPE and is \"full up\" on the number of Server Telnet connections\n\
    \      it's willing to handle, what should happen if a high precedence\n     \
    \ SYN comes in on the Telnet Well-Known Socket (in present day\n      terms)?\
    \  Probably the OPE should arbitrarily close a low\n      precedence connection\
    \ to make room for the new one, and signal the\n      Host, but even that assumes\
    \ the Host will always hurry to be\n      prepared to do a new passive Begin.\
    \  Perhaps we've stumbled across\n      still another argument in favor of \"\
    Symmetric Begins\"....  At any\n      rate, Precedence does need further study--although\
    \ it shouldn't\n      deter us from making \"the rest\" of the protocol work while\
    \ we're\n      waiting for inspiration on how to handle Precedence too.\n"
- title: A Note on Host Integration
  contents:
  - "A Note on Host Integration\n   The most important thing about Hosts in any intercomputer\
    \ network is\n   that they furnish the resources to be shared. The most significant\n\
    \   obstacle to sharing those resources, however, is the fact that almost\n  \
    \ invariably they were designed under the assumption that the Host was\n   a fully\
    \ autonomous entity.  That is, few operating systems currently\n   deployed \"\
    expect\" to be members of a heterogeneous community of\n   operating systems.\
    \  In many cases, this built-in insularity goes so\n   far as to have applications\
    \ programs cognizant of the particular type\n   of terminal from which they will\
    \ be invoked.\n   Intercomputer networking protocols attempt to resolve the problems\
    \ of\n   heterogeneity by virtue of presenting appropriate common intermediate\n\
    \   representations (or \"virtualizations\") of the constructs and concepts\n\
    \   necessary to do resource sharing.  A Host-Host protocol such as TCP\n   \"\
    is\" a virtual interprocess communication mechanism; a virtual\n   terminal protocol\
    \ such as Telnet obviously is a mechanism for\n   defining and dealing with virtual\
    \ terminals; FTP offers common\n   representations of files; and so on.  It cannot\
    \ be stressed strongly\n   enough, though, that this entire approach to intercomputer\
    \ networking\n   is predicated on the assumption that the modules which interpret\
    \ the\n   protocols (PIs, as we'll refer to them often) will be PROPERLY\n   integrated\
    \ into the various participating operating systems.  Even in\n   the presence\
    \ of powerful OPEs, wherein the bulk of the work of the\n   various PIs is performed\
    \ outboard of the Host, the inboard \"hooks\"\n   which serve to interface the\
    \ outboard PIs to the native system must\n   not only be present, they must be\
    \ \"right\".  The argument parallels\n   the analysis of the flexible vs. rigid\
    \ front-ending attachment\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   strategy issue of [1]; to borrow an example, if you\
    \ attempt to\n   integrate FTP by \"looking like\" a native terminal user and\
    \ the\n   operator forces a message to all terminals, you've got an undetected\n\
    \   pollution of your data stream. So the key issue in attaching Hosts to\n  \
    \ networks is not what sort of hardware is required or what sort of\n   protocol\
    \ is interpreted by the Host and the OPE (or comm subnet\n   processor, for that\
    \ matter), but how the PIs (full or partial) are\n   made to interrelate with\
    \ the pre-existing environment.\n   It would be well beyond the scope of this\
    \ document to attempt even to\n   sketch (much less specify) how to integrate\
    \ H-FP PIs into each type\n   of operating system which will be found in the DoD.\
    \  An example,\n   though, should be of use and interest.  Therefore, because\
    \ it is the\n   implementation with which we are most intimately familiar, even\n\
    \   though it's been several years, we propose to sketch the Multics\n   operating\
    \ system integration of the original ARPANET Network Control\n   Program (NCP)--which\
    \ is functionally equivalent to an H-FP PI for\n   offloading ARM L II and L I--and\
    \ Telnet.  (A few comments will also\n   be made about FTP.) Note, by the way,\
    \ that the sketch is for a\n   \"full-blown\" H-FP; that is, shortcuts along the\
    \ lines of the\n   scenario-driven approach mentioned above are not dealt with\
    \ here.\n   One of the particularly interesting features of Multics is the fact\n\
    \   that each process possesses an extremely large \"segmented virtual\n   memory\"\
    .  That is, memory references other than to the segment at\n   hand (which can\
    \ itself be up to 256K 36-bit words long) indirect\n   through a descriptor segment,\
    \ which is in principle \"just another\n   segment\", by segment number and offset\
    \ within the segment, so that a\n   single process--or \"scheduling and access\
    \ control entity\"--can\n   contain rather impressive amounts of code and data.\
    \  Given that the\n   code is \"pure procedure\" (or \"re-entrant\"), a \"distributed\n\
    \   supervisor\" approach is natural; each process, then, appears to have\n  \
    \ in its address space a copy of each procedure segment (with\n   system-wide\
    \ and process-specific data segments handled\n   appropriately).  Without going\
    \ too far afield, the distributed\n   supervisor approach allows interrupts to\
    \ be processed by whichever\n   process happens to be running at a given time,\
    \ although, of course,\n   interprocess communication may well be a consequence\
    \ of processing a\n   particular interrupt.\n   A few other necessary background\
    \ points:  A distinguished process,\n   called the Answering Service, exists,\
    \ originally to field interrupts\n   from terminals and in general to create processes\
    \ after\n   authenticating them.  Other shared resources such as line printers\n\
    \   are also managed by distinguished processes, generically known as\n   \"Daemons\"\
    .  Device driver code, as is customary on many operating\n   systems, resides\
    \ at least in part in the supervisor (or hard core\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   operating system).  Finally (for our purposes, at least),\
    \ within a\n   process all interfaces are by closed subroutine calls and all I/O\
    \ is\n   done by generic function calls on symbolically named streams; also,\n\
    \   all system commands (and, of course, user written programs which need\n  \
    \ to) use the streams \"user_input\" and \"user_output\" for the obvious\n   purposes.\
    \  (At normal process creation time, both user I/O streams\n   are \"attached\"\
    \ to the user's terminal, but either or both can be\n   attached to any other\
    \ I/O system interface module instead--including\n   to one which reads and writes\
    \ files, which is handy for consoleless\n   processes.)\n   All that almost assuredly\
    \ doesn't do justice to Multics, but equally\n   likely is more than most readers\
    \ of this document want to know, so\n   let's hope it's enough to make the following\
    \ integration sketch\n   comprehensible. (There will be some conscious omissions\
    \ in the\n   sketch, and doubtless some unconscious ones, but if memory serves,\
    \ no\n   known lies have been included.)\n   Recalling that NCP is functionally\
    \ equivalent to H-FP, let's start\n   with it. In the first place, the device\
    \ driver for the 1822 spec\n   hardware interface resides in the supervisor. (For\
    \ most systems, the\n   PI for H-FP's link protocol probably would too.)  In Multics,\n\
    \   interrupt time processing can only be performed by supervisor\n   segments,\
    \ so in the interests of efficiency, both the IMP-Host (1822\n   software) Protocol\
    \ PI and the multiplexing/demultiplexing aspects of\n   the Host-Host Protocol\
    \ PI also reside in the supervisor.  (An H-FP PI\n   would probably also have\
    \ its multiplexing/demultiplexing there; that\n   is, that portion of the Channel\
    \ Layer code which mediates access to\n   the OPE and/or decides what process\
    \ a given message is to be sent to\n   might well be in the supervisor for efficiency\
    \ reasons.  It is not,\n   however, a hard and fast rule that it would be so.\
    \ The system's\n   native interprocess communications mechanism's characteristics\
    \ might\n   allow all the Channel Layer to reside outside of the supervisor.)\n\
    \   Even with a very large virtual memory, though, there are\n   administrative\
    \ biases against putting too much in the supervisor, so\n   \"everything else\"\
    \ lives outside the supervisor. In fact, there are\n   two places where the rest\
    \ of the Host-Host Protocol is interpreted on\n   Multics, although it is not\
    \ necessarily the case that an H-FP PI\n   would follow the same partitioning\
    \ even on Multics, much less on some\n   other operating system.  However, with\
    \ NCP, because there is a\n   distinguished \"control link\" over which Host-Host\
    \ commands are sent\n   in the NCP's Host-Host protocol, the Multics IMP-Host\
    \ Protocol PI\n   relegates such traffic to a Network Daemon process, which naturally\n\
    \   is a key element in the architecture.  (Things would be more\n   efficient,\
    \ though, if there weren't a separate Daemon, because other\n   processes then\
    \ have to get involved with interprocess communication\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   to it; H-FP PI designers take note.)  To avoid traversing\
    \ the Daemon\n   for all traffic, though, normal reads and writes (i.e., noncontrol\n\
    \   link traffic) are done by the appropriate user process.  By virtue of\n  \
    \ the distributed supervisor approach, then, there is a supervisor call\n   interface\
    \ to \"the NCP\" available to procedures (programs) within user\n   processes.\
    \ (The Daemon process uses the same interface, but by virtue\n   of its ID has\
    \ the ability to exercise certain privileged primitives\n   as well.)\n   If a\
    \ native process (perhaps one meaning to do \"User Telnet\", but not\n   limited\
    \ to that) wanted to use the network, it would call the open\n   primitive of\
    \ \"the NCP\", do reads and writes, and so on.  An\n   interesting point has to\
    \ do with just how this interface works:  The\n   reads are inherently asynchronous;\
    \ that is, you don't know just when\n   the data from the net are going to be\
    \ available.  In Multics, there's\n   an \"event\" mechanism that's used in the\
    \ NCP interface that allows the\n   calling process to decide whether or not it\
    \ will go blocked waiting\n   for input when it reads the net (it might want to\
    \ stay active in\n   order to keep outputting, but need to be prepared for input\
    \ as well),\n   so asynchrony can be dealt with.  In the version of Unix (tm)\
    \ on\n   which an early NFE was based, however, native I/O was always\n   synchronous;\
    \ so in order to deal with both input from the terminal\n   and input from the\
    \ net, that system's User Telnet had to consist of\n   two processes (which is\
    \ not very efficient of system resources).\n   Similar considerations might apply\
    \ to other operating systems\n   integrating H-FP; native I/O and interprocess\
    \ communication\n   disciplines have to be taken into account in designing.  (Nor\
    \ can one\n   simply posit a brand new approach for \"the network\", because Telnet\n\
    \   will prove to rely even more heavily on native mode assumptions.)\n   The\
    \ other aspect of NCP integration which we should at least touch\n   on--especially\
    \ because process-level protocols make no sense without\n   it--is how \"Well-Known\
    \ Sockets\" (WKSs) work. In broad terms, on\n   Multics the Network Daemon initially\
    \ \"owns\" all sockets.  For\n   Well-Known Sockets, where a particular process-level\
    \ protocol will be\n   in effect after a successful connection to a given WKS,\
    \ code is added\n   to the Answering Service to call upon the NCP at system\n\
    \   initialization time to be the process \"listening\" on the WKSs.  (This\n\
    \   is a consequence of the fact that the Answering Service is/was the\n   only\
    \ Multics process which can create processes; strategies on other\n   systems\
    \ would differ according to their native process creation\n   disciplines.)  How\
    \ to get the \"right kind of process\" will be\n   sketched in the discussions\
    \ of the process level protocols, but the\n   significant notion for now is that\
    \ typically SOME sort of prior\n   arrangement would be done by any networked\
    \ Host to associate the\n   right kind of process with a WKS.\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   Now, we don't expect that the foregoing will enable\
    \ even the world's\n   greatest system jock to go out and design the integration\
    \ of an H-FP\n   PI for a system that had never been networked (in the ARPANET\
    \ style\n   of networking) before. But we propose to stop there and turn to some\n\
    \   comments on process level protocols, for two reasons: In the first\n   place,\
    \ it would take us much too far afield to go into significantly\n   greater detail;\
    \ and in the second place, because of the functional\n   equivalence of H-FP and\
    \ NCP combined with the number of operating\n   systems which have integrated\
    \ NCP and, for that matter, TCP/IP, which\n   are also functionally equivalent\
    \ to H-FP (used for offloading L II\n   and L I), models are available in the\
    \ ARPANET community and concerned\n   H-FP PI implementors can follow them.\n\
    \   Turning to Telnet integration, and returning to Multics as an\n   example,\
    \ we note that \"User Telnet\" is straightforward. \"All you\n   need\" (for small\
    \ values of \"all\") from an INBOARD User Telnet is a\n   command that gives the\
    \ user some sort of interface, converts between\n   the native Multics character\
    \ set and terminal discipline and the\n   Network Virtual Terminal equivalents\
    \ (and as Multics is very generic\n   when it comes to I/O, that's not hard),\
    \ and writes and reads \"the\n   net\" (more accurately, calls upon the Host-Host\
    \ protocol PI--or upon\n   the H-FP PI to get at the H-HP--appropriately).  (One\
    \ point that's\n   not obvious:  make the Well-Known Socket \"on the other side\"\
    \ a\n   parameter, defaulting to the Telnet WKS, because you'll want to use\n\
    \   the same command to get at other process-level protocols.)  If\n   there's\
    \ an OPE in play which offloads User Telnet, however, things\n   can be even simpler:\
    \ the inboard command just reads and writes the\n   terminal and lets the OUTBOARD\
    \ User Telnet PI handle the conversion\n   to and from the Virtual Terminal form\
    \ (presumably, from and to the\n   desired local form).\n   When it comes to the\
    \ incoming (\"Server\") aspects of Telnet, life can\n   get complicated on some\
    \ systems for an inboard implementation.\n   However, fortunately for our purposes,\n\
    \   Multics' native mechanisms lend themselves readily to integration; an\n  \
    \ awareness of the inboard issues will be useful even if in response to\n   a\
    \ connection attempt on the Telnet WKS, the (Server) Host is\n   obligated to\
    \ associate the connection (the actual logic is somewhat\n   more complex under\
    \ the ARPANET Host-Host Protocol, which employs\n   paired simplex connections)\
    \ with a process that is prepared to\n   translate between Telnet and native mode\
    \ representations and\n   otherwise \"look like\" a local user process--that is,\
    \ in particular\n   the connection becomes an I/O source/sink to the native command\n\
    \   processor on time-sharing systems.  As indicated, process creation is\n  \
    \ taken care of in Multics by having the Answering Service process\n   listen\
    \ on the WKS.  Because the Answering Service is in some sense\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   just another Multics process, it too does user I/O through\
    \ the normal\n   system mechanisms.  So while for local terminals the user I/O\
    \ streams\n   are attached through a module called \"ttydim\" (where \"dim\" stands\
    \ for\n   \"device interface module\"), NVTs are attached through a functionally\n\
    \   equivalent and identically invoked module called \"nttydim\" (the\n   Answering\
    \ Service knows which DIM to use based on the symbolic\n   designator of the \"\
    line\" on which it received the interrupt, as it\n   happens).\n   [The notion\
    \ of \"attaching\" the streams bears a bit more explanation:\n   Attach is a primitive\
    \ of the Multics generic I/O mechanism which\n   associates a stream name and\
    \ a particular DIM (or I/O system\n   interface module in later terminology);\
    \ the other I/O primitives\n   (read, write, etc.) are invoked with the stream\
    \ name as a parameter\n   and an I/O \"switch\" causes the entry point corresponding\
    \ to the\n   primitive to be invoked in whichever DIM the stream is currently\n\
    \   attached to.   So a Server Telnet process starts life attached\n   through\
    \ nttydim to a particular network connection, while a local\n   process starts\
    \ life attached through ttydim to a particular physical\n   line, and both processes\
    \ proceed indistinguishably (viewed from\n   outside the I/O switch, anyway).]\n\
    \   The pre-existing orderliness that makes things easy on Multics does\n   not,\
    \ unfortunately, appear in all operating systems.  Indeed,\n   delicate choices\
    \ occasionally have to be made as to WHICH native\n   terminal to map to on systems\
    \ that don't do generic I/O in native\n   mode, and it is likely that for some\
    \ systems the particular mapping\n   to bring into play in Server Telnet might\
    \ be determined by the\n   particular application program invoked.  This issue\
    \ can become very\n   touchy when the application \"expects\" a \"data entry terminal\"\
    , say.\n   The Server Telnet for such a system would naturally attempt to\n  \
    \ negotiate the \"DET\" option with the corresponding User Telnet.  But\n   the\
    \ user might be at a physical terminal that isn't a member of the\n   DET class,\
    \ so that User Telnet must either refuse to negotiate the\n   option or--and we\
    \ would recommend this alternative strongly, as it\n   seems to be within the\
    \ \"spirit\" of the protocol--offer some sort of\n   simulation, however crude,\
    \ of the behavior of a DET.   Also,\n   something sensible has to be done on systems\
    \ where there is no clear\n   analog of the command processor expected to be managing\
    \ the Server\n   process.  (Say, when a \"menu\" of applications is always displayed\
    \ on\n   an available terminal in native mode.)\n   A final Telnet integration\
    \ issue (although other points could be\n   noted, we're not pretending to be\
    \ exhaustive and this should be\n   enough to \"give the flavor\"):  The Telnet\
    \ Interrupt Process generic\n   function calls for particularly careful integration.\
    \  Here, the\n   intent of the function is to virtualize what is called the \"\
    quit\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   button\" on some systems. That is, the user wants the\
    \ system to\n   interrupt his process (which may, for example, be in a loop) and\
    \ get\n   back to the command processor (or \"the system\" itself).   On native\n\
    \   character-at-a-time systems, the native mechanism is usually the\n   entering\
    \ of a particular \"control character\"; on native\n   line-at-a-time systems,\
    \ the native mechanism is usually the striking\n   of the \"ATTN\" or Interrupt\
    \ button or the \"Break\" key (sometimes more\n   than once, to distinguish it\
    \ from a communication to the executing\n   program).  But the native mechanisms\
    \ typically involve interrupt time\n   code, and Server Telnet typically wouldn't\
    \ be executing at that\n   level, so the solution (omitting the intricacies of\
    \ the interaction\n   with the NCP or the H-FP PI, which also get into the act)\
    \ would be to\n   make use of--in the Multics case--a pre-existing INTRAprocess\
    \ signal,\n   or to add such a mechanism (unless the architecture chosen has a\n\
    \   Server Telnet Daemon of some sort, in which case an INTERprocess\n   signal\
    \ would be needed).\n   The extension of the foregoing to an outboard Server Telnet\
    \ may not\n   be obvious, but we won't expend a great deal of time on it here.\n\
    \   Even if \"the protocol\" is being handled in an OPE, the Host-side\n   software\
    \ must be able to associate an H-FP connection with the\n   command language interpreter\
    \ of a user process and to respond\n   appropriately to an H-FP Signal command\
    \ if it arrives, and the OPE\n   must know not only the desired character set\
    \ but also the local\n   equivalents of Erase and Kill, at the minimum.\n   We'll\
    \ skip FTP integration, on the grounds that this note is already\n   too lengthy,\
    \ except to mention that in the OUTBOARD case it's still\n   going to be necessary\
    \ to convey the name of the appropriate file and\n   directory to/from some appropriate\
    \ Host-side code.  (Similar problems\n   must be dealt with for outboard handling\
    \ of \"mail\" if it's not part\n   of FTP.)\n   One other \"integration\" issue,\
    \ which has been hinted at earlier and\n   about which not much can be said beyond\
    \ some general guidelines: The\n   \"top edge\" of a Host-side H-FP protocol interpreter\
    \ (i.e., the Host\n   user program interface, for\n   Hosts that are \"doing real\
    \ networking\" rather than just using the OPE\n   to get at User Telnet and/or\
    \ FTP and to offer Server Telnet and/or\n   FTP [and maybe \"mail\"], presumably\
    \ in the \"scenario-driven\" fashion\n   sketched earlier) MUST BE APPROPRIATE\
    \ TO THE HOST.  In other words,\n   on Multics, where \"everything\" is closed\
    \ subroutines, there would\n   presumably be a closed subroutine interface with\
    \ event channels for\n   reads, pointers to buffers, and all that sort of thing,\
    \ but on some\n   other style of operating system, the interface to the H-FP PI\
    \ might\n   turn out to be \"all\" interprocess communication, or to \"look like\"\
    \ a\n"
- title: RFC 928                                                    December 1984
  contents:
  - 'RFC 928                                                    December 1984

    '
- title: Introduction to H-FP
  contents:
  - "Introduction to H-FP\n   device of some special class, or \"all\" system\n  \
    \ calls/JSYSs/EOTs/Whatevers.  We can't be much more specific, but we'd\n   be\
    \ remiss to convey any impression that H-FP is a \"free lunch\".  As\n   noted,\
    \ an H-FP PI requires the same kind of integration as a generic\n   NCP--it's\
    \ just smaller, and serves as insulation against changes (in\n   the offloaded\
    \ protocols in general, or in the proximate comm subnet\n   in particular).\n"
- title: References
  contents:
  - "References\n   (References [1]-[3] will be available in M. A. Padlipsky's \"\
    The\n   Elements of Networking Style\", Prentice Hall, 1985.)\n   [1] Padlipsky,\
    \ M. A., \"The Host-Front End Protocol Approach\", MTR\n   3996, Vol. III, MITRE\
    \ Corp., 1980.\n   [2] Padlipsky, M. A., \"The Elements of Networking Style\"\
    , M81-41,\n   MITRE Corp., 1981.\n   [3] Padlipsky, M. A., \"A Perspective on\
    \ the ARPANET Reference Model\",\n   M82-47, MITRE Corp., 1982.\n   [4] Bailey,\
    \ G., \"Network Access Protocol\", S-216,718, National\n   Security Agency Central\
    \ Security Service, 1982.\n   [5] Day, J. D., G. R. Grossman, and R. H. Howe,\
    \ \"WWMCCS Host to Front\n   End Protocol\", 78012.C-INFE.14, Digital Technology\
    \ Incorporated,\n   1979.\n"
