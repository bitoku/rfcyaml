- title: __initial_text__
  contents:
  - '     Integrated Services in the Internet Architecture: an Overview

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo discusses a proposed extension to the Internet architecture\n\
    \   and protocols to provide integrated services, i.e., to support real-\n   time\
    \ as well as the current non-real-time service of IP.  This\n   extension is necessary\
    \ to meet the growing need for real-time service\n   for a variety of new applications,\
    \ including teleconferencing, remote\n   seminars, telescience, and distributed\
    \ simulation.\n   This memo represents the direct product of recent work by Dave\
    \ Clark,\n   Scott Shenker, Lixia Zhang, Deborah Estrin, Sugih Jamin, John\n \
    \  Wroclawski, Shai Herzog, and Bob Braden, and indirectly draws upon\n   the\
    \ work of many others.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ...................................................2\n\
    \   2. Elements of the Architecture ...................................3\n   \
    \   2.1 Integrated Services Model ..................................3\n      2.2\
    \ Reference Implementation Framework .........................6\n   3. Integrated\
    \ Services Model ......................................11\n      3.1 Quality of\
    \ Service Requirements ............................12\n      3.2 Resource-Sharing\
    \ Requirements and Service Models ...........16\n      3.3 Packet Dropping ............................................18\n\
    \      3.4 Usage Feedback .............................................19\n  \
    \    3.5 Reservation Model ..........................................19\n   4.\
    \ Traffic Control Mechanisms .....................................20\n      4.1\
    \ Basic Functions ............................................20\n      4.2 Applying\
    \ the Mechanisms ....................................23\n      4.3 An example\
    \ .................................................24\n   5. Reservation Setup\
    \ Protocol .....................................25\n      5.1 RSVP Overview ..............................................25\n\
    \      5.2 Routing and Reservations ...................................28\n  \
    \ 6. Acknowledgments ................................................30\n   References\
    \ ........................................................31\n   Security Considerations\
    \ ...........................................32\n   Authors' Addresses ................................................33\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The multicasts of IETF meetings across the Internet have\
    \ formed a\n   large-scale experiment in sending digitized voice and video through\
    \ a\n   packet-switched infrastructure.  These highly-visible experiments\n  \
    \ have depended upon three enabling technologies.  (1) Many modern\n   workstations\
    \ now come equipped with built-in multimedia hardware,\n   including audio codecs\
    \ and video frame-grabbers, and the necessary\n   video gear is now inexpensive.\
    \  (2) IP multicasting, which is not yet\n   generally available in commercial\
    \ routers, is being provided by the\n   MBONE, a temporary \"multicast backbone\"\
    .  (3) Highly-sophisticated\n   digital audio and video applications have been\
    \ developed.\n   These experiments also showed that an important technical element\
    \ is\n   still missing: real-time applications often do not work well across\n\
    \   the Internet because of variable queueing delays and congestion\n   losses.\
    \  The Internet, as originally conceived, offers only a very\n   simple quality\
    \ of service (QoS), point-to-point best-effort data\n   delivery.  Before real-time\
    \ applications such as remote video,\n   multimedia conferencing, visualization,\
    \ and virtual reality can be\n   broadly used, the Internet infrastructure must\
    \ be modified to support\n   real-time QoS, which provides some control over end-to-end\
    \ packet\n   delays.  This extension must be designed from the beginning for\n\
    \   multicasting; simply generalizing from the unicast (point-to-point)\n   case\
    \ does not work.\n   Real-time QoS is not the only issue for a next generation\
    \ of traffic\n   management in the Internet.  Network operators are requesting\
    \ the\n   ability to control the sharing of bandwidth on a particular link\n \
    \  among different traffic classes.  They want to be able to divide\n   traffic\
    \ into a few administrative classes and assign to each a\n   minimum percentage\
    \ of the link bandwidth under conditions of\n   overload, while allowing \"unused\"\
    \ bandwidth to be available at other\n   times.  These classes may represent different\
    \ user groups or\n   different protocol families, for example.  Such a management\
    \ facility\n   is commonly called controlled link-sharing.  We use the term\n\
    \   integrated services (IS) for an Internet service model that includes\n   best-effort\
    \ service, real-time service, and controlled link sharing.\n   The requirements\
    \ and mechanisms for integrated services have been the\n   subjects of much discussion\
    \ and research over the past several years\n   (the literature is much too large\
    \ to list even a representative\n   sample here; see the references in [CSZ92,\
    \ Floyd92, Jacobson91,\n   JSCZ93, Partridge92, SCZ93, RSVP93a] for a partial\
    \ list).  This work\n   has led to the unified approach to integrated services\
    \ support that\n   is described in this memo.  We believe that it is now time\
    \ to begin\n   the engineering that must precede deployment of integrated services\n\
    \   in the Internet.\n   Section 2 of this memo introduces the elements of an\
    \ IS extension of\n   the Internet.  Section 3 discusses real-time service models\
    \ [SCZ93a,\n   SCZ93b].  Section 4 discusses traffic control, the forwarding\n\
    \   algorithms to be used in routers [CSZ92].  Section 5 discusses the\n   design\
    \ of RSVP, a resource setup protocol compatible with the\n   assumptions of our\
    \ IS model [RSVP93a, RSVP93b].\n"
- title: 2. Elements of the Architecture
  contents:
  - "2. Elements of the Architecture\n   The fundamental service model of the Internet,\
    \ as embodied in the\n   best-effort delivery service of IP, has been unchanged\
    \ since the\n   beginning of the Internet research project 20 years ago [CerfKahn74].\n\
    \   We are now proposing to alter that model to encompass integrated\n   service.\
    \  From an academic viewpoint, changing the service model of\n   the Internet\
    \ is a major undertaking; however, its impact is mitigated\n   by the fact that\
    \ we wish only to extend the original architecture.\n   The new components and\
    \ mechanisms to be added will supplement but not\n   replace the basic IP service.\n\
    \   Abstractly, the proposed architectural extension is comprised of two\n   elements:\
    \ (1) an extended service model, which we call the IS model,\n   and (2) a reference\
    \ implementation framework, which gives us a set of\n   vocabulary and a generic\
    \ program organization to realize the IS\n   model.  It is important to separate\
    \ the service model, which defines\n   the externally visible behavior, from the\
    \ discussion of the\n   implementation, which may (and should) change during the\
    \ life of the\n   service model.  However, the two are related; to make the service\n\
    \   model credible, it is useful to provide an example of how it might be\n  \
    \ realized.\n   2.1 Integrated Services Model\n      The IS model we are proposing\
    \ includes two sorts of service\n      targeted towards real-time traffic: guaranteed\
    \ and predictive\n      service.  It integrates these services with controlled\
    \ link-\n      sharing, and it is designed to work well with multicast as well\
    \ as\n      unicast.  Deferring a summary of the IS model to Section 3, we\n \
    \     first discuss some key assumptions behind the model.\n      The first assumption\
    \ is that resources (e.g., bandwidth) must be\n      explicitly managed in order\
    \ to meet application requirements.\n      This implies that \"resource reservation\"\
    \ and \"admission control\"\n      are key building blocks of the service.  An\
    \ alternative approach,\n      which we reject, is to attempt to support real-time\
    \ traffic\n      without any explicit changes to the Internet service model.\n\
    \      The essence of real-time service is the requirement for some\n      service\
    \ guarantees, and we argue that guarantees cannot be\n      achieved without reservations.\
    \  The term \"guarantee\" here is to be\n      broadly interpreted; they may be\
    \ absolute or statistical, strict\n      or approximate.  However, the user must\
    \ be able to get a service\n      whose quality is sufficiently predictable that\
    \ the application can\n      operate in an acceptable way over a duration of time\
    \ determined by\n      the user.  Again, \"sufficiently\" and \"acceptable\" are\
    \ vague terms.\n      In general, stricter guarantees have a higher cost in resources\n\
    \      that are made unavailable for sharing with others.\n      The following\
    \ arguments have been raised against resource\n      guarantees in the Internet.\n\
    \      o    \"Bandwidth will be infinite.\"\n           The incredibly large carrying\
    \ capacity of an optical fiber\n           leads some to conclude that in the\
    \ future bandwidth will be\n           so abundant, ubiquitous, and cheap that\
    \ there will be no\n           communication delays other than the speed of light,\
    \ and\n           therefore there will be no need to reserve resources.\n    \
    \       However, we believe that this will be impossible in the short\n      \
    \     term and unlikely in the medium term.  While raw bandwidth\n           may\
    \ seem inexpensive, bandwidth provided as a network service\n           is not\
    \ likely to become so cheap that wasting it will be the\n           most cost-effective\
    \ design principle.  Even if low-cost\n           bandwidth does eventually become\
    \ commonly available, we do\n           not accept that it will be available \"\
    everywhere\" in the\n           Internet.  Unless we provide for the possibility\
    \ of dealing\n           with congested links, then real-time services will simply\
    \ be\n           precluded in those cases.  We find that restriction\n       \
    \    unacceptable.\n      o    \"Simple priority is sufficient.\"\n          \
    \ It is true that simply giving higher priority to real-time\n           traffic\
    \ would lead to adequate real-time service at some\n           times and under\
    \ some conditions.  But priority is an\n           implementation mechanism, not\
    \ a service model.  If we define\n           the service by means of a specific\
    \ mechanism, we may not get\n           the exact features we want.  In the case\
    \ of simple priority,\n           the issue is that as soon as there are too many\
    \ real-time\n           streams competing for the higher priority, every stream\
    \ is\n           degraded.  Restricting our service to this single failure\n \
    \          mode is unacceptable.  In some cases, users will demand that\n    \
    \       some streams succeed while some new requests receive a \"busy\n      \
    \     signal\".\n      o    \"Applications can adapt.\"\n           The development\
    \ of adaptive real-time applications, such as\n           Jacobson's audio program\
    \ VAT, does not eliminate the need to\n           bound packet delivery time.\
    \  Human requirements for\n           interaction and intelligibility limit the\
    \ possible range of\n           adaptation to network delays.  We have seen in\
    \ real\n           experiments that, while VAT can adapt to network delays of\n\
    \           many seconds, the users find that interaction is impossible\n    \
    \       in these cases.\n      We conclude that there is an inescapable requirement\
    \ for routers\n      to be able to reserve resources, in order to provide special\
    \ QoS\n      for specific user packet streams, or \"flows\".  This in turn\n \
    \     requires flow-specific state in the routers, which represents an\n     \
    \ important and fundamental change to the Internet model.  The\n      Internet\
    \ architecture was been founded on the concept that all\n      flow-related state\
    \ should be in the end systems [Clark88].\n      Designing the TCP/IP protocol\
    \ suite on this concept led to a\n      robustness that is one of the keys to\
    \ its success.  In section 5\n      we discuss how the flow state added to the\
    \ routers for resource\n      reservation can be made \"soft\", to preserve the\
    \ robustness of the\n      Internet protocol suite.\n      There is a real-world\
    \ side effect of resource reservation in\n      routers.  Since it implies that\
    \ some users are getting privileged\n      service, resource reservation will\
    \ need enforcement of policy and\n      administrative controls.  This in turn\
    \ will lead to two kinds of\n      authentication requirements:  authentication\
    \ of users who make\n      reservation requests, and authentication of packets\
    \ that use the\n      reserved resources.  However, these issues are not unique\
    \ to \"IS\";\n      other aspects of the evolution of the Internet, including\n\
    \      commercialization and commercial security, are leading to the same\n  \
    \    requirements.  We do not discuss the issues of policy or security\n     \
    \ further in this memo, but they will require attention.\n      We make another\
    \ fundamental assumption, that it is desirable to\n      use the Internet as a\
    \ common infrastructure to support both non-\n      real-time and real-time communication.\
    \  One could alternatively\n      build an entirely new, parallel infrastructure\
    \ for real-time\n      services, leaving the Internet unchanged.  We reject this\n\
    \      approach, as it would lose the significant advantages of\n      statistical\
    \ sharing between real-time and non-real-time traffic,\n      and it would be\
    \ much more complex to build and administer than a\n      common infrastructure.\n\
    \      In addition to this assumption of common infrastructure, we adopt\n   \
    \   a unified protocol stack model, employing a single internet-layer\n      protocol\
    \ for both real-time and non-real-time service.  Thus, we\n      propose to use\
    \ the existing internet-layer protocol (e.g., IP or\n      CLNP) for real-time\
    \ data.  Another approach would be to add a new\n      real-time protocol in the\
    \ internet layer [ST2-90].  Our unified\n      stack approach provides economy\
    \ of mechanism, and it allows us to\n      fold controlled link-sharing in easily.\
    \  It also handles the\n      problem of partial coverage, i.e., allowing interoperation\
    \ between\n      IS-capable Internet systems and systems that have not been\n\
    \      extended, without the complexity of tunneling.\n      We take the view\
    \ that there should be a single service model for\n      the Internet.  If there\
    \ were different service models in different\n      parts of the Internet, it\
    \ is very difficult to see how any end-\n      to-end service quality statements\
    \ could be made.  However, a\n      single service model does not necessarily\
    \ imply a single\n      implementation for packet scheduling or admission control.\n\
    \      Although specific packet scheduling and admission control\n      mechanisms\
    \ that satisfy our service model have been developed, it\n      is quite possible\
    \ that other mechanisms will also satisfy the\n      service model.  The reference\
    \ implementation framework, introduced\n      below, is intended to allow discussion\
    \ of implementation issues\n      without mandating a single design.\n      Based\
    \ upon these considerations, we believe that an IS extension\n      that includes\
    \ additional flow state in routers and an explicit\n      setup mechanism is necessary\
    \ to provide the needed service.  A\n      partial solution short of this point\
    \ would not be a wise\n      investment.  We believe that the extensions we propose\
    \ preserve\n      the essential robustness and efficiency of the Internet\n  \
    \    architecture, and they allow efficient management of the network\n      resources;\
    \ these will be important goals even if bandwidth becomes\n      very inexpensive.\n\
    \   2.2 Reference Implementation Framework\n      We propose a reference implementation\
    \ framework to realize the IS\n      model.  This framework includes four components:\
    \ the packet\n      scheduler, the admission control routine, the classifier,\
    \ and the\n      reservation setup protocol.  These are discussed briefly below\
    \ and\n      more fully in Sections 4 and 5.\n      In the ensuing discussion,\
    \ we define the \"flow\" abstraction as a\n      distinguishable stream of related\
    \ datagrams that results from a\n      single user activity and requires the same\
    \ QoS.  For example, a\n      flow might consist of one transport connection or\
    \ one video stream\n      between a given host pair.  It is the finest granularity\
    \ of packet\n      stream distinguishable by the IS.  We define a flow to be simplex,\n\
    \      i.e., to have a single source but N destinations.  Thus, an N-way\n   \
    \   teleconference will generally require N flows, one originating at\n      each\
    \ site.\n      In today's Internet, IP forwarding is completely egalitarian; all\n\
    \      packets receive the same quality of service, and packets are\n      typically\
    \ forwarded using a strict FIFO queueing discipline.  For\n      integrated services,\
    \ a router must implement an appropriate QoS\n      for each flow, in accordance\
    \ with the service model.  The router\n      function that creates different qualities\
    \ of service is called\n      \"traffic control\".  Traffic control in turn is\
    \ implemented by\n      three components: the packet scheduler, the classifier,\
    \ and\n      admission control.\n      o    Packet Scheduler\n           The packet\
    \ scheduler manages the forwarding of different\n           packet streams using\
    \ a set of queues and perhaps other\n           mechanisms like timers.  The packet\
    \ scheduler must be\n           implemented at the point where packets are queued;\
    \ this is\n           the output driver level of a typical operating system, and\n\
    \           corresponds to the link layer protocol.  The details of the\n    \
    \       scheduling algorithm may be specific to the particular output\n      \
    \     medium.  For example, the output driver will need to invoke\n          \
    \ the appropriate link-layer controls when interfacing to a\n           network\
    \ technology that has an internal bandwidth allocation\n           mechanism.\n\
    \           An experimental packet scheduler has been built that\n           implements\
    \ the IS model described in Section 3 and [SCZ93];\n           this is known as\
    \ the CSZ scheduler and is discussed further\n           in Section 4.  We note\
    \ that the CSZ scheme is not mandatory\n           to accomplish our service model;\
    \ indeed for parts of the\n           network that are known always to be underloaded,\
    \ FIFO will\n           deliver satisfactory service.\n           There is another\
    \ component that could be considered part of\n           the packet scheduler\
    \ or separate: the estimator [Jacobson91].\n           This algorithm is used\
    \ to measure properties of the outgoing\n           traffic stream, to develop\
    \ statistics that control packet\n           scheduling and admission control.\
    \  This memo will consider\n           the estimator to be a part of the packet\
    \ scheduler.\n      o    Classifier\n           For the purpose of traffic control\
    \ (and accounting), each\n           incoming packet must be mapped into some\
    \ class; all packets\n           in the same class get the same treatment from\
    \ the packet\n           scheduler.  This mapping is performed by the classifier.\n\
    \           Choice of a class may be based upon the contents of the\n        \
    \   existing packet header(s) and/or some additional\n           classification\
    \ number added to each packet.\n           A class might correspond to a broad\
    \ category of flows, e.g.,\n           all video flows or all flows attributable\
    \ to a particular\n           organization.  On the other hand, a class might\
    \ hold only a\n           single flow.  A class is an abstraction that may be\
    \ local to\n           a particular router; the same packet may be classified\n\
    \           differently by different routers along the path.  For\n          \
    \ example, backbone routers may choose to map many flows into a\n           few\
    \ aggregated classes, while routers nearer the periphery,\n           where there\
    \ is much less aggregation, may use a separate\n           class for each flow.\n\
    \      o    Admission Control\n           Admission control implements the decision\
    \ algorithm that a\n           router or host uses to determine whether a new\
    \ flow can be\n           granted the requested QoS without impacting earlier\n\
    \           guarantees.  Admission control is invoked at each node to\n      \
    \     make a local accept/reject decision, at the time a host\n           requests\
    \ a real-time service along some path through the\n           Internet.  The admission\
    \ control algorithm must be consistent\n           with the service model, and\
    \ it is logically part of traffic\n           control.  Although there are still\
    \ open research issues in\n           admission control, a first cut exists [JCSZ92].\n\
    \           Admission control is sometimes confused with policing or\n       \
    \    enforcement, which is a packet-by-packet function at the\n           \"edge\"\
    \ of the network to ensure that a host does not violate\n           its promised\
    \ traffic characteristics.  We consider policing\n           to be one of the\
    \ functions of the packet scheduler.\n           In addition to ensuring that\
    \ QoS guarantees are met,\n           admission control will be concerned with\
    \ enforcing\n           administrative policies on resource reservations.  Some\n\
    \           policies will demand authentication of those requesting\n        \
    \   reservations.  Finally, admission control will play an\n           important\
    \ role in accounting and administrative reporting.\n      The fourth and final\
    \ component of our implementation framework is\n      a reservation setup protocol,\
    \ which is necessary to create and\n      maintain flow-specific state in the\
    \ endpoint hosts and in routers\n      along the path of a flow.  Section  discusses\
    \ a reservation setup\n      protocol called RSVP (for \"ReSerVation Protocol\"\
    ) [RSVP93a,\n      RSVP93b].  It may not be possible to insist that there be only\
    \ one\n      reservation protocol in the Internet, but we will argue that\n  \
    \    multiple choices for reservation protocols will cause confusion.\n      We\
    \ believe that multiple protocols should exist only if they\n      support different\
    \ modes of reservation.\n      The setup requirements for the link-sharing portion\
    \ of the service\n      model are far less clear than those for resource reservations.\n\
    \      While we expect that much of this can be done through network\n      management\
    \ interfaces, and thus need not be part of the overall\n      architecture, we\
    \ may also need RSVP to play a role in providing\n      the required state.\n\
    \      In order to state its resource requirements, an application must\n    \
    \  specify the desired QoS using a list of parameters that is called\n      a\
    \ \"flowspec\" [Partridge92].  The flowspec is carried by the\n      reservation\
    \ setup protocol, passed to admission control for to\n      test for acceptability,\
    \ and ultimately used to parametrize the\n      packet scheduling mechanism.\n\
    \      Figure  shows how these components might fit into an IP router\n      that\
    \ has been extended to provide integrated services.  The router\n      has two\
    \ broad functional divisions:  the forwarding path below the\n      double horizontal\
    \ line, and the background code above the line.\n      The forwarding path of\
    \ the router is executed for every packet and\n      must therefore be highly\
    \ optimized.  Indeed, in most commercial\n      routers, its implementation involves\
    \ a hardware assist.  The\n      forwarding path is divided into three sections:\
    \ input driver,\n      internet forwarder, and output driver.  The internet forwarder\n\
    \      interprets the internetworking protocol header appropriate to the\n   \
    \   protocol suite, e.g., the IP header for TCP/IP, or the CLNP header\n     \
    \ for OSI.  For each packet, an internet forwarder executes a\n      suite-dependent\
    \ classifier and then passes the packet and its\n      class to the appropriate\
    \ output driver.  A classifier must be both\n      general and efficient.  For\
    \ efficiency, a common mechanism should\n      be used for both resource classification\
    \ and route lookup.\n      The output driver implements the packet scheduler.\
    \  (Layerists\n      will observe that the output driver now has two distinct\
    \ sections:\n      the packet scheduler that is largely independent of the detailed\n\
    \      mechanics of the interface, and the actual I/O driver that is only\n  \
    \    concerned with the grittiness of the hardware.  The estimator\n      lives\
    \ somewhere in between.  We only note this fact, without\n      suggesting that\
    \ it be elevated to a principle.).\n        _____________________________________________________________\n\
    \       |         ____________     ____________     ___________       |\n    \
    \   |        |            |   | Reservation|   |           |      |\n       |\
    \        |   Routing  |   |    Setup   |   | Management|      |\n       |    \
    \    |    Agent   |   |    Agent   |   |  Agent    |      |\n       |        |______._____|\
    \   |______._____|   |_____._____|      |\n       |               .          \
    \      .    |          .            |\n       |               .              \
    \  .   _V________  .            |\n       |               .                . \
    \ | Admission| .            |\n       |               .                .  |  Control\
    \ | .            |\n       |               V                .  |__________| .\
    \            |\n       |           [Routing ]           V               V    \
    \        |\n       |           [Database]     [Traffic Control Database]     \
    \    |\n       |=============================================================|\n\
    \       |        |                  |     _______                     |\n    \
    \   |        |   __________     |    |_|_|_|_| => o               |\n       |\
    \        |  |          |    |      Packet     |     _____     |\n       |    \
    \ ====> |Classifier| =====>   Scheduler   |===>|_|_|_| ===>\n       |        |\
    \  |__________|    |     _______     |               |\n       |        |    \
    \              |    |_|_|_|_| => o               |\n       | Input  |   Internet\
    \       |                                 |\n       | Driver |   Forwarder   \
    \   |     O u t p u t   D r i v e r   |\n       |________|__________________|_________________________________|\n\
    \             Figure 1: Implementation Reference Model for Routers\n      The\
    \ background code is simply loaded into router memory and\n      executed by a\
    \ general-purpose CPU.  These background routines\n      create data structures\
    \ that control the forwarding path.  The\n      routing agent implements a particular\
    \ routing protocol and builds\n      a routing database.  The reservation setup\
    \ agent implements the\n      protocol used to set up resource reservations; see\
    \ Section .  If\n      admission control gives the \"OK\" for a new request, the\n\
    \      appropriate changes are made to the classifier and packet\n      scheduler\
    \ database to implement the desired QoS.  Finally, every\n      router supports\
    \ an agent for network management.  This agent must\n      be able to modify the\
    \ classifier and packet scheduler databases to\n      set up controlled link-sharing\
    \ and to set admission control\n      policies.\n      The implementation framework\
    \ for a host is generally similar to\n      that for a router, with the addition\
    \ of applications.  Rather than\n      being forwarded, host data originates and\
    \ terminates in an\n      application.  An application needing a real-time QoS\
    \ for a flow\n      must somehow invoke a local reservation setup agent.  The\
    \ best way\n      to interface to applications is still to be determined.  For\n\
    \      example, there might be an explicit API for network resource\n      setup,\
    \ or the setup might be invoked implicitly as part of the\n      operating system\
    \ scheduling function.  The IP output routine of a\n      host may need no classifier,\
    \ since the class assignment for a\n      packet can be specified in the local\
    \ I/O control structure\n      corresponding to the flow.\n      In routers, integrated\
    \ service will require changes to both the\n      forwarding path and the background\
    \ functions.  The forwarding\n      path, which may depend upon hardware acceleration\
    \ for performance,\n      will be the more difficult and costly to change.  It\
    \ will be vital\n      to choose a set of traffic control mechanisms that is general\
    \ and\n      adaptable to a wide variety of policy requirements and future\n \
    \     circumstances, and that can be implemented efficiently.\n"
- title: 3. Integrated Services Model
  contents:
  - "3. Integrated Services Model\n   A service model is embedded within the network\
    \ service interface\n   invoked by applications to define the set of services\
    \ they can\n   request.  While both the underlying network technology and the\n\
    \   overlying suite of applications will evolve, the need for\n   compatibility\
    \ requires that this service interface remain relatively\n   stable (or, more\
    \ properly, extensible; we do expect to add new\n   services in the future but\
    \ we also expect that it will be hard to\n   change existing services).  Because\
    \ of its enduring impact, the\n   service model should not be designed in reference\
    \ to any specific\n   network artifact but rather should be based on fundamental\
    \ service\n   requirements.\n   We now briefly describe a proposal for a core\
    \ set of services for the\n   Internet; this proposed core service model is more\
    \ fully described in\n   [SCZ93a, SCZ93b].  This core service model addresses\
    \ those services\n   which relate most directly to the time-of-delivery of packets.\
    \  We\n   leave the remaining services (such as routing, security, or stream\n\
    \   synchronization) for other standardization venues.  A service model\n   consists\
    \ of a set of service commitments; in response to a service\n   request the network\
    \ commits to deliver some service.  These service\n   commitments can be categorized\
    \ by the entity to whom they are made:\n   they can be made to either individual\
    \ flows or to collective entities\n   (classes of flows).  The service commitments\
    \ made to individual flows\n   are intended to provide reasonable application\
    \ performance, and thus\n   are driven by the ergonomic requirements of the applications;\
    \ these\n   service commitments relate to the quality of service delivered to\
    \ an\n   individual flow.  The service commitments made to collective entities\n\
    \   are driven by resource-sharing, or economic, requirements; these\n   service\
    \ commitments relate to the aggregate resources made available\n   to the various\
    \ entities.\n   In this section we start by exploring the service requirements\
    \ of\n   individual flows and propose a corresponding set of services.  We\n \
    \  then discuss the service requirements and services for resource\n   sharing.\
    \  Finally, we conclude with some remarks about packet\n   dropping.\n   3.1 Quality\
    \ of Service Requirements\n      The core service model is concerned almost exclusively\
    \ with the\n      time-of-delivery of packets.  Thus, per-packet delay is the\n\
    \      central quantity about which the network makes quality of service\n   \
    \   commitments.  We make the even more restrictive assumption that\n      the\
    \ only quantity about which we make quantitative service\n      commitments are\
    \ bounds on the maximum and minimum delays.\n      The degree to which application\
    \ performance depends on low delay\n      service varies widely, and we can make\
    \ several qualitative\n      distinctions between applications based on the degree\
    \ of their\n      dependence.  One class of applications needs the data in each\n\
    \      packet by a certain time and, if the data has not arrived by then,\n  \
    \    the data is essentially worthless; we call these real-time\n      applications.\
    \  Another class of applications will always wait for\n      data to arrive; we\
    \ call these \" elastic\" applications.  We now\n      consider the delay requirements\
    \ of these two classes separately.\n      3.1.1 Real-Time Applications\n     \
    \    An important class of such real-time applications, which are\n         the\
    \ only real-time applications we explicitly consider in the\n         arguments\
    \ that follow, are \"playback\" applications.  In a\n         playback application,\
    \ the source takes some signal, packetizes\n         it, and then transmits the\
    \ packets over the network.  The\n         network inevitably introduces some\
    \ variation in the delay of\n         the delivered packets.  The receiver depacketizes\
    \ the data and\n         then attempts to faithfully play back the signal.  This\
    \ is done\n         by buffering the incoming data and then replaying the signal\
    \ at\n         some fixed offset delay from the original departure time; the\n\
    \         term \"playback point\" refers to the point in time which is\n     \
    \    offset from the original departure time by this fixed delay.\n         Any\
    \ data that arrives before its associated playback point can\n         be used\
    \ to reconstruct the signal; data arriving after the\n         playback point\
    \ is essentially useless in reconstructing the\n         real-time signal.\n \
    \        In order to choose a reasonable value for the offset delay, an\n    \
    \     application needs some \"a priori\" characterization of the\n         maximum\
    \ delay its packets will experience.  This \"a priori\"\n         characterization\
    \ could either be provided by the network in a\n         quantitative service\
    \ commitment to a delay bound, or through\n         the observation of the delays\
    \ experienced by the previously\n         arrived packets; the application needs\
    \ to know what delays to\n         expect, but this expectation need not be constant\
    \ for the\n         entire duration of the flow.\n         The performance of\
    \ a playback application is measured along two\n         dimensions:  latency\
    \ and fidelity.  Some playback applications,\n         in particular those that\
    \ involve interaction between the two\n         ends of a connection such as a\
    \ phone call, are rather sensitive\n         to the latency; other playback applications,\
    \ such as\n         transmitting a movie or lecture, are not.  Similarly,\n  \
    \       applications exhibit a wide range of sensitivity to loss of\n        \
    \ fidelity.  We will consider two somewhat artificially\n         dichotomous\
    \ classes: intolerant applications, which require an\n         absolutely faithful\
    \ playback, and tolerant applications, which\n         can tolerate some loss\
    \ of fidelity.  We expect that the vast\n         bulk of audio and video applications\
    \ will be tolerant, but we\n         also suspect that there will be other applications,\
    \ such as\n         circuit emulation, that are intolerant.\n         Delay can\
    \ affect the performance of playback applications in\n         two ways.  First,\
    \ the value of the offset delay, which is\n         determined by predictions\
    \ about the future packet delays,\n         determines the latency of the application.\
    \  Second, the delays\n         of individual packets can decrease the fidelity\
    \ of the playback\n         by exceeding the offset delay; the application then\
    \ can either\n         change the offset delay in order to play back late packets\n\
    \         (which introduces distortion) or merely discard late packets\n     \
    \    (which creates an incomplete signal).  The two different ways\n         of\
    \ coping with late packets offer a choice between an\n         incomplete signal\
    \ and a distorted one, and the optimal choice\n         will depend on the details\
    \ of the application, but the\n         important point is that late packets necessarily\
    \ decrease\n         fidelity.\n         Intolerant applications must use a fixed\
    \ offset delay, since\n         any variation in the offset delay will introduce\
    \ some\n         distortion in the playback.  For a given distribution of packet\n\
    \         delays, this fixed offset delay must be larger than the\n         absolute\
    \ maximum delay, to avoid the possibility of late\n         packets.   Such an\
    \ application can only set its offset delay\n         appropriately if it is given\
    \ a perfectly reliable upper bound\n         on the maximum delay of each packet.\
    \  We call a service\n         characterized by a perfectly reliable upper bound\
    \ on delay \"\n         guaranteed service\", and propose this as the appropriate\n\
    \         service model for intolerant playback applications.\n         In contrast,\
    \ tolerant applications need not set their offset\n         delay greater than\
    \ the absolute maximum delay, since they can\n         tolerate some late packets.\
    \  Moreover, instead of using a\n         single fixed value for the offset delay,\
    \ they can attempt to\n         reduce their latency by varying their offset delays\
    \ in response\n         to the actual packet delays experienced in the recent\
    \ past.  We\n         call applications which vary their offset delays in this\
    \ manner\n         \"adaptive\" playback applications.\n         For tolerant\
    \ applications we propose a service model called \"\n         predictive service\"\
    \ which supplies a fairly reliable, but not\n         perfectly reliable, delay\
    \ bound.  This bound, in contrast to\n         the bound in the guaranteed service,\
    \ is not based on worst case\n         assumptions on the behavior of other flows.\
    \  Instead, this\n         bound might be computed with properly conservative\
    \ predictions\n         about the behavior of other flows.  If the network turns\
    \ out to\n         be wrong and the bound is violated, the application's\n   \
    \      performance will perhaps suffer, but the users are willing to\n       \
    \  tolerate such interruptions in service in return for the\n         presumed\
    \ lower cost of the service.  Furthermore, because many\n         of the tolerant\
    \ applications are adaptive, we augment the\n         predictive service to also\
    \ give \"minimax\" service, which is to\n         attempt to minimize the ex post\
    \ maximum delay.  This service is\n         not trying to minimize the delay of\
    \ every packet, but rather is\n         trying to pull in the tail of the delay\
    \ distribution.\n         It is clear that given a choice, with all other things\
    \ being\n         equal, an application would perform no worse with absolutely\n\
    \         reliable bounds than with fairly reliable bounds.  Why, then,\n    \
    \     do we offer predictive service?  The key consideration here is\n       \
    \  efficiency; when one relaxes the service requirements from\n         perfectly\
    \ to fairly reliable bounds, this increases the level\n         of network utilization\
    \ that can be sustained, and thus the\n         price of the predictive service\
    \ will presumably be lower than\n         that of guaranteed service.  The predictive\
    \ service class is\n         motivated by the conjecture that the performance\
    \ penalty will\n         be small for tolerant applications but the overall efficiency\n\
    \         gain will be quite large.\n         In order to provide a delay bound,\
    \ the nature of the traffic\n         from the source must be characterized, and\
    \ there must be some\n         admission control algorithm which insures that\
    \ a requested flow\n         can actually be accommodated. A fundamental point\
    \ of our\n         overall architecture is that traffic characterization and\n\
    \         admission control are necessary for these real-time delay bound\n  \
    \       services.  So far we have assumed that an application's data\n       \
    \  generation process is an intrinsic property unaffected by the\n         network.\
    \  However, there are likely to be many audio and video\n         applications\
    \ which can adjust their coding scheme and thus can\n         alter the resulting\
    \ data generation process depending on the\n         network service available.\
    \  This alteration of the coding\n         scheme will present a tradeoff between\
    \ fidelity (of the coding\n         scheme itself, not of the playback process)\
    \ and the bandwidth\n         requirements of the flow.  Such \"rate-adaptive\"\
    \ playback\n         applications have the advantage that they can adjust to the\n\
    \         current network conditions not just by resetting their playback\n  \
    \       point but also by adjusting the traffic pattern itself.  For\n       \
    \  rate-adaptive applications, the traffic characterizations used\n         in\
    \ the service commitment are not immutable.  We can thus\n         augment the\
    \ service model by allowing the network to notify\n         (either implicitly\
    \ through packet drops or explicitly through\n         control packets) rate-adaptive\
    \ applications to change their\n         traffic characterization.\n      3.1.2\
    \ Elastic Applications\n         While real-time applications do not wait for\
    \ late data to\n         arrive, elastic applications will always wait for data\
    \ to\n         arrive.  It is not that these applications are insensitive to\n\
    \         delay; to the contrary, significantly increasing the delay of a\n  \
    \       packet will often harm the application's performance.  Rather,\n     \
    \    the key point is that the application typically uses the\n         arriving\
    \ data immediately, rather than buffering it for some\n         later time, and\
    \ will always choose to wait for the incoming\n         data rather than proceed\
    \ without it.  Because arriving data can\n         be used immediately, these\
    \ applications do not require any a\n         priori characterization of the service\
    \ in order for the\n         application to function.  Generally speaking, it\
    \ is likely that\n         for a given distribution of packet delays, the perceived\n\
    \         performance of elastic applications will depend more on the\n      \
    \   average delay than on the tail of the delay distribution.  One\n         can\
    \ think of several categories of such elastic applications:\n         interactive\
    \ burst (Telnet, X, NFS), interactive bulk transfer\n         (FTP), and asynchronous\
    \ bulk transfer (electronic mail, FAX).\n         The delay requirements of these\
    \ elastic applications vary from\n         rather demanding for interactive burst\
    \ applications to rather\n         lax for asynchronous bulk transfer, with interactive\
    \ bulk\n         transfer being intermediate between them.\n         An appropriate\
    \ service model for elastic applications is to\n         provide \"as-soon-as-possible\"\
    , or ASAP service. (For\n         compatibility with historical usage, we will\
    \ use the term\n         best-effort service when referring to ASAP service.).\
    \  We\n         furthermore propose to offer several classes of best-effort\n\
    \         service to reflect the relative delay sensitivities of\n         different\
    \ elastic applications.  This service model allows\n         interactive burst\
    \ applications to have lower delays than\n         interactive bulk applications,\
    \ which in turn would have lower\n         delays than asynchronous bulk applications.\
    \  In contrast to the\n         real-time service models, applications using this\
    \ service are\n         not subject to admission control.\n         The taxonomy\
    \ of applications into tolerant playback, intolerant\n         playback, and elastic\
    \ is neither exact nor complete, but was\n         only used to guide the development\
    \ of the core service model.\n         The resulting core service model should\
    \ be judged not on the\n         validity of the underlying taxonomy but rather\
    \ on its ability\n         to adequately meet the needs of the entire spectrum\
    \ of\n         applications.  In particular, not all real-time applications\n\
    \         are playback applications; for example, one might imagine a\n      \
    \   visualization application which merely displayed the image\n         encoded\
    \ in each packet whenever it arrived.  However, non-\n         playback applications\
    \ can still use either the guaranteed or\n         predictive real-time service\
    \ model, although these services are\n         not specifically tailored to their\
    \ needs.  Similarly, playback\n         applications cannot be neatly classified\
    \ as either tolerant or\n         intolerant, but rather fall along a continuum;\
    \ offering both\n         guaranteed and predictive service allows applications\
    \ to make\n         their own tradeoff between fidelity, latency, and cost.\n\
    \         Despite these obvious deficiencies in the taxonomy, we expect\n    \
    \     that it describes the service requirements of current and\n         future\
    \ applications well enough so that our core service model\n         can adequately\
    \ meet all application needs.\n   3.2 Resource-Sharing Requirements and Service\
    \ Models\n      The last section considered quality of service commitments; these\n\
    \      commitments dictate how the network must allocate its resources\n     \
    \ among the individual flows.  This allocation of resources is\n      typically\
    \ negotiated on a flow-by-flow basis as each flow requests\n      admission to\
    \ the network, and does not address any of the policy\n      issues that arise\
    \ when one looks at collections of flows.  To\n      address these collective\
    \ policy issues, we now discuss resource-\n      sharing service commitments.\
    \  Recall that for individual quality\n      of service commitments we focused\
    \ on delay as the only quantity of\n      interest.  Here, we postulate that the\
    \ quantity of primary\n      interest in resource-sharing is aggregate bandwidth\
    \ on individual\n      links.  Thus, this component of the service model, called\
    \ \"link-\n      sharing\", addresses the question of how to share the aggregate\n\
    \      bandwidth of a link among various collective entities according to\n  \
    \    some set of specified shares.  There are several examples that are\n    \
    \  commonly used to explain the requirement of link-sharing among\n      collective\
    \ entities.\n      Multi-entity link-sharing. -- A link may be purchased and used\n\
    \      jointly by several organizations, government agencies or the like.\n  \
    \    They may wish to insure that under overload the link is shared in\n     \
    \ a controlled way, perhaps in proportion to the capital investment\n      of\
    \ each entity.  At the same time, they might wish that when the\n      link is\
    \ underloaded, any one of the entities could utilize all the\n      idle bandwidth.\n\
    \      Multi-protocol link-sharing -- In a multi-protocol Internet, it\n     \
    \ may be desired to prevent one protocol family (DECnet, IP, IPX,\n      OSI,\
    \ SNA, etc.) from overloading the link and excluding the other\n      families.\
    \ This is important because different families may have\n      different methods\
    \ of detecting and responding to congestion, and\n      some methods may be more\
    \ \"aggressive\" than others. This could lead\n      to a situation in which one\
    \ protocol backs off more rapidly than\n      another under congestion, and ends\
    \ up getting no bandwidth.\n      Explicit control in the router may be required\
    \ to correct this.\n      Again, one might expect that this control should apply\
    \ only under\n      overload, while permitting an idle link to be used in any\n\
    \      proportion.\n      Multi-service sharing -- Within a protocol family such\
    \ as IP, an\n      administrator might wish to limit the fraction of bandwidth\n\
    \      allocated to various service classes.  For example, an\n      administrator\
    \ might wish to limit the amount of real-time traffic\n      to some fraction\
    \ of the link, to avoid preempting elastic traffic\n      such as FTP.\n     \
    \ In general terms, the link-sharing service model is to share the\n      aggregate\
    \ bandwidth according to some specified shares.  We can\n      extend this link-sharing\
    \ service model to a hierarchical version.\n      For instance, a link could be\
    \ divided between a number of\n      organizations, each of which would divide\
    \ the resulting allocation\n      among a number of protocols, each of which would\
    \ be divided among\n      a number of services.  Here, the sharing is defined\
    \ by a tree with\n      shares assigned to each leaf node.\n      An idealized\
    \ fluid model of instantaneous link-sharing with\n      proportional sharing of\
    \ excess is the fluid processor sharing\n      model (introduced in [DKS89] and\
    \ further explored in [Parekh92]\n      and generalized to the hierarchical case)\
    \ where at every instant\n      the available bandwidth is shared between the\
    \ active entities\n      (i.e., those having packets in the queue) in proportion\
    \ to the\n      assigned shares of the resource.  This fluid model exhibits the\n\
    \      desired policy behavior but is, of course, an unrealistic\n      idealization.\
    \  We then propose that the actual service model\n      should be to approximate,\
    \ as closely as possible, the bandwidth\n      shares produced by this ideal fluid\
    \ model.  It is not necessary to\n      require that the specific order of packet\
    \ departures match those\n      of the fluid model since we presume that all detailed\
    \ per-packet\n      delay requirements of individual flows are addressed through\n\
    \      quality of service commitments and, furthermore, the satisfaction\n   \
    \   with the link-sharing service delivered will probably not depend\n      very\
    \ sensitively on small deviations from the scheduling implied\n      by the fluid\
    \ link-sharing model.\n      We previously observed that admission control was\
    \ necessary to\n      ensure that the real-time service commitments could be met.\n\
    \      Similarly, admission control will again be necessary to ensure\n      that\
    \ the link-sharing commitments can be met.  For each entity,\n      admission\
    \ control must keep the cumulative guaranteed and\n      predictive traffic from\
    \ exceeding the assigned link-share.\n   3.3 Packet Dropping\n      So far, we\
    \ have implicitly assumed that all packets within a flow\n      were equally important.\
    \  However, in many audio and video streams,\n      some packets are more valuable\
    \ than others.  We therefore propose\n      augmenting the service model with\
    \ a \"preemptable\" packet service,\n      whereby some of the packets within\
    \ a flow could be marked as\n      preemptable.  When the network was in danger\
    \ of not meeting some\n      of its quantitative service commitments, it could\
    \ exercise a\n      certain packet's \"preemptability option\" and discard the\
    \ packet\n      (not merely delay it, since that would introduce out-of-order\n\
    \      problems).  By discarding these preemptable packets, a router can\n   \
    \   reduce the delays of the not-preempted packets.\n      Furthermore, one can\
    \ define a class of packets that is not subject\n      to admission control. \
    \ In the scenario described above where\n      preemptable packets are dropped\
    \ only when quantitative service\n      commitments are in danger of being violated,\
    \ the expectation is\n      that preemptable packets will almost always be delivered\
    \ and thus\n      they must included in the traffic description used in admission\n\
    \      control.  However, we can extend preemptability to the extreme\n      case\
    \ of \"expendable\" packets (the term expendable is used to\n      connote an\
    \ extreme degree of preemptability), where the\n      expectation is that many\
    \ of these expendable packets may not be\n      delivered.  One can then exclude\
    \ expendable packets from the\n      traffic description used in admission control;\
    \ i.e., the packets\n      are not considered part of the flow from the perspective\
    \ of\n      admission control, since there is no commitment that they will be\n\
    \      delivered.\n   3.4 Usage Feedback\n      Another important issue in the\
    \ service is the model for usage\n      feedback, also known as \"accounting\"\
    , to prevent abuse of network\n      resources.   The link-sharing service described\
    \ earlier can be\n      used to provide administratively-imposed limits on usage.\n\
    \      However, a more free-market model of network access will require\n    \
    \  back-pressure on users for the network resources they reserve.\n      This\
    \ is a highly contentious issue, and we are not prepared to say\n      more about\
    \ it at this time.\n   3.5 Reservation Model\n      The \"reservation model\"\
    \ describes how an application negotiates\n      for a QoS level.  The simplest\
    \ model is that the application asks\n      for a particular QoS and the network\
    \ either grants it or refuses.\n      Often the situation will be more complex.\
    \  Many applications will\n      be able to get acceptable service from a range\
    \ of QoS levels, or\n      more generally, from anywhere within some region of\
    \ the multi-\n      dimensional space of a flowspec.\n      For example, rather\
    \ than simply refusing the request, the network\n      might grant a lower resource\
    \ level and inform the application of\n      what QoS has been actually granted.\
    \  A more complex example is the\n      \"two-pass\" reservation model, In this\
    \ scheme, an \"offered\"\n      flowspec is propagated along the multicast distribution\
    \ tree from\n      each sender Si to all receivers Rj.  Each router along the\
    \ path\n      records these values and perhaps adjusts them to reflect available\n\
    \      capacity.  The receivers get these offers, generate corresponding\n   \
    \   \"requested\" flowspecs, and propagate them back along the same\n      routes\
    \ to the senders.  At each node, a local reconciliation must\n      be performed\
    \ between the offered and the requested flowspec to\n      create a reservation,\
    \ and an appropriately modified requested\n      flowspec is passed on.  This\
    \ two-pass scheme allows extensive\n      properties like allowed delay to be\
    \ distributed across hops in the\n      path [Tenet90, ST2-90].  Further work\
    \ is needed to define the\n      amount of generality, with a corresponding level\
    \ of complexity,\n      that is required in the reservation model.\n"
- title: 4. Traffic Control Mechanisms
  contents:
  - "4. Traffic Control Mechanisms\n   We first survey very briefly the possible traffic\
    \ control mechanisms.\n   Then in Section 4.2 we apply a subset of these mechanisms\
    \ to support\n   the various services that we have proposed.\n   4.1 Basic Functions\n\
    \      In the packet forwarding path, there is actually a very limited\n     \
    \ set of actions that a router can take.  Given a particular packet,\n      a\
    \ router must select a route for it; in addition the router can\n      either\
    \ forward it or drop it, and the router may reorder it with\n      respect to\
    \ other packets waiting to depart.  The router can also\n      hold the packet,\
    \ even though the link is idle.  These are the\n      building blocks from which\
    \ we must fashion the desired behavior.\n      4.1.1 Packet Scheduling\n     \
    \    The basic function of packet scheduling is to reorder the\n         output\
    \ queue.  There are many papers that have been written on\n         possible ways\
    \ to manage the output queue, and the resulting\n         behavior.  Perhaps the\
    \ simplest approach is a priority scheme,\n         in which packets are ordered\
    \ by priority, and highest priority\n         packets always leave first.  This\
    \ has the effect of giving some\n         packets absolute preference over others;\
    \ if there are enough of\n         the higher priority packets, the lower priority\
    \ class can be\n         completely prevented from being sent.\n         An alternative\
    \ scheduling scheme is round-robin or some\n         variant, which gives different\
    \ classes of packets access to a\n         share of the link. A variant called\
    \ Weighted Fair Queueing, or\n         WFQ, has been demonstrated to allocate\
    \ the total bandwidth of a\n         link into specified shares.\n         There\
    \ are more complex schemes for queue management, most of\n         which involve\
    \ observing the service objectives of individual\n         packets, such as delivery\
    \ deadline, and ordering packets based\n         on these criteria.\n      4.1.2\
    \ Packet Dropping\n         The controlled dropping of packets is as important\
    \ as their\n         scheduling.\n         Most obviously, a router must drop\
    \ packets when its buffers are\n         all full.  This fact, however, does not\
    \ determine which packet\n         should be dropped.  Dropping the arriving packet,\
    \ while simple,\n         may cause undesired behavior.\n         In the context\
    \ of today's Internet, with TCP operating over\n         best effort IP service,\
    \ dropping a packet is taken by TCP as a\n         signal of congestion and causes\
    \ it to reduce its load on the\n         network.  Thus, picking a packet to drop\
    \ is the same as picking\n         a source to throttle.  Without going into any\
    \ particular\n         algorithm, this simple relation suggests that some specific\n\
    \         dropping controls should be implemented in routers to improve\n    \
    \     congestion control.\n         In the context of real-time services, dropping\
    \ more directly\n         relates to achieving the desired quality of service.\
    \  If a\n         queue builds up, dropping one packet reduces the delay of all\n\
    \         the packets behind it in the queue.  The loss of one can\n         contribute\
    \ to the success of many.  The problem for the\n         implementor is to determine\
    \ when the service objective (the\n         delay bound) is in danger of being\
    \ violated.  One cannot look\n         at queue length as an indication of how\
    \ long packets have sat\n         in a queue.  If there is a priority scheme in\
    \ place, packets of\n         lower priority can be pre-empted indefinitely, so\
    \ even a short\n         queue may have very old packets in it.  While actual\
    \ time\n         stamps could be used to measure holding time, the complexity\n\
    \         may be unacceptable.\n         Some simple dropping schemes, such as\
    \ combining all the buffers\n         in a single global pool, and dropping the\
    \ arriving packet if\n         the pool is full, can defeat the service objective\
    \ of a WFQ\n         scheduling scheme.  Thus, dropping and scheduling must be\n\
    \         coordinated.\n      4.1.3 Packet Classification\n         The above\
    \ discussion of scheduling and dropping presumed that\n         the packet had\
    \ been classified into some flow or sequence of\n         packets that should\
    \ be treated in a specified way.  A\n         preliminary to this sort of processing\
    \ is the classification\n         itself.  Today a router looks at the destination\
    \ address and\n         selects a route.  The destination address is not sufficient\
    \ to\n         select the class of service a packet must receive; more\n     \
    \    information is needed.\n         One approach would be to abandon the IP\
    \ datagram model for a\n         virtual circuit model, in which a circuit is\
    \ set up with\n         specific service attributes, and the packet carries a\
    \ circuit\n         identifier.  This is the approach of ATM as well as protocols\n\
    \         such as ST-II [ST2-90].  Another model, less hostile to IP, is\n   \
    \      to allow the classifier to look at more fields in the packet,\n       \
    \  such as the source address, the protocol number and the port\n         fields.\
    \  Thus, video streams might be recognized by a\n         particular well-known\
    \ port field in the UDP header, or a\n         particular flow might be recognized\
    \ by looking at both the\n         source and destination port numbers.  It would\
    \ be possible to\n         look even deeper into the packets, for example testing\
    \ a field\n         in the application layer to select a subset of a\n       \
    \  hierarchically-encoded video stream.\n         The classifier implementation\
    \ issues are complexity and\n         processing overhead.  Current experience\
    \ suggests that careful\n         implementation of efficient algorithms can lead\
    \ to efficient\n         classification of IP packets.  This result is very important,\n\
    \         since it allows us to add QoS support to existing applications,\n  \
    \       such as Telnet, which are based on existing IP headers.\n         One\
    \ approach to reducing the overhead of classification would\n         be to provide\
    \ a \"flow-id\" field in the Internet-layer packet\n         header.  This flow-id\
    \ would be a handle that could be cached\n         and used to short-cut classification\
    \ of the packet.  There are\n         a number of variations of this concept,\
    \ and engineering is\n         required to choose the best design.\n      4.1.4\
    \ Admission Control\n         As we stated in the introduction, real-time service\
    \ depends on\n         setting up state in the router and making commitments to\n\
    \         certain classes of packets.  In order to insure that these\n       \
    \  commitments can be met, it is necessary that resources be\n         explicitly\
    \ requested, so that the request can be refused if the\n         resources are\
    \ not available.  The decision about resource\n         availability is called\
    \ admission control.\n         Admission control requires that the router understand\
    \ the\n         demands that are currently being made on its assets.  The\n  \
    \       approach traditionally proposed is to remember the service\n         parameters\
    \ of past requests, and make a computation based on\n         the worst-case bounds\
    \ on each service.  A recent proposal,\n         which is likely to provide better\
    \ link utilization, is to\n         program the router to measure the actual usage\
    \ by existing\n         packet flows, and to use this measured information as\
    \ a basis\n         of admitting new flows [JCSZ92]. This approach is subject\
    \ to\n         higher risk of overload, but may prove much more effective in\n\
    \         using bandwidth.\n         Note that while the need for admission control\
    \ is part of the\n         global service model, the details of the algorithm\
    \ run in each\n         router is a local matter.  Thus, vendors can compete by\n\
    \         developing and marketing better admission control algorithms,\n    \
    \     which lead to higher link loadings with fewer service\n         overloads.\n\
    \   4.2 Applying the Mechanisms\n      The various tools described above can be\
    \ combined to support the\n      services which were discussed in section 3.\n\
    \      o    Guaranteed delay bounds\n           A theoretical result by Parekh\
    \ [Parekh92] shows that if the\n           router implements a WFQ scheduling\
    \ discipline, and if the\n           nature of the traffic source can be characterized\
    \ (e.g. if it\n           fits within some bound such as a token bucket) then\
    \ there\n           will be an absolute upper bound on the network delay of the\n\
    \           traffic in question.  This simple and very powerful result\n     \
    \      applies not just to one switch, but to general networks of\n          \
    \ routers.  The result is a constructive one; that is, Parekh\n           displays\
    \ a source behavior which leads to the bound, and then\n           shows that\
    \ this behavior is the worst possible.  This means\n           that the bound\
    \ he computes is the best there can be, under\n           these assumptions.\n\
    \      o    Link sharing\n           The same WFQ scheme can provide controlled\
    \ link sharing.  The\n           service objective here is not to bound delay,\
    \ but to limit\n           overload shares on a link, while allowing any mix of\
    \ traffic\n           to proceed if there is spare capacity.  This use of WFQ\
    \ is\n           available in commercial routers today, and is used to\n     \
    \      segregate traffic into classes based on such things as\n           protocol\
    \ type or application.  For example, one can allocate\n           separate shares\
    \ to TCP, IPX and SNA, and one can assure that\n           network control traffic\
    \ gets a guaranteed share of the link.\n      o    Predictive real-time service\n\
    \           This service is actually more subtle than guaranteed service.\n  \
    \         Its objective is to give a delay bound which is, on the one\n      \
    \     hand, as low as possible, and on the other hand, stable\n           enough\
    \ that the receiver can estimate it.  The WFQ mechanism\n           leads to a\
    \ guaranteed bound, but not necessarily a low bound.\n           In fact, mixing\
    \ traffic into one queue, rather than\n           separating it as in WFQ, leads\
    \ to lower bounds, so long as\n           the mixed traffic is generally similar\
    \ (e.g., mixing traffic\n           from multiple video coders makes sense, mixing\
    \ video and FTP\n           does not).\n           This suggests that we need\
    \ a two-tier mechanism, in which the\n           first tier separates traffic\
    \ which has different service\n           objectives, and the second tier schedules\
    \ traffic within each\n           first tier class in order to meet its service\
    \ objective.\n   4.3 An example: The CSZ scheme\n      As a proof of concept,\
    \ a code package has been implemented which\n      realizes the services discussed\
    \ above.  It actually uses a number\n      of the basic tools, combined in a way\
    \ specific to the service\n      needs.  We describe in general terms how it works,\
    \ to suggest how\n      services can be realized.  We stress that there are other\
    \ ways of\n      building a router to meet the same service needs, and there are\
    \ in\n      fact other implementations being used today.\n      At the top level,\
    \ the CSZ code uses WFQ as an isolation mechanism\n      to separate guaranteed\
    \ flows from each other, as well as from the\n      rest of the traffic.  Guaranteed\
    \ service gets the highest priority\n      when and only when it needs the access\
    \ to meets its deadline.  WFQ\n      provides a separate guarantee for each and\
    \ every guaranteed flow.\n      Predictive service and best effort service are\
    \ separated by\n      priority.  Within the predictive service class, a further\
    \ priority\n      is used to provide sub-classes with different delay bounds.\n\
    \      Inside each predictive sub-class, simple FIFO queueing is used to\n   \
    \   mix the traffic, which seems to produce good overall delay\n      behavior.\
    \  This works because the top-tier algorithm has separated\n      out the best\
    \ effort traffic such as FTP.\n      Within the best-effort class, WFQ is used\
    \ to provide link sharing.\n      Since there is a possible requirement for nested\
    \ shares, this WFQ\n      code can be used recursively.  There are thus two different\
    \ uses\n      of WFQ in this code, one to segregate the guaranteed classes, and\n\
    \      one to segregate the link shares.  They are similar, but differ in\n  \
    \    detail.\n      Within each link share of the best effort class, priority\
    \ is used\n      to permit more time-sensitive elastic traffic to precede other\n\
    \      elastic traffic, e.g., to allow interactive traffic to precede\n      asynchronous\
    \ bulk transfers.\n      The CSZ code thus uses both WFQ and priority in an alternating\n\
    \      manner to build a mechanism to support a range of rather\n      sophisticated\
    \ service offerings.  This discussion is very brief,\n      and does not touch\
    \ on a number of significant issues, such as how\n      the CSZ code fits real\
    \ time traffic into the link sharing\n      objectives.  But the basic building\
    \ blocks are very simple, and\n      very powerful.  In particular, while priority\
    \ has been proposed as\n      a key to real-time services, WFQ may be the more\
    \ general and\n      powerful of the two schemes.  It, rather than priority, supports\n\
    \      guaranteed service and link sharing.\n"
- title: 5. Reservation Setup Protocol
  contents:
  - "5. Reservation Setup Protocol\n   There are a number of requirements to be met\
    \ by the design of a\n   reservation setuop protocol.  It should be fundamentally\
    \ designed for\n   a multicast environment, and it must accommodate heterogeneous\n\
    \   service needs.  It must give flexible control over the manner in\n   which\
    \ reservations can be shared along branches of the multicast\n   delivery trees.\
    \  It should be designed around the elementary action\n   of adding one sender\
    \ and/or receiver to an existing set, or deleting\n   one.  It must be robust\
    \ and scale well to large multicast groups.\n   Finally, it must provide for advance\
    \ reservation of resources, and\n   for the preemption that this implies.  The\
    \ reservation setup protocol\n   RSVP has been designed to meet these requirements\
    \ [RSVP93a, RSVP93b].\n   This section gives an overview of the design of RSVP.\n\
    \   5.1 RSVP Overview\n      Figure  shows multi-source, multi-destination data\
    \ delivery for a\n      particular shared, distributed application.  The arrows\
    \ indicate\n      data flow from senders S1 and S2 to receivers R1, R2, and R3,\
    \ and\n      the cloud represents the distribution mesh created by the\n     \
    \ multicast routing protocol.  Multicasting distribution replicates\n      each\
    \ data packet from a sender Si, for delivery to every receiver\n      Rj.  We\
    \ treat uncast delivery from S1 to R1 as a special case, and\n      we call this\
    \ multicast distribution mesh a session.  A session is\n      defined by the common\
    \ IP (multicast) destination address of the\n      receiver(s).\n            \
    \     Senders                              Receivers\n                       \
    \      _____________________\n                            (                  \
    \   ) ===> R1\n                    S1 ===> (    Multicast        )\n         \
    \                   (                     ) ===> R2\n                        \
    \    (    distribution     )\n                    S2 ===> (                  \
    \   )\n                            (                     ) ===> R3\n         \
    \                   (_____________________)\n                   Figure 2: Multicast\
    \ Distribution Session\n      5.1.1 Flowspecs and Filter Specs\n         In general,\
    \ an RSVP reservation request specifies the amount of\n         resources to be\
    \ reserved for all, or some subset of, the\n         packets in a particular session.\
    \  The resource quantity is\n         specified by a flowspec, while the packet\
    \ subset to receive\n         those resources is specified by a filter spec. \
    \ Assuming\n         admission control succeeds, the flowspec will be used to\n\
    \         parametrize a resource class in the packet scheduler, and the\n    \
    \     filter spec will be instantiated in the packet classifier to\n         map\
    \ the appropriate packets into this class.  The subset of the\n         classifier\
    \ state that selects a particular class is referred to\n         in RSVP documentation\
    \ as a (packet) \"filter\".\n         The RSVP protocol mechanisms provide a very\
    \ general facility\n         for creating and maintaining distributed reservation\
    \ state\n         across the mesh of multicast delivery paths.  These mechanisms\n\
    \         treat flowspecs and filter specs as mostly opaque binary data,\n   \
    \      handing them to the local traffic control machinery for\n         interpretation.\
    \  Of course, the service model presented to an\n         application must specify\
    \ how to encode flowspecs and filter\n         specs.\n      5.1.2 Reservation\
    \ Styles\n         RSVP offers several different reservation \"styles\", which\n\
    \         determine the manner in which the resource requirements of\n       \
    \  multiple receivers are aggregated in the routers.  These styles\n         allow\
    \ the reserved resources to more efficiently meet\n         application requirements.\
    \  Currently there are three\n         reservation styles, \"wildcard\", \"fixed-filter\"\
    , and \" dynamic-\n         filter\".  A wildcard reservation uses a filter spec\
    \ that is not\n         source-specific, so all packets destined for the associated\n\
    \         destination (session) may use a common pool of reserved\n         resources.\
    \  This allows a single resource allocation to be made\n         across all distribution\
    \ paths for the group.  The wildcard\n         reservation style is useful in\
    \ support of an audio conference,\n         where at most a small number of sources\
    \ are active\n         simultaneously and may share the resource allocation.\n\
    \         The other two styles use filter specs that select particular\n     \
    \    sources.  A receiver may desire to receive from a fixed set of\n        \
    \ sources, or instead it may desire the network to switch between\n         different\
    \ source, by changing its filter spec(s) dymamically.\n         A fixed-filter\
    \ style reservation cannot be changed during its\n         lifetime without re-invoking\
    \ admission control.  Dynamic-filter\n         reservations do allow a receiver\
    \ to modify its choice of\n         source(s) over time without additional admission\
    \ control;\n         however, this requires that sufficient resources be allocated\n\
    \         to handle the worst case when all downstream receivers take\n      \
    \   input from different sources.\n      5.1.3 Receiver Initiation\n         An\
    \ important design question is whether senders or receivers\n         should have\
    \ responsibility for initiating reservations.  A\n         sender knows the qualities\
    \ of the traffic stream it can send,\n         while a receiver knows what it\
    \ wants to (or can) receive.\n         Perhaps the most obvious choice is to let\
    \ the sender initiate\n         the reservation.  However, this scales poorly\
    \ for large,\n         dynamic multicast delivery trees and for heterogeneous\n\
    \         receivers.\n         Both of these scaling problems are solved by making\
    \ the\n         receiver responsible for initiating a reservation.  Receiver\n\
    \         initiation  handles heterogeneous receivers easily; each\n         receiver\
    \ simply asks for a reservation appropriate to itself,\n         and any differences\
    \ among reservations from different receivers\n         are resolved (\"merged\"\
    ) within the network by RSVP.  Receiver\n         initiation is also consisent\
    \ with IP multicast, in which a\n         multicast group is created implicitly\
    \ by receivers joining it.\n         Although receiver-initiated reservation is\
    \ the natural choice\n         for multicast sessions, the justification for receiver\n\
    \         initiateion may appear weaker for unicast sessions, where the\n    \
    \     sender may be the logical session initiator.  However, we\n         expect\
    \ that every realtime application will have its higher-\n         level signalling\
    \ and control protocol, and this protocol can be\n         used to signal the\
    \ receiver to initiate a reservation (and\n         perhaps indicate the flowspec\
    \ to be used).  For simplicity and\n         economy, a setup protocol should\
    \ support only one direction of\n         initiation, and, and receiver initiation\
    \ appears to us to be\n         the clear winner.\n         RSVP uses receiver-initiation\
    \ of rservations [RSVP93b].  A\n         receiver is assumed to learn the senders'\
    \ offered flowspecs by\n         a higher-level mechanism (\"out of band\"), it\
    \ then generates its\n         own desired flowspec and propagates it towards\
    \ the senders,\n         making reservations in each router along the way.\n \
    \     5.1.4 Soft State\n         There are two different possible styles for reservation\
    \ setup\n         protocols, the \"hard state\" (HS) approach (also called\n \
    \        \"connection-oriented\"), and the \"soft state\" (SS) approach\n    \
    \     (also called \"connectionless\").  In both approaches, multicast\n     \
    \    distribution is performed using flow-specific state in each\n         router\
    \ along the path.  Under the HS approach, this state is\n         created and\
    \ deleted in a fully deterministic manner by\n         cooperation among the routers.\
    \  Once a host requests a session,\n         the \"network\" takes responsibility\
    \ for creating and later\n         destroying the necessary state.  ST-II is an\
    \ example of the HS\n         approach [ST2-90].  Since management of HS session\
    \ state is\n         completely deterministic, the HS setup protocol must be\n\
    \         reliable, with acknowledgments and retransmissions.  In order\n    \
    \     to achieve deterministic cleanup of state after a failure,\n         there\
    \ must be some mechanism to detect failures, i.e., an\n         \"up/down\" protocol.\
    \  The router upstream (towards the source)\n         from a failure takes responsibility\
    \ for rebuilding the\n         necessary state on the router(s) along an alternate\
    \ route.\n         RSVP takes the SS approach, which regards the reservation state\n\
    \         as cached information that is installed and periodically\n         refreshed\
    \ by the end hosts.  Unused state is timed out by the\n         routers.  If the\
    \ route changes, the refresh messages\n         automatically install the necessary\
    \ state along the new route.\n         The SS approach was chosen to obtain the\
    \ simplicity and\n         robustness that have been demonstrated by connectionless\n\
    \         protocols such as IP [Clark88].\n   5.2 Routing and Reservations\n \
    \     There is a fundamental interaction between resource reservation\n      set\
    \ up and routing, since reservation requires the installation of\n      flow state\
    \ along the route of data packets.  If and when a route\n      changes, there\
    \ must be some mechanism to set up a reservation\n      along the new route.\n\
    \      Some have suggested that reservation setup necessarily requires\n     \
    \ route set up, i.e., the imposition of a virtual-circuit internet\n      layer.\
    \  However, our goal is to simply extend the Internet\n      architecture, not\
    \ replace it.  The fundamental connectionless\n      internet layer [Clark88]\
    \ has been highly successful, and we wish\n      to retain it as an architectural\
    \ foundation.  We propose instead\n      to modify somewhat the pure datagram\
    \ forwarding mechanism of the\n      present Internet to accomodate \"IS\".\n\
    \      There are four routing issues faced by a reservation setup\n      protocol\
    \ such as RSVP.\n      1.   Find a route that supports resource reservation.\n\
    \           This is simply \"type-of-service\" routing, a facility that is\n \
    \          already available in some modern routing protocols.\n      2.   Find\
    \ a route that has sufficient unreserved capacity for a\n           new flow.\n\
    \           Early experiments on the ARPANET showed that it is difficult\n   \
    \        to do load-dependent dynamic routing on a packet-by-packet\n        \
    \   basis without instability problems.  However, instability\n           should\
    \ not be a problem if load-dependent routing is\n           performed only at\
    \ reservation setup time.\n           Two different approaches might be taken\
    \ to finding a route\n           with enough capacity.  One could modify the routing\n\
    \           protocol(s) and interface them to the traffic control\n          \
    \ mechanism, so the route computation can consider the average\n           recent\
    \ load.  Alternatively, the routing protocol could be\n           (re-)designed\
    \ to provide multiple alternative routes, and\n           reservation setup could\
    \ be attempted along each in turn.\n      3.   Adapt to a route failure\n    \
    \       When some node or link fails, adaptive routing finds an\n           alternate\
    \ path.  The periodic refresh messages of RSVP will\n           automatically\
    \ request a reservation along the new path.  Of\n           course, this reservation\
    \ may fail because there is\n           insufficienct available capacity on the\
    \ new path.  This is a\n           problem of provisioning and network engineering,\
    \ which cannot\n           be solved by the routing or setup protocols.\n    \
    \       There is a problem of timeliness of establishing reservation\n       \
    \    state on the new path.  The end-to-end robustness mechanism\n           of\
    \ refreshes is limited in frequency by overhead, which may\n           cause a\
    \ gap in realtime service when an old route breaks and\n           a new one is\
    \ chosen.  It should be possible to engineer RSVP\n           to sypplement the\
    \ global refresh mechanism with a local\n           repair mechanism, using hints\
    \ about route changes from the\n           routing mechanism.\n      4.   Adapt\
    \ to a route change (without failure)\n           Route changes may occur even\
    \ without failure in the affected\n           path.  Although RSVP could use the\
    \ same repair techniques as\n           those described in (3), this case raises\
    \ a problem with the\n           robustness of the QoS guarantees.  If it should\
    \ happen that\n           admission control fails on the new route, the user will\
    \ see\n           service degradation unnecessarily and capriciously, since the\n\
    \           orginal route is still functional.\n           To avoid this problem,\
    \ a mechanism called \"route pinning\" has\n           been suggested.  This would\
    \ modify the routing protocol\n           implementation and the interface to\
    \ the classifier, so that\n           routes associated with resource reservations\
    \ would be\n           \"pinned\".  The routing prootocol would not change a pinned\n\
    \           route if it was still viable.\n      It may eventually be possible\
    \ to fold together the routing and\n      reservation setup problems, but we do\
    \ not yet understand enough to\n      do that.  Furthermore, the reservation protocol\
    \ needs to coexist\n      with a number of different routing protocols in use\
    \ in the\n      Internet.  Therefore, RSVP is currently designed to work with\
    \ any\n      current-generation routing protocol without modification.  This is\n\
    \      a short-term compromise, which may result in an occasional failure\n  \
    \    to create the best, or even any, real-time session, or an\n      occasional\
    \ service degradation due to a route change.  We expect\n      that future generations\
    \ of routing protocols will remove this\n      compromise, by including hooks\
    \ and mechanisms that, in conjunction\n      with RSVP, will solve the problems\
    \ (1) through (4) just listed.\n      They will support route pinning, notification\
    \ of RSVP to trigger\n      local repair, and selection of routes with \"IS\"\
    \ support and\n      adequate capacity.\n      The last routing-related issue\
    \ is provided by mobile hosts.  Our\n      conjecture is that mobility is not\
    \ essentially different from\n      other route changes, so that the mechanism\
    \ suggested in (3) and\n      (4) will suffice.  More study and experimentation\
    \ is needed to\n      prove or disprove this conjecture.\n"
- title: 6. ACKNOWLEDGMENTS
  contents:
  - "6. ACKNOWLEDGMENTS\n   Many Internet researchers have contributed to the work\
    \ described in\n   this memo.  We want to especially acknowledge, Steve Casner,\
    \ Steve\n   Deering, Deborah Estrin, Sally Floyd, Shai Herzog, Van Jacobson,\n\
    \   Sugih Jamin, Craig Partridge, John Wroclawski, and Lixia Zhang.  This\n  \
    \ approach to Internet integrated services was initially discussed and\n   organized\
    \ in the End-to-End Research Group of the Internet Research\n   Taskforce, and\
    \ we are grateful to all members of that group for their\n   interesting (and\
    \ sometimes heated) discussions.\n"
- title: REFERENCES
  contents:
  - 'REFERENCES

    '
- title: '[CerfKahn74]  Cerf, V., and R. Kahn, "A Protocol for Packet Network'
  contents:
  - "[CerfKahn74]  Cerf, V., and R. Kahn, \"A Protocol for Packet Network\n    Intercommunication\"\
    , IEEE Trans on Comm., Vol. Com-22, No. 5, May\n    1974.\n"
- title: '[Clark88]  Clark, D., "The Design Philosophy of the DARPA Internet'
  contents:
  - "[Clark88]  Clark, D., \"The Design Philosophy of the DARPA Internet\n    Protocols\"\
    , ACM SIGCOMM '88, August 1988.\n"
- title: '[CSZ92]  Clark, D., Shenker, S., and L. Zhang, "Supporting Real-Time'
  contents:
  - "[CSZ92]  Clark, D., Shenker, S., and L. Zhang, \"Supporting Real-Time\n    Applications\
    \ in an Integrated Services Packet Network: Architecture\n    and Mechanisms\"\
    , Proc. SIGCOMM '92, Baltimore, MD, August 1992.\n"
- title: '[DKS89]  Demers, A., Keshav, S., and S. Shenker.  "Analysis and'
  contents:
  - "[DKS89]  Demers, A., Keshav, S., and S. Shenker.  \"Analysis and\n    Simulation\
    \ of a Fair Queueing Algorithm\", Journal of\n    Internetworking: Research and\
    \ Experience, 1, pp. 3-26, 1990.  Also\n    in Proc. ACM SIGCOMM '89, pp 3-12.\n"
- title: '[SCZ93a]  Shenker, S., Clark, D., and L. Zhang, "A Scheduling Service'
  contents:
  - "[SCZ93a]  Shenker, S., Clark, D., and L. Zhang, \"A Scheduling Service\n    Model\
    \ and a Scheduling Architecture for an Integrated Services\n    Packet Network\"\
    , submitted to ACM/IEEE Trans. on Networking.\n"
- title: '[SCZ93b]  Shenker, S., Clark, D., and L. Zhang, "A Service Model for the'
  contents:
  - "[SCZ93b]  Shenker, S., Clark, D., and L. Zhang, \"A Service Model for the\n \
    \   Integrated Services Internet\", Work in Progress, October 1993.\n"
- title: '[Floyd92]  Floyd, S., "Issues in Flexible Resource Management for'
  contents:
  - "[Floyd92]  Floyd, S., \"Issues in Flexible Resource Management for\n    Datagram\
    \ Networks\", Proceedings of the 3rd Workshop on Very High\n    Speed Networks,\
    \ March 1992.\n"
- title: '[Jacobson91]  Jacobson, V., "Private Communication", 1991.'
  contents:
  - '[Jacobson91]  Jacobson, V., "Private Communication", 1991.

    '
- title: '[JCSZ92]  Jamin, S., Shenker, S., Zhang, L., and D. Clark, "An Admission'
  contents:
  - "[JCSZ92]  Jamin, S., Shenker, S., Zhang, L., and D. Clark, \"An Admission\n \
    \   Control Algorithm for Predictive Real-Time Service\", Extended\n    abstract,\
    \ in Proc. Third International Workshop on Network and\n    Operating System Support\
    \ for Digital Audio and Video, San Diego, CA,\n    Nov. 1992, pp.  73-91.\n"
- title: '[Parekh92]  Parekh, A., "A Generalized Processor Sharing Approach to'
  contents:
  - "[Parekh92]  Parekh, A., \"A Generalized Processor Sharing Approach to\n    Flow\
    \ Control in Integrated Services Networks\", Technical Report\n    LIDS-TR-2089,\
    \ Laboratory for Information and Decision Systems,\n    Massachusetts Institute\
    \ of Technology, 1992.\n"
- title: '[Partridge92]  Partridge, C., "A Proposed Flow Specification", RFC 1363,'
  contents:
  - "[Partridge92]  Partridge, C., \"A Proposed Flow Specification\", RFC 1363,\n\
    \    BBN, July 1992.\n"
- title: '[RSVP93a]  Zhang, L., Deering, S., Estrin, D., Shenker, S., and D.'
  contents:
  - "[RSVP93a]  Zhang, L., Deering, S., Estrin, D., Shenker, S., and D.\n    Zappala,\
    \ \"RSVP: A New Resource ReSerVation Protocol\", Accepted for\n    publication\
    \ in IEEE Network, 1993.\n"
- title: '[RSVP93b]  Zhang, L., Braden, R., Estrin, D., Herzog, S., and S. Jamin,'
  contents:
  - "[RSVP93b]  Zhang, L., Braden, R., Estrin, D., Herzog, S., and S. Jamin,\n   \
    \ \"Resource ReSerVation Protocol (RSVP) - Version 1 Functional\n    Specification\"\
    , Work in Progress, 1993.\n"
- title: '[ST2-90]  Topolcic, C., "Experimental Internet Stream Protocol: Version'
  contents:
  - "[ST2-90]  Topolcic, C., \"Experimental Internet Stream Protocol: Version\n  \
    \  2 (ST-II)\", RFC 1190, BBN, October 1990.\n"
- title: '[Tenet90]  Ferrari, D., and D. Verma, "A Scheme for Real-Time Channel'
  contents:
  - "[Tenet90]  Ferrari, D., and D. Verma, \"A Scheme for Real-Time Channel\n    Establishment\
    \ in Wide-Area Networks\", IEEE JSAC, Vol. 8, No. 3, pp\n    368-379, April 1990.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   As noted in Section 2.1, the ability to reserve resources\
    \ will create\n   a requirement for authentication, both of users requesting resource\n\
    \   guarantees and of packets that claim to have the right to use those\n   guarantees.\
    \  These authentication issues are not otherwise addressed\n   in this memo, but\
    \ are for further study.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Bob Braden\n   USC Information Sciences Institute\n  \
    \ 4676 Admiralty Way\n   Marina del Rey, CA 90292\n   Phone: (310) 822-1511\n\
    \   EMail: Braden@ISI.EDU\n   David Clark\n   MIT Laboratory for Computer Science\n\
    \   545 Technology Square\n   Cambridge, MA 02139-1986\n   Phone: (617) 253-6003\n\
    \   EMail: ddc@LCS.MIT.EDU\n   Scott Shenker\n   Xerox Palo Alto Research Center\n\
    \   3333 Coyote Hill Road\n   Palo Alto, CA 94304\n   Phone: (415) 812-4840\n\
    \   EMail: Shenker@PARC.XEROX.COM\n"
