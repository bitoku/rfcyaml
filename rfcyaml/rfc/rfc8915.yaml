- contents:
  - '          Network Time Security for the Network Time Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This memo specifies Network Time Security (NTS), a mechanism for\n
    \  using Transport Layer Security (TLS) and Authenticated Encryption\n   with
    Associated Data (AEAD) to provide cryptographic security for the\n   client-server
    mode of the Network Time Protocol (NTP).\n   NTS is structured as a suite of two
    loosely coupled sub-protocols.\n   The first (NTS Key Establishment (NTS-KE))
    handles initial\n   authentication and key establishment over TLS.  The second
    (NTS\n   Extension Fields for NTPv4) handles encryption and authentication\n   during
    NTP time synchronization via extension fields in the NTP\n   packets, and holds
    all required state only on the client via opaque\n   cookies.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8915.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Objectives\n     1.2.  Terms
    and Abbreviations\n     1.3.  Protocol Overview\n   2.  Requirements Language\n
    \  3.  TLS Profile for Network Time Security\n   4.  The NTS Key Establishment
    Protocol\n     4.1.  NTS-KE Record Types\n       4.1.1.  End of Message\n       4.1.2.
    \ NTS Next Protocol Negotiation\n       4.1.3.  Error\n       4.1.4.  Warning\n
    \      4.1.5.  AEAD Algorithm Negotiation\n       4.1.6.  New Cookie for NTPv4\n
    \      4.1.7.  NTPv4 Server Negotiation\n       4.1.8.  NTPv4 Port Negotiation\n
    \    4.2.  Retry Intervals\n     4.3.  Key Extraction (Generally)\n   5.  NTS
    Extension Fields for NTPv4\n     5.1.  Key Extraction (for NTPv4)\n     5.2.  Packet
    Structure Overview\n     5.3.  The Unique Identifier Extension Field\n     5.4.
    \ The NTS Cookie Extension Field\n     5.5.  The NTS Cookie Placeholder Extension
    Field\n     5.6.  The NTS Authenticator and Encrypted Extension Fields\n           Extension
    Field\n     5.7.  Protocol Details\n   6.  Suggested Format for NTS Cookies\n
    \  7.  IANA Considerations\n     7.1.  Service Name and Transport Protocol Port
    Number Registry\n     7.2.  TLS Application-Layer Protocol Negotiation (ALPN)
    Protocol\n           IDs Registry\n     7.3.  TLS Exporter Labels Registry\n     7.4.
    \ NTP Kiss-o'-Death Codes Registry\n     7.5.  NTP Extension Field Types Registry\n
    \    7.6.  Network Time Security Key Establishment Record Types\n           Registry\n
    \    7.7.  Network Time Security Next Protocols Registry\n     7.8.  Network Time
    Security Error and Warning Codes Registries\n   8.  Security Considerations\n
    \    8.1.  Protected Modes\n     8.2.  Cookie Encryption Key Compromise\n     8.3.
    \ Sensitivity to DDoS Attacks\n     8.4.  Avoiding DDoS Amplification\n     8.5.
    \ Initial Verification of Server Certificates\n     8.6.  Delay Attacks\n     8.7.
    \ NTS Stripping\n   9.  Privacy Considerations\n     9.1.  Unlinkability\n     9.2.
    \ Confidentiality\n   10. References\n     10.1.  Normative References\n     10.2.
    \ Informative References\n   Acknowledgments\n   Authors' Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo specifies Network Time Security (NTS), a cryptographic\n
    \  security mechanism for network time synchronization.  A complete\n   specification
    is provided for application of NTS to the client-server\n   mode of the Network
    Time Protocol (NTP) [RFC5905].\n"
  - contents:
    - "1.1.  Objectives\n   The objectives of NTS are as follows:\n   *  Identity:
      Through the use of a X.509 public key infrastructure,\n      implementations
      can cryptographically establish the identity of\n      the parties they are
      communicating with.\n   *  Authentication: Implementations can cryptographically
      verify that\n      any time synchronization packets are authentic, i.e., that
      they\n      were produced by an identified party and have not been modified
      in\n      transit.\n   *  Confidentiality: Although basic time synchronization
      data is\n      considered nonconfidential and sent in the clear, NTS includes\n
      \     support for encrypting NTP extension fields.\n   *  Replay prevention:
      Client implementations can detect when a\n      received time synchronization
      packet is a replay of a previous\n      packet.\n   *  Request-response consistency:
      Client implementations can verify\n      that a time synchronization packet
      received from a server was sent\n      in response to a particular request from
      the client.\n   *  Unlinkability: For mobile clients, NTS will not leak any\n
      \     information additional to NTP which would permit a passive\n      adversary
      to determine that two packets sent over different\n      networks came from
      the same client.\n   *  Non-amplification: Implementations (especially server\n
      \     implementations) can avoid acting as distributed denial-of-service\n      (DDoS)
      amplifiers by never responding to a request with a packet\n      larger than
      the request packet.\n   *  Scalability: Server implementations can serve large
      numbers of\n      clients without having to retain any client-specific state.\n
      \  *  Performance: NTS must not significantly degrade the quality of the\n      time
      transfer.  The encryption and authentication used when\n      actually transferring
      time should be lightweight (see Section 5.7\n      of RFC 7384 [RFC7384]).\n"
    title: 1.1.  Objectives
  - contents:
    - "1.2.  Terms and Abbreviations\n   AEAD       Authenticated Encryption with
      Associated Data [RFC5116]\n   ALPN       Application-Layer Protocol Negotiation
      [RFC7301]\n   C2S        Client-to-server\n   DoS        Denial-of-Service\n
      \  DDoS       Distributed Denial-of-Service\n   EF         Extension Field [RFC5905]\n
      \  HKDF       Hashed Message Authentication Code-based Key Derivation\n              Function
      [RFC5869]\n   KoD        Kiss-o'-Death [RFC5905]\n   NTP        Network Time
      Protocol [RFC5905]\n   NTS        Network Time Security\n   NTS NAK    NTS negative-acknowledgment\n
      \  NTS-KE     Network Time Security Key Establishment\n   S2C        Server-to-client\n
      \  TLS        Transport Layer Security [RFC8446]\n"
    title: 1.2.  Terms and Abbreviations
  - contents:
    - "1.3.  Protocol Overview\n   The Network Time Protocol includes many different
      operating modes to\n   support various network topologies (see Section 3 of
      RFC 5905\n   [RFC5905]).  In addition to its best-known and most-widely-used\n
      \  client-server mode, it also includes modes for synchronization\n   between
      symmetric peers, a control mode for server monitoring and\n   administration,
      and a broadcast mode.  These various modes have\n   differing and partly contradictory
      requirements for security and\n   performance.  Symmetric and control modes
      demand mutual\n   authentication and mutual replay protection.  Additionally,
      for\n   certain message types, the control mode may require confidentiality\n
      \  as well as authentication.  Client-server mode places more stringent\n   requirements
      on resource utilization than other modes because servers\n   may have a vast
      number of clients and be unable to afford to maintain\n   per-client state.
      \ However, client-server mode also has more relaxed\n   security needs because
      only the client requires replay protection: it\n   is harmless for stateless
      servers to process replayed packets.  The\n   security demands of symmetric
      and control modes, on the other hand,\n   are in conflict with the resource-utilization
      demands of client-\n   server mode: any scheme that provides replay protection
      inherently\n   involves maintaining some state to keep track of which messages
      have\n   already been seen.\n   This memo specifies NTS exclusively for the
      client-server mode of\n   NTP.  To this end, NTS is structured as a suite of
      two protocols:\n      The \"NTS Extension Fields for NTPv4\" define a collection
      of NTP\n      extension fields for cryptographically securing NTPv4 using\n
      \     previously established key material.  They are suitable for\n      securing
      client-server mode because the server can implement them\n      without retaining
      per-client state.  All state is kept by the\n      client and provided to the
      server in the form of an encrypted\n      cookie supplied with each request.
      \ On the other hand, the NTS\n      Extension Fields are suitable _only_ for
      client-server mode\n      because only the client, and not the server, is protected
      from\n      replay.\n      The \"NTS Key Establishment\" protocol (NTS-KE) is
      a mechanism for\n      establishing key material for use with the NTS Extension
      Fields\n      for NTPv4.  It uses TLS to establish keys, to provide the client\n
      \     with an initial supply of cookies, and to negotiate some\n      additional
      protocol options.  After this, the TLS channel is\n      closed with no per-client
      state remaining on the server side.\n   The typical protocol flow is as follows:
      The client connects to an\n   NTS-KE server on the NTS TCP port and the two
      parties perform a TLS\n   handshake.  Via the TLS channel, the parties negotiate
      some\n   additional protocol parameters, and the server sends the client a\n
      \  supply of cookies along with an address and port of an NTP server for\n   which
      the cookies are valid.  The parties use TLS key export\n   [RFC5705] to extract
      key material, which will be used in the next\n   phase of the protocol.  This
      negotiation takes only a single round\n   trip, after which the server closes
      the connection and discards all\n   associated state.  At this point, the NTS-KE
      phase of the protocol is\n   complete.  Ideally, the client never needs to connect
      to the NTS-KE\n   server again.\n   Time synchronization proceeds with the indicated
      NTP server.  The\n   client sends the server an NTP client packet that includes
      several\n   extension fields.  Included among these fields are a cookie\n   (previously
      provided by the key establishment server) and an\n   authentication tag, computed
      using key material extracted from the\n   NTS-KE handshake.  The NTP server
      uses the cookie to recover this key\n   material and send back an authenticated
      response.  The response\n   includes a fresh, encrypted cookie that the client
      then sends back in\n   the clear in a subsequent request.  This constant refreshing
      of\n   cookies is necessary in order to achieve NTS's unlinkability goal.\n
      \  Figure 1 provides an overview of the high-level interaction between\n   the
      client, the NTS-KE server, and the NTP server.  Note that the\n   cookies' data
      format and the exchange of secrets between NTS-KE and\n   NTP servers are not
      part of this specification and are implementation\n   dependent.  However, a
      suggested format for NTS cookies is provided\n   in Section 6.\n                              Shared
      cookie         |   +--------------+\n   +---------------+      encryption parameters
      \    |   +--------------+\n   |               |    (Implementation dependent)
      \ |   |              |\n   | NTS-KE Server | <------------------------------+->
      | NTP Server 2 |\n          | 1. Negotiate parameters,                |          .\n
      \         |    receive initial cookie               |   +--------------+\n          |
      \   supply, generate AEAD keys,          |   |              |\n          |    and
      receive NTP server IP            +-> | NTP Server N |\n          |    addresses
      using \"NTS Key                 |              |\n          |    Establishment\"
      protocol.                 +--------------+\n          +-----------> |  Client
      \ | <-------------------------+\n            Figure 1: Overview of High-Level
      Interactions in NTS\n"
    title: 1.3.  Protocol Overview
  title: 1.  Introduction
- contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
    RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
    in all\n   capitals, as shown here.\n"
  title: 2.  Requirements Language
- contents:
  - "3.  TLS Profile for Network Time Security\n   Network Time Security makes use
    of TLS for NTS key establishment.\n   Since the NTS protocol is new as of this
    publication, no backward-\n   compatibility concerns exist to justify using obsolete,
    insecure, or\n   otherwise broken TLS features or versions.  Implementations MUST\n
    \  conform with RFC 7525 [RFC7525] or with a later revision of BCP 195.\n   Implementations
    MUST NOT negotiate TLS versions earlier than 1.3\n   [RFC8446] and MAY refuse
    to negotiate any TLS version that has been\n   superseded by a later supported
    version.\n   Use of the Application-Layer Protocol Negotiation Extension [RFC7301]\n
    \  is integral to NTS, and support for it is REQUIRED for\n   interoperability.\n
    \  Implementations MUST follow the rules in RFC 5280 [RFC5280] and RFC\n   6125
    [RFC6125] for the representation and verification of the\n   application's service
    identity.  When NTS-KE service discovery (out\n   of scope for this document)
    produces one or more host names, use of\n   the DNS-ID identifier type [RFC6125]
    is RECOMMENDED; specifications\n   for service discovery mechanisms can provide
    additional guidance for\n   certificate validation based on the results of discovery.\n
    \  Section 8.5 of this memo discusses particular considerations for\n   certificate
    verification in the context of NTS.\n"
  title: 3.  TLS Profile for Network Time Security
- contents:
  - "4.  The NTS Key Establishment Protocol\n   The NTS key establishment protocol
    is conducted via TCP port 4460.\n   The two endpoints carry out a TLS handshake
    in conformance with\n   Section 3, with the client offering (via an ALPN extension\n
    \  [RFC7301]), and the server accepting, an application-layer protocol\n   of
    \"ntske/1\".  Immediately following a successful handshake, the\n   client SHALL
    send a single request as Application Data encapsulated\n   in the TLS-protected
    channel.  Then, the server SHALL send a single\n   response.  After sending their
    respective request and response, the\n   client and server SHALL send TLS \"close_notify\"
    alerts in accordance\n   with Section 6.1 of RFC 8446 [RFC8446].\n   The client's
    request and the server's response each SHALL consist of\n   a sequence of records
    formatted according to Figure 2.  The request\n   and a non-error response each
    SHALL include exactly one NTS Next\n   Protocol Negotiation record.  The sequence
    SHALL be terminated by a\n   \"End of Message\" record.  The requirement that
    all NTS-KE messages be\n   terminated by an End of Message record makes them self-delimiting.\n
    \  Clients and servers MAY enforce length limits on requests and\n   responses;
    however, servers MUST accept requests of at least 1024\n   octets, and clients
    SHOULD accept responses of at least 65536 octets.\n    0                   1                   2
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    6 7 8 9 0 1\n   |C|         Record Type         |          Body Length          |\n
    \  .                           Record Body                         .\n                       Figure
    2: NTS-KE Record Format\n   The fields of an NTS-KE record are defined as follows:\n
    \  C (Critical Bit):  Determines the disposition of unrecognized Record\n      Types.
    \ Implementations which receive a record with an\n      unrecognized Record Type
    MUST ignore the record if the Critical\n      Bit is 0 and MUST treat it as an
    error if the Critical Bit is 1\n      (see Section 4.1.3).\n   Record Type Number:
    \ A 15-bit integer in network byte order.  The\n      semantics of Record Types
    0-7 are specified in this memo.\n      Additional type numbers SHALL be tracked
    through the IANA \"Network\n      Time Security Key Establishment Record Types\"
    registry.\n   Body Length:  The length of the Record Body field, in octets, as
    a\n      16-bit integer in network byte order.  Record bodies MAY have any\n      representable
    length and need not be aligned to a word boundary.\n   Record Body:  The syntax
    and semantics of this field SHALL be\n      determined by the Record Type.\n   For
    clarity regarding bit-endianness: the Critical Bit is the most\n   significant
    bit of the first octet.  In the C programming language,\n   given a network buffer
    'unsigned char b[]' containing an NTS-KE\n   record, the critical bit is 'b[0]
    >> 7' while the record type is\n   '((b[0] & 0x7f) << 8) + b[1]'.\n   Note that,
    although the Type-Length-Body format of an NTS-KE record\n   is similar to that
    of an NTP extension field, the semantics of the\n   length field differ.  While
    the length subfield of an NTP extension\n   field gives the length of the entire
    extension field including the\n   type and length subfields, the length field
    of an NTS-KE record gives\n   just the length of the body.\n   Figure 3 provides
    a schematic overview of the key establishment.  It\n   displays the protocol steps
    to be performed by the NTS client and\n   server and Record Types to be exchanged.\n
    \                  | - Verify client request message.      |\n                   |
    - Extract TLS key material.           |\n                   | - Generate KE response
    message.       |\n                   |   - Include Record Types:             |\n
    \                  |       o NTS Next Protocol Negotiation |\n                   |
    \      o AEAD Algorithm Negotiation    |\n                   |       o <NTPv4
    Server Negotiation>    |\n                   |       o <NTPv4 Port Negotiation>
    \     |\n                   |       o New Cookie for NTPv4          |\n                   |
    \      o <New Cookie for NTPv4>        |\n                   |       o End of
    Message                |\n   Server -----------+---------------+-----+----------------------->\n
    \                  /    TLS application       \\\n                  /     data
    \                  \\\n   Client -----+---------------------------------+----------------->\n
    \  |- Generate KE request message.    |   |- Verify server response|\n   | - Include
    Record Types:          |   |  message.              |\n   |  o NTS Next Protocol
    Negotiation |   |- Extract cookie(s).    |\n   |  o AEAD Algorithm Negotiation
    \   |   +------------------------+\n   |  o <NTPv4 Server Negotiation>    |\n
    \  |  o <NTPv4 Port Negotiation>      |\n   |  o End of Message                |\n
    \                 Figure 3: NTS Key Establishment Messages\n"
  - contents:
    - "4.1.  NTS-KE Record Types\n   The following NTS-KE Record Types are defined:\n"
    - contents:
      - "4.1.1.  End of Message\n   The End of Message record has a Record Type number
        of 0 and a zero-\n   length body.  It MUST occur exactly once as the final
        record of every\n   NTS-KE request and response.  The Critical Bit MUST be
        set.\n"
      title: 4.1.1.  End of Message
    - contents:
      - "4.1.2.  NTS Next Protocol Negotiation\n   The NTS Next Protocol Negotiation
        record has a Record Type number of\n   1.  It MUST occur exactly once in every
        NTS-KE request and response.\n   Its body consists of a sequence of 16-bit
        unsigned integers in\n   network byte order.  Each integer represents a Protocol
        ID from the\n   IANA \"Network Time Security Next Protocols\" registry (Section
        7.7).\n   The Critical Bit MUST be set.\n   The Protocol IDs listed in the
        client's NTS Next Protocol Negotiation\n   record denote those protocols that
        the client wishes to speak using\n   the key material established through
        this NTS-KE session.  Protocol\n   IDs listed in the NTS-KE server's response
        MUST comprise a subset of\n   those listed in the request and denote those
        protocols that the NTP\n   server is willing and able to speak using the key
        material\n   established through this NTS-KE session.  The client MAY proceed
        with\n   one or more of them.  The request MUST list at least one protocol,\n
        \  but the response MAY be empty.\n"
      title: 4.1.2.  NTS Next Protocol Negotiation
    - contents:
      - "4.1.3.  Error\n   The Error record has a Record Type number of 2.  Its body
        is exactly\n   two octets long, consisting of an unsigned 16-bit integer in
        network\n   byte order, denoting an error code.  The Critical Bit MUST be
        set.\n   Clients MUST NOT include Error records in their request.  If clients\n
        \  receive a server response that includes an Error record, they MUST\n   discard
        any key material negotiated during the initial TLS exchange\n   and MUST NOT
        proceed to the Next Protocol.  Requirements for retry\n   intervals are described
        in Section 4.2.\n   The following error codes are defined:\n      Error code
        0 means \"Unrecognized Critical Record\".  The server\n      MUST respond
        with this error code if the request included a record\n      that the server
        did not understand and that had its Critical Bit\n      set.  The client SHOULD
        NOT retry its request without\n      modification.\n      Error code 1 means
        \"Bad Request\".  The server MUST respond with\n      this error if the request
        is not complete and syntactically well-\n      formed, or, upon the expiration
        of an implementation-defined\n      timeout, it has not yet received such
        a request.  The client\n      SHOULD NOT retry its request without modification.\n
        \     Error code 2 means \"Internal Server Error\".  The server MUST\n      respond
        with this error if it is unable to respond properly due to\n      an internal
        condition.  The client MAY retry its request.\n"
      title: 4.1.3.  Error
    - contents:
      - "4.1.4.  Warning\n   The Warning record has a Record Type number of 3.  Its
        body is\n   exactly two octets long, consisting of an unsigned 16-bit integer
        in\n   network byte order, denoting a warning code.  The Critical Bit MUST\n
        \  be set.\n   Clients MUST NOT include Warning records in their request.
        \ If\n   clients receive a server response that includes a Warning record,\n
        \  they MAY discard any negotiated key material and abort without\n   proceeding
        to the Next Protocol.  Unrecognized warning codes MUST be\n   treated as errors.\n
        \  This memo defines no warning codes.\n"
      title: 4.1.4.  Warning
    - contents:
      - "4.1.5.  AEAD Algorithm Negotiation\n   The AEAD Algorithm Negotiation record
        has a Record Type number of 4.\n   Its body consists of a sequence of unsigned
        16-bit integers in\n   network byte order, denoting Numeric Identifiers from
        the IANA \"AEAD\n   Algorithms\" registry [IANA-AEAD].  The Critical Bit MAY
        be set.\n   If the NTS Next Protocol Negotiation record offers Protocol ID
        0 (for\n   NTPv4), then this record MUST be included exactly once.  Other\n
        \  protocols MAY require it as well.\n   When included in a request, this
        record denotes which AEAD algorithms\n   the client is willing to use to secure
        the Next Protocol, in\n   decreasing preference order.  When included in a
        response, this\n   record denotes which algorithm the server chooses to use.
        \ It is\n   empty if the server supports none of the algorithms offered.  In\n
        \  requests, the list MUST include at least one algorithm.  In\n   responses,
        it MUST include at most one.  Honoring the client's\n   preference order is
        OPTIONAL: servers may select among any of the\n   client's offered choices,
        even if they are able to support some other\n   algorithm that the client
        prefers more.\n   Server implementations of NTS Extension Fields for NTPv4
        (Section 5)\n   MUST support AEAD_AES_SIV_CMAC_256 [RFC5297] (Numeric Identifier
        15).\n   That is, if the client includes AEAD_AES_SIV_CMAC_256 in its AEAD\n
        \  Algorithm Negotiation record, and the server accepts Protocol ID 0\n   (NTPv4)
        in its NTS Next Protocol Negotiation record, then the\n   server's AEAD Algorithm
        Negotiation record MUST NOT be empty.\n"
      title: 4.1.5.  AEAD Algorithm Negotiation
    - contents:
      - "4.1.6.  New Cookie for NTPv4\n   The New Cookie for NTPv4 record has a Record
        Type number of 5.  The\n   contents of its body SHALL be implementation-defined,
        and clients\n   MUST NOT attempt to interpret them.  See Section 6 for a suggested\n
        \  construction.\n   Clients MUST NOT send records of this type.  Servers
        MUST send at\n   least one record of this type, and SHOULD send eight of them,
        if the\n   Next Protocol Negotiation response record contains Protocol ID
        0\n   (NTPv4) and the AEAD Algorithm Negotiation response record is not\n
        \  empty.  The Critical Bit SHOULD NOT be set.\n"
      title: 4.1.6.  New Cookie for NTPv4
    - contents:
      - "4.1.7.  NTPv4 Server Negotiation\n   The NTPv4 Server Negotiation record
        has a Record Type number of 6.\n   Its body consists of an ASCII-encoded [RFC0020]
        string.  The contents\n   of the string SHALL be either an IPv4 address, an
        IPv6 address, or a\n   fully qualified domain name (FQDN).  IPv4 addresses
        MUST be in dotted\n   decimal notation.  IPv6 addresses MUST conform to the
        \"Text\n   Representation of Addresses\" as specified in RFC 4291 [RFC4291]
        and\n   MUST NOT include zone identifiers [RFC6874].  If a label contains
        at\n   least one non-ASCII character, it is an internationalized domain\n
        \  name, and an A-LABEL MUST be used as defined in Section 2.3.2.1 of\n   RFC
        5890 [RFC5890].  If the record contains a domain name, the\n   recipient MUST
        treat it as a FQDN, e.g., by making sure it ends with\n   a dot.\n   When
        NTPv4 is negotiated as a Next Protocol and this record is sent\n   by the
        server, the body specifies the hostname or IP address of the\n   NTPv4 server
        with which the client should associate and that will\n   accept the supplied
        cookies.  If no record of this type is sent, the\n   client SHALL interpret
        this as a directive to associate with an NTPv4\n   server at the same IP address
        as the NTS-KE server.  Servers MUST NOT\n   send more than one record of this
        type.\n   When this record is sent by the client, it indicates that the client\n
        \  wishes to associate with the specified NTP server.  The NTS-KE server\n
        \  MAY incorporate this request when deciding which NTPv4 Server\n   Negotiation
        records to respond with, but honoring the client's\n   preference is OPTIONAL.
        \ The client MUST NOT send more than one\n   record of this type.\n   If the
        client has sent a record of this type, the NTS-KE server\n   SHOULD reply
        with the same record if it is valid and the server is\n   able to supply cookies
        for it.  If the client has not sent any record\n   of this type, the NTS-KE
        server SHOULD respond with either an NTP\n   server address in the same family
        as the NTS-KE session or a FQDN\n   that can be resolved to an address in
        that family, if such\n   alternatives are available.\n   Servers MAY set the
        Critical Bit on records of this type; clients\n   SHOULD NOT.\n"
      title: 4.1.7.  NTPv4 Server Negotiation
    - contents:
      - "4.1.8.  NTPv4 Port Negotiation\n   The NTPv4 Port Negotiation record has
        a Record Type number of 7.  Its\n   body consists of a 16-bit unsigned integer
        in network byte order,\n   denoting a UDP port number.\n   When NTPv4 is negotiated
        as a Next Protocol, and this record is sent\n   by the server, the body specifies
        the port number of the NTPv4 server\n   with which the client should associate
        and that will accept the\n   supplied cookies.  If no record of this type
        is sent, the client\n   SHALL assume a default of 123 (the registered port
        number for NTP).\n   When this record is sent by the client in conjunction
        with a NTPv4\n   Server Negotiation record, it indicates that the client wishes
        to\n   associate with the NTP server at the specified port.  The NTS-KE\n
        \  server MAY incorporate this request when deciding what NTPv4 Server\n   Negotiation
        and NTPv4 Port Negotiation records to respond with, but\n   honoring the client's
        preference is OPTIONAL.\n   Servers MAY set the Critical Bit on records of
        this type; clients\n   SHOULD NOT.\n"
      title: 4.1.8.  NTPv4 Port Negotiation
    title: 4.1.  NTS-KE Record Types
  - contents:
    - "4.2.  Retry Intervals\n   A mechanism for not unnecessarily overloading the
      NTS-KE server is\n   REQUIRED when retrying the key establishment process due
      to protocol,\n   communication, or other errors.  The exact workings of this
      will be\n   dependent on the application and operational experience gathered
      over\n   time.  Until such experience is available, this memo provides the\n
      \  following suggestion.\n   Clients SHOULD use exponential backoff, with an
      initial and minimum\n   retry interval of 10 seconds, a maximum retry interval
      of 5 days, and\n   a base of 1.5.  Thus, the minimum interval in seconds, 't',
      for the\n   nth retry is calculated with the following:\n      t = min(10 *
      1.5^(n-1), 432000).\n   Clients MUST NOT reset the retry interval until they
      have performed a\n   successful key establishment with the NTS-KE server, followed
      by a\n   successful use of the negotiated Next Protocol with the keys and data\n
      \  established during that transaction.\n"
    title: 4.2.  Retry Intervals
  - contents:
    - "4.3.  Key Extraction (Generally)\n   Following a successful run of the NTS-KE
      protocol, key material SHALL\n   be extracted using the HMAC-based Extract-and-Expand
      Key Derivation\n   Function (HKDF) [RFC5869] in accordance with Section 7.5
      of RFC 8446\n   [RFC8446].  Inputs to the exporter function are to be constructed
      in\n   a manner specific to the negotiated Next Protocol.  However, all\n   protocols
      that utilize NTS-KE MUST conform to the following two\n   rules:\n      The
      disambiguating label string [RFC5705] MUST be \"EXPORTER-\n      network-time-security\".\n
      \     The per-association context value [RFC5705] MUST be provided and\n      MUST
      begin with the two-octet Protocol ID that was negotiated as a\n      Next Protocol.\n"
    title: 4.3.  Key Extraction (Generally)
  title: 4.  The NTS Key Establishment Protocol
- contents:
  - '5.  NTS Extension Fields for NTPv4

    '
  - contents:
    - "5.1.  Key Extraction (for NTPv4)\n   Following a successful run of the NTS-KE
      protocol wherein Protocol ID\n   0 (NTPv4) is selected as a Next Protocol, two
      AEAD keys SHALL be\n   extracted: a client-to-server (C2S) key and a server-to-client
      (S2C)\n   key.  These keys SHALL be computed with the HKDF defined in\n   Section
      7.5 of RFC 8446 [RFC8446] using the following inputs:\n      The disambiguating
      label string [RFC5705] SHALL be \"EXPORTER-\n      network-time-security\".\n
      \     The per-association context value [RFC5705] SHALL consist of the\n      following
      five octets:\n      -  The first two octets SHALL be zero (the Protocol ID for
      NTPv4).\n      -  The next two octets SHALL be the Numeric Identifier of the\n
      \        negotiated AEAD algorithm in network byte order.\n      -  The final
      octet SHALL be 0x00 for the C2S key and 0x01 for the\n         S2C key.\n   Implementations
      wishing to derive additional keys for private or\n   experimental use MUST NOT
      do so by extending the above-specified\n   syntax for per-association context
      values.  Instead, they SHOULD use\n   their own disambiguating label string.
      \ Note that RFC 5705 [RFC5705]\n   provides that disambiguating label strings
      beginning with\n   \"EXPERIMENTAL\" MAY be used without IANA registration.\n"
    title: 5.1.  Key Extraction (for NTPv4)
  - contents:
    - "5.2.  Packet Structure Overview\n   In general, an NTS-protected NTPv4 packet
      consists of the following:\n      The usual 48-octet NTP header, which is authenticated
      but not\n      encrypted.\n      Some extension fields, which are authenticated
      but not encrypted.\n      An extension field that contains AEAD output (i.e.,
      an\n      authentication tag and possible ciphertext).  The corresponding\n
      \     plaintext, if non-empty, consists of some extension fields that\n      benefit
      from both encryption and authentication.\n      Possibly, some additional extension
      fields that are neither\n      encrypted nor authenticated.  In general, these
      are discarded by\n      the receiver.\n   Always included among the authenticated
      or authenticated-and-\n   encrypted extension fields are a cookie extension
      field and a unique\n   identifier extension field, as described in Section 5.7.
      \ The purpose\n   of the cookie extension field is to enable the server to offload\n
      \  storage of session state onto the client.  The purpose of the unique\n   identifier
      extension field is to protect the client from replay\n   attacks.\n"
    title: 5.2.  Packet Structure Overview
  - contents:
    - "5.3.  The Unique Identifier Extension Field\n   The Unique Identifier extension
      field provides the client with a\n   cryptographically strong means of detecting
      replayed packets.  It has\n   a Field Type of 0x0104.  When the extension field
      is included in a\n   client packet (mode 3), its body SHALL consist of a string
      of octets\n   generated by a cryptographically secure random number generator\n
      \  [RFC4086].  The string MUST be at least 32 octets long.  When the\n   extension
      field is included in a server packet (mode 4), its body\n   SHALL contain the
      same octet string as was provided in the client\n   packet to which the server
      is responding.  All server packets\n   generated by NTS-implementing servers
      in response to client packets\n   containing this extension field MUST also
      contain this field with the\n   same content as in the client's request.  The
      field's use in modes\n   other than client-server is not defined.\n   This extension
      field MAY also be used standalone, without NTS, in\n   which case it provides
      the client with a means of detecting spoofed\n   packets from off-path attackers.
      \ Historically, NTP's origin\n   timestamp field has played both these roles,
      but this is suboptimal\n   for cryptographic purposes because it is only 64
      bits long, and\n   depending on implementation details, most of those bits may
      be\n   predictable.  In contrast, the Unique Identifier extension field\n   enables
      a degree of unpredictability and collision resistance more\n   consistent with
      cryptographic best practice.\n"
    title: 5.3.  The Unique Identifier Extension Field
  - contents:
    - "5.4.  The NTS Cookie Extension Field\n   The NTS Cookie extension field has
      a Field Type of 0x0204.  Its\n   purpose is to carry information that enables
      the server to recompute\n   keys and other session state without having to store
      any per-client\n   state.  The contents of its body SHALL be implementation-defined,
      and\n   clients MUST NOT attempt to interpret them.  See Section 6 for a\n   suggested
      construction.  The NTS Cookie extension field MUST NOT be\n   included in NTP
      packets whose mode is other than 3 (client) or 4\n   (server).\n"
    title: 5.4.  The NTS Cookie Extension Field
  - contents:
    - "5.5.  The NTS Cookie Placeholder Extension Field\n   The NTS Cookie Placeholder
      extension field has a Field Type of\n   0x0304.  When this extension field is
      included in a client packet\n   (mode 3), it communicates to the server that
      the client wishes it to\n   send additional cookies in its response.  This extension
      field MUST\n   NOT be included in NTP packets whose mode is other than 3.\n
      \  Whenever an NTS Cookie Placeholder extension field is present, it\n   MUST
      be accompanied by an NTS Cookie extension field.  The body\n   length of the
      NTS Cookie Placeholder extension field MUST be the same\n   as the body length
      of the NTS Cookie extension field.  This length\n   requirement serves to ensure
      that the response will not be larger\n   than the request, in order to improve
      timekeeping precision and\n   prevent DDoS amplification.  The contents of the
      NTS Cookie\n   Placeholder extension field's body SHOULD be all zeros and, aside\n
      \  from checking its length, MUST be ignored by the server.\n"
    title: 5.5.  The NTS Cookie Placeholder Extension Field
  - contents:
    - "5.6.  The NTS Authenticator and Encrypted Extension Fields Extension\n      Field\n
      \  The NTS Authenticator and Encrypted Extension Fields extension field\n   is
      the central cryptographic element of an NTS-protected NTP packet.\n   Its Field
      Type is 0x0404.  It SHALL be formatted according to\n   Figure 4 and include
      the following fields:\n   Nonce Length:  Two octets in network byte order, giving
      the length of\n      the Nonce field, excluding any padding, interpreted as
      an unsigned\n      integer.\n   Ciphertext Length:  Two octets in network byte
      order, giving the\n      length of the Ciphertext field, excluding any padding,
      interpreted\n      as an unsigned integer.\n   Nonce:  A nonce as required by
      the negotiated AEAD algorithm.  The\n      end of the field is zero-padded to
      a word (four octets) boundary.\n   Ciphertext:  The output of the negotiated
      AEAD algorithm.  The\n      structure of this field is determined by the negotiated
      algorithm,\n      but it typically contains an authentication tag in addition
      to the\n      actual ciphertext.  The end of the field is zero-padded to a word\n
      \     (four octets) boundary.\n   Additional Padding:  Clients that use a nonce
      length shorter than the\n      maximum allowed by the negotiated AEAD algorithm
      may be required\n      to include additional zero-padding.  The necessary length
      of this\n      field is specified below.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   |          Nonce Length         |      Ciphertext Length        |\n
      \  .          Nonce, including up to 3 octets padding              .\n   .        Ciphertext,
      including up to 3 octets padding           .\n   .                      Additional
      Padding                       .\n         Figure 4: NTS Authenticator and Encrypted
      Extension Fields\n                           Extension Field Format\n   The
      Ciphertext field SHALL be formed by providing the following\n   inputs to the
      negotiated AEAD algorithm:\n   K:  For packets sent from the client to the server,
      the C2S key SHALL\n       be used.  For packets sent from the server to the
      client, the S2C\n       key SHALL be used.\n   A:  The associated data SHALL
      consist of the portion of the NTP\n       packet beginning from the start of
      the NTP header and ending at\n       the end of the last extension field that
      precedes the NTS\n       Authenticator and Encrypted Extension Fields extension
      field.\n   P:  The plaintext SHALL consist of all (if any) NTP extension fields\n
      \      to be encrypted; if multiple extension fields are present, they\n       SHALL
      be joined by concatenation.  Each such field SHALL be\n       formatted in accordance
      with RFC 7822 [RFC7822], except that,\n       contrary to the RFC 7822 requirement
      that fields have a minimum\n       length of 16 or 28 octets, encrypted extension
      fields MAY be\n       arbitrarily short (but still MUST be a multiple of 4 octets
      in\n       length).\n   N:  The nonce SHALL be formed however required by the
      negotiated AEAD\n       algorithm.\n   The purpose of the Additional Padding
      field is to ensure that servers\n   can always choose a nonce whose length is
      adequate to ensure its\n   uniqueness, even if the client chooses a shorter
      one, and still\n   ensure that the overall length of the server's response packet
      does\n   not exceed the length of the request.  For mode 4 (server) packets,\n
      \  no Additional Padding field is ever required.  For mode 3 (client)\n   packets,
      the length of the Additional Padding field SHALL be computed\n   as follows.
      \ Let 'N_LEN' be the padded length of the Nonce field.\n   Let 'N_MAX' be, as
      specified by RFC 5116 [RFC5116], the maximum\n   permitted nonce length for
      the negotiated AEAD algorithm.  Let\n   'N_REQ' be the lesser of 16 and N_MAX,
      rounded up to the nearest\n   multiple of 4.  If N_LEN is greater than or equal
      to N_REQ, then no\n   Additional Padding field is required.  Otherwise, the
      Additional\n   Padding field SHALL be at least N_REQ - N_LEN octets in length.\n
      \  Servers MUST enforce this requirement by discarding any packet that\n   does
      not conform to it.\n   Senders are always free to include more Additional Padding
      than\n   mandated by the above paragraph.  Theoretically, it could be\n   necessary
      to do so in order to bring the extension field to the\n   minimum length required
      by RFC 7822 [RFC7822].  This should never\n   happen in practice because any
      reasonable AEAD algorithm will have a\n   nonce and an authenticator long enough
      to bring the extension field\n   to its required length already.  Nonetheless,
      implementers are\n   advised to explicitly handle this case and ensure that
      the extension\n   field they emit is of legal length.\n   The NTS Authenticator
      and Encrypted Extension Fields extension field\n   MUST NOT be included in NTP
      packets whose mode is other than 3\n   (client) or 4 (server).\n"
    title: 5.6.  The NTS Authenticator and Encrypted Extension Fields Extension
  - contents:
    - "5.7.  Protocol Details\n   A client sending an NTS-protected request SHALL
      include the following\n   extension fields as displayed in Figure 5:\n      Exactly
      one Unique Identifier extension field that MUST be\n      authenticated, MUST
      NOT be encrypted, and whose contents MUST be\n      the output of a cryptographically
      secure random number generator\n      [RFC4086].\n      Exactly one NTS Cookie
      extension field that MUST be authenticated\n      and MUST NOT be encrypted.
      \ The cookie MUST be one which has been\n      previously provided to the client,
      either from the key\n      establishment server during the NTS-KE handshake
      or from the NTP\n      server in response to a previous NTS-protected NTP request.\n
      \     Exactly one NTS Authenticator and Encrypted Extension Fields\n      extension
      field, generated using an AEAD algorithm and C2S key\n      established through
      NTS-KE.\n   To protect the client's privacy, the client SHOULD avoid reusing
      a\n   cookie.  If the client does not have any cookies that it has not\n   already
      sent, it SHOULD initiate a rerun of the NTS-KE protocol.  The\n   client MAY
      reuse cookies in order to prioritize resilience over\n   unlinkability.  Which
      of the two that should be prioritized in any\n   particular case is dependent
      on the application and the user's\n   preference.  Section 9.1 describes the
      privacy considerations of this\n   in further detail.\n   The client MAY include
      one or more NTS Cookie Placeholder extension\n   fields that MUST be authenticated
      and MAY be encrypted.  The number\n   of NTS Cookie Placeholder extension fields
      that the client includes\n   SHOULD be such that if the client includes N placeholders
      and the\n   server sends back N+1 cookies, the number of unused cookies stored
      by\n   the client will come to eight.  The client SHOULD NOT include more\n
      \  than seven NTS Cookie Placeholder extension fields in a request.\n   When
      both the client and server adhere to all cookie-management\n   guidance provided
      in this memo, the number of placeholder extension\n   fields will equal the
      number of dropped packets since the last\n   successful volley.\n   In rare
      circumstances, it may be necessary to include fewer NTS\n   Cookie Placeholder
      extensions than recommended above in order to\n   prevent datagram fragmentation.
      \ When cookies adhere to the format\n   recommended in Section 6 and the AEAD
      in use is the mandatory-to-\n   implement AEAD_AES_SIV_CMAC_256, senders can
      include a cookie and\n   seven placeholders and still have packet size fall
      comfortably below\n   1280 octets if no non-NTS-related extensions are used;
      1280 octets is\n   the minimum prescribed MTU for IPv6 and is generally safe
      for\n   avoiding IPv4 fragmentation.  Nonetheless, senders SHOULD include\n
      \  fewer cookies and placeholders than otherwise indicated if doing so\n   is
      necessary to prevent fragmentation.\n                   | - Verify time request
      message.        |\n                   | - Generate time response message.     |\n
      \                  |   - Included NTPv4 extension fields:  |\n                   |
      \     o Unique Identifier EF           |\n                   |      o NTS Authentication
      and         |\n                   |        Encrypted Extension Fields EF  |\n
      \                  |        - NTS Cookie EF                |\n                   |
      \       - <NTS Cookie EF>              |\n                   | - Transmit time
      request packet.       |\n   Server -----------+---------------+-----+----------------------->\n
      \    Time request  /                          \\   Time response\n     (mode
      3)     /                            \\  (mode 4)\n   Client -----+---------------------------------+----------------->\n
      \  |- Generate time request message.   |   |- Verify time response  |\n   |
      - Include NTPv4 Extension fields: |   |  message.              |\n   |    o
      Unique Identifier EF         |   |- Extract cookie(s).    |\n   |    o NTS Cookie
      EF                |   |- Time synchronization  |\n   |    o <NTS Cookie Placeholder
      EF>  |   |  processing.           |\n   |- Generate AEAD tag of NTP message.|\n
      \  |- Add NTS Authentication and       |\n   |  Encrypted Extension Fields EF.
      \  |\n   |- Transmit time request packet.    |\n         Figure 5: NTS-Protected
      NTP Time Synchronization Messages\n   The client MAY include additional (non-NTS-related)
      extension fields\n   that MAY appear prior to the NTS Authenticator and Encrypted\n
      \  Extension Fields extension fields (therefore authenticated but not\n   encrypted),
      within it (therefore encrypted and authenticated), or\n   after it (therefore
      neither encrypted nor authenticated).  The server\n   MUST discard any unauthenticated
      extension fields.  Future\n   specifications of extension fields MAY provide
      exceptions to this\n   rule.\n   Upon receiving an NTS-protected request, the
      server SHALL (through\n   some implementation-defined mechanism) use the cookie
      to recover the\n   AEAD algorithm, C2S key, and S2C key associated with the
      request, and\n   then use the C2S key to authenticate the packet and decrypt
      the\n   ciphertext.  If the cookie is valid and authentication and decryption\n
      \  succeed, the server SHALL include the following extension fields in\n   its
      response:\n      Exactly one Unique Identifier extension field that MUST be\n
      \     authenticated, MUST NOT be encrypted, and whose contents SHALL\n      echo
      those provided by the client.\n      Exactly one NTS Authenticator and Encrypted
      Extension Fields\n      extension field, generated using the AEAD algorithm
      and S2C key\n      recovered from the cookie provided by the client.\n      One
      or more NTS Cookie extension fields that MUST be authenticated\n      and encrypted.
      \ The number of NTS Cookie extension fields included\n      SHOULD be equal
      to, and MUST NOT exceed, one plus the number of\n      valid NTS Cookie Placeholder
      extension fields included in the\n      request.  The cookies returned in those
      fields MUST be valid for\n      use with the NTP server that sent them.  They
      MAY be valid for\n      other NTP servers as well, but there is no way for the
      server to\n      indicate this.\n   We emphasize the contrast that NTS Cookie
      extension fields MUST NOT\n   be encrypted when sent from client to server but
      MUST be encrypted\n   when sent from server to client.  The former is necessary
      in order\n   for the server to be able to recover the C2S and S2C keys, while
      the\n   latter is necessary to satisfy the unlinkability goals discussed in\n
      \  Section 9.1.  We emphasize also that \"encrypted\" means encapsulated\n   within
      the NTS Authenticator and Encrypted Extensions extension\n   field.  While the
      body of an NTS Cookie extension field will\n   generally consist of some sort
      of AEAD output (regardless of whether\n   the recommendations of Section 6 are
      precisely followed), this is not\n   sufficient to make the extension field
      \"encrypted\".\n   The server MAY include additional (non-NTS-related) extension
      fields\n   that MAY appear prior to the NTS Authenticator and Encrypted\n   Extension
      Fields extension field (therefore authenticated but not\n   encrypted), within
      it (therefore encrypted and authenticated), or\n   after it (therefore neither
      encrypted nor authenticated).  The client\n   MUST discard any unauthenticated
      extension fields.  Future\n   specifications of extension fields MAY provide
      exceptions to this\n   rule.\n   Upon receiving an NTS-protected response, the
      client MUST verify that\n   the Unique Identifier matches that of an outstanding
      request, and\n   that the packet is authentic under the S2C key associated with
      that\n   request.  If either of these checks fails, the packet MUST be\n   discarded
      without further processing.  In particular, the client MUST\n   discard unprotected
      responses to NTS-protected requests.\n   If the server is unable to validate
      the cookie or authenticate the\n   request, it SHOULD respond with a Kiss-o'-Death
      (KoD) packet (see\n   Section 7.4 of RFC 5905 [RFC5905]) with kiss code \"NTSN\",
      meaning\n   \"NTS NAK\" (NTS negative-acknowledgment).  It MUST NOT include
      any NTS\n   Cookie or NTS Authenticator and Encrypted Extension Fields extension\n
      \  fields.\n   If the NTP server has previously responded with authentic NTS-\n
      \  protected NTP packets, the client MUST verify that any KoD packets\n   received
      from the server contain the Unique Identifier extension\n   field and that the
      Unique Identifier matches that of an outstanding\n   request.  If this check
      fails, the packet MUST be discarded without\n   further processing.  If this
      check passes, the client MUST comply\n   with Section 7.4 of RFC 5905 [RFC5905]
      where required.\n   A client MAY automatically rerun the NTS-KE protocol upon
      forced\n   disassociation from an NTP server.  In that case, it MUST avoid\n
      \  quickly looping between the NTS-KE and NTP servers by rate limiting\n   the
      retries.  Requirements for retry intervals in NTS-KE are\n   described in Section
      4.2.\n   Upon reception of the NTS NAK kiss code, the client SHOULD wait until\n
      \  the next poll for a valid NTS-protected response, and if none is\n   received,
      initiate a fresh NTS-KE handshake to try to renegotiate new\n   cookies, AEAD
      keys, and parameters.  If the NTS-KE handshake\n   succeeds, the client MUST
      discard all old cookies and parameters and\n   use the new ones instead.  As
      long as the NTS-KE handshake has not\n   succeeded, the client SHOULD continue
      polling the NTP server using\n   the cookies and parameters it has.\n   To allow
      for NTP session restart when the NTS-KE server is\n   unavailable and to reduce
      NTS-KE server load, the client SHOULD keep\n   at least one unused but recent
      cookie, AEAD keys, negotiated AEAD\n   algorithm, and other necessary parameters
      in persistent storage.\n   This way, the client is able to resume the NTP session
      without\n   performing renewed NTS-KE negotiation.\n"
    title: 5.7.  Protocol Details
  title: 5.  NTS Extension Fields for NTPv4
- contents:
  - "6.  Suggested Format for NTS Cookies\n   This section is non-normative.  It gives
    a suggested way for servers\n   to construct NTS cookies.  All normative requirements
    are stated in\n   Section 4.1.6 and Section 5.4.\n   The role of cookies in NTS
    is closely analogous to that of session\n   tickets in TLS.  Accordingly, the
    thematic resemblance of this\n   section to RFC 5077 [RFC5077] is deliberate,
    and the reader should\n   likewise take heed of its security considerations.\n
    \  Servers should select an AEAD algorithm that they will use to encrypt\n   and
    authenticate cookies.  The chosen algorithm should be one such as\n   AEAD_AES_SIV_CMAC_256
    [RFC5297], which resists accidental nonce\n   reuse.  It need not be the same
    as the one that was negotiated with\n   the client.  Servers should randomly generate
    and store a secret\n   master AEAD key 'K'.  Servers should additionally choose
    a non-\n   secret, unique value 'I' as key identifier for 'K'.\n   Servers should
    periodically (e.g., once daily) generate a new pair\n   '(I,K)' and immediately
    switch to using these values for all newly-\n   generated cookies.  Following
    each such key rotation, servers should\n   securely erase any previously generated
    keys that should now be\n   expired.  Servers should continue to accept any cookie
    generated\n   using keys that they have not yet erased, even if those keys are
    no\n   longer current.  Erasing old keys provides for forward secrecy,\n   limiting
    the scope of what old information can be stolen if a master\n   key is somehow
    compromised.  Holding on to a limited number of old\n   keys allows clients to
    seamlessly transition from one generation to\n   the next without having to perform
    a new NTS-KE handshake.\n   The need to keep keys synchronized between NTS-KE
    and NTP servers as\n   well as across load-balanced clusters can make automatic
    key rotation\n   challenging.  However, the task can be accomplished without the
    need\n   for central key-management infrastructure by using a ratchet, i.e.,\n
    \  making each new key a deterministic, cryptographically pseudorandom\n   function
    of its predecessor.  A recommended concrete implementation\n   of this approach
    is to use HKDF [RFC5869] to derive new keys, using\n   the key's predecessor as
    Input Keying Material and its key identifier\n   as a salt.\n   To form a cookie,
    servers should first form a plaintext 'P'\n   consisting of the following fields:\n
    \     The AEAD algorithm negotiated during NTS-KE.\n      The S2C key.\n      The
    C2S key.\n   Servers should then generate a nonce 'N' uniformly at random, and\n
    \  form AEAD output 'C' by encrypting 'P' under key 'K' with nonce 'N'\n   and
    no associated data.\n   The cookie should consist of the tuple '(I,N,C)'.\n   To
    verify and decrypt a cookie provided by the client, first parse it\n   into its
    components 'I', 'N', and 'C'.  Use 'I' to look up its\n   decryption key 'K'.
    \ If the key whose identifier is 'I' has been\n   erased or never existed, decryption
    fails; reply with an NTS NAK.\n   Otherwise, attempt to decrypt and verify ciphertext
    'C' using key 'K'\n   and nonce 'N' with no associated data.  If decryption or
    verification\n   fails, reply with an NTS NAK.  Otherwise, parse out the contents
    of\n   the resulting plaintext 'P' to obtain the negotiated AEAD algorithm,\n
    \  S2C key, and C2S key.\n"
  title: 6.  Suggested Format for NTS Cookies
- contents:
  - '7.  IANA Considerations

    '
  - contents:
    - "7.1.  Service Name and Transport Protocol Port Number Registry\n   IANA has
      allocated the following entry in the \"Service Name and\n   Transport Protocol
      Port Number Registry\" [RFC6335]:\n   Service Name:  ntske\n   Port Number:
      \ 4460\n   Transport Protocol:  tcp\n   Description:  Network Time Security
      Key Establishment\n   Assignee:  IESG <iesg@ietf.org>\n   Contact:  IETF Chair
      <chair@ietf.org>\n   Registration Date:  2020-04-07\n   Reference:  RFC 8915\n"
    title: 7.1.  Service Name and Transport Protocol Port Number Registry
  - contents:
    - "7.2.  TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs\n      Registry\n
      \  IANA has allocated the following entry in the \"TLS Application-Layer\n   Protocol
      Negotiation (ALPN) Protocol IDs\" registry [RFC7301]:\n   Protocol:  Network
      Time Security Key Establishment, version 1\n   Identification Sequence:  0x6E
      0x74 0x73 0x6B 0x65 0x2F 0x31\n      (\"ntske/1\")\n   Reference:  RFC 8915,
      Section 4\n"
    title: 7.2.  TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs
  - contents:
    - "7.3.  TLS Exporter Labels Registry\n   IANA has allocated the following entry
      in the TLS Exporter Labels\n   registry [RFC5705]:\n   | Value                          |DTLS-OK|Recommended|Reference|Note|\n
      \  | EXPORTER-network-time-security |Y      |Y          |RFC 8915,|    |\n"
    title: 7.3.  TLS Exporter Labels Registry
  - contents:
    - "7.4.  NTP Kiss-o'-Death Codes Registry\n   IANA has allocated the following
      entry in the \"NTP Kiss-o'-Death\n   Codes\" registry [RFC5905]:\n          |
      Code | Meaning                       | Reference   |\n          | NTSN | Network
      Time Security (NTS)   | RFC 8915,   |\n          |      | negative-acknowledgment
      (NAK) | Section 5.7 |\n"
    title: 7.4.  NTP Kiss-o'-Death Codes Registry
  - contents:
    - "7.5.  NTP Extension Field Types Registry\n   IANA has allocated the following
      entries in the \"NTP Extension Field\n   Types\" registry [RFC5905]:\n    |
      Field Type | Meaning                    | Reference             |\n    | 0x0104
      \    | Unique Identifier          | RFC 8915, Section 5.3 |\n    | 0x0204     |
      NTS Cookie                 | RFC 8915, Section 5.4 |\n    | 0x0304     | NTS
      Cookie Placeholder     | RFC 8915, Section 5.5 |\n    | 0x0404     | NTS Authenticator
      and      | RFC 8915, Section 5.6 |\n    |            | Encrypted Extension Fields
      |                       |\n"
    title: 7.5.  NTP Extension Field Types Registry
  - contents:
    - "7.6.  Network Time Security Key Establishment Record Types Registry\n   IANA
      has created a new registry entitled \"Network Time Security Key\n   Establishment
      Record Types\".  Entries have the following fields:\n   Record Type Number (REQUIRED):
      \ An integer in the range 0-32767\n      inclusive.\n   Description (REQUIRED):
      \ A short text description of the purpose of\n      the field.\n   Reference
      (REQUIRED):  A reference to a document specifying the\n      semantics of the
      record.\n   The registration policy varies by Record Type Number, as follows:\n
      \  0-1023:  IETF Review\n   1024-16383:  Specification Required\n   16384-32767:
      \ Private or Experimental Use\n   The initial contents of this registry are
      as follows:\n       | Record Type Number | Description          | Reference
      \    |\n       | 0                  | End of Message       | RFC 8915,     |\n
      \      | 1                  | NTS Next Protocol    | RFC 8915,     |\n       |
      \                   | Negotiation          | Section 4.1.2 |\n       | 2                  |
      Error                | RFC 8915,     |\n       | 3                  | Warning
      \             | RFC 8915,     |\n       | 4                  | AEAD Algorithm
      \      | RFC 8915,     |\n       |                    | Negotiation          |
      Section 4.1.5 |\n       | 5                  | New Cookie for NTPv4 | RFC 8915,
      \    |\n       | 6                  | NTPv4 Server         | RFC 8915,     |\n
      \      |                    | Negotiation          | Section 4.1.7 |\n       |
      7                  | NTPv4 Port           | RFC 8915,     |\n       |                    |
      Negotiation          | Section 4.1.8 |\n       | 8-16383            | Unassigned
      \          |               |\n       | 16384-32767        | Reserved for Private
      | RFC 8915      |\n       |                    | or Experimental Use  |               |\n"
    title: 7.6.  Network Time Security Key Establishment Record Types Registry
  - contents:
    - "7.7.  Network Time Security Next Protocols Registry\n   IANA has created a
      new registry entitled \"Network Time Security Next\n   Protocols\".  Entries
      have the following fields:\n   Protocol ID (REQUIRED):  An integer in the range
      0-65535 inclusive,\n      functioning as an identifier.\n   Protocol Name (REQUIRED):
      \ A short text string naming the protocol\n      being identified.\n   Reference
      (REQUIRED):  A reference to a relevant specification\n      document.\n   The
      registration policy varies by Protocol ID, as follows:\n   0-1023:  IETF Review\n
      \  1024-32767:  Specification Required\n   32768-65535:  Private or Experimental
      Use\n   The initial contents of this registry are as follows:\n   | Protocol
      ID | Protocol Name                           | Reference |\n   | 0           |
      Network Time Protocol                   | RFC 8915  |\n   |             | version
      4 (NTPv4)                       |           |\n   | 1-32767     | Unassigned
      \                             |           |\n   | 32768-65535 | Reserved for
      Private                    | RFC 8915  |\n   |             | or Experimental
      Use                     |           |\n"
    title: 7.7.  Network Time Security Next Protocols Registry
  - contents:
    - "7.8.  Network Time Security Error and Warning Codes Registries\n   IANA has
      created two new registries entitled \"Network Time Security\n   Error Codes\"
      and \"Network Time Security Warning Codes\".  Entries in\n   each have the following
      fields:\n   Number (REQUIRED):  An integer in the range 0-65535 inclusive\n
      \  Description (REQUIRED):  A short text description of the condition.\n   Reference
      (REQUIRED):  A reference to a relevant specification\n      document.\n   The
      registration policy varies by Number, as follows:\n   0-1023:  IETF Review\n
      \  1024-32767:  Specification Required\n   32768-65535:  Private or Experimental
      Use\n   The initial contents of the \"Network Time Security Error Codes\"\n
      \  registry are as follows:\n      | Number      | Description                  |
      Reference     |\n      | 0           | Unrecognized Critical Record | RFC 8915,
      \    |\n      | 1           | Bad Request                  | RFC 8915,     |\n
      \     | 2           | Internal Server Error        | RFC 8915,     |\n      |
      3-32767     | Unassigned                   |               |\n      | 32768-65535
      | Reserved for Private or      | RFC 8915      |\n      |             | Experimental
      Use             |               |\n   The \"Network Time Security Warning Codes\"
      registry is initially empty\n   except for the reserved range, i.e.:\n            |
      Number      | Description          | Reference |\n            | 0-32767     |
      Unassigned           |           |\n            | 32768-65535 | Reserved for
      Private | RFC 8915  |\n            |             | or Experimental Use  |           |\n"
    title: 7.8.  Network Time Security Error and Warning Codes Registries
  title: 7.  IANA Considerations
- contents:
  - '8.  Security Considerations

    '
  - contents:
    - "8.1.  Protected Modes\n   NTP provides many different operating modes in order
      to support\n   different network topologies and to adapt to various requirements.\n
      \  This memo only specifies NTS for NTP modes 3 (client) and 4 (server)\n   (see
      Section 1.3).  The best current practice for authenticating the\n   other NTP
      modes is using the symmetric message authentication code\n   feature as described
      in RFC 5905 [RFC5905] and RFC 8573 [RFC8573].\n"
    title: 8.1.  Protected Modes
  - contents:
    - "8.2.  Cookie Encryption Key Compromise\n   If the suggested format for NTS
      cookies in Section 6 of this document\n   is used, an attacker who has gained
      access to the secret cookie\n   encryption key 'K' can impersonate the NTP server,
      including\n   generating new cookies.  NTP and NTS-KE server operators SHOULD\n
      \  remove compromised keys as soon as the compromise is discovered.\n   This
      will cause the NTP servers to respond with NTS NAK, thus forcing\n   key renegotiation.
      \ Note that this measure does not protect against\n   MITM attacks where the
      attacker has access to a compromised cookie\n   encryption key.  If another
      cookie scheme is used, there are likely\n   similar considerations for that
      particular scheme.\n"
    title: 8.2.  Cookie Encryption Key Compromise
  - contents:
    - "8.3.  Sensitivity to DDoS Attacks\n   The introduction of NTS brings with it
      the introduction of asymmetric\n   cryptography to NTP.  Asymmetric cryptography
      is necessary for\n   initial server authentication and AEAD key extraction.
      \ Asymmetric\n   cryptosystems are generally orders of magnitude slower than
      their\n   symmetric counterparts.  This makes it much harder to build systems\n
      \  that can serve requests at a rate corresponding to the full line\n   speed
      of the network connection.  This, in turn, opens up a new\n   possibility for
      DDoS attacks on NTP services.\n   The main protection against these attacks
      in NTS lies in that the use\n   of asymmetric cryptosystems is only necessary
      in the initial NTS-KE\n   phase of the protocol.  Since the protocol design
      enables separation\n   of the NTS-KE and NTP servers, a successful DDoS attack
      on an NTS-KE\n   server separated from the NTP service it supports will not
      affect NTP\n   users that have already performed initial authentication, AEAD
      key\n   extraction, and cookie exchange.\n   NTS users should also consider
      that they are not fully protected\n   against DoS attacks by on-path adversaries.
      \ In addition to dropping\n   packets and attacks such as those described in
      Section 8.6, an on-\n   path attacker can send spoofed Kiss-o'-Death replies,
      which are not\n   authenticated, in response to NTP requests.  This could result
      in\n   significantly increased load on the NTS-KE server.  Implementers have\n
      \  to weigh the user's need for unlinkability against the added\n   resilience
      that comes with cookie reuse in cases of NTS-KE server\n   unavailability.\n"
    title: 8.3.  Sensitivity to DDoS Attacks
  - contents:
    - "8.4.  Avoiding DDoS Amplification\n   Certain nonstandard and/or deprecated
      features of the Network Time\n   Protocol enable clients to send a request to
      a server that causes the\n   server to send a response much larger than the
      request.  Servers that\n   enable these features can be abused in order to amplify
      traffic\n   volume in DDoS attacks by sending them a request with a spoofed\n
      \  source IP address.  In recent years, attacks of this nature have\n   become
      an endemic nuisance.\n   NTS is designed to avoid contributing any further to
      this problem by\n   ensuring that NTS-related extension fields included in server\n
      \  responses will be the same size as the NTS-related extension fields\n   sent
      by the client.  In particular, this is why the client is\n   required to send
      a separate and appropriately padded-out NTS Cookie\n   Placeholder extension
      field for every cookie it wants to get back,\n   rather than being permitted
      simply to specify a desired quantity.\n   Due to the RFC 7822 [RFC7822] requirement
      that extensions be padded\n   and aligned to four-octet boundaries, response
      size may still in some\n   cases exceed request size by up to three octets.
      \ This is\n   sufficiently inconsequential that we have declined to address
      it.\n"
    title: 8.4.  Avoiding DDoS Amplification
  - contents:
    - "8.5.  Initial Verification of Server Certificates\n   NTS's security goals
      are undermined if the client fails to verify\n   that the X.509 certificate
      chain presented by the NTS-KE server is\n   valid and rooted in a trusted certificate
      authority.  RFC 5280\n   [RFC5280] and RFC 6125 [RFC6125] specify how such verification
      is to\n   be performed in general.  However, the expectation that the client\n
      \  does not yet have a correctly-set system clock at the time of\n   certificate
      verification presents difficulties with verifying that\n   the certificate is
      within its validity period, i.e., that the current\n   time lies between the
      times specified in the certificate's notBefore\n   and notAfter fields.  It
      may be operationally necessary in some cases\n   for a client to accept a certificate
      that appears to be expired or\n   not yet valid.  While there is no perfect
      solution to this problem,\n   there are several mitigations the client can implement
      to make it\n   more difficult for an adversary to successfully present an expired\n
      \  certificate:\n      Check whether the system time is in fact unreliable.
      \ On systems\n      with the ntp_adjtime() system call, a return code other
      than\n      TIME_ERROR indicates that some trusted software has already set\n
      \     the time and certificates can be strictly validated.\n      Allow the
      system administrator to specify that certificates should\n      _always_ be
      strictly validated.  Such a configuration is\n      appropriate on systems that
      have a battery-backed clock or that\n      can reasonably prompt the user to
      manually set an approximately\n      correct time if it appears to be needed.\n
      \     Once the clock has been synchronized, periodically write the\n      current
      system time to persistent storage.  Do not accept any\n      certificate whose
      notAfter field is earlier than the last recorded\n      time.\n      NTP time
      replies are expected to be consistent with the NTS-KE TLS\n      certificate
      validity period, i.e. time replies received\n      immediately after an NTS-KE
      handshake are expected to lie within\n      the certificate validity period.
      \ Implementations are recommended\n      to check that this is the case.  Performing
      a new NTS-KE handshake\n      based solely on the fact that the certificate
      used by the NTS-KE\n      server in a previous handshake has expired is normally
      not\n      necessary.  Clients that still wish to do this must take care not\n
      \     to cause an inadvertent denial-of-service attack on the NTS-KE\n      server,
      for example by picking a random time in the week preceding\n      certificate
      expiry to perform the new handshake.\n      Use multiple time sources.  The
      ability to pass off an expired\n      certificate is only useful to an adversary
      who has compromised the\n      corresponding private key.  If the adversary
      has compromised only\n      a minority of servers, NTP's selection algorithm
      (Section 11.2.1\n      of RFC 5905 [RFC5905]) will protect the client from accepting
      bad\n      time from the adversary-controlled servers.\n"
    title: 8.5.  Initial Verification of Server Certificates
  - contents:
    - "8.6.  Delay Attacks\n   In a packet delay attack, an adversary with the ability
      to act as a\n   man-in-the-middle delays time synchronization packets between
      client\n   and server asymmetrically [RFC7384].  Since NTP's formula for\n   computing
      time offset relies on the assumption that network latency\n   is roughly symmetrical,
      this leads to the client to compute an\n   inaccurate value [Mizrahi].  The
      delay attack does not reorder or\n   modify the content of the exchanged synchronization
      packets.\n   Therefore, cryptographic means do not provide a feasible way to\n
      \  mitigate this attack.  However, the maximum error that an adversary\n   can
      introduce is bounded by half of the round-trip delay.\n   RFC 5905 [RFC5905]
      specifies a parameter called MAXDIST, which\n   denotes the maximum round-trip
      latency (including not only the\n   immediate round trip between client and
      server, but the whole\n   distance back to the reference clock as reported in
      the Root Delay\n   field) that a client will tolerate before concluding that
      the server\n   is unsuitable for synchronization.  The standard value for MAXDIST
      is\n   one second, although some implementations use larger values.\n   Whatever
      value a client chooses, the maximum error that can be\n   introduced by a delay
      attack is MAXDIST/2.\n   Usage of multiple time sources, or multiple network
      paths to a given\n   time source [Shpiner], may also serve to mitigate delay
      attacks if\n   the adversary is in control of only some of the paths.\n"
    title: 8.6.  Delay Attacks
  - contents:
    - "8.7.  NTS Stripping\n   Implementers must be aware of the possibility of \"NTS
      stripping\"\n   attacks, where an attacker attempts to trick clients into reverting\n
      \  to plain NTP.  Naive client implementations might, for example,\n   revert
      automatically to plain NTP if the NTS-KE handshake fails.  A\n   man-in-the-middle
      attacker can easily cause this to happen.  Even\n   clients that already hold
      valid cookies can be vulnerable, since an\n   attacker can force a client to
      repeat the NTS-KE handshake by sending\n   faked NTP mode 4 replies with the
      NTS NAK kiss code.  Forcing a\n   client to repeat the NTS-KE handshake can
      also be the first step in\n   more advanced attacks.\n   For the reasons described
      here, implementations SHOULD NOT revert\n   from NTS-protected to unprotected
      NTP with any server without\n   explicit user action.\n"
    title: 8.7.  NTS Stripping
  title: 8.  Security Considerations
- contents:
  - '9.  Privacy Considerations

    '
  - contents:
    - "9.1.  Unlinkability\n   Unlinkability prevents a device from being tracked
      when it changes\n   network addresses (e.g., because said device moved between
      different\n   networks).  In other words, unlinkability thwarts an attacker
      that\n   seeks to link a new network address used by a device with a network\n
      \  address that it was formerly using because of recognizable data that\n   the
      device persistently sends as part of an NTS-secured NTP\n   association.  This
      is the justification for continually supplying the\n   client with fresh cookies,
      so that a cookie never represents\n   recognizable data in the sense outlined
      above.\n   NTS's unlinkability objective is merely to not leak any additional\n
      \  data that could be used to link a device's network address.  NTS does\n   not
      rectify legacy linkability issues that are already present in\n   NTP.  Thus,
      a client that requires unlinkability must also minimize\n   information transmitted
      in a client query (mode 3) packet as\n   described in the document NTP Client
      Data Minimization\n   [NTP-DATA-MIN].\n   The unlinkability objective only holds
      for time synchronization\n   traffic, as opposed to key establishment traffic.
      \ This implies that\n   it cannot be guaranteed for devices that function not
      only as time\n   clients, but also as time servers (because the latter can be\n
      \  externally triggered to send linkable data, such as the TLS\n   certificate).\n
      \  It should also be noted that it could be possible to link devices\n   that
      operate as time servers from their time synchronization traffic,\n   using information
      exposed in (mode 4) server response packets (e.g.\n   reference ID, reference
      time, stratum, poll).  Also, devices that\n   respond to NTP control queries
      could be linked using the information\n   revealed by control queries.\n   Note
      that the unlinkability objective does not prevent a client\n   device from being
      tracked by its time servers.\n"
    title: 9.1.  Unlinkability
  - contents:
    - "9.2.  Confidentiality\n   NTS does not protect the confidentiality of information
      in NTP's\n   header fields.  When clients implement NTP Client Data Minimization\n
      \  [NTP-DATA-MIN], client packet headers do not contain any information\n   that
      the client could conceivably wish to keep secret: one field is\n   random, and
      all others are fixed.  Information in server packet\n   headers is likewise
      public: the origin timestamp is copied from the\n   client's (random) transmit
      timestamp, and all other fields are set\n   the same regardless of the identity
      of the client making the request.\n   Future extension fields could hypothetically
      contain sensitive\n   information, in which case NTS provides a mechanism for
      encrypting\n   them.\n"
    title: 9.2.  Confidentiality
  title: 9.  Privacy Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [IANA-AEAD]\n              IANA, \"Authenticated
      Encryption with Associated Data\n              (AEAD) Parameters\",\n              <https://www.iana.org/assignments/aead-parameters/>.\n
      \  [RFC0020]  Cerf, V., \"ASCII format for network interchange\", STD 80,\n
      \             RFC 20, DOI 10.17487/RFC0020, October 1969,\n              <https://www.rfc-editor.org/info/rfc20>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC4291]  Hinden,
      R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\",
      RFC 4291, DOI 10.17487/RFC4291, February\n              2006, <https://www.rfc-editor.org/info/rfc4291>.\n
      \  [RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n
      \             Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n
      \             <https://www.rfc-editor.org/info/rfc5116>.\n   [RFC5280]  Cooper,
      D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and
      W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC5297]  Harkins, D., \"Synthetic Initialization Vector (SIV)\n              Authenticated
      Encryption Using the Advanced Encryption\n              Standard (AES)\", RFC
      5297, DOI 10.17487/RFC5297, October\n              2008, <https://www.rfc-editor.org/info/rfc5297>.\n
      \  [RFC5705]  Rescorla, E., \"Keying Material Exporters for Transport\n              Layer
      Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n              March 2010,
      <https://www.rfc-editor.org/info/rfc5705>.\n   [RFC5869]  Krawczyk, H. and P.
      Eronen, \"HMAC-based Extract-and-Expand\n              Key Derivation Function
      (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869, May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n
      \  [RFC5890]  Klensin, J., \"Internationalized Domain Names for\n              Applications
      (IDNA): Definitions and Document Framework\",\n              RFC 5890, DOI 10.17487/RFC5890,
      August 2010,\n              <https://www.rfc-editor.org/info/rfc5890>.\n   [RFC5905]
      \ Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network
      Time Protocol Version 4: Protocol and Algorithms\n              Specification\",
      RFC 5905, DOI 10.17487/RFC5905, June 2010,\n              <https://www.rfc-editor.org/info/rfc5905>.\n
      \  [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125, March\n              2011, <https://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire,
      \"Internet Assigned Numbers Authority (IANA)\n              Procedures for the
      Management of the Service Name and\n              Transport Protocol Port Number
      Registry\", BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n
      \             <https://www.rfc-editor.org/info/rfc6335>.\n   [RFC6874]  Carpenter,
      B., Cheshire, S., and R. Hinden, \"Representing\n              IPv6 Zone Identifiers
      in Address Literals and Uniform\n              Resource Identifiers\", RFC 6874,
      DOI 10.17487/RFC6874,\n              February 2013, <https://www.rfc-editor.org/info/rfc6874>.\n
      \  [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,\n              \"Transport
      Layer Security (TLS) Application-Layer Protocol\n              Negotiation Extension\",
      RFC 7301, DOI 10.17487/RFC7301,\n              July 2014, <https://www.rfc-editor.org/info/rfc7301>.\n
      \  [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
      May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC7822]
      \ Mizrahi, T. and D. Mayer, \"Network Time Protocol Version 4\n              (NTPv4)
      Extension Fields\", RFC 7822, DOI 10.17487/RFC7822,\n              March 2016,
      <https://www.rfc-editor.org/info/rfc7822>.\n   [RFC8174]  Leiba, B., \"Ambiguity
      of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC
      8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n
      \  [RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n
      \             Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n
      \             <https://www.rfc-editor.org/info/rfc8446>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [Mizrahi]  Mizrahi, T., \"A game theoretic
      analysis of delay attacks\n              against time synchronization protocols\",
      2012 IEEE\n              International Symposium on Precision Clock Synchronization\n
      \             for Measurement, Control and Communication Proceedings,\n              pp.
      1-6, DOI 10.1109/ISPCS.2012.6336612, September 2012,\n              <https://doi.org/10.1109/ISPCS.2012.6336612>.\n
      \  [NTP-DATA-MIN]\n              Franke, D. F. and A. Malhotra, \"NTP Client
      Data\n              Minimization\", Work in Progress, Internet-Draft, draft-\n
      \             ietf-ntp-data-minimization-04, 25 March 2019,\n              <https://tools.ietf.org/html/draft-ietf-ntp-data-\n
      \             minimization-04>.\n   [RFC4086]  Eastlake 3rd, D., Schiller, J.,
      and S. Crocker,\n              \"Randomness Requirements for Security\", BCP
      106, RFC 4086,\n              DOI 10.17487/RFC4086, June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n
      \  [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,\n              \"Transport
      Layer Security (TLS) Session Resumption without\n              Server-Side State\",
      RFC 5077, DOI 10.17487/RFC5077,\n              January 2008, <https://www.rfc-editor.org/info/rfc5077>.\n
      \  [RFC7384]  Mizrahi, T., \"Security Requirements of Time Protocols in\n              Packet
      Switched Networks\", RFC 7384, DOI 10.17487/RFC7384,\n              October
      2014, <https://www.rfc-editor.org/info/rfc7384>.\n   [RFC8573]  Malhotra, A.
      and S. Goldberg, \"Message Authentication Code\n              for the Network
      Time Protocol\", RFC 8573,\n              DOI 10.17487/RFC8573, June 2019,\n
      \             <https://www.rfc-editor.org/info/rfc8573>.\n   [Shpiner]  Shpiner,
      A., Revah, Y., and T. Mizrahi, \"Multi-path Time\n              Protocols\",
      2013 IEEE International Symposium on Precision\n              Clock Synchronization
      for Measurement, Control and\n              Communication (ISPCS) Proceedings,
      pp. 1-6,\n              DOI 10.1109/ISPCS.2013.6644754, September 2013,\n              <https://doi.org/10.1109/ISPCS.2013.6644754>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Acknowledgments\n   The authors would like to thank Richard Barnes, Steven Bellovin,\n
    \  Scott Fluhrer, Patrik F\xE4ltstr\xF6m, Sharon Goldberg, Russ Housley,\n   Benjamin
    Kaduk, Suresh Krishnan, Mirja K\xFChlewind, Martin Langer,\n   Barry Leiba, Miroslav
    Lichvar, Aanchal Malhotra, Danny Mayer, Dave\n   Mills, Sandra Murphy, Hal Murray,
    Karen O'Donoghue, Eric K. Rescorla,\n   Kurt Roeckx, Stephen Roettger, Dan Romascanu,
    Kyle Rose, Rich Salz,\n   Brian Sniffen, Susan Sons, Douglas Stebila, Harlan Stenn,
    Joachim\n   Str\xF6mbergsson, Martin Thomson, \xC9ric Vyncke, Richard Welty, Christer\n
    \  Weinigel, and Magnus Westerlund for contributions to this document\n   and
    comments on the design of NTS.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Daniel Fox Franke\n   Akamai Technologies\n   145 Broadway\n
    \  Cambridge, MA 02142\n   United States of America\n   Email: dafranke@akamai.com\n
    \  Dieter Sibold\n   Physikalisch-Technische Bundesanstalt\n   Bundesallee 100\n
    \  D-38116 Braunschweig\n   Germany\n   Phone: +49-(0)531-592-8462\n   Email:
    dieter.sibold@ptb.de\n   Kristof Teichel\n   Physikalisch-Technische Bundesanstalt\n
    \  Bundesallee 100\n   D-38116 Braunschweig\n   Germany\n   Phone: +49-(0)531-592-4471\n
    \  Email: kristof.teichel@ptb.de\n   Marcus Dansarie\n   Sweden\n   Email: marcus@dansarie.se\n
    \  URI:   https://orcid.org/0000-0001-9246-0263\n   Ragnar Sundblad\n   Netnod\n"
  title: Authors' Addresses
