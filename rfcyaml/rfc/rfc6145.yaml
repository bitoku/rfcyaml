- title: __initial_text__
  contents:
  - '                     IP/ICMP Translation Algorithm

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Stateless IP/ICMP Translation Algorithm\n\
    \   (SIIT), which translates between IPv4 and IPv6 packet headers\n   (including\
    \ ICMP headers).  This document obsoletes RFC 2765.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6145.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Motivation  . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  IPv4-IPv6 Translation Model  . . . . . . . . . .\
    \ . . . . .  3\n     1.2.  Applicability and Limitations  . . . . . . . . . .\
    \ . . . .  3\n     1.3.  Stateless vs. Stateful Mode  . . . . . . . . . . . .\
    \ . . .  4\n     1.4.  Path MTU Discovery and Fragmentation . . . . . . . . .\
    \ . .  5\n   2.  Changes from RFC 2765  . . . . . . . . . . . . . . . . . . .\
    \ .  5\n   3.  Conventions  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  6\n   4.  Translating from IPv4 to IPv6  . . . . . . . . . . . . . . . .  6\n\
    \     4.1.  Translating IPv4 Headers into IPv6 Headers . . . . . . . .  7\n  \
    \   4.2.  Translating ICMPv4 Headers into ICMPv6 Headers . . . . . . 10\n    \
    \ 4.3.  Translating ICMPv4 Error Messages into ICMPv6  . . . . . . 13\n     4.4.\
    \  Generation of ICMPv4 Error Message . . . . . . . . . . . . 14\n     4.5.  Transport-Layer\
    \ Header Translation . . . . . . . . . . . . 14\n     4.6.  Knowing When to Translate\
    \  . . . . . . . . . . . . . . . . 15\n   5.  Translating from IPv6 to IPv4  .\
    \ . . . . . . . . . . . . . . . 15\n     5.1.  Translating IPv6 Headers into IPv4\
    \ Headers . . . . . . . . 17\n       5.1.1.  IPv6 Fragment Processing . . . .\
    \ . . . . . . . . . . . 19\n     5.2.  Translating ICMPv6 Headers into ICMPv4\
    \ Headers . . . . . . 20\n     5.3.  Translating ICMPv6 Error Messages into ICMPv4\
    \  . . . . . . 22\n     5.4.  Generation of ICMPv6 Error Messages  . . . . . .\
    \ . . . . . 23\n     5.5.  Transport-Layer Header Translation . . . . . . . .\
    \ . . . . 24\n     5.6.  Knowing When to Translate  . . . . . . . . . . . . .\
    \ . . . 24\n   6.  Special Considerations for ICMPv6 Packet Too Big . . . . .\
    \ . . 24\n   7.  Security Considerations  . . . . . . . . . . . . . . . . . .\
    \ . 25\n   8.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . .\
    \ 26\n   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\
    \     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 26\n  \
    \   9.2.  Informative References . . . . . . . . . . . . . . . . . . 28\n   Appendix\
    \ A.  Stateless Translation Workflow Example  . . . . . . . 30\n     A.1.  H6\
    \ Establishes Communication with H4 . . . . . . . . . . . 30\n     A.2.  H4 Establishes\
    \ Communication with H6 . . . . . . . . . . . 32\n"
- title: 1.  Introduction and Motivation
  contents:
  - "1.  Introduction and Motivation\n   This document is a product of the 2008-2010\
    \ effort to define a\n   replacement for NAT-PT [RFC2766] (which was changed to\
    \ Historic\n   status when [RFC4966] was published in 2007).  It is directly derived\n\
    \   from Erik Nordmark's \"Stateless IP/ICMP Translation Algorithm (SIIT)\"\n\
    \   [RFC2765], which provides stateless translation between IPv4\n   [RFC0791]\
    \ and IPv6 [RFC2460], and between ICMPv4 [RFC0792] and ICMPv6\n   [RFC4443]. \
    \ This document obsoletes RFC 2765 [RFC2765].  The changes\n   from RFC 2765 [RFC2765]\
    \ are listed in Section 2.\n   Readers of this document are expected to have read\
    \ and understood the\n   framework described in [RFC6144].  Implementations of\
    \ this IPv4/IPv6\n   translation specification MUST also support the address translation\n\
    \   algorithms in [RFC6052].  Implementations MAY also support stateful\n   translation\
    \ [RFC6146].\n"
- title: 1.1.  IPv4-IPv6 Translation Model
  contents:
  - "1.1.  IPv4-IPv6 Translation Model\n   The translation model consists of two or\
    \ more network domains\n   connected by one or more IP/ICMP translators (XLATs)\
    \ as shown in\n   Figure 1.\n                ---------          ---------\n  \
    \            //        \\\\       //         \\\\\n            /             +----+\
    \              \\\n           |              |XLAT|               | XLAT: IP/ICMP\n\
    \           |   IPv4       +----+   IPv6        |       Translator\n         \
    \  |   Domain     |    |   Domain      |\n           |              |    |   \
    \            |\n            \\             |    |              /\n           \
    \  \\\\         //      \\\\          //\n                --------          ---------\n\
    \                   Figure 1: IPv4-IPv6 Translation Model\n   The scenarios of\
    \ the translation model are discussed in [RFC6144].\n"
- title: 1.2.  Applicability and Limitations
  contents:
  - "1.2.  Applicability and Limitations\n   This document specifies the translation\
    \ algorithms between IPv4\n   packets and IPv6 packets.\n   As with [RFC2765],\
    \ the translating function specified in this\n   document does not translate any\
    \ IPv4 options, and it does not\n   translate IPv6 extension headers except the\
    \ Fragment Header.\n   The issues and algorithms in the translation of datagrams\
    \ containing\n   TCP segments are described in [RFC5382].\n   Fragmented IPv4\
    \ UDP packets that do not contain a UDP checksum (i.e.,\n   the UDP checksum field\
    \ is zero) are not of significant use in the\n   Internet, and in general will\
    \ not be translated by the IP/ICMP\n   translator.  However, when the translator\
    \ is configured to forward\n   the packet without a UDP checksum, the fragmented\
    \ IPv4 UDP packets\n   will be translated.\n   Fragmented ICMP/ICMPv6 packets\
    \ will not be translated by the IP/ICMP\n   translator.\n   The IP/ICMP header\
    \ translation specified in this document is\n   consistent with requirements of\
    \ multicast IP/ICMP headers.  However,\n   IPv4 multicast addresses [RFC5771]\
    \ cannot be mapped to IPv6 multicast\n   addresses [RFC3307] based on the unicast\
    \ mapping rule [RFC6052].\n"
- title: 1.3.  Stateless vs. Stateful Mode
  contents:
  - "1.3.  Stateless vs. Stateful Mode\n   An IP/ICMP translator has two possible\
    \ modes of operation: stateless\n   and stateful [RFC6144].  In both cases, we\
    \ assume that a system (a\n   node or an application) that has an IPv4 address\
    \ but not an IPv6\n   address is communicating with a system that has an IPv6\
    \ address but\n   no IPv4 address, or that the two systems do not have contiguous\n\
    \   routing connectivity and hence are forced to have their\n   communications\
    \ translated.\n   In the stateless mode, a specific IPv6 address range will represent\n\
    \   IPv4 systems (IPv4-converted addresses), and the IPv6 systems have\n   addresses\
    \ (IPv4-translatable addresses) that can be algorithmically\n   mapped to a subset\
    \ of the service provider's IPv4 addresses.  Note\n   that IPv4-translatable addresses\
    \ are a subset of IPv4-converted\n   addresses.  In general, there is no need\
    \ to concern oneself with\n   translation tables, as the IPv4 and IPv6 counterparts\
    \ are\n   algorithmically related.\n   In the stateful mode, a specific IPv6 address\
    \ range will represent\n   IPv4 systems (IPv4-converted addresses), but the IPv6\
    \ systems may use\n   any IPv6 addresses [RFC4291] except in that range.  In this\
    \ case, a\n   translation table is required to bind the IPv6 systems' addresses\
    \ to\n   the IPv4 addresses maintained in the translator.\n   The address translation\
    \ mechanisms for the stateless and the stateful\n   translations are defined in\
    \ [RFC6052].\n"
- title: 1.4.  Path MTU Discovery and Fragmentation
  contents:
  - "1.4.  Path MTU Discovery and Fragmentation\n   Due to the different sizes of\
    \ the IPv4 and IPv6 header, which are 20+\n   octets and 40 octets respectively,\
    \ handling the maximum packet size\n   is critical for the operation of the IPv4/IPv6\
    \ translator.  There are\n   three mechanisms to handle this issue: path MTU discovery\
    \ (PMTUD),\n   fragmentation, and transport-layer negotiation such as the TCP\n\
    \   Maximum Segment Size (MSS) option [RFC0879].  Note that the\n   translator\
    \ MUST behave as a router, i.e., the translator MUST send a\n   Packet Too Big\
    \ error message or fragment the packet when the packet\n   size exceeds the MTU\
    \ of the next-hop interface.\n   Don't Fragment, ICMP Packet Too Big, and packet\
    \ fragmentation are\n   discussed in Sections 4 and 5 of this document.  The reassembling\
    \ of\n   fragmented packets in the stateful translator is discussed in\n   [RFC6146],\
    \ since it requires state maintenance in the translator.\n"
- title: 2.  Changes from RFC 2765
  contents:
  - "2.  Changes from RFC 2765\n   The changes from RFC 2765 are the following:\n\
    \   1.  Redescribing the network model to map to present and projected\n     \
    \  usage.  The scenarios, applicability, and limitations originally\n       presented\
    \ in RFC 2765 [RFC2765] are moved to the framework\n       document [RFC6144].\n\
    \   2.  Moving the address format to the address format document\n       [RFC6052],\
    \ to coordinate with other documents on the topic.\n   3.  Describing the header\
    \ translation for the stateless and stateful\n       operations.  The details\
    \ of the session database and mapping\n       table handling of the stateful translation\
    \ is in the stateful\n       translation document [RFC6146].\n   4.  Having refined\
    \ the header translation, fragmentation handling,\n       ICMP translation and\
    \ ICMP error translation in the IPv4-to-IPv6\n       direction, as well as the\
    \ IPv6-to-IPv4 direction.\n   5.  Adding more discussion on transport-layer header\
    \ translation.\n   6.  Adding Section 5.1.1 for \"IPv6 Fragment Processing\".\n\
    \   7.  Adding Section 6 for \"Special Considerations for ICMPv6 Packet\n    \
    \   Too Big\".\n   8.  Updating Section 7 for \"Security Considerations\".\n \
    \  9.  Adding Appendix A \"Stateless translation workflow example\".\n"
- title: 3.  Conventions
  contents:
  - "3.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 4.  Translating from IPv4 to IPv6
  contents:
  - "4.  Translating from IPv4 to IPv6\n   When an IP/ICMP translator receives an\
    \ IPv4 datagram addressed to a\n   destination towards the IPv6 domain, it translates\
    \ the IPv4 header of\n   that packet into an IPv6 header.  The original IPv4 header\
    \ on the\n   packet is removed and replaced by an IPv6 header, and the transport\n\
    \   checksum is updated as needed, if that transport is supported by the\n   translator.\
    \  The data portion of the packet is left unchanged.  The\n   IP/ICMP translator\
    \ then forwards the packet based on the IPv6\n   destination address.\n      \
    \        +-------------+                 +-------------+\n              |    IPv4\
    \     |                 |    IPv6     |\n              |   Header    |       \
    \          |   Header    |\n              +-------------+                 +-------------+\n\
    \              |  Transport- |                 |  Fragment   |\n             \
    \ |   Layer     |      ===>       |   Header    |\n              |   Header  \
    \  |                 | (if needed) |\n              +-------------+          \
    \       +-------------+\n              |             |                 |  Transport-\
    \ |\n              ~    Data     ~                 |   Layer     |\n         \
    \     |             |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n                                          \
    \    |             |\n                                              ~    Data\
    \     ~\n                                              |             |\n     \
    \                                         +-------------+\n                  \
    \  Figure 2: IPv4-to-IPv6 Translation\n   Path MTU discovery is mandatory in IPv6,\
    \ but it is optional in IPv4.\n   IPv6 routers never fragment a packet -- only\
    \ the sender can do\n   fragmentation.\n   When an IPv4 node performs path MTU\
    \ discovery (by setting the Don't\n   Fragment (DF) bit in the header), path MTU\
    \ discovery can operate end-\n   to-end, i.e., across the translator.  In this\
    \ case, either IPv4 or\n   IPv6 routers (including the translator) might send\
    \ back ICMP Packet\n   Too Big messages to the sender.  When the IPv6 routers\
    \ send these\n   ICMPv6 errors, they will pass through a translator that will\n\
    \   translate the ICMPv6 error to a form that the IPv4 sender can\n   understand.\
    \  As a result, an IPv6 Fragment Header is only included if\n   the IPv4 packet\
    \ is already fragmented.\n   However, when the IPv4 sender does not set the DF\
    \ bit, the translator\n   MUST ensure that the packet does not exceed the path\
    \ MTU on the IPv6\n   side.  This is done by fragmenting the IPv4 packet (with\
    \ Fragment\n   Headers) so that it fits in 1280-byte IPv6 packets, since that\
    \ is the\n   minimum IPv6 MTU.  The IPv6 Fragment Header has been shown to cause\n\
    \   operational difficulties in practice due to limited firewall\n   fragmentation\
    \ support, etc.  In an environment where the network\n   owned/operated by the\
    \ same entity that owns/operates the translator,\n   the translator MAY provide\
    \ a configuration function for the network\n   administrator to adjust the threshold\
    \ of the minimum IPv6 MTU to a\n   value that reflects the real value of the minimum\
    \ IPv6 MTU in the\n   network (greater than 1280 bytes).  This will help reduce\
    \ the chance\n   of including the Fragment Header in the packets.\n   When the\
    \ IPv4 sender does not set the DF bit, the translator SHOULD\n   always include\
    \ an IPv6 Fragment Header to indicate that the sender\n   allows fragmentation.\
    \  The translator MAY provide a configuration\n   function that allows the translator\
    \ not to include the Fragment\n   Header for the non-fragmented IPv6 packets.\n\
    \   The rules in Section 4.1 ensure that when packets are fragmented,\n   either\
    \ by the sender or by IPv4 routers, the low-order 16 bits of the\n   fragment\
    \ identification are carried end-to-end, ensuring that packets\n   are correctly\
    \ reassembled.  In addition, the rules in Section 4.1 use\n   the presence of\
    \ an IPv6 Fragment Header to indicate that the sender\n   might not be using path\
    \ MTU discovery (i.e., the packet should not\n   have the DF flag set should it\
    \ later be translated back to IPv4).\n   Other than the special rules for handling\
    \ fragments and path MTU\n   discovery, the actual translation of the packet header\
    \ consists of a\n   simple translation as defined below.  Note that ICMPv4 packets\n\
    \   require special handling in order to translate the content of ICMPv4\n   error\
    \ messages and also to add the ICMPv6 pseudo-header checksum.\n   The translator\
    \ SHOULD make sure that the packets belonging to the\n   same flow leave the translator\
    \ in the same order in which they\n   arrived.\n"
- title: 4.1.  Translating IPv4 Headers into IPv6 Headers
  contents:
  - "4.1.  Translating IPv4 Headers into IPv6 Headers\n   If the DF flag is not set\
    \ and the IPv4 packet will result in an IPv6\n   packet larger than 1280 bytes,\
    \ the packet SHOULD be fragmented so the\n   resulting IPv6 packet (with Fragment\
    \ Header added to each fragment)\n   will be less than or equal to 1280 bytes.\
    \  For example, if the packet\n   is fragmented prior to the translation, the\
    \ IPv4 packets should be\n   fragmented so that their length, excluding the IPv4\
    \ header, is at\n   most 1232 bytes (1280 minus 40 for the IPv6 header and 8 for\
    \ the\n   Fragment Header).  The translator MAY provide a configuration\n   function\
    \ for the network administrator to adjust the threshold of the\n   minimum IPv6\
    \ MTU to a value greater than 1280-byte if the real value\n   of the minimum IPv6\
    \ MTU in the network is known to the administrator.\n   The resulting fragments\
    \ are then translated independently using the\n   logic described below.\n   If\
    \ the DF bit is set and the MTU of the next-hop interface is less\n   than the\
    \ total length value of the IPv4 packet plus 20, the\n   translator MUST send\
    \ an ICMPv4 \"Fragmentation Needed\" error message\n   to the IPv4 source address.\n\
    \   If the DF bit is set and the packet is not a fragment (i.e., the More\n  \
    \ Fragments (MF) flag is not set and the Fragment Offset is equal to\n   zero),\
    \ then the translator SHOULD NOT add a Fragment Header to the\n   resulting packet.\
    \  The IPv6 header fields are set as follows:\n   Version:  6\n   Traffic Class:\
    \  By default, copied from the IP Type Of Service (TOS)\n      octet.  According\
    \ to [RFC2474], the semantics of the bits are\n      identical in IPv4 and IPv6.\
    \  However, in some IPv4 environments\n      these fields might be used with the\
    \ old semantics of \"Type Of\n      Service and Precedence\".  An implementation\
    \ of a translator SHOULD\n      support an administratively configurable option\
    \ to ignore the IPv4\n      TOS and always set the IPv6 traffic class (TC) to\
    \ zero.  In\n      addition, if the translator is at an administrative boundary,\
    \ the\n      filtering and update considerations of [RFC2475] may be\n      applicable.\n\
    \   Flow Label:  0 (all zero bits)\n   Payload Length:  Total length value from\
    \ the IPv4 header, minus the\n      size of the IPv4 header and IPv4 options,\
    \ if present.\n   Next Header:  For ICMPv4 (1), it is changed to ICMPv6 (58);\n\
    \      otherwise, the protocol field MUST be copied from the IPv4 header.\n  \
    \ Hop Limit:  The hop limit is derived from the TTL value in the IPv4\n      header.\
    \  Since the translator is a router, as part of forwarding\n      the packet it\
    \ needs to decrement either the IPv4 TTL (before the\n      translation) or the\
    \ IPv6 Hop Limit (after the translation).  As\n      part of decrementing the\
    \ TTL or Hop Limit, the translator (as any\n      router) MUST check for zero\
    \ and send the ICMPv4 \"TTL Exceeded\" or\n      ICMPv6 \"Hop Limit Exceeded\"\
    \ error.\n   Source Address:  The IPv4-converted address derived from the IPv4\n\
    \      source address per [RFC6052], Section 2.3.\n      If the translator gets\
    \ an illegal source address (e.g., 0.0.0.0,\n      127.0.0.1, etc.), the translator\
    \ SHOULD silently drop the packet\n      (as discussed in Section 5.3.7 of [RFC1812]).\n\
    \   Destination Address:  In the stateless mode, which is to say that if\n   \
    \   the IPv4 destination address is within a range of configured IPv4\n      stateless\
    \ translation prefix, the IPv6 destination address is the\n      IPv4-translatable\
    \ address derived from the IPv4 destination\n      address per [RFC6052], Section\
    \ 2.3.  A workflow example of\n      stateless translation is shown in Appendix\
    \ A of this document.\n      In the stateful mode (which is to say that if the\
    \ IPv4 destination\n      address is not within the range of any configured IPv4\
    \ stateless\n      translation prefix), the IPv6 destination address and\n   \
    \   corresponding transport-layer destination port are derived from\n      the\
    \ Binding Information Bases (BIBs) reflecting current session\n      state in\
    \ the translator as described in [RFC6146].\n   If any IPv4 options are present\
    \ in the IPv4 packet, they MUST be\n   ignored and the packet translated normally;\
    \ there is no attempt to\n   translate the options.  However, if an unexpired\
    \ source route option\n   is present then the packet MUST instead be discarded,\
    \ and an ICMPv4\n   \"Destination Unreachable, Source Route Failed\" (Type 3,\
    \ Code 5) error\n   message SHOULD be returned to the sender.\n   If there is\
    \ a need to add a Fragment Header (the DF bit is not set or\n   the packet is\
    \ a fragment), the header fields are set as above with\n   the following exceptions:\n\
    \   IPv6 fields:\n      Payload Length:  Total length value from the IPv4 header,\
    \ plus 8\n         for the Fragment Header, minus the size of the IPv4 header\
    \ and\n         IPv4 options, if present.\n      Next Header:  Fragment Header\
    \ (44).\n   Fragment Header fields:\n      Next Header:  For ICMPv4 (1), it is\
    \ changed to ICMPv6 (58);\n         otherwise, the protocol field MUST be copied\
    \ from the IPv4\n         header.\n      Fragment Offset:  Fragment Offset copied\
    \ from the IPv4 header.\n      M flag:  More Fragments bit copied from the IPv4\
    \ header.\n      Identification:  The low-order 16 bits copied from the\n    \
    \     Identification field in the IPv4 header.  The high-order 16\n         bits\
    \ set to zero.\n"
- title: 4.2.  Translating ICMPv4 Headers into ICMPv6 Headers
  contents:
  - "4.2.  Translating ICMPv4 Headers into ICMPv6 Headers\n   All ICMPv4 messages\
    \ that are to be translated require that the ICMPv6\n   checksum field be calculated\
    \ as part of the translation since ICMPv6,\n   unlike ICMPv4, has a pseudo-header\
    \ checksum just like UDP and TCP.\n   In addition, all ICMPv4 packets MUST have\
    \ the Type translated and,\n   for ICMPv4 error messages, the included IP header\
    \ also MUST be\n   translated.\n   The actions needed to translate various ICMPv4\
    \ messages are as\n   follows:\n   ICMPv4 query messages:\n      Echo and Echo\
    \ Reply (Type 8 and Type 0):  Adjust the Type values\n         to 128 and 129,\
    \ respectively, and adjust the ICMP checksum both\n         to take the type change\
    \ into account and to include the ICMPv6\n         pseudo-header.\n      Information\
    \ Request/Reply (Type 15 and Type 16):  Obsoleted in\n         ICMPv6.  Silently\
    \ drop.\n      Timestamp and Timestamp Reply (Type 13 and Type 14):  Obsoleted\
    \ in\n         ICMPv6.  Silently drop.\n      Address Mask Request/Reply (Type\
    \ 17 and Type 18):  Obsoleted in\n         ICMPv6.  Silently drop.\n      ICMP\
    \ Router Advertisement (Type 9):  Single-hop message.  Silently\n         drop.\n\
    \      ICMP Router Solicitation (Type 10):  Single-hop message.  Silently\n  \
    \       drop.\n      Unknown ICMPv4 types:  Silently drop.\n      IGMP messages:\
    \  While the Multicast Listener Discovery (MLD)\n         messages [RFC2710] [RFC3590]\
    \ [RFC3810] are the logical IPv6\n         counterparts for the IPv4 IGMP messages,\
    \ all the \"normal\" IGMP\n         messages are single-hop messages and SHOULD\
    \ be silently dropped\n         by the translator.  Other IGMP messages might\
    \ be used by\n         multicast routing protocols and, since it would be a\n\
    \         configuration error to try to have router adjacencies across\n     \
    \    IP/ICMP translators, those packets SHOULD also be silently\n         dropped.\n\
    \       ICMPv4 error messages:\n         Destination Unreachable (Type 3):  Translate\
    \ the Code as\n            described below, set the Type to 1, and adjust the\
    \ ICMP\n            checksum both to take the type/code change into account and\n\
    \            to include the ICMPv6 pseudo-header.\n            Translate the Code\
    \ as follows:\n            Code 0, 1 (Net Unreachable, Host Unreachable):  Set\
    \ the Code\n               to 0 (No route to destination).\n            Code 2\
    \ (Protocol Unreachable):  Translate to an ICMPv6\n               Parameter Problem\
    \ (Type 4, Code 1) and make the Pointer\n               point to the IPv6 Next\
    \ Header field.\n            Code 3 (Port Unreachable):  Set the Code to 4 (Port\n\
    \               unreachable).\n            Code 4 (Fragmentation Needed and DF\
    \ was Set):  Translate to\n               an ICMPv6 Packet Too Big message (Type\
    \ 2) with Code set\n               to 0.  The MTU field MUST be adjusted for the\
    \ difference\n               between the IPv4 and IPv6 header sizes, i.e.,\n \
    \              minimum(advertised MTU+20, MTU_of_IPv6_nexthop,\n             \
    \  (MTU_of_IPv4_nexthop)+20).  Note that if the IPv4 router\n               set\
    \ the MTU field to zero, i.e., the router does not\n               implement [RFC1191],\
    \ then the translator MUST use the\n               plateau values specified in\
    \ [RFC1191] to determine a\n               likely path MTU and include that path\
    \ MTU in the ICMPv6\n               packet.  (Use the greatest plateau value that\
    \ is less\n               than the returned Total Length field.)\n           \
    \    See also the requirements in Section 6.\n            Code 5 (Source Route\
    \ Failed):  Set the Code to 0 (No route\n               to destination).  Note\
    \ that this error is unlikely since\n               source routes are not translated.\n\
    \            Code 6, 7, 8:  Set the Code to 0 (No route to destination).\n   \
    \         Code 9, 10 (Communication with Destination Host\n               Administratively\
    \ Prohibited):  Set the Code to 1\n               (Communication with destination\
    \ administratively\n               prohibited).\n            Code 11, 12:  Set\
    \ the Code to 0 (No route to destination).\n            Code 13 (Communication\
    \ Administratively Prohibited):  Set\n               the Code to 1 (Communication\
    \ with destination\n               administratively prohibited).\n           \
    \ Code 14 (Host Precedence Violation):  Silently drop.\n            Code 15 (Precedence\
    \ cutoff in effect):  Set the Code to 1\n               (Communication with destination\
    \ administratively\n               prohibited).\n            Other Code values:\
    \  Silently drop.\n         Redirect (Type 5):  Single-hop message.  Silently\
    \ drop.\n         Alternative Host Address (Type 6):  Silently drop.\n       \
    \  Source Quench (Type 4):  Obsoleted in ICMPv6.  Silently drop.\n         Time\
    \ Exceeded (Type 11):  Set the Type to 3, and adjust the\n            ICMP checksum\
    \ both to take the type change into account and\n            to include the ICMPv6\
    \ pseudo-header.  The Code is unchanged.\n         Parameter Problem (Type 12):\
    \  Set the Type to 4, and adjust the\n            ICMP checksum both to take the\
    \ type/code change into account\n            and to include the ICMPv6 pseudo-header.\n\
    \            Translate the Code as follows:\n            Code 0 (Pointer indicates\
    \ the error):  Set the Code to 0\n               (Erroneous header field encountered)\
    \ and update the\n               pointer as defined in Figure 3.  (If the Original\
    \ IPv4\n               Pointer Value is not listed or the Translated IPv6\n  \
    \             Pointer Value is listed as \"n/a\", silently drop the\n        \
    \       packet.)\n            Code 1 (Missing a required option):  Silently drop.\n\
    \            Code 2 (Bad length):  Set the Code to 0 (Erroneous header\n     \
    \          field encountered) and update the pointer as defined in\n         \
    \      Figure 3.  (If the Original IPv4 Pointer Value is not\n               listed\
    \ or the Translated IPv6 Pointer Value is listed as\n               \"n/a\", silently\
    \ drop the packet.)\n            Other Code values:  Silently drop.\n        \
    \ Unknown ICMPv4 types:  Silently drop.\n     +--------------------------------+--------------------------------+\n\
    \     |   Original IPv4 Pointer Value  | Translated IPv6 Pointer Value  |\n  \
    \   +--------------------------------+--------------------------------+\n    \
    \ |  0  | Version/IHL              |  0  | Version/Traffic Class    |\n     |\
    \  1  | Type Of Service          |  1  | Traffic Class/Flow Label |\n     | 2,3\
    \ | Total Length             |  4  | Payload Length           |\n     | 4,5 |\
    \ Identification           | n/a |                          |\n     |  6  | Flags/Fragment\
    \ Offset    | n/a |                          |\n     |  7  | Fragment Offset \
    \         | n/a |                          |\n     |  8  | Time to Live      \
    \       |  7  | Hop Limit                |\n     |  9  | Protocol            \
    \     |  6  | Next Header              |\n     |10,11| Header Checksum       \
    \   | n/a |                          |\n     |12-15| Source Address          \
    \ |  8  | Source Address           |\n     |16-19| Destination Address      |\
    \ 24  | Destination Address      |\n     +--------------------------------+--------------------------------+\n\
    \             Figure 3: Pointer Value for Translating from IPv4 to IPv6\n    \
    \     ICMP Error Payload:  If the received ICMPv4 packet contains an\n       \
    \     ICMPv4 Extension [RFC4884], the translation of the ICMPv4\n            packet\
    \ will cause the ICMPv6 packet to change length.  When\n            this occurs,\
    \ the ICMPv6 Extension length attribute MUST be\n            adjusted accordingly\
    \ (e.g., longer due to the translation\n            from IPv4 to IPv6).  If the\
    \ ICMPv4 Extension exceeds the\n            maximum size of an ICMPv6 message\
    \ on the outgoing interface,\n            the ICMPv4 extension SHOULD be simply\
    \ truncated.  For\n            extensions not defined in [RFC4884], the translator\
    \ passes\n            the extensions as opaque bit strings, and those containing\n\
    \            IPv4 address literals will not have those addresses\n           \
    \ translated to IPv6 address literals; this may cause problems\n            with\
    \ processing of those ICMP extensions.\n"
- title: 4.3.  Translating ICMPv4 Error Messages into ICMPv6
  contents:
  - "4.3.  Translating ICMPv4 Error Messages into ICMPv6\n   There are some differences\
    \ between the ICMPv4 and the ICMPv6 error\n   message formats as detailed above.\
    \  The ICMP error messages\n   containing the packet in error MUST be translated\
    \ just like a normal\n   IP packet.  If the translation of this \"packet in error\"\
    \ changes the\n   length of the datagram, the Total Length field in the outer\
    \ IPv6\n   header MUST be updated.\n              +-------------+            \
    \     +-------------+\n              |    IPv4     |                 |    IPv6\
    \     |\n              |   Header    |                 |   Header    |\n     \
    \         +-------------+                 +-------------+\n              |   ICMPv4\
    \    |                 |   ICMPv6    |\n              |   Header    |        \
    \         |   Header    |\n              +-------------+                 +-------------+\n\
    \              |    IPv4     |      ===>       |    IPv6     |\n             \
    \ |   Header    |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n              |   Partial   |             \
    \    |   Partial   |\n              |  Transport- |                 |  Transport-\
    \ |\n              |   Layer     |                 |   Layer     |\n         \
    \     |   Header    |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n               Figure 4: IPv4-to-IPv6 ICMP\
    \ Error Translation\n   The translation of the inner IP header can be done by\
    \ invoking the\n   function that translated the outer IP headers.  This process\
    \ MUST\n   stop at the first embedded header and drop the packet if it contains\n\
    \   more embedded headers.\n"
- title: 4.4.  Generation of ICMPv4 Error Message
  contents:
  - "4.4.  Generation of ICMPv4 Error Message\n   If the IPv4 packet is discarded,\
    \ then the translator SHOULD be able\n   to send back an ICMPv4 error message\
    \ to the original sender of the\n   packet, unless the discarded packet is itself\
    \ an ICMPv4 message.  The\n   ICMPv4 message, if sent, has a Type of 3 (Destination\
    \ Unreachable)\n   and a Code of 13 (Communication Administratively Prohibited),\
    \ unless\n   otherwise specified in this document or in [RFC6146].  The translator\n\
    \   SHOULD allow an administrator to configure whether the ICMPv4 error\n   messages\
    \ are sent, rate-limited, or not sent.\n"
- title: 4.5.  Transport-Layer Header Translation
  contents:
  - "4.5.  Transport-Layer Header Translation\n   If the address translation algorithm\
    \ is not checksum neutral (see\n   Section 4.1 of [RFC6052]), the recalculation\
    \ and updating of the\n   transport-layer headers that contain pseudo-headers\
    \ need to be\n   performed.  Translators MUST do this for TCP and ICMP packets\
    \ and for\n   UDP packets that contain a UDP checksum (i.e., the UDP checksum\
    \ field\n   is not zero).\n   For UDP packets that do not contain a UDP checksum\
    \ (i.e., the UDP\n   checksum field is zero), the translator SHOULD provide a\n\
    \   configuration function to allow:\n   1.  Dropping the packet and generating\
    \ a system management event that\n       specifies at least the IP addresses and\
    \ port numbers of the\n       packet.\n   2.  Calculating an IPv6 checksum and\
    \ forwarding the packet (which has\n       performance implications).\n      \
    \ A stateless translator cannot compute the UDP checksum of\n       fragmented\
    \ packets, so when a stateless translator receives the\n       first fragment\
    \ of a fragmented UDP IPv4 packet and the checksum\n       field is zero, the\
    \ translator SHOULD drop the packet and generate\n       a system management event\
    \ that specifies at least the IP\n       addresses and port numbers in the packet.\n\
    \       For a stateful translator, the handling of fragmented UDP IPv4\n     \
    \  packets with a zero checksum is discussed in [RFC6146]), Section\n       3.1.\n\
    \   Other transport protocols (e.g., DCCP) are OPTIONAL to support.  In\n   order\
    \ to ease debugging and troubleshooting, translators MUST forward\n   all transport\
    \ protocols as described in the \"Next Header\" step of\n   Section 4.1.\n"
- title: 4.6.  Knowing When to Translate
  contents:
  - "4.6.  Knowing When to Translate\n   If the IP/ICMP translator also provides a\
    \ normal forwarding function,\n   and the destination IPv4 address is reachable\
    \ by a more specific\n   route without translation, the translator MUST forward\
    \ it without\n   translating it.  Otherwise, when an IP/ICMP translator receives\
    \ an\n   IPv4 datagram addressed to an IPv4 destination representing a host in\n\
    \   the IPv6 domain, the packet MUST be translated to IPv6.\n"
- title: 5.  Translating from IPv6 to IPv4
  contents:
  - "5.  Translating from IPv6 to IPv4\n   When an IP/ICMP translator receives an\
    \ IPv6 datagram addressed to a\n   destination towards the IPv4 domain, it translates\
    \ the IPv6 header of\n   the received IPv6 packet into an IPv4 header.  The original\
    \ IPv6\n   header on the packet is removed and replaced by an IPv4 header.\n \
    \  Since the ICMPv6 [RFC4443], TCP [RFC0793], UDP [RFC0768], and DCCP\n   [RFC4340]\
    \ headers contain checksums that cover the IP header, if the\n   address mapping\
    \ algorithm is not checksum neutral, the checksum MUST\n   be evaluated before\
    \ translation and the ICMP and transport-layer\n   headers MUST be updated.  The\
    \ data portion of the packet is left\n   unchanged.  The IP/ICMP translator then\
    \ forwards the packet based on\n   the IPv4 destination address.\n           \
    \   +-------------+                 +-------------+\n              |    IPv6 \
    \    |                 |    IPv4     |\n              |   Header    |        \
    \         |   Header    |\n              +-------------+                 +-------------+\n\
    \              |  Fragment   |                 |  Transport  |\n             \
    \ |   Header    |      ===>       |   Layer     |\n              |(if present)\
    \ |                 |   Header    |\n              +-------------+           \
    \      +-------------+\n              |  Transport  |                 |      \
    \       |\n              |   Layer     |                 ~    Data     ~\n   \
    \           |   Header    |                 |             |\n              +-------------+\
    \                 +-------------+\n              |             |\n           \
    \   ~    Data     ~\n              |             |\n              +-------------+\n\
    \                    Figure 5: IPv6-to-IPv4 Translation\n   There are some differences\
    \ between IPv6 and IPv4 (in the areas of\n   fragmentation and the minimum link\
    \ MTU) that affect the translation.\n   An IPv6 link has to have an MTU of 1280\
    \ bytes or greater.  The\n   corresponding limit for IPv4 is 68 bytes.  Path MTU\
    \ discovery across\n   a translator relies on ICMP Packet Too Big messages being\
    \ received\n   and processed by IPv6 hosts, including an ICMP Packet Too Big that\n\
    \   indicates the MTU is less than the IPv6 minimum MTU.  This\n   requirement\
    \ is described in Section 5 of [RFC2460] (for IPv6's\n   1280-octet minimum MTU)\
    \ and Section 5 of [RFC1883] (for IPv6's\n   previous 576-octet minimum MTU).\n\
    \   In an environment where an ICMPv4 Packet Too Big message is\n   translated\
    \ to an ICMPv6 Packet Too Big message, and the ICMPv6 Packet\n   Too Big message\
    \ is successfully delivered to and correctly processed\n   by the IPv6 hosts (e.g.,\
    \ a network owned/operated by the same entity\n   that owns/operates the translator),\
    \ the translator can rely on IPv6\n   hosts sending subsequent packets to the\
    \ same IPv6 destination with\n   IPv6 Fragment Headers.  In such an environment,\
    \ when the translator\n   receives an IPv6 packet with a Fragment Header, the\
    \ translator SHOULD\n   generate the IPv4 packet with a cleared Don't Fragment\
    \ bit, and with\n   its identification value from the IPv6 Fragment Header, for\
    \ all of\n   the IPv6 fragments (MF=0 or MF=1).\n   In an environment where an\
    \ ICMPv4 Packet Too Big message is filtered\n   (by a network firewall or by the\
    \ host itself) or not correctly\n   processed by the IPv6 hosts, the IPv6 host\
    \ will never generate an\n   IPv6 packet with the IPv6 Fragment Header.  In such\
    \ an environment,\n   the translator SHOULD set the IPv4 Don't Fragment bit. \
    \ While setting\n   the Don't Fragment bit may create PMTUD black holes [RFC2923]\
    \ if\n   there are IPv4 links smaller than 1260 octets, this is considered\n \
    \  safer than causing IPv4 reassembly errors [RFC4963].\n   Other than the special\
    \ rules for handling fragments and path MTU\n   discovery, the actual translation\
    \ of the packet header consists of a\n   simple translation as defined below.\
    \  Note that ICMPv6 packets\n   require special handling in order to translate\
    \ the contents of ICMPv6\n   error messages and also to remove the ICMPv6 pseudo-header\
    \ checksum.\n   The translator SHOULD make sure that the packets belonging to\
    \ the\n   same flow leave the translator in the same order in which they\n   arrived.\n"
- title: 5.1.  Translating IPv6 Headers into IPv4 Headers
  contents:
  - "5.1.  Translating IPv6 Headers into IPv4 Headers\n   If there is no IPv6 Fragment\
    \ Header, the IPv4 header fields are set\n   as follows:\n   Version:  4\n   Internet\
    \ Header Length:  5 (no IPv4 options)\n   Type of Service (TOS) Octet:  By default,\
    \ copied from the IPv6\n      Traffic Class (all 8 bits).  According to [RFC2474],\
    \ the semantics\n      of the bits are identical in IPv4 and IPv6.  However, in\
    \ some IPv4\n      environments, these bits might be used with the old semantics\
    \ of\n      \"Type Of Service and Precedence\".  An implementation of a\n    \
    \  translator SHOULD provide the ability to ignore the IPv6 traffic\n      class\
    \ and always set the IPv4 TOS Octet to a specified value.  In\n      addition,\
    \ if the translator is at an administrative boundary, the\n      filtering and\
    \ update considerations of [RFC2475] may be\n      applicable.\n   Total Length:\
    \  Payload length value from the IPv6 header, plus the\n      size of the IPv4\
    \ header.\n   Identification:  All zero.  In order to avoid black holes caused\
    \ by\n      ICMPv4 filtering or non-[RFC2460]-compatible IPv6 hosts (a\n     \
    \ workaround is discussed in Section 6), the translator MAY provide\n      a function\
    \ to generate the identification value if the packet size\n      is greater than\
    \ 88 bytes and less than or equal to 1280 bytes.\n      The translator SHOULD\
    \ provide a method for operators to enable or\n      disable this function.\n\
    \   Flags:  The More Fragments flag is set to zero.  The Don't Fragment\n    \
    \  (DF) flag is set to one.  In order to avoid black holes caused by\n      ICMPv4\
    \ filtering or non-[RFC2460]-compatible IPv6 hosts (a\n      workaround is discussed\
    \ in Section 6), the translator MAY provide\n      a function as follows.  If\
    \ the packet size is greater than 88\n      bytes and less than or equal to 1280\
    \ bytes, it sets the DF flag to\n      zero; otherwise, it sets the DF flag to\
    \ one.  The translator\n      SHOULD provide a method for operators to enable\
    \ or disable this\n      function.\n   Fragment Offset:  All zeros.\n   Time to\
    \ Live:  Time to Live is derived from Hop Limit value in IPv6\n      header. \
    \ Since the translator is a router, as part of forwarding\n      the packet it\
    \ needs to decrement either the IPv6 Hop Limit (before\n      the translation)\
    \ or the IPv4 TTL (after the translation).  As part\n      of decrementing the\
    \ TTL or Hop Limit the translator (as any\n      router) MUST check for zero and\
    \ send the ICMPv4 \"TTL Exceeded\" or\n      ICMPv6 \"Hop Limit Exceeded\" error.\n\
    \   Protocol:  The IPv6-Frag (44) header is handled as discussed in\n      Section\
    \ 5.1.1.  ICMPv6 (58) is changed to ICMPv4 (1), and the\n      payload is translated\
    \ as discussed in Section 5.2.  The IPv6\n      headers HOPOPT (0), IPv6-Route\
    \ (43), and IPv6-Opts (60) are\n      skipped over during processing as they have\
    \ no meaning in IPv4.\n      For the first 'next header' that does not match one\
    \ of the cases\n      above, its Next Header value (which contains the transport\n\
    \      protocol number) is copied to the protocol field in the IPv4\n      header.\
    \  This means that all transport protocols are translated.\n      Note:  Some\
    \ translated protocols will fail at the receiver for\n         various reasons:\
    \ some are known to fail when translated (e.g.,\n         IPsec Authentication\
    \ Header (51)), and others will fail\n         checksum validation if the address\
    \ translation is not checksum\n         neutral [RFC6052] and the translator does\
    \ not update the\n         transport protocol's checksum (because the translator\
    \ doesn't\n         support recalculating the checksum for that transport protocol;\n\
    \         see Section 5.5).\n   Header Checksum:  Computed once the IPv4 header\
    \ has been created.\n   Source Address:  In the stateless mode (which is to say\
    \ that if the\n      IPv6 source address is within the range of a configured IPv6\n\
    \      translation prefix), the IPv4 source address is derived from the\n    \
    \  IPv6 source address per [RFC6052], Section 2.3.  Note that the\n      original\
    \ IPv6 source address is an IPv4-translatable address.  A\n      workflow example\
    \ of stateless translation is shown in Appendix A\n      of this document.  If\
    \ the translator only supports stateless mode\n      and if the IPv6 source address\
    \ is not within the range of\n      configured IPv6 prefix(es), the translator\
    \ SHOULD drop the packet\n      and respond with an ICMPv6 \"Destination Unreachable,\
    \ Source\n      address failed ingress/egress policy\" (Type 1, Code 5).\n   \
    \   In the stateful mode, which is to say that if the IPv6 source\n      address\
    \ is not within the range of any configured IPv6 stateless\n      translation\
    \ prefix, the IPv4 source address and transport-layer\n      source port corresponding\
    \ to the IPv4-related IPv6 source address\n      and source port are derived from\
    \ the Binding Information Bases\n      (BIBs) as described in [RFC6146].\n   \
    \   In stateless and stateful modes, if the translator gets an illegal\n     \
    \ source address (e.g., ::1, etc.), the translator SHOULD silently\n      drop\
    \ the packet.\n   Destination Address:  The IPv4 destination address is derived\
    \ from\n      the IPv6 destination address of the datagram being translated per\n\
    \      [RFC6052], Section 2.3.  Note that the original IPv6 destination\n    \
    \  address is an IPv4-converted address.\n   If a Routing header with a non-zero\
    \ Segments Left field is present,\n   then the packet MUST NOT be translated,\
    \ and an ICMPv6 \"parameter\n   problem/erroneous header field encountered\" (Type\
    \ 4, Code 0) error\n   message, with the Pointer field indicating the first byte\
    \ of the\n   Segments Left field, SHOULD be returned to the sender.\n"
- title: 5.1.1.  IPv6 Fragment Processing
  contents:
  - "5.1.1.  IPv6 Fragment Processing\n   If the IPv6 packet contains a Fragment Header,\
    \ the header fields are\n   set as above with the following exceptions:\n   Total\
    \ Length:  Payload length value from IPv6 header, minus 8 for the\n      Fragment\
    \ Header, plus the size of the IPv4 header.\n   Identification:  Copied from the\
    \ low-order 16 bits in the\n      Identification field in the Fragment Header.\n\
    \   Flags:  The IPv4 More Fragments (MF) flag is copied from the M flag\n    \
    \  in the IPv6 Fragment Header.  The IPv4 Don't Fragment (DF) flag is\n      cleared\
    \ (set to zero), allowing this packet to be further\n      fragmented by IPv4\
    \ routers.\n   Fragment Offset:  Copied from the Fragment Offset field of the\
    \ IPv6\n      Fragment Header.\n   Protocol:  For ICMPv6 (58), it is changed to\
    \ ICMPv4 (1); otherwise,\n      extension headers are skipped, and the Next Header\
    \ field is copied\n      from the last IPv6 header.\n   If a translated packet\
    \ with DF set to 1 will be larger than the MTU\n   of the next-hop interface,\
    \ then the translator MUST drop the packet\n   and send the ICMPv6 Packet Too\
    \ Big (Type 2, Code 0) error message to\n   the IPv6 host with an adjusted MTU\
    \ in the ICMPv6 message.\n"
- title: 5.2.  Translating ICMPv6 Headers into ICMPv4 Headers
  contents:
  - "5.2.  Translating ICMPv6 Headers into ICMPv4 Headers\n   If a non-checksum-neutral\
    \ translation address is being used, ICMPv6\n   messages MUST have their ICMPv4\
    \ checksum field be updated as part of\n   the translation since ICMPv6 (unlike\
    \ ICMPv4) includes a pseudo-header\n   in the checksum just like UDP and TCP.\n\
    \   In addition, all ICMP packets MUST have the Type translated and, for\n   ICMP\
    \ error messages, the included IP header also MUST be translated.\n   Note that\
    \ the IPv6 addresses in the IPv6 header may not be IPv4-\n   translatable addresses\
    \ and there will be no corresponding IPv4\n   addresses representing this IPv6\
    \ address.  In this case, the\n   translator can do stateful translation.  A mechanism\
    \ by which the\n   translator can instead do stateless translation of this address\
    \ is\n   left for future work.\n   The actions needed to translate various ICMPv6\
    \ messages are:\n   ICMPv6 informational messages:\n      Echo Request and Echo\
    \ Reply (Type 128 and 129):  Adjust the Type\n         values to 8 and 0, respectively,\
    \ and adjust the ICMP checksum\n         both to take the type change into account\
    \ and to exclude the\n         ICMPv6 pseudo-header.\n      MLD Multicast Listener\
    \ Query/Report/Done (Type 130, 131, 132):\n         Single-hop message.  Silently\
    \ drop.\n      Neighbor Discover messages (Type 133 through 137):  Single-hop\n\
    \         message.  Silently drop.\n      Unknown informational messages:  Silently\
    \ drop.\n   ICMPv6 error messages:\n      Destination Unreachable (Type 1)  Set\
    \ the Type to 3, and adjust\n         the ICMP checksum both to take the type/code\
    \ change into\n         account and to exclude the ICMPv6 pseudo-header.\n   \
    \      Translate the Code as follows:\n         Code 0 (No route to destination):\
    \  Set the Code to 1 (Host\n            unreachable).\n         Code 1 (Communication\
    \ with destination administratively\n            prohibited):  Set the Code to\
    \ 10 (Communication with\n            destination host administratively prohibited).\n\
    \         Code 2 (Beyond scope of source address):  Set the Code to 1\n      \
    \      (Host unreachable).  Note that this error is very unlikely\n          \
    \  since an IPv4-translatable source address is typically\n            considered\
    \ to have global scope.\n         Code 3 (Address unreachable):  Set the Code\
    \ to 1 (Host\n            unreachable).\n         Code 4 (Port unreachable): \
    \ Set the Code to 3 (Port\n            unreachable).\n         Other Code values:\
    \  Silently drop.\n      Packet Too Big (Type 2):  Translate to an ICMPv4 Destination\n\
    \         Unreachable (Type 3) with Code 4, and adjust the ICMPv4\n         checksum\
    \ both to take the type change into account and to\n         exclude the ICMPv6\
    \ pseudo-header.  The MTU field MUST be\n         adjusted for the difference\
    \ between the IPv4 and IPv6 header\n         sizes, taking into account whether\
    \ or not the packet in error\n         includes a Fragment Header, i.e., minimum(advertised\
    \ MTU-20,\n         MTU_of_IPv4_nexthop, (MTU_of_IPv6_nexthop)-20).\n        \
    \ See also the requirements in Section 6.\n      Time Exceeded (Type 3):  Set\
    \ the Type to 11, and adjust the ICMPv4\n         checksum both to take the type\
    \ change into account and to\n         exclude the ICMPv6 pseudo-header.  The\
    \ Code is unchanged.\n      Parameter Problem (Type 4):  Translate the Type and\
    \ Code as\n         follows, and adjust the ICMPv4 checksum both to take the type/\n\
    \         code change into account and to exclude the ICMPv6 pseudo-\n       \
    \  header.\n         Translate the Code as follows:\n         Code 0 (Erroneous\
    \ header field encountered):  Set to Type 12,\n            Code 0, and update\
    \ the pointer as defined in Figure 6.  (If\n            the Original IPv6 Pointer\
    \ Value is not listed or the\n            Translated IPv4 Pointer Value is listed\
    \ as \"n/a\", silently\n            drop the packet.)\n         Code 1 (Unrecognized\
    \ Next Header type encountered):  Translate\n            this to an ICMPv4 protocol\
    \ unreachable (Type 3, Code 2).\n         Code 2 (Unrecognized IPv6 option encountered):\
    \  Silently drop.\n      Unknown error messages:  Silently drop.\n     +--------------------------------+--------------------------------+\n\
    \     |   Original IPv6 Pointer Value  | Translated IPv4 Pointer Value  |\n  \
    \   +--------------------------------+--------------------------------+\n    \
    \ |  0  | Version/Traffic Class    |  0  | Version/IHL, Type Of Ser |\n     |\
    \  1  | Traffic Class/Flow Label |  1  | Type Of Service          |\n     | 2,3\
    \ | Flow Label               | n/a |                          |\n     | 4,5 |\
    \ Payload Length           |  2  | Total Length             |\n     |  6  | Next\
    \ Header              |  9  | Protocol                 |\n     |  7  | Hop Limit\
    \                |  8  | Time to Live             |\n     | 8-23| Source Address\
    \           | 12  | Source Address           |\n     |24-39| Destination Address\
    \      | 16  | Destination Address      |\n     +--------------------------------+--------------------------------+\n\
    \            Figure 6: Pointer Value for Translating from IPv6 to IPv4\n     \
    \ ICMP Error Payload:  If the received ICMPv6 packet contains an\n         ICMPv6\
    \ Extension [RFC4884], the translation of the ICMPv6\n         packet will cause\
    \ the ICMPv4 packet to change length.  When\n         this occurs, the ICMPv6\
    \ Extension length attribute MUST be\n         adjusted accordingly (e.g., shorter\
    \ due to the translation from\n         IPv6 to IPv4).  For extensions not defined\
    \ in [RFC4884], the\n         translator passes the extensions as opaque bit strings\
    \ and any\n         IPv6 address literals contained therein will not be translated\n\
    \         to IPv4 address literals; this may cause problems with\n         processing\
    \ of those ICMP extensions.\n"
- title: 5.3.  Translating ICMPv6 Error Messages into ICMPv4
  contents:
  - "5.3.  Translating ICMPv6 Error Messages into ICMPv4\n   There are some differences\
    \ between the ICMPv4 and the ICMPv6 error\n   message formats as detailed above.\
    \  The ICMP error messages\n   containing the packet in error MUST be translated\
    \ just like a normal\n   IP packet.  The translation of this \"packet in error\"\
    \ is likely to\n   change the length of the datagram; thus, the Total Length field\
    \ in\n   the outer IPv4 header MUST be updated.\n              +-------------+\
    \                 +-------------+\n              |    IPv6     |             \
    \    |    IPv4     |\n              |   Header    |                 |   Header\
    \    |\n              +-------------+                 +-------------+\n      \
    \        |   ICMPv6    |                 |   ICMPv4    |\n              |   Header\
    \    |                 |   Header    |\n              +-------------+        \
    \         +-------------+\n              |    IPv6     |      ===>       |   \
    \ IPv4     |\n              |   Header    |                 |   Header    |\n\
    \              +-------------+                 +-------------+\n             \
    \ |   Partial   |                 |   Partial   |\n              |  Transport-\
    \ |                 |  Transport- |\n              |   Layer     |           \
    \      |   Layer     |\n              |   Header    |                 |   Header\
    \    |\n              +-------------+                 +-------------+\n      \
    \         Figure 7: IPv6-to-IPv4 ICMP Error Translation\n   The translation of\
    \ the inner IP header can be done by invoking the\n   function that translated\
    \ the outer IP headers.  This process MUST\n   stop at the first embedded header\
    \ and drop the packet if it contains\n   more embedded headers.  Note that the\
    \ IPv6 addresses in the IPv6\n   header may not be IPv4-translatable addresses,\
    \ and there will be no\n   corresponding IPv4 addresses.  In this case, the translator\
    \ can do\n   stateful translation.  A mechanism by which the translator can\n\
    \   instead do stateless translation is left for future work.\n"
- title: 5.4.  Generation of ICMPv6 Error Messages
  contents:
  - "5.4.  Generation of ICMPv6 Error Messages\n   If the IPv6 packet is discarded,\
    \ then the translator SHOULD send back\n   an ICMPv6 error message to the original\
    \ sender of the packet, unless\n   the discarded packet is itself an ICMPv6 message.\n\
    \   If the ICMPv6 error message is being sent because the IPv6 source\n   address\
    \ is not an IPv4-translatable address and the translator is\n   stateless, the\
    \ ICMPv6 message (if sent) MUST have Type 1 and Code 5\n   (Source address failed\
    \ ingress/egress policy).  In other cases, the\n   ICMPv6 message MUST have Type\
    \ 1 (Destination Unreachable) and Code 1\n   (Communication with destination administratively\
    \ prohibited), unless\n   otherwise specified in this document or [RFC6146]. \
    \ The translator\n   SHOULD allow an administrator to configure whether the ICMPv6\
    \ error\n   messages are sent, rate-limited, or not sent.\n"
- title: 5.5.  Transport-Layer Header Translation
  contents:
  - "5.5.  Transport-Layer Header Translation\n   If the address translation algorithm\
    \ is not checksum neutral (see\n   Section 4.1 of [RFC6052]), the recalculation\
    \ and updating of the\n   transport-layer headers that contain pseudo-headers\
    \ need to be\n   performed.  Translators MUST do this for TCP, UDP, and ICMP.\n\
    \   Other transport protocols (e.g., DCCP) are OPTIONAL to support.  In\n   order\
    \ to ease debugging and troubleshooting, translators MUST forward\n   all transport\
    \ protocols as described in the \"Protocol\" step of\n   Section 5.1.\n"
- title: 5.6.  Knowing When to Translate
  contents:
  - "5.6.  Knowing When to Translate\n   If the IP/ICMP translator also provides a\
    \ normal forwarding function,\n   and the destination address is reachable by\
    \ a more specific route\n   without translation, the router MUST forward it without\
    \ translating\n   it.  When an IP/ICMP translator receives an IPv6 datagram addressed\n\
    \   to an IPv6 address representing a host in the IPv4 domain, the IPv6\n   packet\
    \ MUST be translated to IPv4.\n"
- title: 6.  Special Considerations for ICMPv6 Packet Too Big
  contents:
  - "6.  Special Considerations for ICMPv6 Packet Too Big\n   Two recent studies analyzed\
    \ the behavior of IPv6-capable web servers\n   on the Internet and found that\
    \ approximately 95% responded as\n   expected to an IPv6 Packet Too Big that indicated\
    \ MTU = 1280, but\n   only 43% responded as expected to an IPv6 Packet Too Big\
    \ that\n   indicated an MTU < 1280.  It is believed that firewalls violating\n\
    \   Section 4.3.1 of [RFC4890] are at fault.  Both failures (the 5% wrong\n  \
    \ response when MTU = 1280 and the 57% wrong response when MTU < 1280)\n   will\
    \ cause PMTUD black holes [RFC2923].  Unfortunately, the\n   translator cannot\
    \ improve the failure rate of the first case (MTU =\n   1280), but the translator\
    \ can improve the failure rate of the second\n   case (MTU < 1280).  There are\
    \ two approaches to resolving the problem\n   with sending ICMPv6 messages indicating\
    \ an MTU < 1280.  It SHOULD be\n   possible to configure a translator for either\
    \ of the two approaches.\n   The first approach is to constrain the deployment\
    \ of the IPv6/IPv4\n   translator by observing that four of the scenarios intended\
    \ for\n   stateless IPv6/IPv4 translators do not have IPv6 hosts on the\n   Internet\
    \ (Scenarios 1, 2, 5, and 6 described in [RFC6144], which\n   refer to \"An IPv6\
    \ network\").  In these scenarios, IPv6 hosts, IPv6-\n   host-based firewalls,\
    \ and IPv6 network firewalls can be administered\n   in compliance with Section\
    \ 4.3.1 of [RFC4890] and therefore avoid the\n   problem witnessed with IPv6 hosts\
    \ on the Internet.\n   The second approach is necessary if the translator has\
    \ IPv6 hosts,\n   IPv6-host-based firewalls, or IPv6 network firewalls that do\
    \ not (or\n   cannot) comply with Section 5 of [RFC2460] -- such as IPv6 hosts\
    \ on\n   the Internet.  This approach requires the translator to do the\n   following:\n\
    \   1.  In the IPv4-to-IPv6 direction: if the MTU value of ICMPv4 Packet\n   \
    \    Too Big (PTB) messages is less than 1280, change it to 1280.\n       This\
    \ is intended to cause the IPv6 host and IPv6 firewall to\n       process the\
    \ ICMP PTB message and generate subsequent packets to\n       this destination\
    \ with an IPv6 Fragment Header.\n       Note: Based on recent studies, this is\
    \ effective for 95% of IPv6\n       hosts on the Internet.\n   2.  In the IPv6-to-IPv4\
    \ direction:\n       A.  If there is a Fragment Header in the IPv6 packet, the\
    \ last 16\n           bits of its value MUST be used for the IPv4 identification\n\
    \           value.\n       B.  If there is no Fragment Header in the IPv6 packet:\n\
    \           a.  If the packet is less than or equal to 1280 bytes:\n         \
    \      -  The translator SHOULD set DF to 0 and generate an IPv4\n           \
    \       identification value.\n               -  To avoid the problems described\
    \ in [RFC4963], it is\n                  RECOMMENDED that the translator maintain\
    \ 3-tuple state\n                  for generating the IPv4 identification value.\n\
    \           b.  If the packet is greater than 1280 bytes, the translator\n   \
    \            SHOULD set the IPv4 DF bit to 1.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The use of stateless IP/ICMP translators does\
    \ not introduce any new\n   security issues beyond the security issues that are\
    \ already present\n   in the IPv4 and IPv6 protocols and in the routing protocols\
    \ that are\n   used to make the packets reach the translator.\n   There are potential\
    \ issues that might arise by deriving an IPv4\n   address from an IPv6 address\
    \ -- particularly addresses like broadcast\n   or loopback addresses and the non-IPv4-translatable\
    \ IPv6 addresses,\n   etc.  [RFC6052] addresses these issues.\n   As with network\
    \ address translation of IPv4 to IPv4, the IPsec\n   Authentication Header [RFC4302]\
    \ cannot be used across an IPv6-to-IPv4\n   translator.\n   As with network address\
    \ translation of IPv4 to IPv4, packets with\n   tunnel mode Encapsulating Security\
    \ Payload (ESP) can be translated\n   since tunnel mode ESP does not depend on\
    \ header fields prior to the\n   ESP header.  Similarly, transport mode ESP will\
    \ fail with IPv6-to-\n   IPv4 translation unless checksum-neutral addresses are\
    \ used.  In both\n   cases, the IPsec ESP endpoints will normally detect the presence\
    \ of\n   the translator and encapsulate ESP in UDP packets [RFC3948].\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   This is under development by a large group of people.\
    \  Those who have\n   posted to the list during the discussion include Alexey\
    \ Melnikov,\n   Andrew Sullivan, Andrew Yourtchenko, Brian Carpenter, Dan Wing,\
    \ Dave\n   Thaler, David Harrington, Ed Jankiewicz, Hiroshi Miyata, Iljitsch van\n\
    \   Beijnum, Jari Arkko, Jerry Huang, John Schnizlein, Jouni Korhonen,\n   Kentaro\
    \ Ebisawa, Kevin Yin, Magnus Westerlund, Marcelo Bagnulo Braun,\n   Margaret Wasserman,\
    \ Masahito Endo, Phil Roberts, Philip Matthews,\n   Reinaldo Penno, Remi Denis-Courmont,\
    \ Remi Despres, Sean Turner,\n   Senthil Sivakumar, Simon Perreault, Stewart Bryant,\
    \ Tim Polk, Tero\n   Kivinen, and Zen Cao.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC0768]  Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              August 1980.\n   [RFC0791]  Postel, J., \"Internet\
    \ Protocol\", STD 5, RFC 791,\n              September 1981.\n   [RFC0792]  Postel,\
    \ J., \"Internet Control Message Protocol\", STD 5,\n              RFC 792, September\
    \ 1981.\n   [RFC0793]  Postel, J., \"Transmission Control Protocol\", STD 7,\n\
    \              RFC 793, September 1981.\n   [RFC1812]  Baker, F., \"Requirements\
    \ for IP Version 4 Routers\",\n              RFC 1812, June 1995.\n   [RFC1883]\
    \  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)\
    \ Specification\", RFC 1883, December 1995.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n   [RFC2460]  Deering, S. and R. Hinden, \"Internet Protocol,\
    \ Version 6\n              (IPv6) Specification\", RFC 2460, December 1998.\n\
    \   [RFC2765]  Nordmark, E., \"Stateless IP/ICMP Translation Algorithm\n     \
    \         (SIIT)\", RFC 2765, February 2000.\n   [RFC3948]  Huttunen, A., Swander,\
    \ B., Volpe, V., DiBurro, L., and M.\n              Stenberg, \"UDP Encapsulation\
    \ of IPsec ESP Packets\",\n              RFC 3948, January 2005.\n   [RFC4291]\
    \  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\"\
    , RFC 4291, February 2006.\n   [RFC4340]  Kohler, E., Handley, M., and S. Floyd,\
    \ \"Datagram\n              Congestion Control Protocol (DCCP)\", RFC 4340, March\
    \ 2006.\n   [RFC4443]  Conta, A., Deering, S., and M. Gupta, \"Internet Control\n\
    \              Message Protocol (ICMPv6) for the Internet Protocol\n         \
    \     Version 6 (IPv6) Specification\", RFC 4443, March 2006.\n   [RFC4884]  Bonica,\
    \ R., Gan, D., Tappan, D., and C. Pignataro,\n              \"Extended ICMP to\
    \ Support Multi-Part Messages\", RFC 4884,\n              April 2007.\n   [RFC5382]\
    \  Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.\n              Srisuresh,\
    \ \"NAT Behavioral Requirements for TCP\", BCP 142,\n              RFC 5382, October\
    \ 2008.\n   [RFC5771]  Cotton, M., Vegoda, L., and D. Meyer, \"IANA Guidelines\
    \ for\n              IPv4 Multicast Address Assignments\", BCP 51, RFC 5771,\n\
    \              March 2010.\n   [RFC6052]  Bao, C., Huitema, C., Bagnulo, M., Boucadair,\
    \ M., and X.\n              Li, \"IPv6 Addressing of IPv4/IPv6 Translators\",\
    \ RFC 6052,\n              October 2010.\n   [RFC6146]  Bagnulo, M., Matthews,\
    \ P., and I. Beijnum, \"Stateful\n              NAT64: Network Address and Protocol\
    \ Translation from IPv6\n              Clients to IPv4 Servers\", RFC 6146, April\
    \ 2011.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [RFC0879]  Postel, J., \"TCP maximum segment\
    \ size and related topics\",\n              RFC 879, November 1983.\n   [RFC1191]\
    \  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n             \
    \ November 1990.\n   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,\n\
    \              \"Definition of the Differentiated Services Field (DS\n       \
    \       Field) in the IPv4 and IPv6 Headers\", RFC 2474,\n              December\
    \ 1998.\n   [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n\
    \              and W. Weiss, \"An Architecture for Differentiated\n          \
    \    Services\", RFC 2475, December 1998.\n   [RFC2710]  Deering, S., Fenner,\
    \ W., and B. Haberman, \"Multicast\n              Listener Discovery (MLD) for\
    \ IPv6\", RFC 2710,\n              October 1999.\n   [RFC2766]  Tsirtsis, G. and\
    \ P. Srisuresh, \"Network Address\n              Translation - Protocol Translation\
    \ (NAT-PT)\", RFC 2766,\n              February 2000.\n   [RFC2923]  Lahey, K.,\
    \ \"TCP Problems with Path MTU Discovery\",\n              RFC 2923, September\
    \ 2000.\n   [RFC3307]  Haberman, B., \"Allocation Guidelines for IPv6 Multicast\n\
    \              Addresses\", RFC 3307, August 2002.\n   [RFC3590]  Haberman, B.,\
    \ \"Source Address Selection for the Multicast\n              Listener Discovery\
    \ (MLD) Protocol\", RFC 3590,\n              September 2003.\n   [RFC3810]  Vida,\
    \ R. and L. Costa, \"Multicast Listener Discovery\n              Version 2 (MLDv2)\
    \ for IPv6\", RFC 3810, June 2004.\n   [RFC3849]  Huston, G., Lord, A., and P.\
    \ Smith, \"IPv6 Address Prefix\n              Reserved for Documentation\", RFC\
    \ 3849, July 2004.\n   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC\
    \ 4302,\n              December 2005.\n   [RFC4890]  Davies, E. and J. Mohacsi,\
    \ \"Recommendations for Filtering\n              ICMPv6 Messages in Firewalls\"\
    , RFC 4890, May 2007.\n   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler,\
    \ \"IPv4 Reassembly\n              Errors at High Data Rates\", RFC 4963, July\
    \ 2007.\n   [RFC4966]  Aoun, C. and E. Davies, \"Reasons to Move the Network\n\
    \              Address Translator - Protocol Translator (NAT-PT) to\n        \
    \      Historic Status\", RFC 4966, July 2007.\n   [RFC5737]  Arkko, J., Cotton,\
    \ M., and L. Vegoda, \"IPv4 Address Blocks\n              Reserved for Documentation\"\
    , RFC 5737, January 2010.\n   [RFC6144]  Baker, F., Li, X., Bao, C., and K. Yin,\
    \ \"Framework for\n              IPv4/IPv6 Translation\", RFC 6144, April 2011.\n"
- title: Appendix A.  Stateless Translation Workflow Example
  contents:
  - "Appendix A.  Stateless Translation Workflow Example\n   A stateless translation\
    \ workflow example is depicted in the following\n   figure.  The documentation\
    \ address blocks 2001:db8::/32 [RFC3849],\n   192.0.2.0/24, and 198.51.100.0/24\
    \ [RFC5737] are used in this example.\n            +--------------+          \
    \         +--------------+\n            | IPv4 network |                   | IPv6\
    \ network |\n            |              |     +-------+     |              |\n\
    \            |   +----+     |-----| XLAT  |---- |  +----+      |\n           \
    \ |   | H4 |-----|     +-------+     |--| H6 |      |\n            |   +----+\
    \     |                   |  +----+      |\n            +--------------+     \
    \              +--------------+\n                                 Figure 8\n \
    \  A translator (XLAT) connects the IPv6 network to the IPv4 network.\n   This\
    \ XLAT uses the Network-Specific Prefix (NSP) 2001:db8:100::/40\n   defined in\
    \ [RFC6052] to represent IPv4 addresses in the IPv6 address\n   space (IPv4-converted\
    \ addresses) and to represent IPv6 addresses\n   (IPv4-translatable addresses)\
    \ in the IPv4 address space.  In this\n   example, 192.0.2.0/24 is the IPv4 block\
    \ of the corresponding IPv4-\n   translatable addresses.\n   Based on the address\
    \ mapping rule, the IPv6 node H6 has an IPv4-\n   translatable IPv6 address 2001:db8:1c0:2:21::\
    \ (address mapping from\n   192.0.2.33).  The IPv4 node H4 has IPv4 address 198.51.100.2.\n\
    \   The IPv6 routing is configured in such a way that the IPv6 packets\n   addressed\
    \ to a destination address in 2001:db8:100::/40 are routed to\n   the IPv6 interface\
    \ of the XLAT.\n   The IPv4 routing is configured in such a way that the IPv4\
    \ packets\n   addressed to a destination address in 192.0.2.0/24 are routed to\
    \ the\n   IPv4 interface of the XLAT.\n"
- title: A.1.  H6 Establishes Communication with H4
  contents:
  - "A.1.  H6 Establishes Communication with H4\n   The steps by which H6 establishes\
    \ communication with H4 are:\n   1.  H6 performs the destination address mapping,\
    \ so the IPv4-\n       converted address 2001:db8:1c6:3364:2:: is formed from\n\
    \       198.51.100.2 based on the address mapping algorithm [RFC6052].\n   2.\
    \  H6 sends a packet to H4.  The packet is sent from a source\n       address\
    \ 2001:db8:1c0:2:21:: to a destination address\n       2001:db8:1c6:3364:2::.\n\
    \   3.  The packet is routed to the IPv6 interface of the XLAT (since\n      \
    \ IPv6 routing is configured that way).\n   4.  The XLAT receives the packet and\
    \ performs the following actions:\n       *  The XLAT translates the IPv6 header\
    \ into an IPv4 header using\n          the IP/ICMP Translation Algorithm defined\
    \ in this document.\n       *  The XLAT includes 192.0.2.33 as the source address\
    \ in the\n          packet and 198.51.100.2 as the destination address in the\n\
    \          packet.  Note that 192.0.2.33 and 198.51.100.2 are extracted\n    \
    \      directly from the source IPv6 address 2001:db8:1c0:2:21::\n          (IPv4-translatable\
    \ address) and destination IPv6 address\n          2001:db8:1c6:3364:2:: (IPv4-converted\
    \ address) of the received\n          IPv6 packet that is being translated.\n\
    \   5.  The XLAT sends the translated packet out of its IPv4 interface,\n    \
    \   and the packet arrives at H4.\n   6.  H4 node responds by sending a packet\
    \ with destination address\n       192.0.2.33 and source address 198.51.100.2.\n\
    \   7.  The packet is routed to the IPv4 interface of the XLAT (since\n      \
    \ IPv4 routing is configured that way).  The XLAT performs the\n       following\
    \ operations:\n       *  The XLAT translates the IPv4 header into an IPv6 header\
    \ using\n          the IP/ICMP Translation Algorithm defined in this document.\n\
    \       *  The XLAT includes 2001:db8:1c0:2:21:: as the destination\n        \
    \  address in the packet and 2001:db8:1c6:3364:2:: as the source\n          address\
    \ in the packet.  Note that 2001:db8:1c0:2:21:: and\n          2001:db8:1c6:3364:2::\
    \ are formed directly from the destination\n          IPv4 address 192.0.2.33\
    \ and the source IPv4 address\n          198.51.100.2 of the received IPv4 packet\
    \ that is being\n          translated.\n   8.  The translated packet is sent out\
    \ of the IPv6 interface to H6.\n   The packet exchange between H6 and H4 continues\
    \ until the session is\n   finished.\n"
- title: A.2.  H4 Establishes Communication with H6
  contents:
  - "A.2.  H4 Establishes Communication with H6\n   The steps by which H4 establishes\
    \ communication with H6 are:\n   1.  H4 performs the destination address mapping,\
    \ so 192.0.2.33 is\n       formed from the IPv4-translatable address 2001:db8:1c0:2:21::\n\
    \       based on the address mapping algorithm [RFC6052].\n   2.  H4 sends a packet\
    \ to H6.  The packet is sent from a source\n       address 198.51.100.2 to a destination\
    \ address 192.0.2.33.\n   3.  The packet is routed to the IPv4 interface of the\
    \ XLAT (since\n       IPv4 routing is configured that way).\n   4.  The XLAT receives\
    \ the packet and performs the following actions:\n       *  The XLAT translates\
    \ the IPv4 header into an IPv6 header using\n          the IP/ICMP Translation\
    \ Algorithm defined in this document.\n       *  The XLAT includes 2001:db8:1c6:3364:2::\
    \ as the source address\n          in the packet and 2001:db8:1c0:2:21:: as the\
    \ destination\n          address in the packet.  Note that 2001:db8:1c6:3364:2::\n\
    \          (IPv4-converted address) and 2001:db8:1c0:2:21::\n          (IPv4-translatable\
    \ address) are obtained directly from the\n          source IPv4 address 198.51.100.2\
    \ and destination IPv4 address\n          192.0.2.33 of the received IPv4 packet\
    \ that is being\n          translated.\n   5.  The XLAT sends the translated packet\
    \ out its IPv6 interface, and\n       the packet arrives at H6.\n   6.  H6 node\
    \ responds by sending a packet with destination address\n       2001:db8:1c6:3364:2::\
    \ and source address 2001:db8:1c0:2:21::.\n   7.  The packet is routed to the\
    \ IPv6 interface of the XLAT (since\n       IPv6 routing is configured that way).\
    \  The XLAT performs the\n       following operations:\n       *  The XLAT translates\
    \ the IPv6 header into an IPv4 header using\n          the IP/ICMP Translation\
    \ Algorithm defined in this document.\n       *  The XLAT includes 198.51.100.2\
    \ as the destination address in\n          the packet and 192.0.2.33 as the source\
    \ address in the packet.\n          Note that 198.51.100.2 and 192.0.2.33 are\
    \ formed directly from\n          the destination IPv6 address 2001:db8:1c6:3364:2::\
    \ and source\n          IPv6 address 2001:db8:1c0:2:21:: of the received IPv6\
    \ packet\n          that is being translated.\n   8.  The translated packet is\
    \ sent out the IPv4 interface to H4.\n   The packet exchange between H4 and H6\
    \ continues until the session is\n   finished.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Xing Li\n   CERNET Center/Tsinghua University\n   Room\
    \ 225, Main Building, Tsinghua University\n   Beijing,   100084\n   China\n  \
    \ Phone: +86 10-62785983\n   EMail: xing@cernet.edu.cn\n   Congxiao Bao\n   CERNET\
    \ Center/Tsinghua University\n   Room 225, Main Building, Tsinghua University\n\
    \   Beijing,   100084\n   China\n   Phone: +86 10-62785983\n   EMail: congxiao@cernet.edu.cn\n\
    \   Fred Baker\n   Cisco Systems\n   Santa Barbara, California  93117\n   USA\n\
    \   Phone: +1-408-526-4257\n   EMail: fred@cisco.com\n"
