- title: __initial_text__
  contents:
  - "                  Internet Protocol, Version 6 (IPv6)\n                     \
    \        Specification\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies version 6 of the Internet Protocol (IPv6),\n\
    \   also sometimes referred to as IP Next Generation or IPng.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction..................................................3\n\
    \   2. Terminology...................................................4\n   3.\
    \ IPv6 Header Format............................................5\n   4. IPv6\
    \ Extension Headers........................................6\n       4.1 Extension\
    \ Header Order...................................8\n       4.2 Options..................................................9\n\
    \       4.3 Hop-by-Hop Options Header...............................11\n     \
    \  4.4 Routing Header..........................................13\n       4.5\
    \ Fragment Header.........................................19\n       4.6 Destination\
    \ Options Header..............................24\n       4.7 No Next Header..........................................25\n\
    \   5. Packet Size Issues...........................................26\n   6.\
    \ Flow Labels..................................................28\n   7. Priority.....................................................30\n\
    \   8. Upper-Layer Protocol Issues..................................31\n     \
    \  8.1 Upper-Layer Checksums...................................31\n       8.2\
    \ Maximum Packet Lifetime.................................32\n       8.3 Maximum\
    \ Upper-Layer Payload Size........................32\n   Appendix A. Formatting\
    \ Guidelines for Options...................33\n   Security Considerations.........................................36\n\
    \   Acknowledgments.................................................36\n   Authors'\
    \ Addresses..............................................36\n   References......................................................37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP version 6 (IPv6) is a new version of the Internet Protocol,\n\
    \   designed as a successor to IP version 4 (IPv4) [RFC-791].  The\n   changes\
    \ from IPv4 to IPv6 fall primarily into the following\n   categories:\n      o\
    \  Expanded Addressing Capabilities\n         IPv6 increases the IP address size\
    \ from 32 bits to 128 bits, to\n         support more levels of addressing hierarchy,\
    \ a much greater\n         number of addressable nodes, and simpler auto-configuration\
    \ of\n         addresses.  The scalability of multicast routing is improved by\n\
    \         adding a \"scope\" field to multicast addresses.  And a new type\n \
    \        of address called an \"anycast address\" is defined, used to send\n \
    \        a packet to any one of a group of nodes.\n      o  Header Format Simplification\n\
    \         Some IPv4 header fields have been dropped or made optional, to\n   \
    \      reduce the common-case processing cost of packet handling and\n       \
    \  to limit the bandwidth cost of the IPv6 header.\n      o  Improved Support\
    \ for Extensions and Options\n         Changes in the way IP header options are\
    \ encoded allows for\n         more efficient forwarding, less stringent limits\
    \ on the length\n         of options, and greater flexibility for introducing\
    \ new options\n         in the future.\n      o  Flow Labeling Capability\n  \
    \       A new capability is added to enable the labeling of packets\n        \
    \ belonging to particular traffic \"flows\" for which the sender\n         requests\
    \ special handling, such as non-default quality of\n         service or \"real-time\"\
    \ service.\n      o  Authentication and Privacy Capabilities\n         Extensions\
    \ to support authentication, data integrity, and\n         (optional) data confidentiality\
    \ are specified for IPv6.\n   This document specifies the basic IPv6 header and\
    \ the initially-\n   defined IPv6 extension headers and options.  It also discusses\
    \ packet\n   size issues, the semantics of flow labels and priority, and the\n\
    \   effects of IPv6 on upper-layer protocols.  The format and semantics\n   of\
    \ IPv6 addresses are specified separately in [RFC-1884].  The IPv6\n   version\
    \ of ICMP, which all IPv6 implementations are required to\n   include, is specified\
    \ in [RFC-1885].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   node        - a device that implements IPv6.\n   router \
    \     - a node that forwards IPv6 packets not explicitly\n                 addressed\
    \ to itself.  [See Note below].\n   host        - any node that is not a router.\
    \  [See Note below].\n   upper layer - a protocol layer immediately above IPv6.\
    \  Examples are\n                 transport protocols such as TCP and UDP, control\n\
    \                 protocols such as ICMP, routing protocols such as OSPF,\n  \
    \               and internet or lower-layer protocols being \"tunneled\"\n   \
    \              over (i.e., encapsulated in) IPv6 such as IPX,\n              \
    \   AppleTalk, or IPv6 itself.\n   link        - a communication facility or medium\
    \ over which nodes can\n                 communicate at the link layer, i.e.,\
    \ the layer\n                 immediately below IPv6.  Examples are Ethernets\
    \ (simple\n                 or bridged); PPP links; X.25, Frame Relay, or ATM\n\
    \                 networks; and internet (or higher) layer \"tunnels\",\n    \
    \             such as tunnels over IPv4 or IPv6 itself.\n   neighbors   - nodes\
    \ attached to the same link.\n   interface   - a node's attachment to a link.\n\
    \   address     - an IPv6-layer identifier for an interface or a set of\n    \
    \             interfaces.\n   packet      - an IPv6 header plus payload.\n   link\
    \ MTU    - the maximum transmission unit, i.e., maximum packet\n             \
    \    size in octets, that can be conveyed in one piece over\n                \
    \ a link.\n   path MTU    - the minimum link MTU of all the links in a path between\n\
    \                 a source node and a destination node.\n   Note: it is possible,\
    \ though unusual, for a device with multiple\n   interfaces to be configured to\
    \ forward non-self-destined packets\n   arriving from some set (fewer than all)\
    \ of its interfaces, and to\n   discard non-self-destined packets arriving from\
    \ its other interfaces.\n   Such a device must obey the protocol requirements\
    \ for routers when\n   receiving packets from, and interacting with neighbors\
    \ over, the\n   former (forwarding) interfaces.  It must obey the protocol\n \
    \  requirements for hosts when receiving packets from, and interacting\n   with\
    \ neighbors over, the latter (non-forwarding) interfaces.\n"
- title: 3.  IPv6 Header Format
  contents:
  - "3.  IPv6 Header Format\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version| Prio. |                   Flow Label                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Payload Length        |  Next Header  |   Hop Limit   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version              4-bit Internet Protocol version number = 6.\n   Prio.\
    \                4-bit priority value.  See section 7.\n   Flow Label        \
    \   24-bit flow label.  See section 6.\n   Payload Length       16-bit unsigned\
    \ integer.  Length of payload,\n                        i.e., the rest of the\
    \ packet following the\n                        IPv6 header, in octets.  If zero,\
    \ indicates that\n                        the payload length is carried in a Jumbo\
    \ Payload\n                        hop-by-hop option.\n   Next Header        \
    \  8-bit selector.  Identifies the type of header\n                        immediately\
    \ following the IPv6 header.  Uses\n                        the same values as\
    \ the IPv4 Protocol field\n                        [RFC-1700 et seq.].\n   Hop\
    \ Limit            8-bit unsigned integer.  Decremented by 1 by\n            \
    \            each node that forwards the packet. The packet\n                \
    \        is discarded if Hop Limit is decremented to\n                       \
    \ zero.\n   Source Address       128-bit address of the originator of the\n  \
    \                      packet.  See [RFC-1884].\n   Destination Address  128-bit\
    \ address of the intended recipient\n                        of the packet (possibly\
    \ not the ultimate\n                        recipient, if a Routing header is\
    \ present).\n                        See [RFC-1884] and section 4.4.\n"
- title: 4.  IPv6 Extension Headers
  contents:
  - "4.  IPv6 Extension Headers\n   In IPv6, optional internet-layer information is\
    \ encoded in separate\n   headers that may be placed between the IPv6 header and\
    \ the upper-\n   layer header in a packet.  There are a small number of such extension\n\
    \   headers, each identified by a distinct Next Header value.  As\n   illustrated\
    \ in these examples, an IPv6 packet may carry zero, one, or\n   more extension\
    \ headers, each identified by the Next Header field of\n   the preceding header:\n\
    \   +---------------+------------------------\n   |  IPv6 header  | TCP header\
    \ + data\n   |               |\n   | Next Header = |\n   |      TCP      |\n \
    \  +---------------+------------------------\n   +---------------+----------------+------------------------\n\
    \   |  IPv6 header  | Routing header | TCP header + data\n   |               |\
    \                |\n   | Next Header = |  Next Header = |\n   |    Routing   \
    \ |      TCP       |\n   +---------------+----------------+------------------------\n\
    \   +---------------+----------------+-----------------+-----------------\n  \
    \ |  IPv6 header  | Routing header | Fragment header | fragment of TCP\n   | \
    \              |                |                 |  header + data\n   | Next\
    \ Header = |  Next Header = |  Next Header =  |\n   |    Routing    |    Fragment\
    \    |       TCP       |\n   +---------------+----------------+-----------------+-----------------\n\
    \   With one exception, extension headers are not examined or processed\n   by\
    \ any node along a packet's delivery path, until the packet reaches\n   the node\
    \ (or each of the set of nodes, in the case of multicast)\n   identified in the\
    \ Destination Address field of the IPv6 header.\n   There, normal demultiplexing\
    \ on the Next Header field of the IPv6\n   header invokes the module to process\
    \ the first extension header, or\n   the upper-layer header if no extension header\
    \ is present.  The\n   contents and semantics of each extension header determine\
    \ whether or\n   not to proceed to the next header.  Therefore, extension headers\
    \ must\n   be processed strictly in the order they appear in the packet; a\n \
    \  receiver must not, for example, scan through a packet looking for a\n   particular\
    \ kind of extension header and process that header prior to\n   processing all\
    \ preceding ones.\n   The exception referred to in the preceding paragraph is\
    \ the Hop-by-\n   Hop Options header, which carries information that must be examined\n\
    \   and processed by every node along a packet's delivery path, including\n  \
    \ the source and destination nodes.  The Hop-by-Hop Options header,\n   when present,\
    \ must immediately follow the IPv6 header.  Its presence\n   is indicated by the\
    \ value zero in the Next Header field of the IPv6\n   header.\n   If, as a result\
    \ of processing a header, a node is required to proceed\n   to the next header\
    \ but the Next Header value in the current header is\n   unrecognized by the node,\
    \ it should discard the packet and send an\n   ICMP Parameter Problem message\
    \ to the source of the packet, with an\n   ICMP Code value of 2 (\"unrecognized\
    \ Next Header type encountered\")\n   and the ICMP Pointer field containing the\
    \ offset of the unrecognized\n   value within the original packet.  The same action\
    \ should be taken if\n   a node encounters a Next Header value of zero in any\
    \ header other\n   than an IPv6 header.\n   Each extension header is an integer\
    \ multiple of 8 octets long, in\n   order to retain 8-octet alignment for subsequent\
    \ headers.  Multi-\n   octet fields within each extension header are aligned on\
    \ their\n   natural boundaries, i.e., fields of width n octets are placed at an\n\
    \   integer multiple of n octets from the start of the header, for n = 1,\n  \
    \ 2, 4, or 8.\n   A full implementation of IPv6 includes implementation of the\n\
    \   following extension headers:\n           Hop-by-Hop Options\n           Routing\
    \ (Type 0)\n           Fragment\n           Destination Options\n           Authentication\n\
    \           Encapsulating Security Payload\n   The first four are specified in\
    \ this document; the last two are\n   specified in [RFC-1826] and [RFC-1827],\
    \ respectively.\n"
- title: 4.1  Extension Header Order
  contents:
  - "4.1  Extension Header Order\n   When more than one extension header is used in\
    \ the same packet, it is\n   recommended that those headers appear in the following\
    \ order:\n           IPv6 header\n           Hop-by-Hop Options header\n     \
    \      Destination Options header (note 1)\n           Routing header\n      \
    \     Fragment header\n           Authentication header (note 2)\n           Encapsulating\
    \ Security Payload header (note 2)\n           Destination Options header (note\
    \ 3)\n           upper-layer header\n           note 1: for options to be processed\
    \ by the first destination\n                   that appears in the IPv6 Destination\
    \ Address field\n                   plus subsequent destinations listed in the\
    \ Routing\n                   header.\n           note 2: additional recommendations\
    \ regarding the relative\n                   order of the Authentication and Encapsulating\n\
    \                   Security Payload headers are given in [RFC-1827].\n      \
    \     note 3: for options to be processed only by the final\n                \
    \   destination of the packet.\n   Each extension header should occur at most\
    \ once, except for the\n   Destination Options header which should occur at most\
    \ twice (once\n   before a Routing header and once before the upper-layer header).\n\
    \   If the upper-layer header is another IPv6 header (in the case of IPv6\n  \
    \ being tunneled over or encapsulated in IPv6), it may be followed by\n   its\
    \ own extensions headers, which are separately subject to the same\n   ordering\
    \ recommendations.\n   If and when other extension headers are defined, their\
    \ ordering\n   constraints relative to the above listed headers must be specified.\n\
    \   IPv6 nodes must accept and attempt to process extension headers in\n   any\
    \ order and occurring any number of times in the same packet,\n   except for the\
    \ Hop-by-Hop Options header which is restricted to\n   appear immediately after\
    \ an IPv6 header only.  Nonetheless, it is\n   strongly advised that sources of\
    \ IPv6 packets adhere to the above\n   recommended order until and unless subsequent\
    \ specifications revise\n   that recommendation.\n"
- title: 4.2  Options
  contents:
  - "4.2  Options\n   Two of the currently-defined extension headers -- the Hop-by-Hop\n\
    \   Options header and the Destination Options header -- carry a variable\n  \
    \ number of type-length-value (TLV) encoded \"options\", of the following\n  \
    \ format:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n      | \
    \ Option Type  |  Opt Data Len |  Option Data\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n      Option Type          8-bit identifier of the type of\
    \ option.\n      Opt Data Len         8-bit unsigned integer.  Length of the Option\n\
    \                           Data field of this option, in octets.\n      Option\
    \ Data          Variable-length field.  Option-Type-specific\n               \
    \            data.\n   The sequence of options within a header must be processed\
    \ strictly in\n   the order they appear in the header; a receiver must not, for\n\
    \   example, scan through the header looking for a particular kind of\n   option\
    \ and process that option prior to processing all preceding\n   ones.\n   The\
    \ Option Type identifiers are internally encoded such that their\n   highest-order\
    \ two bits specify the action that must be taken if the\n   processing IPv6 node\
    \ does not recognize the Option Type:\n      00 - skip over this option and continue\
    \ processing the header.\n      01 - discard the packet.\n      10 - discard the\
    \ packet and, regardless of whether or not the\n           packets's Destination\
    \ Address was a multicast address, send\n           an ICMP Parameter Problem,\
    \ Code 2, message to the packet's\n           Source Address, pointing to the\
    \ unrecognized Option Type.\n      11 - discard the packet and, only if the packet's\
    \ Destination\n           Address was not a multicast address, send an ICMP Parameter\n\
    \           Problem, Code 2, message to the packet's Source Address,\n       \
    \    pointing to the unrecognized Option Type.\n   The third-highest-order bit\
    \ of the Option Type specifies whether or\n   not the Option Data of that option\
    \ can change en-route to the\n   packet's final destination.  When an Authentication\
    \ header is present\n   in the packet, for any option whose data may change en-route,\
    \ its\n   entire Option Data field must be treated as zero-valued octets when\n\
    \   computing or verifying the packet's authenticating value.\n      0 - Option\
    \ Data does not change en-route\n      1 - Option Data may change en-route\n \
    \  Individual options may have specific alignment requirements, to\n   ensure\
    \ that multi-octet values within Option Data fields fall on\n   natural boundaries.\
    \  The alignment requirement of an option is\n   specified using the notation\
    \ xn+y, meaning the Option Type must\n   appear at an integer multiple of x octets\
    \ from the start of the\n   header, plus y octets.  For example:\n       2n  \
    \  means any 2-octet offset from the start of the header.\n       8n+2  means\
    \ any 8-octet offset from the start of the header,\n             plus 2 octets.\n\
    \   There are two padding options which are used when necessary to align\n   subsequent\
    \ options and to pad out the containing header to a multiple\n   of 8 octets in\
    \ length.  These padding options must be recognized by\n   all IPv6 implementations:\n\
    \   Pad1 option  (alignment requirement: none)\n       +-+-+-+-+-+-+-+-+\n   \
    \    |       0       |\n       +-+-+-+-+-+-+-+-+\n       NOTE! the format of the\
    \ Pad1 option is a special case -- it does\n             not have length and value\
    \ fields.\n       The Pad1 option is used to insert one octet of padding into\
    \ the\n       Options area of a header.  If more than one octet of padding is\n\
    \       required, the PadN option, described next, should be used,\n       rather\
    \ than multiple Pad1 options.\n   PadN option  (alignment requirement: none)\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n       |       1 \
    \      |  Opt Data Len |  Option Data\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n       The PadN option is used to insert two or more octets\
    \ of padding\n       into the Options area of a header.  For N octets of padding,\n\
    \       the Opt Data Len field contains the value N-2, and the Option\n      \
    \ Data consists of N-2 zero-valued octets.\n   Appendix A contains formatting\
    \ guidelines for designing new options.\n"
- title: 4.3  Hop-by-Hop Options Header
  contents:
  - "4.3  Hop-by-Hop Options Header\n   The Hop-by-Hop Options header is used to carry\
    \ optional information\n   that must be examined by every node along a packet's\
    \ delivery path.\n   The Hop-by-Hop Options header is identified by a Next Header\
    \ value of\n   0 in the IPv6 header, and has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |  Hdr Ext Len  |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   .                                            \
    \                   .\n   .                            Options               \
    \             .\n   .                                                        \
    \       .\n   |                                                              \
    \ |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ Next Header          8-bit selector.  Identifies the type of header\n      \
    \                  immediately following the Hop-by-Hop Options\n            \
    \            header.  Uses the same values as the IPv4\n                     \
    \   Protocol field [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned\
    \ integer.  Length of the\n                        Hop-by-Hop Options header in\
    \ 8-octet units,\n                        not including the first 8 octets.\n\
    \   Options              Variable-length field, of length such that the\n    \
    \                    complete Hop-by-Hop Options header is an integer\n      \
    \                  multiple of 8 octets long.  Contains one or\n             \
    \           more TLV-encoded options, as described in\n                      \
    \  section 4.2.\n   In addition to the Pad1 and PadN options specified in section\
    \ 4.2,\n   the following hop-by-hop option is defined:\n   Jumbo Payload option\
    \  (alignment requirement: 4n + 2)\n                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                       |      194      |Opt Data Len=4 |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                     Jumbo Payload Length                      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       The\
    \ Jumbo Payload option is used to send IPv6 packets with\n       payloads longer\
    \ than 65,535 octets.  The Jumbo Payload Length is\n       the length of the packet\
    \ in octets, excluding the IPv6 header but\n       including the Hop-by-Hop Options\
    \ header; it must be greater than\n       65,535.  If a packet is received with\
    \ a Jumbo Payload option\n       containing a Jumbo Payload Length less than or\
    \ equal to 65,535,\n       an ICMP Parameter Problem message, Code 0, should be\
    \ sent to the\n       packet's source, pointing to the high-order octet of the\
    \ invalid\n       Jumbo Payload Length field.\n       The Payload Length field\
    \ in the IPv6 header must be set to zero\n       in every packet that carries\
    \ the Jumbo Payload option.  If a\n       packet is received with a valid Jumbo\
    \ Payload option present and\n       a non-zero IPv6 Payload Length field, an\
    \ ICMP Parameter Problem\n       message, Code 0, should be sent to the packet's\
    \ source, pointing\n       to the Option Type field of the Jumbo Payload option.\n\
    \       The Jumbo Payload option must not be used in a packet that\n       carries\
    \ a Fragment header.  If a Fragment header is encountered\n       in a packet\
    \ that contains a valid Jumbo Payload option, an ICMP\n       Parameter Problem\
    \ message, Code 0, should be sent to the packet's\n       source, pointing to\
    \ the first octet of the Fragment header.\n       An implementation that does\
    \ not support the Jumbo Payload option\n       cannot have interfaces to links\
    \ whose link MTU is greater than\n       65,575 (40 octets of IPv6 header plus\
    \ 65,535 octets of payload).\n"
- title: 4.4  Routing Header
  contents:
  - "4.4  Routing Header\n   The Routing header is used by an IPv6 source to list\
    \ one or more\n   intermediate nodes to be \"visited\" on the way to a packet's\n\
    \   destination.  This function is very similar to IPv4's Source Route\n   options.\
    \  The Routing header is identified by a Next Header value of\n   43 in the immediately\
    \ preceding header, and has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   .  \
    \                                                             .\n   .        \
    \               type-specific data                      .\n   .              \
    \                                                 .\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Routing header.\n             \
    \           Uses the same values as the IPv4 Protocol field\n                \
    \        [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned integer.\
    \  Length of the\n                        Routing header in 8-octet units, not\
    \ including\n                        the first 8 octets.\n   Routing Type    \
    \     8-bit identifier of a particular Routing\n                        header\
    \ variant.\n   Segments Left        8-bit unsigned integer.  Number of route\n\
    \                        segments remaining, i.e., number of explicitly\n    \
    \                    listed intermediate nodes still to be visited\n         \
    \               before reaching the final destination.\n   type-specific data\
    \   Variable-length field, of format determined by\n                        the\
    \ Routing Type, and of length such that the\n                        complete\
    \ Routing header is an integer multiple\n                        of 8 octets long.\n\
    \   If, while processing a received packet, a node encounters a Routing\n   header\
    \ with an unrecognized Routing Type value, the required behavior\n   of the node\
    \ depends on the value of the Segments Left field, as\n   follows:\n      If Segments\
    \ Left is zero, the node must ignore the Routing header\n      and proceed to\
    \ process the next header in the packet, whose type\n      is identified by the\
    \ Next Header field in the Routing header.\n      If Segments Left is non-zero,\
    \ the node must discard the packet and\n      send an ICMP Parameter Problem,\
    \ Code 0, message to the packet's\n      Source Address, pointing to the unrecognized\
    \ Routing Type.\n   The Type 0 Routing header has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |  Hdr Ext Len  | Routing Type=0| Segments Left |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved    |             Strict/Loose Bit Map              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \             Address[1]                          +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \             Address[2]                          +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   .                               .                               .\n   .  \
    \                             .                               .\n   .        \
    \                       .                               .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \             Address[n]                          +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Routing header.\n             \
    \           Uses the same values as the IPv4 Protocol field\n                \
    \        [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned integer.\
    \  Length of the\n                        Routing header in 8-octet units, not\
    \ including\n                        the first 8 octets.  For the Type 0 Routing\n\
    \                        header, Hdr Ext Len is equal to two times the\n     \
    \                   number of addresses in the header, and must\n            \
    \            be an even number less than or equal to 46.\n   Routing Type    \
    \     0.\n   Segments Left        8-bit unsigned integer.  Number of route\n \
    \                       segments remaining, i.e., number of explicitly\n     \
    \                   listed intermediate nodes still to be visited\n          \
    \              before reaching the final destination.\n                      \
    \  Maximum legal value = 23.\n   Reserved             8-bit reserved field.  Initialized\
    \ to zero for\n                        transmission; ignored on reception.\n \
    \  Strict/Loose Bit Map\n                        24-bit bit-map, numbered 0 to\
    \ 23, left-to-right.\n                        Indicates, for each segment of the\
    \ route, whether\n                        or not the next destination address\
    \ must be a\n                        neighbor of the preceding address: 1 means\
    \ strict\n                        (must be a neighbor), 0 means loose (need not\
    \ be\n                        a neighbor).\n   Address[1..n]        Vector of\
    \ 128-bit addresses, numbered 1 to n.\n   Multicast addresses must not appear\
    \ in a Routing header of Type 0, or\n   in the IPv6 Destination Address field\
    \ of a packet carrying a Routing\n   header of Type 0.\n   If bit number 0 of\
    \ the Strict/Loose Bit Map has value 1, the\n   Destination Address field of the\
    \ IPv6 header in the original packet\n   must identify a neighbor of the originating\
    \ node.  If bit number 0\n   has value 0, the originator may use any legal, non-multicast\
    \ address\n   as the initial Destination Address.\n   Bits numbered greater than\
    \ n, where n is the number of addresses in\n   the Routing header, must be set\
    \ to 0 by the originator and ignored by\n   receivers.\n   A Routing header is\
    \ not examined or processed until it reaches the\n   node identified in the Destination\
    \ Address field of the IPv6 header.\n   In that node, dispatching on the Next\
    \ Header field of the immediately\n   preceding header causes the Routing header\
    \ module to be invoked,\n   which, in the case of Routing Type 0, performs the\
    \ following\n   algorithm:\n   if Segments Left = 0 {\n      proceed to process\
    \ the next header in the packet, whose type is\n      identified by the Next Header\
    \ field in the Routing header\n   }\n   else if Hdr Ext Len is odd or greater\
    \ than 46 {\n         send an ICMP Parameter Problem, Code 0, message to the Source\n\
    \         Address, pointing to the Hdr Ext Len field, and discard the\n      \
    \   packet\n   }\n   else {\n      compute n, the number of addresses in the Routing\
    \ header, by\n      dividing Hdr Ext Len by 2\n      if Segments Left is greater\
    \ than n {\n         send an ICMP Parameter Problem, Code 0, message to the Source\n\
    \         Address, pointing to the Segments Left field, and discard the\n    \
    \     packet\n      }\n      else {\n         decrement Segments Left by 1;\n\
    \         compute i, the index of the next address to be visited in\n        \
    \ the address vector, by subtracting Segments Left from n\n         if Address\
    \ [i] or the IPv6 Destination Address is multicast {\n            discard the\
    \ packet\n         }\n         else {\n            swap the IPv6 Destination Address\
    \ and Address[i]\n            if bit i of the Strict/Loose Bit map has value 1\
    \ and the\n            new Destination Address is not the address of a neighbor\n\
    \            of this node {\n               send an ICMP Destination Unreachable\
    \ -- Not a Neighbor\n               message to the Source Address and discard\
    \ the packet\n            }\n            else if the IPv6 Hop Limit is less than\
    \ or equal to 1 {\n               send an ICMP Time Exceeded -- Hop Limit Exceeded\
    \ in\n               Transit message to the Source Address and discard the\n \
    \              packet\n            }\n            else {\n               decrement\
    \ the Hop Limit by 1\n               resubmit the packet to the IPv6 module for\
    \ transmission\n               to the new destination\n            }\n       \
    \  }\n      }\n   }\n   As an example of the effects of the above algorithm, consider\
    \ the\n   case of a source node S sending a packet to destination node D, using\n\
    \   a Routing header to cause the packet to be routed via intermediate\n   nodes\
    \ I1, I2, and I3.  The values of the relevant IPv6 header and\n   Routing header\
    \ fields on each segment of the delivery path would be\n   as follows:\n   As\
    \ the packet travels from S to I1:\n        Source Address = S               \
    \   Hdr Ext Len = 6\n        Destination Address = I1            Segments Left\
    \ = 3\n                                            Address[1] = I2\n        (if\
    \ bit 0 of the Bit Map is 1,      Address[2] = I3\n         S and I1 must be neighbors;\
    \        Address[3] = D\n         this is checked by S)\n   As the packet travels\
    \ from I1 to I2:\n        Source Address = S                  Hdr Ext Len = 6\n\
    \        Destination Address = I2            Segments Left = 2\n             \
    \                               Address[1] = I1\n        (if bit 1 of the Bit\
    \ Map is 1,      Address[2] = I3\n         I1 and I2 must be neighbors;      \
    \ Address[3] = D\n         this is checked by I1)\n   As the packet travels from\
    \ I2 to I3:\n        Source Address = S                  Hdr Ext Len = 6\n   \
    \     Destination Address = I3            Segments Left = 1\n                \
    \                            Address[1] = I1\n        (if bit 2 of the Bit Map\
    \ is 1,      Address[2] = I2\n         I2 and I3 must be neighbors;       Address[3]\
    \ = D\n         this is checked by I2)\n   As the packet travels from I3 to D:\n\
    \        Source Address = S                  Hdr Ext Len = 6\n        Destination\
    \ Address = D             Segments Left = 0\n                                \
    \            Address[1] = I1\n        (if bit 3 of the Bit Map is 1,      Address[2]\
    \ = I2\n         I3 and D must be neighbors;        Address[3] = I3\n        \
    \ this is checked by I3)\n"
- title: 4.5  Fragment Header
  contents:
  - "4.5  Fragment Header\n   The Fragment header is used by an IPv6 source to send\
    \ packets larger\n   than would fit in the path MTU to their destinations.  (Note:\
    \ unlike\n   IPv4, fragmentation in IPv6 is performed only by source nodes, not\
    \ by\n   routers along a packet's delivery path -- see section 5.)  The\n   Fragment\
    \ header is identified by a Next Header value of 44 in the\n   immediately preceding\
    \ header, and has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Identification                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the initial header\n    \
    \                    type of the Fragmentable Part of the original\n         \
    \               packet (defined below).  Uses the same values\n              \
    \          as the IPv4 Protocol field [RFC-1700 et seq.].\n   Reserved       \
    \      8-bit reserved field.  Initialized to zero for\n                      \
    \  transmission; ignored on reception.\n   Fragment Offset      13-bit unsigned\
    \ integer.  The offset, in 8-octet\n                        units, of the data\
    \ following this header,\n                        relative to the start of the\
    \ Fragmentable Part\n                        of the original packet.\n   Res \
    \                 2-bit reserved field.  Initialized to zero for\n           \
    \             transmission; ignored on reception.\n   M flag               1 =\
    \ more fragments; 0 = last fragment.\n   Identification       32 bits.  See description\
    \ below.\n   In order to send a packet that is too large to fit in the MTU of\
    \ the\n   path to its destination, a source node may divide the packet into\n\
    \   fragments and send each fragment as a separate packet, to be\n   reassembled\
    \ at the receiver.\n   For every packet that is to be fragmented, the source node\
    \ generates\n   an Identification value. The Identification must be different\
    \ than\n   that of any other fragmented packet sent recently* with the same\n\
    \   Source Address and Destination Address.  If a Routing header is\n   present,\
    \ the Destination Address of concern is that of the final\n   destination.\n \
    \     * \"recently\" means within the maximum likely lifetime of a packet,\n \
    \       including transit time from source to destination and time spent\n   \
    \     awaiting reassembly with other fragments of the same packet.\n        However,\
    \ it is not required that a source node know the maximum\n        packet lifetime.\
    \  Rather, it is assumed that the requirement can\n        be met by maintaining\
    \ the Identification value as a simple, 32-\n        bit, \"wrap-around\" counter,\
    \ incremented each time a packet must\n        be fragmented.  It is an implementation\
    \ choice whether to\n        maintain a single counter for the node or multiple\
    \ counters,\n        e.g., one for each of the node's possible source addresses,\
    \ or\n        one for each active (source address, destination address)\n    \
    \    combination.\n   The initial, large, unfragmented packet is referred to as\
    \ the\n   \"original packet\", and it is considered to consist of two parts, as\n\
    \   illustrated:\n   original packet:\n   +------------------+----------------------//-----------------------+\n\
    \   |  Unfragmentable  |                 Fragmentable                  |\n   |\
    \       Part       |                     Part                      |\n   +------------------+----------------------//-----------------------+\n\
    \      The Unfragmentable Part consists of the IPv6 header plus any\n      extension\
    \ headers that must be processed by nodes en route to the\n      destination,\
    \ that is, all headers up to and including the Routing\n      header if present,\
    \ else the Hop-by-Hop Options header if present,\n      else no extension headers.\n\
    \      The Fragmentable Part consists of the rest of the packet, that is,\n  \
    \    any extension headers that need be processed only by the final\n      destination\
    \ node(s), plus the upper-layer header and data.\n   The Fragmentable Part of\
    \ the original packet is divided into\n   fragments, each, except possibly the\
    \ last (\"rightmost\") one, being an\n   integer multiple of 8 octets long.  The\
    \ fragments are transmitted in\n   separate \"fragment packets\" as illustrated:\n\
    \   original packet:\n   +------------------+--------------+--------------+--//--+----------+\n\
    \   |  Unfragmentable  |    first     |    second    |      |   last   |\n   |\
    \       Part       |   fragment   |   fragment   | .... | fragment |\n   +------------------+--------------+--------------+--//--+----------+\n\
    \   fragment packets:\n   +------------------+--------+--------------+\n   | \
    \ Unfragmentable  |Fragment|    first     |\n   |       Part       | Header |\
    \   fragment   |\n   +------------------+--------+--------------+\n   +------------------+--------+--------------+\n\
    \   |  Unfragmentable  |Fragment|    second    |\n   |       Part       | Header\
    \ |   fragment   |\n   +------------------+--------+--------------+\n        \
    \                 o\n                         o\n                         o\n\
    \   +------------------+--------+----------+\n   |  Unfragmentable  |Fragment|\
    \   last   |\n   |       Part       | Header | fragment |\n   +------------------+--------+----------+\n\
    \   Each fragment packet is composed of:\n      (1) The Unfragmentable Part of\
    \ the original packet, with the\n          Payload Length of the original IPv6\
    \ header changed to contain\n          the length of this fragment packet only\
    \ (excluding the length\n          of the IPv6 header itself), and the Next Header\
    \ field of the\n          last header of the Unfragmentable Part changed to 44.\n\
    \      (2) A Fragment header containing:\n               The Next Header value\
    \ that identifies the first header of\n               the Fragmentable Part of\
    \ the original packet.\n               A Fragment Offset containing the offset\
    \ of the fragment,\n               in 8-octet units, relative to the start of\
    \ the\n               Fragmentable Part of the original packet.  The Fragment\n\
    \               Offset of the first (\"leftmost\") fragment is 0.\n          \
    \     An M flag value of 0 if the fragment is the last\n               (\"rightmost\"\
    ) one, else an M flag value of 1.\n               The Identification value generated\
    \ for the original\n               packet.\n      (3) The fragment itself.\n \
    \  The lengths of the fragments must be chosen such that the resulting\n   fragment\
    \ packets fit within the MTU of the path to the packets'\n   destination(s).\n\
    \   At the destination, fragment packets are reassembled into their\n   original,\
    \ unfragmented form, as illustrated:\n   reassembled original packet:\n   +------------------+----------------------//------------------------+\n\
    \   |  Unfragmentable  |                 Fragmentable                   |\n  \
    \ |       Part       |                     Part                       |\n   +------------------+----------------------//------------------------+\n\
    \   The following rules govern reassembly:\n      An original packet is reassembled\
    \ only from fragment packets that\n      have the same Source Address, Destination\
    \ Address, and Fragment\n      Identification.\n      The Unfragmentable Part\
    \ of the reassembled packet consists of all\n      headers up to, but not including,\
    \ the Fragment header of the first\n      fragment packet (that is, the packet\
    \ whose Fragment Offset is\n      zero), with the following two changes:\n   \
    \      The Next Header field of the last header of the Unfragmentable\n      \
    \   Part is obtained from the Next Header field of the first\n         fragment's\
    \ Fragment header.\n         The Payload Length of the reassembled packet is computed\
    \ from\n         the length of the Unfragmentable Part and the length and offset\n\
    \         of the last fragment.  For example, a formula for computing the\n  \
    \       Payload Length of the reassembled original packet is:\n           PL.orig\
    \ = PL.first - FL.first - 8 + (8 * FO.last) + FL.last\n           where\n    \
    \       PL.orig  = Payload Length field of reassembled packet.\n           PL.first\
    \ = Payload Length field of first fragment packet.\n           FL.first = length\
    \ of fragment following Fragment header of\n                      first fragment\
    \ packet.\n           FO.last  = Fragment Offset field of Fragment header of\n\
    \                      last fragment packet.\n           FL.last  = length of\
    \ fragment following Fragment header of\n                      last fragment packet.\n\
    \      The Fragmentable Part of the reassembled packet is constructed\n      from\
    \ the fragments following the Fragment headers in each of the\n      fragment\
    \ packets.  The length of each fragment is computed by\n      subtracting from\
    \ the packet's Payload Length the length of the\n      headers between the IPv6\
    \ header and fragment itself; its relative\n      position in Fragmentable Part\
    \ is computed from its Fragment Offset\n      value.\n      The Fragment header\
    \ is not present in the final, reassembled\n      packet.\n   The following error\
    \ conditions may arise when reassembling fragmented\n   packets:\n      If insufficient\
    \ fragments are received to complete reassembly of a\n      packet within 60 seconds\
    \ of the reception of the first-arriving\n      fragment of that packet, reassembly\
    \ of that packet must be\n      abandoned and all the fragments that have been\
    \ received for that\n      packet must be discarded.  If the first fragment (i.e.,\
    \ the one\n      with a Fragment Offset of zero) has been received, an ICMP Time\n\
    \      Exceeded -- Fragment Reassembly Time Exceeded message should be\n     \
    \ sent to the source of that fragment.\n      If the length of a fragment, as\
    \ derived from the fragment packet's\n      Payload Length field, is not a multiple\
    \ of 8 octets and the M flag\n      of that fragment is 1, then that fragment\
    \ must be discarded and an\n      ICMP Parameter Problem, Code 0, message should\
    \ be sent to the\n      source of the fragment, pointing to the Payload Length\
    \ field of\n      the fragment packet.\n      If the length and offset of a fragment\
    \ are such that the Payload\n      Length of the packet reassembled from that\
    \ fragment would exceed\n      65,535 octets, then that fragment must be discarded\
    \ and an ICMP\n      Parameter Problem, Code 0, message should be sent to the\
    \ source of\n      the fragment, pointing to the Fragment Offset field of the\n\
    \      fragment packet.\n   The following conditions are not expected to occur,\
    \ but are not\n   considered errors if they do:\n      The number and content\
    \ of the headers preceding the Fragment\n      header of different fragments of\
    \ the same original packet may\n      differ.  Whatever headers are present, preceding\
    \ the Fragment\n      header in each fragment packet, are processed when the packets\n\
    \      arrive, prior to queueing the fragments for reassembly.  Only\n      those\
    \ headers in the Offset zero fragment packet are retained in\n      the reassembled\
    \ packet.\n      The Next Header values in the Fragment headers of different\n\
    \      fragments of the same original packet may differ.  Only the value\n   \
    \   from the Offset zero fragment packet is used for reassembly.\n"
- title: 4.6  Destination Options Header
  contents:
  - "4.6  Destination Options Header\n   The Destination Options header is used to\
    \ carry optional information\n   that need be examined only by a packet's destination\
    \ node(s).  The\n   Destination Options header is identified by a Next Header\
    \ value of 60\n   in the immediately preceding header, and has the following format:\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Next\
    \ Header  |  Hdr Ext Len  |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   .                                            \
    \                   .\n   .                            Options               \
    \             .\n   .                                                        \
    \       .\n   |                                                              \
    \ |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ Next Header          8-bit selector.  Identifies the type of header\n      \
    \                  immediately following the Destination Options\n           \
    \             header.  Uses the same values as the IPv4\n                    \
    \    Protocol field [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned\
    \ integer.  Length of the\n                        Destination Options header\
    \ in 8-octet units,\n                        not including the first 8 octets.\n\
    \   Options              Variable-length field, of length such that the\n    \
    \                    complete Destination Options header is an\n             \
    \           integer multiple of 8 octets long.  Contains\n                   \
    \     one or  more TLV-encoded options, as described\n                       \
    \ in section 4.2.\n   The only destination options defined in this document are\
    \ the Pad1\n   and PadN options specified in section 4.2.\n   Note that there\
    \ are two possible ways to encode optional destination\n   information in an IPv6\
    \ packet: either as an option in the Destination\n   Options header, or as a separate\
    \ extension header.  The Fragment\n   header and the Authentication header are\
    \ examples of the latter\n   approach.  Which approach can be used depends on\
    \ what action is\n   desired of a destination node that does not understand the\
    \ optional\n   information:\n      o  if the desired action is for the destination\
    \ node to discard\n         the packet and, only if the packet's Destination Address\
    \ is not\n         a multicast address, send an ICMP Unrecognized Type message\
    \ to\n         the packet's Source Address, then the information may be\n    \
    \     encoded either as a separate header or as an option in the\n         Destination\
    \ Options header whose Option Type has the value 11\n         in its highest-order\
    \ two bits.  The choice may depend on such\n         factors as which takes fewer\
    \ octets, or which yields better\n         alignment or more efficient parsing.\n\
    \      o  if any other action is desired, the information must be encoded\n  \
    \       as an option in the Destination Options header whose Option\n        \
    \ Type has the value 00, 01, or 10 in its highest-order two bits,\n         specifying\
    \ the desired action (see section 4.2).\n"
- title: 4.7 No Next Header
  contents:
  - "4.7 No Next Header\n   The value 59 in the Next Header field of an IPv6 header\
    \ or any\n   extension header indicates that there is nothing following that\n\
    \   header.  If the Payload Length field of the IPv6 header indicates the\n  \
    \ presence of octets past the end of a header whose Next Header field\n   contains\
    \ 59, those octets must be ignored, and passed on unchanged if\n   the packet\
    \ is forwarded.\n"
- title: 5. Packet Size Issues
  contents:
  - "5. Packet Size Issues\n   IPv6 requires that every link in the internet have\
    \ an MTU of 576\n   octets or greater.  On any link that cannot convey a 576-octet\
    \ packet\n   in one piece, link-specific fragmentation and reassembly must be\n\
    \   provided at a layer below IPv6.\n    From each link to which a node is directly\
    \ attached, the node must\n   be able to accept packets as large as that link's\
    \ MTU.  Links that\n   have a configurable MTU (for example, PPP links [RFC-1661])\
    \ must be\n   configured to have an MTU of at least 576 octets; it is recommended\n\
    \   that a larger MTU be configured, to accommodate possible\n   encapsulations\
    \ (i.e., tunneling) without incurring fragmentation.\n   It is strongly recommended\
    \ that IPv6 nodes implement Path MTU\n   Discovery [RFC-1191], in order to discover\
    \ and take advantage of\n   paths with MTU greater than 576 octets.  However,\
    \ a minimal IPv6\n   implementation (e.g., in a boot ROM) may simply restrict\
    \ itself to\n   sending packets no larger than 576 octets, and omit implementation\
    \ of\n   Path MTU Discovery.\n   In order to send a packet larger than a path's\
    \ MTU, a node may use\n   the IPv6 Fragment header to fragment the packet at the\
    \ source and\n   have it reassembled at the destination(s).  However, the use\
    \ of such\n   fragmentation is discouraged in any application that is able to\n\
    \   adjust its packets to fit the measured path MTU (i.e., down to 576\n   octets).\n\
    \   A node must be able to accept a fragmented packet that, after\n   reassembly,\
    \ is as large as 1500 octets, including the IPv6 header.  A\n   node is permitted\
    \ to accept fragmented packets that reassemble to\n   more than 1500 octets. \
    \ However, a node must not send fragments that\n   reassemble to a size greater\
    \ than 1500 octets unless it has explicit\n   knowledge that the destination(s)\
    \ can reassemble a packet of that\n   size.\n   In response to an IPv6 packet\
    \ that is sent to an IPv4 destination\n   (i.e., a packet that undergoes translation\
    \ from IPv6 to IPv4), the\n   originating IPv6 node may receive an ICMP Packet\
    \ Too Big message\n   reporting a Next-Hop MTU less than 576.  In that case, the\
    \ IPv6 node\n   is not required to reduce the size of subsequent packets to less\
    \ than\n   576, but must include a Fragment header in those packets so that the\n\
    \   IPv6-to-IPv4 translating router can obtain a suitable Identification\n   value\
    \ to use in resulting IPv4 fragments.  Note that this means the\n   payload may\
    \ have to be reduced to 528 octets (576 minus 40 for the\n   IPv6 header and 8\
    \ for the Fragment header), and smaller still if\n   additional extension headers\
    \ are used.\n        Note: Path MTU Discovery must be performed even in cases\
    \ where a\n        host \"thinks\" a destination is attached to the same link\
    \ as\n        itself.\n        Note: Unlike IPv4, it is unnecessary in IPv6 to\
    \ set a \"Don't\n        Fragment\" flag in the packet header in order to perform\
    \ Path MTU\n        Discovery; that is an implicit attribute of every IPv6 packet.\n\
    \        Also, those parts of the RFC-1191 procedures that involve use of\n  \
    \      a table of MTU \"plateaus\" do not apply to IPv6, because the IPv6\n  \
    \      version of the \"Datagram Too Big\" message always identifies the\n   \
    \     exact MTU to be used.\n"
- title: 6.  Flow Labels
  contents:
  - "6.  Flow Labels\n   The 24-bit Flow Label field in the IPv6 header may be used\
    \ by a\n   source to label those packets for which it requests special handling\n\
    \   by the IPv6 routers, such as non-default quality of service or\n   \"real-time\"\
    \ service.  This aspect of IPv6 is, at the time of writing,\n   still experimental\
    \ and subject to change as the requirements for flow\n   support in the Internet\
    \ become clearer.  Hosts or routers that do not\n   support the functions of the\
    \ Flow Label field are required to set the\n   field to zero when originating\
    \ a packet, pass the field on unchanged\n   when forwarding a packet, and ignore\
    \ the field when receiving a\n   packet.\n   A flow is a sequence of packets sent\
    \ from a particular source to a\n   particular (unicast or multicast) destination\
    \ for which the source\n   desires special handling by the intervening routers.\
    \  The nature of\n   that special handling might be conveyed to the routers by\
    \ a control\n   protocol, such as a resource reservation protocol, or by information\n\
    \   within the flow's packets themselves, e.g., in a hop-by-hop option.\n   The\
    \ details of such control protocols or options are beyond the scope\n   of this\
    \ document.\n   There may be multiple active flows from a source to a destination,\
    \ as\n   well as traffic that is not associated with any flow.  A flow is\n  \
    \ uniquely identified by the combination of a source address and a\n   non-zero\
    \ flow label.  Packets that do not belong to a flow carry a\n   flow label of\
    \ zero.\n   A flow label is assigned to a flow by the flow's source node.  New\n\
    \   flow labels must be chosen (pseudo-)randomly and uniformly from the\n   range\
    \ 1 to FFFFFF hex.  The purpose of the random allocation is to\n   make any set\
    \ of bits within the Flow Label field suitable for use as\n   a hash key by routers,\
    \ for looking up the state associated with the\n   flow.\n   All packets belonging\
    \ to the same flow must be sent with the same\n   source address, destination\
    \ address, priority, and flow label.  If\n   any of those packets includes a Hop-by-Hop\
    \ Options header, then they\n   all must be originated with the same Hop-by-Hop\
    \ Options header\n   contents (excluding the Next Header field of the Hop-by-Hop\
    \ Options\n   header).  If any of those packets includes a Routing header, then\n\
    \   they all must be originated with the same contents in all extension\n   headers\
    \ up to and including the Routing header (excluding the Next\n   Header field\
    \ in the Routing header).  The routers or destinations are\n   permitted, but\
    \ not required, to verify that these conditions are\n   satisfied.  If a violation\
    \ is detected, it should be reported to the\n   source by an ICMP Parameter Problem\
    \ message, Code 0, pointing to the\n   high-order octet of the Flow Label field\
    \ (i.e., offset 1 within the\n   IPv6 packet).\n   Routers are free to \"opportunistically\"\
    \ set up flow-handling state\n   for any flow, even when no explicit flow establishment\
    \ information\n   has been provided to them via a control protocol, a hop-by-hop\n\
    \   option, or other means.  For example, upon receiving a packet from a\n   particular\
    \ source with an unknown, non-zero flow label, a router may\n   process its IPv6\
    \ header and any necessary extension headers as if the\n   flow label were zero.\
    \  That processing would include determining the\n   next-hop interface, and possibly\
    \ other actions, such as updating a\n   hop-by-hop option, advancing the pointer\
    \ and addresses in a Routing\n   header, or deciding on how to queue the packet\
    \ based on its Priority\n   field.  The router may then choose to \"remember\"\
    \ the results of those\n   processing steps and cache that information, using\
    \ the source address\n   plus the flow label as the cache key.  Subsequent packets\
    \ with the\n   same source address and flow label may then be handled by referring\n\
    \   to the cached information rather than examining all those fields\n   that,\
    \ according to the requirements of the previous paragraph, can be\n   assumed\
    \ unchanged from the first packet seen in the flow.\n   Cached flow-handling state\
    \ that is set up opportunistically, as\n   discussed in the preceding paragraph,\
    \ must be discarded no more than\n   6 seconds after it is established, regardless\
    \ of whether or not\n   packets of the same flow continue to arrive.  If another\
    \ packet with\n   the same source address and flow label arrives after the cached\
    \ state\n   has been discarded, the packet undergoes full, normal processing (as\n\
    \   if its flow label were zero), which may result in the re-creation of\n   cached\
    \ flow state for that flow.\n   The lifetime of flow-handling state that is set\
    \ up explicitly, for\n   example by a control protocol or a hop-by-hop option,\
    \ must be\n   specified as part of the specification of the explicit set-up\n\
    \   mechanism; it may exceed 6 seconds.\n   A source must not re-use a flow label\
    \ for a new flow within the\n   lifetime of any flow-handling state that might\
    \ have been established\n   for the prior use of that flow label.  Since flow-handling\
    \ state with\n   a lifetime of 6 seconds may be established opportunistically\
    \ for any\n   flow, the minimum interval between the last packet of one flow and\n\
    \   the first packet of a new flow using the same flow label is 6\n   seconds.\
    \  Flow labels used for explicitly set-up flows with longer\n   flow-state lifetimes\
    \ must remain unused for those longer lifetimes\n   before being re-used for new\
    \ flows.\n   When a node stops and restarts (e.g., as a result of a \"crash\"\
    ), it\n   must be careful not to use a flow label that it might have used for\n\
    \   an earlier flow whose lifetime may not have expired yet.  This may be\n  \
    \ accomplished by recording flow label usage on stable storage so that\n   it\
    \ can be remembered across crashes, or by refraining from using any\n   flow labels\
    \ until the maximum lifetime of any possible previously\n   established flows\
    \ has expired (at least 6 seconds; more if explicit\n   flow set-up mechanisms\
    \ with longer lifetimes might have been used).\n   If the minimum time for rebooting\
    \ the node is known (often more than\n   6 seconds), that time can be deducted\
    \ from the necessary waiting\n   period before starting to allocate flow labels.\n\
    \   There is no requirement that all, or even most, packets belong to\n   flows,\
    \ i.e., carry non-zero flow labels.  This observation is placed\n   here to remind\
    \ protocol designers and implementors not to assume\n   otherwise.  For example,\
    \ it would be unwise to design a router whose\n   performance would be adequate\
    \ only if most packets belonged to flows,\n   or to design a header compression\
    \ scheme that only worked on packets\n   that belonged to flows.\n"
- title: 7.  Priority
  contents:
  - "7.  Priority\n   The 4-bit Priority field in the IPv6 header enables a source\
    \ to\n   identify the desired delivery priority of its packets, relative to\n\
    \   other packets from the same source.  The Priority values are divided\n   into\
    \ two ranges:  Values 0 through 7 are used to specify the priority\n   of traffic\
    \ for which the source is providing congestion control,\n   i.e., traffic that\
    \ \"backs off\" in response to congestion, such as TCP\n   traffic.  Values 8\
    \ through 15 are used to specify the priority of\n   traffic that does not back\
    \ off in response to congestion, e.g.,\n   \"real-time\" packets being sent at\
    \ a constant rate.\n   For congestion-controlled traffic, the following Priority\
    \ values are\n   recommended for particular application categories:\n        \
    \ 0 - uncharacterized traffic\n         1 - \"filler\" traffic (e.g., netnews)\n\
    \         2 - unattended data transfer (e.g., email)\n         3 - (reserved)\n\
    \         4 - attended bulk transfer (e.g., FTP, NFS)\n         5 - (reserved)\n\
    \         6 - interactive traffic (e.g., telnet, X)\n         7 - internet control\
    \ traffic (e.g., routing protocols, SNMP)\n   For non-congestion-controlled traffic,\
    \ the lowest Priority value (8)\n   should be used for those packets that the\
    \ sender is most willing to\n   have discarded under conditions of congestion\
    \ (e.g., high-fidelity\n   video traffic), and the highest value (15) should be\
    \ used for those\n   packets that the sender is least willing to have discarded\
    \ (e.g.,\n   low-fidelity audio traffic).  There is no relative ordering implied\n\
    \   between the congestion-controlled priorities and the non-congestion-\n   controlled\
    \ priorities.\n"
- title: 8. Upper-Layer Protocol Issues
  contents:
  - '8. Upper-Layer Protocol Issues

    '
- title: 8.1 Upper-Layer Checksums
  contents:
  - "8.1 Upper-Layer Checksums\n   Any transport or other upper-layer protocol that\
    \ includes the\n   addresses from the IP header in its checksum computation must\
    \ be\n   modified for use over IPv6, to include the 128-bit IPv6 addresses\n \
    \  instead of 32-bit IPv4 addresses.  In particular, the following\n   illustration\
    \ shows the TCP and UDP \"pseudo-header\" for IPv6:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Payload Length                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      zero                     |  Next Header  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      o  If the packet contains a Routing header, the Destination\n         Address\
    \ used in the pseudo-header is that of the final\n         destination.  At the\
    \ originating node, that address will be in\n         the last element of the\
    \ Routing header; at the recipient(s),\n         that address will be in the Destination\
    \ Address field of the\n         IPv6 header.\n      o  The Next Header value\
    \ in the pseudo-header identifies the\n         upper-layer protocol (e.g., 6\
    \ for TCP, or 17 for UDP).  It will\n         differ from the Next Header value\
    \ in the IPv6 header if there\n         are extension headers between the IPv6\
    \ header and the upper-\n         layer header.\n      o  The Payload Length used\
    \ in the pseudo-header is the length of\n         the upper-layer packet, including\
    \ the upper-layer header.  It\n         will be less than the Payload Length in\
    \ the IPv6 header (or in\n         the Jumbo Payload option) if there are extension\
    \ headers\n         between the IPv6 header and the upper-layer header.\n    \
    \  o  Unlike IPv4, when UDP packets are originated by an IPv6 node,\n        \
    \ the UDP checksum is not optional.  That is, whenever\n         originating a\
    \ UDP packet, an IPv6 node must compute a UDP\n         checksum over the packet\
    \ and the pseudo-header, and, if that\n         computation yields a result of\
    \ zero, it must be changed to hex\n         FFFF for placement in the UDP header.\
    \  IPv6 receivers must\n         discard UDP packets containing a zero checksum,\
    \ and should log\n         the error.\n   The IPv6 version of ICMP [RFC-1885]\
    \ includes the above pseudo-header\n   in its checksum computation; this is a\
    \ change from the IPv4 version\n   of ICMP, which does not include a pseudo-header\
    \ in its checksum.  The\n   reason for the change is to protect ICMP from misdelivery\
    \ or\n   corruption of those fields of the IPv6 header on which it depends,\n\
    \   which, unlike IPv4, are not covered by an internet-layer checksum.\n   The\
    \ Next Header field in the pseudo-header for ICMP contains the\n   value 58, which\
    \ identifies the IPv6 version of ICMP.\n"
- title: 8.2 Maximum Packet Lifetime
  contents:
  - "8.2 Maximum Packet Lifetime\n   Unlike IPv4, IPv6 nodes are not required to enforce\
    \ maximum packet\n   lifetime.  That is the reason the IPv4 \"Time to Live\" field\
    \ was\n   renamed \"Hop Limit\" in IPv6.  In practice, very few, if any, IPv4\n\
    \   implementations conform to the requirement that they limit packet\n   lifetime,\
    \ so this is not a change in practice.  Any upper-layer\n   protocol that relies\
    \ on the internet layer (whether IPv4 or IPv6) to\n   limit packet lifetime ought\
    \ to be upgraded to provide its own\n   mechanisms for detecting and discarding\
    \ obsolete packets.\n"
- title: 8.3 Maximum Upper-Layer Payload Size
  contents:
  - "8.3 Maximum Upper-Layer Payload Size\n   When computing the maximum payload size\
    \ available for upper-layer\n   data, an upper-layer protocol must take into account\
    \ the larger size\n   of the IPv6 header relative to the IPv4 header.  For example,\
    \ in\n   IPv4, TCP's MSS option is computed as the maximum packet size (a\n  \
    \ default value or a value learned through Path MTU Discovery) minus 40\n   octets\
    \ (20 octets for the minimum-length IPv4 header and 20 octets\n   for the minimum-length\
    \ TCP header).  When using TCP over IPv6, the\n   MSS must be computed as the\
    \ maximum packet size minus 60 octets,\n   because the minimum-length IPv6 header\
    \ (i.e., an IPv6 header with no\n   extension headers) is 20 octets longer than\
    \ a minimum-length IPv4\n   header.\n"
- title: Appendix A. Formatting Guidelines for Options
  contents:
  - "Appendix A. Formatting Guidelines for Options\n   This appendix gives some advice\
    \ on how to lay out the fields when\n   designing new options to be used in the\
    \ Hop-by-Hop Options header or\n   the Destination Options header, as described\
    \ in section 4.2.  These\n   guidelines are based on the following assumptions:\n\
    \      o  One desirable feature is that any multi-octet fields within the\n  \
    \       Option Data area of an option be aligned on their natural\n         boundaries,\
    \ i.e., fields of width n octets should be placed at\n         an integer multiple\
    \ of n octets from the start of the Hop-by-\n         Hop or Destination Options\
    \ header, for n = 1, 2, 4, or 8.\n      o  Another desirable feature is that the\
    \ Hop-by-Hop or Destination\n         Options header take up as little space as\
    \ possible, subject to\n         the requirement that the header be an integer\
    \ multiple of 8\n         octets long.\n      o  It may be assumed that, when\
    \ either of the option-bearing\n         headers are present, they carry a very\
    \ small number of options,\n         usually only one.\n   These assumptions suggest\
    \ the following approach to laying out the\n   fields of an option: order the\
    \ fields from smallest to largest, with\n   no interior padding, then derive the\
    \ alignment requirement for the\n   entire option based on the alignment requirement\
    \ of the largest field\n   (up to a maximum alignment of 8 octets).  This approach\
    \ is\n   illustrated in the following examples:\n   Example 1\n   If an option\
    \ X required two data fields, one of length 8 octets and\n   one of length 4 octets,\
    \ it would be laid out as follows:\n                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                   | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 8n+2, to ensure that the 8-octet field\n   starts\
    \ at a multiple-of-8 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 2\n   If an option Y required three data fields, one of length 4 octets,\n\
    \   one of length 2 octets, and one of length 1 octet, it would be laid\n   out\
    \ as follows:\n                                                   +-+-+-+-+-+-+-+-+\n\
    \                                                   | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 4n+3, to ensure that the 4-octet field\n   starts\
    \ at a multiple-of-4 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 3\n   A Hop-by-Hop or Destination Options header containing both options\
    \ X\n   and Y from Examples 1 and 2 would have one of the two following\n   formats,\
    \ depending on which option appeared first:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Next\
    \ Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0       |       0       | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   This document specifies that the IP Authentication\
    \ Header [RFC-1826]\n   and the IP Encapsulating Security Payload [RFC-1827] be\
    \ used with\n   IPv6, in conformance with the Security Architecture for the Internet\n\
    \   Protocol [RFC-1825].\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors gratefully acknowledge the many helpful suggestions\
    \ of\n   the members of the IPng working group, the End-to-End Protocols\n   research\
    \ group, and the Internet Community At Large.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stephen E. Deering                   Robert M. Hinden\n\
    \   Xerox Palo Alto Research Center      Ipsilon Networks, Inc.\n   3333 Coyote\
    \ Hill Road                2191 E. Bayshore Road, Suite 100\n   Palo Alto, CA\
    \ 94304                  Palo Alto, CA 94303\n   USA                         \
    \         USA\n   Phone: +1 415 812 4839               Phone: +1 415 846 4604\n\
    \   Fax:   +1 415 812 4471               Fax:   +1 415 855 1414\n   EMail: deering@parc.xerox.com\
    \        EMail: hinden@ipsilon.com\n"
- title: References
  contents:
  - "References\n   [RFC-1825]   Atkinson, R., \"Security Architecture for the Internet\n\
    \                Protocol\", RFC 1825, Naval Research Laboratory, August\n   \
    \             1995.\n   [RFC-1826]   Atkinson, R., \"IP Authentication Header\"\
    , RFC 1826,\n                Naval Research Laboratory, August 1995.\n   [RFC-1827]\
    \   Atkinson, R., \"IP Encapsulating Security Protocol\n                (ESP)\"\
    , RFC 1827, Naval Research Laboratory, August\n                1995.\n   [RFC-1885]\
    \   Conta, A., and S. Deering, \"Internet Control Message\n                Protocol\
    \ (ICMPv6) for the Internet Protocol Version 6\n                (IPv6) Specification\"\
    , RFC 1885, Digital Equipment\n                Corporation, Xerox PARC, December\
    \ 1995.\n   [RFC-1884]   Hinden, R., and S. Deering, Editors, \"IP Version 6\n\
    \                Addressing Architecture\", RFC 1884, Ipsilon Networks,\n    \
    \            Xerox PARC, December 1995.\n   [RFC-1191]   Mogul, J., and S. Deering,\
    \ \"Path MTU Discovery\", RFC\n                1191, DECWRL, Stanford University,\
    \ November 1990.\n   [RFC-791]    Postel, J., \"Internet Protocol\", STD 5, RFC\
    \ 791,\n                USC/Information Sciences Institute, September 1981.\n\
    \   [RFC-1700]   Reynolds, J., and J. Postel, \"Assigned Numbers\", STD 2,\n \
    \               RFC 1700, USC/Information Sciences Institute, October\n      \
    \          1994.\n   [RFC-1661]   Simpson, W., Editor, \"The Point-to-Point Protocol\n\
    \                (PPP)\", STD 51, RFC 1661, Daydreamer, July 1994.\n"
