Abstract The United States of America has adopted a suite of Secure Hash Algorithms (SHAs), including four beyond SHA 1, as part of a Federal Information Processing Standard (FIPS), specifically SHA 224 (RFC 3874), SHA 256, SHA 384, and SHA 512.
The purpose of this document is to make source code performing these hash functions conveniently available to the Internet community.
The sample code supports input strings of arbitrary bit length.
SHA 1's sample code from RFC 3174 has also been updated to handle input strings of arbitrary bit length.
Most of the text herein was adapted by the authors from FIPS 180 2.
Code to perform SHA based HMACs, with arbitrary bit length text, is also included.
Much of the text below is taken from [FIPS180 2] and assertions therein of the security of the algorithms described are made by the US Government, the author of [FIPS180 2], and not by the authors of this document.
The text below specifies Secure Hash Algorithms, SHA 224 [RFC3874], SHA 256, SHA 384, and SHA 512, for computing a condensed representation of a message or a data file.
(SHA 1 is specified in [RFC3174].)
When a message of any length < 2^64 bits (for SHA 224 and SHA 256) or < 2^128 bits (for SHA 384 and SHA 512) is input to one of these algorithms, the result is an output called a message digest.
The message digests range in length from 224 to 512 bits, depending on the algorithm.
Secure hash algorithms are typically used with other cryptographic algorithms, such as digital signature algorithms and keyed hash authentication codes, or in the generation of random numbers [RFC4086].
The four algorithms specified in this document are called secure because it is computationally infeasible to (1) find a message that corresponds to a given message digest, or (2) find two different messages that produce the same message digest.
Any change to a message in transit will, with very high probability, result in a different message digest.
This will result in a verification failure when the secure hash algorithm is used with a digital signature algorithm or a keyed hash message authentication algorithm.
The code provided herein supports input strings of arbitrary bit length.
SHA 1's sample code from [RFC3174] has also been updated to handle input strings of arbitrary bit length.
See Section 1.1 for license information for this code.
Section 2 below defines the terminology and functions used as building blocks to form these algorithms.
Section 3 describes the fundamental operations on words from which these algorithms are built.
Section 4 describes how messages are padded up to an integral multiple of the required block size and then parsed into blocks.
Section 5 defines the constants and the composite functions used to specify these algorithms.
Section 6 gives the actual specification for the SHA 224, SHA 256, SHA 384, and SHA 512 functions.
Section 7 provides pointers to the specification of HMAC keyed message authentication codes based on the SHA algorithms.
Section 8 gives sample code for the SHA algorithms and Section 9 code for SHA based HMACs.
The SHA based HMACs will accept arbitrary bit length text.
License Permission is granted for all uses, commercial and non commercial, of the sample code found in Section 8.
Royalty free license to use, copy, modify and distribute the software found in Section 8 is granted, provided that this document is identified in all material mentioning or referencing this software, and provided that redistributed derivative works do not contain misleading author or version information.
The authors make no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose.
It is provided "as is" without express or implied warranty of any kind.
Notation for Bit Strings and Integers
The following terminology related to bit strings and integers will be used:
A hex digit is the representation of a 4 bit string.
Examples: 7   0111, A   1010.
A word equals a 32 bit or 64 bit string, which may be represented as a sequence of 8 or 16 hex digits, respectively.
To convert a word to hex digits, each 4 bit string is converted to its hex equivalent as described in (a) above.
1111 1110 0010 0011   A103FE23.
Throughout this document, the "big endian" convention is used when expressing both 32 bit and 64 bit words, so that within each word the most significant bit is shown in the left most bit position.
An integer may be represented as a word or pair of words.
An integer between 0 and 2^32 1 inclusive may be represented as a 32 bit word.
The least significant four bits of the integer are represented by the right most hex digit of the word representation.
the integer 291   2^8 2^5 2^1 2
32 2 1 is represented by the hex word 00000123.
The same holds true for an integer between 0 and 2^64 1 inclusive, which may be represented as a 64 bit word.
If Z is an integer, 0 <  z < 2^64, then z   (2^32)x
x < 2^32 and 0
and y can be represented as words X and Y, respectively, z can be represented as the pair of words (X,Y).
512 bit or 1024 bit string.
A block (e.g., B) may be represented as a sequence of 32 bit or 64 bit words.
The following logical operators will be applied to words in all four hash operations specified herein.
SHA 224 and SHA 256 operate on 32 bit words, while SHA 384 and SHA 512 operate on 64 bit words.
In the operations below, x<<n is obtained as follows: discard the left most n bits of
and then pad the result with n zeroed bits on the right
(the result will still be the same number of bits).
a.  Bitwise logical word operations
bitwise logical "exclusive or" of X and Y. NOT
Y is defined as follows:
words X and Y represent w bit integers
and y, where 0 <  x < 2^w and
0 <  y < 2^w.
For positive integers n and m, let n mod m be the remainder upon dividing n by m.
Then 0 <  z < 2^w.
Convert z to a word, Z, and define Z
The right shift operation SHR^n(x), where x is a w bit word and n is an integer with 0 <  n < w, is defined by SHR^n(x)
The rotate right (circular right shift) operation ROTR^n(x), where x is a w bit word and n is an integer with 0 <  n < w, is defined by ROTR^n(x)
(x>>w n) Note the following equivalence relationships, where w is fixed in each relationship:
The hash functions specified herein are used to compute a message digest for a message or data file that is provided as input.
The message or data file should be considered to be a bit string.
The length of the message is the number of bits in the message (the empty message has length 0).
If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex.
The purpose of message padding is to make the total length of a padded message a multiple of 512 for SHA 224 and SHA 256 or a multiple of 1024 for SHA 384 and SHA 512.
The following specifies how this padding shall be performed.
As a summary, a "1" followed by a number of "0"s followed by a 64 bit or 128 bit integer are appended to the end of the message to produce a padded message of length 512 n or 1024 n.
The minimum number of "0"s necessary to meet this criterion is used.
The appended integer is the length of the original message.
The padded message is then processed by the hash function as n 512 bit or 1024 bit blocks.
SHA 224 and SHA 256 Suppose a message has length L < 2^64.
Before it is input to the hash function, the message is padded on the right as follows:
Example: if the original message is "01010000", this is padded to "010100001".
b.  K "0"s are appended where K is the smallest, non negative solution to the equation
K   448 (mod 512) c.
Then append the 64 bit block that is L in binary representation.
After appending this block, the length of the message will be a multiple of 512 bits.
Suppose the original message is the bit string 01100001 01100010 01100011 01100100 01100101
After step (a), this gives 01100001 01100010 01100011 01100100 01100101 1
Since L   40, the number of bits in the above is 41 and K   407 "0"s
are appended, making the total now 448.
This gives the following in hex:
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
The 64 bit representation of L   40 is hex 00000000 00000028.
Hence the final padded message is the following hex:
SHA 384 and SHA 512 Suppose a message has length L < 2^128.
Before it is input to the hash function, the message is padded on the right as follows:
Example: if the original message is "01010000", this is padded to "010100001".
b.  K "0"s are appended where K is the smallest, non negative solution to the equation
Then append the 128 bit block that is L in binary representation.
After appending this block, the length of the message will be a multiple of 1024 bits.
Suppose the original message is the bit string 01100001 01100010 01100011 01100100 01100101
this gives 01100001 01100010 01100011 01100100 01100101 1
Since L   40, the number of bits in the above is 41 and K   855 "0"s
are appended, making the total now 896.
This gives the following in hex:
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
The 128 bit representation of L   40 is hex 00000000 00000000 00000000 00000028.
Hence the final padded message is the following hex:
Functions and Constants Used The following subsections give the six logical functions and the table of constants used in each of the hash functions.
SHA 224 and SHA 256 SHA 224 and SHA 256 use six logical functions, where each function operates on 32 bit words, which are represented as x, y, and z.
The result of each function is a new 32 bit word.
(x AND y) XOR ( (NOT x) AND z)
z) XOR (y AND z) BSIG0(x)
These words represent the first thirty two bits of the fractional parts of the cube roots of the first sixty four prime numbers.
In hex, these constant words are as follows (from left to right):
748f82ee 78a5636f 84c87814 8cc70208 90befffa
SHA 384 and SHA 512 SHA 384 and SHA 512
each use six logical functions, where each function operates on 64 bit words, which are represented as x, y, and z.
The result of each function is a new 64 bit word.
(x AND y) XOR ( (NOT x) AND z)
z) XOR (y AND z) BSIG0(x)
These words represent the first sixty four bits of the fractional parts of the cube roots of the first eighty prime numbers.
In hex, these constant words are as follows (from left to right):
c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275
27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de
The output of each of the secure hash functions, after being applied to a message of N blocks, is the hash quantity H(N).
For SHA 224 and SHA 256
As described below, the hash words are initialized, modified as each message block is processed, and finally concatenated after processing the last block to yield the output.
For SHA 256 and SHA 512, all of the H(N) variables are concatenated while the SHA 224 and SHA 384 hashes are produced by omitting some from the final concatenation.
SHA 224 and SHA 256 Initialization
For SHA 224, the initial hash value, H(0), consists of the following 32 bit words in hex:
For SHA 256, the initial hash value, H(0), consists of the following eight 32 bit words, in hex.
These words were obtained by taking the first thirty two bits of the fractional parts of the square roots of the first eight prime numbers.
SHA 224 and SHA 256 Processing SHA 224 and SHA 256 perform identical processing on messages blocks and differ only in how H(0)
is initialized and how they produce their final output.
They may be used to hash a message, M, having a length of L bits, where 0 <  L < 2^64.
a message schedule of sixty four 32 bit words,
(2) eight working variables of 32 bits each, and (3) a hash value of eight 32 bit words.
The eight working variables are labeled a, b, c, d, e, f, g, and h.
They also use two temporary words, T1 and T2.
The following computations are then performed for each of the N message blocks.
All addition is performed modulo 2^32.
For i   1 to N 1.
Prepare the message schedule W:
For t   0 to 15
For t   16 to 63 Wt   SSIG1(W(t 2))
Initialize the working variables: a   H(i 1)0 b   H(i
Perform the main hash computation:
For t   0 to 63 T1
b b   a a   T1   T2 4.
Compute the intermediate hash value H(i):
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated.
For SHA 256, this is the concatenation of all of H(N)0, H(N)1, through H(N)7.
For SHA 224, this is the concatenation of H(N)0, H(N)1, through H(N)6.
SHA 384 and SHA 512 Initialization
For SHA 384, the initial hash value, H(0), consists of the following eight 64 bit words, in hex.
These words were obtained by taking the first sixty four bits of the fractional parts of the square roots of the ninth through sixteenth prime numbers.
For SHA 512, the initial hash value, H(0), consists of the following eight 64 bit words, in hex.
These words were obtained by taking the first sixty four bits of the fractional parts of the square roots of the first eight prime numbers.
SHA 384 and SHA 512
Processing SHA 384 and SHA 512 perform identical processing on message blocks and differ only in how H(0)
is initialized and how they produce their final output.
They may be used to hash a message, M, having a length of L bits, where 0 <  L < 2^128.
a message schedule of eighty 64 bit words,
(2) eight working variables of 64 bits each, and (3) a hash value of eight 64 bit words.
The eight working variables are labeled a, b, c, d, e, f, g, and h.
The following computations are then performed for each of the N message blocks.
All addition is performed modulo 2^64.
For i   1 to N 1.
Prepare the message schedule W:
For t   0 to 15
For t   16 to 79
Initialize the working variables: a   H(i 1)0 b   H(i
Perform the main hash computation:
For t   0 to 79 T1
b b   a a   T1   T2 4.
Compute the intermediate hash value H(i):
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated.
For SHA 512, this is the concatenation of all of H(N)0, H(N)1, through H(N)7.
For SHA 384, this is the concatenation of H(N)0, H(N)1, through H(N)5.
SHA Based HMACs HMAC is a method for computing a keyed MAC (message authentication code) using a hash function as described in [RFC2104].
It uses a key to mix in with the input text to produce the final hash.
Sample code is also provided, in Section 8.3 below, to perform HMAC based on any of the SHA algorithms described herein.
The sample code found in [RFC2104] was written in terms of a specified text size.
Since SHA is defined in terms of an arbitrary number of bits, the sample HMAC code has been written to allow the text input to HMAC to have an arbitrary number of octets and bits.
A fixed length interface is also provided.
C Code for SHAs Below is a demonstration implementation of these secure hash functions in C.  Section 8.1 contains the header file sha.h, which declares all constants, structures, and functions used by the sha and hmac functions.
Section 8.2 contains the C code for sha1.c, sha224 256.c, sha384 512.c, and
usha.c along with sha private.h, which provides some declarations common to all the sha functions.
Section 8.3 contains the C code for the hmac functions.
Section 8.4 contains a test driver to exercise the code.
constant returned by each function on success
constant returned by each function when presented with a null pointer parameter shaInputTooLong
constant returned by each function when the input data is too long
Structure: typedef SHA$$$Context an opaque structure holding the complete state for producing the hash Functions: int
t  octets, unsigned int bytecount); Incorporate bytecount octets into the hash.
, const uint8 t octet, unsigned int bitcount); Incorporate bitcount bits into the hash.
The bits are in the upper portion of the octet.
SHA$$$Input() cannot be called after this.
SHA$$$Result(SHA$$$Context  , uint8 t Message Digest[SHA$$$HashSize]); Do the final calculations on the hash and copy the value into Message Digest.
They add the following constants, structure, and functions:
typedef USHAContext an opaque structure holding the complete state for producing the hash Functions: int
; Reset the hash context state.
, const uint8 t  bytes, unsigned int bytecount); Incorporate bytecount octets into the hash.
, const uint8 t bits, unsigned int bitcount); Incorporate bitcount bits into the hash.
, uint8 t Message Digest[USHAMaxHashSize])
; Do the final calculations on the hash and copy the value into Message Digest.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
; The number of octets in the given hash.
; The number of bits in the given hash.
USHABlockSize(enum SHAversion whichSha); The internal block size for the given hash.
The hmac functions follow the same pattern to allow any length of text input to be used.
typedef HMACContext an opaque structure holding the complete state for producing the hash Functions: int
hmacReset(HMACContext  ctx, enum SHAversion whichSha, const unsigned char
key, int key len); Reset the hash context state.
hmacInput(HMACContext  ctx, const unsigned char  text, int text len)
; Incorporate text len octets into the hash.
ctx, const uint8 t bits, unsigned int bitcount); Incorporate bitcount bits into the hash.
ctx, uint8 t Message Digest[USHAMaxHashSize]); Do the final calculations on the hash and copy the value into Message Digest.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
In addition, a combined interface is provided, similar to that shown in RFC 2104, that allows a fixed length text input to be used.
int hmac(SHAversion whichSha, const unsigned char
text, int text len, const unsigned char
key, int key len, uint8 t Message Digest[USHAMaxHashSize]); Calculate the given digest for the given text and key, and return the resulting hash.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
64 byte / 512 bit  /
All SHA functions return one of these values.
/  input data too long
These constants hold size information for each of the SHA    hashing operations  / enum { SHA1 Message Block Size   64,
SHA224 Message Block Size   64, SHA256 Message Block Size   64, SHA384 Message Block Size   128, SHA512 Message Block Size   128, USHA Max Message Block Size   SHA512 Message Block Size,
SHA1HashSize   20, SHA224HashSize   28, SHA256HashSize   32
, SHA384HashSize   48, SHA512HashSize   64, USHAMaxHashSize   SHA512HashSize, SHA1HashSizeBits
/ typedef struct SHA1Context {
/ typedef struct SHA256Context { uint32 t Intermediate Hash[SHA256HashSize/4]; /
/ typedef struct SHA512Context { #ifdef USE 32BIT
/ uint64 t Intermediate Hash[SHA512HashSize/8]; /
It uses the SHA 256 structure for computation.
It uses the SHA 512 structure for computation.
SHA256Context sha256Context; SHA384Context sha384Context; SHA512Context sha512Context; }
/ unsigned char k opad[USHA Max Message Block Size];
extern int SHA1Input(SHA1Context  , const uint8 t  bytes, unsigned int bytecount); extern int
SHA1FinalBits(SHA1Context  , const uint8 t bits, unsigned int bitcount);
, const uint8 t  bytes, unsigned int bytecount); extern int SHA224FinalBits(SHA224Context  , const uint8 t bits, unsigned int bitcount);
, const uint8 t  bytes, unsigned int bytecount); extern int SHA256FinalBits(SHA256Context  , const uint8 t bits, unsigned int bitcount);
/ extern int SHA384Reset(SHA384Context  )
, const uint8 t  bytes, unsigned int bytecount); extern int SHA384FinalBits(SHA384Context  , const uint8 t bits, unsigned int bitcount); extern int SHA384Result(SHA384Context
/ extern int SHA512Reset(SHA512Context  )
, const uint8 t  bytes, unsigned int bytecount); extern int SHA512FinalBits(SHA512Context  , const uint8 t bits, unsigned int bitcount)
, SHAversion whichSha); extern int USHAInput(USHAContext
This interface allows a fixed length text input to be used.
This interface allows any length of text input to be used.
hmacReset(HMACContext  ctx, enum SHAversion whichSha, const unsigned char
key, int key len); extern int hmacInput(HMACContext  ctx, const unsigned char  text, int text len)
This code is primarily intended as expository and could be optimized further.
, h could be treated as a cycle and the loop unrolled, rather than doing the explicit copying.
Note that there are alternative representations of the Ch() and Maj() functions controlled by an ifdef.
SHA1Reset(SHA1Context  context) { if (!
/ int SHA1Input(SHA1Context  context, const uint8
t  message array, unsigned length) { if (!
return shaNull; if (context Computed)
; return shaStateError; } if (context Corrupted) return context Corrupted;
{ context Message Block[context Message Block Index ]
( message array & 0xFF); if (!
& (context Message Block Index   SHA1 Message Block Size)) SHA1ProcessMessageBlock(context)
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int SHA1FinalBits(SHA1Context  context, const uint8 t message bits, unsigned int length) { uint8 t masks[8]
/ 0xFE }; uint8 t markbit[8]
/ 0x01 }; if (!length) return shaSuccess; if (!
return shaNull; if (context Computed
; return shaStateError; } if (context Corrupted) return context Corrupted; SHA1AddLength(context, length); SHA1Finalize(context, (uint8 t)
Where the digest is returned.
SHA1Result(SHA1Context  context, uint8 t Message Digest[SHA1HashSize])
{ int i; if (!
if (context Corrupted) return context Corrupted; if (!
; for (i   0; i < SHA1HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>2] >
/ static void SHA1Finalize(SHA1Context  context,
uint8 t Pad Byte) { int i; SHA1PadMessage(context, Pad Byte)
/ context Length High   0
The first padding bit must be a '1'.
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
; } else context Message Block[context Message Block Index ]
(uint8 t) (context Length High >> 24); context Message Block[57]
(uint8 t) (context Length High >> 16)
(uint8 t) (context Length High >> 8);
(context Length Low >> 24); context Message Block[61]
(uint8 t) (context Length Low
> 16); context Message Block[62]
(uint8 t) (context Length Low >> 8);
(uint8 t) (context Length Low);
Constants defined in FIPS 180 2, section 4.2.1  / const
((uint32 t)context Message Block[t   4])
W[t]   SHA1 ROTL(1, W[t 3]
E   W[t]   K[3]; E   D; D   C; C   SHA1 ROTL(30,B)
context Message Block Index   0; } 8.2.2.
/  Define the SHA SIGMA and sigma macros  /
\ (SHA256 ROTR( 2,word) ^ SHA256 ROTR(13,word) ^ SHA256 ROTR(22,word))
\ (SHA256 ROTR( 6,word) ^ SHA256 ROTR(11,word) ^ SHA256 ROTR(25,word))
(SHA256 ROTR( 7,word) ^ SHA256 ROTR(18,word) ^
/ static void SHA224 256Finalize(SHA256Context  context, uint8 t Pad Byte); static void SHA224 256PadMessage(SHA256Context  context, uint8 t Pad Byte); static void SHA224
256ProcessMessageBlock(SHA256Context  context); static int SHA224
256Reset(SHA256Context  context, uint32 t  H0); static int SHA224
FIPS 180 2 section 5.3.2
/ int SHA224Reset(SHA224Context  context) { return SHA224 256Reset(context, SHA224 H0);
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
Where the digest is returned.
t  message array, unsigned int length) { if (!
return shaNull; if (context Computed)
; return shaStateError; } if (context Corrupted) return context Corrupted;
{ context Message Block[context Message Block Index ]
( message array & 0xFF);
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
, const uint8 t message bits, unsigned int length) { uint8
/ 0xFE }; uint8 t markbit[8]
/ 0x01 }; if (!length) return shaSuccess; if (!
; return shaStateError; } if (context Corrupted) return context Corrupted; SHA224 256AddLength(context, length); SHA224 256Finalize(context, (uint8 t)
Where the digest is returned.
/ static void SHA224 256Finalize(SHA256Context  context, uint8 t Pad Byte) {
The first padding bit must be a '1'.
All bits in between should be 0.
/ static void SHA224 256PadMessage(SHA256Context  context,
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
Pad Byte; while (context Message Block Index < SHA256 Message Block Size) context
Length High >> 24); context Message Block[57]
Length High >> 16); context Message Block[58]
Length High >> 8); context Message Block[59]
(uint8 t)(context Length High); context Message Block[60]
(uint8 t)(context Length Low >> 24); context Message Block[61]
Length Low >> 16); context Message Block[62]
Length Low >> 8); context Message Block[63]
0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624,
A, B, C, D, E, F, G, H;  /
W  / for (t   t4   0
; t < 16; t , t4    4) W[t]
(((uint32 t)context Message Block[t4   1])
(((uint32 t)context Message Block[t4   2])
W[t 16]; A   context Intermediate Hash[0]; B   context Intermediate Hash[1]; C   context Intermediate Hash[2]; D   context Intermediate Hash[3]; E   context Intermediate Hash[4]; F   context Intermediate Hash[5]; G   context Intermediate Hash[6]; H   context Intermediate Hash[7]; for (t   0; t < 64
SHA Ch(E,F,G)   K[t]   W[t]; temp2
SHA Maj(A,B,C); H   G; G   F; F   E;
E   D   temp1; D   C; C   B;
temp2; } context Intermediate Hash[0]
The initial hash value to use.
256Reset(SHA256Context  context, uint32 t  H0) { if (!
context Message Block Index    0; context Intermediate Hash[0]   H0[0]
; context Intermediate Hash[1]   H0[1]; context Intermediate Hash[2]
H0[2]; context Intermediate Hash[3]   H0[3]; context Intermediate Hash[4]   H0[4]; context Intermediate Hash[5]   H0[5]; context Intermediate Hash[6]   H0[6]; context Intermediate Hash[7]
H0[7]; context Computed    0; context
Where the digest is returned.
context, uint8 t Message Digest[], int HashSize)
{ int i; if (!
if (context Corrupted) return context Corrupted; if (!context Computed) SHA224 256Finalize(context, 0x80); for (i   0; i < HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>2] >
Each 64 bit number is represented in a 2 word array.
All macros are defined such that the result is the last parameter.
/ #define SHA512 SHR(bits, word, ret)
#define SHA512 SHL(bits, word, ret)
define SHA512 OR(word1, word2, ret)
/ #define SHA512 AND(word1, word2, ret)
define SHA512 ADD(word1, word2, ret)
/ static uint32 t ADDTO4 temp, ADDTO4
/ static uint32 t ADDTO2 temp; #define SHA512 ADDTO2(word1, word2)
/ static uint32 t ROTR temp1[2], ROTR temp2[2]; #define SHA512 ROTR(bits, word, ret)
SHA512 SHL(64 (bits), (word), ROTR temp2),
Define the SHA SIGMA and sigma macros    SHA512 ROTR(28,word)
, SIGMA0 temp2[2], SIGMA0 temp3[2], SIGMA0 temp4[2]; #define SHA512 SIGMA0(word, ret)
SIGMA1 temp1[2], SIGMA1 temp2[2], SIGMA1 temp3[2], SIGMA1 temp4[2]; #define SHA512 SIGMA1(word, ret)
/ static uint32 t sigma0 temp1[2], sigma0 temp2[2], sigma0 temp3[2], sigma0 temp4[2]; #define SHA512 sigma0(word, ret)
/ static uint32 t sigma1 temp1[2], sigma1 temp2[2], sigma1 temp3[2], sigma1 temp4[2]; #define SHA512 sigma1(word, ret)
SHA512 XOR(sigma1 temp1, sigma1 temp4, (ret)) )
#undef SHA Ch #undef SHA Maj #ifndef USE MODIFIED MACROS /
These definitions are the ones used in FIPS 180 2,
/ static uint32 t Ch temp1[2]
, Ch temp2[2], Ch temp3[2]; #define SHA Ch(x, y, z, ret)
SHA512 XOR(Ch temp1, Ch temp3, (ret)) )
, Maj temp2[2], Maj temp3[2], Maj temp4[2]; #define SHA Maj(x, y, z, ret)
temp2, Maj temp3, Maj temp4),
These definitions are potentially faster equivalents for the ones   used in FIPS 180 2, section 4.1.3.
(x & (y ^ z))
define SHA Ch(x, y, z, ret)
define SHA Maj(x, y, z, ret)
(length), SHA512 ADDTO4((context) Length, addTemp), \
/ static void SHA384 512Finalize(SHA512Context  context,
uint8 t Pad Byte); static void SHA384 512PadMessage(SHA512Context
/  Define the SHA SIGMA and sigma macros  /
^ SHA512 ROTR(34,word) ^ SHA512 ROTR(39,word))
(SHA512 ROTR(14,word) ^ SHA512 ROTR(18,word) ^ SHA512 ROTR(41,word))
(SHA512 ROTR( 1,word) ^ SHA512 ROTR( 8,word)
(SHA512 ROTR(19,word) ^ SHA512 ROTR(61,word)
addTemp   context Length Low, context
/ static void SHA384 512Finalize(SHA512Context  context,
uint8 t Pad Byte); static void SHA384 512PadMessage(SHA512Context
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
Where the digest is returned.
t  message array, unsigned int length) { if (!
return shaNull; if (context Computed)
; return shaStateError; } if (context Corrupted) return context Corrupted;
{ context Message Block[context Message Block Index ]
( message array & 0xFF); if (!
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int SHA512FinalBits(SHA512Context  context, const uint8 t message bits, unsigned int length) { uint8
/ 0xFE }; uint8 t markbit[8]
/ 0x01 }; if (!length) return shaSuccess; if (!
; return shaStateError; } if (context Corrupted) return context Corrupted; SHA384 512AddLength(context, length); SHA384 512Finalize(context, (uint8 t)
/ static void SHA384 512Finalize(SHA512Context
context, uint8 t Pad Byte) { int
) context Message Block[i]   0; #ifdef USE 32BIT
context Length[1]   0; context Length[2]
ONLY  / context Length Low   0
; context Length High   0; #endif /  USE 32BIT ONLY  / context
Where the digest is returned.
The first padding bit must be a '1'.
All bits in between should be 0.
/ static void SHA384 512PadMessage(SHA512Context  context,
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
(SHA512 Message Block Size 16))
{ context Message Block[context Message Block Index ]
Pad Byte; while (context Message Block Index < (SHA512 Message Block Size 16))
> 16); context Message Block[114]
(uint8 t)(context Length[1]); context Message Block[120]
> 24); context Message Block[121]
Length High >> 32); context Message Block[116]
Length High >> 8); context Message Block[119]
Length Low >> 24); context Message Block[125]
Length Low >> 16); context Message Block[126]
Length Low >> 8); context Message Block[127]
(uint8 t)(context Length Low); #endif /  USE 32BIT ONLY  / SHA384 512ProcessMessageBlock(context)
Constants defined in FIPS 180 2, section
0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8, 0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53, 0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8, 0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3, 0x748F82EE
, 0x5DEFB2FC, 0x78A5636F, 0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC, 0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B, 0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207, 0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6, 0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C
Temporary word values  / temp3[2], temp4[2], temp5[2]; uint32 t
for (t   t2   t8   0; t < 16; t , t8    8) {
; D[1]   context Intermediate Hash[7]
; E[0]   context Intermediate Hash[8]; E[1]   context Intermediate Hash[9]; F[0]
; SHA512 ADD(D, temp1, E); D[0]
, 0xB5C0FBCFEC4D3B2Fll, 0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll, 0x59F111F1B605D019ll, 0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll, 0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll, 0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll, 0xC19BF174CF692694ll, 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll, 0x0FC19DC68B8CD5B5ll
, 0x240CA1CC77AC9C65ll, 0x2DE92C6F592B0275ll, 0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll, 0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll, 0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll, 0x06CA6351E003826Fll, 0x142929670A0E6E70ll,
, 0x53380D139D95B3DFll, 0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll, 0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll, 0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll, 0xD69906245565A910ll, 0xF40E35855771202All, 0x106AA07032BBD1B8ll, 0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll, 0x2748774CDF8EEB99ll, 0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll, 0x5B9CCA4F7763E373ll,
0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll, 0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll, 0x90BEFFFA23631E28ll, 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll, 0xC67178F2E372532Bll,
0xCA273ECEEA26619Cll, 0xD186B8C721C0C207ll, 0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll, 0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll, 0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll, 0x431D67C49C100D4Cll, 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All, 0x5FCB6FAB3AD6FAECll,
A, B, C, D, E, F, G, H;  /
for (t   t8   0; t < 16; t , t8    8)
((uint64 t)(context Message Block[t8  ])
((uint64 t)(context Message Block[t8   1])
((uint64 t)(context Message Block[t8   2])
((uint64 t)(context Message Block[t8   3])
((uint64 t)(context Message Block[t8   4])
((uint64 t)(context Message Block[t8   5])
((uint64 t)(context Message Block[t8   6])
W[t 16]; A   context Intermediate Hash[0]; B   context Intermediate Hash[1]; C   context Intermediate Hash[2]; D   context Intermediate Hash[3]; E   context Intermediate Hash[4]; F   context Intermediate Hash[5]; G   context Intermediate Hash[6]; H   context Intermediate Hash[7]; for (t   0; t < 80
SHA Ch(E,F,G)   K[t]   W[t]; temp2
SHA Maj(A,B,C); H   G; G   F; F   E;
E   D   temp1; D   C; C   B;
temp2; } context Intermediate Hash[0]
H; #endif /  USE 32BIT ONLY
The initial hash value to use.
512Reset(SHA512Context  context, uint32 t H0[])
/ static int SHA384 512Reset(SHA512Context
if (!context) return shaNull; context Message Block Index   0; #ifdef USE 32BIT ONLY context
context Length[1]   0; context Length[2]
context Length[3]   0; for (i   0; i < SHA512HashSize/4; i ) context Intermediate Hash[i]
ONLY  / context Length High   context
Length Low   0; for (i   0; i < SHA512HashSize/8; i ) context Intermediate Hash[i]
H0[i]; #endif /  USE 32BIT ONLY  / context Computed   0
Where the digest is returned.
/ static int SHA384 512ResultN(SHA512Context
context, uint8 t Message Digest[], int HashSize)
{ int i; #ifdef USE 32BIT ONLY int i2; #endif /  USE 32BIT
if (context Corrupted) return context Corrupted; if (!context Computed)
SHA384 512Finalize(context, 0x80); #ifdef USE 32BIT ONLY for (i
Intermediate Hash[i2]>>24); Message Digest[i ]
Intermediate Hash[i2]>>16); Message Digest[i ]
Intermediate Hash[i2]>>24); Message Digest[i ]
Intermediate Hash[i2]>>16); Message Digest[i ]
ONLY  / for (i   0; i < HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>3]
ctx, enum SHAversion whichSha) { if (ctx)
; switch (whichSha) { case SHA1:
ctx, const uint8 t  bytes, unsigned int bytecount) { if (ctx)
{ switch (ctx whichSha) { case SHA1: return SHA1Input((SHA1Context )&ctx ctx, bytes, bytecount)
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
ctx, const uint8 t bits, unsigned int bitcount) { if (ctx)
Where the digest is returned.
{ switch (ctx whichSha) { case SHA1: return SHA1Result((SHA1Context )&ctx ctx, Message Digest)
{ switch (whichSha) { case SHA1:
return SHA1 Message Block Size
; case SHA224: return SHA224 Message Block Size; case SHA256: return SHA256 Message Block Size; case SHA384:
/ int USHAHashSize(enum SHAversion whichSha)
{ switch (whichSha) { case SHA1:
{ switch (whichSha) { case SHA1:
SHA PRIVATE H #define  SHA PRIVATE H /
These definitions are defined in FIPS 180 2, section 4.1.
Ch() and Maj() are defined identically in sections 4.1.1,   4.1.2 and 4.1.3.
The definitions used in FIPS 180 2 are as follows:  /
The following definitions are equivalent and potentially faster.
define SHA Ch(x, y, z)
#define SHA Maj(x, y, z)
endif /  USE MODIFIED MACROS  /
define SHA Parity(x, y, z)
/ int hmac(SHAversion whichSha, const unsigned char
text, int text len, const unsigned char
ctx, enum SHAversion whichSha, const unsigned char
) return shaNull; blocksize   ctx
/ if (key len > blocksize) { USHAContext tctx;
USHAResult(&tctx, tempkey); if (err !
ipad is the byte 0x36 repeated blocksize times
opad is the byte 0x5c repeated blocksize times   and
text is the data being protected.
/ return USHAReset(&ctx shaContext, whichSha)
ctx, const unsigned char  text, int text len) {
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
ctx, const uint8 t bits, unsigned int bitcount) { if (!
Where the digest is returned.
ctx, uint8 t  digest) {
(Use digest here as a temporary buffer.)
/ return USHAResult(&ctx shaContext, digest)
/ USHAReset(&ctx shaContext, ctx whichSha)
ctx k opad, ctx blockSize)
then results of 1st hash
/ USHAInput(&ctx shaContext, digest, ctx hashSize)
The Test Driver The following code is a main program test driver to exercise the code in sha1.c, sha224 256.c, and sha384 512.c.
The test driver can also be used as a stand alone program for generating the hashes.
See also [RFC2202], [RFC4231], and [SHAVS].
To run the tests and just see PASSED/FAILED, use the  p option.
> #include <string.h> #include <ctype.h> #include "sha.h" static int xgetopt(int argc, char
argv, const char  optstring); extern char  xoptarg; static int
#define TEST10 256 \ "
" #define TEST10 384 \
\x8d\x4e\x3c\x0e\x38\x89\x19\x14\x91\x81\x6e\x9d\x98\xbf\xf0\xa0" #define TEST9 512 \ "
#define PRINTHEX 3 #define PRINTBASE64 4
#define PRINTPASSFAIL 1 #define PRINTFAIL
/ struct hash { const char  name; SHAversion whichSha; int hashsize; struct { const char  testarray; int length; long repeatcount; int extrabits; int numberExtrabits;
/ { TEST2 1, length(TEST2 1), 1, 0, 0, "84983E441C3BD26EBAAE4AA1F95129E5E54670F1" },
/ struct hmachash { const char  keyarray[5]; int keylength[5]
"; int checkmatch(const unsigned char  hashvalue, const char  hexstr, int hashsize) { int i; for (i   0
; i < hashsize;  i) { if (
> 4) & 0xF]) return 0;
{ fprintf(stderr, "Usage:\n" "Common options: [ h hash] [ w  x]
[ H]\n" "Standard tests:\n" "\t%s [ m]
[ l loopcount] [ t test#]
FAILED\n" " X\tprint FAILED, but not PASSED\n" " r\tseed for random test\n" "
R\thow many times to run random test\n" " s\tstring to hash\n" " S\texpected result of hashed string, in
hex\n" " w\toutput hash in raw format\n" " x\toutput hash in hex
format\n" " B\t# extra bits to add in after string or file
input\n" " b\textra bits to add (high order bits of #, 0
# or 0x#)\n" " H\tinput hashstr or randomseed is in
Message Digest, int hashsize, const char  hashname, const char
testtype, const char  testname, const char
resultarray, int printResults, int printPassFail)
{ int i, k; if (printResults   PRINTTEXT)
{ putchar('\t'); for (i   0; i < hashsize ;  i)
The input is the testarray,   repeated repeatcount times, followed by the extrabits.
If the   result is known, it is in resultarray in uppercase hex.
/ int hash(int testno, int loopno, int hashno, const char
testarray, int length, long repeatcount, int numberExtrabits, int extrabits, const unsigned char
, int hashsize, int printResults, int printPassFail) { USHAContext sha; HMACContext hmac; int err, i; uint8 t Message Digest[USHAMaxHashSize]; char buf[20]; if (printResults   PRINTTEXT) { printf("\nTest
hmacReset(&hmac, hashes[hashno].whichSha, keyarray, keylen) : USHAReset(&sha, hashes[hashno].whichSha); if (err !
hmacInput(&hmac, (const uint8 t  ) testarray, length) : USHAInput(&sha,
(const uint8 t  ) testarray, length);
hmacFinalBits(&hmac, (uint8 t) extrabits, numberExtrabits) :
USHAFinalBits(&sha, (uint8 t) extrabits, numberExtrabits); if (err !
hmacResult(&hmac, Message Digest) : USHAResult(&sha, Message Digest); if (err !
Digest, hashsize, hashes[hashno].name, keyarray ? "
The input is a filename.
If the result is known, it is in resultarray in uppercase hex.
/ int hashfile(int hashno, const char  hashfilename, int bits, int bitcount, int skipSpaces, const unsigned char
, int hashsize, int printResults, int printPassFail) { USHAContext sha; HMACContext hmac; int err, nread, c; unsigned char buf[4096]; uint8 t Message Digest[USHAMaxHashSize]; unsigned char cc;
stdin : fopen(hashfilename, "r"); if (!
hmacReset(&hmac, hashes[hashno].whichSha, keyarray, keylen) : USHAReset(&sha, hashes[hashno].whichSha); if (err !
hmacInput(&hmac, &cc, 1) : USHAInput(&sha, &cc, 1); if (err !
hmacInput(&hmac, buf, nread) : USHAInput(&sha, buf, nread); if (err !
USHAFinalBits(&sha, bits, bitcount); if (err !  shaSuccess) {
hmacResult(&hmac, Message Digest) : USHAResult(&sha, Message Digest); if (err !
Digest, hashsize, hashes[hashno].name, "file", hashfilename, resultarray, printResults, printPassFail); if (hashfp !
The input is an initial seed.
That seed is replicated 3 times.
For 1000 rounds, the previous three results are used as the input.
This result is then checked, and used to seed the next cycle.
If the result is known, it is in resultarrays in uppercase hex.
resultarrays, int randomcount, int printResults, int printPassFail)
Seed A random seed n bits long
MDj  / sprintf(buf, "%d", j); printResult(SEED, hashsize, hashes[hashno].name, "random test", buf, resultarrays ?
resultarrays[j] : 0, printResults, (j < RANDOMCOUNT) ?
argv0, const char  opt) { int i;
Run some tests that should invoke errors.
/ void testErrors(int hashnolow, int hashnohigh,
{ USHAContext usha; uint8 t Message Digest[USHAMaxHashSize]; int hashno, err; for (hashno   hashnolow; hashno <  hashnohigh; hashno ) {
printf("%s se: %s\n", hashes[hashno].name, (err
printf ("\nError %d. Should be %d.\n", err, shaStateError); if ((printPassFail   PRINTPASSFAIL)
printf("%s se: %s\n", hashes[hashno].name, (err
printf("\nError %d. Should be %d.\n", err, shaNull); if ((printPassFail   PRINTPASSFAIL)
; break; case SHA384: err   SHA384Reset(0); break; case SHA512: err   SHA512Reset(0); break; } if (printResults   PRINTTEXT)
printf("\nError %d. Should be %d.\n", err, shaNull); if ((printPassFail   PRINTPASSFAIL)
%s\n", hashes[hashno].name, (err   shaNull) ?
{ nibble1   tolower( hexstr) 'a'   10; } else if (isdigit((int)(unsigned char)( hexstr)))
{ printf("\nError: bad hex character '%c'\n",  hexstr); }
{ int i, err; int loopno, loopnohigh   1; int hashno,
hashnolow   0, hashnohigh   HASHCOUNT 1; int testno, testnolow   0, testnohigh;
int ntestnohigh   0; int printResults   PRINTTEXT; int printPassFail   1;
0; char  hashstr   0; int hashlen   0; const char  resultstr   0; char  randomseedstr   0; int runHmacTests   0; char  hmacKey   0; int hmaclen   0; int randomcount   RANDOMCOUNT; const char  hashfilename   0; const char  hashFilename   0; int extrabits   0, numberExtrabits   0;
; while ((i   xgetopt(argc, argv, "b:
{ case 'b': extrabits   strtol(xoptarg, 0, 0); break; case 'B': numberExtrabits
checkErrors   1; break; case 'f': hashfilename   xoptarg; break; case 'F': hashFilename   xoptarg; break; case 'h': hashnolow   hashnohigh   findhash(argv[0], xoptarg); break; case 'H':
strIsHex   1; break; case 'k':
; break; case 'l': loopnohigh   atoi(xoptarg); break; case 'm':
runHmacTests   1; break; case 'P': printPassFail   0; break; case 'p': printResults   PRINTNONE;
break; case 'R': randomcount   atoi(xoptarg); break; case 'r': randomseedstr   xoptarg; break;
case 's': hashstr   xoptarg; hashlen   strlen(hashstr); break; case 'S': resultstr   xoptarg; break; case 't': testnolow
atoi(xoptarg) 1; break; case 'w': printResults   PRINTRAW; break; case 'x': printResults   PRINTHEX; break;
hash(0, loopno, hashno, hashstr, hashlen, 1, numberExtrabits, extrabits, (const unsigned char  )
hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail); else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail); else if (hashfilename)
hashfile(hashno, hashfilename, extrabits, numberExtrabits, 0,
(const unsigned char  )hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail); else if (hashFilename)
hash(testno, loopno, hashno, hmachashes[testno].dataarray[hashno] ?
hmachashes[testno].dataarray[1] : hmachashes[testno].dataarray[0], hmachashes[testno].datalength[hashno] ?
hmachashes[testno].keyarray[1] : hmachashes[testno].keyarray[0]), hmachashes[testno].keylength[hashno] ?
Equivalent to strcasecmp() found on some systems.
This is a copy of getopt provided for those systems that do not   have it.
The name was changed to xgetopt to not conflict on those   systems that do have it.
Similarly, optarg, optind and opterr   were renamed to xoptarg, xoptind and xopterr.
Copyright 1990, 1991, 1992 by the Massachusetts Institute of   Technology and UniSoft Group Limited.
Permission to use, copy, modify, distribute, and sell this software   and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and   that both that copyright notice and this permission notice appear in   supporting documentation, and that the names of MIT and UniSoft not   be used in advertising or publicity pertaining to distribution of   the software without specific, written prior permission.
MIT and   UniSoft make no representations about the suitability of this   software for any purpose.
It is provided "as is" without express   or implied warranty.
Reformatted to match above style.
At beginning of arg but not an option  /
if (avplace   0) { if (ap[0] !
cp   strchr(optstring, c); if (cp
/  There should be an option arg
if ( xoptind >  argc) { if (xopterr)
This document is intended to provides the Internet community convenient access to source code that implements the United States of America Federal Information Processing Standard Secure Hash Algorithms (SHAs)
[FIPS180 2] and HMACs based upon these one way hash functions.
See license in Section 1.1.
No independent assertion of the security of this hash function by the authors for any particular use is intended.
