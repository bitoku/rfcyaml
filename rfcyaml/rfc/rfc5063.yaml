- contents:
  - "        Extensions to GMPLS Resource Reservation Protocol (RSVP)\n                            Graceful
    Restart\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document describes extensions to the Resource Reservation\n
    \  Protocol (RSVP) Graceful Restart mechanisms defined in RFC 3473.  The\n   extensions
    enable the recovery of RSVP signaling state based on the\n   Path message last
    sent by the node being restarted.\n   Previously defined Graceful Restart mechanisms,
    also called recovery\n   from nodal faults, permit recovery of signaling state
    from adjacent\n   nodes when the data plane has retained the associated forwarding\n
    \  state across a restart.  Those mechanisms do not fully support\n   signaling
    state recovery on ingress nodes or recovery of all RSVP\n   objects.\n   The extensions
    defined in this document build on the RSVP Hello\n   extensions defined in RFC
    3209, and extensions for state recovery on\n   nodal faults defined in RFC 3473.
    \ Using these extensions, the\n   restarting node can recover all previously transmitted
    Path state,\n   including the Explicit Route Object and the downstream (outgoing)\n
    \  interface identifiers.  The extensions can also be used to recover\n   signaling
    state after the restart of an ingress node.\n   These extensions are not used
    to create or restore data plane state.\n   The extensions optionally support the
    use of Summary Refresh, defined\n   in RFC 2961, to reduce the number of messages
    exchanged during the\n   Recovery Phase when the restarting node has recovered
    signaling state\n   locally for one or more Label Switched Paths (LSPs).\n   Table
    of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions Used in This Document ...............................5\n   3.
    Terminology .....................................................5\n   4. Extensions
    to Nodal Fault Handling ..............................5\n      4.1. RecoveryPath
    Message Format ................................5\n      4.2. Capability Object
    ..........................................6\n           4.2.1. Conformance .........................................7\n
    \     4.3. Related Procedures .........................................7\n      4.4.
    Procedures for the Capability Object .......................8\n           4.4.1.
    Procedures for the Downstream Neighbor ..............8\n           4.4.2. Procedures
    for the Restarting Node ..................8\n      4.5. Procedures for the RecoveryPath
    Message ....................9\n           4.5.1. Procedures for the Downstream
    Neighbor ..............9\n           4.5.2. Procedures for the Restarting Node
    .................10\n                  4.5.2.1. Path and RecoveryPath Message
    Procedures ..11\n                  4.5.2.2. Re-Synchronization Procedures .............12\n
    \                 4.5.2.3. Procedures on Expiration of\n                           Recovery
    Period ...........................13\n      4.6. Compatibility .............................................13\n
    \  5. RecoveryPath Summary Refresh ...................................14\n      5.1.
    MESSAGE_ID ACK/NACK and MESSAGE_ID LIST Objects ...........15\n      5.2. RecoveryPath
    Srefresh Capable Bit .........................16\n           5.2.1. Procedures
    .........................................16\n           5.2.2. Compatibility ......................................17\n
    \     5.3. RecoveryPath Summary Refresh Procedures ...................17\n           5.3.1.
    Generation of RecoveryPath-Related Srefresh\n                  Messages ...........................................17\n
    \          5.3.2. RecoveryPath-Related Srefresh Receive\n                  Processing
    and NACK Generation .....................19\n           5.3.3. RecoveryPath-Related
    MESSAGE_ID NACK\n                  Receive Processing .................................19\n
    \  6. Security Considerations ........................................20\n   7.
    Acknowledgments ................................................21\n   8. IANA
    Considerations ............................................21\n   9. Normative
    References ...........................................22\n"
  title: Abstract
- contents:
  - "1.  Introduction\n   RSVP Graceful Restart is defined in [RFC3473] and uses mechanisms\n
    \  defined in [RFC3209].  When data/forwarding plane state can be\n   retained
    across the restart of the RSVP agent that established such\n   state, RSVP Graceful
    Restart provides the ability for the RSVP agent\n   to resynchronize its state
    based on updates received from its\n   neighboring RSVP agents, and, reconcile
    such state with the retained\n   data/forwarding plane state.  [RFC3209] describes
    a mechanism, using\n   RSVP Hello messages, to detect the state of an adjacent
    RSVP agent.\n   [RFC3473] extends this mechanism to advertise the capability of\n
    \  retaining data/forwarding plane state across the restart of a node or\n   a
    \"nodal fault\".  [RFC3473] also defines the Recovery Label object\n   for use
    in the Path message of the RSVP neighbor upstream of a\n   restarting node, to
    indicate that the Path message is for existing\n   data plane state.\n   This
    document presents extensions to address two aspects of graceful\n   restart not
    previously supported.  The presented extensions enable a\n   restarting node to
    recover all objects in previously transmitted Path\n   messages, including the
    Explicit Route Object (ERO), from its\n   downstream neighbors, thus recovering
    the control plane state.  The\n   extensions do not facilitate the recovery or
    creation of\n   data/forwarding plane state, and can only be used to reestablish\n
    \  control plane state that matches in-place data/forwarding state.  The\n   extensions
    also enable graceful restart of an ingress node that does\n   not preserve full
    RSVP state across restarts.  The presented\n   extensions are equally applicable
    to LSPs of various switching types\n   as defined in [RFC3471].\n   Per [RFC3473],
    a restarting node can distinguish Path messages\n   associated with LSPs being
    recovered by the presence of the Recovery\n   Label object.  To determine the
    downstream (outgoing) interface and\n   associated label(s), the restarting node
    must consult the data plane.\n   This may not be possible for all types of nodes.
    \ Furthermore, data\n   plane information is not sufficient to reconstruct all
    previously\n   transmitted Path state.  In these cases, the only source of RSVP\n
    \  state is the downstream RSVP neighbor.\n   For example, when the restarting
    node is an ingress node, all\n   previously transmitted Path state may need to
    be recovered.  Such\n   Path state may include (but is not restricted to) the
    Protection\n   object, the Admin Status object, the Session Attribute object,
    the\n   Notify Request object, and the Sender Tspec object.  A restarting\n   transit
    node may have modified received Path state in its previously\n   transmitted Path
    message, which cannot be reconstructed internally\n   during recovery.\n   Another
    example of state that cannot be completely recovered from the\n   data plane in
    some cases is the previously transmitted ERO.  Recovery\n   of the previously
    transmitted ERO minimizes subsequent change of\n   downstream LSP state.  On a
    restarting ingress node, the ERO may have\n   been based on configuration or the
    result of a previous path\n   computation.  A restarting transit node may have
    previously performed\n   some form of path computation as a result of not receiving
    an ERO or\n   receiving a loose hop in the ERO.  In addition to the ERO, the\n
    \  restarting node may have modified other received Path state in its\n   previously
    transmitted Path state, which cannot be reconstructed\n   internally during recovery.\n
    \  The defined extensions provide a restarting upstream node with all\n   information
    previously transmitted by the node in Path messages.\n   This is accomplished
    by the downstream RSVP neighbor sending a new\n   message for every Path message
    it has previously received from the\n   restarting node, after reestablishing
    RSVP communication with a\n   restarted node that supports the recovery procedures
    defined in\n   Section 4.5.2 of this document.\n   The new message is called the
    RecoveryPath message.  The message\n   conveys the contents of the last received
    Path message back to the\n   restarting node.  The restarting node can use the
    RecoveryPath\n   message, along with the state in the received Path message to\n
    \  associate control and data plane state and to validate the forwarding\n   state
    with the state presented by the neighboring RSVP nodes.\n   The restarting node
    indicates its desire to receive and process the\n   RecoveryPath message by including
    a new object called the Capability\n   object with the RecoveryPath Desired bit
    set, in its Hello messages\n   sent to the downstream RSVP neighbor.  The downstream
    RSVP neighbor\n   can indicate its ability to send RecoveryPath messages by including\n
    \  the Capability object with the RecoveryPath Transmit Enabled set in\n   its
    Hello messages to the restarting node.  Thus, both the restarting\n   node and
    its RSVP neighbor, with the help of the Capability object,\n   can detect if the
    RecoveryPath message extensions defined in this\n   document can be used to recover
    signaling state after a restart.\n   If the restarting node is a transit node,
    it will receive a Path\n   message with a Recovery Label object from its upstream
    RSVP neighbor.\n   In addition, the RecoveryPath message allows such transit nodes
    to\n   reconstruct any state that was previously dynamically constructed by\n
    \  the node, e.g., ERO sub-objects.  If the restarting node is an\n   ingress
    node, all significant signaling state can be recovered based\n   on the RecoveryPath
    message.\n   Selective transmission of the RecoveryPath message is supported by\n
    \  enhancing the Summary Refresh mechanisms defined in [RFC2961].  When\n   Recovery
    Summary Refresh is supported, the restarting node can select\n   the LSPs for
    which it would like to receive RecoveryPath messages.\n   This is useful when
    the restarting node is able to locally recover\n   the signaling state for a subset
    of the previously active LSPs.\n   Restarting egress nodes, and Resv message processing
    are not impacted\n   by the presented extensions, see [RFC3473] for details.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  Terminology\n   The reader is assumed to be familiar with the terminology
    defined in\n   [RFC3209] and [RFC3473].\n   Throughout this document, the term
    \"node\", when used in the context\n   of a restarting or restarted node, generally
    refers to the control\n   plane component, which is the signaling controller for
    a data plane\n   switch.\n"
  title: 3.  Terminology
- contents:
  - "4.  Extensions to Nodal Fault Handling\n   This section presents the protocol
    modifications to Section 9 of\n   [RFC3473].\n"
  - contents:
    - "4.1.  RecoveryPath Message Format\n   The format of a RecoveryPath message
      is the same as the format of a\n   Path message, as defined in [RFC3473], but
      uses a new message number\n   (30) so that it can be identified correctly.\n
      \     <RecoveryPath Message> ::= <Path Message>\n   The destination address
      used in the IP header of a RecoveryPath\n   message MUST be the same as the
      destination address used in the IP\n   header of the corresponding Resv message
      last generated by the\n   sending node.  Except as specified below, all objects
      in a\n   RecoveryPath message are identical to the objects in the\n   corresponding
      Path message last received by the sending node.\n"
    title: 4.1.  RecoveryPath Message Format
  - contents:
    - "4.2.  Capability Object\n   Capability objects are carried in RSVP Hello messages.
      \ The\n   Capability object uses Class-Number 134 (of form 10bbbbbb) and C-Type\n
      \  of 1.\n   The message format of a Hello message is modified to be:\n      <Hello
      Message> ::= <Common Header> [ <INTEGRITY> ] <HELLO>\n                          [
      <RESTART_CAP> ] [ <CAPABILITY> ]\n   The format of a Capability object is:\n
      \      0                   1                   2                   3\n       0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |            Length             | Class-Num(134)|  C-Type  (1)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                         Reserved                        |T|R|S|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     RecoveryPath Transmit Enabled (T): 1 bit\n         When set (1), indicates
      that the sending node is enabled to\n         send RecoveryPath messages.  Absence
      of the Capability object\n         MUST be treated as if the T-bit is cleared
      (0).\n      RecoveryPath Desired (R): 1 bit\n         When set (1), indicates
      that the sending node desires to\n         receive RecoveryPath messages.  Absence
      of the Capability\n         object MUST be treated as if the R-bit is cleared
      (0).\n      RecoveryPath Srefresh Capable (S): 1 bit\n         When set (1),
      along with the R-bit, indicates that the sending\n         node is capable of
      receiving and processing Srefresh messages\n         with the RecoveryPath Flag
      set (1) in the MESSAGE_ID LIST\n         object.  Absence of the Capability
      object MUST be treated as if\n         the S-bit is cleared (0).  Related procedures
      are defined in\n         Section 5.2.1.\n      Reserved bits\n         Reserved
      bits MUST be set to zero on transmission and MUST be\n         ignored on receipt.\n"
    - contents:
      - "4.2.1.  Conformance\n   All nodes supporting the extensions defined in this
        document MUST be\n   able to transmit, and properly receive and process RecoveryPath\n
        \  messages.  All nodes MUST be able to set both the T and R bits.  Both\n
        \  the T and R bits SHOULD be set (1) by default.  A node MAY allow\n   RecoveryPath
        message transmission and reception to be independently\n   disabled based
        on local policy.  When RecoveryPath message\n   transmission is disabled,
        the T-bit MUST be set to zero (0).  When\n   RecoveryPath message reception
        is not desired, the R-bit MUST be set\n   to zero (0).\n   Any node that supports
        the extensions defined in this document and\n   sets the Refresh-Reduction-Capable
        bit [RFC2961] SHOULD support\n   setting of the S-bit and support the mechanisms
        defined in Section 5.\n"
      title: 4.2.1.  Conformance
    title: 4.2.  Capability Object
  - contents:
    - "4.3.  Related Procedures\n   This document does not modify existing procedures
      for sending and\n   receiving RSVP Hello messages, as defined in [RFC3209],
      and the\n   Restart_Cap object in RSVP Hello messages as defined in [RFC3473].\n
      \  The procedures for control channel faults are defined in [RFC3473]\n   and
      are not changed by this document.\n   The presented extensions require the use
      of RSVP Hellos, as defined\n   in [RFC3209], and the use of the Restart_Cap
      object extension as\n   defined in [RFC3473].  The presented extensions address
      only \"Nodal\n   Faults\" as defined in [RFC3473].  Control channel faults are
      fully\n   addressed in [RFC3473].\n   Note: There are no changes to the procedures
      defined in Section 9.5.3\n   in [RFC3473] (Procedures for the Neighbor of a
      Restarting node).\n   There are no changes to the procedures defined in Section
      9.5.2 in\n   [RFC3473] if the restarting node is an egress node.\n   There are
      no changes to the procedures with respect to the\n   data/forwarding plane as
      described in [RFC3473].  In particular, a\n   restarting node MUST NOT create
      data/forwarding plane state as the\n   result of any of the extensions defined
      in this document.\n   The following sections assume previously defined procedures
      are\n   followed, except where explicitly modified.\n"
    title: 4.3.  Related Procedures
  - contents:
    - '4.4.  Procedures for the Capability Object

      '
    - contents:
      - "4.4.1.  Procedures for the Downstream Neighbor\n   If a node is capable of
        sending RecoveryPath messages, it MUST\n   include the Capability object with
        the RecoveryPath Transmit Enabled\n   (T) bit set (1) in all its Hello messages.\n
        \  If the downstream RSVP neighbor receives Hello messages from a\n   restarting
        node, with the Restart_Cap object, as defined in\n   [RFC3473], and with the
        Capability object with the RecoveryPath\n   Desired (R) bit set (1), it MUST
        treat the restarting node as capable\n   of receiving and processing RecoveryPath
        messages as defined in this\n   document.\n   If the downstream RSVP neighbor
        receives a Capability object in a\n   Hello message with the RecoveryPath
        Desired (R) bit set (1), but\n   without the Restart_Cap object, it MUST process
        the Hello message as\n   if the RecoveryPath Receive Desired (R) bit is cleared
        (0) in the\n   Hello message.\n   If the downstream RSVP neighbor does not
        receive the Capability\n   object in Hello messages sent by the restarting
        node or the\n   RecoveryPath Desired (R) bit is cleared (0) in the Capability
        object,\n   it MUST treat the restarting node as not capable of supporting
        the\n   RecoveryPath message procedures defined in this document, and MUST\n
        \  revert to recovery procedures as defined in [RFC3473].\n"
      title: 4.4.1.  Procedures for the Downstream Neighbor
    - contents:
      - "4.4.2.  Procedures for the Restarting Node\n   A node that expects to recover
        RSVP state by the receipt and\n   processing of RecoveryPath messages according
        to procedures defined\n   in this document, MUST include the Capability object
        with the\n   RecoveryPath Desired (R) bit set (1) in its RSVP Hello messages
        to\n   its neighbors.  The node MUST also include the Restart_Cap object,
        as\n   defined in [RFC3473], in all those Hello messages.\n   If the Recovery
        Time is zero (0) or the restarting node does not\n   support/desire the use
        of RecoveryPath messages, the RecoveryPath\n   Desired (R) bit MUST be cleared
        (0) in the Capability object included\n   in Hello messages, or the Capability
        object MAY be omitted from Hello\n   messages sent by the restarting node.\n
        \  During the Recovery Period, if the restarting node receives Hello\n   messages
        from a downstream RSVP neighbor with the RecoveryPath\n   Transmit Enabled
        (T) bit set (1) in the Capability object and the\n   Restart_Cap object, as
        defined in [RFC3473], it MUST treat the\n   downstream RSVP neighbor as capable
        of sending RecoveryPath messages\n   according to procedures defined in Section
        4.5.1.  If the restarting\n   node expects to recover RSVP state by the receipt
        and processing of\n   RecoveryPath messages, it MUST follow procedures defined
        in Section\n   4.5.2, with the downstream RSVP neighbor.\n   During the Recovery
        Period, if the restarting node receives Hello\n   messages from a downstream
        RSVP neighbor with the RecoveryPath\n   Transmit Enabled (T) bit cleared (0)
        in the Capability object, or,\n   with the Capability object not present,
        it MUST treat the downstream\n   RSVP neighbor as not capable of the RecoveryPath
        message procedures\n   defined in this document, and, it MUST revert to the
        recovery\n   procedures defined in [RFC3473] immediately, with the downstream
        RSVP\n   neighbor.\n"
      title: 4.4.2.  Procedures for the Restarting Node
    title: 4.4.  Procedures for the Capability Object
  - contents:
    - '4.5.  Procedures for the RecoveryPath Message

      '
    - contents:
      - "4.5.1.  Procedures for the Downstream Neighbor\n   After a downstream RSVP
        neighbor has detected that its upstream node\n   has restarted, is capable
        of recovery as defined in [RFC3473], and,\n   is capable of receiving RecoveryPath
        messages as defined in Section\n   4.4, the downstream RSVP neighbor MUST
        send a RecoveryPath message\n   for each LSP associated with the restarting
        node for which it has\n   sent a Resv message.  During the Recovery Period,
        if the downstream\n   RSVP neighbor detects that the restarting node is not
        capable of\n   receiving RecoveryPath messages by the absence of the Capability\n
        \  object or the RecoveryPath Desired (R) bit cleared (0) in the\n   Capability
        object in the restarting node's Hello messages, the\n   downstream RSVP neighbor
        SHOULD NOT send the RecoveryPath messages to\n   the restarting node.\n   The
        RecoveryPath message is constructed by copying all objects from\n   the last
        received associated Path message, with the following\n   exceptions:\n      The
        MESSAGE_ID, MESSAGE_ID_ACK and MESSAGE_ID_NACK objects are not\n      copied.
        \ Any MESSAGE_ID, MESSAGE_ID_ACK and MESSAGE_ID_NACK\n      objects used in
        RecoveryPath messages are generated based on\n      procedures defined in
        [RFC2961].\n      The Integrity object is not copied.  Any Integrity objects
        used in\n      RecoveryPath messages are generated based on procedures defined
        in\n      [RFC2747].\n      The RSVP Hop object is copied from the most recent
        associated Resv\n      message sent to the restarted node for the LSP being
        recovered.\n      In the sender descriptor, the Recovery Label object MUST
        be\n      included, with the label value copied from the label value in the\n
        \     Label object in the most recent associated Resv message sent to\n      the
        restarted node, for the LSP being recovered.\n   All other objects from the
        most recent received Path message MUST be\n   included in the RecoveryPath
        message.\n   All RecoveryPath messages SHOULD be sent at least once within\n
        \  approximately 1/2 of the Recovery Time advertised by the restarted\n   neighbor.
        \ If there are many LSPs to be recovered by the restarted\n   node, the downstream
        RSVP neighbor should avoid sending RecoveryPath\n   messages in a short time
        interval to avoid overloading the restarted\n   node's CPU.  Instead, it should
        spread the messages across 1/2 the\n   Recovery Time interval.  The range
        of Recovery Time is dependent on\n   many factors including, but not limited
        to, the CPU processing power\n   on the restarting node as well as the upstream
        and downstream\n   neighbors, the amount of CPU available for processing RSVP
        recovery\n   procedures, and the implementation specifics that affect the
        amount\n   of time taken to verify the received recovery state against existing\n
        \  forwarding plane state.  Such discussion is out of scope of this\n   document.\n
        \  After sending a RecoveryPath message and during the Recovery Period,\n
        \  the node SHOULD periodically resend the RecoveryPath message until it\n
        \  receives a corresponding response.  A corresponding response is a\n   Message
        ID acknowledgment or a Path message for the LSP the\n   RecoveryPath message
        represents.  Each such resend attempt is at the\n   end of any Message ID
        rapid retransmissions, if the Message ID\n   mechanism is used.  If the Message
        ID mechanism is not in use, the\n   period between resend attempts SHOULD
        be such that at least 3\n   attempts are completed before the expiry of 3/4
        the Recovery Time\n   interval.  Each such resend attempt MUST treat the RecoveryPath\n
        \  message as a new message and update the MESSAGE_ID object according\n   to
        procedures defined in [RFC2961].  Note, per [RFC3473], Resv\n   messages are
        suppressed during this recovery period until a\n   corresponding Path message
        is received.\n"
      title: 4.5.1.  Procedures for the Downstream Neighbor
    - contents:
      - "4.5.2.  Procedures for the Restarting Node\n   These procedures apply during
        the \"state recovery process\" and\n   \"Recovery Period\" as defined in Section
        9.5.2 of [RFC3473].  Any\n   RecoveryPath message received after the Recovery
        Period has expired\n   SHOULD be matched against local LSP state.  If matching
        fully\n   resynchronized state is located, the node SHOULD send a Path message\n
        \  downstream.  If non-resynchronized or no LSP state matching the\n   RecoveryPath
        message is located, the restarted node MAY send a\n   PathTear message constructed
        from the RecoveryPath message to\n   expedite the cleanup of unrecovered RSVP
        and associated forwarding\n   state downstream of the restarted node.  The
        restarting node MUST NOT\n   create data plane or forwarding state to match
        the received\n   RecoveryPath message.\n   The remaining procedures are broken
        down into three sub-sections.\n   The term \"resynchronized state\", originally
        defined in [RFC3473], is\n   used and modified in these sections.  This term
        refers to LSP state\n   that is fully recovered.\n   Signaling state may be
        recovered from sources other than the\n   mechanisms defined in this document.
        \ The restarting node SHOULD\n   consider signaling state as resynchronized
        for all such LSPs and\n   follow corresponding procedures defined below.  Further,
        recovery\n   procedures defined below may be overridden by local policy.\n
        \  Again, there are no changes to the procedures defined in Section\n   9.5.2
        in [RFC3473] if the restarting node is an egress node.\n"
      - contents:
        - "4.5.2.1.  Path and RecoveryPath Message Procedures\n   When a node receives
          a RecoveryPath message during the Recovery\n   Period, the node first checks
          if it has resynchronized RSVP state\n   associated with the message.  If
          there is resynchronized state, and\n   when both reliable message delivery
          [RFC2961] is supported and a\n   MESSAGE_ID object is present in the RecoveryPath
          message, the node\n   MUST follow Message ID acknowledgment procedures,
          as defined in\n   [RFC2961], and consider the message as processed.  If
          there is\n   resynchronized state and there is no MESSAGE_ID object or reliable\n
          \  message delivery [RFC2961] is not supported, the node SHOULD send a\n
          \  trigger Path message, and, consider the message as processed.\n   If
          a non-resynchronized state is found or the node is the ingress,\n   the
          node saves the information contained in the RecoveryPath message\n   and
          continues with processing as defined in Section 4.5.2.2.\n   If no associated
          RSVP state is found and the node is not the ingress\n   node, the node saves
          the information contained in the RecoveryPath\n   message for later use.\n
          \  Note the following modifies Section 9.5.2 of [RFC3473]:\n   When a node
          receives a Path message during the Recovery Period, the\n   node first locates
          any RSVP state associated with the message.  If\n   resynchronized RSVP
          state is found, then the node handles this\n   message according to previously
          defined procedures.\n   If a non-resynchronized state is found, the node
          saves the\n   information contained in the Path message, including the\n
          \  Recovery_Label object, and continues with processing as defined in\n
          \  Section 4.5.2.2.\n   Per [RFC3473], if matching RSVP state is not found,
          and the message\n   does not carry a Recovery_Label object, the node treats
          this as a\n   setup for a new LSP, and handles it according to previously
          defined\n   procedures.\n   If a matching RSVP state is not found and the
          message carries a\n   Recovery_Label object, the node saves the information
          contained in\n   the Path message, including the Recovery_Label object for
          later use.\n"
        title: 4.5.2.1.  Path and RecoveryPath Message Procedures
      - contents:
        - "4.5.2.2.  Re-Synchronization Procedures\n   After receipt of the RecoveryPath
          message and, for non-ingress LSPs,\n   the corresponding Path message with
          a Recovery Label object, the\n   restarting node SHOULD locate and associate
          corresponding forwarding\n   state using the received information.  The
          restarting node associates\n   the corresponding active forwarding plane
          state from the following\n   signaled information:\n      The upstream data
          interface is recovered from the RSVP HOP object\n      in the received Path
          message.\n      The label on the upstream data interface is recovered from
          the\n      Recovery Label object in the received Path message.  If the LSP
          is\n      bidirectional, the label for the upstream direction is recovered\n
          \     from the Upstream Label object in the received Path message.\n      The
          downstream data interface is recovered from the RSVP HOP\n      object in
          the received RecoveryPath message.\n      The label on the downstream data
          interface is recovered from the\n      Recovery Label object in the received
          RecoveryPath message.  If\n      the LSP is bidirectional, the label for
          the upstream direction is\n      recovered from the Upstream Label object
          in the RecoveryPath\n      message.\n   If complete forwarding state is
          located, the restarted node MUST\n   treat the LSP as resynchronized and
          MUST send a trigger Path message\n   downstream.  The Explicit Route object
          in the Path message SHOULD\n   match the Explicit Route object received
          in the RecoveryPath message.\n   In addition, the restarted node SHOULD
          recover state from the other\n   objects received in the RecoveryPath message.
          \ Optimally, the\n   resulting Path message should not cause any redundant
          or unnecessary\n   reprocessing of state along the remaining downstream
          nodes.  Ideally,\n   except for MESSAGE_ID processing and recovery processing,
          the\n   transmitted Path message will be treated as a refresh by the\n   downstream
          RSVP neighbor (and hence, should not trigger any\n   generation of Path
          messages with changed state further downstream).\n   If no forwarding state
          is located, the node treats the received Path\n   message as a setup request
          for a new LSP.  The outgoing interface and\n   label(s) indicated in the
          RecoveryPath message SHOULD be reused when\n   possible.  All other information
          contained in the RecoveryPath\n   message MAY also be used.  That is, forwarding
          state MUST NOT be\n   created except after receipt of a Path message from
          upstream or, at\n   an ingress node, the receipt of a command from the management
          plane.\n   Further, the forwarding state created is subject to local policy
          and\n   the information received from downstream in the RecoveryPath message\n
          \  is treated only as advisory.\n"
        title: 4.5.2.2.  Re-Synchronization Procedures
      - contents:
        - "4.5.2.3.  Procedures on Expiration of Recovery Period\n   There are several
          cleanup steps to follow at the end of the Recovery\n   Period.  At the end
          of the Recovery Period, any state that was\n   installed as the result of
          a received RecoveryPath message that is\n   not resynchronized SHOULD be
          discarded.\n   Any Path messages that were received containing a Recovery_Label
          that\n   has not been resynchronized, MUST be treated as being received
          during\n   the Recovery Period and processed as per [RFC3473].\n   Per [RFC3473],
          any other state that is not resynchronized during the\n   Recovery Period
          SHOULD be removed at the end of the Period.\n"
        title: 4.5.2.3.  Procedures on Expiration of Recovery Period
      title: 4.5.2.  Procedures for the Restarting Node
    title: 4.5.  Procedures for the RecoveryPath Message
  - contents:
    - "4.6.  Compatibility\n   This document introduces a new RSVP signaling message
      called the\n   RecoveryPath message to be generated by the downstream RSVP neighbor\n
      \  of a restarting node.  To advertise the capability of sending and\n   receiving
      RecoveryPath messages, this document introduces the\n   Capability object to
      be included in Hello messages by a restarting\n   node and its downstream RSVP
      neighbors.\n   If a restarting node does not support the Capability object,
      it will\n   discard the object, as the Class-Number is of the form 10bbbbbb,
      and\n   revert to recovery processing as defined in [RFC3473].  The\n   restarting
      node will not include the Capability object in its Hello\n   messages.  Hence,
      all downstream RSVP neighbors that detect that the\n   restarting node is not
      capable of supporting the extensions defined\n   in this document will not send
      the RecoveryPath messages to the\n   restarting node and will revert to recovery
      processing as defined in\n   [RFC3473].\n   If a downstream RSVP neighbor does
      not support the Capability object,\n   it will discard the object received in
      Hello messages and revert to\n   recovery processing as defined in [RFC3473].
      \ The downstream RSVP\n   neighbor will not include the Capability object in
      its Hello\n   messages.  Hence, the restarting node will detect that the downstream\n
      \  RSVP neighbor is not capable of supporting the extensions defined in\n   this
      document and will revert to recovery processing as defined in\n   [RFC3473].\n"
    title: 4.6.  Compatibility
  title: 4.  Extensions to Nodal Fault Handling
- contents:
  - "5.  RecoveryPath Summary Refresh\n   This section describes a mechanism to control
    which LSP state is\n   communicated in RecoveryPath messages.  This mechanism
    enhances the\n   Summary Refresh mechanism defined in [RFC2961], and uses the\n
    \  RecoveryPath Srefresh Capable (S) bit in the Capability object, as\n   defined
    in Section 4.2, carried in the Hello message defined in\n   [RFC3209] and [RFC3473].
    \ The described mechanism is referred to as\n   RecoveryPath Summary Refresh.\n
    \  Selective transmission of RecoveryPath messages is controlled much\n   the
    same way transmission of Path or Resv messages is controlled with\n   standard
    Summary Refresh, see [RFC2961].  In standard Summary\n   Refresh, an Srefresh
    message is sent by a node to identify to its\n   neighbor about Path and Resv
    state that is locally installed and\n   available.  The receiver of the Srefresh
    message can then attempt to\n   locate matching Path and Resv state.  If no matching
    state is found,\n   the receiver can request that the missing state be sent to
    it by\n   sending an Srefresh NACK to the sender of the Srefresh message.  When\n
    \  the Srefresh NACK is received, the corresponding Path or Resv message\n   is
    sent.  MESSAGE_ID information is used to identify Path and Resv\n   state in this
    process.\n   The mechanism described in this section extends the Summary Refresh\n
    \  process to the Path state that can be represented in RecoveryPath\n   messages.
    \ In this case, the Srefresh messages represent previously\n   received Path messages,
    rather than previously transmitted Path\n   messages.  This is the primary difference
    between standard Summary\n   Refresh and RecoveryPath Summary Refresh described
    in this section.\n   When a node restarts, and is capable of supporting the mechanisms\n
    \  described in this section, it includes the Capability object with the\n   RecoveryPath
    Desired (R) bit set and the RecoveryPath Srefresh\n   Capable (S) bit set in Hello
    messages it sends to its RSVP neighbors.\n   When a neighbor of the restarting
    node detects a restart (see\n   [RFC3209]), it detects that the restarted node
    is capable of\n   receiving RecoveryPath messages, as defined in Section 4.4,
    and that\n   the restarted node is requesting RecoveryPath Srefresh messages by\n
    \  the RecoveryPath Srefresh Capable (S) bit set in the Capability\n   object.
    \ When such an indication is found, the neighbor generates one\n   or more Srefresh
    messages.  Each message indicates the Path state\n   that can be represented in
    a RecoveryPath message.  Within such\n   Srefresh messages, the Path state that
    can be represented in\n   RecoveryPath messages is represented using MESSAGE_ID
    information,\n   and this information is communicated within MESSAGE_ID LIST objects.\n
    \  To indicate that the MESSAGE_ID LIST object is for recovery purposes,\n   a
    new flag is set in the MESSAGE_ID LIST object.  This flag is called\n   the RecoveryPath
    Flag and is defined below.\n   The restarted node can then use the Srefresh message
    and the\n   MESSAGE_ID LIST object to try to identify matching transmitted Path\n
    \  state.  The node identifies local state by matching Epoch and Message\n   ID
    tuples against Path messages transmitted downstream prior to the\n   restart.\n
    \  If matching state is located, then the restarted node operates as if\n   a
    RecoveryPath message has been received, per Section 4.5.2.  If no\n   matching
    state can be located, the restarted node generates a\n   Srefresh NACK, see Section
    5.4 of [RFC2961].  The Srefresh NACK is\n   also marked with the new RecoveryPath
    Flag to indicate that the NACK\n   is related to RecoveryPath messages.\n   Upon
    receiving a Srefresh NACK, the downstream node generates a\n   RecoveryPath message
    for the Path state indicated by each entry in\n   the MESSAGE_ID LIST.  The procedures
    defined in Section 4 above are\n   then followed by the restarted node and the
    downstream RSVP neighbor.\n"
  - contents:
    - "5.1.  MESSAGE_ID ACK/NACK and MESSAGE_ID LIST Objects\n   The MESSAGE_ID ACK/NACK
      objects and the MESSAGE_ID LIST object,\n   defined in [RFC2961], are updated
      by this document.  A new bit within\n   the existing Flags field of each object
      is defined.  This bit\n   indicates that the object carries MESSAGE_ID information
      related to\n   Path state that can be recovered using RecoveryPath messages.
      \ The\n   same flag value is used in all the objects for consistency.\n   MESSAGE_ID_ACK
      object\n   MESSAGE_ID_NACK object\n      See Section 4.3 of [RFC2961] for definition
      of other fields.\n   MESSAGE_ID LIST object\n      See Section 5.1 of [RFC2961]
      for definition of other fields.\n      Flags: 8 bits\n      0x02: RecoveryPath
      Flag\n         Indicates that the associated object carries MESSAGE_ID\n         information
      related to one or more Path messages that can be\n         recovered using a
      RecoveryPath message.\n"
    title: 5.1.  MESSAGE_ID ACK/NACK and MESSAGE_ID LIST Objects
  - contents:
    - "5.2.  RecoveryPath Srefresh Capable Bit\n   The Capability object and the RecoveryPath
      Srefresh Capable (S) bit\n   are defined in Section 4.2.\n"
    - contents:
      - "5.2.1.  Procedures\n   To support the selective receipt of RecoveryPath messages
        as defined\n   in this section, a restarting node MUST support the receipt
        and\n   processing of RecoveryPath messages as defined in Section 4.5.2, and\n
        \  MUST indicate this capability by including the Capability object with\n
        \  the RecoveryPath Desired (R) bit set as defined in Section 4.4.2 in\n   its
        Hello messages.\n   To indicate to an RSVP neighbor that selective transmission
        of\n   RecoveryPath messages is desired, a node MUST set (1) the S-bit in\n
        \  the Capability object in all Hello messages it sends.  When the\n   restarting
        node does not desire the receipt of RecoveryPath messages\n   (see Section
        4.4.2) or the selective transmission mechanism defined\n   in this section,
        it MUST clear (0) the S-bit in the Capability object\n   if included in Hello
        messages.\n   The downstream RSVP neighbor checks the R-bit and the S-bit
        upon\n   detecting a restart of a node that supports state recovery with\n
        \  RecoveryPath messages.  Detection of neighbor restarts with state\n   recovery
        using RecoveryPath messages is defined in Section 4.  If\n   both the R-bit
        and the S-bit are set, then the procedures defined\n   below in Section 5.3.1
        MUST be followed.  If the S-bit is cleared,\n   the downstream RSVP neighbor
        MUST revert to normal procedures defined\n   in Section 4.5.1.  If the R-bit
        is cleared, but the S-bit is set, the\n   downstream RSVP neighbor MUST treat
        it as if the Capability object\n   was received with the S-bit cleared.  See
        Section 4.4 for handling of\n   Hello messages without the Capability object.\n"
      title: 5.2.1.  Procedures
    - contents:
      - "5.2.2.  Compatibility\n   There are no compatibility issues introduced in
        the procedures\n   defined in Section 5.2.1.\n   The restarting node will
        detect that its neighbor does not support\n   selective transmission of RecoveryPath
        messages when a RecoveryPath\n   message is received prior to the receipt
        of a Srefresh message\n   containing a MESSAGE_ID LIST object with the RecoveryPath
        Flag set\n   (1).  When this occurs, any received RecoveryPath messages MUST
        be\n   processed as defined in Section 4.\n"
      title: 5.2.2.  Compatibility
    title: 5.2.  RecoveryPath Srefresh Capable Bit
  - contents:
    - "5.3.  RecoveryPath Summary Refresh Procedures\n   Related processing occurs
      in the following logical order:\n   o  Generation of RecoveryPath-related Srefresh
      messages\n   o  RecoveryPath-related Srefresh message receive processing and
      NACK\n      generation\n   o  Message ID NACK receive processing and generation
      of RecoveryPath\n      messages\n   o  Receive processing of RecoveryPath messages\n
      \  Actual processing MAY result in the above occurring in an interlaced\n   fashion
      when multiple LSPs are being recovered.  Both the restarted\n   node and the
      downstream RSVP neighbor MUST be able to process in this\n   fashion.\n"
    - contents:
      - "5.3.1.  Generation of RecoveryPath-Related Srefresh Messages\n   A neighbor
        of a restarting node generates one or more RecoveryPath-\n   related Srefresh
        messages when the S-bit is set in the restarted\n   node's Hello messages
        as described in Section 5.2.1.  The procedures\n   for generating an Srefresh
        message are defined in [RFC2961].  Only\n   modifications to these procedures
        are described in this section.\n   Also, Srefresh message transmit and receive
        processing may occur\n   simultaneously during the Recovery Period and are
        not impacted by the\n   procedures defined in this section.\n   To generate
        RecoveryPath-related Srefresh messages, a node must\n   identify which Path
        state can be represented in RecoveryPath messages\n   and which Srefresh message
        or messages can be used to carry the\n   related information.  As previously
        mentioned, the Path state that\n   can be represented in RecoveryPath messages
        is indicated in Srefresh\n   messages using the MESSAGE_ID information from
        the most recently\n   received Path message associated with the state.\n   After
        processing the S-bit as described in Section 5.2.1, the node\n   identifies
        all state associated with Path messages received from the\n   restarted neighbor.
        \ Only a Path state that has not been updated\n   since the restart may be
        represented in the Srefresh messages.\n   Received Path state containing a
        MESSAGE_ID object whose Epoch value\n   matches the Epoch received in the
        most recent Hello message is\n   considered as updated after the upstream
        neighbor has restarted.\n   Such Path state MUST NOT be represented in the
        Srefresh messages.\n   Each Srefresh message contains one or more MESSAGE_ID
        LIST objects.\n   Each such MESSAGE_ID LIST object MUST have the RecoveryPath
        Flag set\n   (1).\n   Multiple MESSAGE_ID LIST objects MAY be included in
        order to\n   accommodate multiple Epoch values.  The MESSAGE_ID LIST objects\n
        \  represent the identified, non-updated, Path state.  A\n   Message_Identifier
        field created for each identified, non-updated\n   Path state MUST be included
        in an appropriate MESSAGE_ID LIST object.\n   The Message_Identifier field
        is created based on the MESSAGE_ID\n   object from the most recently received
        Path message associated with\n   identified Path state.  If any identified
        Path state does not have an\n   associated MESSAGE_ID object, this state MUST
        be processed as defined\n   above in Section 4.5.1.\n   The source IP address
        for the Srefresh message SHOULD be the source\n   IP address in the IP header
        of the corresponding Resv messages\n   previously sent to the restarted node.
        \ The Srefresh message SHOULD\n   be destined to the IP address in the HOP
        object in the corresponding\n   Path messages.  This may result in multiple
        Srefresh messages being\n   generated.  Per [RFC2961], implementations may
        choose to limit each\n   Srefresh message to the MTU size of the outgoing
        link, and to not\n   bundle Srefresh messages.  RecoveryPath-related Srefresh
        messages\n   SHOULD be sent using reliable delivery, as defined in [RFC2961].\n
        \  During the Recovery Period, unacknowledged RecoveryPath-related\n   Srefresh
        messages SHOULD be periodically transmitted.  The\n   retransmission algorithm
        used can be the same algorithm used for\n   retransmitting RecoveryPath messages
        during the Recovery Period (see\n   Section 4.5.1).  Note that prior to each
        such periodic\n   retransmission, the Srefresh message SHOULD be updated to
        exclude the\n   Message ID's of Path state that has been updated by the receipt
        of a\n   Path message.\n   To allow sufficient processing time for the restarted
        node, the\n   downstream RSVP neighbor MAY choose to generate multiple\n   RecoveryPath-related
        Srefresh messages containing partial but\n   mutually exclusive sets of Message
        Identifiers spread across 1/4 of\n   the Recovery Time advertised by the restarted
        node.\n"
      title: 5.3.1.  Generation of RecoveryPath-Related Srefresh Messages
    - contents:
      - "5.3.2.  RecoveryPath-Related Srefresh Receive Processing and NACK\n        Generation\n
        \  Upon receiving an Srefresh message containing a MESSAGE_ID LIST\n   object
        with the RecoveryPath Flag set), the restarted node attempts\n   to locate
        matching previously transmitted Path state.  The Epoch in\n   the MESSAGE_ID
        LIST object, along with each Message Identifier in the\n   object, is used
        to match against the MESSAGE_ID object in Path\n   messages previously transmitted
        to the downstream RSVP neighbor.  For\n   each Message Identifier in the MESSAGE_ID
        LIST:\n      If matching transmitted Path state is found, the restarting node\n
        \     treats the corresponding LSP state as having received and\n      processed
        a RecoveryPath message and perform any further\n      processing necessary
        as defined in Section 4.5.2.  Specifically,\n      it MUST generate a trigger
        Path message for the LSP as defined in\n      Section 4.5.2.2.  The restarted
        node MAY spread the transmission\n      of such trigger Path messages across
        1/2 of the remaining Recovery\n      Period to allow the downstream RSVP neighbor
        sufficient processing\n      time.\n      If matching transmitted Path state
        is not found, the restarting\n      node MUST generate a MESSAGE_ID NACK as
        defined in [RFC2961].\n      Each generated MESSAGE_ID NACK MUST have the
        RecoveryPath Flag set\n      (1).\n   It is recommended that the restarted
        node combine multiple such\n   MESSAGE_ID NACKs into a single ACK message,
        per [RFC2961].\n"
      title: 5.3.2.  RecoveryPath-Related Srefresh Receive Processing and NACK
    - contents:
      - "5.3.3.  RecoveryPath-Related MESSAGE_ID NACK Receive Processing\n   This
        section defines the procedures associated with the processing of\n   received
        MESSAGE_ID NACKs that have the RecoveryPath Flag set (1).\n   Procedures for
        processing of MESSAGE_ID NACKs without the\n   RecoveryPath Flag present are
        defined in [RFC2961] and not modified\n   in this document.  Processing of
        MESSAGE_ID NACKs with the\n   RecoveryPath Flag set (1) also follows procedures
        defined in\n   [RFC2961] unless explicitly modified in this section.\n   For
        each MESSAGE_ID NACK with the RecoveryPath Flag set (1), the\n   downstream
        RSVP neighbor must locate the matching received Path\n   message.  If a matching
        Path message is found, the downstream RSVP\n   neighbor MUST generate a RecoveryPath
        message as defined in Section\n   4.5.1.  If a matching Path message is not
        found, the MESSAGE_ID NACK\n   is ignored.  An example where this may occur
        is when the restarted\n   node has already generated an updated Path message
        after its restart.\n"
      title: 5.3.3.  RecoveryPath-Related MESSAGE_ID NACK Receive Processing
    title: 5.3.  RecoveryPath Summary Refresh Procedures
  title: 5.  RecoveryPath Summary Refresh
- contents:
  - "6.  Security Considerations\n   This document introduces a new RSVP message that
    is restricted to one\n   RSVP hop.  This document introduces no new security considerations\n
    \  beyond those already addressed for existing RSVP hop-by-hop messages.\n   This
    document introduces a new RSVP object to be included in RSVP\n   Hello messages.
    \ This document introduces no new security\n   considerations beyond those already
    addressed for existing objects in\n   RSVP Hello messages.\n   This document introduces
    new procedures to be performed on RSVP\n   agents that neighbor a restarting RSVP
    agent.  In situations where\n   the control plane in general, and the RSVP agent
    in particular, of a\n   node carrying one or more LSPs is restarted due to external
    attacks,\n   the procedures introduced in this document provide the ability for\n
    \  the restarting RSVP agent to recover the RSVP state corresponding to\n   the
    LSPs with the least possible perturbation to the rest of the\n   network.  Ideally,
    only the neighboring RSVP agents should notice the\n   restart and hence need
    to perform additional processing.  This allows\n   for a network with active LSPs
    to recover LSP state gracefully from\n   an external attack without perturbing
    the data/forwarding plane\n   state.\n   [RFC2747] provides mechanisms to protect
    against external agents\n   compromising the RSVP signaling state in an RSVP agent.
    \ These\n   mechanisms, when used with the new message and procedures introduced\n
    \  in this document, provide the same degree of protection to the\n   restarting
    RSVP agent against installing compromised signaling state\n   from an external
    agent during its RSVP signaling state recovery.\n   Note that the procedures assume
    a full trust model between RSVP\n   neighbors.  That is, although the protocol
    exchanges before and after\n   restart can be secured, and although it is possible
    to authenticate\n   the identity of the neighbors, no mechanism is provided to
    verify\n   that the restart information is correctly mapped from the protocol\n
    \  information exchanged before the restart.  This is considered\n   acceptable
    because a similar trust model is required for normal\n   operation of the protocol.\n
    \  The procedures defined in this document introduce additional\n   processing
    overhead for the RSVP agents that neighbor a restarting\n   RSVP agent.  If an
    RSVP agent restarts due to external attacks, such\n   added processing on the
    neighboring RSVP agents may impact their\n   ability to perform other control
    plane tasks, including any\n   processing for other LSPs that do not involve the
    restarting node.\n   Such impact can be minimalized by the restarting RSVP agent
    using a\n   large enough Recovery Time, so that its neighbors are provided\n   sufficient
    time to handle the additional processing involved while\n   continuing to perform
    their other control plane functions normally\n   during the Recovery Period.\n
    \  Note that the procedures defined in this document cannot be used to\n   create
    false forwarding state.  The restarting node that receives a\n   RecoveryPath
    message that does not match the existing forwarding\n   state MUST NOT create
    or modify its forwarding state to match.  A\n   restarting node SHOULD log such
    an event or otherwise notify the\n   operator since it might represent an attack.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgments\n   The authors would like to thank participants of the CCAMP
    WG for\n   comments and suggestions.  Also thanks to Arthi Ayyangar, Adrian\n
    \  Farrel, Nick Neate, and Pavan Beeram for their helpful comments and\n   feedback.\n
    \  Derek Atkins provided useful discussion during SecDir review.  Sam\n   Hartman
    gave careful scrutiny of the security considerations and the\n   potential impact
    on the RSVP-TE security trust model.\n   Adrian Farrel edited the final revisions
    of this document as it\n   progressed through IESG review.\n"
  title: 7.  Acknowledgments
- contents:
  - "8.  IANA Considerations\n   [RFC2205] defines the Class-Number name space for
    RSVP objects.  The\n   name space is managed by IANA.\n   A new RSVP object using
    a Class-Number of form 10bbbbbb called the\n   Capability Object is defined in
    Section 4.2 in this document.  The\n   Class-Number is 134.\n   A new RSVP message
    type called a RecoveryPath message is defined in\n   Section 4.1 of this document.
    \ The RSVP message type is 30.\n   This document creates a new name space in the
    Capability object\n   defined in Section 4.2.  The new name space is a 32-bit-wide
    field.\n   New registrations in this name space are to be allocated by IANA\n
    \  through an IETF Consensus action, per [RFC2434].  IANA also serves as\n   the
    repository for this name space.\n   Section 4.2 defines the following bits in
    the 32-bit field of the\n   Capability Object (134):\n      RecoveryPath Transmit
    Enabled (T): 1 bit\n      RecoveryPath Desired (R): 1 bit\n      RecoveryPath
    Srefresh Capable (S): 1 bit\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs
    to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n
    \  [RFC2205]  Braden, B., Zhang, L., Berson, S., Herzog, S., and S.\n              Jamin,
    \"Resource ReSerVation Protocol (RSVP) -- Version 1\n              Functional
    Specification\", RFC 2205, September 1997.\n   [RFC2434]  Narten, T. and H. Alvestrand,
    \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\",
    BCP 26, RFC 2434,\n              October 1998.\n   [RFC2747]  Baker, F., Lindell,
    B., and M. Talwar, \"RSVP Cryptographic\n              Authentication\", RFC 2747,
    January 2000.\n   [RFC2961]  Berger, L., Gan, D., Swallow, G., Pan, P., Tommasi,
    F.,\n              and S. Molendini, \"RSVP Refresh Overhead Reduction\n              Extensions\",
    RFC 2961, April 2001.\n   [RFC3209]  Awduche, D., Berger, L., Gan, D., Li, T.,
    Srinivasan, V.,\n              and G. Swallow, \"RSVP-TE: Extensions to RSVP for
    LSP\n              Tunnels\", RFC 3209, December 2001.\n   [RFC3471]  Berger,
    L., \"Generalized Multi-Protocol Label Switching\n              (GMPLS) Signaling
    Functional Description\", RFC 3471,\n              January 2003.\n   [RFC3473]
    \ Berger, L., \"Generalized Multi-Protocol Label Switching\n              (GMPLS)
    Signaling Resource ReserVation Protocol-Traffic\n              Engineering (RSVP-TE)
    Extensions\", RFC 3473, January 2003.\n"
  title: 9.  Normative References
- contents:
  - "Editors' Addresses\n   Arun Satyanarayana (editor)\n   Cisco Systems, Inc.\n
    \  170 West Tasman Dr.\n   San Jose, CA  95134\n   USA\n   Phone: +1 408 853 3206\n
    \  EMail: asatyana@cisco.com\n   Reshad Rahman (editor)\n   Cisco Systems, Inc.\n
    \  2000 Innovation Dr.\n   Kanata, Ontario  K2K 3E8\n   Canada\n   Phone: 613
    254 3519\n   EMail: rrahman@cisco.com\n"
  title: Editors' Addresses
- contents:
  - "Authors' Addresses\n   Dimitri Papadimitriou\n   Alcatel\n   Francis Wellesplein
    1\n   B-2018 Antwerpen\n   Belgium\n   Phone: +32 3 240-8491\n   EMail: dimitri.papadimitriou@alcatel-lucent.be\n
    \  Lou Berger\n   LabN Consulting, L.L.C.\n   Phone: +1 301 468 9228\n   EMail:
    lberger@labn.net\n   Anca Zamfir\n   Cisco Systems, Inc.\n   2000 Innovation Dr.\n
    \  Kanata, Ontario  K2K 3E8\n   Canada\n   Phone: 613 254 3484\n   EMail: ancaz@cisco.com\n
    \  Junaid Israr\n   Cisco Systems, Inc.\n   2000 Innovation Dr.\n   Kanata, Ontario
    \ K2K 3E8\n   Canada\n   Phone: 613 254 3693\n   EMail: jisrar@cisco.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
