- contents:
  - '                      Port Control Protocol (PCP)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Port Control Protocol allows an IPv6 or IPv4 host to control
    how\n   incoming IPv6 or IPv4 packets are translated and forwarded by a\n   Network
    Address Translator (NAT) or simple firewall, and also allows\n   a host to optimize
    its outgoing NAT keepalive messages.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6887.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Scope  . . . . . . . . . . . . . . . . . . . . . . . .
    . . . .  5\n     2.1.  Deployment Scenarios . . . . . . . . . . . . . . . . .
    . .  5\n     2.2.  Supported Protocols  . . . . . . . . . . . . . . . . . . .
    \ 5\n     2.3.  Single-Homed Customer Premises Network . . . . . . . . . .  5\n
    \  3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n   4.
    \ Relationship between PCP Server and Its PCP-Controlled\n       Device . . .
    . . . . . . . . . . . . . . . . . . . . . . . . . 10\n   5.  Note on Fixed-Size
    Addresses . . . . . . . . . . . . . . . . . 10\n   6.  Protocol Design Note .
    . . . . . . . . . . . . . . . . . . . . 11\n   7.  Common Request and Response
    Header Format  . . . . . . . . . . 13\n     7.1.  Request Header . . . . . . .
    . . . . . . . . . . . . . . . 14\n     7.2.  Response Header  . . . . . . . .
    . . . . . . . . . . . . . 15\n     7.3.  Options  . . . . . . . . . . . . . .
    . . . . . . . . . . . 16\n     7.4.  Result Codes . . . . . . . . . . . . . .
    . . . . . . . . . 19\n   8.  General PCP Operation  . . . . . . . . . . . . .
    . . . . . . . 20\n     8.1.  General PCP Client: Generating a Request . . . .
    . . . . . 21\n       8.1.1.  PCP Client Retransmission  . . . . . . . . . . .
    . . . 22\n     8.2.  General PCP Server: Processing a Request . . . . . . . .
    . 24\n     8.3.  General PCP Client: Processing a Response  . . . . . . . . 25\n
    \    8.4.  Multi-Interface Issues . . . . . . . . . . . . . . . . . . 27\n     8.5.
    \ Epoch  . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n   9.  Version
    Negotiation  . . . . . . . . . . . . . . . . . . . . . 29\n   10. Introduction
    to MAP and PEER Opcodes . . . . . . . . . . . . . 30\n     10.1. For Operating
    a Server . . . . . . . . . . . . . . . . . . 33\n     10.2. For Operating a Symmetric
    Client/Server  . . . . . . . . . 35\n     10.3. For Reducing NAT or Firewall Keepalive
    Messages  . . . . . 37\n     10.4. For Restoring Lost Implicit TCP Dynamic Mapping
    State  . . 38\n   11. MAP Opcode . . . . . . . . . . . . . . . . . . . . . . .
    . . . 39\n     11.1. MAP Operation Packet Formats . . . . . . . . . . . . . .
    . 40\n     11.2. Generating a MAP Request . . . . . . . . . . . . . . . . . 43\n
    \      11.2.1. Renewing a Mapping . . . . . . . . . . . . . . . . . . 44\n     11.3.
    Processing a MAP Request . . . . . . . . . . . . . . . . . 44\n     11.4. Processing
    a MAP Response  . . . . . . . . . . . . . . . . 48\n     11.5. Address Change
    Events  . . . . . . . . . . . . . . . . . . 49\n     11.6. Learning the External
    IP Address Alone . . . . . . . . . . 50\n   12. PEER Opcode  . . . . . . . . .
    . . . . . . . . . . . . . . . . 50\n     12.1. PEER Operation Packet Formats  .
    . . . . . . . . . . . . . 51\n     12.2. Generating a PEER Request  . . . . .
    . . . . . . . . . . . 54\n     12.3. Processing a PEER Request  . . . . . . .
    . . . . . . . . . 55\n     12.4. Processing a PEER Response . . . . . . . . .
    . . . . . . . 56\n   13. Options for MAP and PEER Opcodes . . . . . . . . . .
    . . . . . 57\n     13.1. THIRD_PARTY Option for MAP and PEER Opcodes  . . . .
    . . . 57\n     13.2. PREFER_FAILURE Option for MAP Opcode . . . . . . . . . .
    . 59\n     13.3. FILTER Option for MAP Opcode . . . . . . . . . . . . . . . 61\n
    \  14. Rapid Recovery . . . . . . . . . . . . . . . . . . . . . . . . 63\n     14.1.
    ANNOUNCE Opcode  . . . . . . . . . . . . . . . . . . . . . 64\n       14.1.1.
    ANNOUNCE Operation . . . . . . . . . . . . . . . . . . 65\n       14.1.2. Generating
    and Processing a Solicited ANNOUNCE\n               Message  . . . . . . . . .
    . . . . . . . . . . . . . . 65\n       14.1.3. Generating and Processing an Unsolicited
    ANNOUNCE\n               Message  . . . . . . . . . . . . . . . . . . . . . .
    . 66\n     14.2. PCP Mapping Update . . . . . . . . . . . . . . . . . . . . 67\n
    \  15. Mapping Lifetime and Deletion  . . . . . . . . . . . . . . . . 69\n     15.1.
    Lifetime Processing for the MAP Opcode . . . . . . . . . . 71\n   16. Implementation
    Considerations  . . . . . . . . . . . . . . . . 72\n     16.1. Implementing MAP
    with EDM Port-Mapping NAT . . . . . . . . 72\n     16.2. Lifetime of Explicit
    and Implicit Dynamic Mappings . . . . 72\n     16.3. PCP Failure Recovery . .
    . . . . . . . . . . . . . . . . . 72\n       16.3.1. Recreating Mappings  . .
    . . . . . . . . . . . . . . . 73\n       16.3.2. Maintaining Mappings . . . .
    . . . . . . . . . . . . . 73\n       16.3.3. SCTP . . . . . . . . . . . . . .
    . . . . . . . . . . . 74\n     16.4. Source Address Replicated in PCP Header  .
    . . . . . . . . 75\n     16.5. State Diagram  . . . . . . . . . . . . . . . .
    . . . . . . 76\n   17. Deployment Considerations  . . . . . . . . . . . . . .
    . . . . 77\n     17.1. Ingress Filtering  . . . . . . . . . . . . . . . . . .
    . . 77\n     17.2. Mapping Quota  . . . . . . . . . . . . . . . . . . . . . .
    77\n   18. Security Considerations  . . . . . . . . . . . . . . . . . . . 78\n
    \    18.1. Simple Threat Model  . . . . . . . . . . . . . . . . . . . 78\n       18.1.1.
    Attacks Considered . . . . . . . . . . . . . . . . . . 79\n       18.1.2. Deployment
    Examples Supporting the Simple Threat\n               Model  . . . . . . . . .
    . . . . . . . . . . . . . . . 79\n     18.2. Advanced Threat Model  . . . . .
    . . . . . . . . . . . . . 80\n     18.3. Residual Threats . . . . . . . . . .
    . . . . . . . . . . . 80\n       18.3.1. Denial of Service  . . . . . . . . .
    . . . . . . . . . 80\n       18.3.2. Ingress Filtering  . . . . . . . . . . .
    . . . . . . . 81\n       18.3.3. Mapping Theft  . . . . . . . . . . . . . . .
    . . . . . 81\n       18.3.4. Attacks against Server Discovery . . . . . . . .
    . . . 81\n   19. IANA Considerations  . . . . . . . . . . . . . . . . . . . .
    . 82\n     19.1. Port Number  . . . . . . . . . . . . . . . . . . . . . . . 82\n
    \    19.2. Opcodes  . . . . . . . . . . . . . . . . . . . . . . . . . 82\n     19.3.
    Result Codes . . . . . . . . . . . . . . . . . . . . . . . 82\n     19.4. Options
    \ . . . . . . . . . . . . . . . . . . . . . . . . . 82\n   20. Acknowledgments
    \ . . . . . . . . . . . . . . . . . . . . . . . 83\n   21. References . . . .
    . . . . . . . . . . . . . . . . . . . . . . 84\n     21.1. Normative References
    . . . . . . . . . . . . . . . . . . . 84\n     21.2. Informative References .
    . . . . . . . . . . . . . . . . . 84\n   Appendix A. NAT-PMP Transition . . .
    . . . . . . . . . . . . . . . 87\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Port Control Protocol (PCP) provides a mechanism to
    control how\n   incoming packets are forwarded by upstream devices such as Network\n
    \  Address Translator IPv6/IPv4 (NAT64), Network Address Translator\n   IPv4/IPv4
    (NAT44), and IPv6 and IPv4 firewall devices, and a\n   mechanism to reduce application
    keepalive traffic.  PCP is designed\n   to be implemented in the context of Carrier-Grade
    NATs (CGNs) and\n   small NATs (e.g., residential NATs), as well as with dual-stack
    and\n   IPv6-only Customer Premises Equipment (CPE) routers, and all of the\n
    \  currently known transition scenarios towards IPv6-only CPE routers.\n   PCP
    allows hosts to operate servers for a long time (e.g., a network-\n   attached
    home security camera) or a short time (e.g., while playing a\n   game or on a
    phone call) when behind a NAT device, including when\n   behind a CGN operated
    by their Internet service provider or an IPv6\n   firewall integrated in their
    CPE router.\n   PCP allows applications to create mappings from an external IP\n
    \  address, protocol, and port to an internal IP address, protocol, and\n   port.
    \ These mappings are required for successful inbound\n   communications destined
    to machines located behind a NAT or a\n   firewall.\n   After creating a mapping
    for incoming connections, it is necessary to\n   inform remote computers about
    the IP address, protocol, and port for\n   the incoming connection.  This is usually
    done in an application-\n   specific manner.  For example, a computer game might
    use a rendezvous\n   server specific to that game (or specific to that game developer),
    a\n   SIP phone would use a SIP proxy, and a client using DNS-Based Service\n
    \  Discovery [RFC6763] would use DNS Update [RFC2136] [RFC3007].  PCP\n   does
    not provide this rendezvous function.  The rendezvous function\n   may support
    IPv4, IPv6, or both.  Depending on that support and the\n   application's support
    of IPv4 or IPv6, the PCP client may need an\n   IPv4 mapping, an IPv6 mapping,
    or both.\n   Many NAT-friendly applications send frequent application-level\n
    \  messages to ensure that their session will not be timed out by a NAT.\n   These
    are commonly called \"NAT keepalive\" messages, even though they\n   are not sent
    to the NAT itself (rather, they are sent 'through' the\n   NAT).  These applications
    can reduce the frequency of such NAT\n   keepalive messages by using PCP to learn
    (and influence) the NAT\n   mapping lifetime.  This helps reduce bandwidth on
    the subscriber's\n   access network, traffic to the server, and battery consumption
    on\n   mobile devices.\n   Many NATs and firewalls include Application Layer Gateways
    (ALGs) to\n   create mappings for applications that establish additional streams
    or\n   accept incoming connections.  ALGs incorporated into NATs may also\n   modify
    the application payload.  Industry experience has shown that\n   these ALGs are
    detrimental to protocol evolution.  PCP allows an\n   application to create its
    own mappings in NATs and firewalls,\n   reducing the incentive to deploy ALGs
    in NATs and firewalls.\n"
  title: 1.  Introduction
- contents:
  - '2.  Scope

    '
  - contents:
    - "2.1.  Deployment Scenarios\n   PCP can be used in various deployment scenarios,
      including:\n   o  Basic NAT [RFC3022]\n   o  Network Address and Port Translation
      [RFC3022], such as commonly\n      deployed in residential NAT devices\n   o
      \ Carrier-Grade NAT [RFC6888]\n   o  Dual-Stack Lite (DS-Lite) [RFC6333]\n   o
      \ NAT that is Layer-2 Aware [L2NAT]\n   o  Dual-Stack Extra Lite [RFC6619]\n
      \  o  NAT64, both Stateless [RFC6145] and Stateful [RFC6146]\n   o  IPv4 and
      IPv6 simple firewall control [RFC6092]\n   o  IPv6-to-IPv6 Network Prefix Translation
      (NPTv6) [RFC6296]\n"
    title: 2.1.  Deployment Scenarios
  - contents:
    - "2.2.  Supported Protocols\n   The PCP Opcodes defined in this document are
      designed to support\n   transport-layer protocols that use a 16-bit port number
      (e.g., TCP,\n   UDP, Stream Control Transmission Protocol (SCTP) [RFC4960],
      and\n   Datagram Congestion Control Protocol (DCCP) [RFC4340]).  Protocols\n
      \  that do not use a port number (e.g., Resource Reservation Protocol\n   (RSVP),
      IP Encapsulating Security Payload (ESP) [RFC4303], ICMP, and\n   ICMPv6) are
      supported for IPv4 firewall, IPv6 firewall, and NPTv6\n   functions, but are
      out of scope for any NAT functions.\n"
    title: 2.2.  Supported Protocols
  - contents:
    - "2.3.  Single-Homed Customer Premises Network\n   PCP assumes a single-homed
      IP address model.  That is, for a given IP\n   address of a host, only one default
      route exists to reach other hosts\n   on the Internet from that source IP address.
      \ This is important\n   because after a PCP mapping is created and an inbound
      packet (e.g.,\n   TCP SYN) is rewritten and delivered to a host, the outbound
      response\n   (e.g., TCP SYNACK) has to go through the same (reverse) path so
      it\n   passes through the same NAT to have the necessary inverse rewrite\n   performed.
      \ This restriction exists because otherwise there would\n   need to be a PCP-enabled
      NAT for every egress (because the host could\n   not reliably determine which
      egress path packets would take), and the\n   client would need to be able to
      reliably make the same internal/\n   external mapping in every NAT gateway,
      which in general is not\n   possible (because the other NATs might already have
      the necessary\n   external port mapped to another host).\n"
    title: 2.3.  Single-Homed Customer Premises Network
  title: 2.  Scope
- contents:
  - "3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   \"Key words for use in RFCs to Indicate Requirement Levels\" [RFC2119].\n
    \  Internal Host:\n      A host served by a NAT gateway, or protected by a firewall.
    \ This\n      is the host that will receive incoming traffic resulting from a\n
    \     PCP mapping request, or the host that initiated an implicit\n      dynamic
    outbound mapping (e.g., by sending a TCP SYN) across a\n      firewall or a NAT.\n
    \  Remote Peer Host:\n      A host with which an internal host is communicating.
    \ This can\n      include another internal host (or even the same internal host);
    if\n      a NAT is involved, the NAT would need to hairpin the traffic\n      [RFC4787].\n
    \  Internal Address:\n      The address of an internal host served by a NAT gateway
    or\n      protected by a firewall.\n   External Address:\n      The address of
    an internal host as seen by other remote peers on\n      the Internet with which
    the internal host is communicating, after\n      translation by any NAT gateways
    on the path.  An external address\n      is generally a public routable (i.e.,
    non-private) address.  In\n      the case of an internal host protected by a pure
    firewall, with no\n      address translation on the path, its external address
    is the same\n      as its internal address.\n   Endpoint-Dependent Mapping (EDM):
    \ A term applied to NAT operation\n      where an implicit mapping created by
    outgoing traffic (e.g., TCP\n      SYN) from a single internal address, protocol,
    and port to\n      different remote peers and ports may be assigned different\n
    \     external ports, and a subsequent PCP mapping request for that\n      internal
    address, protocol, and port may be assigned yet another\n      different external
    port.  This term encompasses both Address-\n      Dependent Mapping and Address
    and Port-Dependent Mapping\n      [RFC4787].\n   Endpoint-Independent Mapping
    (EIM):  A term applied to NAT operation\n      where all mappings from a single
    internal address, protocol, and\n      port to different remote peers and ports
    are all assigned the same\n      external address and port.\n   Remote Peer Address:\n
    \     The address of a remote peer, as seen by the internal host.  A\n      remote
    address is generally a publicly routable address.  In the\n      case of a remote
    peer that is itself served by a NAT gateway, the\n      remote address may in
    fact be the remote peer's external address,\n      but since this remote translation
    is generally invisible to\n      software running on the internal host, the distinction
    can safely\n      be ignored for the purposes of this document.\n   Third Party:\n
    \     In the common case, an internal host manages its own mappings\n      using
    PCP requests, and the internal address of those mappings is\n      the same as
    the source IP address of the PCP request packet.\n      In the case where one
    device is managing mappings on behalf of\n      some other device that does not
    implement PCP, the presence of the\n      THIRD_PARTY option in the MAP request
    signifies that the specified\n      address, rather than the source IP address
    of the PCP request\n      packet, should be used as the internal address for the
    mapping.\n   Mapping, Port Mapping, Port Forwarding:\n      A NAT mapping creates
    a relationship between an internal IP\n      address, protocol, and port, and
    an external IP address, protocol,\n      and port.  More specifically, it creates
    a translation rule where\n      packets destined *to* the external IP address,
    protocol, and port\n      have their destination address and port translated to
    the internal\n      address and port, and conversely, packets *from* the internal
    IP\n      address, protocol, and port have their source address and port\n      translated
    to the external address and port.  In the case of a\n      pure firewall, the
    \"mapping\" is the identity function, translating\n      an internal IP address,
    protocol, and port number to the same\n      external IP address, protocol, and
    port number.  Firewall\n      filtering, applied in addition to that identity
    mapping function,\n      is separate from the mapping itself.\n   Mapping Types:\n
    \     There are three dimensions to classifying mapping types: how they\n      are
    created (implicitly/explicitly), their primary purpose\n      (outbound/inbound),
    and how they are deleted (dynamic/static).\n      Implicit mappings are created
    as a side effect of some other\n      operation; explicit mappings are created
    by a mechanism explicitly\n      dealing with mappings.  Outbound mappings exist
    primarily to\n      facilitate outbound communication; inbound mappings exist\n
    \     primarily to facilitate inbound communication.  Dynamic mappings\n      are
    deleted when their lifetime expires, or through other protocol\n      action;
    static mappings are permanent until the user chooses to\n      delete them.\n
    \     *  Implicit dynamic mappings are created implicitly as a side\n         effect
    of traffic such as an outgoing TCP SYN or outgoing UDP\n         packet.  Such
    packets were not originally designed explicitly\n         for creating NAT (or
    firewall) state, but they can have that\n         effect when they pass through
    a NAT (or firewall) device.\n         Implicit dynamic mappings usually have a
    finite lifetime,\n         though this lifetime is generally not known to the
    client using\n         them.\n      *  Explicit dynamic mappings are created as
    a result of explicit\n         PCP MAP and PEER requests.  Like a DHCP address
    lease, explicit\n         dynamic mappings have a finite lifetime, and this lifetime
    is\n         communicated to the client.  As with a DHCP address lease, if\n         the
    client wants a mapping to persist the client must prove\n         that it is still
    present by periodically renewing the mapping\n         to prevent it from expiring.
    \ If a PCP client goes away, then\n         any mappings it created will be automatically
    cleaned up when\n         they expire.\n      *  Explicit static mappings are
    created by manual configuration\n         (e.g., via command-line interface or
    other user interface) and\n         persist until the user changes that manual
    configuration.\n      Both implicit and explicit dynamic mappings are dynamic
    in the\n      sense that they are created on demand, as requested (implicitly
    or\n      explicitly) by the internal host, and have a lifetime.  After the\n
    \     lifetime, the mapping is deleted unless the lifetime is extended\n      by
    action by the internal host (e.g., sending more traffic or\n      sending another
    PCP request).\n      Static mappings are, by their nature, always explicit.  Static\n
    \     mappings differ from explicit dynamic mappings in that their\n      lifetime
    is effectively infinite (they exist until manually\n      removed), but otherwise
    they behave exactly the same as explicit\n      MAP mappings.\n      While all
    mappings are, by necessity, bidirectional (most Internet\n      communication
    requires information to flow in both directions for\n      successful operation),
    when talking about mappings, it can be\n      helpful to identify them loosely
    according to their 'primary'\n      purpose.\n      *  Outbound mappings exist
    primarily to enable outbound\n         communication.  For example, when a host
    calls connect() to\n         make an outbound connection, a NAT gateway will create
    an\n         implicit dynamic outbound mapping to facilitate that outbound\n         communication.\n
    \     *  Inbound mappings exist primarily to enable listening servers to\n         receive
    inbound connections.  Generally, when a client calls\n         listen() to listen
    for inbound connections, a NAT gateway will\n         not implicitly create any
    mapping to facilitate that inbound\n         communication.  A PCP MAP request
    can be used explicitly to\n         create a dynamic inbound mapping to enable
    the desired inbound\n         communication.\n      Explicit static (manual) mappings
    and explicit dynamic (MAP)\n      mappings both allow internal hosts to receive
    inbound traffic that\n      is not in direct response to any immediately preceding
    outbound\n      communication (i.e., to allow internal hosts to operate a \"server\"\n
    \     that is accessible to other hosts on the Internet).\n   PCP Client:\n      A
    PCP software instance responsible for issuing PCP requests to a\n      PCP server.
    \ Several independent PCP clients can exist on the same\n      host.  Several
    PCP clients can be located in the same local\n      network.  A PCP client can
    issue PCP requests on behalf of a\n      third-party device for which it is authorized
    to do so.  An\n      interworking function from Universal Plug and Play Internet\n
    \     Gateway Device (UPnP IGDv1 [IGDv1]) to PCP is another example of a\n      PCP
    client.  A PCP server in a NAT gateway that is itself a client\n      of another
    NAT gateway (nested NAT) may itself act as a PCP client\n      to the upstream
    NAT.\n   PCP-Controlled Device:\n      A NAT or firewall that controls or rewrites
    packet flows between\n      internal hosts and remote peer hosts.  PCP manages
    the mappings on\n      this device.\n   PCP Server:\n      A PCP software instance
    that resides on the PCP-Controlled Device\n      that receives PCP requests from
    the PCP client and creates\n      appropriate state in response to that request.\n
    \  Subscriber:\n      The unit of billing for a commercial ISP.  A subscriber
    may have a\n      single IP address from the commercial ISP (which can be shared\n
    \     among multiple hosts using a NAT gateway, thereby making them\n      appear
    to be a single host to the ISP) or may have multiple IP\n      addresses provided
    by the commercial ISP.  In either case, the IP\n      address or addresses provided
    by the ISP may themselves be further\n      translated by a Carrier-Grade NAT
    (CGN) operated by the ISP.\n"
  title: 3.  Terminology
- contents:
  - "4.  Relationship between PCP Server and Its PCP-Controlled Device\n   The PCP
    server receives and responds to PCP requests.  The PCP server\n   functionality
    is typically a capability of a NAT or firewall device,\n   as shown in Figure
    1.  It is also possible for the PCP functionality\n   to be provided by some other
    device, which communicates with the\n   actual NAT(s) or firewall(s) via some
    other proprietary mechanism, as\n   long as from the PCP client's perspective
    such split operation is\n   indistinguishable from the integrated case.\n                                  +-----------------+\n
    \        +------------+           | NAT or firewall |\n         | PCP client |-<network>-+
    \     with       +---<Internet>\n         +------------+           |    PCP server
    \  |\n                                  +-----------------+\n                   Figure
    1: PCP-Enabled NAT or Firewall\n   A NAT or firewall device, between the PCP client
    and the Internet,\n   might implement simple or advanced firewall functionality.
    \ This may\n   be a side effect of the technology implemented by the device (e.g.,
    a\n   network address and port translator, by virtue of its port rewriting,\n
    \  normally requires connections to be initiated from an inside host\n   towards
    the Internet), or this might be an explicit firewall policy\n   to deny unsolicited
    traffic from the Internet.  Some firewall devices\n   deny certain unsolicited
    traffic from the Internet (e.g., TCP, UDP to\n   most ports) but allow certain
    other unsolicited traffic from the\n   Internet (e.g., UDP port 500 and IP ESP)
    [RFC6092].  Such default\n   filtering (or lack thereof) is out of scope of PCP
    itself.  If a\n   client device wants to receive traffic and supports PCP, and
    does not\n   possess prior knowledge of such default filtering policy, it SHOULD\n
    \  use PCP to request the necessary mappings to receive the desired\n   traffic.\n"
  title: 4.  Relationship between PCP Server and Its PCP-Controlled Device
- contents:
  - "5.  Note on Fixed-Size Addresses\n   For simplicity in building and parsing request
    and response packets,\n   PCP always uses fixed-size 128-bit IP address fields
    for both IPv6\n   addresses and IPv4 addresses.\n   When the address field holds
    an IPv6 address, the fixed-size 128-bit\n   IP address field holds the IPv6 address
    stored as is.\n   When the address field holds an IPv4 address, an IPv4-mapped
    IPv6\n   address [RFC4291] is used (::ffff:0:0/96).  This has the first 80\n   bits
    set to zero and the next 16 set to one, while its last 32 bits\n   are filled
    with the IPv4 address.  This is unambiguously\n   distinguishable from a native
    IPv6 address, because an IPv4-mapped\n   IPv6 address [RFC4291] would not be valid
    for a mapping.\n   When checking for an IPv4-mapped IPv6 address, all of the first
    96\n   bits MUST be checked for the pattern -- it is not sufficient to check\n
    \  for ones in bits 81-96.\n   The all-zeros IPv6 address MUST be expressed by
    filling the\n   fixed-size 128-bit IP address field with all zeros (::).\n   The
    all-zeros IPv4 address MUST be expressed by 80 bits of zeros,\n   16 bits of ones,
    and 32 bits of zeros (::ffff:0:0).\n"
  title: 5.  Note on Fixed-Size Addresses
- contents:
  - "6.  Protocol Design Note\n   PCP can be viewed as a request/response protocol,
    much like many\n   other UDP-based request/response protocols, and can be implemented\n
    \  perfectly well as such.  It can also be viewed as what might be\n   called
    a hint/notification protocol, and this observation can help\n   simplify implementations.\n
    \  Rather than viewing the message streams between PCP client and PCP\n   server
    as following a strict request/response pattern, where every\n   response is associated
    with exactly one request, the message flows\n   can be viewed as two somewhat
    independent streams carrying\n   information in opposite directions:\n   o  A
    stream of hints flowing from PCP client to PCP server, where the\n      client
    indicates to the server what it would like the state of its\n      mappings to
    be, and\n   o  A stream of notifications flowing from PCP server to PCP client,\n
    \     where the server informs the clients what the state of its\n      mappings
    actually is.\n   To an extent, some of this approach is required anyway in a UDP-based\n
    \  request/response protocol, since UDP packets can be lost, duplicated,\n   or
    reordered.\n   In this view of the protocol, the client transmits hints to the\n
    \  server at various intervals signaling its desires, and the server\n   transmits
    notifications to the client signaling the actual state of\n   its mappings.  These
    two message flows are loosely correlated in that\n   a client request (hint) usually
    elicits a server response\n   (notification), but only loosely, in that a client
    request may result\n   in no server response (in the case of packet loss), and
    a server\n   response may be generated gratuitously without an immediately\n   preceding
    client request (in the case where server configuration\n   change, e.g., change
    of external IP address on a NAT gateway, results\n   in a change of mapping state).\n
    \  The exact times that client requests are sent are influenced by a\n   client
    timing state machine taking into account whether (i) the\n   client has not yet
    received a response from the server for a prior\n   request (retransmission),
    or (ii) the client has previously received\n   a response from the server saying
    how long the indicated mapping\n   would remain active (renewal).  This design
    philosophy is the reason\n   why PCP's retransmissions and renewals are exactly
    the same packet on\n   the wire.  Typically, retransmissions are sent with exponentially\n
    \  increasing intervals as the client waits for the server to respond,\n   whereas
    renewals are sent with exponentially decreasing intervals as\n   the expiry time
    approaches, but, from the server's point of view,\n   both packets are identical,
    and both signal the client's desire that\n   the stated mapping exist or continue
    to exist.\n   A PCP server usually sends responses as a direct result of client\n
    \  requests, but not always.  For example, if a server is too overloaded\n   to
    respond, it is allowed to silently ignore a request message and\n   let the client
    retransmit.  Also, if external factors cause a NAT\n   gateway or firewall's configuration
    to change, then the PCP server\n   can send unsolicited responses to clients informing
    them of the new\n   state of their mappings.  Such reconfigurations are expected
    to be\n   rare, because of the disruption they can cause to clients, but should\n
    \  they happen, PCP provides a way for servers to communicate the new\n   state
    to clients promptly, without having to wait for the next\n   periodic renewal
    request.\n   This design goal helps explain why PCP request and response messages\n
    \  have no transaction ID, because such a transaction ID is unnecessary,\n   and
    would unnecessarily limit the protocol and unnecessarily\n   complicate implementations.
    \ A PCP server response (i.e.,\n   notification) is self-describing and complete.
    \ It communicates the\n   internal and external addresses, protocol, and ports
    for a mapping,\n   and its remaining lifetime.  If the client does in fact currently\n
    \  want such a mapping to exist, then it can identify the mapping in\n   question
    from the internal address, protocol, and port, and update\n   its state to reflect
    the current external address and port, and\n   remaining lifetime.  If a client
    does not currently want such a\n   mapping to exist, then it can safely ignore
    the message.  No client\n   action is required for unexpected mapping notifications.
    \ In today's\n   world, a NAT gateway can have a static mapping, and the client
    device\n   has no explicit knowledge of this, and no way to change the fact.\n
    \  Also, in today's world, a client device can be connected directly to\n   the
    public Internet, with a globally routable IP address, and, in\n   this case, it
    effectively has \"mappings\" for all of its listening\n   ports.  Such a device
    has to be responsible for its own security and\n   cannot rely on assuming that
    some other network device will be\n   blocking all incoming packets.\n"
  title: 6.  Protocol Design Note
- contents:
  - "7.  Common Request and Response Header Format\n   All PCP messages are sent over
    UDP, with a maximum UDP payload length\n   of 1100 octets.  The PCP messages contain
    a request or response\n   header containing an Opcode, any relevant Opcode-specific\n
    \  information, and zero or more options.  All numeric quantities larger\n   than
    a single octet (e.g., result codes, lifetimes, Epoch times,\n   etc.) are represented
    in conventional IETF network order, i.e., most\n   significant octet first.  Non-numeric
    quantities are represented as\n   is on all platforms, with no byte swapping (e.g.,
    IP addresses and\n   ports are placed in PCP messages using the same representation
    as\n   when placed in IP or TCP headers).\n   The packet layout for the common
    header, and operation of the PCP\n   client and PCP server, are described in the
    following sections.  The\n   information in this section applies to all Opcodes.
    \ Behavior of the\n   Opcodes defined in this document is described in Sections
    10, 11, and\n   12.\n"
  - contents:
    - "7.1.  Request Header\n   All requests have the following format:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  Version = 2  |R|   Opcode    |         Reserved              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                 Requested Lifetime (32 bits)                  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \           PCP Client's IP Address (128 bits)                 |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    :                                                               :\n     :
      \            (optional) Opcode-specific information            :\n     :                                                               :\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     :
      \                                                              :\n     :             (optional)
      PCP Options                            :\n     :                                                               :\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure
      2: Common Request Packet Format\n   These fields are described below:\n   Version:
      \ This document specifies protocol version 2.  PCP clients\n      and servers
      compliant with this document use the value 2.  This\n      field is used for
      version negotiation as described in Section 9.\n   R: Indicates Request (0)
      or Response (1).\n   Opcode:  A 7-bit value specifying the operation to be performed.
      \ MAP\n      and PEER Opcodes are defined in Sections 11 and 12.\n   Reserved:
      \ 16 reserved bits.  MUST be zero on transmission and MUST\n      be ignored
      on reception.\n   Requested Lifetime:  An unsigned 32-bit integer, in seconds,
      ranging\n      from 0 to 2^32-1 seconds.  This is used by the MAP and PEER\n
      \     Opcodes defined in this document for their requested lifetime.\n   PCP
      Client's IP Address:  The source IPv4 or IPv6 address in the IP\n      header
      used by the PCP client when sending this PCP request.  An\n      IPv4 address
      is represented using an IPv4-mapped IPv6 address.\n      The PCP Client IP Address
      in the PCP message header is used to\n      detect an unexpected NAT on the
      path between the PCP client and\n      the PCP-controlled NAT or firewall device.
      \ See Section 8.1.\n   Opcode-specific information:  Payload data for this Opcode.
      \ The\n      length of this data is determined by the Opcode definition.\n   PCP
      Options:  Zero, one, or more options that are legal for both a\n      PCP request
      and for this Opcode.  See Section 7.3.\n"
    title: 7.1.  Request Header
  - contents:
    - "7.2.  Response Header\n   All responses have the following format:\n      0
      \                  1                   2                   3\n      0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  Version = 2  |R|   Opcode    |   Reserved    |  Result Code  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                      Lifetime (32 bits)                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                     Epoch Time (32 bits)                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                     Reserved (96 bits)                       |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     :
      \                                                              :\n     :             (optional)
      Opcode-specific response data          :\n     :                                                               :\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     :
      \            (optional) Options                                :\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                 Figure 3: Common Response Packet Format\n   These fields are
      described below:\n   Version:  Responses from servers compliant with this specification\n
      \     MUST use version 2.  This is set by the server.\n   R: Indicates Request
      (0) or Response (1).  All Responses MUST use 1.\n      This is set by the server.\n
      \  Opcode:  The 7-bit Opcode value.  The server copies this value from\n      the
      request.\n   Reserved:  8 reserved bits, MUST be sent as 0, MUST be ignored
      when\n      received.  This is set by the server.\n   Result Code:  The result
      code for this response.  See Section 7.4 for\n      values.  This is set by
      the server.\n   Lifetime:  An unsigned 32-bit integer, in seconds, ranging from
      0 to\n      2^32-1 seconds.  On an error response, this indicates how long\n
      \     clients should assume they'll get the same error response from\n      that
      PCP server if they repeat the same request.  On a success\n      response for
      the PCP Opcodes that create a mapping (MAP and PEER),\n      the Lifetime field
      indicates the lifetime for this mapping.  This\n      is set by the server.\n
      \  Epoch Time:  The server's Epoch Time value.  See Section 8.5 for\n      discussion.
      \ This value is set by the server, in both success and\n      error responses.\n
      \  Reserved:  96 reserved bits.  For requests that were successfully\n      parsed,
      this MUST be sent as 0, MUST be ignored when received.\n      This is set by
      the server.  For requests that were not\n      successfully parsed, the server
      copies the last 96 bits of the PCP\n      Client's IP Address field from the
      request message into this\n      corresponding 96-bit field of the response.\n
      \  Opcode-specific information:  Payload data for this Opcode.  The\n      length
      of this data is determined by the Opcode definition.\n   PCP Options:  Zero,
      one, or more options that are legal for both a\n      PCP response and for this
      Opcode.  See Section 7.3.\n"
    title: 7.2.  Response Header
  - contents:
    - "7.3.  Options\n   A PCP Opcode can be extended with one or more options.  Options
      can\n   be used in requests and responses.  The design decisions in this\n   specification
      about whether to include a given piece of information\n   in the base Opcode
      format or in an option were an engineering trade-\n   off between packet size
      and code complexity.  For information that is\n   usually (or always) required,
      placing it in the fixed Opcode data\n   results in simpler code to generate
      and parse the packet, because the\n   information is a fixed location in the
      Opcode data, but wastes space\n   in the packet in the event that field is all
      zeros because the\n   information is not needed or not relevant.  For information
      that is\n   required less often, placing it in an option results in slightly
      more\n   complicated code to generate and parse packets containing that\n   option,
      but saves space in the packet when that information is not\n   needed.  Placing
      information in an option also means that an\n   implementation that never uses
      that information doesn't even need to\n   implement code to generate and parse
      it.  For example, a client that\n   never requests mappings on behalf of some
      other device doesn't need\n   to implement code to generate the THIRD_PARTY
      option, and a PCP\n   server that doesn't implement the necessary security measures
      to\n   create third-party mappings safely doesn't need to implement code to\n
      \  parse the THIRD_PARTY option.\n   Options use the following Type-Length-Value
      format:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  Option Code  |  Reserved     |       Option Length           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    :                       (optional) Data                         :\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                        Figure 4: Options Header\n   The description of the
      fields is as follows:\n   Option Code:  8 bits.  Its most significant bit indicates
      if this\n      option is mandatory (0) or optional (1) to process.\n   Reserved:
      \ 8 bits.  MUST be set to 0 on transmission and MUST be\n      ignored on reception.\n
      \  Option Length:  16 bits.  Indicates the length of the enclosed data,\n      in
      octets.  Options with length of 0 are allowed.  Options that\n      are not
      a multiple of 4 octets long are followed by one, two, or\n      three 0 octets
      to pad their effective length in the packet to be a\n      multiple of 4 octets.
      \ The Option Length reflects the semantic\n      length of the option, not including
      any padding octets.\n   Data:  Option data.\n   If several options are included
      in a PCP request, they MAY be encoded\n   in any order by the PCP client, but
      MUST be processed by the PCP\n   server in the order in which they appear.  It
      is the responsibility\n   of the PCP client to ensure that the server has sufficient
      room to\n   reply without exceeding the 1100-octet size limit; if its reply
      would\n   exceed that size, the server generates an error.\n   If, while processing
      a PCP request, including its options, an error\n   is encountered that causes
      a PCP error response to be generated, the\n   PCP request MUST cause no state
      change in the PCP server or the\n   PCP-controlled device (i.e., it rolls back
      any tentative changes it\n   might have made while processing the request).
      \ Such an error\n   response MUST consist of a complete copy of the request
      packet with\n   the error code and other appropriate fields set in the header.\n
      \  An option MAY appear more than once in a request or in a response, if\n   permitted
      by the definition of the option.  If the option's\n   definition allows the
      option to appear only once but it appears more\n   than once in a request, and
      the option is understood by the PCP\n   server, the PCP server MUST respond
      with the MALFORMED_OPTION result\n   code.  If the PCP server encounters an
      invalid option (e.g., PCP\n   option length is longer than the UDP packet length),
      the error\n   MALFORMED_OPTION SHOULD be returned (rather than MALFORMED_REQUEST),\n
      \  as that helps the client better understand how the packet was\n   malformed.
      \ If a PCP response would have exceeded the maximum PCP\n   message size, the
      PCP server SHOULD respond with MALFORMED_REQUEST.\n   If the overall option
      structure of a request cannot successfully be\n   parsed (e.g., a nonsensical
      option length), the PCP server MUST\n   generate an error response with code
      MALFORMED_OPTION.\n   If the overall option structure of a request is valid,
      then how each\n   individual option is handled is determined by the most significant\n
      \  bit in the option code.  If the most significant bit is set, handling\n   this
      option is optional, and a PCP server MAY process or ignore this\n   option,
      entirely at its discretion.  If the most significant bit is\n   clear, handling
      this option is mandatory, and a PCP server MUST\n   return the error MALFORMED_OPTION
      if the option contents are\n   malformed, or UNSUPP_OPTION if the option is
      unrecognized,\n   unimplemented, or disabled, or if the client is not authorized
      to use\n   the option.  In error responses, all options are returned.  In\n
      \  success responses, all processed options are included and unprocessed\n   options
      are not included.\n   Because the PCP client cannot reject a response containing
      an Option,\n   PCP clients MUST ignore Options that they do not understand that\n
      \  appear in responses, including Options in the mandatory-to-process\n   range.
      \ Naturally, if a client explicitly requests an Option where\n   correct execution
      of that Option requires processing the Option data\n   in the response, that
      client SHOULD implement code to do that.\n   Different options are valid for
      different Opcodes.  For example:\n   o  The THIRD_PARTY option is valid for
      both MAP and PEER Opcodes.\n   o  The FILTER option is valid only for the MAP
      Opcode (for the PEER\n      Opcode it would have no meaning).\n   o  The PREFER_FAILURE
      option is valid only for the MAP Opcode (for\n      the PEER Opcode, similar
      semantics are automatically implied).\n"
    title: 7.3.  Options
  - contents:
    - "7.4.  Result Codes\n   The following result codes may be returned as a result
      of any Opcode\n   received by the PCP server.  The only success result code
      is 0; other\n   values indicate an error.  If a PCP server encounters multiple
      errors\n   during processing of a request, it SHOULD use the most specific error\n
      \  message.  Each error code below is classified as either a 'long\n   lifetime'
      error or a 'short lifetime' error, which provides guidance\n   to PCP server
      developers for the value of the Lifetime field for\n   these errors.  It is
      RECOMMENDED that short lifetime errors use a\n   30-second lifetime and long
      lifetime errors use a 30-minute lifetime.\n   0  SUCCESS: Success.\n   1  UNSUPP_VERSION:
      The version number at the start of the PCP Request\n      header is not recognized
      by this PCP server.  This is a long\n      lifetime error.  This document describes
      PCP version 2.\n   2  NOT_AUTHORIZED: The requested operation is disabled for
      this PCP\n      client, or the PCP client requested an operation that cannot
      be\n      fulfilled by the PCP server's security policy.  This is a long\n      lifetime
      error.\n   3  MALFORMED_REQUEST: The request could not be successfully parsed.\n
      \     This is a long lifetime error.\n   4  UNSUPP_OPCODE: Unsupported Opcode.
      \ This is a long lifetime error.\n   5  UNSUPP_OPTION: Unsupported option.  This
      error only occurs if the\n      option is in the mandatory-to-process range.
      \ This is a long\n      lifetime error.\n   6  MALFORMED_OPTION: Malformed option
      (e.g., appears too many times,\n      invalid length).  This is a long lifetime
      error.\n   7  NETWORK_FAILURE: The PCP server or the device it controls is\n
      \     experiencing a network failure of some sort (e.g., has not yet\n      obtained
      an external IP address).  This is a short lifetime error.\n   8  NO_RESOURCES:
      Request is well-formed and valid, but the server has\n      insufficient resources
      to complete the requested operation at this\n      time.  For example, the NAT
      device cannot create more mappings at\n      this time, is short of CPU cycles
      or memory, or is unable to\n      handle the request due to some other temporary
      condition.  The\n      same request may succeed in the future.  This is a system-wide\n
      \     error, different from USER_EX_QUOTA.  This can be used as a catch-\n      all
      error, should no other error message be suitable.  This is a\n      short lifetime
      error.\n   9  UNSUPP_PROTOCOL: Unsupported transport protocol, e.g., SCTP in
      a\n      NAT that handles only UDP and TCP.  This is a long lifetime error.\n
      \  10 USER_EX_QUOTA: This attempt to create a new mapping would exceed\n      this
      subscriber's port quota.  This is a short lifetime error.\n   11 CANNOT_PROVIDE_EXTERNAL:
      The suggested external port and/or\n      external address cannot be provided.
      \ This error MUST only be\n      returned for:\n      *  MAP requests that included
      the PREFER_FAILURE option\n         (normal MAP requests will return an available
      external port)\n      *  MAP requests for the SCTP protocol (PREFER_FAILURE
      is implied)\n      *  PEER requests\n      See Section 13.2 for details of the
      PREFER_FAILURE Option.  The\n      error lifetime depends on the reason for
      the failure.\n   12 ADDRESS_MISMATCH: The source IP address of the request packet
      does\n      not match the contents of the PCP Client's IP Address field, due\n
      \     to an unexpected NAT on the path between the PCP client and the\n      PCP-controlled
      NAT or firewall.  This is a long lifetime error.\n   13 EXCESSIVE_REMOTE_PEERS:
      The PCP server was not able to create the\n      filters in this request.  This
      result code MUST only be returned\n      if the MAP request contained the FILTER
      option.  See Section 13.3\n      for details of the FILTER Option.  This is
      a long lifetime error.\n"
    title: 7.4.  Result Codes
  title: 7.  Common Request and Response Header Format
- contents:
  - "8.  General PCP Operation\n   PCP messages MUST be sent over UDP [RFC0768].  Every
    PCP request\n   generates at least one response, so PCP does not need to run over
    a\n   reliable transport protocol.\n   When receiving multiple identical requests,
    the PCP server will\n   generally generate identical responses -- barring cases
    where the PCP\n   server's state changes between those requests due to other activity.\n
    \  As an example of how such a state change could happen, a request\n   could
    be received while the PCP-controlled device has no mappings\n   available, and
    the PCP server will generate an error response.  If\n   mappings become available
    and then another copy of that same request\n   arrives (perhaps duplicated in
    transit in the network), the PCP\n   server will allocate a mapping and generate
    a non-error response.  A\n   PCP client MUST handle such updated responses for
    any request it\n   sends, most notably to support rapid recovery (Section 14).
    \ Also see\n   the Protocol Design Note (Section 6).\n"
  - contents:
    - "8.1.  General PCP Client: Generating a Request\n   This section details operation
      specific to a PCP client, for any\n   Opcode.  Procedures specific to the MAP
      Opcode are described in\n   Section 11, and procedures specific to the PEER
      Opcode are described\n   in Section 12.\n   Prior to sending its first PCP message,
      the PCP client determines\n   which server to use.  The PCP client performs
      the following steps to\n   determine its PCP server:\n   1.  if a PCP server
      is configured (e.g., in a configuration file or\n       via DHCP), that single
      configuration source is used as the list\n       of PCP server(s), else\n   2.
      \ the default router list (for IPv4 and IPv6) is used as the list\n       of
      PCP server(s).  Thus, if a PCP client has both an IPv4 and\n       IPv6 address,
      it will have an IPv4 PCP server (its IPv4 default\n       router) for its IPv4
      mappings, and an IPv6 PCP server (its IPv6\n       default router) for its IPv6
      mappings.\n   For the purposes of this document, only a single PCP server address\n
      \  is supported.  Should future specifications define configuration\n   methods
      that provide a longer list of PCP server addresses, those\n   specifications
      will define how clients select one or more addresses\n   from that list.\n   With
      that PCP server address, the PCP client formulates its PCP\n   request.  The
      PCP request contains a PCP common header, PCP Opcode\n   and payload, and (possibly)
      options.  As with all UDP client software\n   on any operating system, when
      several independent PCP clients exist\n   on the same host, each uses a distinct
      source port number to\n   disambiguate their requests and replies.  The PCP
      client's source\n   port SHOULD be randomly generated [RFC6056].\n   The PCP
      client MUST include the source IP address of the PCP message\n   in the PCP
      request.  This is typically its own IP address; see\n   Section 16.4 for how
      this can be coded.  This is used to detect an\n   unexpected NAT on the path
      between the PCP client and the\n   PCP-controlled NAT or firewall device, to
      avoid wasting resources on\n   the PCP-controlled NAT creating pointless non-functional
      mappings.\n   When such an intervening non-PCP-aware inner NAT is detected,\n
      \  mappings must first be created by some other means in the inner NAT,\n   before
      mappings can be usefully created in the outer PCP-controlled\n   NAT.  Having
      created mappings in the inner NAT by some other means,\n   the PCP client should
      then use the inner NAT's external address as\n   the client IP address, to signal
      to the outer PCP-controlled NAT that\n   the client is aware of the inner NAT,
      and has taken steps to create\n   mappings in it by some other means, so that
      mappings created in the\n   outer NAT will not be a pointless waste of resources.\n"
    - contents:
      - "8.1.1.  PCP Client Retransmission\n   PCP clients are responsible for reliable
        delivery of PCP request\n   messages.  If a PCP client fails to receive an
        expected response from\n   a server, the client must retransmit its message.
        \ The\n   retransmissions MUST use the same Mapping Nonce value (see Sections\n
        \  11.1 and 12.1).  The client begins the message exchange by\n   transmitting
        a message to the server.  The message exchange continues\n   for as long as
        the client wishes to maintain the mapping, and\n   terminates when the PCP
        client is no longer interested in the PCP\n   transaction (e.g., the application
        that requested the mapping is no\n   longer interested in the mapping) or
        (optionally) when the message\n   exchange is considered to have failed according
        to the retransmission\n   mechanism described below.\n   The client retransmission
        behavior is controlled and described by the\n   following variables:\n     RT:
        \  Retransmission timeout, calculated as described below\n    IRT:   Initial
        retransmission time, SHOULD be 3 seconds\n    MRC:   Maximum retransmission
        count, SHOULD be 0 (0 indicates no\n           maximum)\n    MRT:   Maximum
        retransmission time, SHOULD be 1024 seconds\n    MRD:   Maximum retransmission
        duration, SHOULD be 0 (0 indicates no\n           maximum)\n   RAND:   Randomization
        factor, calculated as described below\n   With each message transmission or
        retransmission, the client sets RT\n   according to the rules given below.
        \ If RT expires before a response\n   is received, the client retransmits
        the request and computes a new\n   RT.\n   Each of the computations of a new
        RT include a new randomization\n   factor (RAND), which is a random number
        chosen with a uniform\n   distribution between -0.1 and +0.1.  The randomization
        factor is\n   included to minimize synchronization of messages transmitted
        by PCP\n   clients.  The algorithm for choosing a random number does not need
        to\n   be cryptographically sound.  The algorithm SHOULD produce a different\n
        \  sequence of random numbers from each invocation of the PCP client.\n   The
        RT value is initialized based on IRT:\n      RT = (1 + RAND) * IRT\n   RT
        for each subsequent message transmission is based on the previous\n   value
        of RT, subject to the upper bound on the value of RT specified\n   by MRT.
        \ If MRT has a value of 0, there is no upper limit on the\n   value of RT,
        and MRT is treated as \"infinity\".  The new value of RT\n   is calculated
        as shown below, where RTprev is the current value of\n   RT:\n      RT = (1
        + RAND) * MIN (2 * RTprev, MRT)\n   MRC specifies an upper bound on the number
        of times a client may\n   retransmit a message.  Unless MRC is zero, the message
        exchange fails\n   once the client has transmitted the message MRC times.\n
        \  MRD specifies an upper bound on the length of time a client may\n   retransmit
        a message.  Unless MRD is zero, the message exchange fails\n   once MRD seconds
        have elapsed since the client first transmitted the\n   message.\n   If both
        MRC and MRD are non-zero, the message exchange fails whenever\n   either of
        the conditions specified in the previous two paragraphs are\n   met.  If both
        MRC and MRD are zero, the client continues to transmit\n   the message until
        it receives a response or the client no longer\n   wants a mapping.\n   Once
        a PCP client has successfully received a response from a PCP\n   server on
        that interface, it resets RT to a value randomly selected\n   in the range
        1/2 to 5/8 of the mapping lifetime, as described in\n   Section 11.2.1, \"Renewing
        a Mapping\", and sends subsequent PCP\n   requests for that mapping to that
        same server.\n      Note: If the server's state changes between retransmissions
        and\n      the server's response is delayed or lost, the state in the PCP\n
        \     client and server may not be synchronized.  This is not unique to\n
        \     PCP, but also occurs with other network protocols (e.g., TCP).  In\n
        \     the unlikely event that such de-synchronization occurs, PCP heals\n
        \     itself after lifetime seconds.\n"
      title: 8.1.1.  PCP Client Retransmission
    title: '8.1.  General PCP Client: Generating a Request'
  - contents:
    - "8.2.  General PCP Server: Processing a Request\n   This section details operation
      specific to a PCP server.  Processing\n   SHOULD be performed in the order of
      the following paragraphs.\n   A PCP server MUST only accept normal (non-THIRD_PARTY)
      PCP requests\n   from a client on the same interface from which it would normally\n
      \  receive packets from that client, and it MUST silently ignore PCP\n   requests
      arriving on any other interface.  For example, a residential\n   NAT gateway
      accepts PCP requests only when they arrive on its (LAN)\n   interface connecting
      to the internal network, and silently ignores\n   any PCP requests arriving
      on its external (WAN) interface.  A PCP\n   server that supports THIRD_PARTY
      requests MAY be configured to accept\n   THIRD_PARTY requests on other configured
      interfaces (see Section 13.1\n   for details on the THIRD_PARTY Option).\n   Upon
      receiving a request, the PCP server parses and validates it.  A\n   valid request
      contains a valid PCP common header, one valid PCP\n   Opcode, and zero or more
      options (which the server might or might not\n   comprehend).  If an error is
      encountered during processing, the\n   server generates an error response that
      is sent back to the PCP\n   client.  Processing of an Opcode and its options
      is specific to each\n   Opcode.\n   Error responses have the same packet layout
      as success responses,\n   with certain fields from the request copied into the
      response, and\n   other fields assigned by the PCP server set as indicated in
      Figure 3.\n   Copying request fields into the response is important because
      this is\n   what enables a client to identify to which request a given response\n
      \  pertains.  For Opcodes that are understood by the PCP server, it\n   follows
      the requirements of that Opcode to copy the appropriate\n   fields.  For Opcodes
      that are not understood by the PCP server, it\n   simply generates the UNSUPP_OPCODE
      response and copies fields from\n   the PCP header and copies the rest of the
      PCP payload as is (without\n   attempting to interpret it).\n   All responses
      (both error and success) contain the same Opcode as the\n   request, but with
      the \"R\" bit set.\n   Any error response has a non-zero result code, and is
      created by:\n   o  Copying the entire UDP payload, or 1100 octets, whichever
      is less,\n      and zero-padding the response to a multiple of 4 octets if\n
      \     necessary\n   o  Setting the R bit\n   o  Setting the result code\n   o
      \ Setting the Lifetime, Epoch Time, and Reserved fields\n   o  Updating other
      fields in the response, as indicated by 'set by the\n      server' in the PCP
      response field description\n   A success response has a zero result code, and
      is created by:\n   o  Copying the first 4 octets of request packet header\n
      \  o  Setting the R bit\n   o  Setting the result code to zero\n   o  Setting
      the Lifetime, Epoch Time, and Reserved fields\n   o  Possibly setting Opcode-specific
      response data if appropriate\n   o  Adding any processed options to the response
      message\n   If the received PCP request message is less than 2 octets long,
      it is\n   silently dropped.\n   If the R bit is set, the message is silently
      dropped.\n   If the first octet (version) is a version that is not supported,
      a\n   response is generated with the UNSUPP_VERSION result code, and the\n   Version
      Negotiation steps detailed in Section 9 are followed.\n   Otherwise, if the
      version is supported but the received message is\n   shorter than 24 octets,
      the message is silently dropped.\n   If the server is overloaded by requests
      (from a particular client or\n   from all clients), it MAY simply silently discard
      requests, as the\n   requests will be retried by PCP clients, or it MAY generate
      the\n   NO_RESOURCES error response.\n   If the length of the message exceeds
      1100 octets, is not a multiple\n   of 4 octets, or is too short for the Opcode
      in question, it is\n   invalid and a MALFORMED_REQUEST response is generated,
      and the\n   response message is truncated to 1100 octets.\n   The PCP server
      compares the source IP address (from the received IP\n   header) with the field
      PCP Client IP Address.  If they do not match,\n   the error ADDRESS_MISMATCH
      MUST be returned.  This is done to detect\n   and prevent accidental use of
      PCP where a non-PCP-aware NAT exists\n   between the PCP client and PCP server.
      \ If the PCP client wants such\n   a mapping, it needs to ensure that the PCP
      field matches its apparent\n   IP address from the perspective of the PCP server.\n"
    title: '8.2.  General PCP Server: Processing a Request'
  - contents:
    - "8.3.  General PCP Client: Processing a Response\n   The PCP client receives
      the response and verifies that the source IP\n   address and port belong to
      the PCP server of a previously sent PCP\n   request.  If not, the response is
      silently dropped.\n   If the received PCP response message is less than 4 octets
      long, it\n   is silently dropped.\n   If the R bit is clear, the message is
      silently dropped.\n   If the error code is UNSUPP_VERSION, Version Negotiation
      processing\n   continues as described in Section 9.\n   Responses shorter than
      24 octets, longer than 1100 octets, or not a\n   multiple of 4 octets are invalid
      and ignored.\n   The PCP client then validates that the Opcode matches a previous
      PCP\n   request.  If the response does not match a previous PCP request, the\n
      \  response is ignored.  The response is further matched by comparing\n   fields
      in the response Opcode-specific data to fields in the request\n   Opcode-specific
      data, as described by the processing for that Opcode.\n   If that fails, the
      response is ignored.\n   After these matches are successful, the PCP client
      checks the Epoch\n   Time field (see Section 8.5) to determine if it needs to
      restore its\n   state to the PCP server.  A PCP client SHOULD be prepared to
      receive\n   multiple responses from the PCP server at any time after a single\n
      \  request is sent.  This allows the PCP server to inform the client of\n   mapping
      changes such as an update or deletion.  For example, a PCP\n   server might
      send a SUCCESS response and, after a configuration\n   change on the PCP server,
      later send a NOT_AUTHORIZED response.  A\n   PCP client MUST be prepared to
      receive responses for requests it\n   never sent (which could have been sent
      by a previous PCP instance on\n   this same host, or by a previous host that
      used the same client IP\n   address, or by a malicious attacker) by simply ignoring
      those\n   unexpected messages.\n   If the error ADDRESS_MISMATCH is received,
      it indicates the presence\n   of a NAT between the PCP client and PCP server.
      \ Procedures to\n   resolve this problem are beyond the scope of this document.\n
      \  For both success and error responses, a Lifetime value is returned.\n   The
      lifetime indicates how long this response should be considered\n   valid by
      the client (i.e for success results, how long the mapping\n   will last, and
      for failure results how long the same failure\n   condition should be expected
      to persist).  The PCP client SHOULD\n   impose an upper limit on this returned
      value (to protect against\n   absurdly large values, e.g., 5 years), detailed
      in Section 15,\n   \"Mapping Lifetime and Deletion\".\n   If the result code
      is 0 (SUCCESS), the request succeeded.\n   If the result code is not 0, the
      request failed, and the PCP client\n   SHOULD NOT resend the same request for
      the indicated lifetime of the\n   error (as limited by the sanity checking detailed
      in Section 15).\n   If the PCP client has discovered a new PCP server (e.g.,
      connected to\n   a new network), the PCP client MAY immediately begin communicating\n
      \  with this PCP server, without regard to hold times from communicating\n   with
      a previous PCP server.\n"
    title: '8.3.  General PCP Client: Processing a Response'
  - contents:
    - "8.4.  Multi-Interface Issues\n   Hosts that desire a PCP mapping might be multi-interfaced
      (i.e., own\n   several logical/physical interfaces).  Indeed, a host can be\n
      \  configured with several IPv4 addresses (e.g., WiFi and Ethernet) or\n   dual-stacked.
      \ These IP addresses may have distinct reachability\n   scopes (e.g., if IPv6,
      they might have global reachability scope as\n   is the case for a Global Unicast
      Address (GUA) [RFC3587] or limited\n   scope as is the case for a Unique Local
      Address (ULA) [RFC4193]).\n   IPv6 addresses with global reachability (e.g.,
      GUAs) SHOULD be used\n   as the source address when generating a PCP request.
      \ IPv6 addresses\n   without global reachability (e.g., ULAs) SHOULD NOT be
      used as the\n   source interface when generating a PCP request.  If IPv6 privacy\n
      \  addresses [RFC4941] are used for PCP mappings, a new PCP request will\n   need
      to be issued whenever the IPv6 privacy address is changed.  This\n   PCP request
      SHOULD be sent from the IPv6 privacy address itself.  It\n   is RECOMMENDED
      that the client delete its mappings to the previous\n   privacy address after
      it no longer needs those old mappings.\n   Due to the ubiquity of IPv4 NAT,
      IPv4 addresses with limited scope\n   (e.g., private addresses [RFC1918]) MAY
      be used as the source\n   interface when generating a PCP request.\n"
    title: 8.4.  Multi-Interface Issues
  - contents:
    - "8.5.  Epoch\n   Every PCP response sent by the PCP server includes an Epoch
      Time\n   field.  This time field increments by one every second.  Anomalies
      in\n   the received Epoch Time value provide a hint to PCP clients that a\n
      \  PCP server state loss may have occurred.  Clients respond to such\n   state
      loss hints by promptly renewing their mappings, so as to\n   quickly restore
      any lost state at the PCP server.\n   If the PCP server resets or loses the
      state of its explicit dynamic\n   mappings (that is, those mappings created
      by PCP requests), due to\n   reboot, power failure, or any other reason, it
      MUST reset its Epoch\n   time to its initial starting value (usually zero) to
      provide this\n   hint to PCP clients.  After resetting its Epoch time, the PCP
      server\n   resumes incrementing the Epoch Time value by one every second.\n
      \  Similarly, if the external IP address(es) of the NAT (controlled by\n   the
      PCP server) changes, the Epoch time MUST be reset.  A PCP server\n   MAY maintain
      one Epoch Time value for all PCP clients or MAY maintain\n   distinct Epoch
      Time values (per PCP client, per interface, or based\n   on other criteria);
      this choice is implementation-dependent.\n   Whenever a client receives a PCP
      response, the client validates the\n   received Epoch Time value according to
      the procedure below, using\n   integer arithmetic:\n   o  If this is the first
      PCP response the client has received from\n      this PCP server, the Epoch
      Time value is treated as necessarily\n      valid, otherwise\n      *  If the
      current PCP server Epoch time (curr_server_time) is less\n         than the
      previously received PCP server Epoch time\n         (prev_server_time) by more
      than one second, then the client\n         treats the Epoch time as obviously
      invalid (time should not go\n         backwards).  The server Epoch time apparently
      going backwards\n         by *up to* one second is not deemed invalid, so that
      minor\n         packet reordering on the path from PCP server to PCP client\n
      \        does not trigger a cascade of unnecessary mapping renewals.  If\n         the
      server Epoch time passes this check, then further\n         validation checks
      are performed:\n         +  The client computes the difference between its\n
      \           current local time (curr_client_time) and the\n            time
      the previous PCP response was received from this PCP\n            server (prev_client_time):\n
      \           client_delta = curr_client_time - prev_client_time;\n         +
      \ The client computes the difference between the\n            current PCP server
      Epoch time (curr_server_time) and the\n            previously received Epoch
      time (prev_server_time):\n            server_delta = curr_server_time - prev_server_time;\n
      \        +  If client_delta+2 < server_delta - server_delta/16\n            or
      server_delta+2 < client_delta - client_delta/16,\n            then the client
      treats the Epoch Time value as invalid,\n            else the client treats
      the Epoch Time value as valid.\n   o  The client records the current time values
      for use in its next\n      comparison:\n      prev_client_time = curr_client_time\n
      \     prev_server_time = curr_server_time\n   If the PCP client determined that
      the Epoch Time value it received\n   was invalid, then it concludes that the
      PCP server may have lost\n   state, and promptly renews all its active port
      mapping leases\n   following the mapping recreation procedure described in\n
      \  Section 16.3.1.\n   Notes:\n   o  The client clock MUST never go backwards.
      \ If curr_client_time is\n      found to be less than prev_client_time, then
      this is a client bug,\n      and how the client deals with this client bug is
      implementation\n      specific.\n   o  The calculations above are constructed
      to allow client_delta and\n      server_delta to be computed as unsigned integer
      values.\n   o  The \"+2\" in the calculations above is to accommodate quantization\n
      \     errors in client and server clocks (up to one-second quantization\n      error
      each in server and client time intervals).\n   o  The \"/16\" in the calculations
      above is to accommodate inaccurate\n      clocks in low-cost devices.  This
      allows for a total discrepancy\n      of up to 1/16 (6.25%) to be considered
      benign; e.g., if one clock\n      were to run too fast by 3% while the other
      clock ran too slow by\n      3%, then the client would not consider this difference
      to be\n      anomalous or indicative of a restart having occurred.  This\n      tolerance
      is strict enough to be effective at detecting reboots,\n      while not being
      so strict as to generate false alarms.\n"
    title: 8.5.  Epoch
  title: 8.  General PCP Operation
- contents:
  - "9.  Version Negotiation\n   A PCP client sends its requests using PCP version
    number 2.  Should\n   later updates to this document specify different message
    formats with\n   a version number greater than 2, it is expected that PCP servers
    will\n   still support version 2 in addition to the newer version(s).\n   However,
    in the event that a server returns a response with result\n   code UNSUPP_VERSION,
    the client MAY log an error message to inform\n   the user that it is too old
    to work with this server.\n   Should later updates to this document specify different
    message\n   formats with a version number greater than 2, and backwards\n   compatibility
    be desired, this first octet can be used for forward\n   and backward compatibility.\n
    \  If future PCP versions greater than 2 are specified, version\n   negotiation
    proceeds as follows:\n   1.  The client sends its first request using the highest\n
    \      (i.e., presumably 'best') version number it supports.\n   2.  If the server
    supports that version, it responds normally.\n   3.  If the server does not support
    that version, it replies giving a\n       result containing the result code UNSUPP_VERSION,
    and the closest\n       version number it does support (if the server supports
    a range of\n       versions higher than the client's requested version, the server\n
    \      returns the lowest of that supported range; if the server\n       supports
    a range of versions lower than the client's requested\n       version, the server
    returns the highest of that supported range).\n   4.  If the client receives an
    UNSUPP_VERSION result containing a\n       version it does support, it records
    this fact and proceeds to use\n       this message version for subsequent communication
    with this PCP\n       server (until a possible future UNSUPP_VERSION response
    if the\n       server is later updated, at which point the version negotiation\n
    \      process repeats).  If the version number in the UNSUPP_VERSION\n       response
    is zero then that means this is a NAT-PMP server\n       [RFC6886], and a client
    MAY choose to communicate with it using\n       the older NAT-PMP protocol, as
    described in Appendix A.\n   5.  If the client receives an UNSUPP_VERSION result
    containing a\n       version it does not support, then the client SHOULD try the
    next-\n       lower version supported by the client.  The attempt to use the\n
    \      next-lower version repeats until the client has tried version 2.\n       If
    using version 2 fails, the client MAY log an error message to\n       inform the
    user that it is too old to work with this server, and\n       the client SHOULD
    set a timer to retry its request in 30 minutes\n       or the returned Lifetime
    value, whichever is smaller.  By\n       automatically retrying in 30 minutes,
    the protocol accommodates\n       an upgrade of the PCP server.\n"
  title: 9.  Version Negotiation
- contents:
  - "10.  Introduction to MAP and PEER Opcodes\n   There are four uses for the MAP
    and PEER Opcodes defined in this\n   document:\n   o  a host operating a server
    and wanting an incoming connection\n      (Section 10.1);\n   o  a host operating
    a client and server on the same port\n      (Section 10.2);\n   o  a host operating
    a client and wanting to optimize the application\n      keepalive traffic (Section
    10.3); and\n   o  a host operating a client and wanting to restore lost state
    in its\n      NAT (Section 10.4).\n   These are discussed in the following sections,
    and a (non-normative)\n   state diagram is provided in Section 16.5.\n   When
    operating a server (see Sections 10.1 and 10.2), the PCP client\n   knows if it
    wants an IPv4 listener, IPv6 listener, or both on the\n   Internet.  The PCP client
    also knows if it has an IPv4 address or\n   IPv6 address configured on one of
    its interfaces.  It takes the union\n   of this knowledge to decide to which of
    its PCP servers to send the\n   request (e.g., an IPv4 address or an IPv6 address),
    and whether to\n   send one or two MAP requests for each of its interfaces (e.g.,
    if the\n   PCP client has only an IPv4 address but wants both IPv6 and IPv4\n
    \  listeners, it sends a MAP request containing the all-zeros IPv6\n   address
    in the Suggested External Address field, and sends a second\n   MAP request containing
    the all-zeros IPv4 address in the Suggested\n   External Address field).  If the
    PCP client has both an IPv4 and IPv6\n   address, and only wants an IPv4 listener,
    it sends one MAP request\n   from its IPv4 address (if the PCP server supports
    NAT44 or IPv4\n   firewall) or one MAP request from its IPv6 address (if the PCP
    server\n   supports NAT64).  The PCP client can simply request the desired\n   mapping
    to determine if the PCP server supports the desired mapping.\n   Applications
    that embed IP addresses in payloads (e.g., FTP, SIP)\n   will find it beneficial
    to avoid address family translation, if\n   possible.\n   The MAP and PEER requests
    include a Suggested External IP Address\n   field.  Some PCP-controlled devices,
    especially CGN but also multi-\n   homed NPTv6 networks, have a pool of public-facing
    IP addresses.  PCP\n   allows the client to indicate if it wants a mapping assigned
    on a\n   specific address of that pool or any address of that pool.  Some\n   applications
    will break if mappings are created on different IP\n   addresses (e.g., active
    mode FTP), so applications should carefully\n   consider the implications of using
    this capability.  Static mappings\n   for that internal address (e.g., those created
    by a command-line\n   interface on the PCP server or PCP-controlled device) may
    exist to a\n   certain external address, and if the suggested external IP address
    is\n   the IPv4 or IPv6 all-zeros address, PCP SHOULD assign its mappings to\n
    \  the same external address, as this can also help applications using a\n   mix
    of both static mappings and PCP-created mappings.  If, on the\n   other hand,
    the suggested external IP address contains a non-zero IP\n   address the PCP server
    SHOULD create a mapping to that external\n   address, even if there are other
    mappings from that same internal\n   address to a different external address.
    \ Once an internal address\n   has no implicit dynamic mappings and no explicit
    dynamic mappings in\n   the PCP-controlled device, a subsequent implicit or explicit
    mapping\n   for that internal address MAY be assigned to a different External\n
    \  address.  Generally, this reassignment would occur when a CGN device\n   is
    load balancing newly seen internal addresses to its public pool of\n   external
    addresses.\n   The following table summarizes how various common PCP deployments
    use\n   IPv6 and IPv4 addresses.\n   The 'internal' address is implicitly the
    same as the source IP\n   address of the PCP request, except when the THIRD_PARTY
    option is\n   used.\n   The 'external' address is the Suggested External Address
    field of the\n   MAP or PEER request, and its address family is usually the same
    as\n   the 'internal' address family, except when technologies like NAT64\n   are
    used.\n   The 'remote peer' address is the remote peer IP address of the PEER\n
    \  request or the FILTER option of the MAP request, and is always the\n   same
    address family as the 'internal' address, even when NAT64 is\n   used.  In NAT64,
    the IPv6 PCP client is not necessarily aware of the\n   NAT64 or aware of the
    actual IPv4 address of the remote peer, so it\n   expresses the IPv6 address from
    its perspective, as shown in Figure\n   5.\n                 internal  external
    \ PCP remote peer  actual remote peer\n                 --------  -------   ---------------
    \ ------------------\n   IPv4 firewall   IPv4      IPv4         IPv4              IPv4\n
    \  IPv6 firewall   IPv6      IPv6         IPv6              IPv6\n           NAT44
    \  IPv4      IPv4         IPv4              IPv4\n           NAT46   IPv4      IPv6
    \        IPv4              IPv6\n           NAT64   IPv6      IPv4         IPv6
    \             IPv4\n           NPTv6   IPv6      IPv6         IPv6              IPv6\n
    \              Figure 5: Address Families with MAP and PEER\n   Note that the
    internal address and the remote peer address are always\n   the same address family,
    and the external address and the actual\n   remote peer address are always the
    same address family.\n"
  - contents:
    - "10.1.  For Operating a Server\n   A host operating a server (e.g., a web server)
      listens for traffic on\n   a port, but the server never initiates traffic from
      that port.  For\n   this to work across a NAT or a firewall, the host needs
      to (a) create\n   a mapping from a public IP address, protocol, and port to
      itself\n   using the MAP Opcode, as described in Section 11; (b) publish that\n
      \  public IP address, protocol, and port via some sort of rendezvous\n   server
      (e.g., DNS, a SIP message, or a proprietary protocol); and\n   (c) ensure that
      any other non-PCP-speaking packet filtering\n   middleboxes on the path (e.g.,
      host-based firewall, network-based\n   firewall, or other NATs) will also allow
      the incoming traffic.\n   Publishing the public IP address and port is out of
      scope of this\n   specification.  To accomplish (a), the host follows the procedures\n
      \  described in this section.\n   As normal, the application needs to begin
      listening on a port.  Then,\n   the application constructs a PCP message with
      the MAP Opcode, with\n   the external address set to the appropriate all-zeros
      address,\n   depending on whether it wants a public IPv4 or IPv6 address.\n
      \  The following pseudocode shows how PCP can be reliably used to\n   operate
      a server:\n    /* start listening on the local server port */\n    int s = socket(...);\n
      \   bind(s, ...);\n    listen(s, ...);\n    getsockname(s, &internal_sockaddr,
      ...);\n    bzero(&external_sockaddr, sizeof(external_sockaddr));\n    while
      (1)\n        {\n        /* Note: The \"time_to_send_pcp_request()\" check below
      includes:\n         * 1. Sending the first request\n         * 2. Retransmitting
      requests due to packet loss\n         * 3. Resending a request due to impending
      lease expiration\n         * 4. Resending a request due to server state loss\n
      \        * The PCP packet sent is identical in all four cases; from\n         *
      the PCP server's point of view they are the same operation.\n         * The
      suggested external address and port may be updated\n         * repeatedly during
      the lifetime of the mapping.\n         * Other fields in the packet generally
      remain unchanged.\n         */\n        if (time_to_send_pcp_request())\n            pcp_send_map_request(internal_sockaddr.sin_port,\n
      \               internal_sockaddr.sin_addr,\n                &external_sockaddr,
      /* will be zero the first time */\n                requested_lifetime, &assigned_lifetime);\n
      \       if (pcp_response_received())\n            update_rendezvous_server(\"Client
      Ident\", external_sockaddr);\n        if (received_incoming_connection_or_packet())\n
      \           process_it(s);\n        if (other_work_to_do())\n            do_it();\n
      \       /* ... */\n        block_until_we_need_to_do_something_else();\n        }\n
      \         Figure 6: Pseudocode for Using PCP to Operate a Server\n"
    title: 10.1.  For Operating a Server
  - contents:
    - "10.2.  For Operating a Symmetric Client/Server\n   A host operating a client
      and server on the same port (e.g.,\n   Symmetric RTP [RFC4961] or SIP Symmetric
      Response Routing (rport)\n   [RFC3581]) first establishes a local listener,
      (usually) sends the\n   local and public IP addresses, protocol, and ports to
      a rendezvous\n   service (which is out of scope of this document), and initiates
      an\n   outbound connection from that same source address and same port.  To\n
      \  accomplish this, the application uses the procedure described in this\n   section.\n
      \  An application that is using the same port for outgoing connections\n   as
      well as incoming connections MUST first signal its operation of a\n   server
      using the PCP MAP Opcode, as described in Section 11, and\n   receive a positive
      PCP response before it sends any packets from that\n   port.\n      Discussion:
      In general, a PCP client doesn't know in advance if it\n      is behind a NAT
      or firewall.  On detecting that the host has\n      connected to a new network,
      the PCP client can attempt to request\n      a mapping using PCP; if that succeeds,
      then the client knows it\n      has successfully created a mapping.  If, after
      multiple retries,\n      it has received no PCP response, then either the client
      is *not*\n      behind a NAT or firewall and has unfettered connectivity or
      the\n      client *is* behind a NAT or firewall that doesn't support PCP (and\n
      \     the client may still have working connectivity by virtue of static\n      mappings
      previously created manually by the user).  Retransmitting\n      PCP requests
      multiple times before giving up and assuming\n      unfettered connectivity
      adds delay in that case.  Initiating\n      outbound TCP connections immediately
      without waiting for PCP\n      avoids this delay, and will work if the NAT has
      endpoint-\n      independent mapping (EIM) behavior, but may fail if the NAT
      has\n      endpoint-dependent mapping (EDM) behavior.  Waiting enough time to\n
      \     allow an explicit PCP MAP mapping to be created (if possible)\n      first
      ensures that the same external port will then be used for\n      all subsequent
      implicit dynamic mappings (e.g., TCP SYNs) sent\n      from the specified internal
      address, protocol, and port.  PCP\n      supports both EIM and EDM NATs, so
      clients need to assume they may\n      be dealing with an EDM NAT.  In this
      case, the client will\n      experience more reliable connectivity if it attempts
      explicit PCP\n      MAP requests first, before initiating any outbound TCP connections\n
      \     from that internal address and port.  For further information on\n      using
      PCP with EDM NATs, see Section 16.1.\n   The following pseudocode shows how
      PCP can be used to operate a\n   symmetric client and server:\n    /* start
      listening on the local server port */\n    int s = socket(...);\n    bind(s,
      ...);\n    listen(s, ...);\n    getsockname(s, &internal_sockaddr, ...);\n    bzero(&external_sockaddr,
      sizeof(external_sockaddr));\n    while (1)\n        {\n        /* Note: The
      \"time_to_send_pcp_request()\" check below includes:\n         * 1. Sending
      the first request\n         * 2. Retransmitting requests due to packet loss\n
      \        * 3. Resending a request due to impending lease expiration\n         *
      4. Resending a request due to server state loss\n         */\n        if (time_to_send_pcp_request())\n
      \           pcp_send_map_request(internal_sockaddr.sin_port,\n                internal_sockaddr.sin_addr,\n
      \               &external_sockaddr, /* will be zero the first time */\n                requested_lifetime,
      &assigned_lifetime);\n        if (pcp_response_received())\n            update_rendezvous_server(\"Client
      Ident\", external_sockaddr);\n        if (received_incoming_connection_or_packet())\n
      \           process_it(s);\n        if (need_to_make_outgoing_connection())\n
      \           make_outgoing_connection(s, ...);\n        if (data_to_send())\n
      \           send_it(s);\n        if (other_work_to_do())\n            do_it();\n
      \       /* ... */\n        block_until_we_need_to_do_something_else();\n        }\n
      \             Figure 7: Pseudocode for Using PCP to Operate a\n                          Symmetric
      Client/Server\n"
    title: 10.2.  For Operating a Symmetric Client/Server
  - contents:
    - "10.3.  For Reducing NAT or Firewall Keepalive Messages\n   A host operating
      a client (e.g., XMPP client, SIP client) sends from\n   a port, and may receive
      responses, but never accepts incoming\n   connections from other remote peers
      on this port.  It wants to ensure\n   that the flow to its remote peer is not
      terminated (due to\n   inactivity) by an on-path NAT or firewall.  To accomplish
      this, the\n   application uses the procedure described in this section.\n   Middleboxes,
      such as NATs or firewalls, generally need to see\n   occasional traffic or they
      will terminate their session state,\n   causing application failures.  To avoid
      this, many applications\n   routinely generate keepalive traffic for the primary
      (or sole)\n   purpose of maintaining state with such middleboxes.  Applications
      can\n   reduce such application keepalive traffic by using PCP.\n      Note:
      For reasons beyond NAT, an application may find it useful to\n      perform
      application-level keepalives, such as to detect a broken\n      path between
      the client and server, keep state alive on the remote\n      peer, or detect
      a powered-down client.  These keepalives are not\n      related to maintaining
      middlebox state, and PCP cannot do anything\n      useful to reduce those keepalives.\n
      \  To use PCP for this function, the application first connects to its\n   server,
      as normal.  Afterwards, it issues a PCP request with the PEER\n   Opcode as
      described in Section 12 to learn and/or extend the lifetime\n   of its mapping.\n
      \  The following pseudocode shows how PCP can be reliably used with a\n   dynamic
      socket, for the purposes of reducing application keepalive\n   messages:\n    /*
      make outgoing connection to server */\n    int s = socket(...);\n    connect(s,
      &remote_peer, ...);\n    getsockname(s, &internal_sockaddr, ...);\n    bzero(&external_sockaddr,
      sizeof(external_sockaddr));\n    while (1)\n        {\n        /* Note: The
      \"time_to_send_pcp_request()\" check below includes:\n         * 1. Sending
      the first request\n         * 2. Retransmitting requests due to packet loss\n
      \        * 3. Resending a request due to impending lease expiration\n         *
      4. Resending a request due to server state loss\n         */\n        if (time_to_send_pcp_request())\n
      \           pcp_send_peer_request(internal_sockaddr.sin_port,\n                internal_sockaddr.sin_addr,\n
      \               &external_sockaddr, /* will be zero the first time */\n                remote_peer,
      requested_lifetime, &assigned_lifetime);\n        if (data_to_send())\n            send_it(s);\n
      \       if (received_incoming_data())\n            process_it(s);\n        if
      (other_work_to_do())\n            do_it();\n        /* ... */\n        block_until_we_need_to_do_something_else();\n
      \       }\n           Figure 8: Pseudocode Using PCP with a Dynamic Socket\n"
    title: 10.3.  For Reducing NAT or Firewall Keepalive Messages
  - contents:
    - "10.4.  For Restoring Lost Implicit TCP Dynamic Mapping State\n   After a NAT
      loses state (e.g., because of a crash or power failure),\n   it is useful for
      clients to re-establish TCP mappings on the NAT.\n   This allows servers on
      the Internet to see traffic from the same IP\n   address and port, so that sessions
      can be resumed exactly where they\n   were left off.  This can be useful for
      long-lived connections\n   (e.g., instant messaging) or for connections transferring
      a lot of\n   data (e.g., FTP).  This can be accomplished by first establishing
      a\n   TCP connection normally and then sending a PEER request/response and\n
      \  remembering the external address and external port.  Later, when the\n   NAT
      has lost state, the client can send a PEER request with the\n   suggested external
      port and suggested external address remembered\n   from the previous session,
      which will create a mapping in the NAT\n   that functions exactly as an implicit
      dynamic mapping.  The client\n   then resumes sending TCP data to the server.\n
      \     Note: This procedure works well for TCP, provided:\n         (i) the NAT
      creates a new implicit dynamic outbound mapping\n         only for outbound
      TCP segments with the SYN bit set (i.e., the\n         newly booted NAT silently
      drops outbound data segments from the\n         client when the NAT does not
      have an active mapping for those\n         segments), and\n         (ii) the
      newly booted NAT does not send a TCP RST in response\n         to receiving
      unexpected inbound TCP segments.\n      This procedure works less well for UDP,
      because as soon as\n      outbound UDP traffic is seen by the NAT, a new UDP
      implicit\n      dynamic outbound mapping will be created (probably on a different\n
      \     port).\n"
    title: 10.4.  For Restoring Lost Implicit TCP Dynamic Mapping State
  title: 10.  Introduction to MAP and PEER Opcodes
- contents:
  - "11.  MAP Opcode\n   This section defines an Opcode that controls inbound forwarding
    from\n   a NAT (or firewall) to an internal host.\n   MAP:  Create an explicit
    dynamic mapping between an Internal Address\n           + Port and an External
    Address + Port.\n   PCP servers SHOULD provide a configuration option to allow\n
    \  administrators to disable MAP support if they wish.\n   Mappings created by
    PCP MAP requests are, by definition, endpoint-\n   independent mappings (EIMs)
    with endpoint-independent filtering (EIF)\n   (unless the FILTER option is used),
    even on a NAT that usually\n   creates endpoint-dependent mapping (EDM) or endpoint-dependent\n
    \  filtering (EDF) for outgoing connections, since the purpose of an\n   (unfiltered)
    MAP mapping is to receive inbound traffic from any\n   remote endpoint, not from
    only one specific remote endpoint.\n   Note also that all NAT mappings (created
    by PCP or otherwise) are by\n   necessity bidirectional and symmetric.  For any
    packet going in one\n   direction (in or out) that is translated by the NAT, a
    reply going in\n   the opposite direction needs to have the corresponding opposite\n
    \  translation done so that the reply arrives at the right endpoint.\n   This
    means that if a client creates a MAP mapping, and then later\n   sends an outgoing
    packet using the mapping's internal address,\n   protocol, and port, the NAT should
    translate that packet's internal\n   address and port to the mapping's external
    address and port, so that\n   replies addressed to the external address and port
    are correctly\n   translated back to the mapping's internal address and port.\n
    \  On operating systems that allow multiple listening servers to bind to\n   the
    same internal address, protocol, and port, servers MUST ensure\n   that they have
    exclusive use of that internal address, protocol, and\n   port (e.g., by binding
    the port using INADDR_ANY, or using\n   SO_EXCLUSIVEADDRUSE or similar) before
    sending their PCP MAP request,\n   to ensure that no other PCP clients on the
    same machine are also\n   listening on the same internal protocol and internal
    port.\n   As a side effect of creating a mapping, ICMP messages associated with\n
    \  the mapping MUST be forwarded (and also translated, if appropriate)\n   for
    the duration of the mapping's lifetime.  This is done to ensure\n   that ICMP
    messages can still be used by hosts, without application\n   programmers or PCP
    client implementations needing to use PCP\n   separately to create ICMP mappings
    for those flows.\n   The operation of the MAP Opcode is described in this section.\n"
  - contents:
    - "11.1.  MAP Operation Packet Formats\n   The MAP Opcode has a similar packet
      layout for both requests and\n   responses.  If the assigned external IP address
      and port in the PCP\n   response always match the internal IP address and port
      from the PCP\n   request, then the functionality is purely a firewall; otherwise,
      the\n   functionality is a Network Address Translator that might also perform\n
      \  firewall-like functions.\n   The following diagram shows the format of the
      Opcode-specific\n   information in a request for the MAP Opcode.\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                Mapping Nonce (96 bits)                       |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \  Protocol    |          Reserved (24 bits)                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Internal Port          |    Suggested External Port    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \          Suggested External IP Address (128 bits)            |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      Figure 9: MAP Opcode Request\n   These fields are described
      below:\n   Requested lifetime (in common header):  Requested lifetime of this\n
      \     mapping, in seconds.  The value 0 indicates \"delete\".\n   Mapping Nonce:
      \ Random value chosen by the PCP client.  See\n      Section 11.2, \"Generating
      a MAP Request\".  Zero is a legal value\n      (but unlikely, occurring in roughly
      one in 2^96 requests).\n   Protocol:  Upper-layer protocol associated with this
      Opcode.  Values\n      are taken from the IANA protocol registry [proto_numbers].
      \ For\n      example, this field contains 6 (TCP) if the Opcode is intended
      to\n      create a TCP mapping.  This field contains 17 (UDP) if the Opcode\n
      \     is intended to create a UDP mapping.  The value 0 has a special\n      meaning
      for 'all protocols'.\n   Reserved:  24 reserved bits, MUST be sent as 0 and
      MUST be ignored\n      when received.\n   Internal Port:  Internal port for
      the mapping.  The value 0 indicates\n      'all ports', and is legal when the
      lifetime is zero (a delete\n      request), if the protocol does not use 16-bit
      port numbers, or the\n      client is requesting 'all ports'.  If the protocol
      is zero\n      (meaning 'all protocols'), then internal port MUST be zero on\n
      \     transmission and MUST be ignored on reception.\n   Suggested External
      Port:  Suggested external port for the mapping.\n      This is useful for refreshing
      a mapping, especially after the PCP\n      server loses state.  If the PCP client
      does not know the external\n      port, or does not have a preference, it MUST
      use 0.\n   Suggested External IP Address:  Suggested external IPv4 or IPv6\n
      \     address.  This is useful for refreshing a mapping, especially\n      after
      the PCP server loses state.  If the PCP client does not know\n      the external
      address, or does not have a preference, it MUST use\n      the address-family-specific
      all-zeros address (see Section 5).\n   The internal address for the request
      is the source IP address of the\n   PCP request message itself, unless the THIRD_PARTY
      option is used.\n   The following diagram shows the format of Opcode-specific
      information\n   in a response packet for the MAP Opcode:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                Mapping Nonce (96 bits)                       |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \  Protocol    |          Reserved (24 bits)                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Internal Port          |    Assigned External Port     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \           Assigned External IP Address (128 bits)            |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                     Figure 10: MAP Opcode Response\n   These fields are described
      below:\n   Lifetime (in common header):  On an error response, this indicates\n
      \     how long clients should assume they'll get the same error response\n      from
      the PCP server if they repeat the same request.  On a success\n      response,
      this indicates the lifetime for this mapping, in\n      seconds.\n   Mapping
      Nonce:  Copied from the request.\n   Protocol:  Copied from the request.\n   Reserved:
      \ 24 reserved bits, MUST be sent as 0 and MUST be ignored\n      when received.\n
      \  Internal Port:  Copied from the request.\n   Assigned External Port:  On
      a success response, this is the assigned\n      external port for the mapping.
      \ On an error response, the\n      suggested external port is copied from the
      request.\n   Assigned External IP Address:  On a success response, this is the\n
      \     assigned external IPv4 or IPv6 address for the mapping.  An IPv4\n      address
      is encoded using IPv4-mapped IPv6 address.  On an error\n      response, the
      suggested external IP address is copied from the\n      request.\n"
    title: 11.1.  MAP Operation Packet Formats
  - contents:
    - "11.2.  Generating a MAP Request\n   This section describes the operation of
      a PCP client when sending\n   requests with the MAP Opcode.\n   The request
      MAY contain values in the Suggested External Port and\n   Suggested External
      IP Address fields.  This allows the PCP client to\n   attempt to rebuild lost
      state on the PCP server, which improves the\n   chances of existing connections
      surviving, and helps the PCP client\n   avoid having to change information maintained
      at its rendezvous\n   server.  Of course, due to other activity on the network
      (e.g., by\n   other users or network renumbering), the PCP server may not be
      able\n   to grant the suggested external IP address, protocol, and port, and\n
      \  in that case it will assign a different external IP address and port.\n   A
      PCP client MUST be written assuming that it may *never* be assigned\n   the
      external port it suggests.  In the case of recreating state after\n   a NAT
      gateway crash, the suggested external port, being one that was\n   previously
      allocated to this client, is likely to be available for\n   this client to continue
      using.  In all other cases, the client MUST\n   assume that it is unlikely that
      its suggested external port will be\n   granted.  For example, when many subscribers
      are sharing a Carrier-\n   Grade NAT, popular ports such as 80, 443, and 8080
      are likely to be\n   in high demand.  At most one client can have each of those
      popular\n   ports for each external IP address, and all the other clients will
      be\n   assigned other, dynamically allocated, external ports.  Indeed, some\n
      \  ISPs may, by policy, choose not to grant those external ports to\n   *anyone*,
      so that none of their clients are *ever* assigned external\n   ports 80, 443,
      or 8080.\n   If the protocol does not use 16-bit port numbers (e.g., RSVP, IP\n
      \  protocol number 46), the port number MUST be zero.  This will cause\n   all
      traffic matching that protocol to be mapped.\n   If the client wants all protocols
      mapped, it uses protocol 0 (zero)\n   and internal port 0 (zero).\n   The Mapping
      Nonce value is randomly chosen by the PCP client,\n   following accepted practices
      for generating unguessable random\n   numbers [RFC4086], and is used as part
      of the validation of PCP\n   responses (see below) by the PCP client, and validation
      for mapping\n   refreshes by the PCP server.  The client MUST use a different
      mapping\n   nonce for each PCP server it communicates with, and it is RECOMMENDED\n
      \  to choose a new random mapping nonce whenever the PCP client is\n   initialized.
      \ The client MAY use a different mapping nonce for every\n   mapping.\n"
    - contents:
      - "11.2.1.  Renewing a Mapping\n   An existing mapping SHOULD have its lifetime
        extended by the PCP\n   client for as long as the client wishes to have that
        mapping continue\n   to exist.  To do this, the PCP client sends a new MAP
        request\n   indicating the internal port.  The PCP MAP request SHOULD also\n
        \  include the currently assigned external IP address and port in the\n   Suggested
        External IP Address and Suggested External Port fields, so\n   if the PCP
        server has lost state it can recreate the lost mapping\n   with the same parameters.\n
        \  The PCP client SHOULD renew the mapping before its expiry time;\n   otherwise,
        it will be removed by the PCP server (see Section 15,\n   \"Mapping Lifetime
        and Deletion\").  To reduce the risk of inadvertent\n   synchronization of
        renewal requests, a random jitter component should\n   be included.  It is
        RECOMMENDED that PCP clients send a single\n   renewal request packet at a
        time chosen with uniform random\n   distribution in the range 1/2 to 5/8 of
        expiration time.  If no\n   SUCCESS response is received, then the next renewal
        request should be\n   sent 3/4 to 3/4 + 1/16 to expiration, and then another
        7/8 to 7/8 +\n   1/32 to expiration, and so on, subject to the constraint
        that renewal\n   requests MUST NOT be sent less than four seconds apart (a
        PCP client\n   MUST NOT send a flood of ever-closer-together requests in the
        last\n   few seconds before a mapping expires).\n"
      title: 11.2.1.  Renewing a Mapping
    title: 11.2.  Generating a MAP Request
  - contents:
    - "11.3.  Processing a MAP Request\n   This section describes the operation of
      a PCP server when processing\n   a request with the MAP Opcode.  Processing
      SHOULD be performed in the\n   order of the following paragraphs.\n   The Protocol,
      Internal Port, and Mapping Nonce fields from the MAP\n   request are copied
      into the MAP response.  The THIRD_PARTY option, if\n   present, and processed
      by the PCP server, is also copied into the MAP\n   response.\n   If the requested
      lifetime is non-zero, then:\n   o  If both the protocol and internal port are
      non-zero, it indicates\n      a request to create a mapping or extend the lifetime
      of an\n      existing mapping.  If the PCP server or PCP-controlled device does\n
      \     not support the protocol, the UNSUPP_PROTOCOL error MUST be\n      returned.\n
      \  o  If the protocol is non-zero and the internal port is zero, it\n      indicates
      a request to create or extend a mapping for all incoming\n      traffic for
      that entire protocol -- a 'wildcard' (all-ports)\n      mapping for that protocol.
      \ If this request cannot be fulfilled in\n      its entirety, the UNSUPP_PROTOCOL
      error MUST be returned.\n   o  If both the protocol and internal port are zero,
      it indicates a\n      request to create or extend a mapping for all incoming
      traffic for\n      all protocols (commonly called a 'DMZ host').  If this request\n
      \     cannot be fulfilled in its entirety, the UNSUPP_PROTOCOL error\n      MUST
      be returned.\n   o  If the protocol is zero and the internal port is non-zero,
      then\n      the request is invalid and the PCP server MUST return a\n      MALFORMED_REQUEST
      error to the client.\n   If the requested lifetime is zero, it indicates a request
      to delete\n   an existing mapping.\n   Further processing of the lifetime is
      described in Section 15,\n   \"Mapping Lifetime and Deletion\".\n   If operating
      in the Simple Threat Model (Section 18.1), and the\n   internal port, protocol,
      and internal address match an existing\n   explicit dynamic mapping, but the
      mapping nonce does not match, the\n   request MUST be rejected with a NOT_AUTHORIZED
      error with the\n   lifetime of the error indicating duration of that existing
      mapping.\n   The PCP server only needs to remember one Mapping Nonce value for\n
      \  each explicit dynamic mapping.  This specification makes no statement\n   about
      mapping nonce with the Advanced Threat Model.\n   If the internal port, protocol,
      and internal address match an\n   existing static mapping (which will have no
      nonce), then a PCP reply\n   is sent giving the external address and port of
      that static mapping,\n   using the nonce from the PCP request.  The server does
      not record the\n   nonce.\n   If an option with value less than 128 exists (i.e.,
      mandatory to\n   process) but that option does not make sense (e.g., the\n   PREFER_FAILURE
      option is included in a request with lifetime=0), the\n   request is invalid
      and generates a MALFORMED_OPTION error.\n   If the PCP-controlled device is
      stateless (that is, it does not\n   establish any per-flow state, and simply
      rewrites the address and/or\n   port in a purely algorithmic fashion, including
      no rewriting), the\n   PCP server simply returns an answer indicating the external
      IP\n   address and port yielded by this stateless algorithmic translation.\n
      \  This allows the PCP client to learn its external IP address and port\n   as
      seen by remote peers.  Examples of stateless translators include\n   stateless
      NAT64, 1:1 NAT44, and NPTv6 [RFC6296], all of which modify\n   addresses but
      not port numbers, and pure firewalls, which modify\n   neither the address nor
      the port.\n   It is possible that a mapping might already exist for a requested\n
      \  internal address, protocol, and port.  If so, the PCP server takes\n   the
      following actions:\n   1.  If the MAP request contains the PREFER_FAILURE option,
      but the\n       suggested external address and port do not match the external\n
      \      address and port of the existing mapping, the PCP server MUST\n       return
      CANNOT_PROVIDE_EXTERNAL.\n   2.  If the existing mapping is static (created
      outside of PCP), the\n       PCP server MUST return the external address and
      port of the\n       existing mapping in its response and SHOULD indicate a lifetime\n
      \      of 2^32-1 seconds, regardless of the suggested external address\n       and
      port in the request.\n   3.  If the existing mapping is explicit dynamic inbound
      (created by a\n       previous MAP request), the PCP server MUST return the
      existing\n       external address and port in its response, regardless of the\n
      \      suggested external address and port in the request.\n       Additionally,
      the PCP server MUST update the lifetime of the\n       existing mapping, in
      accordance with Section 15, \"Mapping\n       Lifetime and Deletion\".\n   4.
      \ If the existing mapping is dynamic outbound (created by outgoing\n       traffic
      or a previous PEER request), the PCP server SHOULD create\n       a new explicit
      inbound mapping, replicating the ports and\n       addresses from the outbound
      mapping (but the outbound mapping\n       continues to exist, and remains in
      effect if the explicit inbound\n       mapping is later deleted).\n   If no
      mapping exists for the internal address, protocol, and port,\n   and the PCP
      server is able to create a mapping using the suggested\n   external address
      and port, it SHOULD do so.  This is beneficial for\n   re-establishing state
      lost in the PCP server (e.g., due to a reboot).\n   There are, however, cases
      where the PCP server is not able to create\n   a new mapping using the suggested
      external address and port:\n   o  The suggested external address, protocol,
      and port is already\n      assigned to another existing explicit or implicit
      mapping\n      (i.e., is already forwarding traffic to some other internal\n
      \     address and port).\n   o  The suggested external address, protocol, and
      port is already used\n      by the NAT gateway for one of its own services,
      for example, TCP\n      port 80 for the NAT gateway's own configuration web
      pages, or UDP\n      ports 5350 and 5351, used by PCP itself.  A PCP server
      MUST NOT\n      create client mappings for external UDP ports 5350 or 5351.\n
      \  o  The suggested external address, protocol, and port is otherwise\n      prohibited
      by the PCP server's policy.\n   o  The suggested external IP address, protocol,
      or suggested port are\n      invalid or invalid combinations (e.g., external
      address 127.0.0.1,\n      ::1, a multicast address, or the suggested port is
      not valid for\n      the protocol).\n   o  The suggested external address does
      not belong to the NAT gateway.\n   o  The suggested external address is not
      configured to be used as an\n      external address of the firewall or NAT gateway.\n
      \  If the PCP server cannot assign the suggested external address,\n   protocol,
      and port, then:\n   o  If the request contained the PREFER_FAILURE option, then
      the PCP\n      server MUST return CANNOT_PROVIDE_EXTERNAL.\n   o  If the request
      did not contain the PREFER_FAILURE option, and the\n      PCP server can assign
      some other external address and port for\n      that protocol, then the PCP
      server MUST do so and return the newly\n      assigned external address and
      port in the response.  In no case is\n      the client penalized for a 'poor'
      choice of suggested external\n      address and port.  The suggested external
      address and port may be\n      used by the server to guide its choice of what
      external address\n      and port to assign, but in no case do they cause the
      server to\n      fail to allocate an external address and port where otherwise
      it\n      would have succeeded.  The presence of a non-zero suggested\n      external
      address or port is merely a hint; it never does any harm.\n   A PCP-controlled
      device MUST NOT create mappings for a protocol not\n   indicated in the request.
      \ For example, if the request was for a TCP\n   mapping, an additional corresponding
      UDP mapping MUST NOT be\n   automatically created.\n   Mappings typically consume
      state on the PCP-controlled device, and it\n   is RECOMMENDED that a per-host
      and/or per-subscriber limit be\n   enforced by the PCP server to prevent exhausting
      the mapping state.\n   If this limit is exceeded, the result code USER_EX_QUOTA
      is returned.\n   If all of the preceding operations were successful (did not
      generate\n   an error response), then the requested mapping is created or\n
      \  refreshed as described in the request and a SUCCESS response is\n   built.\n"
    title: 11.3.  Processing a MAP Request
  - contents:
    - "11.4.  Processing a MAP Response\n   This section describes the operation of
      the PCP client when it\n   receives a PCP response for the MAP Opcode.\n   After
      performing common PCP response processing, the response is\n   further matched
      with a previously sent MAP request by comparing the\n   internal IP address
      (the destination IP address of the PCP response,\n   or other IP address specified
      via the THIRD_PARTY option), the\n   protocol, the internal port, and the mapping
      nonce.  Other fields are\n   not compared, because the PCP server sets those
      fields.  The PCP\n   server will send a Mapping Update (Section 14.2) if the
      mapping\n   changes (e.g., due to IP renumbering).\n   If the result code is
      NO_RESOURCES and the request was for the\n   creation or renewal of a mapping,
      then the PCP client SHOULD NOT send\n   further requests for any new mappings
      to that PCP server for the\n   (limited) value of the lifetime.  If the result
      code is NO_RESOURCES\n   and the request was for the deletion of a mapping,
      then the PCP\n   client SHOULD NOT send further requests of *any kind* to that
      PCP\n   server for the (limited) value of the lifetime.\n   On a success response,
      the PCP client can use the external IP address\n   and port as needed.  Typically,
      the PCP client will communicate the\n   external IP address and port to another
      host on the Internet using an\n   application-specific rendezvous mechanism
      such as DNS SRV records.\n   After a success response, for as long as renewal
      is desired, the PCP\n   client MUST set a timer or otherwise schedule an event
      to renew the\n   mapping before its lifetime expires.  Renewing a mapping is
      performed\n   by sending another MAP request, exactly as described in Section
      11.2,\n   except that the suggested external address and port SHOULD be set
      to\n   the values received in the response.  From the PCP server's point of\n
      \  view a MAP request to renew a mapping is identical to a MAP request\n   to
      create a new mapping, and is handled identically.  Indeed, in the\n   event
      of PCP server state loss, a renewal request from a PCP client\n   will appear
      to the server to be a request to create a new mapping,\n   with a particular
      suggested external address and port, which happen\n   to be what the PCP server
      previously assigned.  See also\n   Section 16.3.1, \"Recreating Mappings\".\n
      \  On an error response, the client SHOULD NOT repeat the same request\n   to
      the same PCP server within the lifetime returned in the response.\n"
    title: 11.4.  Processing a MAP Response
  - contents:
    - "11.5.  Address Change Events\n   A customer premises router might obtain a
      new external IP address,\n   for a variety of reasons including a reboot, power
      outage, DHCP lease\n   expiry, or other action by the ISP.  If this occurs,
      traffic\n   forwarded to a host's previous address might be delivered to another\n
      \  host that now has that address.  This affects all mapping types,\n   whether
      implicit or explicit.  This same problem already occurs today\n   when a host's
      IP address is reassigned, without PCP and without an\n   ISP-operated CGN.  The
      solution is the same as today: the problems\n   associated with host renumbering
      are caused by host renumbering, and\n   are eliminated if host renumbering is
      avoided.  PCP defined in this\n   document does not provide machinery to reduce
      the host renumbering\n   problem.\n   When an internal host changes its internal
      IP address (e.g., by\n   having a different address assigned by the DHCP server),
      the NAT (or\n   firewall) will continue to send traffic to the old IP address.\n
      \  Typically, the internal host will no longer receive traffic sent to\n   that
      old IP address.  Assuming the internal host wants to continue\n   receiving
      traffic, it needs to install new mappings for its new IP\n   address.  The Suggested
      External Port field will not be fulfilled by\n   the PCP server, in all likelihood,
      because it is still being\n   forwarded to the old IP address.  Thus, a mapping
      is likely to be\n   assigned a new external port number and/or external IP address.
      \ Note\n   that such host renumbering is not expected to happen routinely on
      a\n   regular basis for most hosts, since most hosts renew their DHCP\n   leases
      before they expire (or re-request the same address after\n   reboot) and most
      DHCP servers honor such requests and grant the host\n   the same address it
      was previously using before the reboot.\n   A host might gain or lose interfaces
      while existing mappings are\n   active (e.g., Ethernet cable plugged in or removed,
      joining/leaving a\n   WiFi network).  Because of this, if the PCP client is
      sending a PCP\n   request to maintain state in the PCP server, it SHOULD ensure
      that\n   those PCP requests continue to use the same interface (e.g., when\n
      \  refreshing mappings).  If the PCP client is sending a PCP request to\n   create
      new state in the PCP server, it MAY use a different source\n   interface or
      different source address.\n"
    title: 11.5.  Address Change Events
  - contents:
    - "11.6.  Learning the External IP Address Alone\n   NAT-PMP [RFC6886] includes
      a mechanism to allow clients to learn the\n   external IP address alone, without
      also requesting a port mapping.\n   NAT-PMP was designed for residential NAT
      gateways, where such an\n   operation makes sense because a typical residential
      NAT gateway has\n   only one external IP address.  PCP has broader scope, and
      also\n   supports Carrier-Grade NATs (CGNs) that may have a pool of external\n
      \  IP addresses, not just one.  A client may not be assigned any\n   particular
      external IP address from that pool until it has at least\n   one implicit, explicit,
      or static port mapping, and even then only\n   for as long as that mapping remains
      valid.  Client software that just\n   wishes to display the user's external
      IP address for cosmetic\n   purposes can achieve that by requesting a short-lived
      mapping (e.g.,\n   to the Discard service (TCP/9 or UDP/9) or some other port)
      and then\n   displaying the resulting external IP address.  However, once that\n
      \  mapping expires a subsequent implicit or explicit dynamic mapping\n   might
      be mapped to a different external IP address.\n"
    title: 11.6.  Learning the External IP Address Alone
  title: 11.  MAP Opcode
- contents:
  - "12.  PEER Opcode\n   This section defines an Opcode for controlling dynamic outbound\n
    \  mappings.\n   PEER: Create a new dynamic outbound mapping to a remote peer's
    IP\n         address and port, or extend the lifetime of an existing\n         outbound
    mapping.\n   The use of this Opcodes is described in this section.\n   PCP servers
    SHOULD provide a configuration option to allow\n   administrators to disable PEER
    support if they wish.\n   Because a mapping created or managed by PEER behaves
    almost exactly\n   like an implicit dynamic outbound mapping created as a side
    effect of\n   a packet (e.g., TCP SYN) sent by the host, mappings created or\n
    \  managed using PCP PEER requests may be endpoint-independent mapping\n   (EIM)
    or endpoint-dependent mapping (EDM), with endpoint-independent\n   filtering (EIF)
    or endpoint-dependent filtering (EDF), consistent\n   with the existing behavior
    of the NAT gateway or firewall in question\n   for implicit outbound mappings
    it creates automatically as a result\n   of observing outgoing traffic from internal
    hosts.\n"
  - contents:
    - "12.1.  PEER Operation Packet Formats\n   The PEER Opcode allows a PCP client
      to create a new explicit dynamic\n   outbound mapping (which functions similarly
      to an outbound mapping\n   created implicitly when a host sends an outbound
      TCP SYN) or to\n   extend the lifetime of an existing outbound mapping.\n   The
      following diagram shows the Opcode layout for the PEER Opcode.\n   The formats
      for the PEER request and response packets are aligned so\n   that related fields
      fall at the same offsets in the packet.\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                Mapping Nonce (96 bits)                       |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \  Protocol    |          Reserved (24 bits)                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Internal Port          |    Suggested External Port    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \          Suggested External IP Address (128 bits)            |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       Remote Peer Port        |     Reserved (16 bits)        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \              Remote Peer IP Address (128 bits)               |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                     Figure 11: PEER Opcode Request\n   These fields are described
      below:\n   Requested Lifetime (in common header):  Requested lifetime of this\n
      \     mapping, in seconds.  Note that it is not possible to reduce the\n      lifetime
      of a mapping (or delete it, with requested lifetime=0)\n      using PEER.\n
      \  Mapping Nonce:  Random value chosen by the PCP client.  See\n      Section
      12.2, \"Generating a PEER Request\".  Zero is a legal value\n      (but unlikely,
      occurring in roughly one in 2^96 requests).\n   Protocol:  Upper-layer protocol
      associated with this Opcode.  Values\n      are taken from the IANA protocol
      registry [proto_numbers].  For\n      example, this field contains 6 (TCP) if
      the Opcode is describing a\n      TCP mapping.  This field contains 17 (UDP)
      if the Opcode is\n      describing a UDP mapping.  Protocol MUST NOT be zero.\n
      \  Reserved:  24 reserved bits, MUST be set to 0 on transmission and\n      MUST
      be ignored on reception.\n   Internal Port:  Internal port for the mapping.
      \ Internal port MUST\n      NOT be zero.\n   Suggested External Port:  Suggested
      external port for the mapping.\n      If the PCP client does not know the external
      port, or does not\n      have a preference, it MUST use 0.\n   Suggested External
      IP Address:  Suggested external IP address for the\n      mapping.  If the PCP
      client does not know the external address, or\n      does not have a preference,
      it MUST use the address-family-\n      specific all-zeros address (see Section
      5).\n   Remote Peer Port:  Remote peer's port for the mapping.  Remote peer\n
      \     port MUST NOT be zero.\n   Reserved:  16 reserved bits, MUST be set to
      0 on transmission and\n      MUST be ignored on reception.\n   Remote Peer IP
      Address:  Remote peer's IP address.  This is from the\n      perspective of
      the PCP client, so that the PCP client does not\n      need to concern itself
      with NAT64 or NAT46 (which both cause the\n      client's idea of the remote
      peer's IP address to differ from the\n      remote peer's actual IP address).
      \ This field allows the PCP\n      client and PCP server to disambiguate multiple
      connections from\n      the same port on the internal host to different servers.
      \ An IPv6\n      address is represented directly, and an IPv4 address is\n      represented
      using the IPv4-mapped address syntax (Section 5).\n   When attempting to re-create
      a lost mapping, the suggested external\n   IP address and port are set to the
      External IP Address and Port\n   fields received in a previous PEER response
      from the PCP server.  On\n   an initial PEER request, the external IP address
      and port are set to\n   zero.\n   Note that semantics similar to the PREFER_FAILURE
      option are\n   automatically implied by PEER requests.  If the Suggested External
      IP\n   Address or Suggested External Port fields are non-zero, and the PCP\n
      \  server is unable to honor the suggested external IP address,\n   protocol,
      or port, then the PCP server MUST return a\n   CANNOT_PROVIDE_EXTERNAL error
      response.  The PREFER_FAILURE option is\n   neither required nor allowed in
      PEER requests, and if a PCP server\n   receives a PEER request containing the
      PREFER_FAILURE option it MUST\n   return a MALFORMED_REQUEST error response.\n
      \  The following diagram shows the Opcode response for the PEER Opcode:\n      0
      \                  1                   2                   3\n      0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                Mapping Nonce (96 bits)                       |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \  Protocol    |          Reserved (24 bits)                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Internal Port          |    Assigned External Port     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \           Assigned External IP Address (128 bits)            |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       Remote Peer Port        |     Reserved (16 bits)        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \              Remote Peer IP Address (128 bits)               |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                     Figure 12: PEER Opcode Response\n   Lifetime (in common
      header):  On a success response, this indicates\n      the lifetime for this
      mapping, in seconds.  On an error response,\n      this indicates how long clients
      should assume they'll get the same\n      error response from the PCP server
      if they repeat the same\n      request.\n   Mapping Nonce:  Copied from the
      request.\n   Protocol:  Copied from the request.\n   Reserved:  24 reserved
      bits, MUST be set to 0 on transmission, MUST\n      be ignored on reception.\n
      \  Internal Port:  Copied from request.\n   Assigned External Port:  On a success
      response, this is the assigned\n      external port for the mapping.  On an
      error response, the\n      suggested external port is copied from the request.\n
      \  Assigned External IP Address:  On a success response, this is the\n      assigned
      external IPv4 or IPv6 address for the mapping.  On an\n      error response,
      the suggested external IP address is copied from\n      the request.\n   Remote
      Peer Port:  Copied from request.\n   Reserved:  16 reserved bits, MUST be set
      to 0 on transmission, MUST\n      be ignored on reception.\n   Remote Peer IP
      Address:  Copied from the request.\n"
    title: 12.1.  PEER Operation Packet Formats
  - contents:
    - "12.2.  Generating a PEER Request\n   This section describes the operation of
      a client when generating a\n   message with the PEER Opcode.\n   The PEER Opcode
      MAY be sent before or after establishing\n   bidirectional communication with
      the remote peer.\n   If sent before, this is considered a PEER-created mapping
      that\n   creates a new dynamic outbound mapping in the PCP-controlled device.\n
      \  If sent after, this allows the PCP client to learn the IP address,\n   port,
      and lifetime of the assigned external address and port for the\n   existing
      implicit dynamic outbound mapping, and potentially to extend\n   this lifetime
      (for reducing NAT or firewall keepalive messages, as\n   described in Section
      10.3).\n   PEER requests are also useful for restoring mappings after a NAT
      has\n   lost its mapping state (e.g., due to a crash).\n   The Mapping Nonce
      value is randomly chosen by the PCP client,\n   following accepted practices
      for generating unguessable random\n   numbers [RFC4086], and is used as part
      of the validation of PCP\n   responses (see below) by the PCP client, and validation
      for mapping\n   refreshes by the PCP server.  The client MUST use a different
      mapping\n   nonce for each PCP server it communicates with, and it is RECOMMENDED\n
      \  to choose a new random mapping nonce whenever the PCP client is\n   initialized.
      \ The client MAY use a different mapping nonce for every\n   mapping.\n   The
      PEER Opcode contains a Remote Peer Address field, which is always\n   from the
      perspective of the PCP client.  Note that when the\n   PCP-controlled device
      is performing address family translation (NAT46\n   or NAT64), the remote peer
      address from the perspective of the PCP\n   client is different from the remote
      peer address on the other side of\n   the address family translation device.\n"
    title: 12.2.  Generating a PEER Request
  - contents:
    - "12.3.  Processing a PEER Request\n   This section describes the operation of
      a server when receiving a\n   request with the PEER Opcode.  Processing SHOULD
      be performed in the\n   order of the following paragraphs.\n   The following
      fields from a PEER request are copied into the\n   response: Protocol, Internal
      Port, Remote Peer IP Address, Remote\n   Peer Port, and Mapping Nonce.\n   When
      an implicit dynamic mapping is created, some NATs and firewalls\n   validate
      destination addresses and will not create an implicit\n   dynamic mapping if
      the destination address is invalid (e.g.,\n   127.0.0.1).  If a PCP-controlled
      device does such validation for\n   implicit dynamic mappings, it SHOULD also
      do a similar validation of\n   the remote peer IP address, protocol, and port
      for PEER-created\n   explicit dynamic mappings.  If the validation determines
      the remote\n   peer IP address of a PEER request is invalid, then no mapping
      is\n   created, and a MALFORMED_REQUEST error result is returned.\n   On receiving
      the PEER Opcode, the PCP server examines the mapping\n   table for a matching
      five-tuple { Protocol, Internal Address,\n   Internal Port, Remote Peer Address,
      Remote Peer Port }.\n   If no matching mapping is found, and the suggested external
      address\n   and port are either zero or can be honored for the specified\n   Protocol,
      a new mapping is created.  By having the PEER create such a\n   mapping, we
      avoid a race condition between the PEER request and the\n   initial outgoing
      packet arriving at the NAT or firewall device first,\n   and allow PEER to be
      used to recreate a lost outbound dynamic mapping\n   (see Section 16.3.1, \"Recreating
      Mappings\").  Thereafter, this PEER-\n   created mapping is treated as if it
      was an implicit dynamic outbound\n   mapping (e.g., as if the PCP client sent
      a TCP SYN) and a lifetime\n   appropriate to such a mapping is returned (note:
      on many NATs and\n   firewalls, such mapping lifetimes are very short until
      bidirectional\n   traffic is seen by the NAT or firewall).\n   If no matching
      mapping is found, and the suggested external address\n   and port cannot be
      honored, then no new state is created, and the\n   error CANNOT_PROVIDE_EXTERNAL
      is returned.\n   If a matching mapping is found, and no previous PEER Opcode
      was\n   successfully processed for this mapping, then the Suggested External\n
      \  Address and Port values in the request are ignored, the lifetime of\n   that
      mapping is adjusted as described below, and information about\n   the existing
      mapping is returned.  This allows a client to explicitly\n   extend the lifetime
      of an existing mapping and/or to learn an\n   existing mapping's external address,
      port, and lifetime.  The mapping\n   nonce is remembered for this mapping.\n
      \  If operating in the Simple Threat Model (Section 18.1), and the\n   internal
      port, protocol, and internal address match a mapping that\n   already exists,
      but the mapping nonce does not match (that is, a\n   previous PEER request was
      processed), the request MUST be rejected\n   with a NOT_AUTHORIZED error with
      the lifetime of the error indicating\n   duration of that existing mapping.
      \ The PCP server only needs to\n   remember one Mapping Nonce value for each
      mapping.  This\n   specification makes no statement about mapping nonce with
      the\n   Advanced Threat Model.\n   Processing the Lifetime value of the PEER
      Opcode is described in\n   Section 15, \"Mapping Lifetime and Deletion\".  Sending
      a PEER request\n   with a very short requested lifetime can be used to query
      the\n   lifetime of an existing mapping.  So that PCP clients can reduce the\n
      \  frequency of their NAT and firewall keepalive messages, it is\n   RECOMMENDED
      that lifetimes of mappings created or lengthened with\n   PEER be longer than
      the lifetimes of implicitly created mappings.\n   If all of the preceding operations
      were successful (did not generate\n   an error response), then a SUCCESS response
      is generated, with the\n   Lifetime field containing the lifetime of the mapping.\n
      \  If a PEER-created or PEER-managed mapping is not renewed using PEER,\n   then
      it reverts to the NAT's usual behavior for implicit mappings.\n   For example,
      continued outbound traffic keeps the mapping alive, as\n   per the NAT or firewall
      device's existing policy.  A PEER-created or\n   PEER-managed mapping may be
      terminated at any time by action of the\n   TCP client or server (e.g., due
      to TCP FIN or TCP RST), as per the\n   NAT or firewall device's existing policy.\n"
    title: 12.3.  Processing a PEER Request
  - contents:
    - "12.4.  Processing a PEER Response\n   This section describes the operation
      of a client when processing a\n   response with the PEER Opcode.\n   After performing
      common PCP response processing, the response is\n   further matched with an
      outstanding PEER request by comparing the\n   internal IP address (the destination
      IP address of the PCP response,\n   or other IP address specified via the THIRD_PARTY
      option), the\n   protocol, the internal port, the remote peer address, the remote
      peer\n   port, and the mapping nonce.  Other fields are not compared, because\n
      \  the PCP server sets those fields to provide information about the\n   mapping
      created by the Opcode.  The PCP server will send a Mapping\n   Update (Section
      14.2) if the mapping changes (e.g., due to IP\n   renumbering).\n   If the result
      code is NO_RESOURCES and the request was for the\n   creation or renewal of
      a mapping, then the PCP client SHOULD NOT send\n   further requests for any
      new mappings to that PCP server for the\n   (limited) value of the lifetime.\n
      \  On a successful response, the application can use the assigned\n   Lifetime
      value to reduce its frequency of application keepalives for\n   that particular
      NAT mapping.  Of course, there may be other reasons,\n   specific to the application,
      to use more frequent application\n   keepalives.  For example, the PCP assigned
      lifetime could be one hour\n   but the application may want to maintain state
      on its server (e.g.,\n   \"busy\" / \"away\") more frequently than once an hour.
      \ If the response\n   indicates an unexpected IP address or port (e.g., due
      to IP\n   renumbering), the PCP client will want to re-establish its connection\n
      \  to its remote server.\n   If the PCP client wishes to keep this mapping alive
      beyond the\n   indicated lifetime, it MAY rely on continued inside-to-outside\n
      \  traffic to ensure that the mapping will continue to exist, or it MAY\n   issue
      a new PCP request prior to the expiration.  The recommended\n   timings for
      renewing PEER mappings are the same as for MAP mappings,\n   as described in
      Section 11.2.1.\n      Note: Implementations need to expect the PEER response
      may contain\n      an external IP address with a different family than the remote\n
      \     peer IP address, e.g., when NAT64 or NAT46 are being used.\n"
    title: 12.4.  Processing a PEER Response
  title: 12.  PEER Opcode
- contents:
  - "13.  Options for MAP and PEER Opcodes\n   This section describes options for
    the MAP and PEER Opcodes.  These\n   options MUST NOT appear with other Opcodes,
    unless permitted by those\n   other Opcodes.\n"
  - contents:
    - "13.1.  THIRD_PARTY Option for MAP and PEER Opcodes\n   This option is used
      when a PCP client wants to control a mapping to\n   an internal host other than
      itself.  This is used with both MAP and\n   PEER Opcodes.\n   Due to security
      concerns with the THIRD_PARTY option, this option\n   MUST NOT be implemented
      or used unless the network on which the PCP\n   messages are to be sent is fully
      trusted.  For example, if access\n   control lists (ACLs) are installed on the
      PCP client, PCP server, and\n   the network between them, so those ACLs allow
      only communications\n   from a trusted PCP client to the PCP server.\n   A management
      device would use this option to control a PCP server on\n   behalf of users.
      \ For example, a management device located in a\n   network operations center,
      which presents a user interface to end\n   users or to network operations staff,
      and issues PCP requests with\n   the THIRD_PARTY option to the appropriate PCP
      server.\n   The THIRD_PARTY option is formatted as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Option Code=1 |  Reserved     |   Option Length=16            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   |                Internal
      IP Address (128 bits)                 |\n   |                                                               |\n
      \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      Figure 13: THIRD_PARTY Option\n   The fields are described
      below:\n   Internal IP Address:  Internal IP address for this mapping.\n      Option
      Name: THIRD_PARTY\n      Number: 1\n      Purpose: Indicates the MAP or PEER
      request is for a host other\n      than the host sending the PCP option.\n      Valid
      for Opcodes: MAP, PEER\n      Length: 16 octets\n      May appear in: request.
      \ May appear in response only if it\n      appeared in the associated request.\n
      \     Maximum occurrences: 1\n   A THIRD_PARTY option MUST NOT contain the same
      address as the source\n   address of the packet.  This is because many PCP servers
      may not\n   implement the THIRD_PARTY option at all, and with those servers
      a\n   client redundantly using the THIRD_PARTY option to specify its own IP\n
      \  address would cause such mapping requests to fail where they would\n   otherwise
      have succeeded.  A PCP server receiving a THIRD_PARTY\n   option specifying
      the same address as the source address of the\n   packet MUST return a MALFORMED_REQUEST
      result code.\n   A PCP server MAY be configured to permit or to prohibit the
      use of\n   the THIRD_PARTY option.  If this option is permitted, properly\n
      \  authorized clients may perform these operations on behalf of other\n   hosts.
      \ If this option is prohibited, and a PCP server receives a PCP\n   MAP request
      with a THIRD_PARTY option, it MUST generate a\n   UNSUPP_OPTION response.\n
      \  It is RECOMMENDED that customer premises equipment implementing a PCP\n   server
      be configured to prohibit third-party mappings by default.\n   With this default,
      if a user wants to create a third-party mapping,\n   the user needs to interact
      out-of-band with their customer premises\n   router (e.g., using its HTTP administrative
      interface).\n   It is RECOMMENDED that service provider NAT and firewall devices\n
      \  implementing a PCP server be configured to permit the THIRD_PARTY\n   option,
      when sent by a properly authorized host.  If the packet\n   arrives from an
      unauthorized host, the PCP server MUST generate an\n   UNSUPP_OPTION error.\n
      \  Note that the THIRD_PARTY option is not needed for today's common\n   scenario
      of an ISP offering a single IP address to a customer who is\n   using NAT to
      share that address locally, since in this scenario all\n   the customer's hosts
      appear, from the point of view of the ISP, to be\n   a single host.\n   When
      a PCP client is using the THIRD_PARTY option to make and\n   maintain mappings
      on behalf of some other device, it may be\n   beneficial if, where possible,
      the PCP client verifies that the other\n   device is actually present and active
      on the network.  Otherwise, the\n   PCP client risks maintaining those mappings
      forever, long after the\n   device that required them has gone.  This would
      defeat the purpose of\n   PCP mappings having a finite lifetime so that they
      can be\n   automatically deleted after they are no longer needed.\n"
    title: 13.1.  THIRD_PARTY Option for MAP and PEER Opcodes
  - contents:
    - "13.2.  PREFER_FAILURE Option for MAP Opcode\n   This option is only used with
      the MAP Opcode.\n   This option indicates that if the PCP server is unable to
      map both\n   the suggested external port and suggested external address, the
      PCP\n   server should not create a mapping.  This differs from the behavior\n
      \  without this option, which is to create a mapping.\n   PREFER_FAILURE is
      never necessary for a PCP client to manage mappings\n   for itself, and its
      use causes additional work in the PCP client and\n   in the PCP server.  This
      option exists for interworking with non-PCP\n   mapping protocols that have
      different semantics than PCP (e.g., UPnP\n   IGDv1 interworking [PNP-IGD-PCP],
      where the semantics of UPnP IGDv1\n   only allow the UPnP IGDv1 client to dictate
      mapping a specific port),\n   or separate port allocation systems that allocate
      ports to a\n   subscriber (e.g., a subscriber-accessed web portal operated by
      the\n   same ISP that operates the PCP server).  A PCP server MAY support\n
      \  this option, if its designers wish to support such downstream devices\n   or
      separate port allocation systems.  PCP servers that are not\n   intended to
      interface with such systems are not required to support\n   this option.  PCP
      clients other than UPnP IGDv1 interworking clients\n   or other than a separate
      port allocation system SHOULD NOT use this\n   option because it results in
      inefficient operation, and they cannot\n   safely assume that all PCP servers
      will implement it.  It is\n   anticipated that this option will be deprecated
      in the future as more\n   clients adopt PCP natively and the need for this option
      declines.\n   The PREFER_FAILURE option is formatted as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Option Code=2 |  Reserved     |   Option Length=0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                    Figure 14: PREFER_FAILURE Option\n      Option Name: PREFER_FAILURE\n
      \     Number: 2\n      Purpose: indicates that the PCP server should not create
      an\n      alternative mapping if the suggested external port and address\n      cannot
      be mapped.\n      Valid for Opcodes: MAP\n      Length: 0\n      May appear
      in: request.  May appear in response only if it\n      appeared in the associated
      request.\n      Maximum occurrences: 1\n   The result code CANNOT_PROVIDE_EXTERNAL
      is returned if the suggested\n   external address, protocol, and port cannot
      be mapped.  This can\n   occur because the external port is already mapped to
      another host's\n   outbound dynamic mapping, an inbound dynamic mapping, a static\n
      \  mapping, or the same internal address, protocol, and port already\n   have
      an outbound dynamic mapping that is mapped to a different\n   external port
      than suggested.  This can also occur because the\n   external address is no
      longer available (e.g., due to renumbering).\n   The server MAY set the lifetime
      in the response to the remaining\n   lifetime of the conflicting mapping + TIME_WAIT
      [RFC0793], rounded up\n   to the next larger integer number of seconds.\n   If
      a PCP request contains the PREFER_FAILURE option and has zero in\n   the Suggested
      External Port field, then it is invalid.  The PCP\n   server MUST reject such
      a message with the MALFORMED_OPTION error\n   code.\n   PCP servers MAY choose
      to rate-limit their handling of PREFER_FAILURE\n   requests, to protect themselves
      from a rapid flurry of 65535\n   consecutive PREFER_FAILURE requests from clients
      probing to discover\n   which external ports are available.\n   There can exist
      a race condition between the MAP Opcode using the\n   PREFER_FAILURE option
      and Mapping Update (Section 14.2).  For\n   example, a previous host on the
      local network could have previously\n   had the same internal address, with
      a mapping for the same internal\n   port.  At about the same moment that the
      current host sends a MAP\n   Request using the PREFER_FAILURE option, the PCP
      server could send a\n   spontaneous Mapping Update for the old mapping due to
      an external\n   configuration change, which could appear to be a reply to the
      new\n   mapping request.  Because of this, the PCP client MUST validate that\n
      \  the external IP address, protocol, port, and nonce in a success\n   response
      match the associated suggested values from the request.  If\n   they do not
      match, it is because the Mapping Update was sent before\n   the MAP request
      was processed.\n"
    title: 13.2.  PREFER_FAILURE Option for MAP Opcode
  - contents:
    - "13.3.  FILTER Option for MAP Opcode\n   This option is only used with the MAP
      Opcode.\n   This option indicates that filtering incoming packets is desired.\n
      \  The protocol being filtered is indicated by the Protocol field in the\n   MAP
      Request, and the remote peer IP address and remote peer port of\n   the FILTER
      option indicate the permitted remote peer's source IP\n   address and source
      port for packets from the Internet; other traffic\n   from other addresses is
      blocked.  The remote peer prefix length\n   indicates the length of the remote
      peer's IP address that is\n   significant; this allows a single option to permit
      an entire subnet.\n   After processing this MAP request containing the FILTER
      option and\n   generating a successful response, the PCP-controlled device will
      drop\n   packets received on its public-facing interface that don't match the\n
      \  filter fields.  After dropping the packet, if its security policy\n   allows,
      the PCP-controlled device MAY also generate an ICMP error in\n   response to
      the dropped packet.\n   The use of the FILTER option can be seen as a performance\n
      \  optimization.  Since all software using PCP to receive incoming\n   connections
      also has to deal with the case where it may be directly\n   connected to the
      Internet and receive unrestricted incoming TCP\n   connections and UDP packets,
      if it wishes to restrict incoming\n   traffic to a specific source address or
      group of source addresses,\n   such software already needs to check the source
      address of incoming\n   traffic and reject unwanted traffic.  However, the FILTER
      option is a\n   particularly useful performance optimization for battery powered\n
      \  wireless devices, because it can enable them to conserve battery\n   power
      by not having to wake up just to reject unwanted traffic.\n   The FILTER option
      is formatted as follows:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | Option Code=3 |  Reserved     |   Option Length=20            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Reserved   | Prefix Length |      Remote Peer Port         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \              Remote Peer IP address (128 bits)               |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                     Figure 15: FILTER Option Layout\n   These fields are described
      below:\n   Reserved:  8 reserved bits, MUST be sent as 0 and MUST be ignored\n
      \     when received.\n   Prefix Length:  indicates how many bits of the IPv4
      or IPv6 address\n      are relevant for this filter.  The value 0 indicates
      \"no filter\",\n      and will remove all previous filters.  See below for detail.\n
      \  Remote Peer Port:  the port number of the remote peer.  The value 0\n      indicates
      \"all ports\".\n   Remote Peer IP address:  The IP address of the remote peer.\n
      \     Option Name: FILTER\n      Number: 3\n      Purpose: specifies a filter
      for incoming packets\n      Valid for Opcodes: MAP\n      Length: 20 octets\n
      \     May appear in: request.  May appear in response only if it\n      appeared
      in the associated request.\n      Maximum occurrences: as many as fit within
      maximum PCP message\n      size\n   The Prefix Length indicates how many bits
      of the address are used for\n   the filter.  For IPv4 addresses (which are encoded
      using the\n   IPv4-mapped address format (::FFFF:0:0/96)), this means valid
      prefix\n   lengths are between 96 and 128 bits, inclusive.  That is, add 96
      to\n   the IPv4 prefix length.  For IPv6 addresses, valid prefix lengths are\n
      \  between 0 and 128 bits, inclusive.  Values outside those ranges cause\n   the
      PCP server to return the MALFORMED_OPTION result code.\n   If multiple occurrences
      of the FILTER option exist in the same MAP\n   request, they are processed in
      the order received (as per normal PCP\n   option processing), and they MAY overlap
      the filtering requested.  If\n   there is an existing mapping (with or without
      a filter) and the\n   server receives a MAP request with FILTER, the filters
      indicated in\n   the new request are added to any existing filters.  If a MAP
      request\n   has a lifetime of 0 and contains the FILTER option, the error\n
      \  MALFORMED_OPTION is returned.\n   If any occurrences of the FILTER option
      in a request packet are not\n   successfully processed then an error is returned
      (e.g.,\n   MALFORMED_OPTION if one of the options was malformed) and as with\n
      \  other PCP errors, returning an error causes no state to be changed in\n   the
      PCP server or in the PCP-controlled device.\n   To remove all existing filters,
      the Prefix Length 0 is used.  There\n   is no mechanism to remove a specific
      filter.\n   To change an existing filter, the PCP client sends a MAP request\n
      \  containing two FILTER options, the first option containing a prefix\n   length
      of 0 (to delete all existing filters) and the second\n   containing the new
      remote peer's IP address, protocol, and port.\n   Other FILTER options in that
      PCP request, if any, add more allowed\n   remote peers.\n   The PCP server or
      the PCP-controlled device is expected to have a\n   limit on the number of remote
      peers it can support.  This limit might\n   be as small as one.  If a MAP request
      would exceed this limit, the\n   entire MAP request is rejected with the result
      code\n   EXCESSIVE_REMOTE_PEERS, and the state on the PCP server is unchanged.\n
      \  All PCP servers MUST support at least one filter per MAP mapping.\n"
    title: 13.3.  FILTER Option for MAP Opcode
  title: 13.  Options for MAP and PEER Opcodes
- contents:
  - "14.  Rapid Recovery\n   PCP includes a rapid recovery feature, which allows PCP
    clients to\n   repair failed mappings within seconds, rather than the minutes
    or\n   hours it might take if they relied solely on waiting for the next\n   routine
    renewal of the mapping.  Mapping failures may occur when a\n   NAT gateway is
    rebooted and loses its mapping state, or when a NAT\n   gateway has its external
    IP address changed so that its current\n   mapping state becomes invalid.\n   The
    PCP rapid recovery feature enables users to, for example, connect\n   to remote
    machines using ssh, and then reboot their NAT or firewall\n   device (or even
    replace it with completely new hardware) without\n   losing their established
    ssh connections.\n   Use of PCP rapid recovery is a performance optimization to
    PCP's\n   routine self-healing.  Without rapid recovery, PCP clients will still\n
    \  recreate their correct state when they next renew their mappings, but\n   this
    routine self-healing process may take hours rather than seconds,\n   and will
    probably not happen fast enough to prevent active TCP\n   connections from timing
    out.\n   There are two mechanisms to perform rapid recovery, described below.\n
    \  Failing to implement and deploy a rapid recovery mechanism will\n   encourage
    application developers to feel the need to refresh their\n   PCP state more frequently
    than necessary, causing more network\n   traffic.  Therefore, a PCP server that
    can lose state (e.g., due to\n   reboot) or might have a mapping change (e.g.,
    due to IP renumbering)\n   MUST implement either the Announce Opcode or the Mapping
    Update\n   mechanism and SHOULD implement both mechanisms.\n"
  - contents:
    - "14.1.  ANNOUNCE Opcode\n   This rapid recovery mechanism uses the ANNOUNCE
      Opcode.  When the PCP\n   server loses its state (e.g., it lost its state when
      rebooted), it\n   resets its Epoch time to its initial starting value (usually
      zero)\n   and sends the ANNOUNCE response to the link-scoped multicast address\n
      \  (specific address explained below) if a multicast network exists on\n   its
      local interface, or, if configured with the IP address(es) and\n   port(s) of
      PCP client(s), it sends unicast ANNOUNCE responses to\n   those address(es)
      and port(s).  This means ANNOUNCE may not be\n   available on all networks (such
      as networks without a multicast link\n   between the PCP server and its PCP
      clients).  Additionally, an\n   ANNOUNCE request can be sent (unicast) by a
      PCP client that elicits a\n   unicast ANNOUNCE response like any other Opcode.\n
      \  Upon receiving PCP response packets with an anomalous Epoch time,\n   clients
      deduce that the PCP server lost state and recreate their lost\n   mappings.\n"
    - contents:
      - "14.1.1.  ANNOUNCE Operation\n   The PCP ANNOUNCE Opcode requests and responses
        have no\n   Opcode-specific payload (that is, the length of the Opcode-specific\n
        \  data is zero).  The Requested Lifetime field of requests and Lifetime\n
        \  field of responses are both set to 0 on transmission and ignored on\n   reception.\n
        \  If a PCP server receives an ANNOUNCE request, it first parses it and\n
        \  generates a SUCCESS if parsing and processing of ANNOUNCE is\n   successful.
        \ An error is generated if the client's IP Address field\n   does not match
        the packet source address, or the request packet is\n   otherwise malformed,
        such as packet length less than 24 octets.  Note\n   that, in the future,
        options MAY be sent with the PCP ANNOUNCE\n   Opcode; PCP clients and servers
        need to be prepared to receive\n   options with the ANNOUNCE Opcode.\n      Discussion:
        Client-to-server request messages are sent, from any\n      client source
        port, to listening UDP port 5351 on the server;\n      server-to-client multicast
        notifications are sent from the\n      server's UDP port (5351) to listening
        UDP port 5350 on the client.\n      The reason the same listening UDP port
        is not used for both\n      purposes is that a single device may have multiple
        roles.  For\n      example, a multi-function home gateway that provides NAT
        service\n      (PCP server) may also provide printer sharing (which wants
        a PCP\n      client), or a home computer (PCP client) may also provide\n      \"Internet
        Sharing\" (NAT) functionality (which needs to offer PCP\n      service).  Such
        devices need to act as both a PCP server and a PCP\n      client at the same
        time, and the software that implements the PCP\n      server on the device
        may not be the same software component that\n      implements the PCP client.
        \ The software that implements the PCP\n      server needs to listen for unicast
        client requests, whereas the\n      software that implements the PCP client
        needs to listen for\n      multicast restart announcements.  In many networking
        APIs it is\n      difficult or impossible to have two independent clients
        listening\n      for both unicasts and multicasts on the same port at the
        same\n      time.  For this reason, two ports are used.\n"
      title: 14.1.1.  ANNOUNCE Operation
    - contents:
      - "14.1.2.  Generating and Processing a Solicited ANNOUNCE Message\n   The PCP
        ANNOUNCE Opcode MAY be sent (unicast) by a PCP client.  The\n   Requested
        Lifetime value MUST be set to zero.\n   When the PCP server receives the ANNOUNCE
        Opcode and successfully\n   parses and processes it, it generates SUCCESS
        response with an\n   assigned lifetime of zero.\n   This functionality allows
        a PCP client to determine a server's Epoch,\n   or to determine if a PCP server
        is running, without changing the\n   server's state.\n"
      title: 14.1.2.  Generating and Processing a Solicited ANNOUNCE Message
    - contents:
      - "14.1.3.  Generating and Processing an Unsolicited ANNOUNCE Message\n   When
        sending unsolicited responses, the ANNOUNCE Opcode MUST have\n   result code
        equal to zero (SUCCESS), and the packet MUST be sent from\n   the unicast
        IP address and UDP port number on which PCP requests are\n   received (so
        that the PCP response processing described in\n   Section 8.3 will accept
        the message).  This message is most typically\n   multicast, but can also
        be unicast.  Multicast PCP restart\n   announcements are sent to 224.0.0.1:5350
        and/or [ff02::1]:5350, as\n   described below.  Sending PCP restart announcements
        via unicast\n   requires that the PCP server know the IP address(es) and port(s)
        of\n   its listening clients, which means that sending PCP restart\n   announcements
        via unicast is only applicable to PCP servers that\n   retain knowledge of
        the IP address(es) and port(s) of their clients\n   even after they otherwise
        lose the rest of their state.\n   When a PCP server device that implements
        this functionality reboots,\n   restarts its NAT engine, or otherwise enters
        a state where it may\n   have lost some or all of its previous mapping state
        (or enters a\n   state where it doesn't even know whether it may have had
        prior state\n   that it lost), it MUST inform PCP clients of this fact by
        unicasting\n   or multicasting a gratuitous PCP ANNOUNCE Opcode response packet,
        as\n   shown below, via paths over which it accepts PCP requests.  If\n   sending
        a multicast ANNOUNCE message, a PCP server device that\n   accepts PCP requests
        over IPv4 sends the Restart Announcement to the\n   IPv4 multicast address
        224.0.0.1:5350 (224.0.0.1 is the All Hosts\n   multicast group address), and
        a PCP server device that accepts PCP\n   requests over IPv6 sends the Restart
        Announcement to the IPv6\n   multicast address [ff02::1]:5350 (ff02::1 is
        for all nodes on the\n   local segment).  A PCP server device that accepts
        PCP requests over\n   both IPv4 and IPv6 sends a pair of Restart Announcements,
        one to each\n   multicast address.  If sending a unicast ANNOUNCE messages,
        it sends\n   ANNOUNCE response message to the IP address(es) and port(s) of
        its\n   PCP clients.  To accommodate packet loss, the PCP server device MAY\n
        \  transmit such packets (or packet pairs) up to ten times (with an\n   appropriate
        Epoch Time value in each to reflect the passage of time\n   between transmissions)
        provided that the interval between the first\n   two notifications is at least
        250 ms, and the interval between\n   subsequent notification at least doubles.\n
        \  A PCP client that sends PCP requests to a PCP server via a multicast-\n
        \  capable path, and implements the Restart Announcement feature, and\n   wishes
        to receive these announcements, MUST listen to receive these\n   PCP Restart
        Announcements (gratuitous PCP ANNOUNCE Opcode response\n   packets) on the
        appropriate multicast-capable interfaces on which it\n   sends PCP requests,
        and MAY also listen for unicast announcements\n   from the server too, (using
        the UDP port it already uses to issue\n   unicast PCP requests to, and receive
        unicast PCP responses from, that\n   server).  A PCP client device that sends
        PCP requests using IPv4\n   listens for packets sent to the IPv4 multicast
        address\n   224.0.0.1:5350.  A PCP client device that sends PCP requests using\n
        \  IPv6 listens for packets sent to the IPv6 multicast address\n   [ff02::1]:5350.
        \ A PCP client device that sends PCP requests using\n   both IPv4 and IPv6
        listens for both types of Restart Announcement.\n   The SO_REUSEPORT socket
        option or equivalent should be used for the\n   multicast UDP port, if required
        by the host OS to permit multiple\n   independent listeners on the same multicast
        UDP port.\n   Upon receiving a unicasted or multicasted PCP ANNOUNCE Opcode\n
        \  response packet, a PCP client MUST (as it does with all received PCP\n
        \  response packets) inspect the announcement's source IP address, and\n   if
        the Epoch Time value is outside the expected range for that\n   server, it
        MUST wait a random amount of time between 0 and 5 seconds\n   (to prevent
        synchronization of all PCP clients), then for all PCP\n   mappings it made
        at that server address the client issues new PCP\n   requests to recreate
        any lost mapping state.  The use of the\n   Suggested External IP Address
        and Suggested External Port fields in\n   the client's renewal requests allows
        the client to remind the\n   restarted PCP server device of what mappings
        the client had\n   previously been given, so that in many cases the prior
        state can be\n   recreated.  For PCP server devices that reboot relatively
        quickly it\n   is usually possible to reconstruct lost mapping state fast
        enough\n   that existing TCP connections and UDP communications do not time
        out,\n   and continue without failure.  As for all PCP response messages,
        if\n   the Epoch Time value is within the expected range for that server,\n
        \  the PCP client does not recreate its mappings.  As for all PCP\n   response
        messages, after receiving and validating the ANNOUNCE\n   message, the client
        updates its own Epoch time for that server, as\n   described in Section 8.5.\n"
      title: 14.1.3.  Generating and Processing an Unsolicited ANNOUNCE Message
    title: 14.1.  ANNOUNCE Opcode
  - contents:
    - "14.2.  PCP Mapping Update\n   This rapid recovery mechanism is used when the
      PCP server remembers\n   its state and determines its existing mappings are
      invalid (e.g., IP\n   renumbering changes the external IP address of a PCP-controlled
      NAT).\n   It is anticipated that servers that are routinely reconfigured by
      an\n   administrator or have their WAN address changed frequently will\n   implement
      this feature (e.g., residential CPE routers).  It is\n   anticipated that servers
      that are not routinely reconfigured will not\n   implement this feature (e.g.,
      service provider-operated CGN).\n   If a PCP server device has not forgotten
      its mapping state, but for\n   some other reason has determined that some or
      all of its mappings\n   have become unusable (e.g., when a home gateway is assigned
      a\n   different external IPv4 address by the upstream DHCP server), then\n   the
      PCP server device automatically repairs its mappings and notifies\n   its clients
      by following the procedure described below.\n   For PCP-managed mappings, for
      each one the PCP server device should\n   update the external IP address and
      external port to appropriate\n   available values, and then send unicast PCP
      MAP or PEER responses (as\n   appropriate for the mapping) to inform the PCP
      client of the new\n   external IP address and external port.  Such unsolicited
      responses\n   are identical to the MAP or PEER responses normally returned in\n
      \  response to client MAP or PEER requests, containing newly updated\n   External
      IP Address and External Port values, and are sent to the\n   same client IP
      address and port that the PCP server used to send the\n   prior response for
      that mapping.  If the earlier associated request\n   contained the THIRD_PARTY
      option, the THIRD_PARTY option MUST also\n   appear in the Mapping Update as
      it is necessary for the PCP client to\n   disambiguate the response.  If the
      earlier associated request\n   contained the PREFER_FAILURE option, and the
      same external IP\n   address, protocol, and port cannot be provided, the error\n
      \  CANNOT_PROVIDE_EXTERNAL SHOULD be sent.  If the earlier associated\n   request
      contained the FILTER option, the filters are moved to the new\n   mapping and
      the FILTER option is sent in the Mapping Update response.\n   Non-mandatory
      options SHOULD NOT be sent in the Mapping Update\n   response.\n      Discussion:
      It could have been possible to design this so that the\n      PCP server (1)
      sent an ANNOUNCE Opcode to the PCP client, the PCP\n      client reacted by
      (2) sending a new MAP request and (3) receiving\n      a MAP response.  Instead,
      the server can create a shortcut for\n      that design by simply sending the
      message it would have sent in\n      (3).\n   To accommodate packet loss, the
      PCP server device SHOULD transmit\n   such packets three times, with an appropriate
      Epoch Time value in\n   each to reflect the passage of time between transmissions.
      \ The\n   interval between the first two notifications MUST be at least 250
      ms,\n   and the third packet after a 500-ms interval.  Once the PCP server\n
      \  has received a refreshed state for that mapping, the PCP server\n   SHOULD
      cease those retransmissions for that mapping, as it serves no\n   further purpose
      to continue sending messages regarding that mapping.\n   Upon receipt of such
      an updated MAP or PEER response, a PCP client\n   uses the information in the
      response to adjust rendezvous servers or\n   reconnect to servers, respectively.
      \ For MAP, this would mean\n   updating the DNS entries or other address and
      port information\n   recorded with some kind of application-specific rendezvous
      server.\n   For PEER responses giving a CANNOT_PROVIDE_EXTERNAL error, this
      would\n   typically mean establishing new connections to servers.  Anytime the\n
      \  external address or port changes, existing TCP and UDP connections\n   will
      be lost; PCP can't avoid that, but does provide immediate\n   notification of
      the event to lessen the impact.\n"
    title: 14.2.  PCP Mapping Update
  title: 14.  Rapid Recovery
- contents:
  - "15.  Mapping Lifetime and Deletion\n   The PCP client requests a certain lifetime,
    and the PCP server\n   responds with the assigned lifetime.  The PCP server MAY
    grant a\n   lifetime smaller or larger than the requested lifetime.  The PCP\n
    \  server SHOULD be configurable for permitted minimum and maximum\n   lifetime,
    and the minimum value SHOULD be 120 seconds.  The maximum\n   value SHOULD be
    the remaining lifetime of the IP address assigned to\n   the PCP client if that
    information is available (e.g., from the DHCP\n   server), or half the lifetime
    of IP address assignments on that\n   network if the remaining lifetime is not
    available, or 24 hours.\n   Excessively long lifetimes can cause consumption of
    ports even if the\n   internal host is no longer interested in receiving the traffic
    or is\n   no longer connected to the network.  These recommendations are not\n
    \  strict, and deployments should evaluate the trade-offs to determine\n   their
    own minimum and maximum Lifetime values.\n   Once a PCP server has responded positively
    to a MAP request for a\n   certain lifetime, the port mapping is active for the
    duration of the\n   lifetime unless the lifetime is reduced by the PCP client
    (to a\n   shorter lifetime or to zero) or until the PCP server loses its state\n
    \  (e.g., crashes).  Mappings created by PCP MAP requests are not\n   special
    or different from mappings created in other ways.  In\n   particular, it is implementation-dependent
    if outgoing traffic\n   extends the lifetime of such mappings beyond the PCP-assigned\n
    \  lifetime.  PCP clients MUST NOT depend on this behavior to keep\n   mappings
    active, and MUST explicitly renew their mappings as required\n   by the Lifetime
    field in PCP response messages.\n   Upon receipt of a PCP response with an absurdly
    long assigned\n   lifetime, the PCP client SHOULD behave as if it received a more
    sane\n   value (e.g., 24 hours), and renew the mapping accordingly, to ensure\n
    \  that if the static mapping is removed, the client will continue to\n   maintain
    the mapping it desires.\n   An application that forgets its PCP-assigned mappings
    (e.g., the\n   application or OS crashes) will request new PCP mappings.  This
    may\n   consume port mappings, if the application binds to a different\n   internal
    port every time it runs.  The application will also likely\n   initiate new outbound
    TCP connections, which create implicit dynamic\n   outbound mappings without using
    PCP, which will also consume port\n   mappings.  If there is a port mapping quota
    for the internal host,\n   frequent restarts such as this may exhaust the quota.\n
    \  To help clean PCP state, when the PCP-controlled device is collocated\n   with
    the address assignment (DHCP) server, such as in a typical\n   residential CPE,
    it is RECOMMENDED that when an IP address becomes\n   invalid (e.g., the DHCP
    lease expires, or the DHCP client sends an\n   explicit DHCP RELEASE) the PCP-controlled
    device SHOULD also discard\n   any dynamic mapping state relating to that expired
    IP address.\n   When using NAT, the same external port may be assigned for use
    by\n   different internal hosts at different times.  For example, if an\n   internal
    host using an external port ceases sending traffic using\n   that port, then its
    mapping may expire, and then later the same\n   external port may be assigned
    to a new internal host.  The new\n   internal host could then receive incoming
    traffic that was intended\n   for the previous internal host.  This generally
    happens\n   inadvertently, and this reassignment of the external port only\n   happens
    after the current holder of the external port has ceased\n   using it for some
    period of time.  It would be unacceptable if an\n   attacker could use PCP to
    intentionally speed up this reassignment of\n   the external port in order to
    deliberately steal traffic intended for\n   the current holder, by (i) spoofing
    PCP requests using the current\n   holder's source IP address and mapping nonce
    to fraudulently delete\n   the mapping or shorten its lifetime, and then (ii)
    subsequently\n   claiming the external port for itself.\n   Therefore, in the
    simple security model, to protect against this\n   attack, PCP MUST NOT allow
    a PCP request (even a PCP request that\n   appears to come from the current holder
    of the mapping) to cause a\n   mapping to expire sooner than it would naturally
    have expired\n   otherwise by virtue of outbound traffic keeping the mapping active.\n
    \  A PCP server MUST set the lifetime of a mapping to no less than the\n   remaining
    time before the mapping would expire if no further outbound\n   traffic is seen
    for that mapping.  This means a MAP or PEER request\n   with lifetime of 0 will
    only set the assigned lifetime to 0 (i.e.,\n   delete the mapping) if the internal
    host had not sent a packet using\n   that mapping for the idle-timeout time, otherwise
    the assigned\n   lifetime will be the remaining idle-timeout time.\n   Finally,
    to reduce unwanted traffic and data corruption for both TCP\n   and UDP, the assigned
    external port created by the MAP Opcode or PEER\n   Opcode SHOULD NOT be reused
    for an interval equal to the reuse time\n   limit enforced by the NAT for its
    implicit dynamic mappings\n   (typically, the maximum TCP segment lifetime of
    2 minutes [RFC0793]).\n   Furthermore, to reduce port stealing attacks, the assigned
    external\n   port also SHOULD NOT be reused for an interval equal to the time
    the\n   PCP- controlled device would normally maintain an idle (no traffic)\n
    \  implicit dynamic mapping (e.g., 2 minutes for UDP [RFC4787] and 124\n   minutes
    for TCP [RFC5382]).  However, within these time windows, the\n   PCP server SHOULD
    allow an external port to be reclaimed by the same\n   client, where \"same client\"
    means \"same internal IP address, internal\n   port, and mapping nonce\".\n"
  - contents:
    - "15.1.  Lifetime Processing for the MAP Opcode\n   If the requested lifetime
      is zero then:\n   o  If both the protocol and internal port are non-zero, it
      indicates\n      a request to delete the indicated mapping immediately.\n   o
      \ If the protocol is non-zero and the internal port is zero, it\n      indicates
      a request to delete a previous 'wildcard' (all-ports)\n      mapping for that
      protocol.  The nonce MUST match the nonce used to\n      create the 'wildcard'
      mapping.\n   o  If both the protocol and internal port are zero, it indicates
      a\n      request to delete a previous 'DMZ host' (all incoming traffic for\n
      \     all protocols) mapping.  The nonce MUST match the nonce used to\n      create
      the 'DMZ host' mapping.\n   o  If the protocol is zero and the internal port
      is non-zero, then\n      the request is invalid and the PCP server MUST return
      a\n      MALFORMED_REQUEST error to the client.\n   In requests where the requested
      Lifetime is 0, the Suggested External\n   Address and Suggested External Port
      fields MUST be set to zero on\n   transmission and MUST be ignored on reception,
      and these fields MUST\n   be copied into the assigned external IP address and
      assigned external\n   port of the response.\n   PCP MAP requests can only delete
      or shorten lifetimes of MAP-created\n   mappings.  If the PCP client attempts
      to delete a static mapping\n   (i.e., a mapping created outside of PCP itself),
      or an outbound\n   (implicit or PEER-created) mapping, the PCP server MUST return\n
      \  NOT_AUTHORIZED.  If the PCP client attempts to delete a mapping that\n   does
      not exist, the SUCCESS result code is returned (this is\n   necessary for PCP
      to return the same response for retransmissions or\n   duplications of the same
      request).  If the deletion request was\n   properly formatted and successfully
      processed, a SUCCESS response is\n   generated with the protocol and internal
      port number copied from the\n   request, and the response lifetime set to zero.
      \ An inbound mapping\n   (i.e., static mapping or MAP-created dynamic mapping)
      MUST NOT have\n   its lifetime reduced by transport protocol messages (e.g.,
      TCP RST,\n   TCP FIN).  Note the THIRD_PARTY option (Section 13.1), if authorized,\n
      \  can also delete PCP-created MAP mappings.\n"
    title: 15.1.  Lifetime Processing for the MAP Opcode
  title: 15.  Mapping Lifetime and Deletion
- contents:
  - "16.  Implementation Considerations\n   Section 16 provides non-normative guidance
    that may be useful to\n   implementers.\n"
  - contents:
    - "16.1.  Implementing MAP with EDM Port-Mapping NAT\n   For implicit dynamic
      outbound mappings, some existing NAT devices\n   have endpoint-independent mapping
      (EIM) behavior while other NAT\n   devices have endpoint-dependent mapping (EDM)
      behavior.  NATs that\n   have EIM behavior do not suffer from the problem described
      in this\n   section.  The IETF strongly encourages EIM behavior\n   [RFC4787][RFC5382].\n
      \  In EDM NAT devices, the same external port may be used by an outbound\n   dynamic
      mapping and an inbound dynamic mapping (from the same\n   internal host or from
      a different internal host).  This complicates\n   the interaction with the MAP
      Opcode.  With such NAT devices, there\n   are two ways envisioned to implement
      the MAP Opcode:\n   1.  Have outbound mappings use a different set of external
      ports than\n       inbound mappings (e.g., those created with MAP), thus reducing\n
      \      the interaction problem between them; or\n   2.  On arrival of a packet
      (inbound from the Internet or outbound\n       from an internal host), first
      attempt to use a dynamic outbound\n       mapping to process that packet.  If
      none match, attempt to use an\n       inbound mapping to process that packet.
      \ This effectively\n       'prioritizes' outbound mappings above inbound mappings.\n"
    title: 16.1.  Implementing MAP with EDM Port-Mapping NAT
  - contents:
    - "16.2.  Lifetime of Explicit and Implicit Dynamic Mappings\n   No matter if
      a NAT is EIM or EDM, it is possible that one (or more)\n   outbound mappings,
      using the same internal port on the internal host,\n   might be created before
      or after a MAP request.  When this occurs, it\n   is important that the NAT
      honor the lifetime returned in the MAP\n   response.  Specifically, if an inbound
      mapping was created with the\n   MAP Opcode, the implementation needs to ensure
      that termination of an\n   outbound mapping (e.g., via a TCP FIN handshake)
      does not prematurely\n   destroy the MAP-created inbound mapping.\n"
    title: 16.2.  Lifetime of Explicit and Implicit Dynamic Mappings
  - contents:
    - "16.3.  PCP Failure Recovery\n   If an event occurs that causes the PCP server
      to lose dynamic mapping\n   state (such as a crash or power outage), the mappings
      created by PCP\n   are lost.  Occasional loss of state may be unavoidable in
      a\n   residential NAT device that does not write transient information to\n
      \  non-volatile memory.  Loss of state is expected to be rare in a\n   service
      provider environment (due to redundant power, disk drives for\n   storage, etc.).
      \ Of course, due to outright failure of service\n   provider equipment (e.g.,
      software malfunction), state may still be\n   lost.\n   The Epoch time allows
      a client to deduce when a PCP server may have\n   lost its state.  When the
      Epoch Time value is observed to be outside\n   the expected range, the PCP client
      can attempt to recreate the\n   mappings following the procedures described
      in this section.\n   Further analysis of PCP failure scenarios is planned for
      a future\n   document [PCP-FAIL].\n"
    - contents:
      - "16.3.1.  Recreating Mappings\n   A mapping renewal packet is formatted identically
        to an original\n   mapping request; from the point of view of the client,
        it is a\n   renewal of an existing mapping; however, from the point of view
        of a\n   newly rebooted PCP server, it appears as a new mapping request.  In\n
        \  the normal process of routinely renewing its mappings before they\n   expire,
        a PCP client will automatically recreate all its lost\n   mappings.\n   When
        the PCP server loses state and begins processing new PCP\n   messages, its
        Epoch time is reset and begins counting again.  As the\n   result of receiving
        a packet where the Epoch Time field is outside\n   the expected range (Section
        8.5), indicating that a reboot or similar\n   loss of state has occurred,
        the client can renew its port mappings\n   sooner, without waiting for the
        normal routine renewal time.\n"
      title: 16.3.1.  Recreating Mappings
    - contents:
      - "16.3.2.  Maintaining Mappings\n   A PCP client refreshes a mapping by sending
        a new PCP request\n   containing information learned from the earlier PCP
        response.  The\n   PCP server will respond indicating the new lifetime.  It
        is possible,\n   due to reconfiguration or failure of the PCP server, that
        the\n   external IP address and/or external port, or the PCP server itself,\n
        \  has changed (due to a new route to a different PCP server).  Such\n   events
        are rare, but not an error.  The PCP server will simply return\n   a new external
        address and/or external port to the client, and the\n   client should record
        this new external address and port with its\n   rendezvous service.  To detect
        such events more quickly, a server\n   that requires extremely high availability
        may find it beneficial to\n   use shorter lifetimes in its PCP mappings requests,
        so that it\n   communicates with the PCP server more often.  This is an engineering\n
        \  trade-off based on (i) the acceptable downtime for the service in\n   question,
        (ii) the expected likelihood of NAT or firewall state loss,\n   and (iii)
        the amount of PCP maintenance traffic that is acceptable.\n   If the PCP client
        has several mappings, the Epoch Time value only\n   needs to be retrieved
        for one of them to determine whether or not it\n   appears the PCP server
        may have suffered a catastrophic loss of\n   state.  If the client wishes
        to check the PCP server's Epoch time, it\n   sends a PCP request for any one
        of the client's mappings.  This will\n   return the current Epoch Time value.
        \ In that request, the PCP client\n   could extend the mapping lifetime (by
        asking for more time) or\n   maintain the current lifetime (by asking for
        the same number of\n   seconds that it knows are remaining of the lifetime).\n
        \  If a PCP client changes its internal IP address (e.g., because the\n   internal
        host has moved to a new network), and the PCP client wishes\n   to still receive
        incoming traffic, it needs create new mappings on\n   that new network.  New
        mappings will typically also require an update\n   to the application-specific
        rendezvous server if the external address\n   or port is different from the
        previous values (see Sections 10.1 and\n   11.5).\n"
      title: 16.3.2.  Maintaining Mappings
    - contents:
      - "16.3.3.  SCTP\n   Although SCTP has port numbers like TCP and UDP, SCTP works\n
        \  differently when behind an address-sharing NAT, in that SCTP port\n   numbers
        are not changed [SCTPNAT].  Outbound dynamic SCTP mappings\n   use the verification
        tag of the association instead of the local and\n   remote peer port numbers.
        \ As with TCP, explicit outbound mappings\n   can be made to reduce keepalive
        intervals, and explicit inbound\n   mappings can be made by passive listeners
        expecting to receive new\n   associations at the external port.\n   Because
        an SCTP-aware NAT does not (currently) rewrite SCTP port\n   numbers, it will
        not be able to assign an external port that is\n   different from the client's
        internal port.  A PCP client making a MAP\n   request for SCTP should be aware
        of this restriction.  The PCP client\n   SHOULD make its SCTP MAP request
        just as it would for a TCP MAP\n   request: in its initial PCP MAP request
        it SHOULD specify zero for\n   the external address and port, and then in
        subsequent renewals it\n   SHOULD echo the assigned external address and port.
        \ However, since a\n   current SCTP-aware NAT can only assign an external
        port that is the\n   same as the internal port, it may not be able to do that
        if the\n   external port is already assigned to a different PCP client.  This
        is\n   likely if there is more than one instance of a given SCTP service on\n
        \  the local network, since both instances are likely to listen on the\n   same
        well-known SCTP port for that service on their respective hosts,\n   but they
        can't both have the same external port on the NAT gateway's\n   external address.
        \ A particular external port may not be assignable\n   for other reasons,
        such as when it is already in use by the NAT\n   device itself, or otherwise
        prohibited by policy, as described in\n   Section 11.3, \"Processing a MAP
        Request\".  In the event that the\n   external port matching the internal
        port cannot be assigned (and the\n   SCTP-aware NAT does not perform SCTP
        port rewriting), the SCTP-aware\n   NAT MUST return a CANNOT_PROVIDE_EXTERNAL
        error to the requesting PCP\n   client.  Note that this restriction places
        an extra burden on the\n   SCTP server whose MAP request failed, because it
        then has to tear\n   down its exiting listening socket and try again with
        a different\n   internal port, repeatedly until it is successful in finding
        an\n   external port it can use.\n   The SCTP complications described above
        occur because of address\n   sharing.  The SCTP complications are avoided
        when address sharing is\n   avoided (e.g., 1:1 NAT, firewall).\n"
      title: 16.3.3.  SCTP
    title: 16.3.  PCP Failure Recovery
  - contents:
    - "16.4.  Source Address Replicated in PCP Header\n   All PCP requests include
      the PCP client's IP address replicated in\n   the PCP header.  This is used
      to detect unexpected address rewriting\n   (NAT) on the path between the PCP
      client and its PCP server.  On\n   operating systems that support the sockets
      API, the following steps\n   are RECOMMENDED for a PCP client to insert the
      correct source address\n   in the PCP header:\n   1.  Create a UDP socket.\n
      \  2.  Call \"connect\" on this UDP socket using the address and port of\n       the
      desired PCP server.\n   3.  Call the getsockname() function to retrieve a sockaddr
      containing\n       the source address the kernel will use for UDP packets sent\n
      \      through this socket.\n   4.  If the IP address is an IPv4 address, encode
      the address into an\n       IPv4-mapped IPv6 address.  Place the IPv4-mapped
      IPv6 address or\n       the native IPv6 address into the PCP Client's IP Address
      field in\n       the PCP header.\n   5.  Send PCP requests using this connected
      UDP socket.\n"
    title: 16.4.  Source Address Replicated in PCP Header
  - contents:
    - "16.5.  State Diagram\n   Each mapping entry of the PCP-controlled device would
      go through the\n   state machine shown below.  This state diagram is non-normative.\n
      \      CLOSE_MSG or\n      (NO_TRAFFIC and EXPIRY)   +---------+  NO_TRAFFIC
      and EXPIRY\n                +-------------->|         |<------------+\n                |
      \              |NO_ENTRY |             |\n                |   +-----------|
      \        |---------+   |\n                |   |           +---------+         |
      \  |\n                |   |              ^  |             |   |\n                |
      \  |   NO_TRAFFIC |  |             |   |\n                |   |           or
      |  |             |   |\n                |   |   CLOSE_MSGS |  |             |
      \  |\n                |   |              |  |             |   |\n                |
      \  |PEER request  |  |  MAP request|   |\n                |   V              |
      \ |             V   |\n             +---------+           |  |         +---------+\n
      \        +-->|  \"P\",   |           |  |    M-R  |  \"M\",   |<--+\n     P-R
      |   | PEER    |-----------|--|-------->| MAP     |   | M-R or\n         +---|
      \ mapping|           |  |         |  mapping|---+ P-R or\n             +---------+
      \          |  |         +---------+  CLOSE_MSGS\n                |   ^              |
      \ |             ^   |\n                |   |PEER request  |  |  MAP request|
      \  |\n                |   |              |  |             |   |\n                |
      \  |              |  |             |   |\n                |   |              |
      \ |             |   |\n                |   |              |  | outbound    |
      \  |\n                |   |              |  | TRAFFIC     |   |\n                |
      \  |              |  V             |   |\n                |   |           +---------+
      \        |   |\n                |   +-----------| \"I\",    |---------+   |\n
      \               |               | implicit|             |\n                +-------------->|
      mapping |<------------+\n            TRAFFIC and EXPIRY  +---------+  TRAFFIC
      and EXPIRY\n                       Figure 16: PCP State Diagram\n   The meanings
      of the states and events are:\n      NO_ENTRY:  Invalid state represents Entry
      does not exist.  This is\n            the only possible start state.\n      M-R:
      \ MAP request\n      P-R:  PEER request\n      M:    Mapping entry when created
      by MAP request\n      P:    Mapping entry when created/managed by PEER request\n
      \     I:    Implicit mapping created by an outgoing packet from the\n            client
      (e.g., TCP SYN), and also the state when a\n            PCP-created mapping's
      lifetime expires while there is still\n            active traffic.\n      EXPIRY:
      PEER or MAP lifetime expired\n      TRAFFIC:  Traffic seen by PCP-controlled
      device using this entry\n            within the expiry time for that entry.
      \ This traffic may be\n            inbound or outbound.\n      NO_TRAFFIC:  Indicates
      that there is no TRAFFIC.\n      CLOSE_MSG:  Protocol messages from the client
      or server to close\n            the session (e.g., TCP FIN or TCP RST), as per
      the NAT or\n            firewall device's handling of such protocol messages.\n
      \  Notes on the diagram:\n   1.  The 'and' clause indicates the events on either
      side of 'and' are\n       required for the state-transition.  The 'or' clause
      indicates\n       either one of the events are enough for the state-transition.\n
      \  2.  Transition from state M to state I is implementation dependent.\n"
    title: 16.5.  State Diagram
  title: 16.  Implementation Considerations
- contents:
  - '17.  Deployment Considerations

    '
  - contents:
    - "17.1.  Ingress Filtering\n   As with implicit dynamic mappings created by outgoing
      TCP SYN\n   packets, explicit dynamic mappings created via PCP use the source
      IP\n   address of the packet as the internal address for the mappings.\n   Therefore,
      ingress filtering [RFC2827] SHOULD be used on the path\n   between the internal
      host and the PCP server to prevent the injection\n   of spoofed packets onto
      that path.\n"
    title: 17.1.  Ingress Filtering
  - contents:
    - "17.2.  Mapping Quota\n   On PCP-controlled devices that create state when a
      mapping is created\n   (e.g., NAT), the PCP server SHOULD maintain per-host
      and/or per-\n   subscriber quotas for mappings.  It is implementation specific\n
      \  whether the PCP server uses a separate quotas for implicit, explicit,\n   and
      static mappings, a combined quota for all of them, or some other\n   policy.\n"
    title: 17.2.  Mapping Quota
  title: 17.  Deployment Considerations
- contents:
  - "18.  Security Considerations\n   The goal of the PCP protocol is to improve the
    ability of end nodes\n   to control their associated NAT state, and to improve
    the efficiency\n   and error handling of NAT mappings when compared to existing
    implicit\n   mapping mechanisms in NAT boxes and stateful firewalls.  It is the\n
    \  security goal of the PCP protocol to limit any new denial-of-service\n   opportunities,
    and to avoid introducing new attacks that can result\n   in unauthorized changes
    to mapping state.  One of the most serious\n   consequences of unauthorized changes
    in mapping state is traffic\n   theft.  All mappings that could be created by
    a specific host using\n   implicit mapping mechanisms are inherently considered
    to be\n   authorized.  Confidentiality of mappings is not a requirement, even\n
    \  in cases where the PCP messages may transit paths that would not be\n   traveled
    by the mapped traffic.\n"
  - contents:
    - "18.1.  Simple Threat Model\n   PCP servers are secure against off-path attackers
      who cannot spoof a\n   packet that the PCP server will view as a packet received
      from the\n   internal network.  PCP clients are secure against off-path attackers\n
      \  who can spoof the PCP server's IP address.\n   Defending against attackers
      who can modify or drop packets between\n   the internal network and the PCP
      server, or who can inject spoofed\n   packets that appear to come from the internal
      network is out of\n   scope.  Such an attacker can redirect traffic to a host
      of their\n   choosing.\n   A PCP server is secure under this threat model if
      the PCP server is\n   constrained so that it does not configure any explicit
      mapping that\n   it would not configure implicitly.  In most cases, this means
      that\n   PCP servers running on NAT boxes or stateful firewalls that support\n
      \  the PEER and MAP Opcodes can be secure under this threat model if\n   (1)
      all of their hosts are within a single administrative domain (or\n   if the
      internal hosts can be securely partitioned into separate\n   administrative
      domains, as in the DS-Lite B4 case), (2) explicit\n   mappings are created with
      the same lifetime as implicit mappings, and\n   (3) the THIRD_PARTY option is
      not supported.  PCP servers can also\n   securely support the MAP Opcode under
      this threat model if the\n   security policy on the device running the PCP server
      would permit\n   endpoint-independent filtering of implicit mappings.\n   PCP
      servers that comply with the Simple Threat Model and do not\n   implement a
      PCP security mechanism described in Section 18.2 MUST\n   enforce the constraints
      described in the paragraph above.\n"
    - contents:
      - "18.1.1.  Attacks Considered\n   o  If you allow multiple administrative domains
        to send PCP requests\n      to a single PCP server that does not enforce a
        boundary between\n      the domains, it is possible for a node in one domain
        to perform a\n      denial-of-service attack on other domains or to capture
        traffic\n      that is intended for a node in another domain.\n   o  If explicit
        mappings have longer lifetimes than implicit mappings,\n      it makes it
        easier to perpetrate a denial-of-service attack than\n      it would be if
        the PCP server was not present.\n   o  If the PCP server supports deleting
        or reducing the lifetime of\n      existing mappings, this allows an attacking
        node to steal an\n      existing mapping and receive traffic that was intended
        for another\n      node.\n   o  If the THIRD_PARTY option is supported, this
        also allows an\n      attacker to open a window for an external node to attack
        an\n      internal node, allows an attacker to steal traffic that was\n      intended
        for another node, or may facilitate a denial-of-service\n      attack.  One
        example of how the THIRD_PARTY option could grant an\n      attacker more
        capability than a spoofed implicit mapping is that\n      the PCP server (especially
        if it is running in a service\n      provider's network) may not be aware
        of internal filtering that\n      would prevent spoofing an equivalent implicit
        mapping, such as\n      filtering between a guest and corporate network.\n
        \  o  If the MAP Opcode is supported by the PCP server in cases where\n      the
        security policy would not support endpoint-independent\n      filtering of
        implicit mappings, then the MAP Opcode changes the\n      security properties
        of the device running the PCP server by\n      allowing explicit mappings
        that violate the security policy.\n"
      title: 18.1.1.  Attacks Considered
    - contents:
      - "18.1.2.  Deployment Examples Supporting the Simple Threat Model\n   This
        section offers two examples of how the Simple Threat Model can\n   be supported
        in real-world deployment scenarios.\n"
      - contents:
        - "18.1.2.1.  Residential Gateway Deployment\n   Parity with many currently
          deployed residential gateways can be\n   achieved using a PCP server that
          is constrained as described in\n   Section 18.1 above.\n"
        title: 18.1.2.1.  Residential Gateway Deployment
      title: 18.1.2.  Deployment Examples Supporting the Simple Threat Model
    title: 18.1.  Simple Threat Model
  - contents:
    - "18.2.  Advanced Threat Model\n   In the Advanced Threat Model, the PCP protocol
      ensures that attackers\n   (on- or off-path) cannot create unauthorized mappings
      or make\n   unauthorized changes to existing mappings.  The protocol must also\n
      \  limit the opportunity for on- or off-path attackers to perpetrate\n   denial-of-service
      attacks.\n   The Advanced Threat Model security model will be needed in the\n
      \  following cases:\n   o  Security infrastructure equipment, such as corporate
      firewalls,\n      that does not create implicit mappings.\n   o  Equipment (such
      as CGNs or service provider firewalls) that serves\n      multiple administrative
      domains and does not have a mechanism to\n      securely partition traffic from
      those domains.\n   o  Any implementation that wants to be more permissive in
      authorizing\n      explicit mappings than it is in authorizing implicit mappings.\n
      \  o  Implementations that wish to support any deployment scenario that\n      does
      not meet the constraints described in Section 18.1.\n   To protect against attacks
      under this threat model, a PCP security\n   mechanism that provides an authenticated,
      integrity-protected\n   signaling channel would need to be specified.\n   PCP
      servers that implement a PCP security mechanism MAY accept\n   unauthenticated
      requests.  In their default configuration, PCP\n   servers implementing the
      PCP security mechanism MUST still enforce\n   the constraints described in Section
      18.1 when processing\n   unauthenticated requests.\n"
    title: 18.2.  Advanced Threat Model
  - contents:
    - "18.3.  Residual Threats\n   This section describes some threats that are not
      addressed in either\n   of the above threat models and recommends appropriate
      mitigation\n   strategies.\n"
    - contents:
      - "18.3.1.  Denial of Service\n   Because of the state created in a NAT or firewall,
        a per-host and/or\n   per-subscriber quota will likely exist for both implicit
        dynamic\n   mappings and explicit dynamic mappings.  A host might make an\n
        \  excessive number of implicit or explicit dynamic mappings, consuming\n
        \  an inordinate number of ports, causing a denial of service to other\n   hosts.
        \ Thus, Section 17.2 recommends that hosts be limited to a\n   reasonable
        number of explicit dynamic mappings.\n   An attacker, on the path between
        the PCP client and PCP server, can\n   drop PCP requests, drop PCP responses,
        or spoof a PCP error, all of\n   which will effectively deny service.  Through
        such actions, the PCP\n   client might not be aware the PCP server might have
        actually\n   processed the PCP request.  An attacker sending a NO_RESOURCES
        error\n   can cause the PCP client to not send messages to that server for
        a\n   while.  There is no mitigation to this on-path attacker.\n"
      title: 18.3.1.  Denial of Service
    - contents:
      - "18.3.2.  Ingress Filtering\n   It is important to prevent a host from fraudulently
        creating,\n   deleting, or refreshing a mapping (or filtering) for another
        host,\n   because this can expose the other host to unwanted traffic, prevent\n
        \  it from receiving wanted traffic, or consume the other host's mapping\n
        \  quota.  Both implicit and explicit dynamic mappings are created based\n
        \  on the source IP address in the packet, and hence depend on ingress\n   filtering
        to guard against spoof source IP addresses.\n"
      title: 18.3.2.  Ingress Filtering
    - contents:
      - "18.3.3.  Mapping Theft\n   In the time between when a PCP server loses state
        and the PCP client\n   notices the lower-than-expected Epoch Time value, it
        is possible that\n   the PCP client's mapping will be acquired by another
        host (via an\n   explicit dynamic mapping or implicit dynamic mapping).  This
        means\n   incoming traffic will be sent to a different host (\"theft\").  Rapid\n
        \  recovery reduces this interval, but does not completely eliminate\n   this
        threat.  The PCP client can reduce this interval by using a\n   relatively
        short lifetime; however, this increases the amount of PCP\n   chatter.  This
        threat is reduced by using persistent storage of\n   explicit dynamic mappings
        in the PCP server (so it does not lose\n   explicit dynamic mapping state),
        or by ensuring that the previous\n   external IP address, protocol, and port
        cannot be used by another\n   host (e.g., by using a different IP address
        pool).\n"
      title: 18.3.3.  Mapping Theft
    - contents:
      - "18.3.4.  Attacks against Server Discovery\n   This document does not specify
        server discovery, beyond contacting\n   the default gateway.\n"
      title: 18.3.4.  Attacks against Server Discovery
    title: 18.3.  Residual Threats
  title: 18.  Security Considerations
- contents:
  - "19.  IANA Considerations\n   IANA has performed the following actions.\n"
  - contents:
    - "19.1.  Port Number\n   PCP uses ports 5350 and 5351, previously assigned by
      IANA to NAT-PMP\n   [RFC6886].  IANA has reassigned those ports to PCP.\n"
    title: 19.1.  Port Number
  - contents:
    - "19.2.  Opcodes\n   IANA has created a new protocol registry for PCP Opcodes,
      numbered\n   0-127, initially populated with the values:\n           Value            Opcode\n
      \          -----            -------------------------\n           0                ANNOUNCE\n
      \          1                MAP\n           2                PEER\n           3-31
      \            Standards Action [RFC5226]\n           32-63            Specification
      Required [RFC5226]\n           96-126           Reserved for Private Use [RFC5226]\n
      \          127              Reserved, Standards Action [RFC5226]\n   The value
      127 is Reserved and may be assigned via Standards Action\n   [RFC5226].  The
      values in the range 3-31 can be assigned via\n   Standards Action [RFC5226],
      32-63 via Specification Required\n   [RFC5226], and the range 96-126 is for
      Private Use [RFC5226].\n"
    title: 19.2.  Opcodes
  - contents:
    - "19.3.  Result Codes\n   IANA has created a new registry for PCP result codes,
      numbered 0-255,\n   initially populated with the result codes from Section 7.4.
      \ The\n   value 255 is Reserved and may be assigned via Standards Action\n   [RFC5226].\n
      \  The values in the range 14-127 can be assigned via Standards Action\n   [RFC5226],
      128-191 via Specification Required [RFC5226], and the\n   range 191-254 is for
      Private Use [RFC5226].\n"
    title: 19.3.  Result Codes
  - contents:
    - "19.4.  Options\n   IANA has created a new registry for PCP options, numbered
      0-255, each\n   with an associated mnemonic.  The values 0-127 are mandatory
      to\n   process, and 128-255 are optional to process.  The initial registry\n
      \  contains the options described in Section 13.  The option values 0,\n   127,
      and 255 are Reserved and may be assigned via Standards Action\n   [RFC5226].\n
      \  Additional PCP option codes in the ranges 4-63 and 128-191 can be\n   created
      via Standards Action [RFC5226], the ranges 64-95 and 192-223\n   are for Specification
      Required [RFC5226], and the ranges 96-126 and\n   224-254 are for Private Use
      [RFC5226].\n   Documents describing an option should describe the processing
      for\n   both the PCP client and server, and the information below:\n      Option
      Name: <mnemonic>\n      Number: <value>\n      Purpose: <textual description>\n
      \     Valid for Opcodes: <list of Opcodes>\n      Length: <rules for length>\n
      \     May appear in: <requests/responses/both>\n      Maximum occurrences: <count>\n"
    title: 19.4.  Options
  title: 19.  IANA Considerations
- contents:
  - "20.  Acknowledgments\n   Thanks to Xiaohong Deng, Alain Durand, Christian Jacquenet,
    Jacni\n   Qin, Simon Perreault, James Yu, Tina TSOU (Ting ZOU), Felipe Miranda\n
    \  Costa, James Woodyatt, Dave Thaler, Masataka Ohta, Vijay K. Gurbani,\n   Loa
    Andersson, Richard Barnes, Russ Housley, Adrian Farrel, Pete\n   Resnick, Pasi
    Sarolahti, Robert Sparks, Wesley Eddy, Dan Harkins,\n   Peter Saint-Andre, Stephen
    Farrell, Ralph Droms, Felipe Miranda\n   Costa, Amit Jain, and Wim Henderickx
    for their comments and review.\n   Thanks to Simon Perreault for highlighting
    the interaction of dynamic\n   connections with PCP-created mappings and for many
    other review\n   comments.\n   Thanks to Francis Dupont for his several thorough
    reviews of the\n   specification, which improved the protocol significantly.\n
    \  Thanks to T. S. Ranganathan for the state diagram.\n   Thanks to Peter Lothberg
    for clock skew information, which guided the\n   choice of tolerance levels for
    deciding when an Epoch time should be\n   considered to be anomalous.\n   Thanks
    to Margaret Wasserman and Sam Hartman for writing the Security\n   Considerations
    section.\n   Thanks to authors of DHCPv6 for retransmission text.\n"
  title: 20.  Acknowledgments
- contents:
  - '21.  References

    '
  - contents:
    - "21.1.  Normative References\n   [RFC0768]        Postel, J., \"User Datagram
      Protocol\", STD 6,\n                    RFC 768, August 1980.\n   [RFC2119]
      \       Bradner, S., \"Key words for use in RFCs to Indicate\n                    Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2827]        Ferguson, P. and
      D. Senie, \"Network Ingress\n                    Filtering: Defeating Denial
      of Service Attacks which\n                    employ IP Source Address Spoofing\",
      BCP 38,\n                    RFC 2827, May 2000.\n   [RFC4086]        Eastlake,
      D., Schiller, J., and S. Crocker,\n                    \"Randomness Requirements
      for Security\", BCP 106,\n                    RFC 4086, June 2005.\n   [RFC4193]
      \       Hinden, R. and B. Haberman, \"Unique Local IPv6\n                    Unicast
      Addresses\", RFC 4193, October 2005.\n   [RFC4291]        Hinden, R. and S.
      Deering, \"IP Version 6 Addressing\n                    Architecture\", RFC
      4291, February 2006.\n   [RFC5226]        Narten, T. and H. Alvestrand, \"Guidelines
      for\n                    Writing an IANA Considerations Section in RFCs\",\n
      \                   BCP 26, RFC 5226, May 2008.\n   [RFC6056]        Larsen,
      M. and F. Gont, \"Recommendations for\n                    Transport-Protocol
      Port Randomization\", BCP 156,\n                    RFC 6056, January 2011.\n
      \  [proto_numbers]  IANA, \"Protocol Numbers\", 2011,\n                    <http://www.iana.org/assignments/protocol-numbers>.\n"
    title: 21.1.  Normative References
  - contents:
    - "21.2.  Informative References\n   [IGDv1]          UPnP Gateway Committee,
      \"WANIPConnection:1\",\n                    November 2001, <http://upnp.org/specs/gw/\n
      \                   UPnP-gw-WANIPConnection-v1-Service.pdf>.\n   [L2NAT]          Miles,
      D. and M. Townsley, \"Layer2-Aware NAT\", Work\n                    in Progress,
      March 2009.\n   [PCP-FAIL]       Boucadair, M., Dupont, F., and R. Penno, \"Port\n
      \                   Control Protocol (PCP) Failure Scenarios\", Work\n                    in
      Progress, August 2012.\n   [PNP-IGD-PCP]    Boucadair, M., Penno, R., and D.
      Wing, \"Universal\n                    Plug and Play (UPnP) Internet Gateway
      Device (IGD)-\n                    Port Control Protocol (PCP) Interworking
      Function\",\n                    Work in Progress, December 2012.\n   [RFC0793]
      \       Postel, J., \"Transmission Control Protocol\", STD 7,\n                    RFC
      793, September 1981.\n   [RFC1918]        Rekhter, Y., Moskowitz, R., Karrenberg,
      D., Groot,\n                    G., and E. Lear, \"Address Allocation for Private\n
      \                   Internets\", BCP 5, RFC 1918, February 1996.\n   [RFC2136]
      \       Vixie, P., Thomson, S., Rekhter, Y., and J. Bound,\n                    \"Dynamic
      Updates in the Domain Name System (DNS\n                    UPDATE)\", RFC 2136,
      April 1997.\n   [RFC3007]        Wellington, B., \"Secure Domain Name System
      (DNS)\n                    Dynamic Update\", RFC 3007, November 2000.\n   [RFC3022]
      \       Srisuresh, P. and K. Egevang, \"Traditional IP\n                    Network
      Address Translator (Traditional NAT)\",\n                    RFC 3022, January
      2001.\n   [RFC3581]        Rosenberg, J. and H. Schulzrinne, \"An Extension
      to\n                    the Session Initiation Protocol (SIP) for Symmetric\n
      \                   Response Routing\", RFC 3581, August 2003.\n   [RFC3587]
      \       Hinden, R., Deering, S., and E. Nordmark, \"IPv6\n                    Global
      Unicast Address Format\", RFC 3587,\n                    August 2003.\n   [RFC4303]
      \       Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n                    RFC
      4303, December 2005.\n   [RFC4340]        Kohler, E., Handley, M., and S. Floyd,
      \"Datagram\n                    Congestion Control Protocol (DCCP)\", RFC 4340,\n
      \                   March 2006.\n   [RFC4787]        Audet, F. and C. Jennings,
      \"Network Address\n                    Translation (NAT) Behavioral Requirements
      for\n                    Unicast UDP\", BCP 127, RFC 4787, January 2007.\n   [RFC4941]
      \       Narten, T., Draves, R., and S. Krishnan, \"Privacy\n                    Extensions
      for Stateless Address Autoconfiguration\n                    in IPv6\", RFC
      4941, September 2007.\n   [RFC4960]        Stewart, R., \"Stream Control Transmission
      Protocol\",\n                    RFC 4960, September 2007.\n   [RFC4961]        Wing,
      D., \"Symmetric RTP / RTP Control Protocol\n                    (RTCP)\", BCP
      131, RFC 4961, July 2007.\n   [RFC5382]        Guha, S., Biswas, K., Ford, B.,
      Sivakumar, S., and\n                    P. Srisuresh, \"NAT Behavioral Requirements
      for TCP\",\n                    BCP 142, RFC 5382, October 2008.\n   [RFC6092]
      \       Woodyatt, J., \"Recommended Simple Security\n                    Capabilities
      in Customer Premises Equipment (CPE)\n                    for Providing Residential
      IPv6 Internet Service\",\n                    RFC 6092, January 2011.\n   [RFC6145]
      \       Li, X., Bao, C., and F. Baker, \"IP/ICMP Translation\n                    Algorithm\",
      RFC 6145, April 2011.\n   [RFC6146]        Bagnulo, M., Matthews, P., and I.
      van Beijnum,\n                    \"Stateful NAT64: Network Address and Protocol\n
      \                   Translation from IPv6 Clients to IPv4 Servers\",\n                    RFC
      6146, April 2011.\n   [RFC6296]        Wasserman, M. and F. Baker, \"IPv6-to-IPv6
      Network\n                    Prefix Translation\", RFC 6296, June 2011.\n   [RFC6333]
      \       Durand, A., Droms, R., Woodyatt, J., and Y. Lee,\n                    \"Dual-Stack
      Lite Broadband Deployments Following\n                    IPv4 Exhaustion\",
      RFC 6333, August 2011.\n   [RFC6619]        Arkko, J., Eggert, L., and M. Townsley,
      \"Scalable\n                    Operation of Address Translators with Per-Interface\n
      \                   Bindings\", RFC 6619, June 2012.\n   [RFC6763]        Cheshire,
      S. and M. Krochmal, \"DNS-Based Service\n                    Discovery\", RFC
      6763, February 2013.\n   [RFC6886]        Cheshire, S. and M. Krochmal, \"NAT
      Port Mapping\n                    Protocol (NAT-PMP)\", RFC 6886, April 2013.\n
      \  [RFC6888]        Perreault, S., Ed., Yamagata, I., Miyakawa, S.,\n                    Nakagawa,
      A., and H. Ashida, \"Common Requirements\n                    for Carrier-Grade
      NATs (CGNs)\", BCP 127, RFC 6888,\n                    April 2013.\n   [SCTPNAT]
      \       Stewart, R., Tuexen, M., and I. Ruengeler, \"Stream\n                    Control
      Transmission Protocol (SCTP) Network Address\n                    Translation\",
      Work in Progress, February 2013.\n"
    title: 21.2.  Informative References
  title: 21.  References
- contents:
  - "Appendix A.  NAT-PMP Transition\n   The Port Control Protocol (PCP) is a successor
    to the NAT Port\n   Mapping Protocol, NAT-PMP [RFC6886], and shares similar semantics,\n
    \  concepts, and packet formats.  Because of this, NAT-PMP and PCP both\n   use
    the same port and use NAT-PMP and PCP's version negotiation\n   capabilities to
    determine which version to use.  This section\n   describes how an orderly transition
    from NAT-PMP to PCP may be\n   achieved.\n   A client supporting both NAT-PMP
    and PCP SHOULD send its request\n   using the PCP packet format.  This will be
    received by a NAT-PMP\n   server or a PCP server.  If received by a NAT-PMP server,
    the\n   response will be UNSUPP_VERSION, as indicated by the NAT-PMP\n   specification
    [RFC6886], which will cause the client to downgrade to\n   NAT-PMP and resend
    its request in NAT-PMP format.  If received by a\n   PCP server, the response
    will be as described by this document and\n   processing continues as expected.\n
    \  A PCP server supporting both NAT-PMP and PCP can handle requests in\n   either
    format.  The first octet of the packet indicates if it is\n   NAT-PMP (first octet
    zero) or PCP (first octet non-zero).\n   A PCP-only gateway receiving a NAT-PMP
    request (identified by the\n   first octet being zero) will interpret the request
    as a version\n   mismatch.  Normal PCP processing will emit a PCP response that
    is\n   compatible with NAT-PMP, without any special handling by the PCP\n   server.\n"
  title: Appendix A.  NAT-PMP Transition
- contents:
  - "Authors' Addresses\n   Dan Wing (editor)\n   Cisco Systems, Inc.\n   170 West
    Tasman Drive\n   San Jose, California  95134\n   USA\n   EMail: dwing@cisco.com\n
    \  Stuart Cheshire\n   Apple Inc.\n   1 Infinite Loop\n   Cupertino, California
    \ 95014\n   USA\n   Phone: +1 408 974 3207\n   EMail: cheshire@apple.com\n   Mohamed
    Boucadair\n   France Telecom\n   Rennes  35000\n   France\n   EMail: mohamed.boucadair@orange.com\n
    \  Reinaldo Penno\n   Cisco Systems, Inc.\n   170 West Tasman Drive\n   San Jose,
    California  95134\n   USA\n   EMail: repenno@cisco.com\n   Paul Selkirk\n   Internet
    Systems Consortium\n   950 Charter Street\n   Redwood City, California  94063\n
    \  USA\n   EMail: pselkirk@isc.org\n"
  title: Authors' Addresses
