- contents:
  - '         Structure of Management Information Version 2 (SMIv2)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1 Introduction .................................................3\n
    \  1.1 A Note on Terminology ......................................4\n   2 Definitions
    ..................................................4\n   2.1 The MODULE-IDENTITY
    macro ..................................5\n   2.2 Object Names and Syntaxes ..................................5\n
    \  2.3 The OBJECT-TYPE macro ......................................8\n   2.5 The
    NOTIFICATION-TYPE macro ...............................10\n   2.6 Administrative
    Identifiers ................................11\n   3.2 IMPORTing Symbols .........................................14\n
    \  3.3 Exporting Symbols .........................................14\n   3.4 ASN.1
    Comments ............................................14\n   3.5 OBJECT IDENTIFIER
    values ..................................15\n   3.6 OBJECT IDENTIFIER usage ...................................15\n
    \  3.7 Reserved Keywords .........................................16\n   4 Naming
    Hierarchy ............................................16\n   5 Mapping of the
    MODULE-IDENTITY macro ........................17\n   5.1 Mapping of the LAST-UPDATED
    clause ........................17\n   5.2 Mapping of the ORGANIZATION clause ........................17\n
    \  5.3 Mapping of the CONTACT-INFO clause ........................18\n   5.4 Mapping
    of the DESCRIPTION clause .........................18\n   5.5 Mapping of the REVISION
    clause ............................18\n   5.5.1 Mapping of the DESCRIPTION sub-clause
    ...................18\n   5.6 Mapping of the MODULE-IDENTITY value ......................18\n
    \  5.7 Usage Example .............................................18\n   6 Mapping
    of the OBJECT-IDENTITY macro ........................19\n   6.1 Mapping of the
    STATUS clause ..............................19\n   6.2 Mapping of the DESCRIPTION
    clause .........................20\n   6.3 Mapping of the REFERENCE clause ...........................20\n
    \  6.4 Mapping of the OBJECT-IDENTITY value ......................20\n   6.5 Usage
    Example .............................................20\n   7 Mapping of the OBJECT-TYPE
    macro ............................20\n   7.1 Mapping of the SYNTAX clause ..............................21\n
    \  7.1.1 Integer32 and INTEGER ...................................21\n   7.1.2
    OCTET STRING ............................................21\n   7.1.3 OBJECT IDENTIFIER
    .......................................22\n   7.1.4 The BITS construct ......................................22\n
    \  7.1.5 IpAddress ...............................................22\n   7.1.6
    Counter32 ...............................................23\n   7.1.7 Gauge32
    .................................................23\n   7.1.8 TimeTicks ...............................................24\n
    \  7.1.9 Opaque ..................................................24\n   7.1.10
    Counter64 ..............................................24\n   7.1.11 Unsigned32
    .............................................25\n   7.1.12 Conceptual Tables ......................................25\n
    \  7.1.12.1 Creation and Deletion of Conceptual Rows .............26\n   7.2 Mapping
    of the UNITS clause ...............................26\n   7.3 Mapping of the MAX-ACCESS
    clause ..........................26\n   7.4 Mapping of the STATUS clause ..............................27\n
    \  7.5 Mapping of the DESCRIPTION clause .........................27\n   7.6 Mapping
    of the REFERENCE clause ...........................27\n   7.7 Mapping of the INDEX
    clause ...............................27\n   7.8 Mapping of the AUGMENTS clause
    ............................29\n   7.8.1 Relation between INDEX and AUGMENTS clauses
    .............30\n   8 Mapping of the NOTIFICATION-TYPE macro ......................34\n
    \  8.1 Mapping of the OBJECTS clause .............................34\n   8.2 Mapping
    of the STATUS clause ..............................34\n   8.3 Mapping of the DESCRIPTION
    clause .........................35\n   8.4 Mapping of the REFERENCE clause ...........................35\n
    \  8.5 Mapping of the NOTIFICATION-TYPE value ....................35\n   8.6 Usage
    Example .............................................35\n   9 Refined Syntax ..............................................36\n
    \  10 Extending an Information Module ............................37\n   10.1
    Object Assignments .......................................37\n   10.2 Object Definitions
    .......................................38\n   10.3 Notification Definitions .................................39\n
    \  11 Appendix A: Detailed Sub-typing Rules ......................40\n   11.1
    Syntax Rules .............................................40\n   11.2 Examples
    .................................................41\n   12 Security Considerations
    ....................................41\n   13 Editors' Addresses .........................................41\n
    \  14 References .................................................42\n   15 Full
    Copyright Statement ...................................43\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Management information is viewed as a collection of managed
    objects,\n   residing in a virtual information store, termed the Management\n
    \  Information Base (MIB).  Collections of related objects are defined\n   in
    MIB modules.  These modules are written using an adapted subset of\n   OSI's Abstract
    Syntax Notation One, ASN.1 (1988) [1].  It is the\n   purpose of this document,
    the Structure of Management Information\n   (SMI), to define that adapted subset,
    and to assign a set of\n   associated administrative values.\n   The SMI is divided
    into three parts:  module definitions, object\n   definitions, and, notification
    definitions.\n"
  - "(1)  Module definitions are used when describing information modules.\n     An
    ASN.1 macro, MODULE-IDENTITY, is used to concisely convey the\n     semantics
    of an information module.\n"
  - "(2)  Object definitions are used when describing managed objects.  An\n     ASN.1
    macro, OBJECT-TYPE, is used to concisely convey the syntax\n     and semantics
    of a managed object.\n"
  - "(3)  Notification definitions are used when describing unsolicited\n     transmissions
    of management information.  An ASN.1 macro,\n     NOTIFICATION-TYPE, is used to
    concisely convey the syntax and\n"
  - contents:
    - "1.1.  A Note on Terminology\n   For the purpose of exposition, the original
      Structure of Management\n   Information, as described in RFCs 1155 (STD 16),
      1212 (STD 16), and\n   RFC 1215, is termed the SMI version 1 (SMIv1).  The current
      version\n   of the Structure of Management Information is termed SMI version
      2\n   (SMIv2).\n"
    title: 1.1.  A Note on Terminology
  title: 1.  Introduction
- contents:
  - '2.  Definitions

    '
  - 'SNMPv2-SMI DEFINITIONS ::= BEGIN

    '
  - '-- the path to the root

    '
  - 'org            OBJECT IDENTIFIER ::= { iso 3 }  --  "iso" = 1

    '
  - 'dod            OBJECT IDENTIFIER ::= { org 6 }

    '
  - 'internet       OBJECT IDENTIFIER ::= { dod 1 }

    '
  - 'directory      OBJECT IDENTIFIER ::= { internet 1 }

    '
  - 'mgmt           OBJECT IDENTIFIER ::= { internet 2 }

    '
  - 'mib-2          OBJECT IDENTIFIER ::= { mgmt 1 }

    '
  - 'transmission   OBJECT IDENTIFIER ::= { mib-2 10 }

    '
  - 'experimental   OBJECT IDENTIFIER ::= { internet 3 }

    '
  - 'private        OBJECT IDENTIFIER ::= { internet 4 }

    '
  - 'enterprises    OBJECT IDENTIFIER ::= { private 1 }

    '
  - 'security       OBJECT IDENTIFIER ::= { internet 5 }

    '
  - 'snmpV2         OBJECT IDENTIFIER ::= { internet 6 }

    '
  - '-- transport domains

    '
  - 'snmpDomains    OBJECT IDENTIFIER ::= { snmpV2 1 }

    '
  - '-- transport proxies

    '
  - 'snmpProxys     OBJECT IDENTIFIER ::= { snmpV2 2 }

    '
  - '-- module identities

    '
  - 'snmpModules    OBJECT IDENTIFIER ::= { snmpV2 3 }

    '
  - '-- Extended UTCTime, to allow dates with four-digit years

    '
  - "-- (Note that this definition of ExtUTCTime is not to be IMPORTed\n    --   where:
    YY   - last two digits of year (only years\n    --                 between 1900-1999)\n
    \   --          YYYY - last four digits of the year (any year)\n    --          MM
    \  - month (01 through 12)\n    --          DD   - day of month (01 through 31)\n
    \   --          HH   - hours (00 through 23)\n    --          MM   - minutes (00
    through 59)\n    --          Z    - denotes GMT (the ASCII character Z)\n    --\n
    \   -- For example, \"9502192015Z\" and \"199502192015Z\" represent\n    -- 8:15pm
    GMT on 19 February 1995. Years after 1999 must use\n    -- the four digit year
    format. Years 1900-1999 may use the\n    -- two or four digit format.\n"
  - '-- definitions for information modules

    '
  - 'MODULE-IDENTITY MACRO ::=

    '
  - "BEGIN\n    TYPE NOTATION ::=\n                  \"LAST-UPDATED\" value(Update
    ExtUTCTime)\n                  \"ORGANIZATION\" Text\n                  \"CONTACT-INFO\"
    Text\n                  \"DESCRIPTION\" Text\n                  RevisionPart\n
    \   VALUE NOTATION ::=\n                  value(VALUE OBJECT IDENTIFIER)\n    RevisionPart
    ::=\n                  Revisions\n                | empty\n    Revisions ::=\n
    \                 Revision\n                | Revisions Revision\n    Revision
    ::=\n                  \"REVISION\" value(Update ExtUTCTime)\n                  \"DESCRIPTION\"
    Text\n    -- a character string as defined in section 3.1.1\n    Text ::= value(IA5String)\n"
  - 'END

    '
  - 'OBJECT-IDENTITY MACRO ::=

    '
  - "BEGIN\n                  ReferPart\n    VALUE NOTATION ::=\n                  value(VALUE
    OBJECT IDENTIFIER)\n    Status ::=\n                  \"current\"\n                |
    \"deprecated\"\n                | \"obsolete\"\n    ReferPart ::=\n                  \"REFERENCE\"
    Text\n                | empty\n    -- a character string as defined in section
    3.1.1\n    Text ::= value(IA5String)\n"
  - 'END

    '
  - '-- names of objects

    '
  - '-- (Note that these definitions of ObjectName and NotificationName

    '
  - '--  are not to be IMPORTed by MIB modules.)

    '
  - "ObjectName ::=\n    OBJECT IDENTIFIER\n"
  - "NotificationName ::=\n    OBJECT IDENTIFIER\n"
  - '-- syntax of objects

    '
  - '-- the "base types" defined here are:

    '
  - '--   3 built-in ASN.1 types: INTEGER, OCTET STRING, OBJECT IDENTIFIER

    '
  - '--   8 application-defined types: Integer32, IpAddress, Counter32,

    '
  - '--              Gauge32, Unsigned32, TimeTicks, Opaque, and Counter64

    '
  - "ObjectSyntax ::=\n    CHOICE {\n        simple\n            SimpleSyntax,\n          --
    note that SEQUENCEs for conceptual tables and\n          -- rows are not mentioned
    here...\n        application-wide\n"
  - '-- built-in ASN.1 types

    '
  - "SimpleSyntax ::=\n    CHOICE {\n        -- INTEGERs with a more restrictive range\n
    \       -- may also be used\n        integer-value               -- includes Integer32\n
    \           INTEGER (-2147483648..2147483647),\n        -- OCTET STRINGs with
    a more restrictive size\n        -- may also be used\n        string-value\n            OCTET
    STRING (SIZE (0..65535)),\n        objectID-value\n            OBJECT IDENTIFIER\n
    \   }\n"
  - '-- indistinguishable from INTEGER, but never needs more than

    '
  - '-- 32-bits for a two''s complement representation

    '
  - "Integer32 ::=\n        INTEGER (-2147483648..2147483647)\n"
  - '-- application-wide types

    '
  - "ApplicationSyntax ::=\n    CHOICE {\n        ipAddress-value\n            IpAddress,\n
    \       counter-value\n            Counter32,\n        timeticks-value\n            TimeTicks,\n
    \       arbitrary-value\n            Opaque,\n        big-counter-value\n            Counter64,\n
    \       unsigned-integer-value  -- includes Gauge32\n            Unsigned32\n"
  - '-- (this is a tagged type for historical reasons)

    '
  - "IpAddress ::=\n    [APPLICATION 0]\n        IMPLICIT OCTET STRING (SIZE (4))\n"
  - '-- this wraps

    '
  - "Counter32 ::=\n    [APPLICATION 1]\n        IMPLICIT INTEGER (0..4294967295)\n"
  - '-- this doesn''t wrap

    '
  - "Gauge32 ::=\n    [APPLICATION 2]\n        IMPLICIT INTEGER (0..4294967295)\n"
  - '-- an unsigned 32-bit quantity

    '
  - '-- indistinguishable from Gauge32

    '
  - "Unsigned32 ::=\n    [APPLICATION 2]\n        IMPLICIT INTEGER (0..4294967295)\n"
  - '-- hundredths of seconds since an epoch

    '
  - "TimeTicks ::=\n    [APPLICATION 3]\n        IMPLICIT INTEGER (0..4294967295)\n"
  - '-- for backward-compatibility only

    '
  - "Opaque ::=\n    [APPLICATION 4]\n        IMPLICIT OCTET STRING\n"
  - '-- for counters that wrap in less than one hour with only 32 bits

    '
  - "Counter64 ::=\n    [APPLICATION 6]\n        IMPLICIT INTEGER (0..18446744073709551615)\n"
  - '-- definition for objects

    '
  - 'OBJECT-TYPE MACRO ::=

    '
  - "BEGIN\n    TYPE NOTATION ::=\n                  \"SYNTAX\" Syntax\n                  UnitsPart\n
    \                 \"MAX-ACCESS\" Access\n                  IndexPart\n                  DefValPart\n
    \   VALUE NOTATION ::=\n                  value(VALUE ObjectName)\n    Syntax
    ::=   -- Must be one of the following:\n                       -- a base type
    (or its refinement),\n                       -- a textual convention (or its refinement),
    or\n                       -- a BITS pseudo-type\n                   type\n                |
    \"BITS\" \"{\" NamedBits \"}\"\n    NamedBits ::= NamedBit\n                |
    NamedBits \",\" NamedBit\n    NamedBit ::=  identifier \"(\" number \")\" -- number
    is nonnegative\n    UnitsPart ::=\n                  \"UNITS\" Text\n                |
    empty\n    Access ::=\n                  \"not-accessible\"\n                |
    \"accessible-for-notify\"\n                | \"read-only\"\n                |
    \"read-write\"\n                | \"read-create\"\n    Status ::=\n                  \"current\"\n
    \               | \"deprecated\"\n                | \"obsolete\"\n    ReferPart
    ::=\n                  \"REFERENCE\" Text\n                | empty\n    IndexPart
    ::=\n                  \"INDEX\"    \"{\" IndexTypes \"}\"\n                |
    \"AUGMENTS\" \"{\" Entry      \"}\"\n                | empty\n    IndexTypes ::=\n
    \                 IndexType\n                | IndexTypes \",\" IndexType\n    Index
    ::=\n                    -- use the SYNTAX value of the\n                    --
    correspondent OBJECT-TYPE invocation\n                  value(ObjectName)\n    Entry
    ::=\n                    -- use the INDEX value of the\n                    --
    correspondent OBJECT-TYPE invocation\n                  value(ObjectName)\n    DefValPart
    ::= \"DEFVAL\" \"{\" Defvalue \"}\"\n                | empty\n    Defvalue ::=
    \ -- must be valid for the type specified in\n                  -- SYNTAX clause
    of same OBJECT-TYPE macro\n                  value(ObjectSyntax)\n                |
    \"{\" BitsValue \"}\"\n    BitsValue ::= BitNames\n                | empty\n    BitNames
    ::=  BitName\n                | BitNames \",\" BitName\n    BitName ::= identifier\n
    \   -- a character string as defined in section 3.1.1\n    Text ::= value(IA5String)\n"
  - 'END

    '
  - '-- definitions for notifications

    '
  - 'NOTIFICATION-TYPE MACRO ::=

    '
  - "BEGIN\n    TYPE NOTATION ::=\n                  ObjectsPart\n                  \"STATUS\"
    Status\n                  \"DESCRIPTION\" Text\n                  ReferPart\n
    \   VALUE NOTATION ::=\n                  value(VALUE NotificationName)\n    ObjectsPart
    ::=\n                  \"OBJECTS\" \"{\" Objects \"}\"\n                | Objects
    \",\" Object\n    Object ::=\n                  value(ObjectName)\n    Status
    ::=\n                  \"current\"\n                | \"deprecated\"\n                |
    \"obsolete\"\n    ReferPart ::=\n                  \"REFERENCE\" Text\n                |
    empty\n    -- a character string as defined in section 3.1.1\n    Text ::= value(IA5String)\n"
  - 'END

    '
  - '-- definitions of administrative identifiers

    '
  - "zeroDotZero    OBJECT-IDENTITY\n    STATUS     current\n    DESCRIPTION\n            \"A
    value used for null identifiers.\"\n    ::= { 0 0 }\n"
  - 'END

    '
  title: 2.  Definitions
- contents:
  - "3.  Information Modules\n   An \"information module\" is an ASN.1 module defining
    information\n   relating to network management.\n   The SMI describes how to use
    an adapted subset of ASN.1 (1988) to\n   define an information module.  Further,
    additional restrictions are\n   placed on \"standard\" information modules.  It
    is strongly recommended\n   that \"enterprise-specific\" information modules also
    adhere to these\n   restrictions.\n   Typically, there are three kinds of information
    modules:\n"
  - "(1)  MIB modules, which contain definitions of inter-related managed\n     objects,
    make use of the OBJECT-TYPE and NOTIFICATION-TYPE macros;\n"
  - "(2)  compliance statements for MIB modules, which make use of the\n     MODULE-COMPLIANCE
    and OBJECT-GROUP macros [2]; and,\n   This classification scheme does not imply
    a rigid taxonomy.  For\n   example, a \"standard\" information module will normally
    include\n   definitions of managed objects and a compliance statement.\n   Similarly,
    an \"enterprise-specific\" information module might include\n   definitions of
    managed objects and a capability statement.  Of\n   course, a \"standard\" information
    module may not contain capability\n   statements.\n   The constructs of ASN.1
    allowed in SMIv2 information modules include:\n   the IMPORTS clause, value definitions
    for OBJECT IDENTIFIERs, type\n   definitions for SEQUENCEs (with restrictions),
    ASN.1 type assignments\n   of the restricted ASN.1 types allowed in SMIv2, and
    instances of\n   ASN.1 macros defined in this document and its companion documents
    [2,\n   3].  Additional ASN.1 macros must not be defined in SMIv2 information\n
    \  modules.  SMIv1 macros must not be used in SMIv2 information modules.\n   The
    names of all standard information modules must be unique (but\n   different versions
    of the same information module should have the\n   same name).  Developers of
    enterprise information modules are\n   encouraged to choose names for their information
    modules that will\n   have a low probability of colliding with standard or other
    enterprise\n   information modules. An information module may not use the ASN.1\n
    \  construct of placing an object identifier value between the module\n   name
    and the \"DEFINITIONS\" keyword.  For the purposes of this\n   specification,
    an ASN.1 module name begins with an upper-case letter\n   and continues with zero
    or more letters, digits, or hyphens, except\n   that a hyphen can not be the last
    character, nor can there be two\n   consecutive hyphens.\n   All information modules
    start with exactly one invocation of the\n   MODULE-IDENTITY macro, which provides
    contact information as well as\n   revision history to distinguish between versions
    of the same\n   information module.  This invocation must appear immediately after\n
    \  any IMPORTs statements.\n"
  - contents:
    - "3.1.  Macro Invocation\n   Within an information module, each macro invocation
      appears as:\n        <descriptor> <macro> <clauses> ::= <value>\n   where <descriptor>
      corresponds to an ASN.1 identifier, <macro> names\n   the macro being invoked,
      and <clauses> and <value> depend on the\n   definition of the macro.  (Note
      that this definition of a descriptor\n   applies to all macros defined in this
      memo and in [2].)\n   For the purposes of this specification, an ASN.1 identifier
      consists\n   of one or more letters or digits, and its initial character must
      be a\n   lower-case letter.  Note that hyphens are not allowed by this\n   specification
      (except for use by information modules converted from\n   SMIv1 which did allow
      hyphens).\n   For all descriptors appearing in an information module, the\n
      \  descriptor shall be unique and mnemonic, and shall not exceed 64\n   characters
      in length.  (However, descriptors longer than 32\n   characters are not recommended.)
      \ This promotes a common language for\n   humans to use when discussing the
      information module and also\n   facilitates simple table mappings for user-interfaces.\n
      \  The set of descriptors defined in all \"standard\" information modules\n
      \  shall be unique.\n   Finally, by convention, if the descriptor refers to
      an object with a\n   SYNTAX clause value of either Counter32 or Counter64, then
      the\n   descriptor used for the object should denote plurality.\n"
    - contents:
      - "3.1.1.  Textual Values and Strings\n   Some clauses in a macro invocation
        may take a character string as a\n   textual value (e.g., the DESCRIPTION
        clause).  Other clauses take\n   binary or hexadecimal strings (in any position
        where a non-negative\n   number is allowed).\n   A character string is preceded
        and followed by the quote character\n   (\"), and consists of an arbitrary
        number (possibly zero) of:\n      - any 7-bit displayable ASCII characters
        except quote (\"),\n      - tab characters,\n      - spaces, and\n      -
        line terminator characters (\\n or \\r\\n).\n   The value of a character string
        is interpreted as ASCII.\n   A binary string consists of a number (possibly
        zero) of zeros and\n   ones preceded by a single (') and followed by either
        the pair ('B) or\n   ('b), where the number is a multiple of eight.\n   A
        hexadecimal string consists of an even number (possibly zero) of\n   hexadecimal
        digits, preceded by a single (') and followed by either\n   the pair ('H)
        or ('h).  Digits specified via letters can be in upper\n   or lower case.\n"
      title: 3.1.1.  Textual Values and Strings
    title: 3.1.  Macro Invocation
  - contents:
    - "3.2.  IMPORTing Symbols\n   To reference an external object, the IMPORTS statement
      must be used\n   to identify both the descriptor and the module in which the\n
      \  descriptor is defined, where the module is identified by its ASN.1\n   module
      name.\n   Note that when symbols from \"enterprise-specific\" information modules\n
      \  are referenced  (e.g., a descriptor), there is the possibility of\n   collision.
      \ As such, if different objects with the same descriptor\n   are IMPORTed, then
      this ambiguity is resolved by prefixing the\n   descriptor with the name of
      the information module and a dot (\".\"),\n   i.e.,\n        \"module.descriptor\"\n
      \  (All descriptors must be unique within any information module.)\n   Of course,
      this notation can be used to refer to objects even when\n   there is no collision
      when IMPORTing symbols.\n   Finally, if any of the ASN.1 named types and macros
      defined in this\n   document, specifically:\n        Counter32, Counter64, Gauge32,
      Integer32, IpAddress, MODULE-\n        IDENTITY, NOTIFICATION-TYPE, Opaque,
      OBJECT-TYPE, OBJECT-\n        IDENTITY, TimeTicks, Unsigned32,\n   or any of
      those defined in [2] or [3], are used in an information\n   module, then they
      must be imported using the IMPORTS statement.\n   However, the following must
      not be included in an IMPORTS statement:\n      - named types defined by ASN.1
      itself, specifically: INTEGER,\n        OCTET STRING, OBJECT IDENTIFIER, SEQUENCE,
      SEQUENCE OF type,\n      - the BITS construct.\n"
    title: 3.2.  IMPORTing Symbols
  - contents:
    - "3.3.  Exporting Symbols\n   The ASN.1 EXPORTS statement is not allowed in SMIv2
      information\n   modules.  All items defined in an information module are\n   automatically
      exported.\n"
    title: 3.3.  Exporting Symbols
  - contents:
    - "3.4.  ASN.1 Comments\n   ASN.1 comments can be included in an information module.
      \ However, it\n   ASN.1 comments commence with a pair of adjacent hyphens and
      end with\n   the next pair of adjacent hyphens or at the end of the line,\n
      \  whichever occurs first.  Comments ended by a pair of hyphens have the\n   effect
      of a single space character.\n"
    title: 3.4.  ASN.1 Comments
  - contents:
    - "3.5.  OBJECT IDENTIFIER values\n   An OBJECT IDENTIFIER value is an ordered
      list of non-negative\n   numbers.  For the SMIv2, each number in the list is
      referred to as a\n   sub-identifier, there are at most 128 sub-identifiers in
      a value, and\n   each sub-identifier has a maximum value of 2^32-1 (4294967295\n
      \  decimal).\n   All OBJECT IDENTIFIER values have at least two sub-identifiers,
      where\n   the value of the first sub-identifier is one of the following well-\n
      \  known names:\n        Value   Name\n          0     ccitt\n          1     iso\n
      \         2     joint-iso-ccitt\n   (Note that this SMI does not recognize \"new\"
      well-known names, e.g.,\n   as defined when the CCITT became the ITU.)\n"
    title: 3.5.  OBJECT IDENTIFIER values
  - contents:
    - "3.6.  OBJECT IDENTIFIER usage\n   OBJECT IDENTIFIERs are used in information
      modules in two ways:\n"
    - "(1)  registration: the definition of a particular item is registered as\n     a
      particular OBJECT IDENTIFIER value, and associated with a\n     particular descriptor.
      \ After such a registration, the semantics\n     thereby associated with the
      value are not allowed to change, the\n     OBJECT IDENTIFIER can not be used
      for any other registration, and\n     the descriptor can not be changed nor
      associated with any other\n     registration.  The following macros result in
      a registration:\n          OBJECT-TYPE, MODULE-IDENTITY, NOTIFICATION-TYPE,
      OBJECT-GROUP,\n          OBJECT-IDENTITY, NOTIFICATION-GROUP, MODULE-COMPLIANCE,\n
      \         AGENT-CAPABILITIES.\n"
    - "(2)  assignment: a descriptor can be assigned to a particular OBJECT\n     IDENTIFIER
      value.  For this usage, the semantics associated with\n     the OBJECT IDENTIFIER
      value is not allowed to change, and a\n     descriptor assigned to a particular
      OBJECT IDENTIFIER value cannot\n          mib         OBJECT IDENTIFIER ::=
      { mgmt 1 }  -- from RFC1156\n          mib-2       OBJECT IDENTIFIER ::= { mgmt
      1 }  -- from RFC1213\n          fredRouter  OBJECT IDENTIFIER ::= { flintStones
      1 1 }\n          barneySwitch OBJECT IDENTIFIER ::= { flintStones bedrock(2)
      1 }\n     Note while the above examples are legal, the following is not:\n          dinoHost
      OBJECT IDENTIFIER ::= { flintStones bedrock 2 }\n   A descriptor is allowed
      to be associated with both a registration and\n   an assignment, providing both
      are associated with the same OBJECT\n   IDENTIFIER value and semantics.\n"
    title: 3.6.  OBJECT IDENTIFIER usage
  - contents:
    - "3.7.  Reserved Keywords\n   The following are reserved keywords which must
      not be used as\n   descriptors or module names:\n        ABSENT ACCESS AGENT-CAPABILITIES
      ANY APPLICATION AUGMENTS BEGIN\n        BIT BITS BOOLEAN BY CHOICE COMPONENT
      COMPONENTS CONTACT-INFO\n        CREATION-REQUIRES Counter32 Counter64 DEFAULT
      DEFINED\n        DEFINITIONS DEFVAL DESCRIPTION DISPLAY-HINT END ENUMERATED\n
      \       ENTERPRISE EXPLICIT EXPORTS EXTERNAL FALSE FROM GROUP Gauge32\n        IDENTIFIER
      IMPLICIT IMPLIED IMPORTS INCLUDES INDEX INTEGER\n        Integer32 IpAddress
      LAST-UPDATED MANDATORY-GROUPS MAX MAX-ACCESS\n        MIN MIN-ACCESS MINUS-INFINITY
      MODULE MODULE-COMPLIANCE MODULE-\n        IDENTITY NOTIFICATION-GROUP NOTIFICATION-TYPE
      NOTIFICATIONS NULL\n        OBJECT OBJECT-GROUP OBJECT-IDENTITY OBJECT-TYPE
      OBJECTS OCTET OF\n        OPTIONAL ORGANIZATION Opaque PLUS-INFINITY PRESENT
      PRIVATE\n        PRODUCT-RELEASE REAL REFERENCE REVISION SEQUENCE SET SIZE STATUS\n
      \       STRING SUPPORTS SYNTAX TAGS TEXTUAL-CONVENTION TRAP-TYPE TRUE\n        TimeTicks
      UNITS UNIVERSAL Unsigned32 VARIABLES VARIATION WITH\n        WRITE-SYNTAX\n"
    title: 3.7.  Reserved Keywords
  title: 3.  Information Modules
- contents:
  - "4.  Naming Hierarchy\n   The root of the subtree administered by the Internet
    Assigned Numbers\n   Authority (IANA) for the Internet is:\n        internet       OBJECT
    IDENTIFIER ::= { iso 3 6 1 }\n   That is, the Internet subtree of OBJECT IDENTIFIERs
    starts with the\n   prefix:\n        1.3.6.1.\n        mgmt           OBJECT IDENTIFIER
    ::= { internet 2 }\n        experimental   OBJECT IDENTIFIER ::= { internet 3
    }\n        private        OBJECT IDENTIFIER ::= { internet 4 }\n        enterprises
    \   OBJECT IDENTIFIER ::= { private 1 }\n   However, the SMI does not prohibit
    the definition of objects in other\n   portions of the object tree.\n   The mgmt(2)
    subtree is used to identify \"standard\" objects.\n   The experimental(3) subtree
    is used to identify objects being\n   designed by working groups of the IETF.
    \ If an information module\n   produced by a working group becomes a \"standard\"
    information module,\n   then at the very beginning of its entry onto the Internet
    standards\n   track, the objects are moved under the mgmt(2) subtree.\n   The
    private(4) subtree is used to identify objects defined\n   unilaterally.  The
    enterprises(1) subtree beneath private is used,\n   among other things, to permit
    providers of networking subsystems to\n   register models of their products.\n"
  title: 4.  Naming Hierarchy
- contents:
  - "5.  Mapping of the MODULE-IDENTITY macro\n   The MODULE-IDENTITY macro is used
    to provide contact and revision\n   history for each information module.  It must
    appear exactly once in\n   every information module.  It should be noted that
    the expansion of\n   the MODULE-IDENTITY macro is something which conceptually
    happens\n   during implementation and not during run-time.\n   Note that reference
    in an IMPORTS clause or in clauses of SMIv2\n   macros to an information module
    is NOT through the use of the\n   'descriptor' of a MODULE-IDENTITY macro; rather,
    an information\n   module is referenced through specifying its module name.\n"
  - contents:
    - "5.1.  Mapping of the LAST-UPDATED clause\n   The LAST-UPDATED clause, which
      must be present, contains the date and\n   time that this information module
      was last edited.\n"
    title: 5.1.  Mapping of the LAST-UPDATED clause
  - contents:
    - "5.2.  Mapping of the ORGANIZATION clause\n   The ORGANIZATION clause, which
      must be present, contains a textual\n   description of the organization under
      whose auspices this information\n   module was developed.\n"
    title: 5.2.  Mapping of the ORGANIZATION clause
  - contents:
    - "5.3.  Mapping of the CONTACT-INFO clause\n   The CONTACT-INFO clause, which
      must be present, contains the name,\n   postal address, telephone number, and
      electronic mail address of the\n   person to whom technical queries concerning
      this information module\n   should be sent.\n"
    title: 5.3.  Mapping of the CONTACT-INFO clause
  - contents:
    - "5.4.  Mapping of the DESCRIPTION clause\n   The DESCRIPTION clause, which must
      be present, contains a high-level\n   textual description of the contents of
      this information module.\n"
    title: 5.4.  Mapping of the DESCRIPTION clause
  - contents:
    - "5.5.  Mapping of the REVISION clause\n   The REVISION clause, which need not
      be present, is repeatedly used to\n   describe the revisions (including the
      initial version) made to this\n   information module, in reverse chronological
      order (i.e., most recent\n   first).  Each instance of this clause contains
      the date and time of\n   the revision.\n"
    - contents:
      - "5.5.1.  Mapping of the DESCRIPTION sub-clause\n   The DESCRIPTION sub-clause,
        which must be present for each REVISION\n   clause, contains a high-level
        textual description of the revision\n   identified in that REVISION clause.\n"
      title: 5.5.1.  Mapping of the DESCRIPTION sub-clause
    title: 5.5.  Mapping of the REVISION clause
  - contents:
    - "5.6.  Mapping of the MODULE-IDENTITY value\n   The value of an invocation of
      the MODULE-IDENTITY macro is an OBJECT\n   IDENTIFIER.  As such, this value
      may be authoritatively used when\n   specifying an OBJECT IDENTIFIER value to
      refer to the information\n   module containing the invocation.\n   Note that
      it is a common practice to use the value of the MODULE-\n   IDENTITY macro as
      a subtree under which other OBJECT IDENTIFIER\n   values assigned within the
      module are defined.  However, it is legal\n   (and occasionally necessary) for
      the other OBJECT IDENTIFIER values\n   assigned within the module to be unrelated
      to the OBJECT IDENTIFIER\n   value of the MODULE-IDENTITY macro.\n"
    title: 5.6.  Mapping of the MODULE-IDENTITY value
  - contents:
    - "5.7.  Usage Example\n   Consider how a skeletal MIB module might be constructed:
      \ e.g.,\n   FIZBIN-MIB DEFINITIONS ::= BEGIN\n           FROM SNMPv2-SMI;\n
      \  fizbin MODULE-IDENTITY\n       LAST-UPDATED \"199505241811Z\"\n       ORGANIZATION
      \"IETF SNMPv2 Working Group\"\n       CONTACT-INFO\n               \"        Marshall
      T. Rose\n                Postal: Dover Beach Consulting, Inc.\n                        420
      Whisman Court\n                        Mountain View, CA  94043-2186\n                        US\n
      \                  Tel: +1 415 968 1052\n                   Fax: +1 415 968
      2510\n                E-mail: mrose@dbc.mtview.ca.us\"\n       DESCRIPTION\n
      \              \"The MIB module for entities implementing the xxxx\n               protocol.\"\n
      \      REVISION      \"9505241811Z\"\n       DESCRIPTION\n               \"The
      latest version of this MIB module.\"\n       REVISION      \"9210070433Z\"\n
      \      DESCRIPTION\n               \"The initial version of this MIB module,
      published in\n               RFC yyyy.\"\n   -- contact IANA for actual number\n
      \      ::= { experimental xx }\n   END\n"
    title: 5.7.  Usage Example
  title: 5.  Mapping of the MODULE-IDENTITY macro
- contents:
  - "6.  Mapping of the OBJECT-IDENTITY macro\n   The OBJECT-IDENTITY macro is used
    to define information about an\n   OBJECT IDENTIFIER assignment.  All administrative
    OBJECT IDENTIFIER\n   assignments which define a type identification value (see\n
    \  AutonomousType, a textual convention defined in [3]) should be\n   defined
    via the OBJECT-IDENTITY macro.  It should be noted that the\n   expansion of the
    OBJECT-IDENTITY macro is something which\n   conceptually happens during implementation
    and not during run-time.\n"
  - contents:
    - "6.1.  Mapping of the STATUS clause\n   The value \"current\" means that the
      definition is current and valid.\n   The value \"obsolete\" means the definition
      is obsolete and should not\n   be implemented and/or can be removed if previously
      implemented.\n   While the value \"deprecated\" also indicates an obsolete definition,\n
      \  it permits new/continued implementation in order to foster\n   interoperability
      with older/existing implementations.\n"
    title: 6.1.  Mapping of the STATUS clause
  - contents:
    - "6.2.  Mapping of the DESCRIPTION clause\n   The DESCRIPTION clause, which must
      be present, contains a textual\n   description of the object assignment.\n"
    title: 6.2.  Mapping of the DESCRIPTION clause
  - contents:
    - "6.3.  Mapping of the REFERENCE clause\n   The REFERENCE clause, which need
      not be present, contains a textual\n   cross-reference to some other document,
      either another information\n   module which defines a related assignment, or
      some other document\n   which provides additional information relevant to this
      definition.\n"
    title: 6.3.  Mapping of the REFERENCE clause
  - contents:
    - "6.4.  Mapping of the OBJECT-IDENTITY value\n   The value of an invocation of
      the OBJECT-IDENTITY macro is an OBJECT\n   IDENTIFIER.\n"
    title: 6.4.  Mapping of the OBJECT-IDENTITY value
  - contents:
    - "6.5.  Usage Example\n   Consider how an OBJECT IDENTIFIER assignment might
      be made:  e.g.,\n   fizbin69 OBJECT-IDENTITY\n       STATUS  current\n       DESCRIPTION\n
      \              \"The authoritative identity of the Fizbin 69 chipset.\"\n      ::=
      { fizbinChipSets 1 }\n"
    title: 6.5.  Usage Example
  title: 6.  Mapping of the OBJECT-IDENTITY macro
- contents:
  - "7.  Mapping of the OBJECT-TYPE macro\n   The OBJECT-TYPE macro is used to define
    a type of managed object.  It\n   should be noted that the expansion of the OBJECT-TYPE
    macro is\n   something which conceptually happens during implementation and not\n
    \  during run-time.\n   For leaf objects which are not columnar objects (i.e.,
    not contained\n   within a conceptual table), instances of the object are identified
    by\n   appending a sub-identifier of zero to the name of that object.\n   Otherwise,
    the INDEX clause of the conceptual row object superior to\n"
  - contents:
    - "7.1.  Mapping of the SYNTAX clause\n   The SYNTAX clause, which must be present,
      defines the abstract data\n   structure corresponding to that object.  The data
      structure must be\n   one of the following: a base type, the BITS construct,
      or a textual\n   convention.  (SEQUENCE OF and SEQUENCE are also possible for\n
      \  conceptual tables, see section 7.1.12).  The base types are those\n   defined
      in the ObjectSyntax CHOICE.  A textual convention is a\n   newly-defined type
      defined as a sub-type of a base type [3].\n   An extended subset of the full
      capabilities of ASN.1 (1988) sub-\n   typing is allowed, as appropriate to the
      underlying ASN.1 type.  Any\n   such restriction on size, range or enumerations
      specified in this\n   clause represents the maximal level of support which makes
      \"protocol\n   sense\".  Restrictions on sub-typing are specified in detail
      in\n   Section 9 and Appendix A of this memo.\n   The semantics of ObjectSyntax
      are now described.\n"
    - contents:
      - "7.1.1.  Integer32 and INTEGER\n   The Integer32 type represents integer-valued
        information between\n   -2^31 and 2^31-1 inclusive (-2147483648 to 2147483647
        decimal).  This\n   type is indistinguishable from the INTEGER type.  Both
        the INTEGER\n   and Integer32 types may be sub-typed to be more constrained
        than the\n   Integer32 type.\n   The INTEGER type (but not the Integer32 type)
        may also be used to\n   represent integer-valued information as named-number
        enumerations.\n   In this case, only those named-numbers so enumerated may
        be present\n   as a value.  Note that although it is recommended that enumerated\n
        \  values start at 1 and be numbered contiguously, any valid value for\n   Integer32
        is allowed for an enumerated value and, further, enumerated\n   values needn't
        be contiguously assigned.\n   Finally, a label for a named-number enumeration
        must consist of one\n   or more letters or digits, up to a maximum of 64 characters,
        and the\n   initial character must be a lower-case letter.  (However, labels\n
        \  longer than 32 characters are not recommended.)  Note that hyphens\n   are
        not allowed by this specification (except for use by information\n   modules
        converted from SMIv1 which did allow hyphens).\n"
      title: 7.1.1.  Integer32 and INTEGER
    - contents:
      - "7.1.2.  OCTET STRING\n   The OCTET STRING type represents arbitrary binary
        or textual data.\n"
      title: 7.1.2.  OCTET STRING
    - contents:
      - "7.1.3.  OBJECT IDENTIFIER\n   The OBJECT IDENTIFIER type represents administratively
        assigned\n   names.  Any instance of this type may have at most 128 sub-\n
        \  identifiers.  Further, each sub-identifier must not exceed the value\n
        \  2^32-1 (4294967295 decimal).\n"
      title: 7.1.3.  OBJECT IDENTIFIER
    - contents:
      - "7.1.4.  The BITS construct\n   The BITS construct represents an enumeration
        of named bits.  This\n   collection is assigned non-negative, contiguous (but
        see below)\n   values, starting at zero.  Only those named-bits so enumerated
        may be\n   present in a value.  (Thus, enumerations must be assigned to\n
        \  consecutive bits; however, see Section 9 for refinements of an object\n
        \  with this syntax.)\n   As part of updating an information module, for an
        object defined\n   using the BITS construct, new enumerations can be added
        or existing\n   enumerations can have new labels assigned to them.  After
        an\n   enumeration is added, it might not be possible to distinguish between\n
        \  an implementation of the updated object for which the new enumeration\n
        \  is not asserted, and an implementation of the object prior to the\n   addition.
        \ Depending on the circumstances, such an ambiguity could\n   either be desirable
        or could be undesirable.  The means to avoid such\n   an ambiguity is dependent
        on the encoding of values on the wire;\n   however, one possibility is to
        define new enumerations starting at\n   the next multiple of eight bits.  (Of
        course, this can also result in\n   the enumerations no longer being contiguous.)\n
        \  Although there is no SMI-specified limitation on the number of\n   enumerations
        (and therefore on the length of a value), except as may\n   be imposed by
        the limit on the length of an OCTET STRING, MIB\n   designers should realize
        that there may be implementation and\n   interoperability limitations for
        sizes in excess of 128 bits.\n   Finally, a label for a named-number enumeration
        must consist of one\n   or more letters or digits, up to a maximum of 64 characters,
        and the\n   initial character must be a lower-case letter.  (However, labels\n
        \  longer than 32 characters are not recommended.)  Note that hyphens\n   are
        not allowed by this specification.\n"
      title: 7.1.4.  The BITS construct
    - contents:
      - "7.1.5.  IpAddress\n   The IpAddress type represents a 32-bit internet address.
        \ It is\n   represented as an OCTET STRING of length 4, in network byte-order.\n
        \  Note that the IpAddress type is a tagged type for historical reasons.\n
        \  Network addresses should be represented using an invocation of the\n   TEXTUAL-CONVENTION
        macro [3].\n"
      title: 7.1.5.  IpAddress
    - contents:
      - "7.1.6.  Counter32\n   The Counter32 type represents a non-negative integer
        which\n   monotonically increases until it reaches a maximum value of 2^32-1\n
        \  (4294967295 decimal), when it wraps around and starts increasing\n   again
        from zero.\n   Counters have no defined \"initial\" value, and thus, a single
        value of\n   a Counter has (in general) no information content.  Discontinuities\n
        \  in the monotonically increasing value normally occur at re-\n   initialization
        of the management system, and at other times as\n   specified in the description
        of an object-type using this ASN.1 type.\n   If such other times can occur,
        for example, the creation of an object\n   instance at times other than re-initialization,
        then a corresponding\n   object should be defined, with an appropriate SYNTAX
        clause, to\n   indicate the last discontinuity.  Examples of appropriate SYNTAX\n
        \  clause include:  TimeStamp (a textual convention defined in [3]),\n   DateAndTime
        (another textual convention from [3]) or TimeTicks.\n   The value of the MAX-ACCESS
        clause for objects with a SYNTAX clause\n   value of Counter32 is either \"read-only\"
        or \"accessible-for-notify\".\n   A DEFVAL clause is not allowed for objects
        with a SYNTAX clause value\n   of Counter32.\n"
      title: 7.1.6.  Counter32
    - contents:
      - "7.1.7.  Gauge32\n   The Gauge32 type represents a non-negative integer, which
        may\n   increase or decrease, but shall never exceed a maximum value, nor\n
        \  fall below a minimum value.  The maximum value can not be greater\n   than
        2^32-1 (4294967295 decimal), and the minimum value can not be\n   smaller
        than 0.  The value of a Gauge32 has its maximum value\n   whenever the information
        being modeled is greater than or equal to\n   its maximum value, and has its
        minimum value whenever the information\n   being modeled is smaller than or
        equal to its minimum value.  If the\n   information being modeled subsequently
        decreases below (increases\n   above) the maximum (minimum) value, the Gauge32
        also decreases\n   (increases).  (Note that despite of the use of the term
        \"latched\" in\n   the original definition of this type, it does not become
        \"stuck\" at\n   its maximum or minimum value.)\n"
      title: 7.1.7.  Gauge32
    - contents:
      - "7.1.8.  TimeTicks\n   The TimeTicks type represents a non-negative integer
        which represents\n   the time, modulo 2^32 (4294967296 decimal), in hundredths
        of a second\n   between two epochs.  When objects are defined which use this
        ASN.1\n   type, the description of the object identifies both of the reference\n
        \  epochs.\n   For example, [3] defines the TimeStamp textual convention which
        is\n   based on the TimeTicks type.  With a TimeStamp, the first reference\n
        \  epoch is defined as the time when sysUpTime [5] was zero, and the\n   second
        reference epoch is defined as the current value of sysUpTime.\n   The TimeTicks
        type may not be sub-typed.\n"
      title: 7.1.8.  TimeTicks
    - contents:
      - "7.1.9.  Opaque\n   The Opaque type is provided solely for backward-compatibility,
        and\n   shall not be used for newly-defined object types.\n   The Opaque type
        supports the capability to pass arbitrary ASN.1\n   syntax.  A value is encoded
        using the ASN.1 Basic Encoding Rules [4]\n   into a string of octets.  This,
        in turn, is encoded as an OCTET\n   STRING, in effect \"double-wrapping\"
        the original ASN.1 value.\n   Note that a conforming implementation need only
        be able to accept and\n   recognize opaquely-encoded data.  It need not be
        able to unwrap the\n   data and then interpret its contents.\n   A requirement
        on \"standard\" MIB modules is that no object may have a\n   SYNTAX clause
        value of Opaque.\n"
      title: 7.1.9.  Opaque
    - contents:
      - "7.1.10.  Counter64\n   The Counter64 type represents a non-negative integer
        which\n   monotonically increases until it reaches a maximum value of 2^64-1\n
        \  (18446744073709551615 decimal), when it wraps around and starts\n   increasing
        again from zero.\n   Counters have no defined \"initial\" value, and thus,
        a single value of\n   a Counter has (in general) no information content.  Discontinuities\n
        \  in the monotonically increasing value normally occur at re-\n   initialization
        of the management system, and at other times as\n   specified in the description
        of an object-type using this ASN.1 type.\n   If such other times can occur,
        for example, the creation of an object\n   clause are:  TimeStamp (a textual
        convention defined in [3]),\n   DateAndTime (another textual convention from
        [3]) or TimeTicks.\n   The value of the MAX-ACCESS clause for objects with
        a SYNTAX clause\n   value of Counter64 is either \"read-only\" or \"accessible-for-notify\".\n
        \  A requirement on \"standard\" MIB modules is that the Counter64 type\n
        \  may be used only if the information being modeled would wrap in less\n
        \  than one hour if the Counter32 type was used instead.\n   A DEFVAL clause
        is not allowed for objects with a SYNTAX clause value\n   of Counter64.\n"
      title: 7.1.10.  Counter64
    - contents:
      - "7.1.11.  Unsigned32\n   The Unsigned32 type represents integer-valued information
        between 0\n   and 2^32-1 inclusive (0 to 4294967295 decimal).\n"
      title: 7.1.11.  Unsigned32
    - contents:
      - "7.1.12.  Conceptual Tables\n   Management operations apply exclusively to
        scalar objects.  However,\n   it is sometimes convenient for developers of
        management applications\n   to impose an imaginary, tabular structure on an
        ordered collection of\n   objects within the MIB.  Each such conceptual table
        contains zero or\n   more rows, and each row may contain one or more scalar
        objects,\n   termed columnar objects.  This conceptualization is formalized
        by\n   using the OBJECT-TYPE macro to define both an object which\n   corresponds
        to a table and an object which corresponds to a row in\n   that table.  A
        conceptual table has SYNTAX of the form:\n        SEQUENCE OF <EntryType>\n
        \  where <EntryType> refers to the SEQUENCE type of its subordinate\n   conceptual
        row.  A conceptual row has SYNTAX of the form:\n        <EntryType>\n   where
        <EntryType> is a SEQUENCE type defined as follows:\n        <EntryType> ::=
        SEQUENCE { <type1>, ... , <typeN> }\n   where there is one <type> for each
        subordinate object, and each\n   <type> is of the form:\n        <descriptor>
        <syntax>\n   except that both sub-typing information and the named values
        for\n   enumerated integers or the named bits for the BITS construct, are\n
        \  omitted from <syntax>.\n   Further, a <type> is always present for every
        subordinate object.\n   (The ASN.1 DEFAULT and OPTIONAL clauses are disallowed
        in the\n   SEQUENCE definition.)  The MAX-ACCESS clause for conceptual tables\n
        \  and rows is \"not-accessible\".\n"
      - contents:
        - "7.1.12.1.  Creation and Deletion of Conceptual Rows\n   For newly-defined
          conceptual rows which allow the creation of new\n   object instances and/or
          the deletion of existing object instances,\n   there should be one columnar
          object with a SYNTAX clause value of\n   RowStatus (a textual convention
          defined in [3]) and a MAX-ACCESS\n   clause value of read-create.  By convention,
          this is termed the\n   status column for the conceptual row.\n"
        title: 7.1.12.1.  Creation and Deletion of Conceptual Rows
      title: 7.1.12.  Conceptual Tables
    title: 7.1.  Mapping of the SYNTAX clause
  - contents:
    - "7.2.  Mapping of the UNITS clause\n   This UNITS clause, which need not be
      present, contains a textual\n   definition of the units associated with that
      object.\n"
    title: 7.2.  Mapping of the UNITS clause
  - contents:
    - "7.3.  Mapping of the MAX-ACCESS clause\n   The MAX-ACCESS clause, which must
      be present, defines whether it\n   makes \"protocol sense\" to read, write and/or
      create an instance of\n   the object, or to include its value in a notification.
      \ This is the\n   maximal level of access for the object.  (This maximal level
      of\n   access is independent of any administrative authorization policy.)\n
      \  The value \"read-write\" indicates that read and write access make\n   \"protocol
      sense\", but create does not.  The value \"read-create\"\n   indicates that
      read, write and create access make \"protocol sense\".\n   The value \"not-accessible\"
      indicates an auxiliary object (see Section\n   7.7).  The value \"accessible-for-notify\"
      indicates an object which is\n   accessible only via a notification (e.g., snmpTrapOID
      [5]).\n   These values are ordered, from least to greatest:  \"not-accessible\",\n
      \  \"accessible-for-notify\", \"read-only\", \"read-write\", \"read-create\".\n
      \  If any columnar object in a conceptual row has \"read-create\" as its\n   maximal
      level of access, then no other columnar object of the same\n   conceptual row
      may have a maximal access of \"read-write\".  (Note that\n   \"read-create\"
      is a superset of \"read-write\".)\n"
    title: 7.3.  Mapping of the MAX-ACCESS clause
  - contents:
    - "7.4.  Mapping of the STATUS clause\n   The STATUS clause, which must be present,
      indicates whether this\n   definition is current or historic.\n   The value
      \"current\" means that the definition is current and valid.\n   The value \"obsolete\"
      means the definition is obsolete and should not\n   be implemented and/or can
      be removed if previously implemented.\n   While the value \"deprecated\" also
      indicates an obsolete definition,\n   it permits new/continued implementation
      in order to foster\n   interoperability with older/existing implementations.\n"
    title: 7.4.  Mapping of the STATUS clause
  - contents:
    - "7.5.  Mapping of the DESCRIPTION clause\n   The DESCRIPTION clause, which must
      be present, contains a textual\n   definition of that object which provides
      all semantic definitions\n   necessary for implementation, and should embody
      any information which\n   would otherwise be communicated in any ASN.1 commentary
      annotations\n   associated with the object.\n"
    title: 7.5.  Mapping of the DESCRIPTION clause
  - contents:
    - "7.6.  Mapping of the REFERENCE clause\n   The REFERENCE clause, which need
      not be present, contains a textual\n   cross-reference to some other document,
      either another information\n   module which defines a related assignment, or
      some other document\n   which provides additional information relevant to this
      definition.\n"
    title: 7.6.  Mapping of the REFERENCE clause
  - contents:
    - "7.7.  Mapping of the INDEX clause\n   The INDEX clause, which must be present
      if that object corresponds to\n   a conceptual row (unless an AUGMENTS clause
      is present instead), and\n   must be absent otherwise, defines instance identification
      information\n   for the columnar objects subordinate to that object.\n   The
      instance identification information in an INDEX clause must\n   specify object(s)
      such that value(s) of those object(s) will\n   unambiguously distinguish a conceptual
      row.  The objects can be\n   columnar objects from the same and/or another conceptual
      table, but\n   must not be scalar objects.  Multiple occurrences of the same
      object\n   in a single INDEX clause is strongly discouraged.\n   The syntax
      of the objects in the INDEX clause indicate how to form\n   the instance-identifier:\n"
    - '(1)  integer-valued (i.e., having INTEGER as its underlying primitive

      '
    - "(2)  string-valued, fixed-length strings (or variable-length preceded by\n
      \    the IMPLIED keyword):  `n' sub-identifiers, where `n' is the length\n     of
      the string (each octet of the string is encoded in a separate\n     sub-identifier);\n"
    - "(3)  string-valued, variable-length strings (not preceded by the IMPLIED\n
      \    keyword):  `n+1' sub-identifiers, where `n' is the length of the\n     string
      (the first sub-identifier is `n' itself, following this,\n     each octet of
      the string is encoded in a separate sub-identifier);\n"
    - "(4)  object identifier-valued (when preceded by the IMPLIED keyword):\n     `n'
      sub-identifiers, where `n' is the number of sub-identifiers in\n     the value
      (each sub-identifier of the value is copied into a\n     separate sub-identifier);\n"
    - "(5)  object identifier-valued (when not preceded by the IMPLIED\n     keyword):
      \ `n+1' sub-identifiers, where `n' is the number of sub-\n     identifiers in
      the value (the first sub-identifier is `n' itself,\n     following this, each
      sub-identifier in the value is copied);\n"
    - "(6)  IpAddress-valued:  4 sub-identifiers, in the familiar a.b.c.d\n     notation.\n
      \  Note that the IMPLIED keyword can only be present for an object\n   having
      a variable-length syntax (e.g., variable-length strings or\n   object identifier-valued
      objects), Further, the IMPLIED keyword can\n   only be associated with the last
      object in the INDEX clause.\n   Finally, the IMPLIED keyword may not be used
      on a variable-length\n   string object if that string might have a value of
      zero-length.\n   Since a single value of a Counter has (in general) no information\n
      \  content (see section 7.1.6 and 7.1.10), objects defined using the\n   syntax,
      Counter32 or Counter64, must not be specified in an INDEX\n   clause. If an
      object defined using the BITS construct is used in an\n   INDEX clause, it is
      considered a variable-length string.\n   Instances identified by use of integer-valued
      objects should be\n   numbered starting from one (i.e., not from zero).  The
      use of zero as\n   a value for an integer-valued index object should be avoided,
      except\n   in special cases.\n   Objects which are both specified in the INDEX
      clause of a conceptual\n   row and also columnar objects of the same conceptual
      row are termed\n   auxiliary objects.  The MAX-ACCESS clause for auxiliary objects
      is\n"
    - "(1)  within a MIB module originally written to conform to SMIv1, and\n     later
      converted to conform to SMIv2; or\n"
    - "(2)  a conceptual row must contain at least one columnar object which is\n
      \    not an auxiliary object.  In the event that all of a conceptual\n     row's
      columnar objects are also specified in its INDEX clause, then\n     one of them
      must be accessible, i.e., have a MAX-ACCESS clause of\n     \"read-only\". (Note
      that this situation does not arise for a\n     conceptual row allowing create
      access, since such a row will have a\n     status column which will not be an
      auxiliary object.)\n   Note that objects specified in a conceptual row's INDEX
      clause need\n   not be columnar objects of that conceptual row.  In this situation,\n
      \  the DESCRIPTION clause of the conceptual row must include a textual\n   explanation
      of how the objects which are included in the INDEX clause\n   but not columnar
      objects of that conceptual row, are used in uniquely\n   identifying instances
      of the conceptual row's columnar objects.\n"
    title: 7.7.  Mapping of the INDEX clause
  - contents:
    - "7.8.  Mapping of the AUGMENTS clause\n   The AUGMENTS clause, which must not
      be present unless the object\n   corresponds to a conceptual row, is an alternative
      to the INDEX\n   clause.  Every object corresponding to a conceptual row has
      either an\n   INDEX clause or an AUGMENTS clause.\n   If an object corresponding
      to a conceptual row has an INDEX clause,\n   that row is termed a base conceptual
      row; alternatively, if the\n   object has an AUGMENTS clause, the row is said
      to be a conceptual row\n   augmentation, where the AUGMENTS clause names the
      object\n   corresponding to the base conceptual row which is augmented by this\n
      \  conceptual row augmentation.  (Thus, a conceptual row augmentation\n   cannot
      itself be augmented.)  Instances of subordinate columnar\n   objects of a conceptual
      row augmentation are identified according to\n   the INDEX clause of the base
      conceptual row corresponding to the\n   object named in the AUGMENTS clause.
      \ Further, instances of\n   subordinate columnar objects of a conceptual row
      augmentation exist\n   according to the same semantics as instances of subordinate
      columnar\n   objects of the base conceptual row being augmented.  As such, note\n
      \  that creation of a base conceptual row implies the correspondent\n   creation
      of any conceptual row augmentations.\n   For example, a MIB designer might wish
      to define additional columns\n   in an \"enterprise-specific\" MIB which logically
      extend a conceptual\n   row in a \"standard\" MIB.  The \"standard\" MIB definition
      of the\n   conceptual row would include the INDEX clause and the \"enterprise-\n
      \  and the many media-specific MIBs which extend it for specific media\n   (e.g.,
      the dot3Table in RFC 2358), since not all interfaces are of\n   the same media.\n
      \  Note that a base conceptual row may be augmented by multiple\n   conceptual
      row augmentations.\n"
    - contents:
      - "7.8.1.  Relation between INDEX and AUGMENTS clauses\n   When defining instance
        identification information for a conceptual\n   table:\n"
      - "(1)  If there is a one-to-one correspondence between the conceptual rows\n
        \    of this table and an existing table, then the AUGMENTS clause\n     should
        be used.\n"
      - "(2)  Otherwise, if there is a sparse relationship between the conceptual\n
        \    rows of this table and an existing table, then an INDEX clause\n     should
        be used which is identical to that in the existing table.\n     For example,
        the relationship between RFC 2233's ifTable and a\n     media-specific MIB
        which extends the ifTable for a specific media\n     (e.g., the dot3Table
        in RFC 2358), is a sparse relationship.\n"
      - "(3)  Otherwise, if no existing objects have the required syntax and\n     semantics,
        then auxiliary objects should be defined within the\n     conceptual row for
        the new table, and those objects should be used\n     within the INDEX clause
        for the conceptual row.\n"
      title: 7.8.1.  Relation between INDEX and AUGMENTS clauses
    title: 7.8.  Mapping of the AUGMENTS clause
  - contents:
    - "7.9.  Mapping of the DEFVAL clause\n   The DEFVAL clause, which need not be
      present, defines an acceptable\n   default value which may be used at the discretion
      of an agent when an\n   object instance is created.  That is, the value is a
      \"hint\" to\n   implementors.\n   During conceptual row creation, if an instance
      of a columnar object\n   is not present as one of the operands in the correspondent
      management\n   protocol set operation, then the value of the DEFVAL clause,
      if\n   present, indicates an acceptable default value that an agent might\n
      \  use (especially for a read-only object).\n   Note that with this definition
      of the DEFVAL clause, it is\n   appropriate to use it for any columnar object
      of a read-create table.\n   It is also permitted to use it for scalar objects
      dynamically created\n   by an agent, or for columnar objects of a read-write
      table\n   The value of the DEFVAL clause must, of course, correspond to the\n
      \  SYNTAX clause for the object.  If the value is an OBJECT IDENTIFIER,\n   then
      it must be expressed as a single ASN.1 identifier, and not as a\n   collection
      of sub-identifiers.\n   Note that if an operand to the management protocol set
      operation is\n   an instance of a read-only object, then the error `notWritable'
      [6]\n   will be returned.  As such, the DEFVAL clause can be used to provide\n
      \  an acceptable default value that an agent might use.\n   By way of example,
      consider the following possible DEFVAL clauses:\n        ObjectSyntax       DEFVAL
      clause\n        ----------------   ------------\n        Integer32          DEFVAL
      { 1 }\n                           -- same for Gauge32, TimeTicks, Unsigned32\n
      \       INTEGER            DEFVAL { valid } -- enumerated value\n        OCTET
      STRING       DEFVAL { 'ffffffffffff'H }\n        DisplayString      DEFVAL {
      \"SNMP agent\" }\n        IpAddress          DEFVAL { 'c0210415'H } -- 192.33.4.21\n
      \       OBJECT IDENTIFIER  DEFVAL { sysDescr }\n        BITS               DEFVAL
      { { primary, secondary } }\n                           -- enumerated values
      that are set\n        BITS               DEFVAL { { } }\n                           --
      no enumerated values are set\n   A binary string used in a DEFVAL clause for
      an OCTET STRING must be\n   either an integral multiple of eight or zero bits
      in length;\n   similarly, a hexadecimal string must be an even number of hexadecimal\n
      \  digits.  The value of a character string used in a DEFVAL clause must\n   not
      contain tab characters or line terminator characters.\n   Object types with
      SYNTAX of Counter32 and Counter64 may not have\n   DEFVAL clauses, since they
      do not have defined initial values.\n   However, it is recommended that they
      be initialized to zero.\n"
    title: 7.9.  Mapping of the DEFVAL clause
  - contents:
    - "7.10.  Mapping of the OBJECT-TYPE value\n   The value of an invocation of the
      OBJECT-TYPE macro is the name of\n   the object, which is an OBJECT IDENTIFIER,
      an administratively\n   assigned name.\n   When an OBJECT IDENTIFIER is assigned
      to an object:\n"
    - "(1)  If the object corresponds to a conceptual table, then only a single\n
      \    \"1\" to the administratively assigned name for the conceptual table.\n"
    - "(2)  If the object corresponds to a conceptual row, then at least one\n     assignment,
      one for each column in the conceptual row, is present\n     beneath that object.
      \ The administratively assigned name for each\n     column is derived by appending
      a unique, positive sub-identifier to\n     the administratively assigned name
      for the conceptual row.\n"
    - "(3)  Otherwise, no other OBJECT IDENTIFIERs which are subordinate to the\n
      \    object may be assigned.\n   Note that the final sub-identifier of any administratively
      assigned\n   name for an object shall be positive.  A zero-valued  final sub-\n
      \  identifier is reserved for future use.\n"
    title: 7.10.  Mapping of the OBJECT-TYPE value
  - contents:
    - "7.11.  Usage Example\n   Consider how one might define a conceptual table and
      its\n   subordinates.  (This example uses the RowStatus textual convention\n
      \  defined in [3].)\n   evalSlot OBJECT-TYPE\n       SYNTAX      Integer32 (0..2147483647)\n
      \      MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n
      \              \"The index number of the first unassigned entry in the\n               evaluation
      table, or the value of zero indicating that\n               all entries are
      assigned.\n               A management station should create new entries in
      the\n               evaluation table using this algorithm:  first, issue a\n
      \              management protocol retrieval operation to determine the\n               value
      of evalSlot; and, second, issue a management\n               protocol set operation
      to create an instance of the\n               evalStatus object setting its value
      to createAndGo(4) or\n               createAndWait(5).  If this latter operation
      succeeds,\n               then the management station may continue modifying
      the\n               instances corresponding to the newly created conceptual\n
      \              row, without fear of collision with other management\n               stations.\"\n
      \     ::= { eval 1 }\n   evalTable OBJECT-TYPE\n       SYNTAX      SEQUENCE
      OF EvalEntry\n               \"The (conceptual) evaluation table.\"\n      ::=
      { eval 2 }\n   evalEntry OBJECT-TYPE\n       SYNTAX      EvalEntry\n       MAX-ACCESS
      \ not-accessible\n       STATUS      current\n       DESCRIPTION\n               \"An
      entry (conceptual row) in the evaluation table.\"\n      INDEX   { evalIndex
      }\n      ::= { evalTable 1 }\n   EvalEntry ::=\n       SEQUENCE {\n           evalIndex
      \      Integer32,\n           evalString      DisplayString,\n           evalValue
      \      Integer32,\n           evalStatus      RowStatus\n       }\n   evalIndex
      OBJECT-TYPE\n       SYNTAX      Integer32 (1..2147483647)\n       MAX-ACCESS
      \ not-accessible\n       STATUS      current\n       DESCRIPTION\n               \"The
      auxiliary variable used for identifying instances of\n               the columnar
      objects in the evaluation table.\"\n           ::= { evalEntry 1 }\n   evalString
      OBJECT-TYPE\n       SYNTAX      DisplayString\n       MAX-ACCESS  read-create\n
      \      STATUS      current\n       DESCRIPTION\n               \"The string
      to evaluate.\"\n           ::= { evalEntry 2 }\n   evalValue OBJECT-TYPE\n       SYNTAX
      \     Integer32\n       MAX-ACCESS  read-only\n       STATUS      current\n
      \      DESCRIPTION\n               \"The value when evalString was last evaluated,
      or zero if\n                no such value is available.\"\n       DEFVAL  {
      0 }\n       SYNTAX      RowStatus\n       MAX-ACCESS  read-create\n       STATUS
      \     current\n       DESCRIPTION\n               \"The status column used for
      creating, modifying, and\n               deleting instances of the columnar
      objects in the\n               evaluation table.\"\n    DEFVAL  { active }\n
      \       ::= { evalEntry 4 }\n"
    title: 7.11.  Usage Example
  title: 7.  Mapping of the OBJECT-TYPE macro
- contents:
  - "8.  Mapping of the NOTIFICATION-TYPE macro\n   The NOTIFICATION-TYPE macro is
    used to define the information\n   contained within an unsolicited transmission
    of management\n   information (i.e., within either a SNMPv2-Trap-PDU or InformRequest-\n
    \  PDU).  It should be noted that the expansion of the NOTIFICATION-TYPE\n   macro
    is something which conceptually happens during implementation\n   and not during
    run-time.\n"
  - contents:
    - "8.1.  Mapping of the OBJECTS clause\n   The OBJECTS clause, which need not
      be present, defines an ordered\n   sequence of MIB object types.  One and only
      one object instance for\n   each occurrence of each object type must be present,
      and in the\n   specified order, in every instance of the notification.  If the
      same\n   object type occurs multiple times in a notification's ordered\n   sequence,
      then an object instance is present for each of them.  An\n   object type specified
      in this clause must not have an MAX-ACCESS\n   clause of \"not-accessible\".
      \ The notification's DESCRIPTION clause\n   must specify the information/meaning
      conveyed by each occurrence of\n   each object type in the sequence.  The DESCRIPTION
      clause must also\n   specify which object instance is present for each object
      type in the\n   notification.\n   Note that an agent is allowed, at its own
      discretion, to append as\n   many additional objects as it considers useful
      to the end of the\n   notification (i.e., after the objects defined by the OBJECTS
      clause).\n"
    title: 8.1.  Mapping of the OBJECTS clause
  - contents:
    - "8.2.  Mapping of the STATUS clause\n   The STATUS clause, which must be present,
      indicates whether this\n   definition is current or historic.\n   The value
      \"current\" means that the definition is current and valid.\n   The value \"obsolete\"
      means the definition is obsolete and should not\n   interoperability with older/existing
      implementations.\n"
    title: 8.2.  Mapping of the STATUS clause
  - contents:
    - "8.3.  Mapping of the DESCRIPTION clause\n   The DESCRIPTION clause, which must
      be present, contains a textual\n   definition of the notification which provides
      all semantic\n   definitions necessary for implementation, and should embody
      any\n   information which would otherwise be communicated in any ASN.1\n   commentary
      annotations associated with the notification.  In\n   particular, the DESCRIPTION
      clause should document which instances of\n   the objects mentioned in the OBJECTS
      clause should be contained\n   within notifications of this type.\n"
    title: 8.3.  Mapping of the DESCRIPTION clause
  - contents:
    - "8.4.  Mapping of the REFERENCE clause\n   The REFERENCE clause, which need
      not be present, contains a textual\n   cross-reference to some other document,
      either another information\n   module which defines a related assignment, or
      some other document\n   which provides additional information relevant to this
      definition.\n"
    title: 8.4.  Mapping of the REFERENCE clause
  - contents:
    - "8.5.  Mapping of the NOTIFICATION-TYPE value\n   The value of an invocation
      of the NOTIFICATION-TYPE macro is the name\n   of the notification, which is
      an OBJECT IDENTIFIER, an\n   administratively assigned name.  In order to achieve
      compatibility\n   with SNMPv1 traps, both when converting SMIv1 information
      modules\n   to/from this SMI, and in the procedures employed by multi-lingual\n
      \  systems and proxy forwarding applications, the next to last sub-\n   identifier
      in the name of any newly-defined notification must have\n   the value zero.\n
      \  Sections 4.2.6 and 4.2.7 of [6] describe how the NOTIFICATION-TYPE\n   macro
      is used to generate a SNMPv2-Trap-PDU or InformRequest-PDU,\n   respectively.\n"
    title: 8.5.  Mapping of the NOTIFICATION-TYPE value
  - contents:
    - "8.6.  Usage Example\n   Consider how a configuration change notification might
      be described:\n   entityMIBTraps      OBJECT IDENTIFIER ::= { entityMIB 2 }\n
      \  entityMIBTrapPrefix OBJECT IDENTIFIER ::= { entityMIBTraps 0 }\n   entConfigChange
      NOTIFICATION-TYPE\n       STATUS             current\n       DESCRIPTION\n               An
      agent must not generate more than one entConfigChange\n               'trap-event'
      in a five second period, where a 'trap-event'\n               is the transmission
      of a single trap PDU to a list of\n               trap destinations.  If additional
      configuration changes\n               occur within the five second 'throttling'
      period, then\n               these trap-events should be suppressed by the agent.
      An\n               NMS should periodically check the value of\n               entLastChangeTime
      to detect any missed entConfigChange\n               trap-events, e.g. due to
      throttling or transmission loss.\"\n      ::= { entityMIBTrapPrefix 1 }\n   According
      to this invocation, the notification authoritatively\n   identified as\n        {
      entityMIBTrapPrefix 1 }\n   is used to report a particular type of configuration
      change.\n"
    title: 8.6.  Usage Example
  title: 8.  Mapping of the NOTIFICATION-TYPE macro
- contents:
  - "9.  Refined Syntax\n   Some macros have clauses which allows syntax to be refined,\n
    \  specifically: the SYNTAX clause of the OBJECT-TYPE macro, and the\n   SYNTAX/WRITE-SYNTAX
    clauses of the MODULE-COMPLIANCE and AGENT-\n   CAPABILITIES macros [2].  However,
    not all refinements of syntax are\n   appropriate.  In particular, the object's
    primitive or application\n   type must not be changed.\n   Further, the following
    restrictions apply:\n                          Restrictions to Refinement of\n
    \    object syntax         range   enumeration     size\n     -----------------
    \    -----   -----------     ----\n               INTEGER      (1)        (2)
    \          -\n             Integer32      (1)         -            -\n            Unsigned32
    \     (1)         -            -\n          OCTET STRING       -          -           (3)\n
    \    OBJECT IDENTIFIER       -          -            -\n                  BITS
    \      -         (2)           -\n             IpAddress       -          -            -\n
    \            Counter32       -          -            -\n             Counter64
    \      -          -            -\n               Gauge32      (1)         -            -\n
    \            TimeTicks       -          -            -\n"
  - "(1)  the range of permitted values may be refined by raising the lower-\n     bounds,
    by reducing the upper-bounds, and/or by reducing the\n     alternative value/range
    choices;\n"
  - "(2)  the enumeration of named-values may be refined by removing one or\n     more
    named-values (note that for BITS, a refinement may cause the\n     enumerations
    to no longer be contiguous); or,\n"
  - "(3)  the size in octets of the value may be refined by raising the\n     lower-bounds,
    by reducing the upper-bounds, and/or by reducing the\n     alternative size choices.\n
    \  No other types of refinements can be specified in the SYNTAX clause.\n   However,
    the DESCRIPTION clause is available to specify additional\n   restrictions which
    can not be expressed in the SYNTAX clause.\n   Further details on (and examples
    of) sub-typing are provided in\n   Appendix A.\n"
  title: 9.  Refined Syntax
- contents:
  - "10.  Extending an Information Module\n   As experience is gained with an information
    module, it may be\n   desirable to revise that information module.  However, changes
    are\n   not allowed if they have any potential to cause interoperability\n   problems
    \"over the wire\" between an implementation using an original\n   specification
    and an implementation using an updated\n   specification(s).\n   For any change,
    the invocation of the MODULE-IDENTITY macro must be\n   updated to include information
    about the revision: specifically,\n   updating the LAST-UPDATED clause, adding
    a pair of REVISION and\n   DESCRIPTION clauses (see section 5.5), and making any
    necessary\n   changes to existing clauses, including the ORGANIZATION and CONTACT-\n
    \  INFO clauses.\n   Note that any definition contained in an information module
    is\n   available to be IMPORT-ed by any other information module, and is\n   referenced
    in an IMPORTS clause via the module name.  Thus, a module\n   name should not
    be changed.  Specifically, the module name (e.g.,\n   \"FIZBIN-MIB\" in the example
    of Section 5.7) should not be changed\n   when revising an information module
    (except to correct typographical\n   errors), and definitions should not be moved
    from one information\n   module to another.\n   Also note that obsolete definitions
    must not be removed from MIB\n   modules since their descriptors may still be
    referenced by other\n"
  - contents:
    - "10.1.  Object Assignments\n   If any non-editorial change is made to any clause
      of a object\n   assignment, then the OBJECT IDENTIFIER value associated with
      that\n   object assignment must also be changed, along with its associated\n
      \  descriptor.\n"
    title: 10.1.  Object Assignments
  - contents:
    - "10.2.  Object Definitions\n   An object definition may be revised in any of
      the following ways:\n"
    - "(1)  A SYNTAX clause containing an enumerated INTEGER may have new\n     enumerations
      added or existing labels changed.  Similarly, named\n     bits may be added
      or existing labels changed for the BITS\n     construct.\n"
    - "(2)  The value of a SYNTAX clause may be replaced by a textual\n     convention,
      providing the textual convention is defined to use the\n     same primitive
      ASN.1 type, has the same set of values, and has\n     identical semantics.\n"
    - "(3)  A STATUS clause value of \"current\" may be revised as \"deprecated\"\n
      \    or \"obsolete\".  Similarly, a STATUS clause value of \"deprecated\"\n
      \    may be revised as \"obsolete\".  When making such a change, the\n     DESCRIPTION
      clause should be updated to explain the rationale.\n"
    - '(4)  A DEFVAL clause may be added or updated.

      '
    - '(5)  A REFERENCE clause may be added or updated.

      '
    - '(6)  A UNITS clause may be added.

      '
    - "(7)  A conceptual row may be augmented by adding new columnar objects at\n
      \    the end of the row, and making the corresponding update to the\n     SEQUENCE
      definition.\n"
    - "(8)  Clarifications and additional information may be included in the\n     DESCRIPTION
      clause.\n"
    - "(9)  Entirely new objects may be defined, named with previously\n     unassigned
      OBJECT IDENTIFIER values.\n   Otherwise, if the semantics of any previously
      defined object are\n   changed (i.e., if a non-editorial change is made to any
      clause other\n   than those specifically allowed above), then the OBJECT IDENTIFIER\n
      \  Note that changing the descriptor associated with an existing object\n   is
      considered a semantic change, as these strings may be used in an\n   IMPORTS
      statement.\n"
    title: 10.2.  Object Definitions
  - contents:
    - "10.3.  Notification Definitions\n   A notification definition may be revised
      in any of the following\n   ways:\n"
    - '(1)  A REFERENCE clause may be added or updated.

      '
    - "(2)  A STATUS clause value of \"current\" may be revised as \"deprecated\"\n
      \    or \"obsolete\".  Similarly, a STATUS clause value of \"deprecated\"\n
      \    may be revised as \"obsolete\".  When making such a change, the\n     DESCRIPTION
      clause should be updated to explain the rationale.\n"
    - "(3)  A DESCRIPTION clause may be clarified.\n   Otherwise, if the semantics
      of any previously defined notification\n   are changed (i.e., if a non-editorial
      change is made to any clause\n   other those specifically allowed above), then
      the OBJECT IDENTIFIER\n   value associated with that notification must also
      be changed.\n   Note that changing the descriptor associated with an existing\n
      \  notification is considered a semantic change, as these strings may be\n   used
      in an IMPORTS statement.\n"
    title: 10.3.  Notification Definitions
  title: 10.  Extending an Information Module
- contents:
  - '11.  Appendix A: Detailed Sub-typing Rules

    '
  - contents:
    - "11.1.  Syntax Rules\n   The syntax rules for sub-typing are given below.  Note
      that while\n   this syntax is based on ASN.1, it includes some extensions beyond\n
      \  what is allowed in ASN.1, and a number of ASN.1 constructs are not\n   allowed
      by this syntax.\n        <integerSubType>\n            ::= <empty>\n              |
      \"(\" <range> [\"|\" <range>]... \")\"\n        <octetStringSubType>\n            ::=
      <empty>\n              | \"(\" \"SIZE\" \"(\" <range> [\"|\" <range>]... \")\"
      \")\"\n        <range>\n            ::= <value>\n              | <value> \"..\"
      <value>\n        <value>\n            ::= \"-\" <number>\n              | <number>\n
      \             | <hexString>\n              | <binString>\n        where:\n            <empty>
      \    is the empty string\n            <number>    is a non-negative integer\n
      \           <hexString> is a hexadecimal string (e.g., '0F0F'H)\n            <binString>
      is a binary string (e.g, '1010'B)\n            <range> is further restricted
      as follows:\n                - any <value> used in a SIZE clause must be non-negative.\n
      \               - when a pair of values is specified, the first value\n                  must
      be less than the second value.\n                - when multiple ranges are specified,
      the ranges may\n                  not overlap but may touch. For example, (1..4
      | 4..9)\n                  is invalid, and (1..4 | 5..9) is valid.\n                -
      the ranges must be a subset of the maximum range of the\n                  base
      type.\n"
    title: 11.1.  Syntax Rules
  - contents:
    - "11.2.  Examples\n   Some examples of legal sub-typing:\n            Integer32
      (-20..100)\n            Integer32 (0..100 | 300..500)\n            Integer32
      (300..500 | 0..100)\n            Integer32 (0 | 2 | 4 | 6 | 8 | 10)\n            OCTET
      STRING (SIZE(0..100))\n            OCTET STRING (SIZE(0..100 | 300..500))\n
      \           OCTET STRING (SIZE(0 | 2 | 4 | 6 | 8 | 10))\n            SYNTAX
      \  TimeInterval (0..100)\n            SYNTAX   DisplayString (SIZE(0..32))\n
      \  (Note the last two examples above are not valid in a TEXTUAL\n   CONVENTION,
      see [3].)\n   Some examples of illegal sub-typing:\n        Integer32 (150..100)
      \        -- first greater than second\n        Integer32 (0..100 | 50..500)
      -- ranges overlap\n        Integer32 (0 | 2 | 0 )       -- value duplicated\n
      \       Integer32 (MIN..-1 | 1..MAX) -- MIN and MAX not allowed\n        Integer32
      (SIZE (0..34))     -- must not use SIZE\n        OCTET STRING (0..100)        --
      must use SIZE\n        OCTET STRING (SIZE(-10..100)) -- negative SIZE\n"
    title: 11.2.  Examples
  title: '11.  Appendix A: Detailed Sub-typing Rules'
- contents:
  - "12.  Security Considerations\n   This document defines a language with which
    to write and read\n   descriptions of management information.  The language itself
    has no\n   security impact on the Internet.\n"
  title: 12.  Security Considerations
- contents:
  - "13.  Editors' Addresses\n   Keith McCloghrie\n   Cisco Systems, Inc.\n   170
    West Tasman Drive\n   San Jose, CA  95134-1706\n   USA\n   Phone: +1 408 526 5260\n
    \  EMail: kzm@cisco.com\n   David Perkins\n   SNMPinfo\n   3763 Benton Street\n
    \  Santa Clara, CA 95051\n   USA\n   Phone: +1 408 221-8702\n   EMail: dperkins@snmpinfo.com\n
    \  Juergen Schoenwaelder\n   TU Braunschweig\n   Bueltenweg 74/75\n   38106 Braunschweig\n
    \  Germany\n   Phone: +49 531 391-3283\n   EMail: schoenw@ibr.cs.tu-bs.de\n"
  title: 13.  Editors' Addresses
- contents:
  - '14.  References

    '
  - "[1]  Information processing systems - Open Systems Interconnection -\n     Specification
    of Abstract Syntax Notation One (ASN.1),\n     International Organization for
    Standardization.  International\n     Standard 8824, (December, 1987).\n"
  - "[2]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.\n     and
    S. Waldbusser, \"Conformance Statements for SMIv2\", STD 58,\n     RFC 2580, April
    1999.\n"
  - "[3]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.\n     and
    S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58,\n     RFC 2579, April
    1999.\n"
  - "[4]  Information processing systems - Open Systems Interconnection -\n     Specification
    of Basic Encoding Rules for Abstract Syntax Notation\n     One (ASN.1), International
    Organization for Standardization.\n     International Standard 8825, (December,
    1987).\n"
  - "[5]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M. and\n     S.
    Waldbusser, \"Management Information Base for Version 2 of the\n     Simple Network
    Management Protocol (SNMPv2)\", RFC 1907, January\n     1996.\n"
  - "[6]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M. and\n     S.
    Waldbusser, \"Protocol Operations for Version 2 of the Simple\n     Network Management
    Protocol (SNMPv2)\", RFC 1905, January 1996.\n"
  title: 14.  References
- contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\"\n"
  title: 15.  Full Copyright Statement
