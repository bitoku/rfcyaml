- contents:
  - '                Forward Error Correction (FEC) Framework

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a framework for using Forward Error\n   Correction
    (FEC) codes with applications in public and private IP\n   networks to provide
    protection against packet loss.  The framework\n   supports applying FEC to arbitrary
    packet flows over unreliable\n   transport and is primarily intended for real-time,
    or streaming,\n   media.  This framework can be used to define Content Delivery\n
    \  Protocols that provide FEC for streaming media delivery or other\n   packet
    flows.  Content Delivery Protocols defined using this\n   framework can support
    any FEC scheme (and associated FEC codes) that\n   is compliant with various requirements
    defined in this document.\n   Thus, Content Delivery Protocols can be defined
    that are not specific\n   to a particular FEC scheme, and FEC schemes can be defined
    that are\n   not specific to a particular Content Delivery Protocol.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6363.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Definitions and Abbreviations ...................................5\n   3.
    Architecture Overview ...........................................7\n   4. Procedural
    Overview ............................................11\n      4.1. General ...................................................11\n
    \     4.2. Sender Operation ..........................................13\n      4.3.
    Receiver Operation ........................................15\n   5. Protocol
    Specification .........................................19\n      5.1. General
    ...................................................19\n      5.2. Structure of
    the Source Block .............................19\n      5.3. Packet Format for
    FEC Source Packets ......................19\n           5.3.1. Generic Explicit
    Source FEC Payload ID .............21\n      5.4. Packet Format for FEC Repair
    Packets ......................21\n           5.4.1. Packet Format for FEC Repair
    Packets over RTP ......22\n      5.5. FEC Framework Configuration Information
    ...................22\n      5.6. FEC Scheme Requirements ...................................24\n
    \  6. Feedback .......................................................26\n   7.
    Transport Protocols ............................................27\n   8. Congestion
    Control .............................................27\n      8.1. Motivation
    ................................................27\n      8.2. Normative Requirements
    ....................................29\n   9. Security Considerations ........................................29\n
    \     9.1. Problem Statement .........................................29\n      9.2.
    Attacks against the Data Flows ............................31\n           9.2.1.
    Access to Confidential Content .....................31\n           9.2.2. Content
    Corruption .................................32\n      9.3. Attacks against the
    FEC Parameters ........................33\n      9.4. When Several Source Flows
    Are to Be Protected Together ....33\n      9.5. Baseline Secure FEC Framework
    Operation ...................34\n   10. Operations and Management Considerations
    ......................35\n      10.1. What Are the Key Aspects to Consider? ....................35\n
    \     10.2. Operational and Management Recommendations ...............36\n   11.
    IANA Considerations ...........................................39\n   12. Acknowledgments
    ...............................................39\n   13. References ....................................................40\n
    \     13.1. Normative References .....................................40\n      13.2.
    Informative References ...................................40\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Many applications have a requirement to transport a continuous
    stream\n   of packetized data from a source (sender) to one or more destinations\n
    \  (receivers) over networks that do not provide guaranteed packet\n   delivery.
    \ Primary examples are real-time, or streaming, media\n   applications such as
    broadcast, multicast, or on-demand forms of\n   audio, video, or multimedia.\n
    \  Forward Error Correction (FEC) is a well-known technique for\n   improving
    the reliability of packet transmission over networks that\n   do not provide guaranteed
    packet delivery, especially in multicast\n   and broadcast applications.  The
    FEC Building Block, defined in\n   [RFC5052], provides a framework for the definition
    of Content\n   Delivery Protocols (CDPs) for object delivery (including, primarily,\n
    \  file delivery) that make use of separately defined FEC schemes.  Any\n   CDP
    defined according to the requirements of the FEC Building Block\n   can then easily
    be used with any FEC scheme that is also defined\n   according to the requirements
    of the FEC Building Block.\n   Note that the term \"Forward Erasure Correction\"
    is sometimes used,\n   erasures being a type of error in which data is lost and
    this loss\n   can be detected, rather than being received in corrupted form.  The\n
    \  focus of this document is strictly on erasures, and the term \"Forward\n   Error
    Correction\" is more widely used.\n   This document defines a framework for the
    definition of CDPs that\n   provide for FEC protection for arbitrary packet flows
    over unreliable\n   transports such as UDP.  As such, this document complements
    the FEC\n   Building Block of [RFC5052], by providing for the case of arbitrary\n
    \  packet flows over unreliable transport, the same kind of framework as\n   that
    document provides for object delivery.  This document does not\n   define a complete
    CDP; rather, it defines only those aspects that are\n   expected to be common
    to all CDPs based on this framework.\n   This framework does not define how the
    flows to be protected are\n   determined, nor does it define how the details of
    the protected flows\n   and the FEC streams that protect them are communicated
    from sender to\n   receiver.  It is expected that any complete CDP specification
    that\n   makes use of this framework will address these signaling\n   requirements.
    \ However, this document does specify the information\n   that is required by
    the FEC Framework at the sender and receiver,\n   e.g., details of the flows to
    be FEC protected, the flow(s) that will\n   carry the FEC protection data, and
    an opaque container for\n   FEC-Scheme-Specific Information.\n   FEC schemes designed
    for use with this framework must fulfill a\n   number of requirements defined
    in this document.  These requirements\n   are different from those defined in
    [RFC5052] for FEC schemes for\n   object delivery.  However, there is a great
    deal of commonality, and\n   FEC schemes defined for object delivery may be easily
    adapted for use\n   with the framework defined in this document.\n   Since RTP
    [RFC3550] is (often) used over UDP, this framework can be\n   applied to RTP flows
    as well.  FEC repair packets may be sent\n   directly over UDP or RTP.  The latter
    approach has the advantage that\n   RTP instrumentation, based on the RTP Control
    Protocol (RTCP), can be\n   used for the repair flow.  Additionally, the post-repair
    RTCP\n   extended reports [RFC5725] may be used to obtain information about\n
    \  the loss rate after FEC recovery.\n   The use of RTP for repair flows is defined
    for each FEC scheme by\n   defining an RTP payload format for that particular
    FEC scheme\n   (possibly in the same document).\n"
  title: 1.  Introduction
- contents:
  - "2.  Definitions and Abbreviations\n   Application Data Unit (ADU): The unit of
    source data provided as\n      payload to the transport layer.\n   ADU Flow: A
    sequence of ADUs associated with a transport-layer flow\n      identifier (such
    as the standard 5-tuple {source IP address,\n      source port, destination IP
    address, destination port, transport\n      protocol}).\n   AL-FEC: Application-layer
    Forward Error Correction.\n   Application Protocol: Control protocol used to establish
    and control\n      the source flow being protected, e.g., the Real-Time Streaming\n
    \     Protocol (RTSP).\n   Content Delivery Protocol (CDP): A complete application
    protocol\n      specification that, through the use of the framework defined in\n
    \     this document, is able to make use of FEC schemes to provide FEC\n      capabilities.\n
    \  FEC Code: An algorithm for encoding data such that the encoded data\n      flow
    is resilient to data loss.  Note that, in general, FEC codes\n      may also be
    used to make a data flow resilient to corruption, but\n      that is not considered
    in this document.\n   FEC Framework: A protocol framework for the definition of
    Content\n      Delivery Protocols using FEC, such as the framework defined in\n
    \     this document.\n   FEC Framework Configuration Information: Information
    that controls\n      the operation of the FEC Framework.\n   FEC Payload ID: Information
    that identifies the contents of a packet\n      with respect to the FEC scheme.\n
    \  FEC Repair Packet: At a sender (respectively, at a receiver), a\n      payload
    submitted to (respectively, received from) the transport\n      protocol containing
    one or more repair symbols along with a Repair\n      FEC Payload ID and possibly
    an RTP header.\n   FEC Scheme: A specification that defines the additional protocol\n
    \     aspects required to use a particular FEC code with the FEC\n      Framework.\n
    \  FEC Source Packet: At a sender (respectively, at a receiver), a\n      payload
    submitted to (respectively, received from) the transport\n      protocol containing
    an ADU along with an optional Explicit Source\n      FEC Payload ID.\n   Protection
    Amount: The relative increase in data sent due to the use\n      of FEC.\n   Repair
    Flow: The packet flow carrying FEC data.\n   Repair FEC Payload ID: A FEC Payload
    ID specifically for use with\n      repair packets.\n   Source Flow: The packet
    flow to which FEC protection is to be\n      applied.  A source flow consists
    of ADUs.\n   Source FEC Payload ID: A FEC Payload ID specifically for use with\n
    \     source packets.\n   Source Protocol: A protocol used for the source flow
    being protected,\n      e.g., RTP.\n   Transport Protocol: The protocol used for
    the transport of the source\n      and repair flows, e.g., UDP and the Datagram
    Congestion Control\n      Protocol (DCCP).\n   The following definitions are aligned
    with [RFC5052]:\n   Code Rate: The ratio between the number of source symbols
    and the\n      number of encoding symbols.  By definition, the code rate is such\n
    \     that 0 < code rate <= 1.  A code rate close to 1 indicates that a\n      small
    number of repair symbols have been produced during the\n      encoding process.\n
    \  Encoding Symbol: Unit of data generated by the encoding process.\n      With
    systematic codes, source symbols are part of the encoding\n      symbols.\n   Packet
    Erasure Channel: A communication path where packets are either\n      dropped
    (e.g., by a congested router, or because the number of\n      transmission errors
    exceeds the correction capabilities of the\n      physical-layer codes) or received.
    \ When a packet is received, it\n      is assumed that this packet is not corrupted.\n
    \  Repair Symbol: Encoding symbol that is not a source symbol.\n   Source Block:
    Group of ADUs that are to be FEC protected as a single\n      block.\n   Source
    Symbol: Unit of data used during the encoding process.\n   Systematic Code: FEC
    code in which the source symbols are part of the\n      encoding symbols.\n   The
    key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in [RFC2119].\n"
  title: 2.  Definitions and Abbreviations
- contents:
  - "3.  Architecture Overview\n   The FEC Framework is described in terms of an additional
    layer\n   between the transport layer (e.g., UDP or DCCP) and protocols running\n
    \  over this transport layer.  As such, the data path interface between\n   the
    FEC Framework and both underlying and overlying layers can be\n   thought of as
    being the same as the standard interface to the\n   transport layer; i.e., the
    data exchanged consists of datagram\n   payloads each associated with a single
    ADU flow identified by the\n   standard 5-tuple {source IP address, source port,
    destination IP\n   address, destination port, transport protocol}.  In the case
    that RTP\n   is used for the repair flows, the source and repair data can be\n
    \  multiplexed using RTP onto a single UDP flow and needs to be\n   consequently
    demultiplexed at the receiver.  There are various ways\n   in which this multiplexing
    can be done (for example, as described in\n   [RFC4588]).\n   It is important
    to understand that the main purpose of the FEC\n   Framework architecture is to
    allocate functional responsibilities to\n   separately documented components in
    such a way that specific\n   instances of the components can be combined in different
    ways to\n   describe different protocols.\n   The FEC Framework makes use of a
    FEC scheme, in a similar sense to\n   that defined in [RFC5052], and uses the
    terminology of that document.\n   The FEC scheme defines the FEC encoding and
    decoding, and it defines\n   the protocol fields and procedures used to identify
    packet payload\n   data in the context of the FEC scheme.  The interface between
    the FEC\n   Framework and a FEC scheme, which is described in this document, is
    a\n   logical one that exists for specification purposes only.  At an\n   encoder,
    the FEC Framework passes ADUs to the FEC scheme for FEC\n   encoding.  The FEC
    scheme returns repair symbols with their\n   associated Repair FEC Payload IDs
    and, in some cases, Source FEC\n   Payload IDs, depending on the FEC scheme.  At
    a decoder, the FEC\n   Framework passes transport packet payloads (source and
    repair) to the\n   FEC scheme, and the FEC scheme returns additional recovered
    source\n   packet payloads.\n   This document defines certain FEC Framework Configuration
    Information\n   that MUST be available to both sender and receiver(s).  For example,\n
    \  this information includes the specification of the ADU flows that are\n   to
    be FEC protected, specification of the ADU flow(s) that will carry\n   the FEC
    protection (repair) data, and the relationship(s) between\n   these source and
    repair flows (i.e., which source flow(s) are\n   protected by repair flow(s)).
    \ The FEC Framework Configuration\n   Information also includes information fields
    that are specific to the\n   FEC scheme.  This information is analogous to the
    FEC Object\n   Transmission Information defined in [RFC5052].\n   The FEC Framework
    does not define how the FEC Framework Configuration\n   Information for the stream
    is communicated from sender to receiver.\n   This has to be defined by any CDP
    specification, as described in the\n   following sections.\n   In this architecture,
    we assume that the interface to the transport\n   layer supports the concepts
    of data units (referred to here as\n   Application Data Units (ADUs)) to be transported
    and identification\n   of ADU flows on which those data units are transported.
    \ Since this\n   is an interface internal to the architecture, we do not specify
    this\n   interface explicitly.  We do require that ADU flows that are distinct\n
    \  from the transport layer point of view (for example, distinct UDP\n   flows
    as identified by the UDP source/destination addresses/ports)\n   are also distinct
    on the interface between the transport layer and\n   the FEC Framework.\n   As
    noted above, RTP flows are a specific example of ADU flows that\n   might be protected
    by the FEC Framework.  From the FEC Framework\n   point of view, RTP source flows
    are ADU flows like any other, with\n   the RTP header included within the ADU.\n
    \  Depending on the FEC scheme, RTP can also be used as a transport for\n   repair
    packet flows.  In this case, a FEC scheme has to define an RTP\n   payload format
    for the repair data.\n   The architecture outlined above is illustrated in Figure
    1.  In this\n   architecture, two (optional) RTP instances are shown, for the
    source\n   and repair data, respectively.  This is because the use of RTP for\n
    \  the source data is separate from, and independent of, the use of RTP\n   for
    the repair data.  The appearance of two RTP instances is more\n   natural when
    one considers that in many FEC codes, the repair payload\n   contains repair data
    calculated across the RTP headers of the source\n   packets.  Thus, a repair packet
    carried over RTP starts with an RTP\n   header of its own, which is followed (after
    the Repair Payload ID) by\n   repair data containing bytes that protect the source
    RTP headers (as\n   well as repair data for the source RTP payloads).\n      +--------------------------------------------+\n
    \     |                 Application                |\n      +--------------------------------------------+\n
    \                            |\n                             |\n                             |\n
    \   + - - - - - - - - - - - - - - - - - - - - - - - -+\n    | +--------------------------------------------+
    |\n      |            Application Layer               |\n    | +--------------------------------------------+
    |\n                             |                |\n    | + -- -- -- -- -- --
    -- -- -- -- --+     |      |\n      |            RTP (Optional)       |     |\n
    \   | |                                 |     |- Configuration/\n      +- -- --
    -- -- -- -- -- -- -- -- -+     |  Coordination\n    |                    |                    |
    \     |\n                         | ADU flows          |\n    |                    |
    \                   v      |\n      +--------------------------------------------+
    \    +------------+\n    | |      FEC Framework (This document)         |<--->|
    FEC Scheme |\n      +--------------------------------------------+     +------------+\n
    \   |                |               |               |\n              Source |
    \       Repair |\n    |                |               |               |\n      +--
    -- -- -- --|-- --+ -- -- -- -- -- + -- --+\n    | | RTP Layer    |     | RTP Processing
    |      | |\n      | (Optional)   |     +-- -- -- |- -- -+      |\n    | |        +--
    -- -- -- -- -- -- |--+          | |\n      |        |  RTP (De)multiplexing  |
    \         |\n    | +-- -- -- --- -- -- -- -- -- -- -- -- -- -- -+ |\n                             |\n
    \   | +--------------------------------------------+ |\n      |          Transport
    Layer (e.g., UDP)       |\n    | +--------------------------------------------+
    |\n                             |\n    | +--------------------------------------------+
    |\n      |                     IP                     |\n    | +--------------------------------------------+
    |\n    | Content Delivery Protocol                      |\n    + - - - - - - -
    - - - - - - - -  - - - - - - - - +\n                   Figure 1: FEC Framework
    Architecture\n   The content of the transport payload for repair packets is fully\n
    \  defined by the FEC scheme.  For a specific FEC scheme, a means MAY be\n   defined
    for repair data to be carried over RTP, in which case, the\n   repair packet payload
    format starts with the RTP header.  This\n   corresponds to defining an RTP payload
    format for the specific FEC\n   scheme.\n   The use of RTP for repair packets
    is independent of the protocols\n   used for source packets: if RTP is used for
    source packets, repair\n   packets may or may not use RTP and vice versa (although
    it is\n   unlikely that there are useful scenarios where non-RTP source flows\n
    \  are protected by RTP repair flows).  FEC schemes are expected to\n   recover
    entire transport payloads for recovered source packets in all\n   cases.  For
    example, if RTP is used for source flows, the FEC scheme\n   is expected to recover
    the entire UDP payload, including the RTP\n   header.\n"
  title: 3.  Architecture Overview
- contents:
  - '4.  Procedural Overview

    '
  - contents:
    - "4.1.  General\n   The mechanism defined in this document does not place any\n
      \  restrictions on the ADUs that can be protected together, except that\n   the
      ADU be carried over a supported transport protocol (see\n   Section 7).  The
      data can be from multiple source flows that are\n   protected jointly.  The
      FEC Framework handles the source flows as a\n   sequence of source blocks each
      consisting of a set of ADUs, possibly\n   from multiple source flows that are
      to be protected together.  For\n   example, each source block can be constructed
      from those ADUs related\n   to a particular segment in time of the flow.\n   At
      the sender, the FEC Framework passes the payloads for a given\n   block to the
      FEC scheme for FEC encoding.  The FEC scheme performs\n   the FEC encoding operation
      and returns the following information:\n   o  Optionally, FEC Payload IDs for
      each of the source payloads\n      (encoded according to a FEC-Scheme-Specific
      format).\n   o  One or more FEC repair packet payloads.\n   o  FEC Payload IDs
      for each of the repair packet payloads (encoded\n      according to a FEC-Scheme-Specific
      format).\n   The FEC Framework then performs two operations.  First, it appends\n
      \  the Source FEC Payload IDs, if provided, to each of the ADUs, and\n   sends
      the resulting packets, known as \"FEC source packets\", to the\n   receiver.
      \ Second, it places the provided FEC repair packet payloads\n   and corresponding
      Repair FEC Payload IDs appropriately to construct\n   FEC repair packets and
      send them to the receiver.\n   This document does not define how the sender
      determines which ADUs\n   are included in which source blocks or the sending
      order and timing\n   of FEC source and repair packets.  A specific CDP MAY define
      this\n   mapping, or it MAY be left as implementation dependent at the sender.\n
      \  However, a CDP specification MUST define how a receiver determines a\n   minimum
      length of time that it needs to wait to receive FEC repair\n   packets for any
      given source block.  FEC schemes MAY define\n   limitations on this mapping,
      such as maximum size of source blocks,\n   but they SHOULD NOT attempt to define
      specific mappings.  The\n   sequence of operations at the sender is described
      in more detail in\n   Section 4.2.\n   At the receiver, original ADUs are recovered
      by the FEC Framework\n   directly from any FEC source packets received simply
      by removing the\n   Source FEC Payload ID, if present.  The receiver also passes
      the\n   contents of the received ADUs, plus their FEC Payload IDs, to the FEC\n
      \  scheme for possible decoding.\n   If any ADUs related to a given source block
      have been lost, then the\n   FEC scheme can perform FEC decoding to recover
      the missing ADUs\n   (assuming sufficient FEC source and repair packets related
      to that\n   source block have been received).\n   Note that the receiver might
      need to buffer received source packets\n   to allow time for the FEC repair
      packets to arrive and FEC decoding\n   to be performed before some or all of
      the received or recovered\n   packets are passed to the application.  If such
      a buffer is not\n   provided, then the application has to be able to deal with
      the severe\n   re-ordering of packets that can occur.  However, such buffering
      is\n   CDP- and/or implementation-specific and is not specified here.  The\n
      \  receiver operation is described in more detail in Section 4.3.\n   The FEC
      source packets MUST contain information that identifies the\n   source block
      and the position within the source block (in terms\n   specific to the FEC scheme)
      occupied by the ADU.  This information is\n   known as the Source FEC Payload
      ID.  The FEC scheme is responsible\n   for defining and interpreting this information.
      \ This information MAY\n   be encoded into a specific field within the FEC source
      packet format\n   defined in this specification, called the Explicit Source
      FEC Payload\n   ID field.  The exact contents and format of the Explicit Source
      FEC\n   Payload ID field are defined by the FEC schemes.  Alternatively, the\n
      \  FEC scheme MAY define how the Source FEC Payload ID is derived from\n   other
      fields within the source packets.  This document defines the\n   way that the
      Explicit Source FEC Payload ID field is appended to\n   source packets to form
      FEC source packets.\n   The FEC repair packets MUST contain information that
      identifies the\n   source block and the relationship between the contained repair\n
      \  payloads and the original source block.  This is known as the Repair\n   FEC
      Payload ID.  This information MUST be encoded into a specific\n   field, the
      Repair FEC Payload ID field, the contents and format of\n   which are defined
      by the FEC schemes.\n   The FEC scheme MAY use different FEC Payload ID field
      formats for\n   source and repair packets.\n"
    title: 4.1.  General
  - contents:
    - "4.2.  Sender Operation\n   It is assumed that the sender has constructed or
      received original\n   data packets for the session.  These could be carrying
      any type of\n   data.  The following operations, illustrated in Figure 2 for
      the case\n   of UDP repair flows and in Figure 3 for the case of RTP repair
      flows,\n   describe a possible way to generate compliant source and repair\n
      \  flows:\n   1.  ADUs are provided by the application.\n   2.  A source block
      is constructed as specified in Section 5.2.\n   3.  The source block is passed
      to the FEC scheme for FEC encoding.\n       The Source FEC Payload ID information
      of each source packet is\n       determined by the FEC scheme.  If required
      by the FEC scheme, the\n       Source FEC Payload ID is encoded into the Explicit
      Source FEC\n       Payload ID field.\n   4.  The FEC scheme performs FEC encoding,
      generating repair packet\n       payloads from a source block and a Repair FEC
      Payload ID field\n       for each repair payload.\n   5.  The Explicit Source
      FEC Payload IDs (if used), Repair FEC Payload\n       IDs, and repair packet
      payloads are provided back from the FEC\n       scheme to the FEC Framework.\n
      \  6.  The FEC Framework constructs FEC source packets according to\n       Section
      5.3, and FEC repair packets according to Section 5.4,\n       using the FEC
      Payload IDs and repair packet payloads provided by\n       the FEC scheme.\n
      \  7.  The FEC source and repair packets are sent using normal\n       transport-layer
      procedures.  The port(s) and multicast group(s)\n       to be used for FEC repair
      packets are defined in the FEC\n       Framework Configuration Information.
      \ The FEC source packets are\n       sent using the same ADU flow identification
      information as would\n       have been used for the original source packets
      if the FEC\n       Framework were not present (for example, in the UDP case,
      the UDP\n       source and destination addresses and ports on the IP datagram\n
      \      carrying the source packet will be the same whether or not the\n       FEC
      Framework is applied).\n   +----------------------+\n   |     Application      |\n
      \  +----------------------+\n              |\n              |(1) ADUs\n              |\n
      \             v\n   +----------------------+                           +----------------+\n
      \  |    FEC Framework     |                           |                |\n   |
      \                     |-------------------------->|   FEC Scheme   |\n   |(2)
      Construct source  |(3) Source Block           |                |\n   |    blocks
      \           |                           |(4) FEC Encoding|\n   |(6) Construct
      FEC     |<--------------------------|                |\n   |    source and repair
      |                           |                |\n   |    packets           |(5)
      Explicit Source FEC    |                |\n   +----------------------+    Payload
      IDs            +----------------+\n              |                Repair FEC
      Payload IDs\n              |                Repair symbols\n              |\n
      \             |(7) FEC source and repair packets\n              v\n   +----------------------+\n
      \  |   Transport Layer    |\n   |     (e.g., UDP)      |\n   +----------------------+\n
      \                       Figure 2: Sender Operation\n   +----------------------+\n
      \  |     Application      |\n   +----------------------+\n              |\n
      \             |(1) ADUs\n              |\n              v\n   +----------------------+
      \                          +----------------+\n   |    FEC Framework     |                           |
      \               |\n   |                      |-------------------------->|   FEC
      Scheme   |\n   |(2) Construct source  |(3) Source Block           |                |\n
      \  |    blocks            |                           |(4) FEC Encoding|\n   |(6)
      Construct FEC     |<--------------------------|                |\n   |    source
      packets and|                           |                |\n   |    repair payloads
      \  |(5) Explicit Source FEC    |                |\n   +----------------------+
      \   Payload IDs            +----------------+\n       |             |         Repair
      FEC Payload IDs\n       |             |         Repair symbols\n       |             |\n
      \      |(7) Source   |(7') Repair payloads\n       |    packets  |\n       |
      \            |\n       |      + -- -- -- -- -+\n       |      |     RTP      |\n
      \      |      +-- -- -- -- --+\n       v             v\n   +----------------------+\n
      \  |   Transport Layer    |\n   |     (e.g., UDP)      |\n   +----------------------+\n
      \            Figure 3: Sender Operation with RTP Repair Flows\n"
    title: 4.2.  Sender Operation
  - contents:
    - "4.3.  Receiver Operation\n   The following describes a possible receiver algorithm,
      illustrated in\n   Figures 4 and 5 for the case of UDP and RTP repair flows,\n
      \  respectively, when receiving a FEC source or repair packet:\n   1.  FEC source
      packets and FEC repair packets are received and passed\n       to the FEC Framework.
      \ The type of packet (source or repair) and\n       the source flow to which
      it belongs (in the case of source\n       packets) are indicated by the ADU
      flow information, which\n       identifies the flow at the transport layer.\n
      \      In the special case that RTP is used for repair packets, and\n       source
      and repair packets are multiplexed onto the same UDP flow,\n       then RTP
      demultiplexing is required to demultiplex source and\n       repair flows.  However,
      RTP processing is applied only to the\n       repair packets at this stage;
      source packets continue to be\n       handled as UDP payloads (i.e., including
      their RTP headers).\n   2.  The FEC Framework extracts the Explicit Source FEC
      Payload ID\n       field (if present) from the source packets and the Repair
      FEC\n       Payload ID from the repair packets.\n   3.  The Explicit Source
      FEC Payload IDs (if present), Repair FEC\n       Payload IDs, and FEC source
      and repair payloads are passed to the\n       FEC scheme.\n   4.  The FEC scheme
      uses the received FEC Payload IDs (and derived FEC\n       Source Payload IDs
      in the case that the Explicit Source FEC\n       Payload ID field is not used)
      to group source and repair packets\n       into source blocks.  If at least
      one source packet is missing\n       from a source block, and at least one repair
      packet has been\n       received for the same source block, then FEC decoding
      can be\n       performed in order to recover missing source payloads.  The FEC\n
      \      scheme determines whether source packets have been lost and\n       whether
      enough data for decoding of any or all of the missing\n       source payloads
      in the source block has been received.\n   5.  The FEC scheme returns the ADUs
      to the FEC Framework in the form\n       of source blocks containing received
      and decoded ADUs and\n       indications of any ADUs that were missing and could
      not be\n       decoded.\n   6.  The FEC Framework passes the received and recovered
      ADUs to the\n       application.\n   The description above defines functionality
      responsibilities but does\n   not imply a specific set of timing relationships.
      \ Source packets\n   that are correctly received and those that are reconstructed
      MAY be\n   delivered to the application out of order and in a different order\n
      \  from the order of arrival at the receiver.  Alternatively, buffering\n   and
      packet re-ordering MAY be applied to re-order received and\n   reconstructed
      source packets into the order they were placed into the\n   source block, if
      that is necessary according to the application.\n   +----------------------+\n
      \  |     Application      |\n   +----------------------+\n              ^\n
      \             |\n              |(6) ADUs\n              |\n   +----------------------+
      \                          +----------------+\n   |    FEC Framework     |                           |
      \               |\n   |                      |<--------------------------|   FEC
      Scheme   |\n   |(2)Extract FEC Payload|(5) ADUs                   |                |\n
      \  |   IDs and pass IDs & |                           |(4) FEC Decoding|\n   |
      \  payloads to FEC    |-------------------------->|                |\n   |   scheme
      \            |(3) Explicit Source FEC    |                |\n   +----------------------+
      \   Payload IDs            +----------------+\n              ^                Repair
      FEC Payload IDs\n              |                Source payloads\n              |
      \               Repair payloads\n              |\n              |(1) FEC source
      and repair packets\n              |\n   +----------------------+\n   |   Transport
      Layer    |\n   |     (e.g., UDP)      |\n   +----------------------+\n                       Figure
      4: Receiver Operation\n   +----------------------+\n   |     Application      |\n
      \  +----------------------+\n              ^\n              |\n              |(6)
      ADUs\n              |\n   +----------------------+                           +----------------+\n
      \  |    FEC Framework     |                           |                |\n   |
      \                     |<--------------------------|   FEC Scheme   |\n   |(2)Extract
      FEC Payload|(5) ADUs                   |                |\n   |   IDs and pass
      IDs & |                           |(4) FEC Decoding|\n   |   payloads to FEC
      \   |-------------------------->|                |\n   |   scheme             |(3)
      Explicit Source FEC    |                |\n   +----------------------+    Payload
      IDs            +----------------+\n       ^             ^         Repair FEC
      Payload IDs\n       |             |         Source payloads\n       |             |
      \        Repair payloads\n       |             |\n       |Source       |Repair
      payloads\n       |packets      |\n       |             |\n   +-- |- -- -- --
      -- -- -+\n   |RTP| | RTP Processing |\n   |   | +-- -- -- --|-- -+\n   | +--
      -- -- -- -- |--+ |\n   | | RTP Demux        | |\n   +-- -- -- -- -- -- -- -+\n
      \             ^\n              |(1) FEC source and repair packets\n              |\n
      \  +----------------------+\n   |   Transport Layer    |\n   |     (e.g., UDP)
      \     |\n   +----------------------+\n            Figure 5: Receiver Operation
      with RTP Repair Flows\n   Note that the above procedure might result in a situation
      in which\n   not all ADUs are recovered.\n"
    title: 4.3.  Receiver Operation
  title: 4.  Procedural Overview
- contents:
  - '5.  Protocol Specification

    '
  - contents:
    - "5.1.  General\n   This section specifies the protocol elements for the FEC
      Framework.\n   Three components of the protocol are defined in this document
      and are\n   described in the following sections:\n   1.  Construction of a source
      block from ADUs.  The FEC code will be\n       applied to this source block
      to produce the repair payloads.\n   2.  A format for packets containing source
      data.\n   3.  A format for packets containing repair data.\n   The operation
      of the FEC Framework is governed by certain FEC\n   Framework Configuration
      Information, which is defined in this\n   section.  A complete protocol specification
      that uses this framework\n   MUST specify the means to determine and communicate
      this information\n   between sender and receiver.\n"
    title: 5.1.  General
  - contents:
    - "5.2.  Structure of the Source Block\n   The FEC Framework and FEC scheme exchange
      ADUs in the form of source\n   blocks.  A source block is generated by the FEC
      Framework from an\n   ordered sequence of ADUs.  The allocation of ADUs to blocks
      is\n   dependent on the application.  Note that some ADUs may not be\n   included
      in any block.  Each source block provided to the FEC scheme\n   consists of
      an ordered sequence of ADUs where the following\n   information is provided
      for each ADU:\n   o  A description of the source flow with which the ADU is
      associated.\n   o  The ADU itself.\n   o  The length of the ADU.\n"
    title: 5.2.  Structure of the Source Block
  - contents:
    - "5.3.  Packet Format for FEC Source Packets\n   The packet format for FEC source
      packets MUST be used to transport\n   the payload of an original source packet.
      \ As depicted in Figure 6,\n   it consists of the original packet, optionally
      followed by the\n   Explicit Source FEC Payload ID field.  The FEC scheme determines\n
      \  whether the Explicit Source FEC Payload ID field is required.  This\n   determination
      is specific to each ADU flow.\n                   +------------------------------------+\n
      \                  |             IP Header              |\n                   +------------------------------------+\n
      \                  |          Transport Header          |\n                   +------------------------------------+\n
      \                  |        Application Data Unit       |\n                   +------------------------------------+\n
      \                  |   Explicit Source FEC Payload ID   |\n                   +------------------------------------+\n
      \   Figure 6: Structure of the FEC Packet Format for FEC Source Packets\n   The
      FEC source packets MUST be sent using the same ADU flow as would\n   have been
      used for the original source packets if the FEC Framework\n   were not present.
      \ The transport payload of the FEC source packet\n   MUST consist of the ADU
      followed by the Explicit Source FEC Payload\n   ID field, if required.\n   The
      Explicit Source FEC Payload ID field contains information\n   required to associate
      the source packet with a source block and for\n   the operation of the FEC algorithm,
      and is defined by the FEC scheme.\n   The format of the Source FEC Payload ID
      field is defined by the FEC\n   scheme.  In the case that the FEC scheme or
      CDP defines a means to\n   derive the Source FEC Payload ID from other information
      in the packet\n   (for example, a sequence number used by the application protocol),\n
      \  then the Source FEC Payload ID field is not included in the packet.\n   In
      this case, the original source packet and FEC source packet are\n   identical.\n
      \  In applications where avoidance of IP packet fragmentation is a goal,\n   CDPs
      SHOULD consider the Explicit Source FEC Payload ID size when\n   determining
      the size of ADUs that will be delivered using the FEC\n   Framework.  This is
      because the addition of the Explicit Source FEC\n   Payload ID increases the
      packet length.\n   The Explicit Source FEC Payload ID is placed at the end of
      the\n   packet, so that in the case that Robust Header Compression (ROHC)\n
      \  [RFC3095] or other header compression mechanisms are used, and in the\n   case
      that a ROHC profile is defined for the protocol carried within\n   the transport
      payload (for example, RTP), then ROHC will still be\n   applied for the FEC
      source packets.  Applications that are used with\n   this framework need to
      consider that FEC schemes can add this\n   Explicit Source FEC Payload ID and
      thereby increase the packet size.\n   In many applications, support for FEC
      is added to a pre-existing\n   protocol, and in this case, use of the Explicit
      Source FEC Payload ID\n   can break backward compatibility, since source packets
      are modified.\n"
    - contents:
      - "5.3.1.  Generic Explicit Source FEC Payload ID\n   In order to apply FEC
        protection using multiple FEC schemes to a\n   single source flow, all schemes
        have to use the same Explicit Source\n   FEC Payload ID format.  In order
        to enable this, it is RECOMMENDED\n   that FEC schemes support the Generic
        Explicit Source FEC Payload ID\n   format described below.\n   The Generic
        Explicit Source FEC Payload ID has a length of two octets\n   and consists
        of an unsigned packet sequence number in network-byte\n   order.  The allocation
        of sequence numbers to packets is independent\n   of any FEC scheme and of
        the source block construction, except that\n   the use of this sequence number
        places a constraint on source block\n   construction.  Source packets within
        a given source block MUST have\n   consecutive sequence numbers (where consecutive
        includes wrap-around\n   from the maximum value that can be represented in
        two octets (65535)\n   to 0).  Sequence numbers SHOULD NOT be reused until
        all values in the\n   sequence number space have been used.\n   Note that
        if the original packets of the source flow are already\n   carrying a packet
        sequence number that is at least two bytes long,\n   there is no need to add
        the generic Explicit Source FEC Payload ID\n   and modify the packets.\n"
      title: 5.3.1.  Generic Explicit Source FEC Payload ID
    title: 5.3.  Packet Format for FEC Source Packets
  - contents:
    - "5.4.  Packet Format for FEC Repair Packets\n   The packet format for FEC repair
      packets is shown in Figure 7.  The\n   transport payload consists of a Repair
      FEC Payload ID field followed\n   by repair data generated in the FEC encoding
      process.\n                   +------------------------------------+\n                   |
      \            IP Header              |\n                   +------------------------------------+\n
      \                  |          Transport Header          |\n                   +------------------------------------+\n
      \                  |        Repair FEC Payload ID       |\n                   +------------------------------------+\n
      \                  |           Repair Symbols           |\n                   +------------------------------------+\n
      \             Figure 7: Packet Format for FEC Repair Packets\n   The Repair
      FEC Payload ID field contains information required for the\n   operation of
      the FEC algorithm at the receiver.  This information is\n   defined by the FEC
      scheme.  The format of the Repair FEC Payload ID\n   field is defined by the
      FEC scheme.\n"
    - contents:
      - "5.4.1.  Packet Format for FEC Repair Packets over RTP\n   For FEC schemes
        that specify the use of RTP for repair packets, the\n   packet format for
        repair packets includes an RTP header as shown in\n   Figure 8.\n                   +------------------------------------+\n
        \                  |             IP Header              |\n                   +------------------------------------+\n
        \                  |      Transport Header (UDP)        |\n                   +------------------------------------+\n
        \                  |             RTP Header             |\n                   +------------------------------------+\n
        \                  |       Repair FEC Payload ID        |\n                   +------------------------------------+\n
        \                  |          Repair Symbols            |\n                   +------------------------------------+\n
        \         Figure 8: Packet Format for FEC Repair Packets over RTP\n"
      title: 5.4.1.  Packet Format for FEC Repair Packets over RTP
    title: 5.4.  Packet Format for FEC Repair Packets
  - contents:
    - "5.5.  FEC Framework Configuration Information\n   The FEC Framework Configuration
      Information is information that the\n   FEC Framework needs in order to apply
      FEC protection to the ADU\n   flows.  A complete CDP specification that uses
      the framework\n   specified here MUST include details of how this information
      is\n   derived and communicated between sender and receiver.\n   The FEC Framework
      Configuration Information includes identification\n   of the set of source flows.
      \ For example, in the case of UDP, each\n   source flow is uniquely identified
      by a tuple {source IP address,\n   source UDP port, destination IP address,
      destination UDP port}.  In\n   some applications, some of these fields can contain
      wildcards, so\n   that the flow is identified by a subset of the fields.  In\n
      \  particular, in many applications the limited tuple {destination IP\n   address,
      destination UDP port} is sufficient.\n   A single instance of the FEC Framework
      provides FEC protection for\n   packets of the specified set of source flows,
      by means of one or more\n   packet flows consisting of repair packets.  The
      FEC Framework\n   Configuration Information includes, for each instance of the
      FEC\n   Framework:\n   1.  Identification of the repair flows.\n   2.  For each
      source flow protected by the repair flow(s):\n       A.  Definition of the source
      flow.\n       B.  An integer identifier for this flow definition (i.e., tuple).\n
      \          This identifier MUST be unique among all source flows that\n           are
      protected by the same FEC repair flow.  Integer\n           identifiers can
      be allocated starting from zero and\n           increasing by one for each flow.
      \ However, any random (but\n           still unique) allocation is also possible.
      \ A source flow\n           identifier need not be carried in source packets,
      since\n           source packets are directly associated with a flow by virtue\n
      \          of their packet headers.\n   3.  The FEC Encoding ID, identifying
      the FEC scheme.\n   4.  The length of the Explicit Source FEC Payload ID (in
      octets).\n   5.  Zero or more FEC-Scheme-Specific Information (FSSI) elements,\n
      \      each consisting of a name and a value where the valid element\n       names
      and value ranges are defined by the FEC scheme.\n   Multiple instances of the
      FEC Framework, with separate and\n   independent FEC Framework Configuration
      Information, can be present\n   at a sender or receiver.  A single instance
      of the FEC Framework\n   protects packets of the source flows identified in
      (2) above; i.e.,\n   all packets sent on those flows MUST be FEC source packets
      as defined\n   in Section 5.3.  A single source flow can be protected by multiple\n
      \  instances of the FEC Framework.\n   The integer flow identifier identified
      in (2B) above is a shorthand\n   to identify source flows between the FEC Framework
      and the FEC\n   scheme.  The reason for defining this as an integer, and including
      it\n   in the FEC Framework Configuration Information, is so that the FEC\n
      \  scheme at the sender and receiver can use it to identify the source\n   flow
      with which a recovered packet is associated.  The integer flow\n   identifier
      can therefore take the place of the complete flow\n   description (e.g., UDP
      4-tuple).\n   Whether and how this flow identifier is used is defined by the
      FEC\n   scheme.  Since repair packets can provide protection for multiple\n
      \  source flows, repair packets either would not carry the identifier at\n   all
      or can carry multiple identifiers.  However, in any case, the\n   flow identifier
      associated with a particular source packet can be\n   recovered from the repair
      packets as part of a FEC decoding\n   operation.\n   A single FEC repair flow
      provides repair packets for a single\n   instance of the FEC Framework.  Other
      packets MUST NOT be sent within\n   this flow; i.e., all packets in the FEC
      repair flow MUST be FEC\n   repair packets as defined in Section 5.4 and MUST
      relate to the same\n   FEC Framework instance.\n   In the case that RTP is used
      for repair packets, the identification\n   of the repair packet flow can also
      include the RTP payload type to be\n   used for repair packets.\n   FSSI includes
      the information that is specific to the FEC scheme used\n   by the CDP.  FSSI
      is used to communicate the information that cannot\n   be adequately represented
      otherwise and is essential for proper FEC\n   encoding and decoding operations.
      \ The motivation behind separating\n   the FSSI required only by the sender
      (which is carried in a Sender-\n   Side FEC-Scheme-Specific Information (SS-FSSI)
      container) from the\n   rest of the FSSI is to provide the receiver or the third-party\n
      \  entities a means of controlling the FEC operations at the sender.\n   Any
      FSSI other than the one solely required by the sender MUST be\n   communicated
      via the FSSI container.\n   The variable-length SS-FSSI and FSSI containers
      transmit the\n   information in textual representation and contain zero or more\n
      \  distinct elements, whose descriptions are provided by the fully\n   specified
      FEC schemes.\n   For the CDPs that choose the Session Description Protocol (SDP)\n
      \  [RFC4566] for their multimedia sessions, the ABNF [RFC5234] syntax\n   for
      the SS-FSSI and FSSI containers is provided in Section 4.5 of\n   [RFC6364].\n"
    title: 5.5.  FEC Framework Configuration Information
  - contents:
    - "5.6.  FEC Scheme Requirements\n   In order to be used with this framework,
      a FEC scheme MUST be capable\n   of processing data arranged into blocks of
      ADUs (source blocks).\n   A specification for a new FEC scheme MUST include
      the following:\n   1.  The FEC Encoding ID value that uniquely identifies the
      FEC\n       scheme.  This value MUST be registered with IANA, as described in\n
      \      Section 11.\n   2.  The type, semantics, and encoding format of the Repair
      FEC\n       Payload ID.\n   3.  The name, type, semantics, and text value encoding
      rules for zero\n       or more FEC-Scheme-Specific Information elements.\n   4.
      \ A full specification of the FEC code.\n       This specification MUST precisely
      define the valid FEC-Scheme-\n       Specific Information values, the valid
      FEC Payload ID values, and\n       the valid packet payload sizes (where packet
      payload refers to\n       the space within a packet dedicated to carrying encoding\n
      \      symbols).\n       Furthermore, given a source block as defined in Section
      5.2,\n       valid values of the FEC-Scheme-Specific Information, a valid\n
      \      Repair FEC Payload ID value, and a valid packet payload size, the\n       specification
      MUST uniquely define the values of the encoding\n       symbols to be included
      in the repair packet payload of a packet\n       with the given Repair FEC Payload
      ID value.\n       A common and simple way to specify the FEC code to the required\n
      \      level of detail is to provide a precise specification of an\n       encoding
      algorithm that -- given a source block, valid values of\n       the FEC-Scheme-Specific
      Information, a valid Repair FEC Payload\n       ID value, and a valid packet
      payload size as input -- produces\n       the exact value of the encoding symbols
      as output.\n   5.  A description of practical encoding and decoding algorithms.\n
      \      This description need not be to the same level of detail as for\n       the
      encoding above; however, it has to be sufficient to\n       demonstrate that
      encoding and decoding of the code are both\n       possible and practical.\n
      \  FEC scheme specifications MAY additionally define the following:\n      Type,
      semantics, and encoding format of an Explicit Source FEC\n      Payload ID.\n
      \  Whenever a FEC scheme specification defines an 'encoding format' for\n   an
      element, this has to be defined in terms of a sequence of bytes\n   that can
      be embedded within a protocol.  The length of the encoding\n   format either
      MUST be fixed or it MUST be possible to derive the\n   length from examining
      the encoded bytes themselves.  For example, the\n   initial bytes can include
      some kind of length indication.\n   FEC scheme specifications SHOULD use the
      terminology defined in this\n   document and SHOULD follow the following format:\n
      \  1.  Introduction  <Describe the use cases addressed by this FEC\n       scheme>\n
      \  2.  Formats and Codes\n       2.1.  Source FEC Payload ID(s)  <Either define
      the type and\n             format of the Explicit Source FEC Payload ID or define
      how\n             Source FEC Payload ID information is derived from source\n
      \            packets>\n       2.2.  Repair FEC Payload ID  <Define the type
      and format of the\n             Repair FEC Payload ID>\n       2.3.  FEC Framework
      Configuration Information  <Define the names,\n             types, and text
      value encoding formats of the FEC-Scheme-\n             Specific Information
      elements>\n   3.  Procedures  <Describe any procedures that are specific to
      this\n       FEC scheme, in particular derivation and interpretation of the\n
      \      fields in the FEC Payload IDs and FEC-Scheme-Specific\n       Information>\n
      \  4.  FEC Code Specification  <Provide a complete specification of the\n       FEC
      Code>\n   Specifications can include additional sections including examples.\n
      \  Each FEC scheme MUST be specified independently of all other FEC\n   schemes,
      for example, in a separate specification or a completely\n   independent section
      of a larger specification (except, of course, a\n   specification of one FEC
      scheme can include portions of another by\n   reference).  Where an RTP payload
      format is defined for repair data\n   for a specific FEC scheme, the RTP payload
      format and the FEC scheme\n   can be specified within the same document.\n"
    title: 5.6.  FEC Scheme Requirements
  title: 5.  Protocol Specification
- contents:
  - "6.  Feedback\n   Many applications require some kind of feedback on transport\n
    \  performance, e.g., how much data arrived at the receiver, at what\n   rate,
    and when?  When FEC is added to such applications, feedback\n   mechanisms may
    also need to be enhanced to report on the performance\n   of the FEC, e.g., how
    much lost data was recovered by the FEC?\n   When used to provide instrumentation
    for engineering purposes, it is\n   important to remember that FEC is generally
    applied to relatively\n   small blocks of data (in the sense that each block is
    transmitted\n   over a relatively small period of time).  Thus, feedback information\n
    \  that is averaged over longer periods of time will likely not provide\n   sufficient
    information for engineering purposes.  More detailed\n   feedback over shorter
    time scales might be preferred.  For example,\n   for applications using RTP transport,
    see [RFC5725].\n   Applications that use feedback for congestion control purposes
    MUST\n   calculate such feedback on the basis of packets received before FEC\n
    \  recovery is applied.  If this requirement conflicts with other uses\n   of
    the feedback information, then the application MUST be enhanced to\n   support
    information calculated both pre- and post-FEC recovery.  This\n   is to ensure
    that congestion control mechanisms operate correctly\n   based on congestion indications
    received from the network, rather\n   than on post-FEC recovery information that
    would give an inaccurate\n   picture of congestion conditions.\n   New applications
    that require such feedback SHOULD use RTP/RTCP\n   [RFC3550].\n"
  title: 6.  Feedback
- contents:
  - "7.  Transport Protocols\n   This framework is intended to be used to define CDPs
    that operate\n   over transport protocols providing an unreliable datagram service,\n
    \  including in particular the User Datagram Protocol (UDP) and the\n   Datagram
    Congestion Control Protocol (DCCP).\n"
  title: 7.  Transport Protocols
- contents:
  - "8.  Congestion Control\n   This section starts with some informative background
    on the\n   motivation of the normative requirements for congestion control,\n
    \  which are spelled out in Section 8.2.\n"
  - contents:
    - "8.1.  Motivation\n   o  The enforcement of congestion control principles has
      gained a lot\n      of momentum in the IETF over recent years.  While the need
      for\n      congestion control over the open Internet is unquestioned, and the\n
      \     goal of TCP friendliness is generally agreed upon for most (but\n      not
      all) applications, the problem of congestion detection and\n      measurement
      in heterogeneous networks can hardly be considered\n      solved.  Most congestion
      control algorithms detect and measure\n      congestion by taking (primarily
      or exclusively) the packet loss\n      rate into account.  This appears to be
      inappropriate in\n      environments where a large percentage of the packet
      losses are the\n      result of link-layer errors and independent of the network
      load.\n   o  The authors of this document are primarily interested in\n      applications
      where the application reliability requirements and\n      end-to-end reliability
      of the network differ, such that it\n      warrants higher-layer protection
      of the packet stream, e.g., due\n      to the presence of unreliable links in
      the end-to-end path and\n      where real-time, scalability, or other constraints
      prohibit the\n      use of higher-layer (transport or application) feedback.
      \ A\n      typical example for such applications is multicast and broadcast\n
      \     streaming or multimedia transmission over heterogeneous networks.\n      In
      other cases, application reliability requirements can be so\n      high that
      the required end-to-end reliability will be difficult to\n      achieve.  Furthermore,
      the end-to-end network reliability is not\n      necessarily known in advance.\n
      \  o  This FEC Framework is not defined as, nor is it intended to be, a\n      quality-of-service
      (QoS) enhancement tool to combat losses\n      resulting from highly congested
      networks.  It should not be used\n      for such purposes.\n   o  In order to
      prevent such misuse, one approach is to leave\n      standardization to bodies
      most concerned with the problem\n      described above.  However, the IETF defines
      base standards used by\n      several bodies, including the Digital Video Broadcasting
      (DVB)\n      Project, the Third Generation Partnership Project (3GPP), and\n
      \     3GPP2, all of which appear to share the environment and the\n      problem
      described.\n   o  Another approach is to write a clear applicability statement.
      \ For\n      example, one could restrict the use of this framework to networks\n
      \     with certain loss characteristics (e.g., wireless links).\n      However,
      there can be applications where the use of FEC is\n      justified to combat
      congestion-induced packet losses --\n      particularly in lightly loaded networks,
      where congestion is the\n      result of relatively rare random peaks in instantaneous
      traffic\n      load -- thereby intentionally violating congestion control\n
      \     principles.  One possible example for such an application could be\n      a
      no-matter-what, brute-force FEC protection of traffic generated\n      as an
      emergency signal.\n   o  A third approach is to require, at a minimum, that
      the use of this\n      framework with any given application, in any given environment,\n
      \     does not cause congestion issues that the application alone would\n      not
      itself cause; i.e., the use of this framework must not make\n      things worse.\n
      \  o  Taking the above considerations into account, Section 8.2\n      specifies
      a small set of constraints for FEC; these constraints\n      are mandatory for
      all senders compliant with this FEC Framework.\n      Further restrictions can
      be imposed by certain CDPs.\n"
    title: 8.1.  Motivation
  - contents:
    - "8.2.  Normative Requirements\n   o  The bandwidth of FEC repair data MUST NOT
      exceed the bandwidth of\n      the original source data being protected (without
      the possible\n      addition of an Explicit Source FEC Payload ID).  This disallows\n
      \     the (static or dynamic) use of excessively strong FEC to combat\n      high
      packet loss rates, which can otherwise be chosen by naively\n      implemented
      dynamic FEC-strength selection mechanisms.  We\n      acknowledge that there
      are a few exotic applications, e.g., IP\n      traffic from space-based senders,
      or senders in certain hardened\n      military devices, that could warrant a
      higher FEC strength.\n      However, in this specification, we give preference
      to the overall\n      stability and network friendliness of average applications.\n
      \  o  Whenever the source data rate is adapted due to the operation of\n      congestion
      control mechanisms, the FEC repair data rate MUST be\n      similarly adapted.\n"
    title: 8.2.  Normative Requirements
  title: 8.  Congestion Control
- contents:
  - "9.  Security Considerations\n   First of all, it must be clear that the application
    of FEC protection\n   to a stream does not provide any kind of security.  On the
    contrary,\n   the FEC Framework itself could be subject to attacks or could pose\n
    \  new security risks.  The goals of this section are to state the\n   problem,
    discuss the risks, and identify solutions when feasible.  It\n   also defines
    a mandatory-to-implement (but not mandatory-to-use)\n   security scheme.\n"
  - contents:
    - "9.1.  Problem Statement\n   A content delivery system is potentially subject
      to many attacks.\n   Attacks can target the content, the CDP, or the network
      itself, with\n   completely different consequences, particularly in terms of
      the\n   number of impacted nodes.\n   Attacks can have several goals:\n   o
      \ They can try to give access to confidential content (e.g., in the\n      case
      of non-free content).\n   o  They can try to corrupt the source flows (e.g.,
      to prevent a\n      receiver from using them), which is a form of denial-of-service\n
      \     (DoS) attack.\n   o  They can try to compromise the receiver's behavior
      (e.g., by\n      making the decoding of an object computationally expensive),
      which\n      is another form of DoS attack.\n   o  They can try to compromise
      the network's behavior (e.g., by\n      causing congestion within the network),
      which potentially impacts\n      a large number of nodes.\n   These attacks
      can be launched either against the source and/or repair\n   flows (e.g., by
      sending fake FEC source and/or repair packets) or\n   against the FEC parameters
      that are sent either in-band (e.g., in the\n   Repair FEC Payload ID or in the
      Explicit Source FEC Payload ID) or\n   out-of-band (e.g., in the FEC Framework
      Configuration Information).\n   Several dimensions to the problem need to be
      considered.  The first\n   one is the way the FEC Framework is used.  The FEC
      Framework can be\n   used end-to-end, i.e., it can be included in the final
      end-device\n   where the upper application runs, or the FEC Framework can be
      used in\n   middleboxes, for instance, to globally protect several source flows\n
      \  exchanged between two or more distant sites.\n   A second dimension is the
      threat model.  When the FEC Framework\n   operates in the end-device, this device
      (e.g., a personal computer)\n   might be subject to attacks.  Here, the attacker
      is either the end-\n   user (who might want to access confidential content)
      or somebody\n   else.  In all cases, the attacker has access to the end-device
      but\n   does not necessarily fully control this end-device (a secure domain\n
      \  can exist).  Similarly, when the FEC Framework operates in a\n   middlebox,
      this middlebox can be subject to attacks or the attacker\n   can gain access
      to it.  The threats can also concern the end-to-end\n   transport (e.g., through
      the Internet).  Here, examples of threats\n   include the transmission of fake
      FEC source or repair packets; the\n   replay of valid packets; the drop, delay,
      or misordering of packets;\n   and, of course, traffic eavesdropping.\n   The
      third dimension consists in the desired security services.  Among\n   them,
      the content integrity and sender authentication services are\n   probably the
      most important features.  We can also mention DoS\n   mitigation, anti-replay
      protection, or content confidentiality.\n   Finally, the fourth dimension consists
      in the security tools\n   available.  This is the case of the various Digital
      Rights Management\n   (DRM) systems, defined outside of the context of the IETF,
      that can\n   be proprietary solutions.  Otherwise, the Secure Real-Time Transport\n
      \  Protocol (SRTP) [RFC3711] and IPsec/Encapsulating Security Payload\n   (IPsec/ESP)
      [RFC4303] are two tools that can turn out to be useful in\n   the context of
      the FEC Framework.  Note that using SRTP requires that\n   the application generate
      RTP source flows and, when applied below the\n   FEC Framework, that both the
      FEC source and repair packets be regular\n   RTP packets.  Therefore, SRTP is
      not considered to be a universal\n   solution applicable in all use cases.\n
      \  In the following sections, we further discuss security aspects\n   related
      to the use of the FEC Framework.\n"
    title: 9.1.  Problem Statement
  - contents:
    - '9.2.  Attacks against the Data Flows

      '
    - contents:
      - "9.2.1.  Access to Confidential Content\n   Access control to the source flow
        being transmitted is typically\n   provided by means of encryption.  This
        encryption can be done by the\n   content provider itself, or within the application
        (for instance, by\n   using SRTP [RFC3711]), or at the network layer on a
        per-packet basis\n   when IPsec/ESP is used [RFC4303].  If confidentiality
        is a concern,\n   it is RECOMMENDED that one of these solutions be used.  Even
        if we\n   mention these attacks here, they are neither related to nor\n   facilitated
        by the use of FEC.\n   Note that when encryption is applied, this encryption
        MUST be applied\n   either on the source data before the FEC protection or,
        if done after\n   the FEC protection, on both the FEC source packets and repair
        packets\n   (and an encryption at least as cryptographically secure as the\n
        \  encryption applied on the FEC source packets MUST be used for the FEC\n
        \  repair packets).  Otherwise, if encryption were to be performed only\n
        \  on the FEC source packets after FEC encoding, a non-authorized\n   receiver
        could be able to recover the source data after decoding the\n   FEC repair
        packets, provided that a sufficient number of such packets\n   were available.\n
        \  The following considerations apply when choosing where to apply\n   encryption
        (and more generally where to apply security services\n   beyond encryption).
        \ Once decryption has taken place, the source data\n   is in plaintext.  The
        full path between the output of the deciphering\n   module and the final destination
        (e.g., the TV display in the case of\n   a video) MUST be secured, in order
        to prevent any unauthorized access\n   to the source data.\n   When the FEC
        Framework endpoint is the end-system (i.e., where the\n   upper application
        runs) and if the threat model includes the\n   possibility that an attacker
        has access to this end-system, then the\n   end-system architecture is very
        important.  More precisely, in order\n   to prevent an attacker from getting
        hold of the plaintext, all\n   processing, once deciphering has taken place,
        MUST occur in a\n   protected environment.  If encryption is applied after
        FEC protection\n   at the sending side (i.e., below the FEC Framework), it
        means that\n   FEC decoding MUST take place in the protected environment.
        \ With\n   certain use cases, this MAY be complicated or even impossible.
        \ In\n   such cases, applying encryption before FEC protection is preferred.\n
        \  When the FEC Framework endpoint is a middlebox, the recovered source\n
        \  flow, after FEC decoding, SHOULD NOT be sent in plaintext to the\n   final
        destination(s) if the threat model includes the possibility\n   that an attacker
        eavesdrops on the traffic.  In that case, it is\n   preferable to apply encryption
        before FEC protection.\n   In some cases, encryption could be applied both
        before and after the\n   FEC protection.  The considerations described above
        still apply in\n   such cases.\n"
      title: 9.2.1.  Access to Confidential Content
    - contents:
      - "9.2.2.  Content Corruption\n   Protection against corruptions (e.g., against
        forged FEC source/\n   repair packets) is achieved by means of a content integrity\n
        \  verification/source authentication scheme.  This service is usually\n   provided
        at the packet level.  In this case, after removing all the\n   forged packets,
        the source flow might sometimes be recovered.\n   Several techniques can provide
        this content integrity/source\n   authentication service:\n   o  At the application
        layer, SRTP [RFC3711] provides several\n      solutions to check the integrity
        and authenticate the source of\n      RTP and RTCP messages, among other services.
        \ For instance, when\n      associated with the Timed Efficient Stream Loss-Tolerant\n
        \     Authentication (TESLA) [RFC4383], SRTP is an attractive solution\n      that
        is robust to losses, provides a true authentication/integrity\n      service,
        and does not create any prohibitive processing load or\n      transmission
        overhead.  Yet, with TESLA, checking a packet\n      requires a small delay
        (a second or more) after its reception.\n      Whether or not this extra delay,
        both in terms of startup delay at\n      the client and end-to-end delay,
        is appropriate depends on the\n      target use case.  In some situations,
        this might degrade the user\n      experience.  In other situations, this
        will not be an issue.\n      Other building blocks can be used within SRTP
        to provide content\n      integrity/authentication services.\n   o  At the
        network layer, IPsec/ESP [RFC4303] offers (among other\n      services) an
        integrity verification mechanism that can be used to\n      provide authentication/content
        integrity services.\n   It is up to the developer and the person in charge
        of deployment, who\n   know the security requirements and features of the
        target application\n   area, to define which solution is the most appropriate.
        \ Nonetheless,\n   it is RECOMMENDED that at least one of these techniques
        be used.\n   Note that when integrity protection is applied, it is RECOMMENDED\n
        \  that it take place on both FEC source and repair packets.  The\n   motivation
        is to keep corrupted packets from being considered during\n   decoding, as
        such packets would often lead to a decoding failure or\n   result in a corrupted
        decoded source flow.\n"
      title: 9.2.2.  Content Corruption
    title: 9.2.  Attacks against the Data Flows
  - contents:
    - "9.3.  Attacks against the FEC Parameters\n   Attacks on these FEC parameters
      can prevent the decoding of the\n   associated object.  For instance, modifying
      the finite field size of\n   a Reed-Solomon FEC scheme (when applicable) will
      lead a receiver to\n   consider a different FEC code.\n   Therefore, it is RECOMMENDED
      that security measures be taken to\n   guarantee the integrity of the FEC Framework
      Configuration\n   Information.  Since the FEC Framework does not define how
      the FEC\n   Framework Configuration Information is communicated from sender
      to\n   receiver, we cannot provide further recommendations on how to\n   guarantee
      its integrity.  However, any complete CDP specification\n   MUST give recommendations
      on how to achieve it.  When the FEC\n   Framework Configuration Information
      is sent out-of-band, e.g., in a\n   session description, it SHOULD be protected,
      for instance, by\n   digitally signing it.\n   Attacks are also possible against
      some FEC parameters included in the\n   Explicit Source FEC Payload ID and Repair
      FEC Payload ID.  For\n   instance, modifying the Source Block Number of a FEC
      source or repair\n   packet will lead a receiver to assign this packet to a
      wrong block.\n   Therefore, it is RECOMMENDED that security measures be taken
      to\n   guarantee the integrity of the Explicit Source FEC Payload ID and\n   Repair
      FEC Payload ID.  To that purpose, one of the packet-level\n   source authentication/content
      integrity techniques described in\n   Section 9.2.2 can be used.\n"
    title: 9.3.  Attacks against the FEC Parameters
  - contents:
    - "9.4.  When Several Source Flows Are to Be Protected Together\n   When several
      source flows, with different security requirements, need\n   to be FEC protected
      jointly, within a single FEC Framework instance,\n   then each flow MAY be processed
      appropriately, before the protection.\n   For instance, source flows that require
      access control MAY be\n   encrypted before they are FEC protected.\n   There
      are also situations where the only insecure domain is the one\n   over which
      the FEC Framework operates.  In that case, this situation\n   MAY be addressed
      at the network layer, using IPsec/ESP (see\n   Section 9.5), even if only a
      subset of the source flows has strict\n   security requirements.\n   Since the
      use of the FEC Framework should not add any additional\n   threat, it is RECOMMENDED
      that the FEC Framework aggregate flow be in\n   line with the maximum security
      requirements of the individual source\n   flows.  For instance, if denial-of-service
      (DoS) protection is\n   required, an integrity protection SHOULD be provided
      below the FEC\n   Framework, using, for instance, IPsec/ESP.\n   Generally speaking,
      whenever feasible, it is RECOMMENDED that FEC\n   protecting flows with totally
      different security requirements be\n   avoided.  Otherwise, significant processing
      overhead would be added\n   to protect source flows that do not need it.\n"
    title: 9.4.  When Several Source Flows Are to Be Protected Together
  - contents:
    - "9.5.  Baseline Secure FEC Framework Operation\n   The FEC Framework has been
      defined in such a way to be independent\n   from the application that generates
      source flows.  Some applications\n   might use purely unidirectional flows,
      while other applications might\n   also use unicast feedback from the receivers.
      \ For instance, this is\n   the case when considering RTP/RTCP-based source
      flows.\n   This section describes a baseline mode of secure FEC Framework\n
      \  operation based on the application of the IPsec protocol, which is\n   one
      possible solution to solve or mitigate the security threats\n   introduced by
      the use of the FEC Framework.\n   Two related documents are of interest.  First,
      Section 5.1 of\n   [RFC5775] defines a baseline secure Asynchronous Layered
      Coding (ALC)\n   operation for sender-to-group transmissions, assuming the presence
      of\n   a single sender and a source-specific multicast (SSM) or SSM-like\n   operation.
      \ The proposed solution, based on IPsec/ESP, can be used to\n   provide a baseline
      FEC Framework secure operation, for the downstream\n   source flow.\n   Second,
      Section 7.1 of [RFC5740] defines a baseline secure NACK-\n   Oriented Reliable
      Multicast (NORM) operation, for sender-to-group\n   transmissions as well as
      unicast feedback from receivers.  Here, it\n   is also assumed there is a single
      sender.  The proposed solution is\n   also based on IPsec/ESP.  However, the
      difference with respect to\n   [RFC5775] relies on the management of IPsec Security
      Associations\n   (SAs) and corresponding Security Policy Database (SPD) entries,
      since\n   NORM requires a second set of SAs and SPD entries to be defined to\n
      \  protect unicast feedback from receivers.\n   Note that the IPsec/ESP requirement
      profiles outlined in [RFC5775]\n   and [RFC5740] are commonly available on many
      potential hosts.  They\n   can form the basis of a secure mode of operation.
      \ Configuration and\n   operation of IPsec typically require privileged user
      authorization.\n   Automated key management implementations are typically configured\n
      \  with the privileges necessary to allow the needed system IPsec\n   configuration.\n"
    title: 9.5.  Baseline Secure FEC Framework Operation
  title: 9.  Security Considerations
- contents:
  - "10.  Operations and Management Considerations\n   The question of operating and
    managing the FEC Framework and the\n   associated FEC scheme(s) is of high practical
    importance.  The goals\n   of this section are to discuss aspects and recommendations
    related to\n   specific deployments and solutions.\n   In particular, this section
    discusses the questions of\n   interoperability across vendors/use cases and whether
    defining\n   mandatory-to-implement (but not mandatory-to-use) solutions is\n
    \  beneficial.\n"
  - contents:
    - "10.1.  What Are the Key Aspects to Consider?\n   Several aspects need to be
      considered, since they will directly\n   impact the way the FEC Framework and
      the associated FEC schemes can\n   be operated and managed.\n   This section
      lists them as follows:\n   1.  A Single Small Generic Component within a Larger
      (and Often\n       Legacy) Solution: The FEC Framework is one component within
      a\n       larger solution that includes one or several upper-layer\n       applications
      (that generate one or several ADU flows) and an\n       underlying protocol
      stack.  A key design principle is that the\n       FEC Framework should be able
      to work without making any\n       assumption with respect to either the upper-layer
      application(s)\n       or the underlying protocol stack, even if there are special
      cases\n       where assumptions are made.\n   2.  One-to-One with Feedback vs.
      One-to-Many with Feedback vs. One-\n       to-Many without Feedback Scenarios:
      The FEC Framework can be used\n       in use cases that completely differ from
      one another.  Some use\n       cases are one-way (e.g., in broadcast networks),
      with either a\n       one-to-one, one-to-many, or many-to-many transmission
      model, and\n       the receiver(s) cannot send any feedback to the sender(s).
      \ Other\n       use cases follow a bidirectional one-to-one, one-to-many, or\n
      \      many-to-many scenario, and the receiver(s) can send feedback to\n       the
      sender(s).\n   3.  Non-FEC Framework Capable Receivers: With the one-to-many
      and\n       many-to-many use cases, the receiver population might have\n       different
      capabilities with respect to the FEC Framework itself\n       and the supported
      FEC schemes.  Some receivers might not be\n       capable of decoding the repair
      packets belonging to a particular\n       FEC scheme, while some other receivers
      might not support the FEC\n       Framework at all.\n   4.  Internet vs. Non-Internet
      Networks: The FEC Framework can be\n       useful in many use cases that use
      a transport network that is not\n       the public Internet (e.g., with IPTV
      or Mobile TV).  In such\n       networks, the operational and management considerations
      can be\n       achieved through an open or proprietary solution, which is\n
      \      specified outside of the IETF.\n   5.  Congestion Control Considerations:
      See Section 8 for a discussion\n       on whether or not congestion control
      is needed, and its\n       relationships with the FEC Framework.\n   6.  Within
      End-Systems vs. within Middleboxes: The FEC Framework can\n       be used within
      end-systems, very close to the upper-layer\n       application, or within dedicated
      middleboxes (for instance, when\n       it is desired to protect one or several
      flows while they cross a\n       lossy channel between two or more remote sites).\n
      \  7.  Protecting a Single Flow vs. Several Flows Globally: The FEC\n       Framework
      can be used to protect a single flow or several flows\n       globally.\n"
    title: 10.1.  What Are the Key Aspects to Consider?
  - contents:
    - "10.2.  Operational and Management Recommendations\n   Overall, from the discussion
      in Section 10.1, it is clear that the\n   CDPs and FEC schemes compatible with
      the FEC Framework differ widely\n   in their capabilities, application, and
      deployment scenarios such\n   that a common operation and management method
      or protocol that works\n   well for all of them would be too complex to define.
      \ Thus, as a\n   design choice, the FEC Framework does not dictate the use of
      any\n   particular technology or protocol for transporting FEC data, managing\n
      \  the hosts, signaling the configuration information, or encoding the\n   configuration
      information.  This provides flexibility and is one of\n   the main goals of
      the FEC Framework.  However, this section gives\n   some RECOMMENDED guidelines.\n
      \  1.  A Single Small Generic Component within a Larger (and Often\n       Legacy)
      Solution: It is anticipated that the FEC Framework will\n       often be used
      to protect one or several RTP streams.  Therefore,\n       implementations SHOULD
      make feedback information accessible via\n       RTCP to enable users to take
      advantage of the tools using (or\n       used by) RTCP to operate and manage
      the FEC Framework instance\n       along with the associated FEC schemes.\n
      \  2.  One-to-One with Feedback vs. One-to-Many with Feedback vs. One-\n       to-Many
      without Feedback Scenarios: With use cases that are\n       one-way, the FEC
      Framework sender does not have any way to gather\n       feedback from receivers.
      \ With use cases that are bidirectional,\n       the FEC Framework sender can
      collect detailed feedback (e.g., in\n       the case of a one-to-one scenario)
      or at least occasional\n       feedback (e.g., in the case of a multicast, one-to-many\n
      \      scenario).  All these applications have naturally different\n       operational
      and management aspects.  They also have different\n       requirements or features,
      if any, for collecting feedback,\n       processing it, and acting on it.  The
      data structures for\n       carrying the feedback also vary.\n       Implementers
      SHOULD make feedback available using either an\n       in-band or out-of-band
      asynchronous reporting mechanism.  When an\n       out-of-band solution is preferred,
      a standardized reporting\n       mechanism, such as Syslog [RFC5424] or Simple
      Network Management\n       Protocol (SNMP) notifications [RFC3411], is RECOMMENDED.
      \ When\n       required, a mapping mechanism between the Syslog and SNMP\n       reporting
      mechanisms could be used, as described in [RFC5675] and\n       [RFC5676].\n
      \  3.  Non-FEC Framework Capable Receivers: Section 5.3 gives\n       recommendations
      on how to provide backward compatibility in the\n       presence of receivers
      that cannot support the FEC scheme being\n       used or the FEC Framework itself:
      basically, the use of Explicit\n       Source FEC Payload ID is banned.  Additionally,
      a non-FEC\n       Framework capable receiver MUST also have a means not to receive\n
      \      the repair packets that it will not be able to decode in the\n       first
      place or a means to identify and discard them appropriately\n       upon receiving
      them.  This SHOULD be achieved by sending repair\n       packets on a different
      transport-layer flow.  In the case of RTP\n       transport, and if both source
      and repair packets will be sent on\n       the same transport-layer flow, this
      SHOULD be achieved by using\n       an RTP framing for FEC repair packets with
      a different payload\n       type.  It is the responsibility of the sender to
      select the\n       appropriate mechanism when needed.\n   4.  Within End-Systems
      vs. within Middleboxes: When the FEC Framework\n       is used within middleboxes,
      it is RECOMMENDED that the paths\n       between the hosts where the sending
      applications run and the\n       middlebox that performs FEC encoding be as
      reliable as possible,\n       i.e., not be prone to packet loss, packet reordering,
      or varying\n       delays in delivering packets.\n       Similarly, when the
      FEC Framework is used within middleboxes, it\n       is RECOMMENDED that the
      paths be as reliable as possible between\n       the middleboxes that perform
      FEC decoding and the end-systems\n       where the receiving applications operate.\n
      \  5.  Management of Communication Issues before Reaching the Sending\n       FECFRAME
      Instance: Let us consider situations where the FEC\n       Framework is used
      within middleboxes.  At the sending side, the\n       general reliability recommendation
      for the path between the\n       sending applications and the middlebox is important,
      but it may\n       not guarantee that a loss, reordering, or long delivery delay\n
      \      cannot happen, for whatever reason.  If such a rare event\n       happens,
      this event SHOULD NOT compromise the operation of the\n       FECFRAME instances,
      at either the sending side or the receiving\n       side.  This is particularly
      important with FEC schemes that do\n       not modify the ADU for backward-compatibility
      purposes (i.e., do\n       not use any Explicit Source FEC Payload ID) and rely
      on, for\n       instance, the RTP sequence number field to identify FEC source\n
      \      packets within their source block.  In this case, packet loss or\n       packet
      reordering leads to a gap in the RTP sequence number space\n       seen by the
      FECFRAME instance.  Similarly, varying delay in\n       delivering packets over
      this path can lead to significant timing\n       issues.  With FEC schemes that
      indicate in the Repair FEC Payload\n       ID, for each source block, the base
      RTP sequence number and\n       number of consecutive RTP packets that belong
      to this source\n       block, a missing ADU or an ADU delivered out of order
      could cause\n       the FECFRAME sender to switch to a new source block.  However,\n
      \      some FEC schemes and/or receivers may not necessarily handle such\n       varying
      source block sizes.  In this case, one could consider\n       duplicating the
      last ADU received before the loss, or inserting\n       zeroed ADU(s), depending
      on the nature of the ADU flow.\n       Implementers SHOULD consider the consequences
      of such alternative\n       approaches, based on their use cases.\n   6.  Protecting
      a Single Flow vs. Several Flows Globally: In the\n       general case, the various
      ADU flows that are globally protected\n       can have different features, and
      in particular different real-\n       time requirements (in the case of real-time
      flows).  The process\n       of globally protecting these flows SHOULD take
      into account the\n       requirements of each individual flow.  In particular,
      it would be\n       counterproductive to add repair traffic to a real-time flow
      for\n       which the FEC decoding delay at a receiver makes decoded ADUs for\n
      \      this flow useless because they do not satisfy the associated\n       real-time
      constraints.  From a practical point of view, this\n       means that the source
      block creation process at the sending FEC\n       Framework instance SHOULD
      consider the most stringent real-time\n       requirements of the ADU flows
      being globally protected.\n   7.  ADU Flow Bundle Definition and Flow Delivery:
      By design, a repair\n       flow might enable a receiver to recover the ADU
      flow(s) that it\n       protects even if none of the associated FEC source packets
      are\n       received.  Therefore, when defining the bundle of ADU flows that\n
      \      are globally protected and when defining which receiver receives\n       which
      flow, the sender SHOULD make sure that the ADU flow(s) and\n       repair flow(s)
      of that bundle will only be received by receivers\n       that are authorized
      to receive all the ADU flows of that bundle.\n       See Section 9.4 for additional
      recommendations for situations\n       where strict access control for ADU flows
      is needed.\n       Additionally, when multiple ADU flows are globally protected,
      a\n       receiver that wants to benefit from FECFRAME loss protection\n       SHOULD
      receive all the ADU flows of the bundle.  Otherwise, the\n       missing FEC
      source packets would be considered lost, which might\n       significantly reduce
      the efficiency of the FEC scheme.\n"
    title: 10.2.  Operational and Management Recommendations
  title: 10.  Operations and Management Considerations
- contents:
  - "11.  IANA Considerations\n   FEC schemes for use with this framework are identified
    in protocols\n   using FEC Encoding IDs.  Values of FEC Encoding IDs are subject
    to\n   IANA registration.  For this purpose, this document creates a new\n   registry
    called the \"FEC Framework (FECFRAME) FEC Encoding IDs\".\n   The values that
    can be assigned within the \"FEC Framework (FECFRAME)\n   FEC Encoding IDs\" registry
    are numeric indexes in the range (0, 255).\n   Values of 0 and 255 are reserved.
    \ Assignment requests are granted on\n   an IETF Review basis as defined in [RFC5226].
    \ Section 5.6 defines\n   explicit requirements that documents defining new FEC
    Encoding IDs\n   should meet.\n"
  title: 11.  IANA Considerations
- contents:
  - "12.  Acknowledgments\n   This document is based in part on [FEC-SF], and so thanks
    are due to\n   the additional authors of that document: Mike Luby, Magnus\n   Westerlund,
    and Stephan Wenger.  That document was in turn based on\n   the FEC Streaming
    Protocol defined by 3GPP in [MBMSTS], and thus,\n   thanks are also due to the
    participants in 3GPP SA Working Group 4.\n   Further thanks are due to the members
    of the FECFRAME Working Group\n   for their comments and reviews.\n"
  title: 12.  Acknowledgments
- contents:
  - '13.  References

    '
  - contents:
    - "13.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3411]  Harrington, D., Presuhn, R., and B. Wijnen, \"An\n              Architecture
      for Describing Simple Network Management\n              Protocol (SNMP) Management
      Frameworks\", STD 62, RFC 3411,\n              December 2002.\n   [RFC5052]
      \ Watson, M., Luby, M., and L. Vicisano, \"Forward Error\n              Correction
      (FEC) Building Block\", RFC 5052, August 2007.\n   [RFC5226]  Narten, T. and
      H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations
      Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n   [RFC5234]
      \ Crocker, D., Ed., and P. Overell, \"Augmented BNF for\n              Syntax
      Specifications: ABNF\", STD 68, RFC 5234,\n              January 2008.\n   [RFC5424]
      \ Gerhards, R., \"The Syslog Protocol\", RFC 5424, March 2009.\n"
    title: 13.1.  Normative References
  - contents:
    - "13.2.  Informative References\n   [FEC-SF]   Watson, M., Luby, M., Westerlund,
      M., and S. Wenger,\n              \"Forward Error Correction (FEC) Streaming
      Framework\", Work\n              in Progress, July 2005.\n   [MBMSTS]   3GPP,
      \"Multimedia Broadcast/Multicast Service (MBMS);\n              Protocols and
      codecs\", 3GPP TS 26.346, March 2009,\n              <http://ftp.3gpp.org/specs/html-info/26346.htm>.\n
      \  [RFC3095]  Bormann, C., Burmeister, C., Degermark, M., Fukushima, H.,\n              Hannu,
      H., Jonsson, L-E., Hakenberg, R., Koren, T., Le,\n              K., Liu, Z.,
      Martensson, A., Miyazaki, A., Svanbro, K.,\n              Wiebke, T., Yoshimura,
      T., and H. Zheng, \"RObust Header\n              Compression (ROHC): Framework
      and four profiles: RTP, UDP,\n              ESP, and uncompressed\", RFC 3095,
      July 2001.\n   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.\n
      \             Jacobson, \"RTP: A Transport Protocol for Real-Time\n              Applications\",
      STD 64, RFC 3550, July 2003.\n   [RFC3711]  Baugher, M., McGrew, D., Naslund,
      M., Carrara, E., and K.\n              Norrman, \"The Secure Real-time Transport
      Protocol (SRTP)\",\n              RFC 3711, March 2004.\n   [RFC4303]  Kent,
      S., \"IP Encapsulating Security Payload (ESP)\",\n              RFC 4303, December
      2005.\n   [RFC4383]  Baugher, M. and E. Carrara, \"The Use of Timed Efficient\n
      \             Stream Loss-Tolerant Authentication (TESLA) in the Secure\n              Real-time
      Transport Protocol (SRTP)\", RFC 4383,\n              February 2006.\n   [RFC4566]
      \ Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n              Description
      Protocol\", RFC 4566, July 2006.\n   [RFC4588]  Rey, J., Leon, D., Miyazaki,
      A., Varsa, V., and R.\n              Hakenberg, \"RTP Retransmission Payload
      Format\", RFC 4588,\n              July 2006.\n   [RFC5675]  Marinov, V. and
      J. Schoenwaelder, \"Mapping Simple Network\n              Management Protocol
      (SNMP) Notifications to SYSLOG\n              Messages\", RFC 5675, October
      2009.\n   [RFC5676]  Schoenwaelder, J., Clemm, A., and A. Karmakar,\n              \"Definitions
      of Managed Objects for Mapping SYSLOG\n              Messages to Simple Network
      Management Protocol (SNMP)\n              Notifications\", RFC 5676, October
      2009.\n   [RFC5725]  Begen, A., Hsu, D., and M. Lague, \"Post-Repair Loss RLE\n
      \             Report Block Type for RTP Control Protocol (RTCP) Extended\n              Reports
      (XRs)\", RFC 5725, February 2010.\n   [RFC5740]  Adamson, B., Bormann, C., Handley,
      M., and J. Macker,\n              \"NACK-Oriented Reliable Multicast (NORM)
      Transport\n              Protocol\", RFC 5740, November 2009.\n   [RFC5775]
      \ Luby, M., Watson, M., and L. Vicisano, \"Asynchronous\n              Layered
      Coding (ALC) Protocol Instantiation\", RFC 5775,\n              April 2010.\n
      \  [RFC6364]  Begen, A., \"Session Description Protocol Elements for FEC\n              Framework\",
      RFC 6364, October 2011.\n"
    title: 13.2.  Informative References
  title: 13.  References
- contents:
  - "Authors' Addresses\n   Mark Watson\n   Netflix, Inc.\n   100 Winchester Circle\n
    \  Los Gatos, CA  95032\n   USA\n   EMail: watsonm@netflix.com\n   Ali Begen\n
    \  Cisco\n   181 Bay Street\n   Toronto, ON  M5J 2T3\n   Canada\n   EMail: abegen@cisco.com\n
    \  Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee; Montbonnot\n
    \  ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n   URI:
    \  http://planete.inrialpes.fr/people/roca/\n"
  title: Authors' Addresses
