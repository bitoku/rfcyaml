- contents:
  - '      Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n
    \  level protocol for distributed, collaborative, hypertext information\n   systems.
    \ This document defines HTTP/1.1 conditional requests,\n   including metadata
    header fields for indicating state changes,\n   request header fields for making
    preconditions on such state, and\n   rules for constructing the responses to a
    conditional request when\n   one or more preconditions evaluate to false.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7232.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Conformance and Error Handling .............................4\n      1.2.
    Syntax Notation ............................................4\n   2. Validators
    ......................................................5\n      2.1. Weak versus
    Strong .........................................5\n      2.2. Last-Modified ..............................................7\n
    \          2.2.1. Generation ..........................................7\n           2.2.2.
    Comparison ..........................................8\n      2.3. ETag .......................................................9\n
    \          2.3.1. Generation .........................................10\n           2.3.2.
    Comparison .........................................10\n           2.3.3. Example:
    Entity-Tags Varying on\n                  Content-Negotiated Resources .......................11\n
    \     2.4. When to Use Entity-Tags and Last-Modified Dates ...........12\n   3.
    Precondition Header Fields .....................................13\n      3.1.
    If-Match ..................................................13\n      3.2. If-None-Match
    .............................................14\n      3.3. If-Modified-Since
    .........................................16\n      3.4. If-Unmodified-Since .......................................17\n
    \     3.5. If-Range ..................................................18\n   4.
    Status Code Definitions ........................................18\n      4.1.
    304 Not Modified ..........................................18\n      4.2. 412
    Precondition Failed ...................................19\n   5. Evaluation .....................................................19\n
    \  6. Precedence .....................................................20\n   7.
    IANA Considerations ............................................22\n      7.1.
    Status Code Registration ..................................22\n      7.2. Header
    Field Registration .................................22\n   8. Security Considerations
    ........................................22\n   9. Acknowledgments ................................................23\n
    \  10. References ....................................................24\n      10.1.
    Normative References .....................................24\n      10.2. Informative
    References ...................................24\n   Appendix A. Changes from
    RFC 2616 .................................25\n   Appendix B. Imported ABNF .........................................25\n
    \  Appendix C. Collected ABNF ........................................26\n   Index
    .............................................................27\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Conditional requests are HTTP requests [RFC7231] that include
    one or\n   more header fields indicating a precondition to be tested before\n
    \  applying the method semantics to the target resource.  This document\n   defines
    the HTTP/1.1 conditional request mechanisms in terms of the\n   architecture,
    syntax notation, and conformance criteria defined in\n   [RFC7230].\n   Conditional
    GET requests are the most efficient mechanism for HTTP\n   cache updates [RFC7234].
    \ Conditionals can also be applied to\n   state-changing methods, such as PUT
    and DELETE, to prevent the \"lost\n   update\" problem: one client accidentally
    overwriting the work of\n   another client that has been acting in parallel.\n
    \  Conditional request preconditions are based on the state of the\n   target
    resource as a whole (its current value set) or the state as\n   observed in a
    previously obtained representation (one value in that\n   set).  A resource might
    have multiple current representations, each\n   with its own observable state.
    \ The conditional request mechanisms\n   assume that the mapping of requests to
    a \"selected representation\"\n   (Section 3 of [RFC7231]) will be consistent
    over time if the server\n   intends to take advantage of conditionals.  Regardless,
    if the\n   mapping is inconsistent and the server is unable to select the\n   appropriate
    representation, then no harm will result when the\n   precondition evaluates to
    false.\n   The conditional request preconditions defined by this specification\n
    \  (Section 3) are evaluated when applicable to the recipient\n   (Section 5)
    according to their order of precedence (Section 6).\n"
  - contents:
    - "1.1.  Conformance and Error Handling\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in [RFC2119].\n   Conformance criteria and considerations regarding error handling
      are\n   defined in Section 2.5 of [RFC7230].\n"
    title: 1.1.  Conformance and Error Handling
  - contents:
    - "1.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234] with a list extension, defined in Section
      7 of\n   [RFC7230], that allows for compact definition of comma-separated\n
      \  lists using a '#' operator (similar to how the '*' operator indicates\n   repetition).
      \ Appendix B describes rules imported from other\n   documents.  Appendix C
      shows the collected grammar with all list\n   operators expanded to standard
      ABNF notation.\n"
    title: 1.2.  Syntax Notation
  title: 1.  Introduction
- contents:
  - "2.  Validators\n   This specification defines two forms of metadata that are
    commonly\n   used to observe resource state and test for preconditions:\n   modification
    dates (Section 2.2) and opaque entity tags\n   (Section 2.3).  Additional metadata
    that reflects resource state has\n   been defined by various extensions of HTTP,
    such as Web Distributed\n   Authoring and Versioning (WebDAV, [RFC4918]), that
    are beyond the\n   scope of this specification.  A resource metadata value is
    referred\n   to as a \"validator\" when it is used within a precondition.\n"
  - contents:
    - "2.1.  Weak versus Strong\n   Validators come in two flavors: strong or weak.
      \ Weak validators are\n   easy to generate but are far less useful for comparisons.
      \ Strong\n   validators are ideal for comparisons but can be very difficult
      (and\n   occasionally impossible) to generate efficiently.  Rather than impose\n
      \  that all forms of resource adhere to the same strength of validator,\n   HTTP
      exposes the type of validator in use and imposes restrictions on\n   when weak
      validators can be used as preconditions.\n   A \"strong validator\" is representation
      metadata that changes value\n   whenever a change occurs to the representation
      data that would be\n   observable in the payload body of a 200 (OK) response
      to GET.\n   A strong validator might change for reasons other than a change
      to\n   the representation data, such as when a semantically significant part\n
      \  of the representation metadata is changed (e.g., Content-Type), but\n   it
      is in the best interests of the origin server to only change the\n   value when
      it is necessary to invalidate the stored responses held by\n   remote caches
      and authoring tools.\n   Cache entries might persist for arbitrarily long periods,
      regardless\n   of expiration times.  Thus, a cache might attempt to validate
      an\n   entry using a validator that it obtained in the distant past.  A\n   strong
      validator is unique across all versions of all representations\n   associated
      with a particular resource over time.  However, there is\n   no implication
      of uniqueness across representations of different\n   resources (i.e., the same
      strong validator might be in use for\n   representations of multiple resources
      at the same time and does not\n   imply that those representations are equivalent).\n
      \  There are a variety of strong validators used in practice.  The best\n   are
      based on strict revision control, wherein each change to a\n   representation
      always results in a unique node name and revision\n   identifier being assigned
      before the representation is made\n   accessible to GET.  A collision-resistant
      hash function applied to\n   the representation data is also sufficient if the
      data is available\n   prior to the response header fields being sent and the
      digest does\n   not need to be recalculated every time a validation request
      is\n   received.  However, if a resource has distinct representations that\n
      \  differ only in their metadata, such as might occur with content\n   negotiation
      over media types that happen to share the same data\n   format, then the origin
      server needs to incorporate additional\n   information in the validator to distinguish
      those representations.\n   In contrast, a \"weak validator\" is representation
      metadata that might\n   not change for every change to the representation data.
      \ This\n   weakness might be due to limitations in how the value is calculated,\n
      \  such as clock resolution, an inability to ensure uniqueness for all\n   possible
      representations of the resource, or a desire of the resource\n   owner to group
      representations by some self-determined set of\n   equivalency rather than unique
      sequences of data.  An origin server\n   SHOULD change a weak entity-tag whenever
      it considers prior\n   representations to be unacceptable as a substitute for
      the current\n   representation.  In other words, a weak entity-tag ought to
      change\n   whenever the origin server wants caches to invalidate old responses.\n
      \  For example, the representation of a weather report that changes in\n   content
      every second, based on dynamic measurements, might be grouped\n   into sets
      of equivalent representations (from the origin server's\n   perspective) with
      the same weak validator in order to allow cached\n   representations to be valid
      for a reasonable period of time (perhaps\n   adjusted dynamically based on server
      load or weather quality).\n   Likewise, a representation's modification time,
      if defined with only\n   one-second resolution, might be a weak validator if
      it is possible\n   for the representation to be modified twice during a single
      second\n   and retrieved between those modifications.\n   Likewise, a validator
      is weak if it is shared by two or more\n   representations of a given resource
      at the same time, unless those\n   representations have identical representation
      data.  For example, if\n   the origin server sends the same validator for a
      representation with\n   a gzip content coding applied as it does for a representation
      with no\n   content coding, then that validator is weak.  However, two\n   simultaneous
      representations might share the same strong validator if\n   they differ only
      in the representation metadata, such as when two\n   different media types are
      available for the same representation data.\n   Strong validators are usable
      for all conditional requests, including\n   cache validation, partial content
      ranges, and \"lost update\"\n   avoidance.  Weak validators are only usable
      when the client does not\n   require exact equality with previously obtained
      representation data,\n   such as when validating a cache entry or limiting a
      web traversal to\n   recent changes.\n"
    title: 2.1.  Weak versus Strong
  - contents:
    - "2.2.  Last-Modified\n   The \"Last-Modified\" header field in a response provides
      a timestamp\n   indicating the date and time at which the origin server believes
      the\n   selected representation was last modified, as determined at the\n   conclusion
      of handling the request.\n     Last-Modified = HTTP-date\n   An example of its
      use is\n     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n"
    - contents:
      - "2.2.1.  Generation\n   An origin server SHOULD send Last-Modified for any
        selected\n   representation for which a last modification date can be reasonably\n
        \  and consistently determined, since its use in conditional requests\n   and
        evaluating cache freshness ([RFC7234]) results in a substantial\n   reduction
        of HTTP traffic on the Internet and can be a significant\n   factor in improving
        service scalability and reliability.\n   A representation is typically the
        sum of many parts behind the\n   resource interface.  The last-modified time
        would usually be the most\n   recent time that any of those parts were changed.
        \ How that value is\n   determined for any given resource is an implementation
        detail beyond\n   the scope of this specification.  What matters to HTTP is
        how\n   recipients of the Last-Modified header field can use its value to\n
        \  make conditional requests and test the validity of locally cached\n   responses.\n
        \  An origin server SHOULD obtain the Last-Modified value of the\n   representation
        as close as possible to the time that it generates the\n   Date field value
        for its response.  This allows a recipient to make\n   an accurate assessment
        of the representation's modification time,\n   especially if the representation
        changes near the time that the\n   response is generated.\n   An origin server
        with a clock MUST NOT send a Last-Modified date that\n   is later than the
        server's time of message origination (Date).  If\n   the last modification
        time is derived from implementation-specific\n   metadata that evaluates to
        some time in the future, according to the\n   origin server's clock, then
        the origin server MUST replace that value\n   with the message origination
        date.  This prevents a future\n   modification date from having an adverse
        impact on cache validation.\n   An origin server without a clock MUST NOT
        assign Last-Modified values\n   to a response unless these values were associated
        with the resource\n   by some other system or user with a reliable clock.\n"
      title: 2.2.1.  Generation
    - contents:
      - "2.2.2.  Comparison\n   A Last-Modified time, when used as a validator in
        a request, is\n   implicitly weak unless it is possible to deduce that it
        is strong,\n   using the following rules:\n   o  The validator is being compared
        by an origin server to the actual\n      current validator for the representation
        and,\n   o  That origin server reliably knows that the associated\n      representation
        did not change twice during the second covered by\n      the presented validator.\n
        \  or\n   o  The validator is about to be used by a client in an\n      If-Modified-Since,
        If-Unmodified-Since, or If-Range header field,\n      because the client has
        a cache entry for the associated\n      representation, and\n   o  That cache
        entry includes a Date value, which gives the time when\n      the origin server
        sent the original response, and\n   o  The presented Last-Modified time is
        at least 60 seconds before the\n      Date value.\n   or\n   o  The validator
        is being compared by an intermediate cache to the\n      validator stored
        in its cache entry for the representation, and\n   o  That cache entry includes
        a Date value, which gives the time when\n      the origin server sent the
        original response, and\n   o  The presented Last-Modified time is at least
        60 seconds before the\n      Date value.\n   This method relies on the fact
        that if two different responses were\n   sent by the origin server during
        the same second, but both had the\n   same Last-Modified time, then at least
        one of those responses would\n   have a Date value equal to its Last-Modified
        time.  The arbitrary\n   60-second limit guards against the possibility that
        the Date and\n   Last-Modified values are generated from different clocks
        or at\n   somewhat different times during the preparation of the response.
        \ An\n   implementation MAY use a value larger than 60 seconds, if it is\n
        \  believed that 60 seconds is too short.\n"
      title: 2.2.2.  Comparison
    title: 2.2.  Last-Modified
  - contents:
    - "2.3.  ETag\n   The \"ETag\" header field in a response provides the current
      entity-tag\n   for the selected representation, as determined at the conclusion
      of\n   handling the request.  An entity-tag is an opaque validator for\n   differentiating
      between multiple representations of the same\n   resource, regardless of whether
      those multiple representations are\n   due to resource state changes over time,
      content negotiation\n   resulting in multiple representations being valid at
      the same time,\n   or both.  An entity-tag consists of an opaque quoted string,
      possibly\n   prefixed by a weakness indicator.\n     ETag       = entity-tag\n
      \    entity-tag = [ weak ] opaque-tag\n     weak       = %x57.2F ; \"W/\", case-sensitive\n
      \    opaque-tag = DQUOTE *etagc DQUOTE\n     etagc      = %x21 / %x23-7E / obs-text\n
      \               ; VCHAR except double quotes, plus obs-text\n      Note: Previously,
      opaque-tag was defined to be a quoted-string\n      ([RFC2616], Section 3.11);
      thus, some recipients might perform\n      backslash unescaping.  Servers therefore
      ought to avoid backslash\n      characters in entity tags.\n   An entity-tag
      can be more reliable for validation than a modification\n   date in situations
      where it is inconvenient to store modification\n   dates, where the one-second
      resolution of HTTP date values is not\n   sufficient, or where modification
      dates are not consistently\n   maintained.\n   Examples:\n     ETag: \"xyzzy\"\n
      \    ETag: W/\"xyzzy\"\n     ETag: \"\"\n   An entity-tag can be either a weak
      or strong validator, with strong\n   being the default.  If an origin server
      provides an entity-tag for a\n   representation and the generation of that entity-tag
      does not satisfy\n   all of the characteristics of a strong validator (Section
      2.1), then\n   the origin server MUST mark the entity-tag as weak by prefixing
      its\n   opaque value with \"W/\" (case-sensitive).\n"
    - contents:
      - "2.3.1.  Generation\n   The principle behind entity-tags is that only the
        service author\n   knows the implementation of a resource well enough to select
        the most\n   accurate and efficient validation mechanism for that resource,
        and\n   that any such mechanism can be mapped to a simple sequence of octets\n
        \  for easy comparison.  Since the value is opaque, there is no need for\n
        \  the client to be aware of how each entity-tag is constructed.\n   For example,
        a resource that has implementation-specific versioning\n   applied to all
        changes might use an internal revision number, perhaps\n   combined with a
        variance identifier for content negotiation, to\n   accurately differentiate
        between representations.  Other\n   implementations might use a collision-resistant
        hash of\n   representation content, a combination of various file attributes,
        or\n   a modification timestamp that has sub-second resolution.\n   An origin
        server SHOULD send an ETag for any selected representation\n   for which detection
        of changes can be reasonably and consistently\n   determined, since the entity-tag's
        use in conditional requests and\n   evaluating cache freshness ([RFC7234])
        can result in a substantial\n   reduction of HTTP network traffic and can
        be a significant factor in\n   improving service scalability and reliability.\n"
      title: 2.3.1.  Generation
    - contents:
      - "2.3.2.  Comparison\n   There are two entity-tag comparison functions, depending
        on whether\n   or not the comparison context allows the use of weak validators:\n
        \  o  Strong comparison: two entity-tags are equivalent if both are not\n
        \     weak and their opaque-tags match character-by-character.\n   o  Weak
        comparison: two entity-tags are equivalent if their\n      opaque-tags match
        character-by-character, regardless of either or\n      both being tagged as
        \"weak\".\n   The example below shows the results for a set of entity-tag
        pairs and\n   both the weak and strong comparison function results:\n   +--------+--------+-------------------+-----------------+\n
        \  | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |\n   +--------+--------+-------------------+-----------------+\n
        \  | W/\"1\"  | W/\"1\"  | no match          | match           |\n   | W/\"1\"
        \ | W/\"2\"  | no match          | no match        |\n   | W/\"1\"  | \"1\"
        \   | no match          | match           |\n   | \"1\"    | \"1\"    | match
        \            | match           |\n   +--------+--------+-------------------+-----------------+\n"
      title: 2.3.2.  Comparison
    - contents:
      - "2.3.3.  Example: Entity-Tags Varying on Content-Negotiated Resources\n   Consider
        a resource that is subject to content negotiation (Section\n   3.4 of [RFC7231]),
        and where the representations sent in response to\n   a GET request vary based
        on the Accept-Encoding request header field\n   (Section 5.3.4 of [RFC7231]):\n
        \  >> Request:\n     GET /index HTTP/1.1\n     Host: www.example.com\n     Accept-Encoding:
        gzip\n   In this case, the response might or might not use the gzip content\n
        \  coding.  If it does not, the response might look like:\n   >> Response:\n
        \    HTTP/1.1 200 OK\n     Date: Fri, 26 Mar 2010 00:05:00 GMT\n     ETag:
        \"123-a\"\n     Content-Length: 70\n     Vary: Accept-Encoding\n     Content-Type:
        text/plain\n     Hello World!\n     Hello World!\n     Hello World!\n     Hello
        World!\n     Hello World!\n   An alternative representation that does use
        gzip content coding would\n   be:\n   >> Response:\n     HTTP/1.1 200 OK\n
        \    Date: Fri, 26 Mar 2010 00:05:00 GMT\n     ETag: \"123-b\"\n     Content-Length:
        43\n     Vary: Accept-Encoding\n     Content-Type: text/plain\n     Content-Encoding:
        gzip\n     ...binary data...\n      Note: Content codings are a property of
        the representation data,\n      so a strong entity-tag for a content-encoded
        representation has to\n      be distinct from the entity tag of an unencoded
        representation to\n      prevent potential conflicts during cache updates
        and range\n      requests.  In contrast, transfer codings (Section 4 of [RFC7230])\n
        \     apply only during message transfer and do not result in distinct\n      entity-tags.\n"
      title: '2.3.3.  Example: Entity-Tags Varying on Content-Negotiated Resources'
    title: 2.3.  ETag
  - contents:
    - "2.4.  When to Use Entity-Tags and Last-Modified Dates\n   In 200 (OK) responses
      to GET or HEAD, an origin server:\n   o  SHOULD send an entity-tag validator
      unless it is not feasible to\n      generate one.\n   o  MAY send a weak entity-tag
      instead of a strong entity-tag, if\n      performance considerations support
      the use of weak entity-tags, or\n      if it is unfeasible to send a strong
      entity-tag.\n   o  SHOULD send a Last-Modified value if it is feasible to send
      one.\n   In other words, the preferred behavior for an origin server is to\n
      \  send both a strong entity-tag and a Last-Modified value in successful\n   responses
      to a retrieval request.\n   A client:\n   o  MUST send that entity-tag in any
      cache validation request (using\n      If-Match or If-None-Match) if an entity-tag
      has been provided by\n      the origin server.\n   o  SHOULD send the Last-Modified
      value in non-subrange cache\n      validation requests (using If-Modified-Since)
      if only a\n      Last-Modified value has been provided by the origin server.\n
      \  o  MAY send the Last-Modified value in subrange cache validation\n      requests
      (using If-Unmodified-Since) if only a Last-Modified value\n      has been provided
      by an HTTP/1.0 origin server.  The user agent\n      SHOULD provide a way to
      disable this, in case of difficulty.\n   o  SHOULD send both validators in cache
      validation requests if both\n      an entity-tag and a Last-Modified value have
      been provided by the\n      origin server.  This allows both HTTP/1.0 and HTTP/1.1
      caches to\n      respond appropriately.\n"
    title: 2.4.  When to Use Entity-Tags and Last-Modified Dates
  title: 2.  Validators
- contents:
  - "3.  Precondition Header Fields\n   This section defines the syntax and semantics
    of HTTP/1.1 header\n   fields for applying preconditions on requests.  Section
    5 defines\n   when the preconditions are applied.  Section 6 defines the order
    of\n   evaluation when more than one precondition is present.\n"
  - contents:
    - "3.1.  If-Match\n   The \"If-Match\" header field makes the request method conditional
      on\n   the recipient origin server either having at least one current\n   representation
      of the target resource, when the field-value is \"*\",\n   or having a current
      representation of the target resource that has an\n   entity-tag matching a
      member of the list of entity-tags provided in\n   the field-value.\n   An origin
      server MUST use the strong comparison function when\n   comparing entity-tags
      for If-Match (Section 2.3.2), since the client\n   intends this precondition
      to prevent the method from being applied if\n   there have been any changes
      to the representation data.\n     If-Match = \"*\" / 1#entity-tag\n   Examples:\n
      \    If-Match: \"xyzzy\"\n     If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n
      \    If-Match: *\n   If-Match is most often used with state-changing methods
      (e.g., POST,\n   PUT, DELETE) to prevent accidental overwrites when multiple
      user\n   agents might be acting in parallel on the same resource (i.e., to\n
      \  prevent the \"lost update\" problem).  It can also be used with safe\n   methods
      to abort a request if the selected representation does not\n   match one already
      stored (or partially stored) from a prior request.\n   An origin server that
      receives an If-Match header field MUST evaluate\n   the condition prior to performing
      the method (Section 5).  If the\n   field-value is \"*\", the condition is false
      if the origin server does\n   not have a current representation for the target
      resource.  If the\n   field-value is a list of entity-tags, the condition is
      false if none\n   of the listed tags match the entity-tag of the selected\n
      \  representation.\n   An origin server MUST NOT perform the requested method
      if a received\n   If-Match condition evaluates to false; instead, the origin
      server\n   MUST respond with either a) the 412 (Precondition Failed) status
      code\n   or b) one of the 2xx (Successful) status codes if the origin server\n
      \  has verified that a state change is being requested and the final\n   state
      is already reflected in the current state of the target\n   resource (i.e.,
      the change requested by the user agent has already\n   succeeded, but the user
      agent might not be aware of it, perhaps\n   because the prior response was lost
      or a compatible change was made\n   by some other user agent).  In the latter
      case, the origin server\n   MUST NOT send a validator header field in the response
      unless it can\n   verify that the request is a duplicate of an immediately prior
      change\n   made by the same user agent.\n   The If-Match header field can be
      ignored by caches and intermediaries\n   because it is not applicable to a stored
      response.\n"
    title: 3.1.  If-Match
  - contents:
    - "3.2.  If-None-Match\n   The \"If-None-Match\" header field makes the request
      method conditional\n   on a recipient cache or origin server either not having
      any current\n   representation of the target resource, when the field-value
      is \"*\",\n   or having a selected representation with an entity-tag that does
      not\n   match any of those listed in the field-value.\n   A recipient MUST use
      the weak comparison function when comparing\n   entity-tags for If-None-Match
      (Section 2.3.2), since weak entity-tags\n   can be used for cache validation
      even if there have been changes to\n   the representation data.\n     If-None-Match
      = \"*\" / 1#entity-tag\n   Examples:\n     If-None-Match: \"xyzzy\"\n     If-None-Match:
      W/\"xyzzy\"\n     If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\n     If-None-Match:
      W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\n     If-None-Match: *\n   If-None-Match
      is primarily used in conditional GET requests to enable\n   efficient updates
      of cached information with a minimum amount of\n   transaction overhead.  When
      a client desires to update one or more\n   stored responses that have entity-tags,
      the client SHOULD generate an\n   If-None-Match header field containing a list
      of those entity-tags\n   when making a GET request; this allows recipient servers
      to send a\n   304 (Not Modified) response to indicate when one of those stored\n
      \  responses matches the selected representation.\n   If-None-Match can also
      be used with a value of \"*\" to prevent an\n   unsafe request method (e.g.,
      PUT) from inadvertently modifying an\n   existing representation of the target
      resource when the client\n   believes that the resource does not have a current
      representation\n   (Section 4.2.1 of [RFC7231]).  This is a variation on the
      \"lost\n   update\" problem that might arise if more than one client attempts
      to\n   create an initial representation for the target resource.\n   An origin
      server that receives an If-None-Match header field MUST\n   evaluate the condition
      prior to performing the method (Section 5).\n   If the field-value is \"*\",
      the condition is false if the origin\n   server has a current representation
      for the target resource.  If the\n   field-value is a list of entity-tags, the
      condition is false if one\n   of the listed tags match the entity-tag of the
      selected\n   representation.\n   An origin server MUST NOT perform the requested
      method if the\n   condition evaluates to false; instead, the origin server MUST
      respond\n   with either a) the 304 (Not Modified) status code if the request\n
      \  method is GET or HEAD or b) the 412 (Precondition Failed) status code\n   for
      all other request methods.\n   Requirements on cache handling of a received
      If-None-Match header\n   field are defined in Section 4.3.2 of [RFC7234].\n"
    title: 3.2.  If-None-Match
  - contents:
    - "3.3.  If-Modified-Since\n   The \"If-Modified-Since\" header field makes a
      GET or HEAD request\n   method conditional on the selected representation's
      modification date\n   being more recent than the date provided in the field-value.\n
      \  Transfer of the selected representation's data is avoided if that\n   data
      has not changed.\n     If-Modified-Since = HTTP-date\n   An example of the field
      is:\n     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n   A recipient MUST
      ignore If-Modified-Since if the request contains an\n   If-None-Match header
      field; the condition in If-None-Match is\n   considered to be a more accurate
      replacement for the condition in\n   If-Modified-Since, and the two are only
      combined for the sake of\n   interoperating with older intermediaries that might
      not implement\n   If-None-Match.\n   A recipient MUST ignore the If-Modified-Since
      header field if the\n   received field-value is not a valid HTTP-date, or if
      the request\n   method is neither GET nor HEAD.\n   A recipient MUST interpret
      an If-Modified-Since field-value's\n   timestamp in terms of the origin server's
      clock.\n   If-Modified-Since is typically used for two distinct purposes: 1)
      to\n   allow efficient updates of a cached representation that does not have\n
      \  an entity-tag and 2) to limit the scope of a web traversal to\n   resources
      that have recently changed.\n   When used for cache updates, a cache will typically
      use the value of\n   the cached message's Last-Modified field to generate the
      field value\n   of If-Modified-Since.  This behavior is most interoperable for
      cases\n   where clocks are poorly synchronized or when the server has chosen
      to\n   only honor exact timestamp matches (due to a problem with\n   Last-Modified
      dates that appear to go \"back in time\" when the origin\n   server's clock
      is corrected or a representation is restored from an\n   archived backup).  However,
      caches occasionally generate the field\n   value based on other data, such as
      the Date header field of the\n   cached message or the local clock time that
      the message was received,\n   particularly when the cached message does not
      contain a Last-Modified\n   field.\n   When used for limiting the scope of retrieval
      to a recent time\n   window, a user agent will generate an If-Modified-Since
      field value\n   based on either its own local clock or a Date header field received\n
      \  from the server in a prior response.  Origin servers that choose an\n   exact
      timestamp match based on the selected representation's\n   Last-Modified field
      will not be able to help the user agent limit its\n   data transfers to only
      those changed during the specified window.\n   An origin server that receives
      an If-Modified-Since header field\n   SHOULD evaluate the condition prior to
      performing the method\n   (Section 5).  The origin server SHOULD NOT perform
      the requested\n   method if the selected representation's last modification
      date is\n   earlier than or equal to the date provided in the field-value;\n
      \  instead, the origin server SHOULD generate a 304 (Not Modified)\n   response,
      including only those metadata that are useful for\n   identifying or updating
      a previously cached response.\n   Requirements on cache handling of a received
      If-Modified-Since header\n   field are defined in Section 4.3.2 of [RFC7234].\n"
    title: 3.3.  If-Modified-Since
  - contents:
    - "3.4.  If-Unmodified-Since\n   The \"If-Unmodified-Since\" header field makes
      the request method\n   conditional on the selected representation's last modification
      date\n   being earlier than or equal to the date provided in the field-value.\n
      \  This field accomplishes the same purpose as If-Match for cases where\n   the
      user agent does not have an entity-tag for the representation.\n     If-Unmodified-Since
      = HTTP-date\n   An example of the field is:\n     If-Unmodified-Since: Sat,
      29 Oct 1994 19:43:31 GMT\n   A recipient MUST ignore If-Unmodified-Since if
      the request contains\n   an If-Match header field; the condition in If-Match
      is considered to\n   be a more accurate replacement for the condition in\n   If-Unmodified-Since,
      and the two are only combined for the sake of\n   interoperating with older
      intermediaries that might not implement\n   If-Match.\n   A recipient MUST ignore
      the If-Unmodified-Since header field if the\n   received field-value is not
      a valid HTTP-date.\n   A recipient MUST interpret an If-Unmodified-Since field-value's\n
      \  timestamp in terms of the origin server's clock.\n   If-Unmodified-Since
      is most often used with state-changing methods\n   (e.g., POST, PUT, DELETE)
      to prevent accidental overwrites when\n   multiple user agents might be acting
      in parallel on a resource that\n   does not supply entity-tags with its representations
      (i.e., to\n   prevent the \"lost update\" problem).  It can also be used with
      safe\n   methods to abort a request if the selected representation does not\n
      \  match one already stored (or partially stored) from a prior request.\n   An
      origin server that receives an If-Unmodified-Since header field\n   MUST evaluate
      the condition prior to performing the method\n   (Section 5).  The origin server
      MUST NOT perform the requested method\n   if the selected representation's last
      modification date is more\n   recent than the date provided in the field-value;
      instead the origin\n   server MUST respond with either a) the 412 (Precondition
      Failed)\n   status code or b) one of the 2xx (Successful) status codes if the\n
      \  origin server has verified that a state change is being requested and\n   the
      final state is already reflected in the current state of the\n   target resource
      (i.e., the change requested by the user agent has\n   already succeeded, but
      the user agent might not be aware of that\n   because the prior response message
      was lost or a compatible change\n   was made by some other user agent).  In
      the latter case, the origin\n   server MUST NOT send a validator header field
      in the response unless\n   it can verify that the request is a duplicate of
      an immediately prior\n   change made by the same user agent.\n   The If-Unmodified-Since
      header field can be ignored by caches and\n   intermediaries because it is not
      applicable to a stored response.\n"
    title: 3.4.  If-Unmodified-Since
  - contents:
    - "3.5.  If-Range\n   The \"If-Range\" header field provides a special conditional
      request\n   mechanism that is similar to the If-Match and If-Unmodified-Since\n
      \  header fields but that instructs the recipient to ignore the Range\n   header
      field if the validator doesn't match, resulting in transfer of\n   the new selected
      representation instead of a 412 (Precondition\n   Failed) response.  If-Range
      is defined in Section 3.2 of [RFC7233].\n"
    title: 3.5.  If-Range
  title: 3.  Precondition Header Fields
- contents:
  - '4.  Status Code Definitions

    '
  - contents:
    - "4.1.  304 Not Modified\n   The 304 (Not Modified) status code indicates that
      a conditional GET\n   or HEAD request has been received and would have resulted
      in a 200\n   (OK) response if it were not for the fact that the condition\n
      \  evaluated to false.  In other words, there is no need for the server\n   to
      transfer a representation of the target resource because the\n   request indicates
      that the client, which made the request\n   conditional, already has a valid
      representation; the server is\n   therefore redirecting the client to make use
      of that stored\n   representation as if it were the payload of a 200 (OK) response.\n
      \  The server generating a 304 response MUST generate any of the\n   following
      header fields that would have been sent in a 200 (OK)\n   response to the same
      request: Cache-Control, Content-Location, Date,\n   ETag, Expires, and Vary.\n
      \  Since the goal of a 304 response is to minimize information transfer\n   when
      the recipient already has one or more cached representations, a\n   sender SHOULD
      NOT generate representation metadata other than the\n   above listed fields
      unless said metadata exists for the purpose of\n   guiding cache updates (e.g.,
      Last-Modified might be useful if the\n   response does not have an ETag field).\n
      \  Requirements on a cache that receives a 304 response are defined in\n   Section
      4.3.4 of [RFC7234].  If the conditional request originated\n   with an outbound
      client, such as a user agent with its own cache\n   sending a conditional GET
      to a shared proxy, then the proxy SHOULD\n   forward the 304 response to that
      client.\n   A 304 response cannot contain a message-body; it is always terminated\n
      \  by the first empty line after the header fields.\n"
    title: 4.1.  304 Not Modified
  - contents:
    - "4.2.  412 Precondition Failed\n   The 412 (Precondition Failed) status code
      indicates that one or more\n   conditions given in the request header fields
      evaluated to false when\n   tested on the server.  This response code allows
      the client to place\n   preconditions on the current resource state (its current\n
      \  representations and metadata) and, thus, prevent the request method\n   from
      being applied if the target resource is in an unexpected state.\n"
    title: 4.2.  412 Precondition Failed
  title: 4.  Status Code Definitions
- contents:
  - "5.  Evaluation\n   Except when excluded below, a recipient cache or origin server
    MUST\n   evaluate received request preconditions after it has successfully\n   performed
    its normal request checks and just before it would perform\n   the action associated
    with the request method.  A server MUST ignore\n   all received preconditions
    if its response to the same request\n   without those conditions would have been
    a status code other than a\n   2xx (Successful) or 412 (Precondition Failed).
    \ In other words,\n   redirects and failures take precedence over the evaluation
    of\n   preconditions in conditional requests.\n   A server that is not the origin
    server for the target resource and\n   cannot act as a cache for requests on the
    target resource MUST NOT\n   evaluate the conditional request header fields defined
    by this\n   specification, and it MUST forward them if the request is forwarded,\n
    \  since the generating client intends that they be evaluated by a\n   server
    that can provide a current representation.  Likewise, a server\n   MUST ignore
    the conditional request header fields defined by this\n   specification when received
    with a request method that does not\n   involve the selection or modification
    of a selected representation,\n   such as CONNECT, OPTIONS, or TRACE.\n   Conditional
    request header fields that are defined by extensions to\n   HTTP might place conditions
    on all recipients, on the state of the\n   target resource in general, or on a
    group of resources.  For\n   instance, the \"If\" header field in WebDAV can make
    a request\n   conditional on various aspects of multiple resources, such as locks,\n
    \  if the recipient understands and implements that field ([RFC4918],\n   Section
    10.4).\n   Although conditional request header fields are defined as being\n   usable
    with the HEAD method (to keep HEAD's semantics consistent with\n   those of GET),
    there is no point in sending a conditional HEAD\n   because a successful response
    is around the same size as a 304 (Not\n   Modified) response and more useful than
    a 412 (Precondition Failed)\n   response.\n"
  title: 5.  Evaluation
- contents:
  - "6.  Precedence\n   When more than one conditional request header field is present
    in a\n   request, the order in which the fields are evaluated becomes\n   important.
    \ In practice, the fields defined in this document are\n   consistently implemented
    in a single, logical order, since \"lost\n   update\" preconditions have more
    strict requirements than cache\n   validation, a validated cache is more efficient
    than a partial\n   response, and entity tags are presumed to be more accurate
    than date\n   validators.\n   A recipient cache or origin server MUST evaluate
    the request\n   preconditions defined by this specification in the following order:\n
    \  1.  When recipient is the origin server and If-Match is present,\n       evaluate
    the If-Match precondition:\n       *  if true, continue to step 3\n       *  if
    false, respond 412 (Precondition Failed) unless it can be\n          determined
    that the state-changing request has already\n          succeeded (see Section
    3.1)\n   2.  When recipient is the origin server, If-Match is not present, and\n
    \      If-Unmodified-Since is present, evaluate the If-Unmodified-Since\n       precondition:\n
    \      *  if true, continue to step 3\n       *  if false, respond 412 (Precondition
    Failed) unless it can be\n          determined that the state-changing request
    has already\n          succeeded (see Section 3.4)\n   3.  When If-None-Match
    is present, evaluate the If-None-Match\n       precondition:\n       *  if true,
    continue to step 5\n       *  if false for GET/HEAD, respond 304 (Not Modified)\n
    \      *  if false for other methods, respond 412 (Precondition Failed)\n   4.
    \ When the method is GET or HEAD, If-None-Match is not present, and\n       If-Modified-Since
    is present, evaluate the If-Modified-Since\n       precondition:\n       *  if
    true, continue to step 5\n       *  if false, respond 304 (Not Modified)\n   5.
    \ When the method is GET and both Range and If-Range are present,\n       evaluate
    the If-Range precondition:\n       *  if the validator matches and the Range specification
    is\n          applicable to the selected representation, respond 206\n          (Partial
    Content) [RFC7233]\n   6.  Otherwise,\n       *  all conditions are met, so perform
    the requested action and\n          respond according to its success or failure.\n
    \  Any extension to HTTP/1.1 that defines additional conditional request\n   header
    fields ought to define its own expectations regarding the\n   order for evaluating
    such fields in relation to those defined in this\n   document and other conditionals
    that might be found in practice.\n"
  title: 6.  Precedence
- contents:
  - '7.  IANA Considerations

    '
  - contents:
    - "7.1.  Status Code Registration\n   The \"Hypertext Transfer Protocol (HTTP)
      Status Code Registry\" located\n   at <http://www.iana.org/assignments/http-status-codes>
      has been\n   updated with the registrations below:\n   +-------+---------------------+-------------+\n
      \  | Value | Description         | Reference   |\n   +-------+---------------------+-------------+\n
      \  | 304   | Not Modified        | Section 4.1 |\n   | 412   | Precondition
      Failed | Section 4.2 |\n   +-------+---------------------+-------------+\n"
    title: 7.1.  Status Code Registration
  - contents:
    - "7.2.  Header Field Registration\n   HTTP header fields are registered within
      the \"Message Headers\"\n   registry maintained at\n   <http://www.iana.org/assignments/message-headers/>.\n
      \  This document defines the following HTTP header fields, so their\n   associated
      registry entries have been updated according to the\n   permanent registrations
      below (see [BCP90]):\n   +---------------------+----------+----------+-------------+\n
      \  | Header Field Name   | Protocol | Status   | Reference   |\n   +---------------------+----------+----------+-------------+\n
      \  | ETag                | http     | standard | Section 2.3 |\n   | If-Match
      \           | http     | standard | Section 3.1 |\n   | If-Modified-Since   |
      http     | standard | Section 3.3 |\n   | If-None-Match       | http     | standard
      | Section 3.2 |\n   | If-Unmodified-Since | http     | standard | Section 3.4
      |\n   | Last-Modified       | http     | standard | Section 2.2 |\n   +---------------------+----------+----------+-------------+\n
      \  The change controller is: \"IETF (iesg@ietf.org) - Internet\n   Engineering
      Task Force\".\n"
    title: 7.2.  Header Field Registration
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   This section is meant to inform developers, information
    providers,\n   and users of known security concerns specific to the HTTP conditional\n
    \  request mechanisms.  More general security considerations are\n   addressed
    in HTTP \"Message Syntax and Routing\" [RFC7230] and\n   \"Semantics and Content\"
    [RFC7231].\n   The validators defined by this specification are not intended to\n
    \  ensure the validity of a representation, guard against malicious\n   changes,
    or detect man-in-the-middle attacks.  At best, they enable\n   more efficient
    cache updates and optimistic concurrent writes when\n   all participants are behaving
    nicely.  At worst, the conditions will\n   fail and the client will receive a
    response that is no more harmful\n   than an HTTP exchange without conditional
    requests.\n   An entity-tag can be abused in ways that create privacy risks.  For\n
    \  example, a site might deliberately construct a semantically invalid\n   entity-tag
    that is unique to the user or user agent, send it in a\n   cacheable response
    with a long freshness time, and then read that\n   entity-tag in later conditional
    requests as a means of re-identifying\n   that user or user agent.  Such an identifying
    tag would become a\n   persistent identifier for as long as the user agent retained
    the\n   original cache entry.  User agents that cache representations ought\n
    \  to ensure that the cache is cleared or replaced whenever the user\n   performs
    privacy-maintaining actions, such as clearing stored cookies\n   or changing to
    a private browsing mode.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgments\n   See Section 10 of [RFC7230].\n"
  title: 9.  Acknowledgments
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC7230]
      \ Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol
      (HTTP/1.1): Message Syntax and Routing\",\n              RFC 7230, June 2014.\n
      \  [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n              June
      2014.\n   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n
      \             \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\",\n
      \             RFC 7233, June 2014.\n   [RFC7234]  Fielding, R., Ed., Nottingham,
      M., Ed., and J. Reschke,\n              Ed., \"Hypertext Transfer Protocol (HTTP/1.1):
      Caching\",\n              RFC 7234, June 2014.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [BCP90]    Klyne, G., Nottingham, M., and
      J. Mogul, \"Registration\n              Procedures for Message Header Fields\",
      BCP 90, RFC 3864,\n              September 2004.\n   [RFC2616]  Fielding, R.,
      Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P.,
      and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\",
      RFC 2616, June 1999.\n   [RFC4918]  Dusseault, L., Ed., \"HTTP Extensions for
      Web Distributed\n              Authoring and Versioning (WebDAV)\", RFC 4918,
      June 2007.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Changes from RFC 2616\n   The definition of validator weakness has
    been expanded and clarified.\n   (Section 2.1)\n   Weak entity-tags are now allowed
    in all requests except range\n   requests.  (Sections 2.1 and 3.2)\n   The ETag
    header field ABNF has been changed to not use quoted-string,\n   thus avoiding
    escaping issues.  (Section 2.3)\n   ETag is defined to provide an entity tag for
    the selected\n   representation, thereby clarifying what it applies to in various\n
    \  situations (such as a PUT response).  (Section 2.3)\n   The precedence for
    evaluation of conditional requests has been\n   defined.  (Section 6)\n"
  title: Appendix A.  Changes from RFC 2616
- contents:
  - "Appendix B.  Imported ABNF\n   The following core rules are included by reference,
    as defined in\n   Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return),\n
    \  CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double\n   quote),
    HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any\n   8-bit sequence
    of data), SP (space), and VCHAR (any visible US-ASCII\n   character).\n   The
    rules below are defined in [RFC7230]:\n     OWS           = <OWS, see [RFC7230],
    Section 3.2.3>\n     obs-text      = <obs-text, see [RFC7230], Section 3.2.6>\n
    \  The rules below are defined in other parts:\n     HTTP-date     = <HTTP-date,
    see [RFC7231], Section 7.1.1.1>\n"
  title: Appendix B.  Imported ABNF
- contents:
  - "Appendix C.  Collected ABNF\n   In the collected ABNF below, list rules are expanded
    as per Section\n   1.2 of [RFC7230].\n   ETag = entity-tag\n   HTTP-date = <HTTP-date,
    see [RFC7231], Section 7.1.1.1>\n   If-Match = \"*\" / ( *( \",\" OWS ) entity-tag
    *( OWS \",\" [ OWS\n    entity-tag ] ) )\n   If-Modified-Since = HTTP-date\n   If-None-Match
    = \"*\" / ( *( \",\" OWS ) entity-tag *( OWS \",\" [ OWS\n    entity-tag ] ) )\n
    \  If-Unmodified-Since = HTTP-date\n   Last-Modified = HTTP-date\n   OWS = <OWS,
    see [RFC7230], Section 3.2.3>\n   entity-tag = [ weak ] opaque-tag\n   etagc =
    \"!\" / %x23-7E ; '#'-'~'\n    / obs-text\n   obs-text = <obs-text, see [RFC7230],
    Section 3.2.6>\n   opaque-tag = DQUOTE *etagc DQUOTE\n   weak = %x57.2F ; W/\n"
  title: Appendix C.  Collected ABNF
- contents:
  - "Index\n   3\n      304 Not Modified (status code)  19\n   4\n      412 Precondition
    Failed (status code)  18\n   E\n      ETag header field  9\n   G\n      Grammar\n
    \        entity-tag  9\n         ETag  9\n         etagc  9\n         If-Match
    \ 13\n         If-Modified-Since  15\n         If-None-Match  14\n         If-Unmodified-Since
    \ 17\n         Last-Modified  7\n         opaque-tag  9\n         weak  9\n   I\n
    \     If-Match header field  13\n      If-Modified-Since header field  16\n      If-None-Match
    header field  14\n      If-Unmodified-Since header field  17\n   L\n      Last-Modified
    header field  7\n   M\n      metadata  5\n   S\n      selected representation
    \ 4\n   V\n      validator  5\n         strong  5\n         weak  5\n"
  title: Index
- contents:
  - "Authors' Addresses\n   Roy T. Fielding (editor)\n   Adobe Systems Incorporated\n
    \  345 Park Ave\n   San Jose, CA  95110\n   USA\n   EMail: fielding@gbiv.com\n
    \  URI:   http://roy.gbiv.com/\n   Julian F. Reschke (editor)\n   greenbytes GmbH\n
    \  Hafenweg 16\n   Muenster, NW  48155\n   Germany\n   EMail: julian.reschke@greenbytes.de\n
    \  URI:   http://greenbytes.de/tech/webdav/\n"
  title: Authors' Addresses
