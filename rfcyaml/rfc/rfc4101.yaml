- title: __initial_text__
  contents:
  - '                        Writing Protocol Models

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   The IETF process depends on peer review.  However, IETF documents\
    \ are\n   generally written to be useful for implementors, not reviewers.  In\n\
    \   particular, while great care is generally taken to provide a complete\n  \
    \ description of the state machines and bits on the wire, this level of\n   detail\
    \ tends to get in the way of initial understanding.  This\n   document describes\
    \ an approach for providing protocol \"models\" that\n   allow reviewers to quickly\
    \ grasp the essence of a system.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The IETF process depends on peer review.  However, in many\
    \ cases, the\n   documents submitted for publication are extremely difficult to\n\
    \   review.  Because reviewers have only limited amounts of time, this\n   leads\
    \ to extremely long review times, inadequate reviews, or both.\n   In our view,\
    \ a large part of the problem is that most documents fail\n   to present an architectural\
    \ model for how the protocol operates,\n   opting instead to simply describe the\
    \ protocol and let the reviewer\n   figure it out.\n   This is acceptable when\
    \ documenting a protocol for implementors,\n   because they need to understand\
    \ the protocol in any case; but it\n   dramatically increases the strain on reviewers.\
    \  Reviewers need to\n   get the big picture of the system and then focus on particular\n\
    \   points.  They simply do not have time to give the entire document the\n  \
    \ attention an implementor would.\n   One way to reduce this load is to present\
    \ the reviewer with a\n   MODEL -- a short description of the system in overview\
    \ form.  This\n   provides the reviewer with the context to identify the important\
    \ or\n   difficult pieces of the system and focus on them for review.  As a\n\
    \   side benefit, if the model is done first, it can be serve as an aid\n   to\
    \ the detailed protocol design and a focus for early review, prior\n   to protocol\
    \ completion.  The intention is that the model would either\n   be the first section\
    \ of the protocol document or be a separate\n   document provided with the protocol.\n"
- title: 2.  The Purpose of a Protocol Model
  contents:
  - "2.  The Purpose of a Protocol Model\n   A protocol model needs to answer three\
    \ basic questions:\n   1. What problem is the protocol trying to achieve?\n  \
    \ 2. What messages are being transmitted and what do they mean?\n   3. What are\
    \ the important, but unobvious, features of the protocol?\n   The basic idea is\
    \ to provide enough information that the reader could\n   design a protocol which\
    \ was roughly isomorphic to the protocol being\n   described.  Of course, this\
    \ doesn't mean that the protocol would be\n   identical, but merely that it would\
    \ share most important features.\n   For instance, the decision to use a KDC-based\
    \ authentication model is\n   an essential feature of Kerberos [KERBEROS].  By\
    \ contrast, the use of\n   ASN.1 is a simple implementation decision.  S-expressions\
    \ -- or XML,\n   had it existed at the time -- would have served equally well.\n\
    \   The purpose of a protocol model is explicitly not to provide a\n   complete\
    \ or alternate description of the protocol being discussed.\n   Instead, it is\
    \ to provide a big picture overview of the protocol so\n   that readers can quickly\
    \ understand the essential elements of how it\n   works.\n"
- title: 3.  Basic Principles
  contents:
  - "3.  Basic Principles\n   In this section we discuss basic principles that should\
    \ guide your\n   presentation.\n"
- title: 3.1.  Less is more
  contents:
  - "3.1.  Less is more\n   Humans are only capable of keeping a very small number\
    \ of pieces of\n   information in their head at once.  Because we're interested\
    \ in\n   ensuring that people get the big picture, we have to dispense with a\n\
    \   lot of detail.  That's good, not bad.  The simpler you can make\n   things\
    \ the better.\n"
- title: 3.2.  Abstraction is good
  contents:
  - "3.2.  Abstraction is good\n   A key technique for representing complex systems\
    \ is to try to\n   abstract away pieces.  For instance, maps are better than photographs\n\
    \   for finding out where you want to go because they provide an\n   abstract,\
    \ stylized, view of the information you're interested in.\n   Don't be afraid\
    \ to compress multiple protocol elements into a single\n   abstract piece for\
    \ pedagogical purposes.\n"
- title: 3.3.  A few well-chosen details sometimes help
  contents:
  - "3.3.  A few well-chosen details sometimes help\n   The converse of the previous\
    \ principle is that sometimes details help\n   to bring a description into focus.\
    \  Many people work better when\n   given examples.  Thus, it's often a good approach\
    \ to talk about the\n   material in the abstract and then provide a concrete description\
    \ of\n   one specific piece to bring it into focus.  Authors should focus on\n\
    \   the normal path.  Error cases and corner cases should only be\n   discussed\
    \ where they help illustrate an important point.\n"
- title: 4.  Writing Protocol Models
  contents:
  - "4.  Writing Protocol Models\n   Our experience indicates that it is easiest to\
    \ grasp protocol models\n   when they are presented in visual form.  We recommend\
    \ a presentation\n   format centered around a few key diagrams, with explanatory\
    \ text for\n   each.  These diagrams should be simple and typically consist of\n\
    \   \"boxes and arrows\" -- boxes representing the major components, arrows\n\
    \   representing their relationships, and labels indicating important\n   features.\n\
    \   We recommend a presentation structured in three parts to match the\n   three\
    \ questions mentioned in the previous sections.  Each part should\n   contain\
    \ 1-3 diagrams intended to illustrate the relevant points.\n"
- title: 4.1.  Describe the problem you're trying to solve
  contents:
  - "4.1.  Describe the problem you're trying to solve\n   The most critical task\
    \ that a protocol model must perform is to\n   explain what the protocol is trying\
    \ to achieve.  This provides\n   crucial context for understanding how the protocol\
    \ works, and whether\n   it meets its goals.  Given the desired goals, an experienced\
    \ reviewer\n   will usually have an idea of how they would approach the problem\
    \ and,\n   thus, be able to compare that approach with the approach taken by the\n\
    \   protocol under review.\n   The \"Problem\" section of the model should start\
    \ with a short\n   statement of the environments in which the protocol is expected\
    \ to be\n   used.  This section should describe the relevant entities and the\n\
    \   likely scenarios under which they would participate in the protocol.\n   The\
    \ Problem section should feature a diagram of the major\n   communicating parties\
    \ and their inter-relationships.  It is\n   particularly important to lay out\
    \ the trust relationships between the\n   various parties, as these are often\
    \ unobvious.\n"
- title: '4.1.1.  Example: STUN (RFC 3489)'
  contents:
  - "4.1.1.  Example: STUN (RFC 3489)\n   STUN [STUN] is a UNilateral Self-Address\
    \ Fixing (UNSAF) [UNSAF]\n   protocol that allows a machine located behind a NAT\
    \ to determine what\n   its external apparent IP address is.  Although STUN provides\
    \ a\n   complete and thorough description of the operation of the protocol,\n\
    \   it does not provide a brief, up-front overview suitable for a quick\n   understanding\
    \ of its operation.  The rest of this section shows what\n   a suitable overview\
    \ might look like.\n   Network Address Translation (NAT) makes it difficult to\
    \ run a number\n   of classes of service from behind the NAT gateway.  This is\n\
    \   particularly a problem when protocols need to advertise address/port\n   pairs\
    \ as part of the application layer protocol.  Although the NAT\n   can be configured\
    \ to accept data destined for that port, address\n   translation means the address\
    \ that the application knows about is not\n   the same as the one on which it\
    \ is reachable.\n   Consider the scenario represented in the figure below.  A\
    \ SIP client\n   is initiating a session with a SIP server in which it wants the\
    \ SIP\n   server to send it some media.  In its Session Description Protocol\n\
    \   (SDP) [SDP] request it provides the IP address and port on which it\n   is\
    \ listening.  However, unbeknownst to the client, a NAT is in the\n   way.  The\
    \ NAT translates the IP address in the header, but unless it\n   is SIP aware,\
    \ it doesn't change the address in the request.  The\n   result is that the media\
    \ goes into a black hole.\n                   +-----------+\n                \
    \   |    SIP    |\n                   |  Server   |\n                   |    \
    \       |\n                   +-----------+\n                        ^\n     \
    \                   | [FROM: 198.203.2.1:8954]\n                        | [MSG:\
    \ SEND MEDIA TO 10.0.10.5:6791]\n                        |\n                 \
    \       |\n                   +-----------+\n                   |           |\n\
    \                   |    NAT    |\n     --------------+  Gateway  +----------------\n\
    \                   |           |\n                   +-----------+\n        \
    \                ^\n                        | [FROM: 10.0.10.5:6791]\n       \
    \                 | [MSG: SEND MEDIA TO 10.0.10.5:6791]\n                    \
    \    |\n                     10.0.10.5\n                   +-----------+\n   \
    \                |    SIP    |\n                   |  Client   |\n           \
    \        |           |\n                   +-----------+\n   The purpose of STUN\
    \ is to allow clients to detect this situation and\n   determine the address mapping.\
    \  They can then place the appropriate\n   address in their application-level\
    \ messages.  This is done by using\n   an external STUN server.  That server is\
    \ able to determine the\n   translated address and tell the STUN client, as shown\
    \ below.\n                               +-----------+\n                     \
    \          |   STUN    |\n                               |  Server   |\n     \
    \                          |           |\n                               +-----------+\n\
    \                                   ^   |\n   [IP HDR FROM: 198.203.2.1:8954]\
    \ |   | [IP HDR TO: 198.203.2.1:8954]\n   [MSG: WHAT IS MY ADDRESS?]      |  \
    \ | [MSG: YOU ARE 198.203.2.1:8954]\n                                   |   v\n\
    \                               +-----------+\n                              \
    \ |           |\n                               |    NAT    |\n              \
    \   --------------+  Gateway  +----------------\n                            \
    \   |           |\n                               +-----------+\n            \
    \                      ^    |\n   [IP HDR FROM: 10.0.10.5:6791]  |    | [IP HDR\
    \ TO: 10.0.10.5:6791]\n   [MSG: WHAT IS MY ADDRESS?]     |    | [MSG: YOU ARE\
    \ 198.203.2.1:8954]\n                                  |    v\n              \
    \                   10.0.10.5\n                               +-----------+\n\
    \                               |    SIP    |\n                              \
    \ |  Client   |\n                               |           |\n              \
    \                 +-----------+\n"
- title: 4.2.  Describe the protocol in broad overview
  contents:
  - "4.2.  Describe the protocol in broad overview\n   Once the problem has been described,\
    \ the next task is to give a broad\n   overview of the protocol.  This means showing,\
    \ either in \"ladder\n   diagram\" or \"boxes and arrows\" form, the protocol\
    \ messages that flow\n   between the various networking agents.  This diagram\
    \ should be\n   accompanied with explanatory text that describes the purpose of\
    \ each\n   message and the MAJOR data elements.\n   This section SHOULD NOT contain\
    \ detailed descriptions of the\n   protocol messages or of each data element.\
    \  In particular, bit\n   diagrams, ASN.1 modules, and XML schema SHOULD NOT be\
    \ shown.  The\n   purpose of this section is not to provide a complete\n   description\
    \ of the protocol, but to provide enough of a\n   map that a person reading the\
    \ full protocol document can see\n   where each specific piece fits.\n   In certain\
    \ cases, it may be helpful to provide a state machine\n   description of the behavior\
    \ of network elements.  However, such\n   state machines should be kept as minimal\
    \ as possible.  Remember that\n   the purpose is to promote high-level comprehension,\
    \ not complete\n   understanding.\n"
- title: '4.2.1.  Example: DCCP'
  contents:
  - "4.2.1.  Example: DCCP\n   Datagram Congestion Control Protocol [DCCP] is a protocol\
    \ for\n   providing datagram transport with network-friendly congestion\n   avoidance\
    \ behavior.  The DCCP base protocol document is over 100\n   pages long and the\
    \ congestion control mechanisms themselves are\n   separate.  Therefore, it is\
    \ very helpful to have a an architectural\n   overview of DCCP that abstracts\
    \ away the details.  The remainder of\n   this section is an attempt to do so.\n\
    \   NOTE: The author of this document was on the DCCP review team and\n   his\
    \ experience with that document was one of the motivating factors\n   for this\
    \ document.  Since the review, the DCCP authors have added\n   some overview material,\
    \ some of which derives from earlier versions\n   of this document.\n   Although\
    \ DCCP is datagram-oriented like UDP, it is stateful\n   like TCP.  Connections\
    \ go through the following phases:\n      1. Initiation\n      2. Feature negotiation\n\
    \      3. Data transfer\n      4. Termination\n"
- title: 4.2.1.1.  Initiation
  contents:
  - "4.2.1.1.  Initiation\n   As with TCP, the initiation phase of DCCP involves a\
    \ three-way\n   handshake, shown below.\n   Client                           \
    \           Server\n   ------                                      ------\n  \
    \ DCCP-Request            ->\n   [Ports, Service,\n   Features]\n            \
    \               <-           DCCP-Response\n                                 \
    \          [Features,\n                                              Cookie]\n\
    \   DCCP-Ack                ->\n   [Features,\n   Cookie]\n                  \
    \         DCCP 3-way handshake\n   In the DCCP-Request message, the client tells\
    \ the server the name of\n   the service it wants to talk to and the ports it\
    \ wants to communicate\n   on.  Note that ports are not tightly bound to services,\
    \ as they are\n   in TCP or UDP common practice.  It also starts feature negotiation.\n\
    \   For pedagogical reasons, we will present feature negotiation\n   separately\
    \ in the next section.  However, realize that the early\n   phases of feature\
    \ negotiation happen concurrently with initiation.\n   In the DCCP-Response message,\
    \ the server tells the client that it is\n   willing to accept the connection\
    \ and continues feature negotiation.\n   In order to prevent SYN flood-style DOS\
    \ attacks, DCCP incorporates an\n   IKE-style cookie exchange.  The server can\
    \ provide the client with a\n   cookie that contains all of the negotiation state.\
    \  This cookie must\n   be echoed by the client in the DCCP-Ack, thus removing\
    \ the need for\n   the server to keep state.\n   In the DCCP-Ack message, the\
    \ client acknowledges the DCCP-Response\n   and returns the cookie to permit the\
    \ server to complete its side of\n   the connection.  As indicated above, this\
    \ message may also include\n   feature negotiation messages.\n"
- title: 4.2.1.2.  Feature Negotiation
  contents:
  - "4.2.1.2.  Feature Negotiation\n   In DCCP, feature negotiation is performed by\
    \ attaching options to\n   other DCCP packets.  Thus, feature negotiation can\
    \ be piggybacked on\n   any other DCCP message.  This allows feature negotiation\
    \ during\n   connection initiation as well as during data flow.\n   Somewhat unusually,\
    \ DCCP features are one-sided.  Thus, it's possible\n   to have a different congestion\
    \ control regime for data sent from\n   client to server than from server to client.\n\
    \   Feature negotiation is done with the Change and Confirm options.\n   There\
    \ are four feature negotiation options in all: Change L, Confirm\n   L, Change\
    \ R, and Confirm R.  The \"L\" options are sent by the feature\n   location, where\
    \ the feature is maintained, and the \"R\" options are\n   sent by the feature\
    \ remote.\n   A Change R message says to the peer \"change this option setting\
    \ on\n   your side\".  The peer can respond with a Confirm L, meaning \"I've\n\
    \   changed it\".  Some features allow Change R options to contain\n   multiple\
    \ values, sorted in preference order.  For example:\n          Client        \
    \                                Server\n          ------                    \
    \                    ------\n          Change R(CCID, 2) -->\n               \
    \                         <-- Confirm L(CCID, 2)\n                     * agreement\
    \ that CCID/Server = 2 *\n          Change R(CCID, 3 4) -->\n                \
    \                   <-- Confirm L(CCID, 4, 4 2)\n                     * agreement\
    \ that CCID/Server = 4 *\n   In the second exchange, the client requests that\
    \ the server use\n   either CCID 3 or CCID 4, with 3 preferred.  The server chooses\
    \ 4 and\n   supplies its preference list, \"4 2\".\n   The Change L and Confirm\
    \ R options are used for feature negotiations\n   that are initiated by the feature\
    \ location.  In the following\n   example, the server requests that CCID/Server\
    \ be set to 3 or 2 (with\n   3 being preferred), and the client agrees.\n    \
    \      Client                                       Server\n          ------ \
    \                                      ------\n                              \
    \        <-- Change L(CCID, 3 2)\n          Confirm R(CCID, 3, 3 2)  -->\n   \
    \                  * agreement that CCID/Server = 3 *\n"
- title: 4.2.1.3.  Data Transfer
  contents:
  - "4.2.1.3.  Data Transfer\n   Rather than have a single congestion control regime,\
    \ as in TCP, DCCP\n   offers a variety of negotiable congestion control regimes.\
    \  The DCCP\n   documents describe two congestion control regimes: additive increase,\n\
    \   multiplicative decrease (CCID-2 [CCID2]), and TCP-friendly rate\n   control\
    \ (CCID-3 [CCID3]).  CCID-2 is intended for applications that\n   want maximum\
    \ throughput.  CCID-3 is intended for real-time\n   applications that want smooth\
    \ response to congestion.\n"
- title: 4.2.1.3.1.  CCID-2
  contents:
  - "4.2.1.3.1.  CCID-2\n   CCID-2's congestion control is extremely similar to that\
    \ of TCP.  The\n   sender maintains a congestion window and sends packets until\
    \ that\n   window is full.  Packets are Acked by the receiver.  Dropped packets\n\
    \   and ECN [ECN] are used to indicate congestion.  The response to\n   congestion\
    \ is to halve the congestion window.  One subtle difference\n   between DCCP and\
    \ TCP is that the Acks in DCCP must contain the\n   sequence numbers of all received\
    \ packets (within a given window), not\n   just the highest sequence number, as\
    \ in TCP.\n"
- title: 4.2.1.3.2.  CCID-3
  contents:
  - "4.2.1.3.2.  CCID-3\n   CCID-3 is an equation-based form of rate control, intended\
    \ to provide\n   smoother response to congestion than CCID-2.  The sender maintains\
    \ a\n   \"transmit rate\".  The receiver sends Ack packets that contain\n   information\
    \ about the receiver's estimate of packet loss.  The sender\n   uses this information\
    \ to update its transmit rate.  Although CCID-3\n   behaves somewhat differently\
    \ than TCP in its short-term congestion\n   response, it is designed to operate\
    \ fairly with TCP over the long\n   term.\n"
- title: 4.2.1.4.  Termination
  contents:
  - "4.2.1.4.  Termination\n   Connection termination in DCCP is initiated by sending\
    \ a Close\n   message.  Either side can send a Close message.  The peer then\n\
    \   responds with a Reset message, at which point the connection is\n   closed.\
    \  The side that sent the Close message must quietly preserve\n   the socket in\
    \ TIMEWAIT state for 2MSL.\n   Client                                      Server\n\
    \   ------                                      ------\n   Close             \
    \       ->\n                            <-                  Reset\n   [Remains\
    \ in TIMEWAIT]\n   Note that the server may wish to close the connection but not\
    \ remain\n   in TIMEWAIT (e.g., due to a desire to minimize server-side state).\n\
    \   In order to accomplish this, the server can elicit a Close from the\n   client\
    \ by sending a CloseReq message and, thus, keep the TIMEWAIT\n   state on the\
    \ client.\n"
- title: 4.3.  Describe any important protocol features
  contents:
  - "4.3.  Describe any important protocol features\n   The final section (if there\
    \ is one) should contain an explanation of\n   any important protocol features\
    \ that are not obvious from the\n   previous sections.  In the best case, all\
    \ the important features of\n   the protocol would be obvious from the message\
    \ flow.  However, this\n   isn't always the case.  This section is an opportunity\
    \ for the author\n   to explain those features.  Authors should think carefully\
    \ before\n   writing this section.  If there are no important points to be made,\n\
    \   they should not populate this section.\n   Examples of the kind of feature\
    \ that belongs in this section include:\n   high-level security considerations,\
    \ congestion control information,\n   and overviews of the algorithms that the\
    \ network elements are\n   intended to follow.  For instance, if you have a routing\
    \ protocol,\n   you might use this section to sketch out the algorithm that the\n\
    \   router uses to determine the appropriate routes from protocol\n   messages.\n"
- title: '4.3.1.  Example: WebDAV COPY and MOVE'
  contents:
  - "4.3.1.  Example: WebDAV COPY and MOVE\n   The WebDAV standard [WEBDAV] is fairly\
    \ terse, preferring to define\n   the required behaviors and let the reader work\
    \ out the implications.\n   In some situations, explanatory material that details\
    \ those\n   implications can help the reader understand the overall model.  The\n\
    \   rest of this section describes one such case.\n   WebDAV [WEBDAV] includes\
    \ both a COPY method and a MOVE method.  While\n   a MOVE can be thought of as\
    \ a COPY followed by DELETE, COPY+DELETE\n   and MOVE aren't entirely equivalent.\n\
    \   The use of COPY+DELETE as a substitute for MOVE is problematic\n   because\
    \ of the creation of the intermediate file.  Consider the case\n   where the user\
    \ is approaching a quota boundary.  A COPY+DELETE should\n   be forbidden because\
    \ it would temporarily exceed the quota.  However,\n   a simple rename should\
    \ work in this situation.\n   The second issue is permissions.  The WebDAV permissions\
    \ model allows\n   the server to grant users permission to rename files, but not\
    \ to\n   create new ones.  This is unusual in ordinary filesystems, but\n   nothing\
    \ prevents it in WebDAV.  This is clearly not possible if a\n   client uses COPY+DELETE\
    \ to do a MOVE.\n   Finally, a COPY+DELETE does not produce the same logical result\
    \ as\n   would be expected with a MOVE.  Because COPY creates a new resource,\n\
    \   it is permitted (but not required) to use the time of new file\n   creation\
    \ as the creation date property.  By contrast, the expectation\n   for MOVE is\
    \ that the renamed file will have the same properties as\n   the original.\n"
- title: 5.  Formatting Issues
  contents:
  - "5.  Formatting Issues\n   The requirement that Internet-Drafts and RFCs be renderable\
    \ in ASCII\n   is a significant obstacle when writing the sort of graphics-heavy\n\
    \   document being described here.  Authors may find it more convenient\n   to\
    \ do a separate protocol model document in Postscript or PDF and\n   simply make\
    \ it available at review time -- though an archival version\n   would certainly\
    \ be handy.\n"
- title: '6.  A Complete Example: Internet Key Exchange (IKE)'
  contents:
  - "6.  A Complete Example: Internet Key Exchange (IKE)\n   Internet Key Exchange\
    \ (IKE) [IKE] is one of the most complicated\n   security protocols ever designed\
    \ by the IETF.  Although the basic IKE\n   core is a fairly straightforward Diffie-Hellman-based\
    \ handshake, this\n   can often be difficult for new readers to understand abstractly,\n\
    \   apart from the protocol details.  The remainder of this section\n   provides\
    \ overview of IKE suitable for those new readers.\n"
- title: 6.1.  Operating Environment
  contents:
  - "6.1.  Operating Environment\n   Internet key Exchange (IKE) [IKE] is a key establishment\
    \ and\n   parameter negotiation protocol for Internet protocols.  Its primary\n\
    \   application is for establishing security associations (SAs) [IPSEC]\n   for\
    \ IPsec AH [AH] and ESP [ESP].\n   +--------------------+                    \
    \   +--------------------+\n   |                    |                       |\
    \                    |\n   |   +------------+   |                       |   +------------+\
    \   |\n   |   |    Key     |   |         IKE           |   |    Key     |   |\n\
    \   |   | Management | <-+-----------------------+-> | Management |   |\n   |\
    \   |  Process   |   |                       |   |  Process   |   |\n   |   +------------+\
    \   |                       |   +------------+   |\n   |         ^          |\
    \                       |         ^          |\n   |         |          |    \
    \                   |         |          |\n   |         v          |        \
    \               |         v          |\n   |   +------------+   |            \
    \           |   +------------+   |\n   |   |   IPsec    |   |        AH/ESP  \
    \       |   |   IPsec    |   |\n   |   |   Stack    | <-+-----------------------+->\
    \ |   Stack    |   |\n   |   |            |   |                       |   |  \
    \          |   |\n   |   +------------+   |                       |   +------------+\
    \   |\n   |                    |                       |                    |\n\
    \   |                    |                       |                    |\n   |\
    \     Initiator      |                       |     Responder      |\n   +--------------------+\
    \                       +--------------------+\n   The general deployment model\
    \ for IKE is shown above.  The IPsec\n   engines and IKE engines typically are\
    \ separate modules.  When no\n   security association exists for a packet that\
    \ needs to be processed\n   (either sent or received), the IPsec engine contacts\
    \ the IKE engine\n   and asks it to establish an appropriate SA.  The IKE engine\
    \ contacts\n   the appropriate peer and uses IKE to establish the SA.  Once the\
    \ IKE\n   handshake is finished it registers the SA with the IPsec engine.\n \
    \  In addition, IKE traffic between the peers can be used to refresh\n   keying\
    \ material or adjust operating parameters, such as algorithms.\n"
- title: 6.1.1.  Initiator and Responder
  contents:
  - "6.1.1.  Initiator and Responder\n   Although IPsec is basically symmetrical,\
    \ IKE is not.  The party who\n   sends the first message is called the INITIATOR.\
    \  The other party is\n   called the RESPONDER.  In the case of TCP connections,\
    \ the INITIATOR\n   will typically be the peer doing the active open (i.e., the\
    \ client).\n"
- title: 6.1.2.  Perfect Forward Secrecy
  contents:
  - "6.1.2.  Perfect Forward Secrecy\n   One of the major concerns in IKE design was\
    \ that traffic be protected\n   even if the keying material of the nodes was later\
    \ compromised,\n   provided that the session in question had terminated and so\
    \ the\n   session-specific keying material was gone.  This property is often\n\
    \   called Perfect Forward Secrecy (PFS) or back traffic protection.\n"
- title: 6.1.3.  Denial of Service Resistance
  contents:
  - "6.1.3.  Denial of Service Resistance\n   Because IKE allows arbitrary peers to\
    \ initiate computationally-\n   expensive cryptographic operations, it potentially\
    \ allows resource\n   consumption denial of service (DoS) attacks to be mounted\
    \ against the\n   IKE engine.  IKE includes countermeasures designed to minimize\
    \ this\n   risk.\n"
- title: 6.1.4.  Keying Assumptions
  contents:
  - "6.1.4.  Keying Assumptions\n   Because Security Associations are essentially\
    \ symmetric, both sides\n   must, in general, be authenticated.  Because IKE needs\
    \ to be able to\n   establish SAs between a broad range of peers with various\
    \ kinds of\n   prior relationships, IKE supports a very flexible keying model.\n\
    \   Peers can authenticate via shared keys, digital signatures (typically\n  \
    \ from keys vouched for by certificates), or encryption keys.\n"
- title: 6.1.5.  Identity Protection
  contents:
  - "6.1.5.  Identity Protection\n   Although IKE requires the peers to authenticate\
    \ to each other, it was\n   considered desirable by the working group to provide\
    \ some identity\n   protection for the communicating peers.  In particular, the\
    \ peers\n   should be able to hide their identity from passive observers and one\n\
    \   peer should be able to require the author to authenticate before they\n  \
    \ self-identity.  In this case, the designers chose to make the party\n   who\
    \ speaks first (the INITIATOR) identify first.\n"
- title: 6.2.  Protocol Overview
  contents:
  - "6.2.  Protocol Overview\n   At a very high level, there are two kinds of IKE\
    \ handshake:\n   (1) Those that establish an IKE security association.\n   (2)\
    \ Those that establish an AH or ESP security association.\n   When two peers that\
    \ have never communicated before need to establish\n   an AH/ESH SA, they must\
    \ first establish an IKE SA.  This allows them\n   to exchange an arbitrary amount\
    \ of protected IKE traffic.  They can\n   then use that SA to do a second handshake\
    \ to establish SAs for AH and\n   ESP.  This process is shown in schematic form\
    \ below.  The notation\n   E(SA,XXXX) is used to indicate that traffic is encrypted\
    \ under a\n   given SA.\n   Initiator                               Responder\n\
    \   ---------                               ---------\n   Handshake MSG      \
    \     ->                        \\  Stage 1:\n                           <-  \
    \       Handshake MSG   \\ Establish IKE\n                                   \
    \                   / SA (IKEsa)\n                          [...]            \
    \          /\n                                                     \\  Stage 2:\n\
    \   E(IKEsa, Handshake MSG) ->                         \\ Establish AH/ESP\n \
    \                          <- E(IKEsa, Handshake MSG) / SA\n                 \
    \     The two kinds of IKE handshake\n   IKE terminology is somewhat confusing,\
    \ referring under different\n   circumstances to \"phases\" and \"modes\".  For\
    \ maximal clarity we will\n   refer to the Establishment of the IKE SA as \"Stage\
    \ 1\" and the\n   Establishment of AH/ESP SAs as \"Stage 2\".  Note that it's\
    \ quite\n   possible for there to be more than one Stage 2 handshake, once Stage\n\
    \   1 has been finished.  This might be useful for establishing multiple\n   AH/ESP\
    \ SAs with different cryptographic properties.\n   The Stage 1 and Stage 2 handshakes\
    \ are actually rather different,\n   because the Stage 2 handshake can, of course,\
    \ assume that its traffic\n   is being protected with an IKE SA.  Accordingly,\
    \ we will first\n   discuss Stage 1 and then Stage 2.\n"
- title: 6.2.1.  Stage 1
  contents:
  - "6.2.1.  Stage 1\n   There are a large number of variants of the IKE Stage 1 handshake,\n\
    \   necessitated by use of different authentication mechanisms.  However,\n  \
    \ broadly speaking Stage 1 handshakes fall into one of two basic\n   categories:\
    \ MAIN MODE, which provides identity protection and DoS\n   resistance, and AGGRESSIVE\
    \ MODE, which does not.  We will cover MAIN\n   MODE first.\n"
- title: 6.2.1.1.  Main Mode
  contents:
  - "6.2.1.1.  Main Mode\n   Main Mode is a six message (3 round trip) handshake,\
    \ which offers\n   identity protection and DoS resistance.  An overview of the\
    \ handshake\n   is below.\n   Initiator                                   Responder\n\
    \   ---------                                   ---------\n   CookieI, Algorithms\
    \      ->                          \\  Parameter\n                           \
    \ <-      CookieR, Algorithms /  Establishment\n   CookieR,\n   Nonce, Key Exchange\
    \      ->\n                            <-       Nonce, Key Exchange\\  Establish\n\
    \                                                        /  Shared key\n   E(IKEsa,\
    \ Auth Data)      ->\n                            <-       E(IKEsa, Auth data)\\\
    \  Authenticate\n                                                        /   \
    \   Peers\n                     IKE Main Mode handshake (Stage 1)\n   In the first\
    \ round trip, the Initiator offers a set of algorithms and\n   parameters.  The\
    \ Responder picks out the single set that it likes and\n   responds with that\
    \ set.  It also provides CookieR, which will be used\n   to prevent DoS attacks.\
    \  At this point, there is no secure\n   association but the peers have tentatively\
    \ agreed upon parameters.\n   These parameters include a Diffie-Hellman (DH) group,\
    \ which will be\n   used in the second round trip.\n   In the second round trip,\
    \ the Initiator sends the key exchange\n   information.  This generally consists\
    \ of the Initiator's Diffie-\n   Hellman public share (Yi).  He also supplies\
    \ CookieR, which was\n   provided by the responder.  The Responder replies with\
    \ his own DH\n   share (Yr).  At this point, both Initiator and Responder can\
    \ compute\n   the shared DH key (ZZ).  However, there has been no authentication\n\
    \   and, therefore, they don't know with any certainty that the\n   connection\
    \ hasn't been attacked.  Note that as long as the peers\n   generate fresh DH\
    \ shares for each handshake, PFS will be provided.\n   Before we move on, let's\
    \ take a look at the cookie exchange.  The\n   basic anti-DoS measure used by\
    \ IKE is to force the peer to\n   demonstrate that it can receive traffic from\
    \ you.  This foils blind\n   attacks like SYN floods [SYNFLOOD] and also makes\
    \ it somewhat easier\n   to track down attackers.  The cookie exchange serves\
    \ this role in\n   IKE.  The Responder can verify that the Initiator supplied\
    \ a valid\n   CookieR before doing the expensive DH key agreement.  This does\
    \ not\n   totally eliminate DoS attacks, because an attacker who was willing to\n\
    \   reveal his location could still consume server resources; but it does\n  \
    \ protect against a certain class of blind attack.\n   In the final round trip,\
    \ the peers establish their identities.\n   Because they share an (unauthenticated)\
    \ key, they can send their\n   identities encrypted, thus providing identity protection\
    \ from\n   eavesdroppers.  The exact method of proving identity depends on what\n\
    \   form of credential is being used (signing key, encryption key, shared\n  \
    \ secret, etc.), but in general you can think of it as a signature over\n   some\
    \ subset of the handshake messages.  So, each side would supply\n   its certificate\
    \ and then sign using the key associated with that\n   certificate.  If shared\
    \ keys are used, the authentication data would\n   be a key ID and a MAC.  Authentication\
    \ using public key encryption\n   follows similar principles, but is more complicated.\
    \  Refer to the\n   IKE document for more details.\n   At the end of the Main\
    \ Mode handshake, the peers share:\n      (1) A set of algorithms for encryption\
    \ of further IKE traffic.\n      (2) Traffic encryption and authentication keys.\n\
    \      (3) Mutual knowledge of the peer's identity.\n"
- title: 6.2.1.2.  Aggressive Mode
  contents:
  - "6.2.1.2.  Aggressive Mode\n   Although IKE Main Mode provides the required services,\
    \ there was\n   concern that the large number of round trips required added,\n\
    \   excessive latency.  Accordingly, an Aggressive Mode was defined.\n   Aggressive\
    \ mode packs more data into fewer messages, and thus reduces\n   latency.  However,\
    \ it does not provide identity protection or\n   protection against DoS.\n   Initiator\
    \                                   Responder\n   ---------                  \
    \                 ---------\n   Algorithms, Nonce,\n   Key Exchange,         \
    \   ->\n                            <-         Algorithms, Nonce,\n          \
    \                        Key Exchange, Auth Data\n   Auth Data               \
    \ ->\n                  IKE Aggressive Mode Handshake (Stage 1)\n   After the\
    \ first round trip, the peers have all the required\n   properties, but the Initiator\
    \ has not authenticated to the Responder.\n   The third message closes the loop\
    \ by authenticating the Initiator.\n   Note that since the authentication data\
    \ is sent in the clear, no\n   identity protection is provided; and because the\
    \ Responder does the\n   DH key agreement without a round trip to the Initiator,\
    \ there is no\n   DoS protection\n"
- title: 6.2.2.  Stage 2
  contents:
  - "6.2.2.  Stage 2\n   Stage 1 on its own isn't very useful.  The purpose of IKE,\
    \ after all,\n   is to establish associations to be used to protect other traffic,\
    \ not\n   merely to establish IKE SAs.  Stage 2 (what IKE calls \"Quick Mode\"\
    )\n   is used for this purpose.  The basic Stage 2 handshake is shown\n   below.\n\
    \      Initiator                                    Responder\n      ---------\
    \                                    ---------\n      AH/ESP parameters,\n   \
    \   Algorithms, Nonce,\n      Handshake Hash           ->\n                  \
    \             <-          AH/ESP parameters,\n                               \
    \            Algorithms, Nonce,\n                                            \
    \   Handshake Hash\n      Handshake Hash           ->\n                      The\
    \ Basic IKE Quick Mode (Stage 2)\n   As with quick mode, the first two messages\
    \ establish the algorithms\n   and parameters while the final message is a check\
    \ over the previous\n   messages.  In this case, the parameters also include the\
    \ transforms\n   to be applied to the traffic (AH or ESP) and the kinds of traffic\n\
    \   that are to be protected.  Note that there is no key exchange\n   information\
    \ shown in these messages.\n   In this version of Quick Mode, the peers use the\
    \ preexisting Stage 1\n   keying material to derive fresh keying material for\
    \ traffic\n   protection (with the nonces to ensure freshness).  Quick mode also\n\
    \   allows for a new Diffie-Hellman handshake for per-traffic key PFS.\n   In\
    \ that case, the first two messages shown above would also include\n   Key Exchange\
    \ payloads, as shown below.\n      Initiator                                 \
    \   Responder\n      ---------                                    ---------\n\
    \      AH/ESP parameters,\n      Algorithms, Nonce,\n      Key Exchange,     \
    \       ->\n      Handshake Hash\n                               <-          AH/ESP\
    \ parameters,\n                                           Algorithms, Nonce,\n\
    \                                                Key Exchange,\n             \
    \                                  Handshake Hash\n      Handshake Hash      \
    \     ->\n                  A Variant of Quick Mode with PFS (Stage 2)\n"
- title: 6.3.  Other Considerations
  contents:
  - "6.3.  Other Considerations\n   There are a number of features of IKE that deserve\
    \ special\n   consideration.  They are discussed here.\n"
- title: 6.3.1.  Cookie Generation
  contents:
  - "6.3.1.  Cookie Generation\n   As mentioned previously, IKE uses cookies as a\
    \ partial defense\n   against DoS attacks.  When the responder receives Main Mode\
    \ message 3\n   containing the Key Exchange data and the cookie, it verifies that\
    \ the\n   cookie is correct.  However, this verification must not involve\n  \
    \ having a list of valid cookies.  Otherwise, an attacker could\n   potentially\
    \ consume arbitrary amounts of memory by repeatedly\n   requesting cookies from\
    \ a responder.  The recommended way to generate\n   a cookie, as suggested by\
    \ Phil Karn, is to have a single master key\n   and compute a hash of the secret\
    \ and the initiator's address\n   information.  This cookie can be verified by\
    \ recomputing the cookie\n   value based on information in the third message,\
    \ and seeing if it\n   matches.\n"
- title: 6.3.2.  Endpoint Identities
  contents:
  - "6.3.2.  Endpoint Identities\n   So far we have been rather vague about what kinds\
    \ of endpoint\n   identities are used.  In principle, there are three ways a peer\
    \ might\n   be identified: by a shared key, a pre-configured public key, or a\n\
    \   certificate.\n"
- title: 6.3.2.1.  Shared Key
  contents:
  - "6.3.2.1.  Shared Key\n   In a shared key scheme, the peers share a symmetric\
    \ key.  This key is\n   associated with a key identifier, which is known to both\
    \ parties.  It\n   is assumed that the party verifying that identity also has\
    \ a table\n   that indicates for which traffic (i.e., what addresses) that identity\n\
    \   is allowed to negotiate SAs.\n"
- title: 6.3.2.2.  Pre-Configured Public Key
  contents:
  - "6.3.2.2.  Pre-Configured Public Key\n   A pre-configured public key scheme is\
    \ the same as a shared key scheme\n   except that the verifying party has the\
    \ authenticating party's public\n   key instead of a shared key.\n"
- title: 6.3.2.3.  Certificate
  contents:
  - "6.3.2.3.  Certificate\n   In a certificate scheme, the authenticating party presents\
    \ a\n   certificate containing their public key.  It is straightforward to\n \
    \  establish that this certificate matches the authentication data\n   provided\
    \ by the peer.  What is less straightforward is to determine\n   whether a given\
    \ peer is entitled to negotiate for a given class of\n   traffic.  In theory,\
    \ one might be able to determine this from the\n   name in the certificate (e.g.,\
    \ the subject name contains an IP\n   address that matches the ostensible IP address).\
    \  In practice, this\n   is not clearly specified in IKE and, therefore, is not\
    \ really\n   interoperable.  Currently, it is likely that a configuration table\n\
    \   maps certificates to policies, as in the other two authentication\n   schemes.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document does not define any protocols and\
    \ therefore has no\n   security issues.\n"
- title: 'A.  Appendix: IAB Members at the Time of This Writing'
  contents:
  - "A.  Appendix: IAB Members at the Time of This Writing\n   Bernard Aboba\n   Harald\
    \ Alvestrand\n   Rob Austein\n   Leslie Daigle\n   Patrik Falstrom\n   Sally Floyd\n\
    \   Jun-ichiro Itojun Hagino\n   Mark Handley\n   Bob Hinden\n   Geoff Huston\n\
    \   Eric Rescorla\n   Pete Resnick\n   Jonathan Rosenberg\n"
- title: Normative References
  contents:
  - "Normative References\n   There are no normative references for this document.\n"
- title: Informative References
  contents:
  - "Informative References\n   [AH]       Kent, S., and R. Atkinson, \"IP Authentication\
    \ Header\", RFC\n              2402, November 1998.\n   [CCID2]    Floyd, S. and\
    \ E. Kohler, \"Profile for DCCP Congestion\n              Control ID 2: TCP-like\
    \ Congestion Control\", Work in\n              Progress, October 2003.\n   [CCID3]\
    \    Floyd, S., Kohler, E., and J. Padhye, \"Profile for DCCP\n              Congestion\
    \ Control ID 3: TFRC Congestion Control\", Work in\n              Progress, February\
    \ 2004.\n   [DCCP]     Kohler, E., Handley, M., and S. Floyd, \"Datagram\n   \
    \           Congestion Control Protocol (DCCP)\", Work in Progress,\n        \
    \      November 2004.\n   [ECN]      Ramakrishnan, K. Floyd, S., and D. Black,\
    \ \"The Addition of\n              Explicit Congestion Notification (ECN) to IP\"\
    , RFC 3168,\n              September 2001.\n   [ESP]      Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security\n              Payload (ESP)\", RFC 2406, November\
    \ 1998.\n   [IKE]      Harkins, D. and D. Carrel, \"The Internet Key Exchange\n\
    \              (IKE)\", RFC 2409, November 1998.\n   [IPSEC]    Kent, S. and R.\
    \ Atkinson, \"Security Architecture for the\n              Internet Protocol\"\
    , RFC 2401, November 1998.\n   [KERBEROS] Kohl, J. and C. Neuman, \"The Kerberos\
    \ Network\n              Authentication Service (V5)\", RFC 1510, September 1993.\n\
    \   [SDP]      Handley, M. and V. Jacobson, \"SDP: Session Description\n     \
    \         Protocol\" RFC 2327, April 1998.\n   [STUN]     Rosenberg, J., Weinberger,\
    \ J., Huitema, C., and R. Mahy,\n              \"STUN - Simple Traversal of User\
    \ Datagram Protocol (UDP)\",\n              RFC 3489, March 2003.\n   [SYNFLOOD]\
    \ CERT Advisory CA-1996-21 TCP SYN Flooding and IP Spoofing\n              Attacks\
    \ <http://www.cert.org/advisories/CA-1996-21.html>,\n              September 19,\
    \ 1996.\n   [UNSAF]    Daigle, L. and IAB, \"IAB Considerations for UNilateral\n\
    \              Self-Address Fixing (UNSAF) Across Network Address\n          \
    \    Translation\", RFC 3424, November 2002.\n   [WEBDAV]   Goland, Y., Whitehead,\
    \ E., Faizi, A., Carter, S., and D.\n              Jensen, \"HTTP Extensions for\
    \ Distributed Authoring --\n              WEBDAV\", RFC 2518, February 1999.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Eric Rescorla\n   RTFM, Inc.\n   2064 Edgewood Drive\n\
    \   Palo Alto, CA 94303\n   Phone: (650)-320-8549\n   EMail: ekr@rtfm.com\n  \
    \ Internet Architecture Board\n   IAB\n   EMail: iab@iab.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
