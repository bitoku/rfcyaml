- contents:
  - '                        The Interfaces Group MIB

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1 Introduction .................................................
    \   2\n   2 The SNMP Network Management Framework ........................    2\n
    \  3 Experience with the Interfaces Group .........................    3\n   3.1
    Clarifications/Revisions ...................................    4\n   3.1.1 Interface
    Sub-Layers .....................................    4\n   3.1.2 Guidance on Defining
    Sub-layers ..........................    7\n   3.1.3 Virtual Circuits .........................................
    \   8\n   3.1.4 Bit, Character, and Fixed-Length Interfaces ..............    8\n
    \  3.1.5 Interface Numbering ......................................   10\n   3.1.6
    Counter Size .............................................   14\n   3.1.7 Interface
    Speed ..........................................   16\n   3.1.8 Multicast/Broadcast
    Counters .............................   17\n   3.1.9 Trap Enable ..............................................
    \  17\n   3.1.10 Addition of New ifType values ...........................   18\n
    \  3.1.11 InterfaceIndex Textual Convention .......................   18\n   3.1.12
    New states for IfOperStatus .............................   18\n   3.1.13 IfAdminStatus
    and IfOperStatus ..........................   19\n   3.1.14 IfOperStatus in an
    Interface Stack ......................   21\n   3.1.15 Traps ...................................................
    \  21\n   3.1.16 ifSpecific ..............................................   23\n
    \  3.1.17 Creation/Deletion of Interfaces .........................   23\n   3.1.18
    All Values Must be Known ................................   24\n   4 Media-Specific
    MIB Applicability .............................   24\n   5 Overview .....................................................
    \  25\n   6 Interfaces Group Definitions .................................   26\n
    \  7 Acknowledgements .............................................   64\n   8
    References ...................................................   64\n   9 Security
    Considerations ......................................   66\n   10 Authors' Addresses
    ..........................................   67\n   11 Changes from RFC 2233 .......................................
    \  67\n   12 Notice on Intellectual Property .............................   68\n
    \  13 Full Copyright Statement ....................................   69\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo defines a portion of the Management Information
    Base (MIB)\n   for use with network management protocols in the Internet community.\n
    \  In particular, it describes managed objects used for managing Network\n   Interfaces.
    \ This memo discusses the 'interfaces' group of MIB-II\n   [17], especially the
    experience gained from the definition of\n   numerous media-specific MIB modules
    for use in conjunction with the '\n   interfaces' group for managing various sub-layers
    beneath the\n   internetwork-layer.  It specifies clarifications to, and extensions\n
    \  of, the architectural issues within the MIB-II model of the '\n   interfaces'
    group.  This memo obsoletes RFC 2233, the previous\n   version of the Interfaces
    Group MIB.\n   The key words \"MUST\" and \"MUST NOT\" in this document are to
    be\n   interpreted as described in RFC 2119 [16].\n"
  title: 1.  Introduction
- contents:
  - "2.  The SNMP Network Management Framework\n   The SNMP Management Framework presently
    consists of five major\n   components:\n      o  An overall architecture, described
    in RFC 2571 [1].\n      o  Mechanisms for describing and naming objects and events
    for the\n         purpose of management.  The first version of this Structure
    of\n         Management Information (SMI) is called SMIv1 and described in\n         STD
    16, RFC 1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4].\n         The second
    version, called SMIv2, is described in STD 58, which\n         consists of RFC
    2578 [5], RFC 2579 [6] and RFC 2580 [7].\n      o  Message protocols for transferring
    management information.  The\n         first version of the SNMP message protocol
    is called SNMPv1 and\n         described in STD 15, RFC 1157 [8].  A second version
    of the\n         SNMP message protocol, which is not an Internet standards track\n
    \        protocol, is called SNMPv2c and described in RFC 1901 [9] and\n         RFC
    1906 [10].  The third version of the message protocol is\n         called SNMPv3
    and described in RFC 1906 [10], RFC 2572 [11] and\n         RFC 2574 [12].\n      o
    \ Protocol operations for accessing management information.  The\n         first
    set of protocol operations and associated PDU formats is\n         described in
    STD 15, RFC 1157 [8].  A second set of protocol\n         operations and associated
    PDU formats is described in RFC 1905\n         [13].\n      o  A set of fundamental
    applications described in RFC 2573 [14]\n         and the view-based access control
    mechanism described in RFC\n         2575 [15].\n   A more detailed introduction
    to the current SNMP Management Framework\n   can be found in RFC 2570 [22].\n
    \  Managed objects are accessed via a virtual information store, termed\n   the
    Management Information Base or MIB.  Objects in the MIB are\n   defined using
    the mechanisms defined in the SMI.\n   This memo specifies a MIB module that is
    compliant to the SMIv2.  A\n   MIB conforming to the SMIv1 can be produced through
    the appropriate\n   translations.  The resulting translated MIB must be semantically\n
    \  equivalent, except where objects or events are omitted because no\n   translation
    is possible (e.g., use of Counter64).  Some machine\n   readable information in
    SMIv2 will be converted into textual\n   descriptions in SMIv1 during the translation
    process.  However, this\n   loss of machine readable information is not considered
    to change the\n   semantics of the MIB.\n"
  title: 2.  The SNMP Network Management Framework
- contents:
  - "3.  Experience with the Interfaces Group\n   One of the strengths of internetwork-layer
    protocols such as IP [18]\n   is that they are designed to run over any network
    interface.  In\n   achieving this, IP considers any and all protocols it runs
    over as a\n   single \"network interface\" layer.  A similar view is taken by
    other\n   internetwork-layer protocols.  This concept is represented in MIB-II\n
    \  by the 'interfaces' group which defines a generic set of managed\n   objects
    such that any network interface can be managed in an\n   interface-independent
    manner through these managed objects.  The '\n   interfaces' group provides the
    means for additional managed objects\n   specific to particular types of network
    interface (e.g., a specific\n   medium such as Ethernet) to be defined as extensions
    to the '\n   interfaces' group for media-specific management.  Since the\n   standardization
    of MIB-II, many such media-specific MIB modules have\n   been defined.\n   Experience
    in defining these media-specific MIB modules has shown\n   that the model defined
    by MIB-II is too simplistic and/or static for\n   some types of media-specific
    management.  As a result, some of these\n   media-specific MIB modules assume
    an evolution or loosening of the\n   model.  This memo documents and standardizes
    that evolution of the\n   model and fills in the gaps caused by that evolution.
    \ This memo also\n   incorporates the interfaces group extensions documented in
    RFC 1229\n   [19].\n"
  - contents:
    - "3.1.  Clarifications/Revisions\n   There are several areas for which experience
      has indicated that\n   clarification, revision, or extension of the model would
      be helpful.\n   The following sections discuss the changes in the interfaces
      group\n   adopted by this memo in each of these areas.\n   In some sections,
      one or more paragraphs contain discussion of\n   rejected alternatives to the
      model adopted in this memo.  Readers not\n   familiar with the MIB-II model
      and not interested in the rationale\n   behind the new model may want to skip
      these paragraphs.\n"
    - contents:
      - "3.1.1.  Interface Sub-Layers\n   Experience in defining media-specific management
        information has\n   shown the need to distinguish between the multiple sub-layers
        beneath\n   the internetwork-layer.  In addition, there is a need to manage
        these\n   sub-layers in devices (e.g., MAC-layer bridges) which are unaware
        of\n   which, if any, internetwork protocols run over these sub-layers.  As\n
        \  such, a model of having a single conceptual row in the interfaces\n   table
        (MIB-II's ifTable) represent a whole interface underneath the\n   internetwork-layer,
        and having a single associated media-specific MIB\n   module (referenced via
        the ifType object) is too simplistic.  A\n   further problem arises with the
        value of the ifType object which has\n   enumerated values for each type of
        interface.\n   Consider, for example, an interface with PPP running over an
        HDLC\n   link which uses a RS232-like connector.  Each of these sub-layers
        has\n   its own media-specific MIB module.  If all of this is represented
        by\n   a single conceptual row in the ifTable, then an enumerated value for\n
        \  ifType is needed for that specific combination which maps to the\n   specific
        combination of media-specific MIBs.  Furthermore, such a\n   model still lacks
        a method to describe the relationship of all the\n   sub-layers of the MIB
        stack.\n   An associated problem is that of upward and downward multiplexing
        of\n   the sub-layers.  An example of upward multiplexing is MLP (Multi-\n
        \  Link-Procedure) which provides load-sharing over several serial lines\n
        \  by appearing as a single point-to-point link to the sub-layer(s)\n   above.
        \ An example of downward multiplexing would be several\n   instances of PPP,
        each framed within a separate X.25 virtual circuit,\n   all of which run over
        one fractional T1 channel, concurrently with\n   other uses of the T1 link.
        \ The MIB structure must allow these sorts\n   of relationships to be described.\n
        \  Several solutions for representing multiple sub-layers were rejected.\n
        \  One was to retain the concept of one conceptual row for all the sub-\n
        \  layers of an interface and have each media-specific MIB module\n   identify
        its \"superior\" and \"subordinate\" sub-layers through OBJECT\n   IDENTIFIER
        \"pointers\".  This scheme would have several drawbacks: the\n   superior/subordinate
        pointers would be contained in the media-\n   specific MIB modules; thus,
        a manager could not learn the structure\n   of an interface without inspecting
        multiple pointers in different MIB\n   modules; this would be overly complex
        and only possible if the\n   manager had knowledge of all the relevant media-specific
        MIB modules;\n   MIB modules would all need to be retrofitted with these new\n
        \  \"pointers\"; this scheme would not adequately address the problem of\n
        \  upward and downward multiplexing; and finally, enumerated values of\n   ifType
        would be needed for each combination of sub-layers.  Another\n   rejected
        solution also retained the concept of one conceptual row for\n   all the sub-layers
        of an interface but had a new separate MIB table\n   to identify the \"superior\"
        and \"subordinate\" sub-layers and to\n   contain OBJECT IDENTIFIER \"pointers\"
        to the media-specific MIB module\n   for each sub-layer.  Effectively, one
        conceptual row in the ifTable\n   would represent each combination of sub-layers
        between the\n   internetwork-layer and the wire.  While this scheme has fewer\n
        \  drawbacks, it still would not support downward multiplexing, such as\n
        \  PPP over MLP: observe that MLP makes two (or more) serial lines\n   appear
        to the layers above as a single physical interface, and thus\n   PPP over
        MLP should appear to the internetwork-layer as a single\n   interface; in
        contrast, this scheme would result in two (or more)\n   conceptual rows in
        the ifTable, both of which the internetwork-layer\n   would run over.  This
        scheme would also require enumerated values of\n   ifType for each combination
        of sub-layers.\n   The solution adopted by this memo is to have an individual
        conceptual\n   row in the ifTable to represent each sub-layer, and have a
        new\n   separate MIB table (the ifStackTable, see section 6 below) to\n   identify
        the \"superior\" and \"subordinate\" sub-layers through INTEGER\n   \"pointers\"
        to the appropriate conceptual rows in the ifTable.  This\n   solution supports
        both upward and downward multiplexing, allows the\n   IANAifType to Media-Specific
        MIB mapping to identify the media-\n   specific MIB module for that sub-layer,
        such that the new table need\n   only be referenced to obtain information
        about layering, and it only\n   requires enumerated values of ifType for each
        sub-layer, not for\n   combinations of them.  However, it does require that
        the descriptions\n   of some objects in the ifTable (specifically, ifType,
        ifPhysAddress,\n   ifInUcastPkts, and ifOutUcastPkts) be generalized so as
        to apply to\n   any sub-layer (rather than only to a sub-layer immediately
        beneath\n   the network layer as previously), plus some (specifically, ifSpeed)\n
        \  which need to have appropriate values identified for use when a\n   generalized
        definition does not apply to a particular sub-layer.\n   In addition, this
        adopted solution makes no requirement that a\n   device, in which a sub-layer
        is instrumented by a conceptual row of\n   the ifTable, be aware of whether
        an internetwork protocol runs on top\n   of (i.e., at some layer above) that
        sub-layer.  In fact, the counters\n   of packets received on an interface
        are defined as counting the\n   number \"delivered to a higher-layer protocol\".
        \ This meaning of\n   \"higher-layer\" includes:\n   (1)   Delivery to a forwarding
        module which accepts\n         packets/frames/octets and forwards them on
        at the same protocol\n         layer.  For example, for the purposes of this
        definition, the\n         forwarding module of a MAC-layer bridge is considered
        as a\n         \"higher-layer\" to the MAC-layer of each port on the bridge.\n
        \  (2)   Delivery to a higher sub-layer within a interface stack.  For\n         example,
        for the purposes of this definition, if a PPP module\n         operated directly
        over a serial interface, the PPP module would\n         be considered the
        higher sub-layer to the serial interface.\n   (3)   Delivery to a higher protocol
        layer which does not do packet\n         forwarding for sub-layers that are
        \"at the top of\" the\n         interface stack.  For example, for the purposes
        of this\n         definition, the local IP module would be considered the
        higher\n         layer to a SLIP serial interface.\n   Similarly, for output,
        the counters of packets transmitted out an\n   interface are defined as counting
        the number \"that higher-level\n   protocols requested to be transmitted\".
        \ This meaning of \"higher-\n   layer\" includes:\n   (1)   A forwarding module,
        at the same protocol layer, which\n         transmits packets/frames/octets
        that were received on an\n         different interface.  For example, for
        the purposes of this\n         definition, the forwarding module of a MAC-layer
        bridge is\n         considered as a \"higher-layer\" to the MAC-layer of each
        port on\n         the bridge.\n   (2)   The next higher sub-layer within an
        interface stack.  For\n         example, for the purposes of this definition,
        if a PPP module\n         operated directly over a serial interface, the PPP
        module would\n         be a \"higher layer\" to the serial interface.\n   (3)
        \  For sub-layers that are \"at the top of\" the interface stack, a\n         higher
        element in the network protocol stack.  For example, for\n         the purposes
        of this definition, the local IP module would be\n         considered the
        higher layer to an Ethernet interface.\n"
      title: 3.1.1.  Interface Sub-Layers
    - contents:
      - "3.1.2.  Guidance on Defining Sub-layers\n   The designer of a media-specific
        MIB must decide whether to divide\n   the interface into sub-layers or not,
        and if so, how to make the\n   divisions.  The following guidance is offered
        to assist the media-\n   specific MIB designer in these decisions.\n   In
        general, the number of entries in the ifTable should be kept to\n   the minimum
        required for network management.  In particular, a group\n   of related interfaces
        should be treated as a single interface with\n   one entry in the ifTable
        providing that:\n   (1)   None of the group of interfaces performs multiplexing
        for any\n         other interface in the agent,\n   (2)   There is a meaningful
        and useful way for all of the ifTable's\n         information (e.g., the counters,
        and the status variables), and\n         all of the ifTable's capabilities
        (e.g., write access to\n         ifAdminStatus), to apply to the group of
        interfaces as a whole.\n   Under these circumstances, there should be one
        entry in the ifTable\n   for such a group of interfaces, and any internal
        structure which\n   needs to be represented to network management should be
        captured in a\n   MIB module specific to the particular type of interface.\n
        \  Note that application of bullet 2 above to the ifTable's ifType\n   object
        requires that there is a meaningful media-specific MIB and a\n   meaningful
        ifType value which apply to the group of interfaces as a\n   whole.  For example,
        it is not appropriate to treat an HDLC sub-layer\n   and an RS-232 sub-layer
        as a single ifTable entry when the media-\n   specific MIBs and the ifType
        values for HDLC and RS-232 are separate\n   (rather than combined).\n   Subject
        to the above, it is appropriate to assign an ifIndex value to\n   any interface
        that can occur in an interface stack (in the\n   ifStackTable) where the bottom
        of the stack is a physical interface\n   (ifConnectorPresent has the value
        'true') and there is a layer-3 or\n   other application that \"points down\"
        to the top of this stack.  An\n   example of an application that points down
        to the top of the stack is\n   the Character MIB [21].\n   Note that the sub-layers
        of an interface on one device will sometimes\n   be different from the sub-layers
        of the interconnected interface of\n   another device; for example, for a
        frame-relay DTE interface\n   connected a frameRelayService interface, the
        inter-connected DTE and\n   DCE interfaces have different ifType values and
        media-specific MIBs.\n   These guidelines are just that, guidelines.  The
        designer of a\n   media-specific MIB is free to lay out the MIB in whatever
        SMI\n   conformant manner is desired.  However, in doing so, the media-\n
        \  specific MIB MUST completely specify the sub-layering model used for\n
        \  the MIB, and provide the assumptions, reasoning, and rationale used\n   to
        develop that model.\n"
      title: 3.1.2.  Guidance on Defining Sub-layers
    - contents:
      - "3.1.3.  Virtual Circuits\n   Several of the sub-layers for which media-specific
        MIB modules have\n   been defined are connection oriented (e.g., Frame Relay,
        X.25).\n   Experience has shown that each effort to define such a MIB module\n
        \  revisits the question of whether separate conceptual rows in the\n   ifTable
        are needed for each virtual circuit.  Most, if not all, of\n   these efforts
        to date have decided to have all virtual circuits\n   reference a single conceptual
        row in the ifTable.\n   This memo strongly recommends that connection-oriented
        sub-layers do\n   not have a conceptual row in the ifTable for each virtual
        circuit.\n   This avoids the proliferation of conceptual rows, especially
        those\n   which have considerable redundant information.  (Note, as a\n   comparison,
        that connection-less sub-layers do not have conceptual\n   rows for each remote
        address.)  There may, however, be circumstances\n   under which it is appropriate
        for a virtual circuit of a connection-\n   oriented sub-layer to have its
        own conceptual row in the ifTable; an\n   example of this might be PPP over
        an X.25 virtual circuit.  The MIB\n   in section 6 of this memo supports such
        circumstances.\n   If a media-specific MIB wishes to assign an entry in the
        ifTable to\n   each virtual circuit, the MIB designer must present the rationale
        for\n   this decision in the media-specific MIB's specification.\n"
      title: 3.1.3.  Virtual Circuits
    - contents:
      - "3.1.4.  Bit, Character, and Fixed-Length Interfaces\n   RS-232 is an example
        of a character-oriented sub-layer over which\n   (e.g., through use of PPP)
        IP datagrams can be sent.  Due to the\n   packet-based nature of many of the
        objects in the ifTable, experience\n   has shown that it is not appropriate
        to have a character-oriented\n   sub-layer represented by a whole conceptual
        row in the ifTable.\n   Experience has also shown that it is sometimes desirable
        to have some\n   management information for bit-oriented interfaces, which
        are\n   similarly difficult to represent by a whole conceptual row in the\n
        \  ifTable.  For example, to manage the channels of a DS1 circuit, where\n
        \  only some of the channels are carrying packet-based data.\n   A further
        complication is that some subnetwork technologies transmit\n   data in fixed
        length transmission units.  One example of such a\n   technology is cell relay,
        and in particular Asynchronous Transfer\n   Mode (ATM), which transmits data
        in fixed-length cells.  Representing\n   such a interface as a packet-based
        interface produces redundant\n   objects if the relationship between the number
        of packets and the\n   number of octets in either direction is fixed by the
        size of the\n   transmission unit (e.g., the size of a cell).\n   About half
        the objects in the ifTable are applicable to every type of\n   interface:
        packet-oriented, character-oriented, and bit-oriented.  Of\n   the other half,
        two are applicable to both character-oriented and\n   packet-oriented interfaces,
        and the rest are applicable only to\n   packet-oriented interfaces.  Thus,
        while it is desirable for\n   consistency to be able to represent any/all
        types of interfaces in\n   the ifTable, it is not possible to implement the
        full ifTable for\n   bit- and character-oriented sub-layers.\n   A rejected
        solution to this problem would be to split the ifTable\n   into two (or more)
        new MIB tables, one of which would contain objects\n   that are relevant only
        to packet-oriented interfaces (e.g., PPP), and\n   another that may be used
        by all interfaces.  This is highly\n   undesirable since it would require
        changes in every agent\n   implementing the ifTable (i.e., just about every
        existing SNMP\n   agent).\n   The solution adopted in this memo builds upon
        the fact that\n   compliance statements in SMIv2 (in contrast to SMIv1) refer
        to object\n   groups, where object groups are explicitly defined by listing
        the\n   objects they contain.  Thus, with SMIv2, multiple compliance\n   statements
        can be specified, one for all interfaces and additional\n   ones for specific
        types of interfaces.  The separate compliance\n   statements can be based
        on separate object groups, where the object\n   group for all interfaces can
        contain only those objects from the\n   ifTable which are appropriate for
        every type of interfaces.  Using\n   this solution, every sub-layer can have
        its own conceptual row in the\n   ifTable.\n   Thus, section 6 of this memo
        contains definitions of the objects of\n   the existing 'interfaces' group
        of MIB-II, in a manner which is both\n   SNMPv2-compliant and semantically-equivalent
        to the existing MIB-II\n   definitions.  With equivalent semantics, and with
        the BER (\"on the\n   wire\") encodings unchanged, these definitions retain
        the same OBJECT\n   IDENTIFIER values as assigned by MIB-II.  Thus, in general,
        no\n   rewrite of existing agents which conform to MIB-II and the\n   ifExtensions
        MIB is required.\n   In addition, this memo defines several object groups
        for the purposes\n   of defining which objects apply to which types of interface:\n
        \  (1)   the ifGeneralInformationGroup.  This group contains those\n         objects
        applicable to all types of network interfaces,\n         including bit-oriented
        interfaces.\n   (2)   the ifPacketGroup.  This group contains those objects\n
        \        applicable to packet-oriented network interfaces.\n   (3)   the ifFixedLengthGroup.
        \ This group contains the objects\n         applicable not only to character-oriented
        interfaces, such as\n         RS-232, but also to those subnetwork technologies,
        such as\n         cell-relay/ATM, which transmit data in fixed length\n         transmission
        units.  As well as the octet counters, there are\n         also a few other
        counters (e.g., the error counters) which are\n         useful for this type
        of interface, but are currently defined as\n         being packet-oriented.
        \ To accommodate this, the definitions of\n         these counters are generalized
        to apply to character-oriented\n         interfaces and fixed-length-transmission
        interfaces.\n   It should be noted that the octet counters in the ifTable
        aggregate\n   octet counts for unicast and non-unicast packets into a single
        octet\n   counter per direction (received/transmitted).  Thus, with the above\n
        \  definition of fixed-length-transmission interfaces, where such\n   interfaces
        which support non-unicast packets, separate counts of\n   unicast and multicast/broadcast
        transmissions can only be maintained\n   in a media-specific MIB module.\n"
      title: 3.1.4.  Bit, Character, and Fixed-Length Interfaces
    - contents:
      - "3.1.5.  Interface Numbering\n   MIB-II defines an object, ifNumber, whose
        value represents:\n      \"The number of network interfaces (regardless of
        their\n      current state) present on this system.\"\n   Each interface is
        identified by a unique value of the ifIndex object,\n   and the description
        of ifIndex constrains its value as follows:\n      \"Its value ranges between
        1 and the value of ifNumber.  The\n      value for each interface must remain
        constant at least from\n      one re-initialization of the entity's network
        management\n      system to the next re-initialization.\"\n   This constancy
        requirement on the value of ifIndex for a particular\n   interface is vital
        for efficient management.  However, an increasing\n   number of devices allow
        for the dynamic addition/removal of network\n   interfaces.  One example of
        this is a dynamic ability to configure\n   the use of SLIP/PPP over a character-oriented
        port.  For such dynamic\n   additions/removals, the combination of the constancy
        requirement and\n   the restriction that the value of ifIndex is less than
        ifNumber is\n   problematic.\n   Redefining ifNumber to be the largest value
        of ifIndex was rejected\n   since it would not help.  Such a re-definition
        would require ifNumber\n   to be deprecated and the utility of the redefined
        object would be\n   questionable.  Alternatively, ifNumber could be deprecated
        and not\n   replaced.  However, the deprecation of ifNumber would require
        a\n   change to that portion of ifIndex's definition which refers to\n   ifNumber.
        \ So, since the definition of ifIndex must be changed anyway\n   in order
        to solve the problem, changes to ifNumber do not benefit the\n   solution.\n
        \  The solution adopted in this memo is just to delete the requirement\n   that
        the value of ifIndex must be less than the value of ifNumber,\n   and to retain
        ifNumber with its current definition.  This is a minor\n   change in the semantics
        of ifIndex; however, all existing agent\n   implementations conform to this
        new definition, and in the interests\n   of not requiring changes to existing
        agent implementations and to the\n   many existing media-specific MIBs, this
        memo assumes that this change\n   does not require ifIndex to be deprecated.
        \ Experience indicates that\n   this assumption does \"break\" a few management
        applications, but this\n   is considered preferable to breaking all agent
        implementations.\n   This solution also results in the possibility of \"holes\"
        in the\n   ifTable, i.e., the ifIndex values of conceptual rows in the ifTable\n
        \  are not necessarily contiguous, but SNMP's GetNext (and GetBulk)\n   operation
        easily deals with such holes.  The value of ifNumber still\n   represents
        the number of conceptual rows, which increases/decreases\n   as new interfaces
        are dynamically added/removed.\n   The requirement for constancy (between
        re-initializations) of an\n   interface's ifIndex value is met by requiring
        that after an interface\n   is dynamically removed, its ifIndex value is not
        re-used by a\n   *different* dynamically added interface until after the following\n
        \  re-initialization of the network management system.  This avoids the\n
        \  need for assignment (in advance) of ifIndex values for all possible\n   interfaces
        that might be added dynamically.  The exact meaning of a\n   \"different\"
        interface is hard to define, and there will be gray\n   areas.  Any firm definition
        in this document would likely turn out to\n   be inadequate.  Instead, implementors
        must choose what it means in\n   their particular situation, subject to the
        following rules:\n   (1)   a previously-unused value of ifIndex must be assigned
        to a\n         dynamically added interface if an agent has no knowledge of\n
        \        whether the interface is the \"same\" or \"different\" to a\n         previously
        incarnated interface.\n   (2)   a management station, not noticing that an
        interface has gone\n         away and another has come into existence, must
        not be confused\n         when calculating the difference between the counter
        values\n         retrieved on successive polls for a particular ifIndex value.\n
        \  When the new interface is the same as an old interface, but a\n   discontinuity
        in the value of the interface's counters cannot be\n   avoided, the ifTable
        has (until now) required that a new ifIndex\n   value be assigned to the returning
        interface.  That is, either all\n   counter values have had to be retained
        during the absence of an\n   interface in order to use the same ifIndex value
        on that interface's\n   return, or else a new ifIndex value has had to be
        assigned to the\n   returning interface.  Both alternatives have proved to
        be burdensome\n   to some implementations:\n   (1)   maintaining the counter
        values may not be possible (e.g., if\n         they are maintained on removable
        hardware),\n   (2)   using a new ifIndex value presents extra work for management\n
        \        applications.  While the potential need for such extra work is\n
        \        unavoidable on agent re-initializations, it is desirable to\n         avoid
        it between re-initializations.\n   To address this, a new object, ifCounterDiscontinuityTime,
        has been\n   defined to record the time of the last discontinuity in an\n
        \  interface's counters.  By monitoring the value of this new object, a\n
        \  management application can now detect counter discontinuities without\n
        \  the ifIndex value of the interface being changed.  Thus, an agent\n   which
        implements this new object should, when a new interface is the\n   same as
        an old interface, retain that interface's ifIndex value and\n   update if
        necessary the interface's value of\n   ifCounterDiscontinuityTime.  With this
        new object, a management\n   application must, when calculating differences
        between counter values\n   retrieved on successive polls, discard any calculated
        difference for\n   which the value of ifCounterDiscontinuityTime is different
        for the\n   two polls.  (Note that this test must be performed in addition
        to the\n   normal checking of sysUpTime to detect an agent re-initialization.)\n
        \  Since such discards are a waste of network management processing and\n
        \  bandwidth, an agent should not update the value of\n   ifCounterDiscontinuityTime
        unless absolutely necessary.\n   While defining this new object is a change
        in the semantics of the\n   ifTable counter objects, it is impractical to
        deprecate and redefine\n   all these counters because of their wide deployment
        and importance.\n   Also, a survey of implementations indicates that many
        agents and\n   management applications do not correctly implement this aspect
        of the\n   current semantics (because of the burdensome issues mentioned above),\n
        \  such that the practical implications of such a change is small.\n   Thus,
        this breach of the SMI's rules is considered to be acceptable.\n   Note, however,
        that the addition of ifCounterDiscontinuityTime does\n   not change the fact
        that:\n      it is necessary at certain times for the assignment of\n      ifIndex
        values to change on a re-initialization of the agent\n      (such as a reboot).\n
        \  The possibility of ifIndex value re-assignment must be accommodated\n   by
        a management application whenever the value of sysUpTime is reset\n   to zero.\n
        \  Note also that some agents support multiple \"naming scopes\", e.g.,\n
        \  for an SNMPv1 agent, multiple values of the SNMPv1 community string.\n
        \  For such an agent (e.g., a CNM agent which supports a different\n   subset
        of interfaces for different customers), there is no required\n   relationship
        between the ifIndex values which identify interfaces in\n   one naming scope
        and those which identify interfaces in another\n   naming scope.  It is the
        agent's choice as to whether the same or\n   different ifIndex values identify
        the same or different interfaces in\n   different naming scopes.\n   Because
        of the restriction of the value of ifIndex to be less than\n   ifNumber, interfaces
        have been numbered with small integer values.\n   This has led to the ability
        by humans to use the ifIndex values as\n   (somewhat) user-friendly names
        for network interfaces (e.g.,\n   \"interface number 3\").  With the relaxation
        of the restriction on the\n   value of ifIndex, there is now the possibility
        that ifIndex values\n   could be assigned as very large numbers (e.g., memory
        addresses).\n   Such numbers would be much less user-friendly.  Therefore,
        this memo\n   recommends that ifIndex values still be assigned as (relatively)\n
        \  small integer values starting at 1, even though the values in use at\n
        \  any one time are not necessarily contiguous.  (Note that this makes\n   remembering
        which values have been assigned easy for agents which\n   dynamically add
        new interfaces)\n   A new problem is introduced by representing each sub-layer
        as an\n   ifTable entry.  Previously, there usually was a simple, direct,\n
        \  mapping of interfaces to the physical ports on systems.  This mapping\n
        \  would be based on the ifIndex value.  However, by having an ifTable\n   entry
        for each interface sub-layer, mapping from interfaces to\n   physical ports
        becomes increasingly problematic.\n   To address this issue, a new object,
        ifName, is added to the MIB.\n   This object contains the device's local name
        (e.g., the name used at\n   the device's local console) for the interface
        of which the relevant\n   entry in the ifTable is a component.  For example,
        consider a router\n   having an interface composed of PPP running over an
        RS-232 port.  If\n   the router uses the name \"wan1\" for the (combined)
        interface, then\n   the ifName objects for the corresponding PPP and RS-232
        entries in\n   the ifTable would both have the value \"wan1\".  On the other
        hand, if\n   the router uses the name \"wan1.1\" for the PPP interface and
        \"wan1.2\"\n   for the RS-232 port, then the ifName objects for the corresponding\n
        \  PPP and RS-232 entries in the ifTable would have the values \"wan1.1\"\n
        \  and \"wan1.2\", respectively.  As an another example, consider an agent\n
        \  which responds to SNMP queries concerning an interface on some other\n
        \  (proxied) device:  if such a proxied device associates a particular\n   identifier
        with an interface, then it is appropriate to use this\n   identifier as the
        value of the interface's ifName, since the local\n   console in this case
        is that of the proxied device.\n   In contrast, the existing ifDescr object
        is intended to contain a\n   description of an interface, whereas another
        new object, ifAlias,\n   provides a location in which a network management
        application can\n   store a non-volatile interface-naming value of its own
        choice.  The\n   ifAlias object allows a network manager to give one or more\n
        \  interfaces their own unique names, irrespective of any interface-\n   stack
        relationship.  Further, the ifAlias name is non-volatile, and\n   thus an
        interface must retain its assigned ifAlias value across\n   reboots, even
        if an agent chooses a new ifIndex value for the\n   interface.\n"
      title: 3.1.5.  Interface Numbering
    - contents:
      - "3.1.6.  Counter Size\n   As the speed of network media increase, the minimum
        time in which a\n   32 bit counter will wrap decreases.  For example, a 10Mbs
        stream of\n   back-to-back, full-size packets causes ifInOctets to wrap in
        just\n   over 57 minutes; at 100Mbs, the minimum wrap time is 5.7 minutes,
        and\n   at 1Gbs, the minimum is 34 seconds.  Requiring that interfaces be\n
        \  polled frequently enough not to miss a counter wrap is increasingly\n   problematic.\n
        \  A rejected solution to this problem was to scale the counters; for\n   example,
        ifInOctets could be changed to count received octets in,\n   say, 1024 byte
        blocks.  While it would provide acceptable\n   functionality at high rates
        of the counted-events, at low rates it\n   suffers.  If there is little traffic
        on an interface, there might be\n   a significant interval before enough of
        the counted-events occur to\n   cause the scaled counter to be incremented.
        \ Traffic would then\n   appear to be very bursty, leading to incorrect conclusions
        of the\n   network's performance.\n   Instead, this memo adopts expanded,
        64 bit, counters.  These counters\n   are provided in new \"high capacity\"
        groups.  The old, 32-bit,\n   counters have not been deprecated.  The 64-bit
        counters are to be\n   used only when the 32-bit counters do not provide enough
        capacity;\n   that is, when the 32 bit counters could wrap too fast.\n   For
        interfaces that operate at 20,000,000 (20 million) bits per\n   second or
        less, 32-bit byte and packet counters MUST be supported.\n   For interfaces
        that operate faster than 20,000,000 bits/second, and\n   slower than 650,000,000
        bits/second, 32-bit packet counters MUST be\n   supported and 64-bit octet
        counters MUST be supported.  For\n   interfaces that operate at 650,000,000
        bits/second or faster, 64-bit\n   packet counters AND 64-bit octet counters
        MUST be supported.\n   These speed thresholds were chosen as reasonable compromises
        based on\n   the following:\n   (1)   The cost of maintaining 64-bit counters
        is relatively high, so\n         minimizing the number of agents which must
        support them is\n         desirable.  Common interfaces (such as 10Mbs Ethernet)
        should\n         not require them.\n   (2)   64-bit counters are a new feature,
        introduced in the SMIv2.  It\n         is reasonable to expect that support
        for them will be spotty\n         for the immediate future.  Thus, we wish
        to limit them to as\n         few systems as possible.  This, in effect, means
        that 64-bit\n         counters should be limited to higher speed interfaces.\n
        \        Ethernet (10,000,000 bps) and Token Ring (16,000,000 bps) are\n         fairly
        wide-spread so it seems reasonable to not require 64-bit\n         counters
        for these interfaces.\n   (3)   The 32-bit octet counters will wrap in the
        following times, for\n         the following interfaces (when transmitting
        maximum-sized\n         packets back-to-back):\n         -   10Mbs Ethernet:
        57 minutes,\n         -   16Mbs Token Ring: 36 minutes,\n         -   a US
        T3 line (45 megabits): 12 minutes,\n         -   FDDI: 5.7 minutes\n   (4)
        \  The 32-bit packet counters wrap in about 57 minutes when 64-\n         byte
        packets are transmitted back-to-back on a 650,000,000\n         bit/second
        link.\n   As an aside, a 1-terabit/second (1,000 Gbs) link will cause a 64
        bit\n   octet counter to wrap in just under 5 years.  Conversely, an\n   81,000,000
        terabit/second link is required to cause a 64-bit counter\n   to wrap in 30
        minutes.  We believe that, while technology rapidly\n   marches forward, this
        link speed will not be achieved for at least\n   several years, leaving sufficient
        time to evaluate the introduction\n   of 96 bit counters.\n   When 64-bit
        counters are in use, the 32-bit counters MUST still be\n   available.  They
        will report the low 32-bits of the associated 64-bit\n   count (e.g., ifInOctets
        will report the least significant 32 bits of\n   ifHCInOctets).  This enhances
        inter-operability with existing\n   implementations at a very minimal cost
        to agents.\n   The new \"high capacity\" groups are:\n   (1)   the ifHCFixedLengthGroup
        for character-oriented/fixed-length\n         interfaces, and the ifHCPacketGroup
        for packet-based\n         interfaces; both of these groups include 64 bit
        counters for\n         octets, and\n   (2)   the ifVHCPacketGroup for packet-based
        interfaces; this group\n         includes 64 bit counters for octets and packets.\n"
      title: 3.1.6.  Counter Size
    - contents:
      - "3.1.7.  Interface Speed\n   Network speeds are increasing.  The range of
        ifSpeed is limited to\n   reporting a maximum speed of (2**31)-1 bits/second,
        or approximately\n   2.2Gbs.  SONET defines an OC-48 interface, which is defined
        at\n   operating at 48 times 51 Mbs, which is a speed in excess of 2.4Gbs.\n
        \  Thus, ifSpeed is insufficient for the future, and this memo defines\n   an
        additional object: ifHighSpeed.\n   The ifHighSpeed object reports the speed
        of the interface in\n   1,000,000 (1 million) bits/second units.  Thus, the
        true speed of the\n   interface will be the value reported by this object,
        plus or minus\n   500,000 bits/second.\n   Other alternatives considered (but
        rejected) were:\n   (1)   Making the interface speed a 64-bit gauge.  This
        was rejected\n         since the current SMI does not allow such a syntax.\n
        \     Furthermore, even if 64-bit gauges were available, their use would\n
        \     require additional complexity in agents due to an increased\n      requirement
        for 64-bit operations.\n   (2)   We also considered making \"high-32 bit\"
        and \"low-32-bit\"\n         objects which, when combined, would be a 64-bit
        value.  This\n         simply seemed overly complex for what we are trying
        to do.\n      Furthermore, a full 64-bits of precision does not seem necessary.\n
        \     The value of ifHighSpeed will be the only report of interface\n      speed
        for interfaces that are faster than 4,294,967,295 bits per\n      second.
        \ At this speed, the granularity of ifHighSpeed will be\n      1,000,000 bits
        per second, thus the error will be 1/4294, or about\n      0.02%.  This seems
        reasonable.\n   (3)   Adding a \"scale\" object, which would define the units
        which\n         ifSpeed's value is.\n      This would require two additional
        objects; one for the scaling\n      object, and one to replace the current
        ifSpeed.  This later object\n      is required since the semantics of ifSpeed
        would be significantly\n      altered, and manager stations which do not understand
        the new\n      semantics would be confused.\n"
      title: 3.1.7.  Interface Speed
    - contents:
      - "3.1.8.  Multicast/Broadcast Counters\n   In MIB-II, the ifTable counters
        for multicast and broadcast packets\n   are combined as counters of non-unicast
        packets.  In contrast, the\n   ifExtensions MIB [19] defined one set of counters
        for multicast, and\n   a separate set for broadcast packets.  With the separate
        counters,\n   the original combined counters become redundant.  To avoid this\n
        \  redundancy, the non-unicast counters are deprecated.\n   For the output
        broadcast and multicast counters defined in RFC 1229,\n   their definitions
        varied slightly from the packet counters in the\n   ifTable, in that they
        did not count errors/discarded packets.  Thus,\n   this memo defines new objects
        with better aligned definitions.\n   Counters with 64 bits of range are also
        needed, as explained above.\n"
      title: 3.1.8.  Multicast/Broadcast Counters
    - contents:
      - "3.1.9.  Trap Enable\n   In the multi-layer interface model, each sub-layer
        for which there is\n   an entry in the ifTable can generate linkUp/linkDown
        Traps.  Since\n   interface state changes would tend to propagate through
        the interface\n   (from top to bottom, or bottom to top), it is likely that
        several\n   traps would be generated for each linkUp/linkDown occurrence.\n
        \  It is desirable to provide a mechanism for manager stations to\n   control
        the generation of these traps.  To this end, the\n   ifLinkUpDownTrapEnable
        object has been added.  This object allows\n   managers to limit generation
        of traps to just the sub-layers of\n   interest.\n   The default setting should
        limit the number of traps generated to one\n   per interface per linkUp/linkDown
        event.  Furthermore, it seems that\n   the state changes of most interest
        to network managers occur at the\n   lowest level of an interface stack.  Therefore
        we specify that by\n   default, only the lowest sub-layer of the interface
        generate traps.\n"
      title: 3.1.9.  Trap Enable
    - contents:
      - "3.1.10.  Addition of New ifType values\n   Over time, there is the need to
        add new ifType enumerated values for\n   new interface types.  If the syntax
        of ifType were defined in the MIB\n   in section 6, then a new version of
        this MIB would have to be re-\n   issued in order to define new values.  In
        the past, re-issuing of a\n   MIB has occurred only after several years.\n
        \  Therefore, the syntax of ifType is changed to be a textual\n   convention,
        such that the enumerated integer values are now defined\n   in the textual
        convention, IANAifType, defined in a different\n   document.  This allows
        additional values to be documented without\n   having to re-issue a new version
        of this document.  The Internet\n   Assigned Number Authority (IANA) is responsible
        for the assignment of\n   all Internet numbers, including various SNMP-related
        numbers, and\n   specifically, new ifType values.\n"
      title: 3.1.10.  Addition of New ifType values
    - contents:
      - "3.1.11.  InterfaceIndex Textual Convention\n   A new textual convention,
        InterfaceIndex, has been defined.  This\n   textual convention \"contains\"
        all of the semantics of the ifIndex\n   object.  This allows other MIB modules
        to easily import the semantics\n   of ifIndex.\n"
      title: 3.1.11.  InterfaceIndex Textual Convention
    - contents:
      - "3.1.12.  New states for IfOperStatus\n   Three new states have been added
        to ifOperStatus: 'dormant',\n   'notPresent', and 'lowerLayerDown'.\n   The
        dormant state indicates that the relevant interface is not\n   actually in
        a condition to pass packets (i.e., it is not 'up') but is\n   in a \"pending\"
        state, waiting for some external event.  For \"on-\n   demand\" interfaces,
        this new state identifies the situation where the\n   interface is waiting
        for events to place it in the up state.\n   Examples of such events might
        be:\n   (1)   having packets to transmit before establishing a connection
        to\n         a remote system;\n   (2)   having a remote system establish a
        connection to the interface\n         (e.g. dialing up to a slip-server).\n
        \  The notPresent state is a refinement on the down state which\n   indicates
        that the relevant interface is down specifically because\n   some component
        (typically, a hardware component) is not present in\n   the managed system.
        \ Examples of use of the notPresent state are:\n   (1)   to allow an interface's
        conceptual row including its counter\n         values to be retained across
        a \"hot swap\" of a card/module,\n         and/or\n   (2)   to allow an interface's
        conceptual row to be created, and\n         thereby enable interfaces to be
        pre-configured prior to\n         installation of the hardware needed to make
        the interface\n         operational.\n   Agents are not required to support
        interfaces in the notPresent\n   state.  However, from a conceptual viewpoint,
        when a row in the\n   ifTable is created, it first enters the notPresent state
        and then\n   subsequently transitions into the down state; similarly, when
        a row\n   in the ifTable is deleted, it first enters the notPresent state
        and\n   then subsequently the object instances are deleted.  For an agent\n
        \  with no support for notPresent, both of these transitions (from the\n   notPresent
        state to the down state, and from the notPresent state to\n   the instances
        being removed) are immediate, i.e., the transition does\n   not last long
        enough to be recorded by ifOperStatus.  Even for those\n   agents which do
        support interfaces in the notPresent state, the\n   length of time and conditions
        under which an interface stays in the\n   notPresent state is implementation-specific.\n
        \  The lowerLayerDown state is also a refinement on the down state.\n   This
        new state indicates that this interface runs \"on top of\" one or\n   more
        other interfaces (see ifStackTable) and that this interface is\n   down specifically
        because one or more of these lower-layer interfaces\n   are down.\n"
      title: 3.1.12.  New states for IfOperStatus
    - contents:
      - "3.1.13.  IfAdminStatus and IfOperStatus\n   The down state of ifOperStatus
        now has two meanings, depending on the\n   value of ifAdminStatus.\n   (1)
        \  if ifAdminStatus is not down and ifOperStatus is down then a\n         fault
        condition is presumed to exist on the interface.\n   (2)   if ifAdminStatus
        is down, then ifOperStatus will normally also\n         be down (or notPresent)
        i.e., there is not (necessarily) a\n         fault condition on the interface.\n
        \  Note that when ifAdminStatus transitions to down, ifOperStatus will\n   normally
        also transition to down.  In this situation, it is possible\n   that ifOperStatus's
        transition will not occur immediately, but rather\n   after a small time lag
        to complete certain operations before going\n   \"down\"; for example, it
        might need to finish transmitting a packet.\n   If a manager station finds
        that ifAdminStatus is down and\n   ifOperStatus is not down for a particular
        interface, the manager\n   station should wait a short while and check again.
        \ If the condition\n   still exists, only then should it raise an error indication.\n
        \  Naturally, it should also ensure that ifLastChange has not changed\n   during
        this interval.\n   Whenever an interface table entry is created (usually as
        a result of\n   system initialization), the relevant instance of ifAdminStatus
        is set\n   to down, and ifOperStatus will be down or notPresent.\n   An interface
        may be enabled in two ways: either as a result of\n   explicit management
        action (e.g. setting ifAdminStatus to up) or as a\n   result of the managed
        system's initialization process.  When\n   ifAdminStatus changes to the up
        state, the related ifOperStatus\n   should do one of the following:\n   (1)
        \  Change to the up state if and only if the interface is able to\n         send
        and receive packets.\n   (2)   Change to the lowerLayerDown state if and only
        if the interface\n         is prevented from entering the up state because
        of the state of\n         one or more of the interfaces beneath it in the
        interface\n         stack.\n   (3)   Change to the dormant state if and only
        if the interface is\n         found to be operable, but the interface is waiting
        for other,\n         external, events to occur before it can transmit or receive\n
        \        packets.  Presumably when the expected events occur, the\n         interface
        will then change to the up state.\n   (4)   Remain in the down state if an
        error or other fault condition\n         is detected on the interface.\n   (5)
        \  Change to the unknown state if, for some reason, the state of\n         the
        interface can not be ascertained.\n   (6)   Change to the testing state if
        some test(s) must be performed\n         on the interface. Presumably after
        completion of the test, the\n         interface's state will change to up,
        dormant, or down, as\n         appropriate.\n   (7)   Remain in the notPresent
        state if interface components are\n         missing.\n"
      title: 3.1.13.  IfAdminStatus and IfOperStatus
    - contents:
      - "3.1.14.  IfOperStatus in an Interface Stack\n   When an interface is a part
        of an interface-stack, but is not the\n   lowest interface in the stack, then:\n
        \  (1)   ifOperStatus has the value 'up' if it is able to pass packets\n         due
        to one or more interfaces below it in the stack being 'up',\n         irrespective
        of whether other interfaces below it are 'down', '\n         dormant', 'notPresent',
        'lowerLayerDown', 'unknown' or '\n         testing'.\n   (2)   ifOperStatus
        may have the value 'up' or 'dormant' if one or\n         more interfaces below
        it in the stack are 'dormant', and all\n         others below it are either
        'down', 'dormant', 'notPresent', '\n         lowerLayerDown', 'unknown' or
        'testing'.\n   (3)   ifOperStatus has the value 'lowerLayerDown' while all\n
        \        interfaces below it in the stack are either 'down', '\n         notPresent',
        'lowerLayerDown', or 'testing'.\n"
      title: 3.1.14.  IfOperStatus in an Interface Stack
    - contents:
      - "3.1.15.  Traps\n   The exact definition of when linkUp and linkDown traps
        are generated\n   has been changed to reflect the changes to ifAdminStatus
        and\n   ifOperStatus.  Operational experience indicates that management\n
        \  stations are most concerned with an interface being in the down state\n
        \  and the fact that this state may indicate a failure.  Thus, it is\n   most
        useful to instrument transitions into/out of either the up state\n   or the
        down state.\n   Instrumenting transitions into or out of the up state was
        rejected\n   since it would have the drawback that a demand interface might
        have\n   many transitions between up and dormant, leading to many linkUp traps\n
        \  and no linkDown traps.  Furthermore, if a node's only interface is\n   the
        demand interface, then a transition to dormant would entail\n   generation
        of a linkDown trap, necessitating bringing the link to the\n   up state (and
        a linkUp trap)!!\n   On the other hand, instrumenting transitions into or
        out of the down\n   state (to/from all other states except notPresent) has
        the\n   advantages:\n   (1)   A transition into the down state (from a state
        other than\n         notPresent) will occur when an error is detected on an\n
        \        interface.  Error conditions are presumably of great interest\n         to
        network managers.\n   (2)   Departing the down state (to a state other than
        the notPresent\n         state) generally indicates that the interface is
        going to\n         either up or dormant, both of which are considered \"healthy\"\n
        \        states.\n   Furthermore, it is believed that generating traps on
        transitions into\n   or out of the down state (except to/from the notPresent
        state) is\n   generally consistent with current usage and interpretation of
        these\n   traps by manager stations.\n   Transitions to/from the notPresent
        state are concerned with the\n   insertion and removal of hardware, and are
        outside the scope of these\n   traps.\n   Therefore, this memo defines that
        LinkUp and linkDown traps are\n   generated just after ifOperStatus leaves,
        or just before it enters,\n   the down state, respectively; except that LinkUp
        and linkDown traps\n   are never generated on transitions to/from the notPresent
        state.  For\n   the purpose of deciding when these traps occur, the lowerLayerDown\n
        \  state and the down state are considered to be equivalent, i.e., there\n
        \  is no trap on transition from lowerLayerDown into down, and there is\n
        \  a trap on transition from any other state except down (and\n   notPresent)
        into lowerLayerDown.\n   Note that this definition allows a node with only
        one interface to\n   transmit a linkDown trap before that interface goes down.
        \ (Of\n   course, when the interface is going down because of a failure\n
        \  condition, the linkDown trap probably cannot be successfully\n   transmitted
        anyway.)\n   Some interfaces perform a link \"training\" function when trying
        to\n   bring the interface up.  In the event that such an interface were\n
        \  defective, then the training function would fail and the interface\n   would
        remain down, and the training function might be repeated at\n   appropriate
        intervals.  If the interface, while performing this\n   training function,
        were considered to the in the testing state, then\n   linkUp and linkDown
        traps would be generated for each start and end\n   of the training function.
        \ This is not the intent of the linkUp and\n   linkDown traps, and therefore,
        while performing such a training\n   function, the interface's state should
        be represented as down.\n   An exception to the above generation of linkUp/linkDown
        traps on\n   changes in ifOperStatus, occurs when an interface is \"flapping\",\n
        \  i.e., when it is rapidly oscillating between the up and down states.\n
        \  If traps were generated for each such oscillation, the network and\n   the
        network management system would be flooded with unnecessary\n   traps.  In
        such a situation, the agent should limit the rate at which\n   it generates
        traps.\n"
      title: 3.1.15.  Traps
    - contents:
      - "3.1.16.  ifSpecific\n   The original definition of the OBJECT IDENTIFIER
        value of ifSpecific\n   was not sufficiently clear.  As a result, different
        implementors used\n   it differently, and confusion resulted.  Some implementations
        set the\n   value of ifSpecific to the OBJECT IDENTIFIER that defines the
        media-\n   specific MIB, i.e., the \"foo\" of:\n                foo OBJECT
        IDENTIFIER ::= { transmission xxx }\n   while others set it to be OBJECT IDENTIFIER
        of the specific table or\n   entry in the appropriate media-specific MIB (i.e.,
        fooTable or\n   fooEntry), while still others set it be the OBJECT IDENTIFIER
        of the\n   index object of the table's row, including instance identifier,\n
        \  (i.e., fooIfIndex.ifIndex).  A definition based on the latter would\n   not
        be sufficient unless it also allowed for media-specific MIBs\n   which include
        several tables, where each table has its own\n   (different) indexing.\n   The
        only definition that can both be made explicit and can cover all\n   the useful
        situations is to have ifSpecific be the most general value\n   for the media-specific
        MIB module (the first example given above).\n   This effectively makes it
        redundant because it contains no more\n   information than is provided by
        ifType.  Thus, ifSpecific has been\n   deprecated.\n"
      title: 3.1.16.  ifSpecific
    - contents:
      - "3.1.17.  Creation/Deletion of Interfaces\n   While some interfaces, for example,
        most physical interfaces, cannot\n   be created via network management, other
        interfaces such as logical\n   interfaces sometimes can be.  The ifTable contains
        only generic\n   information about an interface.  Almost all 'create-able'
        interfaces\n   have other, media-specific, information through which configuration\n
        \  parameters may be supplied prior to creating such an interface.\n   Thus,
        the ifTable does not itself support the creation or deletion of\n   an interface
        (specifically, it has no RowStatus [6] column).  Rather,\n   if a particular
        interface type supports the dynamic creation and/or\n   deletion of an interface
        of that type, then that media-specific MIB\n   should include an appropriate
        RowStatus object (see the ATM LAN-\n   Emulation Client MIB [20] for an example
        of a MIB which does this).\n   Typically, when such a RowStatus object is
        created/deleted, then the\n   conceptual row in the ifTable appears/disappears
        as a by-product, and\n   an ifIndex value (chosen by the agent) is stored
        in an appropriate\n   object in the media-specific MIB.\n"
      title: 3.1.17.  Creation/Deletion of Interfaces
    - contents:
      - "3.1.18.  All Values Must be Known\n   There are a number of situations where
        an agent does not know the\n   value of one or more objects for a particular
        interface.  In all such\n   circumstances, an agent MUST NOT instantiate an
        object with an\n   incorrect value; rather, it MUST respond with the appropriate\n
        \  error/exception condition (e.g., noSuchInstance or noSuchName).\n   One
        example is where an agent is unable to count the occurrences\n   defined by
        one (or more) of the ifTable counters.  In this\n   circumstance, the agent
        MUST NOT instantiate the particular counter\n   with a value of, say, zero.
        \ To do so would be to provide mis-\n   information to a network management
        application reading the zero\n   value, and thereby assuming that there have
        been no occurrences of\n   the event (e.g., no input errors because ifInErrors
        is always zero).\n   Sometimes the lack of knowledge of an object's value
        is temporary.\n   For example, when the MTU of an interface is a configured
        value and a\n   device dynamically learns the configured value through (after)\n
        \  exchanging messages over the interface (e.g., ATM LAN-Emulation\n   [20]).
        \ In such a case, the value is not known until after the\n   ifTable entry
        has already been created.  In such a case, the ifTable\n   entry should be
        created without an instance of the object whose value\n   is unknown; later,
        when the value becomes known, the missing object\n   can then be instantiated
        (e.g., the instance of ifMtu is only\n   instantiated once the interface's
        MTU becomes known).\n   As a result of this \"known values\" rule, management
        applications MUST\n   be able to cope with the responses to retrieving the
        object instances\n   within a conceptual row of the ifTable revealing that
        some of the\n   row's columnar objects are missing/not available.\n"
      title: 3.1.18.  All Values Must be Known
    title: 3.1.  Clarifications/Revisions
  title: 3.  Experience with the Interfaces Group
- contents:
  - "4.  Media-Specific MIB Applicability\n   The exact use and semantics of many
    objects in this MIB are open to\n   some interpretation.  This is a result of
    the generic nature of this\n   MIB.  It is not always possible to come up with
    specific,\n   unambiguous, text that covers all cases and yet preserves the generic\n
    \  nature of the MIB.\n   Therefore, it is incumbent upon a media-specific MIB
    designer to,\n   wherever necessary, clarify the use of the objects in this MIB
    with\n   respect to the media-specific MIB.\n   Specific areas of clarification
    include\n   Layering Model\n      The media-specific MIB designer MUST completely
    and unambiguously\n      specify the layering model used.  Each individual sub-layer
    must\n      be identified, as must the ifStackTable's portrayal of the\n      relationship(s)
    between the sub-layers.\n   Virtual Circuits\n      The media-specific MIB designer
    MUST specify whether virtual\n      circuits are assigned entries in the ifTable
    or not.  If they are,\n      compelling rationale must be presented.\n   ifRcvAddressTable\n
    \     The media-specific MIB designer MUST specify the applicability of\n      the
    ifRcvAddressTable.\n   ifType\n      For each of the ifType values to which the
    media-specific MIB\n      applies, it must specify the mapping of ifType values
    to media-\n      specific MIB module(s) and instances of MIB objects within those\n
    \     modules.\n   ifXxxOctets\n      The definitions of ifInOctets and ifOutOctets
    (and similarly,\n      ifHCInOctets and ifHCOutOctets) specify that their values
    include\n      framing characters.  The media-specific MIB designer MUST specify\n
    \     any special conditions of the media concerning the inclusion of\n      framing
    characters, especially with respect to frames with errors.\n   However, wherever
    this interface MIB is specific in the semantics,\n   DESCRIPTION, or applicability
    of objects, the media-specific MIB\n   designer MUST NOT change said semantics,
    DESCRIPTION, or\n   applicability.\n"
  title: 4.  Media-Specific MIB Applicability
- contents:
  - "5.  Overview\n   This MIB consists of 4 tables:\n   ifTable\n      This table
    is the ifTable from MIB-II.\n   ifXTable\n      This table contains objects that
    have been added to the Interface\n      MIB as a result of the Interface Evolution
    effort, or replacements\n      for objects of the original (MIB-II) ifTable that
    were deprecated\n      because the semantics of said objects have significantly
    changed.\n      This table also contains objects that were previously in the\n
    \     ifExtnsTable.\n   ifStackTable\n      This table contains objects that define
    the relationships among\n      the sub-layers of an interface.\n   ifRcvAddressTable\n
    \     This table contains objects that are used to define the media-\n      level
    addresses which this interface will receive.  This table is\n      a generic table.
    \ The designers of media-specific MIBs must define\n      exactly how this table
    applies to their specific MIB.\n"
  title: 5.  Overview
- contents:
  - '6.  Interfaces Group Definitions

    '
  - 'IF-MIB DEFINITIONS ::= BEGIN

    '
  - "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32, Counter64,\n    Integer32,
    TimeTicks, mib-2,\n    NOTIFICATION-TYPE                        FROM SNMPv2-SMI\n
    \   TEXTUAL-CONVENTION, DisplayString,\n    PhysAddress, TruthValue, RowStatus,\n
    \   TimeStamp, AutonomousType, TestAndIncr   FROM SNMPv2-TC\n    MODULE-COMPLIANCE,
    OBJECT-GROUP,\n    NOTIFICATION-GROUP                       FROM SNMPv2-CONF\n
    \   snmpTraps                                FROM SNMPv2-MIB\n    IANAifType                               FROM
    IANAifType-MIB;\n"
  - "ifMIB MODULE-IDENTITY\n    LAST-UPDATED \"200006140000Z\"\n    ORGANIZATION \"IETF
    Interfaces MIB Working Group\"\n    CONTACT-INFO\n            \"   Keith McCloghrie\n
    \               Cisco Systems, Inc.\n                170 West Tasman Drive\n                San
    Jose, CA  95134-1706\n                US\n                408-526-5260\n                kzm@cisco.com\"\n
    \   DESCRIPTION\n            \"The MIB module to describe generic objects for
    network\n            interface sub-layers.  This MIB is an updated version of\n
    \           MIB-II's ifTable, and incorporates the extensions defined in\n            RFC
    1229.\"\n    REVISION      \"200006140000Z\"\n    DESCRIPTION\n            \"Clarifications
    agreed upon by the Interfaces MIB WG, and\n            published as RFC 2863.\"\n
    \   REVISION      \"199602282155Z\"\n    DESCRIPTION\n            \"Revisions
    made by the Interfaces MIB WG, and published in\n            RFC 2233.\"\n    REVISION
    \     \"199311082155Z\"\n    DESCRIPTION\n            \"Initial revision, published
    as part of RFC 1573.\"\n    ::= { mib-2 31 }\n"
  - 'ifMIBObjects OBJECT IDENTIFIER ::= { ifMIB 1 }

    '
  - 'interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }

    '
  - '--

    '
  - '-- Textual Conventions

    '
  - '--

    '
  - '-- OwnerString has the same semantics as used in RFC 1271

    '
  - "OwnerString ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"255a\"\n    STATUS       deprecated\n
    \   DESCRIPTION\n            \"This data type is used to model an administratively\n
    \           assigned name of the owner of a resource.  This information\n            is
    taken from the NVT ASCII character set.  It is suggested\n            that this
    name contain one or more of the following: ASCII\n            form of the manager
    station's transport address, management\n            station name (e.g., domain
    name), network management\n            personnel's name, location, or phone number.
    \ In some cases\n            the agent itself will be the owner of an entry.  In
    these\n            cases, this string shall be set to a string starting with\n
    \           'agent'.\"\n    SYNTAX       OCTET STRING (SIZE(0..255))\n"
  - '-- InterfaceIndex contains the semantics of ifIndex and should be used

    '
  - '-- for any objects defined in other MIB modules that need these semantics.

    '
  - "InterfaceIndex ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"d\"\n    STATUS       current\n
    \   DESCRIPTION\n            \"A unique value, greater than zero, for each interface
    or\n            interface sub-layer in the managed system.  It is\n            recommended
    that values are assigned contiguously starting\n            from 1.  The value
    for each interface sub-layer must remain\n            constant at least from one
    re-initialization of the entity's\n            network management system to the
    next re-initialization.\"\n    SYNTAX       Integer32 (1..2147483647)\n"
  - "InterfaceIndexOrZero ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"d\"\n    STATUS
    \      current\n    DESCRIPTION\n            \"This textual convention is an extension
    of the\n            InterfaceIndex convention.  The latter defines a greater\n
    \           than zero value used to identify an interface or interface\n            sub-layer
    in the managed system.  This extension permits the\n            additional value
    of zero.  the value zero is object-specific\n            and must therefore be
    defined as part of the description of\n            any object which uses this
    syntax.  Examples of the usage of\n            zero might include situations where
    interface was unknown,\n            or when none or all interfaces need to be
    referenced.\"\n    SYNTAX       Integer32 (0..2147483647)\n"
  - "ifNumber  OBJECT-TYPE\n    SYNTAX      Integer32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of network
    interfaces (regardless of their\n            current state) present on this system.\"\n
    \   ::= { interfaces 1 }\n"
  - "ifTableLastChange  OBJECT-TYPE\n    SYNTAX      TimeTicks\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The value of sysUpTime
    at the time of the last creation or\n            deletion of an entry in the ifTable.
    \ If the number of\n            entries has been unchanged since the last re-initialization\n
    \           of the local network management subsystem, then this object\n            contains
    a zero value.\"\n    ::= { ifMIBObjects 5 }\n"
  - '-- the Interfaces table

    '
  - '-- The Interfaces table contains information on the entity''s

    '
  - '-- interfaces.  Each sub-layer below the internetwork-layer

    '
  - '-- of a network interface is considered to be an interface.

    '
  - "ifTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF IfEntry\n    MAX-ACCESS  not-accessible\n
    \   STATUS      current\n    DESCRIPTION\n            \"A list of interface entries.
    \ The number of entries is\n            given by the value of ifNumber.\"\n    ::=
    { interfaces 2 }\n"
  - "ifEntry OBJECT-TYPE\n    SYNTAX      IfEntry\n    MAX-ACCESS  not-accessible\n
    \   STATUS      current\n    DESCRIPTION\n            \"An entry containing management
    information applicable to a\n            particular interface.\"\n    INDEX   {
    ifIndex }\n    ::= { ifTable 1 }\n"
  - "IfEntry ::=\n    SEQUENCE {\n        ifIndex                 InterfaceIndex,\n
    \       ifDescr                 DisplayString,\n        ifType                  IANAifType,\n
    \       ifMtu                   Integer32,\n        ifSpeed                 Gauge32,\n
    \       ifPhysAddress           PhysAddress,\n        ifAdminStatus           INTEGER,\n
    \       ifOperStatus            INTEGER,\n        ifLastChange            TimeTicks,\n
    \       ifInOctets              Counter32,\n        ifInUcastPkts           Counter32,\n
    \       ifInNUcastPkts          Counter32,  -- deprecated\n        ifInDiscards
    \           Counter32,\n        ifInErrors              Counter32,\n        ifInUnknownProtos
    \      Counter32,\n        ifOutOctets             Counter32,\n        ifOutUcastPkts
    \         Counter32,\n        ifOutNUcastPkts         Counter32,  -- deprecated\n
    \       ifOutDiscards           Counter32,\n        ifOutErrors             Counter32,\n
    \       ifOutQLen               Gauge32,    -- deprecated\n        ifSpecific
    \             OBJECT IDENTIFIER -- deprecated\n    }\n"
  - "ifIndex OBJECT-TYPE\n    SYNTAX      InterfaceIndex\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"A unique value, greater
    than zero, for each interface.  It\n            is recommended that values are
    assigned contiguously\n            starting from 1.  The value for each interface
    sub-layer\n            must remain constant at least from one re-initialization
    of\n            the entity's network management system to the next re-\n            initialization.\"\n
    \   ::= { ifEntry 1 }\n"
  - "ifDescr OBJECT-TYPE\n    SYNTAX      DisplayString (SIZE (0..255))\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n            \"A textual
    string containing information about the\n            interface.  This string should
    include the name of the\n            manufacturer, the product name and the version
    of the\n            interface hardware/software.\"\n    ::= { ifEntry 2 }\n"
  - "ifType OBJECT-TYPE\n    SYNTAX      IANAifType\n    MAX-ACCESS  read-only\n    STATUS
    \     current\n    DESCRIPTION\n            \"The type of interface.  Additional
    values for ifType are\n            assigned by the Internet Assigned Numbers Authority
    (IANA),\n            through updating the syntax of the IANAifType textual\n            convention.\"\n
    \   ::= { ifEntry 3 }\n"
  - "ifMtu OBJECT-TYPE\n    SYNTAX      Integer32\n    MAX-ACCESS  read-only\n    STATUS
    \     current\n    DESCRIPTION\n            \"The size of the largest packet which
    can be sent/received\n            on the interface, specified in octets.  For
    interfaces that\n            are used for transmitting network datagrams, this
    is the\n            size of the largest network datagram that can be sent on the\n
    \           interface.\"\n    ::= { ifEntry 4 }\n"
  - "ifSpeed OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n    STATUS
    \     current\n    DESCRIPTION\n            \"An estimate of the interface's current
    bandwidth in bits\n            per second.  For interfaces which do not vary in
    bandwidth\n            or for those where no accurate estimation can be made,
    this\n            object should contain the nominal bandwidth.  If the\n            bandwidth
    of the interface is greater than the maximum value\n            reportable by
    this object then this object should report its\n            maximum value (4,294,967,295)
    and ifHighSpeed must be used\n            to report the interace's speed.  For
    a sub-layer which has\n            no concept of bandwidth, this object should
    be zero.\"\n    ::= { ifEntry 5 }\n"
  - "ifPhysAddress OBJECT-TYPE\n    SYNTAX      PhysAddress\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The interface's address
    at its protocol sub-layer.  For\n            example, for an 802.x interface,
    this object normally\n            contains a MAC address.  The interface's media-specific
    MIB\n            must define the bit and byte ordering and the format of the\n
    \           value of this object.  For interfaces which do not have such\n            an
    address (e.g., a serial line), this object should contain\n            an octet
    string of zero length.\"\n    ::= { ifEntry 6 }\n"
  - "ifAdminStatus OBJECT-TYPE\n    SYNTAX  INTEGER {\n                up(1),       --
    ready to pass packets\n                down(2),\n                testing(3)   --
    in some test mode\n            }\n    MAX-ACCESS  read-write\n    STATUS      current\n
    \   DESCRIPTION\n            \"The desired state of the interface.  The testing(3)
    state\n            indicates that no operational packets can be passed.  When
    a\n            managed system initializes, all interfaces start with\n            ifAdminStatus
    in the down(2) state.  As a result of either\n            explicit management
    action or per configuration information\n            retained by the managed system,
    ifAdminStatus is then\n            changed to either the up(1) or testing(3) states
    (or remains\n            in the down(2) state).\"\n    ::= { ifEntry 7 }\n"
  - "ifOperStatus OBJECT-TYPE\n    SYNTAX  INTEGER {\n                up(1),        --
    ready to pass packets\n                down(2),\n                testing(3),   --
    in some test mode\n                unknown(4),   -- status can not be determined\n
    \                             -- for some reason.\n                dormant(5),\n
    \               notPresent(6),    -- some component is missing\n                lowerLayerDown(7)
    -- down due to state of\n                                  -- lower-layer interface(s)\n
    \           }\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n
    \           \"The current operational state of the interface.  The\n            testing(3)
    state indicates that no operational packets can\n            be passed.  If ifAdminStatus
    is down(2) then ifOperStatus\n            should be down(2).  If ifAdminStatus
    is changed to up(1)\n            then ifOperStatus should change to up(1) if the
    interface is\n            ready to transmit and receive network traffic; it should\n
    \           change to dormant(5) if the interface is waiting for\n            external
    actions (such as a serial line waiting for an\n            incoming connection);
    it should remain in the down(2) state\n            if and only if there is a fault
    that prevents it from going\n            to the up(1) state; it should remain
    in the notPresent(6)\n            state if the interface has missing (typically,
    hardware)\n            components.\"\n    ::= { ifEntry 8 }\n"
  - "ifLastChange OBJECT-TYPE\n    SYNTAX      TimeTicks\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The value of sysUpTime
    at the time the interface entered\n            its current operational state.
    \ If the current state was\n            entered prior to the last re-initialization
    of the local\n            network management subsystem, then this object contains
    a\n            zero value.\"\n    ::= { ifEntry 9 }\n"
  - "ifInOctets OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of octets
    received on the interface,\n            including framing characters.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifEntry 10 }\n"
  - "ifInUcastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were not
    addressed to a multicast\n            or broadcast address at this sub-layer.\n
    \           Discontinuities in the value of this counter can occur at\n            re-initialization
    of the management system, and at other\n            times as indicated by the
    value of\n            ifCounterDiscontinuityTime.\"\n    ::= { ifEntry 11 }\n"
  - "ifInNUcastPkts OBJECT-TYPE\n    SYNTAX  Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      deprecated\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were addressed
    to a multicast or\n            broadcast address at this sub-layer.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\n            This object is deprecated
    in favour of ifInMulticastPkts and\n            ifInBroadcastPkts.\"\n    ::=
    { ifEntry 12 }\n"
  - "ifInDiscards OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of inbound
    packets which were chosen to be\n            discarded even though no errors had
    been detected to prevent\n            their being deliverable to a higher-layer
    protocol.  One\n            possible reason for discarding such a packet could
    be to\n            free up buffer space.\n            Discontinuities in the value
    of this counter can occur at\n            re-initialization of the management
    system, and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifEntry 13 }\n"
  - "ifInErrors OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"For packet-oriented interfaces,
    the number of inbound\n            packets that contained errors preventing them
    from being\n            deliverable to a higher-layer protocol.  For character-\n
    \           oriented or fixed-length interfaces, the number of inbound\n            transmission
    units that contained errors preventing them\n            from being deliverable
    to a higher-layer protocol.\n            Discontinuities in the value of this
    counter can occur at\n            re-initialization of the management system,
    and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifEntry 14 }\n"
  - "ifInUnknownProtos OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"For packet-oriented interfaces,
    the number of packets\n            received via the interface which were discarded
    because of\n            an unknown or unsupported protocol.  For character-oriented\n
    \           or fixed-length interfaces that support protocol\n            multiplexing
    the number of transmission units received via\n            the interface which
    were discarded because of an unknown or\n            unsupported protocol.  For
    any interface that does not\n            support protocol multiplexing, this counter
    will always be\n            0.\n            Discontinuities in the value of this
    counter can occur at\n            re-initialization of the management system,
    and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifEntry 15 }\n"
  - "ifOutOctets OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of octets
    transmitted out of the\n            interface, including framing characters.\n
    \           Discontinuities in the value of this counter can occur at\n            re-initialization
    of the management system, and at other\n            times as indicated by the
    value of\n            ifCounterDiscontinuityTime.\"\n    ::= { ifEntry 16 }\n"
  - "ifOutUcastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    not addressed to a\n            multicast or broadcast address at this sub-layer,
    including\n            those that were discarded or not sent.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifEntry 17 }\n"
  - "ifOutNUcastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      deprecated\n    DESCRIPTION\n            \"The total number of
    packets that higher-level protocols\n            requested be transmitted, and
    which were addressed to a\n            multicast or broadcast address at this
    sub-layer, including\n            those that were discarded or not sent.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\n            This object is deprecated
    in favour of ifOutMulticastPkts\n            and ifOutBroadcastPkts.\"\n    ::=
    { ifEntry 18 }\n"
  - "ifOutDiscards OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of outbound
    packets which were chosen to be\n            discarded even though no errors had
    been detected to prevent\n            their being transmitted.  One possible reason
    for discarding\n            such a packet could be to free up buffer space.\n
    \           Discontinuities in the value of this counter can occur at\n            re-initialization
    of the management system, and at other\n            times as indicated by the
    value of\n            ifCounterDiscontinuityTime.\"\n    ::= { ifEntry 19 }\n"
  - "ifOutErrors OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"For packet-oriented interfaces,
    the number of outbound\n            packets that could not be transmitted because
    of errors.\n            For character-oriented or fixed-length interfaces, the\n
    \           number of outbound transmission units that could not be\n            transmitted
    because of errors.\n            Discontinuities in the value of this counter can
    occur at\n            re-initialization of the management system, and at other\n
    \           times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifEntry 20 }\n"
  - "ifOutQLen OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n    STATUS
    \     deprecated\n    DESCRIPTION\n            \"The length of the output packet
    queue (in packets).\"\n    ::= { ifEntry 21 }\n"
  - "ifSpecific OBJECT-TYPE\n    SYNTAX      OBJECT IDENTIFIER\n    MAX-ACCESS  read-only\n
    \   STATUS      deprecated\n    DESCRIPTION\n            \"A reference to MIB
    definitions specific to the particular\n            media being used to realize
    the interface.  It is\n            recommended that this value point to an instance
    of a MIB\n            object in the media-specific MIB, i.e., that this object\n
    \           have the semantics associated with the InstancePointer\n            textual
    convention defined in RFC 2579.  In fact, it is\n            recommended that
    the media-specific MIB specify what value\n            ifSpecific should/can take
    for values of ifType.  If no MIB\n            definitions specific to the particular
    media are available,\n            the value should be set to the OBJECT IDENTIFIER
    { 0 0 }.\"\n    ::= { ifEntry 22 }\n"
  - '--

    '
  - '--   Extension to the interface table

    '
  - '--

    '
  - '-- This table replaces the ifExtnsTable table.

    '
  - '--

    '
  - "ifXTable        OBJECT-TYPE\n    SYNTAX      SEQUENCE OF IfXEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"A list
    of interface entries.  The number of entries is\n            given by the value
    of ifNumber.  This table contains\n            additional objects for the interface
    table.\"\n    ::= { ifMIBObjects 1 }\n"
  - "ifXEntry        OBJECT-TYPE\n    SYNTAX      IfXEntry\n    MAX-ACCESS  not-accessible\n
    \   STATUS      current\n    DESCRIPTION\n            \"An entry containing additional
    management information\n            applicable to a particular interface.\"\n
    \   AUGMENTS    { ifEntry }\n    ::= { ifXTable 1 }\n"
  - "IfXEntry ::=\n    SEQUENCE {\n        ifName                  DisplayString,\n
    \       ifInMulticastPkts       Counter32,\n        ifInBroadcastPkts       Counter32,\n
    \       ifOutMulticastPkts      Counter32,\n        ifOutBroadcastPkts      Counter32,\n
    \       ifHCInOctets            Counter64,\n        ifHCInUcastPkts         Counter64,\n
    \       ifHCInMulticastPkts     Counter64,\n        ifHCInBroadcastPkts     Counter64,\n
    \       ifHCOutOctets           Counter64,\n        ifHCOutUcastPkts        Counter64,\n
    \       ifHCOutMulticastPkts    Counter64,\n        ifHCOutBroadcastPkts    Counter64,\n
    \       ifLinkUpDownTrapEnable  INTEGER,\n        ifHighSpeed             Gauge32,\n
    \       ifPromiscuousMode       TruthValue,\n        ifConnectorPresent      TruthValue,\n
    \       ifAlias                 DisplayString,\n        ifCounterDiscontinuityTime
    TimeStamp\n    }\n"
  - "ifName OBJECT-TYPE\n    SYNTAX      DisplayString\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The textual name of the
    interface.  The value of this\n            object should be the name of the interface
    as assigned by\n            the local device and should be suitable for use in
    commands\n            entered at the device's `console'.  This might be a text\n
    \           name, such as `le0' or a simple port number, such as `1',\n            depending
    on the interface naming syntax of the device.  If\n            several entries
    in the ifTable together represent a single\n            interface as named by
    the device, then each will have the\n            same value of ifName.  Note that
    for an agent which responds\n            to SNMP queries concerning an interface
    on some other\n            (proxied) device, then the value of ifName for such
    an\n            interface is the proxied device's local name for it.\n            If
    there is no local name, or this object is otherwise not\n            applicable,
    then this object contains a zero-length string.\"\n    ::= { ifXEntry 1 }\n"
  - "ifInMulticastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were addressed
    to a multicast\n            address at this sub-layer.  For a MAC layer protocol,
    this\n            includes both Group and Functional addresses.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 2 }\n"
  - "ifInBroadcastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were addressed
    to a broadcast\n            address at this sub-layer.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 3 }\n"
  - "ifOutMulticastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    addressed to a\n            multicast address at this sub-layer, including those
    that\n            were discarded or not sent.  For a MAC layer protocol, this\n
    \           includes both Group and Functional addresses.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 4 }\n"
  - "ifOutBroadcastPkts OBJECT-TYPE\n    SYNTAX      Counter32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    addressed to a\n            broadcast address at this sub-layer, including those
    that\n            were discarded or not sent.\n            Discontinuities in
    the value of this counter can occur at\n            re-initialization of the management
    system, and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifXEntry 5 }\n"
  - '--

    '
  - '-- High Capacity Counter objects.  These objects are all

    '
  - '-- 64 bit versions of the "basic" ifTable counters.  These

    '
  - '-- objects all have the same basic semantics as their 32-bit

    '
  - '-- counterparts, however, their syntax has been extended

    '
  - '-- to 64 bits.

    '
  - '--

    '
  - "ifHCInOctets OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of octets
    received on the interface,\n            including framing characters.  This object
    is a 64-bit\n            version of ifInOctets.\n            Discontinuities in
    the value of this counter can occur at\n            re-initialization of the management
    system, and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifXEntry 6 }\n"
  - "ifHCInUcastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were not
    addressed to a multicast\n            or broadcast address at this sub-layer.
    \ This object is a\n            64-bit version of ifInUcastPkts.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 7 }\n"
  - "ifHCInMulticastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were addressed
    to a multicast\n            address at this sub-layer.  For a MAC layer protocol,
    this\n            includes both Group and Functional addresses.  This object\n
    \           is a 64-bit version of ifInMulticastPkts.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 8 }\n"
  - "ifHCInBroadcastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The number of packets,
    delivered by this sub-layer to a\n            higher (sub-)layer, which were addressed
    to a broadcast\n            address at this sub-layer.  This object is a 64-bit
    version\n            of ifInBroadcastPkts.\n            Discontinuities in the
    value of this counter can occur at\n            re-initialization of the management
    system, and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifXEntry 9 }\n"
  - "ifHCOutOctets OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of octets
    transmitted out of the\n            interface, including framing characters.  This
    object is a\n            64-bit version of ifOutOctets.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 10 }\n"
  - "ifHCOutUcastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    not addressed to a\n            multicast or broadcast address at this sub-layer,
    including\n            those that were discarded or not sent.  This object is
    a\n            64-bit version of ifOutUcastPkts.\n            Discontinuities
    in the value of this counter can occur at\n            re-initialization of the
    management system, and at other\n            times as indicated by the value of\n
    \           ifCounterDiscontinuityTime.\"\n    ::= { ifXEntry 11 }\n"
  - "ifHCOutMulticastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    addressed to a\n            multicast address at this sub-layer, including those
    that\n            were discarded or not sent.  For a MAC layer protocol, this\n
    \           includes both Group and Functional addresses.  This object\n            is
    a 64-bit version of ifOutMulticastPkts.\n            Discontinuities in the value
    of this counter can occur at\n            re-initialization of the management
    system, and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifXEntry 12 }\n"
  - "ifHCOutBroadcastPkts OBJECT-TYPE\n    SYNTAX      Counter64\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"The total number of packets
    that higher-level protocols\n            requested be transmitted, and which were
    addressed to a\n            broadcast address at this sub-layer, including those
    that\n            were discarded or not sent.  This object is a 64-bit version\n
    \           of ifOutBroadcastPkts.\n            Discontinuities in the value of
    this counter can occur at\n            re-initialization of the management system,
    and at other\n            times as indicated by the value of\n            ifCounterDiscontinuityTime.\"\n
    \   ::= { ifXEntry 13 }\n"
  - "ifLinkUpDownTrapEnable  OBJECT-TYPE\n    SYNTAX      INTEGER { enabled(1), disabled(2)
    }\n    MAX-ACCESS  read-write\n    STATUS      current\n    DESCRIPTION\n            \"Indicates
    whether linkUp/linkDown traps should be generated\n            for this interface.\n
    \           By default, this object should have the value enabled(1) for\n            interfaces
    which do not operate on 'top' of any other\n            interface (as defined
    in the ifStackTable), and disabled(2)\n            otherwise.\"\n    ::= { ifXEntry
    14 }\n"
  - "ifHighSpeed OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n            \"An estimate of the interface's
    current bandwidth in units\n            of 1,000,000 bits per second.  If this
    object reports a\n            value of `n' then the speed of the interface is
    somewhere in\n            the range of `n-500,000' to `n+499,999'.  For interfaces\n
    \           which do not vary in bandwidth or for those where no\n            accurate
    estimation can be made, this object should contain\n            the nominal bandwidth.
    \ For a sub-layer which has no concept\n            of bandwidth, this object
    should be zero.\"\n    ::= { ifXEntry 15 }\n"
  - "ifPromiscuousMode  OBJECT-TYPE\n    SYNTAX      TruthValue\n    MAX-ACCESS  read-write\n
    \   STATUS      current\n    DESCRIPTION\n            \"This object has a value
    of false(2) if this interface only\n            accepts packets/frames that are
    addressed to this station.\n            This object has a value of true(1) when
    the station accepts\n            all packets/frames transmitted on the media.
    \ The value\n            true(1) is only legal on certain types of media.  If
    legal,\n            setting this object to a value of true(1) may require the\n
    \           interface to be reset before becoming effective.\n            The
    value of ifPromiscuousMode does not affect the reception\n            of broadcast
    and multicast packets/frames by the interface.\"\n    ::= { ifXEntry 16 }\n"
  - "ifConnectorPresent   OBJECT-TYPE\n    SYNTAX      TruthValue\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n            \"This object
    has the value 'true(1)' if the interface\n            sublayer has a physical
    connector and the value 'false(2)'\n            otherwise.\"\n    ::= { ifXEntry
    17 }\n"
  - "ifAlias   OBJECT-TYPE\n    SYNTAX      DisplayString (SIZE(0..64))\n    MAX-ACCESS
    \ read-write\n    STATUS      current\n    DESCRIPTION\n            \"This object
    is an 'alias' name for the interface as\n            specified by a network manager,
    and provides a non-volatile\n            'handle' for the interface.\n            On
    the first instantiation of an interface, the value of\n            ifAlias associated
    with that interface is the zero-length\n            string.  As and when a value
    is written into an instance of\n            ifAlias through a network management
    set operation, then the\n            agent must retain the supplied value in the
    ifAlias instance\n            associated with the same interface for as long as
    that\n            interface remains instantiated, including across all re-\n            initializations/reboots
    of the network management system,\n            including those which result in
    a change of the interface's\n            ifIndex value.\n            An example
    of the value which a network manager might store\n            in this object for
    a WAN interface is the (Telco's) circuit\n            number/identifier of the
    interface.\n            Some agents may support write-access only for interfaces\n
    \           having particular values of ifType.  An agent which supports\n            write
    access to this object is required to keep the value in\n            non-volatile
    storage, but it may limit the length of new\n            values depending on how
    much storage is already occupied by\n            the current values for other
    interfaces.\"\n    ::= { ifXEntry 18 }\n"
  - "ifCounterDiscontinuityTime OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n            \"The value
    of sysUpTime on the most recent occasion at which\n            any one or more
    of this interface's counters suffered a\n            discontinuity.  The relevant
    counters are the specific\n            instances associated with this interface
    of any Counter32 or\n            Counter64 object contained in the ifTable or
    ifXTable.  If\n            no such discontinuities have occurred since the last
    re-\n            initialization of the local management subsystem, then this\n
    \           object contains a zero value.\"\n    ::= { ifXEntry 19 }\n"
  - '--           The Interface Stack Group

    '
  - '--

    '
  - '-- Implementation of this group is optional, but strongly recommended

    '
  - '-- for all systems

    '
  - '--

    '
  - "ifStackTable  OBJECT-TYPE\n     SYNTAX        SEQUENCE OF IfStackEntry\n     MAX-ACCESS
    \   not-accessible\n     STATUS        current\n     DESCRIPTION\n            \"The
    table containing information on the relationships\n            between the multiple
    sub-layers of network interfaces.  In\n            particular, it contains information
    on which sub-layers run\n            'on top of' which other sub-layers, where
    each sub-layer\n            corresponds to a conceptual row in the ifTable.  For\n
    \           example, when the sub-layer with ifIndex value x runs over\n            the
    sub-layer with ifIndex value y, then this table\n            contains:\n              ifStackStatus.x.y=active\n
    \           For each ifIndex value, I, which identifies an active\n            interface,
    there are always at least two instantiated rows\n            in this table associated
    with I.  For one of these rows, I\n            is the value of ifStackHigherLayer;
    for the other, I is the\n            value of ifStackLowerLayer.  (If I is not
    involved in\n            multiplexing, then these are the only two rows associated\n
    \           with I.)\n            For example, two rows exist even for an interface
    which has\n            no others stacked on top or below it:\n              ifStackStatus.0.x=active\n
    \             ifStackStatus.x.0=active \"\n     ::= { ifMIBObjects 2 }\n"
  - "ifStackEntry  OBJECT-TYPE\n     SYNTAX        IfStackEntry\n     MAX-ACCESS    not-accessible\n
    \    STATUS        current\n     DESCRIPTION\n            \"Information on a particular
    relationship between two sub-\n            layers, specifying that one sub-layer
    runs on 'top' of the\n            other sub-layer.  Each sub-layer corresponds
    to a conceptual\n            row in the ifTable.\"\n     INDEX { ifStackHigherLayer,
    ifStackLowerLayer }\n     ::= { ifStackTable 1 }\n"
  - "IfStackEntry ::=\n    SEQUENCE {\n        ifStackHigherLayer  InterfaceIndexOrZero,\n
    \       ifStackLowerLayer   InterfaceIndexOrZero,\n        ifStackStatus       RowStatus\n
    \    }\n"
  - "ifStackHigherLayer  OBJECT-TYPE\n     SYNTAX        InterfaceIndexOrZero\n     MAX-ACCESS
    \   not-accessible\n     STATUS        current\n     DESCRIPTION\n            \"The
    value of ifIndex corresponding to the higher sub-layer\n            of the relationship,
    i.e., the sub-layer which runs on 'top'\n            of the sub-layer identified
    by the corresponding instance of\n            ifStackLowerLayer.  If there is
    no higher sub-layer (below\n            the internetwork layer), then this object
    has the value 0.\"\n     ::= { ifStackEntry 1 }\n"
  - "ifStackLowerLayer  OBJECT-TYPE\n     SYNTAX        InterfaceIndexOrZero\n     MAX-ACCESS
    \   not-accessible\n     STATUS        current\n     DESCRIPTION\n            \"The
    value of ifIndex corresponding to the lower sub-layer\n            of the relationship,
    i.e., the sub-layer which runs 'below'\n            the sub-layer identified by
    the corresponding instance of\n            ifStackHigherLayer.  If there is no
    lower sub-layer, then\n            this object has the value 0.\"\n     ::= {
    ifStackEntry 2 }\n"
  - "ifStackStatus  OBJECT-TYPE\n    SYNTAX         RowStatus\n    MAX-ACCESS     read-create\n
    \   STATUS         current\n    DESCRIPTION\n            \"The status of the relationship
    between two sub-layers.\n            Changing the value of this object from 'active'
    to\n            'notInService' or 'destroy' will likely have consequences up\n
    \           and down the interface stack.  Thus, write access to this\n            object
    is likely to be inappropriate for some types of\n            interfaces, and many
    implementations will choose not to\n            support write-access for any type
    of interface.\"\n    ::= { ifStackEntry 3 }\n"
  - "ifStackLastChange OBJECT-TYPE\n    SYNTAX         TimeTicks\n    MAX-ACCESS     read-only\n
    \   STATUS         current\n    DESCRIPTION\n            \"The value of sysUpTime
    at the time of the last change of\n            the (whole) interface stack.  A
    change of the interface\n            stack is defined to be any creation, deletion,
    or change in\n            value of any instance of ifStackStatus.  If the interface\n
    \           stack has been unchanged since the last re-initialization of\n            the
    local network management subsystem, then this object\n            contains a zero
    value.\"\n    ::= { ifMIBObjects 6 }\n"
  - '--   Generic Receive Address Table

    '
  - '--

    '
  - '-- This group of objects is mandatory for all types of

    '
  - '-- interfaces which can receive packets/frames addressed to

    '
  - '-- more than one address.

    '
  - '--

    '
  - '-- This table replaces the ifExtnsRcvAddr table.  The main

    '
  - '-- difference is that this table makes use of the RowStatus

    '
  - '-- textual convention, while ifExtnsRcvAddr did not.

    '
  - "ifRcvAddressTable  OBJECT-TYPE\n    SYNTAX      SEQUENCE OF IfRcvAddressEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"This
    table contains an entry for each address (broadcast,\n            multicast, or
    uni-cast) for which the system will receive\n            packets/frames on a particular
    interface, except as follows:\n            - for an interface operating in promiscuous
    mode, entries\n            are only required for those addresses for which the
    system\n            would receive frames were it not operating in promiscuous\n
    \           mode.\n            - for 802.5 functional addresses, only one entry
    is\n            required, for the address which has the functional address\n            bit
    ANDed with the bit mask of all functional addresses for\n            which the
    interface will accept frames.\n            A system is normally able to use any
    unicast address which\n            corresponds to an entry in this table as a
    source address.\"\n    ::= { ifMIBObjects 4 }\n"
  - "ifRcvAddressEntry  OBJECT-TYPE\n    SYNTAX      IfRcvAddressEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"A list
    of objects identifying an address for which the\n            system will accept
    packets/frames on the particular\n            interface identified by the index
    value ifIndex.\"\n    INDEX  { ifIndex, ifRcvAddressAddress }\n    ::= { ifRcvAddressTable
    1 }\n"
  - "IfRcvAddressEntry ::=\n    SEQUENCE {\n        ifRcvAddressAddress   PhysAddress,\n
    \       ifRcvAddressStatus    RowStatus,\n        ifRcvAddressType      INTEGER\n
    \   }\n"
  - "ifRcvAddressAddress OBJECT-TYPE\n    SYNTAX      PhysAddress\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"An address
    for which the system will accept packets/frames\n            on this entry's interface.\"\n
    \   ::= { ifRcvAddressEntry 1 }\n"
  - "ifRcvAddressStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n
    \   STATUS      current\n    DESCRIPTION\n            \"This object is used to
    create and delete rows in the\n            ifRcvAddressTable.\"\n    ::= { ifRcvAddressEntry
    2 }\n"
  - "ifRcvAddressType OBJECT-TYPE\n    SYNTAX      INTEGER {\n                    other(1),\n
    \                   volatile(2),\n                    nonVolatile(3)\n                }\n
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n            \"This
    object has the value nonVolatile(3) for those entries\n            in the table
    which are valid and will not be deleted by the\n            next restart of the
    managed system.  Entries having the\n            value volatile(2) are valid and
    exist, but have not been\n            saved, so that will not exist after the
    next restart of the\n            managed system.  Entries having the value other(1)
    are valid\n            and exist but are not classified as to whether they will\n
    \           continue to exist after the next restart.\"\n    DEFVAL  { volatile
    }\n    ::= { ifRcvAddressEntry 3 }\n"
  - '-- definition of interface-related traps.

    '
  - "linkDown NOTIFICATION-TYPE\n    OBJECTS { ifIndex, ifAdminStatus, ifOperStatus
    }\n    STATUS  current\n    DESCRIPTION\n            \"A linkDown trap signifies
    that the SNMP entity, acting in\n            an agent role, has detected that
    the ifOperStatus object for\n            one of its communication links is about
    to enter the down\n            state from some other state (but not from the notPresent\n
    \           state).  This other state is indicated by the included value\n            of
    ifOperStatus.\"\n    ::= { snmpTraps 3 }\n"
  - "linkUp NOTIFICATION-TYPE\n    OBJECTS { ifIndex, ifAdminStatus, ifOperStatus
    }\n    STATUS  current\n    DESCRIPTION\n            \"A linkUp trap signifies
    that the SNMP entity, acting in an\n            agent role, has detected that
    the ifOperStatus object for\n            one of its communication links left the
    down state and\n            transitioned into some other state (but not into the\n
    \           notPresent state).  This other state is indicated by the\n            included
    value of ifOperStatus.\"\n    ::= { snmpTraps 4 }\n"
  - '-- conformance information

    '
  - 'ifConformance OBJECT IDENTIFIER ::= { ifMIB 2 }

    '
  - 'ifGroups      OBJECT IDENTIFIER ::= { ifConformance 1 }

    '
  - 'ifCompliances OBJECT IDENTIFIER ::= { ifConformance 2 }

    '
  - '-- compliance statements

    '
  - "ifCompliance3 MODULE-COMPLIANCE\n    STATUS  current\n    DESCRIPTION\n            \"The
    compliance statement for SNMP entities which have\n            network interfaces.\"\n
    \   MODULE  -- this module\n        MANDATORY-GROUPS { ifGeneralInformationGroup,\n
    \                          linkUpDownNotificationsGroup }\n"
  - '-- The groups:

    '
  - '--        ifFixedLengthGroup

    '
  - '--        ifHCFixedLengthGroup

    '
  - '--        ifPacketGroup

    '
  - '--        ifHCPacketGroup

    '
  - '--        ifVHCPacketGroup

    '
  - '-- are mutually exclusive; at most one of these groups is implemented

    '
  - '-- for a particular interface.  When any of these groups is implemented

    '
  - '-- for a particular interface, then ifCounterDiscontinuityGroup must

    '
  - "-- also be implemented for that interface.\n        GROUP       ifFixedLengthGroup\n
    \       DESCRIPTION\n            \"This group is mandatory for those network interfaces
    which\n            are character-oriented or transmit data in fixed-length\n            transmission
    units, and for which the value of the\n            corresponding instance of ifSpeed
    is less than or equal to\n            20,000,000 bits/second.\"\n        GROUP
    \      ifHCFixedLengthGroup\n        DESCRIPTION\n            \"This group is
    mandatory for those network interfaces which\n            are character-oriented
    or transmit data in fixed-length\n            transmission units, and for which
    the value of the\n            corresponding instance of ifSpeed is greater than
    20,000,000\n            bits/second.\"\n        GROUP       ifPacketGroup\n        DESCRIPTION\n
    \           \"This group is mandatory for those network interfaces which\n            are
    packet-oriented, and for which the value of the\n            corresponding instance
    of ifSpeed is less than or equal to\n            20,000,000 bits/second.\"\n        GROUP
    \      ifHCPacketGroup\n        DESCRIPTION\n            \"This group is mandatory
    only for those network interfaces\n            which are packet-oriented and for
    which the value of the\n            corresponding instance of ifSpeed is greater
    than 20,000,000\n            bits/second but less than or equal to 650,000,000\n
    \           bits/second.\"\n        GROUP       ifVHCPacketGroup\n        DESCRIPTION\n
    \           \"This group is mandatory only for those network interfaces\n            which
    are packet-oriented and for which the value of the\n            corresponding
    instance of ifSpeed is greater than\n            650,000,000 bits/second.\"\n
    \       GROUP       ifCounterDiscontinuityGroup\n        DESCRIPTION\n            \"This
    group is mandatory for those network interfaces that\n            are required
    to maintain counters (i.e., those for which one\n            of the ifFixedLengthGroup,
    ifHCFixedLengthGroup,\n            ifPacketGroup, ifHCPacketGroup, or ifVHCPacketGroup
    is\n            mandatory).\"\n        GROUP       ifRcvAddressGroup\n        DESCRIPTION\n
    \           \"The applicability of this group MUST be defined by the\n            media-specific
    MIBs.  Media-specific MIBs must define the\n            exact meaning, use, and
    semantics of the addresses in this\n            group.\"\n        OBJECT      ifLinkUpDownTrapEnable\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION\n            \"Write access
    is not required.\"\n        OBJECT      ifPromiscuousMode\n        MIN-ACCESS
    \ read-only\n        DESCRIPTION\n            \"Write access is not required.\"\n
    \       OBJECT       ifAdminStatus\n        SYNTAX       INTEGER { up(1), down(2)
    }\n        MIN-ACCESS   read-only\n        DESCRIPTION\n            \"Write access
    is not required, nor is support for the value\n            testing(3).\"\n        OBJECT
    \      ifAlias\n        MIN-ACCESS   read-only\n        DESCRIPTION\n            \"Write
    access is not required.\"\n    ::= { ifCompliances 3 }\n"
  - '-- units of conformance

    '
  - "ifGeneralInformationGroup    OBJECT-GROUP\n    OBJECTS { ifIndex, ifDescr, ifType,
    ifSpeed, ifPhysAddress,\n              ifAdminStatus, ifOperStatus, ifLastChange,\n
    \             ifLinkUpDownTrapEnable, ifConnectorPresent,\n              ifHighSpeed,
    ifName, ifNumber, ifAlias,\n              ifTableLastChange }\n    STATUS  current\n
    \   DESCRIPTION\n            \"A collection of objects providing information applicable
    to\n            all network interfaces.\"\n    ::= { ifGroups 10 }\n"
  - '-- the following five groups are mutually exclusive; at most

    '
  - '-- one of these groups is implemented for any interface

    '
  - "ifFixedLengthGroup    OBJECT-GROUP\n    OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,\n
    \             ifInErrors, ifOutErrors }\n    STATUS  current\n    DESCRIPTION\n
    \           \"A collection of objects providing information specific to\n            non-high
    speed (non-high speed interfaces transmit and\n            receive at speeds less
    than or equal to 20,000,000\n            bits/second) character-oriented or fixed-length-transmission\n
    \           network interfaces.\"\n    ::= { ifGroups 2 }\n"
  - "ifHCFixedLengthGroup    OBJECT-GROUP\n    OBJECTS { ifHCInOctets, ifHCOutOctets,\n
    \             ifInOctets, ifOutOctets, ifInUnknownProtos,\n              ifInErrors,
    ifOutErrors }\n    STATUS  current\n    DESCRIPTION\n            \"A collection
    of objects providing information specific to\n            high speed (greater
    than 20,000,000 bits/second) character-\n            oriented or fixed-length-transmission
    network interfaces.\"\n    ::= { ifGroups 3 }\n"
  - "ifPacketGroup    OBJECT-GROUP\n    OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,\n
    \             ifInErrors, ifOutErrors,\n              ifMtu, ifInUcastPkts, ifInMulticastPkts,\n
    \             ifInBroadcastPkts, ifInDiscards,\n              ifOutUcastPkts,
    ifOutMulticastPkts,\n              ifOutBroadcastPkts, ifOutDiscards,\n              ifPromiscuousMode
    }\n    STATUS  current\n    DESCRIPTION\n            \"A collection of objects
    providing information specific to\n            non-high speed (non-high speed
    interfaces transmit and\n            receive at speeds less than or equal to 20,000,000\n
    \           bits/second) packet-oriented network interfaces.\"\n    ::= { ifGroups
    4 }\n"
  - "ifHCPacketGroup    OBJECT-GROUP\n    OBJECTS { ifHCInOctets, ifHCOutOctets,\n
    \             ifInOctets, ifOutOctets, ifInUnknownProtos,\n              ifInErrors,
    ifOutErrors,\n              ifMtu, ifInUcastPkts, ifInMulticastPkts,\n              ifInBroadcastPkts,
    ifInDiscards,\n              ifOutUcastPkts, ifOutMulticastPkts,\n              ifOutBroadcastPkts,
    ifOutDiscards,\n              ifPromiscuousMode }\n    STATUS  current\n    DESCRIPTION\n
    \           \"A collection of objects providing information specific to\n            high
    speed (greater than 20,000,000 bits/second but less\n            than or equal
    to 650,000,000 bits/second) packet-oriented\n            network interfaces.\"\n
    \   ::= { ifGroups 5 }\n"
  - "ifVHCPacketGroup    OBJECT-GROUP\n    OBJECTS { ifHCInUcastPkts, ifHCInMulticastPkts,\n
    \             ifHCInBroadcastPkts, ifHCOutUcastPkts,\n              ifHCOutMulticastPkts,
    ifHCOutBroadcastPkts,\n              ifHCInOctets, ifHCOutOctets,\n              ifInOctets,
    ifOutOctets, ifInUnknownProtos,\n              ifInErrors, ifOutErrors,\n              ifMtu,
    ifInUcastPkts, ifInMulticastPkts,\n              ifInBroadcastPkts, ifInDiscards,\n
    \             ifOutUcastPkts, ifOutMulticastPkts,\n              ifOutBroadcastPkts,
    ifOutDiscards,\n              ifPromiscuousMode }\n    STATUS  current\n    DESCRIPTION\n
    \           \"A collection of objects providing information specific to\n            higher
    speed (greater than 650,000,000 bits/second) packet-\n            oriented network
    interfaces.\"\n    ::= { ifGroups 6 }\n"
  - "ifRcvAddressGroup    OBJECT-GROUP\n    OBJECTS { ifRcvAddressStatus, ifRcvAddressType
    }\n    STATUS  current\n    DESCRIPTION\n            \"A collection of objects
    providing information on the\n            multiple addresses which an interface
    receives.\"\n    ::= { ifGroups 7 }\n"
  - "ifStackGroup2    OBJECT-GROUP\n    OBJECTS { ifStackStatus, ifStackLastChange
    }\n    STATUS  current\n    DESCRIPTION\n            \"A collection of objects
    providing information on the\n            layering of MIB-II interfaces.\"\n    ::=
    { ifGroups 11 }\n"
  - "ifCounterDiscontinuityGroup  OBJECT-GROUP\n    OBJECTS { ifCounterDiscontinuityTime
    }\n    STATUS  current\n    DESCRIPTION\n            \"A collection of objects
    providing information specific to\n            interface counter discontinuities.\"\n
    \   ::= { ifGroups 13 }\n"
  - "linkUpDownNotificationsGroup  NOTIFICATION-GROUP\n    NOTIFICATIONS { linkUp,
    linkDown }\n    STATUS  current\n    DESCRIPTION\n            \"The notifications
    which indicate specific changes in the\n            value of ifOperStatus.\"\n
    \   ::= { ifGroups 14 }\n"
  - '-- Deprecated Definitions - Objects

    '
  - '--

    '
  - '--    The Interface Test Table

    '
  - '--

    '
  - '-- This group of objects is optional.  However, a media-specific

    '
  - '-- MIB may make implementation of this group mandatory.

    '
  - '--

    '
  - '-- This table replaces the ifExtnsTestTable

    '
  - '--

    '
  - "ifTestTable   OBJECT-TYPE\n    SYNTAX      SEQUENCE OF IfTestEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      deprecated\n    DESCRIPTION\n            \"This
    table contains one entry per interface.  It defines\n            objects which
    allow a network manager to instruct an agent\n            to test an interface
    for various faults.  Tests for an\n            interface are defined in the media-specific
    MIB for that\n            interface.  After invoking a test, the object ifTestResult\n
    \           can be read to determine the outcome.  If an agent can not\n            perform
    the test, ifTestResult is set to so indicate.  The\n            object ifTestCode
    can be used to provide further test-\n            specific or interface-specific
    (or even enterprise-specific)\n            information concerning the outcome
    of the test.  Only one\n            test can be in progress on each interface
    at any one time.\n            If one test is in progress when another test is
    invoked, the\n            second test is rejected.  Some agents may reject a test
    when\n            a prior test is active on another interface.\n            Before
    starting a test, a manager-station must first obtain\n            'ownership'
    of the entry in the ifTestTable for the\n            interface to be tested.  This
    is accomplished with the\n            ifTestId and ifTestStatus objects as follows:\n
    \         try_again:\n              get (ifTestId, ifTestStatus)\n              while
    (ifTestStatus != notInUse)\n                  /*\n                   * Loop while
    a test is running or some other\n                   * manager is configuring a
    test.\n                   */\n                  short delay\n                  get
    (ifTestId, ifTestStatus)\n              }\n              /*\n               *
    Is not being used right now -- let's compete\n               * to see who gets
    it.\n               */\n              lock_value = ifTestId\n              if
    ( set(ifTestId = lock_value, ifTestStatus = inUse,\n                       ifTestOwner
    = 'my-IP-address') == FAILURE)\n                  /*\n                   * Another
    manager got the ifTestEntry -- go\n                   * try again\n                   */\n
    \                 goto try_again;\n              /*\n               * I have the
    lock\n               */\n              set up any test parameters.\n              /*\n
    \              * This starts the test\n               */\n              set(ifTestType
    = test_to_run);\n              wait for test completion by polling ifTestResult\n
    \             when test completes, agent sets ifTestResult\n                   agent
    also sets ifTestStatus = 'notInUse'\n              retrieve any additional test
    results, and ifTestId\n              if (ifTestId == lock_value+1) results are
    valid\n            A manager station first retrieves the value of the\n            appropriate
    ifTestId and ifTestStatus objects, periodically\n            repeating the retrieval
    if necessary, until the value of\n            ifTestStatus is 'notInUse'.  The
    manager station then tries\n            to set the same ifTestId object to the
    value it just\n            retrieved, the same ifTestStatus object to 'inUse',
    and the\n            corresponding ifTestOwner object to a value indicating\n
    \           itself.  If the set operation succeeds then the manager has\n            obtained
    ownership of the ifTestEntry, and the value of the\n            ifTestId object
    is incremented by the agent (per the\n            semantics of TestAndIncr).  Failure
    of the set operation\n            indicates that some other manager has obtained
    ownership of\n            the ifTestEntry.\n            Once ownership is obtained,
    any test parameters can be\n            setup, and then the test is initiated
    by setting ifTestType.\n            On completion of the test, the agent sets
    ifTestStatus to\n            'notInUse'.  Once this occurs, the manager can retrieve
    the\n            results.  In the (rare) event that the invocation of tests\n
    \           by two network managers were to overlap, then there would be\n            a
    possibility that the first test's results might be\n            overwritten by
    the second test's results prior to the first\n            results being read.
    \ This unlikely circumstance can be\n            detected by a network manager
    retrieving ifTestId at the\n            same time as retrieving the test results,
    and ensuring that\n            the results are for the desired request.\n            If
    ifTestType is not set within an abnormally long period of\n            time after
    ownership is obtained, the agent should time-out\n            the manager, and
    reset the value of the ifTestStatus object\n            back to 'notInUse'.  It
    is suggested that this time-out\n            period be 5 minutes.\n            In
    general, a management station must not retransmit a\n            request to invoke
    a test for which it does not receive a\n            response; instead, it properly
    inspects an agent's MIB to\n            determine if the invocation was successful.
    \ Only if the\n            invocation was unsuccessful, is the invocation request\n
    \           retransmitted.\n            Some tests may require the interface to
    be taken off-line in\n            order to execute them, or may even require the
    agent to\n            reboot after completion of the test.  In these\n            circumstances,
    communication with the management station\n            invoking the test may be
    lost until after completion of the\n            test.  An agent is not required
    to support such tests.\n            However, if such tests are supported, then
    the agent should\n            make every effort to transmit a response to the
    request\n            which invoked the test prior to losing communication.  When\n
    \           the agent is restored to normal service, the results of the\n            test
    are properly made available in the appropriate objects.\n            Note that
    this requires that the ifIndex value assigned to\n            an interface must
    be unchanged even if the test causes a\n            reboot.  An agent must reject
    any test for which it cannot,\n            perhaps due to resource constraints,
    make available at least\n            the minimum amount of information after that
    test\n            completes.\"\n    ::= { ifMIBObjects 3 }\n"
  - "ifTestEntry OBJECT-TYPE\n    SYNTAX       IfTestEntry\n    MAX-ACCESS   not-accessible\n
    \   STATUS       deprecated\n    DESCRIPTION\n            \"An entry containing
    objects for invoking tests on an\n            interface.\"\n    AUGMENTS  { ifEntry
    }\n    ::= { ifTestTable 1 }\n"
  - "IfTestEntry ::=\n    SEQUENCE {\n        ifTestId           TestAndIncr,\n        ifTestStatus
    \      INTEGER,\n        ifTestType         AutonomousType,\n        ifTestResult
    \      INTEGER,\n        ifTestCode         OBJECT IDENTIFIER,\n        ifTestOwner
    \       OwnerString\n    }\n"
  - "ifTestId         OBJECT-TYPE\n    SYNTAX       TestAndIncr\n    MAX-ACCESS   read-write\n
    \   STATUS       deprecated\n    DESCRIPTION\n            \"This object identifies
    the current invocation of the\n            interface's test.\"\n    ::= { ifTestEntry
    1 }\n"
  - "ifTestStatus     OBJECT-TYPE\n    SYNTAX       INTEGER { notInUse(1), inUse(2)
    }\n    MAX-ACCESS   read-write\n    STATUS       deprecated\n    DESCRIPTION\n
    \           \"This object indicates whether or not some manager currently\n            has
    the necessary 'ownership' required to invoke a test on\n            this interface.
    \ A write to this object is only successful\n            when it changes its value
    from 'notInUse(1)' to 'inUse(2)'.\n            After completion of a test, the
    agent resets the value back\n            to 'notInUse(1)'.\"\n    ::= { ifTestEntry
    2 }\n"
  - "ifTestType       OBJECT-TYPE\n    SYNTAX       AutonomousType\n    MAX-ACCESS
    \  read-write\n    STATUS       deprecated\n    DESCRIPTION\n            \"A control
    variable used to start and stop operator-\n            initiated interface tests.
    \ Most OBJECT IDENTIFIER values\n            assigned to tests are defined elsewhere,
    in association with\n            specific types of interface.  However, this document
    assigns\n            a value for a full-duplex loopback test, and defines the\n
    \           special meanings of the subject identifier:\n                noTest
    \ OBJECT IDENTIFIER ::= { 0 0 }\n            When the value noTest is written
    to this object, no action\n            is taken unless a test is in progress,
    in which case the\n            test is aborted.  Writing any other value to this
    object is\n            only valid when no test is currently in progress, in which\n
    \           case the indicated test is initiated.\n            When read, this
    object always returns the most recent value\n            that ifTestType was set
    to.  If it has not been set since\n            the last initialization of the
    network management subsystem\n            on the agent, a value of noTest is returned.\"\n
    \   ::= { ifTestEntry 3 }\n"
  - "ifTestResult  OBJECT-TYPE\n    SYNTAX       INTEGER {\n                     none(1),
    \         -- no test yet requested\n                     success(2),\n                     inProgress(3),\n
    \                    notSupported(4),\n                     unAbleToRun(5),   --
    due to state of system\n                     aborted(6),\n                     failed(7)\n
    \                }\n    MAX-ACCESS   read-only\n    STATUS       deprecated\n
    \   DESCRIPTION\n            \"This object contains the result of the most recently\n
    \           requested test, or the value none(1) if no tests have been\n            requested
    since the last reset.  Note that this facility\n            provides no provision
    for saving the results of one test\n            when starting another, as could
    be required if used by\n            multiple managers concurrently.\"\n    ::=
    { ifTestEntry 4 }\n"
  - "ifTestCode  OBJECT-TYPE\n    SYNTAX       OBJECT IDENTIFIER\n    MAX-ACCESS   read-only\n
    \   STATUS       deprecated\n    DESCRIPTION\n            \"This object contains
    a code which contains more specific\n            information on the test result,
    for example an error-code\n            after a failed test.  Error codes and other
    values this\n            object may take are specific to the type of interface
    and/or\n            test.  The value may have the semantics of either the\n            AutonomousType
    or InstancePointer textual conventions as\n            defined in RFC 2579.  The
    identifier:\n                testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }\n
    \           is defined for use if no additional result code is\n            available.\"\n
    \   ::= { ifTestEntry 5 }\n"
  - "ifTestOwner      OBJECT-TYPE\n    SYNTAX       OwnerString\n    MAX-ACCESS   read-write\n
    \   STATUS       deprecated\n    DESCRIPTION\n            \"The entity which currently
    has the 'ownership' required to\n            invoke a test on this interface.\"\n
    \   ::= { ifTestEntry 6 }\n"
  - '-- Deprecated Definitions - Groups

    '
  - "ifGeneralGroup    OBJECT-GROUP\n    OBJECTS { ifDescr, ifType, ifSpeed, ifPhysAddress,\n
    \             ifAdminStatus, ifOperStatus, ifLastChange,\n              ifLinkUpDownTrapEnable,
    ifConnectorPresent,\n              ifHighSpeed, ifName }\n    STATUS  deprecated\n
    \   DESCRIPTION\n            \"A collection of objects deprecated in favour of\n
    \           ifGeneralInformationGroup.\"\n    ::= { ifGroups 1 }\n"
  - "ifTestGroup    OBJECT-GROUP\n    OBJECTS { ifTestId, ifTestStatus, ifTestType,\n
    \             ifTestResult, ifTestCode, ifTestOwner }\n    STATUS  deprecated\n
    \   DESCRIPTION\n            \"A collection of objects providing the ability to
    invoke\n            tests on an interface.\"\n    ::= { ifGroups 8 }\n"
  - "ifStackGroup    OBJECT-GROUP\n    OBJECTS { ifStackStatus }\n    STATUS  deprecated\n
    \   DESCRIPTION\n            \"The previous collection of objects providing information
    on\n            the layering of MIB-II interfaces.\"\n    ::= { ifGroups 9 }\n"
  - "ifOldObjectsGroup    OBJECT-GROUP\n    OBJECTS { ifInNUcastPkts, ifOutNUcastPkts,\n
    \             ifOutQLen, ifSpecific }\n    STATUS  deprecated\n    DESCRIPTION\n
    \           \"The collection of objects deprecated from the original MIB-\n            II
    interfaces group.\"\n    ::= { ifGroups 12 }\n"
  - '-- Deprecated Definitions - Compliance

    '
  - "ifCompliance MODULE-COMPLIANCE\n    STATUS  deprecated\n    DESCRIPTION\n            \"A
    compliance statement defined in a previous version of\n            this MIB module,
    for SNMP entities which have network\n            interfaces.\"\n    MODULE  --
    this module\n        MANDATORY-GROUPS { ifGeneralGroup, ifStackGroup }\n        GROUP
    \      ifFixedLengthGroup\n        DESCRIPTION\n            \"This group is mandatory
    for all network interfaces which\n            are character-oriented or transmit
    data in fixed-length\n            transmission units.\"\n        GROUP       ifHCFixedLengthGroup\n
    \       DESCRIPTION\n            \"This group is mandatory only for those network
    interfaces\n            which are character-oriented or transmit data in fixed-\n
    \           length transmission units, and for which the value of the\n            corresponding
    instance of ifSpeed is greater than 20,000,000\n            bits/second.\"\n        GROUP
    \      ifPacketGroup\n        DESCRIPTION\n            \"This group is mandatory
    for all network interfaces which\n            are packet-oriented.\"\n        GROUP
    \      ifHCPacketGroup\n        DESCRIPTION\n            \"This group is mandatory
    only for those network interfaces\n            which are packet-oriented and for
    which the value of the\n            corresponding instance of ifSpeed is greater
    than\n            650,000,000 bits/second.\"\n        GROUP       ifTestGroup\n
    \       DESCRIPTION\n            \"This group is optional.  Media-specific MIBs
    which require\n            interface tests are strongly encouraged to use this
    group\n            for invoking tests and reporting results.  A medium specific\n
    \           MIB which has mandatory tests may make implementation of\n            this
    group mandatory.\"\n        GROUP       ifRcvAddressGroup\n        DESCRIPTION\n
    \           \"The applicability of this group MUST be defined by the\n            media-specific
    MIBs.  Media-specific MIBs must define the\n            exact meaning, use, and
    semantics of the addresses in this\n            group.\"\n        OBJECT      ifLinkUpDownTrapEnable\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION\n            \"Write access
    is not required.\"\n        OBJECT      ifPromiscuousMode\n        MIN-ACCESS
    \ read-only\n        DESCRIPTION\n            \"Write access is not required.\"\n
    \       OBJECT      ifStackStatus\n        SYNTAX      INTEGER { active(1) } --
    subset of RowStatus\n        MIN-ACCESS  read-only\n        DESCRIPTION\n            \"Write
    access is not required, and only one of the six\n            enumerated values
    for the RowStatus textual convention need\n            be supported, specifically:
    active(1).\"\n        OBJECT       ifAdminStatus\n        SYNTAX       INTEGER
    { up(1), down(2) }\n        MIN-ACCESS   read-only\n        DESCRIPTION\n            \"Write
    access is not required, nor is support for the value\n            testing(3).\"\n
    \   ::= { ifCompliances 1 }\n"
  - "ifCompliance2 MODULE-COMPLIANCE\n    STATUS      deprecated\n    DESCRIPTION\n
    \           \"A compliance statement defined in a previous version of\n            this
    MIB module, for SNMP entities which have network\n            interfaces.\"\n
    \   MODULE  -- this module\n        MANDATORY-GROUPS { ifGeneralInformationGroup,
    ifStackGroup2,\n                           ifCounterDiscontinuityGroup }\n        GROUP
    \      ifFixedLengthGroup\n        DESCRIPTION\n            \"This group is mandatory
    for all network interfaces which\n            are character-oriented or transmit
    data in fixed-length\n            transmission units.\"\n        GROUP       ifHCFixedLengthGroup\n
    \       DESCRIPTION\n            \"This group is mandatory only for those network
    interfaces\n            which are character-oriented or transmit data in fixed-\n
    \           length transmission units, and for which the value of the\n            corresponding
    instance of ifSpeed is greater than 20,000,000\n            bits/second.\"\n        GROUP
    \      ifPacketGroup\n        DESCRIPTION\n            \"This group is mandatory
    for all network interfaces which\n            are packet-oriented.\"\n        GROUP
    \      ifHCPacketGroup\n        DESCRIPTION\n            \"This group is mandatory
    only for those network interfaces\n            which are packet-oriented and for
    which the value of the\n            corresponding instance of ifSpeed is greater
    than\n            650,000,000 bits/second.\"\n        GROUP       ifRcvAddressGroup\n
    \       DESCRIPTION\n            \"The applicability of this group MUST be defined
    by the\n            media-specific MIBs.  Media-specific MIBs must define the\n
    \           exact meaning, use, and semantics of the addresses in this\n            group.\"\n
    \       OBJECT      ifLinkUpDownTrapEnable\n        MIN-ACCESS  read-only\n        DESCRIPTION\n
    \           \"Write access is not required.\"\n        OBJECT      ifPromiscuousMode\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION\n            \"Write access
    is not required.\"\n        OBJECT      ifStackStatus\n        SYNTAX      INTEGER
    { active(1) } -- subset of RowStatus\n        MIN-ACCESS  read-only\n        DESCRIPTION\n
    \           \"Write access is not required, and only one of the six\n            enumerated
    values for the RowStatus textual convention need\n            be supported, specifically:
    active(1).\"\n        OBJECT       ifAdminStatus\n        SYNTAX       INTEGER
    { up(1), down(2) }\n        MIN-ACCESS   read-only\n        DESCRIPTION\n            \"Write
    access is not required, nor is support for the value\n            testing(3).\"\n
    \       OBJECT       ifAlias\n        MIN-ACCESS   read-only\n        DESCRIPTION\n
    \           \"Write access is not required.\"\n    ::= { ifCompliances 2 }\n"
  - 'END

    '
  title: 6.  Interfaces Group Definitions
- contents:
  - "7.  Acknowledgements\n   This memo has been produced by the IETF's Interfaces
    MIB working-\n   group.\n   The original proposal evolved from conversations and
    discussions with\n   many people, including at least the following: Fred Baker,
    Ted\n   Brunner, Chuck Davin, Jeremy Greene, Marshall Rose, Kaj Tesink, and\n
    \  Dean Throop.\n"
  title: 7.  Acknowledgements
- contents:
  - "8.  References\n   [1]  Harrington, D., Presuhn, R. and B. Wijnen, \"An Architecture
    for\n        Describing SNMP Management Frameworks\", RFC 2571, April 1999.\n
    \  [2]  Rose, M. and K. McCloghrie, \"Structure and Identification of\n        Management
    Information for TCP/IP-based Internets\", STD 16, RFC\n        1155, May 1990.\n
    \  [3]  Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n        RFC
    1212, March 1991.\n   [4]  Rose, M., \"A Convention for Defining Traps for use
    with the\n        SNMP\", RFC 1215, March 1991.\n   [5]  McCloghrie, K., Perkins,
    D., Schoenwaelder, J., Case, J., Rose,\n        M.  and S. Waldbusser, \"Structure
    of Management Information\n        Version 2 (SMIv2)\", STD 58, RFC 2578, April
    1999.\n   [6]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose,\n
    \       M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58,\n        RFC
    2579, April 1999.\n   [7]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case,
    J., Rose,\n        M.  and S. Waldbusser, \"Conformance Statements for SMIv2\",
    STD\n        58, RFC 2580, April 1999.\n   [8]  Case, J., Fedor, M., Schoffstall,
    M. and J. Davin, \"Simple\n        Network Management Protocol\", STD 15, RFC
    1157, May 1990.\n   [9]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n
    \       \"Introduction to Community-based SNMPv2\", RFC 1901, January\n        1996.\n
    \  [10] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Transport\n        Mappings
    for Version 2 of the Simple Network Management Protocol\n        (SNMPv2)\", RFC
    1906, January 1996.\n   [11] Case, J., Harrington D., Presuhn R. and B. Wijnen,
    \"Message\n        Processing and Dispatching for the Simple Network Management\n
    \       Protocol (SNMP)\", RFC 2572, January 1998.\n   [12] Blumenthal, U. and
    B. Wijnen, \"User-based Security Model (USM)\n        for version 3 of the Simple
    Network Management Protocol\n        (SNMPv3)\", RFC 2574, January 1998.\n   [13]
    Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol\n        Operations
    for Version 2 of the Simple Network Management\n        Protocol (SNMPv2)\", RFC
    1905, January 1996.\n   [14] Levi, D., Meyer, P. and B. Stewart, \"SMPv3 Applications\",
    RFC\n        2573, January 1998.\n   [15] Wijnen, B., Presuhn, R. and K. McCloghrie,
    \"View-based Access\n        Control Model (VACM) for the Simple Network Management
    Protocol\n        (SNMP)\", RFC 2575, January 1998.\n   [16] Bradner, S., \"Key
    words for use in RFCs to Indicate Requirements\n        Levels\", BCP 14, RFC
    2119, March 1997.\n   [17] McCloghrie, K. and M. Rose, \"Management Information
    Base for\n        Network Management of TCP/IP-based internets - MIB-II\", STD
    17.\n        RFC 1213, March 1991.\n   [18] Postel, J., \"Internet Protocol\",
    STD 5, RFC 791, September 1981.\n   [19] McCloghrie, K., \"Extensions to the Generic-Interface
    MIB\", RFC\n        1229, May 1991.\n   [20] ATM Forum Technical Committee, \"LAN
    Emulation Client Management:\n        Version 1.0 Specification\", af-lane-0044.000,
    ATM Forum,\n        September 1995.\n   [21] Stewart, B., \"Definitions of Managed
    Objects for Character\n        Stream Devices using SMIv2\", RFC 1658, July 1994.\n
    \  [22] Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction\n        to
    Version 3 of the Internet-standard Network Management\n        Framework\", RFC
    2570, April 1999.\n   [23] McCloghrie, K. and F. Kastenholz, \"Evolution of the
    Interfaces\n        Group of MIB-II\", RFC 1573, January 1994.\n   [24] McCloghrie,
    K. and F. Kastenholz, \"The Interfaces Group MIB\n        using SMIv2\", RFC 2233,
    November 1997.\n"
  title: 8.  References
- contents:
  - "9.  Security Considerations\n   There are a number of management objects defined
    in this MIB that\n   have a MAX-ACCESS clause of read-write and/or read-create.
    \ Such\n   objects may be considered sensitive or vulnerable in some network\n
    \  environments.  The support for SET operations in a non-secure\n   environment
    without proper protection can have a negative effect on\n   network operations.\n
    \  In particular, write-able objects allow an administrator to control\n   the
    interfaces and to perform tests on the interfaces, and\n   unauthorized access
    to these could cause a denial of service, or in\n   combination with other (e.g.,
    physical) security breaches, could\n   cause unauthorized connectivity to a device.\n
    \  SNMPv1 by itself is not a secure environment.  Even if the network\n   itself
    is secure (for example by using IPSec), even then, there is no\n   control as
    to who on the secure network is allowed to access and\n   GET/SET (read/change/create/delete)
    the objects in this MIB.\n   It is recommended that the implementers consider
    the security\n   features as provided by the SNMPv3 framework.  Specifically,
    the use\n   of the User-based Security Model RFC 2574 [12] and the View- based\n
    \  Access Control Model RFC 2575 [15] is recommended.\n   It is then a customer/user
    responsibility to ensure that the SNMP\n   entity giving access to an instance
    of this MIB, is properly\n   configured to give access to the objects only to
    those principals\n   (users) that have legitimate rights to indeed GET or SET\n
    \  (change/create/delete) them.\n"
  title: 9.  Security Considerations
- contents:
  - "10.  Authors' Addresses\n   Keith McCloghrie\n   Cisco Systems, Inc.\n   170
    West Tasman Drive\n   San Jose, CA  95134-1706\n   Phone: 408-526-5260\n   EMail:
    kzm@cisco.com\"\n   Frank Kastenholz\n   Argon Networks\n   25 Porter Rd\n   Littleton
    Ma 01460\n   Phone: (508)685-4000\n   EMail: kasten@argon.com\n"
  title: 10.  Authors' Addresses
- contents:
  - "11.  Changes from RFC 2233\n   Added linkUpDownNotificationsGroup.\n   Changed
    the status of the definition of OwnerString in this MIB to be\n   deprecated,
    because it is only used by ifTestOwner, which is now\n   deprecated, and because
    other MIBs should import OwnerString from RFC\n   1757 or its successors.\n   Added
    ifCompliance3 as a replacement for ifCompliance2 to omit the\n   ifStackGroup2
    group, and add linkUpDownNotificationsGroup.  Also,\n   corrected the omission
    of ifVHCPacketGroup, and typos in the\n   DESCRIPTIONs of ifHCPacketGroup and
    ifFixedLengthGroup.  Obsoleted\n   ifCompliance2.\n   Modified syntax of ifStackHigherLayer
    and ifStackLowerLayer to be\n   InterfaceIndexOrZero.\n   Added requirement that
    media-specific MIB designers specify any\n   special conditions concerning the
    counting of framing characters in\n   ifInOctets and ifOutOctets.\n   Corrected
    a typo in the DESCRIPTION of the linkUp notification.\n   Modified the introductory
    SNMP Network Management Framework\n   boilerplate text.\n"
  title: 11.  Changes from RFC 2233
- contents:
  - "12.  Notice on Intellectual Property\n   The IETF takes no position regarding
    the validity or scope of any\n   intellectual property or other rights that might
    be claimed to\n   pertain to the implementation or use of the technology described
    in\n   this document or the extent to which any license under such rights\n   might
    or might not be available; neither does it represent that it\n   has made any
    effort to identify any such rights.  Information on the\n   IETF's procedures
    with respect to rights in standards-track and\n   standards-related documentation
    can be found in BCP-11.  Copies of\n   claims of rights made available for publication
    and any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 12.  Notice on Intellectual Property
- contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 13.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
