- contents:
  - '        The Transport Layer Security (TLS) Protocol Version 1.3

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies version 1.3 of the Transport Layer Security\n
    \  (TLS) protocol.  TLS allows client/server applications to communicate\n   over
    the Internet in a way that is designed to prevent eavesdropping,\n   tampering,
    and message forgery.\n   This document updates RFCs 5705 and 6066, and obsoletes
    RFCs 5077,\n   5246, and 6961.  This document also specifies new requirements
    for\n   TLS 1.2 implementations.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8446.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................6\n
    \     1.1. Conventions and Terminology ................................7\n      1.2.
    Major Differences from TLS 1.2 .............................8\n      1.3. Updates
    Affecting TLS 1.2 ..................................9\n   2. Protocol Overview
    ..............................................10\n      2.1. Incorrect DHE Share
    .......................................14\n      2.2. Resumption and Pre-Shared
    Key (PSK) .......................15\n      2.3. 0-RTT Data ................................................17\n
    \  3. Presentation Language ..........................................19\n      3.1.
    Basic Block Size ..........................................19\n      3.2. Miscellaneous
    .............................................20\n      3.3. Numbers ...................................................20\n
    \     3.4. Vectors ...................................................20\n      3.5.
    Enumerateds ...............................................21\n      3.6. Constructed
    Types .........................................22\n      3.7. Constants .................................................23\n
    \     3.8. Variants ..................................................23\n   4.
    Handshake Protocol .............................................24\n      4.1.
    Key Exchange Messages .....................................25\n           4.1.1.
    Cryptographic Negotiation ..........................26\n           4.1.2. Client
    Hello .......................................27\n           4.1.3. Server Hello
    .......................................31\n           4.1.4. Hello Retry Request
    ................................33\n      4.2. Extensions ................................................35\n
    \          4.2.1. Supported Versions .................................39\n           4.2.2.
    Cookie .............................................40\n           4.2.3. Signature
    Algorithms ...............................41\n           4.2.4. Certificate Authorities
    ............................45\n           4.2.5. OID Filters ........................................45\n
    \          4.2.6. Post-Handshake Client Authentication ...............47\n           4.2.7.
    Supported Groups ...................................47\n           4.2.8. Key
    Share ..........................................48\n           4.2.9. Pre-Shared
    Key Exchange Modes ......................51\n           4.2.10. Early Data Indication
    .............................52\n           4.2.11. Pre-Shared Key Extension ..........................55\n
    \     4.3. Server Parameters .........................................59\n           4.3.1.
    Encrypted Extensions ...............................60\n           4.3.2. Certificate
    Request ................................60\n      4.4. Authentication Messages
    ...................................61\n           4.4.1. The Transcript Hash ................................63\n
    \          4.4.2. Certificate ........................................64\n           4.4.3.
    Certificate Verify .................................69\n           4.4.4. Finished
    ...........................................71\n      4.5. End of Early Data .........................................72\n
    \     4.6. Post-Handshake Messages ...................................73\n           4.6.1.
    New Session Ticket Message .........................73\n           4.6.2. Post-Handshake
    Authentication ......................75\n           4.6.3. Key and Initialization
    Vector Update ...............76\n   5. Record Protocol ................................................77\n
    \     5.1. Record Layer ..............................................78\n      5.2.
    Record Payload Protection .................................80\n      5.3. Per-Record
    Nonce ..........................................82\n      5.4. Record Padding
    ............................................83\n      5.5. Limits on Key Usage
    .......................................84\n   6. Alert Protocol .................................................85\n
    \     6.1. Closure Alerts ............................................87\n      6.2.
    Error Alerts ..............................................88\n   7. Cryptographic
    Computations .....................................90\n      7.1. Key Schedule
    ..............................................91\n      7.2. Updating Traffic
    Secrets ..................................94\n      7.3. Traffic Key Calculation
    ...................................95\n      7.4. (EC)DHE Shared Secret Calculation
    .........................95\n           7.4.1. Finite Field Diffie-Hellman ........................95\n
    \          7.4.2. Elliptic Curve Diffie-Hellman ......................96\n      7.5.
    Exporters .................................................97\n   8. 0-RTT and
    Anti-Replay ..........................................98\n      8.1. Single-Use
    Tickets ........................................99\n      8.2. Client Hello Recording
    ....................................99\n      8.3. Freshness Checks .........................................101\n
    \  9. Compliance Requirements .......................................102\n      9.1.
    Mandatory-to-Implement Cipher Suites .....................102\n      9.2. Mandatory-to-Implement
    Extensions ........................103\n      9.3. Protocol Invariants ......................................104\n
    \  10. Security Considerations ......................................106\n   11.
    IANA Considerations ..........................................106\n   12. References
    ...................................................109\n      12.1. Normative
    References ....................................109\n      12.2. Informative References
    ..................................112\n   Appendix A. State Machine ........................................120\n
    \    A.1. Client ....................................................120\n     A.2.
    Server ....................................................121\n   Appendix B.
    Protocol Data Structures and Constant Values .........122\n     B.1. Record Layer
    ..............................................122\n     B.2. Alert Messages ............................................123\n
    \    B.3. Handshake Protocol ........................................124\n       B.3.1.
    Key Exchange Messages .................................125\n       B.3.2. Server
    Parameters Messages ............................131\n       B.3.3. Authentication
    Messages ...............................132\n       B.3.4. Ticket Establishment
    ..................................132\n       B.3.5. Updating Keys .........................................133\n
    \    B.4. Cipher Suites .............................................133\n   Appendix
    C. Implementation Notes .................................134\n     C.1. Random
    Number Generation and Seeding ......................134\n     C.2. Certificates
    and Authentication ...........................135\n     C.3. Implementation Pitfalls
    ...................................135\n     C.4. Client Tracking Prevention ................................137\n
    \    C.5. Unauthenticated Operation .................................137\n   Appendix
    D. Backward Compatibility ...............................138\n     D.1. Negotiating
    with an Older Server ..........................139\n     D.2. Negotiating with
    an Older Client ..........................139\n     D.3. 0-RTT Backward Compatibility
    ..............................140\n     D.4. Middlebox Compatibility Mode ..............................140\n
    \    D.5. Security Restrictions Related to Backward Compatibility ...141\n   Appendix
    E. Overview of Security Properties ......................142\n     E.1. Handshake
    .................................................142\n       E.1.1. Key Derivation
    and HKDF ...............................145\n       E.1.2. Client Authentication
    .................................146\n       E.1.3. 0-RTT .................................................146\n
    \      E.1.4. Exporter Independence .................................146\n       E.1.5.
    Post-Compromise Security ..............................146\n       E.1.6. External
    References ...................................147\n     E.2. Record Layer ..............................................147\n
    \      E.2.1. External References ...................................148\n     E.3.
    Traffic Analysis ..........................................148\n     E.4. Side-Channel
    Attacks ......................................149\n     E.5. Replay Attacks on
    0-RTT ...................................150\n       E.5.1. Replay and Exporters
    ..................................151\n     E.6. PSK Identity Exposure .....................................152\n
    \    E.7. Sharing PSKs ..............................................152\n     E.8.
    Attacks on Static RSA .....................................152\n   Contributors
    .....................................................153\n   Author's Address
    .................................................160\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The primary goal of TLS is to provide a secure channel between
    two\n   communicating peers; the only requirement from the underlying\n   transport
    is a reliable, in-order data stream.  Specifically, the\n   secure channel should
    provide the following properties:\n   -  Authentication: The server side of the
    channel is always\n      authenticated; the client side is optionally authenticated.\n
    \     Authentication can happen via asymmetric cryptography (e.g., RSA\n      [RSA],
    the Elliptic Curve Digital Signature Algorithm (ECDSA)\n      [ECDSA], or the
    Edwards-Curve Digital Signature Algorithm (EdDSA)\n      [RFC8032]) or a symmetric
    pre-shared key (PSK).\n   -  Confidentiality: Data sent over the channel after
    establishment is\n      only visible to the endpoints.  TLS does not hide the
    length of\n      the data it transmits, though endpoints are able to pad TLS\n
    \     records in order to obscure lengths and improve protection against\n      traffic
    analysis techniques.\n   -  Integrity: Data sent over the channel after establishment
    cannot\n      be modified by attackers without detection.\n   These properties
    should be true even in the face of an attacker who\n   has complete control of
    the network, as described in [RFC3552].  See\n   Appendix E for a more complete
    statement of the relevant security\n   properties.\n   TLS consists of two primary
    components:\n   -  A handshake protocol (Section 4) that authenticates the\n      communicating
    parties, negotiates cryptographic modes and\n      parameters, and establishes
    shared keying material.  The handshake\n      protocol is designed to resist tampering;
    an active attacker\n      should not be able to force the peers to negotiate different\n
    \     parameters than they would if the connection were not under\n      attack.\n
    \  -  A record protocol (Section 5) that uses the parameters established\n      by
    the handshake protocol to protect traffic between the\n      communicating peers.
    \ The record protocol divides traffic up into\n      a series of records, each
    of which is independently protected\n      using the traffic keys.\n   TLS is
    application protocol independent; higher-level protocols can\n   layer on top
    of TLS transparently.  The TLS standard, however, does\n   not specify how protocols
    add security with TLS; how to initiate TLS\n   handshaking and how to interpret
    the authentication certificates\n   exchanged are left to the judgment of the
    designers and implementors\n   of protocols that run on top of TLS.\n   This document
    defines TLS version 1.3.  While TLS 1.3 is not directly\n   compatible with previous
    versions, all versions of TLS incorporate a\n   versioning mechanism which allows
    clients and servers to\n   interoperably negotiate a common version if one is
    supported by both\n   peers.\n   This document supersedes and obsoletes previous
    versions of TLS,\n   including version 1.2 [RFC5246].  It also obsoletes the TLS
    ticket\n   mechanism defined in [RFC5077] and replaces it with the mechanism\n
    \  defined in Section 2.2.  Because TLS 1.3 changes the way keys are\n   derived,
    it updates [RFC5705] as described in Section 7.5.  It also\n   changes how Online
    Certificate Status Protocol (OCSP) messages are\n   carried and therefore updates
    [RFC6066] and obsoletes [RFC6961] as\n   described in Section 4.4.2.1.\n"
  - contents:
    - "1.1.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be
      interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,
      they appear in all\n   capitals, as shown here.\n   The following terms are
      used:\n   client:  The endpoint initiating the TLS connection.\n   connection:
      \ A transport-layer connection between two endpoints.\n   endpoint:  Either
      the client or server of the connection.\n   handshake:  An initial negotiation
      between client and server that\n      establishes the parameters of their subsequent
      interactions\n      within TLS.\n   peer:  An endpoint.  When discussing a particular
      endpoint, \"peer\"\n      refers to the endpoint that is not the primary subject
      of\n      discussion.\n   receiver:  An endpoint that is receiving records.\n
      \  sender:  An endpoint that is transmitting records.\n   server:  The endpoint
      that did not initiate the TLS connection.\n"
    title: 1.1.  Conventions and Terminology
  - contents:
    - "1.2.  Major Differences from TLS 1.2\n   The following is a list of the major
      functional differences between\n   TLS 1.2 and TLS 1.3.  It is not intended
      to be exhaustive, and there\n   are many minor differences.\n   -  The list
      of supported symmetric encryption algorithms has been\n      pruned of all algorithms
      that are considered legacy.  Those that\n      remain are all Authenticated
      Encryption with Associated Data\n      (AEAD) algorithms.  The cipher suite
      concept has been changed to\n      separate the authentication and key exchange
      mechanisms from the\n      record protection algorithm (including secret key
      length) and a\n      hash to be used with both the key derivation function and\n
      \     handshake message authentication code (MAC).\n   -  A zero round-trip
      time (0-RTT) mode was added, saving a round trip\n      at connection setup
      for some application data, at the cost of\n      certain security properties.\n
      \  -  Static RSA and Diffie-Hellman cipher suites have been removed; all\n      public-key
      based key exchange mechanisms now provide forward\n      secrecy.\n   -  All
      handshake messages after the ServerHello are now encrypted.\n      The newly
      introduced EncryptedExtensions message allows various\n      extensions previously
      sent in the clear in the ServerHello to also\n      enjoy confidentiality protection.\n
      \  -  The key derivation functions have been redesigned.  The new design\n      allows
      easier analysis by cryptographers due to their improved key\n      separation
      properties.  The HMAC-based Extract-and-Expand Key\n      Derivation Function
      (HKDF) is used as an underlying primitive.\n   -  The handshake state machine
      has been significantly restructured to\n      be more consistent and to remove
      superfluous messages such as\n      ChangeCipherSpec (except when needed for
      middlebox compatibility).\n   -  Elliptic curve algorithms are now in the base
      spec, and new\n      signature algorithms, such as EdDSA, are included.  TLS
      1.3\n      removed point format negotiation in favor of a single point format\n
      \     for each curve.\n   -  Other cryptographic improvements were made, including
      changing the\n      RSA padding to use the RSA Probabilistic Signature Scheme\n
      \     (RSASSA-PSS), and the removal of compression, the Digital\n      Signature
      Algorithm (DSA), and custom Ephemeral Diffie-Hellman\n      (DHE) groups.\n
      \  -  The TLS 1.2 version negotiation mechanism has been deprecated in\n      favor
      of a version list in an extension.  This increases\n      compatibility with
      existing servers that incorrectly implemented\n      version negotiation.\n
      \  -  Session resumption with and without server-side state as well as\n      the
      PSK-based cipher suites of earlier TLS versions have been\n      replaced by
      a single new PSK exchange.\n   -  References have been updated to point to the
      updated versions of\n      RFCs, as appropriate (e.g., RFC 5280 rather than
      RFC 3280).\n"
    title: 1.2.  Major Differences from TLS 1.2
  - contents:
    - "1.3.  Updates Affecting TLS 1.2\n   This document defines several changes that
      optionally affect\n   implementations of TLS 1.2, including those which do not
      also support\n   TLS 1.3:\n   -  A version downgrade protection mechanism is
      described in\n      Section 4.1.3.\n   -  RSASSA-PSS signature schemes are defined
      in Section 4.2.3.\n   -  The \"supported_versions\" ClientHello extension can
      be used to\n      negotiate the version of TLS to use, in preference to the\n
      \     legacy_version field of the ClientHello.\n   -  The \"signature_algorithms_cert\"
      extension allows a client to\n      indicate which signature algorithms it can
      validate in X.509\n      certificates.\n   Additionally, this document clarifies
      some compliance requirements\n   for earlier versions of TLS; see Section 9.3.\n"
    title: 1.3.  Updates Affecting TLS 1.2
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   The cryptographic parameters used by the secure channel
    are produced\n   by the TLS handshake protocol.  This sub-protocol of TLS is used
    by\n   the client and server when first communicating with each other.  The\n
    \  handshake protocol allows peers to negotiate a protocol version,\n   select
    cryptographic algorithms, optionally authenticate each other,\n   and establish
    shared secret keying material.  Once the handshake is\n   complete, the peers
    use the established keys to protect the\n   application-layer traffic.\n   A failure
    of the handshake or other protocol error triggers the\n   termination of the connection,
    optionally preceded by an alert\n   message (Section 6).\n   TLS supports three
    basic key exchange modes:\n   -  (EC)DHE (Diffie-Hellman over either finite fields
    or elliptic\n      curves)\n   -  PSK-only\n   -  PSK with (EC)DHE\n   Figure
    1 below shows the basic full TLS handshake:\n       Client                                           Server\n"
  - 'Key  ^ ClientHello

    '
  - "Exch | + key_share*\n     | + signature_algorithms*\n     | + psk_key_exchange_modes*\n
    \    v + pre_shared_key*       -------->\n                                                  ServerHello
    \ ^ Key\n                                                 + key_share*  | Exch\n
    \                                           + pre_shared_key*  v\n                                        {EncryptedExtensions}
    \ ^  Server\n                                        {CertificateRequest*}  v
    \ Params\n                                               {Certificate*}  ^\n                                         {CertificateVerify*}
    \ | Auth\n                                                   {Finished}  v\n                               <--------
    \ [Application Data*]\n     ^ {Certificate*}\n"
  - "Auth | {CertificateVerify*}\n     v {Finished}              -------->\n       [Application
    Data]      <------->  [Application Data]\n              +  Indicates noteworthy
    extensions sent in the\n                 previously noted message.\n              *
    \ Indicates optional or situation-dependent\n                 messages/extensions
    that are not always sent.\n              {} Indicates messages protected using
    keys\n                 derived from a [sender]_handshake_traffic_secret.\n              []
    Indicates messages protected using keys\n                 derived from [sender]_application_traffic_secret_N.\n
    \              Figure 1: Message Flow for Full TLS Handshake\n   The handshake
    can be thought of as having three phases (indicated in\n   the diagram above):\n
    \  -  Key Exchange: Establish shared keying material and select the\n      cryptographic
    parameters.  Everything after this phase is\n      encrypted.\n   -  Server Parameters:
    Establish other handshake parameters\n      (whether the client is authenticated,
    application-layer protocol\n      support, etc.).\n   -  Authentication: Authenticate
    the server (and, optionally, the\n      client) and provide key confirmation and
    handshake integrity.\n   In the Key Exchange phase, the client sends the ClientHello\n
    \  (Section 4.1.2) message, which contains a random nonce\n   (ClientHello.random);
    its offered protocol versions; a list of\n   symmetric cipher/HKDF hash pairs;
    either a set of Diffie-Hellman key\n   shares (in the \"key_share\" (Section 4.2.8)
    extension), a set of\n   pre-shared key labels (in the \"pre_shared_key\" (Section
    4.2.11)\n   extension), or both; and potentially additional extensions.\n   Additional
    fields and/or messages may also be present for middlebox\n   compatibility.\n
    \  The server processes the ClientHello and determines the appropriate\n   cryptographic
    parameters for the connection.  It then responds with\n   its own ServerHello
    (Section 4.1.3), which indicates the negotiated\n   connection parameters.  The
    combination of the ClientHello and the\n   ServerHello determines the shared keys.
    \ If (EC)DHE key establishment\n   is in use, then the ServerHello contains a
    \"key_share\" extension with\n   the server's ephemeral Diffie-Hellman share;
    the server's share MUST\n   be in the same group as one of the client's shares.
    \ If PSK key\n   establishment is in use, then the ServerHello contains a\n   \"pre_shared_key\"
    extension indicating which of the client's offered\n   PSKs was selected.  Note
    that implementations can use (EC)DHE and PSK\n   together, in which case both
    extensions will be supplied.\n   The server then sends two messages to establish
    the Server\n   Parameters:\n   EncryptedExtensions:  responses to ClientHello
    extensions that are\n      not required to determine the cryptographic parameters,
    other than\n      those that are specific to individual certificates.\n      [Section
    4.3.1]\n   CertificateRequest:  if certificate-based client authentication is\n
    \     desired, the desired parameters for that certificate.  This\n      message
    is omitted if client authentication is not desired.\n      [Section 4.3.2]\n   Finally,
    the client and server exchange Authentication messages.  TLS\n   uses the same
    set of messages every time that certificate-based\n   authentication is needed.
    \ (PSK-based authentication happens as a\n   side effect of key exchange.)  Specifically:\n
    \  Certificate:  The certificate of the endpoint and any per-certificate\n      extensions.
    \ This message is omitted by the server if not\n      authenticating with a certificate
    and by the client if the server\n      did not send CertificateRequest (thus indicating
    that the client\n      should not authenticate with a certificate).  Note that
    if raw\n      public keys [RFC7250] or the cached information extension\n      [RFC7924]
    are in use, then this message will not contain a\n      certificate but rather
    some other value corresponding to the\n      server's long-term key.  [Section
    4.4.2]\n   CertificateVerify:  A signature over the entire handshake using the\n
    \     private key corresponding to the public key in the Certificate\n      message.
    \ This message is omitted if the endpoint is not\n      authenticating via a certificate.
    \ [Section 4.4.3]\n   Finished:  A MAC (Message Authentication Code) over the
    entire\n      handshake.  This message provides key confirmation, binds the\n
    \     endpoint's identity to the exchanged keys, and in PSK mode also\n      authenticates
    the handshake.  [Section 4.4.4]\n   Upon receiving the server's messages, the
    client responds with its\n   Authentication messages, namely Certificate and CertificateVerify
    (if\n   requested), and Finished.\n   At this point, the handshake is complete,
    and the client and server\n   derive the keying material required by the record
    layer to exchange\n   application-layer data protected through authenticated encryption.\n
    \  Application Data MUST NOT be sent prior to sending the Finished\n   message,
    except as specified in Section 2.3.  Note that while the\n   server may send Application
    Data prior to receiving the client's\n   Authentication messages, any data sent
    at that point is, of course,\n   being sent to an unauthenticated peer.\n"
  - contents:
    - "2.1.  Incorrect DHE Share\n   If the client has not provided a sufficient \"key_share\"
      extension\n   (e.g., it includes only DHE or ECDHE groups unacceptable to or\n
      \  unsupported by the server), the server corrects the mismatch with a\n   HelloRetryRequest
      and the client needs to restart the handshake with\n   an appropriate \"key_share\"
      extension, as shown in Figure 2.  If no\n   common cryptographic parameters
      can be negotiated, the server MUST\n   abort the handshake with an appropriate
      alert.\n        Client                                               Server\n
      \       ClientHello\n        + key_share             -------->\n                                                  HelloRetryRequest\n
      \                               <--------               + key_share\n        ClientHello\n
      \       + key_share             -------->\n                                                        ServerHello\n
      \                                                       + key_share\n                                              {EncryptedExtensions}\n
      \                                             {CertificateRequest*}\n                                                     {Certificate*}\n
      \                                              {CertificateVerify*}\n                                                         {Finished}\n
      \                               <--------       [Application Data*]\n        {Certificate*}\n
      \       {CertificateVerify*}\n        {Finished}              -------->\n        [Application
      Data]      <------->        [Application Data]\n             Figure 2: Message
      Flow for a Full Handshake with\n                           Mismatched Parameters\n
      \  Note: The handshake transcript incorporates the initial\n   ClientHello/HelloRetryRequest
      exchange; it is not reset with the\n   new ClientHello.\n   TLS also allows
      several optimized variants of the basic handshake, as\n   described in the following
      sections.\n"
    title: 2.1.  Incorrect DHE Share
  - contents:
    - "2.2.  Resumption and Pre-Shared Key (PSK)\n   Although TLS PSKs can be established
      out of band, PSKs can also be\n   established in a previous connection and then
      used to establish a new\n   connection (\"session resumption\" or \"resuming\"
      with a PSK).  Once a\n   handshake has completed, the server can send the client
      a PSK\n   identity that corresponds to a unique key derived from the initial\n
      \  handshake (see Section 4.6.1).  The client can then use that PSK\n   identity
      in future handshakes to negotiate the use of the associated\n   PSK.  If the
      server accepts the PSK, then the security context of the\n   new connection
      is cryptographically tied to the original connection\n   and the key derived
      from the initial handshake is used to bootstrap\n   the cryptographic state
      instead of a full handshake.  In TLS 1.2 and\n   below, this functionality was
      provided by \"session IDs\" and \"session\n   tickets\" [RFC5077].  Both mechanisms
      are obsoleted in TLS 1.3.\n   PSKs can be used with (EC)DHE key exchange in
      order to provide\n   forward secrecy in combination with shared keys, or can
      be used\n   alone, at the cost of losing forward secrecy for the application\n
      \  data.\n   Figure 3 shows a pair of handshakes in which the first handshake\n
      \  establishes a PSK and the second handshake uses it:\n          Client                                               Server\n
      \  Initial Handshake:\n          ClientHello\n          + key_share               -------->\n
      \                                                         ServerHello\n                                                          +
      key_share\n                                                {EncryptedExtensions}\n
      \                                               {CertificateRequest*}\n                                                       {Certificate*}\n
      \                                                {CertificateVerify*}\n                                                           {Finished}\n
      \                                   <--------     [Application Data*]\n          {Certificate*}\n
      \         {CertificateVerify*}\n          {Finished}                -------->\n
      \                                   <--------      [NewSessionTicket]\n          [Application
      Data]        <------->      [Application Data]\n   Subsequent Handshake:\n          ClientHello\n
      \         + key_share*\n          + pre_shared_key          -------->\n                                                          ServerHello\n
      \                                                    + pre_shared_key\n                                                         +
      key_share*\n                                                {EncryptedExtensions}\n
      \                                                          {Finished}\n                                    <--------
      \    [Application Data*]\n          {Finished}                -------->\n          [Application
      Data]        <------->      [Application Data]\n               Figure 3: Message
      Flow for Resumption and PSK\n   As the server is authenticating via a PSK, it
      does not send a\n   Certificate or a CertificateVerify message.  When a client
      offers\n   resumption via a PSK, it SHOULD also supply a \"key_share\" extension\n
      \  to the server to allow the server to decline resumption and fall back\n   to
      a full handshake, if needed.  The server responds with a\n   \"pre_shared_key\"
      extension to negotiate the use of PSK key\n   establishment and can (as shown
      here) respond with a \"key_share\"\n   extension to do (EC)DHE key establishment,
      thus providing forward\n   secrecy.\n   When PSKs are provisioned out of band,
      the PSK identity and the KDF\n   hash algorithm to be used with the PSK MUST
      also be provisioned.\n   Note:  When using an out-of-band provisioned pre-shared
      secret, a\n      critical consideration is using sufficient entropy during the
      key\n      generation, as discussed in [RFC4086].  Deriving a shared secret\n
      \     from a password or other low-entropy sources is not secure.  A\n      low-entropy
      secret, or password, is subject to dictionary attacks\n      based on the PSK
      binder.  The specified PSK authentication is not\n      a strong password-based
      authenticated key exchange even when used\n      with Diffie-Hellman key establishment.
      \ Specifically, it does not\n      prevent an attacker that can observe the
      handshake from performing\n      a brute-force attack on the password/pre-shared
      key.\n"
    title: 2.2.  Resumption and Pre-Shared Key (PSK)
  - contents:
    - "2.3.  0-RTT Data\n   When clients and servers share a PSK (either obtained
      externally or\n   via a previous handshake), TLS 1.3 allows clients to send
      data on the\n   first flight (\"early data\").  The client uses the PSK to authenticate\n
      \  the server and to encrypt the early data.\n   As shown in Figure 4, the 0-RTT
      data is just added to the 1-RTT\n   handshake in the first flight.  The rest
      of the handshake uses the\n   same messages as for a 1-RTT handshake with PSK
      resumption.\n         Client                                               Server\n
      \        ClientHello\n         + early_data\n         + key_share*\n         +
      psk_key_exchange_modes\n         + pre_shared_key\n         (Application Data*)
      \    -------->\n                                                         ServerHello\n
      \                                                   + pre_shared_key\n                                                        +
      key_share*\n                                               {EncryptedExtensions}\n
      \                                                      + early_data*\n                                                          {Finished}\n
      \                                <--------       [Application Data*]\n         (EndOfEarlyData)\n
      \        {Finished}              -------->\n         [Application Data]      <------->
      \       [Application Data]\n               +  Indicates noteworthy extensions
      sent in the\n                  previously noted message.\n               *  Indicates
      optional or situation-dependent\n                  messages/extensions that
      are not always sent.\n               () Indicates messages protected using keys\n
      \                 derived from a client_early_traffic_secret.\n               {}
      Indicates messages protected using keys\n                  derived from a [sender]_handshake_traffic_secret.\n
      \              [] Indicates messages protected using keys\n                  derived
      from [sender]_application_traffic_secret_N.\n               Figure 4: Message
      Flow for a 0-RTT Handshake\n   IMPORTANT NOTE: The security properties for 0-RTT
      data are weaker\n   than those for other kinds of TLS data.  Specifically:\n
      \  1.  This data is not forward secret, as it is encrypted solely under\n       keys
      derived using the offered PSK.\n   2.  There are no guarantees of non-replay
      between connections.\n       Protection against replay for ordinary TLS 1.3
      1-RTT data is\n       provided via the server's Random value, but 0-RTT data
      does not\n       depend on the ServerHello and therefore has weaker guarantees.\n
      \      This is especially relevant if the data is authenticated either\n       with
      TLS client authentication or inside the application\n       protocol.  The same
      warnings apply to any use of the\n       early_exporter_master_secret.\n   0-RTT
      data cannot be duplicated within a connection (i.e., the server\n   will not
      process the same data twice for the same connection), and an\n   attacker will
      not be able to make 0-RTT data appear to be 1-RTT data\n   (because it is protected
      with different keys).  Appendix E.5 contains\n   a description of potential
      attacks, and Section 8 describes\n   mechanisms which the server can use to
      limit the impact of replay.\n"
    title: 2.3.  0-RTT Data
  title: 2.  Protocol Overview
- contents:
  - "3.  Presentation Language\n   This document deals with the formatting of data
    in an external\n   representation.  The following very basic and somewhat casually\n
    \  defined presentation syntax will be used.\n"
  - contents:
    - "3.1.  Basic Block Size\n   The representation of all data items is explicitly
      specified.  The\n   basic data block size is one byte (i.e., 8 bits).  Multiple-byte
      data\n   items are concatenations of bytes, from left to right, from top to\n
      \  bottom.  From the byte stream, a multi-byte item (a numeric in the\n   following
      example) is formed (using C notation) by:\n      value = (byte[0] << 8*(n-1))
      | (byte[1] << 8*(n-2)) |\n              ... | byte[n-1];\n   This byte ordering
      for multi-byte values is the commonplace network\n   byte order or big-endian
      format.\n"
    title: 3.1.  Basic Block Size
  - contents:
    - "3.2.  Miscellaneous\n   Comments begin with \"/*\" and end with \"*/\".\n   Optional
      components are denoted by enclosing them in \"[[ ]]\" (double\n   brackets).\n
      \  Single-byte entities containing uninterpreted data are of\n   type opaque.\n
      \  A type alias T' for an existing type T is defined by:\n      T T';\n"
    title: 3.2.  Miscellaneous
  - contents:
    - "3.3.  Numbers\n   The basic numeric data type is an unsigned byte (uint8).
      \ All larger\n   numeric data types are constructed from a fixed-length series
      of\n   bytes concatenated as described in Section 3.1 and are also unsigned.\n
      \  The following numeric types are predefined.\n      uint8 uint16[2];\n      uint8
      uint24[3];\n      uint8 uint32[4];\n      uint8 uint64[8];\n   All values, here
      and elsewhere in the specification, are transmitted\n   in network byte (big-endian)
      order; the uint32 represented by the hex\n   bytes 01 02 03 04 is equivalent
      to the decimal value 16909060.\n"
    title: 3.3.  Numbers
  - contents:
    - "3.4.  Vectors\n   A vector (single-dimensioned array) is a stream of homogeneous
      data\n   elements.  The size of the vector may be specified at documentation\n
      \  time or left unspecified until runtime.  In either case, the length\n   declares
      the number of bytes, not the number of elements, in the\n   vector.  The syntax
      for specifying a new type, T', that is a fixed-\n   length vector of type T
      is\n      T T'[n];\n   Here, T' occupies n bytes in the data stream, where n
      is a multiple\n   of the size of T.  The length of the vector is not included
      in the\n   encoded stream.\n   In the following example, Datum is defined to
      be three consecutive\n   bytes that the protocol does not interpret, while Data
      is three\n   consecutive Datum, consuming a total of nine bytes.\n      opaque
      Datum[3];      /* three uninterpreted bytes */\n      Datum Data[9];        /*
      three consecutive 3-byte vectors */\n   Variable-length vectors are defined
      by specifying a subrange of legal\n   lengths, inclusively, using the notation
      <floor..ceiling>.  When\n   these are encoded, the actual length precedes the
      vector's contents\n   in the byte stream.  The length will be in the form of
      a number\n   consuming as many bytes as required to hold the vector's specified\n
      \  maximum (ceiling) length.  A variable-length vector with an actual\n   length
      field of zero is referred to as an empty vector.\n      T T'<floor..ceiling>;\n
      \  In the following example, \"mandatory\" is a vector that must contain\n   between
      300 and 400 bytes of type opaque.  It can never be empty.\n   The actual length
      field consumes two bytes, a uint16, which is\n   sufficient to represent the
      value 400 (see Section 3.3).  Similarly,\n   \"longer\" can represent up to
      800 bytes of data, or 400 uint16\n   elements, and it may be empty.  Its encoding
      will include a two-byte\n   actual length field prepended to the vector.  The
      length of an\n   encoded vector must be an exact multiple of the length of a
      single\n   element (e.g., a 17-byte vector of uint16 would be illegal).\n      opaque
      mandatory<300..400>;\n            /* length field is two bytes, cannot be empty
      */\n      uint16 longer<0..800>;\n            /* zero to 400 16-bit unsigned
      integers */\n"
    title: 3.4.  Vectors
  - contents:
    - "3.5.  Enumerateds\n   An additional sparse data type, called \"enum\" or \"enumerated\",
      is\n   available.  Each definition is a different type.  Only enumerateds of\n
      \  the same type may be assigned or compared.  Every element of an\n   enumerated
      must be assigned a value, as demonstrated in the following\n   example.  Since
      the elements of the enumerated are not ordered, they\n   can be assigned any
      unique value, in any order.\n      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]]
      } Te;\n   Future extensions or additions to the protocol may define new values.\n
      \  Implementations need to be able to parse and ignore unknown values\n   unless
      the definition of the field states otherwise.\n   An enumerated occupies as
      much space in the byte stream as would its\n   maximal defined ordinal value.
      \ The following definition would cause\n   one byte to be used to carry fields
      of type Color.\n      enum { red(3), blue(5), white(7) } Color;\n   One may
      optionally specify a value without its associated tag to\n   force the width
      definition without defining a superfluous element.\n   In the following example,
      Taste will consume two bytes in the data\n   stream but can only assume the
      values 1, 2, or 4 in the current\n   version of the protocol.\n      enum {
      sweet(1), sour(2), bitter(4), (32000) } Taste;\n   The names of the elements
      of an enumeration are scoped within the\n   defined type.  In the first example,
      a fully qualified reference to\n   the second element of the enumeration would
      be Color.blue.  Such\n   qualification is not required if the target of the
      assignment is well\n   specified.\n      Color color = Color.blue;     /* overspecified,
      legal */\n      Color color = blue;           /* correct, type implicit */\n
      \  The names assigned to enumerateds do not need to be unique.  The\n   numerical
      value can describe a range over which the same name\n   applies.  The value
      includes the minimum and maximum inclusive values\n   in that range, separated
      by two period characters.  This is\n   principally useful for reserving regions
      of the space.\n      enum { sad(0), meh(1..254), happy(255) } Mood;\n"
    title: 3.5.  Enumerateds
  - contents:
    - "3.6.  Constructed Types\n   Structure types may be constructed from primitive
      types for\n   convenience.  Each specification declares a new, unique type.
      \ The\n   syntax used for definitions is much like that of C.\n      struct
      {\n          T1 f1;\n          T2 f2;\n          ...\n          Tn fn;\n      }
      T;\n   Fixed- and variable-length vector fields are allowed using the\n   standard
      vector syntax.  Structures V1 and V2 in the variants example\n   (Section 3.8)
      demonstrate this.\n   The fields within a structure may be qualified using the
      type's name,\n   with a syntax much like that available for enumerateds.  For
      example,\n   T.f2 refers to the second field of the previous declaration.\n"
    title: 3.6.  Constructed Types
  - contents:
    - "3.7.  Constants\n   Fields and variables may be assigned a fixed value using
      \"=\", as in:\n      struct {\n          T1 f1 = 8;  /* T.f1 must always be
      8 */\n          T2 f2;\n      } T;\n"
    title: 3.7.  Constants
  - contents:
    - "3.8.  Variants\n   Defined structures may have variants based on some knowledge
      that is\n   available within the environment.  The selector must be an enumerated\n
      \  type that defines the possible variants the structure defines.  Each\n   arm
      of the select (below) specifies the type of that variant's field\n   and an
      optional field label.  The mechanism by which the variant is\n   selected at
      runtime is not prescribed by the presentation language.\n      struct {\n          T1
      f1;\n          T2 f2;\n          ....\n          Tn fn;\n          select (E)
      {\n              case e1: Te1 [[fe1]];\n              case e2: Te2 [[fe2]];\n
      \             ....\n              case en: Ten [[fen]];\n          };\n      }
      Tv;\n   For example:\n      enum { apple(0), orange(1) } VariantTag;\n      struct
      {\n          uint16 number;\n          opaque string<0..10>; /* variable length
      */\n      } V1;\n      struct {\n          uint32 number;\n          opaque
      string[10];    /* fixed length */\n      } V2;\n      struct {\n          VariantTag
      type;\n          select (VariantRecord.type) {\n              case apple:  V1;\n
      \             case orange: V2;\n          };\n      } VariantRecord;\n"
    title: 3.8.  Variants
  title: 3.  Presentation Language
- contents:
  - "4.  Handshake Protocol\n   The handshake protocol is used to negotiate the security
    parameters\n   of a connection.  Handshake messages are supplied to the TLS record\n
    \  layer, where they are encapsulated within one or more TLSPlaintext or\n   TLSCiphertext
    structures which are processed and transmitted as\n   specified by the current
    active connection state.\n      enum {\n          client_hello(1),\n          server_hello(2),\n
    \         new_session_ticket(4),\n          end_of_early_data(5),\n          encrypted_extensions(8),\n
    \         certificate(11),\n          certificate_request(13),\n          certificate_verify(15),\n
    \         finished(20),\n          key_update(24),\n          message_hash(254),\n
    \         (255)\n      } HandshakeType;\n      struct {\n          HandshakeType
    msg_type;    /* handshake type */\n          uint24 length;             /* remaining
    bytes in message */\n          select (Handshake.msg_type) {\n              case
    client_hello:          ClientHello;\n              case server_hello:          ServerHello;\n
    \             case end_of_early_data:     EndOfEarlyData;\n              case
    encrypted_extensions:  EncryptedExtensions;\n              case certificate_request:
    \  CertificateRequest;\n              case certificate:           Certificate;\n
    \             case certificate_verify:    CertificateVerify;\n              case
    finished:              Finished;\n              case new_session_ticket:    NewSessionTicket;\n
    \             case key_update:            KeyUpdate;\n          };\n      } Handshake;\n
    \  Protocol messages MUST be sent in the order defined in Section 4.4.1\n   and
    shown in the diagrams in Section 2.  A peer which receives a\n   handshake message
    in an unexpected order MUST abort the handshake\n   with an \"unexpected_message\"
    alert.\n   New handshake message types are assigned by IANA as described in\n
    \  Section 11.\n"
  - contents:
    - "4.1.  Key Exchange Messages\n   The key exchange messages are used to determine
      the security\n   capabilities of the client and the server and to establish
      shared\n   secrets, including the traffic keys used to protect the rest of the\n
      \  handshake and the data.\n"
    - contents:
      - "4.1.1.  Cryptographic Negotiation\n   In TLS, the cryptographic negotiation
        proceeds by the client offering\n   the following four sets of options in
        its ClientHello:\n   -  A list of cipher suites which indicates the AEAD algorithm/HKDF\n
        \     hash pairs which the client supports.\n   -  A \"supported_groups\"
        (Section 4.2.7) extension which indicates the\n      (EC)DHE groups which
        the client supports and a \"key_share\"\n      (Section 4.2.8) extension which
        contains (EC)DHE shares for some\n      or all of these groups.\n   -  A \"signature_algorithms\"
        (Section 4.2.3) extension which indicates\n      the signature algorithms
        which the client can accept.  A\n      \"signature_algorithms_cert\" extension
        (Section 4.2.3) may also be\n      added to indicate certificate-specific
        signature algorithms.\n   -  A \"pre_shared_key\" (Section 4.2.11) extension
        which contains a\n      list of symmetric key identities known to the client
        and a\n      \"psk_key_exchange_modes\" (Section 4.2.9) extension which indicates\n
        \     the key exchange modes that may be used with PSKs.\n   If the server
        does not select a PSK, then the first three of these\n   options are entirely
        orthogonal: the server independently selects a\n   cipher suite, an (EC)DHE
        group and key share for key establishment,\n   and a signature algorithm/certificate
        pair to authenticate itself to\n   the client.  If there is no overlap between
        the received\n   \"supported_groups\" and the groups supported by the server,
        then the\n   server MUST abort the handshake with a \"handshake_failure\"
        or an\n   \"insufficient_security\" alert.\n   If the server selects a PSK,
        then it MUST also select a key\n   establishment mode from the set indicated
        by the client's\n   \"psk_key_exchange_modes\" extension (at present, PSK
        alone or with\n   (EC)DHE).  Note that if the PSK can be used without (EC)DHE,
        then\n   non-overlap in the \"supported_groups\" parameters need not be fatal,\n
        \  as it is in the non-PSK case discussed in the previous paragraph.\n   If
        the server selects an (EC)DHE group and the client did not offer a\n   compatible
        \"key_share\" extension in the initial ClientHello, the\n   server MUST respond
        with a HelloRetryRequest (Section 4.1.4) message.\n   If the server successfully
        selects parameters and does not require a\n   HelloRetryRequest, it indicates
        the selected parameters in the\n   ServerHello as follows:\n   -  If PSK is
        being used, then the server will send a \"pre_shared_key\"\n      extension
        indicating the selected key.\n   -  When (EC)DHE is in use, the server will
        also provide a \"key_share\"\n      extension.  If PSK is not being used,
        then (EC)DHE and\n      certificate-based authentication are always used.\n
        \  -  When authenticating via a certificate, the server will send the\n      Certificate
        (Section 4.4.2) and CertificateVerify (Section 4.4.3)\n      messages.  In
        TLS 1.3 as defined by this document, either a PSK or\n      a certificate
        is always used, but not both.  Future documents may\n      define how to use
        them together.\n   If the server is unable to negotiate a supported set of
        parameters\n   (i.e., there is no overlap between the client and server parameters),\n
        \  it MUST abort the handshake with either a \"handshake_failure\" or\n   \"insufficient_security\"
        fatal alert (see Section 6).\n"
      title: 4.1.1.  Cryptographic Negotiation
    - contents:
      - "4.1.2.  Client Hello\n   When a client first connects to a server, it is
        REQUIRED to send the\n   ClientHello as its first TLS message.  The client
        will also send a\n   ClientHello when the server has responded to its ClientHello
        with a\n   HelloRetryRequest.  In that case, the client MUST send the same\n
        \  ClientHello without modification, except as follows:\n   -  If a \"key_share\"
        extension was supplied in the HelloRetryRequest,\n      replacing the list
        of shares with a list containing a single\n      KeyShareEntry from the indicated
        group.\n   -  Removing the \"early_data\" extension (Section 4.2.10) if one
        was\n      present.  Early data is not permitted after a HelloRetryRequest.\n
        \  -  Including a \"cookie\" extension if one was provided in the\n      HelloRetryRequest.\n
        \  -  Updating the \"pre_shared_key\" extension if present by recomputing\n
        \     the \"obfuscated_ticket_age\" and binder values and (optionally)\n      removing
        any PSKs which are incompatible with the server's\n      indicated cipher
        suite.\n   -  Optionally adding, removing, or changing the length of the\n
        \     \"padding\" extension [RFC7685].\n   -  Other modifications that may
        be allowed by an extension defined in\n      the future and present in the
        HelloRetryRequest.\n   Because TLS 1.3 forbids renegotiation, if a server
        has negotiated\n   TLS 1.3 and receives a ClientHello at any other time, it
        MUST\n   terminate the connection with an \"unexpected_message\" alert.\n
        \  If a server established a TLS connection with a previous version of\n   TLS
        and receives a TLS 1.3 ClientHello in a renegotiation, it MUST\n   retain
        the previous protocol version.  In particular, it MUST NOT\n   negotiate TLS
        1.3.\n   Structure of this message:\n      uint16 ProtocolVersion;\n      opaque
        Random[32];\n      uint8 CipherSuite[2];    /* Cryptographic suite selector
        */\n      struct {\n          ProtocolVersion legacy_version = 0x0303;    /*
        TLS v1.2 */\n          Random random;\n          opaque legacy_session_id<0..32>;\n
        \         CipherSuite cipher_suites<2..2^16-2>;\n          opaque legacy_compression_methods<1..2^8-1>;\n
        \         Extension extensions<8..2^16-1>;\n      } ClientHello;\n   legacy_version:
        \ In previous versions of TLS, this field was used for\n      version negotiation
        and represented the highest version number\n      supported by the client.
        \ Experience has shown that many servers\n      do not properly implement
        version negotiation, leading to \"version\n      intolerance\" in which the
        server rejects an otherwise acceptable\n      ClientHello with a version number
        higher than it supports.  In\n      TLS 1.3, the client indicates its version
        preferences in the\n      \"supported_versions\" extension (Section 4.2.1)
        and the\n      legacy_version field MUST be set to 0x0303, which is the version\n
        \     number for TLS 1.2.  TLS 1.3 ClientHellos are identified as having\n
        \     a legacy_version of 0x0303 and a supported_versions extension\n      present
        with 0x0304 as the highest version indicated therein.\n      (See Appendix
        D for details about backward compatibility.)\n   random:  32 bytes generated
        by a secure random number generator.  See\n      Appendix C for additional
        information.\n   legacy_session_id:  Versions of TLS before TLS 1.3 supported
        a\n      \"session resumption\" feature which has been merged with pre-shared\n
        \     keys in this version (see Section 2.2).  A client which has a\n      cached
        session ID set by a pre-TLS 1.3 server SHOULD set this\n      field to that
        value.  In compatibility mode (see Appendix D.4),\n      this field MUST be
        non-empty, so a client not offering a\n      pre-TLS 1.3 session MUST generate
        a new 32-byte value.  This value\n      need not be random but SHOULD be unpredictable
        to avoid\n      implementations fixating on a specific value (also known as\n
        \     ossification).  Otherwise, it MUST be set as a zero-length vector\n
        \     (i.e., a zero-valued single byte length field).\n   cipher_suites:  A
        list of the symmetric cipher options supported by\n      the client, specifically
        the record protection algorithm\n      (including secret key length) and a
        hash to be used with HKDF, in\n      descending order of client preference.
        \ Values are defined in\n      Appendix B.4.  If the list contains cipher
        suites that the server\n      does not recognize, support, or wish to use,
        the server MUST\n      ignore those cipher suites and process the remaining
        ones as\n      usual.  If the client is attempting a PSK key establishment,
        it\n      SHOULD advertise at least one cipher suite indicating a Hash\n      associated
        with the PSK.\n   legacy_compression_methods:  Versions of TLS before 1.3
        supported\n      compression with the list of supported compression methods
        being\n      sent in this field.  For every TLS 1.3 ClientHello, this vector\n
        \     MUST contain exactly one byte, set to zero, which corresponds to\n      the
        \"null\" compression method in prior versions of TLS.  If a\n      TLS 1.3
        ClientHello is received with any other value in this\n      field, the server
        MUST abort the handshake with an\n      \"illegal_parameter\" alert.  Note
        that TLS 1.3 servers might\n      receive TLS 1.2 or prior ClientHellos which
        contain other\n      compression methods and (if negotiating such a prior
        version) MUST\n      follow the procedures for the appropriate prior version
        of TLS.\n   extensions:  Clients request extended functionality from servers
        by\n      sending data in the extensions field.  The actual \"Extension\"\n
        \     format is defined in Section 4.2.  In TLS 1.3, the use of certain\n
        \     extensions is mandatory, as functionality has moved into\n      extensions
        to preserve ClientHello compatibility with previous\n      versions of TLS.
        \ Servers MUST ignore unrecognized extensions.\n   All versions of TLS allow
        an extensions field to optionally follow\n   the compression_methods field.
        \ TLS 1.3 ClientHello messages always\n   contain extensions (minimally \"supported_versions\",
        otherwise, they\n   will be interpreted as TLS 1.2 ClientHello messages).
        \ However,\n   TLS 1.3 servers might receive ClientHello messages without
        an\n   extensions field from prior versions of TLS.  The presence of\n   extensions
        can be detected by determining whether there are bytes\n   following the compression_methods
        field at the end of the\n   ClientHello.  Note that this method of detecting
        optional data\n   differs from the normal TLS method of having a variable-length
        field,\n   but it is used for compatibility with TLS before extensions were\n
        \  defined.  TLS 1.3 servers will need to perform this check first and\n   only
        attempt to negotiate TLS 1.3 if the \"supported_versions\"\n   extension is
        present.  If negotiating a version of TLS prior to 1.3,\n   a server MUST
        check that the message either contains no data after\n   legacy_compression_methods
        or that it contains a valid extensions\n   block with no data following.  If
        not, then it MUST abort the\n   handshake with a \"decode_error\" alert.\n
        \  In the event that a client requests additional functionality using\n   extensions
        and this functionality is not supplied by the server, the\n   client MAY abort
        the handshake.\n   After sending the ClientHello message, the client waits
        for a\n   ServerHello or HelloRetryRequest message.  If early data is in use,\n
        \  the client may transmit early Application Data (Section 2.3) while\n   waiting
        for the next handshake message.\n"
      title: 4.1.2.  Client Hello
    - contents:
      - "4.1.3.  Server Hello\n   The server will send this message in response to
        a ClientHello\n   message to proceed with the handshake if it is able to negotiate
        an\n   acceptable set of handshake parameters based on the ClientHello.\n
        \  Structure of this message:\n      struct {\n          ProtocolVersion legacy_version
        = 0x0303;    /* TLS v1.2 */\n          Random random;\n          opaque legacy_session_id_echo<0..32>;\n
        \         CipherSuite cipher_suite;\n          uint8 legacy_compression_method
        = 0;\n          Extension extensions<6..2^16-1>;\n      } ServerHello;\n   legacy_version:
        \ In previous versions of TLS, this field was used for\n      version negotiation
        and represented the selected version number\n      for the connection.  Unfortunately,
        some middleboxes fail when\n      presented with new values.  In TLS 1.3,
        the TLS server indicates\n      its version using the \"supported_versions\"
        extension\n      (Section 4.2.1), and the legacy_version field MUST be set
        to\n      0x0303, which is the version number for TLS 1.2.  (See Appendix
        D\n      for details about backward compatibility.)\n   random:  32 bytes
        generated by a secure random number generator.  See\n      Appendix C for
        additional information.  The last 8 bytes MUST be\n      overwritten as described
        below if negotiating TLS 1.2 or TLS 1.1,\n      but the remaining bytes MUST
        be random.  This structure is\n      generated by the server and MUST be generated
        independently of the\n      ClientHello.random.\n   legacy_session_id_echo:
        \ The contents of the client's\n      legacy_session_id field.  Note that
        this field is echoed even if\n      the client's value corresponded to a cached
        pre-TLS 1.3 session\n      which the server has chosen not to resume.  A client
        which\n      receives a legacy_session_id_echo field that does not match what\n
        \     it sent in the ClientHello MUST abort the handshake with an\n      \"illegal_parameter\"
        alert.\n   cipher_suite:  The single cipher suite selected by the server from\n
        \     the list in ClientHello.cipher_suites.  A client which receives a\n
        \     cipher suite that was not offered MUST abort the handshake with an\n
        \     \"illegal_parameter\" alert.\n   legacy_compression_method:  A single
        byte which MUST have the\n      value 0.\n   extensions:  A list of extensions.
        \ The ServerHello MUST only include\n      extensions which are required to
        establish the cryptographic\n      context and negotiate the protocol version.
        \ All TLS 1.3\n      ServerHello messages MUST contain the \"supported_versions\"\n
        \     extension.  Current ServerHello messages additionally contain\n      either
        the \"pre_shared_key\" extension or the \"key_share\"\n      extension, or
        both (when using a PSK with (EC)DHE key\n      establishment).  Other extensions
        (see Section 4.2) are sent\n      separately in the EncryptedExtensions message.\n
        \  For reasons of backward compatibility with middleboxes (see\n   Appendix
        D.4), the HelloRetryRequest message uses the same structure\n   as the ServerHello,
        but with Random set to the special value of the\n   SHA-256 of \"HelloRetryRequest\":\n
        \    CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91\n     C2 A2 11 16 7A
        BB 8C 5E 07 9E 09 E2 C8 A8 33 9C\n   Upon receiving a message with type server_hello,
        implementations MUST\n   first examine the Random value and, if it matches
        this value, process\n   it as described in Section 4.1.4).\n   TLS 1.3 has
        a downgrade protection mechanism embedded in the server's\n   random value.
        \ TLS 1.3 servers which negotiate TLS 1.2 or below in\n   response to a ClientHello
        MUST set the last 8 bytes of their Random\n   value specially in their ServerHello.\n
        \  If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of\n
        \  their Random value to the bytes:\n     44 4F 57 4E 47 52 44 01\n   If negotiating
        TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2\n   servers SHOULD, set
        the last 8 bytes of their ServerHello.Random\n   value to the bytes:\n     44
        4F 57 4E 47 52 44 00\n   TLS 1.3 clients receiving a ServerHello indicating
        TLS 1.2 or below\n   MUST check that the last 8 bytes are not equal to either
        of these\n   values.  TLS 1.2 clients SHOULD also check that the last 8 bytes
        are\n   not equal to the second value if the ServerHello indicates TLS 1.1
        or\n   below.  If a match is found, the client MUST abort the handshake with\n
        \  an \"illegal_parameter\" alert.  This mechanism provides limited\n   protection
        against downgrade attacks over and above what is provided\n   by the Finished
        exchange: because the ServerKeyExchange, a message\n   present in TLS 1.2
        and below, includes a signature over both random\n   values, it is not possible
        for an active attacker to modify the\n   random values without detection as
        long as ephemeral ciphers are\n   used.  It does not provide downgrade protection
        when static RSA\n   is used.\n   Note: This is a change from [RFC5246], so
        in practice many TLS 1.2\n   clients and servers will not behave as specified
        above.\n   A legacy TLS client performing renegotiation with TLS 1.2 or prior\n
        \  and which receives a TLS 1.3 ServerHello during renegotiation MUST\n   abort
        the handshake with a \"protocol_version\" alert.  Note that\n   renegotiation
        is not possible when TLS 1.3 has been negotiated.\n"
      title: 4.1.3.  Server Hello
    - contents:
      - "4.1.4.  Hello Retry Request\n   The server will send this message in response
        to a ClientHello\n   message if it is able to find an acceptable set of parameters
        but the\n   ClientHello does not contain sufficient information to proceed
        with\n   the handshake.  As discussed in Section 4.1.3, the HelloRetryRequest\n
        \  has the same format as a ServerHello message, and the legacy_version,\n
        \  legacy_session_id_echo, cipher_suite, and legacy_compression_method\n   fields
        have the same meaning.  However, for convenience we discuss\n   \"HelloRetryRequest\"
        throughout this document as if it were a distinct\n   message.\n   The server's
        extensions MUST contain \"supported_versions\".\n   Additionally, it SHOULD
        contain the minimal set of extensions\n   necessary for the client to generate
        a correct ClientHello pair.  As\n   with the ServerHello, a HelloRetryRequest
        MUST NOT contain any\n   extensions that were not first offered by the client
        in its\n   ClientHello, with the exception of optionally the \"cookie\" (see\n
        \  Section 4.2.2) extension.\n   Upon receipt of a HelloRetryRequest, the
        client MUST check the\n   legacy_version, legacy_session_id_echo, cipher_suite,
        and\n   legacy_compression_method as specified in Section 4.1.3 and then\n
        \  process the extensions, starting with determining the version using\n   \"supported_versions\".
        \ Clients MUST abort the handshake with an\n   \"illegal_parameter\" alert
        if the HelloRetryRequest would not result\n   in any change in the ClientHello.
        \ If a client receives a second\n   HelloRetryRequest in the same connection
        (i.e., where the ClientHello\n   was itself in response to a HelloRetryRequest),
        it MUST abort the\n   handshake with an \"unexpected_message\" alert.\n   Otherwise,
        the client MUST process all extensions in the\n   HelloRetryRequest and send
        a second updated ClientHello.  The\n   HelloRetryRequest extensions defined
        in this specification are:\n   -  supported_versions (see Section 4.2.1)\n
        \  -  cookie (see Section 4.2.2)\n   -  key_share (see Section 4.2.8)\n   A
        client which receives a cipher suite that was not offered MUST\n   abort the
        handshake.  Servers MUST ensure that they negotiate the\n   same cipher suite
        when receiving a conformant updated ClientHello (if\n   the server selects
        the cipher suite as the first step in the\n   negotiation, then this will
        happen automatically).  Upon receiving\n   the ServerHello, clients MUST check
        that the cipher suite supplied in\n   the ServerHello is the same as that
        in the HelloRetryRequest and\n   otherwise abort the handshake with an \"illegal_parameter\"
        alert.\n   In addition, in its updated ClientHello, the client SHOULD NOT
        offer\n   any pre-shared keys associated with a hash other than that of the\n
        \  selected cipher suite.  This allows the client to avoid having to\n   compute
        partial hash transcripts for multiple hashes in the second\n   ClientHello.\n
        \  The value of selected_version in the HelloRetryRequest\n   \"supported_versions\"
        extension MUST be retained in the ServerHello,\n   and a client MUST abort
        the handshake with an \"illegal_parameter\"\n   alert if the value changes.\n"
      title: 4.1.4.  Hello Retry Request
    title: 4.1.  Key Exchange Messages
  - contents:
    - "4.2.  Extensions\n   A number of TLS messages contain tag-length-value encoded
      extensions\n   structures.\n    struct {\n        ExtensionType extension_type;\n
      \       opaque extension_data<0..2^16-1>;\n    } Extension;\n    enum {\n        server_name(0),
      \                            /* RFC 6066 */\n        max_fragment_length(1),
      \                    /* RFC 6066 */\n        status_request(5),                          /*
      RFC 6066 */\n        supported_groups(10),                       /* RFC 8422,
      7919 */\n        signature_algorithms(13),                   /* RFC 8446 */\n
      \       use_srtp(14),                               /* RFC 5764 */\n        heartbeat(15),
      \                             /* RFC 6520 */\n        application_layer_protocol_negotiation(16),
      /* RFC 7301 */\n        signed_certificate_timestamp(18),           /* RFC 6962
      */\n        client_certificate_type(19),                /* RFC 7250 */\n        server_certificate_type(20),
      \               /* RFC 7250 */\n        padding(21),                                /*
      RFC 7685 */\n        pre_shared_key(41),                         /* RFC 8446
      */\n        early_data(42),                             /* RFC 8446 */\n        supported_versions(43),
      \                    /* RFC 8446 */\n        cookie(44),                                 /*
      RFC 8446 */\n        psk_key_exchange_modes(45),                 /* RFC 8446
      */\n        certificate_authorities(47),                /* RFC 8446 */\n        oid_filters(48),
      \                           /* RFC 8446 */\n        post_handshake_auth(49),
      \                   /* RFC 8446 */\n        signature_algorithms_cert(50),              /*
      RFC 8446 */\n        key_share(51),                              /* RFC 8446
      */\n        (65535)\n    } ExtensionType;\n   Here:\n   -  \"extension_type\"
      identifies the particular extension type.\n   -  \"extension_data\" contains
      information specific to the particular\n      extension type.\n   The list of
      extension types is maintained by IANA as described in\n   Section 11.\n   Extensions
      are generally structured in a request/response fashion,\n   though some extensions
      are just indications with no corresponding\n   response.  The client sends its
      extension requests in the ClientHello\n   message, and the server sends its
      extension responses in the\n   ServerHello, EncryptedExtensions, HelloRetryRequest,
      and Certificate\n   messages.  The server sends extension requests in the\n
      \  CertificateRequest message which a client MAY respond to with a\n   Certificate
      message.  The server MAY also send unsolicited extensions\n   in the NewSessionTicket,
      though the client does not respond directly\n   to these.\n   Implementations
      MUST NOT send extension responses if the remote\n   endpoint did not send the
      corresponding extension requests, with the\n   exception of the \"cookie\" extension
      in the HelloRetryRequest.  Upon\n   receiving such an extension, an endpoint
      MUST abort the handshake\n   with an \"unsupported_extension\" alert.\n   The
      table below indicates the messages where a given extension may\n   appear, using
      the following notation: CH (ClientHello),\n   SH (ServerHello), EE (EncryptedExtensions),
      CT (Certificate),\n   CR (CertificateRequest), NST (NewSessionTicket), and\n
      \  HRR (HelloRetryRequest).  If an implementation receives an extension\n   which
      it recognizes and which is not specified for the message in\n   which it appears,
      it MUST abort the handshake with an\n   \"illegal_parameter\" alert.\n   +--------------------------------------------------+-------------+\n
      \  | Extension                                        |     TLS 1.3 |\n   +--------------------------------------------------+-------------+\n
      \  | server_name [RFC6066]                            |      CH, EE |\n   |
      \                                                 |             |\n   | max_fragment_length
      [RFC6066]                    |      CH, EE |\n   |                                                  |
      \            |\n   | status_request [RFC6066]                         |  CH,
      CR, CT |\n   |                                                  |             |\n
      \  | supported_groups [RFC7919]                       |      CH, EE |\n   |
      \                                                 |             |\n   | signature_algorithms
      (RFC 8446)                  |      CH, CR |\n   |                                                  |
      \            |\n   | use_srtp [RFC5764]                               |      CH,
      EE |\n   |                                                  |             |\n
      \  | heartbeat [RFC6520]                              |      CH, EE |\n   |
      \                                                 |             |\n   | application_layer_protocol_negotiation
      [RFC7301] |      CH, EE |\n   |                                                  |
      \            |\n   | signed_certificate_timestamp [RFC6962]           |  CH,
      CR, CT |\n   |                                                  |             |\n
      \  | client_certificate_type [RFC7250]                |      CH, EE |\n   |
      \                                                 |             |\n   | server_certificate_type
      [RFC7250]                |      CH, EE |\n   |                                                  |
      \            |\n   | padding [RFC7685]                                |          CH
      |\n   |                                                  |             |\n   |
      key_share (RFC 8446)                             | CH, SH, HRR |\n   |                                                  |
      \            |\n   | pre_shared_key (RFC 8446)                        |      CH,
      SH |\n   |                                                  |             |\n
      \  | psk_key_exchange_modes (RFC 8446)                |          CH |\n   |
      \                                                 |             |\n   | early_data
      (RFC 8446)                            | CH, EE, NST |\n   |                                                  |
      \            |\n   | cookie (RFC 8446)                                |     CH,
      HRR |\n   |                                                  |             |\n
      \  | supported_versions (RFC 8446)                    | CH, SH, HRR |\n   |
      \                                                 |             |\n   | certificate_authorities
      (RFC 8446)               |      CH, CR |\n   |                                                  |
      \            |\n   | oid_filters (RFC 8446)                           |          CR
      |\n   |                                                  |             |\n   |
      post_handshake_auth (RFC 8446)                   |          CH |\n   |                                                  |
      \            |\n   | signature_algorithms_cert (RFC 8446)             |      CH,
      CR |\n   +--------------------------------------------------+-------------+\n
      \  When multiple extensions of different types are present, the\n   extensions
      MAY appear in any order, with the exception of\n   \"pre_shared_key\" (Section
      4.2.11) which MUST be the last extension in\n   the ClientHello (but can appear
      anywhere in the ServerHello\n   extensions block).  There MUST NOT be more than
      one extension of the\n   same type in a given extension block.\n   In TLS 1.3,
      unlike TLS 1.2, extensions are negotiated for each\n   handshake even when in
      resumption-PSK mode.  However, 0-RTT\n   parameters are those negotiated in
      the previous handshake; mismatches\n   may require rejecting 0-RTT (see Section
      4.2.10).\n   There are subtle (and not so subtle) interactions that may occur
      in\n   this protocol between new features and existing features which may\n
      \  result in a significant reduction in overall security.  The following\n   considerations
      should be taken into account when designing new\n   extensions:\n   -  Some
      cases where a server does not agree to an extension are error\n      conditions
      (e.g., the handshake cannot continue), and some are\n      simply refusals to
      support particular features.  In general, error\n      alerts should be used
      for the former and a field in the server\n      extension response for the latter.\n
      \  -  Extensions should, as far as possible, be designed to prevent any\n      attack
      that forces use (or non-use) of a particular feature by\n      manipulation
      of handshake messages.  This principle should be\n      followed regardless
      of whether the feature is believed to cause a\n      security problem.  Often
      the fact that the extension fields are\n      included in the inputs to the
      Finished message hashes will be\n      sufficient, but extreme care is needed
      when the extension changes\n      the meaning of messages sent in the handshake
      phase.  Designers\n      and implementors should be aware of the fact that until
      the\n      handshake has been authenticated, active attackers can modify\n      messages
      and insert, remove, or replace extensions.\n"
    - contents:
      - "4.2.1.  Supported Versions\n      struct {\n          select (Handshake.msg_type)
        {\n              case client_hello:\n                   ProtocolVersion versions<2..254>;\n
        \             case server_hello: /* and HelloRetryRequest */\n                   ProtocolVersion
        selected_version;\n          };\n      } SupportedVersions;\n   The \"supported_versions\"
        extension is used by the client to indicate\n   which versions of TLS it supports
        and by the server to indicate which\n   version it is using.  The extension
        contains a list of supported\n   versions in preference order, with the most
        preferred version first.\n   Implementations of this specification MUST send
        this extension in the\n   ClientHello containing all versions of TLS which
        they are prepared to\n   negotiate (for this specification, that means minimally
        0x0304, but\n   if previous versions of TLS are allowed to be negotiated,
        they MUST\n   be present as well).\n   If this extension is not present, servers
        which are compliant with\n   this specification and which also support TLS
        1.2 MUST negotiate\n   TLS 1.2 or prior as specified in [RFC5246], even if\n
        \  ClientHello.legacy_version is 0x0304 or later.  Servers MAY abort the\n
        \  handshake upon receiving a ClientHello with legacy_version 0x0304 or\n
        \  later.\n   If this extension is present in the ClientHello, servers MUST
        NOT use\n   the ClientHello.legacy_version value for version negotiation and
        MUST\n   use only the \"supported_versions\" extension to determine client\n
        \  preferences.  Servers MUST only select a version of TLS present in\n   that
        extension and MUST ignore any unknown versions that are present\n   in that
        extension.  Note that this mechanism makes it possible to\n   negotiate a
        version prior to TLS 1.2 if one side supports a sparse\n   range.  Implementations
        of TLS 1.3 which choose to support prior\n   versions of TLS SHOULD support
        TLS 1.2.  Servers MUST be prepared to\n   receive ClientHellos that include
        this extension but do not include\n   0x0304 in the list of versions.\n   A
        server which negotiates a version of TLS prior to TLS 1.3 MUST set\n   ServerHello.version
        and MUST NOT send the \"supported_versions\"\n   extension.  A server which
        negotiates TLS 1.3 MUST respond by sending\n   a \"supported_versions\" extension
        containing the selected version\n   value (0x0304).  It MUST set the ServerHello.legacy_version
        field to\n   0x0303 (TLS 1.2).  Clients MUST check for this extension prior
        to\n   processing the rest of the ServerHello (although they will have to\n
        \  parse the ServerHello in order to read the extension).  If this\n   extension
        is present, clients MUST ignore the\n   ServerHello.legacy_version value and
        MUST use only the\n   \"supported_versions\" extension to determine the selected
        version.  If\n   the \"supported_versions\" extension in the ServerHello contains
        a\n   version not offered by the client or contains a version prior to\n   TLS
        1.3, the client MUST abort the handshake with an\n   \"illegal_parameter\"
        alert.\n"
      title: 4.2.1.  Supported Versions
    - contents:
      - "4.2.2.  Cookie\n      struct {\n          opaque cookie<1..2^16-1>;\n      }
        Cookie;\n   Cookies serve two primary purposes:\n   -  Allowing the server
        to force the client to demonstrate\n      reachability at their apparent network
        address (thus providing a\n      measure of DoS protection).  This is primarily
        useful for\n      non-connection-oriented transports (see [RFC6347] for an
        example\n      of this).\n   -  Allowing the server to offload state to the
        client, thus allowing\n      it to send a HelloRetryRequest without storing
        any state.  The\n      server can do this by storing the hash of the ClientHello
        in the\n      HelloRetryRequest cookie (protected with some suitable integrity\n
        \     protection algorithm).\n   When sending a HelloRetryRequest, the server
        MAY provide a \"cookie\"\n   extension to the client (this is an exception
        to the usual rule that\n   the only extensions that may be sent are those
        that appear in the\n   ClientHello).  When sending the new ClientHello, the
        client MUST copy\n   the contents of the extension received in the HelloRetryRequest
        into\n   a \"cookie\" extension in the new ClientHello.  Clients MUST NOT
        use\n   cookies in their initial ClientHello in subsequent connections.\n
        \  When a server is operating statelessly, it may receive an unprotected\n
        \  record of type change_cipher_spec between the first and second\n   ClientHello
        (see Section 5).  Since the server is not storing any\n   state, this will
        appear as if it were the first message to be\n   received.  Servers operating
        statelessly MUST ignore these records.\n"
      title: 4.2.2.  Cookie
    - contents:
      - "4.2.3.  Signature Algorithms\n   TLS 1.3 provides two extensions for indicating
        which signature\n   algorithms may be used in digital signatures.  The\n   \"signature_algorithms_cert\"
        extension applies to signatures in\n   certificates, and the \"signature_algorithms\"
        extension, which\n   originally appeared in TLS 1.2, applies to signatures
        in\n   CertificateVerify messages.  The keys found in certificates MUST also\n
        \  be of appropriate type for the signature algorithms they are used\n   with.
        \ This is a particular issue for RSA keys and PSS signatures, as\n   described
        below.  If no \"signature_algorithms_cert\" extension is\n   present, then
        the \"signature_algorithms\" extension also applies to\n   signatures appearing
        in certificates.  Clients which desire the\n   server to authenticate itself
        via a certificate MUST send the\n   \"signature_algorithms\" extension.  If
        a server is authenticating via\n   a certificate and the client has not sent
        a \"signature_algorithms\"\n   extension, then the server MUST abort the handshake
        with a\n   \"missing_extension\" alert (see Section 9.2).\n   The \"signature_algorithms_cert\"
        extension was added to allow\n   implementations which supported different
        sets of algorithms for\n   certificates and in TLS itself to clearly signal
        their capabilities.\n   TLS 1.2 implementations SHOULD also process this extension.\n
        \  Implementations which have the same policy in both cases MAY omit the\n
        \  \"signature_algorithms_cert\" extension.\n   The \"extension_data\" field
        of these extensions contains a\n   SignatureSchemeList value:\n      enum
        {\n          /* RSASSA-PKCS1-v1_5 algorithms */\n          rsa_pkcs1_sha256(0x0401),\n
        \         rsa_pkcs1_sha384(0x0501),\n          rsa_pkcs1_sha512(0x0601),\n
        \         /* ECDSA algorithms */\n          ecdsa_secp256r1_sha256(0x0403),\n
        \         ecdsa_secp384r1_sha384(0x0503),\n          ecdsa_secp521r1_sha512(0x0603),\n
        \         /* RSASSA-PSS algorithms with public key OID rsaEncryption */\n
        \         rsa_pss_rsae_sha256(0x0804),\n          rsa_pss_rsae_sha384(0x0805),\n
        \         rsa_pss_rsae_sha512(0x0806),\n          /* EdDSA algorithms */\n
        \         ed25519(0x0807),\n          ed448(0x0808),\n          /* RSASSA-PSS
        algorithms with public key OID RSASSA-PSS */\n          rsa_pss_pss_sha256(0x0809),\n
        \         rsa_pss_pss_sha384(0x080a),\n          rsa_pss_pss_sha512(0x080b),\n
        \         /* Legacy algorithms */\n          rsa_pkcs1_sha1(0x0201),\n          ecdsa_sha1(0x0203),\n
        \         /* Reserved Code Points */\n          private_use(0xFE00..0xFFFF),\n
        \         (0xFFFF)\n      } SignatureScheme;\n      struct {\n          SignatureScheme
        supported_signature_algorithms<2..2^16-2>;\n      } SignatureSchemeList;\n
        \  Note: This enum is named \"SignatureScheme\" because there is already a\n
        \  \"SignatureAlgorithm\" type in TLS 1.2, which this replaces.  We use\n
        \  the term \"signature algorithm\" throughout the text.\n   Each SignatureScheme
        value lists a single signature algorithm that\n   the client is willing to
        verify.  The values are indicated in\n   descending order of preference.  Note
        that a signature algorithm\n   takes as input an arbitrary-length message,
        rather than a digest.\n   Algorithms which traditionally act on a digest should
        be defined in\n   TLS to first hash the input with a specified hash algorithm
        and then\n   proceed as usual.  The code point groups listed above have the\n
        \  following meanings:\n   RSASSA-PKCS1-v1_5 algorithms:  Indicates a signature
        algorithm using\n      RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding
        hash algorithm\n      as defined in [SHS].  These values refer solely to signatures\n
        \     which appear in certificates (see Section 4.4.2.2) and are not\n      defined
        for use in signed TLS handshake messages, although they\n      MAY appear
        in \"signature_algorithms\" and\n      \"signature_algorithms_cert\" for backward
        compatibility with\n      TLS 1.2.\n   ECDSA algorithms:  Indicates a signature
        algorithm using ECDSA\n      [ECDSA], the corresponding curve as defined in
        ANSI X9.62 [ECDSA]\n      and FIPS 186-4 [DSS], and the corresponding hash
        algorithm as\n      defined in [SHS].  The signature is represented as a DER-encoded\n
        \     [X690] ECDSA-Sig-Value structure.\n   RSASSA-PSS RSAE algorithms:  Indicates
        a signature algorithm using\n      RSASSA-PSS [RFC8017] with mask generation
        function 1.  The digest\n      used in the mask generation function and the
        digest being signed\n      are both the corresponding hash algorithm as defined
        in [SHS].\n      The length of the Salt MUST be equal to the length of the
        output\n      of the digest algorithm.  If the public key is carried in an
        X.509\n      certificate, it MUST use the rsaEncryption OID [RFC5280].\n   EdDSA
        algorithms:  Indicates a signature algorithm using EdDSA as\n      defined
        in [RFC8032] or its successors.  Note that these\n      correspond to the
        \"PureEdDSA\" algorithms and not the \"prehash\"\n      variants.\n   RSASSA-PSS
        PSS algorithms:  Indicates a signature algorithm using\n      RSASSA-PSS [RFC8017]
        with mask generation function 1.  The digest\n      used in the mask generation
        function and the digest being signed\n      are both the corresponding hash
        algorithm as defined in [SHS].\n      The length of the Salt MUST be equal
        to the length of the digest\n      algorithm.  If the public key is carried
        in an X.509 certificate,\n      it MUST use the RSASSA-PSS OID [RFC5756].
        \ When used in\n      certificate signatures, the algorithm parameters MUST
        be DER\n      encoded.  If the corresponding public key's parameters are\n
        \     present, then the parameters in the signature MUST be identical to\n
        \     those in the public key.\n   Legacy algorithms:  Indicates algorithms
        which are being deprecated\n      because they use algorithms with known weaknesses,
        specifically\n      SHA-1 which is used in this context with either (1) RSA
        using\n      RSASSA-PKCS1-v1_5 or (2) ECDSA.  These values refer solely to\n
        \     signatures which appear in certificates (see Section 4.4.2.2) and\n
        \     are not defined for use in signed TLS handshake messages, although\n
        \     they MAY appear in \"signature_algorithms\" and\n      \"signature_algorithms_cert\"
        for backward compatibility with\n      TLS 1.2.  Endpoints SHOULD NOT negotiate
        these algorithms but are\n      permitted to do so solely for backward compatibility.
        \ Clients\n      offering these values MUST list them as the lowest priority\n
        \     (listed after all other algorithms in SignatureSchemeList).\n      TLS
        1.3 servers MUST NOT offer a SHA-1 signed certificate unless\n      no valid
        certificate chain can be produced without it (see\n      Section 4.4.2.2).\n
        \  The signatures on certificates that are self-signed or certificates\n   that
        are trust anchors are not validated, since they begin a\n   certification
        path (see [RFC5280], Section 3.2).  A certificate that\n   begins a certification
        path MAY use a signature algorithm that is not\n   advertised as being supported
        in the \"signature_algorithms\"\n   extension.\n   Note that TLS 1.2 defines
        this extension differently.  TLS 1.3\n   implementations willing to negotiate
        TLS 1.2 MUST behave in\n   accordance with the requirements of [RFC5246] when
        negotiating that\n   version.  In particular:\n   -  TLS 1.2 ClientHellos
        MAY omit this extension.\n   -  In TLS 1.2, the extension contained hash/signature
        pairs.  The\n      pairs are encoded in two octets, so SignatureScheme values
        have\n      been allocated to align with TLS 1.2's encoding.  Some legacy\n
        \     pairs are left unallocated.  These algorithms are deprecated as of\n
        \     TLS 1.3.  They MUST NOT be offered or negotiated by any\n      implementation.
        \ In particular, MD5 [SLOTH], SHA-224, and DSA\n      MUST NOT be used.\n
        \  -  ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature\n
        \     pairs.  However, the old semantics did not constrain the signing\n      curve.
        \ If TLS 1.2 is negotiated, implementations MUST be prepared\n      to accept
        a signature that uses any curve that they advertised in\n      the \"supported_groups\"
        extension.\n   -  Implementations that advertise support for RSASSA-PSS (which
        is\n      mandatory in TLS 1.3) MUST be prepared to accept a signature using\n
        \     that scheme even when TLS 1.2 is negotiated.  In TLS 1.2,\n      RSASSA-PSS
        is used with RSA cipher suites.\n"
      title: 4.2.3.  Signature Algorithms
    - contents:
      - "4.2.4.  Certificate Authorities\n   The \"certificate_authorities\" extension
        is used to indicate the\n   certificate authorities (CAs) which an endpoint
        supports and which\n   SHOULD be used by the receiving endpoint to guide certificate\n
        \  selection.\n   The body of the \"certificate_authorities\" extension consists
        of a\n   CertificateAuthoritiesExtension structure.\n      opaque DistinguishedName<1..2^16-1>;\n
        \     struct {\n          DistinguishedName authorities<3..2^16-1>;\n      }
        CertificateAuthoritiesExtension;\n   authorities:  A list of the distinguished
        names [X501] of acceptable\n      certificate authorities, represented in
        DER-encoded [X690] format.\n      These distinguished names specify a desired
        distinguished name for\n      a trust anchor or subordinate CA; thus, this
        message can be used\n      to describe known trust anchors as well as a desired
        authorization\n      space.\n   The client MAY send the \"certificate_authorities\"
        extension in the\n   ClientHello message.  The server MAY send it in the\n
        \  CertificateRequest message.\n   The \"trusted_ca_keys\" extension [RFC6066],
        which serves a similar\n   purpose but is more complicated, is not used in
        TLS 1.3 (although it\n   may appear in ClientHello messages from clients which
        are offering\n   prior versions of TLS).\n"
      title: 4.2.4.  Certificate Authorities
    - contents:
      - "4.2.5.  OID Filters\n   The \"oid_filters\" extension allows servers to provide
        a set of\n   OID/value pairs which it would like the client's certificate
        to\n   match.  This extension, if provided by the server, MUST only be sent\n
        \  in the CertificateRequest message.\n      struct {\n          opaque certificate_extension_oid<1..2^8-1>;\n
        \         opaque certificate_extension_values<0..2^16-1>;\n      } OIDFilter;\n
        \     struct {\n          OIDFilter filters<0..2^16-1>;\n      } OIDFilterExtension;\n
        \  filters:  A list of certificate extension OIDs [RFC5280] with their\n      allowed
        value(s) and represented in DER-encoded [X690] format.\n      Some certificate
        extension OIDs allow multiple values (e.g.,\n      Extended Key Usage).  If
        the server has included a non-empty\n      filters list, the client certificate
        included in the response MUST\n      contain all of the specified extension
        OIDs that the client\n      recognizes.  For each extension OID recognized
        by the client, all\n      of the specified values MUST be present in the client
        certificate\n      (but the certificate MAY have other values as well).  However,
        the\n      client MUST ignore and skip any unrecognized certificate extension\n
        \     OIDs.  If the client ignored some of the required certificate\n      extension
        OIDs and supplied a certificate that does not satisfy\n      the request,
        the server MAY at its discretion either continue the\n      connection without
        client authentication or abort the handshake\n      with an \"unsupported_certificate\"
        alert.  Any given OID MUST NOT\n      appear more than once in the filters
        list.\n   PKIX RFCs define a variety of certificate extension OIDs and their\n
        \  corresponding value types.  Depending on the type, matching\n   certificate
        extension values are not necessarily bitwise-equal.  It\n   is expected that
        TLS implementations will rely on their PKI libraries\n   to perform certificate
        selection using certificate extension OIDs.\n   This document defines matching
        rules for two standard certificate\n   extensions defined in [RFC5280]:\n
        \  -  The Key Usage extension in a certificate matches the request when\n
        \     all key usage bits asserted in the request are also asserted in\n      the
        Key Usage certificate extension.\n   -  The Extended Key Usage extension in
        a certificate matches the\n      request when all key purpose OIDs present
        in the request are also\n      found in the Extended Key Usage certificate
        extension.  The\n      special anyExtendedKeyUsage OID MUST NOT be used in
        the request.\n   Separate specifications may define matching rules for other\n
        \  certificate extensions.\n"
      title: 4.2.5.  OID Filters
    - contents:
      - "4.2.6.  Post-Handshake Client Authentication\n   The \"post_handshake_auth\"
        extension is used to indicate that a client\n   is willing to perform post-handshake
        authentication (Section 4.6.2).\n   Servers MUST NOT send a post-handshake
        CertificateRequest to clients\n   which do not offer this extension.  Servers
        MUST NOT send this\n   extension.\n      struct {} PostHandshakeAuth;\n   The
        \"extension_data\" field of the \"post_handshake_auth\" extension is\n   zero
        length.\n"
      title: 4.2.6.  Post-Handshake Client Authentication
    - contents:
      - "4.2.7.  Supported Groups\n   When sent by the client, the \"supported_groups\"
        extension indicates\n   the named groups which the client supports for key
        exchange, ordered\n   from most preferred to least preferred.\n   Note: In
        versions of TLS prior to TLS 1.3, this extension was named\n   \"elliptic_curves\"
        and only contained elliptic curve groups.  See\n   [RFC8422] and [RFC7919].
        \ This extension was also used to negotiate\n   ECDSA curves.  Signature algorithms
        are now negotiated independently\n   (see Section 4.2.3).\n   The \"extension_data\"
        field of this extension contains a\n   \"NamedGroupList\" value:\n      enum
        {\n          /* Elliptic Curve Groups (ECDHE) */\n          secp256r1(0x0017),
        secp384r1(0x0018), secp521r1(0x0019),\n          x25519(0x001D), x448(0x001E),\n
        \         /* Finite Field Groups (DHE) */\n          ffdhe2048(0x0100), ffdhe3072(0x0101),
        ffdhe4096(0x0102),\n          ffdhe6144(0x0103), ffdhe8192(0x0104),\n          /*
        Reserved Code Points */\n          ffdhe_private_use(0x01FC..0x01FF),\n          ecdhe_private_use(0xFE00..0xFEFF),\n
        \         (0xFFFF)\n      } NamedGroup;\n      struct {\n          NamedGroup
        named_group_list<2..2^16-1>;\n      } NamedGroupList;\n   Elliptic Curve Groups
        (ECDHE):  Indicates support for the\n      corresponding named curve, defined
        in either FIPS 186-4 [DSS] or\n      [RFC7748].  Values 0xFE00 through 0xFEFF
        are reserved for\n      Private Use [RFC8126].\n   Finite Field Groups (DHE):
        \ Indicates support for the corresponding\n      finite field group, defined
        in [RFC7919].  Values 0x01FC through\n      0x01FF are reserved for Private
        Use.\n   Items in named_group_list are ordered according to the sender's\n
        \  preferences (most preferred choice first).\n   As of TLS 1.3, servers are
        permitted to send the \"supported_groups\"\n   extension to the client.  Clients
        MUST NOT act upon any information\n   found in \"supported_groups\" prior
        to successful completion of the\n   handshake but MAY use the information
        learned from a successfully\n   completed handshake to change what groups
        they use in their\n   \"key_share\" extension in subsequent connections.  If
        the server has a\n   group it prefers to the ones in the \"key_share\" extension
        but is\n   still willing to accept the ClientHello, it SHOULD send\n   \"supported_groups\"
        to update the client's view of its preferences;\n   this extension SHOULD
        contain all groups the server supports,\n   regardless of whether they are
        currently supported by the client.\n"
      title: 4.2.7.  Supported Groups
    - contents:
      - "4.2.8.  Key Share\n   The \"key_share\" extension contains the endpoint's
        cryptographic\n   parameters.\n   Clients MAY send an empty client_shares
        vector in order to request\n   group selection from the server, at the cost
        of an additional round\n   trip (see Section 4.1.4).\n      struct {\n          NamedGroup
        group;\n          opaque key_exchange<1..2^16-1>;\n      } KeyShareEntry;\n
        \  group:  The named group for the key being exchanged.\n   key_exchange:
        \ Key exchange information.  The contents of this field\n      are determined
        by the specified group and its corresponding\n      definition.  Finite Field
        Diffie-Hellman [DH76] parameters are\n      described in Section 4.2.8.1;
        Elliptic Curve Diffie-Hellman\n      parameters are described in Section 4.2.8.2.\n
        \  In the ClientHello message, the \"extension_data\" field of this\n   extension
        contains a \"KeyShareClientHello\" value:\n      struct {\n          KeyShareEntry
        client_shares<0..2^16-1>;\n      } KeyShareClientHello;\n   client_shares:
        \ A list of offered KeyShareEntry values in descending\n      order of client
        preference.\n   This vector MAY be empty if the client is requesting a\n   HelloRetryRequest.
        \ Each KeyShareEntry value MUST correspond to a\n   group offered in the \"supported_groups\"
        extension and MUST appear in\n   the same order.  However, the values MAY
        be a non-contiguous subset\n   of the \"supported_groups\" extension and MAY
        omit the most preferred\n   groups.  Such a situation could arise if the most
        preferred groups\n   are new and unlikely to be supported in enough places
        to make\n   pregenerating key shares for them efficient.\n   Clients can offer
        as many KeyShareEntry values as the number of\n   supported groups it is offering,
        each representing a single set of\n   key exchange parameters.  For instance,
        a client might offer shares\n   for several elliptic curves or multiple FFDHE
        groups.  The\n   key_exchange values for each KeyShareEntry MUST be generated\n
        \  independently.  Clients MUST NOT offer multiple KeyShareEntry values\n
        \  for the same group.  Clients MUST NOT offer any KeyShareEntry values\n
        \  for groups not listed in the client's \"supported_groups\" extension.\n
        \  Servers MAY check for violations of these rules and abort the\n   handshake
        with an \"illegal_parameter\" alert if one is violated.\n   In a HelloRetryRequest
        message, the \"extension_data\" field of this\n   extension contains a KeyShareHelloRetryRequest
        value:\n      struct {\n          NamedGroup selected_group;\n      } KeyShareHelloRetryRequest;\n
        \  selected_group:  The mutually supported group the server intends to\n      negotiate
        and is requesting a retried ClientHello/KeyShare for.\n   Upon receipt of
        this extension in a HelloRetryRequest, the client\n   MUST verify that (1)
        the selected_group field corresponds to a group\n   which was provided in
        the \"supported_groups\" extension in the\n   original ClientHello and (2)
        the selected_group field does not\n   correspond to a group which was provided
        in the \"key_share\" extension\n   in the original ClientHello.  If either
        of these checks fails, then\n   the client MUST abort the handshake with an
        \"illegal_parameter\"\n   alert.  Otherwise, when sending the new ClientHello,
        the client MUST\n   replace the original \"key_share\" extension with one
        containing only a\n   new KeyShareEntry for the group indicated in the selected_group
        field\n   of the triggering HelloRetryRequest.\n   In a ServerHello message,
        the \"extension_data\" field of this\n   extension contains a KeyShareServerHello
        value:\n      struct {\n          KeyShareEntry server_share;\n      } KeyShareServerHello;\n
        \  server_share:  A single KeyShareEntry value that is in the same group\n
        \     as one of the client's shares.\n   If using (EC)DHE key establishment,
        servers offer exactly one\n   KeyShareEntry in the ServerHello.  This value
        MUST be in the same\n   group as the KeyShareEntry value offered by the client
        that the\n   server has selected for the negotiated key exchange.  Servers\n
        \  MUST NOT send a KeyShareEntry for any group not indicated in the\n   client's
        \"supported_groups\" extension and MUST NOT send a\n   KeyShareEntry when
        using the \"psk_ke\" PskKeyExchangeMode.  If using\n   (EC)DHE key establishment
        and a HelloRetryRequest containing a\n   \"key_share\" extension was received
        by the client, the client MUST\n   verify that the selected NamedGroup in
        the ServerHello is the same as\n   that in the HelloRetryRequest.  If this
        check fails, the client MUST\n   abort the handshake with an \"illegal_parameter\"
        alert.\n"
      - contents:
        - "4.2.8.1.  Diffie-Hellman Parameters\n   Diffie-Hellman [DH76] parameters
          for both clients and servers are\n   encoded in the opaque key_exchange
          field of a KeyShareEntry in a\n   KeyShare structure.  The opaque value
          contains the Diffie-Hellman\n   public value (Y = g^X mod p) for the specified
          group (see [RFC7919]\n   for group definitions) encoded as a big-endian
          integer and padded to\n   the left with zeros to the size of p in bytes.\n
          \  Note: For a given Diffie-Hellman group, the padding results in all\n
          \  public keys having the same length.\n   Peers MUST validate each other's
          public key Y by ensuring that 1 < Y\n   < p-1.  This check ensures that
          the remote peer is properly behaved\n   and isn't forcing the local system
          into a small subgroup.\n"
        title: 4.2.8.1.  Diffie-Hellman Parameters
      - contents:
        - "4.2.8.2.  ECDHE Parameters\n   ECDHE parameters for both clients and servers
          are encoded in the\n   opaque key_exchange field of a KeyShareEntry in a
          KeyShare structure.\n   For secp256r1, secp384r1, and secp521r1, the contents
          are the\n   serialized value of the following struct:\n      struct {\n
          \         uint8 legacy_form = 4;\n          opaque X[coordinate_length];\n
          \         opaque Y[coordinate_length];\n      } UncompressedPointRepresentation;\n
          \  X and Y, respectively, are the binary representations of the x and y\n
          \  values in network byte order.  There are no internal length markers,\n
          \  so each number representation occupies as many octets as implied by\n
          \  the curve parameters.  For P-256, this means that each of X and Y use\n
          \  32 octets, padded on the left by zeros if necessary.  For P-384, they\n
          \  take 48 octets each.  For P-521, they take 66 octets each.\n   For the
          curves secp256r1, secp384r1, and secp521r1, peers MUST\n   validate each
          other's public value Q by ensuring that the point is a\n   valid point on
          the elliptic curve.  The appropriate validation\n   procedures are defined
          in Section 4.3.7 of [ECDSA] and alternatively\n   in Section 5.6.2.3 of
          [KEYAGREEMENT].  This process consists of three\n   steps: (1) verify that
          Q is not the point at infinity (O), (2) verify\n   that for Q = (x, y) both
          integers x and y are in the correct\n   interval, and (3) ensure that (x,
          y) is a correct solution to the\n   elliptic curve equation.  For these
          curves, implementors do not need\n   to verify membership in the correct
          subgroup.\n   For X25519 and X448, the contents of the public value are
          the byte\n   string inputs and outputs of the corresponding functions defined
          in\n   [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.\n   Note: Versions
          of TLS prior to 1.3 permitted point format\n   negotiation; TLS 1.3 removes
          this feature in favor of a single point\n   format for each curve.\n"
        title: 4.2.8.2.  ECDHE Parameters
      title: 4.2.8.  Key Share
    - contents:
      - "4.2.9.  Pre-Shared Key Exchange Modes\n   In order to use PSKs, clients MUST
        also send a\n   \"psk_key_exchange_modes\" extension.  The semantics of this
        extension\n   are that the client only supports the use of PSKs with these
        modes,\n   which restricts both the use of PSKs offered in this ClientHello
        and\n   those which the server might supply via NewSessionTicket.\n   A client
        MUST provide a \"psk_key_exchange_modes\" extension if it\n   offers a \"pre_shared_key\"
        extension.  If clients offer\n   \"pre_shared_key\" without a \"psk_key_exchange_modes\"
        extension,\n   servers MUST abort the handshake.  Servers MUST NOT select
        a key\n   exchange mode that is not listed by the client.  This extension
        also\n   restricts the modes for use with PSK resumption.  Servers SHOULD
        NOT\n   send NewSessionTicket with tickets that are not compatible with the\n
        \  advertised modes; however, if a server does so, the impact will just\n
        \  be that the client's attempts at resumption fail.\n   The server MUST NOT
        send a \"psk_key_exchange_modes\" extension.\n      enum { psk_ke(0), psk_dhe_ke(1),
        (255) } PskKeyExchangeMode;\n      struct {\n          PskKeyExchangeMode
        ke_modes<1..255>;\n      } PskKeyExchangeModes;\n   psk_ke:  PSK-only key
        establishment.  In this mode, the server\n      MUST NOT supply a \"key_share\"
        value.\n   psk_dhe_ke:  PSK with (EC)DHE key establishment.  In this mode,
        the\n      client and server MUST supply \"key_share\" values as described
        in\n      Section 4.2.8.\n   Any future values that are allocated must ensure
        that the transmitted\n   protocol messages unambiguously identify which mode
        was selected by\n   the server; at present, this is indicated by the presence
        of the\n   \"key_share\" in the ServerHello.\n"
      title: 4.2.9.  Pre-Shared Key Exchange Modes
    - contents:
      - "4.2.10.  Early Data Indication\n   When a PSK is used and early data is allowed
        for that PSK, the client\n   can send Application Data in its first flight
        of messages.  If the\n   client opts to do so, it MUST supply both the \"pre_shared_key\"
        and\n   \"early_data\" extensions.\n   The \"extension_data\" field of this
        extension contains an\n   \"EarlyDataIndication\" value.\n      struct {}
        Empty;\n      struct {\n          select (Handshake.msg_type) {\n              case
        new_session_ticket:   uint32 max_early_data_size;\n              case client_hello:
        \        Empty;\n              case encrypted_extensions: Empty;\n          };\n
        \     } EarlyDataIndication;\n   See Section 4.6.1 for details regarding the
        use of the\n   max_early_data_size field.\n   The parameters for the 0-RTT
        data (version, symmetric cipher suite,\n   Application-Layer Protocol Negotiation
        (ALPN) [RFC7301] protocol,\n   etc.) are those associated with the PSK in
        use.  For externally\n   provisioned PSKs, the associated values are those
        provisioned along\n   with the key.  For PSKs established via a NewSessionTicket
        message,\n   the associated values are those which were negotiated in the\n
        \  connection which established the PSK.  The PSK used to encrypt the\n   early
        data MUST be the first PSK listed in the client's\n   \"pre_shared_key\" extension.\n
        \  For PSKs provisioned via NewSessionTicket, a server MUST validate\n   that
        the ticket age for the selected PSK identity (computed by\n   subtracting
        ticket_age_add from PskIdentity.obfuscated_ticket_age\n   modulo 2^32) is
        within a small tolerance of the time since the ticket\n   was issued (see
        Section 8).  If it is not, the server SHOULD proceed\n   with the handshake
        but reject 0-RTT, and SHOULD NOT take any other\n   action that assumes that
        this ClientHello is fresh.\n   0-RTT messages sent in the first flight have
        the same (encrypted)\n   content types as messages of the same type sent in
        other flights\n   (handshake and application_data) but are protected under
        different\n   keys.  After receiving the server's Finished message, if the
        server\n   has accepted early data, an EndOfEarlyData message will be sent
        to\n   indicate the key change.  This message will be encrypted with the\n
        \  0-RTT traffic keys.\n   A server which receives an \"early_data\" extension
        MUST behave in one\n   of three ways:\n   -  Ignore the extension and return
        a regular 1-RTT response.  The\n      server then skips past early data by
        attempting to deprotect\n      received records using the handshake traffic
        key, discarding\n      records which fail deprotection (up to the configured\n
        \     max_early_data_size).  Once a record is deprotected successfully,\n
        \     it is treated as the start of the client's second flight and the\n      server
        proceeds as with an ordinary 1-RTT handshake.\n   -  Request that the client
        send another ClientHello by responding\n      with a HelloRetryRequest.  A
        client MUST NOT include the\n      \"early_data\" extension in its followup
        ClientHello.  The server\n      then ignores early data by skipping all records
        with an external\n      content type of \"application_data\" (indicating that
        they are\n      encrypted), up to the configured max_early_data_size.\n   -
        \ Return its own \"early_data\" extension in EncryptedExtensions,\n      indicating
        that it intends to process the early data.  It is not\n      possible for
        the server to accept only a subset of the early data\n      messages.  Even
        though the server sends a message accepting early\n      data, the actual
        early data itself may already be in flight by the\n      time the server generates
        this message.\n   In order to accept early data, the server MUST have accepted
        a PSK\n   cipher suite and selected the first key offered in the client's\n
        \  \"pre_shared_key\" extension.  In addition, it MUST verify that the\n   following
        values are the same as those associated with the\n   selected PSK:\n   -  The
        TLS version number\n   -  The selected cipher suite\n   -  The selected ALPN
        [RFC7301] protocol, if any\n   These requirements are a superset of those
        needed to perform a 1-RTT\n   handshake using the PSK in question.  For externally
        established\n   PSKs, the associated values are those provisioned along with
        the key.\n   For PSKs established via a NewSessionTicket message, the associated\n
        \  values are those negotiated in the connection during which the ticket\n
        \  was established.\n   Future extensions MUST define their interaction with
        0-RTT.\n   If any of these checks fail, the server MUST NOT respond with the\n
        \  extension and must discard all the first-flight data using one of the\n
        \  first two mechanisms listed above (thus falling back to 1-RTT or\n   2-RTT).
        \ If the client attempts a 0-RTT handshake but the server\n   rejects it,
        the server will generally not have the 0-RTT record\n   protection keys and
        must instead use trial decryption (either with\n   the 1-RTT handshake keys
        or by looking for a cleartext ClientHello in\n   the case of a HelloRetryRequest)
        to find the first non-0-RTT message.\n   If the server chooses to accept the
        \"early_data\" extension, then it\n   MUST comply with the same error-handling
        requirements specified for\n   all records when processing early data records.
        \ Specifically, if the\n   server fails to decrypt a 0-RTT record following
        an accepted\n   \"early_data\" extension, it MUST terminate the connection
        with a\n   \"bad_record_mac\" alert as per Section 5.2.\n   If the server
        rejects the \"early_data\" extension, the client\n   application MAY opt to
        retransmit the Application Data previously\n   sent in early data once the
        handshake has been completed.  Note that\n   automatic retransmission of early
        data could result in incorrect\n   assumptions regarding the status of the
        connection.  For instance,\n   when the negotiated connection selects a different
        ALPN protocol from\n   what was used for the early data, an application might
        need to\n   construct different messages.  Similarly, if early data assumes\n
        \  anything about the connection state, it might be sent in error after\n
        \  the handshake completes.\n   A TLS implementation SHOULD NOT automatically
        resend early data;\n   applications are in a better position to decide when
        retransmission\n   is appropriate.  A TLS implementation MUST NOT automatically
        resend\n   early data unless the negotiated connection selects the same ALPN\n
        \  protocol.\n"
      title: 4.2.10.  Early Data Indication
    - contents:
      - "4.2.11.  Pre-Shared Key Extension\n   The \"pre_shared_key\" extension is
        used to negotiate the identity of\n   the pre-shared key to be used with a
        given handshake in association\n   with PSK key establishment.\n   The \"extension_data\"
        field of this extension contains a\n   \"PreSharedKeyExtension\" value:\n
        \     struct {\n          opaque identity<1..2^16-1>;\n          uint32 obfuscated_ticket_age;\n
        \     } PskIdentity;\n      opaque PskBinderEntry<32..255>;\n      struct
        {\n          PskIdentity identities<7..2^16-1>;\n          PskBinderEntry
        binders<33..2^16-1>;\n      } OfferedPsks;\n      struct {\n          select
        (Handshake.msg_type) {\n              case client_hello: OfferedPsks;\n              case
        server_hello: uint16 selected_identity;\n          };\n      } PreSharedKeyExtension;\n
        \  identity:  A label for a key.  For instance, a ticket (as defined in\n
        \     Appendix B.3.4) or a label for a pre-shared key established\n      externally.\n
        \  obfuscated_ticket_age:  An obfuscated version of the age of the key.\n
        \     Section 4.2.11.1 describes how to form this value for identities\n      established
        via the NewSessionTicket message.  For identities\n      established externally,
        an obfuscated_ticket_age of 0 SHOULD be\n      used, and servers MUST ignore
        the value.\n   identities:  A list of the identities that the client is willing
        to\n      negotiate with the server.  If sent alongside the \"early_data\"\n
        \     extension (see Section 4.2.10), the first identity is the one used\n
        \     for 0-RTT data.\n   binders:  A series of HMAC values, one for each
        value in the\n      identities list and in the same order, computed as described\n
        \     below.\n   selected_identity:  The server's chosen identity expressed
        as a\n      (0-based) index into the identities in the client's list.\n   Each
        PSK is associated with a single Hash algorithm.  For PSKs\n   established
        via the ticket mechanism (Section 4.6.1), this is the KDF\n   Hash algorithm
        on the connection where the ticket was established.\n   For externally established
        PSKs, the Hash algorithm MUST be set when\n   the PSK is established or default
        to SHA-256 if no such algorithm is\n   defined.  The server MUST ensure that
        it selects a compatible PSK\n   (if any) and cipher suite.\n   In TLS versions
        prior to TLS 1.3, the Server Name Identification\n   (SNI) value was intended
        to be associated with the session (Section 3\n   of [RFC6066]), with the server
        being required to enforce that the SNI\n   value associated with the session
        matches the one specified in the\n   resumption handshake.  However, in reality
        the implementations were\n   not consistent on which of two supplied SNI values
        they would use,\n   leading to the consistency requirement being de facto
        enforced by the\n   clients.  In TLS 1.3, the SNI value is always explicitly
        specified in\n   the resumption handshake, and there is no need for the server
        to\n   associate an SNI value with the ticket.  Clients, however, SHOULD\n
        \  store the SNI with the PSK to fulfill the requirements of\n   Section 4.6.1.\n
        \  Implementor's note: When session resumption is the primary use case\n   of
        PSKs, the most straightforward way to implement the PSK/cipher\n   suite matching
        requirements is to negotiate the cipher suite first\n   and then exclude any
        incompatible PSKs.  Any unknown PSKs (e.g., ones\n   not in the PSK database
        or encrypted with an unknown key) SHOULD\n   simply be ignored.  If no acceptable
        PSKs are found, the server\n   SHOULD perform a non-PSK handshake if possible.
        \ If backward\n   compatibility is important, client-provided, externally
        established\n   PSKs SHOULD influence cipher suite selection.\n   Prior to
        accepting PSK key establishment, the server MUST validate\n   the corresponding
        binder value (see Section 4.2.11.2 below).  If this\n   value is not present
        or does not validate, the server MUST abort the\n   handshake.  Servers SHOULD
        NOT attempt to validate multiple binders;\n   rather, they SHOULD select a
        single PSK and validate solely the\n   binder that corresponds to that PSK.
        \ See Section 8.2 and\n   Appendix E.6 for the security rationale for this
        requirement.  In\n   order to accept PSK key establishment, the server sends
        a\n   \"pre_shared_key\" extension indicating the selected identity.\n   Clients
        MUST verify that the server's selected_identity is within the\n   range supplied
        by the client, that the server selected a cipher suite\n   indicating a Hash
        associated with the PSK, and that a server\n   \"key_share\" extension is
        present if required by the ClientHello\n   \"psk_key_exchange_modes\" extension.
        \ If these values are not\n   consistent, the client MUST abort the handshake
        with an\n   \"illegal_parameter\" alert.\n   If the server supplies an \"early_data\"
        extension, the client MUST\n   verify that the server's selected_identity
        is 0.  If any other value\n   is returned, the client MUST abort the handshake
        with an\n   \"illegal_parameter\" alert.\n   The \"pre_shared_key\" extension
        MUST be the last extension in the\n   ClientHello (this facilitates implementation
        as described below).\n   Servers MUST check that it is the last extension
        and otherwise fail\n   the handshake with an \"illegal_parameter\" alert.\n"
      - contents:
        - "4.2.11.1.  Ticket Age\n   The client's view of the age of a ticket is the
          time since the\n   receipt of the NewSessionTicket message.  Clients MUST
          NOT attempt to\n   use tickets which have ages greater than the \"ticket_lifetime\"
          value\n   which was provided with the ticket.  The \"obfuscated_ticket_age\"\n
          \  field of each PskIdentity contains an obfuscated version of the\n   ticket
          age formed by taking the age in milliseconds and adding the\n   \"ticket_age_add\"
          value that was included with the ticket (see\n   Section 4.6.1), modulo
          2^32.  This addition prevents passive\n   observers from correlating connections
          unless tickets are reused.\n   Note that the \"ticket_lifetime\" field in
          the NewSessionTicket message\n   is in seconds but the \"obfuscated_ticket_age\"
          is in milliseconds.\n   Because ticket lifetimes are restricted to a week,
          32 bits is enough\n   to represent any plausible age, even in milliseconds.\n"
        title: 4.2.11.1.  Ticket Age
      - contents:
        - "4.2.11.2.  PSK Binder\n   The PSK binder value forms a binding between
          a PSK and the current\n   handshake, as well as a binding between the handshake
          in which the\n   PSK was generated (if via a NewSessionTicket message) and
          the current\n   handshake.  Each entry in the binders list is computed as
          an HMAC\n   over a transcript hash (see Section 4.4.1) containing a partial\n
          \  ClientHello up to and including the PreSharedKeyExtension.identities\n
          \  field.  That is, it includes all of the ClientHello but not the\n   binders
          list itself.  The length fields for the message (including\n   the overall
          length, the length of the extensions block, and the\n   length of the \"pre_shared_key\"
          extension) are all set as if binders\n   of the correct lengths were present.\n
          \  The PskBinderEntry is computed in the same way as the Finished\n   message
          (Section 4.4.4) but with the BaseKey being the binder_key\n   derived via
          the key schedule from the corresponding PSK which is\n   being offered (see
          Section 7.1).\n   If the handshake includes a HelloRetryRequest, the initial\n
          \  ClientHello and HelloRetryRequest are included in the transcript\n   along
          with the new ClientHello.  For instance, if the client sends\n   ClientHello1,
          its binder will be computed over:\n      Transcript-Hash(Truncate(ClientHello1))\n
          \  Where Truncate() removes the binders list from the ClientHello.\n   If
          the server responds with a HelloRetryRequest and the client then\n   sends
          ClientHello2, its binder will be computed over:\n      Transcript-Hash(ClientHello1,\n
          \                     HelloRetryRequest,\n                      Truncate(ClientHello2))\n
          \  The full ClientHello1/ClientHello2 is included in all other handshake\n
          \  hash computations.  Note that in the first flight,\n   Truncate(ClientHello1)
          is hashed directly, but in the second flight,\n   ClientHello1 is hashed
          and then reinjected as a \"message_hash\"\n   message, as described in Section
          4.4.1.\n"
        title: 4.2.11.2.  PSK Binder
      - contents:
        - "4.2.11.3.  Processing Order\n   Clients are permitted to \"stream\" 0-RTT
          data until they receive the\n   server's Finished, only then sending the
          EndOfEarlyData message,\n   followed by the rest of the handshake.  In order
          to avoid deadlocks,\n   when accepting \"early_data\", servers MUST process
          the client's\n   ClientHello and then immediately send their flight of messages,\n
          \  rather than waiting for the client's EndOfEarlyData message before\n
          \  sending its ServerHello.\n"
        title: 4.2.11.3.  Processing Order
      title: 4.2.11.  Pre-Shared Key Extension
    title: 4.2.  Extensions
  - contents:
    - "4.3.  Server Parameters\n   The next two messages from the server, EncryptedExtensions
      and\n   CertificateRequest, contain information from the server that\n   determines
      the rest of the handshake.  These messages are encrypted\n   with keys derived
      from the server_handshake_traffic_secret.\n"
    - contents:
      - "4.3.1.  Encrypted Extensions\n   In all handshakes, the server MUST send
        the EncryptedExtensions\n   message immediately after the ServerHello message.
        \ This is the first\n   message that is encrypted under keys derived from
        the\n   server_handshake_traffic_secret.\n   The EncryptedExtensions message
        contains extensions that can be\n   protected, i.e., any which are not needed
        to establish the\n   cryptographic context but which are not associated with
        individual\n   certificates.  The client MUST check EncryptedExtensions for
        the\n   presence of any forbidden extensions and if any are found MUST abort\n
        \  the handshake with an \"illegal_parameter\" alert.\n   Structure of this
        message:\n      struct {\n          Extension extensions<0..2^16-1>;\n      }
        EncryptedExtensions;\n   extensions:  A list of extensions.  For more information,
        see the\n      table in Section 4.2.\n"
      title: 4.3.1.  Encrypted Extensions
    - contents:
      - "4.3.2.  Certificate Request\n   A server which is authenticating with a certificate
        MAY optionally\n   request a certificate from the client.  This message, if
        sent, MUST\n   follow EncryptedExtensions.\n   Structure of this message:\n
        \     struct {\n          opaque certificate_request_context<0..2^8-1>;\n
        \         Extension extensions<2..2^16-1>;\n      } CertificateRequest;\n
        \  certificate_request_context:  An opaque string which identifies the\n      certificate
        request and which will be echoed in the client's\n      Certificate message.
        \ The certificate_request_context MUST be\n      unique within the scope of
        this connection (thus preventing replay\n      of client CertificateVerify
        messages).  This field SHALL be zero\n      length unless used for the post-handshake
        authentication exchanges\n      described in Section 4.6.2.  When requesting
        post-handshake\n      authentication, the server SHOULD make the context unpredictable\n
        \     to the client (e.g., by randomly generating it) in order to\n      prevent
        an attacker who has temporary access to the client's\n      private key from
        pre-computing valid CertificateVerify messages.\n   extensions:  A set of
        extensions describing the parameters of the\n      certificate being requested.
        \ The \"signature_algorithms\" extension\n      MUST be specified, and other
        extensions may optionally be included\n      if defined for this message.
        \ Clients MUST ignore unrecognized\n      extensions.\n   In prior versions
        of TLS, the CertificateRequest message carried a\n   list of signature algorithms
        and certificate authorities which the\n   server would accept.  In TLS 1.3,
        the former is expressed by sending\n   the \"signature_algorithms\" and optionally
        \"signature_algorithms_cert\"\n   extensions.  The latter is expressed by
        sending the\n   \"certificate_authorities\" extension (see Section 4.2.4).\n
        \  Servers which are authenticating with a PSK MUST NOT send the\n   CertificateRequest
        message in the main handshake, though they MAY\n   send it in post-handshake
        authentication (see Section 4.6.2) provided\n   that the client has sent the
        \"post_handshake_auth\" extension (see\n   Section 4.2.6).\n"
      title: 4.3.2.  Certificate Request
    title: 4.3.  Server Parameters
  - contents:
    - "4.4.  Authentication Messages\n   As discussed in Section 2, TLS generally
      uses a common set of\n   messages for authentication, key confirmation, and
      handshake\n   integrity: Certificate, CertificateVerify, and Finished.  (The
      PSK\n   binders also perform key confirmation, in a similar fashion.)  These\n
      \  three messages are always sent as the last messages in their\n   handshake
      flight.  The Certificate and CertificateVerify messages are\n   only sent under
      certain circumstances, as defined below.  The\n   Finished message is always
      sent as part of the Authentication Block.\n   These messages are encrypted under
      keys derived from the\n   [sender]_handshake_traffic_secret.\n   The computations
      for the Authentication messages all uniformly take\n   the following inputs:\n
      \  -  The certificate and signing key to be used.\n   -  A Handshake Context
      consisting of the set of messages to be\n      included in the transcript hash.\n
      \  -  A Base Key to be used to compute a MAC key.\n   Based on these inputs,
      the messages then contain:\n   Certificate:  The certificate to be used for
      authentication, and any\n      supporting certificates in the chain.  Note that
      certificate-based\n      client authentication is not available in PSK handshake
      flows\n      (including 0-RTT).\n   CertificateVerify:  A signature over the
      value\n      Transcript-Hash(Handshake Context, Certificate).\n   Finished:
      \ A MAC over the value Transcript-Hash(Handshake Context,\n      Certificate,
      CertificateVerify) using a MAC key derived from the\n      Base Key.\n   The
      following table defines the Handshake Context and MAC Base Key\n   for each
      scenario:\n   +-----------+-------------------------+-----------------------------+\n
      \  | Mode      | Handshake Context       | Base Key                    |\n   +-----------+-------------------------+-----------------------------+\n
      \  | Server    | ClientHello ... later   | server_handshake_traffic_   |\n   |
      \          | of EncryptedExtensions/ | secret                      |\n   |           |
      CertificateRequest      |                             |\n   |           |                         |
      \                            |\n   | Client    | ClientHello ... later   | client_handshake_traffic_
      \  |\n   |           | of server               | secret                      |\n
      \  |           | Finished/EndOfEarlyData |                             |\n   |
      \          |                         |                             |\n   | Post-
      \    | ClientHello ... client  | client_application_traffic_ |\n   | Handshake
      | Finished +              | secret_N                    |\n   |           |
      CertificateRequest      |                             |\n   +-----------+-------------------------+-----------------------------+\n"
    - contents:
      - "4.4.1.  The Transcript Hash\n   Many of the cryptographic computations in
        TLS make use of a\n   transcript hash.  This value is computed by hashing
        the concatenation\n   of each included handshake message, including the handshake
        message\n   header carrying the handshake message type and length fields,
        but not\n   including record layer headers.  I.e.,\n    Transcript-Hash(M1,
        M2, ... Mn) = Hash(M1 || M2 || ... || Mn)\n   As an exception to this general
        rule, when the server responds to a\n   ClientHello with a HelloRetryRequest,
        the value of ClientHello1 is\n   replaced with a special synthetic handshake
        message of handshake type\n   \"message_hash\" containing Hash(ClientHello1).
        \ I.e.,\n  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =\n      Hash(message_hash
        ||        /* Handshake type */\n           00 00 Hash.length  ||  /* Handshake
        message length (bytes) */\n           Hash(ClientHello1) ||  /* Hash of ClientHello1
        */\n           HelloRetryRequest  || ... || Mn)\n   The reason for this construction
        is to allow the server to do a\n   stateless HelloRetryRequest by storing
        just the hash of ClientHello1\n   in the cookie, rather than requiring it
        to export the entire\n   intermediate hash state (see Section 4.2.2).\n   For
        concreteness, the transcript hash is always taken from the\n   following sequence
        of handshake messages, starting at the first\n   ClientHello and including
        only those messages that were sent:\n   ClientHello, HelloRetryRequest, ClientHello,
        ServerHello,\n   EncryptedExtensions, server CertificateRequest, server Certificate,\n
        \  server CertificateVerify, server Finished, EndOfEarlyData, client\n   Certificate,
        client CertificateVerify, client Finished.\n   In general, implementations
        can implement the transcript by keeping a\n   running transcript hash value
        based on the negotiated hash.  Note,\n   however, that subsequent post-handshake
        authentications do not\n   include each other, just the messages through the
        end of the main\n   handshake.\n"
      title: 4.4.1.  The Transcript Hash
    - contents:
      - "4.4.2.  Certificate\n   This message conveys the endpoint's certificate chain
        to the peer.\n   The server MUST send a Certificate message whenever the agreed-upon\n
        \  key exchange method uses certificates for authentication (this\n   includes
        all key exchange methods defined in this document\n   except PSK).\n   The
        client MUST send a Certificate message if and only if the server\n   has requested
        client authentication via a CertificateRequest message\n   (Section 4.3.2).
        \ If the server requests client authentication but no\n   suitable certificate
        is available, the client MUST send a Certificate\n   message containing no
        certificates (i.e., with the \"certificate_list\"\n   field having length
        0).  A Finished message MUST be sent regardless\n   of whether the Certificate
        message is empty.\n   Structure of this message:\n      enum {\n          X509(0),\n
        \         RawPublicKey(2),\n          (255)\n      } CertificateType;\n      struct
        {\n          select (certificate_type) {\n              case RawPublicKey:\n
        \               /* From RFC 7250 ASN.1_subjectPublicKeyInfo */\n                opaque
        ASN1_subjectPublicKeyInfo<1..2^24-1>;\n              case X509:\n                opaque
        cert_data<1..2^24-1>;\n          };\n          Extension extensions<0..2^16-1>;\n
        \     } CertificateEntry;\n      struct {\n          opaque certificate_request_context<0..2^8-1>;\n
        \         CertificateEntry certificate_list<0..2^24-1>;\n      } Certificate;\n
        \  certificate_request_context:  If this message is in response to a\n      CertificateRequest,
        the value of certificate_request_context in\n      that message.  Otherwise
        (in the case of server authentication),\n      this field SHALL be zero length.\n
        \  certificate_list:  A sequence (chain) of CertificateEntry structures,\n
        \     each containing a single certificate and set of extensions.\n   extensions:
        \ A set of extension values for the CertificateEntry.  The\n      \"Extension\"
        format is defined in Section 4.2.  Valid extensions\n      for server certificates
        at present include the OCSP Status\n      extension [RFC6066] and the SignedCertificateTimestamp
        extension\n      [RFC6962]; future extensions may be defined for this message
        as\n      well.  Extensions in the Certificate message from the server MUST\n
        \     correspond to ones from the ClientHello message.  Extensions in\n      the
        Certificate message from the client MUST correspond to\n      extensions in
        the CertificateRequest message from the server.  If\n      an extension applies
        to the entire chain, it SHOULD be included in\n      the first CertificateEntry.\n
        \  If the corresponding certificate type extension\n   (\"server_certificate_type\"
        or \"client_certificate_type\") was not\n   negotiated in EncryptedExtensions,
        or the X.509 certificate type was\n   negotiated, then each CertificateEntry
        contains a DER-encoded X.509\n   certificate.  The sender's certificate MUST
        come in the first\n   CertificateEntry in the list.  Each following certificate
        SHOULD\n   directly certify the one immediately preceding it.  Because\n   certificate
        validation requires that trust anchors be distributed\n   independently, a
        certificate that specifies a trust anchor MAY be\n   omitted from the chain,
        provided that supported peers are known to\n   possess any omitted certificates.\n
        \  Note: Prior to TLS 1.3, \"certificate_list\" ordering required each\n   certificate
        to certify the one immediately preceding it; however,\n   some implementations
        allowed some flexibility.  Servers sometimes\n   send both a current and deprecated
        intermediate for transitional\n   purposes, and others are simply configured
        incorrectly, but these\n   cases can nonetheless be validated properly.  For
        maximum\n   compatibility, all implementations SHOULD be prepared to handle\n
        \  potentially extraneous certificates and arbitrary orderings from any\n
        \  TLS version, with the exception of the end-entity certificate which\n   MUST
        be first.\n   If the RawPublicKey certificate type was negotiated, then the\n
        \  certificate_list MUST contain no more than one CertificateEntry,\n   which
        contains an ASN1_subjectPublicKeyInfo value as defined in\n   [RFC7250], Section
        3.\n   The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.\n
        \  The server's certificate_list MUST always be non-empty.  A client\n   will
        send an empty certificate_list if it does not have an\n   appropriate certificate
        to send in response to the server's\n   authentication request.\n"
      - contents:
        - "4.4.2.1.  OCSP Status and SCT Extensions\n   [RFC6066] and [RFC6961] provide
          extensions to negotiate the server\n   sending OCSP responses to the client.
          \ In TLS 1.2 and below, the\n   server replies with an empty extension to
          indicate negotiation of\n   this extension and the OCSP information is carried
          in a\n   CertificateStatus message.  In TLS 1.3, the server's OCSP information\n
          \  is carried in an extension in the CertificateEntry containing the\n   associated
          certificate.  Specifically, the body of the\n   \"status_request\" extension
          from the server MUST be a\n   CertificateStatus structure as defined in
          [RFC6066], which is\n   interpreted as defined in [RFC6960].\n   Note: The
          status_request_v2 extension [RFC6961] is deprecated.\n   TLS 1.3 servers
          MUST NOT act upon its presence or information in it\n   when processing
          ClientHello messages; in particular, they MUST NOT\n   send the status_request_v2
          extension in the EncryptedExtensions,\n   CertificateRequest, or Certificate
          messages.  TLS 1.3 servers MUST be\n   able to process ClientHello messages
          that include it, as it MAY be\n   sent by clients that wish to use it in
          earlier protocol versions.\n   A server MAY request that a client present
          an OCSP response with its\n   certificate by sending an empty \"status_request\"
          extension in its\n   CertificateRequest message.  If the client opts to
          send an OCSP\n   response, the body of its \"status_request\" extension
          MUST be a\n   CertificateStatus structure as defined in [RFC6066].\n   Similarly,
          [RFC6962] provides a mechanism for a server to send a\n   Signed Certificate
          Timestamp (SCT) as an extension in the ServerHello\n   in TLS 1.2 and below.
          \ In TLS 1.3, the server's SCT information is\n   carried in an extension
          in the CertificateEntry.\n"
        title: 4.4.2.1.  OCSP Status and SCT Extensions
      - contents:
        - "4.4.2.2.  Server Certificate Selection\n   The following rules apply to
          the certificates sent by the server:\n   -  The certificate type MUST be
          X.509v3 [RFC5280], unless explicitly\n      negotiated otherwise (e.g.,
          [RFC7250]).\n   -  The server's end-entity certificate's public key (and
          associated\n      restrictions) MUST be compatible with the selected authentication\n
          \     algorithm from the client's \"signature_algorithms\" extension\n      (currently
          RSA, ECDSA, or EdDSA).\n   -  The certificate MUST allow the key to be used
          for signing (i.e.,\n      the digitalSignature bit MUST be set if the Key
          Usage extension is\n      present) with a signature scheme indicated in
          the client's\n      \"signature_algorithms\"/\"signature_algorithms_cert\"
          extensions (see\n      Section 4.2.3).\n   -  The \"server_name\" [RFC6066]
          and \"certificate_authorities\"\n      extensions are used to guide certificate
          selection.  As servers\n      MAY require the presence of the \"server_name\"
          extension, clients\n      SHOULD send this extension, when applicable.\n
          \  All certificates provided by the server MUST be signed by a signature\n
          \  algorithm advertised by the client if it is able to provide such a\n
          \  chain (see Section 4.2.3).  Certificates that are self-signed or\n   certificates
          that are expected to be trust anchors are not validated\n   as part of the
          chain and therefore MAY be signed with any algorithm.\n   If the server
          cannot produce a certificate chain that is signed only\n   via the indicated
          supported algorithms, then it SHOULD continue the\n   handshake by sending
          the client a certificate chain of its choice\n   that may include algorithms
          that are not known to be supported by the\n   client.  This fallback chain
          SHOULD NOT use the deprecated SHA-1 hash\n   algorithm in general, but MAY
          do so if the client's advertisement\n   permits it, and MUST NOT do so otherwise.\n
          \  If the client cannot construct an acceptable chain using the provided\n
          \  certificates and decides to abort the handshake, then it MUST abort\n
          \  the handshake with an appropriate certificate-related alert (by\n   default,
          \"unsupported_certificate\"; see Section 6.2 for more\n   information).\n
          \  If the server has multiple certificates, it chooses one of them based\n
          \  on the above-mentioned criteria (in addition to other criteria, such\n
          \  as transport-layer endpoint, local configuration, and preferences).\n"
        title: 4.4.2.2.  Server Certificate Selection
      - contents:
        - "4.4.2.3.  Client Certificate Selection\n   The following rules apply to
          certificates sent by the client:\n   -  The certificate type MUST be X.509v3
          [RFC5280], unless explicitly\n      negotiated otherwise (e.g., [RFC7250]).\n
          \  -  If the \"certificate_authorities\" extension in the\n      CertificateRequest
          message was present, at least one of the\n      certificates in the certificate
          chain SHOULD be issued by one of\n      the listed CAs.\n   -  The certificates
          MUST be signed using an acceptable signature\n      algorithm, as described
          in Section 4.3.2.  Note that this relaxes\n      the constraints on certificate-signing
          algorithms found in prior\n      versions of TLS.\n   -  If the CertificateRequest
          message contained a non-empty\n      \"oid_filters\" extension, the end-entity
          certificate MUST match the\n      extension OIDs that are recognized by
          the client, as described in\n      Section 4.2.5.\n"
        title: 4.4.2.3.  Client Certificate Selection
      - contents:
        - "4.4.2.4.  Receiving a Certificate Message\n   In general, detailed certificate
          validation procedures are out of\n   scope for TLS (see [RFC5280]).  This
          section provides TLS-specific\n   requirements.\n   If the server supplies
          an empty Certificate message, the client MUST\n   abort the handshake with
          a \"decode_error\" alert.\n   If the client does not send any certificates
          (i.e., it sends an empty\n   Certificate message), the server MAY at its
          discretion either\n   continue the handshake without client authentication
          or abort the\n   handshake with a \"certificate_required\" alert.  Also,
          if some aspect\n   of the certificate chain was unacceptable (e.g., it was
          not signed by\n   a known, trusted CA), the server MAY at its discretion
          either\n   continue the handshake (considering the client unauthenticated)
          or\n   abort the handshake.\n   Any endpoint receiving any certificate which
          it would need to\n   validate using any signature algorithm using an MD5
          hash MUST abort\n   the handshake with a \"bad_certificate\" alert.  SHA-1
          is deprecated,\n   and it is RECOMMENDED that any endpoint receiving any
          certificate\n   which it would need to validate using any signature algorithm
          using a\n   SHA-1 hash abort the handshake with a \"bad_certificate\" alert.
          \ For\n   clarity, this means that endpoints can accept these algorithms
          for\n   certificates that are self-signed or are trust anchors.\n   All
          endpoints are RECOMMENDED to transition to SHA-256 or better as\n   soon
          as possible to maintain interoperability with implementations\n   currently
          in the process of phasing out SHA-1 support.\n   Note that a certificate
          containing a key for one signature algorithm\n   MAY be signed using a different
          signature algorithm (for instance, an\n   RSA key signed with an ECDSA key).\n"
        title: 4.4.2.4.  Receiving a Certificate Message
      title: 4.4.2.  Certificate
    - contents:
      - "4.4.3.  Certificate Verify\n   This message is used to provide explicit proof
        that an endpoint\n   possesses the private key corresponding to its certificate.
        \ The\n   CertificateVerify message also provides integrity for the handshake\n
        \  up to this point.  Servers MUST send this message when authenticating\n
        \  via a certificate.  Clients MUST send this message whenever\n   authenticating
        via a certificate (i.e., when the Certificate message\n   is non-empty).  When
        sent, this message MUST appear immediately after\n   the Certificate message
        and immediately prior to the Finished\n   message.\n   Structure of this message:\n
        \     struct {\n          SignatureScheme algorithm;\n          opaque signature<0..2^16-1>;\n
        \     } CertificateVerify;\n   The algorithm field specifies the signature
        algorithm used (see\n   Section 4.2.3 for the definition of this type).  The
        signature is a\n   digital signature using that algorithm.  The content that
        is covered\n   under the signature is the hash output as described in Section
        4.4.1,\n   namely:\n      Transcript-Hash(Handshake Context, Certificate)\n
        \  The digital signature is then computed over the concatenation of:\n   -
        \ A string that consists of octet 32 (0x20) repeated 64 times\n   -  The context
        string\n   -  A single 0 byte which serves as the separator\n   -  The content
        to be signed\n   This structure is intended to prevent an attack on previous
        versions\n   of TLS in which the ServerKeyExchange format meant that attackers\n
        \  could obtain a signature of a message with a chosen 32-byte prefix\n   (ClientHello.random).
        \ The initial 64-byte pad clears that prefix\n   along with the server-controlled
        ServerHello.random.\n   The context string for a server signature is\n   \"TLS
        1.3, server CertificateVerify\".  The context string for a\n   client signature
        is \"TLS 1.3, client CertificateVerify\".  It is\n   used to provide separation
        between signatures made in different\n   contexts, helping against potential
        cross-protocol attacks.\n   For example, if the transcript hash was 32 bytes
        of 01 (this length\n   would make sense for SHA-256), the content covered
        by the digital\n   signature for a server CertificateVerify would be:\n      2020202020202020202020202020202020202020202020202020202020202020\n
        \     2020202020202020202020202020202020202020202020202020202020202020\n      544c5320312e332c207365727665722043657274696669636174655665726966\n
        \     79\n      00\n      0101010101010101010101010101010101010101010101010101010101010101\n
        \  On the sender side, the process for computing the signature field of\n
        \  the CertificateVerify message takes as input:\n   -  The content covered
        by the digital signature\n   -  The private signing key corresponding to the
        certificate sent in\n      the previous message\n   If the CertificateVerify
        message is sent by a server, the signature\n   algorithm MUST be one offered
        in the client's \"signature_algorithms\"\n   extension unless no valid certificate
        chain can be produced without\n   unsupported algorithms (see Section 4.2.3).\n
        \  If sent by a client, the signature algorithm used in the signature\n   MUST
        be one of those present in the supported_signature_algorithms\n   field of
        the \"signature_algorithms\" extension in the\n   CertificateRequest message.\n
        \  In addition, the signature algorithm MUST be compatible with the key\n
        \  in the sender's end-entity certificate.  RSA signatures MUST use an\n   RSASSA-PSS
        algorithm, regardless of whether RSASSA-PKCS1-v1_5\n   algorithms appear in
        \"signature_algorithms\".  The SHA-1 algorithm\n   MUST NOT be used in any
        signatures of CertificateVerify messages.\n   All SHA-1 signature algorithms
        in this specification are defined\n   solely for use in legacy certificates
        and are not valid for\n   CertificateVerify signatures.\n   The receiver of
        a CertificateVerify message MUST verify the signature\n   field.  The verification
        process takes as input:\n   -  The content covered by the digital signature\n
        \  -  The public key contained in the end-entity certificate found in\n      the
        associated Certificate message\n   -  The digital signature received in the
        signature field of the\n      CertificateVerify message\n   If the verification
        fails, the receiver MUST terminate the handshake\n   with a \"decrypt_error\"
        alert.\n"
      title: 4.4.3.  Certificate Verify
    - contents:
      - "4.4.4.  Finished\n   The Finished message is the final message in the Authentication\n
        \  Block.  It is essential for providing authentication of the handshake\n
        \  and of the computed keys.\n   Recipients of Finished messages MUST verify
        that the contents are\n   correct and if incorrect MUST terminate the connection
        with a\n   \"decrypt_error\" alert.\n   Once a side has sent its Finished
        message and has received and\n   validated the Finished message from its peer,
        it may begin to send\n   and receive Application Data over the connection.
        \ There are two\n   settings in which it is permitted to send data prior to
        receiving the\n   peer's Finished:\n   1.  Clients sending 0-RTT data as described
        in Section 4.2.10.\n   2.  Servers MAY send data after sending their first
        flight, but\n       because the handshake is not yet complete, they have no
        assurance\n       of either the peer's identity or its liveness (i.e., the\n
        \      ClientHello might have been replayed).\n   The key used to compute
        the Finished message is computed from the\n   Base Key defined in Section
        4.4 using HKDF (see Section 7.1).\n   Specifically:\n   finished_key =\n       HKDF-Expand-Label(BaseKey,
        \"finished\", \"\", Hash.length)\n   Structure of this message:\n      struct
        {\n          opaque verify_data[Hash.length];\n      } Finished;\n   The verify_data
        value is computed as follows:\n      verify_data =\n          HMAC(finished_key,\n
        \              Transcript-Hash(Handshake Context,\n                               Certificate*,
        CertificateVerify*))\n      * Only included if present.\n   HMAC [RFC2104]
        uses the Hash algorithm for the handshake.  As noted\n   above, the HMAC input
        can generally be implemented by a running hash,\n   i.e., just the handshake
        hash at this point.\n   In previous versions of TLS, the verify_data was always
        12 octets\n   long.  In TLS 1.3, it is the size of the HMAC output for the
        Hash\n   used for the handshake.\n   Note: Alerts and any other non-handshake
        record types are not\n   handshake messages and are not included in the hash
        computations.\n   Any records following a Finished message MUST be encrypted
        under the\n   appropriate application traffic key as described in Section
        7.2.  In\n   particular, this includes any alerts sent by the server in response\n
        \  to client Certificate and CertificateVerify messages.\n"
      title: 4.4.4.  Finished
    title: 4.4.  Authentication Messages
  - contents:
    - "4.5.  End of Early Data\n      struct {} EndOfEarlyData;\n   If the server
      sent an \"early_data\" extension in EncryptedExtensions,\n   the client MUST
      send an EndOfEarlyData message after receiving the\n   server Finished.  If
      the server does not send an \"early_data\"\n   extension in EncryptedExtensions,
      then the client MUST NOT send an\n   EndOfEarlyData message.  This message indicates
      that all 0-RTT\n   application_data messages, if any, have been transmitted
      and that the\n   following records are protected under handshake traffic keys.\n
      \  Servers MUST NOT send this message, and clients receiving it MUST\n   terminate
      the connection with an \"unexpected_message\" alert.  This\n   message is encrypted
      under keys derived from the\n   client_early_traffic_secret.\n"
    title: 4.5.  End of Early Data
  - contents:
    - "4.6.  Post-Handshake Messages\n   TLS also allows other messages to be sent
      after the main handshake.\n   These messages use a handshake content type and
      are encrypted under\n   the appropriate application traffic key.\n"
    - contents:
      - "4.6.1.  New Session Ticket Message\n   At any time after the server has received
        the client Finished\n   message, it MAY send a NewSessionTicket message.  This
        message\n   creates a unique association between the ticket value and a secret\n
        \  PSK derived from the resumption master secret (see Section 7).\n   The
        client MAY use this PSK for future handshakes by including the\n   ticket
        value in the \"pre_shared_key\" extension in its ClientHello\n   (Section
        4.2.11).  Servers MAY send multiple tickets on a single\n   connection, either
        immediately after each other or after specific\n   events (see Appendix C.4).
        \ For instance, the server might send a new\n   ticket after post-handshake
        authentication in order to encapsulate\n   the additional client authentication
        state.  Multiple tickets are\n   useful for clients for a variety of purposes,
        including:\n   -  Opening multiple parallel HTTP connections.\n   -  Performing
        connection racing across interfaces and address\n      families via (for example)
        Happy Eyeballs [RFC8305] or related\n      techniques.\n   Any ticket MUST
        only be resumed with a cipher suite that has the same\n   KDF hash algorithm
        as that used to establish the original connection.\n   Clients MUST only resume
        if the new SNI value is valid for the server\n   certificate presented in
        the original session and SHOULD only resume\n   if the SNI value matches the
        one used in the original session.  The\n   latter is a performance optimization:
        normally, there is no reason to\n   expect that different servers covered
        by a single certificate would\n   be able to accept each other's tickets;
        hence, attempting resumption\n   in that case would waste a single-use ticket.
        \ If such an indication\n   is provided (externally or by any other means),
        clients MAY resume\n   with a different SNI value.\n   On resumption, if reporting
        an SNI value to the calling application,\n   implementations MUST use the
        value sent in the resumption ClientHello\n   rather than the value sent in
        the previous session.  Note that if a\n   server implementation declines all
        PSK identities with different SNI\n   values, these two values are always
        the same.\n   Note: Although the resumption master secret depends on the client's\n
        \  second flight, a server which does not request client authentication\n
        \  MAY compute the remainder of the transcript independently and then\n   send
        a NewSessionTicket immediately upon sending its Finished rather\n   than waiting
        for the client Finished.  This might be appropriate in\n   cases where the
        client is expected to open multiple TLS connections\n   in parallel and would
        benefit from the reduced overhead of a\n   resumption handshake, for example.\n
        \     struct {\n          uint32 ticket_lifetime;\n          uint32 ticket_age_add;\n
        \         opaque ticket_nonce<0..255>;\n          opaque ticket<1..2^16-1>;\n
        \         Extension extensions<0..2^16-2>;\n      } NewSessionTicket;\n   ticket_lifetime:
        \ Indicates the lifetime in seconds as a 32-bit\n      unsigned integer in
        network byte order from the time of ticket\n      issuance.  Servers MUST
        NOT use any value greater than\n      604800 seconds (7 days).  The value
        of zero indicates that the\n      ticket should be discarded immediately.
        \ Clients MUST NOT cache\n      tickets for longer than 7 days, regardless
        of the ticket_lifetime,\n      and MAY delete tickets earlier based on local
        policy.  A server\n      MAY treat a ticket as valid for a shorter period
        of time than what\n      is stated in the ticket_lifetime.\n   ticket_age_add:
        \ A securely generated, random 32-bit value that is\n      used to obscure
        the age of the ticket that the client includes in\n      the \"pre_shared_key\"
        extension.  The client-side ticket age is\n      added to this value modulo
        2^32 to obtain the value that is\n      transmitted by the client.  The server
        MUST generate a fresh value\n      for each ticket it sends.\n   ticket_nonce:
        \ A per-ticket value that is unique across all tickets\n      issued on this
        connection.\n   ticket:  The value of the ticket to be used as the PSK identity.
        \ The\n      ticket itself is an opaque label.  It MAY be either a database\n
        \     lookup key or a self-encrypted and self-authenticated value.\n   extensions:
        \ A set of extension values for the ticket.  The\n      \"Extension\" format
        is defined in Section 4.2.  Clients MUST ignore\n      unrecognized extensions.\n
        \  The sole extension currently defined for NewSessionTicket is\n   \"early_data\",
        indicating that the ticket may be used to send 0-RTT\n   data (Section 4.2.10).
        \ It contains the following value:\n   max_early_data_size:  The maximum amount
        of 0-RTT data that the\n      client is allowed to send when using this ticket,
        in bytes.  Only\n      Application Data payload (i.e., plaintext but not padding
        or the\n      inner content type byte) is counted.  A server receiving more
        than\n      max_early_data_size bytes of 0-RTT data SHOULD terminate the\n
        \     connection with an \"unexpected_message\" alert.  Note that servers\n
        \     that reject early data due to lack of cryptographic material will\n
        \     be unable to differentiate padding from content, so clients\n      SHOULD
        NOT depend on being able to send large quantities of\n      padding in early
        data records.\n   The PSK associated with the ticket is computed as:\n       HKDF-Expand-Label(resumption_master_secret,\n
        \                       \"resumption\", ticket_nonce, Hash.length)\n   Because
        the ticket_nonce value is distinct for each NewSessionTicket\n   message,
        a different PSK will be derived for each ticket.\n   Note that in principle
        it is possible to continue issuing new tickets\n   which indefinitely extend
        the lifetime of the keying material\n   originally derived from an initial
        non-PSK handshake (which was most\n   likely tied to the peer's certificate).
        \ It is RECOMMENDED that\n   implementations place limits on the total lifetime
        of such keying\n   material; these limits should take into account the lifetime
        of the\n   peer's certificate, the likelihood of intervening revocation, and
        the\n   time since the peer's online CertificateVerify signature.\n"
      title: 4.6.1.  New Session Ticket Message
    - contents:
      - "4.6.2.  Post-Handshake Authentication\n   When the client has sent the \"post_handshake_auth\"
        extension (see\n   Section 4.2.6), a server MAY request client authentication
        at any\n   time after the handshake has completed by sending a\n   CertificateRequest
        message.  The client MUST respond with the\n   appropriate Authentication
        messages (see Section 4.4).  If the client\n   chooses to authenticate, it
        MUST send Certificate, CertificateVerify,\n   and Finished.  If it declines,
        it MUST send a Certificate message\n   containing no certificates followed
        by Finished.  All of the client's\n   messages for a given response MUST appear
        consecutively on the wire\n   with no intervening messages of other types.\n
        \  A client that receives a CertificateRequest message without having\n   sent
        the \"post_handshake_auth\" extension MUST send an\n   \"unexpected_message\"
        fatal alert.\n   Note: Because client authentication could involve prompting
        the user,\n   servers MUST be prepared for some delay, including receiving
        an\n   arbitrary number of other messages between sending the\n   CertificateRequest
        and receiving a response.  In addition, clients\n   which receive multiple
        CertificateRequests in close succession MAY\n   respond to them in a different
        order than they were received (the\n   certificate_request_context value allows
        the server to disambiguate\n   the responses).\n"
      title: 4.6.2.  Post-Handshake Authentication
    - contents:
      - "4.6.3.  Key and Initialization Vector Update\n   The KeyUpdate handshake
        message is used to indicate that the sender\n   is updating its sending cryptographic
        keys.  This message can be sent\n   by either peer after it has sent a Finished
        message.  Implementations\n   that receive a KeyUpdate message prior to receiving
        a Finished\n   message MUST terminate the connection with an \"unexpected_message\"\n
        \  alert.  After sending a KeyUpdate message, the sender SHALL send all\n
        \  its traffic using the next generation of keys, computed as described\n
        \  in Section 7.2.  Upon receiving a KeyUpdate, the receiver MUST update\n
        \  its receiving keys.\n      enum {\n          update_not_requested(0), update_requested(1),
        (255)\n      } KeyUpdateRequest;\n      struct {\n          KeyUpdateRequest
        request_update;\n      } KeyUpdate;\n   request_update:  Indicates whether
        the recipient of the KeyUpdate\n      should respond with its own KeyUpdate.
        \ If an implementation\n      receives any other value, it MUST terminate
        the connection with an\n      \"illegal_parameter\" alert.\n   If the request_update
        field is set to \"update_requested\", then the\n   receiver MUST send a KeyUpdate
        of its own with request_update set to\n   \"update_not_requested\" prior to
        sending its next Application Data\n   record.  This mechanism allows either
        side to force an update to the\n   entire connection, but causes an implementation
        which receives\n   multiple KeyUpdates while it is silent to respond with
        a single\n   update.  Note that implementations may receive an arbitrary number
        of\n   messages between sending a KeyUpdate with request_update set to\n   \"update_requested\"
        and receiving the peer's KeyUpdate, because those\n   messages may already
        be in flight.  However, because send and receive\n   keys are derived from
        independent traffic secrets, retaining the\n   receive traffic secret does
        not threaten the forward secrecy of data\n   sent before the sender changed
        keys.\n   If implementations independently send their own KeyUpdates with\n
        \  request_update set to \"update_requested\" and they cross in flight,\n
        \  then each side will also send a response, with the result that each\n   side
        increments by two generations.\n   Both sender and receiver MUST encrypt their
        KeyUpdate messages with\n   the old keys.  Additionally, both sides MUST enforce
        that a KeyUpdate\n   with the old key is received before accepting any messages
        encrypted\n   with the new key.  Failure to do so may allow message truncation\n
        \  attacks.\n"
      title: 4.6.3.  Key and Initialization Vector Update
    title: 4.6.  Post-Handshake Messages
  title: 4.  Handshake Protocol
- contents:
  - "5.  Record Protocol\n   The TLS record protocol takes messages to be transmitted,
    fragments\n   the data into manageable blocks, protects the records, and transmits\n
    \  the result.  Received data is verified, decrypted, reassembled, and\n   then
    delivered to higher-level clients.\n   TLS records are typed, which allows multiple
    higher-level protocols\n   to be multiplexed over the same record layer.  This
    document\n   specifies four content types: handshake, application_data, alert,
    and\n   change_cipher_spec.  The change_cipher_spec record is used only for\n
    \  compatibility purposes (see Appendix D.4).\n   An implementation may receive
    an unencrypted record of type\n   change_cipher_spec consisting of the single
    byte value 0x01 at any\n   time after the first ClientHello message has been sent
    or received\n   and before the peer's Finished message has been received and MUST\n
    \  simply drop it without further processing.  Note that this record may\n   appear
    at a point at the handshake where the implementation is\n   expecting protected
    records, and so it is necessary to detect this\n   condition prior to attempting
    to deprotect the record.  An\n   implementation which receives any other change_cipher_spec
    value or\n   which receives a protected change_cipher_spec record MUST abort the\n
    \  handshake with an \"unexpected_message\" alert.  If an implementation\n   detects
    a change_cipher_spec record received before the first\n   ClientHello message
    or after the peer's Finished message, it MUST be\n   treated as an unexpected
    record type (though stateless servers may\n   not be able to distinguish these
    cases from allowed cases).\n   Implementations MUST NOT send record types not
    defined in this\n   document unless negotiated by some extension.  If a TLS\n
    \  implementation receives an unexpected record type, it MUST terminate\n   the
    connection with an \"unexpected_message\" alert.  New record\n   content type
    values are assigned by IANA in the TLS ContentType\n   registry as described in
    Section 11.\n"
  - contents:
    - "5.1.  Record Layer\n   The record layer fragments information blocks into TLSPlaintext\n
      \  records carrying data in chunks of 2^14 bytes or less.  Message\n   boundaries
      are handled differently depending on the underlying\n   ContentType.  Any future
      content types MUST specify appropriate\n   rules.  Note that these rules are
      stricter than what was enforced in\n   TLS 1.2.\n   Handshake messages MAY be
      coalesced into a single TLSPlaintext record\n   or fragmented across several
      records, provided that:\n   -  Handshake messages MUST NOT be interleaved with
      other record\n      types.  That is, if a handshake message is split over two
      or more\n      records, there MUST NOT be any other records between them.\n
      \  -  Handshake messages MUST NOT span key changes.  Implementations\n      MUST
      verify that all messages immediately preceding a key change\n      align with
      a record boundary; if not, then they MUST terminate the\n      connection with
      an \"unexpected_message\" alert.  Because the\n      ClientHello, EndOfEarlyData,
      ServerHello, Finished, and KeyUpdate\n      messages can immediately precede
      a key change, implementations\n      MUST send these messages in alignment with
      a record boundary.\n   Implementations MUST NOT send zero-length fragments of
      Handshake\n   types, even if those fragments contain padding.\n   Alert messages
      (Section 6) MUST NOT be fragmented across records, and\n   multiple alert messages
      MUST NOT be coalesced into a single\n   TLSPlaintext record.  In other words,
      a record with an Alert type\n   MUST contain exactly one message.\n   Application
      Data messages contain data that is opaque to TLS.\n   Application Data messages
      are always protected.  Zero-length\n   fragments of Application Data MAY be
      sent, as they are potentially\n   useful as a traffic analysis countermeasure.
      \ Application Data\n   fragments MAY be split across multiple records or coalesced
      into a\n   single record.\n      enum {\n          invalid(0),\n          change_cipher_spec(20),\n
      \         alert(21),\n          handshake(22),\n          application_data(23),\n
      \         (255)\n      } ContentType;\n      struct {\n          ContentType
      type;\n          ProtocolVersion legacy_record_version;\n          uint16 length;\n
      \         opaque fragment[TLSPlaintext.length];\n      } TLSPlaintext;\n   type:
      \ The higher-level protocol used to process the enclosed\n      fragment.\n
      \  legacy_record_version:  MUST be set to 0x0303 for all records\n      generated
      by a TLS 1.3 implementation other than an initial\n      ClientHello (i.e.,
      one not generated after a HelloRetryRequest),\n      where it MAY also be 0x0301
      for compatibility purposes.  This\n      field is deprecated and MUST be ignored
      for all purposes.\n      Previous versions of TLS would use other values in
      this field\n      under some circumstances.\n   length:  The length (in bytes)
      of the following\n      TLSPlaintext.fragment.  The length MUST NOT exceed 2^14
      bytes.  An\n      endpoint that receives a record that exceeds this length MUST\n
      \     terminate the connection with a \"record_overflow\" alert.\n   fragment:
      \ The data being transmitted.  This value is transparent and\n      is treated
      as an independent block to be dealt with by the higher-\n      level protocol
      specified by the type field.\n   This document describes TLS 1.3, which uses
      the version 0x0304.  This\n   version value is historical, deriving from the
      use of 0x0301 for\n   TLS 1.0 and 0x0300 for SSL 3.0.  In order to maximize
      backward\n   compatibility, a record containing an initial ClientHello SHOULD
      have\n   version 0x0301 (reflecting TLS 1.0) and a record containing a second\n
      \  ClientHello or a ServerHello MUST have version 0x0303 (reflecting\n   TLS
      1.2).  When negotiating prior versions of TLS, endpoints follow\n   the procedure
      and requirements provided in Appendix D.\n   When record protection has not
      yet been engaged, TLSPlaintext\n   structures are written directly onto the
      wire.  Once record\n   protection has started, TLSPlaintext records are protected
      and sent\n   as described in the following section.  Note that Application Data\n
      \  records MUST NOT be written to the wire unprotected (see Section 2\n   for
      details).\n"
    title: 5.1.  Record Layer
  - contents:
    - "5.2.  Record Payload Protection\n   The record protection functions translate
      a TLSPlaintext structure\n   into a TLSCiphertext structure.  The deprotection
      functions reverse\n   the process.  In TLS 1.3, as opposed to previous versions
      of TLS, all\n   ciphers are modeled as \"Authenticated Encryption with Associated\n
      \  Data\" (AEAD) [RFC5116].  AEAD functions provide a unified encryption\n   and
      authentication operation which turns plaintext into authenticated\n   ciphertext
      and back again.  Each encrypted record consists of a\n   plaintext header followed
      by an encrypted body, which itself contains\n   a type and optional padding.\n
      \     struct {\n          opaque content[TLSPlaintext.length];\n          ContentType
      type;\n          uint8 zeros[length_of_padding];\n      } TLSInnerPlaintext;\n
      \     struct {\n          ContentType opaque_type = application_data; /* 23
      */\n          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */\n
      \         uint16 length;\n          opaque encrypted_record[TLSCiphertext.length];\n
      \     } TLSCiphertext;\n   content:  The TLSPlaintext.fragment value, containing
      the byte\n      encoding of a handshake or an alert message, or the raw bytes
      of\n      the application's data to send.\n   type:  The TLSPlaintext.type value
      containing the content type of the\n      record.\n   zeros:  An arbitrary-length
      run of zero-valued bytes may appear in\n      the cleartext after the type field.
      \ This provides an opportunity\n      for senders to pad any TLS record by a
      chosen amount as long as\n      the total stays within record size limits.  See
      Section 5.4 for\n      more details.\n   opaque_type:  The outer opaque_type
      field of a TLSCiphertext record\n      is always set to the value 23 (application_data)
      for outward\n      compatibility with middleboxes accustomed to parsing previous\n
      \     versions of TLS.  The actual content type of the record is found\n      in
      TLSInnerPlaintext.type after decryption.\n   legacy_record_version:  The legacy_record_version
      field is always\n      0x0303.  TLS 1.3 TLSCiphertexts are not generated until
      after\n      TLS 1.3 has been negotiated, so there are no historical\n      compatibility
      concerns where other values might be received.  Note\n      that the handshake
      protocol, including the ClientHello and\n      ServerHello messages, authenticates
      the protocol version, so this\n      value is redundant.\n   length:  The length
      (in bytes) of the following\n      TLSCiphertext.encrypted_record, which is
      the sum of the lengths of\n      the content and the padding, plus one for the
      inner content type,\n      plus any expansion added by the AEAD algorithm.  The
      length\n      MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a\n
      \     record that exceeds this length MUST terminate the connection with\n      a
      \"record_overflow\" alert.\n   encrypted_record:  The AEAD-encrypted form of
      the serialized\n      TLSInnerPlaintext structure.\n   AEAD algorithms take
      as input a single key, a nonce, a plaintext, and\n   \"additional data\" to
      be included in the authentication check, as\n   described in Section 2.1 of
      [RFC5116].  The key is either the\n   client_write_key or the server_write_key,
      the nonce is derived from\n   the sequence number and the client_write_iv or
      server_write_iv (see\n   Section 5.3), and the additional data input is the
      record header.\n   I.e.,\n      additional_data = TLSCiphertext.opaque_type
      ||\n                        TLSCiphertext.legacy_record_version ||\n                        TLSCiphertext.length\n
      \  The plaintext input to the AEAD algorithm is the encoded\n   TLSInnerPlaintext
      structure.  Derivation of traffic keys is defined\n   in Section 7.3.\n   The
      AEAD output consists of the ciphertext output from the AEAD\n   encryption operation.
      \ The length of the plaintext is greater than\n   the corresponding TLSPlaintext.length
      due to the inclusion of\n   TLSInnerPlaintext.type and any padding supplied
      by the sender.  The\n   length of the AEAD output will generally be larger than
      the\n   plaintext, but by an amount that varies with the AEAD algorithm.\n   Since
      the ciphers might incorporate padding, the amount of overhead\n   could vary
      with different lengths of plaintext.  Symbolically,\n      AEADEncrypted =\n
      \         AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\n   The
      encrypted_record field of TLSCiphertext is set to AEADEncrypted.\n   In order
      to decrypt and verify, the cipher takes as input the key,\n   nonce, additional
      data, and the AEADEncrypted value.  The output is\n   either the plaintext or
      an error indicating that the decryption\n   failed.  There is no separate integrity
      check.  Symbolically,\n      plaintext of encrypted_record =\n          AEAD-Decrypt(peer_write_key,
      nonce,\n                       additional_data, AEADEncrypted)\n   If the decryption
      fails, the receiver MUST terminate the connection\n   with a \"bad_record_mac\"
      alert.\n   An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion\n
      \  greater than 255 octets.  An endpoint that receives a record from its\n   peer
      with TLSCiphertext.length larger than 2^14 + 256 octets MUST\n   terminate the
      connection with a \"record_overflow\" alert.  This limit\n   is derived from
      the maximum TLSInnerPlaintext length of 2^14 octets +\n   1 octet for ContentType
      + the maximum AEAD expansion of 255 octets.\n"
    title: 5.2.  Record Payload Protection
  - contents:
    - "5.3.  Per-Record Nonce\n   A 64-bit sequence number is maintained separately
      for reading and\n   writing records.  The appropriate sequence number is incremented
      by\n   one after reading or writing each record.  Each sequence number is\n
      \  set to zero at the beginning of a connection and whenever the key is\n   changed;
      the first record transmitted under a particular traffic key\n   MUST use sequence
      number 0.\n   Because the size of sequence numbers is 64-bit, they should not
      wrap.\n   If a TLS implementation would need to wrap a sequence number, it MUST\n
      \  either rekey (Section 4.6.3) or terminate the connection.\n   Each AEAD algorithm
      will specify a range of possible lengths for the\n   per-record nonce, from
      N_MIN bytes to N_MAX bytes of input [RFC5116].\n   The length of the TLS per-record
      nonce (iv_length) is set to the\n   larger of 8 bytes and N_MIN for the AEAD
      algorithm (see [RFC5116],\n   Section 4).  An AEAD algorithm where N_MAX is
      less than 8 bytes\n   MUST NOT be used with TLS.  The per-record nonce for the
      AEAD\n   construction is formed as follows:\n   1.  The 64-bit record sequence
      number is encoded in network byte\n       order and padded to the left with
      zeros to iv_length.\n   2.  The padded sequence number is XORed with either
      the static\n       client_write_iv or server_write_iv (depending on the role).\n
      \  The resulting quantity (of length iv_length) is used as the\n   per-record
      nonce.\n   Note: This is a different construction from that in TLS 1.2, which\n
      \  specified a partially explicit nonce.\n"
    title: 5.3.  Per-Record Nonce
  - contents:
    - "5.4.  Record Padding\n   All encrypted TLS records can be padded to inflate
      the size of the\n   TLSCiphertext.  This allows the sender to hide the size
      of the\n   traffic from an observer.\n   When generating a TLSCiphertext record,
      implementations MAY choose to\n   pad.  An unpadded record is just a record
      with a padding length of\n   zero.  Padding is a string of zero-valued bytes
      appended to the\n   ContentType field before encryption.  Implementations MUST
      set the\n   padding octets to all zeros before encrypting.\n   Application Data
      records may contain a zero-length\n   TLSInnerPlaintext.content if the sender
      desires.  This permits\n   generation of plausibly sized cover traffic in contexts
      where the\n   presence or absence of activity may be sensitive.  Implementations\n
      \  MUST NOT send Handshake and Alert records that have a zero-length\n   TLSInnerPlaintext.content;
      if such a message is received, the\n   receiving implementation MUST terminate
      the connection with an\n   \"unexpected_message\" alert.\n   The padding sent
      is automatically verified by the record protection\n   mechanism; upon successful
      decryption of a\n   TLSCiphertext.encrypted_record, the receiving implementation
      scans\n   the field from the end toward the beginning until it finds a non-zero\n
      \  octet.  This non-zero octet is the content type of the message.  This\n   padding
      scheme was selected because it allows padding of any\n   encrypted TLS record
      by an arbitrary size (from zero up to TLS record\n   size limits) without introducing
      new content types.  The design also\n   enforces all-zero padding octets, which
      allows for quick detection of\n   padding errors.\n   Implementations MUST limit
      their scanning to the cleartext returned\n   from the AEAD decryption.  If a
      receiving implementation does not\n   find a non-zero octet in the cleartext,
      it MUST terminate the\n   connection with an \"unexpected_message\" alert.\n
      \  The presence of padding does not change the overall record size\n   limitations:
      the full encoded TLSInnerPlaintext MUST NOT exceed 2^14\n   + 1 octets.  If
      the maximum fragment length is reduced -- as, for\n   example, by the record_size_limit
      extension from [RFC8449] -- then\n   the reduced limit applies to the full plaintext,
      including the\n   content type and padding.\n   Selecting a padding policy that
      suggests when and how much to pad is\n   a complex topic and is beyond the scope
      of this specification.  If\n   the application-layer protocol on top of TLS
      has its own padding, it\n   may be preferable to pad Application Data TLS records
      within the\n   application layer.  Padding for encrypted Handshake or Alert
      records\n   must still be handled at the TLS layer, though.  Later documents
      may\n   define padding selection algorithms or define a padding policy\n   request
      mechanism through TLS extensions or some other means.\n"
    title: 5.4.  Record Padding
  - contents:
    - "5.5.  Limits on Key Usage\n   There are cryptographic limits on the amount
      of plaintext which can\n   be safely encrypted under a given set of keys.  [AEAD-LIMITS]\n
      \  provides an analysis of these limits under the assumption that the\n   underlying
      primitive (AES or ChaCha20) has no weaknesses.\n   Implementations SHOULD do
      a key update as described in Section 4.6.3\n   prior to reaching these limits.\n
      \  For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be\n   encrypted
      on a given connection while keeping a safety margin of\n   approximately 2^-57
      for Authenticated Encryption (AE) security.  For\n   ChaCha20/Poly1305, the
      record sequence number would wrap before the\n   safety limit is reached.\n"
    title: 5.5.  Limits on Key Usage
  title: 5.  Record Protocol
- contents:
  - "6.  Alert Protocol\n   TLS provides an Alert content type to indicate closure
    information\n   and errors.  Like other messages, alert messages are encrypted
    as\n   specified by the current connection state.\n   Alert messages convey a
    description of the alert and a legacy field\n   that conveyed the severity level
    of the message in previous versions\n   of TLS.  Alerts are divided into two classes:
    closure alerts and\n   error alerts.  In TLS 1.3, the severity is implicit in
    the type of\n   alert being sent, and the \"level\" field can safely be ignored.
    \ The\n   \"close_notify\" alert is used to indicate orderly closure of one\n
    \  direction of the connection.  Upon receiving such an alert, the TLS\n   implementation
    SHOULD indicate end-of-data to the application.\n   Error alerts indicate abortive
    closure of the connection (see\n   Section 6.2).  Upon receiving an error alert,
    the TLS implementation\n   SHOULD indicate an error to the application and MUST
    NOT allow any\n   further data to be sent or received on the connection.  Servers
    and\n   clients MUST forget the secret values and keys established in failed\n
    \  connections, with the exception of the PSKs associated with session\n   tickets,
    which SHOULD be discarded if possible.\n   All the alerts listed in Section 6.2
    MUST be sent with\n   AlertLevel=fatal and MUST be treated as error alerts when
    received\n   regardless of the AlertLevel in the message.  Unknown Alert types\n
    \  MUST be treated as error alerts.\n   Note: TLS defines two generic alerts (see
    Section 6) to use upon\n   failure to parse a message.  Peers which receive a
    message which\n   cannot be parsed according to the syntax (e.g., have a length\n
    \  extending beyond the message boundary or contain an out-of-range\n   length)
    MUST terminate the connection with a \"decode_error\" alert.\n   Peers which receive
    a message which is syntactically correct but\n   semantically invalid (e.g., a
    DHE share of p - 1, or an invalid enum)\n   MUST terminate the connection with
    an \"illegal_parameter\" alert.\n      enum { warning(1), fatal(2), (255) } AlertLevel;\n
    \     enum {\n          close_notify(0),\n          unexpected_message(10),\n
    \         bad_record_mac(20),\n          record_overflow(22),\n          handshake_failure(40),\n
    \         bad_certificate(42),\n          unsupported_certificate(43),\n          certificate_revoked(44),\n
    \         certificate_expired(45),\n          certificate_unknown(46),\n          illegal_parameter(47),\n
    \         unknown_ca(48),\n          access_denied(49),\n          decode_error(50),\n
    \         decrypt_error(51),\n          protocol_version(70),\n          insufficient_security(71),\n
    \         internal_error(80),\n          inappropriate_fallback(86),\n          user_canceled(90),\n
    \         missing_extension(109),\n          unsupported_extension(110),\n          unrecognized_name(112),\n
    \         bad_certificate_status_response(113),\n          unknown_psk_identity(115),\n
    \         certificate_required(116),\n          no_application_protocol(120),\n
    \         (255)\n      } AlertDescription;\n      struct {\n          AlertLevel
    level;\n          AlertDescription description;\n      } Alert;\n"
  - contents:
    - "6.1.  Closure Alerts\n   The client and the server must share knowledge that
      the connection is\n   ending in order to avoid a truncation attack.\n   close_notify:
      \ This alert notifies the recipient that the sender will\n      not send any
      more messages on this connection.  Any data received\n      after a closure
      alert has been received MUST be ignored.\n   user_canceled:  This alert notifies
      the recipient that the sender is\n      canceling the handshake for some reason
      unrelated to a protocol\n      failure.  If a user cancels an operation after
      the handshake is\n      complete, just closing the connection by sending a \"close_notify\"\n
      \     is more appropriate.  This alert SHOULD be followed by a\n      \"close_notify\".
      \ This alert generally has AlertLevel=warning.\n   Either party MAY initiate
      a close of its write side of the connection\n   by sending a \"close_notify\"
      alert.  Any data received after a closure\n   alert has been received MUST be
      ignored.  If a transport-level close\n   is received prior to a \"close_notify\",
      the receiver cannot know that\n   all the data that was sent has been received.\n
      \  Each party MUST send a \"close_notify\" alert before closing its write\n
      \  side of the connection, unless it has already sent some error alert.\n   This
      does not have any effect on its read side of the connection.\n   Note that this
      is a change from versions of TLS prior to TLS 1.3 in\n   which implementations
      were required to react to a \"close_notify\" by\n   discarding pending writes
      and sending an immediate \"close_notify\"\n   alert of their own.  That previous
      requirement could cause truncation\n   in the read side.  Both parties need
      not wait to receive a\n   \"close_notify\" alert before closing their read side
      of the\n   connection, though doing so would introduce the possibility of\n
      \  truncation.\n   If the application protocol using TLS provides that any data
      may be\n   carried over the underlying transport after the TLS connection is\n
      \  closed, the TLS implementation MUST receive a \"close_notify\" alert\n   before
      indicating end-of-data to the application layer.  No part of\n   this standard
      should be taken to dictate the manner in which a usage\n   profile for TLS manages
      its data transport, including when\n   connections are opened or closed.\n   Note:
      It is assumed that closing the write side of a connection\n   reliably delivers
      pending data before destroying the transport.\n"
    title: 6.1.  Closure Alerts
  - contents:
    - "6.2.  Error Alerts\n   Error handling in TLS is very simple.  When an error
      is detected, the\n   detecting party sends a message to its peer.  Upon transmission
      or\n   receipt of a fatal alert message, both parties MUST immediately close\n
      \  the connection.\n   Whenever an implementation encounters a fatal error condition,
      it\n   SHOULD send an appropriate fatal alert and MUST close the connection\n
      \  without sending or receiving any additional data.  In the rest of\n   this
      specification, when the phrases \"terminate the connection\" and\n   \"abort
      the handshake\" are used without a specific alert it means that\n   the implementation
      SHOULD send the alert indicated by the\n   descriptions below.  The phrases
      \"terminate the connection with an X\n   alert\" and \"abort the handshake with
      an X alert\" mean that the\n   implementation MUST send alert X if it sends
      any alert.  All alerts\n   defined below in this section, as well as all unknown
      alerts, are\n   universally considered fatal as of TLS 1.3 (see Section 6).
      \ The\n   implementation SHOULD provide a way to facilitate logging the sending\n
      \  and receiving of alerts.\n   The following error alerts are defined:\n   unexpected_message:
      \ An inappropriate message (e.g., the wrong\n      handshake message, premature
      Application Data, etc.) was received.\n      This alert should never be observed
      in communication between\n      proper implementations.\n   bad_record_mac:
      \ This alert is returned if a record is received which\n      cannot be deprotected.
      \ Because AEAD algorithms combine decryption\n      and verification, and also
      to avoid side-channel attacks, this\n      alert is used for all deprotection
      failures.  This alert should\n      never be observed in communication between
      proper implementations,\n      except when messages were corrupted in the network.\n
      \  record_overflow:  A TLSCiphertext record was received that had a\n      length
      more than 2^14 + 256 bytes, or a record decrypted to a\n      TLSPlaintext record
      with more than 2^14 bytes (or some other\n      negotiated limit).  This alert
      should never be observed in\n      communication between proper implementations,
      except when messages\n      were corrupted in the network.\n   handshake_failure:
      \ Receipt of a \"handshake_failure\" alert message\n      indicates that the
      sender was unable to negotiate an acceptable\n      set of security parameters
      given the options available.\n   bad_certificate:  A certificate was corrupt,
      contained signatures\n      that did not verify correctly, etc.\n   unsupported_certificate:
      \ A certificate was of an unsupported type.\n   certificate_revoked:  A certificate
      was revoked by its signer.\n   certificate_expired:  A certificate has expired
      or is not currently\n      valid.\n   certificate_unknown:  Some other (unspecified)
      issue arose in\n      processing the certificate, rendering it unacceptable.\n
      \  illegal_parameter:  A field in the handshake was incorrect or\n      inconsistent
      with other fields.  This alert is used for errors\n      which conform to the
      formal protocol syntax but are otherwise\n      incorrect.\n   unknown_ca:  A
      valid certificate chain or partial chain was received,\n      but the certificate
      was not accepted because the CA certificate\n      could not be located or could
      not be matched with a known trust\n      anchor.\n   access_denied:  A valid
      certificate or PSK was received, but when\n      access control was applied,
      the sender decided not to proceed with\n      negotiation.\n   decode_error:
      \ A message could not be decoded because some field was\n      out of the specified
      range or the length of the message was\n      incorrect.  This alert is used
      for errors where the message does\n      not conform to the formal protocol
      syntax.  This alert should\n      never be observed in communication between
      proper implementations,\n      except when messages were corrupted in the network.\n
      \  decrypt_error:  A handshake (not record layer) cryptographic\n      operation
      failed, including being unable to correctly verify a\n      signature or validate
      a Finished message or a PSK binder.\n   protocol_version:  The protocol version
      the peer has attempted to\n      negotiate is recognized but not supported (see
      Appendix D).\n   insufficient_security:  Returned instead of \"handshake_failure\"
      when\n      a negotiation has failed specifically because the server requires\n
      \     parameters more secure than those supported by the client.\n   internal_error:
      \ An internal error unrelated to the peer or the\n      correctness of the protocol
      (such as a memory allocation failure)\n      makes it impossible to continue.\n
      \  inappropriate_fallback:  Sent by a server in response to an invalid\n      connection
      retry attempt from a client (see [RFC7507]).\n   missing_extension:  Sent by
      endpoints that receive a handshake\n      message not containing an extension
      that is mandatory to send for\n      the offered TLS version or other negotiated
      parameters.\n   unsupported_extension:  Sent by endpoints receiving any handshake\n
      \     message containing an extension known to be prohibited for\n      inclusion
      in the given handshake message, or including any\n      extensions in a ServerHello
      or Certificate not first offered in\n      the corresponding ClientHello or
      CertificateRequest.\n   unrecognized_name:  Sent by servers when no server exists
      identified\n      by the name provided by the client via the \"server_name\"
      extension\n      (see [RFC6066]).\n   bad_certificate_status_response:  Sent
      by clients when an invalid or\n      unacceptable OCSP response is provided
      by the server via the\n      \"status_request\" extension (see [RFC6066]).\n
      \  unknown_psk_identity:  Sent by servers when PSK key establishment is\n      desired
      but no acceptable PSK identity is provided by the client.\n      Sending this
      alert is OPTIONAL; servers MAY instead choose to send\n      a \"decrypt_error\"
      alert to merely indicate an invalid PSK\n      identity.\n   certificate_required:
      \ Sent by servers when a client certificate is\n      desired but none was provided
      by the client.\n   no_application_protocol:  Sent by servers when a client\n
      \     \"application_layer_protocol_negotiation\" extension advertises only\n
      \     protocols that the server does not support (see [RFC7301]).\n   New Alert
      values are assigned by IANA as described in Section 11.\n"
    title: 6.2.  Error Alerts
  title: 6.  Alert Protocol
- contents:
  - "7.  Cryptographic Computations\n   The TLS handshake establishes one or more
    input secrets which are\n   combined to create the actual working keying material,
    as detailed\n   below.  The key derivation process incorporates both the input\n
    \  secrets and the handshake transcript.  Note that because the\n   handshake
    transcript includes the random values from the Hello\n   messages, any given handshake
    will have different traffic secrets,\n   even if the same input secrets are used,
    as is the case when the same\n   PSK is used for multiple connections.\n"
  - contents:
    - "7.1.  Key Schedule\n   The key derivation process makes use of the HKDF-Extract
      and\n   HKDF-Expand functions as defined for HKDF [RFC5869], as well as the\n
      \  functions defined below:\n       HKDF-Expand-Label(Secret, Label, Context,
      Length) =\n            HKDF-Expand(Secret, HkdfLabel, Length)\n       Where
      HkdfLabel is specified as:\n       struct {\n           uint16 length = Length;\n
      \          opaque label<7..255> = \"tls13 \" + Label;\n           opaque context<0..255>
      = Context;\n       } HkdfLabel;\n       Derive-Secret(Secret, Label, Messages)
      =\n            HKDF-Expand-Label(Secret, Label,\n                              Transcript-Hash(Messages),
      Hash.length)\n   The Hash function used by Transcript-Hash and HKDF is the cipher\n
      \  suite hash algorithm.  Hash.length is its output length in bytes.\n   Messages
      is the concatenation of the indicated handshake messages,\n   including the
      handshake message type and length fields, but not\n   including record layer
      headers.  Note that in some cases a zero-\n   length Context (indicated by \"\")
      is passed to HKDF-Expand-Label.  The\n   labels specified in this document are
      all ASCII strings and do not\n   include a trailing NUL byte.\n   Note: With
      common hash functions, any label longer than 12 characters\n   requires an additional
      iteration of the hash function to compute.\n   The labels in this specification
      have all been chosen to fit within\n   this limit.\n   Keys are derived from
      two input secrets using the HKDF-Extract and\n   Derive-Secret functions.  The
      general pattern for adding a new secret\n   is to use HKDF-Extract with the
      Salt being the current secret state\n   and the Input Keying Material (IKM)
      being the new secret to be added.\n   In this version of TLS 1.3, the two input
      secrets are:\n   -  PSK (a pre-shared key established externally or derived
      from the\n      resumption_master_secret value from a previous connection)\n
      \  -  (EC)DHE shared secret (Section 7.4)\n   This produces a full key derivation
      schedule shown in the diagram\n   below.  In this diagram, the following formatting
      conventions apply:\n   -  HKDF-Extract is drawn as taking the Salt argument
      from the top and\n      the IKM argument from the left, with its output to the
      bottom and\n      the name of the output on the right.\n   -  Derive-Secret's
      Secret argument is indicated by the incoming\n      arrow.  For instance, the
      Early Secret is the Secret for\n      generating the client_early_traffic_secret.\n
      \  -  \"0\" indicates a string of Hash.length bytes set to zero.\n             0\n
      \            |\n             v\n   PSK ->  HKDF-Extract = Early Secret\n             |\n
      \            +-----> Derive-Secret(., \"ext binder\" | \"res binder\", \"\")\n
      \            |                     = binder_key\n             |\n             +----->
      Derive-Secret(., \"c e traffic\", ClientHello)\n             |                     =
      client_early_traffic_secret\n             |\n             +-----> Derive-Secret(.,
      \"e exp master\", ClientHello)\n             |                     = early_exporter_master_secret\n
      \            v\n       Derive-Secret(., \"derived\", \"\")\n             |\n
      \            v\n   (EC)DHE -> HKDF-Extract = Handshake Secret\n             |\n
      \            +-----> Derive-Secret(., \"c hs traffic\",\n             |                     ClientHello...ServerHello)\n
      \            |                     = client_handshake_traffic_secret\n             |\n
      \            +-----> Derive-Secret(., \"s hs traffic\",\n             |                     ClientHello...ServerHello)\n
      \            |                     = server_handshake_traffic_secret\n             v\n
      \      Derive-Secret(., \"derived\", \"\")\n             |\n             v\n
      \  0 -> HKDF-Extract = Master Secret\n             |\n             +-----> Derive-Secret(.,
      \"c ap traffic\",\n             |                     ClientHello...server Finished)\n
      \            |                     = client_application_traffic_secret_0\n             |\n
      \            +-----> Derive-Secret(., \"s ap traffic\",\n             |                     ClientHello...server
      Finished)\n             |                     = server_application_traffic_secret_0\n
      \            |\n             +-----> Derive-Secret(., \"exp master\",\n             |
      \                    ClientHello...server Finished)\n             |                     =
      exporter_master_secret\n             |\n             +-----> Derive-Secret(.,
      \"res master\",\n                                   ClientHello...client Finished)\n
      \                                  = resumption_master_secret\n   The general
      pattern here is that the secrets shown down the left side\n   of the diagram
      are just raw entropy without context, whereas the\n   secrets down the right
      side include Handshake Context and therefore\n   can be used to derive working
      keys without additional context.  Note\n   that the different calls to Derive-Secret
      may take different Messages\n   arguments, even with the same secret.  In a
      0-RTT exchange,\n   Derive-Secret is called with four distinct transcripts;
      in a\n   1-RTT-only exchange, it is called with three distinct transcripts.\n
      \  If a given secret is not available, then the 0-value consisting of a\n   string
      of Hash.length bytes set to zeros is used.  Note that this\n   does not mean
      skipping rounds, so if PSK is not in use, Early Secret\n   will still be HKDF-Extract(0,
      0).  For the computation of the\n   binder_key, the label is \"ext binder\"
      for external PSKs (those\n   provisioned outside of TLS) and \"res binder\"
      for resumption PSKs\n   (those provisioned as the resumption master secret of
      a previous\n   handshake).  The different labels prevent the substitution of
      one\n   type of PSK for the other.\n   There are multiple potential Early Secret
      values, depending on which\n   PSK the server ultimately selects.  The client
      will need to compute\n   one for each potential PSK; if no PSK is selected,
      it will then need\n   to compute the Early Secret corresponding to the zero
      PSK.\n   Once all the values which are to be derived from a given secret have\n
      \  been computed, that secret SHOULD be erased.\n"
    title: 7.1.  Key Schedule
  - contents:
    - "7.2.  Updating Traffic Secrets\n   Once the handshake is complete, it is possible
      for either side to\n   update its sending traffic keys using the KeyUpdate handshake
      message\n   defined in Section 4.6.3.  The next generation of traffic keys is\n
      \  computed by generating client_/server_application_traffic_secret_N+1\n   from
      client_/server_application_traffic_secret_N as described in this\n   section
      and then re-deriving the traffic keys as described in\n   Section 7.3.\n   The
      next-generation application_traffic_secret is computed as:\n       application_traffic_secret_N+1
      =\n           HKDF-Expand-Label(application_traffic_secret_N,\n                             \"traffic
      upd\", \"\", Hash.length)\n   Once client_/server_application_traffic_secret_N+1
      and its associated\n   traffic keys have been computed, implementations SHOULD
      delete\n   client_/server_application_traffic_secret_N and its associated\n
      \  traffic keys.\n"
    title: 7.2.  Updating Traffic Secrets
  - contents:
    - "7.3.  Traffic Key Calculation\n   The traffic keying material is generated
      from the following input\n   values:\n   -  A secret value\n   -  A purpose
      value indicating the specific value being generated\n   -  The length of the
      key being generated\n   The traffic keying material is generated from an input
      traffic secret\n   value using:\n   [sender]_write_key = HKDF-Expand-Label(Secret,
      \"key\", \"\", key_length)\n   [sender]_write_iv  = HKDF-Expand-Label(Secret,
      \"iv\", \"\", iv_length)\n   [sender] denotes the sending side.  The value of
      Secret for each\n   record type is shown in the table below.\n       +-------------------+---------------------------------------+\n
      \      | Record Type       | Secret                                |\n       +-------------------+---------------------------------------+\n
      \      | 0-RTT Application | client_early_traffic_secret           |\n       |
      \                  |                                       |\n       | Handshake
      \        | [sender]_handshake_traffic_secret     |\n       |                   |
      \                                      |\n       | Application Data  | [sender]_application_traffic_secret_N
      |\n       +-------------------+---------------------------------------+\n   All
      the traffic keying material is recomputed whenever the underlying\n   Secret
      changes (e.g., when changing from the handshake to Application\n   Data keys
      or upon a key update).\n"
    title: 7.3.  Traffic Key Calculation
  - contents:
    - '7.4.  (EC)DHE Shared Secret Calculation

      '
    - contents:
      - "7.4.1.  Finite Field Diffie-Hellman\n   For finite field groups, a conventional
        Diffie-Hellman [DH76]\n   computation is performed.  The negotiated key (Z)
        is converted to a\n   byte string by encoding in big-endian form and left-padded
        with zeros\n   up to the size of the prime.  This byte string is used as the
        shared\n   secret in the key schedule as specified above.\n   Note that this
        construction differs from previous versions of TLS\n   which removed leading
        zeros.\n"
      title: 7.4.1.  Finite Field Diffie-Hellman
    - contents:
      - "7.4.2.  Elliptic Curve Diffie-Hellman\n   For secp256r1, secp384r1, and secp521r1,
        ECDH calculations (including\n   parameter and key generation as well as the
        shared secret\n   calculation) are performed according to [IEEE1363] using
        the\n   ECKAS-DH1 scheme with the identity map as the key derivation function\n
        \  (KDF), so that the shared secret is the x-coordinate of the ECDH\n   shared
        secret elliptic curve point represented as an octet string.\n   Note that
        this octet string (\"Z\" in IEEE 1363 terminology) as output\n   by FE2OSP
        (the Field Element to Octet String Conversion Primitive)\n   has constant
        length for any given field; leading zeros found in this\n   octet string MUST
        NOT be truncated.\n   (Note that this use of the identity KDF is a technicality.
        \ The\n   complete picture is that ECDH is employed with a non-trivial KDF\n
        \  because TLS does not directly use this secret for anything other than\n
        \  for computing other secrets.)\n   For X25519 and X448, the ECDH calculations
        are as follows:\n   -  The public key to put into the KeyShareEntry.key_exchange\n
        \     structure is the result of applying the ECDH scalar multiplication\n
        \     function to the secret key of appropriate length (into scalar\n      input)
        and the standard public basepoint (into u-coordinate point\n      input).\n
        \  -  The ECDH shared secret is the result of applying the ECDH scalar\n      multiplication
        function to the secret key (into scalar input) and\n      the peer's public
        key (into u-coordinate point input).  The output\n      is used raw, with
        no processing.\n   For these curves, implementations SHOULD use the approach
        specified\n   in [RFC7748] to calculate the Diffie-Hellman shared secret.\n
        \  Implementations MUST check whether the computed Diffie-Hellman shared\n
        \  secret is the all-zero value and abort if so, as described in\n   Section
        6 of [RFC7748].  If implementors use an alternative\n   implementation of
        these elliptic curves, they SHOULD perform the\n   additional checks specified
        in Section 7 of [RFC7748].\n"
      title: 7.4.2.  Elliptic Curve Diffie-Hellman
    title: 7.4.  (EC)DHE Shared Secret Calculation
  - contents:
    - "7.5.  Exporters\n   [RFC5705] defines keying material exporters for TLS in
      terms of the\n   TLS pseudorandom function (PRF).  This document replaces the
      PRF with\n   HKDF, thus requiring a new construction.  The exporter interface\n
      \  remains the same.\n   The exporter value is computed as:\n   TLS-Exporter(label,
      context_value, key_length) =\n       HKDF-Expand-Label(Derive-Secret(Secret,
      label, \"\"),\n                         \"exporter\", Hash(context_value), key_length)\n
      \  Where Secret is either the early_exporter_master_secret or the\n   exporter_master_secret.
      \ Implementations MUST use the\n   exporter_master_secret unless explicitly
      specified by the\n   application.  The early_exporter_master_secret is defined
      for use in\n   settings where an exporter is needed for 0-RTT data.  A separate\n
      \  interface for the early exporter is RECOMMENDED; this avoids the\n   exporter
      user accidentally using an early exporter when a regular one\n   is desired
      or vice versa.\n   If no context is provided, the context_value is zero length.\n
      \  Consequently, providing no context computes the same value as\n   providing
      an empty context.  This is a change from previous versions\n   of TLS where
      an empty context produced a different output than an\n   absent context.  As
      of this document's publication, no allocated\n   exporter label is used both
      with and without a context.  Future\n   specifications MUST NOT define a use
      of exporters that permit both an\n   empty context and no context with the same
      label.  New uses of\n   exporters SHOULD provide a context in all exporter computations,\n
      \  though the value could be empty.\n   Requirements for the format of exporter
      labels are defined in\n   Section 4 of [RFC5705].\n"
    title: 7.5.  Exporters
  title: 7.  Cryptographic Computations
- contents:
  - "8.  0-RTT and Anti-Replay\n   As noted in Section 2.3 and Appendix E.5, TLS does
    not provide\n   inherent replay protections for 0-RTT data.  There are two potential\n
    \  threats to be concerned with:\n   -  Network attackers who mount a replay attack
    by simply duplicating\n      a flight of 0-RTT data.\n   -  Network attackers
    who take advantage of client retry behavior to\n      arrange for the server to
    receive multiple copies of an\n      application message.  This threat already
    exists to some extent\n      because clients that value robustness respond to
    network errors by\n      attempting to retry requests.  However, 0-RTT adds an
    additional\n      dimension for any server system which does not maintain globally\n
    \     consistent server state.  Specifically, if a server system has\n      multiple
    zones where tickets from zone A will not be accepted in\n      zone B, then an
    attacker can duplicate a ClientHello and early\n      data intended for A to both
    A and B.  At A, the data will be\n      accepted in 0-RTT, but at B the server
    will reject 0-RTT data and\n      instead force a full handshake.  If the attacker
    blocks the\n      ServerHello from A, then the client will complete the handshake\n
    \     with B and probably retry the request, leading to duplication on\n      the
    server system as a whole.\n   The first class of attack can be prevented by sharing
    state to\n   guarantee that the 0-RTT data is accepted at most once.  Servers\n
    \  SHOULD provide that level of replay safety by implementing one of the\n   methods
    described in this section or by equivalent means.  It is\n   understood, however,
    that due to operational concerns not all\n   deployments will maintain state at
    that level.  Therefore, in normal\n   operation, clients will not know which,
    if any, of these mechanisms\n   servers actually implement and hence MUST only
    send early data which\n   they deem safe to be replayed.\n   In addition to the
    direct effects of replays, there is a class of\n   attacks where even operations
    normally considered idempotent could be\n   exploited by a large number of replays
    (timing attacks, resource\n   limit exhaustion and others, as described in Appendix
    E.5).  Those\n   can be mitigated by ensuring that every 0-RTT payload can be
    replayed\n   only a limited number of times.  The server MUST ensure that any\n
    \  instance of it (be it a machine, a thread, or any other entity within\n   the
    relevant serving infrastructure) would accept 0-RTT for the same\n   0-RTT handshake
    at most once; this limits the number of replays to\n   the number of server instances
    in the deployment.  Such a guarantee\n   can be accomplished by locally recording
    data from recently received\n   ClientHellos and rejecting repeats, or by any
    other method that\n   provides the same or a stronger guarantee.  The \"at most
    once per\n   server instance\" guarantee is a minimum requirement; servers SHOULD\n
    \  limit 0-RTT replays further when feasible.\n   The second class of attack cannot
    be prevented at the TLS layer and\n   MUST be dealt with by any application.  Note
    that any application\n   whose clients implement any kind of retry behavior already
    needs to\n   implement some sort of anti-replay defense.\n"
  - contents:
    - "8.1.  Single-Use Tickets\n   The simplest form of anti-replay defense is for
      the server to only\n   allow each session ticket to be used once.  For instance,
      the server\n   can maintain a database of all outstanding valid tickets, deleting\n
      \  each ticket from the database as it is used.  If an unknown ticket is\n   provided,
      the server would then fall back to a full handshake.\n   If the tickets are
      not self-contained but rather are database keys,\n   and the corresponding PSKs
      are deleted upon use, then connections\n   established using PSKs enjoy forward
      secrecy.  This improves security\n   for all 0-RTT data and PSK usage when PSK
      is used without (EC)DHE.\n   Because this mechanism requires sharing the session
      database between\n   server nodes in environments with multiple distributed
      servers, it\n   may be hard to achieve high rates of successful PSK 0-RTT connections\n
      \  when compared to self-encrypted tickets.  Unlike session databases,\n   session
      tickets can successfully do PSK-based session establishment\n   even without
      consistent storage, though when 0-RTT is allowed they\n   still require consistent
      storage for anti-replay of 0-RTT data, as\n   detailed in the following section.\n"
    title: 8.1.  Single-Use Tickets
  - contents:
    - "8.2.  Client Hello Recording\n   An alternative form of anti-replay is to record
      a unique value\n   derived from the ClientHello (generally either the random
      value or\n   the PSK binder) and reject duplicates.  Recording all ClientHellos\n
      \  causes state to grow without bound, but a server can instead record\n   ClientHellos
      within a given time window and use the\n   \"obfuscated_ticket_age\" to ensure
      that tickets aren't reused outside\n   that window.\n   In order to implement
      this, when a ClientHello is received, the\n   server first verifies the PSK
      binder as described in Section 4.2.11.\n   It then computes the expected_arrival_time
      as described in the next\n   section and rejects 0-RTT if it is outside the
      recording window,\n   falling back to the 1-RTT handshake.\n   If the expected_arrival_time
      is in the window, then the server checks\n   to see if it has recorded a matching
      ClientHello.  If one is found,\n   it either aborts the handshake with an \"illegal_parameter\"
      alert or\n   accepts the PSK but rejects 0-RTT.  If no matching ClientHello
      is\n   found, then it accepts 0-RTT and then stores the ClientHello for as\n
      \  long as the expected_arrival_time is inside the window.  Servers MAY\n   also
      implement data stores with false positives, such as Bloom\n   filters, in which
      case they MUST respond to apparent replay by\n   rejecting 0-RTT but MUST NOT
      abort the handshake.\n   The server MUST derive the storage key only from validated
      sections\n   of the ClientHello.  If the ClientHello contains multiple PSK\n
      \  identities, then an attacker can create multiple ClientHellos with\n   different
      binder values for the less-preferred identity on the\n   assumption that the
      server will not verify it (as recommended by\n   Section 4.2.11).  I.e., if
      the client sends PSKs A and B but the\n   server prefers A, then the attacker
      can change the binder for B\n   without affecting the binder for A.  If the
      binder for B is part of\n   the storage key, then this ClientHello will not
      appear as a\n   duplicate, which will cause the ClientHello to be accepted,
      and may\n   cause side effects such as replay cache pollution, although any
      0-RTT\n   data will not be decryptable because it will use different keys.  If\n
      \  the validated binder or the ClientHello.random is used as the storage\n   key,
      then this attack is not possible.\n   Because this mechanism does not require
      storing all outstanding\n   tickets, it may be easier to implement in distributed
      systems with\n   high rates of resumption and 0-RTT, at the cost of potentially
      weaker\n   anti-replay defense because of the difficulty of reliably storing
      and\n   retrieving the received ClientHello messages.  In many such systems,\n
      \  it is impractical to have globally consistent storage of all the\n   received
      ClientHellos.  In this case, the best anti-replay protection\n   is provided
      by having a single storage zone be authoritative for a\n   given ticket and
      refusing 0-RTT for that ticket in any other zone.\n   This approach prevents
      simple replay by the attacker because only one\n   zone will accept 0-RTT data.
      \ A weaker design is to implement\n   separate storage for each zone but allow
      0-RTT in any zone.  This\n   approach limits the number of replays to once per
      zone.  Application\n   message duplication of course remains possible with either
      design.\n   When implementations are freshly started, they SHOULD reject 0-RTT
      as\n   long as any portion of their recording window overlaps the startup\n
      \  time.  Otherwise, they run the risk of accepting replays which were\n   originally
      sent during that period.\n   Note: If the client's clock is running much faster
      than the server's,\n   then a ClientHello may be received that is outside the
      window in the\n   future, in which case it might be accepted for 1-RTT, causing
      a\n   client retry, and then acceptable later for 0-RTT.  This is another\n
      \  variant of the second form of attack described in Section 8.\n"
    title: 8.2.  Client Hello Recording
  - contents:
    - "8.3.  Freshness Checks\n   Because the ClientHello indicates the time at which
      the client sent\n   it, it is possible to efficiently determine whether a ClientHello
      was\n   likely sent reasonably recently and only accept 0-RTT for such a\n   ClientHello,
      otherwise falling back to a 1-RTT handshake.  This is\n   necessary for the
      ClientHello storage mechanism described in\n   Section 8.2 because otherwise
      the server needs to store an unlimited\n   number of ClientHellos, and is a
      useful optimization for self-\n   contained single-use tickets because it allows
      efficient rejection of\n   ClientHellos which cannot be used for 0-RTT.\n   In
      order to implement this mechanism, a server needs to store the\n   time that
      the server generated the session ticket, offset by an\n   estimate of the round-trip
      time between client and server.  I.e.,\n       adjusted_creation_time = creation_time
      + estimated_RTT\n   This value can be encoded in the ticket, thus avoiding the
      need to\n   keep state for each outstanding ticket.  The server can determine
      the\n   client's view of the age of the ticket by subtracting the ticket's\n
      \  \"ticket_age_add\" value from the \"obfuscated_ticket_age\" parameter in\n
      \  the client's \"pre_shared_key\" extension.  The server can determine\n   the
      expected_arrival_time of the ClientHello as:\n     expected_arrival_time = adjusted_creation_time
      + clients_ticket_age\n   When a new ClientHello is received, the expected_arrival_time
      is then\n   compared against the current server wall clock time and if they\n
      \  differ by more than a certain amount, 0-RTT is rejected, though the\n   1-RTT
      handshake can be allowed to complete.\n   There are several potential sources
      of error that might cause\n   mismatches between the expected_arrival_time and
      the measured time.\n   Variations in client and server clock rates are likely
      to be minimal,\n   though potentially the absolute times may be off by large
      values.\n   Network propagation delays are the most likely causes of a mismatch\n
      \  in legitimate values for elapsed time.  Both the NewSessionTicket and\n   ClientHello
      messages might be retransmitted and therefore delayed,\n   which might be hidden
      by TCP.  For clients on the Internet, this\n   implies windows on the order
      of ten seconds to account for errors in\n   clocks and variations in measurements;
      other deployment scenarios may\n   have different needs.  Clock skew distributions
      are not symmetric, so\n   the optimal tradeoff may involve an asymmetric range
      of permissible\n   mismatch values.\n   Note that freshness checking alone is
      not sufficient to prevent\n   replays because it does not detect them during
      the error window,\n   which -- depending on bandwidth and system capacity --
      could include\n   billions of replays in real-world settings.  In addition,
      this\n   freshness checking is only done at the time the ClientHello is\n   received
      and not when subsequent early Application Data records are\n   received.  After
      early data is accepted, records may continue to be\n   streamed to the server
      over a longer time period.\n"
    title: 8.3.  Freshness Checks
  title: 8.  0-RTT and Anti-Replay
- contents:
  - '9.  Compliance Requirements

    '
  - contents:
    - "9.1.  Mandatory-to-Implement Cipher Suites\n   In the absence of an application
      profile standard specifying\n   otherwise:\n   A TLS-compliant application MUST
      implement the TLS_AES_128_GCM_SHA256\n   [GCM] cipher suite and SHOULD implement
      the TLS_AES_256_GCM_SHA384\n   [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439]
      cipher suites (see\n   Appendix B.4).\n   A TLS-compliant application MUST support
      digital signatures with\n   rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256
      (for\n   CertificateVerify and certificates), and ecdsa_secp256r1_sha256.  A\n
      \  TLS-compliant application MUST support key exchange with secp256r1\n   (NIST
      P-256) and SHOULD support key exchange with X25519 [RFC7748].\n"
    title: 9.1.  Mandatory-to-Implement Cipher Suites
  - contents:
    - "9.2.  Mandatory-to-Implement Extensions\n   In the absence of an application
      profile standard specifying\n   otherwise, a TLS-compliant application MUST
      implement the following\n   TLS extensions:\n   -  Supported Versions (\"supported_versions\";
      Section 4.2.1)\n   -  Cookie (\"cookie\"; Section 4.2.2)\n   -  Signature Algorithms
      (\"signature_algorithms\"; Section 4.2.3)\n   -  Signature Algorithms Certificate
      (\"signature_algorithms_cert\";\n      Section 4.2.3)\n   -  Negotiated Groups
      (\"supported_groups\"; Section 4.2.7)\n   -  Key Share (\"key_share\"; Section
      4.2.8)\n   -  Server Name Indication (\"server_name\"; Section 3 of [RFC6066])\n
      \  All implementations MUST send and use these extensions when offering\n   applicable
      features:\n   -  \"supported_versions\" is REQUIRED for all ClientHello, ServerHello,\n
      \     and HelloRetryRequest messages.\n   -  \"signature_algorithms\" is REQUIRED
      for certificate authentication.\n   -  \"supported_groups\" is REQUIRED for
      ClientHello messages using DHE\n      or ECDHE key exchange.\n   -  \"key_share\"
      is REQUIRED for DHE or ECDHE key exchange.\n   -  \"pre_shared_key\" is REQUIRED
      for PSK key agreement.\n   -  \"psk_key_exchange_modes\" is REQUIRED for PSK
      key agreement.\n   A client is considered to be attempting to negotiate using
      this\n   specification if the ClientHello contains a \"supported_versions\"\n
      \  extension with 0x0304 contained in its body.  Such a ClientHello\n   message
      MUST meet the following requirements:\n   -  If not containing a \"pre_shared_key\"
      extension, it MUST contain\n      both a \"signature_algorithms\" extension
      and a \"supported_groups\"\n      extension.\n   -  If containing a \"supported_groups\"
      extension, it MUST also contain\n      a \"key_share\" extension, and vice versa.
      \ An empty\n      KeyShare.client_shares vector is permitted.\n   Servers receiving
      a ClientHello which does not conform to these\n   requirements MUST abort the
      handshake with a \"missing_extension\"\n   alert.\n   Additionally, all implementations
      MUST support the use of the\n   \"server_name\" extension with applications
      capable of using it.\n   Servers MAY require clients to send a valid \"server_name\"
      extension.\n   Servers requiring this extension SHOULD respond to a ClientHello\n
      \  lacking a \"server_name\" extension by terminating the connection with\n
      \  a \"missing_extension\" alert.\n"
    title: 9.2.  Mandatory-to-Implement Extensions
  - contents:
    - "9.3.  Protocol Invariants\n   This section describes invariants that TLS endpoints
      and middleboxes\n   MUST follow.  It also applies to earlier versions of TLS.\n
      \  TLS is designed to be securely and compatibly extensible.  Newer\n   clients
      or servers, when communicating with newer peers, should\n   negotiate the most
      preferred common parameters.  The TLS handshake\n   provides downgrade protection:
      Middleboxes passing traffic between a\n   newer client and newer server without
      terminating TLS should be\n   unable to influence the handshake (see Appendix
      E.1).  At the same\n   time, deployments update at different rates, so a newer
      client or\n   server MAY continue to support older parameters, which would allow
      it\n   to interoperate with older endpoints.\n   For this to work, implementations
      MUST correctly handle extensible\n   fields:\n   -  A client sending a ClientHello
      MUST support all parameters\n      advertised in it.  Otherwise, the server
      may fail to interoperate\n      by selecting one of those parameters.\n   -
      \ A server receiving a ClientHello MUST correctly ignore all\n      unrecognized
      cipher suites, extensions, and other parameters.\n      Otherwise, it may fail
      to interoperate with newer clients.  In\n      TLS 1.3, a client receiving a
      CertificateRequest or\n      NewSessionTicket MUST also ignore all unrecognized
      extensions.\n   -  A middlebox which terminates a TLS connection MUST behave
      as a\n      compliant TLS server (to the original client), including having
      a\n      certificate which the client is willing to accept, and also as a\n
      \     compliant TLS client (to the original server), including verifying\n      the
      original server's certificate.  In particular, it MUST\n      generate its own
      ClientHello containing only parameters it\n      understands, and it MUST generate
      a fresh ServerHello random\n      value, rather than forwarding the endpoint's
      value.\n      Note that TLS's protocol requirements and security analysis only\n
      \     apply to the two connections separately.  Safely deploying a TLS\n      terminator
      requires additional security considerations which are\n      beyond the scope
      of this document.\n   -  A middlebox which forwards ClientHello parameters it
      does not\n      understand MUST NOT process any messages beyond that ClientHello.\n
      \     It MUST forward all subsequent traffic unmodified.  Otherwise, it\n      may
      fail to interoperate with newer clients and servers.\n      Forwarded ClientHellos
      may contain advertisements for features not\n      supported by the middlebox,
      so the response may include future TLS\n      additions the middlebox does not
      recognize.  These additions MAY\n      change any message beyond the ClientHello
      arbitrarily.  In\n      particular, the values sent in the ServerHello might
      change, the\n      ServerHello format might change, and the TLSCiphertext format\n
      \     might change.\n   The design of TLS 1.3 was constrained by widely deployed\n
      \  non-compliant TLS middleboxes (see Appendix D.4); however, it does\n   not
      relax the invariants.  Those middleboxes continue to be\n   non-compliant.\n"
    title: 9.3.  Protocol Invariants
  title: 9.  Compliance Requirements
- contents:
  - "10.  Security Considerations\n   Security issues are discussed throughout this
    memo, especially in\n   Appendices C, D, and E.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   This document uses several registries that were
    originally created in\n   [RFC4346] and updated in [RFC8447].  IANA has updated
    these to\n   reference this document.  The registries and their allocation\n   policies
    are below:\n   -  TLS Cipher Suites registry: values with the first byte in the\n
    \     range 0-254 (decimal) are assigned via Specification Required\n      [RFC8126].
    \ Values with the first byte 255 (decimal) are reserved\n      for Private Use
    [RFC8126].\n      IANA has added the cipher suites listed in Appendix B.4 to the\n
    \     registry.  The \"Value\" and \"Description\" columns are taken from\n      the
    table.  The \"DTLS-OK\" and \"Recommended\" columns are both\n      marked as
    \"Y\" for each new cipher suite.\n   -  TLS ContentType registry: Future values
    are allocated via\n      Standards Action [RFC8126].\n   -  TLS Alerts registry:
    Future values are allocated via Standards\n      Action [RFC8126].  IANA has populated
    this registry with the\n      values from Appendix B.2.  The \"DTLS-OK\" column
    is marked as \"Y\"\n      for all such values.  Values marked as \"_RESERVED\"
    have comments\n      describing their previous usage.\n   -  TLS HandshakeType
    registry: Future values are allocated via\n      Standards Action [RFC8126].  IANA
    has updated this registry to\n      rename item 4 from \"NewSessionTicket\" to
    \"new_session_ticket\" and\n      populated this registry with the values from
    Appendix B.3.  The\n      \"DTLS-OK\" column is marked as \"Y\" for all such values.
    \ Values\n      marked \"_RESERVED\" have comments describing their previous or\n
    \     temporary usage.\n   This document also uses the TLS ExtensionType Values
    registry\n   originally created in [RFC4366].  IANA has updated it to reference\n
    \  this document.  Changes to the registry follow:\n   -  IANA has updated the
    registration policy as follows:\n      Values with the first byte in the range
    0-254 (decimal) are\n      assigned via Specification Required [RFC8126].  Values
    with the\n      first byte 255 (decimal) are reserved for Private Use [RFC8126].\n
    \  -  IANA has updated this registry to include the \"key_share\",\n      \"pre_shared_key\",
    \"psk_key_exchange_modes\", \"early_data\",\n      \"cookie\", \"supported_versions\",
    \"certificate_authorities\",\n      \"oid_filters\", \"post_handshake_auth\",
    and\n      \"signature_algorithms_cert\" extensions with the values defined in\n
    \     this document and the \"Recommended\" value of \"Y\".\n   -  IANA has updated
    this registry to include a \"TLS 1.3\" column which\n      lists the messages
    in which the extension may appear.  This column\n      has been initially populated
    from the table in Section 4.2, with\n      any extension not listed there marked
    as \"-\" to indicate that it\n      is not used by TLS 1.3.\n   This document
    updates an entry in the TLS Certificate Types registry\n   originally created
    in [RFC6091] and updated in [RFC8447].  IANA has\n   updated the entry for value
    1 to have the name \"OpenPGP_RESERVED\",\n   \"Recommended\" value \"N\", and
    comment \"Used in TLS versions prior\n   to 1.3.\"\n   This document updates an
    entry in the TLS Certificate Status Types\n   registry originally created in [RFC6961].
    \ IANA has updated the entry\n   for value 2 to have the name \"ocsp_multi_RESERVED\"
    and comment \"Used\n   in TLS versions prior to 1.3\".\n   This document updates
    two entries in the TLS Supported Groups\n   registry (created under a different
    name by [RFC4492]; now maintained\n   by [RFC8422]) and updated by [RFC7919] and
    [RFC8447].  The entries\n   for values 29 and 30 (x25519 and x448) have been updated
    to also\n   refer to this document.\n   In addition, this document defines two
    new registries that are\n   maintained by IANA:\n   -  TLS SignatureScheme registry:
    Values with the first byte in the\n      range 0-253 (decimal) are assigned via
    Specification Required\n      [RFC8126].  Values with the first byte 254 or 255
    (decimal) are\n      reserved for Private Use [RFC8126].  Values with the first
    byte in\n      the range 0-6 or with the second byte in the range 0-3 that are\n
    \     not currently allocated are reserved for backward compatibility.\n      This
    registry has a \"Recommended\" column.  The registry has been\n      initially
    populated with the values described in Section 4.2.3.\n      The following values
    are marked as \"Recommended\":\n      ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,\n
    \     rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,\n      rsa_pss_pss_sha256,
    rsa_pss_pss_sha384, rsa_pss_pss_sha512, and\n      ed25519.  The \"Recommended\"
    column is assigned a value of \"N\"\n      unless explicitly requested, and adding
    a value with a\n      \"Recommended\" value of \"Y\" requires Standards Action
    [RFC8126].\n      IESG Approval is REQUIRED for a Y->N transition.\n   -  TLS
    PskKeyExchangeMode registry: Values in the range 0-253\n      (decimal) are assigned
    via Specification Required [RFC8126].\n      The values 254 and 255 (decimal)
    are reserved for Private Use\n      [RFC8126].  This registry has a \"Recommended\"
    column.  The\n      registry has been initially populated with psk_ke (0) and\n
    \     psk_dhe_ke (1).  Both are marked as \"Recommended\".  The\n      \"Recommended\"
    column is assigned a value of \"N\" unless explicitly\n      requested, and adding
    a value with a \"Recommended\" value of \"Y\"\n      requires Standards Action
    [RFC8126].  IESG Approval is REQUIRED\n      for a Y->N transition.\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [DH76]     Diffie, W. and M. Hellman, \"New
      directions in\n              cryptography\", IEEE Transactions on Information\n
      \             Theory, Vol. 22 No. 6, pp. 644-654,\n              DOI 10.1109/TIT.1976.1055638,
      November 1976.\n   [ECDSA]    American National Standards Institute, \"Public
      Key\n              Cryptography for the Financial Services Industry: The\n              Elliptic
      Curve Digital Signature Algorithm (ECDSA)\",\n              ANSI ANS X9.62-2005,
      November 2005.\n   [GCM]      Dworkin, M., \"Recommendation for Block Cipher
      Modes of\n              Operation: Galois/Counter Mode (GCM) and GMAC\",\n              NIST
      Special Publication 800-38D,\n              DOI 10.6028/NIST.SP.800-38D, November
      2007.\n   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n
      \             Hashing for Message Authentication\", RFC 2104,\n              DOI
      10.17487/RFC2104, February 1997,\n              <https://www.rfc-editor.org/info/rfc2104>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC5116]  McGrew,
      D., \"An Interface and Algorithms for Authenticated\n              Encryption\",
      RFC 5116, DOI 10.17487/RFC5116, January 2008,\n              <https://www.rfc-editor.org/info/rfc5116>.\n
      \  [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC5705]  Rescorla, E., \"Keying Material Exporters for Transport\n              Layer
      Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n              March 2010,
      <https://www.rfc-editor.org/info/rfc5705>.\n   [RFC5756]  Turner, S., Brown,
      D., Yiu, K., Housley, R., and T. Polk,\n              \"Updates for RSAES-OAEP
      and RSASSA-PSS Algorithm\n              Parameters\", RFC 5756, DOI 10.17487/RFC5756,
      January 2010,\n              <https://www.rfc-editor.org/info/rfc5756>.\n   [RFC5869]
      \ Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n              Key
      Derivation Function (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869,
      May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n   [RFC6066]
      \ Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:
      Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January
      2011,\n              <https://www.rfc-editor.org/info/rfc6066>.\n   [RFC6655]
      \ McGrew, D. and D. Bailey, \"AES-CCM Cipher Suites for\n              Transport
      Layer Security (TLS)\", RFC 6655,\n              DOI 10.17487/RFC6655, July
      2012,\n              <https://www.rfc-editor.org/info/rfc6655>.\n   [RFC6960]
      \ Santesson, S., Myers, M., Ankney, R., Malpani, A.,\n              Galperin,
      S., and C. Adams, \"X.509 Internet Public Key\n              Infrastructure
      Online Certificate Status Protocol - OCSP\",\n              RFC 6960, DOI 10.17487/RFC6960,
      June 2013,\n              <https://www.rfc-editor.org/info/rfc6960>.\n   [RFC6961]
      \ Pettersen, Y., \"The Transport Layer Security (TLS)\n              Multiple
      Certificate Status Request Extension\", RFC 6961,\n              DOI 10.17487/RFC6961,
      June 2013,\n              <https://www.rfc-editor.org/info/rfc6961>.\n   [RFC6962]
      \ Laurie, B., Langley, A., and E. Kasper, \"Certificate\n              Transparency\",
      RFC 6962, DOI 10.17487/RFC6962, June 2013,\n              <https://www.rfc-editor.org/info/rfc6962>.\n
      \  [RFC6979]  Pornin, T., \"Deterministic Usage of the Digital Signature\n              Algorithm
      (DSA) and Elliptic Curve Digital Signature\n              Algorithm (ECDSA)\",
      RFC 6979, DOI 10.17487/RFC6979,\n              August 2013, <https://www.rfc-editor.org/info/rfc6979>.\n
      \  [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,\n              \"Transport
      Layer Security (TLS) Application-Layer Protocol\n              Negotiation Extension\",
      RFC 7301, DOI 10.17487/RFC7301,\n              July 2014, <https://www.rfc-editor.org/info/rfc7301>.\n
      \  [RFC7507]  Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher\n
      \             Suite Value (SCSV) for Preventing Protocol Downgrade\n              Attacks\",
      RFC 7507, DOI 10.17487/RFC7507, April 2015,\n              <https://www.rfc-editor.org/info/rfc7507>.\n
      \  [RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n              for
      Security\", RFC 7748, DOI 10.17487/RFC7748,\n              January 2016, <https://www.rfc-editor.org/info/rfc7748>.\n
      \  [RFC7919]  Gillmor, D., \"Negotiated Finite Field Diffie-Hellman\n              Ephemeral
      Parameters for Transport Layer Security (TLS)\",\n              RFC 7919, DOI
      10.17487/RFC7919, August 2016,\n              <https://www.rfc-editor.org/info/rfc7919>.\n
      \  [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n              \"PKCS
      #1: RSA Cryptography Specifications Version 2.2\",\n              RFC 8017,
      DOI 10.17487/RFC8017, November 2016,\n              <https://www.rfc-editor.org/info/rfc8017>.\n
      \  [RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n              Signature
      Algorithm (EdDSA)\", RFC 8032,\n              DOI 10.17487/RFC8032, January
      2017,\n              <https://www.rfc-editor.org/info/rfc8032>.\n   [RFC8126]
      \ Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC
      2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May
      2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8439]
      \ Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF\n              Protocols\",
      RFC 8439, DOI 10.17487/RFC8439, June 2018,\n              <https://www.rfc-editor.org/info/rfc8439>.\n
      \  [SHS]      Dang, Q., \"Secure Hash Standard (SHS)\", National Institute\n
      \             of Standards and Technology report,\n              DOI 10.6028/NIST.FIPS.180-4,
      August 2015.\n   [X690]     ITU-T, \"Information technology -- ASN.1 encoding
      rules:\n              Specification of Basic Encoding Rules (BER), Canonical\n
      \             Encoding Rules (CER) and Distinguished Encoding Rules\n              (DER)\",
      ISO/IEC 8825-1:2015, November 2015.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [AEAD-LIMITS]\n              Luykx, A. and
      K. Paterson, \"Limits on Authenticated\n              Encryption Use in TLS\",
      August 2017,\n              <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.\n
      \  [BBFGKZ16]\n              Bhargavan, K., Brzuska, C., Fournet, C., Green,
      M.,\n              Kohlweiss, M., and S. Zanella-Beguelin, \"Downgrade\n              Resilience
      in Key-Exchange Protocols\", Proceedings of IEEE\n              Symposium on
      Security and Privacy (San Jose),\n              DOI 10.1109/SP.2016.37, May
      2016.\n   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, \"Verified\n
      \             Models and Reference Implementations for the TLS 1.3\n              Standard
      Candidate\", Proceedings of IEEE Symposium on\n              Security and Privacy
      (San Jose), DOI 10.1109/SP.2017.26,\n              May 2017.\n   [BDFKPPRSZZ16]\n
      \             Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,\n              Kohlweiss,
      M., Pan, J., Protzenko, J., Rastogi, A., Swamy,\n              N., Zanella-Beguelin,
      S., and J. Zinzindohoue,\n              \"Implementing and Proving the TLS 1.3
      Record Layer\",\n              Proceedings of IEEE Symposium on Security and
      Privacy (San\n              Jose), May 2017, <https://eprint.iacr.org/2016/1178>.\n
      \  [Ben17a]   Benjamin, D., \"Presentation before the TLS WG at\n              IETF
      100\", November 2017,\n              <https://datatracker.ietf.org/meeting/100/materials/\n
      \             slides-100-tls-sessa-tls13/>.\n   [Ben17b]   Benjamin, D., \"Additional
      TLS 1.3 results from Chrome\",\n              message to the TLS mailing list,
      18 December 2017,\n              <https://www.ietf.org/mail-archive/web/tls/current/\n
      \             msg25168.html>.\n   [Blei98]   Bleichenbacher, D., \"Chosen Ciphertext
      Attacks against\n              Protocols Based on RSA Encryption Standard PKCS
      #1\",\n              Proceedings of CRYPTO '98, 1998.\n   [BMMRT15]  Badertscher,
      C., Matt, C., Maurer, U., Rogaway, P., and B.\n              Tackmann, \"Augmented
      Secure Channels and the Goal of the\n              TLS 1.3 Record Layer\", ProvSec
      2015, September 2015,\n              <https://eprint.iacr.org/2015/394>.\n   [BT16]
      \    Bellare, M. and B. Tackmann, \"The Multi-User Security of\n              Authenticated
      Encryption: AES-GCM in TLS 1.3\", Proceedings\n              of CRYPTO 2016,
      July 2016,\n              <https://eprint.iacr.org/2016/564>.\n   [CCG16]    Cohn-Gordon,
      K., Cremers, C., and L. Garratt, \"On\n              Post-compromise Security\",
      IEEE Computer Security\n              Foundations Symposium, DOI 10.1109/CSF.2016.19,
      July 2015.\n   [CHECKOWAY]\n              Checkoway, S., Maskiewicz, J., Garman,
      C., Fried, J.,\n              Cohney, S., Green, M., Heninger, N., Weinmann,
      R.,\n              Rescorla, E., and H. Shacham, \"A Systematic Analysis of\n
      \             the Juniper Dual EC Incident\", Proceedings of the 2016 ACM\n
      \             SIGSAC Conference on Computer and Communications Security\n              -
      CCS '16, DOI 10.1145/2976749.2978395, October 2016.\n   [CHHSV17]  Cremers,
      C., Horvat, M., Hoyland, J., Scott, S., and T.\n              van der Merwe,
      \"Awkward Handshake: Possible mismatch of\n              client/server view
      on client authentication in\n              post-handshake mode in Revision 18\",
      message to the TLS\n              mailing list, 10 February 2017, <https://www.ietf.org/\n
      \             mail-archive/web/tls/current/msg22382.html>.\n   [CHSV16]   Cremers,
      C., Horvat, M., Scott, S., and T. van der Merwe,\n              \"Automated
      Analysis and Verification of TLS 1.3: 0-RTT,\n              Resumption and Delayed
      Authentication\", Proceedings of\n              IEEE Symposium on Security and
      Privacy (San Jose),\n              DOI 10.1109/SP.2016.35, May 2016,\n              <https://ieeexplore.ieee.org/document/7546518/>.\n
      \  [CK01]     Canetti, R. and H. Krawczyk, \"Analysis of Key-Exchange\n              Protocols
      and Their Use for Building Secure Channels\",\n              Proceedings of
      Eurocrypt 2001,\n              DOI 10.1007/3-540-44987-6_28, April 2001.\n   [CLINIC]
      \  Miller, B., Huang, L., Joseph, A., and J. Tygar, \"I Know\n              Why
      You Went to the Clinic: Risks and Realization of HTTPS\n              Traffic
      Analysis\", Privacy Enhancing Technologies, pp.\n              143-163, DOI
      10.1007/978-3-319-08506-7_8, 2014.\n   [DFGS15]   Dowling, B., Fischlin, M.,
      Guenther, F., and D. Stebila,\n              \"A Cryptographic Analysis of the
      TLS 1.3 Handshake\n              Protocol Candidates\", Proceedings of ACM CCS
      2015,\n              October 2015, <https://eprint.iacr.org/2015/914>.\n   [DFGS16]
      \  Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,\n              \"A
      Cryptographic Analysis of the TLS 1.3 Full and\n              Pre-shared Key
      Handshake Protocol\", TRON 2016,\n              February 2016, <https://eprint.iacr.org/2016/081>.\n
      \  [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,\n              \"Authentication
      and authenticated key exchanges\", Designs,\n              Codes and Cryptography,
      DOI 10.1007/BF00124891, June 1992.\n   [DSS]      National Institute of Standards
      and Technology, U.S.\n              Department of Commerce, \"Digital Signature
      Standard\n              (DSS)\", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,\n
      \             July 2013.\n   [FG17]     Fischlin, M. and F. Guenther, \"Replay
      Attacks on Zero\n              Round-Trip Time: The Case of the TLS 1.3 Handshake\n
      \             Candidates\", Proceedings of EuroS&P 2017, April 2017,\n              <https://eprint.iacr.org/2017/082>.\n
      \  [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,\n              \"Key
      Confirmation in Key Exchange: A Formal Treatment and\n              Implications
      for TLS 1.3\", Proceedings of IEEE Symposium\n              on Security and
      Privacy (San Jose),\n              DOI 10.1109/SP.2016.34, May 2016,\n              <https://ieeexplore.ieee.org/document/7546517/>.\n
      \  [FW15]     Weimer, F., \"Factoring RSA Keys With TLS Perfect Forward\n              Secrecy\",
      September 2015.\n   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda,
      \"HTTPS\n              traffic analysis and client identification using passive\n
      \             SSL/TLS fingerprinting\", EURASIP Journal on Information\n              Security,
      Vol. 2016, DOI 10.1186/s13635-016-0030-7,\n              February 2016.\n   [HGFS15]
      \  Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,\n              \"Prying
      Open Pandora's Box: KCI Attacks against TLS\",\n              Proceedings of
      USENIX Workshop on Offensive Technologies,\n              August 2015.\n   [IEEE1363]\n
      \             IEEE, \"IEEE Standard Specifications for Public Key\n              Cryptography\",
      IEEE Std. 1363-2000,\n              DOI 10.1109/IEEESTD.2000.92292.\n   [JSS15]
      \   Jager, T., Schwenk, J., and J. Somorovsky, \"On the\n              Security
      of TLS 1.3 and QUIC Against Weaknesses in PKCS#1\n              v1.5 Encryption\",
      Proceedings of ACM CCS 2015,\n              DOI 10.1145/2810103.2813657, October
      2015,\n              <https://www.nds.rub.de/media/nds/\n              veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf>.\n
      \  [KEYAGREEMENT]\n              Barker, E., Chen, L., Roginsky, A., Vassilev,
      A., and R.\n              Davis, \"Recommendation for Pair-Wise Key Establishment\n
      \             Schemes Using Discrete Logarithm Cryptography\", National\n              Institute
      of Standards and Technology,\n              DOI 10.6028/NIST.SP.800-56Ar3, April
      2018.\n   [Kraw10]   Krawczyk, H., \"Cryptographic Extraction and Key\n              Derivation:
      The HKDF Scheme\", Proceedings of CRYPTO 2010,\n              August 2010, <https://eprint.iacr.org/2010/264>.\n
      \  [Kraw16]   Krawczyk, H., \"A Unilateral-to-Mutual Authentication\n              Compiler
      for Key Exchange (with Applications to Client\n              Authentication
      in TLS 1.3\", Proceedings of ACM CCS 2016,\n              October 2016, <https://eprint.iacr.org/2016/711>.\n
      \  [KW16]     Krawczyk, H. and H. Wee, \"The OPTLS Protocol and TLS 1.3\",\n
      \             Proceedings of EuroS&P 2016, March 2016,\n              <https://eprint.iacr.org/2015/978>.\n
      \  [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, \"Multiple\n              Handshakes
      Security of TLS 1.3 Candidates\", Proceedings of\n              IEEE Symposium
      on Security and Privacy (San Jose),\n              DOI 10.1109/SP.2016.36, May
      2016,\n              <https://ieeexplore.ieee.org/document/7546519/>.\n   [Mac17]
      \   MacCarthaigh, C., \"Security Review of TLS1.3 0-RTT\",\n              March
      2017, <https://github.com/tlswg/tls13-spec/\n              issues/1001>.\n   [PS18]
      \    Patton, C. and T. Shrimpton, \"Partially specified\n              channels:
      The TLS 1.3 record layer without elision\", 2018,\n              <https://eprint.iacr.org/2018/634>.\n
      \  [PSK-FINISHED]\n              Scott, S., Cremers, C., Horvat, M., and T.
      van der Merwe,\n              \"Revision 10: possible attack if client authentication
      is\n              allowed during PSK\", message to the TLS mailing list,\n              31
      October 2015, <https://www.ietf.org/\n              mail-archive/web/tls/current/msg18215.html>.\n
      \  [REKEY]    Abdalla, M. and M. Bellare, \"Increasing the Lifetime of a\n              Key:
      A Comparative Analysis of the Security of Re-keying\n              Techniques\",
      ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,\n              October 2000.\n
      \  [Res17a]   Rescorla, E., \"Preliminary data on Firefox TLS 1.3\n              Middlebox
      experiment\", message to the TLS mailing list,\n              5 December 2017,
      <https://www.ietf.org/\n              mail-archive/web/tls/current/msg25091.html>.\n
      \  [Res17b]   Rescorla, E., \"More compatibility measurement results\",\n              message
      to the TLS mailing list, 22 December 2017,\n              <https://www.ietf.org/mail-archive/web/tls/current/\n
      \             msg25179.html>.\n   [RFC3552]  Rescorla, E. and B. Korver, \"Guidelines
      for Writing RFC\n              Text on Security Considerations\", BCP 72, RFC
      3552,\n              DOI 10.17487/RFC3552, July 2003,\n              <https://www.rfc-editor.org/info/rfc3552>.\n
      \  [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness
      Requirements for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086,
      June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n   [RFC4346]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.1\", RFC 4346,\n              DOI 10.17487/RFC4346, April
      2006,\n              <https://www.rfc-editor.org/info/rfc4346>.\n   [RFC4366]
      \ Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,\n              and
      T. Wright, \"Transport Layer Security (TLS)\n              Extensions\", RFC
      4366, DOI 10.17487/RFC4366, April 2006,\n              <https://www.rfc-editor.org/info/rfc4366>.\n
      \  [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.\n              Moeller,
      \"Elliptic Curve Cryptography (ECC) Cipher Suites\n              for Transport
      Layer Security (TLS)\", RFC 4492,\n              DOI 10.17487/RFC4492, May 2006,\n
      \             <https://www.rfc-editor.org/info/rfc4492>.\n   [RFC5077]  Salowey,
      J., Zhou, H., Eronen, P., and H. Tschofenig,\n              \"Transport Layer
      Security (TLS) Session Resumption without\n              Server-Side State\",
      RFC 5077, DOI 10.17487/RFC5077,\n              January 2008, <https://www.rfc-editor.org/info/rfc5077>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5764]
      \ McGrew, D. and E. Rescorla, \"Datagram Transport Layer\n              Security
      (DTLS) Extension to Establish Keys for the Secure\n              Real-time Transport
      Protocol (SRTP)\", RFC 5764,\n              DOI 10.17487/RFC5764, May 2010,\n
      \             <https://www.rfc-editor.org/info/rfc5764>.\n   [RFC5929]  Altman,
      J., Williams, N., and L. Zhu, \"Channel Bindings\n              for TLS\", RFC
      5929, DOI 10.17487/RFC5929, July 2010,\n              <https://www.rfc-editor.org/info/rfc5929>.\n
      \  [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys\n              for
      Transport Layer Security (TLS) Authentication\",\n              RFC 6091, DOI
      10.17487/RFC6091, February 2011,\n              <https://www.rfc-editor.org/info/rfc6091>.\n
      \  [RFC6101]  Freier, A., Karlton, P., and P. Kocher, \"The Secure\n              Sockets
      Layer (SSL) Protocol Version 3.0\", RFC 6101,\n              DOI 10.17487/RFC6101,
      August 2011,\n              <https://www.rfc-editor.org/info/rfc6101>.\n   [RFC6176]
      \ Turner, S. and T. Polk, \"Prohibiting Secure Sockets Layer\n              (SSL)
      Version 2.0\", RFC 6176, DOI 10.17487/RFC6176,\n              March 2011, <https://www.rfc-editor.org/info/rfc6176>.\n
      \  [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security
      Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012,
      <https://www.rfc-editor.org/info/rfc6347>.\n   [RFC6520]  Seggelmann, R., Tuexen,
      M., and M. Williams, \"Transport\n              Layer Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS) Heartbeat Extension\", RFC 6520,\n
      \             DOI 10.17487/RFC6520, February 2012,\n              <https://www.rfc-editor.org/info/rfc6520>.\n
      \  [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC
      7230, DOI 10.17487/RFC7230, June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n
      \  [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,\n              Weiler,
      S., and T. Kivinen, \"Using Raw Public Keys in\n              Transport Layer
      Security (TLS) and Datagram Transport\n              Layer Security (DTLS)\",
      RFC 7250, DOI 10.17487/RFC7250,\n              June 2014, <https://www.rfc-editor.org/info/rfc7250>.\n
      \  [RFC7465]  Popov, A., \"Prohibiting RC4 Cipher Suites\", RFC 7465,\n              DOI
      10.17487/RFC7465, February 2015,\n              <https://www.rfc-editor.org/info/rfc7465>.\n
      \  [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,\n              \"Deprecating
      Secure Sockets Layer Version 3.0\", RFC 7568,\n              DOI 10.17487/RFC7568,
      June 2015,\n              <https://www.rfc-editor.org/info/rfc7568>.\n   [RFC7627]
      \ Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n              Langley,
      A., and M. Ray, \"Transport Layer Security (TLS)\n              Session Hash
      and Extended Master Secret Extension\",\n              RFC 7627, DOI 10.17487/RFC7627,
      September 2015,\n              <https://www.rfc-editor.org/info/rfc7627>.\n
      \  [RFC7685]  Langley, A., \"A Transport Layer Security (TLS) ClientHello\n
      \             Padding Extension\", RFC 7685, DOI 10.17487/RFC7685,\n              October
      2015, <https://www.rfc-editor.org/info/rfc7685>.\n   [RFC7924]  Santesson, S.
      and H. Tschofenig, \"Transport Layer Security\n              (TLS) Cached Information
      Extension\", RFC 7924,\n              DOI 10.17487/RFC7924, July 2016,\n              <https://www.rfc-editor.org/info/rfc7924>.\n
      \  [RFC8305]  Schinazi, D. and T. Pauly, \"Happy Eyeballs Version 2:\n              Better
      Connectivity Using Concurrency\", RFC 8305,\n              DOI 10.17487/RFC8305,
      December 2017,\n              <https://www.rfc-editor.org/info/rfc8305>.\n   [RFC8422]
      \ Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, \"Elliptic\n              Curve
      Cryptography (ECC) Cipher Suites for Transport Layer\n              Security
      (TLS) Versions 1.2 and Earlier\", RFC 8422,\n              DOI 10.17487/RFC8422,
      August 2018,\n              <https://www.rfc-editor.org/info/rfc8422>.\n   [RFC8447]
      \ Salowey, J. and S. Turner, \"IANA Registry Updates for TLS\n              and
      DTLS\", RFC 8447, DOI 10.17487/RFC8447, August 2018,\n              <https://www.rfc-editor.org/info/rfc8447>.\n
      \  [RFC8449]  Thomson, M., \"Record Size Limit Extension for TLS\",\n              RFC
      8449, DOI 10.17487/RFC8449, August 2018,\n              <https://www.rfc-editor.org/info/rfc8449>.\n
      \  [RSA]      Rivest, R., Shamir, A., and L. Adleman, \"A Method for\n              Obtaining
      Digital Signatures and Public-Key\n              Cryptosystems\", Communications
      of the ACM, Vol. 21 No. 2,\n              pp. 120-126, DOI 10.1145/359340.359342,
      February 1978.\n   [SIGMA]    Krawczyk, H., \"SIGMA: The 'SIGn-and-MAc' Approach
      to\n              Authenticated Diffie-Hellman and its Use in the IKE\n              Protocols\",
      Proceedings of CRYPTO 2003,\n              DOI 10.1007/978-3-540-45146-4_24,
      August 2003.\n   [SLOTH]    Bhargavan, K. and G. Leurent, \"Transcript Collision\n
      \             Attacks: Breaking Authentication in TLS, IKE, and SSH\",\n              Network
      and Distributed System Security\n              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,\n
      \             February 2016.\n   [SSL2]     Hickman, K., \"The SSL Protocol\",
      February 1995.\n   [TIMING]   Boneh, D. and D. Brumley, \"Remote Timing Attacks
      Are\n              Practical\", USENIX Security Symposium, August 2003.\n   [TLS13-TRACES]\n
      \             Thomson, M., \"Example Handshake Traces for TLS 1.3\", Work\n
      \             in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.\n   [X501]
      \    ITU-T, \"Information Technology - Open Systems\n              Interconnection
      - The Directory: Models\", ITU-T X.501,\n              October 2016, <https://www.itu.int/rec/T-REC-X.501/en>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  State Machine\n   This appendix provides a summary of the legal
    state transitions for\n   the client and server handshakes.  State names (in all
    capitals,\n   e.g., START) have no formal meaning but are provided for ease of\n
    \  comprehension.  Actions which are taken only in certain circumstances\n   are
    indicated in [].  The notation \"K_{send,recv} = foo\" means \"set\n   the send/recv
    key to the given key\".\n"
  - contents:
    - "A.1.  Client\n                              START <----+\n               Send
      ClientHello |        | Recv HelloRetryRequest\n          [K_send = early data]
      |        |\n                                v        |\n           /                 WAIT_SH
      ----+\n           |                    | Recv ServerHello\n           |                    |
      K_recv = handshake\n       Can |                    V\n      send |                 WAIT_EE\n
      \    early |                    | Recv EncryptedExtensions\n      data |           +--------+--------+\n
      \          |     Using |                 | Using certificate\n           |       PSK
      |                 v\n           |           |            WAIT_CERT_CR\n           |
      \          |        Recv |       | Recv CertificateRequest\n           |           |
      Certificate |       v\n           |           |             |    WAIT_CERT\n
      \          |           |             |       | Recv Certificate\n           |
      \          |             v       v\n           |           |              WAIT_CV\n
      \          |           |                 | Recv CertificateVerify\n           |
      \          +> WAIT_FINISHED <+\n           |                  | Recv Finished\n
      \          \\                  | [Send EndOfEarlyData]\n                              |
      K_send = handshake\n                              | [Send Certificate [+ CertificateVerify]]\n
      \   Can send                  | Send Finished\n    app data   -->            |
      K_send = K_recv = application\n    after here                v\n                          CONNECTED\n
      \  Note that with the transitions as shown above, clients may send\n   alerts
      that derive from post-ServerHello messages in the clear or\n   with the early
      data keys.  If clients need to send such alerts, they\n   SHOULD first rekey
      to the handshake keys if possible.\n"
    title: A.1.  Client
  - contents:
    - "A.2.  Server\n                              START <-----+\n               Recv
      ClientHello |         | Send HelloRetryRequest\n                                v
      \        |\n                             RECVD_CH ----+\n                                |
      Select parameters\n                                v\n                             NEGOTIATED\n
      \                               | Send ServerHello\n                                |
      K_send = handshake\n                                | Send EncryptedExtensions\n
      \                               | [Send CertificateRequest]\n Can send                       |
      [Send Certificate + CertificateVerify]\n app data                       | Send
      Finished\n after   -->                    | K_send = application\n here                  +--------+--------+\n
      \             No 0-RTT |                 | 0-RTT\n                       |                 |\n
      \  K_recv = handshake  |                 | K_recv = early data\n [Skip decrypt
      errors] |    +------> WAIT_EOED -+\n                       |    |       Recv
      |      | Recv EndOfEarlyData\n                       |    | early data |      |
      K_recv = handshake\n                       |    +------------+      |\n                       |
      \                       |\n                       +> WAIT_FLIGHT2 <--------+\n
      \                               |\n                       +--------+--------+\n
      \              No auth |                 | Client auth\n                       |
      \                |\n                       |                 v\n                       |
      \            WAIT_CERT\n                       |        Recv |       | Recv
      Certificate\n                       |       empty |       v\n                       |
      Certificate |    WAIT_CV\n                       |             |       | Recv\n
      \                      |             v       | CertificateVerify\n                       +->
      WAIT_FINISHED <---+\n                                | Recv Finished\n                                |
      K_recv = application\n                                v\n                            CONNECTED\n"
    title: A.2.  Server
  title: Appendix A.  State Machine
- contents:
  - "Appendix B.  Protocol Data Structures and Constant Values\n   This appendix provides
    the normative protocol types and the\n   definitions for constants.  Values listed
    as \"_RESERVED\" were used in\n   previous versions of TLS and are listed here
    for completeness.\n   TLS 1.3 implementations MUST NOT send them but might receive
    them\n   from older TLS implementations.\n"
  - contents:
    - "B.1.  Record Layer\n      enum {\n          invalid(0),\n          change_cipher_spec(20),\n
      \         alert(21),\n          handshake(22),\n          application_data(23),\n
      \         heartbeat(24),  /* RFC 6520 */\n          (255)\n      } ContentType;\n
      \     struct {\n          ContentType type;\n          ProtocolVersion legacy_record_version;\n
      \         uint16 length;\n          opaque fragment[TLSPlaintext.length];\n
      \     } TLSPlaintext;\n      struct {\n          opaque content[TLSPlaintext.length];\n
      \         ContentType type;\n          uint8 zeros[length_of_padding];\n      }
      TLSInnerPlaintext;\n      struct {\n          ContentType opaque_type = application_data;
      /* 23 */\n          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2
      */\n          uint16 length;\n          opaque encrypted_record[TLSCiphertext.length];\n
      \     } TLSCiphertext;\n"
    title: B.1.  Record Layer
  - contents:
    - "B.2.  Alert Messages\n      enum { warning(1), fatal(2), (255) } AlertLevel;\n
      \     enum {\n          close_notify(0),\n          unexpected_message(10),\n
      \         bad_record_mac(20),\n          decryption_failed_RESERVED(21),\n          record_overflow(22),\n
      \         decompression_failure_RESERVED(30),\n          handshake_failure(40),\n
      \         no_certificate_RESERVED(41),\n          bad_certificate(42),\n          unsupported_certificate(43),\n
      \         certificate_revoked(44),\n          certificate_expired(45),\n          certificate_unknown(46),\n
      \         illegal_parameter(47),\n          unknown_ca(48),\n          access_denied(49),\n
      \         decode_error(50),\n          decrypt_error(51),\n          export_restriction_RESERVED(60),\n
      \         protocol_version(70),\n          insufficient_security(71),\n          internal_error(80),\n
      \         inappropriate_fallback(86),\n          user_canceled(90),\n          no_renegotiation_RESERVED(100),\n
      \         missing_extension(109),\n          unsupported_extension(110),\n          certificate_unobtainable_RESERVED(111),\n
      \         unrecognized_name(112),\n          bad_certificate_status_response(113),\n
      \         bad_certificate_hash_value_RESERVED(114),\n          unknown_psk_identity(115),\n
      \         certificate_required(116),\n          no_application_protocol(120),\n
      \         (255)\n      } AlertDescription;\n      struct {\n          AlertLevel
      level;\n          AlertDescription description;\n      } Alert;\n"
    title: B.2.  Alert Messages
  - contents:
    - "B.3.  Handshake Protocol\n      enum {\n          hello_request_RESERVED(0),\n
      \         client_hello(1),\n          server_hello(2),\n          hello_verify_request_RESERVED(3),\n
      \         new_session_ticket(4),\n          end_of_early_data(5),\n          hello_retry_request_RESERVED(6),\n
      \         encrypted_extensions(8),\n          certificate(11),\n          server_key_exchange_RESERVED(12),\n
      \         certificate_request(13),\n          server_hello_done_RESERVED(14),\n
      \         certificate_verify(15),\n          client_key_exchange_RESERVED(16),\n
      \         finished(20),\n          certificate_url_RESERVED(21),\n          certificate_status_RESERVED(22),\n
      \         supplemental_data_RESERVED(23),\n          key_update(24),\n          message_hash(254),\n
      \         (255)\n      } HandshakeType;\n      struct {\n          HandshakeType
      msg_type;    /* handshake type */\n          uint24 length;             /* bytes
      in message */\n          select (Handshake.msg_type) {\n              case client_hello:
      \         ClientHello;\n              case server_hello:          ServerHello;\n
      \             case end_of_early_data:     EndOfEarlyData;\n              case
      encrypted_extensions:  EncryptedExtensions;\n              case certificate_request:
      \  CertificateRequest;\n              case certificate:           Certificate;\n
      \             case certificate_verify:    CertificateVerify;\n              case
      finished:              Finished;\n              case new_session_ticket:    NewSessionTicket;\n
      \             case key_update:            KeyUpdate;\n          };\n      }
      Handshake;\n"
    - contents:
      - "B.3.1.  Key Exchange Messages\n    uint16 ProtocolVersion;\n    opaque Random[32];\n
        \   uint8 CipherSuite[2];    /* Cryptographic suite selector */\n    struct
        {\n        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */\n        Random
        random;\n        opaque legacy_session_id<0..32>;\n        CipherSuite cipher_suites<2..2^16-2>;\n
        \       opaque legacy_compression_methods<1..2^8-1>;\n        Extension extensions<8..2^16-1>;\n
        \   } ClientHello;\n    struct {\n        ProtocolVersion legacy_version =
        0x0303;    /* TLS v1.2 */\n        Random random;\n        opaque legacy_session_id_echo<0..32>;\n
        \       CipherSuite cipher_suite;\n        uint8 legacy_compression_method
        = 0;\n        Extension extensions<6..2^16-1>;\n    } ServerHello;\n    struct
        {\n        ExtensionType extension_type;\n        opaque extension_data<0..2^16-1>;\n
        \   } Extension;\n    enum {\n        server_name(0),                             /*
        RFC 6066 */\n        max_fragment_length(1),                     /* RFC 6066
        */\n        status_request(5),                          /* RFC 6066 */\n        supported_groups(10),
        \                      /* RFC 8422, 7919 */\n        signature_algorithms(13),
        \                  /* RFC 8446 */\n        use_srtp(14),                               /*
        RFC 5764 */\n        heartbeat(15),                              /* RFC 6520
        */\n        application_layer_protocol_negotiation(16), /* RFC 7301 */\n        signed_certificate_timestamp(18),
        \          /* RFC 6962 */\n        client_certificate_type(19),                /*
        RFC 7250 */\n        server_certificate_type(20),                /* RFC 7250
        */\n        padding(21),                                /* RFC 7685 */\n        RESERVED(40),
        \                              /* Used but never\n                                                       assigned
        */\n        pre_shared_key(41),                         /* RFC 8446 */\n        early_data(42),
        \                            /* RFC 8446 */\n        supported_versions(43),
        \                    /* RFC 8446 */\n        cookie(44),                                 /*
        RFC 8446 */\n        psk_key_exchange_modes(45),                 /* RFC 8446
        */\n        RESERVED(46),                               /* Used but never\n
        \                                                      assigned */\n        certificate_authorities(47),
        \               /* RFC 8446 */\n        oid_filters(48),                            /*
        RFC 8446 */\n        post_handshake_auth(49),                    /* RFC 8446
        */\n        signature_algorithms_cert(50),              /* RFC 8446 */\n        key_share(51),
        \                             /* RFC 8446 */\n        (65535)\n    } ExtensionType;\n
        \   struct {\n        NamedGroup group;\n        opaque key_exchange<1..2^16-1>;\n
        \   } KeyShareEntry;\n    struct {\n        KeyShareEntry client_shares<0..2^16-1>;\n
        \   } KeyShareClientHello;\n    struct {\n        NamedGroup selected_group;\n
        \   } KeyShareHelloRetryRequest;\n    struct {\n        KeyShareEntry server_share;\n
        \   } KeyShareServerHello;\n    struct {\n        uint8 legacy_form = 4;\n
        \       opaque X[coordinate_length];\n        opaque Y[coordinate_length];\n
        \   } UncompressedPointRepresentation;\n    enum { psk_ke(0), psk_dhe_ke(1),
        (255) } PskKeyExchangeMode;\n    struct {\n        PskKeyExchangeMode ke_modes<1..255>;\n
        \   } PskKeyExchangeModes;\n    struct {} Empty;\n    struct {\n        select
        (Handshake.msg_type) {\n            case new_session_ticket:   uint32 max_early_data_size;\n
        \           case client_hello:         Empty;\n            case encrypted_extensions:
        Empty;\n        };\n    } EarlyDataIndication;\n    struct {\n        opaque
        identity<1..2^16-1>;\n        uint32 obfuscated_ticket_age;\n    } PskIdentity;\n
        \   opaque PskBinderEntry<32..255>;\n    struct {\n        PskIdentity identities<7..2^16-1>;\n
        \       PskBinderEntry binders<33..2^16-1>;\n    } OfferedPsks;\n    struct
        {\n        select (Handshake.msg_type) {\n            case client_hello: OfferedPsks;\n
        \           case server_hello: uint16 selected_identity;\n        };\n    }
        PreSharedKeyExtension;\n"
      - contents:
        - "B.3.1.1.  Version Extension\n      struct {\n          select (Handshake.msg_type)
          {\n              case client_hello:\n                   ProtocolVersion
          versions<2..254>;\n              case server_hello: /* and HelloRetryRequest
          */\n                   ProtocolVersion selected_version;\n          };\n
          \     } SupportedVersions;\n"
        title: B.3.1.1.  Version Extension
      - contents:
        - "B.3.1.2.  Cookie Extension\n      struct {\n          opaque cookie<1..2^16-1>;\n
          \     } Cookie;\n"
        title: B.3.1.2.  Cookie Extension
      - contents:
        - "B.3.1.3.  Signature Algorithm Extension\n      enum {\n          /* RSASSA-PKCS1-v1_5
          algorithms */\n          rsa_pkcs1_sha256(0x0401),\n          rsa_pkcs1_sha384(0x0501),\n
          \         rsa_pkcs1_sha512(0x0601),\n          /* ECDSA algorithms */\n
          \         ecdsa_secp256r1_sha256(0x0403),\n          ecdsa_secp384r1_sha384(0x0503),\n
          \         ecdsa_secp521r1_sha512(0x0603),\n          /* RSASSA-PSS algorithms
          with public key OID rsaEncryption */\n          rsa_pss_rsae_sha256(0x0804),\n
          \         rsa_pss_rsae_sha384(0x0805),\n          rsa_pss_rsae_sha512(0x0806),\n
          \         /* EdDSA algorithms */\n          ed25519(0x0807),\n          ed448(0x0808),\n
          \         /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */\n          rsa_pss_pss_sha256(0x0809),\n
          \         rsa_pss_pss_sha384(0x080a),\n          rsa_pss_pss_sha512(0x080b),\n
          \         /* Legacy algorithms */\n          rsa_pkcs1_sha1(0x0201),\n          ecdsa_sha1(0x0203),\n
          \         /* Reserved Code Points */\n          obsolete_RESERVED(0x0000..0x0200),\n
          \         dsa_sha1_RESERVED(0x0202),\n          obsolete_RESERVED(0x0204..0x0400),\n
          \         dsa_sha256_RESERVED(0x0402),\n          obsolete_RESERVED(0x0404..0x0500),\n
          \         dsa_sha384_RESERVED(0x0502),\n          obsolete_RESERVED(0x0504..0x0600),\n
          \         dsa_sha512_RESERVED(0x0602),\n          obsolete_RESERVED(0x0604..0x06FF),\n
          \         private_use(0xFE00..0xFFFF),\n          (0xFFFF)\n      } SignatureScheme;\n
          \     struct {\n          SignatureScheme supported_signature_algorithms<2..2^16-2>;\n
          \     } SignatureSchemeList;\n"
        title: B.3.1.3.  Signature Algorithm Extension
      - contents:
        - "B.3.1.4.  Supported Groups Extension\n      enum {\n          unallocated_RESERVED(0x0000),\n
          \         /* Elliptic Curve Groups (ECDHE) */\n          obsolete_RESERVED(0x0001..0x0016),\n
          \         secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),\n          obsolete_RESERVED(0x001A..0x001C),\n
          \         x25519(0x001D), x448(0x001E),\n          /* Finite Field Groups
          (DHE) */\n          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),\n
          \         ffdhe6144(0x0103), ffdhe8192(0x0104),\n          /* Reserved Code
          Points */\n          ffdhe_private_use(0x01FC..0x01FF),\n          ecdhe_private_use(0xFE00..0xFEFF),\n
          \         obsolete_RESERVED(0xFF01..0xFF02),\n          (0xFFFF)\n      }
          NamedGroup;\n      struct {\n          NamedGroup named_group_list<2..2^16-1>;\n
          \     } NamedGroupList;\n   Values within \"obsolete_RESERVED\" ranges are
          used in previous\n   versions of TLS and MUST NOT be offered or negotiated
          by TLS 1.3\n   implementations.  The obsolete curves have various known/theoretical\n
          \  weaknesses or have had very little usage, in some cases only due to\n
          \  unintentional server configuration issues.  They are no longer\n   considered
          appropriate for general use and should be assumed to be\n   potentially
          unsafe.  The set of curves specified here is sufficient\n   for interoperability
          with all currently deployed and properly\n   configured TLS implementations.\n"
        title: B.3.1.4.  Supported Groups Extension
      title: B.3.1.  Key Exchange Messages
    - contents:
      - "B.3.2.  Server Parameters Messages\n      opaque DistinguishedName<1..2^16-1>;\n
        \     struct {\n          DistinguishedName authorities<3..2^16-1>;\n      }
        CertificateAuthoritiesExtension;\n      struct {\n          opaque certificate_extension_oid<1..2^8-1>;\n
        \         opaque certificate_extension_values<0..2^16-1>;\n      } OIDFilter;\n
        \     struct {\n          OIDFilter filters<0..2^16-1>;\n      } OIDFilterExtension;\n
        \     struct {} PostHandshakeAuth;\n      struct {\n          Extension extensions<0..2^16-1>;\n
        \     } EncryptedExtensions;\n      struct {\n          opaque certificate_request_context<0..2^8-1>;\n
        \         Extension extensions<2..2^16-1>;\n      } CertificateRequest;\n"
      title: B.3.2.  Server Parameters Messages
    - contents:
      - "B.3.3.  Authentication Messages\n      enum {\n          X509(0),\n          OpenPGP_RESERVED(1),\n
        \         RawPublicKey(2),\n          (255)\n      } CertificateType;\n      struct
        {\n          select (certificate_type) {\n              case RawPublicKey:\n
        \               /* From RFC 7250 ASN.1_subjectPublicKeyInfo */\n                opaque
        ASN1_subjectPublicKeyInfo<1..2^24-1>;\n              case X509:\n                opaque
        cert_data<1..2^24-1>;\n          };\n          Extension extensions<0..2^16-1>;\n
        \     } CertificateEntry;\n      struct {\n          opaque certificate_request_context<0..2^8-1>;\n
        \         CertificateEntry certificate_list<0..2^24-1>;\n      } Certificate;\n
        \     struct {\n          SignatureScheme algorithm;\n          opaque signature<0..2^16-1>;\n
        \     } CertificateVerify;\n      struct {\n          opaque verify_data[Hash.length];\n
        \     } Finished;\n"
      title: B.3.3.  Authentication Messages
    - contents:
      - "B.3.4.  Ticket Establishment\n      struct {\n          uint32 ticket_lifetime;\n
        \         uint32 ticket_age_add;\n          opaque ticket_nonce<0..255>;\n
        \         opaque ticket<1..2^16-1>;\n          Extension extensions<0..2^16-2>;\n
        \     } NewSessionTicket;\n"
      title: B.3.4.  Ticket Establishment
    - contents:
      - "B.3.5.  Updating Keys\n      struct {} EndOfEarlyData;\n      enum {\n          update_not_requested(0),
        update_requested(1), (255)\n      } KeyUpdateRequest;\n      struct {\n          KeyUpdateRequest
        request_update;\n      } KeyUpdate;\n"
      title: B.3.5.  Updating Keys
    title: B.3.  Handshake Protocol
  - contents:
    - "B.4.  Cipher Suites\n   A symmetric cipher suite defines the pair of the AEAD
      algorithm and\n   hash algorithm to be used with HKDF.  Cipher suite names follow
      the\n   naming convention:\n      CipherSuite TLS_AEAD_HASH = VALUE;\n      +-----------+------------------------------------------------+\n
      \     | Component | Contents                                       |\n      +-----------+------------------------------------------------+\n
      \     | TLS       | The string \"TLS\"                               |\n      |
      \          |                                                |\n      | AEAD
      \     | The AEAD algorithm used for record protection  |\n      |           |
      \                                               |\n      | HASH      | The hash
      algorithm used with HKDF              |\n      |           |                                                |\n
      \     | VALUE     | The two-byte ID assigned for this cipher suite |\n      +-----------+------------------------------------------------+\n
      \  This specification defines the following cipher suites for use with\n   TLS
      1.3.\n              +------------------------------+-------------+\n              |
      Description                  | Value       |\n              +------------------------------+-------------+\n
      \             | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |\n              |
      \                             |             |\n              | TLS_AES_256_GCM_SHA384
      \      | {0x13,0x02} |\n              |                              |             |\n
      \             | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |\n              |
      \                             |             |\n              | TLS_AES_128_CCM_SHA256
      \      | {0x13,0x04} |\n              |                              |             |\n
      \             | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |\n              +------------------------------+-------------+\n
      \  The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM,\n   and
      AEAD_AES_128_CCM are defined in [RFC5116].\n   AEAD_CHACHA20_POLY1305 is defined
      in [RFC8439].  AEAD_AES_128_CCM_8\n   is defined in [RFC6655].  The corresponding
      hash algorithms are\n   defined in [SHS].\n   Although TLS 1.3 uses the same
      cipher suite space as previous\n   versions of TLS, TLS 1.3 cipher suites are
      defined differently, only\n   specifying the symmetric ciphers, and cannot be
      used for TLS 1.2.\n   Similarly, cipher suites for TLS 1.2 and lower cannot
      be used with\n   TLS 1.3.\n   New cipher suite values are assigned by IANA as
      described in\n   Section 11.\n"
    title: B.4.  Cipher Suites
  title: Appendix B.  Protocol Data Structures and Constant Values
- contents:
  - "Appendix C.  Implementation Notes\n   The TLS protocol cannot prevent many common
    security mistakes.  This\n   appendix provides several recommendations to assist
    implementors.\n   [TLS13-TRACES] provides test vectors for TLS 1.3 handshakes.\n"
  - contents:
    - "C.1.  Random Number Generation and Seeding\n   TLS requires a cryptographically
      secure pseudorandom number generator\n   (CSPRNG).  In most cases, the operating
      system provides an\n   appropriate facility such as /dev/urandom, which should
      be used\n   absent other (e.g., performance) concerns.  It is RECOMMENDED to
      use\n   an existing CSPRNG implementation in preference to crafting a new\n
      \  one.  Many adequate cryptographic libraries are already available\n   under
      favorable license terms.  Should those prove unsatisfactory,\n   [RFC4086] provides
      guidance on the generation of random values.\n   TLS uses random values (1)
      in public protocol fields such as the\n   public Random values in the ClientHello
      and ServerHello and (2) to\n   generate keying material.  With a properly functioning
      CSPRNG, this\n   does not present a security problem, as it is not feasible
      to\n   determine the CSPRNG state from its output.  However, with a broken\n
      \  CSPRNG, it may be possible for an attacker to use the public output\n   to
      determine the CSPRNG internal state and thereby predict the keying\n   material,
      as documented in [CHECKOWAY].  Implementations can provide\n   extra security
      against this form of attack by using separate CSPRNGs\n   to generate public
      and private values.\n"
    title: C.1.  Random Number Generation and Seeding
  - contents:
    - "C.2.  Certificates and Authentication\n   Implementations are responsible for
      verifying the integrity of\n   certificates and should generally support certificate
      revocation\n   messages.  Absent a specific indication from an application profile,\n
      \  certificates should always be verified to ensure proper signing by a\n   trusted
      certificate authority (CA).  The selection and addition of\n   trust anchors
      should be done very carefully.  Users should be able to\n   view information
      about the certificate and trust anchor.\n   Applications SHOULD also enforce
      minimum and maximum key sizes.  For\n   example, certification paths containing
      keys or signatures weaker\n   than 2048-bit RSA or 224-bit ECDSA are not appropriate
      for secure\n   applications.\n"
    title: C.2.  Certificates and Authentication
  - contents:
    - "C.3.  Implementation Pitfalls\n   Implementation experience has shown that
      certain parts of earlier TLS\n   specifications are not easy to understand and
      have been a source of\n   interoperability and security problems.  Many of these
      areas have\n   been clarified in this document, but this appendix contains a
      short\n   list of the most important things that require special attention from\n
      \  implementors.\n   TLS protocol issues:\n   -  Do you correctly handle handshake
      messages that are fragmented to\n      multiple TLS records (see Section 5.1)?
      \ Do you correctly handle\n      corner cases like a ClientHello that is split
      into several small\n      fragments?  Do you fragment handshake messages that
      exceed the\n      maximum fragment size?  In particular, the Certificate and\n
      \     CertificateRequest handshake messages can be large enough to\n      require
      fragmentation.\n   -  Do you ignore the TLS record layer version number in all\n
      \     unencrypted TLS records (see Appendix D)?\n   -  Have you ensured that
      all support for SSL, RC4, EXPORT ciphers,\n      and MD5 (via the \"signature_algorithms\"
      extension) is completely\n      removed from all possible configurations that
      support TLS 1.3 or\n      later, and that attempts to use these obsolete capabilities
      fail\n      correctly (see Appendix D)?\n   -  Do you handle TLS extensions
      in ClientHellos correctly, including\n      unknown extensions?\n   -  When
      the server has requested a client certificate but no suitable\n      certificate
      is available, do you correctly send an empty\n      Certificate message, instead
      of omitting the whole message (see\n      Section 4.4.2)?\n   -  When processing
      the plaintext fragment produced by AEAD-Decrypt\n      and scanning from the
      end for the ContentType, do you avoid\n      scanning past the start of the
      cleartext in the event that the\n      peer has sent a malformed plaintext of
      all zeros?\n   -  Do you properly ignore unrecognized cipher suites (Section
      4.1.2),\n      hello extensions (Section 4.2), named groups (Section 4.2.7),
      key\n      shares (Section 4.2.8), supported versions (Section 4.2.1), and\n
      \     signature algorithms (Section 4.2.3) in the ClientHello?\n   -  As a server,
      do you send a HelloRetryRequest to clients which\n      support a compatible
      (EC)DHE group but do not predict it in the\n      \"key_share\" extension?  As
      a client, do you correctly handle a\n      HelloRetryRequest from the server?\n
      \  Cryptographic details:\n   -  What countermeasures do you use to prevent
      timing attacks\n      [TIMING]?\n   -  When using Diffie-Hellman key exchange,
      do you correctly preserve\n      leading zero bytes in the negotiated key (see
      Section 7.4.1)?\n   -  Does your TLS client check that the Diffie-Hellman parameters
      sent\n      by the server are acceptable (see Section 4.2.8.1)?\n   -  Do you
      use a strong and, most importantly, properly seeded random\n      number generator
      (see Appendix C.1) when generating Diffie-Hellman\n      private values, the
      ECDSA \"k\" parameter, and other security-\n      critical values?  It is RECOMMENDED
      that implementations implement\n      \"deterministic ECDSA\" as specified in
      [RFC6979].\n   -  Do you zero-pad Diffie-Hellman public key values and shared\n
      \     secrets to the group size (see Section 4.2.8.1 and Section 7.4.1)?\n   -
      \ Do you verify signatures after making them, to protect against\n      RSA-CRT
      key leaks [FW15]?\n"
    title: C.3.  Implementation Pitfalls
  - contents:
    - "C.4.  Client Tracking Prevention\n   Clients SHOULD NOT reuse a ticket for
      multiple connections.  Reuse of\n   a ticket allows passive observers to correlate
      different connections.\n   Servers that issue tickets SHOULD offer at least
      as many tickets as\n   the number of connections that a client might use; for
      example, a web\n   browser using HTTP/1.1 [RFC7230] might open six connections
      to a\n   server.  Servers SHOULD issue new tickets with every connection.\n
      \  This ensures that clients are always able to use a new ticket when\n   creating
      a new connection.\n"
    title: C.4.  Client Tracking Prevention
  - contents:
    - "C.5.  Unauthenticated Operation\n   Previous versions of TLS offered explicitly
      unauthenticated cipher\n   suites based on anonymous Diffie-Hellman.  These
      modes have been\n   deprecated in TLS 1.3.  However, it is still possible to
      negotiate\n   parameters that do not provide verifiable server authentication
      by\n   several methods, including:\n   -  Raw public keys [RFC7250].\n   -  Using
      a public key contained in a certificate but without\n      validation of the
      certificate chain or any of its contents.\n   Either technique used alone is
      vulnerable to man-in-the-middle\n   attacks and therefore unsafe for general
      use.  However, it is also\n   possible to bind such connections to an external
      authentication\n   mechanism via out-of-band validation of the server's public
      key,\n   trust on first use, or a mechanism such as channel bindings (though\n
      \  the channel bindings described in [RFC5929] are not defined for\n   TLS 1.3).
      \ If no such mechanism is used, then the connection has no\n   protection against
      active man-in-the-middle attack; applications\n   MUST NOT use TLS in such a
      way absent explicit configuration or a\n   specific application profile.\n"
    title: C.5.  Unauthenticated Operation
  title: Appendix C.  Implementation Notes
- contents:
  - "Appendix D.  Backward Compatibility\n   The TLS protocol provides a built-in
    mechanism for version\n   negotiation between endpoints potentially supporting
    different\n   versions of TLS.\n   TLS 1.x and SSL 3.0 use compatible ClientHello
    messages.  Servers can\n   also handle clients trying to use future versions of
    TLS as long as\n   the ClientHello format remains compatible and there is at least
    one\n   protocol version supported by both the client and the server.\n   Prior
    versions of TLS used the record layer version number\n   (TLSPlaintext.legacy_record_version
    and\n   TLSCiphertext.legacy_record_version) for various purposes.  As of\n   TLS
    1.3, this field is deprecated.  The value of\n   TLSPlaintext.legacy_record_version
    MUST be ignored by all\n   implementations.  The value of TLSCiphertext.legacy_record_version
    is\n   included in the additional data for deprotection but MAY otherwise be\n
    \  ignored or MAY be validated to match the fixed constant value.\n   Version
    negotiation is performed using only the handshake versions\n   (ClientHello.legacy_version
    and ServerHello.legacy_version, as well\n   as the ClientHello, HelloRetryRequest,
    and ServerHello\n   \"supported_versions\" extensions).  In order to maximize\n
    \  interoperability with older endpoints, implementations that negotiate\n   the
    use of TLS 1.0-1.2 SHOULD set the record layer version number to\n   the negotiated
    version for the ServerHello and all records\n   thereafter.\n   For maximum compatibility
    with previously non-standard behavior and\n   misconfigured deployments, all implementations
    SHOULD support\n   validation of certification paths based on the expectations
    in this\n   document, even when handling prior TLS versions' handshakes (see\n
    \  Section 4.4.2.2).\n   TLS 1.2 and prior supported an \"Extended Master Secret\"
    [RFC7627]\n   extension which digested large parts of the handshake transcript
    into\n   the master secret.  Because TLS 1.3 always hashes in the transcript\n
    \  up to the server Finished, implementations which support both TLS 1.3\n   and
    earlier versions SHOULD indicate the use of the Extended Master\n   Secret extension
    in their APIs whenever TLS 1.3 is used.\n"
  - contents:
    - "D.1.  Negotiating with an Older Server\n   A TLS 1.3 client who wishes to negotiate
      with servers that do not\n   support TLS 1.3 will send a normal TLS 1.3 ClientHello
      containing\n   0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct\n
      \  version(s) in the \"supported_versions\" extension.  If the server does\n
      \  not support TLS 1.3, it will respond with a ServerHello containing an\n   older
      version number.  If the client agrees to use this version, the\n   negotiation
      will proceed as appropriate for the negotiated protocol.\n   A client using
      a ticket for resumption SHOULD initiate the connection\n   using the version
      that was previously negotiated.\n   Note that 0-RTT data is not compatible with
      older servers and\n   SHOULD NOT be sent absent knowledge that the server supports
      TLS 1.3.\n   See Appendix D.3.\n   If the version chosen by the server is not
      supported by the client\n   (or is not acceptable), the client MUST abort the
      handshake with a\n   \"protocol_version\" alert.\n   Some legacy server implementations
      are known to not implement the TLS\n   specification properly and might abort
      connections upon encountering\n   TLS extensions or versions which they are
      not aware of.\n   Interoperability with buggy servers is a complex topic beyond
      the\n   scope of this document.  Multiple connection attempts may be required\n
      \  in order to negotiate a backward-compatible connection; however, this\n   practice
      is vulnerable to downgrade attacks and is NOT RECOMMENDED.\n"
    title: D.1.  Negotiating with an Older Server
  - contents:
    - "D.2.  Negotiating with an Older Client\n   A TLS server can also receive a
      ClientHello indicating a version\n   number smaller than its highest supported
      version.  If the\n   \"supported_versions\" extension is present, the server
      MUST negotiate\n   using that extension as described in Section 4.2.1.  If the\n
      \  \"supported_versions\" extension is not present, the server MUST\n   negotiate
      the minimum of ClientHello.legacy_version and TLS 1.2.  For\n   example, if
      the server supports TLS 1.0, 1.1, and 1.2, and\n   legacy_version is TLS 1.0,
      the server will proceed with a TLS 1.0\n   ServerHello.  If the \"supported_versions\"
      extension is absent and the\n   server only supports versions greater than\n
      \  ClientHello.legacy_version, the server MUST abort the handshake with\n   a
      \"protocol_version\" alert.\n   Note that earlier versions of TLS did not clearly
      specify the record\n   layer version number value in all cases\n   (TLSPlaintext.legacy_record_version).
      \ Servers will receive various\n   TLS 1.x versions in this field, but its value
      MUST always be ignored.\n"
    title: D.2.  Negotiating with an Older Client
  - contents:
    - "D.3.  0-RTT Backward Compatibility\n   0-RTT data is not compatible with older
      servers.  An older server\n   will respond to the ClientHello with an older
      ServerHello, but it\n   will not correctly skip the 0-RTT data and will fail
      to complete the\n   handshake.  This can cause issues when a client attempts
      to use\n   0-RTT, particularly against multi-server deployments.  For example,
      a\n   deployment could deploy TLS 1.3 gradually with some servers\n   implementing
      TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3\n   deployment could be
      downgraded to TLS 1.2.\n   A client that attempts to send 0-RTT data MUST fail
      a connection if\n   it receives a ServerHello with TLS 1.2 or older.  It can
      then retry\n   the connection with 0-RTT disabled.  To avoid a downgrade attack,
      the\n   client SHOULD NOT disable TLS 1.3, only 0-RTT.\n   To avoid this error
      condition, multi-server deployments SHOULD ensure\n   a uniform and stable deployment
      of TLS 1.3 without 0-RTT prior to\n   enabling 0-RTT.\n"
    title: D.3.  0-RTT Backward Compatibility
  - contents:
    - "D.4.  Middlebox Compatibility Mode\n   Field measurements [Ben17a] [Ben17b]
      [Res17a] [Res17b] have found\n   that a significant number of middleboxes misbehave
      when a TLS\n   client/server pair negotiates TLS 1.3.  Implementations can increase\n
      \  the chance of making connections through those middleboxes by making\n   the
      TLS 1.3 handshake look more like a TLS 1.2 handshake:\n   -  The client always
      provides a non-empty session ID in the\n      ClientHello, as described in the
      legacy_session_id section of\n      Section 4.1.2.\n   -  If not offering early
      data, the client sends a dummy\n      change_cipher_spec record (see the third
      paragraph of Section 5)\n      immediately before its second flight.  This may
      either be before\n      its second ClientHello or before its encrypted handshake
      flight.\n      If offering early data, the record is placed immediately after
      the\n      first ClientHello.\n   -  The server sends a dummy change_cipher_spec
      record immediately\n      after its first handshake message.  This may either
      be after a\n      ServerHello or a HelloRetryRequest.\n   When put together,
      these changes make the TLS 1.3 handshake resemble\n   TLS 1.2 session resumption,
      which improves the chance of successfully\n   connecting through middleboxes.
      \ This \"compatibility mode\" is\n   partially negotiated: the client can opt
      to provide a session ID or\n   not, and the server has to echo it.  Either side
      can send\n   change_cipher_spec at any time during the handshake, as they must
      be\n   ignored by the peer, but if the client sends a non-empty session ID,\n
      \  the server MUST send the change_cipher_spec as described in this\n   appendix.\n"
    title: D.4.  Middlebox Compatibility Mode
  - contents:
    - "D.5.  Security Restrictions Related to Backward Compatibility\n   Implementations
      negotiating the use of older versions of TLS SHOULD\n   prefer forward secret
      and AEAD cipher suites, when available.\n   The security of RC4 cipher suites
      is considered insufficient for the\n   reasons cited in [RFC7465].  Implementations
      MUST NOT offer or\n   negotiate RC4 cipher suites for any version of TLS for
      any reason.\n   Old versions of TLS permitted the use of very low strength ciphers.\n
      \  Ciphers with a strength less than 112 bits MUST NOT be offered or\n   negotiated
      for any version of TLS for any reason.\n   The security of SSL 3.0 [RFC6101]
      is considered insufficient for the\n   reasons enumerated in [RFC7568], and
      it MUST NOT be negotiated for\n   any reason.\n   The security of SSL 2.0 [SSL2]
      is considered insufficient for the\n   reasons enumerated in [RFC6176], and
      it MUST NOT be negotiated for\n   any reason.\n   Implementations MUST NOT send
      an SSL version 2.0 compatible\n   CLIENT-HELLO.  Implementations MUST NOT negotiate
      TLS 1.3 or later\n   using an SSL version 2.0 compatible CLIENT-HELLO.  Implementations\n
      \  are NOT RECOMMENDED to accept an SSL version 2.0 compatible\n   CLIENT-HELLO
      in order to negotiate older versions of TLS.\n   Implementations MUST NOT send
      a ClientHello.legacy_version or\n   ServerHello.legacy_version set to 0x0300
      or less.  Any endpoint\n   receiving a Hello message with ClientHello.legacy_version
      or\n   ServerHello.legacy_version set to 0x0300 MUST abort the handshake\n   with
      a \"protocol_version\" alert.\n   Implementations MUST NOT send any records
      with a version less than\n   0x0300.  Implementations SHOULD NOT accept any
      records with a version\n   less than 0x0300 (but may inadvertently do so if
      the record version\n   number is ignored completely).\n   Implementations MUST
      NOT use the Truncated HMAC extension, defined in\n   Section 7 of [RFC6066],
      as it is not applicable to AEAD algorithms\n   and has been shown to be insecure
      in some scenarios.\n"
    title: D.5.  Security Restrictions Related to Backward Compatibility
  title: Appendix D.  Backward Compatibility
- contents:
  - "Appendix E.  Overview of Security Properties\n   A complete security analysis
    of TLS is outside the scope of this\n   document.  In this appendix, we provide
    an informal description of\n   the desired properties as well as references to
    more detailed work in\n   the research literature which provides more formal definitions.\n
    \  We cover properties of the handshake separately from those of the\n   record
    layer.\n"
  - contents:
    - "E.1.  Handshake\n   The TLS handshake is an Authenticated Key Exchange (AKE)
      protocol\n   which is intended to provide both one-way authenticated (server-only)\n
      \  and mutually authenticated (client and server) functionality.  At the\n   completion
      of the handshake, each side outputs its view of the\n   following values:\n
      \  -  A set of \"session keys\" (the various secrets derived from the\n      master
      secret) from which can be derived a set of working keys.\n   -  A set of cryptographic
      parameters (algorithms, etc.).\n   -  The identities of the communicating parties.\n
      \  We assume the attacker to be an active network attacker, which means\n   it
      has complete control over the network used to communicate between\n   the parties
      [RFC3552].  Even under these conditions, the handshake\n   should provide the
      properties listed below.  Note that these\n   properties are not necessarily
      independent, but reflect the protocol\n   consumers' needs.\n   Establishing
      the same session keys:  The handshake needs to output\n      the same set of
      session keys on both sides of the handshake,\n      provided that it completes
      successfully on each endpoint (see\n      [CK01], Definition 1, part 1).\n   Secrecy
      of the session keys:  The shared session keys should be known\n      only to
      the communicating parties and not to the attacker (see\n      [CK01], Definition
      1, part 2).  Note that in a unilaterally\n      authenticated connection, the
      attacker can establish its own\n      session keys with the server, but those
      session keys are distinct\n      from those established by the client.\n   Peer
      authentication:  The client's view of the peer identity should\n      reflect
      the server's identity.  If the client is authenticated,\n      the server's
      view of the peer identity should match the client's\n      identity.\n   Uniqueness
      of the session keys:  Any two distinct handshakes should\n      produce distinct,
      unrelated session keys.  Individual session keys\n      produced by a handshake
      should also be distinct and independent.\n   Downgrade protection:  The cryptographic
      parameters should be the\n      same on both sides and should be the same as
      if the peers had been\n      communicating in the absence of an attack (see
      [BBFGKZ16],\n      Definitions 8 and 9).\n   Forward secret with respect to
      long-term keys:  If the long-term\n      keying material (in this case the signature
      keys in certificate-\n      based authentication modes or the external/resumption
      PSK in PSK\n      with (EC)DHE modes) is compromised after the handshake is\n
      \     complete, this does not compromise the security of the session key\n      (see
      [DOW92]), as long as the session key itself has been erased.\n      The forward
      secrecy property is not satisfied when PSK is used in\n      the \"psk_ke\"
      PskKeyExchangeMode.\n   Key Compromise Impersonation (KCI) resistance:  In a
      mutually\n      authenticated connection with certificates, compromising the\n
      \     long-term secret of one actor should not break that actor's\n      authentication
      of their peer in the given connection (see\n      [HGFS15]).  For example, if
      a client's signature key is\n      compromised, it should not be possible to
      impersonate arbitrary\n      servers to that client in subsequent handshakes.\n
      \  Protection of endpoint identities:  The server's identity\n      (certificate)
      should be protected against passive attackers.  The\n      client's identity
      should be protected against both passive and\n      active attackers.\n   Informally,
      the signature-based modes of TLS 1.3 provide for the\n   establishment of a
      unique, secret, shared key established by an\n   (EC)DHE key exchange and authenticated
      by the server's signature over\n   the handshake transcript, as well as tied
      to the server's identity by\n   a MAC.  If the client is authenticated by a
      certificate, it also\n   signs over the handshake transcript and provides a
      MAC tied to both\n   identities.  [SIGMA] describes the design and analysis
      of this type\n   of key exchange protocol.  If fresh (EC)DHE keys are used for
      each\n   connection, then the output keys are forward secret.\n   The external
      PSK and resumption PSK bootstrap from a long-term shared\n   secret into a unique
      per-connection set of short-term session keys.\n   This secret may have been
      established in a previous handshake.  If\n   PSK with (EC)DHE key establishment
      is used, these session keys will\n   also be forward secret.  The resumption
      PSK has been designed so that\n   the resumption master secret computed by connection
      N and needed to\n   form connection N+1 is separate from the traffic keys used
      by\n   connection N, thus providing forward secrecy between the connections.\n
      \  In addition, if multiple tickets are established on the same\n   connection,
      they are associated with different keys, so compromise of\n   the PSK associated
      with one ticket does not lead to the compromise of\n   connections established
      with PSKs associated with other tickets.\n   This property is most interesting
      if tickets are stored in a database\n   (and so can be deleted) rather than
      if they are self-encrypted.\n   The PSK binder value forms a binding between
      a PSK and the current\n   handshake, as well as between the session where the
      PSK was\n   established and the current session.  This binding transitively\n
      \  includes the original handshake transcript, because that transcript\n   is
      digested into the values which produce the resumption master\n   secret.  This
      requires that both the KDF used to produce the\n   resumption master secret
      and the MAC used to compute the binder be\n   collision resistant.  See Appendix
      E.1.1 for more on this.  Note: The\n   binder does not cover the binder values
      from other PSKs, though they\n   are included in the Finished MAC.\n   TLS does
      not currently permit the server to send a\n   certificate_request message in
      non-certificate-based handshakes\n   (e.g., PSK).  If this restriction were
      to be relaxed in future, the\n   client's signature would not cover the server's
      certificate directly.\n   However, if the PSK was established through a NewSessionTicket,
      the\n   client's signature would transitively cover the server's certificate\n
      \  through the PSK binder.  [PSK-FINISHED] describes a concrete attack\n   on
      constructions that do not bind to the server's certificate (see\n   also [Kraw16]).
      \ It is unsafe to use certificate-based client\n   authentication when the client
      might potentially share the same\n   PSK/key-id pair with two different endpoints.
      \ Implementations\n   MUST NOT combine external PSKs with certificate-based
      authentication\n   of either the client or the server unless negotiated by some\n
      \  extension.\n   If an exporter is used, then it produces values which are
      unique and\n   secret (because they are generated from a unique session key).\n
      \  Exporters computed with different labels and contexts are\n   computationally
      independent, so it is not feasible to compute one\n   from another or the session
      secret from the exported value.\n   Note: Exporters can produce arbitrary-length
      values; if exporters are\n   to be used as channel bindings, the exported value
      MUST be large\n   enough to provide collision resistance.  The exporters provided
      in\n   TLS 1.3 are derived from the same Handshake Contexts as the early\n   traffic
      keys and the application traffic keys, respectively, and thus\n   have similar
      security properties.  Note that they do not include the\n   client's certificate;
      future applications which wish to bind to the\n   client's certificate may need
      to define a new exporter that includes\n   the full handshake transcript.\n
      \  For all handshake modes, the Finished MAC (and, where present, the\n   signature)
      prevents downgrade attacks.  In addition, the use of\n   certain bytes in the
      random nonces as described in Section 4.1.3\n   allows the detection of downgrade
      to previous TLS versions.  See\n   [BBFGKZ16] for more details on TLS 1.3 and
      downgrade.\n   As soon as the client and the server have exchanged enough\n
      \  information to establish shared keys, the remainder of the handshake\n   is
      encrypted, thus providing protection against passive attackers,\n   even if
      the computed shared key is not authenticated.  Because the\n   server authenticates
      before the client, the client can ensure that if\n   it authenticates to the
      server, it only reveals its identity to an\n   authenticated server.  Note that
      implementations must use the\n   provided record-padding mechanism during the
      handshake to avoid\n   leaking information about the identities due to length.
      \ The client's\n   proposed PSK identities are not encrypted, nor is the one
      that the\n   server selects.\n"
    - contents:
      - "E.1.1.  Key Derivation and HKDF\n   Key derivation in TLS 1.3 uses HKDF as
        defined in [RFC5869] and its\n   two components, HKDF-Extract and HKDF-Expand.
        \ The full rationale for\n   the HKDF construction can be found in [Kraw10]
        and the rationale for\n   the way it is used in TLS 1.3 in [KW16].  Throughout
        this document,\n   each application of HKDF-Extract is followed by one or
        more\n   invocations of HKDF-Expand.  This ordering should always be followed\n
        \  (including in future revisions of this document); in particular, one\n
        \  SHOULD NOT use an output of HKDF-Extract as an input to another\n   application
        of HKDF-Extract without an HKDF-Expand in between.\n   Multiple applications
        of HKDF-Expand to some of the same inputs are\n   allowed as long as these
        are differentiated via the key and/or the\n   labels.\n   Note that HKDF-Expand
        implements a pseudorandom function (PRF) with\n   both inputs and outputs
        of variable length.  In some of the uses of\n   HKDF in this document (e.g.,
        for generating exporters and the\n   resumption_master_secret), it is necessary
        that the application of\n   HKDF-Expand be collision resistant; namely, it
        should be infeasible\n   to find two different inputs to HKDF-Expand that
        output the same\n   value.  This requires the underlying hash function to
        be collision\n   resistant and the output length from HKDF-Expand to be of
        size at\n   least 256 bits (or as much as needed for the hash function to
        prevent\n   finding collisions).\n"
      title: E.1.1.  Key Derivation and HKDF
    - contents:
      - "E.1.2.  Client Authentication\n   A client that has sent authentication data
        to a server, either during\n   the handshake or in post-handshake authentication,
        cannot be sure\n   whether the server afterwards considers the client to be\n
        \  authenticated or not.  If the client needs to determine if the server\n
        \  considers the connection to be unilaterally or mutually\n   authenticated,
        this has to be provisioned by the application layer.\n   See [CHHSV17] for
        details.  In addition, the analysis of\n   post-handshake authentication from
        [Kraw16] shows that the client\n   identified by the certificate sent in the
        post-handshake phase\n   possesses the traffic key.  This party is therefore
        the client that\n   participated in the original handshake or one to whom
        the original\n   client delegated the traffic key (assuming that the traffic
        key has\n   not been compromised).\n"
      title: E.1.2.  Client Authentication
    - contents:
      - "E.1.3.  0-RTT\n   The 0-RTT mode of operation generally provides security
        properties\n   similar to those of 1-RTT data, with the two exceptions that
        the\n   0-RTT encryption keys do not provide full forward secrecy and that\n
        \  the server is not able to guarantee uniqueness of the handshake\n   (non-replayability)
        without keeping potentially undue amounts of\n   state.  See Section 8 for
        mechanisms to limit the exposure to replay.\n"
      title: E.1.3.  0-RTT
    - contents:
      - "E.1.4.  Exporter Independence\n   The exporter_master_secret and early_exporter_master_secret
        are\n   derived to be independent of the traffic keys and therefore do not\n
        \  represent a threat to the security of traffic encrypted with those\n   keys.
        \ However, because these secrets can be used to compute any\n   exporter value,
        they SHOULD be erased as soon as possible.  If the\n   total set of exporter
        labels is known, then implementations SHOULD\n   pre-compute the inner Derive-Secret
        stage of the exporter computation\n   for all those labels, then erase the
        [early_]exporter_master_secret,\n   followed by each inner value as soon as
        it is known that it will not\n   be needed again.\n"
      title: E.1.4.  Exporter Independence
    - contents:
      - "E.1.5.  Post-Compromise Security\n   TLS does not provide security for handshakes
        which take place after\n   the peer's long-term secret (signature key or external
        PSK) is\n   compromised.  It therefore does not provide post-compromise security\n
        \  [CCG16], sometimes also referred to as backward or future secrecy.\n   This
        is in contrast to KCI resistance, which describes the security\n   guarantees
        that a party has after its own long-term secret has been\n   compromised.\n"
      title: E.1.5.  Post-Compromise Security
    - contents:
      - "E.1.6.  External References\n   The reader should refer to the following
        references for analysis of\n   the TLS handshake: [DFGS15], [CHSV16], [DFGS16],
        [KW16], [Kraw16],\n   [FGSW16], [LXZFH16], [FG17], and [BBK17].\n"
      title: E.1.6.  External References
    title: E.1.  Handshake
  - contents:
    - "E.2.  Record Layer\n   The record layer depends on the handshake producing
      strong traffic\n   secrets which can be used to derive bidirectional encryption
      keys and\n   nonces.  Assuming that is true, and the keys are used for no more\n
      \  data than indicated in Section 5.5, then the record layer should\n   provide
      the following guarantees:\n   Confidentiality:  An attacker should not be able
      to determine the\n      plaintext contents of a given record.\n   Integrity:
      \ An attacker should not be able to craft a new record\n      which is different
      from an existing record which will be accepted\n      by the receiver.\n   Order
      protection/non-replayability:  An attacker should not be able\n      to cause
      the receiver to accept a record which it has already\n      accepted or cause
      the receiver to accept record N+1 without having\n      first processed record
      N.\n   Length concealment:  Given a record with a given external length, the\n
      \     attacker should not be able to determine the amount of the record\n      that
      is content versus padding.\n   Forward secrecy after key change:  If the traffic
      key update\n      mechanism described in Section 4.6.3 has been used and the\n
      \     previous generation key is deleted, an attacker who compromises\n      the
      endpoint should not be able to decrypt traffic encrypted with\n      the old
      key.\n   Informally, TLS 1.3 provides these properties by AEAD-protecting the\n
      \  plaintext with a strong key.  AEAD encryption [RFC5116] provides\n   confidentiality
      and integrity for the data.  Non-replayability is\n   provided by using a separate
      nonce for each record, with the nonce\n   being derived from the record sequence
      number (Section 5.3), with the\n   sequence number being maintained independently
      at both sides; thus,\n   records which are delivered out of order result in
      AEAD deprotection\n   failures.  In order to prevent mass cryptanalysis when
      the same\n   plaintext is repeatedly encrypted by different users under the
      same\n   key (as is commonly the case for HTTP), the nonce is formed by mixing\n
      \  the sequence number with a secret per-connection initialization\n   vector
      derived along with the traffic keys.  See [BT16] for analysis\n   of this construction.\n
      \  The rekeying technique in TLS 1.3 (see Section 7.2) follows the\n   construction
      of the serial generator as discussed in [REKEY], which\n   shows that rekeying
      can allow keys to be used for a larger number of\n   encryptions than without
      rekeying.  This relies on the security of\n   the HKDF-Expand-Label function
      as a pseudorandom function (PRF).  In\n   addition, as long as this function
      is truly one way, it is not\n   possible to compute traffic keys from prior
      to a key change (forward\n   secrecy).\n   TLS does not provide security for
      data which is communicated on a\n   connection after a traffic secret of that
      connection is compromised.\n   That is, TLS does not provide post-compromise
      security/future\n   secrecy/backward secrecy with respect to the traffic secret.
      \ Indeed,\n   an attacker who learns a traffic secret can compute all future\n
      \  traffic secrets on that connection.  Systems which want such\n   guarantees
      need to do a fresh handshake and establish a new\n   connection with an (EC)DHE
      exchange.\n"
    - contents:
      - "E.2.1.  External References\n   The reader should refer to the following
        references for analysis of\n   the TLS record layer: [BMMRT15], [BT16], [BDFKPPRSZZ16],
        [BBK17], and\n   [PS18].\n"
      title: E.2.1.  External References
    title: E.2.  Record Layer
  - contents:
    - "E.3.  Traffic Analysis\n   TLS is susceptible to a variety of traffic analysis
      attacks based on\n   observing the length and timing of encrypted packets [CLINIC]\n
      \  [HCJC16].  This is particularly easy when there is a small set of\n   possible
      messages to be distinguished, such as for a video server\n   hosting a fixed
      corpus of content, but still provides usable\n   information even in more complicated
      scenarios.\n   TLS does not provide any specific defenses against this form
      of\n   attack but does include a padding mechanism for use by applications:\n
      \  The plaintext protected by the AEAD function consists of content plus\n   variable-length
      padding, which allows the application to produce\n   arbitrary-length encrypted
      records as well as padding-only cover\n   traffic to conceal the difference
      between periods of transmission and\n   periods of silence.  Because the padding
      is encrypted alongside the\n   actual content, an attacker cannot directly determine
      the length of\n   the padding but may be able to measure it indirectly by the
      use of\n   timing channels exposed during record processing (i.e., seeing how\n
      \  long it takes to process a record or trickling in records to see\n   which
      ones elicit a response from the server).  In general, it is not\n   known how
      to remove all of these channels because even a\n   constant-time padding removal
      function will likely feed the content\n   into data-dependent functions.  At
      minimum, a fully constant-time\n   server or client would require close cooperation
      with the\n   application-layer protocol implementation, including making that\n
      \  higher-level protocol constant time.\n   Note: Robust traffic analysis defenses
      will likely lead to inferior\n   performance due to delays in transmitting packets
      and increased\n   traffic volume.\n"
    title: E.3.  Traffic Analysis
  - contents:
    - "E.4.  Side-Channel Attacks\n   In general, TLS does not have specific defenses
      against side-channel\n   attacks (i.e., those which attack the communications
      via secondary\n   channels such as timing), leaving those to the implementation
      of the\n   relevant cryptographic primitives.  However, certain features of
      TLS\n   are designed to make it easier to write side-channel resistant code:\n
      \  -  Unlike previous versions of TLS which used a composite MAC-then-\n      encrypt
      structure, TLS 1.3 only uses AEAD algorithms, allowing\n      implementations
      to use self-contained constant-time\n      implementations of those primitives.\n
      \  -  TLS uses a uniform \"bad_record_mac\" alert for all decryption\n      errors,
      which is intended to prevent an attacker from gaining\n      piecewise insight
      into portions of the message.  Additional\n      resistance is provided by terminating
      the connection on such\n      errors; a new connection will have different cryptographic\n
      \     material, preventing attacks against the cryptographic primitives\n      that
      require multiple trials.\n   Information leakage through side channels can occur
      at layers above\n   TLS, in application protocols and the applications that
      use them.\n   Resistance to side-channel attacks depends on applications and\n
      \  application protocols separately ensuring that confidential\n   information
      is not inadvertently leaked.\n"
    title: E.4.  Side-Channel Attacks
  - contents:
    - "E.5.  Replay Attacks on 0-RTT\n   Replayable 0-RTT data presents a number of
      security threats to TLS-\n   using applications, unless those applications are
      specifically\n   engineered to be safe under replay (minimally, this means idempotent,\n
      \  but in many cases may also require other stronger conditions, such as\n   constant-time
      response).  Potential attacks include:\n   -  Duplication of actions which cause
      side effects (e.g., purchasing\n      an item or transferring money) to be duplicated,
      thus harming the\n      site or the user.\n   -  Attackers can store and replay
      0-RTT messages in order to reorder\n      them with respect to other messages
      (e.g., moving a delete to\n      after a create).\n   -  Exploiting cache timing
      behavior to discover the content of 0-RTT\n      messages by replaying a 0-RTT
      message to a different cache node\n      and then using a separate connection
      to measure request latency,\n      to see if the two requests address the same
      resource.\n   If data can be replayed a large number of times, additional attacks\n
      \  become possible, such as making repeated measurements of the speed of\n   cryptographic
      operations.  In addition, they may be able to overload\n   rate-limiting systems.
      \ For a further description of these attacks,\n   see [Mac17].\n   Ultimately,
      servers have the responsibility to protect themselves\n   against attacks employing
      0-RTT data replication.  The mechanisms\n   described in Section 8 are intended
      to prevent replay at the TLS\n   layer but do not provide complete protection
      against receiving\n   multiple copies of client data.  TLS 1.3 falls back to
      the 1-RTT\n   handshake when the server does not have any information about
      the\n   client, e.g., because it is in a different cluster which does not\n
      \  share state or because the ticket has been deleted as described in\n   Section
      8.1.  If the application-layer protocol retransmits data in\n   this setting,
      then it is possible for an attacker to induce message\n   duplication by sending
      the ClientHello to both the original cluster\n   (which processes the data immediately)
      and another cluster which will\n   fall back to 1-RTT and process the data upon
      application-layer\n   replay.  The scale of this attack is limited by the client's\n
      \  willingness to retry transactions and therefore only allows a limited\n   amount
      of duplication, with each copy appearing as a new connection\n   at the server.\n
      \  If implemented correctly, the mechanisms described in Sections 8.1\n   and
      8.2 prevent a replayed ClientHello and its associated 0-RTT data\n   from being
      accepted multiple times by any cluster with consistent\n   state; for servers
      which limit the use of 0-RTT to one cluster for a\n   single ticket, then a
      given ClientHello and its associated 0-RTT data\n   will only be accepted once.
      \ However, if state is not completely\n   consistent, then an attacker might
      be able to have multiple copies of\n   the data be accepted during the replication
      window.  Because clients\n   do not know the exact details of server behavior,
      they MUST NOT send\n   messages in early data which are not safe to have replayed
      and which\n   they would not be willing to retry across multiple 1-RTT connections.\n
      \  Application protocols MUST NOT use 0-RTT data without a profile that\n   defines
      its use.  That profile needs to identify which messages or\n   interactions
      are safe to use with 0-RTT and how to handle the\n   situation when the server
      rejects 0-RTT and falls back to 1-RTT.\n   In addition, to avoid accidental
      misuse, TLS implementations MUST NOT\n   enable 0-RTT (either sending or accepting)
      unless specifically\n   requested by the application and MUST NOT automatically
      resend 0-RTT\n   data if it is rejected by the server unless instructed by the\n
      \  application.  Server-side applications may wish to implement special\n   processing
      for 0-RTT data for some kinds of application traffic\n   (e.g., abort the connection,
      request that data be resent at the\n   application layer, or delay processing
      until the handshake\n   completes).  In order to allow applications to implement
      this kind of\n   processing, TLS implementations MUST provide a way for the\n
      \  application to determine if the handshake has completed.\n"
    - contents:
      - "E.5.1.  Replay and Exporters\n   Replays of the ClientHello produce the same
        early exporter, thus\n   requiring additional care by applications which use
        these exporters.\n   In particular, if these exporters are used as an authentication\n
        \  channel binding (e.g., by signing the output of the exporter), an\n   attacker
        who compromises the PSK can transplant authenticators\n   between connections
        without compromising the authentication key.\n   In addition, the early exporter
        SHOULD NOT be used to generate\n   server-to-client encryption keys because
        that would entail the reuse\n   of those keys.  This parallels the use of
        the early application\n   traffic keys only in the client-to-server direction.\n"
      title: E.5.1.  Replay and Exporters
    title: E.5.  Replay Attacks on 0-RTT
  - contents:
    - "E.6.  PSK Identity Exposure\n   Because implementations respond to an invalid
      PSK binder by aborting\n   the handshake, it may be possible for an attacker
      to verify whether a\n   given PSK identity is valid.  Specifically, if a server
      accepts both\n   external-PSK handshakes and certificate-based handshakes, a
      valid PSK\n   identity will result in a failed handshake, whereas an invalid\n
      \  identity will just be skipped and result in a successful certificate\n   handshake.
      \ Servers which solely support PSK handshakes may be able\n   to resist this
      form of attack by treating the cases where there is no\n   valid PSK identity
      and where there is an identity but it has an\n   invalid binder identically.\n"
    title: E.6.  PSK Identity Exposure
  - contents:
    - "E.7.  Sharing PSKs\n   TLS 1.3 takes a conservative approach to PSKs by binding
      them to a\n   specific KDF.  By contrast, TLS 1.2 allows PSKs to be used with
      any\n   hash function and the TLS 1.2 PRF.  Thus, any PSK which is used with\n
      \  both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3,\n   which
      is less than optimal if users want to provision a single PSK.\n   The constructions
      in TLS 1.2 and TLS 1.3 are different, although they\n   are both based on HMAC.
      \ While there is no known way in which the\n   same PSK might produce related
      output in both versions, only limited\n   analysis has been done.  Implementations
      can ensure safety from\n   cross-protocol related output by not reusing PSKs
      between TLS 1.3 and\n   TLS 1.2.\n"
    title: E.7.  Sharing PSKs
  - contents:
    - "E.8.  Attacks on Static RSA\n   Although TLS 1.3 does not use RSA key transport
      and so is not\n   directly susceptible to Bleichenbacher-type attacks [Blei98],
      if TLS\n   1.3 servers also support static RSA in the context of previous\n
      \  versions of TLS, then it may be possible to impersonate the server\n   for
      TLS 1.3 connections [JSS15].  TLS 1.3 implementations can prevent\n   this attack
      by disabling support for static RSA across all versions\n   of TLS.  In principle,
      implementations might also be able to separate\n   certificates with different
      keyUsage bits for static RSA decryption\n   and RSA signature, but this technique
      relies on clients refusing to\n   accept signatures using keys in certificates
      that do not have the\n   digitalSignature bit set, and many clients do not enforce
      this\n   restriction.\n"
    title: E.8.  Attacks on Static RSA
  title: Appendix E.  Overview of Security Properties
- contents:
  - "Contributors\n   Martin Abadi\n   University of California, Santa Cruz\n   abadi@cs.ucsc.edu\n
    \  Christopher Allen\n   (co-editor of TLS 1.0)\n   Alacrity Ventures\n   ChristopherA@AlacrityManagement.com\n
    \  Richard Barnes\n   Cisco\n   rlb@ipv.sx\n   Steven M. Bellovin\n   Columbia
    University\n   smb@cs.columbia.edu\n   David Benjamin\n   Google\n   davidben@google.com\n
    \  Benjamin Beurdouche\n   INRIA & Microsoft Research\n   benjamin.beurdouche@ens.fr\n
    \  Karthikeyan Bhargavan\n   (editor of [RFC7627])\n   INRIA\n   karthikeyan.bhargavan@inria.fr\n
    \  Simon Blake-Wilson\n   (co-author of [RFC4492])\n   BCI\n   sblakewilson@bcisse.com\n
    \  Nelson Bolyard\n   (co-author of [RFC4492])\n   Sun Microsystems, Inc.\n   nelson@bolyard.com\n
    \  Ran Canetti\n   IBM\n   canetti@watson.ibm.com\n   Matt Caswell\n   OpenSSL\n
    \  matt@openssl.org\n   Stephen Checkoway\n   University of Illinois at Chicago\n
    \  sfc@uic.edu\n   Pete Chown\n   Skygate Technology Ltd\n   pc@skygate.co.uk\n
    \  Katriel Cohn-Gordon\n   University of Oxford\n   me@katriel.co.uk\n   Cas Cremers\n
    \  University of Oxford\n   cas.cremers@cs.ox.ac.uk\n   Antoine Delignat-Lavaud\n
    \  (co-author of [RFC7627])\n   INRIA\n   antdl@microsoft.com\n   Tim Dierks\n
    \  (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)\n   Independent\n   tim@dierks.org\n
    \  Roelof DuToit\n   Symantec Corporation\n   roelof_dutoit@symantec.com\n   Taher
    Elgamal\n   Securify\n   taher@securify.com\n   Pasi Eronen\n   Nokia\n   pasi.eronen@nokia.com\n
    \  Cedric Fournet\n   Microsoft\n   fournet@microsoft.com\n   Anil Gangolli\n
    \  anil@busybuddha.org\n   David M. Garrett\n   dave@nulldereference.com\n   Illya
    Gerasymchuk\n   Independent\n   illya@iluxonchik.me\n   Alessandro Ghedini\n   Cloudflare
    Inc.\n   alessandro@cloudflare.com\n   Daniel Kahn Gillmor\n   ACLU\n   dkg@fifthhorseman.net\n
    \  Matthew Green\n   Johns Hopkins University\n   mgreen@cs.jhu.edu\n   Jens Guballa\n
    \  ETAS\n   jens.guballa@etas.com\n   Felix Guenther\n   TU Darmstadt\n   mail@felixguenther.info\n
    \  Vipul Gupta\n   (co-author of [RFC4492])\n   Sun Microsystems Laboratories\n
    \  vipul.gupta@sun.com\n   Chris Hawk\n   (co-author of [RFC4492])\n   Corriente
    Networks LLC\n   chris@corriente.net\n   Kipp Hickman\n   Alfred Hoenes\n   David
    Hopwood\n   Independent Consultant\n   david.hopwood@blueyonder.co.uk\n   Marko
    Horvat\n   MPI-SWS\n   mhorvat@mpi-sws.org\n   Jonathan Hoyland\n   Royal Holloway,
    University of London\n   jonathan.hoyland@gmail.com\n   Subodh Iyengar\n   Facebook\n
    \  subodh@fb.com\n   Benjamin Kaduk\n   Akamai Technologies\n   kaduk@mit.edu\n
    \  Hubert Kario\n   Red Hat Inc.\n   hkario@redhat.com\n   Phil Karlton\n   (co-author
    of SSL 3.0)\n   Leon Klingele\n   Independent\n   mail@leonklingele.de\n   Paul
    Kocher\n   (co-author of SSL 3.0)\n   Cryptography Research\n   paul@cryptography.com\n
    \  Hugo Krawczyk\n   IBM\n   hugokraw@us.ibm.com\n   Adam Langley\n   (co-author
    of [RFC7627])\n   Google\n   agl@google.com\n   Olivier Levillain\n   ANSSI\n
    \  olivier.levillain@ssi.gouv.fr\n   Xiaoyin Liu\n   University of North Carolina
    at Chapel Hill\n   xiaoyin.l@outlook.com\n   Ilari Liusvaara\n   Independent\n
    \  ilariliusvaara@welho.com\n   Atul Luykx\n   K.U. Leuven\n   atul.luykx@kuleuven.be\n
    \  Colm MacCarthaigh\n   Amazon Web Services\n   colm@allcosts.net\n   Carl Mehner\n
    \  USAA\n   carl.mehner@usaa.com\n   Jan Mikkelsen\n   Transactionware\n   janm@transactionware.com\n
    \  Bodo Moeller\n   (co-author of [RFC4492])\n   Google\n   bodo@acm.org\n   Kyle
    Nekritz\n   Facebook\n   knekritz@fb.com\n   Erik Nygren\n   Akamai Technologies\n
    \  erik+ietf@nygren.org\n   Magnus Nystrom\n   Microsoft\n   mnystrom@microsoft.com\n
    \  Kazuho Oku\n   DeNA Co., Ltd.\n   kazuhooku@gmail.com\n   Kenny Paterson\n
    \  Royal Holloway, University of London\n   kenny.paterson@rhul.ac.uk\n   Christopher
    Patton\n   University of Florida\n   cjpatton@ufl.edu\n   Alfredo Pironti\n   (co-author
    of [RFC7627])\n   INRIA\n   alfredo.pironti@inria.fr\n   Andrei Popov\n   Microsoft\n
    \  andrei.popov@microsoft.com\n   Marsh Ray\n   (co-author of [RFC7627])\n   Microsoft\n
    \  maray@microsoft.com\n   Robert Relyea\n   Netscape Communications\n   relyea@netscape.com\n
    \  Kyle Rose\n   Akamai Technologies\n   krose@krose.org\n   Jim Roskind\n   Amazon\n
    \  jroskind@amazon.com\n   Michael Sabin\n   Joe Salowey\n   Tableau Software\n
    \  joe@salowey.net\n   Rich Salz\n   Akamai\n   rsalz@akamai.com\n   David Schinazi\n
    \  Apple Inc.\n   dschinazi@apple.com\n   Sam Scott\n   Royal Holloway, University
    of London\n   me@samjs.co.uk\n   Thomas Shrimpton\n   University of Florida\n
    \  teshrim@ufl.edu\n   Dan Simon\n   Microsoft, Inc.\n   dansimon@microsoft.com\n
    \  Brian Smith\n   Independent\n   brian@briansmith.org\n   Brian Sniffen\n   Akamai
    Technologies\n   ietf@bts.evenmere.org\n   Nick Sullivan\n   Cloudflare Inc.\n
    \  nick@cloudflare.com\n   Bjoern Tackmann\n   University of California, San Diego\n
    \  btackmann@eng.ucsd.edu\n   Tim Taubert\n   Mozilla\n   ttaubert@mozilla.com\n
    \  Martin Thomson\n   Mozilla\n   mt@mozilla.com\n   Hannes Tschofenig\n   Arm
    Limited\n   Hannes.Tschofenig@arm.com\n   Sean Turner\n   sn3rd\n   sean@sn3rd.com\n
    \  Steven Valdez\n   Google\n   svaldez@google.com\n   Filippo Valsorda\n   Cloudflare
    Inc.\n   filippo@cloudflare.com\n   Thyla van der Merwe\n   Royal Holloway, University
    of London\n   tjvdmerwe@gmail.com\n   Victor Vasiliev\n   Google\n   vasilvv@google.com\n
    \  Hoeteck Wee\n   Ecole Normale Superieure, Paris\n   hoeteck@alum.mit.edu\n
    \  Tom Weinstein\n   David Wong\n   NCC Group\n   david.wong@nccgroup.trust\n
    \  Christopher A. Wood\n   Apple Inc.\n   cawood@apple.com\n   Tim Wright\n   Vodafone\n
    \  timothy.wright@vodafone.com\n   Peter Wu\n   Independent\n   peter@lekensteyn.nl\n
    \  Kazu Yamamoto\n   Internet Initiative Japan Inc.\n   kazu@iij.ad.jp\n"
  title: Contributors
- contents:
  - "Author's Address\n   Eric Rescorla\n   Mozilla\n   Email: ekr@rtfm.com\n"
  title: Author's Address
