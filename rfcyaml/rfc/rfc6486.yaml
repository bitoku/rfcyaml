- contents:
  - '      Manifests for the Resource Public Key Infrastructure (RPKI)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines a \"manifest\" for use in the Resource Public
    Key\n   Infrastructure (RPKI).  A manifest is a signed object (file) that\n   contains
    a listing of all the signed objects (files) in the\n   repository publication
    point (directory) associated with an authority\n   responsible for publishing
    in the repository.  For each certificate,\n   Certificate Revocation List (CRL),
    or other type of signed objects\n   issued by the authority that are published
    at this repository\n   publication point, the manifest contains both the name
    of the file\n   containing the object and a hash of the file content.  Manifests
    are\n   intended to enable a relying party (RP) to detect certain forms of\n   attacks
    against a repository.  Specifically, if an RP checks a\n   manifest's contents
    against the signed objects retrieved from a\n   repository publication point,
    then the RP can detect \"stale\" (valid)\n   data and deletion of signed objects.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6486.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Terminology ................................................3\n   2.
    Manifest Scope ..................................................4\n   3. Manifest
    Signing ................................................4\n   4. Manifest Definition
    .............................................5\n      4.1. eContentType ...............................................5\n
    \     4.2. eContent ...................................................5\n           4.2.1.
    Manifest ............................................5\n      4.3. Content-Type
    Attribute .....................................7\n      4.4. Manifest Validation
    ........................................7\n   5. Manifest Generation .............................................7\n
    \     5.1. Manifest Generation Procedure ..............................7\n      5.2.
    Considerations for Manifest Generation .....................9\n   6. Relying Party
    Use of Manifests ..................................9\n      6.1. Tests for Determining
    Manifest State ......................10\n      6.2. Missing Manifests .........................................11\n
    \     6.3. Invalid Manifests .........................................12\n      6.4.
    Stale Manifests ...........................................12\n      6.5. Mismatch
    between Manifest and Publication Point ...........13\n      6.6. Hash Values Not
    Matching Manifests ........................14\n   7. Publication Repositories
    .......................................15\n   8. Security Considerations ........................................15\n
    \  9. IANA Considerations ............................................16\n   10.
    Acknowledgements ..............................................16\n   11. References
    ....................................................16\n      11.1. Normative
    References .....................................16\n      11.2. Informative References
    ...................................17\n   Appendix A. ASN.1 Module ..........................................18\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Resource Public Key Infrastructure (RPKI) [RFC6480]
    makes use of\n   a distributed repository system [RFC6481] to make available a
    variety\n   of objects needed by relying parties (RPs).  Because all of the\n
    \  objects stored in the repository system are digitally signed by the\n   entities
    that created them, attacks that modify these published\n   objects are detectable
    by RPs.  However, digital signatures provide\n   no protection against attacks
    that substitute \"stale\" versions of\n   signed objects (i.e., objects that were
    valid and have not expired,\n   but have since been superseded) or attacks that
    remove an object that\n   should be present in the repository.  To assist in the
    detection of\n   such attacks, the RPKI repository system can make use of a signed\n
    \  object called a \"manifest\".\n   A manifest is a signed object that enumerates
    all the signed objects\n   (files) in the repository publication point (directory)
    that are\n   associated with an authority responsible for publishing at that\n
    \  publication point.  Each manifest contains both the name of the file\n   containing
    the object and a hash of the file content, for every\n   signed object issued
    by an authority that is published at the\n   authority's repository publication
    point.  A manifest is intended to\n   allow an RP to detect unauthorized object
    removal or the substitution\n   of stale versions of objects at a publication
    point.  A manifest also\n   is intended to allow an RP to detect similar outcomes
    that may result\n   from a man-in-the-middle attack on the retrieval of objects
    from the\n   repository.  Manifests are intended to be used in Certification\n
    \  Authority (CA) publication points in repositories (directories\n   containing
    files that are subordinate certificates and Certificate\n   Revocation Lists (CRLs)
    issued by this CA and other signed objects\n   that are verified by end-entity
    (EE) certificates issued by this CA).\n   Manifests are modeled on CRLs, as the
    issues involved in detecting\n   stale manifests and potential attacks using manifest
    replays, etc.,\n   are similar to those for CRLs.  The syntax of the manifest
    payload\n   differs from CRLs, since RPKI repositories contain objects not\n   covered
    by CRLs, e.g., digitally signed objects, such as Route\n   Origination Authorizations
    (ROAs).\n"
  - contents:
    - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Manifest Scope\n   A manifest associated with a CA's repository publication
    point\n   contains a list of:\n      *  the set of (non-expired, non-revoked)
    certificates issued and\n         published by this CA,\n      *  the most recent
    CRL issued by this CA, and\n      *  all published signed objects that are verifiable
    using EE\n         certificates [RFC6487] issued by this CA.\n   Every RPKI signed
    object includes, in the Cryptographic Message\n   Syntax (CMS) [RFC3370] wrapper
    of the object, the EE certificate used\n   to verify it [RFC6488].  Thus, there
    is no requirement to separately\n   publish that EE certificate at the CA's repository
    publication point.\n   Where multiple CA instances share a common publication
    point, as can\n   occur when an entity performs a key-rollover operation [RFC6489],
    the\n   repository publication point will contain multiple manifests.  In\n   this
    case, each manifest describes only the collection of published\n   products of
    its associated CA instance.\n"
  title: 2.  Manifest Scope
- contents:
  - "3.  Manifest Signing\n   A CA's manifest is verified using an EE certificate.
    \ The\n   SubjectInfoAccess (SIA) field of this EE certificate contains the\n
    \  access method OID of id-ad-signedObject.\n   The CA MAY choose to sign only
    one manifest with each generated\n   private key, and generate a new key pair
    for each new version of the\n   manifest.  This form of use of the associated
    EE certificate is\n   termed a \"one-time-use\" EE certificate.\n   Alternatively,
    the CA MAY elect to use the same private key to sign a\n   sequence of manifests.
    \ Because only a single manifest (issued under\n   a single CA instance) is current
    at any point in time, the associated\n   EE certificate is used to verify only
    a single object at a time.  As\n   long as the sequence of objects verified by
    this EE certificate are\n   published using the same file name, then this sequential,
    multiple\n   use of the EE certificate is also valid.  This form of use of an
    EE\n   certificate is termed a \"sequential-use\" EE certificate.\n"
  title: 3.  Manifest Signing
- contents:
  - "4.  Manifest Definition\n   A manifest is an RPKI signed object, as specified
    in [RFC6488].  The\n   RPKI signed object template requires specification of the
    following\n   data elements in the context of the manifest structure.\n"
  - contents:
    - "4.1.  eContentType\n   The eContentType for a manifest is defined as id-ct-rpkiManifest
      and\n   has the numerical value of 1.2.840.113549.1.9.16.1.26.\n      id-smime
      OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)\n                                rsadsi(113549)
      pkcs(1) pkcs9(9) 16 }\n      id-ct OBJECT IDENTIFIER ::= { id-smime 1 }\n      id-ct-rpkiManifest
      OBJECT IDENTIFIER ::= { id-ct 26 }\n"
    title: 4.1.  eContentType
  - contents:
    - "4.2.  eContent\n   The content of a manifest is ASN.1 encoded using the Distinguished\n
      \  Encoding Rules (DER) [X.690].  The content of a manifest is defined\n   as
      follows:\n      Manifest ::= SEQUENCE {\n       version     [0] INTEGER DEFAULT
      0,\n       manifestNumber  INTEGER (0..MAX),\n       thisUpdate      GeneralizedTime,\n
      \      nextUpdate      GeneralizedTime,\n       fileHashAlg     OBJECT IDENTIFIER,\n
      \      fileList        SEQUENCE SIZE (0..MAX) OF FileAndHash\n       }\n     FileAndHash
      ::=     SEQUENCE {\n       file            IA5String,\n       hash            BIT
      STRING\n       }\n"
    - contents:
      - "4.2.1.  Manifest\n   The manifestNumber, thisUpdate, and nextUpdate fields
        are modeled\n   after the corresponding fields in X.509 CRLs (see [RFC5280]).\n
        \  Analogous to CRLs, a manifest is nominally current until the time\n   specified
        in nextUpdate or until a manifest is issued with a greater\n   manifest number,
        whichever comes first.\n   If a \"one-time-use\" EE certificate is employed
        to verify a manifest,\n   the EE certificate MUST have a validity period that
        coincides with\n   the interval from thisUpdate to nextUpdate, to prevent
        needless\n   growth of the CA's CRL.\n   If a \"sequential-use\" EE certificate
        is employed to verify a\n   manifest, the EE certificate's validity period
        needs to be no shorter\n   than the nextUpdate time of the current manifest.
        \ The extended\n   validity time raises the possibility of a substitution
        attack using a\n   stale manifest, as described in Section 6.4.\n   The data
        elements of the manifest structure are defined as follows:\n   version:\n
        \     The version number of this version of the manifest specification\n      MUST
        be 0.\n   manifestNumber:\n      This field is an integer that is incremented
        each time a new\n      manifest is issued for a given publication point.  This
        field\n      allows an RP to detect gaps in a sequence of published manifests.\n
        \     As the manifest is modeled on the CRL specification, the\n      ManifestNumber
        is analogous to the CRLNumber, and the guidance in\n      [RFC5280] for CRLNumber
        values is appropriate as to the range of\n      number values that can be
        used for the manifestNumber.  Manifest\n      numbers can be expected to contain
        long integers.  Manifest\n      verifiers MUST be able to handle number values
        up to 20 octets.\n      Conforming manifest issuers MUST NOT use number values
        longer than\n      20 octets.\n   thisUpdate:\n      This field contains the
        time when the manifest was created.  This\n      field has the same format
        constraints as specified in [RFC5280]\n      for the CRL field of the same
        name.\n   nextUpdate:\n      This field contains the time at which the next
        scheduled manifest\n      will be issued.  The value of nextUpdate MUST be
        later than the\n      value of thisUpdate.  The specification of the GeneralizedTime\n
        \     value is the same as required for the thisUpdate field.\n      If the
        authority alters any of the items that it has published in\n      the repository
        publication point, then the authority MUST issue a\n      new manifest before
        the nextUpdate time.  If a manifest\n      encompasses a CRL, the nextUpdate
        field of the manifest MUST match\n      that of the CRL's nextUpdate field,
        as the manifest will be\n      re-issued when a new CRL is published.  If
        a \"one-time-use\" EE\n      certificate is used to verify the manifest, then
        when a new\n      manifest is issued before the time specified in nextUpdate
        of the\n      current manifest, the CA MUST also issue a new CRL that includes\n
        \     the EE certificate corresponding to the old manifest.\n   fileHashAlg:\n
        \     This field contains the OID of the hash algorithm used to hash the\n
        \     files that the authority has placed into the repository.  The hash\n
        \     algorithm used MUST conform to the RPKI Algorithms and Key Size\n      Profile
        specification [RFC6485].\n   fileList:\n      This field is a sequence of
        FileAndHash objects.  There is one\n      FileAndHash entry for each currently
        valid signed object that has\n      been published by the authority (at this
        publication point).  Each\n      FileAndHash is an ordered pair consisting
        of the name of the file\n      in the repository publication point (directory)
        that contains the\n      object in question and a hash of the file's contents.\n"
      title: 4.2.1.  Manifest
    title: 4.2.  eContent
  - contents:
    - "4.3.  Content-Type Attribute\n   The mandatory content-type attribute MUST
      have its attrValues field\n   set to the same OID as eContentType.  This OID
      is id-ct-rpkiManifest\n   and has the numerical value of 1.2.840.113549.1.9.16.1.26.\n"
    title: 4.3.  Content-Type Attribute
  - contents:
    - "4.4.  Manifest Validation\n   To determine whether a manifest is valid, the
      RP MUST perform the\n   following checks in addition to those specified in [RFC6488]:\n
      \  1. The eContentType in the EncapsulatedContentInfo is\n      id-ad-rpkiManifest
      (OID 1.2.840.113549.1.9.16.1.26).\n   2. The version of the rpkiManifest is
      0.\n   3. In the rpkiManifest, thisUpdate precedes nextUpdate.\n   If the above
      procedure indicates that the manifest is invalid, then\n   the manifest MUST
      be discarded and treated as though no manifest were\n   present.\n"
    title: 4.4.  Manifest Validation
  title: 4.  Manifest Definition
- contents:
  - '5.  Manifest Generation

    '
  - contents:
    - "5.1.  Manifest Generation Procedure\n   For a CA publication point in the RPKI
      repository system, a CA MUST\n   perform the following steps to generate a manifest:\n
      \  1. If no key pair exists, or if using a \"one-time-use\" EE certificate\n
      \     with a new key pair, generate a key pair.\n   2. If using a \"one-time-use\"
      EE certificate, or if a key pair was\n      generated in step 1, or if using
      a \"sequential-use\" EE certificate\n      that will expire before the intended
      nextUpdate time of this\n      manifest, issue an EE certificate for this key
      pair.\n         This EE certificate MUST have an SIA extension access\n         description
      field with an accessMethod OID value of\n         id-ad-signedobject, where
      the associated accessLocation\n         references the publication point of
      the manifest as an object\n         URL.\n         This EE certificate MUST
      describe its Internet Number Resources\n         (INRs) using the \"inherit\"
      attribute, rather than explicit\n         description of a resource set (see
      [RFC3779]).\n         In the case of a \"one-time-use\" EE certificate, the
      validity\n         times of the EE certificate MUST exactly match the thisUpdate\n
      \        and nextUpdate times of the manifest.\n         In the case of a \"sequential-use\"
      EE certificate, the validity\n         times of the EE certificate MUST encompass
      the time interval\n         from thisUpdate to nextUpdate.\n   3. The EE certificate
      MUST NOT be published in the authority's\n      repository publication point.\n
      \  4. Construct the manifest content.\n      The manifest content is described
      in Section 4.2.1.  The\n      manifest's fileList includes the file name and
      hash pair for each\n      object issued by this CA that has been published at
      this\n      repository publication point (directory).  The collection of\n      objects
      to be included in the manifest includes all certificates\n      issued by this
      CA that are published at the CA's repository\n      publication point, the most
      recent CRL issued by the CA, and all\n      objects verified by EE certificates
      that were issued by this CA\n      that are published at this repository publication
      point.\n      Note that the manifest does not include a self reference (i.e.,\n
      \     its own file name and hash), since it would be impossible to\n      compute
      the hash of the manifest itself prior to it being signed.\n   5. Encapsulate
      the manifest content using the CMS SignedData content\n      type (as specified
      Section 4), sign the manifest using the private\n      key corresponding to
      the subject key contained in the EE\n      certificate, and publish the manifest
      in the repository system\n      publication point that is described by the manifest.\n
      \  6. In the case of a key pair that is to be used only once, in\n      conjunction
      with a \"one-time-use\" EE certificate, the private key\n      associated with
      this key pair MUST now be destroyed.\n"
    title: 5.1.  Manifest Generation Procedure
  - contents:
    - "5.2.  Considerations for Manifest Generation\n   A new manifest MUST be issued
      and published on or before the\n   nextUpdate time.\n   An authority MUST issue
      a new manifest in conjunction with the\n   finalization of changes made to objects
      in the publication point.  An\n   authority MAY perform a number of object operations
      on a publication\n   repository within the scope of a repository change before
      issuing a\n   single manifest that covers all the operations within the scope
      of\n   this change.  Repository operators SHOULD implement some form of\n   repository
      update procedure that mitigates, to the extent possible,\n   the risk that RPs
      that are performing retrieval operations on the\n   repository are exposed to
      inconsistent, transient, intermediate\n   states during updates to the repository
      publication point (directory)\n   and the associated manifest.\n   Since the
      manifest object URL is included in the SIA of issued\n   certificates, a new
      manifest MUST NOT invalidate the manifest object\n   URL of previously issued
      certificates.  This implies that the\n   manifest's publication name in the
      repository, in the form of an\n   object URL, is unchanged across manifest generation
      cycles.\n   When a CA entity is performing a key rollover, the entity MAY choose\n
      \  to have two CA instances simultaneously publishing into the same\n   repository
      publication point.  In this case, there will be one\n   manifest associated
      with each active CA instance that is publishing\n   into the common repository
      publication point (directory).\n"
    title: 5.2.  Considerations for Manifest Generation
  title: 5.  Manifest Generation
- contents:
  - "6.  Relying Party Use of Manifests\n   The goal of an RP is to determine which
    signed objects to use for\n   validating assertions about INRs and their use (e.g.,
    which ROAs to\n   use in the construction of route filters).  Ultimately, this\n
    \  selection is a matter of local policy.  However, in the following\n   sections,
    we describe a sequence of tests that the RP SHOULD perform\n   to determine the
    manifest state of the given publication point.  We\n   then discuss the risks
    associated with using signed objects in the\n   publication point, given the manifest
    state; we also provide suitable\n   warning text that SHOULD be placed in a user-accessible
    log file.  It\n   is the responsibility of the RP to weigh these risks against
    the risk\n   of routing failure that could occur if valid data is rejected, and
    to\n   implement a suitable local policy.  Note that if a certificate is\n   deemed
    unfit for use due to local policy, then any signed object that\n   is validated
    using this certificate also SHOULD be deemed unfit for\n   use (regardless of
    the status of the manifest at its own publication\n   point).\n"
  - contents:
    - "6.1.  Tests for Determining Manifest State\n   For a given publication point,
      the RP SHOULD perform the following\n   tests to determine the manifest state
      of the publication point:\n   1. For each CA using this publication point, select
      the CA's current\n      manifest (the \"current\" manifest is the manifest issued
      by this CA\n      having the highest manifestNumber among all valid manifests,
      and\n      where manifest validity is defined in Section 4.4).\n      If the
      publication point does not contain a valid manifest, see\n      Section 6.2.
      \ Lacking a valid manifest, the following tests cannot\n      be performed.\n
      \  2. To verify completeness, an RP MAY check that every file at each\n      publication
      point appears in one and only one current manifest,\n      and that every file
      listed in a current manifest is published at\n      the same publication point
      as the manifest.\n      If there exist files at the publication point that do
      not appear\n      on any manifest, or files listed in a manifest that do not
      appear\n      at the publication point, then see Section 6.5, but still continue\n
      \     with the following test.\n   3. Check that the current time (translated
      to UTC) is between\n      thisUpdate and nextUpdate.\n      If the current time
      does not lie within this interval, then see\n      Section 6.4, but still continue
      with the following tests.\n   4. Verify that the listed hash value of every
      file listed in each\n      manifest matches the value obtained by hashing the
      file at the\n      publication point.\n      If the computed hash value of a
      file listed on the manifest does\n      not match the hash value contained in
      the manifest, then see\n      Section 6.6.\n   5. An RP MAY check that the contents
      of each current manifest\n      conforms to the manifest's scope constraints,
      as specified in\n      Section 2.\n   6. If a current manifest contains entries
      for objects that are not\n      within the scope of the manifest, then the out-of-scope
      entries\n      SHOULD be disregarded in the context of this manifest.  If there\n
      \     is no other current manifest that describes these objects within\n      that
      other manifest's scope, then see Section 6.2.\n   For each signed object, if
      all of the following conditions hold:\n      *  the manifest for its publication
      and the associated publication\n         point pass all of the above checks;\n
      \     *  the signed object is valid; and\n      *  the manifests for every certificate
      on the certification path\n         used to validate the signed object and the
      associated\n         publication points pass all of the above checks;\n   then
      the RP can conclude that no attack against the repository system\n   has compromised
      the given signed object, and the signed object MUST\n   be treated as valid
      (relative to manifest checking).\n"
    title: 6.1.  Tests for Determining Manifest State
  - contents:
    - "6.2.  Missing Manifests\n   The absence of a current manifest at a publication
      point could occur\n   due to an error by the publisher or due to (malicious
      or accidental)\n   deletion or corruption of all valid manifests.\n   When no
      valid manifest is available, there is no protection against\n   attacks that
      delete signed objects or replay old versions of signed\n   objects.  All signed
      objects at the publication point, and all\n   descendant objects that are validated
      using a certificate at this\n   publication point, SHOULD be viewed as suspect,
      but MAY be used by\n   the RP, as per local policy.\n   The primary risk in
      using signed objects at this publication point is\n   that a superseded (but
      not stale) CRL would cause an RP to improperly\n   accept a revoked certificate
      as valid (and thus rely upon signed\n   objects that are validated using that
      certificate).  This risk is\n   somewhat mitigated if the CRL for this publication
      point has a short\n   time between thisUpdate and nextUpdate (and the current
      time is\n   within this interval).  The risk in discarding signed objects at
      this\n   publication point is that an RP may incorrectly discard a large\n   number
      of valid objects.  This gives significant power to an\n   adversary that is
      able to delete a manifest at the publication point.\n   Regardless of whether
      signed objects from this publication are deemed\n   fit for use by an RP, this
      situation SHOULD result in a warning to\n   the effect that: \"No manifest is
      available for <pub point name>, and\n   thus there may have been undetected
      deletions or replay substitutions\n   from the publication point.\"\n   In the
      case where an RP has access to a local cache of previously\n   issued manifests
      that are valid, the RP MAY use the most recently\n   previously issued valid
      manifests for this RPKI repository\n   publication collection for each entity
      that publishes at this\n   publication point.\n"
    title: 6.2.  Missing Manifests
  - contents:
    - "6.3.  Invalid Manifests\n   The presence of an invalid manifest at a publication
      point could\n   occur due to an error by the publisher or due to (malicious
      or\n   accidental) corruption of a valid manifest.  An invalid manifest MUST\n
      \  never be used, even if the manifestNumber of the invalid manifest is\n   greater
      than that of other (valid) manifests.\n   There are no risks associated with
      using signed objects at a\n   publication point containing an invalid manifest,
      provided that valid\n   manifests that collectively cover all the signed objects
      are also\n   present.\n   If an invalid manifest is present at a publication
      point that also\n   contains one or more valid manifests, this situation SHOULD
      result in\n   a warning to the effect that: \"An invalid manifest was found
      at <pub\n   point name>, this indicates an attack against the publication point\n
      \  or an error by the publisher.  Processing for this publication point\n   will
      continue using the most recent valid manifest(s).\"\n   In the case where the
      RP has access to a local cache of previously\n   issued (valid) manifests, an
      RP MAY make use of that locally cached\n   data.  Specifically, the RP MAY use
      the locally cached, most recent,\n   previously issued, valid manifest issued
      by the entity that (appears\n   to have) issued the invalid manifest.\n"
    title: 6.3.  Invalid Manifests
  - contents:
    - "6.4.  Stale Manifests\n   A manifest is considered stale if the current time
      is after the\n   nextUpdate time for the manifest.  This could be due to publisher\n
      \  failure to promptly publish a new manifest, or due to (malicious or\n   accidental)
      corruption or suppression of a more recent manifest.\n   All signed objects
      at the publication point issued by the entity that\n   has published the stale
      manifest, and all descendant signed objects\n   that are validated using a certificate
      issued by the entity that has\n   published the stale manifest at this publication
      point, SHOULD be\n   viewed as somewhat suspect, but MAY be used by the RP as
      per local\n   policy.\n   The primary risk in using such signed objects is that
      a newer\n   manifest exists that, if present, would indicate that certain objects\n
      \  have been removed or replaced.  (For example, the new manifest might\n   show
      the existence of a newer CRL and the removal of one or more\n   revoked certificates).
      \ Thus, the use of objects from a stale\n   manifest may cause an RP to incorrectly
      treat invalid objects as\n   valid.  The risk is that the CRL covered by the
      stale manifest has\n   been superseded, and thus an RP will improperly treat
      a revoked\n   certificate as valid.  This risk is somewhat mitigated if the
      time\n   between the nextUpdate field of the manifest and the current time is\n
      \  short.  The risk in discarding signed objects at this publication\n   point
      is that the RP may incorrectly discard a large number of valid\n   objects.
      \ This gives significant power to an adversary that is able\n   to prevent the
      publication of a new manifest at a given publication\n   point.\n   Regardless
      of whether signed objects from this publication are deemed\n   fit for use by
      an RP, this situation SHOULD result in a warning to\n   the effect that: \"A
      manifest found at <pub point name> is no longer\n   current.  It is possible
      that undetected deletions have occurred at\n   this publication point.\"\n   Note
      that there is also the potential for the current time to be\n   before the thisUpdate
      time for the manifest.  This case could be due\n   to publisher error or a local
      clock error; in such a case, this\n   situation SHOULD result in a warning to
      the effect that: \"A manifest\n   found at <pub point name> has an incorrect
      thisUpdate field.  This\n   could be due to publisher error, or a local clock
      error, and\n   processing for this publication point will continue using this\n
      \  otherwise valid manifest.\"\n"
    title: 6.4.  Stale Manifests
  - contents:
    - "6.5.  Mismatch between Manifest and Publication Point\n   If there exist valid
      signed objects that do not appear in any\n   manifest, then, provided the manifest
      is not stale (see Section 6.4),\n   it is likely that their omission is an error
      by the publisher.  It is\n   also possible that this state could be the result
      of a (malicious or\n   accidental) replacement of a current manifest with an
      older, but\n   still valid, manifest.  However, regarding the appropriate\n
      \  interpretation of such objects, it remains the case that if the\n   objects
      were intended to be invalid, then they should have been\n   revoked using whatever
      revocation mechanism is appropriate for the\n   signed object in question.  Therefore,
      there is little risk in using\n   such signed objects.  If the publication point
      contains a stale\n   manifest, then there is a greater risk that the objects
      in question\n   were revoked, along with a missing Certificate Revocation List
      (CRL),\n   the absence of which is undetectable since the manifest is stale.
      \ In\n   any case, the use of signed objects not present on a manifest, or\n
      \  descendant objects that are validated using such signed objects, is a\n   matter
      of local policy.\n   Regardless of whether objects not appearing on a manifest
      are deemed\n   fit for use by the RP, this situation SHOULD result in a warning
      to\n   the effect that: \"The following files are present in the repository\n
      \  at <pub point name>, but are not listed on any manifest <file list>\n   for
      <pub point name>.\"\n   If there exists files listed on the manifest that do
      not appear in\n   the repository, then these objects are likely to have been
      improperly\n   (via malice or accident) deleted from the repository.  A primary\n
      \  purpose of manifests is to detect such deletions.  Therefore, in such\n   a
      case, this situation SHOULD result in a warning to the effect that:\n   \"The
      following files that should have been present in the repository\n   at <pub
      point name> are missing <file list>.  This indicates an\n   attack against this
      publication point, or the repository, or an error\n   by the publisher.\"\n"
    title: 6.5.  Mismatch between Manifest and Publication Point
  - contents:
    - "6.6.  Hash Values Not Matching Manifests\n   A file appearing on a manifest
      with an incorrect hash value could\n   occur because of publisher error, but
      it also may indicate that an\n   attack has occurred.\n   If an object appeared
      on a previous valid manifest with a correct\n   hash value, and it now appears
      with an invalid hash value, then it is\n   likely that the object has been superseded
      by a new (unavailable)\n   version of the object.  If the object is used, there
      is a risk that\n   the RP will be treating a stale object as valid.  This risk
      is more\n   significant if the object in question is a CRL.  If the object can
      be\n   validated using the RPKI, the use of these objects is a matter of\n   local
      policy.\n   If an object appears on a manifest with an invalid hash and has
      never\n   previously appeared on a manifest, then it is unclear whether the\n
      \  available version of the object is more or less recent than the\n   version
      indicated by the manifest.  If the manifest is stale (see\n   Section 6.4),
      then it becomes more likely that the available version\n   is more recent than
      the version indicated on the manifest, but this\n   is never certain.  Whether
      to use such objects is a matter of local\n   policy.  However, in general, it
      is better to use a possibly outdated\n   version of the object than to discard
      the object completely.\n   While it is a matter of local policy, in the case
      of CRLs, an RP\n   SHOULD endeavor to use the most recently issued valid CRL,
      even where\n   the hash value in the manifest matches an older CRL or does not
      match\n   any available CRL for a CA instance.  The thisUpdate field of the
      CRL\n   can be used to establish the most recent CRL in the case where an RP\n
      \  has more than one valid CRL for a CA instance.\n   Regardless of whether
      objects with incorrect hashes are deemed fit\n   for use by the RP, this situation
      SHOULD result in a warning to the\n   effect that: \"The following files at
      the repository <pub point name>\n   appear on a manifest with incorrect hash
      values <file list>.  It is\n   possible that these objects have been superseded
      by a more recent\n   version.  It is very likely that this problem is due to
      an attack on\n   the publication point, although it also could be due to a publisher\n
      \  error.\"\n"
    title: 6.6.  Hash Values Not Matching Manifests
  title: 6.  Relying Party Use of Manifests
- contents:
  - "7.  Publication Repositories\n   The RPKI publication system model requires that
    every publication\n   point be associated with one or more CAs, and be non-empty.
    \ Upon\n   creation of the publication point associated with a CA, the CA MUST\n
    \  create and publish a manifest as well as a CRL.  A CA's manifest will\n   always
    contain at least one entry, namely, the CRL issued by the CA\n   upon repository
    creation [RFC6481].\n   Every published signed object in the RPKI [RFC6488] is
    published in\n   the repository publication point of the CA that issued the EE\n
    \  certificate, and is listed in the manifest associated with that CA\n   certificate.\n"
  title: 7.  Publication Repositories
- contents:
  - "8.  Security Considerations\n   Manifests provide an additional level of protection
    for RPKI RPs.\n   Manifests can assist an RP to determine if a repository object
    has\n   been deleted, occluded, or otherwise removed from view, or if a\n   publication
    of a newer version of an object has been suppressed (and\n   an older version
    of the object has been substituted).\n   Manifests cannot repair the effects of
    such forms of corruption of\n   repository retrieval operations.  However, a manifest
    enables an RP\n   to determine if a locally maintained copy of a repository is
    a\n   complete and up-to-date copy, even when the repository retrieval\n   operation
    is conducted over an insecure channel.  In cases where the\n   manifest and the
    retrieved repository contents differ, the manifest\n   can assist in determining
    which repository objects form the\n   difference set in terms of missing, extraneous,
    or superseded\n   objects.\n   The signing structure of a manifest and the use
    of the nextUpdate\n   value allows an RP to determine if the manifest itself is
    the subject\n   of attempted alteration.  The requirement for every repository\n
    \  publication point to contain at least one manifest allows an RP to\n   determine
    if the manifest itself has been occluded from view.  Such\n   attacks against
    the manifest are detectable within the time frame of\n   the regular schedule
    of manifest updates.  Forms of replay attack\n   within finer-grained time frames
    are not necessarily detectable by\n   the manifest structure.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   This document registers the following in the \"RPKI
    Signed Object\"\n   registry created by [RFC6488]:\n      Name: Manifest\n      OID:
    1.2.840.113549.1.9.16.1.26\n      Reference: [RFC6486] (this document)\n   This
    document registers the following three-letter filename extension\n   for \"RPKI
    Repository Name Schemes\" registry created by [RFC6481]:\n      Filename extension:
    mft\n      RPKI Object: Manifest\n      Reference: [RFC6481]\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Acknowledgements\n   The authors would like to acknowledge the contributions
    from George\n   Michelson and Randy Bush in the preparation of the manifest\n
    \  specification.  Additionally, the authors would like to thank Mark\n   Reynolds
    and Christopher Small for assistance in clarifying manifest\n   validation and
    RP behavior.  The authors also wish to thank Sean\n   Turner for his helpful review
    of this document.\n"
  title: 10.  Acknowledgements
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use
      in RFCs to Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n             Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n             Infrastructure Certificate
      and Certificate Revocation List\n             (CRL) Profile\", RFC 5280, May
      2008.\n   [RFC6481] Huston, G., Loomans, R., and G. Michaelson, \"A Profile
      for\n             Resource Certificate Repository Structure\", RFC 6481,\n             February
      2012.\n   [RFC6485] Huston, G., \"A Profile for Algorithms and Key Sizes for
      Use\n             in the Resource Public Key Infrastructure (RPKI)\", RFC\n
      \            6485, February 2012.\n   [RFC6487] Huston, G., Michaelson, G.,
      and R. Loomans, \"A Profile for\n             X.509 PKIX Resource Certificates\",
      RFC 6487, February 2012.\n   [RFC6488] Lepinski, M., Chi, A., and S. Kent, \"Signed
      Object Template\n             for the Resource Public Key Infrastructure (RPKI)\",
      RFC\n             6488, February 2012.\n   [X.690]   ITU-T Recommendation X.690
      (2002) | ISO/IEC 8825-1:2002,\n             Information technology - ASN.1 encoding
      rules:\n             Specification of Basic Encoding Rules (BER), Canonical\n
      \            Encoding Rules (CER) and Distinguished Encoding Rules\n             (DER).\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [RFC3370] Housley, R., \"Cryptographic Message
      Syntax (CMS)\n             Algorithms\", RFC 3370, August 2002.\n   [RFC3779]
      Lynn, C., Kent, S., and K. Seo, \"X.509 Extensions for IP\n             Addresses
      and AS Identifiers\", RFC 3779, June 2004.\n   [RFC6480] Lepinski, M. and S.
      Kent, \"An Infrastructure to Support\n             Secure Internet Routing\",
      RFC 6480, February 2012.\n   [RFC6489] Huston, G., Michaelson, G., and S. Kent,
      \"Certification\n             Authority (CA) Key Rollover in the Resource Public
      Key\n             Infrastructure (RPKI)\", BCP 174, RFC 6489, February 2012.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  ASN.1 Module\n   RPKIManifest { iso(1) member-body(2) us(840) rsadsi(113549)\n
    \     pkcs(1) pkcs9(9) smime(16) mod(0) 60 }\n   DEFINITIONS EXPLICIT TAGS ::=\n
    \  BEGIN\n   -- EXPORTS ALL --\n   -- IMPORTS NOTHING --\n   -- Manifest Content
    Type: OID\n   id-smime OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n   us(840)
    rsadsi(113549) pkcs(1) pkcs9(9) 16 }\n   id-ct OBJECT IDENTIFIER ::= { id-smime
    1 }\n   id-ct-rpkiManifest OBJECT IDENTIFIER ::= { id-ct 26 }\n   -- Manifest
    Content Type: eContent\n   Manifest ::= SEQUENCE {\n   version        [0] INTEGER
    DEFAULT 0,\n   manifestNumber     INTEGER (0..MAX),\n   thisUpdate         GeneralizedTime,\n
    \  nextUpdate         GeneralizedTime,\n   fileHashAlg        OBJECT IDENTIFIER,\n
    \  fileList           SEQUENCE SIZE (0..MAX) OF FileAndHash\n   }\n   FileAndHash
    ::= SEQUENCE {\n   file  IA5String,\n   hash  BIT STRING\n   }\n   END\n"
  title: Appendix A.  ASN.1 Module
- contents:
  - "Authors' Addresses\n   Rob Austein\n   Internet Systems Consortium\n   EMail:
    sra@hactrn.net\n   Geoff Huston\n   APNIC\n   6 Cordelia St\n   South Brisbane,
    QLD  4101\n   Australia\n   EMail: gih@apnic.net\n   URI:   http://www.apnic.net\n
    \  Stephen Kent\n   BBN Technologies\n   10 Moulton St.\n   Cambridge, MA  02138\n
    \  USA\n   EMail: kent@bbn.com\n   Matt Lepinski\n   BBN Technologies\n   10 Moulton
    St.\n   Cambridge, MA  02138\n   USA\n   EMail: mlepinski@bbn.com\n"
  title: Authors' Addresses
