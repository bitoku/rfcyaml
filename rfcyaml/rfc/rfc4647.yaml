- title: __initial_text__
  contents:
  - '                       Matching of Language Tags

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet Best Current Practices\
    \ for the\n   Internet Community, and requests discussion and suggestions for\n\
    \   improvements.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a syntax, called a \"language-range\", for\n\
    \   specifying items in a user's list of language preferences.  It also\n   describes\
    \ different mechanisms for comparing and matching these to\n   language tags.\
    \  Two kinds of matching mechanisms, filtering and\n   lookup, are defined.  Filtering\
    \ produces a (potentially empty) set of\n   language tags, whereas lookup produces\
    \ a single language tag.\n   Possible applications include language negotiation\
    \ or content\n   selection.  This document, in combination with RFC 4646, replaces\
    \ RFC\n   3066, which replaced RFC 1766.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. The Language Range ..............................................3\n  \
    \    2.1. Basic Language Range .......................................4\n    \
    \  2.2. Extended Language Range ....................................4\n      2.3.\
    \ The Language Priority List .................................5\n   3. Types of\
    \ Matching ...............................................6\n      3.1. Choosing\
    \ a Matching Scheme .................................6\n      3.2. Implementation\
    \ Considerations ..............................7\n      3.3. Filtering ..................................................8\n\
    \           3.3.1. Basic Filtering .....................................9\n  \
    \         3.3.2. Extended Filtering .................................10\n    \
    \  3.4. Lookup ....................................................12\n      \
    \     3.4.1. Default Values .....................................14\n   4. Other\
    \ Considerations ...........................................15\n      4.1. Choosing\
    \ Language Ranges ..................................15\n      4.2. Meaning of\
    \ Language Tags and Ranges .......................16\n      4.3. Considerations\
    \ for Private-Use Subtags ....................17\n      4.4. Length Considerations\
    \ for Language Ranges .................17\n   5. Security Considerations ........................................17\n\
    \   6. Character Set Considerations ...................................17\n  \
    \ 7. References .....................................................18\n    \
    \  7.1. Normative References ......................................18\n      7.2.\
    \ Informative References ....................................18\n   Appendix A.\
    \ Acknowledgements ......................................19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Human beings on our planet have, past and present, used\
    \ a number of\n   languages.  There are many reasons why one would want to identify\
    \ the\n   language used when presenting or requesting information.\n   Applications,\
    \ protocols, or specifications that use language\n   identifiers, such as the\
    \ language tags defined in [RFC4646],\n   sometimes need to match language tags\
    \ to a user's language\n   preferences.\n   This document defines a syntax (called\
    \ a language range (Section 2))\n   for specifying items in the user's list of\
    \ language preferences\n   (called a language priority list (Section 2.3)), as\
    \ well as several\n   schemes for selecting or filtering sets of language tags\
    \ by comparing\n   the language tags to the user's preferences.  Applications,\n\
    \   protocols, or specifications will have varying needs and requirements\n  \
    \ that affect the choice of a suitable matching scheme.\n   This document describes\
    \ how to indicate a user's preferences using\n   language ranges, three schemes\
    \ for matching these ranges to a set of\n   language tags, and the various practical\
    \ considerations that apply to\n   implementing and using these schemes.\n   This\
    \ document, in combination with [RFC4646], replaces [RFC3066],\n   which replaced\
    \ [RFC1766].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 2.  The Language Range
  contents:
  - "2.  The Language Range\n   Language tags [RFC4646] are used to help identify\
    \ languages, whether\n   spoken, written, signed, or otherwise signaled, for the\
    \ purpose of\n   communication.  Applications, protocols, or specifications that\
    \ use\n   language tags are often faced with the problem of identifying sets of\n\
    \   content that share certain language attributes.  For example,\n   HTTP/1.1\
    \ [RFC2616] describes one such mechanism in its discussion of\n   the Accept-Language\
    \ header (Section 14.4), which is used when\n   selecting content from servers\
    \ based on the language of that content.\n   It is, thus, useful to have a mechanism\
    \ for identifying sets of\n   language tags that share specific attributes.  This\
    \ allows users to\n   select or filter the language tags based on specific requirements.\n\
    \   Such an identifier is called a \"language range\".\n   There are different\
    \ types of language range, whose specific\n   attributes vary according to their\
    \ application.  Language ranges are\n   similar to language tags: they consist\
    \ of a sequence of subtags\n   separated by hyphens.  In a language range, each\
    \ subtag MUST either\n   be a sequence of ASCII alphanumeric characters or the\
    \ single\n   character '*' (%x2A, ASTERISK).  The character '*' is a \"wildcard\"\
    \n   that matches any sequence of subtags.  The meaning and uses of\n   wildcards\
    \ vary according to the type of language range.\n   Language tags and thus language\
    \ ranges are to be treated as case-\n   insensitive: there exist conventions for\
    \ the capitalization of some\n   of the subtags, but these MUST NOT be taken to\
    \ carry meaning.\n   Matching of language tags to language ranges MUST be done\
    \ in a case-\n   insensitive manner.\n"
- title: 2.1.  Basic Language Range
  contents:
  - "2.1.  Basic Language Range\n   A \"basic language range\" has the same syntax\
    \ as an [RFC3066] language\n   tag or is the single character \"*\".  The basic\
    \ language range was\n   originally described by HTTP/1.1 [RFC2616] and later\
    \ [RFC3066].  It\n   is defined by the following ABNF [RFC4234]:\n   language-range\
    \   = (1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\"\n   alphanum         = ALPHA / DIGIT\n\
    \   A basic language range differs from the language tags defined in\n   [RFC4646]\
    \ only in that there is no requirement that it be \"well-\n   formed\" or be validated\
    \ against the IANA Language Subtag Registry.\n   Such ill-formed ranges will probably\
    \ not match anything.  Note that\n   the ABNF [RFC4234] in [RFC2616] is incorrect,\
    \ since it disallows the\n   use of digits anywhere in the 'language-range' (see\
    \ [RFC2616errata]).\n"
- title: 2.2.  Extended Language Range
  contents:
  - "2.2.  Extended Language Range\n   Occasionally, users will wish to select a set\
    \ of language tags based\n   on the presence of specific subtags.  An \"extended\
    \ language range\"\n   describes a user's language preference as an ordered sequence\
    \ of\n   subtags.  For example, a user might wish to select all language tags\n\
    \   that contain the region subtag 'CH' (Switzerland).  Extended language\n  \
    \ ranges are useful for specifying a particular sequence of subtags\n   that appear\
    \ in the set of matching tags without having to specify all\n   of the intervening\
    \ subtags.\n   An extended language range can be represented by the following\
    \ ABNF:\n   extended-language-range = (1*8ALPHA / \"*\")\n                   \
    \          *(\"-\" (1*8alphanum / \"*\"))\n   The wildcard subtag '*' can occur\
    \ in any position in the extended\n   language range, where it matches any sequence\
    \ of subtags that might\n   occur in that position in a language tag.  However,\
    \ wildcards outside\n   the first position are ignored by Extended Filtering (see\
    \ Section\n   3.2.2).  The use or absence of one or more wildcards cannot be taken\n\
    \   to imply that a certain number of subtags will appear in the matching\n  \
    \ set of language tags.\n"
- title: 2.3.  The Language Priority List
  contents:
  - "2.3.  The Language Priority List\n   A user's language preferences will often\
    \ need to specify more than\n   one language range, and thus users often need\
    \ to specify a\n   prioritized list of language ranges in order to best reflect\
    \ their\n   language preferences.  This is especially true for speakers of\n \
    \  minority languages.  A speaker of Breton in France, for example, can\n   specify\
    \ \"br\" followed by \"fr\", meaning that if Breton is available,\n   it is preferred,\
    \ but otherwise French is the best alternative.  It\n   can get more complex:\
    \ a different user might want to fall back from\n   Skolt Sami to Northern Sami\
    \ to Finnish.\n   A \"language priority list\" is a prioritized or weighted list\
    \ of\n   language ranges.  One well-known example of such a list is the\n   \"\
    Accept-Language\" header defined in RFC 2616 [RFC2616] (see Section\n   14.4)\
    \ and RFC 3282 [RFC3282].\n   The various matching operations described in this\
    \ document include\n   considerations for using a language priority list.  This\
    \ document\n   does not define the syntax for a language priority list; defining\n\
    \   such a syntax is the responsibility of the protocol, application, or\n   specification\
    \ that uses it.  When given as examples in this document,\n   language priority\
    \ lists will be shown as a quoted sequence of ranges\n   separated by commas,\
    \ like this: \"en, fr, zh-Hant\" (which is read\n   \"English before French before\
    \ Chinese as written in the Traditional\n   script\").\n   A simple list of ranges\
    \ is considered to be in descending order of\n   priority.  Other language priority\
    \ lists provide \"quality weights\"\n   for the language ranges in order to specify\
    \ the relative priority of\n   the user's language preferences.  An example of\
    \ this is the use of\n   \"q\" values in the syntax of the \"Accept-Language\"\
    \ header (defined in\n   [RFC2616], Section 14.4, and [RFC3282]).\n"
- title: 3.  Types of Matching
  contents:
  - "3.  Types of Matching\n   Matching language ranges to language tags can be done\
    \ in many\n   different ways.  This section describes three such matching schemes,\n\
    \   as well as the considerations for choosing between them.  Protocols\n   and\
    \ specifications requiring conformance to this specification MUST\n   clearly\
    \ indicate the particular mechanism used in selecting or\n   matching language\
    \ tags.\n   There are two types of matching scheme in this document.  A matching\n\
    \   scheme that produces zero or more matching language tags is called\n   \"\
    filtering\".  A matching scheme that produces exactly one match for a\n   given\
    \ request is called \"lookup\".\n"
- title: 3.1.  Choosing a Matching Scheme
  contents:
  - "3.1.  Choosing a Matching Scheme\n   Applications, protocols, and specifications\
    \ are faced with the\n   decision of what type of matching to use.  Sometimes,\
    \ different\n   styles of matching are suited to different kinds of processing\
    \ within\n   a particular application or protocol.\n   This document describes\
    \ three matching schemes:\n   1.  Basic Filtering (Section 3.3.1) matches a language\
    \ priority list\n       consisting of basic language ranges (Section 2.1) to sets\
    \ of\n       language tags.\n   2.  Extended Filtering (Section 3.3.2) matches\
    \ a language priority\n       list consisting of extended language ranges (Section\
    \ 2.2) to sets\n       of language tags.\n   3.  Lookup (Section 3.4) matches\
    \ a language priority list consisting\n       of basic language ranges to sets\
    \ of language tags to find the one\n       exact language tag that best matches\
    \ the range.\n   Filtering can be used to produce a set of results (such as a\n\
    \   collection of documents) by comparing the user's preferences to a set\n  \
    \ of language tags.  For example, when performing a search, filtering\n   can\
    \ be used to limit the results to items tagged as being in the\n   French language.\
    \  Filtering can also be used when deciding whether to\n   perform a language-sensitive\
    \ process on some content.  For example, a\n   process might cause paragraphs\
    \ whose language tag matched the\n   language range \"nl\" (Dutch) to be displayed\
    \ in italics within a\n   document.\n   Lookup produces the single result that\
    \ best matches the user's\n   preferences from the list of available tags, so\
    \ it is useful in cases\n   in which a single item is required (and for which\
    \ only a single item\n   can be returned).  For example, if a process were to\
    \ insert a human-\n   readable error message into a protocol header, it might\
    \ select the\n   text based on the user's language priority list.  Since the process\n\
    \   can return only one item, it is forced to choose a single item and it\n  \
    \ has to return some item, even if none of the content's language tags\n   match\
    \ the language priority list supplied by the user.\n"
- title: 3.2.  Implementation Considerations
  contents:
  - "3.2.  Implementation Considerations\n   Language tag matching is a tool, and\
    \ does not by itself specify a\n   complete procedure for the use of language\
    \ tags.  Such procedures are\n   intimately tied to the application protocol in\
    \ which they occur.\n   When specifying a protocol operation using matching, the\
    \ protocol\n   MUST specify:\n   o  Which type(s) of language tag matching it\
    \ uses\n   o  Whether the operation returns a single result (lookup) or a\n  \
    \    possibly empty set of results (filtering)\n   o  For lookup, what the default\
    \ item is (or the sequence of\n      operations or configuration information used\
    \ to determine the\n      default) when no matching tag is found.  For instance,\
    \ a protocol\n      might define the result as failure of the operation, an empty\n\
    \      value, returning some protocol defined or implementation defined\n    \
    \  default, or returning i-default [RFC2277].\n   Applications, protocols, and\
    \ specifications are not required to\n   validate or understand any of the semantics\
    \ of the language tags or\n   ranges or of the subtags in them, nor do they require\
    \ access to the\n   IANA Language Subtag Registry (see Section 3 in [RFC4646]).\
    \  This\n   simplifies implementation.\n   However, designers of applications,\
    \ protocols, or specifications are\n   encouraged to use the information from\
    \ the IANA Language Subtag\n   Registry to support canonicalizing language tags\
    \ and ranges in order\n   to map grandfathered and obsolete tags or subtags into\
    \ modern\n   equivalents.\n   Applications, protocols, or specifications that\
    \ canonicalize ranges\n   MUST either perform matching operations with both the\
    \ canonical and\n   original (unmodified) form of the range or MUST also canonicalize\n\
    \   each tag for the purposes of comparison.\n   Note that canonicalizing language\
    \ ranges makes certain operations\n   impossible.  For example, an implementation\
    \ that canonicalizes the\n   language range \"art-lojban\" (artificial language,\
    \ lojban variant) to\n   use the more modern \"jbo\" (Lojban) cannot be used to\
    \ select just the\n   items with the older tag.\n   Applications, protocols, or\
    \ specifications that use basic ranges\n   might sometimes receive extended language\
    \ ranges instead.  An\n   application, protocol, or specification MUST choose\
    \ to a) map\n   extended language ranges to basic ranges using the algorithm below,\n\
    \   b) reject any extended language ranges in the language priority list\n   that\
    \ are not valid basic language ranges, or c) treat each extended\n   language\
    \ range as if it were a basic language range, which will have\n   the same result\
    \ as ignoring them, since these ranges will not match\n   any valid language tags.\n\
    \   An extended language range is mapped to a basic language range as\n   follows:\
    \ if the first subtag is a '*' then the entire range is\n   treated as \"*\",\
    \ otherwise each wildcard subtag is removed.  For\n   example, the extended language\
    \ range \"en-*-US\" maps to \"en-US\"\n   (English, United States).\n   Applications,\
    \ protocols, or specifications, in addressing their\n   particular requirements,\
    \ can offer pre-processing or configuration\n   options.  For example, an implementation\
    \ could allow a user to\n   associate or map a particular language range to a\
    \ different value.\n   Such a user might wish to associate the language range\
    \ subtags 'nn'\n   (Nynorsk Norwegian) and 'nb' (Bokmal Norwegian) with the more\
    \ general\n   subtag 'no' (Norwegian).  Or perhaps a user would want to associate\n\
    \   requests for the range \"zh-Hans\" (Chinese as written in the\n   Simplified\
    \ script) with content bearing the language tag \"zh-CN\"\n   (Chinese as used\
    \ in China, where the Simplified script is\n   predominant).  Documentation on\
    \ how the ranges or tags are altered,\n   prioritized, or compared in the subsequent\
    \ match in such an\n   implementation will assist users in making these types\
    \ of\n   configuration choices.\n"
- title: 3.3.  Filtering
  contents:
  - "3.3.  Filtering\n   Filtering is used to select the set of language tags that\
    \ matches a\n   given language priority list.  It is called \"filtering\" because\
    \ this\n   set might contain no items at all or it might return an arbitrarily\n\
    \   large number of matching items: as many items as match the language\n   priority\
    \ list, thus \"filtering out\" the non-matching items.\n   In filtering, each\
    \ language range represents the least specific\n   language tag (that is, the\
    \ language tag with fewest number of\n   subtags) that is an acceptable match.\
    \  All of the language tags in\n   the matching set of tags will have an equal\
    \ or greater number of\n   subtags than the language range.  Every non-wildcard\
    \ subtag in the\n   language range will appear in every one of the matching language\n\
    \   tags.  For example, if the language priority list consists of the\n   range\
    \ \"de-CH\" (German as used in Switzerland), one might see tags\n   such as \"\
    de-CH-1996\" (German as used in Switzerland, orthography of\n   1996) but one\
    \ will never see a tag such as \"de\" (because the 'CH'\n   subtag is missing).\n\
    \   If the language priority list (see Section 2.3) contains more than\n   one\
    \ range, the content returned is typically ordered in descending\n   level of\
    \ preference, but it MAY be unordered, according to the needs\n   of the application\
    \ or protocol.\n   Some examples of applications where filtering might be appropriate\n\
    \   include:\n   o  Applying a style to sections of a document in a particular\
    \ set of\n      languages.\n   o  Displaying the set of documents containing a\
    \ particular set of\n      keywords written in a specific set of languages.\n\
    \   o  Selecting all email items written in a specific set of languages.\n   o\
    \  Selecting audio files spoken in a particular language.\n   Filtering seems\
    \ to imply that there is a semantic relationship\n   between language tags that\
    \ share the same prefix.  While this is\n   often the case, it is not always true:\
    \ the language tags that match a\n   specific language range do not necessarily\
    \ represent mutually\n   intelligible languages.\n"
- title: 3.3.1.  Basic Filtering
  contents:
  - "3.3.1.  Basic Filtering\n   Basic filtering compares basic language ranges to\
    \ language tags.\n   Each basic language range in the language priority list is\
    \ considered\n   in turn, according to priority.  A language range matches a\n\
    \   particular language tag if, in a case-insensitive comparison, it\n   exactly\
    \ equals the tag, or if it exactly equals a prefix of the tag\n   such that the\
    \ first character following the prefix is \"-\".  For\n   example, the language-range\
    \ \"de-de\" (German as used in Germany)\n   matches the language tag \"de-DE-1996\"\
    \ (German as used in Germany,\n   orthography of 1996), but not the language tags\
    \ \"de-Deva\" (German as\n   written in the Devanagari script) or \"de-Latn-DE\"\
    \ (German, Latin\n   script, as used in Germany).\n   The special range \"*\"\
    \ in a language priority list matches any tag.  A\n   protocol that uses language\
    \ ranges MAY specify additional rules about\n   the semantics of \"*\"; for instance,\
    \ HTTP/1.1 [RFC2616] specifies that\n   the range \"*\" matches only languages\
    \ not matched by any other range\n   within an \"Accept-Language\" header.\n \
    \  Basic filtering is identical to the type of matching described in\n   [RFC3066],\
    \ Section 2.5 (Language-range).\n"
- title: 3.3.2.  Extended Filtering
  contents:
  - "3.3.2.  Extended Filtering\n   Extended filtering compares extended language\
    \ ranges to language\n   tags.  Each extended language range in the language priority\
    \ list is\n   considered in turn, according to priority.  A language range matches\n\
    \   a particular language tag if each respective list of subtags matches.\n  \
    \ To determine a match:\n   1.  Split both the extended language range and the\
    \ language tag being\n       compared into a list of subtags by dividing on the\
    \ hyphen (%x2D)\n       character.  Two subtags match if either they are the same\
    \ when\n       compared case-insensitively or the language range's subtag is the\n\
    \       wildcard '*'.\n   2.  Begin with the first subtag in each list.  If the\
    \ first subtag in\n       the range does not match the first subtag in the tag,\
    \ the overall\n       match fails.  Otherwise, move to the next subtag in both\
    \ the\n       range and the tag.\n   3.  While there are more subtags left in\
    \ the language range's list:\n       A.  If the subtag currently being examined\
    \ in the range is the\n           wildcard ('*'), move to the next subtag in the\
    \ range and\n           continue with the loop.\n       B.  Else, if there are\
    \ no more subtags in the language tag's\n           list, the match fails.\n \
    \      C.  Else, if the current subtag in the range's list matches the\n     \
    \      current subtag in the language tag's list, move to the next\n         \
    \  subtag in both lists and continue with the loop.\n       D.  Else, if the language\
    \ tag's subtag is a \"singleton\" (a single\n           letter or digit, which\
    \ includes the private-use subtag 'x')\n           the match fails.\n       E.\
    \  Else, move to the next subtag in the language tag's list and\n           continue\
    \ with the loop.\n   4.  When the language range's list has no more subtags, the\
    \ match\n       succeeds.\n   Subtags not specified, including those at the end\
    \ of the language\n   range, are thus treated as if assigned the wildcard value\
    \ '*'.  Much\n   like basic filtering, extended filtering selects content with\n\
    \   arbitrarily long tags that share the same initial subtags as the\n   language\
    \ range.  In addition, extended filtering selects language\n   tags that contain\
    \ any intermediate subtags not specified in the\n   language range.  For example,\
    \ the extended language range \"de-*-DE\"\n   (or its synonym \"de-DE\") matches\
    \ all of the following tags:\n      de-DE (German, as used in Germany)\n     \
    \ de-de (German, as used in Germany)\n      de-Latn-DE (Latin script)\n      de-Latf-DE\
    \ (Fraktur variant of Latin script)\n      de-DE-x-goethe (private-use subtag)\n\
    \      de-Latn-DE-1996 (orthography of 1996)\n      de-Deva-DE (Devanagari script)\n\
    \   The same range does not match any of the following tags for the\n   reasons\
    \ shown:\n      de (missing 'DE')\n      de-x-DE (singleton 'x' occurs before\
    \ 'DE')\n      de-Deva ('Deva' not equal to 'DE')\n   Note: [RFC4646] defines\
    \ each type of subtag (language, script,\n   region, and so forth) according to\
    \ position, size, and content.  This\n   means that subtags in a language range\
    \ can only match specific types\n   of subtags in a language tag.  For example,\
    \ a subtag such as 'Latn'\n   is always a script subtag (unless it follows a singleton)\
    \ while a\n   subtag such as 'nedis' can only match the equivalent variant subtag.\n\
    \   Two-letter subtags in the initial position have a different type\n   (language)\
    \ than two-letter subtags in later positions (region).  This\n   is the reason\
    \ why a wildcard in the extended language range is\n   significant in the first\
    \ position but is ignored in all other\n   positions.\n"
- title: 3.4.  Lookup
  contents:
  - "3.4.  Lookup\n   Lookup is used to select the single language tag that best matches\n\
    \   the language priority list for a given request.  When performing\n   lookup,\
    \ each language range in the language priority list is\n   considered in turn,\
    \ according to priority.  By contrast with\n   filtering, each language range\
    \ represents the most specific tag that\n   is an acceptable match.  The first\
    \ matching tag found, according to\n   the user's priority, is considered the\
    \ closest match and is the item\n   returned.  For example, if the language range\
    \ is \"de-ch\", a lookup\n   operation can produce content with the tags \"de\"\
    \ or \"de-CH\" but never\n   content with the tag \"de-CH-1996\".  If no language\
    \ tag matches the\n   request, the \"default\" value is returned.\n   For example,\
    \ if an application inserts some dynamic content into a\n   document, returning\
    \ an empty string if there is no exact match is not\n   an option.  Instead, the\
    \ application \"falls back\" until it finds a\n   matching language tag associated\
    \ with a suitable piece of content to\n   insert.  Some applications of lookup\
    \ include:\n   o  Selection of a template containing the text for an automated\
    \ email\n      response.\n   o  Selection of an item containing some text for\
    \ inclusion in a\n      particular Web page.\n   o  Selection of a string of text\
    \ for inclusion in an error log.\n   o  Selection of an audio file to play as\
    \ a prompt in a phone system.\n   In the lookup scheme, the language range is\
    \ progressively truncated\n   from the end until a matching language tag is located.\
    \  Single letter\n   or digit subtags (including both the letter 'x', which introduces\n\
    \   private-use sequences, and the subtags that introduce extensions) are\n  \
    \ removed at the same time as their closest trailing subtag.  For\n   example,\
    \ starting with the range \"zh-Hant-CN-x-private1-private2\"\n   (Chinese, Traditional\
    \ script, China, two private-use tags) the lookup\n   progressively searches for\
    \ content as shown below:\n   Example of a Lookup Fallback Pattern\n   Range to\
    \ match: zh-Hant-CN-x-private1-private2\n   1. zh-Hant-CN-x-private1-private2\n\
    \   2. zh-Hant-CN-x-private1\n   3. zh-Hant-CN\n   4. zh-Hant\n   5. zh\n   6.\
    \ (default)\n   This fallback behavior allows some flexibility in finding a match.\n\
    \   Without fallback, the default content would be returned immediately\n   if\
    \ exactly matching content is unavailable.  With fallback, a result\n   more closely\
    \ matching the user request can be provided.\n   Extensions and unrecognized private-use\
    \ subtags might be unrelated to\n   a particular application of lookup.  Since\
    \ these subtags come at the\n   end of the subtag sequence, they are removed first\
    \ during the\n   fallback process and usually pose no barrier to interoperability.\n\
    \   However, an implementation MAY remove these from ranges prior to\n   performing\
    \ the lookup (provided the implementation also removes them\n   from the tags\
    \ being compared).  Such modification is internal to the\n   implementation and\
    \ applications, protocols, or specifications SHOULD\n   NOT remove or modify subtags\
    \ in content that they return or forward,\n   because this removes information\
    \ that can be used elsewhere.\n   The special language range \"*\" matches any\
    \ language tag.  In the\n   lookup scheme, this range does not convey enough information\
    \ by\n   itself to determine which language tag is most appropriate, since it\n\
    \   matches everything.  If the language range \"*\" is followed by other\n  \
    \ language ranges, it is skipped.  If the language range \"*\" is the\n   only\
    \ one in the language priority list or if no other language range\n   follows,\
    \ the default value is computed and returned.\n   In some cases, the language\
    \ priority list can contain one or more\n   extended language ranges (as, for\
    \ example, when the same language\n   priority list is used as input for both\
    \ lookup and filtering\n   operations).  Wildcard values in an extended language\
    \ range normally\n   match any value that can occur in that position in a language\
    \ tag.\n   Since only one item can be returned for any given lookup request,\n\
    \   wildcards in a language range have to be processed in a consistent\n   manner\
    \ or the same request will produce widely varying results.\n   Applications, protocols,\
    \ or specifications that accept extended\n   language ranges MUST define which\
    \ item is returned when more than one\n   item matches the extended language range.\n\
    \   For example, an implementation could map the extended language ranges\n  \
    \ to basic ranges.  Another possibility would be for an implementation\n   to\
    \ return the matching tag that is first in ASCII-order.  If the\n   language range\
    \ were \"*-CH\" ('CH' represents Switzerland) and the set\n   of tags included\
    \ \"de-CH\" (German as used in Switzerland), \"fr-CH\"\n   (French, Switzerland),\
    \ and \"it-CH\" (Italian, Switzerland), then the\n   tag \"de-CH\" would be returned.\n"
- title: 3.4.1.  Default Values
  contents:
  - "3.4.1.  Default Values\n   Each application, protocol, or specification that\
    \ uses lookup MUST\n   define the defaulting behavior when no tag matches the\
    \ language\n   priority list.  What this action consists of strongly depends on\
    \ how\n   lookup is being applied.  Some examples of defaulting behavior\n   include:\n\
    \   o  return an item with no language tag or an item of a non-linguistic\n  \
    \    nature, such as an image or sound\n   o  return a null string as the language\
    \ tag value, in cases where the\n      protocol permits the empty value (see,\
    \ for example, \"xml:lang\" in\n      [XML10])\n   o  return a particular language\
    \ tag designated for the operation\n   o  return the language tag \"i-default\"\
    \ (see [RFC2277])\n   o  return an error condition or error message\n   o  return\
    \ a list of available languages for the user to select from\n   When performing\
    \ lookup using a language priority list, the\n   progressive search MUST process\
    \ each language range in the list\n   before seeking or calculating the default.\n\
    \   The default value MAY be calculated or include additional searching\n   or\
    \ matching.  Applications, protocols, or specifications can specify\n   different\
    \ ways in which users can specify or override the defaults.\n   One common way\
    \ to provide for a default is to allow a specific\n   language range to be set\
    \ as the default for a specific type of\n   request.  If this approach is chosen,\
    \ this language range MUST be\n   treated as if it were appended to the end of\
    \ the language priority\n   list as a whole, rather than after each item in the\
    \ language priority\n   list.  The application, protocol, or specification MUST\
    \ also define\n   the defaulting behavior if that search fails to find a matching\
    \ tag\n   or item.\n   For example, if a particular user's language priority list\
    \ is \"fr-FR,\n   zh-Hant\" (French as used in France followed by Chinese as written\
    \ in\n   the Traditional script) and the program doing the matching had a\n  \
    \ default language range of \"ja-JP\" (Japanese as used in Japan), then\n   the\
    \ program searches as follows:\n   1. fr-FR\n   2. fr\n   3. zh-Hant // next language\n\
    \   4. zh\n   5. ja-JP   // now searching for the default content\n   6. ja\n\
    \   7. (implementation defined default)\n"
- title: 4.  Other Considerations
  contents:
  - "4.  Other Considerations\n   When working with language ranges and matching schemes,\
    \ there are\n   some additional points that can influence the choice of either.\n"
- title: 4.1.  Choosing Language Ranges
  contents:
  - "4.1.  Choosing Language Ranges\n   Users indicate their language preferences\
    \ via the choice of a\n   language range or the list of language ranges in a language\
    \ priority\n   list.  The type of matching affects what the best choice is for\
    \ a\n   user.\n   Most matching schemes make no attempt to process the semantic\
    \ meaning\n   of the subtags.  The language range is compared, in a case-\n  \
    \ insensitive manner, to each language tag being matched, using basic\n   string\
    \ processing.  Users SHOULD select language ranges that are\n   well-formed, valid\
    \ language tags according to [RFC4646] (substituting\n   wildcards as appropriate\
    \ in extended language ranges).\n   Applications are encouraged to canonicalize\
    \ language tags and ranges\n   by using the Preferred-Value from the IANA Language\
    \ Subtag Registry\n   for tags or subtags that have been deprecated.  If the user\
    \ is\n   working with content that might use the older form, the user might\n\
    \   want to include both the new and old forms in a language priority\n   list.\
    \  For example, the tag \"art-lojban\" is deprecated.  The subtag\n   'jbo' is\
    \ supposed to be used instead, so the user might use it to\n   form the language\
    \ range.  Or the user might include both in a\n   language priority list: \"jbo,\
    \ art-lojban\".\n   Users SHOULD avoid subtags that add no distinguishing value\
    \ to a\n   language range.  When filtering, the fewer the number of subtags that\n\
    \   appear in the language range, the more content the range will\n   probably\
    \ match, while in lookup unnecessary subtags can cause\n   \"better\", more-specific\
    \ content to be skipped in favor of less\n   specific content.  For example, the\
    \ range \"de-Latn-DE\" returns\n   content tagged \"de\" instead of content tagged\
    \ \"de-DE\", even though\n   the latter is probably a better match.\n   Whether\
    \ a subtag adds distinguishing value can depend on the context\n   of the request.\
    \  For example, a user who reads both Simplified and\n   Traditional Chinese,\
    \ but who prefers Simplified, might use the range\n   \"zh\" for filtering (matching\
    \ all items that user can read) but\n   \"zh-Hans\" for lookup (making sure that\
    \ user gets the preferred form\n   if it's available, but the fallback to \"zh\"\
    \ will still work).  On the\n   other hand, content in this case ought to be labeled\
    \ as \"zh-Hans\" (or\n   \"zh-Hant\" if that applies) for filtering, while for\
    \ lookup, if there\n   is either \"zh-Hans\" content or \"zh-Hant\" content, one\
    \ of them (the\n   one considered 'default') also ought to be made available with\
    \ the\n   simple \"zh\".  Note that the user can create a language priority list\n\
    \   \"zh-Hans, zh\" that delivers the best possible results for both\n   schemes.\
    \  If the user cannot be sure which scheme is being used (or\n   if more than\
    \ one might be applied to a given request), the user\n   SHOULD specify the most\
    \ specific (largest number of subtags) range\n   first and then supply shorter\
    \ prefixes later in the list to ensure\n   that filtering returns a complete set\
    \ of tags.\n   Many languages are written predominantly in a single script.  This\
    \ is\n   usually recorded in the Suppress-Script field in that language\n   subtag's\
    \ registry entry.  For these languages, script subtags SHOULD\n   NOT be used\
    \ to form a language range.  Thus, the language range\n   \"en-Latn\" is inappropriate\
    \ in most cases (because the vast majority\n   of English documents are written\
    \ in the Latin script and thus the\n   'en' language subtag has a Suppress-Script\
    \ field for 'Latn' in the\n   registry).\n   When working with tags and ranges,\
    \ note that extensions and most\n   private-use subtags are orthogonal to language\
    \ tag matching, in that\n   they specify additional attributes of the text not\
    \ related to the\n   goals of most matching schemes.  Users SHOULD avoid using\
    \ these\n   subtags in language ranges, since they interfere with the selection\n\
    \   of available content.  When used in language tags (as opposed to\n   ranges),\
    \ these subtags normally do not interfere with filtering\n   (Section 3), since\
    \ they appear at the end of the tag and will match\n   all prefixes.  Lookup (Section\
    \ 3.4) implementations are advised to\n   ignore unrecognized private-use and\
    \ extension subtags when performing\n   language tag fallback.\n"
- title: 4.2.  Meaning of Language Tags and Ranges
  contents:
  - "4.2.  Meaning of Language Tags and Ranges\n   Selecting language tags using language\
    \ ranges requires some\n   understanding by users of what they are selecting.\
    \  The meanings of\n   the various subtags in a language range are identical to\
    \ their\n   meanings in a language tag (see Section 4.2 in [RFC4646]), with the\n\
    \   addition that the wildcard \"*\" represents any matching sequence of\n   values.\n"
- title: 4.3.  Considerations for Private-Use Subtags
  contents:
  - "4.3.  Considerations for Private-Use Subtags\n   Private agreement is necessary\
    \ between the parties that intend to use\n   or exchange language tags that contain\
    \ private-use subtags.  Great\n   caution SHOULD be used in employing private-use\
    \ subtags in content or\n   protocols intended for general use.  Private-use subtags\
    \ are simply\n   useless for information exchange without prior arrangement.\n\
    \   The value and semantic meaning of private-use tags and of the subtags\n  \
    \ used within such a language tag are not defined.  Matching private-\n   use\
    \ tags using language ranges or extended language ranges can result\n   in unpredictable\
    \ content being returned.\n"
- title: 4.4.  Length Considerations for Language Ranges
  contents:
  - "4.4.  Length Considerations for Language Ranges\n   Language ranges are very\
    \ similar to language tags in terms of content\n   and usage.  The same types\
    \ of restrictions on length that can be\n   applied to language tags can also\
    \ be applied to language ranges.  See\n   [RFC4646] Section 4.3 (Length Considerations).\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   Language ranges used in content negotiation might\
    \ be used to infer\n   the nationality of the sender, and thus identify potential\
    \ targets\n   for surveillance.  In addition, unique or highly unusual language\n\
    \   ranges or combinations of language ranges might be used to track a\n   specific\
    \ individual's activities.\n   This is a special case of the general problem that\
    \ anything you send\n   is visible to the receiving party.  It is useful to be\
    \ aware that\n   such concerns can exist in some cases.\n   The evaluation of\
    \ the exact magnitude of the threat, and any possible\n   countermeasures, is\
    \ left to each application or protocol.\n"
- title: 6.  Character Set Considerations
  contents:
  - "6.  Character Set Considerations\n   Language tags permit only the characters\
    \ A-Z, a-z, 0-9, and HYPHEN-\n   MINUS (%x2D).  Language ranges also use the character\
    \ ASTERISK\n   (%x2A).  These characters are present in most character sets, so\n\
    \   presentation or exchange of language tags or ranges should not be\n   constrained\
    \ by character set issues.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2119]       Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                   Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2277]       Alvestrand, H., \"IETF Policy on Character Sets\
    \ and\n                   Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC4234]\
    \       Crocker, D., Ed. and P. Overell, \"Augmented BNF for\n               \
    \    Syntax Specifications: ABNF\", RFC 4234, October 2005.\n   [RFC4646]    \
    \   Phillips, A., Ed., and M. Davis, Ed., \"Tags for\n                   Identifying\
    \ Languages\", BCP 47, RFC 4646, September\n                   2006.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC1766]       Alvestrand, H., \"Tags for the\
    \ Identification of\n                   Languages\", RFC 1766, March 1995.\n \
    \  [RFC2616]       Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n       \
    \            Masinter, L., Leach, P., and T. Berners-Lee,\n                  \
    \ \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616,\n                   June\
    \ 1999.\n   [RFC2616errata] IETF, \"HTTP/1.1 Specification Errata\", October 2004,\n\
    \                   <http://purl.org/NET/http-errata>.\n   [RFC3066]       Alvestrand,\
    \ H., \"Tags for the Identification of\n                   Languages\", BCP 47,\
    \ RFC 3066, January 2001.\n   [RFC3282]       Alvestrand, H., \"Content Language\
    \ Headers\", RFC 3282,\n                   May 2002.\n   [XML10]         Bray,\
    \ T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n                   and F. Yergeau,\
    \ \"Extensible Markup Language (XML) 1.0\n                   (Third Edition)\"\
    , World Wide Web Consortium\n                   Recommendation, February 2004,\n\
    \                   <http://www.w3.org/TR/REC-xml>.\n"
- title: Appendix A.  Acknowledgements
  contents:
  - "Appendix A.  Acknowledgements\n   Any list of contributors is bound to be incomplete;\
    \ please regard the\n   following as only a selection from the group of people\
    \ who have\n   contributed to make this document what it is today.\n   The contributors\
    \ to [RFC1766] and [RFC3066], each of which was a\n   precursor to this document,\
    \ contributed greatly to the development of\n   language tag matching, and, in\
    \ particular, the basic language range\n   and the basic matching scheme.  This\
    \ document was originally part of\n   [RFC4646], but was split off before that\
    \ document's completion.\n   Thus, directly or indirectly, those acknowledged\
    \ in [RFC4646] also\n   had a hand in the development of this document, and work\
    \ done prior\n   to the split is acknowledged in that document.\n   The following\
    \ people (in alphabetical order by family name)\n   contributed to this document:\n\
    \   Harald Alvestrand, Stephane Bortzmeyer, Jeremy Carroll, Peter\n   Constable,\
    \ John Cowan, Mark Crispin, Martin Duerst, Frank Ellermann,\n   Doug Ewell, Debbie\
    \ Garside, Marion Gunn, Jon Hanna, Kent Karlsson,\n   Erkki Kolehmainen, Jukka\
    \ Korpela, Ira McDonald, M. Patton, Randy\n   Presuhn, Eric van der Poel, Markus\
    \ Scherer, Misha Wolf, and many,\n   many others.\n   Very special thanks must\
    \ go to Harald Tveit Alvestrand, who\n   originated RFCs 1766 and 3066, and without\
    \ whom this document would\n   not have been possible.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Addison Phillips (Editor)\n   Yahoo! Inc.\n   EMail: addison@inter-locale.com\n\
    \   Mark Davis (Editor)\n   Google\n   EMail: mark.davis@macchiato.com or mark.davis@google.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
