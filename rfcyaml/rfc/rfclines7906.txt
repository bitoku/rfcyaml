P. Timmel NSA's Cryptographic Message Syntax (CMS)
This document defines key management attributes used by the National Security Agency (NSA).
The attributes can appear in asymmetric and/or symmetric key packages as well as the Cryptographic Message Syntax (CMS) content types that subsequently envelope the key packages.
Key packages described in RFCs 5958 and 6031 are examples of where these attributes can be used.
This document defines key management attributes used by the National Security Agency (NSA).
The attributes can appear in asymmetric and/or symmetric key packages as well as the Cryptographic Message Syntax (CMS) content types that subsequently envelope the key packages.
This document contains definitions for new attributes as well as previously defined attributes.
References are provided to the previously defined attributes; however, their definitions are included herein for convenience.
CMS allows for arbitrary nesting of content types.
Attributes are also supported in various locations in content types and key packages, which are themselves content types (see Section 1.1).
An implementation that supports all of the possibilities would be extremely complex.
Instead of implementing the full flexibility supported by this document, some devices may choose to support one or more templates, which is a profile for a combination of CMS content type(s), key package, and attribute(s); see Section 19. 1.1.
There are a number of CMS content types that support attributes SignedData [RFC5652], EnvelopedData [RFC5652], EncryptedData [RFC5652], AuthenticatedData [RFC5652], and AuthEnvelopedData
[RFC5083] as well as ContentWithAttributes [RFC4073].
There are also a number of other content types defined with CONTENT TYPE [RFC6268]
that support attributes including AsymmetricKeyPackage [RFC5958] and SymmetricKeyPackage [RFC6031].
CMS defines a number of "protecting content types"   SignedData [RFC5652], EnvelopedData [RFC5652], EncryptedData [RFC5652], AuthenticatedData [RFC5652], and AuthEnvelopedData
[RFC5083]   that provide some type of security service.
There are also other CMS content types   Data [RFC5652], ContentWithAttributes [RFC4073], and ContentCollection [RFC4073]   that provide no security service.
There are also different kinds of attributes in these content types:  SignedData supports two kinds of attributes: signed and unsigned attributes in the signedAttrs and unsignedAttrs fields, respectively.
EnvelopedData and EncryptedData each support one kind of attribute: unprotected attributes in the unprotectedAttrs field.
AuthEnvelopedData supports two kinds of attributes: authenticated and unauthenticated attributes in the authAttrs and unauthAttrs fields, respectively.
Both of these attributes are also unprotected (i.e., they are not encrypted); therefore, when referring to AuthEnvelopedData attributes, they are authenticated&unprotected and unauthenticated&unprotected.
For this specification, unauthenticated attributes MUST NOT be included.
AuthenticatedData supports two kinds of attributes: authenticated and unauthenticated attributes in the authAttrs and unauthAttrs fields, respectively.
For this specification, unauthenticated attributes MUST NOT be included.
ContentWithAttributes supports one kind of attribute: content attributes in the attrs field.
AsymmetricKeyPackage supports one kind of attribute:
asymmetric key attributes in the attributes field.
If an attribute appears as part of an asymmetric key package, it SHOULD appear in the attributes field of the AsymmetricKeyPackage.
SymmetricKeyPackage supports two kinds of attributes: symmetric key and symmetric key package attributes in the sKeyAttrs and sKeyPkgAttrs fields, respectively.
Note that [RFC6031] prohibits the same attribute from appearing in both locations in the same SymmetricKeyPackage.
Note that this specification updates the following information object sets SignedAttributesSet, UnsignedAttributes, UnprotectedEnvAttributes, UnprotectedEncAttributes, AuthAttributeSet, UnauthAttributeSet,
AuthEnvDataAttributeSet, UnauthEnvDataAttributeSet, and ContentAttributeSet from [RFC6268] as well as OneAsymmetricKeyAttributes from [RFC5958], SKeyPkgAttributes from [RFC6031], and SKeyAttributes from [RFC6031] to constrain the permissible locations for attributes.
See Appendix A for the ASN.1 for the information object sets.
The attributes defined in this document use 2002 ASN.1
The attributes MUST be DER [X.690] encoded.
Each of the attributes has a single attribute value instance in the values set.
Even though the syntax is defined as a set, there MUST be exactly one instance of AttributeValue present.
Further, the SignedAttributes, UnsignedAttributes, UnprotectedAttributes, AuthAttributes, and UnauthAttributes are also defined as a set, and this set MUST include only one instance of any particular type of attribute.
That is, any object identifier appearing in AttributeType MUST only appear one time in the set of attributes.
SignedData, EnvelopedData, EncryptedData, AuthenticatedData, AuthEnvelopedData, and ContentWithAttributes were originally defined using the 1988 version of ASN.1.
These definitions were updated to the 2008 version of ASN.1 by [RFC6268].
None of the new 2008 ASN.1 tokens are used; this allows 2002 compilers to compile 2008 ASN.1.
AsymmetricKeyPackage and SymmetricKeyPackage are defined using the 2002 ASN.1.
[RFC5652] and [RFC2634] define generally useful attributes for CMS using the 1988 version of ASN.1.
These definitions were updated to the 2008 version of ASN.1 by [RFC6268] and the 2002 version of ASN.1 by [RFC5911], respectively.
[RFC4108] and [RFC6019] also defined attributes using the 1988 version of ASN.1, which this document uses.
Both were updated by [RFC5911] to the 2002 ASN.1.
Refer to [RFC2634], [RFC4108], [RFC5652], and [RFC6019] for the attribute's semantics, but refer to [RFC5911] or [RFC6268] for the attribute's ASN.1 syntax.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119
: The scope of an attribute is the compilation of keying material to which the attribute value is assigned.
The scope of each attribute is determined by its placement within the key package or content collection.
SIR: Source Intermediary Receiver is a model with three entities:  A source initiates the delivery of a key to one or more receivers.
It may wrap or encrypt the key for delivery.
This is expected to be the common case, since a cleartext key is vulnerable to exposure and compromise.
If the sender is to encrypt the key for delivery, it must know how to encrypt the key so that the receiver(s) can decrypt it.
A sender may also carry out any of the functions of an intermediary.
The original key package creators are sometimes referred to as key source authorities.
These entities create the symmetric and/or asymmetric key package and apply the initial CMS protecting layer, which is normally a SignedData but sometimes an AuthenticatedData.
This initial CMS protecting layer is maintained through any intermediary for the receivers of the key package to ensure that receivers can validate the key source authority.
An intermediary does not have access to the cleartext key.
An intermediary may perform source authentication on key packages and may append or remove management information related to the package.
It may encapsulate the encrypted key packages in larger packages that contain other user data destined for later intermediaries or receivers.
A receiver has access to the cleartext key.
If the received key package is encrypted, it can unwrap or decrypt the encrypted key to obtain the cleartext key.
A receiver may be the final destination of the cryptographic product.
An element that acts as a receiver and is not the final destination of the key package may also act as a sender or as an intermediary.
After receiving a key, a receiver may encrypt the received key for local storage.
As noted in Section 1, a receiver can be tailored to support a particular combination of CMS content type(s), key package, and attribute(s) resulting in less complex implementations.
All of these tailored receivers can be supported by a common key management infrastructure that uses this specification; this also can yield efficiencies in generation and provisioning.
Senders and intermediaries that have to understand multiple tailored receivers get the efficiency of a common specification language and modular implementation, as opposed to needing stove piped processing for each different receiver.
The following attributes are defined for [RFC5652]:  content type [RFC5652]
[RFC6268] uniquely specifies the CMS content type.
This attribute MUST be included as a signed, authenticated, or authenticated&unprotected attribute.
[RFC6268] is the message digest of the encapsulated content calculated using the signer's message digest algorithm.
As specified in [RFC5652], it must be included as a signed attribute and an authenticated attribute; as specified in [RFC5652], it must not be an unsigned attribute, unauthenticated attribute, or unprotected attribute; as specified in [RFC5083], it should not be included as an authenticated&unprotected attribute in AuthEnvelopedData.
This attribute MUST NOT be included elsewhere.
[RFC6268] identifies the innermost content when multiple layers of encapsulation have been applied.
Every instance of SignedData, AuthenticatedData, and AuthEnvelopedData that does not directly encapsulate a SymmetricKeyPackage, an AsymmetricKeyPackage, or an EncryptedKeyPackage [RFC6032] MUST include this attribute.
The community identifiers attribute, defined in [RFC4108] and [RFC5911], lists the communities that are authorized recipients of the signed content.
It can appear as a signed, authenticated, authenticated&unprotected, or content attribute.
This attribute MUST be supported.
The 2002 ASN.1 syntax for the community identifiers attribute is included for convenience:
{ TYPE CommunityIdentifiers IDENTIFIED BY id aa communityIdentifiers }
The key province v2 attribute identifies the scope, range, or jurisdiction in which the key is to be used.
The key province v2 attribute MUST be present as a signed attribute or an authenticated attribute in the innermost CMS protection content type that provides authentication (i.e., SignedData, AuthEnvelopedData, or AuthenticatedData) and encapsulates a symmetric key package or an asymmetric key package.
The binary signing time attribute, defined in [RFC6019] and [RFC6268], specifies the time at which the signature or the Message Authentication Code (MAC) was applied to the encapsulated content.
It can appear as a signed, authenticated, or authenticated&unprotected attribute.
The 2002 ASN.1 syntax is included for convenience: aa
Consult [RFC6019] for the binary signing time attribute's semantics.
The manifest attribute lists the short titles of all the Transmission Security Nomenclature (TSEC Nomenclature) attributes from inner key packages.
It MUST only appear as an outermost signed, authenticated, or authenticated&unprotected attribute.
If a short title is repeated in inner packages, it need only appear once in the manifest attribute.
The manifest attribute MUST NOT appear in the same level as the TSEC Nomenclature from Section 10.
The manifest attribute has the following syntax:
The key algorithm attribute indirectly specifies the size and format of the keying material in the skey field of a symmetric key package, which is defined in [RFC6031].
It can appear as a symmetric key, symmetric key package, signed, authenticated, authenticated&unprotected, or content attribute.
If this attribute appears as a signed attribute, then all of the keying material within the SignedData content MUST be associated with the same algorithm.
If this attribute appears as an authenticated or authenticated&unprotected attribute, then all of the keying material within the AuthenticatedData or AuthEnvelopedData content type MUST be associated with the same algorithm.
If this attribute appears as a content attribute, then all of the keying material within the collection MUST be associated with the same algorithm.
If both the key wrap algorithm (Section 24) and key algorithm attributes apply to an sKey, then the key algorithm attribute refers to the decrypted value of sKey rather than to the content of sKey itself.
This attribute MUST be supported.
The key algorithm attribute has the following syntax: aa keyAlgorithm
The fields in the key algorithm attribute have the following semantics:  keyAlg specifies the size and format of the keying material.
If the particular key format supports more than one check word algorithm, then the OPTIONAL checkWordAlg identifier indicates which check word algorithm was used to generate the check word that is present.
If the check word algorithm is implied by the key algorithm, then the checkWordAlg field SHOULD be omitted.
If the particular key format supports more than one Cyclic Redundancy Check (CRC) algorithm, then the OPTIONAL crcAlg identifier indicates which CRC algorithm was used to generate the value that is present.
If the CRC algorithm is implied by the key algorithm, then the crcAlg field SHOULD be omitted.
The keyAlg identifier, the checkWordAlg identifier, and the crcAlg identifier are object identifiers.
The use of an object identifier accommodates any algorithm from any registry.
The format of the keying material in the skey field of a symmetric key package will not match this attribute if the keying material is split (see Section 18 for a discussion of the split identifier attribute).
In this situation, this attribute identifies the format of the keying material once the two splits are combined.
Due to multiple layers of encapsulation or the use of content collections, the key algorithm attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key algorithm attribute within the same scope, the keyAlg field MUST match in all instances.
The OPTIONAL checkWordAlg and crcAlg fields can be omitted in the key algorithm attribute when it appears as a signed, authenticated, authenticated&unprotected, or content attribute.
However, if these optional fields are present, they MUST also match the other occurrences within the same scope.
Receivers MUST reject any key package that fails these consistency checks.
The user certificate attribute specifies the type, format, and value of an X.509 certificate and is used in asymmetric key package's attributes field.
This attribute can appear as an asymmetric key attribute.
This attribute MUST NOT appear in an asymmetric key package attributes field that includes the other certificate formats attribute.
Symmetric key packages do not contain any certificates, so the user certificate attribute MUST NOT appear in a symmetric key package.
The user certificate attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute.
This attribute MUST be supported.
The syntax is taken from [X.509] but redefined using the ATTRIBUTE CLASS from [RFC5912].
MATCHING RULE certificateExactMatch IDENTIFIED BY id at userCertificate } id
Since the user certificate attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute, an asymmetric key package cannot include multiple occurrences of the user certificate attribute within the same scope.
Receivers MUST reject any asymmetric key package in which the user certificate attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute.
The key package receivers v2 attribute indicates the intended audience for the key package.
The key package receivers v2 attribute is not intended for access control decisions; rather, intermediate systems may use this attribute to make routing and relaying decisions.
If the receiver is not listed, it will not be able to decrypt the package; therefore, the receiver SHOULD reject the key package if the key package receivers v2 attribute is present and they are not listed as an intended receiver.
The key package receivers v2 attribute can be used as a signed, authenticated, authenticated&unprotected, or content attribute.
If the key package  receivers v2 attribute is associated with a collection, then the named receivers MUST be able to receive all of the key packages within the collection.
This attribute MUST be supported.
The key package receivers v2 attribute has the following syntax:
{ TYPE KeyPkgReceiversV2 IDENTIFIED BY i
The receiver identifier is either a SIREntityName [RFC7191] or a CommunityIdentifier (see Section 3).
The SIREntityName syntax does not impose any particular structure on the receiver identifier, but it does require registration of receiver identifier types.
The nameType ensures that two receiver identifiers of different types that contain the same values are not interpreted as equivalent.
Name types are expected to be defined that represent several different granularities.
For example, one name type will represent the receiver organization.
At a finer granularity, the name type will identify a specific cryptographic device, perhaps using a manufacturer identifier and serial number.
If a receiver does not recognize a particular nameType or a community identifier, then keying material within the scope of the unrecognized nameType or community identifier MUST NOT be used in any manner.
However, the receiver need not discard the associated key package.
Since many cryptographic devices are programmable, a different firmware load may recognize the nameType.
Likewise, a change in the configuration may lead to the recognition of a previously unrecognized community identifier.
Therefore, the receiver may retain the key package, but refuse to use it for anything with a firmware load that does not recognize the nameType or a configuration that does not recognize the community identifier.
Whenever a key package is saved for later processing due to an unrecognized nameType or community identifier, subsequent processing MUST NOT rely on any checks that were made the first time the key package processing was attempted.
That is, the subsequent processing MUST include the full complement of checks.
Further, a receipt for the packages MUST NOT be generated unless all of these checks are successfully completed.
Due to multiple layers of encapsulation or the use of content collections, the key package receivers v2 attribute can appear in more than one location in the overall key package.
When that happens, each occurrence is evaluated independently.
In a content collection, each member of the collection might contain its own signed, authenticated, authenticated&unprotected, or content attribute that includes a key package receivers v2 attribute.
In this situation, each member of the collection is evaluated separately, and any member that includes an acceptable receiver SHOULD be retained.
Other members can be rejected or retained for later processing with a different firmware load.
The Telecommunications Security Nomenclature (TSEC Nomenclature) attribute provides the name for a piece of keying material, which always includes a printable string called a "short title" (see below).
The TSEC Nomenclature attribute also contains other identifiers when the shortTitle is insufficient to uniquely name a particular piece of keying material.
This attribute can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If this attribute appears in the sKeyAttrs field, the editionID, registerID, and segmentID attribute fields MUST NOT be ranges.
If this attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, all of the keying material within the associated content MUST have the same shortTitle, and the attribute value MUST contain only a shortTitle.
That is, when this attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, all of the optional fields MUST be absent.
If this attribute is associated with a collection, all of the keying material within the collection MUST have the same shortTitle; however, the editionID, registerID, and segmentID will be different for each key package in the collection.
This attribute MUST be supported.
The TSEC Nomenclature attribute has the following syntax:
[2] CharEditionRange } num CHOICE { numEdition
lastRegister   Register } SegmentID ::
The fields in the TSEC Nomenclature attribute have the following semantics:
The shortTitle consists of up to 32 alphanumeric characters.
shortTitle processing always uses the value in its entirety.
The editionID is OPTIONAL, and the editionIdentifier is used to distinguish accountable items.
The editionID consists of either six alphanumeric characters or an integer.
When present, the editionID is either a single value or a range.
The integer encoding should be used when it is important to keep key package size to a minimum.
For electronic keying material, the registerID is usually omitted.
The registerID is an accounting number assigned to identify Communications Security (COMSEC) material.
The registerID is either a single value or a range.
The segmentID is OPTIONAL, and it distinguishes the individual symmetric keys delivered in one edition.
A unique segmentNumber is assigned to each key in an edition.
The segmentNumber is set to one for the first item in each edition, and it is incremented by one for each additional item within that edition.
The segmentID is either a single value or a range.
The order that the keying material will appear in the key package is illustrated by the following example: a cryptographic device may require fresh keying material every day, an edition represents the keying material for a single month, and the segments represent the keying material for a day within that month.
Consider a key package that contains the keying material for July and August; it will contain keying material for 62 days.
Due to multiple layers of encapsulation or the use of content collections, the TSEC Nomenclature attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the TSEC Nomenclature attribute within the same scope, the shortTitle field MUST match in all instances.
Receivers MUST reject any key package that fails these consistency checks.
When the manifest attribute from Section 6 is included in an outer layer, the ShortTitle field values present in TSEC Nomenclature attributes MUST be one of the values in the manifest attribute.
Receivers MUST reject any key package that fails this consistency check.
The key purpose attribute specifies the intended purpose of the key material.
It can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the key purpose attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the associated content MUST have the same key purpose value.
The key purpose attribute has the following syntax: aa
kma keyPurpose } id kma
Due to multiple layers of encapsulation or the use of content collections, the key purpose attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key purpose attribute within the same scope, all fields within the attribute MUST contain exactly the same values.
Receivers MUST reject any key package that fails these consistency checks.
The key use attribute specifies the intended use of the key material.
It can appear as a symmetric key, symmetric key package, asymmetric, signed, authenticated, authenticated&unprotected, or content attribute.
If the key use attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the associated content MUST have the same key use value.
Symmetric Authentication Key rgk  (253),
Certificate Encryption Key exk  (255),
Expect additional key use values   }
The values for the key use attribute have the following semantics:  ffk:
A FIREFLY/CROSSTALK key is used to establish a Key Establishment Key (KEK) or a Transmission Encryption Key (TEK) between two parties.
The KEK or TEK generated from the exchange is used with a symmetric encryption algorithm.
This key use value is associated with keys in the basic format.
A Key Encryption Key is used to encrypt or decrypt other keys for transmission or storage.
kpk: A Key Production Key is used to initialize a keystream generator for the production of other electronically generated keys.
A Message Signature Key is used in a digital signature process that operates on a message to assure message source authentication, message integrity, and non repudiation.
QUADRANT Key Encryption Key is one part of a tamper  resistance solution.
A Traffic Encryption Key is used to encrypt plaintext, to superencrypt previously encrypted data, and/or to decrypt ciphertext.
A Transmission Security Key is used to protect transmissions from interception and exploitation by means other than cryptanalysis.
The keys used to protect communications with an intermediary.
A Netted FIREFLY Key is a FIREFLY key that has an edition number associated with it.
When rekeyed, it is incremented, preventing communications with FIREFLY key of previous editions.
This edition number is maintained within a universal edition.
Enhanced FIREFLY Key is used to establish a KEK or a TEK between two parties.
The KEK or TEK generated from an exchange is used with a symmetric encryption algorithm.
This key use value is associated with keys in the enhanced format.
ebfk: Enhanceable Basic FIREFLY Key is used to establish a KEK or a TEK between two parties.
The KEK or TEK generated from an exchange is used with a symmetric encryption algorithm.
This key use value is associated with keys in the enhanceable basic format.
An Algorithm Encryption Key is used to encrypt or decrypt an algorithm implementation as well as other functionality in the implementation.
A key used to generate the Word of the Day (WOD).
kesk: A Key Establishment Key is an asymmetric key set (e.g., public/private/parameters) used to enable the establishment of symmetric key(s) between entities.
An Entity Identification Key is an asymmetric key set (e.g., public/private/parameters) used to identify one entity to another for access control and other similar purposes.
ask: An Authority Signature Key is an asymmetric key set (e.g., public/private/parameters) used by designated authorities to sign objects such as Trust Anchor Management Protocol (TAMP) messages and firmware packages.
A Key Modifier Key is a symmetric key used to modify the results of the process that forms a symmetric key from a public key exchange process.
: A Revocation Signature Key is an asymmetric key set (e.g., public/private/parameters) used to sign and authenticate revocation lists and compromised key lists.
A Certificate Signature Key is an asymmetric key set (e.g., public/private/parameters) used to sign and authenticate public key certificates.
A Symmetric Authentication Key is used in a MAC algorithm to provide message integrity.
Differs from a Message Signature Key in that it is symmetric key material
and it does not provide source authentication or non repudiation.
Random Generation Key is a key used to seed a deterministic pseudorandom number generator.
A Certificate Encryption Key is used to encrypt public key certificates to support privacy.
An Exclusion Key is a symmetric key used to cryptographically subdivide a single large security domain into smaller segregated domains.
Due to multiple layers of encapsulation or the use of content collections, the key use attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key use attribute within the same scope, all fields within the attribute MUST contain exactly the same values.
Receivers MUST reject any key package that fails these consistency checks.
The transport key attribute identifies whether an asymmetric key is a transport key or an operational key
(i.e., whether or not the key can be used as is).
It can appear as an asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the transport key attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the associated content MUST have the same operational/transport key material.
infosec(1) keying material attributes(13) 15
Due to multiple layers of encapsulation or the use of content collections, the transport key attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the transport key attribute within the same scope, all fields within the attribute MUST contain exactly the same values.
Receivers MUST reject any key package that fails these consistency checks.
The key distribution period attribute indicates the period of time that the keying material is intended for distribution.
Keying material is often distributed before it is intended to be used.
Time of day must be represented in Coordinated Universal Time (UTC).
It can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the key distribution period attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the content MUST have the same key distribution period.
The key distribution period attribute has the following syntax: aa
infosec(1) keying material attributes(13) 5 } KeyDistPeriod ::
The fields in the key distribution period attribute have the following semantics:  The doNotDistBefore field is OPTIONAL, and when it is present, the keying material SHOULD NOT be distributed before the date and time provided.
The doNotDistAfter field is REQUIRED, and the keying material SHOULD NOT be distributed after the date and time provided.
When the key distribution period attribute is associated with a collection of keying material, the distribution period applies to all of the keys in the collection.
None of the keying material in the collection SHOULD be distributed outside the indicated period.
Due to multiple layers of encapsulation or the use of content collections, the key distribution period attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key distribution period attribute within the same scope, all of the included attribute fields MUST contain exactly the same value.
However, if the doNotDistBefore field is absent in an inner layer, a value MAY appear in an outer layer because the outer layer constrains the inner layer.
Receivers MUST reject any key package that fails these consistency checks.
The key validity period attribute indicates the period of time that the keying material is intended for use.
Time of day MUST be represented in Coordinated Universal Time (UTC).
It can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the key validity period attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the content MUST have the same key validity period.
The key validity period attribute has the following syntax: aa
The fields in the key validity period attribute have the following semantics:  The doNotUseBefore field is REQUIRED, and the keying material SHOULD NOT be used before the date and time provided.
The doNotUseAfter field is OPTIONAL, and when it is present, the keying material SHOULD NOT be used after the date and time provided.
For a key package that is being used for rekey, the doNotUseAfter field MAY be required by some templates even though the syntax is OPTIONAL.
When the key validity period attribute is associated with a collection of keying material, the validity period applies to all of the keys in the collection.
None of the keying material in the collection SHOULD be used outside the indicated period.
The key validity period attribute described in this section and the key duration attribute described in the next section provide complementary functions.
The key validity period attribute provides explicit date and time values, which indicate the beginning and ending of the keying material usage period.
The key duration attribute provides the maximum length of time that the keying material SHOULD be used.
If both attributes are provided, this duration MAY occur at any time within the specified period, but the limits imposed by both attributes SHOULD be honored.
Due to multiple layers of encapsulation or the use of content collections, the key validity period attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key validity period attribute within the same scope, all of the included attribute fields MUST contain exactly the same value.
However, if the doNotUseAfter field is absent in an inner layer, a value MAY appear in an outer layer.
Receivers MUST reject any key package that fails these consistency checks.
The key duration attribute indicates the maximum period of time that the keying material is intended for use.
The date and time that the duration begins is not specified, but the maximum amount of time that the keying material can be used to provide security services is specified.
It can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the key duration attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then all of the keying material within the content MUST have the same key duration.
The key duration attribute has the following syntax:
The key validity period attribute described in the previous section and the key duration attribute described in this section provide a complementary function.
The relationship between these attributes is described in the previous section.
Due to multiple layers of encapsulation or the use of content collections, the key duration attribute can appear in more than one location in the overall key package.
When there are multiple occurrences of the key duration attribute within the same scope, all of the included attribute fields MUST contain exactly the same value.
Receivers MUST reject any key package that fails these consistency checks.
The classification attribute indicates level of classification.
The classification attribute specifies the aggregate classification of the package content.
It can appear as a symmetric key, symmetric key package, asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
If the classification attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then the value MUST represent the classification of all of the keying material within the content.
Encrypted layers MAY contain content at a higher classification that will be revealed once they are decrypted.
If the classification attribute is associated with a collection, then the sensitivity of all the data within the collection MUST be dominated by the classification carried in this attribute.
The classification attribute makes use of the ESSSecurityLabel defined in Section 17.1 as well as [RFC2634] and [RFC5911].
The term "classification" is used in this document, but the term "security label" is used in [RFC2634].
The two terms have the same meaning.
[RFC2634] and [RFC5911] specify an object identifier and syntax for the security label attribute.
The same values are used for the classification attribute:
} id aa KP classification OBJECT IDENTIFIER ::
The syntax of ESSSecurityLabel is not repeated here; however, see Section 17.1 for security label conventions that MUST be followed by implementations of this specification.
See [RFC2634] for a complete discussion of the semantics and syntax.
When the classification attribute appears in more than one location in the overall key package, each occurrence is evaluated independently.
The content originator MUST ensure that the classification attribute represents the sensitivity of the plaintext within the content.
That is, the classification MUST dominate any other plaintext classification attribute value that is present elsewhere in the overall key package.
Note that the classification attribute value may exceed these other plaintext classification attribute values
if the other attribute values within the SignerInfo, AuthEnvelopedData, or AuthenticatedData are themselves classified and warrant the higher security label value.
When the classification attribute appears in more than one location in the overall key package, each security label might be associated with a different security policy.
Content originators SHOULD avoid mixing multiple security policies in the same key package whenever possible, since this requires that receivers and intermediaries that check the classification attribute values include support for the union of the security policies that are present.
Failure to recognize an included security policy MUST result in rejection of the key package.
Receivers MUST reject any key package that includes a classification for which the receiver's processing environment is not authorized.
The ESSSecurityLabel ASN.1 type is used to represent the classification.
The ESSSecurityLabel is defined in Section 3.2 of [RFC2634].
The syntax definition is repeated here to facilitate discussion:
A security policy is a set of criteria for the provision of security services.
The security policy identifier, which is an object identifier, is used to identify the security policy associated with the security label.
It indicates the semantics of the other security label components.
If the key package receiver does not recognize the object identifier in the security policy identifier field and the security label includes a security categories field, then the key package contents MUST NOT be accepted and the enclosed keying material MUST NOT be used.
If the key package receiver does not recognize the object identifier in the security policy identifier field and the security label does not include a security categories field, then the key package contents MAY be accepted only if the security classification field is present and it contains a value from the basic hierarchy as described below.
This specification defines the use of the SecurityClassification field exactly as is it specified in the 1988 edition of ITU T Recommendation X.411 [X.411], which states in part: If present, a security classification may have one of a hierarchical list of values.
The basic security classification hierarchy is defined in this Recommendation, but the use of these values is defined by the security policy in force.
Additional values of security classification, and their position in the hierarchy, may also be defined by a security policy as a local matter or by bilateral agreement.
The basic security  classification hierarchy is, in ascending order: unmarked, unclassified, restricted, confidential, secret, top secret.
Implementations MUST support the basic security classification hierarchy.
Such implementations MAY also support other security  classification values; however, the placement of additional values in the hierarchy MUST be specified by the security policy.
Implementations MUST NOT make access control decisions based on the privacy mark.
However, information in the privacy mark can be displayed to human users by devices that have displays to do so.
The privacy mark length MUST NOT exceed 128 characters.
The privacy mark SHALL use the PrintableString choice if all of the characters in the privacy mark are members of the printable string character set.
If present, security categories provide further granularity for the keying material.
The security policy in force indicates the permitted syntaxes of any entries in the set of security categories.
At most, 64 security categories may be present.
The security  categories have ASN.1 type SecurityCategories and further SecurityCategory [RFC5912], which are both repeated here to facilitate discussion:
Only the Enumerated Tag and Informative Tag are permitted in the classification attribute.
The Enumerated Tag is composed of one or more non negative integers.
Each non negative integer represents a non hierarchical security attribute that applies to the labeled content.
A security policy might define a large set of security categories attributes, but a particular key package generally contains only a few security categories attributes.
In this case, use of the integer representation is intended to minimize the size of the label.
Security attributes enumerated by tags of this type could be restrictive (such as compartments) or permissive (such as release permissions).
Two object identifiers for the SecurityCategory type field have been defined, one for restrictive and one for permissive.
The object identifiers are: i
Any security policy that makes use of security categories MUST assign object identifiers for each tagName, assign the set of integer values associated with each tagName, and specify the semantic meaning for each integer value.
Restrictive security attributes and permissive security attributes SHOULD be associated with different tagName object identifiers.
The Informative Tag is composed of either a) one or more non negative integers or b) a bit string.
Only the integer choice is allowed in this specification.
Each non negative integer represents a non  hierarchical security attribute that applies to the labeled content.
Use of the integer representation is intended to minimize the size of the label since a particular key package generally contains only a few security categories attributes, even though a security policy might define a large set of security categories attributes.
Security attributes enumerated by tags of this type are informative (i.e., no access control is performed).
One object identifier for the SecurityCategory type field has been defined and is as follows:
CHOICE { bitSetAttributes    BIT STRING
, securityAttributes  SET OF SecurityAttribute }
Any security policy that makes use of security categories MUST assign object identifiers for each tagName, assign the set of integer values associated with each tagName, and specify the semantic meaning for each integer value.
The key package originator may include a split identifier attribute to designate that the keying material contains a split rather than a complete key.
It may appear as a symmetric and asymmetric key attribute.
The split identifier attribute MUST NOT appear as a symmetric key package, signed, authenticated, authenticated&unprotected, or content attribute.
Split keys have two halves, which are called "A" and "B".
The split identifier attribute indicates which half is included in the key package, and it optionally indicates the algorithm that is needed to combine the two halves.
The combine algorithm is OPTIONAL since each key algorithm has a default mechanism for this purpose, and the combine algorithm is present only if the default mechanism is not employed.
The split identifier attribute has the following syntax:
In most cases, the default combine algorithm will be employed; it makes this attribute a simple constant that identifies either the "A" or "B" half of the split key.
This supports implementation of some key distribution policies.
Note that each split might have its own CRC, but the key and the check word are both recovered when the two splits are combined.
Since the split identifier attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute, a key package cannot include multiple occurrences of the split identifier attribute within the same scope.
Receivers MUST reject any key package in which the split identifier attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute.
The key package type attribute is a shorthand method for specifying all aspects of the key package format, including which attributes are present and the structure of the encapsulated content or collection.
The key package type attribute can be used as a signed, authenticated, authenticated&unprotected, or content attribute.
Rather than implementing the full flexibility of this specification, some devices may implement support for one or more specific key package formats instantiating this specification.
Those specific formats are called templates and can be identified using a key  package type attribute.
The key package type attribute has the following syntax: aa
, the key package type attribute can appear in more than one location in the overall key package.
When that happens, each occurrence is used independently.
Since the receiver is likely to use the key package type attribute value as a decoding aid, any error will most likely lead to parsing problems, and these problems could result in many different errors being reported.
The signature usage attribute identifies the CMS content types that this key can be used to sign, or that are permitted to be signed by the end entity key in a cert path validated by this key.
Symmetric key packages do not contain signature generation or signature validation keying material, so the signature usage attribute MUST NOT appear in a symmetric key package.
For an asymmetric key package, the signature usage attribute indicates the kind of objects that are to be signed with the private key in the package.
However, if the asymmetric key package contains a Certificate Signature Key, then the signature usage attribute also indicates what signed objects can be validated using certificates that are signed by the private key in the asymmetric key package.
Therefore, the signature usage attribute also indicates what kind of objects can be signed by the private keys associated with these certificates.
The signature usage attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute.
The SignatureUsage structure has the same syntax as the CMSContentConstraints structure from [RFC6010], and it is repeated here for convenience.
SignedAttributesSet is updated by this specification.
The SignatureUsage contains a type of CMSContentConstraints.
One or more ContentTypeConstraint MUST appear in CMSContentConstraints.
Within ContentTypeConstraint, the contentType field indicates the encapsulated content type identifier that can be signed with the signature key.
A particular content type MUST NOT appear more than once in the list.
The CMS protecting content types need not be included in the list of permitted content types as the use of CMS is always authorized (see [RFC6010]).
Within ContentTypeConstraint, the canSource enumeration indicates whether the signature key can be used to directly sign the indicated content type.
If the ContentTypeConstraint is canSource (the default value), then the signature key can be used to directly sign the specified content type.
If the ContentTypeConstraint is cannotSource, then the signature key can only be used with the specified content type if it encapsulates a signature that was generated by an originator with a ContentTypeConstraint that is canSource.
Within ContentTypeList, the attrConstraints OPTIONAL field contains a sequence of constraints specific to the content type.
If the attrConstraints field is absent, the signature key can be used to sign the specified content type, without any further checking.
If the attrConstraints field is present, then the signature key can only be used to sign the specified content type if all of the constraints for that content type are satisfied.
Content type constraints are checked by matching the attribute values in the attrConstraint field against the attribute value in the content.
The constraints succeed if the attribute is not present; they fail if the attribute is present and the value is not one of the values provided in attrConstraint.
The fields of attrConstraints implement constraints specific to the content type.
The attrType field is an AttributeType, which is an object identifier of a signed attribute carried in the SignerInfo of the content.
The attrValues field provides one or more acceptable signed attribute values.
It is a set of AttributeValue.
For a signed content to satisfy the constraint, the SignerInfo MUST include a signed attribute of the type identified in the attrType field, and the signed attribute MUST contain one of the values in the set carried in attrValues.
Since the signature usage attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute, an asymmetric key package cannot include multiple occurrences of the signature usage attribute within the same scope.
Receivers MUST reject any asymmetric key package in which the signature usage attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute.
The other certificate formats attribute specifies the type, format, and value of certificates that are not X.509 public key certificates.
Symmetric key packages do not contain any certificates, so the other  certificate formats attribute MUST NOT appear in a symmetric key package.
It SHOULD appear in the attributes field, when the publicKey field is absent and the certificate format is not X.509.
This attribute MUST NOT appear in an attributes field that includes the user certificate attribute from Section 8.
The other  certificate formats attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute.
The other certificate formats attribute has the following syntax: aa
otherCertFormat } The other certificate formats attribute makes use of the CertificateChoices field defined in Section 10.2.2 of [RFC5652].
The certificate, extendedCertificate, and v1AttrCert fields MUST be omitted.
The v2AttrCert field can include Version 2 Attribute Certificates.
The other field can include Enhanced FIREFLY certificates and other as yet undefined certificate formats.
Since the other certificate formats attribute MUST NOT appear as a signed, authenticated, authenticated&unprotected, or content attribute, an asymmetric key package cannot include multiple occurrences of the other certificate formats attribute within the same scope.
Receivers MUST reject any asymmetric key package in which the other certificate formats attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute.
The pki path attribute includes certificates that can aid in the validation of the certificate carried in the user certificate attribute.
Symmetric key packages do not contain any certificates, so the pkiPath attribute MUST NOT appear in a symmetric key package.
It can appear as an asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
It can appear in the attributes field, when the publicKey field is absent and the certificate format is X.509.
This attribute MUST NOT appear in an AsymmetricKeyPackage that has an other certificate formats attribute in the attributes field.
If the pki path attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then the value includes certificates that can be used to construct a certification path to all of the keying material within the content.
This attribute MUST be supported.
The syntax is taken from [X.509] but redefined using the ATTRIBUTE CLASS from [RFC5912].
The pki path attribute has the following syntax: aa
The first certificate in the sequence is the subject's parent Certification Authority (CA).
The next certificate is that CA's parent, and so on.
The end entity and trust anchor are not included in this attribute.
Due to multiple layers of encapsulation or the use of content collections, the pki path attribute can appear in more than one location in the overall key package.
When that happens, each occurrence is evaluated independently.
The useful certificates attribute includes certificates that can aid in the validation of certificates associated with other parties with whom secure communications are anticipated.
It can appear as an asymmetric key, signed, authenticated, authenticated&unprotected, or content attribute.
For an asymmetric key that has an other  certificate formats attribute (Section 21) in the attributes field, the useful certificates attribute MUST NOT appear.
If the useful  certificates attribute appears as a signed, authenticated, authenticated&unprotected, or content attribute, then the value includes certificates that may be used to validate certificates of others with whom the receiver communicates.
This attribute MUST be supported.
The useful certificates attribute has the following syntax:
The useful certificates attribute makes use of the CertificateSet field defined in Section 10.2.3 of [RFC5652].
Within the CertificateChoices field, the extendedCertificate and v1AttrCert fields MUST always be omitted.
If the userCertificate attribute from Section 8 is included, the other field MUST NOT be present.
If the other certificate formats attribute (Section 21) is included, the certificate field MUST NOT be present.
Due to multiple layers of encapsulation or the use of content collections, the useful certificates attribute can appear in more than one location in the overall key package.
When the useful  certificates attribute appears in more than one location in the overall key package, each occurrence is evaluated independently.
The key wrap algorithm attribute identifies a key wrap algorithm with an algorithm identifier.
It can appear as a symmetric key or symmetric key package attribute.
When this attribute is present in sKeyAttrs, it indicates that the associated sKey field contains a black key, which is an encrypted key, that was wrapped by the identified algorithm.
When this attribute is present in sKeyPkgAttrs, it indicates that every sKey field in that symmetric key package contains a black key and that all keys are wrapped by the same designated algorithm.
The content decryption key identifier attribute can appear as an unprotected attribute as well as a symmetric and symmetric key package attribute.
The attribute's semantics differ based on the location.
Symmetric Key and Symmetric Key Package
The content decryption key identifier attribute [RFC6032] identifies the keying material needed to decrypt the sKey.
It can appear as a symmetric key and symmetric key package attribute.
If the key wrap  algorithm attribute appears in sKeyPkgAttrs, then the corresponding content decryption identifier attribute can appear in either sKeyPkgAttrs or sKeyAttrs.
If the key wrap algorithm attribute (Section 24) appears in sKeyAttrs, then the corresponding content  decryption identifier attribute MUST appear in sKeyAttrs.
The content decryption key identifier attribute in included for convenience: aa
The content decryption key identifier contains an octet string, and this syntax does not impose any particular structure on the identifier value.
Unprotected The content decryption key identifier attribute can be used to identify the keying material that is needed for decryption of the EncryptedData content if there is any ambiguity.
The content decryption key identifier attribute syntax is found in Section 25.1.
The content decryption key identifier contains an octet string, and this syntax does not impose any particular structure on the identifier value.
Due to multiple layers of encryption, the content decryption key  identifier attribute can appear in more than one location in the overall key package.
When that happens, each occurrence is evaluated independently.
Each one is used to identify the needed keying material for that layer of encryption.
The certificate pointers attribute can be used to reference one or more certificates that may be helpful in the processing of the content once it is decrypted.
Sometimes certificates are omitted if they can be easily fetched.
However, an intermediary may have better facilities to perform the fetching than the receiver.
The certificate pointers attribute may be useful in some environments.
This attribute can appear as an unprotected and an unauthenticated&unprotected attribute.
The certificate pointers attribute uses the same syntax and semantics as the subject information access certificate extension [RFC5280].
The certificate pointers attribute has the following syntax: aa certificatePointers ATTRIBUTE ::
As specified in [RFC5280], the id ad caRepository access method can be used to point to a repository where a Certification Authority publishes certificates and Certificate Revocation Lists (CRLs).
In this case, the accessLocation field tells how to access the repository.
Where the information is available via HTTP, FTP, or the Lightweight Directory Access Protocol (LDAP), accessLocation contains a Uniform Resource Identifier (URI).
Where the information is available via the Directory Access Protocol (DAP), accessLocation contains a directory name.
The CRL pointers attribute can be used to reference one or more CRLs that may be helpful in the processing of the content once it is decrypted.
Sometimes CRLs are omitted to conserve space or to ensure that the most recent CRL is obtained when the certificate is validated.
However, an intermediary may have better facilities to perform the fetching than the receiver.
The CRL pointers attribute may be useful in some environments.
This attribute can appear as an unprotected and unauthenticated&unprotected attribute.
The CRL pointers attribute has the following syntax: aa crlPointers
{ TYPE GeneralNames IDENTIFIED BY
id aa KP crlPointers }
} The CRL pointers attribute uses the GeneralNames syntax from [RFC5280].
Each name describes a different mechanism to obtain the same CRL.
Where the information is available via HTTP, FTP, or LDAP, GeneralNames contains a URI.
Where the information is available via DAP, GeneralNames contains a directory name.
Key Package Identifier and Receipt Request
The key package identifier and receipt request attribute from [RFC7191] is also supported.
It can appear as a signed attribute, authenticated, authenticated&unprotected, or content attribute.
This specification also defines three additional extended ErrorCodeChoice object identifiers for the oid field [RFC7191]:
{ id errorCodes 4 } missingKeyType indicates that all keying material within a package is of the same type; however, the key package type attribute is not specified in sKeyPkgAttrs [RFC6031].
privacyMarkTooLong indicates that a classification attribute includes a privacy mark that exceeds 128 characters in length.
unrecognizedSecurityPolicy indicates that a security policy  identifier is not supported.
incorrectKeyProvince indicates that the value of the key province v2 attribute in a key package does not match the key province constraint of the trust anchor used to validate the key package.
Processing Key Package Attribute Values and CMS Content Constraints Trust anchors may contain constraints for any content type [RFC5934].
When the trust anchor contains constraints for the symmetric key package content type or the asymmetric key package content type, then the constraints provide default values for key package attributes that are not present in the key package and define the set of acceptable values for key package attributes that are present.
When a trust anchor delegates authority by issuing an X.509 certificate, the CMS content constraints certificate extension [RFC6010] may be included to constrain the authorizations.
The trust anchor and the X.509 certification path provide default values for key package attributes that are not present in the key package and define the set of acceptable of values for key package attributes that are present.
Constraints on content type usage are represented as attributes.
The processing procedures for the CMS content constraints certificate extension [RFC6010] are part of the validation of a signed or authenticated object, and the procedures yield three output values: cms constraints, cms effective attributes, and cms default attributes.
Object validation MUST be performed before processing the key package contents, and these output values are used as part of key package processing.
These same output values are easily generated directly from a trust anchor and the key package when no X.509 certification path is involved in validation.
The cms effective attributes provides the set of acceptable values for attributes.
Each attribute present in the key package that corresponds to an entry in cms effective attributes MUST contain a value that appears in cms effective attributes entry.
Attributes that do not correspond to an entry in cms effective attributes are unconstrained and may contain any value.
Correspondence between attributes and cms effective attributes is determined by comparing the attribute object identifier to object identifier for each entry in cms effective attributes.
The cms default attributes provides values for attributes that do not appear in the key package.
If cms default attributes includes only one attribute value for a particular attribute, then that value is used as if it were included in the key package itself.
However, if cms default attributes includes more than one value for a particular attribute, then the appropriate value remains ambiguous and the key package should be rejected.
Some attributes can appear in more than one place in the key package, and for this reason, the attribute definitions include consistency checks.
These checks are independent of constraints checking.
In addition to the consistency checks, each instance of the attribute MUST be checked against the set of cms effective attributes, and the key package MUST be rejected if any of the attributes values are not in the set of authorized set of values.
This section provides an example symmetric key package in order to provide a discussion of the scope of attributes.
This is an informative section; it is not a normative portion of this specification.
Figure 1 provides the example.
All of the concepts apply to either a symmetric key package or an asymmetric key package, with the exception of the key algorithm attribute, which is only applicable to a symmetric key package.
Each of the components is labeled with a number inside parentheses for easy reference: (1) is the ContentInfo that must be present as the outermost layer of encapsulation.
It is shown for completeness.
(2) is a SignedData content type, which includes six signed attributes.
Four of the signed attributes are keying material attributes.
(3) is a ContentCollection that includes two encapsulated content types: a ContentWithAttributes and an EncryptedKeyPackage.
This content type does not provide any attributes.
(4) is a ContentWithAttributes content type.
It encapsulates a SignedData content type.
Four key material attributes are provided.
(5) is a SignedData content type.
It encapsulates a SymmetricKeyPackage content type.
Six signed attributes are provided.
Four attributes are key material attributes.
(6) is a SymmetricKeyPackage content type, and it includes three key material attributes.
Note that the contents of this key package are not encrypted, but the contents are covered by two digital signatures.
(7) is an EncryptedKeyPackage content type.
It encapsulates a SignedData content type.
This content type provides one unprotected attribute.
(8) is a SignedData content type.
It encapsulates a SymmetricKeyPackage content type.
Six signed attributes are provided.
Four attributes are key material attributes.
(9) is a SymmetricKeyPackage content type, and it includes three key material attributes.
Note that the contents of this key package are encrypted; the plaintext keying material is covered by one digital signature, and the ciphertext keying material is covered by another digital signature.
SignedData content type (2) includes six signed attributes:
The content type attribute contains id
to indicate the type of the encapsulated content, and it has no further scope.
The message digest attribute contains the one way hash value of the encapsulated content; it is needed to validate the digital signature.
It has no further scope.
The classification attribute contains the security label for all of the plaintext in the encapsulated content.
Each classification attribute is evaluated separately; it has no further scope.
In general, the values of this attribute will match or dominate the security label values in (4), (5), and (6).
The value of this attribute might not match or dominate the security label values in (8) and (9) since they are encrypted.
It is possible that these various security label values are associated with different security policies.
To avoid the processing complexity associated with policy mapping, comparison is not required.
The key package receivers v2 attribute indicates the authorized key package receivers, and it has no further scope.
The additional instances of key package receivers v2 attribute embedded in (4) are evaluated without regard to the value of the instance in (2).
The key distribution period attribute contains two date values: doNotDistBefore and doNotDistAfter.
These values must match all others within the same scope, which in this example is the key distribution period within (4).
The key package type attributes indicates the format of the key package, and it has no further scope.
The key package type attributes values within (5) and (8) are evaluated without regard to the value of this attribute.
ContentWithAttributes content type (4) includes four attributes:  The classification attribute contains the security label for all of the plaintext in the encapsulated content.
Each classification attribute is evaluated separately; it has no further scope.
The TSEC Nomenclature attribute includes only the shortTitle field, and the value must match all other instances within the same scope, which appear in (5) and (6).
Note that the TSEC  Nomenclature attribute values in (8) and (9) are not in the same scope as the TSEC Nomenclature attribute that appears in (4).
The key package receivers v2 attribute indicates the authorized key package receivers, and it has no further scope.
The enveloping instance of key package receivers v2 attribute value in (2) is evaluated without regard to the value of this instance in (4), and has no effect on the value of this instance in (4).
The key distribution period attribute contains two date values: doNotDistBefore and doNotDistAfter.
These values must match all others within the same scope, which in this example is the key distribution period within (2).
SignedData content type (5) includes six signed attributes:
The content type attribute contains id ct KP skeyPackage to indicate the type of the encapsulated content, and it has no further scope.
The message digest attribute contains the one way hash value of the encapsulated content; it is needed to validate the digital signature.
It has no further scope.
The classification attribute contains the security label for all of the plaintext in the encapsulated content.
Each classification attribute is evaluated separately; it has no further scope.
The TSEC Nomenclature attribute includes only the shortTitle field, and the value must match all other instances within the same scope, which appear in (6).
Since this is within the scope of (4), these shortTitle field values must match as well.
Note that the TSEC Nomenclature attribute values in (8) and (9) are not in the same scope.
The key purpose attribute specifies the purpose of the key material.
All occurrences within the scope must have the same value; however, in this example, there are no other occurrences within the scope.
The key purpose attribute value within (8) is evaluated without regard to the value of this attribute.
The key package type attribute indicates the format of the key package, and it has no further scope.
The key package type attribute values within (2)
and (8) are evaluated without regard to the value of this attribute.
SymmetricKeyPackage content type (6) includes three keying material attributes, which could appear in the sKeyPkgAttrs or sKeyAttrs fields:
The key algorithm attribute includes only the keyAlg field, and it must match all other occurrences within the same scope.
However, there are no other key algorithm attribute occurrences in the same scope; the key algorithm attribute value in (9) is not in the same scope.
The classification attribute contains the security label for all of the plaintext in the key package.
Each classification attribute is evaluated separately; it has no further scope.
The TSEC Nomenclature attribute includes the shortTitle field as well as some of the optional fields.
The shortTitle field value must match the values in (4) and (5), since this content type is within their scope.
Note that the TSEC Nomenclature attribute values in (8) and (9) are not in the same scope.
EncryptedKeyPackage content type (7) includes one unprotected attribute, and the encryption will prevent any intermediary that does not have the ability to decrypt the content from making any consistency checks on (8) and (9):
The content decryption key identifier attribute identifies the key that is needed to decrypt the encapsulated content; it has no further scope.
SignedData content type (8) includes six signed attributes:
The content type attribute contains id ct KP skeyPackage to indicate the type of the encapsulated content, and it has no further scope.
The message digest attribute contains the one way hash value of the encapsulated content; it is needed to validate the digital signature.
It has no further scope.
The classification attribute contains the security label for content.
Each classification attribute is evaluated separately; it has no further scope.
The TSEC Nomenclature attribute includes only the shortTitle field, and the value must match all other instances within the same scope, which appear in (9).
Note that the TSEC  Nomenclature attribute values in (4), (5), and (6) are not in the same scope.
The key purpose attribute specifies the purpose of the key material.
All occurrences within the scope must have the same value; however, in this example, there are no other occurrences within the scope.
The key purpose attribute value within (5) is evaluated without regard to the value of this attribute.
The key package type attribute indicates the format of the key package, and it has no further scope.
The key package type attribute values within (2) and (5) are evaluated without regard to the value of this attribute.
SymmetricKeyPackage content type (9) includes three keying material attributes, which could appear in the sKeyPkgAttrs or sKeyAttrs fields:
The key algorithm attribute includes only the keyAlg field, and it must match all other occurrences within the same scope.
However, there are no other key algorithm attribute occurrences in the same scope; the key algorithm attribute value in (6) is not in the same scope.
The classification attribute contains the security label for all of the plaintext in the key package.
Each classification attribute is evaluated separately; it has no further scope.
The TSEC Nomenclature attribute includes the shortTitle field as well as some of the optional fields.
The shortTitle field value must match the values in (8), since this content type is within its scope.
Note that the TSEC Nomenclature attributes values in (4), (5), and (6) are not in the same scope.
In summary, the scope of an attribute includes the encapsulated content of the CMS content type in which it appears, and some attributes also require consistency checks with other instances that appear within the encapsulated content.
Proper recognition of scope is required to accurately perform attribute processing.
Example Illustrating Scope of Attributes 32.
The majority of this specification is devoted to the syntax and semantics of key package attributes.
It relies on other specifications, especially [RFC2634], [RFC4073], [RFC4108], [RFC5652], [RFC5911], [RFC5912], [RFC5958], [RFC6010], and [RFC6031]; their security considerations apply here.
Additionally, cryptographic algorithms are used with CMS protecting content types as specified in [RFC5959],
[RFC6160], [RFC6161], and [RFC6162]; the security considerations from those documents apply here as well.
This specification also relies upon [RFC5280] for the syntax and semantics of X.509 certificates.
Digital signatures provide data integrity or data origin authentication, and encryption provides confidentiality.
Security factors outside the scope of this specification greatly affect the assurance provided.
The procedures used by Certification Authorities (CAs) to validate the binding of the subject identity to their public key greatly affect the assurance that ought to be placed in the certificate.
This is particularly important when issuing certificates to other CAs.
The CMS AuthenticatedData content type MUST be used with care since a Message Authentication Code (MAC) is used.
The same key is needed to generate the MAC or validate the MAC.
Thus, any party with access to the key needed to validate the MAC can generate a replacement that will be acceptable to other recipients.
In some situations, returning very detailed error information can provide an attacker with insight into the security processing.
Where this is a concern, the implementation should return the most generic error code that is appropriate.
However, detailed error codes are very helpful during development, debugging, and interoperability testing.
For this reason, implementations may want to have a way to configure the use of generic or detailed error codes.
{ joint iso itu t(2)
39 } DEFINITIONS IMPLICIT TAGS ::
aa communityIdentifiers, CommunityIdentifier FROM CMSFirmwareWrapper 2009 { iso(1) member
id mod cms firmware wrap 02(40) }
aa securityLabel FROM ExtendedSecurityServices 2009
{ iso(1) member body(2) us(840)
d mod ess 2006 02(42) }
From [RFC5911] [RFC5912] AlgorithmIdentifier{}, SMIME CAPS, ParamOptions, KEY WRAP FROM AlgorithmInformation 2009 {
id mod algorithmInformation 02(58) }
From [RFC5912] Name, Certificate FROM PKIX1Explicit 2009 { iso(1)
From [RFC6010] CMSContentConstraints FROM CMSContentConstraintsCertExtn {
aa binarySigningTime, BinaryTime FROM BinarySigningTimeModule 2010
{ iso(1) member body(2) us(840)
id mod binSigningTime 2009(55) }
From [RFC6268] CertificateChoices, CertificateSet, Attribute {},
aa contentType, aa messageDigest FROM CryptographicMessageSyntax 2010 {
id mod cms 2009(58) }
SIREntityName FROM KeyPackageReceiptAndErrorModuleV2 { iso(1) member body(2
From [X.509] certificateExactMatch FROM CertificateExtensions { joint iso itu t ds(5)
Replaces SignedAttributesSet information object set from   [RFC6268].
}   Replaces OneAsymmetricKeyAttributes from [RFC5958]
Content Type, Message Digest, Content Hint, and Binary Signing
Time are imported from [RFC6268].
Community Identifiers is imported from [RFC5911].
ShortTitle   Key Algorithm Attribute aa keyAlgorithm ATTRIBUTE :
MATCHING RULE certificateExactMatch IDENTIFIED BY id at userCertificate } id
Key Package Receivers Attribute aa keyPackageReceivers v2 ATTRIBUTE
lastRegister   Register } SegmentID ::
Key Purpose Attribute aa keyPurpose ATTRIBUTE :
Symmetric Authentication Key rgk  (253),
Certificate Encryption Key exk  (255),
Expect additional key use values   }
Key Attribute aa transportKey ATTRIBUTE ::
infosec(1) keying material attributes(13) 15
Key Distribution Period Attribute aa keyDistributionPeriod ATTRIBUTE :
infosec(1) keying material attributes(13) 5 } KeyDistPeriod ::
Attribute aa keyValidityPeriod ATTRIBUTE :
BinaryTime, doNotUseAfter   BinaryTime OPTIONAL }
Key Duration Attribute aa keyDurationPeriod ATTRIBUTE :
[1] INTEGER (1..ub KeyDuration weeks), months  [2] INTEGER (1..ub KeyDuration months), years
The attribute syntax is imported from [RFC6268].
The term   "classification" is used in this document, but the term "security   label" is used in [RFC2634].
The terms have the same meaning.
} id aa KP classification OBJECT IDENTIFIER ::
WITH SYNTAX { IDENTIFIER &id [PARAMS [TYPE &Params] ARE &paramPresence]
Key Package Type Attribute aa
Usage Attribute aa signatureUsage v3 ATTRIBUTE :
Other Certificate Format Attribute aa otherCertificateFormats ATTRIBUTE :
PKI Path Attribute aa pkiPath ATTRIBUTE ::
Useful Certificates Attribute aa usefulCertificates ATTRIBUTE :
Content Decryption Key Identifier Attribute aa contentDecryptKeyIdentifier ATTRIBUTE
OCTET STRING   Certificate Pointers Attribute aa certificatePointers
id aa KP crlPointers }
