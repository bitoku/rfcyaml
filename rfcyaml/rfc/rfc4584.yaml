- title: __initial_text__
  contents:
  - '                Extension to Sockets API for Mobile IPv6

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes data structures and API support for Mobile\n\
    \   IPv6 as an extension to the Advanced Socket API for IPv6.\n   Just as the\
    \ Advanced Sockets API for IPv6 gives access to various\n   extension headers\
    \ and the ICMPv6 protocol, this document specifies\n   the same level of access\
    \ for Mobile IPv6 components.  It specifies a\n   mechanism for applications to\
    \ retrieve and set information for\n   Mobility Header messages, Home Address\
    \ destination options, and\n   Routing Header Type 2 extension headers.  It also\
    \ specifies the\n   common data structures and definitions that might be used\
    \ by certain\n   advanced Mobile IPv6 socket applications.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Applicability ...................................................4\n  \
    \ 3. Overview ........................................................5\n   4.\
    \ Common Structures and Definitions ...............................6\n      4.1.\
    \ The Mobility Header Data Structures ........................6\n           4.1.1.\
    \ The ip6_mh Structure ................................6\n           4.1.2. Binding\
    \ Refresh Request Mobility Message ............7\n           4.1.3. Home Address\
    \ Test Init (HoTI) Message ...............7\n           4.1.4. Care-of Address\
    \ Test Init (CoTI) Message ............7\n           4.1.5. Home Address Test\
    \ (HOT) Message .....................8\n           4.1.6. Care Of Address Test\
    \ (COT) Message ..................8\n           4.1.7. Binding Update Mobility\
    \ Message .....................8\n           4.1.8. Binding Acknowledgement Mobility\
    \ Message ............9\n           4.1.9. Binding Error Mobility Message ......................9\n\
    \           4.1.10. Mobility Option TLV data structure .................9\n  \
    \         4.1.11. Mobility Option Data Structures ...................10\n    \
    \              4.1.11.1. Binding Refresh Advice ...................10\n      \
    \            4.1.11.2. Alternate Care-of Address ................10\n        \
    \          4.1.11.3. Nonce Indices ............................10\n          \
    \        4.1.11.4. Binding Authorization Data ...............10\n      4.2. Mobility\
    \ Header Constants .................................10\n      4.3. IPv6 Home Address\
    \ Destination Option ......................12\n      4.4. Type 2 Routing Header\
    \ .....................................12\n      4.5. New ICMP Messages for Mobile\
    \ IPv6 .........................13\n      4.6. IPv6 Neighbor Discovery Changes\
    \ ...........................14\n   5. Access to Home Address Destination Option\
    \ and Routing Headers ..15\n      5.1. Routing Header Access Functions ...........................17\n\
    \      5.2. Content of Type 2 Routing Header ..........................18\n  \
    \    5.3. Order of Extension Headers for Home Address\n           Destination\
    \ Options .......................................19\n      5.4. Home Address Destination\
    \ Option Access Functions ..........20\n      5.5. Content of Home Address Destination\
    \ Option ................20\n   6. Mobility Protocol Headers ......................................21\n\
    \      6.1. Receiving and Sending Mobility Header Messages ............21\n  \
    \ 7. Protocols File .................................................22\n   8.\
    \ IPv4-Mapped IPv6 Addresses .....................................23\n   9. Security\
    \ Considerations ........................................23\n   10. IANA Considerations\
    \ ...........................................23\n   11. Acknowledgements ..............................................23\n\
    \   12. References ....................................................24\n  \
    \    12.1. Normative References .....................................24\n    \
    \  12.2. Informative References ...................................24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Mobility Support in IPv6 [2] defines a new Mobility Protocol\
    \ header,\n   a Home Address destination option and a new Routing Header type.\
    \  It\n   is expected that Mobile IPv6 user-level implementations and some\n \
    \  special applications will need to access and process these IPv6\n   extension\
    \ headers.  This document is an extension to the existing\n   Advanced Sockets\
    \ API document [1]; it addresses the Advanced IPv6\n   Sockets API for these new\
    \ protocol elements defined by Mobile IPv6.\n   The applicability of this API\
    \ mainly targets user-level applications.\n   However, it has also been shown\
    \ to be useful within some Mobile IPv6\n   implementations; for instance, where\
    \ part of the Mobile IPv6 protocol\n   is implemented at user-level and part in\
    \ the kernel.  It is up to any\n   such implementations to architect which part\
    \ of the Mobile IPv6 and\n   IP Security (IPSec) packet processing should be done\
    \ at the user-\n   level in order to meet the design needs of the particular platform\n\
    \   and operating system.\n   The target user-level applications for this socket\
    \ API are believed\n   to be debugging and diagnostic applications and some policy\n\
    \   applications that would like to receive copies of protocol\n   information\
    \ at the application layer.\n   The packet information and access to the extension\
    \ headers (Routing\n   header and Destination options) are specified using the\
    \ \"ancillary\n   data\" fields that were added to the 4.3BSD Reno sockets API\
    \ in 1990.\n   The reason is that these ancillary data fields are part of the\n\
    \   Posix.1g standard and should therefore be adopted by most vendors.\n   This\
    \ document is consistent with Advanced Sockets API for IPv6 [1] in\n   structure\
    \ definitions, header files, and function definitions.  Thus,\n   the implementors\
    \ of this API document are assumed to be familiar with\n   the data structures,\
    \ data sending and receiving procedures, and the\n   IPv6 extension header access\
    \ functions described in the Advanced\n   Sockets API for IPv6 [1].\n   Non-goals\n\
    \   This document does not address application access to either the\n   Authentication\
    \ Header or the Encapsulating Security Payload header.\n   This document also\
    \ does not address any API that might be necessary\n   for Mobile Network [4]\
    \ specific needs.  Furthermore, note that this\n   API document excludes discussion\
    \ on application-level API.  It\n   assumes that address selection socket API\
    \ [5] takes care of selection\n   of care-of address or home address as the source\
    \ address by the\n   application, when source address selection is required due\
    \ to the\n   nature of the application.\n   Providing mobility \"awareness\" to\
    \ applications, such as applications'\n   being able to tell whether the host\
    \ is at home or not, is out of\n   scope for this API.\n"
- title: 2.  Applicability
  contents:
  - "2.  Applicability\n   This API document can be applied in the following cases:\n\
    \   1.  User-level debugging and monitoring tools: This socket API is\n      \
    \ useful for accessing Mobility Headers, Home Address destination\n       options\
    \ and Type 2 Routing Headers .  For example, mh-ping might\n       be a monitoring\
    \ tool that can process mobility headers on the\n       receiving side to check\
    \ binding status.\n   2.  Partial user-level implementation of Mobile IPv6: We\
    \ assume that\n       some implementations may choose to do the Mobility header\n\
    \       processing at user level.  In that case, this document recommends\n  \
    \     implementing at least the handling of Home Address destination\n       options\
    \ and Type 2 Routing Header in the main IP processing paths\n       in the kernel.\
    \  The API can then be used to send and receive the\n       Mobility Header packets\
    \ used for Mobile IPv6 signaling.\n   3.  Complete header processing at the kernel-level:\
    \ Many\n       implementations of Mobile IPv6 [2] perform processing of Home\n\
    \       Address destination options, Type 2 Routing Headers, and Mobility\n  \
    \     headers at the kernel level.  However, the kernel keeps a copy of\n    \
    \   the received extension headers and passes them up to the API,\n       which\
    \ is used by the user-level applications purely for\n       monitoring and debugging\
    \ Mobile IPv6 packets.\n   On an IPv6 host that does not implement Mobile IPv6,\
    \ the IPv6\n   specification [3] requires that packets with the Home Address option\n\
    \   or Type 2 Routing Header (where segments left is non-zero) be dropped\n  \
    \ on receipt.  This means that it is not possible to implement Mobile\n   IPv6\
    \ as an application on such a system.  Thus, on such a system, the\n   applicability\
    \ of this API is limited to the first case above,\n   enabling debugging and monitoring\
    \ applications (such as tcpdump) to\n   parse and interpret Mobile IPv6 packets.\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   This document can be divided into the following parts:\n   1.\
    \  Definitions of constants and structures for C programs that\n       capture\
    \ the Mobile IPv6 packet formats on the wire.  A common\n       definition of\
    \ these is useful at least for packet snooping\n       applications.  This is\
    \ captured in Section 4.  In addition,\n       Section 4 also defines data structures\
    \ for Home Address\n       destination option, Type 2 Routing Header, and new\
    \ ICMPv6\n       messages related to Mobile IPv6.\n   2.  Notes on how to use\
    \ the IPv6 Advanced API to access Home Address\n       options and Type 2 Routing\
    \ Headers.  This is captured in Section\n       5.\n   3.  Notes on how user-level\
    \ applications can observe MH (Mobility\n       Header) packets using raw sockets\
    \ (in Section 6).  The IPv6 RAW\n       socket interface described in this document\
    \ allows applications\n       to receive  MH packets whether or not the system's\
    \ MH processing\n       takes place in the \"kernel\" or at the \"user space\"\
    .\n   4.  A name is suggested for IPv6 Mobility Header protocol in /etc/\n   \
    \    protocols (in Section 7).\n   All examples in this document omit error checking\
    \ in favor of\n   brevity, as it is following the same style as the Advanced Socket\
    \ API\n   [1].\n   Note that many of the functions and socket options defined\
    \ in this\n   document may have error returns that are not defined in this\n \
    \  document.\n   Data types in this document follow the Posix.1g format: intN_t\
    \ means\n   a signed integer of exactly N bits (e.g., int16_t), and uintN_t means\n\
    \   an unsigned integer of exactly N bits (e.g., uint32_t).\n   Once the API specification\
    \ becomes mature and is deployed, it may be\n   formally standardized by a more\
    \ appropriate body, as has been done\n   with the Basic API [6].  However, since\
    \ this specification largely\n   builds upon the Advanced Socket API [1], such\
    \ standardization would\n   make sense only if the Advanced Socket API [1] were\
    \ also\n   standardized.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \
    \ \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119.\n"
- title: 4.  Common Structures and Definitions
  contents:
  - "4.  Common Structures and Definitions\n   In this section, the structures are\
    \ specified in a way so that they\n   maximize the probability that the compiler-layout\
    \ of data structures\n   are identical to the packet formats on the wire.  However,\
    \ ANSI-C\n   provides few guarantees about the size and alignment of data\n  \
    \ structures.\n   The assumption is that the Advanced Socket API [1] will pass\
    \ up the\n   actual packet content (the wire format) in the buffer and in the\n\
    \   ancillary data objects.  Thus, if an implementor has to handle a\n   system\
    \ where the ANSI-C compiler does not and can not lay out these\n   structures\
    \ to match the wire formats in RFC 3775 [2], the structures\n   defined by this\
    \ API can not be supported on such a system.\n   The constants and structures\
    \ shown below are in network byte order,\n   so an application needs to perform\
    \ the appropriate byte order\n   conversion (ntohs(), etc) when necessary.\n \
    \  The structures and constants below will be included when the (new)\n   header\
    \ file is included : <netinet/ip6mh.h>\n"
- title: 4.1.  The Mobility Header Data Structures
  contents:
  - '4.1.  The Mobility Header Data Structures

    '
- title: 4.1.1.  The ip6_mh Structure
  contents:
  - "4.1.1.  The ip6_mh Structure\n   The following structure is defined as a result\
    \ of including\n   <netinet/ip6mh.h>.  This is the fixed part of the Mobility\
    \ Header.\n   Different Mobility message types are defined in Mobile IPv6 [2].\
    \  For\n   portability and alignment reasons, each mobility message type\n   includes\
    \ the mobility header fields instead of including the ip6_mh\n   structure, followed\
    \ by the message-specific fields.\n      struct  ip6_mh {\n          uint8_t \
    \   ip6mh_proto;   /* NO_NXTHDR by default */\n          uint8_t    ip6mh_hdrlen;\
    \  /* Header Len in unit of 8 Octets\n                                       excluding\
    \ the first 8 Octets */\n          uint8_t    ip6mh_type;    /* Type of Mobility\
    \ Header */\n          uint8_t    ip6mh_reserved;   /* Reserved */\n         \
    \ uint16_t   ip6mh_cksum;   /* Mobility Header Checksum */\n          /* Followed\
    \ by type specific messages */\n      };\n"
- title: 4.1.2.  Binding Refresh Request Mobility Message
  contents:
  - "4.1.2.  Binding Refresh Request Mobility Message\n      struct  ip6_mh_binding_request\
    \ {\n          uint8_t    ip6mhbr_proto;\n          uint8_t    ip6mhbr_hdrlen;\n\
    \          uint8_t    ip6mhbr_type;\n          uint8_t    ip6mhbr_reserved;\n\
    \          uint16_t   ip6mhbr_cksum;\n          uint16_t   ip6mhbr_reserved2;\n\
    \          /* Followed by optional Mobility Options */\n      };\n"
- title: 4.1.3.  Home Address Test Init (HoTI) Message
  contents:
  - "4.1.3.  Home Address Test Init (HoTI) Message\n      struct   ip6_mh_home_test_init\
    \ {\n         uint8_t    ip6mhhti_proto;\n         uint8_t    ip6mhhti_hdrlen;\n\
    \         uint8_t    ip6mhhti_type;\n         uint8_t    ip6mhhti_reserved;\n\
    \         uint16_t   ip6mhhti_cksum;\n         uint16_t   ip6mhhti_reserved2;\n\
    \         uint32_t   ip6mhhti_cookie[2]; /* 64 bit Cookie by MN */\n         /*\
    \ Followed by optional Mobility Options */\n      };\n"
- title: 4.1.4.  Care-of Address Test Init (CoTI) Message
  contents:
  - "4.1.4.  Care-of Address Test Init (CoTI) Message\n      struct   ip6_mh_careof_test_init\
    \ {\n         uint8_t    ip6mhcti_proto;\n         uint8_t    ip6mhcti_hdrlen;\n\
    \         uint8_t    ip6mhcti_type;\n         uint8_t    ip6mhcti_reserved;\n\
    \         uint16_t   ip6mhcti_cksum;\n         uint16_t   ip6mhcti_reserved2;\n\
    \         uint32_t   ip6mhcti_cookie[2]; /* 64 bit Cookie by MN */\n         /*\
    \ Followed by optional Mobility Options */\n      };\n"
- title: 4.1.5.  Home Address Test (HOT) Message
  contents:
  - "4.1.5.  Home Address Test (HOT) Message\n       struct  ip6_mh_home_test {\n\
    \          uint8_t    ip6mhht_proto;\n          uint8_t    ip6mhht_hdrlen;\n \
    \         uint8_t    ip6mhht_type;\n          uint8_t    ip6mhht_reserved;\n \
    \         uint16_t   ip6mhht_cksum;\n          uint16_t   ip6mhht_nonce_index;\n\
    \          uint32_t   ip6mhht_cookie[2];    /* Cookie from HOTI msg */\n     \
    \     uint32_t   ip6mhht_keygen[2];  /* 64 Bit Key by CN */\n          /* Followed\
    \ by optional Mobility Options */\n      };\n"
- title: 4.1.6.  Care Of Address Test (COT) Message
  contents:
  - "4.1.6.  Care Of Address Test (COT) Message\n      struct  ip6_mh_careof_test\
    \ {\n         uint8_t    ip6mhct_proto;\n         uint8_t    ip6mhct_hdrlen;\n\
    \         uint8_t    ip6mhct_type;\n         uint8_t    ip6mhct_reserved;\n  \
    \       uint16_t   ip6mhct_cksum;\n         uint16_t   ip6mhct_nonce_index;\n\
    \         uint32_t   ip6mhct_cookie[2]; /* Cookie from COTI message */\n     \
    \    uint32_t   ip6mhct_keygen[2];  /* 64bit key by CN */\n         /* Followed\
    \ by optional Mobility Options */\n      };\n"
- title: 4.1.7.  Binding Update Mobility Message
  contents:
  - "4.1.7.  Binding Update Mobility Message\n      struct ip6_mh_binding_update {\n\
    \          uint8_t     ip6mhbu_proto;\n          uint8_t     ip6mhbu_hdrlen;\n\
    \          uint8_t     ip6mhbu_type;\n          uint8_t     ip6mhbu_reserved;\n\
    \          uint16_t    ip6mhbu_cksum;\n          uint16_t    ip6mhbu_seqno;  \
    \    /* Sequence Number */\n          uint16_t    ip6mhbu_flags;\n          uint16_t\
    \    ip6mhbu_lifetime; /* Time in unit of 4 sec */\n          /* Followed by optional\
    \ Mobility Options */\n      };\n       /* Binding Update Flags, in network byte-order\
    \ */\n       #define IP6_MH_BU_ACK    0x8000  /* Request a binding ack */\n  \
    \     #define IP6_MH_BU_HOME   0x4000  /* Home Registration */\n       #define\
    \ IP6_MH_BU_LLOCAL 0x2000  /* Link-local compatibility */\n       #define IP6_MH_BU_KEYM\
    \   0x1000  /* Key management mobility  */\n"
- title: 4.1.8.  Binding Acknowledgement Mobility Message
  contents:
  - "4.1.8.  Binding Acknowledgement Mobility Message\n      struct  ip6_mh_binding_ack\
    \ {\n         uint8_t   ip6mhba_proto;\n         uint8_t   ip6mhba_hdrlen;\n \
    \        uint8_t   ip6mhba_type;\n         uint8_t   ip6mhba_reserved;\n     \
    \    uint16_t  ip6mhba_cksum;\n         uint8_t   ip6mhba_status;    /* Status\
    \ code */\n         uint8_t   ip6mhba_flags;\n         uint16_t  ip6mhba_seqno;\n\
    \         uint16_t  ip6mhba_lifetime;\n         /* Followed by optional Mobility\
    \ Options */\n      };\n       /* Binding Acknowledgement Flags */\n       #define\
    \ IP6_MH_BA_KEYM       0x80  /* Key management mobility */\n"
- title: 4.1.9.  Binding Error Mobility Message
  contents:
  - "4.1.9.  Binding Error Mobility Message\n       struct   ip6_mh_binding_error\
    \ {\n          uint8_t   ip6mhbe_proto;\n          uint8_t   ip6mhbe_hdrlen;\n\
    \          uint8_t   ip6mhbe_type;\n          uint8_t   ip6mhbe_reserved;\n  \
    \        uint16_t  ip6mhbe_cksum;\n          uint8_t   ip6mhbe_status;  /* Error\
    \ Status */\n          uint8_t   ip6mhbe_reserved2;\n          struct in6_addr\
    \ ip6mhbe_homeaddr;\n          /* Followed by optional Mobility Options */\n \
    \       };\n"
- title: 4.1.10.  Mobility Option TLV data structure
  contents:
  - "4.1.10.  Mobility Option TLV data structure\n      struct   ip6_mh_opt {\n  \
    \       uint8_t    ip6mhopt_type;   /* Option Type */\n         uint8_t    ip6mhopt_len;\
    \    /* Option Length */\n         /* Followed by variable length Option Data\
    \ in bytes */\n      };\n"
- title: 4.1.11.  Mobility Option Data Structures
  contents:
  - '4.1.11.  Mobility Option Data Structures

    '
- title: 4.1.11.1.  Binding Refresh Advice
  contents:
  - "4.1.11.1.  Binding Refresh Advice\n      struct ip6_mh_opt_refresh_advice {\n\
    \          uint8_t  ip6mora_type;\n          uint8_t  ip6mora_len;\n         \
    \ uint16_t ip6mora_interval; /* Refresh interval in 4 sec */\n      };\n"
- title: 4.1.11.2.  Alternate Care-of Address
  contents:
  - "4.1.11.2.  Alternate Care-of Address\n      struct ip6_mh_opt_altcoa {\n    \
    \      uint8_t ip6moa_type;\n          uint8_t ip6moa_len;\n          struct in6_addr\
    \ ip6moa_addr; /* Alternate CoA */\n      };\n"
- title: 4.1.11.3.  Nonce Indices
  contents:
  - "4.1.11.3.  Nonce Indices\n      struct ip6_mh_opt_nonce_index {\n          uint8_t\
    \ ip6moni_type;\n          uint8_t ip6moni_len;\n          uint16_t ip6moni_home_nonce;\n\
    \          uint16_t ip6moni_coa_nonce;\n      };\n"
- title: 4.1.11.4.  Binding Authorization Data
  contents:
  - "4.1.11.4.  Binding Authorization Data\n      struct ip6_mh_opt_auth_data {\n\
    \          uint8_t ip6moad_type;\n          uint8_t ip6moad_len;\n          uint8_t\
    \ ip6moad_data[12];\n      };\n"
- title: 4.2.  Mobility Header Constants
  contents:
  - "4.2.  Mobility Header Constants\n   IPv6 Next Header Value for Mobility:\n  \
    \    <netinet/in.h>\n      #define IPPROTO_MH       135 /* IPv6 Mobility Header:\
    \ IANA */\n      Mobility Header Message Types:\n      <netinet/ip6mh.h>\n   \
    \   #define IP6_MH_TYPE_BRR       0   /* Binding Refresh Request */\n      #define\
    \ IP6_MH_TYPE_HOTI      1   /* HOTI Message   */\n      #define IP6_MH_TYPE_COTI\
    \      2   /* COTI Message  */\n      #define IP6_MH_TYPE_HOT       3   /* HOT\
    \ Message   */\n      #define IP6_MH_TYPE_COT       4   /* COT Message  */\n \
    \     #define IP6_MH_TYPE_BU        5   /* Binding Update */\n      #define IP6_MH_TYPE_BACK\
    \      6   /* Binding ACK */\n      #define IP6_MH_TYPE_BERROR    7   /* Binding\
    \ Error */\n   Mobility Header Message Option Types:\n   <netinet/ip6mh.h>\n \
    \     #define  IP6_MHOPT_PAD1       0x00  /* PAD1 */\n      #define  IP6_MHOPT_PADN\
    \       0x01  /* PADN */\n      #define  IP6_MHOPT_BREFRESH   0x02  /* Binding\
    \ Refresh */\n      #define  IP6_MHOPT_ALTCOA     0x03  /* Alternate COA */\n\
    \      #define  IP6_MHOPT_NONCEID    0x04  /* Nonce Index */\n      #define  IP6_MHOPT_BAUTH\
    \      0x05  /* Binding Auth Data */\n   Status values accompanied with Mobility\
    \ Binding Acknowledgement:\n   <netinet/ip6mh.h>\n      #define IP6_MH_BAS_ACCEPTED\
    \          0   /* BU accepted */\n      #define IP6_MH_BAS_PRFX_DISCOV       1\
    \   /* Accepted, but prefix\n                                                \
    \  discovery Required */\n      #define IP6_MH_BAS_UNSPECIFIED       128 /* Reason\
    \ unspecified */\n      #define IP6_MH_BAS_PROHIBIT          129 /* Administratively\n\
    \                                                  prohibited */\n      #define\
    \ IP6_MH_BAS_INSUFFICIENT      130 /* Insufficient\n                         \
    \                         resources */\n      #define IP6_MH_BAS_HA_NOT_SUPPORTED\
    \  131 /* HA registration not\n                                              \
    \    supported */\n      #define IP6_MH_BAS_NOT_HOME_SUBNET   132  /* Not Home\
    \ subnet */\n      #define IP6_MH_BAS_NOT_HA            133  /* Not HA for this\n\
    \                                                   mobile node */\n      #define\
    \ IP6_MH_BAS_DAD_FAILED        134  /* DAD failed */\n      #define IP6_MH_BAS_SEQNO_BAD\
    \         135  /* Sequence number out\n                                      \
    \             of range */\n      #define IP6_MH_BAS_HOME_NI_EXPIRED   136  /*\
    \ Expired Home nonce\n                                                   index\
    \ */\n      #define IP6_MH_BAS_COA_NI_EXPIRED    137  /* Expired Care-of\n   \
    \                                                nonce index */\n      #define\
    \ IP6_MH_BAS_NI_EXPIRED        138  /* Expired Nonce\n                       \
    \                            Indices */\n      #define IP6_MH_BAS_REG_NOT_ALLOWED\
    \   139  /* Registration type\n                                              \
    \     change disallowed */\n   Status values for the Binding Error mobility messages:\n\
    \   <netinet/ip6mh.h>\n      #define IP6_MH_BES_UNKNOWN_HAO    1 /* Unknown binding\
    \ for HOA */\n      #define IP6_MH_BES_UNKNOWN_MH     2 /* Unknown MH Type */\n"
- title: 4.3.  IPv6 Home Address Destination Option
  contents:
  - "4.3.  IPv6 Home Address Destination Option\n      Due to alignment issues in\
    \ the compiler, and the alignment\n      requirements for this option, the included\
    \ IPv6 address must be\n      specified as an array of 16 octets.\n      <netinet/ip6.h>\n\
    \      /* Home Address Destination Option */\n      struct ip6_opt_home_address\
    \ {\n           uint8_t           ip6oha_type;\n           uint8_t           ip6oha_len;\n\
    \           uint8_t           ip6oha_addr[16];   /* Home Address */\n      };\n\
    \   Option Type Definition:\n   #define IP6OPT_HOME_ADDRESS        0xc9    /*\
    \ 11 0 01001 */\n"
- title: 4.4.  Type 2 Routing Header
  contents:
  - "4.4.  Type 2 Routing Header\n      <netinet/ip6.h>\n      /* Type 2 Routing header\
    \ for Mobile IPv6 */\n      struct ip6_rthdr2 {\n           uint8_t  ip6r2_nxt;\
    \       /* next header */\n           uint8_t  ip6r2_len;       /* length : always\
    \ 2 */\n           uint8_t  ip6r2_type;      /* always 2 */\n           uint8_t\
    \  ip6r2_segleft;   /* segments left: always 1 */\n           uint32_t ip6r2_reserved;\
    \  /* reserved field */\n           struct in6_addr ip6r2_homeaddr;  /* Home Address\
    \ */\n      };\n"
- title: 4.5.  New ICMP Messages for Mobile IPv6
  contents:
  - "4.5.  New ICMP Messages for Mobile IPv6\n   ICMP message types and definitions\
    \ for Mobile IPv6 are defined in\n   <netinet/icmp6.h>.\n      #define MIP6_HA_DISCOVERY_REQUEST\
    \    144\n      #define MIP6_HA_DISCOVERY_REPLY      145\n      #define MIP6_PREFIX_SOLICIT\
    \          146\n      #define MIP6_PREFIX_ADVERT           147\n   The following\
    \ data structures can be used for the ICMP message types\n   discussed in Sections\
    \ 6.5 through 6.8 in the base Mobile IPv6 [2]\n   specification.\n      struct\
    \ mip6_dhaad_req {    /* Dynamic HA Address Discovery */\n             struct\
    \  icmp6_hdr   mip6_dhreq_hdr;\n      };\n      #define  mip6_dhreq_type     \
    \ mip6_dhreq_hdr.icmp6_type\n      #define  mip6_dhreq_code      mip6_dhreq_hdr.icmp6_code\n\
    \      #define  mip6_dhreq_cksum     mip6_dhreq_hdr.icmp6_cksum\n      #define\
    \  mip6_dhreq_id        mip6_dhreq_hdr.icmp6_data16[0]\n      #define  mip6_dhreq_reserved\
    \  mip6_dhreq_hdr.icmp6_data16[1]\n      struct mip6_dhaad_rep {    /* HA Address\
    \ Discovery Reply */\n             struct icmp6_hdr   mip6_dhrep_hdr;\n      \
    \       /* Followed by Home Agent IPv6 addresses */\n      };\n      #define \
    \ mip6_dhrep_type      mip6_dhrep_hdr.icmp6_type\n      #define  mip6_dhrep_code\
    \      mip6_dhrep_hdr.icmp6_code\n      #define  mip6_dhrep_cksum     mip6_dhrep_hdr.icmp6_cksum\n\
    \      #define  mip6_dhrep_id        mip6_dhrep_hdr.icmp6_data16[0]\n      #define\
    \  mip6_dhrep_reserved  mip6_dhrep_hdr.icmp6_data16[1]\n      struct mip6_prefix_solicit\
    \ {   /* Mobile Prefix Solicitation */\n             struct icmp6_hdr     mip6_ps_hdr;\n\
    \      };\n      #define  mip6_ps_type          mip6_ps_hdr.icmp6_type\n     \
    \ #define  mip6_ps_code          mip6_ps_hdr.icmp6_code\n      #define  mip6_ps_cksum\
    \         mip6_ps_hdr.icmp6_cksum\n      #define  mip6_ps_id            mip6_ps_hdr.icmp6_data16[0]\n\
    \      #define  mip6_ps_reserved      mip6_ps_hdr.icmp6_data16[1]\n      struct\
    \ mip6_prefix_advert {  /* Mobile Prefix Advertisements */\n             struct\
    \  icmp6_hdr   mip6_pa_hdr;\n              /* Followed by one or more PI options\
    \ */\n      };\n      #define  mip6_pa_type            mip6_pa_hdr.icmp6_type\n\
    \      #define  mip6_pa_code            mip6_pa_hdr.icmp6_code\n      #define\
    \  mip6_pa_cksum           mip6_pa_hdr.icmp6_cksum\n      #define  mip6_pa_id\
    \              mip6_pa_hdr.icmp6_data16[0]\n      #define  mip6_pa_flags_reserved\
    \  mip6_pa_hdr.icmp6_data16[1]\n      /* Mobile Prefix Advertisement Flags in\
    \ network-byte order */\n       #define  MIP6_PA_FLAG_MANAGED    0x8000\n    \
    \   #define  MIP6_PA_FLAG_OTHER      0x4000\n   Prefix options are defined in\
    \ IPv6 Advanced Socket API [1].  The\n   Mobile IPv6 Base specification [2] describes\
    \ the modified behavior in\n   the 'Modifications to IPv6 Neighbor Discovery'\
    \ section.  Prefix\n   Options for Mobile IP are defined in the following section.\n"
- title: 4.6.  IPv6 Neighbor Discovery Changes
  contents:
  - "4.6.  IPv6 Neighbor Discovery Changes\n   IPv6 Neighbor Discovery changes are\
    \ also defined in\n   <netinet/icmp6.h>.\n      New 'Home Agent' flag in router\
    \ advertisement:  #define\n      ND_RA_FLAG_HOMEAGENT   0x20  /* Home Agent flag\
    \ in RA */\n      New Router flag with prefix information of the home agent:\n\
    \      #define  ND_OPT_PI_FLAG_ROUTER  0x20  /* Router flag in PI */\n   As per\
    \ the Mobile IPv6 specification [2], Section 7.2, a Home Agent\n   MUST include\
    \ at least one prefix option with the Router Address (R)\n   bit set.  Advanced\
    \ Socket API [1] defines data structure for prefix\n   option as follows:\n  \
    \    struct nd_opt_prefix_info {    /* prefix information */\n           uint8_t\
    \   nd_opt_pi_type;\n           uint8_t   nd_opt_pi_len;\n           uint8_t \
    \  nd_opt_pi_prefix_len;\n           uint8_t   nd_opt_pi_flags_reserved;\n   \
    \        uint32_t  nd_opt_pi_valid_time;\n           uint32_t  nd_opt_pi_preferred_time;\n\
    \           uint32_t  nd_opt_pi_reserved2;\n           struct in6_addr  nd_opt_pi_prefix;\n\
    \      };\n   New advertisement interval option and home agent information options\n\
    \   are defined in Mobile IPv6 [2] base specification.\n      struct nd_opt_adv_interval\
    \ { /* Advertisement interval option */\n           uint8_t        nd_opt_ai_type;\n\
    \           uint8_t        nd_opt_ai_len;\n           uint16_t       nd_opt_ai_reserved;\n\
    \           uint32_t       nd_opt_ai_interval;\n      };\n   The option types\
    \ for the new Mobile IPv6 specific options:\n      #define  ND_OPT_ADV_INTERVAL\
    \    7     /* Adv Interval Option  */\n      #define  ND_OPT_HA_INFORMATION  8\
    \     /* HA Information option */\n      struct nd_opt_homeagent_info {  /* Home\
    \ Agent information */\n         uint8_t        nd_opt_hai_type;\n         uint8_t\
    \        nd_opt_hai_len;\n         uint16_t       nd_opt_hai_reserved;\n     \
    \    uint16_t       nd_opt_hai_preference;\n         uint16_t       nd_opt_hai_lifetime;\n\
    \      };\n"
- title: 5.  Access to Home Address Destination Option and Routing Headers
  contents:
  - "5.  Access to Home Address Destination Option and Routing Headers\n   Applications\
    \ that need to be able to access Home Address destination\n   option and Type\
    \ 2 Routing Header information can do so by setting the\n   appropriate setsockopt\
    \ option and using ancillary data objects.  The\n   order of extension headers\
    \ is defined in Mobile IPv6 [2] when an IPv6\n   packet with a Home Address Destination\
    \ Option is sent with other\n   possible extension headers.  Section 5.3 elaborates\
    \ on the extension\n   header order when all possible cases are present.\n   This\
    \ document does not recommend that the user-level program set the\n   Home Address\
    \ destination option or Type 2 Routing Header option;\n   however, for clarity\
    \ it defines the order of extension headers.  See\n   Section 2 of this document\
    \ for appropriate usage of sending and\n   receiving of Home Address destination\
    \ options and Type 2 Routing\n   Header extension headers.\n   This document defines\
    \ a new socket option, IPV6_MIPDSTOPTS for\n   sending Home Address destination\
    \ options.  In order to receive a Home\n   Address destination option or Type\
    \ 2 Route Header, applications must\n   call setsockopt() to turn on the corresponding\
    \ flag as described in\n   IPv6 Advanced Socket API [1] ( for brevity, error checking\
    \ is not\n   performed in the examples):\n      int  on = 1;\n      setsockopt(fd,\
    \ IPPROTO_IPV6, IPV6_RECVRTHDR,    &on, sizeof(on));\n      setsockopt(fd, IPPROTO_IPV6,\
    \ IPV6_RECVDSTOPTS,\n                   &on, sizeof(on));\n   When any of these\
    \ options are enabled, the corresponding data is\n   returned as control information\
    \ by recvmsg(), as one or more\n   ancillary data objects.  Receiving the above\
    \ information for TCP\n   applications is not defined in this document (see Section\
    \ 4.1 of\n   Advanced Sockets API for IPv6 [1]).\n   Note that if the IP implementation\
    \ on the host does not implement the\n   handling of Type 2 Routing Headers or\
    \ Home Address options, per RFC\n   2460 [3] the IP stack is required to drop\
    \ the packet.  Thus,\n   receiving Home Address destination option and Type 2\
    \ Routing Header\n   at the application layer requires implementation of respective\n\
    \   extension headers at the IP layer in the kernel, as defined in\n   RFC3775\
    \ [2].\n   For receiving the Home Address destination option header, the Mobile\n\
    \   IPv6 implementation SHOULD follow the initial processing rules of the\n  \
    \ Home Address destination option (Section 9.3.1 of Mobile IPv6 [2])\n   before\
    \ passing the information to the API level.  This includes\n   initial processing\
    \ of IPSec authentication data in a packet when it\n   exists.  Each Destination\
    \ options header is returned as one ancillary\n   data object described by a cmsghdr\
    \ structure with cmsg_level set to\n   IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.\n\
    \   For sending the Home Address destination option, ancillary data can\n   be\
    \ used to specify the option content for a single datagram.  This\n   applies\
    \ only to datagram and raw sockets, not to TCP sockets.  The\n   Advanced API\
    \ [1] document restricts one IPV6_xxx ancillary data\n   object for a particular\
    \ extension header in the control buffer.\n   Thus, there would be a single ancillary\
    \ data object for the Home\n   address destination option in an ancillary data\
    \ buffer.  If multiple\n   destination options are present, then the header order\
    \ should be in\n   compliance with Section 6.3 and 9.3.2 of the Mobile IPv6 [2]\
    \ base\n   specification.\n   For TCP data packets with the Home Address destination\
    \ option, the\n   \"sticky\" option may be used for all transmitted packets. \
    \ The\n   application can remove the sticky Home Destination option header by\n\
    \   calling setsockopt() for IPV6_MIPDSTOPTS with a zero option length.\n   Note\
    \ that Section 2 of this document does not encourage setting the\n   Home Address\
    \ destination option at the user level.  A Mobile IPv6\n   implementation should\
    \ set and process the Home Address destination\n   option and Routing Header Type\
    \ 2 at the kernel level.  The setting of\n   Routing Header Type 2 and the Home\
    \ Address destination option are\n   described in this document for completeness\
    \ and flexibility to use\n   them in the future, if there is a need.\n   The following\
    \ socket option parameters and cmsghdr fields may be used\n   for sending (although\
    \ not a recommended usage):\n      opt level/    optname/          optval/\n \
    \     cmsg_level    cmsg_type         cmsg_data[]\n      ------------  ------------\
    \      ------------------------\n      IPPROTO_IPV6  IPV6_MIPDSTOPTS      ip6_dest\
    \ structure\n      IPPROTO_IPV6  IPV6_RTHDR           ip6_rthdr structure\n  \
    \ Some IPv6 implementations may support \"sticky\" options [1] for the\n   IPv6\
    \ destination option for datagram and RAW sockets.\n   Behavior of Legacy IPv6\
    \ Socket Applications:\n   Legacy IPv6 applications/implementations using the\
    \ Advanced Socket\n   API [1] mechanisms, upon receiving Home Address destination\
    \ options\n   or Routing headers(Type 2), will discard the packet as per Sections\n\
    \   4.2 and 4.4 of IPV6 Protocol [3] specification, respectively;\n   otherwise,\
    \ they should properly handle the Home Address destination\n   option and the\
    \ Routing Header Type 2 specified in this document.\n"
- title: 5.1.  Routing Header Access Functions
  contents:
  - "5.1.  Routing Header Access Functions\n   IPV6 Protocol [3] defines a Routing\
    \ header extension header for Type\n   0.  Thus, in order to access the IPv6 Routing\
    \ header Type 2 extension\n   header, one MUST use type = 2 and segment = 1. \
    \ The following\n   existing functions defined in Advanced API for IPv6 Sockets\
    \ [1] are\n   supported for Mobile IPv6 applications for sending and receiving\n\
    \   Routing Header Type 2 headers:\n   For Sending:\n     size_t inet6_rth_space(int\
    \ type, int segments);\n     void *inet6_rth_init(void *bp, int bp_len, int type,\
    \ int segments);\n     int inet6_rth_add(void *bp, const struct in6_addr *addr);\n\
    \   For Receiving:\n      int inet6_rth_segments(const void *bp);\n      struct\
    \ in6_addr *inet6_rth_getaddr(const void *bp, int index);\n   NOTE: Reversing\
    \ operation is not possible using the Route Header Type\n   2 extension header.\
    \  Thus, inet6_rth_reverse() is not used.\n   Detailed descriptions and examples\
    \ of accessing an IPv6 Routing\n   Header are discussed in the Advanced Sockets\
    \ API for IPv6 [1].\n   However, Section 7 of Advanced API for IPv6 Sockets [1]\
    \ indicates\n   that multiple types of routing headers can be received as multiple\n\
    \   ancillary data objects to the application (with cmsg_type set to\n   IPV6_RTHDR).\
    \  Currently, there are no API functions defined to return\n   the routing header\
    \ type.  However, this document does not define a\n   helper function, since it\
    \ is easy to access the Routing Header Type\n   field just as easily as the ip6r_segleft\
    \ field.  An excerpt of a code\n   sample is provided for extracting the type\
    \ of the received routing\n   header:\n      if (msg.msg_controllen != 0 &&\n\
    \          cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n          cmsgptr->cmsg_type\
    \ == IPV6_RTHDR) {\n              struct in6_addr *in6;\n              char asciiname[INET6_ADDRSTRLEN];\n\
    \              struct ip6_rthdr *rthdr;\n              int    segments, route_type;\n\
    \              rthdr = (struct ip6_rthdr *)extptr;\n              segments = inet6_rth_segments(extptr);\n\
    \              printf(\"route (%d segments, %d left): \",\n                  segments,\
    \ rthdr->ip6r_segleft);\n              route_type = rthdr->ip6r_type;\n      \
    \        if (route_type == 2) {\n                      printf (\"Routing header\
    \ Type 2 present\\n\");\n              }\n      }\n"
- title: 5.2.  Content of Type 2 Routing Header
  contents:
  - "5.2.  Content of Type 2 Routing Header\n   It is recommended that no portable\
    \ applications send Type 2 Routing\n   Header ancillary data from the application\
    \ layer, since many\n   implementations take care of that at the kernel layer\
    \ and may not\n   support the API for sending Type 2 Routing Header.\n   Mobile\
    \ IPv6 [2] defines the Type 2 Routing Header to allow the packet\n   to be routed\
    \ directly from a correspondent to the mobile node's\n   care-of address.  The\
    \ mobile node's care-of address is inserted into\n   the IPv6 Destination Address\
    \ field.  Once the packet arrives at the\n   care-of address, the mobile node\
    \ retrieves its home address from the\n   routing header, and this is used as\
    \ the final destination address for\n   the received IPv6 packet.\n   For user-level\
    \ applications that receive Type 2 Routing Header,\n   inet6_rth_getaddr() returns\
    \ the care-of address or on-the-wire\n   destination address of the received packet.\
    \  This complies with the\n   existing Routing header Type=0 processing for IPv6\
    \ [1].\n   Thus, on the receive side, the socket application will always receive\n\
    \   data packets at its original home address.  The implementations are\n   responsible\
    \ for processing the Type 2 Routing Header packet as per\n   Mobile IPv6 RFC [2]\
    \ before passing the Type 2 Routing Header\n   information to the Socket API.\n\
    \   If a pure IPv6 [3] system receives the Routing Header Type 2 packets,\n  \
    \ it will follow the process described in Section 4.4 of the IPv6 [3]\n   base\
    \ specification.\n"
- title: 5.3.  Order of Extension Headers for Home Address Destination Options
  contents:
  - "5.3.  Order of Extension Headers for Home Address Destination Options\n   Section\
    \ 6.3 of Mobile IPV6 [2] defines the extension header order for\n   the Home address\
    \ destination option.\n      Routing Header\n      Home Address Destination Option\n\
    \      Fragment Header\n      AH/ESP Header\n   IPv6 [3] specifies that the destination\
    \ header can be either before\n   the Routing header or after the AH/ESP header\
    \ if they are all\n   present.\n   Thus, when the Home Address destination option\
    \ is present along with\n   other extension headers, the order will be:\n    \
    \  Hop-by-Hop Options header\n      Destination Options header\n      Routing\
    \ header\n      Destination Options [Home Address Option]\n      Fragment header\n\
    \      Authentication header\n      Encapsulating Security Payload header\n  \
    \    Destination Options header\n      upper-layer header\n   Any user-level implementation\
    \ or application that sends the Home\n   address destination option through ancillary\
    \ data objects should\n   follow the order extension header defined in this document\
    \ when using\n   IPV6_MIPDSTOPTS socket options.\n"
- title: 5.4.  Home Address Destination Option Access Functions
  contents:
  - "5.4.  Home Address Destination Option Access Functions\n   The application must\
    \ enable the IPV6_RECVDSTOPTS socket option in\n   order to receive the Home Address\
    \ destination option (error checking\n   is not performed in the example for brevity):\n\
    \      int  on = 1;\n      setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on,\
    \ sizeof(on));\n   Each Destination option header is returned as one ancillary\
    \ data\n   object described by a cmsghdr structure, with cmsg_level set to\n \
    \  IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.\n   The received side Home\
    \ Address destination option is further\n   processed by calling the inet6_opt_next(),\
    \ inet6_opt_find(), and\n   inet6_opt_get_value() functions as defined in Advanced\
    \ API for IPv6\n   sockets [1].\n   This document assumes that portable Mobile\
    \ IPv6 applications will not\n   send a Home Address Destination Option from the\
    \ application level, as\n   the Mobile IPv6 implementation underneath takes care\
    \ of sending the\n   Home Address option and the routing header type 2 at the\
    \ kernel.\n   However, some embedded software implementations may implement the\n\
    \   IPv6 packet processing/sending at the user-level; those\n   implementations\
    \ may choose to provide the API support for sending a\n   home-address option\
    \ at the application layer.  In this case, the Home\n   Address destination options\
    \ are normally constructed by using the\n   inet6_opt_init(), inet6_opt_append(),\
    \ inet6_opt_finish(), and\n   inet6_opt_set_val() functions, described in Section\
    \ 10 of the\n   Advanced sockets API for IPv6 [1].\n"
- title: 5.5.  Content of Home Address Destination Option
  contents:
  - "5.5.  Content of Home Address Destination Option\n   The received ancillary data\
    \ object for the Home Address destination\n   option SHOULD contain the care-of\
    \ address of the mobile node.  It is\n   assumed that the initial processing of\
    \ the Home Address destination\n   option will verify the validity of the home\
    \ address, as described in\n   Sections 6.3 and 9.5 of the Mobile IPv6 Specification\
    \ [2], and swap\n   the source address of the packet (COA) with the contents of\
    \ Home\n   Address destination option.\n   Note that whether or not these new\
    \ APIs are used, the sender's home\n   address is contained in the source address\
    \ (which is passed to the\n   application using the socket-level functions recvfrom(),\
    \ recvmsg(),\n   accept(), and getpeername()).  This is necessary for:\n     \
    \ maintaining consistency between simple user-level applications\n      running\
    \ between mobile nodes and the diagnostic applications on\n      the home agent\
    \ or correspondent node that use this API;\n      obtaining the COA address of\
    \ the mobile node when the Home Address\n      destination option is used; and\n\
    \      maintaining consistency of existing IPv6 Socket APIs and\n      processing\
    \ of the Home Address destination option.\n   If an implementation supports send-side\
    \ Home Address destination API,\n   then it must follow the same rule for data\
    \ content as specified in\n   Mobile IPv6 RFC [2] for sending a home-address option.\
    \  Thus, the\n   home-address option will contain the home address, and the\n\
    \   implementation will use the care-of address as the source address of\n   the\
    \ outgoing packet.  If the implementation uses IPSec, then it\n   should use the\
    \ content of Home Address destination option as the\n   source address of the\
    \ packet for security association.  Note that\n   regular user applications must\
    \ not set the home address destination\n   option.\n"
- title: 6.  Mobility Protocol Headers
  contents:
  - "6.  Mobility Protocol Headers\n   Mobile IPv6 [2] defines a new IPv6 protocol\
    \ header to carry mobility\n   messages between Mobile Nodes, Home Agents and\
    \ Correspondent Nodes.\n   These protocol headers carry Mobile IPv6 Binding messages\
    \ as well as\n   Return Routability [2] messages.  Currently the specification\
    \ [2]\n   does not allow transport packets (piggybacking) along with the\n   mobility\
    \ messages.  Thus the mobility protocol header can be accessed\n   through an\
    \ IPv6 RAW socket.  An IPv6 RAW socket that is opened for\n   protocol IPPROTO_MH\
    \ should always be able to see all the MH (Mobility\n   Header) packets.  It is\
    \ possible that future applications may\n   implement part of Mobile IPv6 signal\
    \ processing at the application\n   level.  Having a RAW socket interface may\
    \ also enable an application\n   to execute the Return Routability protocol or\
    \ other future\n   authentication protocol involving the mobility header at the\
    \ user-\n   level.\n"
- title: 6.1.  Receiving and Sending Mobility Header Messages
  contents:
  - "6.1.  Receiving and Sending Mobility Header Messages\n   This specification recommends\
    \ that the IPv6 RAW sockets mechanism\n   send and receive Mobility Header (MH)\
    \ packets.  The behavior is\n   similar to ICMPV6 processing, where the kernel\
    \ passes a copy of the\n   mobility header packet to the receiving socket.  Depending\
    \ on the\n   implementation, the kernel may process the mobility header in\n \
    \  addition to passing the mobility header to the application.  In order\n   to\
    \ comply with the restriction in the Advanced Sockets API for IPv6\n   [1], applications\
    \ should set the IPV6_CHECKSUM socket option with\n   IPPROTO_MH protocol RAW\
    \ Sockets.  A Mobile IPv6 implementation that\n   supports the Mobile IPv6 API\
    \ must implement Mobility Header API\n   checksum calculations by default at the\
    \ kernel for both incoming and\n   outbound paths.  A Mobile IPv6 implementation\
    \ must not return error\n   on the IPV6_CHECKSUM socket option setting, even if\
    \ the socket option\n   is a NO-OP function for that implementation because it\
    \ verifies the\n   checksum at the kernel level.  The Mobility Header checksum\
    \ procedure\n   is described in the Mobile IPv6 Protocol [2] specification.  Again,\n\
    \   for application portability it is recommended that the applications\n   set\
    \ the IPV6_CHECKSUM socket option along with the RAW sockets for\n   IPPROTO_MH\
    \ protocol.\n   As an example, a program that wants to send or receive a mobility\n\
    \   header protocol(MH) could open a socket as follows (for brevity, the\n   error\
    \ checking is not performed in the example below):\n      fd = socket(AF_INET6,\
    \ SOCK_RAW, IPPROTO_MH);\n      int offset = 4;\n      setsockopt(fd, IPPROTO_IPV6,\
    \ IPV6_CHECKSUM, &offset,\n           sizeof(offset));\n   For example, if an\
    \ implementation likes to handle HOTI/HOT and COTI/\n   COT message processing,\
    \ it can do so by using IPv6 RAW Sockets for\n   IPPROTO_MH at the application\
    \ layer.  The same application may also\n   set the IPV6_RECVDSTOPTS socket option\
    \ for receiving Home Address\n   destination option in a binding update [2] from\
    \ the mobile node.\n   IPv6 RAW sockets are described in Section 3 of the IPv6\
    \ Advanced\n   Socket API [1] specification.  All data sent and received via raw\n\
    \   sockets must be in network byte order.  The data structures that are\n   defined\
    \ in this document are in network byte order, and they are\n   believed to be\
    \ supported by most compilers to hold packet formats\n   directly for transmission\
    \ on the wire.\n   The usual send/recv functions for datagram should be used for\
    \ the\n   Mobile IPv6 RAW sockets in order to send and receive data,\n   respectively.\n"
- title: 7.  Protocols File
  contents:
  - "7.  Protocols File\n   Many hosts provide the file /etc/protocols, which contains\
    \ the names\n   of the various IP protocols and their protocol numbers.  The protocol\n\
    \   numbers are obtained through function getprotoXXX() functions.\n   The following\
    \ addition should be made to the /etc/protocols file, in\n   addition to what\
    \ is defined in Section 2.4 of the Advanced Sockets\n   API for IPv6 [1].\n  \
    \ The protocol number for Mobility Header:\n   (http://www.iana.org/assignments/protocol-numbers)\n\
    \      ipv6-mh           135      # Mobility Protocol Header\n"
- title: 8.  IPv4-Mapped IPv6 Addresses
  contents:
  - "8.  IPv4-Mapped IPv6 Addresses\n   The various socket options and ancillary data\
    \ specifications defined\n   in this document apply only to true IPv6 sockets.\
    \  It is possible to\n   create an IPv6 socket that actually sends and receives\
    \ IPv4 packets,\n   using IPv4-mapped IPv6 addresses, but the mapping of the options\n\
    \   defined in this document to an IPv4 datagram is beyond the scope of\n   this\
    \ document.  The above statement is in compliance with Section 13\n   of the IPv6\
    \ Socket API [1].\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The setting of the Home Address Destination option\
    \ and Route Header\n   Type 2 IPV6_RTHDR socket option may not be allowed at the\
    \ application\n   level in order to prevent denial-of-service attacks or man-in-the-\n\
    \   middle attacks by hackers.  Sending and receiving of mobility header\n   messages\
    \ are possible by IPv6 RAW sockets.  Thus, it is assumed that\n   this operation\
    \ is only possible by privileged users.  However, this\n   API does not prevent\
    \ the existing security threat from a hacker\n   sending a bogus mobility header\
    \ or other IPv6 packets using the Home\n   Address option and Type 2 Routing Header\
    \ extensions.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document does not define a new protocol.  However,\
    \ it uses the\n   Mobility Header Protocol for IPv6 to define an API for the\n\
    \   /etc/protocols file. (ref: http://www.iana.org/assignments/protocol-\n   numbers)\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   Thanks to Brian Haley for the thorough review of this\
    \ document and\n   many helpful comments.  Keiichi Shima, Alexandru Petrescu,\
    \ Ryuji\n   Wakikawa, Vijay Devarapalli, Jim Bound, Suvidh Mathur, Karen Nielsen,\n\
    \   Mark Borst, Vladislav Yasevich, and other mobile-ip working group\n   members\
    \ provided valuable input.  Antti Tuominen suggested the\n   routing header type\
    \ function for this API document.  During IESG\n   review, Bill Fenner suggested\
    \ accessing the routing header type\n   directly for being consistent with RFC3542.\
    \  A new socket option for\n   Home Address Destination Option is added per Bill\
    \ Fenner's suggestion\n   for clarity of extension header orders.  Thanks to Thomas\
    \ Narten and\n   Jari Arkko for the review of this document.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [1]  Stevens, W., Thomas, M., Nordmark, E., and\
    \ T. Jinmei, \"Advanced\n        Sockets Application Program Interface (API) for\
    \ IPv6\", RFC 3542,\n        May 2003.\n   [2]  Johnson, D., Perkins, C., and\
    \ J. Arkko, \"Mobility Support in\n        IPv6\", RFC 3775, June 2004.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [3]  Deering, S. and R. Hinden, \"Internet\
    \ Protocol, Version 6 (IPv6)\n        Specification\", RFC 2460, December 1998.\n\
    \   [4]  Devarapalli, V., Wakikawa, R., Petrescu, A., and P. Thubert,\n      \
    \  \"Network Mobility (NEMO) Basic Support Protocol\", RFC 3963,\n        January\
    \ 2005.\n   [5]  Nordmark, E., \"IPv6 Socket API for source address selection\"\
    ,\n        Work in Progress, July 2005.\n   [6]  Gilligan, R., Thomson, S., Bound,\
    \ J., McCann, J., and W.\n        Stevens, \"Basic Socket Interface Extensions\
    \ for IPv6\", RFC 3493,\n        February 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Samita Chakrabarti\n   EMail: samitac2@gmail.com\n   Erik\
    \ Nordmark\n   Sun Microsystems\n   17 Network Circle\n   Menlo Park, CA 94025\n\
    \   USA\n   Phone: +1 650 786 2921\n   EMail: erik.nordmark@sun.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
