- title: __initial_text__
  contents:
  - "            DOMAIN NAMES - IMPLEMENTATION and SPECIFICATION\n        | This memo\
    \ discusses the implementation of domain    |\n        | name servers and resolvers,\
    \ specifies the format of |\n        | transactions, and discusses the use of\
    \ domain names |\n        | in the context of existing mail systems and other\
    \   |\n        | network software.                                   |\n     \
    \   | This memo assumes that the reader is familiar with  |\n        | RFC 882,\
    \ \"Domain Names - Concepts and Facilities\"   |\n        | which discusses the\
    \ basic principles of domain      |\n        | names and their use.          \
    \                      |\n        | The algorithms and internal data structures\
    \ used in |\n        | this memo are offered as suggestions rather than    |\n\
    \        | requirements; implementers are free to design their |\n        | own\
    \ structures so long as the same external         |\n        | behavior is achieved.\
    \                               |\n           | This RFC contains format specifications\
    \ which |\n           | are preliminary and are included for purposes |\n    \
    \       | of explanation only.  Do not attempt to use   |\n           | this information\
    \ for actual implementations.  |\n                         Domain Names - Implementation\
    \ and Specification\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   INTRODUCTION........................................................3\n\
    \      Overview.........................................................3\n  \
    \    Implementation components........................................2\n    \
    \  Conventions......................................................6\n      Design\
    \ philosophy................................................8\n   NAME SERVER\
    \ TRANSACTIONS...........................................11\n      Introduction....................................................11\n\
    \      Query and response transport....................................11\n  \
    \    Overall message format..........................................13\n    \
    \  The contents of standard queries and responses..................15\n      Standard\
    \ query and response example.............................15\n      The contents\
    \ of inverse queries and responses...................17\n      Inverse query and\
    \ response example..............................18\n      Completion queries and\
    \ responses................................19\n      Completion query and response\
    \ example...........................22\n      Recursive Name Service..........................................24\n\
    \      Header section format...........................................26\n  \
    \    Question section format.........................................29\n    \
    \  Resource record format..........................................30\n      Domain\
    \ name representation and compression......................31\n      Organization\
    \ of the Shared database.............................33\n      Query processing................................................36\n\
    \      Inverse query processing........................................37\n  \
    \    Completion query processing.....................................38\n   NAME\
    \ SERVER MAINTENANCE............................................39\n      Introduction....................................................39\n\
    \      Conceptual model of maintenance operations......................39\n  \
    \    Name server data structures and top level logic.................41\n    \
    \  Name server file loading........................................43\n      Name\
    \ server file loading example................................45\n      Name server\
    \ remote zone transfer................................47\n   RESOLVER ALGORITHMS................................................50\n\
    \      Operations......................................................50\n  \
    \ DOMAIN SUPPORT FOR MAIL............................................52\n    \
    \  Introduction....................................................52\n      Agent\
    \ binding...................................................53\n      Mailbox\
    \ binding.................................................54\n   Appendix 1 -\
    \ Domain Name Syntax Specification......................56\n   Appendix 2 - Field\
    \ formats and encodings...........................57\n      TYPE values.....................................................57\n\
    \      QTYPE values....................................................57\n  \
    \    CLASS values....................................................58\n    \
    \  QCLASS values...................................................58\n      Standard\
    \ resource record formats................................59\n   Appendix 3 - Internet\
    \ specific field formats and operations........67\n   REFERENCES and BIBLIOGRAPHY........................................72\n\
    \   INDEX..............................................................73\n  \
    \                       Domain Names - Implementation and Specification\n"
- title: INTRODUCTION
  contents:
  - "INTRODUCTION\n   Overview\n      The goal of domain names is to provide a mechanism\
    \ for naming\n      resources in such a way that the names are usable in different\n\
    \      hosts, networks, protocol families, internets, and administrative\n   \
    \   organizations.\n      From the user's point of view, domain names are useful\
    \ as\n      arguments to a local agent, called a resolver, which retrieves\n \
    \     information associated with the domain name.  Thus a user might\n      ask\
    \ for the host address or mail information associated with a\n      particular\
    \ domain name.  To enable the user to request a\n      particular type of information,\
    \ an appropriate query type is\n      passed to the resolver with the domain name.\
    \  To the user, the\n      domain tree is a single information space.\n      From\
    \ the resolver's point of view, the database that makes up the\n      domain space\
    \ is distributed among various name servers.  Different\n      parts of the domain\
    \ space are stored in different name servers,\n      although a particular data\
    \ item will usually be stored redundantly\n      in two or more name servers.\
    \  The resolver starts with knowledge\n      of at least one name server.  When\
    \ the resolver processes a user\n      query it asks a known name server for the\
    \ information; in return,\n      the resolver either receives the desired information\
    \ or a referral\n      to another name server.  Using these referrals, resolvers\
    \ learn\n      the identities and contents of other name servers.  Resolvers are\n\
    \      responsible for dealing with the distribution of the domain space\n   \
    \   and dealing with the effects of name server failure by consulting\n      redundant\
    \ databases in other servers.\n      Name servers manage two kinds of data.  The\
    \ first kind of data\n      held in sets called zones; each zone is the complete\
    \ database for\n      a particular subtree of the domain space.  This data is\
    \ called\n      authoritative.  A name server periodically checks to make sure\n\
    \      that its zones are up to date, and if not obtains a new copy of\n     \
    \ updated zones from master files stored locally or in another name\n      server.\
    \  The second kind of data is cached data which was acquired\n      by a local\
    \ resolver.  This data may be incomplete but improves the\n      performance of\
    \ the retrieval process when non-local data is\n      repeatedly accessed.  Cached\
    \ data is eventually discarded by a\n      timeout mechanism.\n      This functional\
    \ structure isolates the problems of user interface,\n      failure recovery,\
    \ and distribution in the resolvers and isolates\n      the database update and\
    \ refresh problems in the name servers.\n                         Domain Names\
    \ - Implementation and Specification\n   Implementation components\n      A host\
    \ can participate in the domain name system in a number of\n      ways, depending\
    \ on whether the host runs programs that retrieve\n      information from the\
    \ domain system, name servers that answer\n      queries from other hosts, or\
    \ various combinations of both\n      functions.  The simplest, and perhaps most\
    \ typical, configuration\n      is shown below:\n                   Local Host\
    \                        |  Foreign   \n                                     \
    \                |            \n      +---------+               +----------+ \
    \        |  +--------+\n      |         | user queries  |          |queries  |\
    \  |        |\n      |  User   |-------------->|          |---------|->|Foreign\
    \ |\n      | Program |               | Resolver |         |  |  Name  |\n    \
    \  |         |<--------------|          |<--------|--| Server |\n      |     \
    \    | user responses|          |responses|  |        |\n      +---------+   \
    \            +----------+         |  +--------+\n                            \
    \      |     A            |            \n                  cache additions | \
    \    | references |            \n                                  V     |   \
    \         |            \n                                +----------+        \
    \ |            \n                                | database |         |      \
    \      \n                                +----------+         |            \n\
    \      User programs interact with the domain name space through\n      resolvers;\
    \ the format of user queries and user responses is\n      specific to the host\
    \ and its operating system.  User queries will\n      typically be operating system\
    \ calls, and the resolver and its\n      database will be part of the host operating\
    \ system.  Less capable\n      hosts may choose to implement the resolver as a\
    \ subroutine to be\n      linked in with every program that needs its services.\n\
    \      Resolvers answer user queries with information they acquire via\n     \
    \ queries to foreign name servers, and may also cache or reference\n      domain\
    \ information in the local database.\n      Note that the resolver may have to\
    \ make several queries to several\n      different foreign name servers to answer\
    \ a particular user query,\n      and hence the resolution of a user query may\
    \ involve several\n      network accesses and an arbitrary amount of time.  The\
    \ queries to\n      foreign name servers and the corresponding responses have\
    \ a\n      standard format described in this memo, and may be datagrams.\n   \
    \                      Domain Names - Implementation and Specification\n     \
    \ Depending on its capabilities, a name server could be a stand\n      alone program\
    \ on a dedicated machine or a process or processes on\n      a large timeshared\
    \ host.  A simple configuration might be:\n                   Local Host     \
    \                   |  Foreign   \n                                          \
    \           |            \n        +---------+                               \
    \   |            \n       /         /|                                  |    \
    \        \n      +---------+ |             +----------+         |  +--------+\n\
    \      |         | |             |          |responses|  |        |\n      | \
    \        | |             |   Name   |---------|->|Foreign |\n      |  Master |-------------->|\
    \  Server  |         |  |Resolver|\n      |  files  | |             |        \
    \  |<--------|--|        |\n      |         |/              |          | queries\
    \ |  +--------+\n      +---------+               +----------+         |      \
    \      \n      Here the name server acquires information about one or more zones\n\
    \      by reading master files from its local file system, and answers\n     \
    \ queries about those zones that arrive from foreign resolvers.\n      A more\
    \ sophisticated name server might acquire zones from foreign\n      name servers\
    \ as well as local master files.  This configuration is\n      shown below:\n\
    \                   Local Host                        |  Foreign   \n        \
    \                                             |            \n        +---------+\
    \                                  |            \n       /         /|        \
    \                          |            \n      +---------+ |             +----------+\
    \         |  +--------+\n      |         | |             |          |responses|\
    \  |        |\n      |         | |             |   Name   |---------|->|Foreign\
    \ |\n      |  Master |-------------->|  Server  |         |  |Resolver|\n    \
    \  |  files  | |             |          |<--------|--|        |\n      |     \
    \    |/              |          | queries |  +--------+\n      +---------+   \
    \            +----------+         |            \n                            \
    \      A     |maintenance |  +--------+\n                                  | \
    \    \\------------|->|        |\n                                  |      queries\
    \     |  |Foreign |\n                                  |                  |  |\
    \  Name  |\n                                  \\------------------|--| Server\
    \ |\n                               maintenance responses |  +--------+\n    \
    \  In this configuration, the name server periodically establishes a\n      virtual\
    \ circuit to a foreign name server to acquire a copy of a\n      zone or to check\
    \ that an existing copy has not changed.  The\n      messages sent for these maintenance\
    \ activities follow the same\n      form as queries and responses, but the message\
    \ sequences are\n      somewhat different.\n                         Domain Names\
    \ - Implementation and Specification\n      The information flow in a host that\
    \ supports all aspects of the\n      domain name system is shown below:\n    \
    \               Local Host                        |  Foreign   \n            \
    \                                         |            \n      +---------+   \
    \            +----------+         |  +--------+\n      |         | user queries\
    \  |          |queries  |  |        |\n      |  User   |-------------->|     \
    \     |---------|->|Foreign |\n      | Program |               | Resolver |  \
    \       |  |  Name  |\n      |         |<--------------|          |<--------|--|\
    \ Server |\n      |         | user responses|          |responses|  |        |\n\
    \      +---------+               +----------+         |  +--------+\n        \
    \                          |     A            |            \n                \
    \  cache additions |     | references |            \n                        \
    \          V     |            |            \n                                +----------+\
    \         |            \n                                |  Shared  |        \
    \ |            \n                                | database |         |      \
    \      \n                                +----------+         |            \n\
    \                                  A     |            |            \n        +---------+\
    \     refreshes |     | references |            \n       /         /|        \
    \       |     V            |            \n      +---------+ |             +----------+\
    \         |  +--------+\n      |         | |             |          |responses|\
    \  |        |\n      |         | |             |   Name   |---------|->|Foreign\
    \ |\n      |  Master |-------------->|  Server  |         |  |Resolver|\n    \
    \  |  files  | |             |          |<--------|--|        |\n      |     \
    \    |/              |          | queries |  +--------+\n      +---------+   \
    \            +----------+         |            \n                            \
    \      A     |maintenance |  +--------+\n                                  | \
    \    \\------------|->|        |\n                                  |      queries\
    \     |  |Foreign |\n                                  |                  |  |\
    \  Name  |\n                                  \\------------------|--| Server\
    \ |\n                               maintenance responses |  +--------+\n    \
    \  The shared database holds domain space data for the local name\n      server\
    \ and resolver.  The contents of the shared database will\n      typically be\
    \ a mixture of authoritative data maintained by the\n      periodic refresh operations\
    \ of the name server and cached data\n      from previous resolver requests. \
    \ The structure of the domain data\n      and the necessity for synchronization\
    \ between name servers and\n      resolvers imply the general characteristics\
    \ of this database, but\n      the actual format is up to the local implementer.\
    \  This memo\n      suggests a multiple tree format.\n                       \
    \  Domain Names - Implementation and Specification\n      This memo divides the\
    \ implementation discussion into sections:\n         NAME SERVER TRANSACTIONS,\
    \ which discusses the formats for name\n         servers queries and the corresponding\
    \ responses.\n         NAME SERVER MAINTENANCE, which discusses strategies,\n\
    \         algorithms, and formats for maintaining the data residing in\n     \
    \    name servers.  These services periodically refresh the local\n         copies\
    \ of zones that originate in other hosts.\n         RESOLVER ALGORITHMS, which\
    \ discusses the internal structure of\n         resolvers.  This section also\
    \ discusses data base sharing\n         between a name server and a resolver on\
    \ the same host.\n         DOMAIN SUPPORT FOR MAIL, which discusses the use of\
    \ the domain\n         system to support mail transfer.\n                    \
    \     Domain Names - Implementation and Specification\n   Conventions\n      The\
    \ domain system has several conventions dealing with low-level,\n      but fundamental,\
    \ issues.  While the implementer is free to violate\n      these conventions WITHIN\
    \ HIS OWN SYSTEM, he must observe these\n      conventions in ALL behavior observed\
    \ from other hosts.\n             ********** Data Transmission Order **********\n\
    \      The order of transmission of the header and data described in this\n  \
    \    document is resolved to the octet level.  Whenever a diagram shows\n    \
    \  a group of octets, the order of transmission of those octets is\n      the\
    \ normal order in which they are read in English.  For example,\n      in the\
    \ following diagram the octets are transmitted in the order\n      they are numbered.\n\
    \                    0                   1           \n                    0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 \n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   |       1       |       2       |\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   |       3       |       4       |\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   |       5       |       6       |\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Transmission Order of Bytes\n      Whenever an octet represents\
    \ a numeric quantity the left most bit\n      in the diagram is the high order\
    \ or most significant bit.  That\n      is, the bit labeled 0 is the most significant\
    \ bit.  For example,\n      the following diagram represents the value 170 (decimal).\n\
    \                            0 1 2 3 4 5 6 7 \n                           +-+-+-+-+-+-+-+-+\n\
    \                           |1 0 1 0 1 0 1 0|\n                           +-+-+-+-+-+-+-+-+\n\
    \                          Significance of Bits\n      Similarly, whenever a multi-octet\
    \ field represents a numeric\n      quantity the left most bit of the whole field\
    \ is the most\n      significant bit.  When a multi-octet quantity is transmitted\
    \ the\n      most significant octet is transmitted first.\n                  \
    \       Domain Names - Implementation and Specification\n                  **********\
    \ Character Case **********\n      All comparisons between character strings (e.g.\
    \ labels, domain\n      names, etc.) are done in a case-insensitive manner.\n\
    \      When data enters the domain system, its original case should be\n     \
    \ preserved whenever possible.  In certain circumstances this cannot\n      be\
    \ done.  For example, if two domain names x.y and X.Y are entered\n      into\
    \ the domain database, they are interpreted as the same name,\n      and hence\
    \ may have a single representation.  The basic rule is\n      that case can be\
    \ discarded only when data is used to define\n      structure in a database, and\
    \ two names are identical when compared\n      in a case insensitive manner.\n\
    \      Loss of case sensitive data must be minimized.  Thus while data\n     \
    \ for x.y and X.Y may both be stored under x.y, data for a.x and B.X\n      can\
    \ be stored as a.x and B.x, but not A.x, A.X, b.x, or b.X.  In\n      general,\
    \ this prevents the first component of a domain name from\n      loss of case\
    \ information.\n      Systems administrators who enter data into the domain database\n\
    \      should take care to represent the data they supply to the domain\n    \
    \  system in a case-consistent manner if their system is\n      case-sensitive.\
    \  The data distribution system in the domain system\n      will ensure that consistent\
    \ representations are preserved.\n                         Domain Names - Implementation\
    \ and Specification\n   Design philosophy\n      The design presented in this\
    \ memo attempts to provide a base which\n      will be suitable for several existing\
    \ networks.  An equally\n      important goal is to provide these services within\
    \ a framework\n      that is capable of adjustment to fit the evolution of services\
    \ in\n      early clients as well as to accommodate new networks.\n      Since\
    \ it is impossible to predict the course of these\n      developments, the domain\
    \ system attempts to provide for evolution\n      in the form of an extensible\
    \ framework.  This section describes\n      the areas in which we expect to see\
    \ immediate evolution.\n      DEFINING THE DATABASE\n      This memo defines methods\
    \ for partitioning the database and data\n      for host names, host addresses,\
    \ gateway information, and mail\n      support.  Experience with this system will\
    \ provide guidance for\n      future additions.\n      While the present system\
    \ allows for many new RR types, classes,\n      etc., we feel that it is more\
    \ important to get the basic services\n      in operation than to cover an exhaustive\
    \ set of information.\n      Hence we have limited the data types to those we\
    \ felt were\n      essential, and would caution designers to avoid implementations\n\
    \      which are based on the number of existing types and classes.\n      Extensibility\
    \ in this area is very important.\n      While the domain system provides techniques\
    \ for partitioning the\n      database, policies for administrating the orderly\
    \ connection of\n      separate domains and guidelines for constructing the data\
    \ that\n      makes up a particular domain will be equally important to the\n\
    \      success of the system.   Unfortunately, we feel that experience\n     \
    \ with prototype systems will be necessary before this question can\n      be\
    \ properly addressed.  Thus while this memo has minimal\n      discussion of these\
    \ issues, it is a critical area for development.\n      TYING TOGETHER INTERNETS\n\
    \      Although it is very difficult to characterize the types of\n      networks,\
    \ protocols, and applications that will be clients of the\n      domain system,\
    \ it is very obvious that some of these applications\n      will cross the boundaries\
    \ of network and protocol.  At the very\n      least, mail is such a service.\n\
    \      Attempts to unify two such systems must deal with two major\n      problems:\n\
    \      1. Differing formats for environment sensitive data.  For example,\n  \
    \                       Domain Names - Implementation and Specification\n    \
    \     network addresses vary in format, and it is unreasonable to\n         expect\
    \ to enforce consistent conventions.\n      2. Connectivity may require intermediaries.\
    \  For example, it is a\n         frequent occurence that mail is sent between\
    \ hosts that share\n         no common protocol.\n      The domain system acknowledges\
    \ that these are very difficult\n      problems, and attempts to deal with both\
    \ problems through its\n      CLASS mechanism:\n      1. The CLASS field in RRs\
    \ allows data to be tagged so that all\n         programs in the domain system\
    \ can identify the format in use.\n      2. The CLASS field allows the requestor\
    \ to identify the format of\n         data which can be understood by the requestor.\n\
    \      3. The CLASS field guides the search for the requested data.\n      The\
    \ last point is central to our approach.  When a query crosses\n      protocol\
    \ boundaries, it must be guided though agents capable of\n      performing whatever\
    \ translation is required.  For example, when a\n      mailer wants to identify\
    \ the location of a mailbox in a portion of\n      the domain system that doesn't\
    \ have a compatible protocol, the\n      query must be guided to a name server\
    \ that can cross the boundary\n      itself or form one link in a chain that can\
    \ span the differences.\n      If query and response transport were the only problem,\
    \ then this\n      sort of problem could be dealt with in the name servers\n \
    \     themselves.  However, the applications that will use domain\n      service\
    \ have similar problems.  For example, mail may need to be\n      directed through\
    \ mail gateways, and the characteristics of one of\n      the environments may\
    \ not permit frequent connectivity between name\n      servers in all environments.\n\
    \      These problems suggest that connectivity will be achieved through\n   \
    \   a variety of measures:\n         Translation name servers that act as relays\
    \ between different\n         protocols.\n         Translation application servers\
    \ that translate application\n         level transactions.\n         Default database\
    \ entries that route traffic through application\n         level forwarders in\
    \ ways that depend on the class of the\n         requestor.\n      While this\
    \ approach seems best given our current understanding of\n                   \
    \      Domain Names - Implementation and Specification\n      the problem, we\
    \ realize that the approach of using resource data\n      that transcends class\
    \ may be appropriate in future designs or\n      applications.  By not defining\
    \ class to be directly related to\n      protocol, network, etc., we feel that\
    \ such services could be added\n      by defining a new \"universal\" class, while\
    \ the present use of\n      class will provide immediate service.\n      This\
    \ problem requires more thought and experience before solutions\n      can be\
    \ discovered.  The concepts of CLASS, recursive servers and\n      other mechanisms\
    \ are intended as tools for acquiring experience\n      and not as final solutions.\n\
    \                         Domain Names - Implementation and Specification\n"
- title: NAME SERVER TRANSACTIONS
  contents:
  - "NAME SERVER TRANSACTIONS\n   Introduction\n      The primary purpose of name\
    \ servers is to receive queries from\n      resolvers and return responses.  The\
    \ overall model of this service\n      is that a program (typically a resolver)\
    \ asks the name server\n      questions (queries) and gets responses that either\
    \ answer the\n      question or refer the questioner to another name server. \
    \ Other\n      functions related to name server database maintenance use similar\n\
    \      procedures and formats and are discussed in a section later in\n      this\
    \ memo.\n      There are three kinds of queries presently defined:\n         1.\
    \ Standard queries that ask for a specified resource attached\n            to\
    \ a given domain name.\n         2. Inverse queries that specify a resource and\
    \ ask for a domain\n            name that possesses that resource.\n         3.\
    \ Completion queries that specify a partial domain name and a\n            target\
    \ domain and ask that the partial domain name be\n            completed with a\
    \ domain name close to the target domain.\n      This memo uses an unqualified\
    \ reference to queries to refer to\n      either all queries or standard queries\
    \ when the context is clear.\n   Query and response transport\n      Name servers\
    \ and resolvers use a single message format for all\n      communications.  The\
    \ message format consists of a variable-length\n      octet string which includes\
    \ binary values.\n      The messages used in the domain system are designed so\
    \ that they\n      can be carried using either datagrams or virtual circuits.\
    \  To\n      accommodate the datagram style, all responses carry the query as\n\
    \      part of the response.\n      While the specification allows datagrams to\
    \ be used in any\n      context, some activities are ill suited to datagram use.\
    \  For\n      example, maintenance transactions and recursive queries typically\n\
    \      require the error control of virtual circuits.  Thus datagram use\n   \
    \   should be restricted to simple queries.\n      The domain system assumes that\
    \ a datagram service provides:\n         1. A non-reliable (i.e. best effort)\
    \ method of transporting a\n            message of up to 512 octets.\n       \
    \                  Domain Names - Implementation and Specification\n         \
    \   Hence datagram messages are limited to 512 octets.  If a\n            datagram\
    \ message would exceed 512 octets, it is truncated\n            and a truncation\
    \ flag is set in its header.\n         2. A message size that gives the number\
    \ of octets in the\n            datagram.\n      The main implications for programs\
    \ accessing name servers via\n      datagrams are:\n         1. Datagrams should\
    \ not be used for maintenance transactions\n            and recursive queries.\n\
    \         2. Since datagrams may be lost, the originator of a query must\n   \
    \         perform error recovery (such as retransmissions) as\n            appropriate.\n\
    \         3. Since network or host delay may cause retransmission when a\n   \
    \         datagram has not been lost, the originator of a query must\n       \
    \     be ready to deal with duplicate responses.\n      The domain system assumes\
    \ that a virtual circuit service provides:\n         1. A reliable method of transmitting\
    \ a message of up to 65535\n            octets.\n         2. A message size that\
    \ gives the number of octets in the\n            message.\n            If the\
    \ virtual circuit service does not provide for message\n            boundary detection\
    \ or limits transmission size to less than\n            65535 octets, then messages\
    \ are prefaced with an unsigned 16\n            bit length field and broken up\
    \ into separate transmissions\n            as required.  The length field is only\
    \ prefaced on the first\n            message.  This technique is used for TCP\
    \ virtual circuits.\n         3. Multiple messages may be sent over a virtual\
    \ circuit.\n         4. A method for closing a virtual circuit.\n         5. A\
    \ method for detecting that the other party has requested\n            that the\
    \ virtual circuit be closed.\n      The main implications for programs accessing\
    \ name servers via\n      virtual circuits are:\n         1. Either end of a virtual\
    \ circuit may initiate a close when\n            there is no activity in progress.\
    \  The other end should\n            comply.\n                         Domain\
    \ Names - Implementation and Specification\n            The decision to initiate\
    \ a close is a matter of individual\n            site policy; some name servers\
    \ may leave a virtual circuit\n            open for an indeterminate period following\
    \ a query to allow\n            for subsequent queries; other name servers may\
    \ choose to\n            initiate a close following the completion of the first\
    \ query\n            on a virtual circuit.  Of course, name servers should not\n\
    \            close the virtual circuit in the midst of a multiple message\n  \
    \          stream used for zone transfer.\n         2. Since network delay may\
    \ cause one end to erroneously believe\n            that no activity is in progress,\
    \ a program which receives a\n            virtual circuit close while a query\
    \ is in progress should\n            close the virtual circuit and resubmit the\
    \ query on a new\n            virtual circuit.\n      All messages may use a compression\
    \ scheme to reduce the space\n      consumed by repetitive domain names.  The\
    \ use of the compression\n      scheme is optional for the sender of a message,\
    \ but all receivers\n      must be capable of decoding compressed domain names.\n\
    \   Overall message format\n      All messages sent by the domain system are divided\
    \ into 5 sections\n      (some of which are empty in certain cases) shown below:\n\
    \       +---------------------+                                   \n       | \
    \       Header       |                                   \n       +---------------------+\
    \                                   \n       |       Question      | the question\
    \ for the name server  \n       +---------------------+                      \
    \             \n       |        Answer       | answering resource records (RRs)\
    \  \n       +---------------------+                                   \n     \
    \  |      Authority      | RRs pointing toward an authority  \n       +---------------------+\
    \                                   \n       |      Additional     | RRs holding\
    \ pertinent information \n       +---------------------+                     \
    \              \n      The header section is always present.  The header includes\
    \ fields\n      that specify which of the remaining sections are present, and\
    \ also\n      specify whether the message is a query, inverse query, completion\n\
    \      query, or response.\n      The question section contains fields that describe\
    \ a question to a\n      name server.  These fields are a query type (QTYPE),\
    \ a query class\n      (QCLASS), and a query domain name (QNAME).\n      The last\
    \ three sections have the same format: a possibly empty\n      list of concatenated\
    \ resource records (RRs).  The answer section\n      contains RRs that answer\
    \ the question; the authority section\n                         Domain Names -\
    \ Implementation and Specification\n      contains RRs that point toward an authoritative\
    \ name server; the\n      additional records section contains RRs which relate\
    \ to the query,\n      but are not strictly answers for the question.\n      The\
    \ next two sections of this memo illustrate the use of these\n      message sections\
    \ through examples; a detailed discussion of data\n      formats follows the examples.\n\
    \                         Domain Names - Implementation and Specification\n  \
    \ The contents of standard queries and responses\n      When a name server processes\
    \ a standard query, it first determines\n      whether it is an authority for\
    \ the domain name specified in the\n      query.\n      If the name server is\
    \ an authority, it returns either:\n         1. the specified resource information\n\
    \         2. an indication that the specified name does not exist\n         3.\
    \ an indication that the requested resource information does\n            not\
    \ exist\n      If the name server is not an authority for the specified name,\
    \ it\n      returns whatever relevant resource information it has along with\n\
    \      resource records that the requesting resolver can use to locate an\n  \
    \    authoritative name server.\n   Standard query and response example\n    \
    \  The overall structure of a query for retrieving information for\n      Internet\
    \ mail for domain F.ISI.ARPA is shown below:\n                          +-----------------------------------------+\n\
    \            Header        |          OPCODE=QUERY, ID=2304          |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |QTYPE=MAILA, QCLASS=IN, QNAME=F.ISI.ARPA |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |                 <empty>                 |\n                         \
    \ +-----------------------------------------+\n           Authority      |   \
    \              <empty>                 |\n                          +-----------------------------------------+\n\
    \          Additional      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n      The header\
    \ includes an opcode field that specifies that this\n      datagram is a query,\
    \ and an ID field that will be used to\n      associate replies with the original\
    \ query.  (Some additional\n      header fields have been omitted for clarity.)\
    \  The question\n      section specifies that the type of the query is for mail\
    \ agent\n      information, that only ARPA Internet information is to be\n   \
    \   considered, and that the domain name of interest is F.ISI.ARPA.\n      The\
    \ remaining sections are empty, and would not use any octets in\n      a real\
    \ query.\n                         Domain Names - Implementation and Specification\n\
    \      One possible response to this query might be:\n                       \
    \   +-----------------------------------------+\n            Header        | \
    \       OPCODE=RESPONSE, ID=2304         |\n                          +-----------------------------------------+\n\
    \           Question       |QTYPE=MAILA, QCLASS=IN, QNAME=F.ISI.ARPA |\n     \
    \                     +-----------------------------------------+\n          \
    \  Answer        |                 <empty>                 |\n               \
    \           +-----------------------------------------+\n           Authority\
    \      |          ARPA NS IN A.ISI.ARPA          |\n                         \
    \ |                 -------                 |\n                          |   \
    \       ARPA NS IN F.ISI.ARPA          |\n                          +-----------------------------------------+\n\
    \           Additional     |        F.ISI.ARPA A IN 10.2.0.52        |\n     \
    \                     |                 -------                 |\n          \
    \                |        A.ISI.ARPA A IN 10.1.0.22        |\n               \
    \           +-----------------------------------------+\n      This type of response\
    \ would be returned by a name server that was\n      not an authority for the\
    \ domain name F.ISI.ARPA.  The header field\n      specifies that the datagram\
    \ is a response to a query with an ID of\n      2304.  The question section is\
    \ copied from the question section in\n      the query datagram.\n      The answer\
    \ section is empty because the name server did not have\n      any information\
    \ that would answer the query.  (Name servers may\n      happen to have cached\
    \ information even if they are not\n      authoritative for the query.)\n    \
    \  The best that this name server could do was to pass back\n      information\
    \ for the domain ARPA.  The authority section specifies\n      two name servers\
    \ for the domain ARPA using the Internet family:\n      A.ISI.ARPA and F.ISI.ARPA.\
    \  Note that it is merely a coincidence\n      that F.ISI.ARPA is a name server\
    \ for ARPA as well as the subject\n      of the query.\n      In this case, the\
    \ name server included in the additional records\n      section the Internet addresses\
    \ for the two hosts specified in the\n      authority section.  Such additional\
    \ data is almost always\n      available.\n      Given this response, the process\
    \ that originally sent the query\n      might resend the query to the name server\
    \ on A.ISI.ARPA, with a\n      new ID of 2305.\n                         Domain\
    \ Names - Implementation and Specification\n      The name server on A.ISI.ARPA\
    \ might return a response:\n                          +-----------------------------------------+\n\
    \            Header        |        OPCODE=RESPONSE, ID=2305         |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |QTYPE=MAILA, QCLASS=IN, QNAME=F.ISI.ARPA |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |       F.ISI.ARPA MD IN F.ISI.ARPA       |\n                         \
    \ |                 -------                 |\n                          |   \
    \    F.ISI.ARPA MF IN A.ISI.ARPA       |\n                          +-----------------------------------------+\n\
    \           Authority      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n          Additional\
    \      |        F.ISI.ARPA A IN 10.2.0.52        |\n                         \
    \ |                 -------                 |\n                          |   \
    \     A.ISI.ARPA A IN 10.1.0.22        |\n                          +-----------------------------------------+\n\
    \      This query was directed to an authoritative name server, and hence\n  \
    \    the response includes an answer but no authority records.  In this\n    \
    \  case, the answer section specifies that mail for F.ISI.ARPA can\n      either\
    \ be delivered to F.ISI.ARPA or forwarded to A.ISI.ARPA.  The\n      additional\
    \ records section specifies the Internet addresses of\n      these hosts.\n  \
    \ The contents of inverse queries and responses\n      Inverse queries reverse\
    \ the mappings performed by standard query\n      operations; while a standard\
    \ query maps a domain name to a\n      resource, an inverse query maps a resource\
    \ to a domain name.  For\n      example, a standard query might bind a domain\
    \ name to a host\n      address; the corresponding inverse query binds the host\
    \ address to\n      a domain name.\n      Inverse query mappings are not guaranteed\
    \ to be unique or complete\n      because the domain system does not have any\
    \ internal mechanism for\n      determining authority from resource records that\
    \ parallels the\n      capability for determining authority as a function of domain\
    \ name.\n      In general, resolvers will be configured to direct inverse queries\n\
    \      to a name server which is known to have the desired information.\n    \
    \  Name servers are not required to support any form of inverse\n      queries;\
    \ it is anticipated that most name servers will support\n      address to domain\
    \ name conversions, but no other inverse mappings.\n      If a name server receives\
    \ an inverse query that it does not\n      support, it returns an error response\
    \ with the \"Not Implemented\"\n      error set in the header.  While inverse\
    \ query support is optional,\n      all name servers must be at least able to\
    \ return the error\n      response.\n                         Domain Names - Implementation\
    \ and Specification\n      When a name server processes an inverse query, it either\
    \ returns:\n         1. zero, one, or multiple domain names for the specified\n\
    \         resource\n         2. an error code indicating that the name server\
    \ doesn't\n            support inverse mapping of the specified resource type.\n\
    \   Inverse query and response example\n      The overall structure of an inverse\
    \ query for retrieving the\n      domain name that corresponds to Internet address\
    \ 10.2.0.52 is\n      shown below:\n                          +-----------------------------------------+\n\
    \            Header        |          OPCODE=IQUERY, ID=997          |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |                 <empty>                 |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |        <anyname> A IN 10.2.0.52         |\n                         \
    \ +-----------------------------------------+\n           Authority      |   \
    \              <empty>                 |\n                          +-----------------------------------------+\n\
    \          Additional      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n      This\
    \ query asks for a question whose answer is the Internet style\n      address\
    \ 10.2.0.52.  Since the owner name is not known, any domain\n      name can be\
    \ used as a placeholder (and is ignored).  The response\n      to this query might\
    \ be:\n                          +-----------------------------------------+\n\
    \            Header        |         OPCODE=RESPONSE, ID=997         |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |   QTYPE=A, QCLASS=IN, QNAME=F.ISI.ARPA  |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |       F.ISI.ARPA A IN 10.2.0.52         |\n                         \
    \ +-----------------------------------------+\n           Authority      |   \
    \              <empty>                 |\n                          +-----------------------------------------+\n\
    \          Additional      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n      Note\
    \ that the QTYPE in a response to an inverse query is the same\n      as the TYPE\
    \ field in the answer section of the inverse query.\n      Responses to inverse\
    \ queries may contain multiple questions when\n      the inverse is not unique.\n\
    \                         Domain Names - Implementation and Specification\n  \
    \ Completion queries and responses\n      Completion queries ask a name server\
    \ to complete a partial domain\n      name and return a set of RRs whose domain\
    \ names meet a specified\n      set of criteria for \"closeness\" to the partial\
    \ input.  This type\n      of query can provide a local shorthand for domain names\
    \ or command\n      completion similar to that in TOPS-20.\n      Implementation\
    \ of completion query processing is optional in a\n      name server.  However,\
    \ a name server must return a \"Not\n      Implemented\" (NI) error response if\
    \ it does not support\n      completion.\n      The arguments in a completion\
    \ query specify:\n      1. A type in QTYPE that specifies the type of the desired\
    \ name.\n         The type is used to restrict the type of RRs which will match\n\
    \         the partial input so that completion queries can be used for\n     \
    \    mailbox names, host names, or any other type of RR in the\n         domain\
    \ system without concern for matches to the wrong type of\n         resource.\n\
    \      2. A class in QCLASS which specifies the desired class of the RR.\n   \
    \   3. A partial domain name that gives the input to be completed.\n         All\
    \ returned RRs will begin with the partial string.  The\n         search process\
    \ first looks for names which qualify under the\n         assumption that the\
    \ partial string ends with a full label\n         (\"whole label match\"); if\
    \ this search fails, the search\n         continues under the assumption that\
    \ the last label in the\n         partial sting may be an incomplete label (\"\
    partial label\n         match\").  For example, if the partial string \"Smith\"\
    \ was used\n         in a mailbox completion, it would match Smith@ISI.ARPA in\n\
    \         preference to Smithsonian@ISI.ARPA.\n         The partial name is supplied\
    \ by the user through the user\n         program that is using domain services.\
    \  For example, if the\n         user program is a mail handler, the string might\
    \ be \"Mockap\"\n         which the user intends as a shorthand for the mailbox\n\
    \         Mockapetris@ISI.ARPA; if the user program is TELNET, the user\n    \
    \     might specify \"F\" for F.ISI.ARPA.\n         In order to make parsing of\
    \ messages consistent, the partial\n         name is supplied in domain name format\
    \ (i.e. a sequence of\n         labels terminated with a zero length octet). \
    \ However, the\n         trailing root label is ignored during matching.\n   \
    \   4. A target domain name which specifies the domain which is to be\n      \
    \   examined for matches.  This name is specified in the additional\n        \
    \                 Domain Names - Implementation and Specification\n         section\
    \ using a NULL RR.  All returned names will end with the\n         target name.\n\
    \         The user program which constructs the query uses the target\n      \
    \   name to restrict the search.  For example, user programs\n         running\
    \ at ISI might restrict completion to names that end in\n         ISI.ARPA; user\
    \ programs running at MIT might restrict\n         completion to the domain MIT.ARPA.\n\
    \         The target domain name is also used by the resolver to\n         determine\
    \ the name server which should be used to process the\n         query.  In general,\
    \ queries should be directed to a name server\n         that is authoritative\
    \ for the target domain name.  User\n         programs which wish to provide completion\
    \ for a more than one\n         target can issue multiple completion queries,\
    \ each directed at\n         a different target.  Selection of the target name\
    \ and the\n         number of searches will depend on the goals of the user\n\
    \         program.\n      5. An opcode for the query.  The two types of completion\
    \ queries\n         are \"Completion Query - Multiple\", or CQUERYM, which asks\
    \ for\n         all RRs which could complete the specified input, and\n      \
    \   \"Completion Query - Unique\", or CQUERYU, which asks for the\n         \"\
    best\" completion.\n         CQUERYM is used by user programs which want to know\
    \ if\n         ambiguities exist or wants to do its own determinations as to\n\
    \         the best choice of the available candidates.\n         CQUERYU is used\
    \ by user programs which either do not wish to\n         deal with multiple choices\
    \ or are willing to use the closeness\n         criteria used by CQUERYU to select\
    \ the best match.\n      When a name server receives either completion query,\
    \ it first\n      looks for RRs that begin (on the left) with the same labels\
    \ as are\n      found in QNAME (with the root deleted), and which match the QTYPE\n\
    \      and QCLASS.  This search is called \"whole label\" matching.  If one\n\
    \      or more hits are found the name server either returns all of the\n    \
    \  hits (CQUERYM) or uses the closeness criteria described below to\n      eliminate\
    \ all but one of the matches (CQUERYU).\n      If the whole label match fails\
    \ to find any candidates, then the\n      name server assumes that the rightmost\
    \ label of QNAME (after root\n      deletion) is not a complete label, and looks\
    \ for candidates that\n      would match if characters were added (on the right)\
    \ to the\n      rightmost label of QNAME.  If one or more hits are found the name\n\
    \      server either returns all of the hits (CQUERYM) or uses the\n      closeness\
    \ criteria described below to eliminate all but one of the\n      matches (CQUERYU).\n\
    \                         Domain Names - Implementation and Specification\n  \
    \    If a CQUERYU query encounters multiple hits, it uses the following\n    \
    \  sequence of rules to discard multiple hits:\n      1. Discard candidates that\
    \ have more labels than others.  Since\n         all candidates start with the\
    \ partial name and end with the\n         target name, this means that we select\
    \ those entries that\n         require the fewest number of added labels.  For\
    \ example, a host\n         search with a target of \"ISI.ARPA\" and a partial\
    \ name of \"A\"\n         will select A.ISI.ARPA in preference to A.IBM-PCS.ISI.ARPA.\n\
    \      2. If partial label matching was used, discard those labels which\n   \
    \      required more characters to be added.  For example, a mailbox\n       \
    \  search for partial \"X\" and target \"ISI.ARPA\" would prefer\n         XX@ISI.ARPA\
    \ to XYZZY@ISI.ARPA.\n      If multiple hits are still present, return all hits.\n\
    \      Completion query mappings are not guaranteed to be unique or\n      complete\
    \ because the domain system does not have any internal\n      mechanism for determining\
    \ authority from a partial domain name\n      that parallels the capability for\
    \ determining authority as a\n      function of a complete domain name.  In general,\
    \ resolvers will be\n      configured to direct completion queries to a name server\
    \ which is\n      known to have the desired information.\n      When a name server\
    \ processes a completion query, it either\n      returns:\n         1. An answer\
    \ giving zero, one, or more possible completions.\n         2. an error response\
    \ with Not Implemented (NI) set.\n                         Domain Names - Implementation\
    \ and Specification\n   Completion query and response example\n      Suppose that\
    \ the completion service was used by a TELNET program\n      to allow a user to\
    \ specify a partial domain name for the desired\n      host.  Thus a user might\
    \ ask to be connected to \"B\".  Assuming\n      that the query originated from\
    \ an ISI machine, the query might\n      look like:\n                        \
    \  +-----------------------------------------+\n            Header        |  \
    \       OPCODE=CQUERYU, ID=409          |\n                          +-----------------------------------------+\n\
    \           Question       |       QTYPE=A, QCLASS=IN, QNAME=B       |\n     \
    \                     +-----------------------------------------+\n          \
    \  Answer        |                 <empty>                 |\n               \
    \           +-----------------------------------------+\n           Authority\
    \      |                 <empty>                 |\n                         \
    \ +-----------------------------------------+\n          Additional      |   \
    \          ISI.ARPA NULL IN            |\n                          +-----------------------------------------+\n\
    \      The partial name in the query is \"B\", the mappings of interest are\n\
    \      ARPA Internet address records, and the target domain is ISI.ARPA.\n   \
    \   Note that NULL is a special type of NULL resource record that is\n      used\
    \ as a placeholder and has no significance; NULL RRs obey the\n      standard\
    \ format but have no other function.\n      The response to this completion query\
    \ might be:\n                          +-----------------------------------------+\n\
    \            Header        |         OPCODE=RESPONSE, ID=409         |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |       QTYPE=A, QCLASS=IN, QNAME=B       |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |        B.ISI.ARPA A IN 10.3.0.52        |\n                         \
    \ +-----------------------------------------+\n           Authority      |   \
    \              <empty>                 |\n                          +-----------------------------------------+\n\
    \          Additional      |             ISI.ARPA NULL IN            |\n     \
    \                     +-----------------------------------------+\n      This\
    \ response has completed B to mean B.ISI.ARPA.\n                         Domain\
    \ Names - Implementation and Specification\n      Another query might be:\n  \
    \                        +-----------------------------------------+\n       \
    \     Header        |         OPCODE=CQUERYM, ID=410          |\n            \
    \              +-----------------------------------------+\n           Question\
    \       |       QTYPE=A, QCLASS=IN, QNAME=B       |\n                        \
    \  +-----------------------------------------+\n            Answer        |  \
    \               <empty>                 |\n                          +-----------------------------------------+\n\
    \           Authority      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n          Additional\
    \      |               ARPA NULL IN              |\n                         \
    \ +-----------------------------------------+\n      This query is similar to\
    \ the previous one, but specifies a target\n      of ARPA rather than ISI.ARPA.\
    \  It also allows multiple matches.\n      In this case the same name server might\
    \ return:\n                          +-----------------------------------------+\n\
    \            Header        |         OPCODE=RESPONSE, ID=410         |\n     \
    \                     +-----------------------------------------+\n          \
    \ Question       |       QTYPE=A, QCLASS=IN, QNAME=B       |\n               \
    \           +-----------------------------------------+\n            Answer  \
    \      |        B.ISI.ARPA A IN 10.3.0.52        |\n                         \
    \ |                    -                    |\n                          |   \
    \     B.BBN.ARPA A IN 10.0.0.49        |\n                          |        \
    \            -                    |\n                          |        B.BBNCC.ARPA\
    \ A IN 8.1.0.2        |\n                          +-----------------------------------------+\n\
    \           Authority      |                 <empty>                 |\n     \
    \                     +-----------------------------------------+\n          Additional\
    \      |               ARPA NULL IN              |\n                         \
    \ +-----------------------------------------+\n      This response contains three\
    \ answers, B.ISI.ARPA, B.BBN.ARPA, and\n      B.BBNCC.ARPA.\n                \
    \         Domain Names - Implementation and Specification\n   Recursive Name Service\n\
    \      Recursive service is an optional feature of name servers.\n      When a\
    \ name server receives a query regarding a part of the name\n      space which\
    \ is not in one of the name server's zones, the standard\n      response is a\
    \ message that refers the requestor to another name\n      server.  By iterating\
    \ on these referrals, the requestor eventually\n      is directed to a name server\
    \ that has the required information.\n      Name servers may also implement recursive\
    \ service.  In this type\n      of service, a name server either answers immediately\
    \ based on\n      local zone information, or pursues the query for the requestor\
    \ and\n      returns the eventual result back to the original requestor.\n   \
    \   A name server that supports recursive service sets the Recursion\n      Available\
    \ (RA) bit in all responses it generates.  A requestor\n      asks for recursive\
    \ service by setting the Recursion Desired (RD)\n      bit in queries.  In some\
    \ situations where recursive service is the\n      only path to the desired information\
    \ (see below), the name server\n      may go recursive even if RD is zero.\n \
    \     If a query requests recursion (RD set), but the name server does\n     \
    \ not support recursion, and the query needs recursive service for\n      an answer,\
    \ the name server returns a \"Not Implemented\" (NI) error\n      code.  If the\
    \ query can be answered without recursion since the\n      name server is authoritative\
    \ for the query, it ignores the RD bit.\n      Because of the difficulty in selecting\
    \ appropriate timeouts and\n      error handling, recursive service is best suited\
    \ to virtual\n      circuits, although it is allowed for datagrams.\n      Recursive\
    \ service is valuable in several special situations:\n         In a system of\
    \ small personal computers clustered around one or\n         more large hosts\
    \ supporting name servers, the recursive\n         approach minimizes the amount\
    \ of code in the resolvers in the\n         personal computers.  Such a design\
    \ moves complexity out of the\n         resolver into the name server, and may\
    \ be appropriate for such\n         systems.\n         Name servers on the boundaries\
    \ of different networks may wish\n         to offer recursive service to create\
    \ connectivity between\n         different networks.  Such name servers may wish\
    \ to provide\n         recursive service regardless of the setting of RD.\n  \
    \       Name servers that translate between domain name service and\n        \
    \ some other name service may wish to adopt the recursive style.\n         Implicit\
    \ recursion may be valuable here as well.\n                         Domain Names\
    \ - Implementation and Specification\n      These concepts are still under development.\n\
    \                         Domain Names - Implementation and Specification\n  \
    \ Header section format\n           +-----------------------------------------------+\n\
    \           |                                               |\n           |  \
    \           *****  WARNING  *****             |\n           |                \
    \                               |\n           |  The following format is preliminary\
    \ and is   |\n           | included for purposes of explanation only. In |\n \
    \          | particular, the size and position of the      |\n           | OPCODE,\
    \ RCODE fields and the number and       |\n           | meaning of the single\
    \ bit fields are subject  |\n           | to change.                         \
    \           |\n           |                                               |\n\
    \           +-----------------------------------------------+\n      The header\
    \ contains the following fields:\n                                           1\
    \  1  1  1  1  1 \n             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\
    \ \n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           |\
    \                      ID                       |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |QR|   Opcode  |AA|TC|RD|RA|        |   RCODE   |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    QDCOUNT                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    ANCOUNT                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    NSCOUNT                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    ARCOUNT                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      where:\n      ID      - A 16 bit identifier assigned by the program that\n\
    \                generates any kind of query.  This identifier is copied\n   \
    \             into all replies and can be used by the requestor to\n         \
    \       relate replies to outstanding questions.\n      QR      - A one bit field\
    \ that specifies whether this message is a\n                query (0), or a response\
    \ (1).\n      OPCODE  - A four bit field that specifies kind of query in this\n\
    \                message.  This value is set by the originator of a query\n  \
    \              and copied into the response.  The values are:\n              \
    \          0   a standard query (QUERY)\n                         Domain Names\
    \ - Implementation and Specification\n                        1   an inverse query\
    \ (IQUERY)\n                        2   an completion query allowing multiple\n\
    \                            answers (CQUERYM)\n                        2   an\
    \ completion query requesting a single\n                            answer (CQUERYU)\n\
    \                        4-15 reserved for future use\n      AA      - Authoritative\
    \ Answer - this bit is valid in responses,\n                         and specifies\
    \ that the responding name server\n                         is an authority for\
    \ the domain name in the\n                         corresponding query.\n    \
    \  TC      - TrunCation - specifies that this message was truncated\n        \
    \                 due to length greater than 512 characters.\n               \
    \          This bit is valid in datagram messages but not\n                  \
    \       in messages sent over virtual circuits.\n      RD      - Recursion Desired\
    \ - this bit may be set in a query and\n                         is copied into\
    \ the response.  If RD is set, it\n                         directs the name server\
    \ to pursue the query\n                         recursively.  Recursive query\
    \ support is\n                         optional.\n      RA      - Recursion Available\
    \ - this be is set or cleared in a\n                         response, and denotes\
    \ whether recursive query\n                         support is available in the\
    \ name server.\n      RCODE   - Response code - this 4 bit field is set as part\
    \ of\n                         responses.  The values have the following\n   \
    \                      interpretation:\n                        0    No error\
    \ condition\n                        1    Format error - The name server was unable\n\
    \                             to interpret the query.\n                      \
    \  2    Server failure - The name server was unable\n                        \
    \     to process this query due to a problem with\n                          \
    \   the name server.\n                        3    Name Error - Meaningful only\
    \ for responses\n                             from an authoritative name server,\
    \ this\n                             code signifies that the domain name\n   \
    \                          referenced in the query does not exist.\n         \
    \                Domain Names - Implementation and Specification\n           \
    \             4    Not Implemented - The name server does not\n              \
    \               support the requested kind of query.\n                       \
    \ 5    Refused - The name server refuses to\n                             perform\
    \ the specified operation for policy\n                             reasons.  For\
    \ example, a name server may\n                             not wish to provide\
    \ the information to the\n                             particular requestor, or\
    \ a name server may\n                             not wish to perform a particular\
    \ operation\n                             (e.g. zone transfer) for particular\
    \ data.\n                        6-15 Reserved for future use.\n      QDCOUNT\
    \ - an unsigned 16 bit integer specifying the number of\n                entries\
    \ in the question section.\n      ANCOUNT - an unsigned 16 bit integer specifying\
    \ the number of\n                resource records in the answer section.\n   \
    \   NSCOUNT - an unsigned 16 bit integer specifying the number of name\n     \
    \           server resource records in the authority records\n               \
    \ section.\n      ARCOUNT - an unsigned 16 bit integer specifying the number of\n\
    \                resource records in the additional records section.\n       \
    \                  Domain Names - Implementation and Specification\n   Question\
    \ section format\n      The question section is used in all kinds of queries other\
    \ than\n      inverse queries.  In responses to inverse queries, this section\n\
    \      may contain multiple entries; for all other responses it contains\n   \
    \   a single entry.  Each entry has the following format:\n                  \
    \                         1  1  1  1  1  1 \n             0  1  2  3  4  5  6\
    \  7  8  9  0  1  2  3  4  5 \n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                                               |\n           /  \
    \                   QNAME                     /\n           /                \
    \                               /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                     QTYPE                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                     QCLASS                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      where:\n      QNAME -   a variable number of octets that specify a domain\
    \ name.\n                This field uses the compressed domain name format\n \
    \               described in the next section of this memo.  This field\n    \
    \            can be used to derive a text string for the domain name.\n      \
    \          Note that this field may be an odd number of octets; no\n         \
    \       padding is used.\n      QTYPE -   a two octet code which specifies the\
    \ type of the query.\n                The values for this field include all codes\
    \ valid for a\n                TYPE field, together with some more general codes\
    \ which\n                can match more than one type of RR.  For example, QTYPE\n\
    \                might be A and only match type A RRs, or might be MAILA,\n  \
    \              which matches MF and MD type RRs.  The values for this\n      \
    \          field are listed in Appendix 2.\n      QCLASS -  a two octet code that\
    \ specifies the class of the query.\n                For example, the QCLASS field\
    \ is IN for the ARPA\n                Internet, CS for the CSNET, etc.  The numerical\
    \ values\n                are defined in Appendix 2.\n                       \
    \  Domain Names - Implementation and Specification\n   Resource record format\n\
    \      The answer, authority, and additional sections all share the same\n   \
    \   format: a variable number of resource records, where the number of\n     \
    \ records is specified in the corresponding count field in the\n      header.\
    \  Each resource record has the following format:\n                          \
    \                 1  1  1  1  1  1 \n             0  1  2  3  4  5  6  7  8  9\
    \  0  1  2  3  4  5 \n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                                               |\n           /  \
    \                                             /\n           /                \
    \      NAME                     /\n           |                              \
    \                 |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                      TYPE                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                     CLASS                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                      TTL                      |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                   RDLENGTH                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n\
    \           /                     RDATA                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      where:\n      NAME    - a compressed domain name to which this resource\
    \ record\n                pertains.\n      TYPE    - two octets containing one\
    \ of the RR type codes defined\n                in Appendix 2.  This field specifies\
    \ the meaning of the\n                data in the RDATA field.\n      CLASS  \
    \ - two octets which specify the class of the data in the\n                RDATA\
    \ field.\n      TTL     - a 16 bit unsigned integer that specifies the time\n\
    \                interval (in seconds) that the resource record may be\n     \
    \           cached before it should be discarded.  Zero values are\n         \
    \       interpreted to mean that the RR can only be used for the\n           \
    \     transaction in progress, and should not be cached.  For\n              \
    \  example, SOA records are always distributed with a zero\n                TTL\
    \ to prohibit caching.  Zero values can also be used\n                for extremely\
    \ volatile data.\n                         Domain Names - Implementation and Specification\n\
    \      RDLENGTH- an unsigned 16 bit integer that specifies the length in\n   \
    \             octets of the RDATA field.\n      RDATA   - a variable length string\
    \ of octets that describes the\n                resource.  The format of this\
    \ information varies\n                according to the TYPE and CLASS of the resource\
    \ record.\n                For example, the if the TYPE is A and the CLASS is\
    \ IN,\n                the RDATA field is a 4 octet ARPA Internet address.\n \
    \     Formats for particular resource records are shown in Appendicies 2\n   \
    \   and 3.\n   Domain name representation and compression\n      Domain names\
    \ messages are expressed in terms of a sequence of\n      labels.  Each label\
    \ is represented as a one octet length field\n      followed by that number of\
    \ octets.  Since every domain name ends\n      with the null label of the root,\
    \ a compressed  domain name is\n      terminated by a length byte of zero.  The\
    \ high order two bits of\n      the length field must be zero, and the remaining\
    \ six bits of the\n      length field limit the label to 63 octets or less.\n\
    \      To simplify implementations, the total length of label octets and\n   \
    \   label length octets that make up a domain name is restricted to\n      255\
    \ octets or less.  Since the trailing root label and its dot are\n      not printed,\
    \ printed domain names are 254 octets or less.\n      Although labels can contain\
    \ any 8 bit values in octets that make\n      up a label, it is strongly recommended\
    \ that labels follow the\n      syntax described in Appendix 1 of this memo, which\
    \ is compatible\n      with existing host naming conventions.  Name servers and\
    \ resolvers\n      must compare labels in a case-insensitive manner, i.e. A=a,\
    \ and\n      hence all character strings must be ASCII with zero parity.\n   \
    \   Non-alphabetic codes must match exactly.\n      Whenever possible, name servers\
    \ and resolvers must preserve all 8\n      bits of domain names they process.\
    \  When a name server is given\n      data for the same name under two different\
    \ case usages, this\n      preservation is not always possible.  For example,\
    \ if a name\n      server is given data for ISI.ARPA and isi.arpa, it should create\
    \ a\n      single node, not two, and hence will preserve a single casing of\n\
    \      the label.  Systems with case sensitivity should take special\n      precautions\
    \ to insure that the domain data for the system is\n      created with consistent\
    \ case.\n      In order to reduce the amount of space used by repetitive domain\n\
    \      names, the sequence of octets that defines a domain name may be\n     \
    \ terminated by a pointer to the length octet of a previously\n      specified\
    \ label string.  The label string that the pointer\n                         Domain\
    \ Names - Implementation and Specification\n      specifies is appended to the\
    \ already specified label string.\n      Exact duplication of a previous label\
    \ string can be done with a\n      single pointer.  Multiple levels are allowed.\n\
    \      Pointers can only be used in positions in the message where the\n     \
    \ format is not class specific.  If this were not the case, a name\n      server\
    \ that was handling a RR for another class could make\n      erroneous copies\
    \ of RRs.  As yet, there are no such cases, but\n      they may occur in future\
    \ RDATA formats.\n      If a domain name is contained in a part of the message\
    \ subject to\n      a length field (such as the RDATA section of an RR), and\n\
    \      compression is used, the length of the compressed name is used in\n   \
    \   the length calculation, rather than the length of the expanded\n      name.\n\
    \      Pointers are represented as a two octet field in which the high\n     \
    \ order 2 bits are ones, and the low order 14 bits specify an offset\n      from\
    \ the start of the message.  The 01 and 10 values of the high\n      order bits\
    \ are reserved for future use and should not be used.\n      Programs are free\
    \ to avoid using pointers in datagrams they\n      generate, although this will\
    \ reduce datagram capacity.  However\n      all programs are required to understand\
    \ arriving messages that\n      contain pointers.\n      For example, a datagram\
    \ might need to use the domain names\n      F.ISI.ARPA, FOO.F.ISI.ARPA, ARPA,\
    \ and the root.  Ignoring the\n      other fields of the message, these domain\
    \ names might be\n      represented as:\n                         Domain Names\
    \ - Implementation and Specification\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \          20 |           1           |           F           |\n            \
    \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          22 |          \
    \ 3           |           I           |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \          24 |           S           |           I           |\n            \
    \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          26 |          \
    \ 4           |           A           |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \          28 |           R           |           P           |\n            \
    \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          30 |          \
    \ A           |           0           |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          40\
    \ |           3           |           F           |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \          42 |           O           |           O           |\n            \
    \ +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          44 | 1  1|    \
    \            20                       |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          64\
    \ | 1  1|                26                       |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n          92\
    \ |           0           |                       |\n             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      The domain name for F.ISI.ARPA is shown at offset 20.  The domain\n   \
    \   name FOO.F.ISI.ARPA is shown at offset 40; this definition uses a\n      pointer\
    \ to concatenate a label for FOO to the previously defined\n      F.ISI.ARPA.\
    \  The domain name ARPA is defined at offset 64 using a\n      pointer to the\
    \ ARPA component of the name F.ISI.ARPA at 20; note\n      that this reference\
    \ relies on ARPA being the last label in the\n      string at 20.  The root domain\
    \ name is defined by a single octet\n      of zeros at 92; the root domain name\
    \ has no labels.\n   Organization of the Shared database\n      While name server\
    \ implementations are free to use any internal\n      data structures they choose,\
    \ the suggested structure consists of\n      several separate trees.  Each tree\
    \ has structure corresponding to\n      the domain name space, with RRs attached\
    \ to nodes and leaves.\n      Each zone of authoritative data has a separate tree,\
    \ and one tree\n      holds all non-authoritative data.  All of the trees corresponding\n\
    \      to zones are managed identically, but the non-authoritative or\n      cache\
    \ tree has different management procedures.\n                         Domain Names\
    \ - Implementation and Specification\n      Data stored in the database can be\
    \ kept in whatever form is\n      convenient for the name server, so long as it\
    \ can be transformed\n      back into the format needed for messages.  In particular,\
    \ the\n      database will probably use structure in place of expanded domain\n\
    \      names, and will also convert many of the time intervals used in\n     \
    \ the domain systems to absolute local times.\n      Each tree corresponding to\
    \ a zone has complete information for a\n      \"pruned\" subtree of the domain\
    \ space.  The top node of a zone has\n      a SOA record that marks the start\
    \ of the zone.  The bottom edge of\n      the zone is delimited by nodes containing\
    \ NS records signifying\n      delegation of authority to other zones, or by leaves\
    \ of the domain\n      tree.  When a name server contains abutting zones, one\
    \ tree will\n      have a bottom node containing a NS record, and the other tree\
    \ will\n      begin with a tree location containing a SOA record.\n      Note\
    \ that there is one special case that requires consideration\n      when a name\
    \ server is implemented.  A node that contains a SOA RR\n      denoting a start\
    \ of zone will also have NS records that identify\n      the name servers that\
    \ are expected to have a copy of the zone.\n      Thus a name server will usually\
    \ find itself (and possibly other\n      redundant name servers) referred to in\
    \ NS records occupying the\n      same position in the tree as SOA records.  The\
    \ solution to this\n      problem is to never interpret a NS record as delimiting\
    \ a zone\n      started by a SOA at the same point in the tree.  (The sample\n\
    \      programs in this memo deal with this problem by processing SOA\n      records\
    \ only after NS records have been processed.)\n      Zones may also overlap a\
    \ particular part of the name space when\n      they are of different classes.\n\
    \      Other than the abutting and separate class cases, trees are always\n  \
    \    expected to be disjoint.  Overlapping zones are regarded as a\n      non-fatal\
    \ error.  The scheme described in this memo avoids the\n      overlap issue by\
    \ maintaining separate trees; other designs must\n      take the appropriate measures\
    \ to defend against possible overlap.\n      Non-authoritative data is maintained\
    \ in a separate tree.  This\n      tree is unlike the zone trees in that it may\
    \ have \"holes\".  Each\n      RR in the cache tree has its own TTL that is separately\
    \ managed.\n      The data in this tree is never used if authoritative data is\n\
    \      available from a zone tree; this avoids potential problems due to\n   \
    \   cached data that conflicts with authoritative data.\n      The shared database\
    \ will also contain data structures to support\n      the processing of inverse\
    \ queries and completion queries if the\n      local system supports these optional\
    \ features.  Although many\n      schemes are possible, this memo describes a\
    \ scheme that is based\n      on tables of pointers that invert the database according\
    \ to key.\n                         Domain Names - Implementation and Specification\n\
    \      Each kind of retrieval has a separate set of tables, with one\n      table\
    \ per zone.  When a zone is updated, these tables must also be\n      updated.\
    \  The contents of these tables are discussed in the\n      \"Inverse query processing\"\
    \ and \"Completion query processing\"\n      sections of this memo.\n      The\
    \ database implementation described here includes two locks that\n      are used\
    \ to control concurrent access and modification of the\n      database by name\
    \ server query processing, name server maintenance\n      operations, and resolver\
    \ access:\n         The first lock (\"main lock\") controls access to all of the\n\
    \         trees.  Multiple concurrent reads are allowed, but write access\n  \
    \       can only be acquired by a single process.  Read and write\n         access\
    \ are mutually exclusive.  Resolvers and name server\n         processes that\
    \ answer queries acquire this lock in read mode,\n         and unlock upon completion\
    \ of the current message.  This lock\n         is acquired in write mode by a\
    \ name server maintenance process\n         when it is about to change data in\
    \ the shared database.  The\n         actual update procedures are described under\
    \ \"NAME SERVER\n         MAINTENANCE\" but are designed to be brief.\n      \
    \   The second lock (\"cache queue lock\") controls access to the\n         cache\
    \ queue.  This queue is used by a resolver that wishes to\n         add information\
    \ to the cache tree.  The resolver acquires this\n         lock, then places the\
    \ RRs to be cached into the queue.  The\n         name server maintenance procedure\
    \ periodically acquires this\n         lock and adds the queue information to\
    \ the cache.  The\n         rationale for this procedure is that it allows the\
    \ resolver to\n         operate with read-only access to the shared database,\
    \ and\n         allows the update process to batch cache additions and the\n \
    \        associated costs for inversion calculations.  The name server\n     \
    \    maintenance procedure must take appropriate precautions to\n         avoid\
    \ problems with data already in the cache, inversions, etc.\n      This organization\
    \ solves several difficulties:\n         When searching the domain space for the\
    \ answer to a query, a\n         name server can restrict its search for authoritative\
    \ data to\n         that tree that matches the most labels on the right side of\
    \ the\n         domain name of interest.\n         Since updates to a zone must\
    \ be atomic with respect to\n         searches, maintenance operations can simply\
    \ acquire the main\n         lock, insert a new copy of a particular zone without\
    \ disturbing\n         other zones, and then release the storage used by the old\
    \ copy.\n         Assuming a central table pointing to valid zone trees, this\n\
    \         operation can be a simple pointer swap.\n                         Domain\
    \ Names - Implementation and Specification\n         TTL management of zones can\
    \ be performed using the SOA record\n         for the zone.  This avoids potential\
    \ difficulties if individual\n         RRs in a zone could be timed out separately.\
    \  This issue is\n         discussed further in the maintenance section.\n   Query\
    \ processing\n      The following algorithm outlines processing that takes place\
    \ at a\n      name server when a query arrives:\n      1. Search the list of zones\
    \ to find zones which have the same\n         class as the QCLASS field in the\
    \ query and have a top domain\n         name that matches the right end of the\
    \ QNAME field.  If there\n         are none, go to step 2.  If there are more\
    \ than one, pick the\n         zone that has the longest match and go to step\
    \ 3.\n      2. Since the zone search failed, the only possible RRs are\n     \
    \    contained in the non-authoritative tree.  Search the cache tree\n       \
    \  for the NS record that has the same class as the QCLASS field\n         and\
    \ the largest right end match for domain name.  Add the NS\n         record or\
    \ records to the authority section of the response.  If\n         the cache tree\
    \ has RRs that are pertinent to the question\n         (domain names match, classes\
    \ agree, not timed-out, and the type\n         field is relevant to the QTYPE),\
    \ copy these RRs into the answer\n         section of the response.  The name\
    \ server may also search the\n         cache queue.  Go to step 4.\n      3. Since\
    \ this zone is the best match, the zone in which QNAME\n         resides is either\
    \ this zone or a zone to which this zone will\n         directly or indirectly\
    \ delegate authority.  Search down the\n         tree looking for a NS RR or the\
    \ node specified by QNAME.\n            If the node exists and has no NS record,\
    \ copy the relevant\n            RRs to the answer section of the response and\
    \ go to step 4.\n            If a NS RR is found, either matching a part or all\
    \ of QNAME,\n            then QNAME is in a delegated zone outside of this zone.\
    \  If\n            so, copy the NS record or records into the authority section\n\
    \            of the response, and search the remainder of the zone for an\n  \
    \          A type record corresponding to the NS reference.  If the A\n      \
    \      record is found, add it to the additional section.  Go to\n           \
    \ step 2.\n            If the node is not found and a NS is not found, there is\
    \ no\n            such name; set the Name error bit in the response and exit.\n\
    \      4. When this step is reached, the answer and authority sections\n     \
    \    are complete.  What remains is to complete the additional\n         section.\
    \  This procedure is only possible if the name server\n                      \
    \   Domain Names - Implementation and Specification\n         knows the data formats\
    \ implied by the class of records in the\n         answer and authority sections.\
    \  Hence this procedure is class\n         dependent.  Appendix 3 discusses this\
    \ procedure for Internet\n         class data.\n      While this algorithm deals\
    \ with typical queries and databases,\n      several additions are required that\
    \ will depend on the database\n      supported by the name server:\n      QCLASS=*\n\
    \         Special procedures are required when the QCLASS of the query is\n  \
    \       \"*\".  If the database contains several classes of data, the\n      \
    \   query processing steps above are performed separately for each\n         CLASS,\
    \ and the results are merged into a single response.  The\n         name error\
    \ condition is not meaningful for a QCLASS=* query.\n         If the requestor\
    \ wants this information, it must test each\n         class independently.\n \
    \        If the database is limited to data of a particular class, this\n    \
    \     operation can be performed by simply reseting the authoritative\n      \
    \   bit in the response, and performing the query as if QCLASS was\n         the\
    \ class used in the database.\n      * labels in database RRs\n         Some zones\
    \ will contain default RRs that use * to match in\n         cases where the search\
    \ fails for a particular domain name.  If\n         the database contains these\
    \ records then a failure must be\n         retried using * in place of one or\
    \ more labels of the search\n         key.  The procedure is to replace labels\
    \ from the left with\n         \"*\"s looking for a match until either all labels\
    \ have been\n         replaced, or a match is found.  Note that these records\
    \ can\n         never be the result of caching, so a name server can omit this\n\
    \         processing for zones that don't contain RRs with * in labels,\n    \
    \     or can omit this processing entirely if * never appears in\n         local\
    \ authoritative data.\n   Inverse query processing\n      Name servers that support\
    \ inverse queries can support these\n      operations through exhaustive searches\
    \ of their databases, but\n      this becomes impractical as the size of the database\
    \ increases.\n      An alternative approach is to invert the database according\
    \ to the\n      search key.\n      For name servers that support multiple zones\
    \ and a large amount of\n      data, the recommended approach is separate inversions\
    \ for each\n                         Domain Names - Implementation and Specification\n\
    \      zone.  When a particular zone is changed during a refresh, only\n     \
    \ its inversions need to be redone.\n      Support for transfer of this type of\
    \ inversion may be included in\n      future versions of the domain system, but\
    \ is not supported in this\n      version.\n   Completion query processing\n \
    \     Completion query processing shares many of the same problems in\n      data\
    \ structure design as are found in inverse queries, but is\n      different due\
    \ to the expected high rate of use of top level labels\n      (ie., ARPA, CSNET).\
    \  A name server that wishes to be efficient in\n      its use of memory may well\
    \ choose to invert only occurrences of\n      ARPA, etc. that are below the top\
    \ level, and use a search for the\n      rare case that top level labels are used\
    \ to constrain a\n      completion.\n                         Domain Names - Implementation\
    \ and Specification\n"
- title: NAME SERVER MAINTENANCE
  contents:
  - "NAME SERVER MAINTENANCE\n   Introduction\n      Name servers perform maintenance\
    \ operations on their databases to\n      insure that the data they distribute\
    \ is accurate and timely.  The\n      amount and complexity of the maintenance\
    \ operations that a name\n      server must perform are related to the size, change\
    \ rate, and\n      complexity of the database that the name server manages.\n\
    \      Maintenance operations are fundamentally different for\n      authoritative\
    \ and non-authoritative data.  A name server actively\n      attempts to insure\
    \ the accuracy and timeliness of authoritative\n      data by refreshing the data\
    \ from master copies.  Non-authoritative\n      data is merely purged when its\
    \ time-to-live expires; the name\n      server does not attempt to refresh it.\n\
    \      Although the refreshing scheme is fairly simple to implement, it\n    \
    \  is somewhat less powerful than schemes used in other distributed\n      database\
    \ systems.  In particular, an update to the master does not\n      immediately\
    \ update copies, and should be viewed as gradually\n      percolating though the\
    \ distributed database.  This is adequate for\n      the vast majority of applications.\
    \  In situations where timliness\n      is critical, the master name server can\
    \ prohibit caching of copies\n      or assign short timeouts to copies.\n   Conceptual\
    \ model of maintenance operations\n      The vast majority of information in the\
    \ domain system is derived\n      from master files scattered among hosts that\
    \ implement name\n      servers; some name servers will have no master files,\
    \ other name\n      servers will have one or more master files.  Each master file\n\
    \      contains the master data for a single zone of authority rather\n      than\
    \ data for the whole domain name space.  The administrator of a\n      particular\
    \ zone controls that zone by updating its master file.\n      Master files and\
    \ zone copies from remote servers may include RRs\n      that are outside of the\
    \ zone of authority when a NS record\n      delegates authority to a domain name\
    \ that is a descendant of the\n      domain name at which authority is delegated.\
    \  These forward\n      references are a problem because there is no reasonable\
    \ method to\n      guarantee that the A type records for the delegatee are available\n\
    \      unless they can somehow be attached to the NS records.\n      For example,\
    \ suppose the ARPA zone delegates authority at\n      MIT.ARPA, and states that\
    \ the name server is on AI.MIT.ARPA.  If a\n      resolver gets the NS record\
    \ but not the A type record for\n      AI.MIT.ARPA, it might try to ask the MIT\
    \ name server for the\n      address of AI.MIT.ARPA.\n                       \
    \  Domain Names - Implementation and Specification\n      The solution is to allow\
    \ type A records that are outside of the\n      zone of authority to be copied\
    \ with the zone.  While these records\n      won't be found in a search for the\
    \ A type record itself, they can\n      be protected by the zone refreshing system,\
    \ and will be passed\n      back whenever the name server passes back a referral\
    \ to the\n      corresponding NS record.  If a query is received for the A record,\n\
    \      the name server will pass back a referral to the name server with\n   \
    \   the A record in the additional section, rather than answer\n      section.\n\
    \      The only exception to the use of master files is a small amount of\n  \
    \    data stored in boot files.  Boot file data is used by name servers\n    \
    \  to provide enough resource records to allow zones to be imported\n      from\
    \ foreign servers (e.g. the address of the server), and to\n      establish the\
    \ name and address of root servers.  Boot file records\n      establish the initial\
    \ contents of the cache tree, and hence can be\n      overridden by later loads\
    \ of authoritative data.\n      The data in a master file first becomes available\
    \ to users of the\n      domain name system when it is loaded by the corresponding\
    \ name\n      server.  By definition, data from a master file is authoritative.\n\
    \      Other name servers which wish to be authoritative for a particular\n  \
    \    zone do so by transferring a copy of the zone from the name server\n    \
    \  which holds the master copy using a virtual circuit.  These copies\n      include\
    \ parameters which specify the conditions under which the\n      data in the copy\
    \ is authoritative.  In the most common case, the\n      conditions specify a\
    \ refresh interval and policies to be followed\n      when the refresh operation\
    \ cannot be performed.\n      A name server may acquire multiple zones from different\
    \ name\n      servers and master files, but the name server must maintain each\n\
    \      zone separately from others and from non-authoritative data.\n      When\
    \ the refresh interval for a particular zone copy expires, the\n      name server\
    \ holding the copy must consult the name server that\n      holds the master copy.\
    \  If the data in the zone has not changed,\n      the master name server instructs\
    \ the copy name server to reset the\n      refresh interval.  If the data has\
    \ changed, the master passes a\n      new copy of the zone and its associated\
    \ conditions to the copy\n      name server.  Following either of these transactions,\
    \ the copy\n      name server begins a new refresh interval.\n      Copy name\
    \ servers must also deal with error conditions under which\n      they are unable\
    \ to communicate with the name server that holds the\n      master copy of a particular\
    \ zone.  The policies that a copy name\n      server uses are determined by other\
    \ parameters in the conditions\n      distributed with every copy.  The conditions\
    \ include a retry\n      interval and a maximum holding time.  When a copy name\
    \ server is\n                         Domain Names - Implementation and Specification\n\
    \      unable to establish communications with a master or is unable to\n    \
    \  complete the refresh transaction, it must retry the refresh\n      operation\
    \ at the rate specified by the retry interval.  This retry\n      interval will\
    \ usually be substantially shorter than the refresh\n      interval.  Retries\
    \ continue until the maximum holding time is\n      reached.  At that time the\
    \ copy name server must assume that its\n      copy of the data for the zone in\
    \ question is no longer\n      authoritative.\n      Queries must be processed\
    \ while maintenance operations are in\n      progress because a zone transfer\
    \ can take a long time.  However,\n      to avoid problems caused by access to\
    \ partial databases, the\n      maintenance operations create new copies of data\
    \ rather than\n      directly modifying the old copies.  When the new copy is\
    \ complete,\n      the maintenance process locks out queries for a short time\
    \ using\n      the main lock, and switches pointers to replace the old data with\n\
    \      the new.  After the pointers are swapped, the maintenance process\n   \
    \   unlocks the main lock and reclaims the storage used by the old\n      copy.\n\
    \   Name server data structures and top level logic\n      The name server must\
    \ multiplex its attention between multiple\n      activities.  For example, a\
    \ name server should be able to answer\n      queries while it is also performing\
    \ refresh activities for a\n      particular zone.  While it is possible to design\
    \ a name server\n      that devotes a separate process to each query and refresh\
    \ activity\n      in progress, the model described in this memo is based on the\n\
    \      assumption that there is a single process performing all\n      maintenance\
    \ operations, and one or more processes devoted to\n      handling queries.  The\
    \ model also assumes the existence of shared\n      memory for several control\
    \ structures, the domain database, locks,\n      etc.\n      The model name server\
    \ uses the following files and shared data\n      structures:\n         1. A configuration\
    \ file that describes the master and boot\n            files which the name server\
    \ should load and the zones that\n            the name server should attempt to\
    \ load from foreign name\n            servers.  This file establishes the initial\
    \ contents of the\n            status table.\n         2. Domain data files that\
    \ contain master and boot data to be\n            loaded.\n         3. A status\
    \ table that is derived from the configuration file.\n            Each entry in\
    \ this table describes a source of data.  Each\n            entry has a zone number.\
    \  The zone number is zero for\n                         Domain Names - Implementation\
    \ and Specification\n            non-authoritative sources; authoritative sources\
    \ are\n            assigned separate non-zero numbers.\n         4. The shared\
    \ database that holds the domain data.  This\n            database is assumed\
    \ to be organized in some sort of tree\n            structure paralleling the\
    \ domain name space, with a list of\n            resource records attached to\
    \ each node and leaf in the tree.\n            The elements of the resource record\
    \ list need not contain\n            the exact data present in the corresponding\
    \ output format,\n            but must contain data sufficient to create the output\n\
    \            format; for example, these records need not contain the\n       \
    \     domain name that is associated with the resource because\n            that\
    \ name can be derived from the tree structure.  Each\n            resource record\
    \ also internal data that the name server uses\n            to organize its data.\n\
    \         5. Inversion data structures that allow the name server to\n       \
    \     process inverse queries and completion queries.  Although\n            many\
    \ structures could be used, the implementation described\n            in this\
    \ memo supposes that there is one array for every\n            inversion that\
    \ the name server can handle.  Each array\n            contains a list of pointers\
    \ to resource records such that\n            the order of the inverted quantities\
    \ is sorted.\n         6. The main and cache queue locks\n         7. The cache\
    \ queue\n      The maintenance process begins by loading the status table from\n\
    \      the configuration file.  It then periodically checks each entry,\n    \
    \  to see if its refresh interval has elapsed.  If not, it goes on to\n      the\
    \ next entry.  If so, it performs different operations depending\n      on the\
    \ entry:\n         If the entry is for zone 0, or the cache tree, the maintenance\n\
    \         process checks to see if additions or deletions are required.\n    \
    \     Additions are acquired from the cache queue using the cache\n         queue\
    \ lock.  Deletions are detected using TTL checks.  If any\n         changes are\
    \ required, the maintenance process recalculates\n         inversion data structures\
    \ and then alters the cache tree under\n         the protection of the main lock.\
    \  Whenever the maintenance\n         process modifies the cache tree, it resets\
    \ the refresh interval\n         to the minimum of the contained TTLs and the\
    \ desired time\n         interval for cache additions.\n         If the entry\
    \ is not zone 0, and the entry refers to a local\n         file, the maintenance\
    \ process checks to see if the file has\n         been modified since its last\
    \ load.  If so the file is reloaded\n         using the procedures specified under\
    \ \"Name server file\n                         Domain Names - Implementation and\
    \ Specification\n         loading\".  The refresh interval is reset to that specified\
    \ in\n         the SOA record if the file is a master file.\n         If the entry\
    \ is for a remote master file, the maintenance\n         process checks for a\
    \ new version using the procedure described\n         in \"Names server remote\
    \ zone transfer\".\n   Name server file loading\n      Master files are kept in\
    \ text form for ease of editing by system\n      maintainers.  These files are\
    \ not exchanged by name servers; name\n      servers use the standard message\
    \ format when transferring zones.\n      Organizations that want to have a domain,\
    \ but do not want to run a\n      name server, can use these files to supply a\
    \ domain definition to\n      another organization that will run a name server\
    \ for them.  For\n      example, if organization X wants a domain but not a name\
    \ server,\n      it can find another organization, Y, that has a name server and\
    \ is\n      willing to provide service for X.  Organization X defines domain X\n\
    \      via the master file format and ships a copy of the master file to\n   \
    \   organization Y via mail, FTP, or some other method.  A system\n      administrator\
    \ at Y configures Y's name server to read in X's file\n      and hence support\
    \ the X domain.  X can maintain the master file\n      using a text editor and\
    \ send new versions to Y for installation.\n      These files have a simple line-oriented\
    \ format, with one RR per\n      line.  Fields are separated by any combination\
    \ of blanks and tab\n      characters.  Tabs are treated the same as spaces; in\
    \ the following\n      discussion the term \"blank\" means either a tab or a blank.\
    \  A line\n      can be either blank (and ignored), a RR, or a $INCLUDE line.\n\
    \      If a RR line starts with a domain name, that domain name is used\n    \
    \  to specify the location in the domain space for the record, i.e.\n      the\
    \ owner.  If a RR line starts with a blank, it is loaded into\n      the location\
    \ specified by the most recent location specifier.\n      The location specifiers\
    \ are assumed to be relative to some origin\n      that is provided by the user\
    \ of a file unless the location\n      specifier contains the root label.  This\
    \ provides a convenient\n      shorthand notation, and can also be used to prevent\
    \ errors in\n      master files from propagating into other zones.  This feature\
    \ is\n      particularly useful for master files imported from other sites.\n\
    \      An include line begins with $INCLUDE, starting at the first line\n    \
    \  position, and is followed by a local file name and an optional\n      offset\
    \ modifier.  The filename follows the appropriate local\n      conventions.  The\
    \ offset is one or more labels that are added to\n      the offset in use for\
    \ the file that contained the $INCLUDE.  If\n      the offset is omitted, the\
    \ included file is loaded using the\n                         Domain Names - Implementation\
    \ and Specification\n      offset of the file that contained the $INCLUDE command.\
    \  For\n      example, a file being loaded at offset ARPA might contain the\n\
    \      following lines:\n                $INCLUDE <subsys>isi.data ISI       \
    \    \n                $INCLUDE <subsys>addresses.data         \n      The first\
    \ line would be interpreted to direct loading of the file\n      <subsys>isi.data\
    \ at offset ISI.ARPA.  The second line would be\n      interpreted as a request\
    \ to load data at offset ARPA.\n      Note that $INCLUDE commands do not cause\
    \ data to be loaded into a\n      different zone or tree; they are simply ways\
    \ to allow data for a\n      given zone to be organized in separate files.  For\
    \ example,\n      mailbox data might be kept separately from host data using this\n\
    \      mechanism.\n      Resource records are entered as a sequence of fields\
    \ corresponding\n      to the owner name, TTL, CLASS, TYPE and RDATA components.\
    \  (Note\n      that this order is different from the order used in examples and\n\
    \      the order used in the actual RRs; the given order allows easier\n     \
    \ parsing and defaulting.)\n         The owner name is derived from the location\
    \ specifier.\n         The TTL field is optional, and is expressed as a decimal\n\
    \         number.  If omitted TTL defaults to zero.\n         The CLASS field\
    \ is also optional; if omitted the CLASS defaults\n         to the most recent\
    \ value of the CLASS field in a previous RR.\n         The RDATA fields depend\
    \ on the CLASS and TYPE of the RR.  In\n         general, the fields that make\
    \ up RDATA are expressed as decimal\n         numbers or as domain names.  Some\
    \ exceptions exist, and are\n         documented in the RDATA definitions in Appendicies\
    \ 2 and 3 of\n         this memo.\n      Because CLASS and TYPE fields don't contain\
    \ any common\n      identifiers, and because CLASS and TYPE fields are never decimal\n\
    \      numbers, the parse is always unique.\n      Because these files are text\
    \ files several special encodings are\n      necessary to allow arbitrary data\
    \ to be loaded.  In particular:\n         .    A free standing dot is used to\
    \ refer to the current domain\n              name.\n         @    A free standing\
    \ @ is used to denote the current origin.\n                         Domain Names\
    \ - Implementation and Specification\n         ..   Two free standing dots represent\
    \ the null domain name of\n              the root.\n         \\X   where X is\
    \ any character other than a digit (0-9), is used\n              to quote that\
    \ character so that its special meaning does\n              not apply.  For example,\
    \ \"\\.\" can be used to place a dot\n              character in a label.\n  \
    \       \\DDD where each D is a digit is the octet corresponding to the\n    \
    \          decimal number described by DDD.  The resulting octet is\n        \
    \      assumed to be text and is not checked for special meaning.\n         (\
    \ )  Parentheses are used to group data that crosses a line\n              boundary.\
    \  In effect, line terminations are not recognized\n              within parentheses.\n\
    \         ;    Semicolon is used to start a comment; the remainder of the\n  \
    \            line is ignored.\n   Name server file loading example\n      A name\
    \ server for F.ISI.ARPA , serving as an authority for the\n      ARPA and ISI.ARPA\
    \ domains, might use a boot file and two master\n      files.  The boot file initializes\
    \ some non-authoritative data, and\n      would be loaded without an origin:\n\
    \    ..              9999999 IN      NS      B.ISI.ARPA               \n     \
    \               9999999 CS      NS      UDEL.CSNET               \n    B.ISI.ARPA\
    \      9999999 IN      A       10.3.0.52                \n    UDEL.CSNET     \
    \ 9999999 CS      A       302-555-0000             \n      This file loads non-authoritative\
    \ data which provides the\n      identities and addresses of root name servers.\
    \  The first line\n      contains a NS RR which is loaded at the root; the second\
    \ line\n      starts with a blank, and is loaded at the most recent location\n\
    \      specifier, in this case the root; the third and fourth lines load\n   \
    \   RRs at B.ISI.ARPA and UDEL.CSNET, respectively.  The timeouts are\n      set\
    \ to high values (9999999) to prevent this data from being\n      discarded due\
    \ to timeout.\n      The first master file loads authoritative data for the ARPA\n\
    \      domain.  This file is designed to be loaded with an origin of\n      ARPA,\
    \ which allows the location specifiers to omit the trailing\n      .ARPA labels.\n\
    \                         Domain Names - Implementation and Specification\n  \
    \  @   IN  SOA     F.ISI.ARPA       Action.E.ISI.ARPA (             \n       \
    \                              20     ; SERIAL                 \n            \
    \                         3600   ; REFRESH                \n                 \
    \                    600    ; RETRY                  \n                      \
    \               3600000; EXPIRE                 \n                           \
    \          60)    ; MINIMUM                \n            NS      F.ISI.ARPA ;\
    \ F.ISI.ARPA is a name server for ARPA\n            NS      A.ISI.ARPA ; A.ISI.ARPA\
    \ is a name server for ARPA\n    MIT     NS      AI.MIT.ARPA; delegation to MIT\
    \ name server       \n    ISI     NS      F.ISI.ARPA ; delegation to ISI name\
    \ server       \n    UDEL    MD      UDEL.ARPA                               \
    \         \n            A       10.0.0.96                                    \
    \    \n    NBS     MD      NBS.ARPA                                         \n\
    \            A       10.0.0.19                                        \n    DTI\
    \     MD      DTI.ARPA                                         \n            A\
    \       10.0.0.12                                        \n    AI.MIT  A     \
    \  10.2.0.6                                         \n    F.ISI   A       10.2.0.52\
    \                                        \n      The first group of lines contains\
    \ the SOA record and its\n      parameters, and identifies name servers for this\
    \ zone and for\n      delegated zones.  The Action.E.ISI.ARPA field is a mailbox\n\
    \      specification for the responsible person for the zone, and is the\n   \
    \   domain name encoding of the mail destination Action@E.ISI.ARPA.\n      The\
    \ second group specifies data for domain names within this zone.\n      The last\
    \ group has forward references for name server address\n      resolution for \
    \ AI.MIT.ARPA and F.ISI.ARPA.  This data is not\n      technically within the\
    \ zone, and will only be used for additional\n      record resolution for NS records\
    \ used in referrals.  However, this\n      data is protected by the zone timeouts\
    \ in the SOA, so it will\n      persist as long as the NS references persist.\n\
    \      The second master file defines the ISI.ARPA environment, and is\n     \
    \ loaded with an origin of ISI.ARPA:\n    @   IN  SOA     F.ISI.ARPA      Action\\\
    .ISI.E.ISI.ARPA (         \n                                     20     ; SERIAL\
    \                 \n                                     7200   ; REFRESH    \
    \            \n                                     600    ; RETRY           \
    \       \n                                     3600000; EXPIRE               \
    \  \n                                     60)    ; MINIMUM                \n \
    \           NS      F.ISI.ARPA ; F.ISI.ARPA is a name server         \n    A \
    \      A       10.1.0.32                                        \n           \
    \ MD      A.ISI.ARPA                                       \n            MF  \
    \    F.ISI.ARPA                                       \n    B       A       10.3.0.52\
    \                                        \n            MD      B.ISI.ARPA    \
    \                                   \n                         Domain Names -\
    \ Implementation and Specification\n            MF      F.ISI.ARPA           \
    \                            \n    F       A       10.2.0.52                 \
    \                       \n            MD      F.ISI.ARPA                     \
    \                  \n            MF      A.ISI.ARPA                          \
    \             \n    $INCLUDE <SUBSYS>ISI-MAILBOXES.TXT                       \
    \        \n      Where the file <SUBSYS>ISI-MAILBOXES.TXT is:\n    MOE     MB\
    \      F.ISI.ARPA                                       \n    LARRY   MB     \
    \ A.ISI.ARPA                                       \n    CURLEY  MB      B.ISI.ARPA\
    \                                       \n    STOOGES MB      B.ISI.ARPA     \
    \                                  \n            MG      MOE.ISI.ARPA        \
    \                             \n            MG      LARRY.ISI.ARPA           \
    \                        \n            MG      CURLEY.ISI.ARPA               \
    \                   \n      Note the use of the \\ character in the SOA RR to\
    \ specify the\n      responsible person mailbox \"Action.ISI@E.ISI.ARPA\".\n \
    \  Name server remote zone transfer\n      When a name server needs to make an\
    \ initial copy of a zone or test\n      to see if a existing zone copy should\
    \ be refreshed, it begins by\n      attempting to open a virtual circuit to the\
    \ foreign name server.\n      If this open attempt fails, and this was an initial\
    \ load attempt,\n      it schedules a retry and exits.  If this was a refresh\
    \ operation,\n      the name server tests the status table to see if the maximum\n\
    \      holding time derived from the SOA EXPIRE field has elapsed.  If\n     \
    \ not, the name server schedules a retry.  If the maximum holding\n      time\
    \ has expired, the name server invalidates the zone in the\n      status table,\
    \ and scans all resource records tagged with this zone\n      number.  For each\
    \ record it decrements TTL fields by the length of\n      time since the data\
    \ was last refreshed.  If the new TTL value is\n      negative, the record is\
    \ deleted.  If the TTL value is still\n      positive, it moves the RR to the\
    \ cache tree and schedules a retry.\n      If the open attempt succeeds, the name\
    \ server sends a query to the\n      foreign name server in which QTYPE=SOA, QCLASS\
    \ is set according to\n      the status table information from the configuration\
    \ file, and\n      QNAME is set to the domain name of the zone of interest.\n\
    \      The foreign name server will return either a SOA record indicating\n  \
    \    that it has the zone or an error.  If an error is detected, the\n      virtual\
    \ circuit is closed, and the failure is treated in the same\n      way as if the\
    \ open attempt failed.\n      If the SOA record is returned and this was a refresh,\
    \ rather than\n      an initial load of the zone, the name server compares the\
    \ SERIAL\n                         Domain Names - Implementation and Specification\n\
    \      field in the new SOA record with the SERIAL field in the SOA\n      record\
    \ of the existing zone copy.  If these values match, the zone\n      has not been\
    \ updated since the last copy and hence there is no\n      reason to recopy the\
    \ zone.  In this case the name server resets\n      the times in the existing\
    \ SOA record and closes the virtual\n      circuit to complete the operation.\n\
    \      If this is initial load, or the SERIAL fields were different, the\n   \
    \   name server requests a copy of the zone by sending the foreign\n      name\
    \ server an AXFR query which specifies the zone by its QCLASS\n      and QNAME\
    \ fields.\n      When the foreign name server receives the AXFR request, it sends\n\
    \      each node from the zone to the requestor in a separate message.\n     \
    \ It begins with the node that contains the SOA record, walks the\n      tree\
    \ in breadth-first order, and completes the transfer by\n      resending the node\
    \ containing the SOA record.\n      Several error conditions are possible:\n \
    \        If the AXFR request cannot be matched to a SOA, the foreign\n       \
    \  name server will return a single message in response that does\n         not\
    \ contain the AXFR request.  (The normal SOA query preceding\n         the AXFR\
    \ is designed to avoid this condition, but it is still\n         possible.)\n\
    \         The foreign name server can detect an internal error or detect\n   \
    \      some other condition (e.g. system going down, out of resources,\n     \
    \    etc.) that forces the transfer to be aborted.  If so, it sends\n        \
    \ a message with the \"Server failure\" condition set.  If the AXFR\n        \
    \ can be immediately retried with some chance of success, it\n         leaves\
    \ the virtual open; otherwise it initiates a close.\n         If the foreign name\
    \ server doesn't wish to perform the\n         operation for policy reasons (i.e.\
    \ the system administrator\n         wishes to forbid zone copies), the foreign\
    \ server returns a\n         \"Refused\" condition.\n      The requestor receives\
    \ these records and builds a new tree.  This\n      tree is not yet in the status\
    \ table, so its data are not used to\n      process queries.  The old copy of\
    \ the zone, if any, may be used to\n      satisfy request while the transfer is\
    \ in progress.\n      When the requestor receives the second copy of the SOA node,\
    \ it\n      compares the SERIAL field in the first copy of the SOA against the\n\
    \      SERIAL field in the last copy of the SOA record.  If these don't\n    \
    \  match, the foreign server updated its zone while the transfer was\n      in\
    \ progress.  In this case the requestor repeats the AXFR request\n      to acquire\
    \ the newer version.\n                         Domain Names - Implementation and\
    \ Specification\n      If the AXFR transfer eventually succeeds, the name server\
    \ closes\n      the virtual circuit and and creates new versions of inversion\
    \ data\n      structures for this zone.  When this operation is complete, the\n\
    \      name server acquires the main lock in write mode and then replaces\n  \
    \    any old copy of the zone and inversion data structures with new\n      ones.\
    \  The name server then releases the main lock, and can\n      reclaim the storage\
    \ used by the old copy.\n      If an error occurs during the AXFR transfer, the\
    \ name server can\n      copy any partial information into its cache tree if it\
    \ wishes,\n      although it will not normally do so if the zone transfer was\
    \ a\n      refresh rather than an initial load.\n                         Domain\
    \ Names - Implementation and Specification\n"
- title: RESOLVER ALGORITHMS
  contents:
  - "RESOLVER ALGORITHMS\n   Operations\n      Resolvers have a great deal of latitude\
    \ in the semantics they\n      allow in user calls.  For example, a resolver might\
    \ support\n      different user calls that specify whether the returned information\n\
    \      must be from and authoritative name server or not.  Resolvers are\n   \
    \   also responsible for enforcement of any local restrictions on\n      access,\
    \ etc.\n      In any case, the resolver will transform the user query into a\n\
    \      number of shared database accesses and queries to remote name\n      servers.\
    \  When a user requests a resource associated with a\n      particular domain\
    \ name, the resolver will execute the following\n      steps:\n      1. The resolver\
    \ first checks the local shared database, if any,\n         for the desired information.\
    \  If found, it checks the\n         applicable timeout.  If the timeout check\
    \ succeeds, the\n         information is used to satisfy the user request.  If\
    \ not, the\n         resolver goes to step 2.\n      2. In this step, the resolver\
    \ consults the shared database for the\n         name server that most closely\
    \ matches the domain name in the\n         user query.  Multiple redundant name\
    \ servers may be found.  The\n         resolver goes to step 3.\n      3. In this\
    \ step the resolver chooses one of the available name\n         servers and sends\
    \ off a query.  If the query fails, it tries\n         another name server.  If\
    \ all fail, an error indication is\n         returned to the user.  If a reply\
    \ is received the resolver adds\n         the returned RRs to its database and\
    \ goes to step 4.\n      4. In this step, the resolver interprets the reply. \
    \ If the reply\n         contains the desired information, the resolver returns\
    \ the\n         information to the user.  The the reply indicates that the\n \
    \        domain name in the user query doesn't exist, then the resolver\n    \
    \     returns an error to the user.  If the reply contains a\n         transient\
    \ name server failure, the resolver can either wait and\n         retry the query\
    \ or go back to step 3 and try a different name\n         server.  If the reply\
    \ doesn't contain the desired information,\n         but does contain a pointer\
    \ to a closer name server, the\n         resolver returns to step 2, where the\
    \ closer name servers will\n         be queried.\n      Several modifications\
    \ to this algorithm are possible.  A resolver\n      may not support a local cache\
    \ and instead only cache information\n      during the course of a single user\
    \ request, discarding it upon\n                         Domain Names - Implementation\
    \ and Specification\n      completion.  The resolver may also find that a datagram\
    \ reply was\n      truncated, and open a virtual circuit so that the complete\
    \ reply\n      can be recovered.\n      Inverse and completion queries must be\
    \ treated in an\n      environment-sensitive manner, because the domain system\
    \ doesn't\n      provide a method for guaranteeing that it can locate the correct\n\
    \      information.  The typical choice will be to configure a resolver\n    \
    \  to use a particular set of known name servers for inverse queries.\n      \
    \                   Domain Names - Implementation and Specification\n"
- title: DOMAIN SUPPORT FOR MAIL
  contents:
  - "DOMAIN SUPPORT FOR MAIL\n   Introduction\n      Mail service is a particularly\
    \ sensitive issue for users of the\n      domain system because of the lack of\
    \ a consistent system for\n      naming mailboxes and even hosts, and the need\
    \ to support continued\n      operation of existing services.  This section discusses\
    \ an\n      evolutionary approach for adding consistent domain name support\n\
    \      for mail.\n      The crucial issue is deciding on the types of binding\
    \ to be\n      supported.  Most mail systems specify a mail destination with a\n\
    \      two part construct such as X@Y.  The left hand side, X, is an\n      string,\
    \ often a user or account, and Y is a string, often a host.\n      This section\
    \ refers to the part on the left, i.e. X, as the local\n      part, and refers\
    \ to the part on the right, i.e. Y, as the global\n      part.\n      Most existing\
    \ mail systems route mail based on the global part; a\n      mailer with mail\
    \ to deliver to X@Y will decide on the host to be\n      contacted using only\
    \ Y.  We refer to this type of binding as\n      \"agent binding\".\n        \
    \ For example, mail addressed to Mockapetris@ISIF is delivered to\n         host\
    \ USC-ISIF (USC-ISIF is the official name for the host\n         specified by\
    \ nickname ISIF).\n      More sophisticated mail systems use both the local and\
    \ global\n      parts, i.e. both X and Y to determine which host should receive\n\
    \      the mail.  These more sophisticated systems usually separate the\n    \
    \  binding of the destination to the host from the actual delivery.\n      This\
    \ allows the global part to be a generic name rather than\n      constraining\
    \ it to a single host.  We refer to this type of\n      binding as \"mailbox binding\"\
    .\n         For example, mail addressed to Mockapetris@ISI might be bound\n  \
    \       to host F.ISI.ARPA, and subsequently delivered to that host,\n       \
    \  while mail for Cohen@ISI might be bound to host B.ISI.ARPA.\n      The domain\
    \ support for mail consists of two levels of support,\n      corresponding to\
    \ these two binding models.\n         The first level, agent binding, is compatible\
    \ with existing\n         ARPA Internet mail procedures and uses maps a global\
    \ part onto\n         one or more hosts that will accept the mail.  This type\
    \ of\n         binding uses the MAILA QTYPE.\n         The second level, mailbox\
    \ binding, offers extended services\n                         Domain Names - Implementation\
    \ and Specification\n         that map a local part and a global part onto one\
    \ or more sets\n         of data via the MAILB QTYPE.  The sets of data include\
    \ hosts\n         that will accept the mail, mailing list members  (mail groups),\n\
    \         and mailboxes for reporting errors or requests to change a mail\n  \
    \       group.\n      The domain system encodes the global part of a mail destination\
    \ as\n      a domain name and uses dots in the global part to separate labels\n\
    \      in the encoded domain name.  The domain system encodes the local\n    \
    \  part of a mail destination as a single label, and any dots in this\n      part\
    \ are simply copied into the label.  The domain system forms a\n      complete\
    \ mail destination as the local label concatenated to the\n      domain string\
    \ for the global part.  We call this a mailbox.\n         For example, the mailbox\
    \ Mockapetris@F.ISI.ARPA has a global\n         domain name of three labels, F.ISI.ARPA.\
    \  The domain name\n         encoding for the whole mailbox is Mockapetris.F.ISI.ARPA.\
    \  The\n         mailbox Mockapetris.cad@F.ISI.ARPA has the same domain name for\n\
    \         the global part and a 4 label domain name for the mailbox of\n     \
    \    Mockapetris\\.cad.F.ISI.ARPA (the \\ is not stored in the label,\n      \
    \   its merely used to denote the \"quoted\" dot).\n      It is anticipated that\
    \ the Internet system will adopt agent\n      binding as part of the initial implementation\
    \ of the domain\n      system, and that mailbox binding will eventually become\
    \ the\n      preferred style as organizations convert their mail systems to the\n\
    \      new style.  To facilitate this approach, the domain information\n     \
    \ for these two binding styles is organized to allow a requestor to\n      determine\
    \ which types of support are available, and the\n      information is kept in\
    \ two disjoint classes.\n   Agent binding\n      In agent binding, a mail system\
    \ uses the global part of the mail\n      destination as a domain name, with dots\
    \ denoting structure.  The\n      domain name is resolved using a MAILA query\
    \ which return MF and MD\n      RRs to specify the domain name of the appropriate\
    \ host to receive\n      the mail.  MD (Mail delivery) RRs specify hosts that\
    \ are expected\n      to have the mailbox in question; MF (Mail forwarding) RRs\
    \ specify\n      hosts that are expected to be intermediaries willing to accept\
    \ the\n      mail for eventual forwarding.  The hosts are hints, rather than\n\
    \      definite answers, since the query is made without the full mail\n     \
    \ destination specification.\n      For example, mail for MOCKAPETRIS@F.ISI.ARPA\
    \ would result in a\n      query with QTYPE=MAILA and QNAME=F.ISI.ARPA, which\
    \ might return\n      two RRs:\n                         Domain Names - Implementation\
    \ and Specification\n                      F.ISI.ARPA MD IN F.ISI.ARPA\n     \
    \                 F.ISI.ARPA MF IN A.ISI.ARPA\n      The mailer would interpret\
    \ these to mean that the mail agent on\n      F.ISI.ARPA should be able to deliver\
    \ the mail directly, but that\n      A.ISI.ARPA is willing to accept the mail\
    \ for probable forwarding.\n      Using this system, an organization could implement\
    \ a system that\n      uses organization names for global parts, rather than the\
    \ usual\n      host names, but all mail for the organization would be routed the\n\
    \      same, regardless of its local part.  Hence and organization with\n    \
    \  many hosts would expect to see many forwarding operations.\n   Mailbox binding\n\
    \      In mailbox binding, the mailer uses the entire mail destination\n     \
    \ specification to construct a domain name.  The encoded domain name\n      for\
    \ the mailbox is used as the QNAME field in a QTYPE=MAILB query.\n      Several\
    \ outcomes are possible for this query:\n      1. The query can return a name\
    \ error indicating that the mailbox\n         does not exist as a domain name.\n\
    \         In the long term this would indicate that the specified mailbox\n  \
    \       doesn't exist.  However, until the use of mailbox binding is\n       \
    \  universal, this error condition should be interpreted to mean\n         that\
    \ the organization identified by the global part does not\n         support mailbox\
    \ binding.  The appropriate procedure is to\n         revert to agent binding\
    \ at this point.\n      2. The query can return a Mail Rename (MR) RR.\n     \
    \    The MR RR carries new mailbox specification in its RDATA field.\n       \
    \  The mailer should replace the old mailbox with the new one and\n         retry\
    \ the operation.\n      3. The query can return a MB RR.\n         The MB RR carries\
    \ a domain name for a host in its RDATA field.\n         The mailer should deliver\
    \ the message to that host via whatever\n         protocol is applicable, e.g.\
    \ SMTP.\n      4. The query can return one or more Mail Group (MG) RRs.\n    \
    \     This condition means that the mailbox was actually a mailing\n         list\
    \ or mail group, rather than a single mailbox.  Each MG RR\n         has a RDATA\
    \ field that identifies a mailbox that is a member of\n                      \
    \   Domain Names - Implementation and Specification\n         the group.  The\
    \ mailer should deliver a copy of the message to\n         each member.\n    \
    \  5. The query can return a MB RR as well as one or more MG RRs.\n         This\
    \ condition means the the mailbox was actually a mailing\n         list.  The\
    \ mailer can either deliver the message to the host\n         specified by the\
    \ MB RR, which will in turn do the delivery to\n         all members, or the mailer\
    \ can use the MG RRs to do the\n         expansion itself.\n      In any of these\
    \ cases, the response may include a Mail Information\n      (MINFO) RR.  This\
    \ RR is usually associated with a mail group, but\n      is legal with a MB. \
    \ The MINFO RR identifies two mailboxes.  One\n      of these identifies a responsible\
    \ person for the original mailbox\n      name.  This mailbox should be used for\
    \ requests to be added to a\n      mail group, etc.  The second mailbox name in\
    \ the MINFO RR\n      identifies a mailbox that should receive error messages\
    \ for mail\n      failures.  This is particularly appropriate for mailing lists\
    \ when\n      errors in member names should be reported to a person other than\n\
    \      the one who sends a message to the list.  New fields may be added\n   \
    \   to this RR in the future.\n                         Domain Names - Implementation\
    \ and Specification\n"
- title: Appendix 1 - Domain Name Syntax Specification
  contents:
  - "Appendix 1 - Domain Name Syntax Specification\n   The preferred syntax of domain\
    \ names is given by the following BNF\n   rules.  Adherence to this syntax will\
    \ result in fewer problems with\n   many applications that use domain names (e.g.,\
    \ mail, TELNET).  Note\n   that some applications use domain names containing\
    \ binary information\n   and hence do not follow this syntax.\n      <domain>\
    \ ::=  <subdomain> | \" \"\n      <subdomain> ::=  <label> | <subdomain> \".\"\
    \ <label>\n      <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]\n      <ldh-str>\
    \ ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n      <let-dig-hyp> ::= <let-dig>\
    \ | \"-\"\n      <let-dig> ::= <letter> | <digit>\n      <letter> ::= any one\
    \ of the 52 alphabetic characters A through Z\n      in upper case and a through\
    \ z in lower case\n      <digit> ::= any one of the ten digits 0 through 9\n \
    \  Note that while upper and lower case letters are allowed in domain\n   names\
    \ no significance is attached to the case.  That is, two names\n   with the same\
    \ spelling but different case are to be treated as if\n   identical.\n   The labels\
    \ must follow the rules for ARPANET host names.  They must\n   start with a letter,\
    \ end with a letter or digit, and have as interior\n   characters only letters,\
    \ digits, and hyphen.  There are also some\n   restrictions on the length.  Labels\
    \ must be 63 characters or less.\n   For example, the following strings identify\
    \ hosts in the ARPA\n   Internet:\n      F.ISI.ARPA     LINKABIT-DCN5.ARPA   \
    \  UCL-TAC.ARPA\n                         Domain Names - Implementation and Specification\n"
- title: Appendix 2 - Field formats and encodings
  contents:
  - "Appendix 2 - Field formats and encodings\n           +-----------------------------------------------+\n\
    \           |                                               |\n           |  \
    \           *****  WARNING  *****             |\n           |                \
    \                               |\n           |  The following formats are preliminary\
    \ and    |\n           | are included for purposes of explanation only.|\n   \
    \        | In particular, new RR types will be added,    |\n           | and the\
    \ size, position, and encoding of       |\n           | fields are subject to\
    \ change.                 |\n           |                                    \
    \           |\n           +-----------------------------------------------+\n\
    \   TYPE values\n      TYPE fields are used in resource records.  Note that these\
    \ types\n      are not the same as the QTYPE fields used in queries, although\
    \ the\n      functions are often similar.\n      TYPE value meaning\n      A \
    \     1   a host address\n      NS     2   an authoritative name server\n    \
    \  MD     3   a mail destination\n      MF     4   a mail forwarder\n      CNAME\
    \  5   the canonical name for an alias\n      SOA    6   marks the start of a\
    \ zone of authority\n      MB     7   a mailbox domain name\n      MG     8  \
    \ a mail group member\n      MR     9   a mail rename domain name\n      NULL\
    \  10   a null RR\n      WKS   11   a well known service description\n      PTR\
    \   12   a domain name pointer\n      HINFO 13   host information\n      MINFO\
    \ 14   mailbox or mail list information\n                         Domain Names\
    \ - Implementation and Specification\n   QTYPE values\n      QTYPE fields appear\
    \ in the question part of a query.  They include\n      the values of TYPE with\
    \ the following additions:\n      AXFR   252 A request for a transfer of an entire\
    \ zone of authority\n      MAILB  253 A request for mailbox-related records (MB,\
    \ MG or MR)\n      MAILA  254 A request for mail agent RRs (MD and MF)\n     \
    \ *      255 A request for all records\n   CLASS values\n      CLASS fields appear\
    \ in resource records\n      CLASS value meaning\n      IN      1   the ARPA Internet\n\
    \      CS      2   the computer science network (CSNET)\n   QCLASS values\n  \
    \    QCLASS fields appear in the question section of a query.  They\n      include\
    \ the values of CLASS with the following additions:\n      *        255 any class\n\
    \                         Domain Names - Implementation and Specification\n  \
    \ Standard resource record formats\n      All RRs have the same top level format\
    \ shown below:\n                                           1  1  1  1  1  1 \n\
    \             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 \n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                                               |\n           /  \
    \                                             /\n           /                \
    \      NAME                     /\n           |                              \
    \                 |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                      TYPE                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                     CLASS                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                      TTL                      |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                   RDLENGTH                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n\
    \           /                     RDATA                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         NAME    - a compressed domain name to which this resource\n\
    \                   record pertains.\n         TYPE    - two octets containing\
    \ one of the RR type codes\n                   defined in Appendix 2.  This field\
    \ specifies the\n                   meaning of the data in the RDATA field.\n\
    \         CLASS   - two octets which specifies the class of the data in\n    \
    \               the RDATA field.\n         TTL     - a 16 bit signed integer that\
    \ specifies the time\n                   interval that the resource record may\
    \ be cached\n                   before the source of the information should again\
    \ be\n                   consulted.  Zero values are interpreted to mean that\n\
    \                   the RR can only be used for the transaction in\n         \
    \          progress, and should not be cached.  For example, SOA\n           \
    \        records are always distributed with a zero TTL to\n                 \
    \  prohibit caching.  Zero values can also be used for\n                   extremely\
    \ volatile data.\n         RDLENGTH- an unsigned 16 bit integer that specifies\
    \ the length\n                   in octets of the RDATA field.\n             \
    \            Domain Names - Implementation and Specification\n         RDATA \
    \ - a variable length string of octets that describes the\n                  \
    \ resource.  The format of this information varies\n                   according\
    \ to the TYPE and CLASS of the resource\n                   record.\n      The\
    \ format of the RDATA field is standard for all classes for the\n      RR types\
    \ NS, MD, MF, CNAME, SOA, MB, MG, MR, PTR, HINFO, MINFO and\n      NULL.  These\
    \ formats are shown below together with the appropriate\n      additional section\
    \ RR processing.\n      CNAME RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                     CNAME                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         CNAME   - A compressed domain name which specifies\
    \ that the\n                   domain name of the RR is an alias for a canonical\n\
    \                   name specified by CNAME.\n         CNAME records cause no\
    \ additional section processing.  The\n         RDATA section of a CNAME line\
    \ in a master file is a standard\n         printed domain name.\n      HINFO RDATA\
    \ format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n     \
    \      /                      CPU                      /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                       OS                      /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         CPU   - A character string which specifies the CPU\
    \ type.  The\n                   character string is represented as a single octet\n\
    \                   length followed by that number of characters.    The\n   \
    \                following standard strings are defined:.\n            PDP-11/70\
    \   C/30        C/70        VAX-11/780   \n            H-316       H-516     \
    \  DEC-2060    DEC-1090T    \n            ALTO        IBM-PC      IBM-PC/XT  \
    \ PERQ         \n            IBM-360/67  IBM-370/145                         \
    \ \n         OS   - A character string which specifies the operating system\n\
    \         type.  The character string is represented as a single octet\n     \
    \                    Domain Names - Implementation and Specification\n       \
    \  length followed by that number of characters.    The following\n         standard\
    \ types are defined:.\n            ASP         AUGUST      BKY         CCP   \
    \       \n            DOS/360     ELF         EPOS        EXEC-8       \n    \
    \        GCOS        GPOS        ITS         INTERCOM     \n            KRONOS\
    \      MCP         MOS         MPX-RT       \n            MULTICS     MVT    \
    \     NOS         NOS/BE       \n            OS/MVS      OS/MVT      RIG     \
    \    RSX11        \n            RSX11M      RT11        SCOPE       SIGNAL   \
    \    \n            SINTRAN     TENEX       TOPS10      TOPS20       \n       \
    \     TSS         UNIX        VM/370      VM/CMS       \n            VMS     \
    \    WAITS                                \n         HINFO records cause no additional\
    \ section processing.\n         HINFO records are used to acquire general information\
    \ about a\n         host.  The main use is for protocols such as FTP that can\
    \ use\n         special procedures when talking between machines or operating\n\
    \         systems of the same type.\n      MB RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                   MADNAME                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         MADNAME - A compressed domain name which specifies\
    \ a host which\n                   has the specified mailbox.\n         MB records\
    \ cause additional section processing which looks up\n         an A type record\
    \ corresponding to MADNAME.  The RDATA section\n         of a MB line in a master\
    \ file is a standard printed domain\n         name.\n      MD RDATA format\n \
    \          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           /   \
    \                MADNAME                     /\n           /                 \
    \                              /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         MADNAME - A compressed domain name which specifies\
    \ a host which\n                         Domain Names - Implementation and Specification\n\
    \                   has a mail agent for the domain which should be able\n   \
    \                to deliver mail for the domain.\n         MD records cause additional\
    \ section processing which looks up\n         an A type record corresponding to\
    \ MADNAME.  The RDATA section\n         of a MD line in a master file is a standard\
    \ printed domain\n         name.\n      MF RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                   MADNAME                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         MADNAME - A compressed domain name which specifies\
    \ a host which\n                   has a mail agent for the domain which will\
    \ accept\n                   mail for forwarding to the domain.\n         MF records\
    \ cause additional section processing which looks up\n         an A type record\
    \ corresponding to MADNAME.  The RDATA section\n         of a MF line in a master\
    \ file is a standard printed domain\n         name.\n      MG RDATA format\n \
    \          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           /   \
    \                MGMNAME                     /\n           /                 \
    \                              /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         MGMNAME - A compressed domain name which specifies\
    \ a mailbox\n                   which is a member of the mail group specified\
    \ by the\n                   domain name.\n         MF records cause no additional\
    \ section processing.  The RDATA\n         section of a MF line in a master file\
    \ is a standard printed\n         domain name.\n                         Domain\
    \ Names - Implementation and Specification\n      MINFO RDATA format\n       \
    \    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           /         \
    \           RMAILBX                    /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                    EMAILBX                    /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         RMAILBX - A compressed domain name which specifies\
    \ a mailbox\n                   which is responsible for the mailing list or mailbox.\n\
    \                   If this domain name names the root, the owner of the\n   \
    \                MINFO RR is responsible for itself.  Note that many\n       \
    \            existing mailing lists use a mailbox X-request for\n            \
    \       the RMAILBX field of mailing list X, e.g.\n                   Msgroup-request\
    \ for Msgroup.  This field provides a\n                   more general mechanism.\n\
    \         EMAILBX - A compressed domain name which specifies a mailbox\n     \
    \              which is to receive error messages related to the\n           \
    \        mailing list or mailbox specified by the owner of the\n             \
    \      MINFO RR (similar to the ERRORS-TO: field which has\n                 \
    \  been proposed).  If this domain name names the root,\n                   errors\
    \ should be returned to the sender of the\n                   message.\n     \
    \    MINFO records cause no additional section processing.  Although\n       \
    \  these records can be associated with a simple mailbox, they are\n         usually\
    \ used with a mailing list.  The MINFO section of a MF\n         line in a master\
    \ file is a standard printed domain name.\n      MR RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                   NEWNAME                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         NEWNAME - A compressed domain name which specifies\
    \ a mailbox\n                   which is the proper rename of the specified mailbox.\n\
    \         MR records cause no additional section processing.  The RDATA\n    \
    \     section of a MR line in a master file is a standard printed\n         domain\
    \ name.\n                         Domain Names - Implementation and Specification\n\
    \      NULL RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                  <anything>                   /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         Anything at all may be in the RDATA field so long as it is\n       \
    \  65535 octets or less.\n         NULL records cause no additional section processing.\
    \  NULL RRs\n         are not allowed in master files.\n      NS RDATA format\n\
    \           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           /  \
    \                 NSDNAME                     /\n           /                \
    \                               /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         NSDNAME - A compressed domain name which specifies\
    \ a host which\n                   has a name server for the domain.\n       \
    \  NS records cause both the usual additional section processing\n         to\
    \ locate a type A record, and a special search of the zone in\n         which\
    \ they reside.  The RDATA section of a NS line in a master\n         file is a\
    \ standard printed domain name.\n      PTR RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                   PTRDNAME                    /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         PTRDNAME - A compressed domain name which points to\
    \ some\n                   location in the domain name space.\n         PTR records\
    \ cause no additional section processing.  These RRs\n         are used in special\
    \ domains to point to some other location in\n         the domain space.  These\
    \ records are simple data, and don't\n         imply any special processing similar\
    \ to that performed by\n         CNAME, which identifies aliases.  Appendix 3\
    \ discusses the use\n         of these records in the ARPA Internet address domain.\n\
    \                         Domain Names - Implementation and Specification\n  \
    \    SOA RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                     MNAME                     /\n           /  \
    \                                             /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           /                     RNAME                     /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    SERIAL                     |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    REFRESH                    |\n           |  \
    \                                             |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                     RETRY                     |\n           |  \
    \                                             |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    EXPIRE                     |\n           |  \
    \                                             |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    MINIMUM                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \         where:\n         MNAME   - The domain name of the name server that was\
    \ the\n                   original source of data for this zone.\n         RNAME\
    \   - A domain name which specifies the mailbox of the\n                   person\
    \ responsible for this zone.\n         SERIAL  - The unsigned 16 bit version number\
    \ of the of the\n                   original copy of the zone.  This value wraps\
    \ and\n                   should be compared using sequence space arithmetic.\n\
    \         REFRESH - The unsigned 32 bit time interval before the zone\n      \
    \             should be refreshed.\n         RETRY   - The unsigned 32 bit time\
    \ interval that should elapse\n                   before a failed refresh should\
    \ be retried.\n         EXPIRE  - A 32 bit time value that specifies the upper\
    \ limit on\n                   the time interval that can elapse before the zone\
    \ is\n                   no longer authoritative.\n         MINIMUM - The unsigned\
    \ 16 bit minimum TTL field that should be\n                   exported with any\
    \ RR from this zone (other than the\n                   SOA itself).\n       \
    \  SOA records cause no additional section processing.  The RDATA\n          \
    \               Domain Names - Implementation and Specification\n         section\
    \ of a SOA line in a master file is a standard printed\n         domain name for\
    \ MNAME, a standard X@Y mailbox specification for\n         RNAME, and decimal\
    \ numbers for the remaining parameters.\n         All times are in units of seconds.\n\
    \         Most of these fields are pertinent only for name server\n         maintenance\
    \ operations.  However, MINIMUM is used in all query\n         operations that\
    \ retrieve RRs from a zone.  Whenever a RR is\n         sent in a response to\
    \ a query, the TTL field is set to the\n         maximum of the TTL field from\
    \ the RR and the MINIMUM field in\n         the appropriate SOA.  Thus MINIMUM\
    \ is a lower bound on the TTL\n         field for all RRs in a zone.  RRs in a\
    \ zone are never discarded\n         due to timeout unless the whole zone is deleted.\
    \  This prevents\n         partial copies of zones.\n                        \
    \ Domain Names - Implementation and Specification\n"
- title: Appendix 3 - Internet specific field formats and operations
  contents:
  - "Appendix 3 - Internet specific field formats and operations\n   Message transport\n\
    \      The Internet supports name server access using TCP [10] on server\n   \
    \   port 53 (decimal) as well as datagram access using UDP [11] on UDP\n     \
    \ port 53 (decimal).  Messages sent over TCP virtual circuits are\n      preceded\
    \ by an unsigned 16 bit length field which describes the\n      length of the\
    \ message, excluding the length field itself.\n           +-----------------------------------------------+\n\
    \           |                                               |\n           |  \
    \           *****  WARNING  *****             |\n           |                \
    \                               |\n           |  The following formats are preliminary\
    \ and    |\n           | are included for purposes of explanation only.|\n   \
    \        | In particular, new RR types will be added,    |\n           | and the\
    \ size, position, and encoding of       |\n           | fields are subject to\
    \ change.                 |\n           |                                    \
    \           |\n           +-----------------------------------------------+\n\
    \   A RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    ADDRESS                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      where:\n      ADDRESS   - A 32 bit ARPA internet address\n      Hosts that\
    \ have multiple ARPA Internet addresses will have\n      multiple A records.\n\
    \      A records cause no additional section processing.  The RDATA\n      section\
    \ of an A line in a master file is an Internet address\n      expressed as four\
    \ decimal numbers separated by dots without any\n      imbedded spaces (e.g.,\
    \ \"10.2.0.52\" or \"192.0.5.6\").\n                         Domain Names - Implementation\
    \ and Specification\n   WKS RDATA format\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |                    ADDRESS                    |\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \           |       PROTOCOL        |                       |\n           +--+--+--+--+--+--+--+--+\
    \                       |\n           |                                      \
    \         |\n           /                   <BIT MAP>                   /\n  \
    \         /                                               /\n           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \      where:\n      ADDRESS   - An 32 bit ARPA Internet address\n      PROTOCOL\
    \  - An 8 bit IP protocol number\n      <BIT MAP> - A variable length bit map.\
    \  The bit map must be a\n                multiple of 8 bits long.\n      The\
    \ WKS record is used to describe the well known services\n      supported by a\
    \ particular protocol on a particular internet\n      address.  The PROTOCOL field\
    \ specifies an IP protocol number, and\n      the bit map has one bit per port\
    \ of the specified protocol.  The\n      first bit corresponds to port 0, the\
    \ second to port 1, etc.  If\n      less than 256 bits are present, the remainder\
    \ are assumed to be\n      zero.  The appropriate values for ports and protocols\
    \ are\n      specified in [13].\n      For example, if PROTOCOL=TCP (6), the 26th\
    \ bit corresponds to TCP\n      port 25 (SMTP).  If this bit is set, a SMTP server\
    \ should be\n      listening on TCP port 25; if zero, SMTP service is not supported\n\
    \      on the specified address.\n      The anticipated use of WKS RRs is to provide\
    \ availability\n      information for servers for TCP and UDP.  If a server supports\n\
    \      both TCP and UDP, or has multiple Internet addresses, then\n      multiple\
    \ WKS RRs are used.\n      WKS RRs cause no additional section processing.  The\
    \ RDATA section\n      of a WKS record consists of a decimal protocol number followed\
    \ by\n      mnemonic identifiers which specify bits to be set to 1.\n   IN-ADDR\
    \ special domain\n      The ARPA internet uses a special domain to support gateway\n\
    \      location and ARPA Internet address to host mapping.  The intent of\n  \
    \    this domain is to allow queries to locate all gateways on a\n           \
    \              Domain Names - Implementation and Specification\n      particular\
    \ network in the ARPA Internet, and also to provide a\n      guaranteed method\
    \ to perform host address to host name mapping.\n      Note that both of these\
    \ services are similar to functions that\n      could be performed by inverse\
    \ queries; the difference is that this\n      part of the domain name space is\
    \ structured according to address,\n      and hence can guarantee that the appropriate\
    \ data can be located\n      without an exhaustive search of the domain space.\
    \  It is\n      anticipated that the special tree will be used by ARPA Internet\n\
    \      resolvers for all gateway location services, but that address to\n    \
    \  name resolution will be performed by first trying the inverse\n      query\
    \ on the local name server database followed by a query in the\n      special\
    \ space if the inverse query fails.\n      The domain is a top level domain called\
    \ IN-ADDR whose substructure\n      follows the ARPA Internet addressing structure.\n\
    \      Domain names in the IN-ADDR domain are defined to have up to four\n   \
    \   labels in addition to the IN-ADDR label.  Each label is a\n      character\
    \ string which expresses a decimal value in the range\n      0-255 (with leading\
    \ zeros omitted except in the case of a zero\n      octet which is represented\
    \ by a single zero).  These labels\n      correspond to the 4 octets of an ARPA\
    \ Internet address.\n      Host addresses are represented by domain names that\
    \ have all four\n      labels specified.  Thus data for ARPA Internet address\
    \ 10.2.0.52\n      is located at domain name 52.0.2.10.IN-ADDR.  The reversal,\
    \ though\n      awkward to read,  allows zones to follow the natural grouping\
    \ of\n      hosts within networks.  For example, 10.IN-ADDR can be a zone\n  \
    \    containing data for the ARPANET, while 26.IN-ADDR can be a\n      separate\
    \ zone for MILNET.  Address nodes are used to hold pointers\n      to primary\
    \ host names in the normal domain space.\n      Network addresses correspond to\
    \ some of the non-terminal nodes in\n      the IN-ADDR tree, since ARPA Internet\
    \ network numbers are either\n      1, 2, or 3 octets.  Network nodes are used\
    \ to hold pointers to\n      primary host names (which happen to be gateways)\
    \ in the normal\n      domain space.  Since a gateway is, by definition, on more\
    \ than one\n      network, it will typically have two or more network nodes that\n\
    \      point at the gateway.  Gateways will also have host level pointers\n  \
    \    at their fully qualified addresses.\n      Both the gateway pointers at network\
    \ nodes and the normal host\n      pointers at full address nodes use the PTR\
    \ RR to point back to the\n      primary domain names of the corresponding hosts.\n\
    \      For example, part of the IN-ADDR domain will contain information\n    \
    \  about the ISI to MILNET and MIT gateways, and hosts F.ISI.ARPA and\n      MULTICS.MIT.ARPA.\
    \  Assuming that ISI gateway has addresses\n                         Domain Names\
    \ - Implementation and Specification\n      10.2.0.22 and 26.0.0.103, and a name\
    \ MILNET-GW.ISI.ARPA, and the\n      MIT gateway has addresses 10.0.0.77 and 18.10.0.4\
    \ and a name\n      GW.MIT.ARPA, the domain database would contain:\n        \
    \   10.IN-ADDR           PTR  IN MILNET-GW.ISI.ARPA   \n           10.IN-ADDR\
    \           PTR  IN GW.MIT.ARPA          \n           18.IN-ADDR           PTR\
    \  IN GW.MIT.ARPA          \n           26.IN-ADDR           PTR  IN MILNET-GW.ISI.ARPA\
    \   \n           22.0.2.10.IN-ADDR    PTR  IN MILNET-GW.ISI.ARPA   \n        \
    \   103.0.0.26.IN-ADDR   PTR  IN MILNET-GW.ISI.ARPA   \n           77.0.0.10.IN-ADDR\
    \    PTR  IN GW.MIT.ARPA          \n           4.0.10.18.IN-ADDR    PTR  IN GW.MIT.ARPA\
    \          \n           52.0.2.10.IN-ADDR    PTR  IN F.ISI.ARPA           \n \
    \          6.0.0.10.IN-ADDR     PTR  IN MULTICS.MIT.ARPA     \n      Thus a program\
    \ which wanted to locate gateways on net 10 would\n      originate a query of\
    \ the form QTYPE=PTR, QCLASS=IN,\n      QNAME=10.IN-ADDR.  It would receive two\
    \ RRs in response:\n           10.IN-ADDR           PTR  IN MILNET-GW.ISI.ARPA\
    \   \n           10.IN-ADDR           PTR  IN GW.MIT.ARPA          \n      The\
    \ program could then originate QTYPE=A, QCLASS=IN queries for\n      MILNET-GW.ISI.ARPA\
    \ and GW.MIT.ARPA to discover the ARPA Internet\n      addresses of these gateways.\n\
    \      A resolver which wanted to find the host name corresponding to\n      ARPA\
    \ Internet host address 10.0.0.6 might first try an inverse\n      query on the\
    \ local name server, but find that this information\n      wasn't available. \
    \ It could then try a query of the form\n      QTYPE=PTR, QCLASS=IN, QNAME=6.0.0.10.IN-ADDR,\
    \ and would receive:\n           6.0.0.10.IN-ADDR     PTR  IN MULTICS.MIT.ARPA\
    \     \n      Several cautions apply to the use of these services:\n         Since\
    \ the IN-ADDR special domain and the normal domain for a\n         particular\
    \ host or gateway will be in different zones, the\n         possibility exists\
    \ that that the data may be inconsistent.\n         Gateways will often have two\
    \ names in separate domains, only\n         one of which can be primary.\n   \
    \      Systems that use the domain database to initialize their\n         routing\
    \ tables must start with enough gateway information to\n         guarantee that\
    \ they can access the appropriate name server.\n         The gateway data only\
    \ reflects the existence of a gateway in a\n                         Domain Names\
    \ - Implementation and Specification\n         manner equivalent to the current\
    \ HOSTS.TXT file.  It doesn't\n         replace the dynamic availability information\
    \ from GGP or EGP.\n                         Domain Names - Implementation and\
    \ Specification\n"
- title: REFERENCES and BIBLIOGRAPHY
  contents:
  - "REFERENCES and BIBLIOGRAPHY\n   [1]  E. Feinler, K. Harrenstien, Z. Su, and V.\
    \ White, \"DOD Internet\n        Host Table Specification\", RFC 810, Network\
    \ Information Center,\n        SRI International, March 1982.\n   [2]  J. Postel,\
    \ \"Computer Mail Meeting Notes\", RFC 805,\n        USC/Information Sciences\
    \ Institute, February 1982.\n   [3]  Z. Su, and J. Postel, \"The Domain Naming\
    \ Convention for Internet\n        User Applications\", RFC 819, Network Information\
    \ Center, SRI\n        International, August 1982.\n   [4]  Z. Su, \"A Distributed\
    \ System for Internet Name Service\",\n        RFC 830, Network Information Center,\
    \ SRI International,\n        October 1982.\n   [5]  K. Harrenstien, and V. White,\
    \ \"NICNAME/WHOIS\", RFC 812, Network\n        Information Center, SRI International,\
    \ March 1982.\n   [6]   M. Solomon, L. Landweber, and D. Neuhengen, \"The CSNET\
    \ Name\n        Server\", Computer Networks, vol 6, nr 3, July 1982.\n   [7] \
    \ K. Harrenstien, \"NAME/FINGER\", RFC 742, Network Information\n        Center,\
    \ SRI International, December 1977.\n   [8]  J. Postel, \"Internet Name Server\"\
    , IEN 116, USC/Information\n        Sciences Institute, August 1979.\n   [9] \
    \ K. Harrenstien, V. White, and E. Feinler, \"Hostnames Server\",\n        RFC\
    \ 811, Network Information Center, SRI International,\n        March 1982.\n \
    \  [10] J. Postel, \"Transmission Control Protocol\", RFC 793,\n        USC/Information\
    \ Sciences Institute, September 1981.\n   [11] J. Postel, \"User Datagram Protocol\"\
    , RFC 768, USC/Information\n        Sciences Institute, August 1980.\n   [12]\
    \ J. Postel, \"Simple Mail Transfer Protocol\", RFC 821,\n        USC/Information\
    \ Sciences Institute, August 1980.\n   [13] J. Reynolds, and J. Postel, \"Assigned\
    \ Numbers\", RFC 870,\n        USC/Information Sciences Institute, October 1983.\n\
    \   [14] P. Mockapetris, \"Domain names - Concepts and Facilities,\"\n       \
    \ RFC 882, USC/Information Sciences Institute, November 1983.\n              \
    \           Domain Names - Implementation and Specification\n"
- title: INDEX
  contents:
  - "INDEX\n   * usage........................................................37,\
    \ 57\n   A RDATA format.....................................................67\n\
    \   byte order..........................................................6\n  \
    \ cache queue....................................................35, 42\n   character\
    \ case..................................................7, 31\n   CLASS...........................................................9,\
    \ 58\n   completion.........................................................19\n\
    \   compression........................................................31\n  \
    \ CNAME RR...........................................................60\n   header\
    \ format......................................................26\n   HINFO RR...........................................................60\n\
    \   include files......................................................43\n  \
    \ inverse queries....................................................17\n   mailbox\
    \ names......................................................53\n   master files.......................................................43\n\
    \   MB RR..............................................................61\n  \
    \ MD RR..............................................................61\n   message\
    \ format.....................................................13\n   MF RR..............................................................62\n\
    \   MG RR..............................................................62\n  \
    \ MINFO RR...........................................................63\n   MR\
    \ RR..............................................................63\n   NULL\
    \ RR............................................................64\n   NS RR..............................................................64\n\
    \   PTR RR.........................................................64, 69\n  \
    \ QCLASS.............................................................58\n   QTYPE..............................................................57\n\
    \   queries (standard).................................................15\n  \
    \ recursive service..................................................24\n   RR\
    \ format..........................................................59\n   SOA RR.............................................................65\n\
    \   Special domains....................................................68\n  \
    \ TYPE...............................................................57\n   WKS\
    \ type RR........................................................68\n"
