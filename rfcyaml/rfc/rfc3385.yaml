- title: __initial_text__
  contents:
  - "       Internet Protocol Small Computer System Interface (iSCSI)\n         Cyclic\
    \ Redundancy Check (CRC)/Checksum Considerations\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   In this memo, we attempt to give some estimates for the probability\n\
    \   of undetected errors to facilitate the selection of an error\n   detection\
    \ code for the Internet Protocol Small Computer System\n   Interface (iSCSI).\n\
    \   We will also attempt to compare Cyclic Redundancy Checks (CRCs) with\n   other\
    \ checksum forms (e.g., Fletcher, Adler, weighted checksums), as\n   permitted\
    \ by available data.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   Cyclic Redundancy Check (CRC) codes [Peterson] are shortened\
    \ cyclic\n   codes used for error detection.  A number of CRC codes have been\n\
    \   adopted in standards: ATM, IEC, IEEE, CCITT, IBM-SDLC, and more\n   [Baicheva].\
    \  The most important expectation from this kind of code is\n   a very low probability\
    \ for undetected errors.  The probability of\n   undetected errors in such codes\
    \ has been, and still is, subject to\n   extensive studies that have included\
    \ both analytical models and\n   simulations.  Those codes have been used extensively\
    \ in\n   communications and magnetic recording as they demonstrate good \"burst\n\
    \   error\" detection capabilities, but are also good at detecting several\n \
    \  independent bit errors.  Hardware implementations are very simple and\n   well\
    \ known; their simplicity has made them popular with hardware\n   developers for\
    \ many years.  However, algorithms and software for\n   effective implementations\
    \ of CRC are now also widely available\n   [Williams].\n   The probability of\
    \ undetected errors depends on the polynomial\n   selected to generate the code,\
    \ the error distribution (error model),\n   and the data length.\n"
- title: 2. Error Models and Goals
  contents:
  - "2. Error Models and Goals\n   We will analyze the code behavior under two conditions:\n\
    \      - noisy channel - burst errors with an average length of n bits\n     \
    \ - low noise channel - independent single bit errors\n   Burst errors are the\
    \ prevalent natural phenomenon on communication\n   lines and recording media.\
    \  The numbers quoted for them revolve\n   around the BER (bit error rate).  However,\
    \ those numbers are\n   frequently nothing more than a reflection of the Burst\
    \ Error Rate\n   multiplied by the average burst length.  In field engineering\
    \ tests,\n   three numbers are usually quoted together -- BER, error-free-seconds\n\
    \   and severely-error-seconds; this illustrates our point.\n   Even beyond communication\
    \ and recording media, the effects of errors\n   will be bursty.  An example of\
    \ this is a memory error that will\n   affect more than a single bit and the total\
    \ effect will not be very\n   different from the communication error, or software\
    \ errors that occur\n   while manipulating packets will have a burst effect. \
    \ Software errors\n   also result in burst errors.  In addition, serial internal\n\
    \   interconnects will make this type of error the most common within\n   machines\
    \ as well.\n   We also analyze the effects of single independent bit errors, since\n\
    \   these may be caused by certain defects.\n   On burst, we assume an average\
    \ burst error duration of bd, which at a\n   given transmission rate s, will result\
    \ in an average burst of a =\n   bd*s bits.  (E.g., an average burst duration\
    \ of 3 ns at 1Gbs gives an\n   average burst of 3 bits.)\n   For the burst error\
    \ rate, we will take 10^-10.  The numbers quoted\n   for BER on wired communication\
    \ channels are between 10^-10 to 10^-12\n   and we consider the BER as burst-error-rate*average-burst-length.\n\
    \   Nevertheless, please keep in mind that if the channel includes\n   wireless\
    \ links, the error rates may be substantially higher.\n   For independent single\
    \ bit errors, we assume a 10^-11 error rate.\n   Because the error detection mechanisms\
    \ will have to transport large\n   amounts of data (petabytes=10^16 bits) without\
    \ errors, we will target\n   very low probabilities for undetected errors for\
    \ all block lengths\n   (at 10Gb/s that much data can be sent in less than 2 weeks\
    \ on a\n   single link).\n   Alternatively, as iSCSI has to perform efficiently,\
    \ we will require\n   that the error detection capability of a selected protection\n\
    \   mechanism be very good, at least up to block lengths of 8k bytes\n   (64kbits).\n\
    \   The error detection capability should keep the probability of\n   undetected\
    \ errors at values that would be \"next-to-impossible\".  We\n   recognize, however,\
    \ that such attributes are hard to quantify and we\n   resorted to physics.  The\
    \ value 10^23 is the Avogadro number while\n   10^45 is the number of atoms in\
    \ the known Universe (or it was many\n   years ago when we read about it) and\
    \ those are the bounds of\n   incertitude we could live with.  (10^-23 at worst\
    \ and 10^-45 if we\n   can afford it.)  For 8k blocks, the per/bit equivalent\
    \ would be\n   (10^-28 to 10^-50).\n"
- title: 3. Background and Literature Survey
  contents:
  - "3. Background and Literature Survey\n   Each codeword of a binary (n,k) CRC code\
    \ C consists of n = k+r bits.\n   The block of r parity bits is computed from\
    \ the block of k\n   information bits.  The code has a degree r generator polynomial\
    \ g(x).\n   The code is linear in the sense that the bitwise addition of any two\n\
    \   codewords yields a codeword.\n   For the minimal m such that g(x) divides\
    \ (x^m)-1, either n=m, and the\n   code C comprises the set D of all the multiplications\
    \ of g(x) modulo\n   (x^m)-1, or n<m, and C is obtained from D by shortening each\
    \ word in\n   the latter in m-n specific positions.  (This also reduces the number\n\
    \   of words since all zero words are then discarded and duplicates are\n   not\
    \ maintained.)\n   Error detection at the receiving end is made by computing the\
    \ parity\n   bits from the received information block, and comparing them with\
    \ the\n   received parity bits.\n   An undetected error occurs when the received\
    \ word c' is a codeword,\n   but is different from the c that is transmitted.\n\
    \   This is only possible when the error pattern e=c'-c is a codeword by\n   itself\
    \ (because of the linearity of the code).  The performance of a\n   CRC code is\
    \ measured by the probability Pud of undetected channel\n   errors.\n   Let Ai\
    \ denote the number of codewords of weight i, (i.e., with i 1-\n   bits).  For\
    \ a binary symmetric channel (BSC), with sporadic,\n   independent bit error ratio\
    \ of probability 0<=epsilon<=0.5, the\n   probability of undetected errors for\
    \ the code C is thus given by:\n"
- title: Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))
  contents:
  - "Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))\n   where\
    \ d is the distance of the code:  the minimal weight difference\n   between two\
    \ codewords in C which, by the linearity of the code, is\n   also the minimal\
    \ weight of any codeword in the code.  Pud can also be\n   expressed by the weight\
    \ distribution of the dual code:  the set of\n   words each of which is orthogonal\
    \ (bitwise AND yields an even number\n   of 1-bits) to every word of C.  The fact\
    \ that Pud can be computed\n   using the dual code is extremely important; while\
    \ the number of\n   codewords in the code is 2^k, the number of codewords in the\
    \ dual\n   code is 2^r.  k is in the orders of thousands, and r in the order of\n\
    \   16 or 24 or 32.  If we use Bi to denote the number of codewords in\n   the\
    \ dual code which are of weight i, then ([LinCostello]):\n"
- title: Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i -
  contents:
  - 'Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i -

    '
- title: (1-epsilon)^n
  contents:
  - "(1-epsilon)^n\n   Wolf [Wolf94o] introduced an efficient algorithm for enumerating\
    \ all\n   the codewords of a code and finding their weight distribution.\n   Wolf\
    \ [Wolf82] found that, counter to what was assumed, (1) there\n   exist codes\
    \ for which Pud(C,epsilon)>Pud(C,0.5) for some epsilon\n   not=0.5 and (2) Pud\
    \ is not always increasing for 0<=epsilon<=0.5.\n   The value of what was assumed\
    \ to be the worst Pud is Pud(C,0.5)=(2^-\n   r) - (2^-n).  This stems from the\
    \ fact that with epsilon=0.5, all 2^n\n   received words are equally likely and\
    \ out of them 2^(n-r)-1 will be\n   accepted as codewords of no errors, although\
    \ they are different from\n   the codeword transmitted.  Previously Pud had been\
    \ assumed to equal\n   [2^(n-r)-1]/(2^n-1) or the ratio of the number of non-zero\
    \ multiples\n   of the polynomial of degree less than n (each such multiple is\n\
    \   undetected) and the number of possible error polynomials.  With\n   either\
    \ formula Pud approaches 1/2^r as n approaches infinity, but\n   Wolf's formula\
    \ is more accurate.\n   Wolf [Wolf94j] investigated the CCITT code of r=16 parity\
    \ bits.  This\n   code is a member of the family of (shortened codes of) BCH codes\
    \ of\n   length 2^(r-1) -1 (r=16 in the CCITT 16-bit case) generated by a\n  \
    \ polynomial of the form g(x) =(x+1)p(x) with p(x) being a primitive\n   polynomial\
    \ of degree r-1 (=15 in this case).  These codes have a BCH\n   design distance\
    \ of 4.  That is, the minimal distance between any two\n   codewords in the code\
    \ is at least 4 bits (which is earned by the fact\n   that the sequence of powers\
    \ of alpha, the root of p(x), which are\n   roots of g(x), includes three consecutive\
    \ powers -- alpha^0, alpha^1,\n   alpha^2).  Hence, every 3 single bit errors\
    \ are detectable.\n   Wolf found that different shortened versions of a given\
    \ code, of the\n   same codeword length, perform the same (independent of which\
    \ specific\n   indexes are omitted from the original code).  He also found that\
    \ for\n   the unshortened codes, all primitive polynomials yield codes of the\n\
    \   same performance.  But for the shortened versions, the choice of the\n   primitive\
    \ polynomial does make a difference.  Wolf [Wolf94j] found a\n   primitive polynomial\
    \ which (when multiplied by x+1) yields a\n   generating polynomial that outperforms\
    \ the CCITT one by an order of\n   magnitude.  For 32-bit redundancy bits, he\
    \ found an example of two\n   polynomials that differ in their probability of\
    \ undetected burst of\n   length 33 by 4 orders of magnitude.\n   It so happens,\
    \ that for some shortened codes, the minimum distance,\n   or the distribution\
    \ of the weights, is better than for others derived\n   from different unshortened\
    \ codes.\n   Baicheva, et. al. [Baicheva] made a comprehensive comparison of\n\
    \   different generating polynomials of degree 16 of the form g(x) =\n   (x+1)p(x),\
    \ and of other forms.  They computed their Pud for code\n   lengths up to 1024\
    \ bits.  They measured their \"goodness\"  -- if\n   Pud(C,epsilon)  <= Pud(C,0.5)\
    \ and being \"well-behaved\" -- if\n   Pud(C,epsilon) increases with epsilon in\
    \ the range (0,0.5).  The\n   paper gives a comprehensive table that lists which\
    \ of the polynomials\n   is good and which is well-behaved for different length\
    \ ranges.\n   For a single burst error, Wolf [Wolf94J] suggested the model of\
    \ (b:p)\n   burst -- the errors only occur within a span of b bits, and within\n\
    \   that span, the errors occur randomly, with a bit error probability 0\n   <=\
    \ p <= 1.\n   For p=0.5, which used to be considered the worst case, it is well\n\
    \   known [Wolf94J] that the probability of undetected one burst error of\n  \
    \ length b <= r is 0, of length b=r+1 is 2^-(r-1), and of b > r+1, is\n   2^-r,\
    \ independently of the choice of the primitive polynomial.\n   With Wolf's definition,\
    \ where p can be different from 0.5, indeed it\n   was found that for a given\
    \ b there are values of p, different from\n   0.5 which maximize the probability\
    \ of undetected (b:p) burst error.\n   Wolf proved that for a given code, for\
    \ all b in the range r < b < n,\n   the conditional probability of undetected\
    \ error for the (n, n-r)\n   code, given that a (b:p) burst occurred, is equal\
    \ to the probability\n   of undetected errors for the same code (the same generating\n\
    \   polynomial), shortened to block length b, when this shortened code is\n  \
    \ used with a binary symmetric channel with channel (sporadic,\n   independent)\
    \ bit error probability p.\n   For the IEEE-802.3 used CRC32, Fujiwara et al.\
    \ [Fujiwara89] measured\n   the weights of all words of all shortened versions\
    \ of the IEEE 802.3\n   code of 32 check bits.  This code is generated by a primitive\n\
    \   polynomial of degree 32:\n   g(x) = x^32 + x^26 + x^23 + x^22 + x^16 + x^12\
    \ + x^11 + x^10 + x^8 +\n   x^7 + x^5 + x^4 + x^2 + x + 1 and hence the designed\
    \ distance of it\n   is only 3.  This distance holds for codes as long as 2^32-1.\n\
    \   However, the frame format of the MAC (Media Access Control) of the\n   data\
    \ link layer in IEEE 802.3, as well as that of the data link layer\n   for the\
    \ Ethernet (1980) forbid lengths exceeding 12,144 bits.  Thus,\n   only such bounded\
    \ lengths are investigated in [Fujiwara89].  For\n   shortened versions, the minimum\
    \ distance was found to be 4 for\n   lengths 4096 to 12,144; 5 for lengths 512\
    \ to 2048; and even 15 for\n   lengths 33 through 42.  A chart of results of calculations\
    \ of Pud is\n   presented in [Fujiwara89] from which we can see that for codes\
    \ of\n   length 12,144 and BSC of epsilon = 10^-5 - 10^-4,\n   Pud(12,144,epsilon)=\
    \ 10^-14 - 10^-13 and for epsilon = 10^-4 - 10^-3,\n   Pud(512,epsilon) = 10^-15,\
    \ Pud(1024,epsilon) = 10^-14,\n   Pud(2048,epsilon) = 10^-13, Pud(4096,epsilon)\
    \ = 10^-12 - 10^-11, and\n   Pud(8192,epsilon) = 10^-10 which is rather close\
    \ to 2^-32.\n   Castagnoli, et. al. [Castagnoli93] extended Fujiwara's technique\
    \ for\n   efficiently calculating the minimum distance through the weight\n  \
    \ distribution of the dual code and explored a large number of CRC\n   codes with\
    \ 24 and 32 redundancy bit.  They explored several codes\n   built as a multiplication\
    \ of several lower degree irreducible\n   polynomials.\n   In the popular class\
    \ of (x+1)*deg31-irreducible-polynomial they\n   explored 47000 polynomials (not\
    \ all the possible ones).  The best\n   they found has d=6 up to block lengths\
    \ of 5275 and d=4 up to 2^31-1\n   (bits).\n   The investigation was done in 1993\
    \ with a special purpose processor.\n   By comparison, the IEEE-802 code has d=4\
    \ up to at least 64,000 bits\n   (Fujikura stopped looking at 12,144) and d=3\
    \ up to 2^32-1 bits.\n   CRC32/4 (we will refer to it as CRC32C for the remainder\
    \ of this\n   memo) is 11EDC6F41;  IEEE-802 CRC is 104C11DB7, denoting the\n \
    \  coefficients as a bit vector.\n   [Stone98] evaluated the performance of CRC\
    \ (the AAL5 CRC that is the\n   same as IEEE802) and the TCP and Fletcher checksums\
    \ on large amounts\n   of data.  The results of this experiment indicate a serious\
    \ weakness\n   of the checksums on real-data that stems from the fact that checksums\n\
    \   do not spread the \"hot spots\" in input data.  However, the results\n   show\
    \ that Fletcher behaves by a factor of 2 better than the regular\n   TCP checksum.\n"
- title: 4. Probability of Undetected Errors - Burst Error
  contents:
  - '4. Probability of Undetected Errors - Burst Error

    '
- title: 4.1 CRC32C (Derivations from [Wolf94j])
  contents:
  - "4.1 CRC32C (Derivations from [Wolf94j])\n   Wolf [Wolf94j] found a 32-bit polynomial\
    \ of the form g(x) = (1+x)p(x)\n   for which the conditional probability of undetected\
    \ error, given that\n   a burst of length 33 occurred, is at most (i.e., maximized\
    \ over all\n   possible channel bit error probabilities within the burst) 4 *\
    \ 10^-\n   10.\n   We will now figure the probability of undetected error, given\
    \ that a\n   burst of length 34 occurred, using the result derived in this paper,\n\
    \   namely that for a given code, for all b in the range 32 < b < n, the\n   conditional\
    \ probability of undetected error for the (n, n-32) code,\n   given that a (b:p)\
    \ burst occurred, is equal to the probability of\n   undetected errors for the\
    \ same code (the same generating polynomial),\n   shortened to block length b,\
    \ when this shortened code is used with a\n   binary symmetric channel with channel\
    \ (sporadic, independent) bit\n   error probability p.\n   The approximation formula\
    \ for Pud of sporadic errors, if the weights\n   Ai are distributed binomially,\
    \ is:\n   Pud(C, epsilon) =~= Sigma[for i=d to n] ((n choose i) / 2^r )*(1-\n\
    \   epsilon)^(n-i) * epsilon^i .\n   Assuming a very small epsilon, this expression\
    \ is dominated by i=d.\n   From [Fujiwara89] we know that for 32-bit CRC, for\
    \ such small n,\n   d=15.  Thus, when n grows from 33 to 34, we find that the\n\
    \   approximation of Pud grows by (34 choose 15) / (33 choose 15) =\n   34/19;\
    \ when n grows further to 35, Pud grows by another 35/20.\n   Taking, from Wolf\
    \ [Wolf94j], the most generous conditional\n   probability, computed with the\
    \ bit error probability p* that\n   maximizes Pub(p|b), we derive: Pud(p*|33)\
    \ = 4 x 10^{-10}, yielding\n   Pud(p*|34) = 7.15 x 10^{-10} and Pud(p*|35) = 1.25\
    \ x 10^{-9}.\n   For the density function of the burst length, we assume the Rayleigh\n\
    \   density function (the discretization thereof to integers), which is\n   the\
    \ density of the absolute values of complex numbers of Gauss\n   distribution:\n\
    \      f(x) = x / a^2  exp {-x^2 / 2a^2 }     , x>0 .\n   This density function\
    \ has a peak at the parameter a and it decreases\n   smoothly as x increases.\n\
    \   We take three consecutive bits as the most common burst event once an\n  \
    \ error does occur, and thus a=3.\n   Now, the probability that a burst of length\
    \ b occurs in a specific\n   position is the burst error rate, which we estimate\
    \ as 10^{-10},\n   times f(b).  Calculating for b=33 we find f(33) = 1.94 x 10^{-26}.\n\
    \   Together, we found that the probability that a burst of length 33\n   occurred,\
    \ starting at a specific position, is 1.94 x 10^{-36}.\n   Multiplying this by\
    \ the generous upper bound on the probability that\n   this burst error is not\
    \ detected, Pud(p*|33), we get that the\n   probability that a burst occurred\
    \ at a specific position, and is not\n   detected, is 7.79 x 10 ^{-46}.\n   Going\
    \ again along this path of calculations, this time for b=34 we\n   find that f(34)\
    \ = 4.85*10^{-28}.  Multiplying by 10^{-10} and by\n   Pud(p*|34) = 7.15*10^{-10}\
    \ we find that the probability that a burst\n   of length 34 occurred at a specific\
    \ position, and is not detected, is\n   3.46*10^{-47}.\n   Last, computing for\
    \ b=35, we get 1*10^{-29} * 10^{-10} * 1.25*10^{-9}\n   = 1.25*10^{-48}.\n   It\
    \ looks like the total can be approximated at 10^-45 which is within\n   the bounds\
    \ of what we are looking for.\n   When we multiply this by the length of the code\
    \ (because thus far we\n   calculated for a specific position) we have 10^-45\
    \ * 6.5*10^4 =\n   6.5*10^-41 as an upper bound on the probability of undetected\
    \ burst\n   error for a code of length 8K Bytes.\n   We can also apply this overestimation\
    \ for IEEE 802.3.\n   Comment: 2^{-32} = 2.33*10^{-10}.\n"
- title: 5. Probability of Undetected Errors - Independent Errors
  contents:
  - '5. Probability of Undetected Errors - Independent Errors

    '
- title: 5.1 CRC (Derivations from [Castagnoli93])
  contents:
  - "5.1 CRC (Derivations from [Castagnoli93])\n   It is reported in [Castagnoli93]\
    \ that for BER = epsilon=10^-6, Pud\n   for a single bit error, for a code of\
    \ length 8KB, for both cases,\n   IEEE-802.3 and CRC32C is 10^{-20}.  They also\
    \ report that CRC32C has\n   distance 4, and IEEE either 3 or 4 for this code\
    \ length.  From this,\n   and the minimum distance of the code of this length,\
    \ we conclude that\n   with our estimation of epsilon, namely 10^{-11}, we should\
    \ multiply\n   the reported result by {10^{-5}}^4 = 10^{-20} for CRC32C, and either\n\
    \   10^{-15} or 10^{-20} for IEEE802.3.\n"
- title: 5.2 Checksums
  contents:
  - "5.2 Checksums\n   For independent bit errors, Pud of CRC is approximately 12,000\
    \ better\n   than Fletcher, and 22,000 better than Adler.  For burst errors, by\n\
    \   the simple examples that exist for three consecutive values that can\n   produce\
    \ an undetected burst, we take the factor to be at least the\n   same.\n   If\
    \ in three consecutive bytes, the error values are x, -2x, x then\n   the error\
    \ is undetected.  Even for this error pattern alone, the\n   conditional probability\
    \ of undetected error, assuming a uniform\n   distribution of data, is 2^-16 =\
    \ 1.5 * 10^-5.  The probability that a\n   burst of length 3 bytes occurs, is\
    \ f(24) = 3*10^-14.  Together:\n   4.5*10^-19.  Multiplying this by the length\
    \ of the code, we get close\n   to 4.5*10^-16, way worse than the vicinity of\
    \ 10^-40.\n   The numbers in the table in Section 7 below reflect a more \"tolerant\"\
    \n   difference (10*4).\n"
- title: 6. Incremental CRC Updates
  contents:
  - "6. Incremental CRC Updates\n   In some protocols the packet header changes frequently.\
    \  If the CRC\n   includes the changing part, the CRC will have to be recomputed.\
    \  This\n   raises two issues:\n      - the complete computation is expensive\n\
    \      - the packet is not protected against unwanted changes\n        between\
    \ the last check and the recomputation\n   Fortunately, changes in the header\
    \ do not imply a need for completed\n   CRC computation.  The reason is the linearity\
    \ of the CRC function.\n   Namely, with I1 and I2 denoting two equal-length blocks\
    \ of\n   information bits, CRC(I) denoting the CRC check bits calculated for\n\
    \   I, and + denoting bitwise modulo-2 addition, we have CRC(I1+I2) =\n   CRC(I1)+CRC(I2).\n\
    \   Hence, for an IP packet, made of a header h followed by data d\n   followed\
    \ by CRC bits c = CRC(h d), arriving at a node, which updates\n   header h to\
    \ become h', the implied update of c is an addition of\n   CRC(h'-h 0), where\
    \ 0 is an all 0 block of the length of the data\n   block d, and addition and\
    \ subtraction are bitwise modulo 2.\n   We know that a predetermined permutation\
    \ of bits does not change\n   distance and weight statistics of the codewords.\
    \  It follows that\n   such a transformation does not change the probability of\
    \ undetected\n   errors.\n   We can then conceive the packet as if it was built\
    \ from data d\n   followed by header h, compute the CRC accordingly, c=CRC(d h),\
    \ and\n   update at the node with an addition of CRC(0 h'-h)=CRC(h'-h), but on\n\
    \   transmission, send the header part before the data and the CRC bits.\n   This\
    \ will allow a faster computation of the CRC, while still letting\n   the header\
    \ part lead (no change to the protocol).\n   Error detection, i.e., computing\
    \ the CRC bits by the data and header\n   parts that arrive, and comparing them\
    \ with the CRC part that arrives\n   together with them, can be done at the final,\
    \ end-target node only,\n   and the detected errors will include unwanted changes\
    \ introduced by\n   the intermediate nodes.\n   The analysis of the undetected\
    \ error probability remains valid\n   according to the following rationale:\n\
    \   The packet started its way as a codeword.  On its way, several\n   codewords\
    \ were added to it (any information followed by the\n   corresponding CRC is a\
    \ codeword).  Let e denote the totality of\n   errors added to the packet, on\
    \ its long, multi-hop journey.  Because\n   the code is linear (i.e., the sum\
    \ of two codewords is also a\n   codeword) the packet arriving to the end-target\
    \ node is some codeword\n   + e, and hence, as in our preceding analysis, e is\
    \ undetected if and\n   only if it is a codeword by itself.  This fact is the\
    \ basis of our\n   above analysis, and hence that analysis applies here too. \
    \ (See a\n   detailed discussion at [braun01].)\n"
- title: 7. Complexity of Hardware Implementation
  contents:
  - "7. Complexity of Hardware Implementation\n   Comparing the cost of various CRC\
    \ polynomials, we used a tool\n   available at http://www.easics.com/webtools/crctool\
    \ to implement CRC\n   generators/checkers for various CRC polynomials.  The program\
    \ gives\n   either Verilog or VHDL code after specifying a polynomial, as well\
    \ as\n   the number of data bits, k, to be handled in one clock cycle.  For a\n\
    \   serial implementation, k would be one.\n   The cost for either one generator\
    \ or checker is shown in the\n   following table.\n   The number of 2-input XOR\
    \ gates, for an un-optimized implementation,\n   required for various values of\
    \ k:\n   +----------------------------------------------+\n   | Polynomial  |\
    \ k=32     | k=64     | k=128    |\n   +----------------------------------------------+\n\
    \   | CCITT-CRC32 | 488      | 740      | 1430     |\n   +----------------------------------------------+\n\
    \   | IEEE-802    | 872      | 1390     | 2518     |\n   +----------------------------------------------+\n\
    \   | CRC32Q(Wolf)| 944      | 1444     | 2534     |\n   +----------------------------------------------+\n\
    \   | CRC32C      | 1036     | 1470     | 2490     |\n   +----------------------------------------------+\n\
    \   After optimizing (sharing terms) and in terms of Cells (4 cells per 2\n  \
    \ input AND, 7 cells per 2 input XOR, 3 cells per inverter) the cost\n   for two\
    \ candidate polynomials is shown in the following table.\n   +-----------------------------------+\n\
    \   | Polynomial  | k=32     | k=64     |\n   +-----------------------------------+\n\
    \   | CCITT-CRC32 | 1855     | 3572     |\n   +-----------------------------------+\n\
    \   | CRC32C      | 4784     | 7111     |\n   +-----------------------------------+\n\
    \   For 32-bit datapath, CCITT-CRC32 requires 40% of the number of cells\n   required\
    \ by the CRC32C.  For a 64-bit datapath, CCITT-CRC32 requires\n   50% of the number\
    \ of cells.\n   The total size of one of our smaller chips is roughly 1 million\n\
    \   cells.  The fraction represented by the CRC circuit is less than 1%.\n"
- title: 8. Implementation of CRC32C
  contents:
  - '8. Implementation of CRC32C

    '
- title: 8.1 A Serial Implementation in Hardware
  contents:
  - "8.1 A Serial Implementation in Hardware\n   A serial implementation that processes\
    \ one data bit at a time and\n   performs simultaneous multiplication of the data\
    \ polynomial by x^32\n   and division by the CRC32C polynomial is described in\
    \ the following\n   Verilog [ieee1364] code.\n   /////////////////////////////////////////////////////////////////////\n\
    \   //File: CRC32_D1.v\n   //Date: Tue Feb 26 02:47:05 2002\n   //\n   //Copyright\
    \ (C) 1999 Easics NV.\n   //This source file may be used and distributed without\
    \ restriction\n   //provided that this copyright statement is not removed from\
    \ the file\n   //and that any derivative work contains the original copyright\
    \ notice\n   //and the associated disclaimer.\n   //\n   //THIS SOURCE FILE IS\
    \ PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS\n   //OR IMPLIED WARRANTIES, INCLUDING,\
    \ WITHOUT LIMITATION, THE IMPLIED\n   //WARRANTIES OF MERCHANTIBILITY AND FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n   //\n   //Purpose: Verilog module containing a\
    \ synthesizable CRC function\n   //* polynomial: (0 1 2 4 5 7 8 10 11 12 16 22\
    \ 23 26 32)\n   //* data width: 1\n   //\n   //Info: jand@easics.be (Jan Decaluwe)\n\
    \   //http://www.easics.com\n   /////////////////////////////////////////////////////////////////////\n\
    \   module CRC32_D1;\n   // polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)\n\
    \   // data width: 1\n   function [31:0] nextCRC32_D1;\n   input Data;\n   input\
    \ [31:0] CRC;\n   reg [0:0] D;\n   reg [31:0] C;\n   reg [31:0] NewCRC;\n   begin\n\
    \   D[0] = Data;\n   C = CRC;\n   NewCRC[0] = D[0] ^ C[31];\n   NewCRC[1] = D[0]\
    \ ^ C[0] ^ C[31];\n   NewCRC[2] = D[0] ^ C[1] ^ C[31];\n   NewCRC[3] = C[2];\n\
    \   NewCRC[4] = D[0] ^ C[3] ^ C[31];\n   NewCRC[5] = D[0] ^ C[4] ^ C[31];\n  \
    \ NewCRC[6] = C[5];\n   NewCRC[7] = D[0] ^ C[6] ^ C[31];\n   NewCRC[8] = D[0]\
    \ ^ C[7] ^ C[31];\n   NewCRC[9] = C[8];\n   NewCRC[10] = D[0] ^ C[9] ^ C[31];\n\
    \   NewCRC[11] = D[0] ^ C[10] ^ C[31];\n   NewCRC[12] = D[0] ^ C[11] ^ C[31];\n\
    \   NewCRC[13] = C[12];\n   NewCRC[14] = C[13];\n   NewCRC[15] = C[14];\n   NewCRC[16]\
    \ = D[0] ^ C[15] ^ C[31];\n   NewCRC[17] = C[16];\n   NewCRC[18] = C[17];\n  \
    \ NewCRC[19] = C[18];\n   NewCRC[20] = C[19];\n   NewCRC[21] = C[20];\n   NewCRC[22]\
    \ = D[0] ^ C[21] ^ C[31];\n   NewCRC[23] = D[0] ^ C[22] ^ C[31];\n   NewCRC[24]\
    \ = C[23];\n   NewCRC[25] = C[24];\n   NewCRC[26] = D[0] ^ C[25] ^ C[31];\n  \
    \ NewCRC[27] = C[26];\n   NewCRC[28] = C[27];\n   NewCRC[29] = C[28];\n   NewCRC[30]\
    \ = C[29];\n   NewCRC[31] = C[30];\n   nextCRC32_D1 = NewCRC;\n   end\n   endfunction\n\
    \   endmodule\n"
- title: 8.2 A Parallel Implementation in Hardware
  contents:
  - "8.2 A Parallel Implementation in Hardware\n   A parallel implementation that\
    \ processes 32 data bits at a time is\n   described in the following Verilog [ieee1364]\
    \ code.  In software\n   implementations, the next state logic is typically implemented\
    \ by\n   means of tables indexed by the input and the current state.\n   /////////////////////////////////////////////////////////////////////\n\
    \   //File: CRC32_D32.v\n   //Date: Tue Feb 26 02:50:08 2002\n   //\n   //Copyright\
    \ (C) 1999 Easics NV.\n   //This source file may be used and distributed without\
    \ restriction\n   //provided that this copyright statement is not removed from\
    \ the file\n   //and that any derivative work contains the original copyright\
    \ notice\n   //and the associated disclaimer.\n   //\n   //THIS SOURCE FILE IS\
    \ PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS\n   //OR IMPLIED WARRANTIES, INCLUDING,\
    \ WITHOUT LIMITATION, THE IMPLIED\n   //WARRANTIES OF MERCHANTIBILITY AND FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n   //\n   //Purpose: Verilog module containing a\
    \ synthesizable CRC function\n   //* polynomial: p(0 to 32) := \"100000101111011000111011011110001\"\
    \n   //* data width: 32\n   //\n   //Info: jand@easics.be (Jan Decaluwe)\n   //http://www.easics.com\n\
    \   /////////////////////////////////////////////////////////////////////\n  \
    \ module CRC32_D32;\n   // polynomial: p(0 to 32) := \"100000101111011000111011011110001\"\
    \n   // data width: 32\n   // convention: the first serial data bit is D[31]\n\
    \   function [31:0] nextCRC32_D32;\n   input [31:0] Data;\n   input [31:0] CRC;\n\
    \   reg [31:0] D;\n   reg [31:0] C;\n   reg [31:0] NewCRC;\n   begin\n   D = Data;\n\
    \   C = CRC;\n   NewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^ D[23]\n\
    \   ^\n   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[12] ^ D[9] ^ D[8] ^\n   D[7] ^ D[6]\
    \ ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^\n   C[6] ^ C[7] ^ C[8] ^ C[9] ^\
    \ C[12] ^ C[16] ^ C[17] ^\n   C[18] ^ C[21] ^ C[23] ^ C[25] ^ C[26] ^ C[27] ^\
    \ C[28] ^\n   C[30] ^ C[31];\n   NewCRC[1] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[26]\
    \ ^ D[24] ^ D[22]\n   ^\n   D[19] ^ D[18] ^ D[17] ^ D[13] ^ D[10] ^ D[9] ^ D[8]\
    \ ^\n   D[7] ^ D[6] ^ D[5] ^ D[1] ^ C[1] ^ C[5] ^ C[6] ^ C[7] ^\n   C[8] ^ C[9]\
    \ ^ C[10] ^ C[13] ^ C[17] ^ C[18] ^ C[19] ^\n   C[22] ^ C[24] ^ C[26] ^ C[27]\
    \ ^ C[28] ^ C[29] ^ C[31];\n   NewCRC[2] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25]\
    \ ^ D[23] ^ D[20]\n   ^\n   D[19] ^ D[18] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8]\
    \ ^\n   D[7] ^ D[6] ^ D[2] ^ C[2] ^ C[6] ^ C[7] ^ C[8] ^ C[9] ^\n   C[10] ^ C[11]\
    \ ^ C[14] ^ C[18] ^ C[19] ^ C[20] ^ C[23] ^\n   C[25] ^ C[27] ^ C[28] ^ C[29]\
    \ ^ C[30];\n   NewCRC[3] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[24] ^ D[21]\n\
    \   ^\n   D[20] ^ D[19] ^ D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^\n   D[8] ^ D[7]\
    \ ^ D[3] ^ C[3] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^\n   C[11] ^ C[12] ^ C[15] ^ C[19]\
    \ ^ C[20] ^ C[21] ^ C[24] ^\n   C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];\n   NewCRC[4]\
    \ = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[25] ^ D[22] ^ D[21]\n   ^\n   D[20] ^ D[16]\
    \ ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^\n   D[8] ^ D[4] ^ C[4] ^ C[8] ^ C[9]\
    \ ^ C[10] ^ C[11] ^\n   C[12] ^ C[13] ^ C[16] ^ C[20] ^ C[21] ^ C[22] ^ C[25]\
    \ ^\n   C[27] ^ C[29] ^ C[30] ^ C[31];\n   NewCRC[5] = D[31] ^ D[30] ^ D[28] ^\
    \ D[26] ^ D[23] ^ D[22] ^ D[21]\n   ^\n   D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11]\
    \ ^ D[10] ^ D[9] ^\n   D[5] ^ C[5] ^ C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^\n\
    \   C[14] ^ C[17] ^ C[21] ^ C[22] ^ C[23] ^ C[26] ^ C[28] ^\n   C[30] ^ C[31];\n\
    \   NewCRC[6] = D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[22]\n   ^\n\
    \   D[21] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[11] ^\n   D[10] ^ D[9] ^\
    \ D[8] ^ D[7] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^\n   C[4] ^ C[5] ^ C[7] ^ C[8] ^ C[9]\
    \ ^ C[10] ^ C[11] ^\n   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[21] ^ C[22]\
    \ ^\n   C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30];\n   NewCRC[7] = D[31] ^\
    \ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23]\n   ^\n   D[22] ^ D[18] ^ D[17]\
    \ ^ D[16] ^ D[15] ^ D[14] ^ D[12] ^\n   D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^ D[5]\
    \ ^ D[1] ^\n   C[1] ^ C[5] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^\n   C[12] ^\
    \ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[18] ^ C[22] ^\n   C[23] ^ C[25] ^ C[26] ^\
    \ C[27] ^ C[29] ^ C[30] ^ C[31];\n   NewCRC[8] = D[25] ^ D[24] ^ D[21] ^ D[19]\
    \ ^ D[15] ^ D[13] ^ D[11]\n   ^\n   D[10] ^ D[8] ^ D[5] ^ D[4] ^ D[2] ^ D[0] ^\
    \ C[0] ^ C[2] ^\n   C[4] ^ C[5] ^ C[8] ^ C[10] ^ C[11] ^ C[13] ^ C[15] ^\n   C[19]\
    \ ^ C[21] ^ C[24] ^ C[25];\n   NewCRC[9] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[23]\
    \ ^ D[22] ^ D[21]\n   ^\n   D[20] ^ D[18] ^ D[17] ^ D[14] ^ D[11] ^ D[8] ^ D[7]\
    \ ^\n   D[4] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[4] ^\n   C[7] ^ C[8]\
    \ ^ C[11] ^ C[14] ^ C[17] ^ C[18] ^ C[20] ^\n   C[21] ^ C[22] ^ C[23] ^ C[27]\
    \ ^ C[28] ^ C[30] ^ C[31];\n   NewCRC[10] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25]\
    \ ^ D[24] ^\n   D[22] ^\n   D[19] ^ D[17] ^ D[16] ^ D[15] ^ D[7] ^ D[6] ^ D[2]\
    \ ^\n   D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[6] ^ C[7] ^ C[15] ^\n   C[16] ^ C[17]\
    \ ^ C[19] ^ C[22] ^ C[24] ^ C[25] ^ C[26] ^\n   C[27] ^ C[29] ^ C[30];\n   NewCRC[11]\
    \ = D[21] ^ D[20] ^ D[12] ^ D[9] ^ D[6] ^ D[5] ^ D[4] ^\n   D[3] ^ D[2] ^ D[1]\
    \ ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[3] ^\n   C[4] ^ C[5] ^ C[6] ^ C[9] ^ C[12] ^\
    \ C[20] ^ C[21];\n   NewCRC[12] = D[22] ^ D[21] ^ D[13] ^ D[10] ^ D[7] ^ D[6]\
    \ ^ D[5] ^\n   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^\n   C[5]\
    \ ^ C[6] ^ C[7] ^ C[10] ^ C[13] ^ C[21] ^ C[22];\n   NewCRC[13] = D[31] ^ D[30]\
    \ ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^\n   D[22] ^\n   D[21] ^ D[18] ^ D[17] ^ D[16]\
    \ ^ D[14] ^ D[12] ^ D[11] ^\n   D[9] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3]\
    \ ^ C[9] ^\n   C[11] ^ C[12] ^ C[14] ^ C[16] ^ C[17] ^ C[18] ^ C[21] ^\n   C[22]\
    \ ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^ C[30] ^ C[31];\n   NewCRC[14] = D[30] ^ D[29]\
    \ ^ D[25] ^ D[22] ^ D[21] ^ D[19] ^\n   D[16] ^\n   D[15] ^ D[13] ^ D[10] ^ D[9]\
    \ ^ D[8] ^ D[7] ^ D[6] ^\n   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^\
    \ C[5] ^\n   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[15] ^\n   C[16] ^ C[19]\
    \ ^ C[21] ^ C[22] ^ C[25] ^ C[29] ^ C[30];\n   NewCRC[15] = D[31] ^ D[30] ^ D[26]\
    \ ^ D[23] ^ D[22] ^ D[20] ^\n   D[17] ^\n   D[16] ^ D[14] ^ D[11] ^ D[10] ^ D[9]\
    \ ^ D[8] ^ D[7] ^\n   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^\n\
    \   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^ C[14] ^ C[16] ^\n   C[17] ^ C[20] ^ C[22]\
    \ ^ C[23] ^ C[26] ^ C[30] ^ C[31];\n   NewCRC[16] = D[31] ^ D[27] ^ D[24] ^ D[23]\
    \ ^ D[21] ^ D[18] ^\n   D[17] ^\n   D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8]\
    \ ^ D[7] ^\n   D[5] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[5] ^ C[7] ^ C[8] ^\n   C[9]\
    \ ^ C[10] ^ C[11] ^ C[12] ^ C[15] ^ C[17] ^ C[18] ^\n   C[21] ^ C[23] ^ C[24]\
    \ ^ C[27] ^ C[31];\n   NewCRC[17] = D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[19] ^ D[18]\
    \ ^\n   D[16] ^\n   D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^\n   D[4]\
    \ ^ D[3] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^\n   C[11] ^ C[12] ^ C[13]\
    \ ^ C[16] ^ C[18] ^ C[19] ^ C[22] ^\n   C[24] ^ C[25] ^ C[28];\n   NewCRC[18]\
    \ = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[21] ^\n   D[20] ^\n   D[19] ^ D[18]\
    \ ^ D[16] ^ D[14] ^ D[13] ^ D[11] ^ D[10] ^\n   D[8] ^ D[6] ^ D[0] ^ C[0] ^ C[6]\
    \ ^ C[8] ^ C[10] ^ C[11] ^\n   C[13] ^ C[14] ^ C[16] ^ C[18] ^ C[19] ^ C[20] ^\
    \ C[21] ^\n   C[27] ^ C[28] ^ C[29] ^ C[30] ^ C[31];\n   NewCRC[19] = D[29] ^\
    \ D[27] ^ D[26] ^ D[25] ^ D[23] ^ D[22] ^\n   D[20] ^\n   D[19] ^ D[18] ^ D[16]\
    \ ^ D[15] ^ D[14] ^ D[11] ^ D[8] ^\n   D[6] ^ D[5] ^ D[4] ^ D[1] ^ D[0] ^ C[0]\
    \ ^ C[1] ^ C[4] ^\n   C[5] ^ C[6] ^ C[8] ^ C[11] ^ C[14] ^ C[15] ^ C[16] ^\n \
    \  C[18] ^ C[19] ^ C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[26] ^\n   C[27] ^ C[29];\n\
    \   NewCRC[20] = D[31] ^ D[25] ^ D[24] ^ D[20] ^ D[19] ^ D[18] ^\n   D[15] ^\n\
    \   D[8] ^ D[4] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^\n   C[4] ^ C[8] ^\
    \ C[15] ^ C[18] ^ C[19] ^ C[20] ^ C[24] ^\n   C[25] ^ C[31];\n   NewCRC[21] =\
    \ D[26] ^ D[25] ^ D[21] ^ D[20] ^ D[19] ^ D[16] ^ D[9]\n   ^\n   D[5] ^ D[3] ^\
    \ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[5] ^\n   C[9] ^ C[16] ^ C[19] ^ C[20] ^\
    \ C[21] ^ C[25] ^ C[26];\n   NewCRC[22] = D[31] ^ D[30] ^ D[28] ^ D[25] ^ D[23]\
    \ ^ D[22] ^\n   D[20] ^\n   D[18] ^ D[16] ^ D[12] ^ D[10] ^ D[9] ^ D[8] ^ D[7]\
    \ ^\n   D[5] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[5] ^\n   C[7] ^ C[8]\
    \ ^ C[9] ^ C[10] ^ C[12] ^ C[16] ^ C[18] ^\n   C[20] ^ C[22] ^ C[23] ^ C[25] ^\
    \ C[28] ^ C[30] ^ C[31];\n   NewCRC[23] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25]\
    \ ^ D[24] ^\n   D[19] ^\n   D[18] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[7]\
    \ ^\n   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^\n   C[7] ^ C[10]\
    \ ^ C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^\n   C[19] ^ C[24] ^ C[25] ^ C[27]\
    \ ^ C[28] ^ C[29] ^ C[30];\n   NewCRC[24] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26]\
    \ ^ D[25] ^\n   D[20] ^\n   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[8]\
    \ ^\n   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^\n   C[8] ^ C[11]\
    \ ^ C[12] ^ C[13] ^ C[14] ^ C[17] ^ C[19] ^\n   C[20] ^ C[25] ^ C[26] ^ C[28]\
    \ ^ C[29] ^ C[30] ^ C[31];\n   NewCRC[25] = D[29] ^ D[28] ^ D[25] ^ D[23] ^ D[20]\
    \ ^ D[17] ^\n   D[16] ^\n   D[15] ^ D[14] ^ D[13] ^ D[8] ^ D[6] ^ D[4] ^ D[3]\
    \ ^\n   D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^\n   C[13] ^ C[14]\
    \ ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^ C[23] ^\n   C[25] ^ C[28] ^ C[29];\n   NewCRC[26]\
    \ = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^\n   D[23] ^\n   D[15] ^ D[14]\
    \ ^ D[12] ^ D[8] ^ D[6] ^ D[3] ^ D[1] ^\n   D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[6] ^\
    \ C[8] ^ C[12] ^ C[14] ^\n   C[15] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29]\
    \ ^\n   C[31];\n   NewCRC[27] = D[31] ^ D[29] ^ D[27] ^ D[24] ^ D[23] ^ D[21]\
    \ ^\n   D[18] ^\n   D[17] ^ D[15] ^ D[13] ^ D[12] ^ D[8] ^ D[6] ^ D[5] ^\n   D[2]\
    \ ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[5] ^ C[6] ^\n   C[8] ^ C[12] ^ C[13]\
    \ ^ C[15] ^ C[17] ^ C[18] ^ C[21] ^\n   C[23] ^ C[24] ^ C[27] ^ C[29] ^ C[31];\n\
    \   NewCRC[28] = D[31] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^\n   D[21] ^\n\
    \   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[8] ^ D[5] ^\n   D[4] ^ D[3] ^ D[2]\
    \ ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^\n   C[3] ^ C[4] ^ C[5] ^ C[8] ^ C[12] ^\
    \ C[13] ^ C[14] ^\n   C[17] ^ C[19] ^ C[21] ^ C[22] ^ C[23] ^ C[24] ^ C[26] ^\n\
    \   C[27] ^ C[31];\n   NewCRC[29] = D[28] ^ D[27] ^ D[25] ^ D[24] ^ D[23] ^ D[22]\
    \ ^\n   D[20] ^\n   D[18] ^ D[15] ^ D[14] ^ D[13] ^ D[9] ^ D[6] ^ D[5] ^\n   D[4]\
    \ ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^\n   C[5] ^ C[6] ^ C[9] ^\
    \ C[13] ^ C[14] ^ C[15] ^ C[18] ^\n   C[20] ^ C[22] ^ C[23] ^ C[24] ^ C[25] ^\
    \ C[27] ^ C[28];\n   NewCRC[30] = D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[23]\
    \ ^\n   D[21] ^\n   D[19] ^ D[16] ^ D[15] ^ D[14] ^ D[10] ^ D[7] ^ D[6] ^\n  \
    \ D[5] ^ D[4] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[4] ^ C[5] ^\n   C[6] ^ C[7] ^ C[10]\
    \ ^ C[14] ^ C[15] ^ C[16] ^ C[19] ^\n   C[21] ^ C[23] ^ C[24] ^ C[25] ^ C[26]\
    \ ^ C[28] ^ C[29];\n   NewCRC[31] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24]\
    \ ^\n   D[22] ^\n   D[20] ^ D[17] ^ D[16] ^ D[15] ^ D[11] ^ D[8] ^ D[7] ^\n  \
    \ D[6] ^ D[5] ^ D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[5] ^ C[6] ^\n   C[7] ^ C[8] ^ C[11]\
    \ ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^\n   C[22] ^ C[24] ^ C[25] ^ C[26] ^ C[27]\
    \ ^ C[29] ^ C[30];\n   nextCRC32_D32 = NewCRC;\n   end\n   endfunction\n"
- title: 8.3 Some Hardware Implementation Comments
  contents:
  - "8.3 Some Hardware Implementation Comments\n   The iSCSI spec specifies that the\
    \ most significant 32 bits of the\n   data be complemented prior to performing\
    \ the CRC computation.  For\n   most implementations of the CRC algorithm, such\
    \ as the ones described\n   here, which perform simultaneous multiplication by\
    \ x^32 and division\n   by the CRC polynomial, this is equivalent to initializing\
    \ the CRC\n   register to ones regardless of the CRC polynomial.  For other\n\
    \   implementations, in particular one that only performs division by the\n  \
    \ CRC polynomial (and for which the prescribed multiplication by x^32\n   is performed\
    \ externally) initializing the CRC register to ones does\n   not have the same\
    \ effect as complementing the most significant 32\n   bits of the message.  With\
    \ such implementations, for the CRC32c\n   polynomial, initializing the CRC register\
    \ to 0x2a26f826 has the same\n   effect as complementing the most significant\
    \ 32 bits of the data.\n   See reference [Tuikov&Cavanna] for more details.\n"
- title: 8.4 Fast Hardware Implementation References
  contents:
  - "8.4 Fast Hardware Implementation References\n   Fast hardware implementations\
    \ start from a canonic scheme (as the one\n   presented in 7.2) and optimize it\
    \ based on different criteria.  Two\n   classic papers on this subject are [Albertengo1990]\
    \ and [Glaise1997].\n   A more modern (and systematic) approach can be found in\
    \ [Shie2001]\n   and [Sprachman2001].\n"
- title: 9. Summary and Conclusions
  contents:
  - "9. Summary and Conclusions\n   The following table is a summary of the error\
    \ detection capabilities\n   of the different codes analyzed.  In the table, d\
    \ is the minimal\n   distance at block length block (in bits), i/byte - software\n\
    \   instructions/byte, Table size (if table lookup needed), T-look number\n  \
    \ of lookups/byte, Pudb - Pud burst and Puds - Pud sporadic:\n   +-----------------------------------------------------------+\n\
    \   | Code      |d| Block |i/Byte|Tsize|T-look| Pudb   | Puds   |\n   +-----------------------------------------------------------+\n\
    \   | Fletcher32|3| 2^19  | 2    |  -  | -    | 10^-37 | 10^-36 |\n   +-----------------------------------------------------------+\n\
    \   | Adler32   |3| 2^19  | 3    |  -  | -    | 10^-36 | 10^-35 |\n   +-----------------------------------------------------------+\n\
    \   | IEEE-802  |3| 2^16  | 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |\n   +-----------------------------------------------------------+\n\
    \   | CRC32C    |3| 2^31-1| 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |\n   +-----------------------------------------------------------+\n\
    \   The probabilities for undetected errors in the above table are\n   computed\
    \ assuming uniformly distributed data.  For real data - that\n   can be biased\
    \ - [Stone98], checksums behave substantially worse than\n   CRCs.\n   Considering\
    \ the protection level it offers, the lack of sensitivity\n   for biased data\
    \ and the large block it can protect, we think that\n   CRC32C is a good choice\
    \ as a basic error detection mechanism for\n   iSCSI.\n   Please observe also\
    \ that burst errors characterized by a fixed\n   average time will have a higher\
    \ impact on error detection capability\n   as the speed of the channels (machines\
    \ and networks) increases.  The\n   only way to keep the Pud within bounds for\
    \ the long-term is to reduce\n   the BER by using better coding of lower levels\
    \ of the channel.\n"
- title: 10. Security Considerations
  contents:
  - "10. Security Considerations\n   These codes detect unintentional changes to data\
    \ such as those caused\n   by noise. In an environment where an attacker can change\
    \ the data, it\n   can also change the error-detection code to match the new data.\n\
    \   Therefore, the error-detection codes overviewed here do not provide\n   protection\
    \ against attacks.  Indeed, these codes are not intended for\n   security purposes;\
    \ they are meant to be used within some application,\n   and the application's\
    \ threat model and security design control the\n   security considerations for\
    \ the use of the CRC.\n"
- title: 11. References and Bibliography
  contents:
  - "11. References and Bibliography\n   [Albertengo1990] G. Albertengo, R. Sisto,\
    \ \"Parallel CRC Generation\n                    IEEE Micro\", Vol. 10, No. 5,\
    \ October 1990, pp. 63-\n                    71.\n   [Arazi]          B Arazi,\
    \ \"A commonsense Approach to the Theory of\n                    Error Correcting\
    \ codes\".\n   [Baicheva]       T Baicheva, S Dodunekov and P Kazakov, \"Undetected\n\
    \                    error probability performance of cyclic redundancy-\n   \
    \                 check codes of 16-bit redundancy\", IEEE Proceedings\n     \
    \               on Communications, 147:253-256, October 2000.\n   [Black]    \
    \      \"Fast CRC32 in Software\"  by Richard Black, 1994, at\n              \
    \      www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crc.\n                  \
    \  html.\n   [Castagnoli93]   Guy Castagnoli, Stefan Braeuer and Martin Herrman\n\
    \                    \"Optimization of Cyclic Redundancy-Check Codes with\n  \
    \                  24 and 32 Parity Bits\", IEEE Transact. on\n              \
    \      Communications, Vol. 41, No. 6, June 1993.\n   [braun01]        Florian\
    \ Braun and Marcel Waldvogel, \"Fast\n                    Incremental CRC Updates\
    \ for IP over ATM Networks\",\n                    IEEE, High Performance Switching\
    \ and Routing, 2001,\n                    pp. 48-52.\n   [FITS]           \"NASA\
    \ FITS documents\" at http://heasarc.gsfc.nasa.\n                    gov/docs/heasarc/ofwg/docs/general/checksum/node26.\n\
    \                    html.\n   [Fujiwara89]     Toru Fujiwara, Tadao Kasami, and\
    \ Shu Lin, \"Error\n                    detecting capabilities of the shortened\
    \ hamming\n                    codes adopted forerror detection in IEEE standard\n\
    \                    802.3\", IEEE Transactions on Communications, COM-\n    \
    \                37:986989, September 1989.\n   [Glaise1997]     Glaise, R. J.,\
    \ \"A two-step computation of cyclic\n                    redundancy code CRC-32\
    \ for ATM networks\", IBM\n                    Journal of Research and Development,\
    \ Volume 41,\n                    Number 6, 1997.\n   [ieee1364]       IEEE Standard\
    \ Hardware Description Language Based on\n                    the Verilog Hardware\
    \ Description Language, IEEE\n                    Standard 1364-1995, December\
    \ 1995.\n   [LinCostello]    S. Lin and D.J. Costello, Jr., \"Error Control\n\
    \                    Coding: Fundamentals and Applications\", Englewood\n    \
    \                Cliffs, NJ: Prentice Hall, 1983.\n   [Peterson]       W Wesley\
    \ Peterson & E J Weldon - Error Correcting\n                    Codes - First\
    \ Edition 1961/Second Edition 1972.\n   [RFC2026]        Bradner, S., \"The Internet\
    \ Standards Process --\n                    Revision 3\", BCP 9, RFC 2026, October\
    \ 1996.\n   [Ritter]         Ritter, T. 1986. The Great CRC Mystery. Dr. Dobb's\n\
    \                    Journal of Software Tools. February. 11(2): 26-34,\n    \
    \                76-83.\n   [Polynomials]    \"Information on Primitive and Irreducible\n\
    \                    Polynomials\" at http://www.theory.csc.uvic.ca/~cos/\n  \
    \                  inf/neck/PolyInfo.html.\n   [RFC1146]        Zweig, J. and\
    \ C. Partridge, \"TCP Alternate Checksum\n                    Options\", RFC 1146,\
    \ March 1990.\n   [RFC1950]        Deutsch, P. and J. Gailly, \"ZLIB Compressed\
    \ Data\n                    Format Specification version 3.3\", RFC 1950, May\n\
    \                    1996.\n   [Shie2001]       Ming-Der Shieh, et. al, \"A Systematic\
    \ Approach for\n                    Parallel CRC Computations\", Journal of Information\n\
    \                    Science and Engineering, Vol.17 No.3, pp.445-461.\n   [Sprachman2001]\
    \  Michael Sprachman, \"Automatic Generation of Parallel\n                   \
    \ CRC Circuits\", IEEE Design & Test May-June 2001.\n   [Stone98]        J. Stone\
    \ et. al., \"Performance of Checksums and\n                    CRC's over Real\
    \ Data\", IEEE/ACM Transactions on\n                    Networking, Vol. 6, No.\
    \ 5, October 1998.\n   [Williams]       Ross Williams - A PAINLESS GUIDE TO CRC\
    \ ERROR\n                    DETECTION ALGORITHMS widely available on the net\
    \ -\n                    (e.g., ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt)\n\
    \   [Wolf82]         J.K. Wolf, Arnold Michelson and Allen Levesque, \"On\n  \
    \                  the probability of undetected error for linear block\n    \
    \                codes\", IEEE Transactions on Communications, COM-30:\n     \
    \               317-324, 1982.\n   [Wolf88]         J.K. Wolf, R.D. Blackeney,\
    \ \"An Exact Evaluation of\n                    the Probability of Undetected\
    \ Error for Certain\n                    Shortened Binary CRC Codes\", Proc. MILCOM\
    \ - IEEE\n                    1988.\n   [Wolf94J]        J.K. Wolf and Dexter\
    \ Chun, \"The single burst error\n                    detection performance of\
    \ binary cyclic codes\", IEEE\n                    Transactions on Communications\
    \ COM-42:11-13, January\n                    1994.\n   [Wolf94O]        Dexter\
    \ Chun and J.K. Wolf, \"Special Hardware for\n                    computing the\
    \ probability of undetected error for\n                    certain binary crc\
    \ codes and test results\", IEEE\n                    Transactions on Communications,\
    \ COM-42:2769-2772.\n   [Tuikov&Cavanna] Luben Tuikov and Vicente Cavanna, \"\
    The iSCSI CRC32C\n                    Digest and the Simultaneous Multiply and\
    \ Divide\n                    Algorithm\", January 30, 2002. White paper\n   \
    \                 distributed to the IETF ips iSCSI reflector.\n"
- title: 12. Acknowledgements
  contents:
  - "12. Acknowledgements\n   We would like to thank Matt Wakeley for providing us\
    \ with the\n   motivation to co-author this paper and for helpful discussions\
    \ on the\n   subject matter, during his employment with Agilent.\n"
- title: 13. Authors' Addresses
  contents:
  - "13. Authors' Addresses\n   Julian Satran\n   IBM, Haifa Research Lab\n   MATAM\
    \ - Advanced Technology Center\n   Haifa 31905, Israel\n   EMail: julian_satran@il.ibm.com\n\
    \   Dafna Sheinwald\n   IBM, Haifa Research Lab\n   MATAM - Advanced Technology\
    \ Center\n   Haifa 31905, Israel\n   EMail: Dafna_Sheinwald@il.ibm.com\n   Pat\
    \ Thaler\n   Agilent Technologies\n   1101 Creekside Ridge Drive\n   Suite 100,\
    \ M/S RH21\n   Roseville, CA 95661\n   EMail: pat_thaler@agilent.com\n   Vicente\
    \ Cavanna\n   Agilent Technologies\n   1101 Creekside Ridge Drive\n   Suite 100,\
    \ M/S RH21\n   Roseville, CA 95661\n   EMail: vince_cavanna@agilent.com\n"
- title: 14.  Full Copyright Statement
  contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2002).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
