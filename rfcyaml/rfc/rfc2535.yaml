- title: __initial_text__
  contents:
  - '                 Domain Name System Security Extensions

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Extensions to the Domain Name System (DNS) are described that provide\n\
    \   data integrity and authentication to security aware resolvers and\n   applications\
    \ through the use of cryptographic digital signatures.\n   These digital signatures\
    \ are included in secured zones as resource\n   records.  Security can also be\
    \ provided through non-security aware\n   DNS servers in some cases.\n   The extensions\
    \ provide for the storage of authenticated public keys\n   in the DNS.  This storage\
    \ of keys can support general public key\n   distribution services as well as\
    \ DNS security.  The stored keys\n   enable security aware resolvers to learn\
    \ the authenticating key of\n   zones in addition to those for which they are\
    \ initially configured.\n   Keys associated with DNS names can be retrieved to\
    \ support other\n   protocols.  Provision is made for a variety of key types and\n\
    \   algorithms.\n   In addition, the security extensions provide for the optional\n\
    \   authentication of DNS protocol transactions and requests.\n   This document\
    \ incorporates feedback on RFC 2065 from early\n   implementers and potential\
    \ users.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The significant contributions and suggestions of the following\n\
    \   persons (in alphabetic order) to DNS security are gratefully\n   acknowledged:\n\
    \      James M. Galvin\n      John Gilmore\n      Olafur Gudmundsson\n      Charlie\
    \ Kaufman\n      Edward Lewis\n      Thomas Narten\n      Radia J. Perlman\n \
    \     Jeffrey I. Schiller\n      Steven (Xunhua) Wang\n      Brian Wellington\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   Abstract...................................................1\n\
    \   Acknowledgments............................................2\n   1. Overview\
    \ of Contents....................................4\n   2. Overview of the DNS\
    \ Extensions..........................5\n   2.1 Services Not Provided..................................5\n\
    \   2.2 Key Distribution.......................................5\n   2.3 Data\
    \ Origin Authentication and Integrity...............6\n   2.3.1 The SIG Resource\
    \ Record..............................7\n   2.3.2 Authenticating Name and Type\
    \ Non-existence...........7\n   2.3.3 Special Considerations With Time-to-Live.............7\n\
    \   2.3.4 Special Considerations at Delegation Points..........8\n   2.3.5 Special\
    \ Considerations with CNAME....................8\n   2.3.6 Signers Other Than\
    \ The Zone..........................9\n   2.4 DNS Transaction and Request Authentication.............9\n\
    \   3. The KEY Resource Record................................10\n   3.1 KEY RDATA\
    \ format......................................10\n   3.1.1 Object Types, DNS Names,\
    \ and Keys...................11\n   3.1.2 The KEY RR Flag Field...............................11\n\
    \   3.1.3 The Protocol Octet..................................13\n   3.2 The KEY\
    \ Algorithm Number Specification................14\n   3.3 Interaction of Flags,\
    \ Algorithm, and Protocol Bytes...15\n   3.4 Determination of Zone Secure/Unsecured\
    \ Status.........15\n   3.5 KEY RRs in the Construction of Responses..............17\n\
    \   4. The SIG Resource Record................................17\n   4.1 SIG RDATA\
    \ Format......................................17\n   4.1.1 Type Covered Field..................................18\n\
    \   4.1.2 Algorithm Number Field..............................18\n   4.1.3 Labels\
    \ Field........................................18\n   4.1.4 Original TTL Field..................................19\n\
    \   4.1.5 Signature Expiration and Inception Fields...........19\n   4.1.6 Key\
    \ Tag Field.......................................20\n   4.1.7 Signer's Name Field.................................20\n\
    \   4.1.8 Signature Field.....................................20\n   4.1.8.1 Calculating\
    \ Transaction and Request SIGs..........21\n   4.2 SIG RRs in the Construction\
    \ of Responses..............21\n   4.3 Processing Responses and SIG RRs......................22\n\
    \   4.4 Signature Lifetime, Expiration, TTLs, and Validity....23\n   5. Non-existent\
    \ Names and Types...........................24\n   5.1 The NXT Resource Record...............................24\n\
    \   5.2 NXT RDATA Format......................................25\n   5.3 Additional\
    \ Complexity Due to Wildcards................26\n   5.4 Example...............................................26\n\
    \   5.5 Special Considerations at Delegation Points...........27\n   5.6 Zone\
    \ Transfers........................................27\n   5.6.1 Full Zone Transfers.................................28\n\
    \   5.6.2 Incremental Zone Transfers..........................28\n   6. How to\
    \ Resolve Securely and the AD and CD Bits.........29\n   6.1 The AD and CD Header\
    \ Bits.............................29\n   6.2 Staticly Configured Keys..............................31\n\
    \   6.3 Chaining Through The DNS..............................31\n   6.3.1 Chaining\
    \ Through KEYs...............................31\n   6.3.2 Conflicting Data....................................33\n\
    \   6.4 Secure Time...........................................33\n   7. ASCII\
    \ Representation of Security RRs...................34\n   7.1 Presentation of\
    \ KEY RRs...............................34\n   7.2 Presentation of SIG RRs...............................35\n\
    \   7.3 Presentation of NXT RRs...............................36\n   8. Canonical\
    \ Form and Order of Resource Records...........36\n   8.1 Canonical RR Form.....................................36\n\
    \   8.2 Canonical DNS Name Order..............................37\n   8.3 Canonical\
    \ RR Ordering Within An RRset.................37\n   8.4 Canonical Ordering of\
    \ RR Types........................37\n   9. Conformance............................................37\n\
    \   9.1 Server Conformance....................................37\n   9.2 Resolver\
    \ Conformance..................................38\n   10. Security Considerations...............................38\n\
    \   11. IANA Considerations...................................39\n   References................................................39\n\
    \   Author's Address..........................................41\n   Appendix\
    \ A: Base 64 Encoding..............................42\n   Appendix B: Changes\
    \ from RFC 2065.........................44\n   Appendix C: Key Tag Calculation...........................46\n\
    \   Full Copyright Statement..................................47\n"
- title: 1. Overview of Contents
  contents:
  - "1. Overview of Contents\n   This document standardizes extensions of the Domain\
    \ Name System (DNS)\n   protocol to support DNS security and public key distribution.\
    \ It\n   assumes that the reader is familiar with the Domain Name System,\n  \
    \ particularly as described in RFCs 1033, 1034, 1035 and later RFCs. An\n   earlier\
    \ version of these extensions appears in RFC 2065.  This\n   replacement for that\
    \ RFC incorporates early implementation experience\n   and requests from  potential\
    \ users.\n   Section 2 provides an overview of the extensions and the key\n  \
    \ distribution, data origin authentication, and transaction and request\n   security\
    \ they provide.\n   Section 3 discusses the KEY resource record, its structure,\
    \ and use\n   in DNS responses.  These resource records represent the public keys\n\
    \   of entities named in the DNS and are used for key distribution.\n   Section\
    \ 4 discusses the SIG digital signature resource record, its\n   structure, and\
    \ use in DNS responses.  These resource records are used\n   to authenticate other\
    \ resource records in the DNS and optionally to\n   authenticate DNS transactions\
    \ and requests.\n   Section 5 discusses the NXT resource record (RR) and its use\
    \ in DNS\n   responses including full and incremental zone transfers.  The NXT\
    \ RR\n   permits authenticated denial of the existence of a name or of an RR\n\
    \   type for an existing name.\n   Section 6 discusses how a resolver can be configured\
    \ with a starting\n   key or keys and proceed to securely resolve DNS requests.\n\
    \   Interactions between resolvers and servers are discussed for various\n   combinations\
    \ of security aware and security non-aware.  Two\n   additional DNS header bits\
    \ are defined for signaling between\n   resolvers and servers.\n   Section 7 describes\
    \ the ASCII representation of the security resource\n   records for use in master\
    \ files and elsewhere.\n   Section 8 defines the canonical form and order of RRs\
    \ for DNS\n   security purposes.\n   Section 9 defines levels of conformance for\
    \ resolvers and servers.\n   Section 10 provides a few paragraphs on overall security\n\
    \   considerations.\n   Section 11 specified IANA considerations for allocation\
    \ of additional\n   values of paramters defined in this document.\n   Appendix\
    \ A gives details of base 64 encoding which is used in the\n   file representation\
    \ of some RRs defined in this document.\n   Appendix B summarizes changes between\
    \ this memo and RFC 2065.\n   Appendix C specified how to calculate the simple\
    \ checksum used as a\n   key tag in most SIG RRs.\n   The key words \"MUST\",\
    \ \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document are\
    \ to be interpreted as described in [RFC2119].\n"
- title: 2. Overview of the DNS Extensions
  contents:
  - "2. Overview of the DNS Extensions\n   The Domain Name System (DNS) protocol security\
    \ extensions provide\n   three distinct services: key distribution as described\
    \ in Section 2.2\n   below, data origin authentication as described in Section\
    \ 2.3 below,\n   and transaction and request authentication, described in Section\
    \ 2.4\n   below.\n   Special considerations related to \"time to live\", CNAMEs,\
    \ and\n   delegation points are also discussed in Section 2.3.\n"
- title: 2.1 Services Not Provided
  contents:
  - "2.1 Services Not Provided\n   It is part of the design philosophy of the DNS\
    \ that the data in it is\n   public and that the DNS gives the same answers to\
    \ all inquirers.\n   Following this philosophy, no attempt has been made to include\
    \ any\n   sort of access control lists or other means to differentiate\n   inquirers.\n\
    \   No effort has been made to provide for any confidentiality for\n   queries\
    \ or responses.  (This service may be available via IPSEC [RFC\n   2401], TLS,\
    \ or other security protocols.)\n   Protection is not provided against denial\
    \ of service.\n"
- title: 2.2 Key Distribution
  contents:
  - "2.2 Key Distribution\n   A resource record format is defined to associate keys\
    \ with DNS names.\n   This permits the DNS to be used as a public key distribution\n\
    \   mechanism in support of DNS security itself and other protocols.\n   The syntax\
    \ of a KEY resource record (RR) is described in Section 3.\n   It includes an\
    \ algorithm identifier, the actual public key\n   parameter(s), and a variety\
    \ of flags including those indicating the\n   type of entity the key is associated\
    \ with and/or asserting that there\n   is no key associated with that entity.\n\
    \   Under conditions described in Section 3.5, security aware DNS servers\n  \
    \ will automatically attempt to return KEY resources as additional\n   information,\
    \ along with those resource records actually requested, to\n   minimize the number\
    \ of queries needed.\n"
- title: 2.3 Data Origin Authentication and Integrity
  contents:
  - "2.3 Data Origin Authentication and Integrity\n   Authentication is provided by\
    \ associating with resource record sets\n   (RRsets [RFC 2181]) in the DNS cryptographically\
    \ generated digital\n   signatures. Commonly, there will be a single private key\
    \ that\n   authenticates an entire zone but there might be multiple keys for\n\
    \   different algorithms, signers, etc. If a security aware resolver\n   reliably\
    \ learns a public key of the zone, it can authenticate, for\n   signed data read\
    \ from that zone, that it is properly authorized.  The\n   most secure implementation\
    \ is for the zone private key(s) to be kept\n   off-line and used to re-sign all\
    \ of the records in the zone\n   periodically.  However, there are cases, for\
    \ example dynamic update\n   [RFCs 2136, 2137], where DNS private keys need to\
    \ be on-line [RFC\n   2541].\n   The data origin authentication key(s) are associated\
    \ with the zone\n   and not with the servers that store copies of the data.  That\
    \ means\n   compromise of a secondary server or, if the key(s) are kept off line,\n\
    \   even the primary server for a zone, will not necessarily affect the\n   degree\
    \ of assurance that a resolver has that it can determine whether\n   data is genuine.\n\
    \   A resolver could learn a public key of a zone either by reading it\n   from\
    \ the DNS or by having it staticly configured.  To reliably learn\n   a public\
    \ key by reading it from the DNS, the key itself must be\n   signed with a key\
    \ the resolver trusts. The resolver must be\n   configured with at least a public\
    \ key which authenticates one zone as\n   a starting point. From there, it can\
    \ securely read public keys of\n   other zones, if the intervening zones in the\
    \ DNS tree are secure and\n   their signed keys accessible.\n   Adding data origin\
    \ authentication and integrity requires no change to\n   the \"on-the-wire\" DNS\
    \ protocol beyond the addition of the signature\n   resource type and the key\
    \ resource type needed for key distribution.\n   (Data non-existence authentication\
    \ also requires the NXT RR as\n   described in 2.3.2.)  This service can be supported\
    \ by existing\n   resolver and caching server implementations so long as they\
    \ can\n   support the additional resource types (see Section 9). The one\n   exception\
    \ is that CNAME referrals in a secure zone can not be\n   authenticated if they\
    \ are from non-security aware servers (see\n   Section 2.3.5).\n   If signatures\
    \ are separately retrieved and verified when retrieving\n   the information they\
    \ authenticate, there will be more trips to the\n   server and performance will\
    \ suffer.  Security aware servers mitigate\n   that degradation by attempting\
    \ to send the signature(s) needed (see\n   Section 4.2).\n"
- title: 2.3.1 The SIG Resource Record
  contents:
  - "2.3.1 The SIG Resource Record\n   The syntax of a SIG resource record (signature)\
    \ is described in\n   Section 4.  It cryptographicly binds the RRset being signed\
    \ to the\n   signer and a validity interval.\n   Every name in a secured zone\
    \ will have associated with it at least\n   one SIG resource record for each resource\
    \ type under that name except\n   for glue address RRs and delegation point NS\
    \ RRs.  A security aware\n   server will attempt to return, with RRs retrieved,\
    \ the corresponding\n   SIGs.  If a server is not security aware, the resolver\
    \ must retrieve\n   all the SIG records for a name and select the one or ones\
    \ that sign\n   the resource record set(s) that resolver is interested in.\n"
- title: 2.3.2 Authenticating Name and Type Non-existence
  contents:
  - "2.3.2 Authenticating Name and Type Non-existence\n   The above security mechanism\
    \ only provides a way to sign existing\n   RRsets in a zone.  \"Data origin\"\
    \ authentication is not obviously\n   provided for the non-existence of a domain\
    \ name in a zone or the\n   non-existence of a type for an existing name.  This\
    \ gap is filled by\n   the NXT RR which authenticatably asserts a range of non-existent\n\
    \   names in a zone and the non-existence of types for the existing name\n   just\
    \ before that range.\n   Section 5 below covers the NXT RR.\n"
- title: 2.3.3 Special Considerations With Time-to-Live
  contents:
  - "2.3.3 Special Considerations With Time-to-Live\n   A digital signature will fail\
    \ to verify if any change has occurred to\n   the data between the time it was\
    \ originally signed and the time the\n   signature is verified.  This conflicts\
    \ with our desire to have the\n   time-to-live (TTL) field of resource records\
    \ tick down while they are\n   cached.\n   This could be avoided by leaving the\
    \ time-to-live out of the digital\n   signature, but that would allow unscrupulous\
    \ servers to set\n   arbitrarily long TTL values undetected.  Instead, we include\
    \ the\n   \"original\" TTL in the signature and communicate that data along with\n\
    \   the current TTL. Unscrupulous servers under this scheme can\n   manipulate\
    \ the TTL but a security aware resolver will bound the TTL\n   value it uses at\
    \ the original signed value.  Separately, signatures\n   include a signature inception\
    \ time and a signature expiration time. A\n   resolver that knows the absolute\
    \ time can determine securely whether\n   a signature is in effect.  It is not\
    \ possible to rely solely on the\n   signature expiration as a substitute for\
    \ the TTL, however, since the\n   TTL is primarily a database consistency mechanism\
    \ and non-security\n   aware servers that depend on TTL must still be supported.\n"
- title: 2.3.4 Special Considerations at Delegation Points
  contents:
  - "2.3.4 Special Considerations at Delegation Points\n   DNS security would like\
    \ to view each zone as a unit of data\n   completely under the control of the\
    \ zone owner with each entry\n   (RRset) signed by a special private key held\
    \ by the zone manager.\n   But the DNS protocol views the leaf nodes in a zone,\
    \ which are also\n   the apex nodes of a subzone (i.e., delegation points), as\
    \ \"really\"\n   belonging to the subzone.  These nodes occur in two master files\
    \ and\n   might have RRs signed by both the upper and lower zone's keys. A\n \
    \  retrieval could get a mixture of these RRs and SIGs, especially since\n   one\
    \ server could be serving both the zone above and below a\n   delegation point.\
    \ [RFC 2181]\n   There MUST be a zone KEY RR, signed by its superzone, for every\n\
    \   subzone if the superzone is secure. This will normally appear in the\n   subzone\
    \ and may also be included in the superzone.  But, in the case\n   of an unsecured\
    \ subzone which can not or will not be modified to add\n   any security RRs, a\
    \ KEY declaring the subzone to be unsecured MUST\n   appear with the superzone\
    \ signature in the superzone, if the\n   superzone is secure. For all but one\
    \ other RR type the data from the\n   subzone is more authoritative so only the\
    \ subzone KEY RR should be\n   signed in the superzone if it appears there. The\
    \ NS and any glue\n   address RRs SHOULD only be signed in the subzone. The SOA\
    \ and any\n   other RRs that have the zone name as owner should appear only in\
    \ the\n   subzone and thus are signed only there. The NXT RR type is the\n   exceptional\
    \ case that will always appear differently and\n   authoritatively in both the\
    \ superzone and subzone, if both are\n   secure, as described in Section 5.\n"
- title: 2.3.5 Special Considerations with CNAME
  contents:
  - "2.3.5 Special Considerations with CNAME\n   There is a problem when security\
    \ related RRs with the same owner name\n   as a CNAME RR are retrieved from a\
    \ non-security-aware server. In\n   particular, an initial retrieval for the CNAME\
    \ or any other type may\n   not retrieve any associated SIG, KEY, or NXT RR. For\
    \ retrieved types\n   other than CNAME, it will retrieve that type at the target\
    \ name of\n   the CNAME (or chain of CNAMEs) and will also return the CNAME. \
    \ In\n   particular, a specific retrieval for type SIG will not get the SIG,\n\
    \   if any, at the original CNAME domain name but rather a SIG at the\n   target\
    \ name.\n   Security aware servers must be used to securely CNAME in DNS.\n  \
    \ Security aware servers MUST (1) allow KEY, SIG, and NXT RRs along\n   with CNAME\
    \ RRs, (2) suppress CNAME processing on retrieval of these\n   types as well as\
    \ on retrieval of the type CNAME, and (3)\n   automatically return SIG RRs authenticating\
    \ the CNAME or CNAMEs\n   encountered in resolving a query.  This is a change\
    \ from the previous\n   DNS standard [RFCs 1034/1035] which prohibited any other\
    \ RR type at a\n   node where a CNAME RR was present.\n"
- title: 2.3.6 Signers Other Than The Zone
  contents:
  - "2.3.6 Signers Other Than The Zone\n   There are cases where the signer in a SIG\
    \ resource record is other\n   than one of the private key(s) used to authenticate\
    \ a zone.\n   One is for support of dynamic update [RFC 2136] (or future requests\n\
    \   which require secure authentication) where an entity is permitted to\n   authenticate/update\
    \ its records [RFC 2137] and the zone is operating\n   in a mode where the zone\
    \ key is not on line. The public key of the\n   entity must be present in the\
    \ DNS and be signed by a zone level key\n   but the other RR(s) may be signed\
    \ with the entity's key.\n   A second case is support of transaction and request\
    \ authentication as\n   described in Section 2.4.\n   In additions, signatures\
    \ can be included on resource records within\n   the DNS for use by applications\
    \ other than DNS. DNS related\n   signatures authenticate that data originated\
    \ with the authority of a\n   zone owner or that a request or transaction originated\
    \ with the\n   relevant entity. Other signatures can provide other types of\n\
    \   assurances.\n"
- title: 2.4 DNS Transaction and Request Authentication
  contents:
  - "2.4 DNS Transaction and Request Authentication\n   The data origin authentication\
    \ service described above protects\n   retrieved resource records and the non-existence\
    \ of resource records\n   but provides no protection for DNS requests or for message\
    \ headers.\n   If header bits are falsely set by a bad server, there is little\
    \ that\n   can be done.  However, it is possible to add transaction\n   authentication.\
    \  Such authentication means that a resolver can be\n   sure it is at least getting\
    \ messages from the server it thinks it\n   queried and that the response is from\
    \ the query it sent (i.e., that\n   these messages have not been diddled in transit).\
    \  This is\n   accomplished by optionally adding a special SIG resource record\
    \ at\n   the end of the reply which digitally signs the concatenation of the\n\
    \   server's response and the resolver's query.\n   Requests can also be authenticated\
    \ by including a special SIG RR at\n   the end of the request.  Authenticating\
    \ requests serves no function\n   in older DNS servers and requests with a non-empty\
    \ additional\n   information section produce error returns or may even be ignored\
    \ by\n   many of them. However, this syntax for signing requests is defined as\n\
    \   a way of authenticating secure dynamic update requests [RFC 2137] or\n   future\
    \ requests requiring authentication.\n   The private keys used in transaction\
    \ security belong to the entity\n   composing the reply, not to the zone involved.\
    \  Request\n   authentication may also involve the private key of the host or\
    \ other\n   entity composing the request or other private keys depending on the\n\
    \   request authority it is sought to establish. The corresponding public\n  \
    \ key(s) are normally stored in and retrieved from the DNS for\n   verification.\n\
    \   Because requests and replies are highly variable, message\n   authentication\
    \ SIGs can not be pre-calculated.  Thus it will be\n   necessary to keep the private\
    \ key on-line, for example in software or\n   in a directly connected piece of\
    \ hardware.\n"
- title: 3. The KEY Resource Record
  contents:
  - "3. The KEY Resource Record\n   The KEY resource record (RR) is used to store\
    \ a public key that is\n   associated with a Domain Name System (DNS) name.  This\
    \ can be the\n   public key of a zone, a user, or a host or other end entity.\
    \ Security\n   aware DNS implementations MUST be designed to handle at least two\n\
    \   simultaneously valid keys of the same type associated with the same\n   name.\n\
    \   The type number for the KEY RR is 25.\n   A KEY RR is, like any other RR,\
    \ authenticated by a SIG RR.  KEY RRs\n   must be signed by a zone level key.\n"
- title: 3.1 KEY RDATA format
  contents:
  - "3.1 KEY RDATA format\n   The RDATA for a KEY RR consists of flags, a protocol\
    \ octet, the\n   algorithm number octet, and the public key itself.  The format\
    \ is as\n   follows:\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2\
    \ 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             flags             |    protocol   |   algorithm   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               /\n   /  \
    \                        public key                           /\n   /        \
    \                                                       /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   The KEY RR is not intended for storage of certificates and a separate\n  \
    \ certificate RR has been developed for that purpose, defined in [RFC\n   2538].\n\
    \   The meaning of the KEY RR owner name, flags, and protocol octet are\n   described\
    \ in Sections 3.1.1 through 3.1.5 below.  The flags and\n   algorithm must be\
    \ examined before any data following the algorithm\n   octet as they control the\
    \ existence and format of any following data.\n   The algorithm and public key\
    \ fields are described in Section 3.2.\n   The format of the public key is algorithm\
    \ dependent.\n   KEY RRs do not specify their validity period but their authenticating\n\
    \   SIG RR(s) do as described in Section 4 below.\n"
- title: 3.1.1 Object Types, DNS Names, and Keys
  contents:
  - "3.1.1 Object Types, DNS Names, and Keys\n   The public key in a KEY RR is for\
    \ the object named in the owner name.\n   A DNS name may refer to three different\
    \ categories of things.  For\n   example, foo.host.example could be (1) a zone,\
    \ (2) a host or other\n   end entity , or (3) the mapping into a DNS name of the\
    \ user or\n   account foo@host.example.  Thus, there are flag bits, as described\n\
    \   below, in the KEY RR to indicate with which of these roles the owner\n   name\
    \ and public key are associated.  Note that an appropriate zone\n   KEY RR MUST\
    \ occur at the apex node of a secure zone and zone KEY RRs\n   occur only at delegation\
    \ points.\n"
- title: 3.1.2 The KEY RR Flag Field
  contents:
  - "3.1.2 The KEY RR Flag Field\n   In the \"flags\" field:\n     0   1   2   3 \
    \  4   5   6   7   8   9   0   1   2   3   4   5\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   |  A/C  | Z | XT| Z | Z | NAMTYP| Z | Z | Z | Z |      SIG      |\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   Bit 0 and 1 are the key \"type\" bits whose values have the following\n  \
    \ meanings:\n           10: Use of the key is prohibited for authentication.\n\
    \           01: Use of the key is prohibited for confidentiality.\n          \
    \ 00: Use of the key for authentication and/or confidentiality\n             \
    \  is permitted. Note that DNS security makes use of keys\n               for\
    \ authentication only. Confidentiality use flagging is\n               provided\
    \ for use of keys in other protocols.\n               Implementations not intended\
    \ to support key distribution\n               for confidentiality MAY require\
    \ that the confidentiality\n               use prohibited bit be on for keys they\
    \ serve.\n           11: If both bits are one, the \"no key\" value, there is\
    \ no key\n               information and the RR stops after the algorithm octet.\n\
    \               By the use of this \"no key\" value, a signed KEY RR can\n   \
    \            authenticatably assert that, for example, a zone is not\n       \
    \        secured.  See section 3.4 below.\n   Bits 2 is reserved and must be zero.\n\
    \   Bits 3 is reserved as a flag extension bit.  If it is a one, a second\n  \
    \        16 bit flag field is added after the algorithm octet and\n          before\
    \ the key data.  This bit MUST NOT be set unless one or\n          more such additional\
    \ bits have been defined and are non-zero.\n   Bits 4-5 are reserved and must\
    \ be zero.\n   Bits 6 and 7 form a field that encodes the name type. Field values\n\
    \   have the following meanings:\n           00: indicates that this is a key\
    \ associated with a \"user\" or\n               \"account\" at an end entity,\
    \ usually a host.  The coding\n               of the owner name is that used for\
    \ the responsible\n               individual mailbox in the SOA and RP RRs: The\
    \ owner name\n               is the user name as the name of a node under the\
    \ entity\n               name.  For example, \"j_random_user\" on\n          \
    \     host.subdomain.example could have a public key associated\n            \
    \   through a KEY RR with name\n               j_random_user.host.subdomain.example.\
    \  It could be used\n               in a security protocol where authentication\
    \ of a user was\n               desired.  This key might be useful in IP or other\n\
    \               security for a user level service such a telnet, ftp,\n      \
    \         rlogin, etc.\n           01: indicates that this is a zone key for the\
    \ zone whose name\n               is the KEY RR owner name.  This is the public\
    \ key used\n               for the primary DNS security feature of data origin\n\
    \               authentication.  Zone KEY RRs occur only at delegation\n     \
    \          points.\n           10: indicates that this is a key associated with\
    \ the non-zone\n               \"entity\" whose name is the RR owner name.  This\
    \ will\n               commonly be a host but could, in some parts of the DNS\n\
    \               tree, be some other type of entity such as a telephone\n     \
    \          number [RFC 1530] or numeric IP address.  This is the\n           \
    \    public key used in connection with DNS request and\n               transaction\
    \ authentication services.  It could also be\n               used in an IP-security\
    \ protocol where authentication at\n               the host, rather than user,\
    \ level was desired, such as\n               routing, NTP, etc.\n           11:\
    \ reserved.\n   Bits 8-11 are reserved and must be zero.\n   Bits 12-15 are the\
    \ \"signatory\" field.  If non-zero, they indicate\n              that the key\
    \ can validly sign things as specified in DNS\n              dynamic update [RFC\
    \ 2137].  Note that zone keys (see bits\n              6 and 7 above) always have\
    \ authority to sign any RRs in\n              the zone regardless of the value\
    \ of the signatory field.\n"
- title: 3.1.3 The Protocol Octet
  contents:
  - "3.1.3 The Protocol Octet\n   It is anticipated that keys stored in DNS will be\
    \ used in conjunction\n   with a variety of Internet protocols.  It is intended\
    \ that the\n   protocol octet and possibly some of the currently unused (must\
    \ be\n   zero) bits in the KEY RR flags as specified in the future will be\n \
    \  used to indicate a key's validity for different protocols.\n   The following\
    \ values of the Protocol Octet are reserved as indicated:\n        VALUE   Protocol\n\
    \          0      -reserved\n          1     TLS\n          2     email\n    \
    \      3     dnssec\n          4     IPSEC\n         5-254   - available for assignment\
    \ by IANA\n        255     All\n   In more detail:\n        1 is reserved for\
    \ use in connection with TLS.\n        2 is reserved for use in connection with\
    \ email.\n        3 is used for DNS security.  The protocol field SHOULD be set\
    \ to\n          this value for zone keys and other keys used in DNS security.\n\
    \          Implementations that can determine that a key is a DNS\n          security\
    \ key by the fact that flags label it a zone key or the\n          signatory flag\
    \ field is non-zero are NOT REQUIRED to check the\n          protocol field.\n\
    \        4 is reserved to refer to the Oakley/IPSEC [RFC 2401] protocol\n    \
    \      and indicates that this key is valid for use in conjunction\n         \
    \ with that security standard.  This key could be used in\n          connection\
    \ with secured communication on behalf of an end\n          entity or user whose\
    \ name is the owner name of the KEY RR if\n          the entity or user flag bits\
    \ are set.  The presence of a KEY\n          resource with this protocol value\
    \ is an assertion that the\n          host speaks Oakley/IPSEC.\n        255 indicates\
    \ that the key can be used in connection with any\n          protocol for which\
    \ KEY RR protocol octet values have been\n          defined.  The use of this\
    \ value is discouraged and the use of\n          different keys for different\
    \ protocols is encouraged.\n"
- title: 3.2 The KEY Algorithm Number Specification
  contents:
  - "3.2 The KEY Algorithm Number Specification\n   This octet is the key algorithm\
    \ parallel to the same field for the\n   SIG resource as described in Section\
    \ 4.1.  The following values are\n   assigned:\n   VALUE   Algorithm\n     0 \
    \     - reserved, see Section 11\n     1     RSA/MD5 [RFC 2537] - recommended\n\
    \     2     Diffie-Hellman [RFC 2539] - optional, key only\n     3     DSA [RFC\
    \ 2536] - MANDATORY\n     4     reserved for elliptic curve crypto\n   5-251 \
    \   - available, see Section 11\n   252     reserved for indirect keys\n   253\
    \     private - domain name (see below)\n   254     private - OID (see below)\n\
    \   255      - reserved, see Section 11\n   Algorithm specific formats and procedures\
    \ are given in separate\n   documents.  The mandatory to implement for interoperability\
    \ algorithm\n   is number 3, DSA.  It is recommended that the RSA/MD5 algorithm,\n\
    \   number 1, also be implemented.  Algorithm 2 is used to indicate\n   Diffie-Hellman\
    \ keys and algorithm 4 is reserved for elliptic curve.\n   Algorithm number 252\
    \ indicates an indirect key format where the\n   actual key material is elsewhere.\
    \  This format is to be defined in a\n   separate document.\n   Algorithm numbers\
    \ 253 and 254 are reserved for private use and will\n   never be assigned a specific\
    \ algorithm.  For number 253, the public\n   key area and the signature begin\
    \ with a wire encoded domain name.\n   Only local domain name compression is permitted.\
    \  The domain name\n   indicates the private algorithm to use and the remainder\
    \ of the\n   public key area is whatever is required by that algorithm.  For\n\
    \   number 254, the public key area for the KEY RR and the signature\n   begin\
    \ with an unsigned length byte followed by a BER encoded Object\n   Identifier\
    \ (ISO OID) of that length.  The OID indicates the private\n   algorithm in use\
    \ and the remainder of the area is whatever is\n   required by that algorithm.\
    \  Entities should only use domain names\n   and OIDs they control to designate\
    \ their private algorithms.\n   Values 0 and 255 are reserved but the value 0\
    \ is used in the\n   algorithm field when that field is not used.  An example\
    \ is in a KEY\n   RR with the top two flag bits on, the \"no-key\" value, where\
    \ no key is\n   present.\n"
- title: 3.3 Interaction of Flags, Algorithm, and Protocol Bytes
  contents:
  - "3.3 Interaction of Flags, Algorithm, and Protocol Bytes\n   Various combinations\
    \ of the no-key type flags, algorithm byte,\n   protocol byte, and any future\
    \ assigned protocol indicating flags are\n   possible.  The meaning of these combinations\
    \ is indicated below:\n   NK = no key type (flags bits 0 and 1 on)\n   AL = algorithm\
    \ byte\n   PR = protocols indicated by protocol byte or future assigned flags\n\
    \   x represents any valid non-zero value(s).\n    AL  PR   NK  Meaning\n    \
    \ 0   0   0   Illegal, claims key but has bad algorithm field.\n     0   0   1\
    \   Specifies total lack of security for owner zone.\n     0   x   0   Illegal,\
    \ claims key but has bad algorithm field.\n     0   x   1   Specified protocols\
    \ unsecured, others may be secure.\n     x   0   0   Gives key but no protocols\
    \ to use it.\n     x   0   1   Denies key for specific algorithm.\n     x   x\
    \   0   Specifies key for protocols.\n     x   x   1   Algorithm not understood\
    \ for protocol.\n"
- title: 3.4 Determination of Zone Secure/Unsecured Status
  contents:
  - "3.4 Determination of Zone Secure/Unsecured Status\n   A zone KEY RR with the\
    \ \"no-key\" type field value (both key type flag\n   bits 0 and 1 on) indicates\
    \ that the zone named is unsecured while a\n   zone KEY RR with a key present\
    \ indicates that the zone named is\n   secure.  The secured versus unsecured status\
    \ of a zone may vary with\n   different cryptographic algorithms.  Even for the\
    \ same algorithm,\n   conflicting zone KEY RRs may be present.\n   Zone KEY RRs,\
    \ like all RRs, are only trusted if they are\n   authenticated by a SIG RR whose\
    \ signer field is a signer for which\n   the resolver has a public key they trust\
    \ and where resolver policy\n   permits that signer to sign for the KEY owner\
    \ name.  Untrusted zone\n   KEY RRs MUST be ignored in determining the security\
    \ status of the\n   zone.  However, there can be multiple sets of trusted zone\
    \ KEY RRs\n   for a zone with different algorithms, signers, etc.\n   For any\
    \ particular algorithm, zones can be (1) secure, indicating\n   that any retrieved\
    \ RR must be authenticated by a SIG RR or it will be\n   discarded as bogus, (2)\
    \ unsecured, indicating that SIG RRs are not\n   expected or required for RRs\
    \ retrieved from the zone, or (3)\n   experimentally secure, which indicates that\
    \ SIG RRs might or might\n   not be present but must be checked if found.  The\
    \ status of a zone is\n   determined as follows:\n   1. If, for a zone and algorithm,\
    \ every trusted zone KEY RR for the\n      zone says there is no key for that\
    \ zone, it is unsecured for that\n      algorithm.\n   2. If, there is at least\
    \ one trusted no-key zone KEY RR and one\n      trusted key specifying zone KEY\
    \ RR, then that zone is only\n      experimentally secure for the algorithm. \
    \ Both authenticated and\n      non-authenticated RRs for it should be accepted\
    \ by the resolver.\n   3. If every trusted zone KEY RR that the zone and algorithm\
    \ has is\n      key specifying, then it is secure for that algorithm and only\n\
    \      authenticated RRs from it will be accepted.\n   Examples:\n   (1)  A resolver\
    \ initially trusts only signatures by the superzone of\n   zone Z within the DNS\
    \ hierarchy.  Thus it will look only at the KEY\n   RRs that are signed by the\
    \ superzone.  If it finds only no-key KEY\n   RRs, it will assume the zone is\
    \ not secure.  If it finds only key\n   specifying KEY RRs, it will assume the\
    \ zone is secure and reject any\n   unsigned responses.  If it finds both, it\
    \ will assume the zone is\n   experimentally secure\n   (2)  A resolver trusts\
    \ the superzone of zone Z (to which it got\n   securely from its local zone) and\
    \ a third party, cert-auth.example.\n   When considering data from zone Z, it\
    \ may be signed by the superzone\n   of Z, by cert-auth.example, by both, or by\
    \ neither.  The following\n   table indicates whether zone Z will be considered\
    \ secure,\n   experimentally secure, or unsecured, depending on the signed zone\
    \ KEY\n   RRs for Z;\n                      c e r t - a u t h . e x a m p l e\n\
    \        KEY RRs|   None    |  NoKeys   |  Mixed   |   Keys   |\n     S      \
    \ --+-----------+-----------+----------+----------+\n     u  None   | illegal\
    \   | unsecured | experim. | secure   |\n     p       --+-----------+-----------+----------+----------+\n\
    \     e  NoKeys | unsecured | unsecured | experim. | secure   |\n     r      \
    \ --+-----------+-----------+----------+----------+\n     Z  Mixed  | experim.\
    \  | experim.  | experim. | secure   |\n     o       --+-----------+-----------+----------+----------+\n\
    \     n  Keys   | secure    | secure    | secure   | secure   |\n     e      \
    \   +-----------+-----------+----------+----------+\n"
- title: 3.5 KEY RRs in the Construction of Responses
  contents:
  - "3.5 KEY RRs in the Construction of Responses\n   An explicit request for KEY\
    \ RRs does not cause any special additional\n   information processing except,\
    \ of course, for the corresponding SIG\n   RR from a security aware server (see\
    \ Section 4.2).\n   Security aware DNS servers include KEY RRs as additional information\n\
    \   in responses, where a KEY is available, in the following cases:\n   (1) On\
    \ the retrieval of SOA or NS RRs, the KEY RRset with the same\n   name (perhaps\
    \ just a zone key) SHOULD be included as additional\n   information if space is\
    \ available. If not all additional information\n   will fit, type A and AAAA glue\
    \ RRs have higher priority than KEY\n   RR(s).\n   (2) On retrieval of type A\
    \ or AAAA RRs, the KEY RRset with the same\n   name (usually just a host RR and\
    \ NOT the zone key (which usually\n   would have a different name)) SHOULD be\
    \ included if space is\n   available.  On inclusion of A or AAAA RRs as additional\
    \ information,\n   the KEY RRset with the same name should also be included but\
    \ with\n   lower priority than the A or AAAA RRs.\n"
- title: 4. The SIG Resource Record
  contents:
  - "4. The SIG Resource Record\n   The SIG or \"signature\" resource record (RR)\
    \ is the fundamental way\n   that data is authenticated in the secure Domain Name\
    \ System (DNS). As\n   such it is the heart of the security provided.\n   The\
    \ SIG RR unforgably authenticates an RRset [RFC 2181] of a\n   particular type,\
    \ class, and name and binds it to a time interval and\n   the signer's domain\
    \ name.  This is done using cryptographic\n   techniques and the signer's private\
    \ key.  The signer is frequently\n   the owner of the zone from which the RR originated.\n\
    \   The type number for the SIG RR type is 24.\n"
- title: 4.1 SIG RDATA Format
  contents:
  - "4.1 SIG RDATA Format\n   The RDATA portion of a SIG RR is as shown below.  The\
    \ integrity of\n   the RDATA information is protected by the signature field.\n\
    \                           1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |        type covered           |  algorithm    |     labels    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         original TTL                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                      signature expiration                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      signature inception                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |            key  tag           |                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         signer's name         +\n      |\
    \                                                               /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-/\n\
    \      /                                                               /\n   \
    \   /                            signature                          /\n      /\
    \                                                               /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.1.1 Type Covered Field
  contents:
  - "4.1.1 Type Covered Field\n   The \"type covered\" is the type of the other RRs\
    \ covered by this SIG.\n"
- title: 4.1.2 Algorithm Number Field
  contents:
  - "4.1.2 Algorithm Number Field\n   This octet is as described in section 3.2.\n"
- title: 4.1.3 Labels Field
  contents:
  - "4.1.3 Labels Field\n   The \"labels\" octet is an unsigned count of how many\
    \ labels there are\n   in the original SIG RR owner name not counting the null\
    \ label for\n   root and not counting any initial \"*\" for a wildcard.  If a\
    \ secured\n   retrieval is the result of wild card substitution, it is necessary\n\
    \   for the resolver to use the original form of the name in verifying\n   the\
    \ digital signature.  This field makes it easy to determine the\n   original form.\n\
    \   If, on retrieval, the RR appears to have a longer name than indicated\n  \
    \ by \"labels\", the resolver can tell it is the result of wildcard\n   substitution.\
    \  If the RR owner name appears to be shorter than the\n   labels count, the SIG\
    \ RR must be considered corrupt and ignored.  The\n   maximum number of labels\
    \ allowed in the current DNS is 127 but the\n   entire octet is reserved and would\
    \ be required should DNS names ever\n   be expanded to 255 labels.  The following\
    \ table gives some examples.\n   The value of \"labels\" is at the top, the retrieved\
    \ owner name on the\n   left, and the table entry is the name to use in signature\n\
    \   verification except that \"bad\" means the RR is corrupt.\n   labels= |  0\
    \  |   1  |    2   |      3   |      4   |\n   --------+-----+------+--------+----------+----------+\n\
    \          .|   . | bad  |  bad   |    bad   |    bad   |\n         d.|  *. |\
    \   d. |  bad   |    bad   |    bad   |\n       c.d.|  *. | *.d. |   c.d. |  \
    \  bad   |    bad   |\n     b.c.d.|  *. | *.d. | *.c.d. |   b.c.d. |    bad  \
    \ |\n   a.b.c.d.|  *. | *.d. | *.c.d. | *.b.c.d. | a.b.c.d. |\n"
- title: 4.1.4 Original TTL Field
  contents:
  - "4.1.4 Original TTL Field\n   The \"original TTL\" field is included in the RDATA\
    \ portion to avoid\n   (1) authentication problems that caching servers would\
    \ otherwise\n   cause by decrementing the real TTL field and (2) security problems\n\
    \   that unscrupulous servers could otherwise cause by manipulating the\n   real\
    \ TTL field.  This original TTL is protected by the signature\n   while the current\
    \ TTL field is not.\n   NOTE:  The \"original TTL\" must be restored into the\
    \ covered RRs when\n   the signature is verified (see Section 8).  This generaly\
    \ implies\n   that all RRs for a particular type, name, and class, that is, all\
    \ the\n   RRs in any particular RRset, must have the same TTL to start with.\n"
- title: 4.1.5 Signature Expiration and Inception Fields
  contents:
  - "4.1.5 Signature Expiration and Inception Fields\n   The SIG is valid from the\
    \ \"signature inception\" time until the\n   \"signature expiration\" time.  Both\
    \ are unsigned numbers of seconds\n   since the start of 1 January 1970, GMT,\
    \ ignoring leap seconds.  (See\n   also Section 4.4.)  Ring arithmetic is used\
    \ as for DNS SOA serial\n   numbers [RFC 1982] which means that these times can\
    \ never be more\n   than about 68 years in the past or the future.  This means\
    \ that these\n   times are ambiguous modulo ~136.09 years.  However there is no\n\
    \   security flaw because keys are required to be changed to new random\n   keys\
    \ by [RFC 2541] at least every five years.  This means that the\n   probability\
    \ that the same key is in use N*136.09 years later should\n   be the same as the\
    \ probability that a random guess will work.\n   A SIG RR may have an expiration\
    \ time numerically less than the\n   inception time if the expiration time is\
    \ near the 32 bit wrap around\n   point and/or the signature is long lived.\n\
    \   (To prevent misordering of network requests to update a zone\n   dynamically,\
    \ monotonically increasing \"signature inception\" times may\n   be necessary.)\n\
    \   A secure zone must be considered changed for SOA serial number\n   purposes\
    \ not only when its data is updated but also when new SIG RRs\n   are inserted\
    \ (ie, the zone or any part of it is re-signed).\n"
- title: 4.1.6 Key Tag Field
  contents:
  - "4.1.6 Key Tag Field\n   The \"key Tag\" is a two octet quantity that is used\
    \ to efficiently\n   select between multiple keys which may be applicable and\
    \ thus check\n   that a public key about to be used for the computationally expensive\n\
    \   effort to check the signature is possibly valid.  For algorithm 1\n   (MD5/RSA)\
    \ as defined in [RFC 2537], it is the next to the bottom two\n   octets of the\
    \ public key modulus needed to decode the signature\n   field.  That is to say,\
    \ the most significant 16 of the least\n   significant 24 bits of the modulus\
    \ in network (big endian) order. For\n   all other algorithms, including private\
    \ algorithms, it is calculated\n   as a simple checksum of the KEY RR as described\
    \ in Appendix C.\n"
- title: 4.1.7 Signer's Name Field
  contents:
  - "4.1.7 Signer's Name Field\n   The \"signer's name\" field is the domain name\
    \ of the signer generating\n   the SIG RR.  This is the owner name of the public\
    \ KEY RR that can be\n   used to verify the signature.  It is frequently the zone\
    \ which\n   contained the RRset being authenticated.  Which signers should be\n\
    \   authorized to sign what is a significant resolver policy question as\n   discussed\
    \ in Section 6. The signer's name may be compressed with\n   standard DNS name\
    \ compression when being transmitted over the\n   network.\n"
- title: 4.1.8 Signature Field
  contents:
  - "4.1.8 Signature Field\n   The actual signature portion of the SIG RR binds the\
    \ other RDATA\n   fields to the RRset of the \"type covered\" RRs with that owner\
    \ name\n   and class.  This covered RRset is thereby authenticated.  To\n   accomplish\
    \ this, a data sequence is constructed as follows:\n         data = RDATA | RR(s)...\n\
    \   where \"|\" is concatenation,\n   RDATA is the wire format of all the RDATA\
    \ fields in the SIG RR itself\n   (including the canonical form of the signer's\
    \ name) before but not\n   including the signature, and\n   RR(s) is the RRset\
    \ of the RR(s) of the type covered with the same\n   owner name and class as the\
    \ SIG RR in canonical form and order as\n   defined in Section 8.\n   How this\
    \ data sequence is processed into the signature is algorithm\n   dependent.  These\
    \ algorithm dependent formats and procedures are\n   described in separate documents\
    \ (Section 3.2).\n   SIGs SHOULD NOT be included in a zone for any \"meta-type\"\
    \ such as\n   ANY, AXFR, etc. (but see section 5.6.2 with regard to IXFR).\n"
- title: 4.1.8.1 Calculating Transaction and Request SIGs
  contents:
  - "4.1.8.1 Calculating Transaction and Request SIGs\n   A response message from\
    \ a security aware server may optionally\n   contain a special SIG at the end\
    \ of the additional information\n   section to authenticate the transaction.\n\
    \   This SIG has a \"type covered\" field of zero, which is not a valid RR\n \
    \  type.  It is calculated by using a \"data\" (see Section 4.1.8) of the\n  \
    \ entire preceding DNS reply message, including DNS header but not the\n   IP\
    \ header and before the reply RR counts have been adjusted for the\n   inclusion\
    \ of any transaction SIG, concatenated with the entire DNS\n   query message that\
    \ produced this response, including the query's DNS\n   header and any request\
    \ SIGs but not its IP header.  That is\n      data = full response (less transaction\
    \ SIG) | full query\n   Verification of the transaction SIG (which is signed by\
    \ the server\n   host key, not the zone key) by the requesting resolver shows\
    \ that the\n   query and response were not tampered with in transit, that the\n\
    \   response corresponds to the intended query, and that the response\n   comes\
    \ from the queried server.\n   A DNS request may be optionally signed by including\
    \ one or more SIGs\n   at the end of the query. Such SIGs are identified by having\
    \ a \"type\n   covered\" field of zero. They sign the preceding DNS request message\n\
    \   including DNS header but not including the IP header or any request\n   SIGs\
    \ at the end and before the request RR counts have been adjusted\n   for the inclusions\
    \ of any request SIG(s).\n   WARNING: Request SIGs are unnecessary for any currently\
    \ defined\n   request other than update [RFC 2136, 2137] and will cause some old\n\
    \   DNS servers to give an error return or ignore a query.  However, such\n  \
    \ SIGs may in the future be needed for other requests.\n   Except where needed\
    \ to authenticate an update or similar privileged\n   request, servers are not\
    \ required to check request SIGs.\n"
- title: 4.2 SIG RRs in the Construction of Responses
  contents:
  - "4.2 SIG RRs in the Construction of Responses\n   Security aware DNS servers SHOULD,\
    \ for every authenticated RRset the\n   query will return, attempt to send the\
    \ available SIG RRs which\n   authenticate the requested RRset.  The following\
    \ rules apply to the\n   inclusion of SIG RRs in responses:\n     1. when an RRset\
    \ is placed in a response, its SIG RR has a higher\n        priority for inclusion\
    \ than additional RRs that may need to be\n        included.  If space does not\
    \ permit its inclusion, the response\n        MUST be considered truncated except\
    \ as provided in 2 below.\n     2. When a SIG RR is present in the zone for an\
    \ additional\n        information section RR, the response MUST NOT be considered\n\
    \        truncated merely because space does not permit the inclusion of\n   \
    \     the SIG RR with the additional information.\n     3. SIGs to authenticate\
    \ glue records and NS RRs for subzones at a\n        delegation point are unnecessary\
    \ and MUST NOT be sent.\n     4. If a SIG covers any RR that would be in the answer\
    \ section of\n        the response, its automatic inclusion MUST be in the answer\n\
    \        section.  If it covers an RR that would appear in the authority\n   \
    \     section, its automatic inclusion MUST be in the authority\n        section.\
    \  If it covers an RR that would appear in the additional\n        information\
    \ section it MUST appear in the additional information\n        section.  This\
    \ is a change in the existing standard [RFCs 1034,\n        1035] which contemplates\
    \ only NS and SOA RRs in the authority\n        section.\n     5. Optionally,\
    \ DNS transactions may be authenticated by a SIG RR at\n        the end of the\
    \ response in the additional information section\n        (Section 4.1.8.1). \
    \ Such SIG RRs are signed by the DNS server\n        originating the response.\
    \  Although the signer field MUST be a\n        name of the originating server\
    \ host, the owner name, class, TTL,\n        and original TTL, are meaningless.\
    \  The class and TTL fields\n        SHOULD be zero.  To conserve space, the owner\
    \ name SHOULD be\n        root (a single zero octet).  If transaction authentication\
    \ is\n        desired, that SIG RR must be considered the highest priority for\n\
    \        inclusion.\n"
- title: 4.3 Processing Responses and SIG RRs
  contents:
  - "4.3 Processing Responses and SIG RRs\n   The following rules apply to the processing\
    \ of SIG RRs included in a\n   response:\n     1. A security aware resolver that\
    \ receives a response from a\n        security aware server via a secure communication\
    \ with the AD bit\n        (see Section 6.1) set, MAY choose to accept the RRs\
    \ as received\n        without verifying the zone SIG RRs.\n     2. In other cases,\
    \ a security aware resolver SHOULD verify the SIG\n        RRs for the RRs of\
    \ interest.  This may involve initiating\n        additional queries for SIG or\
    \ KEY RRs, especially in the case of\n        getting a response from a server\
    \ that does not implement\n        security.  (As explained in 2.3.5 above, it\
    \ will not be possible\n        to secure CNAMEs being served up by non-secure\
    \ resolvers.)\n        NOTE: Implementers might expect the above SHOULD to be\
    \ a MUST.\n        However, local policy or the calling application may not require\n\
    \        the security services.\n     3. If SIG RRs are received in response to\
    \ a user query explicitly\n        specifying the SIG type, no special processing\
    \ is required.\n   If the message does not pass integrity checks or the SIG does\
    \ not\n   check against the signed RRs, the SIG RR is invalid and should be\n\
    \   ignored.  If all of the SIG RR(s) purporting to authenticate an RRset\n  \
    \ are invalid, then the RRset is not authenticated.\n   If the SIG RR is the last\
    \ RR in a response in the additional\n   information section and has a type covered\
    \ of zero, it is a\n   transaction signature of the response and the query that\
    \ produced the\n   response.  It MAY be optionally checked and the message rejected\
    \ if\n   the checks fail.  But even if the checks succeed, such a transaction\n\
    \   authentication SIG does NOT directly authenticate any RRs in the\n   message.\
    \  Only a proper SIG RR signed by the zone or a key tracing\n   its authority\
    \ to the zone or to static resolver configuration can\n   directly authenticate\
    \ RRs, depending on resolver policy (see Section\n   6).  If a resolver does not\
    \ implement transaction and/or request\n   SIGs, it MUST ignore them without error.\n\
    \   If all checks indicate that the SIG RR is valid then RRs verified by\n   it\
    \ should be considered authenticated.\n"
- title: 4.4 Signature Lifetime, Expiration, TTLs, and Validity
  contents:
  - "4.4 Signature Lifetime, Expiration, TTLs, and Validity\n   Security aware servers\
    \ MUST NOT consider SIG RRs to authenticate\n   anything before their signature\
    \ inception or after its expiration\n   time (see also Section 6).  Security aware\
    \ servers MUST NOT consider\n   any RR to be authenticated after all its signatures\
    \ have expired.\n   When a secure server caches authenticated data, if the TTL\
    \ would\n   expire at a time further in the future than the authentication\n \
    \  expiration time, the server SHOULD trim the TTL in the cache entry\n   not\
    \ to extent beyond the authentication expiration time.  Within\n   these constraints,\
    \ servers should continue to follow DNS TTL aging.\n   Thus authoritative servers\
    \ should continue to follow the zone refresh\n   and expire parameters and a non-authoritative\
    \ server should count\n   down the TTL and discard RRs when the TTL is zero (even\
    \ for a SIG\n   that has not yet reached its authentication expiration time).\
    \  In\n   addition, when RRs are transmitted in a query response, the TTL\n  \
    \ should be trimmed so that current time plus the TTL does not extend\n   beyond\
    \ the authentication expiration time.  Thus, in general, the TTL\n   on a transmitted\
    \ RR would be\n      min(authExpTim,max(zoneMinTTL,min(originalTTL,currentTTL)))\n\
    \   When signatures are generated, signature expiration times should be\n   set\
    \ far enough in the future that it is quite certain that new\n   signatures can\
    \ be generated before the old ones expire.  However,\n   setting expiration too\
    \ far into the future could mean a long time to\n   flush any bad data or signatures\
    \ that may have been generated.\n   It is recommended that signature lifetime\
    \ be a small multiple of the\n   TTL (ie, 4 to 16 times the TTL) but not less\
    \ than a reasonable\n   maximum re-signing interval and not less than the zone\
    \ expiry time.\n"
- title: 5. Non-existent Names and Types
  contents:
  - "5. Non-existent Names and Types\n   The SIG RR mechanism described in Section\
    \ 4 above provides strong\n   authentication of RRs that exist in a zone.  But\
    \ it is not clear\n   above how to verifiably deny the existence of a name in\
    \ a zone or a\n   type for an existent name.\n   The nonexistence of a name in\
    \ a zone is indicated by the NXT (\"next\")\n   RR for a name interval containing\
    \ the nonexistent name. An NXT RR or\n   RRs and its or their SIG(s) are returned\
    \ in the authority section,\n   along with the error, if the server is security\
    \ aware.  The same is\n   true for a non-existent type under an existing name\
    \ except that there\n   is no error indication other than an empty answer section\n\
    \   accompanying the NXT(s). This is a change in the existing standard\n   [RFCs\
    \ 1034/1035] which contemplates only NS and SOA RRs in the\n   authority section.\
    \ NXT RRs will also be returned if an explicit query\n   is made for the NXT type.\n\
    \   The existence of a complete set of NXT records in a zone means that\n   any\
    \ query for any name and any type to a security aware server\n   serving the zone\
    \ will result in an reply containing at least one\n   signed RR unless it is a\
    \ query for delegation point NS or glue A or\n   AAAA RRs.\n"
- title: 5.1 The NXT Resource Record
  contents:
  - "5.1 The NXT Resource Record\n   The NXT resource record is used to securely indicate\
    \ that RRs with an\n   owner name in a certain name interval do not exist in a\
    \ zone and to\n   indicate what RR types are present for an existing name.\n \
    \  The owner name of the NXT RR is an existing name in the zone.  It's\n   RDATA\
    \ is a \"next\" name and a type bit map. Thus the NXT RRs in a zone\n   create\
    \ a chain of all of the literal owner names in that zone,\n   including unexpanded\
    \ wildcards but omitting the owner name of glue\n   address records unless they\
    \ would otherwise be included. This implies\n   a canonical ordering of all domain\
    \ names in a zone as described in\n   Section 8. The presence of the NXT RR means\
    \ that no name between its\n   owner name and the name in its RDATA area exists\
    \ and that no other\n   types exist under its owner name.\n   There is a potential\
    \ problem with the last NXT in a zone as it wants\n   to have an owner name which\
    \ is the last existing name in canonical\n   order, which is easy, but it is not\
    \ obvious what name to put in its\n   RDATA to indicate the entire remainder of\
    \ the name space.  This is\n   handled by treating the name space as circular\
    \ and putting the zone\n   name in the RDATA of the last NXT in a zone.\n   The\
    \ NXT RRs for a zone SHOULD be automatically calculated and added\n   to the zone\
    \ when SIGs are added.  The NXT RR's TTL SHOULD NOT exceed\n   the zone minimum\
    \ TTL.\n   The type number for the NXT RR is 30.\n   NXT RRs are only signed by\
    \ zone level keys.\n"
- title: 5.2 NXT RDATA Format
  contents:
  - "5.2 NXT RDATA Format\n   The RDATA for an NXT RR consists simply of a domain\
    \ name followed by\n   a bit map, as shown below.\n                        1 1\
    \ 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  next domain name                             /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    type bit map                               /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The NXT RR type bit map format currently defined is one bit per RR\n   type\
    \ present for the owner name.  A one bit indicates that at least\n   one RR of\
    \ that type is present for the owner name.  A zero indicates\n   that no such\
    \ RR is present.  All bits not specified because they are\n   beyond the end of\
    \ the bit map are assumed to be zero.  Note that bit\n   30, for NXT, will always\
    \ be on so the minimum bit map length is\n   actually four octets. Trailing zero\
    \ octets are prohibited in this\n   format.  The first bit represents RR type\
    \ zero (an illegal type which\n   can not be present) and so will be zero in this\
    \ format.  This format\n   is not used if there exists an RR with a type number\
    \ greater than\n   127.  If the zero bit of the type bit map is a one, it indicates\
    \ that\n   a different format is being used which will always be the case if a\n\
    \   type number greater than 127 is present.\n   The domain name may be compressed\
    \ with standard DNS name compression\n   when being transmitted over the network.\
    \  The size of the bit map can\n   be inferred from the RDLENGTH and the length\
    \ of the next domain name.\n"
- title: 5.3 Additional Complexity Due to Wildcards
  contents:
  - "5.3 Additional Complexity Due to Wildcards\n   Proving that a non-existent name\
    \ response is correct or that a\n   wildcard expansion response is correct makes\
    \ things a little more\n   complex.\n   In particular, when a non-existent name\
    \ response is returned, an NXT\n   must be returned showing that the exact name\
    \ queried did not exist\n   and, in general, one or more additional NXT's need\
    \ to be returned to\n   also prove that there wasn't a wildcard whose expansion\
    \ should have\n   been returned. (There is no need to return multiple copies of\
    \ the\n   same NXT.) These NXTs, if any, are returned in the authority section\n\
    \   of the response.\n   Furthermore, if a wildcard expansion is returned in a\
    \ response, in\n   general one or more NXTs needs to also be returned in the authority\n\
    \   section to prove that no more specific name (including possibly more\n   specific\
    \ wildcards in the zone) existed on which the response should\n   have been based.\n"
- title: 5.4 Example
  contents:
  - "5.4 Example\n   Assume zone foo.nil has entries for\n          big.foo.nil,\n\
    \          medium.foo.nil.\n          small.foo.nil.\n          tiny.foo.nil.\n\
    \   Then a query to a security aware server for huge.foo.nil would\n   produce\
    \ an error reply with an RCODE of NXDOMAIN and the authority\n   section data\
    \ including something like the following:\n   foo.nil.    NXT big.foo.nil NS KEY\
    \ SOA NXT ;prove no *.foo.nil\n   foo.nil.    SIG NXT 1 2 ( ;type-cov=NXT, alg=1,\
    \ labels=2\n                    19970102030405 ;signature expiration\n       \
    \             19961211100908 ;signature inception\n                    2143  \
    \         ;key identifier\n                    foo.nil.       ;signer\n   AIYADP8d3zYNyQwW2EM4wXVFdslEJcUx/fxkfBeH1El4ixPFhpfHFElxbvKoWmvjDTCm\n\
    \   fiYy2X+8XpFjwICHc398kzWsTMKlxovpz2FnCTM= ;signature (640 bits)\n         \
    \                 )\n   big.foo.nil. NXT medium.foo.nil. A MX SIG NXT ;prove no\
    \ huge.foo.nil\n   big.foo.nil. SIG NXT 1 3 ( ;type-cov=NXT, alg=1, labels=3\n\
    \                    19970102030405 ;signature expiration\n                  \
    \  19961211100908 ;signature inception\n                    2143           ;key\
    \ identifier\n                    foo.nil.       ;signer\n    MxFcby9k/yvedMfQgKzhH5er0Mu/vILz45IkskceFGgiWCn/GxHhai6VAuHAoNUz4YoU\n\
    \    1tVfSCSqQYn6//11U6Nld80jEeC8aTrO+KKmCaY= ;signature (640 bits)\n        \
    \                     )\n   Note that this response implies that big.foo.nil is\
    \ an existing name\n   in the zone and thus has other RR types associated with\
    \ it than NXT.\n   However, only the NXT (and its SIG) RR appear in the response\
    \ to this\n   query for huge.foo.nil, which is a non-existent name.\n"
- title: 5.5 Special Considerations at Delegation Points
  contents:
  - "5.5 Special Considerations at Delegation Points\n   A name (other than root)\
    \ which is the head of a zone also appears as\n   the leaf in a superzone.  If\
    \ both are secure, there will always be\n   two different NXT RRs with the same\
    \ name.  They can be easily\n   distinguished by their signers, the next domain\
    \ name fields, the\n   presence of the SOA type bit, etc.  Security aware servers\
    \ should\n   return the correct NXT automatically when required to authenticate\n\
    \   the non-existence of a name and both NXTs, if available, on explicit\n   query\
    \ for type NXT.\n   Non-security aware servers will never automatically return\
    \ an NXT and\n   some old implementations may only return the NXT from the subzone\
    \ on\n   explicit queries.\n"
- title: 5.6 Zone Transfers
  contents:
  - "5.6 Zone Transfers\n   The subsections below describe how full and incremental\
    \ zone\n   transfers are secured.\n   SIG RRs secure all authoritative RRs transferred\
    \ for both full and\n   incremental [RFC 1995] zone transfers.  NXT RRs are an\
    \ essential\n   element in secure zone transfers and assure that every authoritative\n\
    \   name and type will be present; however, if there are multiple SIGs\n   with\
    \ the same name and type covered, a subset of the SIGs could be\n   sent as long\
    \ as at least one is present and, in the case of unsigned\n   delegation point\
    \ NS or glue A or AAAA RRs a subset of these RRs or\n   simply a modified set\
    \ could be sent as long as at least one of each\n   type is included.\n   When\
    \ an incremental or full zone transfer request is received with\n   the same or\
    \ newer version number than that of the server's copy of\n   the zone, it is replied\
    \ to with just the SOA RR of the server's\n   current version and the SIG RRset\
    \ verifying that SOA RR.\n   The complete NXT chains specified in this document\
    \ enable a resolver\n   to obtain, by successive queries chaining through NXTs,\
    \ all of the\n   names in a zone even if zone transfers are prohibited.  Different\n\
    \   format NXTs may be specified in the future to avoid this.\n"
- title: 5.6.1 Full Zone Transfers
  contents:
  - "5.6.1 Full Zone Transfers\n   To provide server authentication that a complete\
    \ transfer has\n   occurred, transaction authentication SHOULD be used on full\
    \ zone\n   transfers.  This provides strong server based protection for the\n\
    \   entire zone in transit.\n"
- title: 5.6.2 Incremental Zone Transfers
  contents:
  - "5.6.2 Incremental Zone Transfers\n   Individual RRs in an incremental (IXFR)\
    \ transfer [RFC 1995] can be\n   verified in the same way as for a full zone transfer\
    \ and the\n   integrity of the NXT name chain and correctness of the NXT type\
    \ bits\n   for the zone after the incremental RR deletes and adds can check each\n\
    \   disjoint area of the zone updated.  But the completeness of an\n   incremental\
    \ transfer can not be confirmed because usually neither the\n   deleted RR section\
    \ nor the added RR section has a compete zone NXT\n   chain.  As a result, a server\
    \ which securely supports IXFR must\n   handle IXFR SIG RRs for each incremental\
    \ transfer set that it\n   maintains.\n   The IXFR SIG is calculated over the\
    \ incremental zone update\n   collection of RRs in the order in which it is transmitted:\
    \ old SOA,\n   then deleted RRs, then new SOA and added RRs.  Within each section,\n\
    \   RRs must be ordered as specified in Section 8.  If condensation of\n   adjacent\
    \ incremental update sets is done by the zone owner, the\n   original IXFR SIG\
    \ for each set included in the condensation must be\n   discarded and a new on\
    \ IXFR SIG calculated to cover the resulting\n   condensed set.\n   The IXFR SIG\
    \ really belongs to the zone as a whole, not to the zone\n   name.  Although it\
    \ SHOULD be correct for the zone name, the labels\n   field of an IXFR SIG is\
    \ otherwise meaningless.  The IXFR SIG is only\n   sent as part of an incremental\
    \ zone transfer.  After validation of\n   the IXFR SIG, the transferred RRs MAY\
    \ be considered valid without\n   verification of the internal SIGs if such trust\
    \ in the server\n   conforms to local policy.\n"
- title: 6. How to Resolve Securely and the AD and CD Bits
  contents:
  - "6. How to Resolve Securely and the AD and CD Bits\n   Retrieving or resolving\
    \ secure data from the Domain Name System (DNS)\n   involves starting with one\
    \ or more trusted public keys that have been\n   staticly configured at the resolver.\
    \  With starting trusted keys, a\n   resolver willing to perform cryptography\
    \ can progress securely\n   through the secure DNS structure to the zone of interest\
    \ as described\n   in Section 6.3. Such trusted public keys would normally be\
    \ configured\n   in a manner similar to that described in Section 6.2.  However,\
    \ as a\n   practical matter, a security aware resolver would still gain some\n\
    \   confidence in the results it returns even if it was not configured\n   with\
    \ any keys but trusted what it got from a local well known server\n   as if it\
    \ were staticly configured.\n   Data stored at a security aware server needs to\
    \ be internally\n   categorized as Authenticated, Pending, or Insecure. There\
    \ is also a\n   fourth transient state of Bad which indicates that all SIG checks\n\
    \   have explicitly failed on the data. Such Bad data is not retained at\n   a\
    \ security aware server. Authenticated means that the data has a\n   valid SIG\
    \ under a KEY traceable via a chain of zero or more SIG and\n   KEY RRs allowed\
    \ by the resolvers policies to a KEY staticly\n   configured at the resolver.\
    \ Pending data has no authenticated SIGs\n   and at least one additional SIG the\
    \ resolver is still trying to\n   authenticate.  Insecure data is data which it\
    \ is known can never be\n   either Authenticated or found Bad in the zone where\
    \ it was found\n   because it is in or has been reached via a unsecured zone or\
    \ because\n   it is unsigned glue address or delegation point NS data. Behavior\
    \ in\n   terms of control of and flagging based on such data labels is\n   described\
    \ in Section 6.1.\n   The proper validation of signatures requires a reasonably\
    \ secure\n   shared opinion of the absolute time between resolvers and servers\
    \ as\n   described in Section 6.4.\n"
- title: 6.1 The AD and CD Header Bits
  contents:
  - "6.1 The AD and CD Header Bits\n   Two previously unused bits are allocated out\
    \ of the DNS\n   query/response format header. The AD (authentic data) bit indicates\n\
    \   in a response that all the data included in the answer and authority\n   portion\
    \ of the response has been authenticated by the server\n   according to the policies\
    \ of that server. The CD (checking disabled)\n   bit indicates in a query that\
    \ Pending (non-authenticated) data is\n   acceptable to the resolver sending the\
    \ query.\n   These bits are allocated from the previously must-be-zero Z field\
    \ as\n   follows:\n                                           1  1  1  1  1  1\n\
    \             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |                      ID                       |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |QR|   Opcode  |AA|TC|RD|RA| Z|AD|CD|   RCODE   |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |                    QDCOUNT                    |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |                    ANCOUNT                    |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |                    NSCOUNT                    |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \            |                    ARCOUNT                    |\n            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   These bits are zero in old servers and resolvers.  Thus the responses\n  \
    \ of old servers are not flagged as authenticated to security aware\n   resolvers\
    \ and queries from non-security aware resolvers do not assert\n   the checking\
    \ disabled bit and thus will be answered by security aware\n   servers only with\
    \ Authenticated or Insecure data. Security aware\n   resolvers MUST NOT trust\
    \ the AD bit unless they trust the server they\n   are talking to and either have\
    \ a secure path to it or use DNS\n   transaction security.\n   Any security aware\
    \ resolver willing to do cryptography SHOULD assert\n   the CD bit on all queries\
    \ to permit it to impose its own policies and\n   to reduce DNS latency time by\
    \ allowing security aware servers to\n   answer with Pending data.\n   Security\
    \ aware servers MUST NOT return Bad data.  For non-security\n   aware resolvers\
    \ or security aware resolvers requesting service by\n   having the CD bit clear,\
    \ security aware servers MUST return only\n   Authenticated or Insecure data in\
    \ the answer and authority sections\n   with the AD bit set in the response. Security\
    \ aware servers SHOULD\n   return Pending data, with the AD bit clear in the response,\
    \ to\n   security aware resolvers requesting this service by asserting the CD\n\
    \   bit in their request.  The AD bit MUST NOT be set on a response\n   unless\
    \ all of the RRs in the answer and authority sections of the\n   response are\
    \ either Authenticated or Insecure.  The AD bit does not\n   cover the additional\
    \ information section.\n"
- title: 6.2 Staticly Configured Keys
  contents:
  - "6.2 Staticly Configured Keys\n   The public key to authenticate a zone SHOULD\
    \ be defined in local\n   configuration files before that zone is loaded at the\
    \ primary server\n   so the zone can be authenticated.\n   While it might seem\
    \ logical for everyone to start with a public key\n   associated with the root\
    \ zone and staticly configure this in every\n   resolver, this has problems. \
    \ The logistics of updating every DNS\n   resolver in the world should this key\
    \ ever change would be severe.\n   Furthermore, many organizations will explicitly\
    \ wish their \"interior\"\n   DNS implementations to completely trust only their\
    \ own DNS servers.\n   Interior resolvers of such organizations can then go through\
    \ the\n   organization's zone servers to access data outside the organization's\n\
    \   domain and need not be configured with keys above the organization's\n   DNS\
    \ apex.\n   Host resolvers that are not part of a larger organization may be\n\
    \   configured with a key for the domain of their local ISP whose\n   recursive\
    \ secure DNS caching server they use.\n"
- title: 6.3 Chaining Through The DNS
  contents:
  - "6.3 Chaining Through The DNS\n   Starting with one or more trusted keys for any\
    \ zone, it should be\n   possible to retrieve signed keys for that zone's subzones\
    \ which have\n   a key. A secure sub-zone is indicated by a KEY RR with non-null\
    \ key\n   information appearing with the NS RRs in the sub-zone and which may\n\
    \   also be present in the parent.  These make it possible to descend\n   within\
    \ the tree of zones.\n"
- title: 6.3.1 Chaining Through KEYs
  contents:
  - "6.3.1 Chaining Through KEYs\n   In general, some RRset that you wish to validate\
    \ in the secure DNS\n   will be signed by one or more SIG RRs.  Each of these\
    \ SIG RRs has a\n   signer under whose name is stored the public KEY to use in\n\
    \   authenticating the SIG.  Each of those KEYs will, generally, also be\n   signed\
    \ with a SIG.  And those SIGs will have signer names also\n   referring to KEYs.\
    \  And so on. As a result, authentication leads to\n   chains of alternating SIG\
    \ and KEY RRs with the first SIG signing the\n   original data whose authenticity\
    \ is to be shown and the final KEY\n   being some trusted key staticly configured\
    \ at the resolver performing\n   the authentication.\n   In testing such a chain,\
    \ the validity periods of the SIGs encountered\n   must be intersected to determine\
    \ the validity period of the\n   authentication of the data, a purely algorithmic\
    \ process. In\n   addition, the validation of each SIG over the data with reference\
    \ to\n   a KEY must meet the objective cryptographic test implied by the\n   cryptographic\
    \ algorithm used (although even here the resolver may\n   have policies as to\
    \ trusted algorithms and key lengths).  Finally,\n   the judgement that a SIG\
    \ with a particular signer name can\n   authenticate data (possibly a KEY RRset)\
    \ with a particular owner\n   name, is primarily a policy question.  Ultimately,\
    \ this is a policy\n   local to the resolver and any clients that depend on that\
    \ resolver's\n   decisions.  It is, however, recommended, that the policy below\
    \ be\n   adopted:\n        Let A < B mean that A is a shorter domain name than\
    \ B formed by\n        dropping one or more whole labels from the left end of\
    \ B, i.e.,\n        A is a direct or indirect superdomain of B.  Let A = B mean\
    \ that\n        A and B are the same domain name (i.e., are identical after\n\
    \        letter case canonicalization).  Let A > B mean that A is a\n        longer\
    \ domain name than B formed by adding one or more whole\n        labels on the\
    \ left end of B, i.e., A is a direct or indirect\n        subdomain of B\n   \
    \     Let Static be the owner names of the set of staticly configured\n      \
    \  trusted keys at a resolver.\n        Then Signer is a valid signer name for\
    \ a SIG authenticating an\n        RRset (possibly a KEY RRset) with owner name\
    \ Owner at the\n        resolver if any of the following three rules apply:\n\
    \        (1) Owner > or = Signer (except that if Signer is root, Owner\n     \
    \   must be root or a top level domain name).  That is, Owner is the\n       \
    \ same as or a subdomain of Signer.\n        (2) ( Owner < Signer ) and ( Signer\
    \ > or = some Static ).  That\n        is, Owner is a superdomain of Signer and\
    \ Signer is staticly\n        configured or a subdomain of a staticly configured\
    \ key.\n        (3) Signer = some Static.  That is, the signer is exactly some\n\
    \        staticly configured key.\n   Rule 1 is the rule for descending the DNS\
    \ tree and includes a special\n   prohibition on the root zone key due to the\
    \ restriction that the root\n   zone be only one label deep.  This is the most\
    \ fundamental rule.\n   Rule 2 is the rule for ascending the DNS tree from one\
    \ or more\n   staticly configured keys.  Rule 2 has no effect if only root zone\n\
    \   keys are staticly configured.\n   Rule 3 is a rule permitting direct cross\
    \ certification.  Rule 3 has\n   no effect if only root zone keys are staticly\
    \ configured.\n   Great care should be taken that the consequences have been fully\n\
    \   considered before making any local policy adjustments to these rules\n   (other\
    \ than dispensing with rules 2 and 3 if only root zone keys are\n   staticly configured).\n"
- title: 6.3.2 Conflicting Data
  contents:
  - "6.3.2 Conflicting Data\n   It is possible that there will be multiple SIG-KEY\
    \ chains that appear\n   to authenticate conflicting RRset answers to the same\
    \ query.  A\n   resolver should choose only the most reliable answer to return\
    \ and\n   discard other data.  This choice of most reliable is a matter of\n \
    \  local policy which could take into account differing trust in\n   algorithms,\
    \ key sizes, staticly configured keys, zones traversed,\n   etc.  The technique\
    \ given below is recommended for taking into\n   account SIG-KEY chain length.\n\
    \   A resolver should keep track of the number of successive secure zones\n  \
    \ traversed from a staticly configured key starting point to any secure\n   zone\
    \ it can reach.  In general, the lower such a distance number is,\n   the greater\
    \ the confidence in the data.  Staticly configured data\n   should be given a\
    \ distance number of zero.  If a query encounters\n   different Authenticated\
    \ data for the same query with different\n   distance values, that with a larger\
    \ value should be ignored unless\n   some other local policy covers the case.\n\
    \   A security conscious resolver should completely refuse to step from a\n  \
    \ secure zone into a unsecured zone unless the unsecured zone is\n   certified\
    \ to be non-secure by the presence of an authenticated KEY RR\n   for the unsecured\
    \ zone with the no-key type value.  Otherwise the\n   resolver is getting bogus\
    \ or spoofed data.\n   If legitimate unsecured zones are encountered in traversing\
    \ the DNS\n   tree, then no zone can be trusted as secure that can be reached\
    \ only\n   via information from such non-secure zones. Since the unsecured zone\n\
    \   data could have been spoofed, the \"secure\" zone reached via it could\n \
    \  be counterfeit.  The \"distance\" to data in such zones or zones\n   reached\
    \ via such zones could be set to 256 or more as this exceeds\n   the largest possible\
    \ distance through secure zones in the DNS.\n"
- title: 6.4 Secure Time
  contents:
  - "6.4 Secure Time\n   Coordinated interpretation of the time fields in SIG RRs\
    \ requires\n   that reasonably consistent time be available to the hosts\n   implementing\
    \ the DNS security extensions.\n   A variety of time synchronization protocols\
    \ exist including the\n   Network Time Protocol (NTP [RFC 1305, 2030]).  If such\
    \ protocols are\n   used, they MUST be used securely so that time can not be spoofed.\n\
    \   Otherwise, for example, a host could get its clock turned back and\n   might\
    \ then believe old SIG RRs, and the data they authenticate, which\n   were valid\
    \ but are no longer.\n"
- title: 7. ASCII Representation of Security RRs
  contents:
  - "7. ASCII Representation of Security RRs\n   This section discusses the format\
    \ for master file and other ASCII\n   presentation of the three DNS security resource\
    \ records.\n   The algorithm field in KEY and SIG RRs can be represented as either\n\
    \   an unsigned integer or symbolicly.  The following initial symbols are\n  \
    \ defined as indicated:\n        Value  Symbol\n        001    RSAMD5\n      \
    \  002    DH\n        003    DSA\n        004    ECC\n        252    INDIRECT\n\
    \        253    PRIVATEDNS\n        254    PRIVATEOID\n"
- title: 7.1 Presentation of KEY RRs
  contents:
  - "7.1 Presentation of KEY RRs\n   KEY RRs may appear as single logical lines in\
    \ a zone data master file\n   [RFC 1033].\n   The flag field is represented as\
    \ an unsigned integer or a sequence of\n   mnemonics as follows separated by instances\
    \ of the verticle bar (\"|\")\n   character:\n     BIT  Mnemonic  Explanation\n\
    \    0-1           key type\n        NOCONF    =1 confidentiality use prohibited\n\
    \        NOAUTH    =2 authentication use prohibited\n        NOKEY     =3 no key\
    \ present\n    2   FLAG2     - reserved\n    3   EXTEND    flags extension\n \
    \   4   FLAG4     - reserved\n    5   FLAG5     - reserved\n    6-7          \
    \ name type\n        USER      =0 (default, may be omitted)\n        ZONE    \
    \  =1\n        HOST      =2 (host or other end entity)\n        NTYP3     - reserved\n\
    \    8   FLAG8     - reserved\n    9   FLAG9     - reserved\n   10   FLAG10  \
    \  - reserved\n   11   FLAG11    - reserved\n   12-15          signatory field,\
    \ values 0 to 15\n            can be represented by SIG0, SIG1, ... SIG15\n  \
    \ No flag mnemonic need be present if the bit or field it represents is\n   zero.\n\
    \   The protocol octet can be represented as either an unsigned integer\n   or\
    \ symbolicly.  The following initial symbols are defined:\n        000    NONE\n\
    \        001    TLS\n        002    EMAIL\n        003    DNSSEC\n        004\
    \    IPSEC\n        255    ALL\n   Note that if the type flags field has the NOKEY\
    \ value, nothing\n   appears after the algorithm octet.\n   The remaining public\
    \ key portion is represented in base 64 (see\n   Appendix A) and may be divided\
    \ up into any number of white space\n   separated substrings, down to single base\
    \ 64 digits, which are\n   concatenated to obtain the full signature.  These substrings\
    \ can span\n   lines using the standard parenthesis.\n   Note that the public\
    \ key may have internal sub-fields but these do\n   not appear in the master file\
    \ representation.  For example, with\n   algorithm 1 there is a public exponent\
    \ size, then a public exponent,\n   and then a modulus.  With algorithm 254, there\
    \ will be an OID size,\n   an OID, and algorithm dependent information. But in\
    \ both cases only a\n   single logical base 64 string will appear in the master\
    \ file.\n"
- title: 7.2 Presentation of SIG RRs
  contents:
  - "7.2 Presentation of SIG RRs\n   A data SIG RR may be represented as a single\
    \ logical line in a zone\n   data file [RFC 1033] but there are some special considerations\
    \ as\n   described below.  (It does not make sense to include a transaction or\n\
    \   request authenticating SIG RR in a file as they are a transient\n   authentication\
    \ that covers data including an ephemeral transaction\n   number and so must be\
    \ calculated in real time.)\n   There is no particular problem with the signer,\
    \ covered type, and\n   times.  The time fields appears in the form YYYYMMDDHHMMSS\
    \ where YYYY\n   is the year, the first MM is the month number (01-12), DD is\
    \ the day\n   of the month (01-31), HH is the hour in 24 hours notation (00-23),\n\
    \   the second MM is the minute (00-59), and SS is the second (00-59).\n   The\
    \ original TTL field appears as an unsigned integer.\n   If the original TTL,\
    \ which applies to the type signed, is the same as\n   the TTL of the SIG RR itself,\
    \ it may be omitted.  The date field\n   which follows it is larger than the maximum\
    \ possible TTL so there is\n   no ambiguity.\n   The \"labels\" field appears\
    \ as an unsigned integer.\n   The key tag appears as an unsigned number.\n   However,\
    \ the signature itself can be very long.  It is the last data\n   field and is\
    \ represented in base 64 (see Appendix A) and may be\n   divided up into any number\
    \ of white space separated substrings, down\n   to single base 64 digits, which\
    \ are concatenated to obtain the full\n   signature.  These substrings can be\
    \ split between lines using the\n   standard parenthesis.\n"
- title: 7.3 Presentation of NXT RRs
  contents:
  - "7.3 Presentation of NXT RRs\n   NXT RRs do not appear in original unsigned zone\
    \ master files since\n   they should be derived from the zone as it is being signed.\
    \  If a\n   signed file with NXTs added is printed or NXTs are printed by\n  \
    \ debugging code, they appear as the next domain name followed by the\n   RR type\
    \ present bits as an unsigned interger or sequence of RR\n   mnemonics.\n"
- title: 8. Canonical Form and Order of Resource Records
  contents:
  - "8. Canonical Form and Order of Resource Records\n   This section specifies, for\
    \ purposes of domain name system (DNS)\n   security, the canonical form of resource\
    \ records (RRs), their name\n   order, and their overall order.  A canonical name\
    \ order is necessary\n   to construct the NXT name chain.  A canonical form and\
    \ ordering\n   within an RRset is necessary in consistently constructing and\n\
    \   verifying SIG RRs.  A canonical ordering of types within a name is\n   required\
    \ in connection with incremental transfer (Section 5.6.2).\n"
- title: 8.1 Canonical RR Form
  contents:
  - "8.1 Canonical RR Form\n   For purposes of DNS security, the canonical form for\
    \ an RR is the\n   wire format of the RR with domain names (1) fully expanded\
    \ (no name\n   compression via pointers), (2) all domain name letters set to lower\n\
    \   case, (3) owner name wild cards in master file form (no substitution\n   made\
    \ for *), and (4) the original TTL substituted for the current\n   TTL.\n"
- title: 8.2 Canonical DNS Name Order
  contents:
  - "8.2 Canonical DNS Name Order\n   For purposes of DNS security, the canonical\
    \ ordering of owner names\n   is to sort individual labels as unsigned left justified\
    \ octet strings\n   where the absence of a octet sorts before a zero value octet\
    \ and\n   upper case letters are treated as lower case letters.  Names in a\n\
    \   zone are sorted by sorting on the highest level label and then,\n   within\
    \ those names with the same highest level label by the next\n   lower label, etc.\
    \ down to leaf node labels.  Within a zone, the zone\n   name itself always exists\
    \ and all other names are the zone name with\n   some prefix of lower level labels.\
    \  Thus the zone name itself always\n   sorts first.\n   Example:\n          foo.example\n\
    \          a.foo.example\n          yljkjljk.a.foo.example\n          Z.a.foo.example\n\
    \          zABC.a.FOO.EXAMPLE\n          z.foo.example\n          *.z.foo.example\n\
    \          \\200.z.foo.example\n"
- title: 8.3 Canonical RR Ordering Within An RRset
  contents:
  - "8.3 Canonical RR Ordering Within An RRset\n   Within any particular owner name\
    \ and type, RRs are sorted by RDATA as\n   a left justified unsigned octet sequence\
    \ where the absence of an\n   octet sorts before the zero octet.\n"
- title: 8.4 Canonical Ordering of RR Types
  contents:
  - "8.4 Canonical Ordering of RR Types\n   When RRs of the same name but different\
    \ types must be ordered, they\n   are ordered by type, considering the type to\
    \ be an unsigned integer,\n   except that SIG RRs are placed immediately after\
    \ the type they cover.\n   Thus, for example, an A record would be put before\
    \ an MX record\n   because A is type 1 and MX is type 15 but if both were signed,\
    \ the\n   order would be A < SIG(A) < MX < SIG(MX).\n"
- title: 9. Conformance
  contents:
  - "9. Conformance\n   Levels of server and resolver conformance are defined below.\n"
- title: 9.1 Server Conformance
  contents:
  - "9.1 Server Conformance\n   Two levels of server conformance for DNS security\
    \ are defined as\n   follows:\n   BASIC:  Basic server compliance is the ability\
    \ to store and retrieve\n   (including zone transfer) SIG, KEY, and NXT RRs. \
    \ Any secondary or\n   caching server for a secure zone MUST have at least basic\
    \ compliance\n   and even then some things, such as secure CNAMEs, will not work\n\
    \   without full compliance.\n   FULL:  Full server compliance adds the following\
    \ to basic compliance:\n   (1) ability to read SIG, KEY, and NXT RRs in zone files\
    \ and (2)\n   ability, given a zone file and private key, to add appropriate SIG\n\
    \   and NXT RRs, possibly via a separate application, (3) proper\n   automatic\
    \ inclusion of SIG, KEY, and NXT RRs in responses, (4)\n   suppression of CNAME\
    \ following on retrieval of the security type RRs,\n   (5) recognize the CD query\
    \ header bit and set the AD query header\n   bit, as appropriate, and (6) proper\
    \ handling of the two NXT RRs at\n   delegation points.  Primary servers for secure\
    \ zones MUST be fully\n   compliant and for complete secure operation, all secondary,\
    \ caching,\n   and other servers handling the zone SHOULD be fully compliant as\n\
    \   well.\n"
- title: 9.2 Resolver Conformance
  contents:
  - "9.2 Resolver Conformance\n   Two levels of resolver compliance (including the\
    \ resolver portion of\n   a server) are defined for DNS Security:\n   BASIC: A\
    \ basic compliance resolver can handle SIG, KEY, and NXT RRs\n   when they are\
    \ explicitly requested.\n   FULL: A fully compliant resolver (1) understands KEY,\
    \ SIG, and NXT\n   RRs including verification of SIGs at least for the mandatory\n\
    \   algorithm, (2) maintains appropriate information in its local caches\n   and\
    \ database to indicate which RRs have been authenticated and to\n   what extent\
    \ they have been authenticated, (3) performs additional\n   queries as necessary\
    \ to attempt to obtain KEY, SIG, or NXT RRs when\n   needed, (4) normally sets\
    \ the CD query header bit on its queries.\n"
- title: 10. Security Considerations
  contents:
  - "10. Security Considerations\n   This document specifies extensions to the Domain\
    \ Name System (DNS)\n   protocol to provide data integrity and data origin authentication,\n\
    \   public key distribution, and optional transaction and request\n   security.\n\
    \   It should be noted that, at most, these extensions guarantee the\n   validity\
    \ of resource records, including KEY resource records,\n   retrieved from the\
    \ DNS.  They do not magically solve other security\n   problems.  For example,\
    \ using secure DNS you can have high confidence\n   in the IP address you retrieve\
    \ for a host name; however, this does\n   not stop someone for substituting an\
    \ unauthorized host at that\n   address or capturing packets sent to that address\
    \ and falsely\n   responding with packets apparently from that address.  Any reasonably\n\
    \   complete security system will require the protection of many\n   additional\
    \ facets of the Internet beyond DNS.\n   The implementation of NXT RRs as described\
    \ herein enables a resolver\n   to determine all the names in a zone even if zone\
    \ transfers are\n   prohibited (section 5.6).  This is an active area of work\
    \ and may\n   change.\n   A number of precautions in DNS implementation have evolved\
    \ over the\n   years to harden the insecure DNS against spoofing.  These precautions\n\
    \   should not be abandoned but should be considered to provide\n   additional\
    \ protection in case of key compromise in secure DNS.\n"
- title: 11. IANA Considerations
  contents:
  - "11. IANA Considerations\n   KEY RR flag bits 2 and 8-11 and all flag extension\
    \ field bits can be\n   assigned by IETF consensus as defined in RFC 2434.  The\
    \ remaining\n   values of the NAMTYP flag field and flag bits 4 and 5 (which could\n\
    \   conceivably become an extension of the NAMTYP field) can only be\n   assigned\
    \ by an IETF Standards Action [RFC 2434].\n   Algorithm numbers 5 through 251\
    \ are available for assignment should\n   sufficient reason arise.  However, the\
    \ designation of a new algorithm\n   could have a major impact on interoperability\
    \ and requires an IETF\n   Standards Action [RFC 2434].  The existence of the\
    \ private algorithm\n   types 253 and 254 should satify most needs for private\
    \ or proprietary\n   algorithms.\n   Additional values of the Protocol Octet (5-254)\
    \ can be assigned by\n   IETF Consensus [RFC 2434].\n   The meaning of the first\
    \ bit of the NXT RR \"type bit map\" being a one\n   can only be assigned by a\
    \ standards action.\n"
- title: References
  contents:
  - "References\n   [RFC 1033]  Lottor, M., \"Domain Administrators Operations Guide\"\
    , RFC\n               1033, November 1987.\n   [RFC 1034]  Mockapetris, P., \"\
    Domain Names - Concepts and\n               Facilities\", STD 13, RFC 1034, November\
    \ 1987.\n   [RFC 1035]  Mockapetris, P., \"Domain Names - Implementation and\n\
    \               Specifications\", STD 13, RFC 1035, November 1987.\n   [RFC 1305]\
    \  Mills, D., \"Network Time Protocol (v3)\", RFC 1305, March\n              \
    \ 1992.\n   [RFC 1530]  Malamud, C. and M. Rose, \"Principles of Operation for\
    \ the\n               TPC.INT Subdomain: General Principles and Policy\", RFC\n\
    \               1530, October 1993.\n   [RFC 2401]  Kent, S. and R. Atkinson,\
    \ \"Security Architecture for the\n               Internet Protocol\", RFC 2401,\
    \ November 1998.\n   [RFC 1982]  Elz, R. and R. Bush, \"Serial Number Arithmetic\"\
    , RFC\n               1982, September 1996.\n   [RFC 1995]  Ohta, M., \"Incremental\
    \ Zone Transfer in DNS\", RFC 1995,\n               August 1996.\n   [RFC 2030]\
    \  Mills, D., \"Simple Network Time Protocol (SNTP) Version 4\n              \
    \ for IPv4, IPv6 and OSI\", RFC 2030, October 1996.\n   [RFC 2045]  Freed, N.\
    \ and N. Borenstein, \"Multipurpose Internet Mail\n               Extensions (MIME)\
    \ Part One: Format of Internet Message\n               Bodies\", RFC 2045, November\
    \ 1996.\n   [RFC 2065]  Eastlake, D. and C. Kaufman, \"Domain Name System Security\n\
    \               Extensions\", RFC 2065, January 1997.\n   [RFC 2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n               Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC 2136]  Vixie, P., Thomson, S., Rekhter,\
    \ Y. and J. Bound,\n               \"Dynamic Updates in the Domain Name System\
    \ (DNS UPDATE)\",\n               RFC 2136, April 1997.\n   [RFC 2137]  Eastlake,\
    \ D., \"Secure Domain Name System Dynamic Update\",\n               RFC 2137,\
    \ April 1997.\n   [RFC 2181]  Elz, R. and R. Bush, \"Clarifications to the DNS\n\
    \               Specification\", RFC 2181, July 1997.\n   [RFC 2434]  Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing an\n               IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 2434,\n               October 1998.\n   [RFC\
    \ 2537]  Eastlake, D., \"RSA/MD5 KEYs and SIGs in the Domain Name\n          \
    \     System (DNS)\", RFC 2537, March 1999.\n   [RFC 2539]  Eastlake, D., \"Storage\
    \ of Diffie-Hellman Keys in the\n               Domain Name System (DNS)\", RFC\
    \ 2539, March 1999.\n   [RFC 2536]  Eastlake, D., \"DSA KEYs and SIGs in the Domain\
    \ Name\n               System (DNS)\", RFC 2536, March 1999.\n   [RFC 2538]  Eastlake,\
    \ D. and O. Gudmundsson, \"Storing Certificates in\n               the Domain\
    \ Name System\", RFC 2538, March 1999.\n   [RFC 2541]  Eastlake, D., \"DNS Operational\
    \ Security Considerations\",\n               RFC 2541, March 1999.\n   [RSA FAQ]\
    \ - RSADSI Frequently Asked Questions periodic posting.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Donald E. Eastlake 3rd\n   IBM\n   65 Shindegan Hill Road\n\
    \   RR #1\n   Carmel, NY 10512\n   Phone:   +1-914-784-7913 (w)\n            +1-914-276-2668\
    \ (h)\n   Fax:     +1-914-784-3833 (w-fax)\n   EMail:   dee3@us.ibm.com\n"
- title: 'Appendix A: Base 64 Encoding'
  contents:
  - "Appendix A: Base 64 Encoding\n   The following encoding technique is taken from\
    \ [RFC 2045] by N.\n   Borenstein and N. Freed.  It is reproduced here in an edited\
    \ form for\n   convenience.\n   A 65-character subset of US-ASCII is used, enabling\
    \ 6 bits to be\n   represented per printable character. (The extra 65th character,\
    \ \"=\",\n   is used to signify a special processing function.)\n   The encoding\
    \ process represents 24-bit groups of input bits as output\n   strings of 4 encoded\
    \ characters. Proceeding from left to right, a\n   24-bit input group is formed\
    \ by concatenating 3 8-bit input groups.\n   These 24 bits are then treated as\
    \ 4 concatenated 6-bit groups, each\n   of which is translated into a single digit\
    \ in the base 64 alphabet.\n   Each 6-bit group is used as an index into an array\
    \ of 64 printable\n   characters. The character referenced by the index is placed\
    \ in the\n   output string.\n                         Table 1: The Base 64 Alphabet\n\
    \      Value Encoding  Value Encoding  Value Encoding  Value Encoding\n      \
    \    0 A            17 R            34 i            51 z\n          1 B      \
    \      18 S            35 j            52 0\n          2 C            19 T   \
    \         36 k            53 1\n          3 D            20 U            37 l\
    \            54 2\n          4 E            21 V            38 m            55\
    \ 3\n          5 F            22 W            39 n            56 4\n         \
    \ 6 G            23 X            40 o            57 5\n          7 H         \
    \   24 Y            41 p            58 6\n          8 I            25 Z      \
    \      42 q            59 7\n          9 J            26 a            43 r   \
    \         60 8\n         10 K            27 b            44 s            61 9\n\
    \         11 L            28 c            45 t            62 +\n         12 M\
    \            29 d            46 u            63 /\n         13 N            30\
    \ e            47 v\n         14 O            31 f            48 w         (pad)\
    \ =\n         15 P            32 g            49 x\n         16 Q            33\
    \ h            50 y\n   Special processing is performed if fewer than 24 bits\
    \ are available\n   at the end of the data being encoded.  A full encoding quantum\
    \ is\n   always completed at the end of a quantity.  When fewer than 24 input\n\
    \   bits are available in an input group, zero bits are added (on the\n   right)\
    \ to form an integral number of 6-bit groups.  Padding at the\n   end of the data\
    \ is performed using the '=' character.  Since all base\n   64 input is an integral\
    \ number of octets, only the following cases\n   can arise: (1) the final quantum\
    \ of encoding input is an integral\n   multiple of 24 bits; here, the final unit\
    \ of encoded output will be\n   an integral multiple of 4 characters with no \"\
    =\" padding, (2) the\n   final quantum of encoding input is exactly 8 bits; here,\
    \ the final\n   unit of encoded output will be two characters followed by two\
    \ \"=\"\n   padding characters, or (3) the final quantum of encoding input is\n\
    \   exactly 16 bits; here, the final unit of encoded output will be three\n  \
    \ characters followed by one \"=\" padding character.\n"
- title: 'Appendix B: Changes from RFC 2065'
  contents:
  - "Appendix B: Changes from RFC 2065\n   This section summarizes the most important\
    \ changes that have been\n   made since RFC 2065.\n   1. Most of Section 7 of\
    \ [RFC 2065] called \"Operational\n      Considerations\", has been removed and\
    \ may be made into a separate\n      document [RFC 2541].\n   2. The KEY RR has\
    \ been changed by (2a) eliminating the \"experimental\"\n      flag as unnecessary,\
    \ (2b) reserving a flag  bit for flags\n      expansion, (2c) more compactly encoding\
    \ a number of bit fields in\n      such a way as to leave unchanged bits actually\
    \ used by the limited\n      code currently deployed, (2d) eliminating the IPSEC\
    \ and email flag\n      bits which are replaced by values of the protocol field\
    \ and adding\n      a protocol field value for DNS security itself, (2e) adding\n\
    \      material to indicate that zone KEY RRs occur only at delegation\n     \
    \ points, and (2f) removing the description of the RSA/MD5 algorithm\n      to\
    \ a separate document [RFC 2537].  Section 3.4 describing the\n      meaning of\
    \ various combinations of \"no-key\" and key present KEY\n      RRs has been added\
    \ and the secure / unsecure status of a zone has\n      been clarified as being\
    \ per algorithm.\n   3. The SIG RR has been changed by (3a) renaming the \"time\
    \ signed\"\n      field to be the \"signature inception\" field, (3b) clarifying\
    \ that\n      signature expiration and inception use serial number ring\n    \
    \  arithmetic, (3c) changing the definition of the key footprint/tag\n      for\
    \ algorithms other than 1 and adding Appendix C to specify its\n      calculation.\
    \  In addition, the SIG covering type AXFR has been\n      eliminated while one\
    \ covering IXFR [RFC 1995] has been added (see\n      section 5.6).\n   4. Algorithm\
    \ 3, the DSA algorithm, is now designated as the mandatory\n      to implement\
    \ algorithm.  Algorithm 1, the RSA/MD5 algorithm, is\n      now a recommended\
    \ option.  Algorithm 2 and 4 are designated as the\n      Diffie-Hellman key and\
    \ elliptic cryptography algorithms\n      respectively, all to be defined in separate\
    \ documents. Algorithm\n      code point 252 is designated to indicate \"indirect\"\
    \ keys, to be\n      defined in a separate document, where the actual key is elsewhere.\n\
    \      Both the KEY and SIG RR definitions have been simplified by\n      eliminating\
    \ the \"null\" algorithm 253 as defined in [RFC 2065].\n      That algorithm had\
    \ been included because at the time it was\n      thought it might be useful in\
    \ DNS dynamic update [RFC 2136]. It\n      was in fact not so used and it is dropped\
    \ to simplify DNS\n      security.  Howver, that algorithm number has been re-used\
    \ to\n      indicate private algorithms where a domain name specifies the\n  \
    \    algorithm.\n   5. The NXT RR has been changed so that (5a) the NXT RRs in\
    \ a zone\n      cover all names, including wildcards as literal names without\n\
    \      expansion, except for glue address records whose names would not\n    \
    \  otherwise appear, (5b) all NXT bit map areas whose first octet has\n      bit\
    \ zero set have been reserved for future definition, (5c) the\n      number of\
    \ and circumstances under which an NXT must be returned in\n      connection with\
    \ wildcard names has been extended, and (5d) in\n      connection with the bit\
    \ map, references to the WKS RR have been\n      removed and verticle bars (\"\
    |\") have been added between the RR\n      type mnemonics in the ASCII representation.\n\
    \   6. Information on the canonical form and ordering of RRs has been\n      moved\
    \ into a separate Section 8.\n   7. A subsection covering incremental and full\
    \ zone transfer has been\n      added in Section 5.\n   8. Concerning DNS chaining:\
    \ Further specification and policy\n      recommendations on secure resolution\
    \ have been added, primarily in\n      Section 6.3.1.  It is now clearly stated\
    \ that authenticated data\n      has a validity period of the intersection of\
    \ the validity periods\n      of the SIG RRs in its authentication chain.  The\
    \ requirement to\n      staticly configure a superzone's key signed by a zone\
    \ in all of\n      the zone's authoritative servers has been removed.  The\n \
    \     recommendation to continue DNS security checks in a secure island\n    \
    \  of DNS data that is separated from other parts of the DNS tree by\n      insecure\
    \ zones and does not contain a zone for which a key has\n      been staticly configured\
    \ was dropped.\n   9. It was clarified that the presence of the AD bit in a response\n\
    \      does not apply to the additional information section or to glue\n     \
    \ address or delegation point NS RRs.  The AD bit only indicates\n      that the\
    \ answer and authority sections of the response are\n      authoritative.\n  \
    \ 10. It is now required that KEY RRs and NXT RRs be signed only with\n      \
    \ zone-level keys.\n   11.  Add IANA Considerations section and references to\
    \ RFC 2434.\n"
- title: 'Appendix C: Key Tag Calculation'
  contents:
  - "Appendix C: Key Tag Calculation\n   The key tag field in the SIG RR is just a\
    \ means of more efficiently\n   selecting the correct KEY RR to use when there\
    \ is more than one KEY\n   RR candidate available, for example, in verifying a\
    \ signature.  It is\n   possible for more than one candidate key to have the same\
    \ tag, in\n   which case each must be tried until one works or all fail.  The\n\
    \   following reference implementation of how to calculate the Key Tag,\n   for\
    \ all algorithms other than algorithm 1, is in ANSI C.  It is coded\n   for clarity,\
    \ not efficiency.  (See section 4.1.6 for how to determine\n   the Key Tag of\
    \ an algorithm 1 key.)\n   /* assumes int is at least 16 bits\n      first byte\
    \ of the key tag is the most significant byte of return\n      value\n      second\
    \ byte of the key tag is the least significant byte of\n      return value\n \
    \     */\n   int keytag (\n           unsigned char key[],  /* the RDATA part\
    \ of the KEY RR */\n           unsigned int keysize, /* the RDLENGTH */\n    \
    \       )\n   {\n   long int    ac;    /* assumed to be 32 bits or larger */\n\
    \   for ( ac = 0, i = 0; i < keysize; ++i )\n       ac += (i&1) ? key[i] : key[i]<<8;\n\
    \   ac += (ac>>16) & 0xFFFF;\n   return ac & 0xFFFF;\n   }\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
