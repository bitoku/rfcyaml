- title: __initial_text__
  contents:
  - "                 HIP BONE: Host Identity Protocol (HIP)\n              Based\
    \ Overlay Networking Environment (BONE)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a framework to build HIP-based (Host Identity\n\
    \   Protocol) overlay networks.  This framework uses HIP to perform\n   connection\
    \ management.  Other functions, such as data storage and\n   retrieval or overlay\
    \ maintenance, are implemented using protocols\n   other than HIP.  These protocols\
    \ are loosely referred to as \"peer\n   protocols\".\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6079.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................3\n  \
    \ 3. Background on HIP ...............................................4\n    \
    \  3.1. ID/Locator Split ...........................................4\n      \
    \     3.1.1. Identifier Format ...................................5\n        \
    \   3.1.2. HIP Base Exchange ...................................5\n          \
    \ 3.1.3. Locator Management ..................................6\n      3.2. NAT\
    \ Traversal ..............................................6\n      3.3. Security\
    \ ...................................................7\n           3.3.1. DoS\
    \ Protection ......................................7\n           3.3.2. Identifier\
    \ Assignment and Authentication ............7\n           3.3.3. Connection Security\
    \ .................................9\n      3.4. HIP Deployability and Legacy\
    \ Applications ..................9\n   4. Framework Overview .............................................10\n\
    \   5. The HIP BONE Framework .........................................13\n  \
    \    5.1. Node ID Assignment and Bootstrap ..........................13\n    \
    \  5.2. Overlay Network Identification ............................14\n      5.3.\
    \ Connection Establishment ..................................15\n      5.4. Lightweight\
    \ Message Exchanges .............................15\n      5.5. HIP BONE Instantiation\
    \ ....................................16\n   6. Overlay HIP Parameters .........................................17\n\
    \      6.1. Overlay Identifier ........................................17\n  \
    \    6.2. Overlay TTL ...............................................17\n   7.\
    \ Security Considerations ........................................18\n   8. Acknowledgements\
    \ ...............................................19\n   9. IANA Considerations\
    \ ............................................19\n   10. References ....................................................19\n\
    \      10.1. Normative References .....................................19\n  \
    \    10.2. Informative References ...................................20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Host Identity Protocol (HIP) [RFC5201] defines a new\
    \ name space\n   between the network and transport layers.  HIP provides upper\
    \ layers\n   with mobility, multihoming, NAT (Network Address Translation)\n \
    \  traversal, and security functionality.  HIP implements the so-called\n   identifier/locator\
    \ (ID/locator) split, which implies that IP\n   addresses are only used as locators,\
    \ not as host identifiers.  This\n   split makes HIP a suitable protocol to build\
    \ overlay networks that\n   implement identifier-based overlay routing over IP\
    \ networks, which in\n   turn implement locator-based routing.\n   Using HIP-Based\
    \ Overlay Networking Environment (HIP BONE), as opposed\n   to a peer protocol,\
    \ to perform connection management in an overlay\n   has a set of advantages.\
    \  HIP BONE can be used by any peer protocol.\n   This keeps each peer protocol\
    \ from defining primitives needed for\n   connection management (e.g., primitives\
    \ to establish connections and\n   to tunnel messages through the overlay) and\
    \ NAT traversal.  Having\n   this functionality at a lower layer allows multiple\
    \ upper-layer\n   protocols to take advantage of it.\n   Additionally, having\
    \ a solution that integrates mobility and\n   multihoming is useful in many scenarios.\
    \  Peer protocols do not\n   typically specify mobility and multihoming solutions.\
    \  Combining a\n   peer protocol including NAT traversal with a separate mobility\n\
    \   mechanism and a separate multihoming mechanism can easily lead to\n   unexpected\
    \ (and unpleasant) interactions.\n   The remainder of this document is organized\
    \ as follows.  Section 3\n   provides background information on HIP.  Section\
    \ 4 gives an overview\n   of the HIP BONE (HIP-Based Overlay Networking Environment)\
    \ framework\n   and architecture and Section 5 describes the framework in more\n\
    \   detail.  Finally, Section 6 introduces new HIP parameters for overlay\n  \
    \ usage.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   The following terms are used in context of HIP BONEs:\n\
    \   Overlay network:  A network built on top of another network.  In case\n  \
    \    of HIP BONEs, the underlying network is an IP network and the\n      overlay\
    \ can be, e.g., a peer-to-peer (P2P) network.\n   Peer protocol:  A protocol used\
    \ by nodes in an overlay network for\n      performing, e.g., data storage and\
    \ retrieval or overlay\n      maintenance.\n   HIP BONE instance:  A HIP-based\
    \ overlay network that uses a\n      particular peer protocol and is based on\
    \ the framework presented\n      in this document.\n   Node ID:  A value that\
    \ uniquely identifies a node in an overlay\n      network.  The value is not usually\
    \ human-friendly.  As an example,\n      it may be a hash of a public key.\n \
    \  HIP association:  An IP-layer communications context created using\n      the\
    \ Host Identity Protocol.\n   Valid locator:  A locator (as defined in [RFC5206];\
    \ usually an IP\n      address or an address and a port number) at which a host\
    \ is known\n      to be reachable, for example, because there is an active HIP\n\
    \      association with the host.\n   Final recipient:  A node is the final recipient\
    \ of a HIP signaling\n      packet if one of its Host Identity Tags (HITs) matches\
    \ to the\n      receiver's HIT in the HIP packet header.\n"
- title: 3.  Background on HIP
  contents:
  - "3.  Background on HIP\n   This section provides background on HIP.  Given the\
    \ tutorial nature\n   of this section, readers that are familiar with what HIP\
    \ provides and\n   how HIP works may want to skip it.  All descriptions contain\n\
    \   references to the relevant HIP specifications where readers can find\n   detailed\
    \ explanations on the different topics discussed in this\n   section.\n"
- title: 3.1.  ID/Locator Split
  contents:
  - "3.1.  ID/Locator Split\n   In an IP network, IP addresses typically serve two\
    \ roles: they are\n   used as host identifiers and as host locators.  IP addresses\
    \ are\n   locators because a given host's IP address indicates where in the\n\
    \   network that host is located.  IP networks route based on these\n   locators.\
    \  Additionally, IP addresses are used to identify remote\n   hosts.  The simultaneous\
    \ use of IP addresses as host identifiers and\n   locators makes mobility and\
    \ multihoming complicated.  For example,\n   when a host opens a TCP connection,\
    \ the host identifies the remote\n   end of the connection by the remote IP address\
    \ (plus port).  If the\n   remote host changes its IP address, the TCP connection\
    \ will not\n   survive, since the transport layer identifier of the remote end\
    \ of\n   the connection has changed.\n   Mobility solutions such as Mobile IP\
    \ keep the remote IP address from\n   changing so that it can still be used as\
    \ an identifier.  HIP, on the\n   other hand, uses IP addresses only as locators\
    \ and defines a new\n   identifier space.  This approach is referred to as the\
    \ ID/locator\n   split and makes the implementation of mobility and multihoming\
    \ more\n   natural.  In the previous example, the TCP connection would be bound\n\
    \   to the remote host's identifier, which would not change when the\n   remote\
    \ hosts moves to a new IP address (i.e., to a new locator).  The\n   TCP connection\
    \ is able to survive locator changes because the remote\n   host's identifier\
    \ does not change.\n"
- title: 3.1.1.  Identifier Format
  contents:
  - "3.1.1.  Identifier Format\n   HIP uses 128-bit ORCHIDs (Overlay Routable Cryptographic\
    \ Hash\n   Identifiers) [RFC4843] as identifiers.  ORCHIDs look like IPv6\n  \
    \ addresses but cannot collide with regular IPv6 addresses because\n   ORCHID\
    \ spaces are registered with the IANA.  That is, a portion of\n   the IPv6 address\
    \ space is reserved for ORCHIDs.  The ORCHID\n   specification allows the creation\
    \ of multiple disjoint identifier\n   spaces.  Each such space is identified by\
    \ a separate Context\n   Identifier.  The Context Identifier can be either drawn\
    \ implicitly\n   from the context the ORCHID is used in or carried explicitly\
    \ in a\n   protocol.\n   HIP defines a native socket API [HIP-NATIVE-API] that\
    \ applications\n   can use to establish and manage connections.  Additionally,\
    \ HIP can\n   also be used through the traditional IPv4 and IPv6 TCP/IP socket\n\
    \   APIs.  Section 3.4 describes how an application using these\n   traditional\
    \ APIs can make use of HIP.  Figure 1 shows all these APIs\n   between the application\
    \ and the transport layers.\n            +-----------------------------------------+\n\
    \            |               Application               |\n            +----------------+------------------------+\n\
    \            | HIP Native API | Traditional Socket API |\n            +----------------+------------------------+\n\
    \            |             Transport Layer             |\n            +-----------------------------------------+\n\
    \                        Figure 1: HIP API\n"
- title: 3.1.2.  HIP Base Exchange
  contents:
  - "3.1.2.  HIP Base Exchange\n   Typically, before two HIP hosts exchange upper-layer\
    \ traffic, they\n   perform a four-way handshake that is referred to as the HIP\
    \ base\n   exchange.  Figure 2 illustrates the HIP base exchange.  The initiator\n\
    \   sends an I1 packet and receives an R1 packet from the responder.\n   After\
    \ that, the initiator sends an I2 packet and receives an R2\n   packet from the\
    \ responder.\n            Initiator                    Responder\n           \
    \     |            I1             |\n                |-------------------------->|\n\
    \                |            R1             |\n                |<--------------------------|\n\
    \                |            I2             |\n                |-------------------------->|\n\
    \                |            R2             |\n                |<--------------------------|\n\
    \                 Figure 2: HIP Base Exchange\n   Of course, the initiator needs\
    \ the responder's locator (or locators)\n   in order to send its I1 packet.  The\
    \ initiator can obtain locators\n   for the responder in multiple ways.  For example,\
    \ according to the\n   current HIP specifications the initiator can get the locators\n\
    \   directly from the DNS [RFC5205] or indirectly by sending packets\n   through\
    \ a HIP rendezvous server [RFC5204].  However, HIP is an open-\n   ended architecture.\
    \  The HIP architecture allows the locators to be\n   obtained by any means (e.g.,\
    \ from packets traversing an overlay\n   network or as part of the candidate address\
    \ collection process in a\n   NAT traversal scenario).\n"
- title: 3.1.3.  Locator Management
  contents:
  - "3.1.3.  Locator Management\n   Once a HIP connection between two hosts has been\
    \ established with a\n   HIP base exchange, the hosts can start exchanging higher-layer\n\
    \   traffic.  If any of the hosts changes its set of locators, it runs an\n  \
    \ update exchange [RFC5206], which consists of three messages.  If a\n   host\
    \ is multihomed, it simply provides more than one locator in its\n   exchanges.\
    \  However, if both of the endpoints move at the same time,\n   or through some\
    \ other reason both lose track of the peers' currently\n   active locators, they\
    \ need to resort to using a rendezvous server or\n   getting new peer locators\
    \ by some other means.\n"
- title: 3.2.  NAT Traversal
  contents:
  - "3.2.  NAT Traversal\n   HIP's NAT traversal mechanism [RFC5770] is based on ICE\
    \ (Interactive\n   Connectivity Establishment) [RFC5245].  Hosts gather address\n\
    \   candidates and, as part of the HIP base exchange, hosts perform an\n   ICE\
    \ offer/answer exchange where they exchange their respective\n   address candidates.\
    \  Hosts perform end-to-end STUN-based [RFC5389]\n   connectivity checks in order\
    \ to discover which address candidate\n   pairs yield connectivity.\n   Even though,\
    \ architecturally, HIP lies below the transport layer\n   (i.e., HIP packets are\
    \ carried directly in IP packets), in the\n   presence of NATs, HIP sometimes\
    \ needs to be tunneled in a transport\n   protocol (i.e., HIP packets are carried\
    \ by a transport protocol such\n   as UDP).\n"
- title: 3.3.  Security
  contents:
  - "3.3.  Security\n   Security is an essential part of HIP.  The following sections\n\
    \   describe the security-related functionality provided by HIP.\n"
- title: 3.3.1.  DoS Protection
  contents:
  - "3.3.1.  DoS Protection\n   HIP provides protection against DoS (denial-of-service)\
    \ attacks by\n   having initiators resolve a cryptographic puzzle before the responder\n\
    \   stores any state.  On receiving an I1 packet, a responder sends a\n   pre-generated\
    \ R1 packet that contains a cryptographic puzzle and\n   deletes all the state\
    \ associated with the processing of this I1\n   packet.  The initiator needs to\
    \ resolve the puzzle in the R1 packet\n   in order to generate an I2 packet. \
    \ The difficulty of the puzzle can\n   be adjusted so that, if a receiver is under\
    \ a DoS attack, it can\n   increase the difficulty of its puzzles.\n   On receiving\
    \ an I2 packet, a receiver checks that the solution in the\n   packet corresponds\
    \ to a puzzle generated by the receiver and that the\n   solution is correct.\
    \  If it is, the receiver processes the I2 packet.\n   Otherwise, it silently\
    \ discards it.\n   In an overlay scenario, there are multiple ways in which this\n\
    \   mechanism can be utilized within the overlay.  One possibility is to\n   cache\
    \ the pre-generated R1 packets within the overlay and let the\n   overlay directly\
    \ respond with R1s to I1s.  In that way, the responder\n   is not bothered at\
    \ all until the initiator sends an I2 packet, with\n   the puzzle solution.  Furthermore,\
    \ a more sophisticated overlay could\n   verify that an I2 packet has a correctly\
    \ solved puzzle before\n   forwarding the packet to the responder.\n"
- title: 3.3.2.  Identifier Assignment and Authentication
  contents:
  - "3.3.2.  Identifier Assignment and Authentication\n   As discussed earlier, HIP\
    \ uses ORCHIDs [RFC4843] as the main\n   representation for identifiers.  Potentially,\
    \ HIP can use different\n   types of ORCHIDs as long as the probability of finding\
    \ collisions\n   (i.e., two nodes with the same ORCHID) is low enough.  One way\
    \ to\n   completely avoid this type of collision is to have a central\n   authority\
    \ generate and assign ORCHIDs to nodes.  To secure the\n   binding between ORCHIDs\
    \ and any higher-layer identifiers, every time\n   the central authority assigns\
    \ an ORCHID to a node, it also generates\n   and signs a certificate stating who\
    \ is the owner of the ORCHID.  The\n   owner of the ORCHID then includes the corresponding\
    \ certificate in\n   its R1 (when acting as responder) and I2 packets (when acting\n\
    \   initiator) to prove that it is actually allowed to use the ORCHID\n   and,\
    \ implicitly, the associated public key.\n   Having a central authority works\
    \ well to completely avoid collisions.\n   However, having a central authority\
    \ is impractical in some scenarios.\n   As defined today, HIP systems generally\
    \ use a self-certifying ORCHID\n   type called HIT (Host Identity Tag) that does\
    \ not require a central\n   authority (but still allows one to be used).\n   A\
    \ HIT is the hash of a node's public key.  A node proves that it has\n   the right\
    \ to use a HIT by showing its ability to sign data with its\n   associated private\
    \ key.  This scheme is secure due to the so-called\n   second-preimage resistance\
    \ property of hash functions.  That is,\n   given a fixed public key K1, finding\
    \ a different public key K2 such\n   that hash(K1) = hash(K2) is computationally\
    \ very hard.  Optimally, a\n   preimage attack on the 100-bit hash function used\
    \ in ORCHIDs will\n   take an order of 2^100 operations to be successful, and\
    \ can be\n   expected to take in the average 2^99 operations.  Given that each\n\
    \   operation requires the attacker to generate a new key pair, the\n   attack\
    \ is fully impractical with current technology and techniques\n   (see [RFC4843]).\n\
    \   HIP nodes using HITs as ORCHIDs do not typically use certificates\n   during\
    \ their base exchanges.  Instead, they use a leap-of-faith\n   mechanism, similar\
    \ to the Secure Shell (SSH) protocol [RFC4251],\n   whereby a node somehow authenticates\
    \ remote nodes the first time they\n   connect to it and, then, remembers their\
    \ public keys.  While user-\n   assisted leap-of-faith mechanism (such as in SSH)\
    \ can be used to\n   facilitate a human-operated offline path (such as a telephone\
    \ call),\n   automated leap-of-faith mechanisms can be combined with a reputation\n\
    \   management system to create an incentive to behave.  However, such\n   considerations\
    \ go well beyond the current HIP architecture and even\n   beyond this proposal.\
    \  For the purposes of the present document, we\n   merely want to point out that,\
    \ architecturally, HIP supports both\n   self-generated opportunistic identifiers\
    \ and administratively\n   assigned ones.\n"
- title: 3.3.3.  Connection Security
  contents:
  - "3.3.3.  Connection Security\n   Once two nodes complete a base exchange between\
    \ them, the traffic\n   they exchange is encrypted and integrity protected.  The\
    \ security\n   mechanism used to protect the traffic is IPsec Encapsulating Security\n\
    \   Payload (ESP) [RFC5202].  However, there is ongoing work to specify\n   how\
    \ to use other protection mechanisms.\n"
- title: 3.4.  HIP Deployability and Legacy Applications
  contents:
  - "3.4.  HIP Deployability and Legacy Applications\n   As discussed earlier, HIP\
    \ defines a native socket API [HIP-NATIVE-\n   API] that applications can use\
    \ to establish and manage connections.\n   New applications can implement this\
    \ API to get full advantage of HIP.\n   However, in most cases, legacy (i.e.,\
    \ non-HIP-aware) applications\n   [RFC5338] can use HIP through the traditional\
    \ IPv4 and IPv6 socket\n   APIs.\n   The idea is that when a legacy IPv6 application\
    \ tries to obtain a\n   remote host's IP address (e.g., by querying the DNS),\
    \ the DNS\n   resolver passes the remote host's ORCHID (which was also stored\
    \ in\n   the DNS) to the legacy application.  At the same time, the DNS\n   resolver\
    \ stores the remote host's IP address internally at the HIP\n   module.  Since\
    \ the ORCHID looks like an IPv6 address, the legacy\n   application treats it\
    \ as such.  It opens a connection (e.g., TCP)\n   using the traditional IPv6 socket\
    \ API.  The HIP module running in the\n   same host as the legacy application\
    \ intercepts this call somehow\n   (e.g., using an interception library or setting\
    \ up the host's routing\n   tables so that the HIP module receives the traffic)\
    \ and runs HIP (on\n   behalf of the legacy application) towards the IP address\n\
    \   corresponding to the ORCHID.  This mechanism works well in almost all\n  \
    \ cases.  However, applications involving referrals (i.e., passing of\n   IPv6\
    \ addresses between applications) present issues, which are\n   discussed in Section\
    \ 5 below.  Additionally, management applications\n   that care about the exact\
    \ IP address format may not work well with\n   such a straightforward approach.\n\
    \   In order to make HIP work through the traditional IPv4 socket API,\n   the\
    \ HIP module passes an LSI (Local Scope Identifier), instead of a\n   regular\
    \ IPv4 address, to the legacy IPv4 application.  The LSI looks\n   like an IPv4\
    \ address, but is locally bound to an ORCHID.  That is,\n   when the legacy application\
    \ uses the LSI in a socket call, the HIP\n   module intercepts it and replaces\
    \ the LSI with its corresponding\n   ORCHID.  Therefore, LSIs always have local\
    \ scope.  They do not have\n   any meaning outside the host running the application.\
    \  The ORCHID is\n   used on the wire; not the LSI.  In the referral case, if\
    \ it is not\n   possible to rewrite the application level packets to use ORCHIDs\n\
    \   instead of LSIs, it may be hard to make IPv4 referrals work in\n   Internet-wide\
    \ settings.  IPv4 LSIs have been successfully used in\n   existing HIP deployments\
    \ within a single corporate network.\n"
- title: 4.  Framework Overview
  contents:
  - "4.  Framework Overview\n   The HIP BONE framework combines HIP with different\
    \ peer protocols to\n   provide robust and secure overlay network solutions.\n\
    \   Many overlays typically require three types of operations:\n   o  overlay\
    \ maintenance,\n   o  data storage and retrieval, and\n   o  connection management.\n\
    \   Overlay maintenance operations deal with nodes joining and leaving\n   the\
    \ overlay and with the maintenance of the overlay's routing tables.\n   Data storage\
    \ and retrieval operations deal with nodes storing,\n   retrieving, and removing\
    \ information in or from the overlay.\n   Connection management operations deal\
    \ with the establishment of\n   connections and the exchange of lightweight messages\
    \ among the nodes\n   of the overlay, potentially in the presence of NATs.\n \
    \  The HIP BONE framework uses HIP to perform connection management.\n   Data\
    \ storage and retrieval and overlay maintenance are to be\n   implemented using\
    \ protocols other than HIP.  For lack of a better\n   name, these protocols are\
    \ referred to as peer protocols.\n   One way to depict the relationship between\
    \ the peer protocol and HIP\n   modules is shown in Figure 3.  The peer protocol\
    \ module implements\n   the overlay construction and maintenance features, and\
    \ possibly\n   storage (if the particular protocol supports such a feature). \
    \ The\n   HIP module consults the peer protocol's overlay topology part to make\n\
    \   routing decisions, and the peer protocol uses HIP for connection\n   management\
    \ and sending peer protocol messages to other hosts.  The\n   HIP BONE API that\
    \ applications use is a combination of the HIP Native\n   API and traditional\
    \ socket API (as shown in Figure 1) with any\n   additional API a particular instance\
    \ implementation provides.\n                       Application\n            --------------------------------\
    \ HIP BONE API\n             +---+   +--------------------+\n             |  \
    \ |   |    Peer Protocol   |\n             |   |   +--------+ +---------+\n  \
    \           |   |<->|Topology| |(Storage)|\n             |   |   +---------+----------+\n\
    \             |   |             ^\n             |   |             v\n        \
    \     |   +------------------------+\n             |                HIP      \
    \   |\n             +----------------------------+\n            Figure 3: HIP\
    \ with Peer Protocol\n   Architecturally, HIP can be considered to create a new\
    \ thin \"waist\"\n   layer on top of the IPv4 and IPv6 networks; see Figure 4.\
    \  The HIP\n   layer itself consists of the HIP signaling protocol and one or\
    \ more\n   data transport protocols; see Figure 5.  The HIP signaling packets\n\
    \   and the data transport packets can take different routes.  In the HIP\n  \
    \ BONE scenarios, the HIP signaling packets are typically first routed\n   through\
    \ the overlay and then directly (if possible), while the data\n   transport packets\
    \ are typically routed only directly between the\n   endpoints.\n            +--------------------------------------+\n\
    \            |    Transport (using HITs or LSIs)    |\n            +--------------------------------------+\n\
    \            |                 HIP                  |\n            +------------------+-------------------+\n\
    \            |      IPv4        |       IPv6        |\n            +------------------+-------------------+\n\
    \                 Figure 4: HIP as a Thin Waist\n            +------------------+-------------------+\n\
    \            |  HIP signaling   |  data transports  |\n            +------------------+-------------------+\n\
    \                 Figure 5: HIP Layer Structure\n   In HIP BONE, the peer protocol\
    \ creates a new signaling layer on top\n   of HIP.  It is used to set up forwarding\
    \ paths for HIP signaling\n   messages.  This is a similar relationship that an\
    \ IP routing\n   protocol, such as OSPF, has to the IP protocol itself.  In the\
    \ HIP\n   BONE case, the peer protocol plays a role similar to OSPF, and HIP\n\
    \   plays a role similar to IP.  The ORCHIDs (or, in general, Node IDs if\n  \
    \ the ORCHID prefix is not used) are used for forwarding HIP packets\n   according\
    \ to the information in the routing tables.  The peer\n   protocols are used to\
    \ exchange routing information based on Node IDs\n   and to construct the routing\
    \ tables.\n   Architecturally, routing tables are located between the peer protocol\n\
    \   and HIP, as shown in Figure 6.  The peer protocol constructs the\n   routing\
    \ table and keeps it updated.  The HIP layer accesses the\n   routing table in\
    \ order to make routing decisions.  The bootstrap of a\n   HIP BONE overlay does\
    \ not create circular dependencies between the\n   peer protocol (which needs\
    \ to use HIP to establish connections with\n   other nodes) and HIP (which needs\
    \ the peer protocol to know how to\n   route messages to other nodes) for the\
    \ same reasons as the bootstrap\n   of an IP network does not create circular\
    \ dependencies between OSPF\n   and IP.  The first connections established by\
    \ the peer protocol are\n   with nodes whose locators are known.  HIP establishes\
    \ those\n   connections as any connection between two HIP nodes where no overlays\n\
    \   are present.  That is, there is no need for the overlay to provide a\n   rendezvous\
    \ service for those connections.\n            +--------------------------------------+\n\
    \            |            Peer protocol             |\n            +--------------------------------------+\n\
    \            |            Routing table             |\n            +--------------------------------------+\n\
    \            |                 HIP                  |\n            +--------------------------------------+\n\
    \                    Figure 6: Routing Tables\n   It is possible that different\
    \ overlays use different routing table\n   formats.  For example, the structure\
    \ of the routing tables of two\n   overlays based on different DHTs (Distributed\
    \ Hash Tables) may be\n   very different.  In order to make routing decisions,\
    \ the HIP layer\n   needs to convert the routing table generated by the peer protocol\n\
    \   into a forwarding table that allows the HIP layer select a next hop\n   for\
    \ any packet being routed.\n   In HIP BONE, the HIP usage of public keys and deriving\
    \ ORCHIDs\n   through a hash function can be utilized at the peer protocol side\
    \ to\n   better secure routing table maintenance and to protect against\n   chosen-peer-ID\
    \ attacks.\n   HIP BONE provides quite a lot of flexibility with regards to how\
    \ to\n   arrange the different protocols in detail.  Figure 7 shows one\n   potential\
    \ stack structure.\n            +-----------------------+--------------+\n   \
    \         | peer protocols        |     media    |\n            +------------------+----+--------------+\n\
    \            | HIP signaling    |   data transport  |\n            |         \
    \                             |\n            +------------------+-------------------+\n\
    \            | NAT    | non-NAT |                   |\n            |         \
    \         |                   |\n            |      IPv4        |       IPv6 \
    \       |\n            +------------------+-------------------+\n          Figure\
    \ 7: Example HIP BONE Stack Structure\n"
- title: 5.  The HIP BONE Framework
  contents:
  - "5.  The HIP BONE Framework\n   HIP BONE is a generic framework that allows the\
    \ use of different peer\n   protocols.  A particular HIP BONE instance uses a\
    \ particular peer\n   protocol.  The details on how to implement HIP BONE using\
    \ a given\n   peer protocol need to be specified in a, so-called, HIP BONE instance\n\
    \   specification.  Section 5.5 discusses what details need to be\n   specified\
    \ by HIP BONE instance specifications.  For example, the HIP\n   BONE instance\
    \ specification for RELOAD [P2PSIP-BASE] is specified in\n   [HIP-RELOAD-INSTANCE].\n"
- title: 5.1.  Node ID Assignment and Bootstrap
  contents:
  - "5.1.  Node ID Assignment and Bootstrap\n   Nodes in an overlay are primarily\
    \ identified by their Node IDs.\n   Overlays typically have an enrollment server\
    \ that can generate Node\n   IDs, or at least some part of the Node ID, and sign\
    \ certificates.  A\n   certificate generated by an enrollment server authorizes\
    \ a particular\n   user to use a particular Node ID in a particular overlay. \
    \ The way\n   users are identified is defined by the peer protocol and HIP BONE\n\
    \   instance specification.\n   The enrollment server of an overlay using HITs\
    \ derived from public\n   keys as Node IDs could just authorize users to use the\
    \ public keys\n   and HITs associated to their nodes.  Such a Node ID has the\
    \ same\n   self-certifying property as HITs and the Node ID can also be used in\n\
    \   the HIP and legacy APIs as an ORCHID.  This works well as long as the\n  \
    \ enrollment server is the one generating the public/private key pairs\n   for\
    \ all those nodes.  If the enrollment server authorizes users to\n   use HITs\
    \ that are generated directly by the nodes themselves, the\n   system is open\
    \ to a type of chosen-peer-ID attack.\n   If the overlay network or peer protocol\
    \ has more specific\n   requirements for the Node ID value that prevent using\
    \ HITs derived\n   from public keys, each host will need a certificate (e.g.,\
    \ in their\n   HIP base exchanges) provided by the enrollment server to prove\
    \ that\n   they are authorized to use a particular identifier in the overlay.\n\
    \   Depending on how the certificates are constructed, they typically\n   also\
    \ need to contain the host's self-generated public key.  Depending\n   on how\
    \ the Node IDs and public keys are attributed, different\n   scenarios become\
    \ possible.  For example, the Node IDs may be\n   attributed to users, there may\
    \ be user public key identifiers, and\n   there may be separate host public key\
    \ identifiers.  Authorization\n   certificates can be used to bind the different\
    \ types of identifiers\n   together.\n   HITs, as defined in [RFC5201], always\
    \ start with the ORCHID prefix.\n   Therefore, there are 100 bits left in the\
    \ HIT for different Node ID\n   values.  If an overlay network requires a larger\
    \ address space, it is\n   also possible to use all the 128 bits of a HIT for\
    \ addressing peer\n   layer identifiers.  The benefit of using ORCHID prefix for\
    \ Node IDs\n   is that it makes possible to use them with legacy socket APIs,\
    \ but in\n   this context, most of the applications are assumed to be HIP aware\n\
    \   and able to use a more advanced API supporting full 128-bit\n   identifiers.\
    \  Even larger address spaces could be supported with an\n   additional HIP parameter\
    \ giving the source and destination Node IDs,\n   but defining such a parameter,\
    \ if needed, is left for future\n   documents.\n   Bootstrap issues, such as how\
    \ to locate an enrollment or a bootstrap\n   server, belong to the peer protocol.\n"
- title: 5.2.  Overlay Network Identification
  contents:
  - "5.2.  Overlay Network Identification\n   It is possible for a HIP host to participate\
    \ simultaneously in\n   multiple different overlay networks.  It is also possible\
    \ that some\n   HIP traffic is not intended to be forwarded over an overlay.\n\
    \   Therefore, a host needs to know to which overlay an incoming HIP\n   message\
    \ belongs and the outgoing HIP messages need to be labeled as\n   belonging to\
    \ a certain overlay.  This document specifies a new\n   generic HIP parameter\
    \ (in Section 6.1) for the purpose of directing\n   HIP messages to the right\
    \ overlay.\n   In addition, an application using HIP BONE needs to define, either\n\
    \   implicitly or explicitly, the overlay to use for communication.\n   Explicit\
    \ configuration can happen, e.g., by configuring certain local\n   HITs to be\
    \ bound to certain overlays or by defining the overlay\n   identifier using advanced\
    \ HIP socket options or other suitable APIs.\n   On the other hand, if no explicit\
    \ configuration for a HIP association\n   is used, a host may have a configured\
    \ default overlay where all HIP\n   messages without a valid locator are sent.\
    \  The specification for how\n   to implement this coordination for locally originated\
    \ messages is out\n   of scope for this document.\n"
- title: 5.3.  Connection Establishment
  contents:
  - "5.3.  Connection Establishment\n   Nodes in an overlay need to establish connections\
    \ with other nodes in\n   different cases.  For example, a node typically has\
    \ connections to\n   the nodes in its forwarding table.  Nodes also need to establish\n\
    \   connections with other nodes in order to exchange application-layer\n   messages.\n\
    \   As discussed earlier, HIP uses the base exchange to establish\n   connections.\
    \  A HIP endpoint (the initiator) initiates a HIP base\n   exchange with a remote\
    \ endpoint by sending an I1 packet.  The\n   initiator sends the I1 packet to\
    \ the remote endpoint's locator.\n   Initiators that do not have any locator for\
    \ the remote endpoint need\n   to use a rendezvous service.  Traditionally, a\
    \ HIP rendezvous server\n   [RFC5204] has provided such a rendezvous service.\
    \  In HIP BONE, the\n   overlay itself provides the rendezvous service.\n   Therefore,\
    \ in HIP BONE, a node uses an I1 packet (as usual) to\n   establish a connection\
    \ with another node in the overlay.  Nodes in\n   the overlay forward I1 packets\
    \ in a hop-by-hop fashion according to\n   the overlay's routing table towards\
    \ its destination.  This way, the\n   overlay provides a rendezvous service between\
    \ the nodes establishing\n   the connection.  If the overlay nodes have active\
    \ connections with\n   other nodes in their forwarding tables and if those connections\
    \ are\n   protected (typically with IPsec ESP), I1 packets may be sent over\n\
    \   protected connections between nodes.  Alternatively, if there is no\n   such\
    \ an active connection but the node forwarding the I1 packet has a\n   valid locator\
    \ for the next hop, the I1 packets may be forwarded\n   directly, in a similar\
    \ fashion to how I1 packets are today forwarded\n   by a HIP rendezvous server.\n\
    \   Since HIP supports NAT traversal, a HIP base exchange over the\n   overlay\
    \ will perform an ICE [RFC5245] offer/answer exchange between\n   the nodes that\
    \ are establishing the connection.  In order to perform\n   this exchange, the\
    \ nodes need to first gather candidate addresses.\n   Which nodes can be used\
    \ to obtain reflexive address candidates and\n   which ones can be used to obtain\
    \ relayed candidates is defined by the\n   peer protocol.\n"
- title: 5.4.  Lightweight Message Exchanges
  contents:
  - "5.4.  Lightweight Message Exchanges\n   In some cases, nodes need to perform\
    \ a lightweight query to another\n   node (e.g., a request followed by a single\
    \ response).  In this\n   situation, establishing a connection using the mechanisms\
    \ in Section\n   5.3 for a simple query would be an overkill.  A better solution\
    \ is to\n   forward a HIP message through the overlay with the query and another\n\
    \   one with the response to the query.  The payload of such HIP packets\n   is\
    \ integrity protected [RFC6078].\n   Nodes in the overlay forward this HIP packet\
    \ in a hop-by-hop fashion\n   according to the overlay's routing table towards\
    \ its destination,\n   typically through the protected connections established\
    \ between them.\n   Again, the overlay acts as a rendezvous server between the\
    \ nodes\n   exchanging the messages.\n"
- title: 5.5.  HIP BONE Instantiation
  contents:
  - "5.5.  HIP BONE Instantiation\n   As discussed in Section 5, HIP BONE is a generic\
    \ framework that\n   allows using different peer protocols.  A particular HIP\
    \ BONE\n   instance uses a particular peer protocol.  The details on how to\n\
    \   implement a HIP BONE using a given peer protocol need to be specified\n  \
    \ in a, so-called, HIP BONE instance specification.  A HIP BONE\n   instance specification\
    \ needs to define, minimally:\n   o  the peer protocol to be used,\n   o  what\
    \ kind of Node IDs are used and how they are derived,\n   o  which peer protocol\
    \ primitives trigger HIP messages, and\n   o  how the overlay identifier is generated.\n\
    \   Additionally, a HIP BONE instance specification may need to specify\n   other\
    \ details that are specific to the peer protocol used.\n   As an example, the\
    \ HIP BONE instance specification for RELOAD\n   [P2PSIP-BASE] is specified in\
    \ [HIP-RELOAD-INSTANCE].\n   The areas not covered by a particular HIP BONE instance\
    \ specification\n   are specified by the peer protocol or elsewhere.  These areas\n\
    \   include:\n   o  the algorithm to create the overlay (e.g., a DHT),\n   o \
    \ overlay maintenance functions,\n   o  data storage and retrieval functions,\n\
    \   o  the process for obtaining a Node ID,\n   o  bootstrap function, and\n \
    \  o  how to select STUN and TURN servers for the candidate address\n      collection\
    \ process in NAT traversal scenarios.\n   Note that the border between a HIP BONE\
    \ instance specification and a\n   peer protocol specifications is fuzzy.  Depending\
    \ on how generic the\n   specification of a given peer protocol is, its associated\
    \ HIP BONE\n   instance specification may need to specify more or less details.\n\
    \   Also, a HIP BONE instance specification may leave certain areas\n   unspecified\
    \ in order to leave their configuration up to each\n   particular overlay.\n"
- title: 6.  Overlay HIP Parameters
  contents:
  - "6.  Overlay HIP Parameters\n   This section defines the generic format and protocol\
    \ behavior for the\n   Overlay Identifier and Overlay Time-to-Live (TTL) HIP parameters\
    \ that\n   can be used in HIP based overlay networks.  HIP BONE instance\n   specifications\
    \ define the exact format and content of the Overlay\n   Identifier parameter,\
    \ the cases when the Overlay TTL parameter should\n   be used, and any additional\
    \ behavior for each packet.\n"
- title: 6.1.  Overlay Identifier
  contents:
  - "6.1.  Overlay Identifier\n   To identify to which overlay network a HIP message\
    \ belongs, all HIP\n   messages that are sent via an overlay, or as a part of\
    \ operations\n   specific to a certain overlay, MUST contain an OVERLAY_ID parameter\n\
    \   with the identifier of the corresponding overlay network.  Instance\n   specifications\
    \ define how the identifier is generated for different\n   types of overlay networks.\
    \  The generation mechanism MUST be such\n   that it is unlikely to generate the\
    \ same identifier for two different\n   overlay instances and any other means\
    \ possible for preventing\n   collisions SHOULD be used.\n   The generic format\
    \ of the OVERLAY_ID parameter is shown in Figure 8.\n   Instance specifications\
    \ define valid length for the parameter and how\n   the identifier values are\
    \ generated.\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |             Type              |             Length            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Identifier                          /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                                               |    Padding    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type        4592\n      Length      Length of the Identifier, in octets\n\
    \      Identifier  The identifier value\n      Padding     0-7 bytes of padding\
    \ if needed\n                 Figure 8: Format of the OVERLAY_ID Parameter\n"
- title: 6.2.  Overlay TTL
  contents:
  - "6.2.  Overlay TTL\n   HIP packets sent in an overlay network MAY contain an Overlay\
    \ Time-\n   to-live (OVERLAY_TTL) parameter whose TTL value is decremented on\n\
    \   each overlay network hop.  When a HIP host receives a HIP packet with\n  \
    \ an OVERLAY_TTL parameter, and the host is not the final recipient of\n   the\
    \ packet, it MUST decrement the TTL value in the parameter by one\n   before forwarding\
    \ the packet.\n   If the TTL value in a received HIP packet is zero, and the receiving\n\
    \   host is not the final recipient, the packet MUST be dropped and the\n   host\
    \ SHOULD send HIP Notify packet with NOTIFICATION error type\n   OVERLAY_TTL_EXCEEDED\
    \ (value 70) to the sender of the original HIP\n   packet.\n   The Notification\
    \ Data field for the OVERLAY_TTL_EXCEEDED\n   notifications SHOULD contain the\
    \ HIP header and the TRANSACTION_ID\n   [RFC6078] parameter (if one exists) of\
    \ the packet whose TTL was\n   exceeded.\n   Figure 9 shows the format of the\
    \ OVERLAY_TTL parameter.  The TTL\n   value is given as the number of overlay\
    \ hops this packet has left and\n   it is encoded as an unsigned integer using\
    \ network byte order.\n       0                   1                   2      \
    \             3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Type              |             Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \             TTL               |            Reserved           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Type        64011\n      Length      4\n      TTL         The Time-to-Live\
    \ value\n      Reserved    Reserved for future use\n                Figure 9:\
    \ Format of the OVERLAY_TTL Parameter\n   The type of the OVERLAY_TTL parameter\
    \ is critical (as defined in\n   Section 5.2.1 of [RFC5201]) and therefore all\
    \ the HIP nodes\n   forwarding a packet with this parameter MUST support it. \
    \ If the\n   parameter is used in a scenario where the final recipient does not\n\
    \   support the parameter, the parameter SHOULD be removed before\n   forwarding\
    \ the packet to the final recipient.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document provides a high-level framework\
    \ to build HIP-based\n   overlays.  The security properties of HIP and its extensions\
    \ used in\n   this framework are discussed in their respective specifications.\n\
    \   Those security properties can be affected by the way HIP is used in a\n  \
    \ particular overlay.  However, those properties are mostly affected by\n   the\
    \ design decisions made to build a particular overlay; not so much\n   by the\
    \ high-level framework specified in this document.  Such design\n   decisions\
    \ are typically documented in a HIP BONE instance\n   specification, which describes\
    \ the security properties of the\n   resulting overlay.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   HIP BONE is based on ideas coming from conversations\
    \ and discussions\n   with a number of people in the HIP and P2PSIP communities.\
    \  In\n   particular, Philip Matthews, Eric Cooper, Joakim Koskela, Thomas\n \
    \  Henderson, Bruce Lowekamp, and Miika Komu provided useful input on\n   HIP\
    \ BONE.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This section is to be interpreted according to [RFC5226].\n\
    \   This document updates the IANA Registry for HIP Parameter Types\n   [RFC5201]\
    \ by assigning HIP Parameter Type values for the new HIP\n   Parameters OVERLAY_ID\
    \ (defined in Section 6.1) and OVERLAY_TTL\n   (defined in Section 6.2).  This\
    \ document also defines a new HIP\n   Notify Message Type [RFC5201], OVERLAY_TTL_EXCEEDED\
    \ in Section 6.2.\n   This value is allocated in the error range.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC4843]  Nikander, P., Laganier, J., and F. Dupont, \"An IPv6 Prefix\n\
    \              for Overlay Routable Cryptographic Hash Identifiers\n         \
    \     (ORCHID)\", RFC 4843, April 2007.\n   [RFC5201]  Moskowitz, R., Nikander,\
    \ P., Jokela, P., Ed., and T.\n              Henderson, \"Host Identity Protocol\"\
    , RFC 5201, April 2008.\n   [RFC5202]  Jokela, P., Moskowitz, R., and P. Nikander,\
    \ \"Using the\n              Encapsulating Security Payload (ESP) Transport Format\
    \ with\n              the Host Identity Protocol (HIP)\", RFC 5202, April 2008.\n\
    \   [RFC5770]  Komu, M., Henderson, T., Tschofenig, H., Melen, J., and A.\n  \
    \            Keranen, Ed., \"Basic Host Identity Protocol (HIP)\n            \
    \  Extensions for Traversal of Network Address Translators\",\n              RFC\
    \ 5770, April 2010.\n   [RFC6078]  Camarillo, G. and J. Melen, \"Host Identity\
    \ Protocol (HIP)\n              Immediate Carriage and Conveyance of Upper-Layer\
    \ Protocol\n              Signaling (HICCUPS)\", RFC 6078, January 2011.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC4251]  Ylonen, T. and C. Lonvick, Ed.,\
    \ \"The Secure Shell (SSH)\n              Protocol Architecture\", RFC 4251, January\
    \ 2006.\n   [RFC5204]  Laganier, J. and L. Eggert, \"Host Identity Protocol (HIP)\n\
    \              Rendezvous Extension\", RFC 5204, April 2008.\n   [RFC5205]  Nikander,\
    \ P. and J. Laganier, \"Host Identity Protocol\n              (HIP) Domain Name\
    \ System (DNS) Extensions\", RFC 5205,\n              April 2008.\n   [RFC5206]\
    \  Nikander, P., Henderson, T., Ed., Vogt, C., and J. Arkko,\n              \"\
    End-Host Mobility and Multihoming with the Host Identity\n              Protocol\"\
    , RFC 5206, April 2008.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n              May 2008.\n   [RFC5338]  Henderson, T., Nikander, P.,\
    \ and M. Komu, \"Using the Host\n              Identity Protocol with Legacy Applications\"\
    , RFC 5338,\n              September 2008.\n   [RFC5389]  Rosenberg, J., Mahy,\
    \ R., Matthews, P., and D. Wing,\n              \"Session Traversal Utilities\
    \ for NAT (STUN)\", RFC 5389,\n              October 2008.\n   [HIP-NATIVE-API]\n\
    \              Komu, M. and T. Henderson, \"Basic Socket Interface\n         \
    \     Extensions for Host Identity Protocol (HIP)\", Work in\n              Progress,\
    \ January 2010.\n   [RFC5245]  Rosenberg, J., \"Interactive Connectivity Establishment\n\
    \              (ICE): A Protocol for Network Address Translator (NAT)\n      \
    \        Traversal for Offer/Answer Protocols\", RFC 5245, April\n           \
    \   2010.\n   [P2PSIP-BASE]\n              Jennings, C., Lowekamp, B., Ed., Rescorla,\
    \ E., Baset, S.,\n              and H. Schulzrinne, \"REsource LOcation And Discovery\n\
    \              (RELOAD) Base Protocol\", Work in Progress, November 2010.\n  \
    \ [HIP-RELOAD-INSTANCE]\n              Keranen, A., Camarillo, G., and J. Maenpaa,\
    \ \"Host Identity\n              Protocol-Based Overlay Networking Environment\
    \ (HIP BONE)\n              Instance Specification for REsource LOcation And Discovery\n\
    \              (RELOAD)\", Work in Progress, January 2011.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Gonzalo Camarillo\n   Ericsson\n   Hirsalantie 11\n  \
    \ Jorvas  02420\n   Finland\n   EMail: Gonzalo.Camarillo@ericsson.com\n   Pekka\
    \ Nikander\n   Ericsson\n   Hirsalantie 11\n   Jorvas  02420\n   Finland\n   EMail:\
    \ Pekka.Nikander@ericsson.com\n   Jani Hautakorpi\n   Ericsson\n   Hirsalantie\
    \ 11\n   Jorvas  02420\n   Finland\n   EMail: Jani.Hautakorpi@ericsson.com\n \
    \  Ari Keranen\n   Ericsson\n   Hirsalantie 11\n   Jorvas 02420\n   Finland\n\
    \   EMail: Ari.Keranen@ericsson.com\n   Alan Johnston\n   Avaya\n   St. Louis,\
    \ MO  63124\n   EMail: alan.b.johnston@gmail.com\n"
