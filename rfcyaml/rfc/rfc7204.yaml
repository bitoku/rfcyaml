- title: __initial_text__
  contents:
  - '                      Requirements for Labeled NFS

    '
- title: Abstract
  contents:
  - "Abstract\n   This memo outlines high-level requirements for the integration of\n\
    \   flexible Mandatory Access Control (MAC) functionality into the\n   Network\
    \ File System (NFS) version 4.2 (NFSv4.2).  It describes the\n   level of protections\
    \ that should be provided over protocol components\n   and the basic structure\
    \ of the proposed system.  The intent here is\n   not to present the protocol\
    \ changes but to describe the environment\n   in which they reside.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7204.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Definitions .....................................................3\n  \
    \    2.1. Requirements Language ......................................4\n   3.\
    \ Requirements ....................................................4\n      3.1.\
    \ General ....................................................4\n      3.2. Security\
    \ Services ..........................................5\n      3.3. Label Encoding,\
    \ Label Format Specifiers, and Label\n           Checking Authorities .......................................5\n\
    \      3.4. Labeling ...................................................6\n  \
    \         3.4.1. Client Labeling .....................................6\n    \
    \       3.4.2. Server Labeling .....................................7\n      3.5.\
    \ Policy Enforcement .........................................7\n           3.5.1.\
    \ Client Enforcement ..................................7\n           3.5.2. Server\
    \ Enforcement ..................................8\n      3.6. Namespace Access\
    \ ...........................................8\n      3.7. Upgrading Existing\
    \ Server ..................................9\n   4. Modes of Operation ..............................................9\n\
    \      4.1. Full Mode ..................................................9\n  \
    \    4.2. Limited Server Mode .......................................10\n    \
    \  4.3. Guest Mode ................................................10\n   5. Use\
    \ Cases ......................................................11\n      5.1. Full\
    \ MAC Labeling Support for Remotely Mounted\n           File Systems ..............................................11\n\
    \      5.2. MAC Labeling of Virtual Machine Images Stored on\n           the Network\
    \ ...............................................11\n      5.3. Simple Security\
    \ Label Storage .............................12\n      5.4. Diskless Linux ............................................12\n\
    \      5.5. Multi-Level Security ......................................13\n  \
    \         5.5.1. Full Mode - MAC-Functional Client and Server .......13\n    \
    \       5.5.2. MAC-Functional Client ..............................14\n      \
    \     5.5.3. MAC-Functional Server ..............................15\n   6. Security\
    \ Considerations ........................................15\n      6.1. Trust\
    \ Needed for a Community ..............................15\n      6.2. Guest Mode\
    \ ................................................15\n      6.3. MAC-Functional\
    \ Client Configuration .......................16\n   7. References .....................................................16\n\
    \      7.1. Normative References ......................................16\n  \
    \    7.2. Informative References ....................................16\n   Appendix\
    \ A. Acknowledgments .......................................18\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Mandatory Access Control (MAC) systems (as defined in [RFC4949])\
    \ have\n   been mainstreamed in modern operating systems such as Linux, FreeBSD,\n\
    \   and Solaris.  MAC systems bind security attributes to subjects\n   (processes)\
    \ and objects within a system.  These attributes are used\n   with other information\
    \ in the system to make access control\n   decisions.\n   Access control models\
    \ such as Unix permissions or Access Control\n   Lists (ACLs) are commonly referred\
    \ to as Discretionary Access Control\n   (DAC) models.  These systems base their\
    \ access decisions on user\n   identity and resource ownership.  In contrast,\
    \ MAC models base their\n   access control decisions on the label on the subject\
    \ (usually a\n   process) and the object it wishes to access.  These labels may\n\
    \   contain user identity information but usually contain additional\n   information.\
    \  In DAC systems, users are free to specify the access\n   rules for resources\
    \ that they own.  MAC models base their security\n   decisions on a system-wide\
    \ policy established by an administrator or\n   organization that the users do\
    \ not have the ability to override.  DAC\n   systems offer some protection against\
    \ unauthorized users running\n   malicious software.  However, even an authorized\
    \ user can execute\n   malicious or flawed software with those programs running\
    \ with the\n   full permissions of the user executing it.  Inversely, MAC models\
    \ can\n   confine malicious or flawed software and usually act at a finer\n  \
    \ granularity than their DAC counterparts.\n   Besides describing the requirements,\
    \ this document records the\n   functional requirements for the client imposed\
    \ by the preexisting\n   security models on the client.  This document may help\
    \ those outside\n   the NFS community understand those issues.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   Foreign Label:  a label in a format other than the format\
    \ that a MAC\n      implementation uses for encoding.\n   Label Format Specifier\
    \ (LFS):  an identifier used by the client to\n      establish the syntactic format\
    \ of the security label and the\n      semantic meaning of its components.\n \
    \  MAC-Aware:  a server that can transmit and store object labels.\n   MAC-Functional:\
    \  a client or server that is Labeled NFS enabled.\n      Such a system can interpret\
    \ labels and apply policies based on the\n      security system.\n   Multi-Level\
    \ Security (MLS):  a traditional model where objects are\n      given a sensitivity\
    \ level (Unclassified, Secret, Top Secret, etc.)\n      and a category set [RH_MLS].\n\
    \   Object:  a passive resource within the system that we wish to\n      protect.\
    \  Objects can be entities such as files, directories,\n      pipes, sockets,\
    \ and many other system resources relevant to the\n      protection of the system\
    \ state.\n   Policy Identifier (PI):  an optional part of the definition of a\n\
    \      Label Format Specifier.  The PI allows clients and servers to\n      identify\
    \ specific security policies.\n   Subject:  an active entity, usually a process,\
    \ that is requesting\n      access to an object.\n"
- title: 2.1.  Requirements Language
  contents:
  - "2.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Requirements
  contents:
  - "3.  Requirements\n   The following initial requirements have been gathered from\
    \ users and\n   developers, and from previous development efforts in this area\
    \ such\n   as the Distributed Trusted Operating System [DTOS] and the NSA's\n\
    \   experimental NFSv3 enhancements [SENFSv3].\n"
- title: 3.1.  General
  contents:
  - "3.1.  General\n   A mechanism is required to provide security attribute information\
    \ to\n   NFSv4 clients and servers.  This mechanism has the following\n   requirements:\n\
    \   (1)  Clients MUST be able to convey to the server the client's\n        privileges,\
    \ i.e., the subject, for making the access request.\n        The server may provide\
    \ a mechanism to enforce MAC policy based\n        on the requesting client's\
    \ privileges.\n   (2)  Servers MUST be able to store and retrieve the security\n\
    \        attribute of exported files as requested by the client.\n   (3)  Servers\
    \ MUST provide a mechanism for notifying clients of\n        attribute changes\
    \ of files on the server.\n   (4)  Clients and Servers MUST be able to negotiate\
    \ Label Formats and\n        provide a mechanism to translate between them as\
    \ needed.\n"
- title: 3.2.  Security Services
  contents:
  - "3.2.  Security Services\n   Labeled NFS or the underlying system on which the\
    \ Labeled NFS\n   operates MUST provide the following security services for all\
    \ NFSv4.2\n   messaging:\n   o  Authentication\n   o  Integrity\n   o  Privacy\n\
    \   Mechanisms and algorithms used in the provision of security services\n   MUST\
    \ be configurable so that appropriate levels of protection may be\n   flexibly\
    \ specified per mandatory security policy.\n   Strong mutual authentication is\
    \ required between the server and the\n   client for Full Mode operation (Section\
    \ 4.1).\n   MAC security labels and any related security state MUST always be\n\
    \   protected by these security services when transferred over the\n   network,\
    \ as MUST the binding of labels and state to associated\n   objects and subjects.\n\
    \   Labeled NFS SHOULD support authentication on a context granularity so\n  \
    \ that different contexts running on a client can use different\n   cryptographic\
    \ keys and facilities.\n"
- title: 3.3.  Label Encoding, Label Format Specifiers, and Label Checking
  contents:
  - "3.3.  Label Encoding, Label Format Specifiers, and Label Checking\n      Authorities\n\
    \   Encoding of MAC labels and attributes passed over the network MUST be\n  \
    \ specified in a complete and unambiguous manner while maintaining the\n   flexibility\
    \ of MAC implementations.  To accomplish this, the labels\n   MUST consist of\
    \ a format-specific component bound with a Label Format\n   Specifier (LFS). \
    \ The LFS component provides a mechanism for\n   identifying the structure and\
    \ semantics of the opaque component.\n   Meanwhile, the opaque component is the\
    \ security label that will be\n   interpreted by the MAC models.\n   MAC models\
    \ base access decisions on security attribute privileges\n   bound to subjects\
    \ and objects, respectively.  With a given MAC model,\n   all systems have semantically\
    \ coherent labeling -- a security label\n   MUST always mean exactly the same\
    \ thing on every system.  While this\n   may not be necessary for simple MAC models,\
    \ it is recommended that\n   most Label Formats assigned an LFS incorporate semantically\
    \ coherent\n   labeling into their Label Format.\n   Labeled NFS SHOULD define\
    \ an initial negotiation scheme with the\n   primary aims of simplicity and completeness.\
    \  This is to facilitate\n   practical deployment of systems without being weighed\
    \ down by complex\n   and overgeneralized global schemes.  Future extensibility\
    \ SHOULD also\n   be taken into consideration.\n   Labeled NFS MUST provide a\
    \ means for servers and clients to identify\n   their LFSs for the purposes of\
    \ authorization, security service\n   selection, and security label interpretation.\n\
    \   Labeled NFS MUST provide a means for servers and clients to identify\n   their\
    \ mode of operation (see Section 4).\n   A negotiation scheme SHOULD be provided,\
    \ allowing systems from\n   different Label Formats to agree on how they will\
    \ interpret or\n   translate each other's foreign labels.  Multiple concurrent\n\
    \   agreements may be current between a server and a client.\n   All security\
    \ labels and related security state transferred across the\n   network MUST be\
    \ tagged with a valid LFS.\n   If the LFS supported on a system changes, the system\
    \ SHOULD\n   renegotiate agreements to reflect these changes.\n   If a system\
    \ receives any security label or security state tagged with\n   an LFS it does\
    \ not recognize or cannot interpret, it MUST reject that\n   label or state.\n\
    \   NFSv4.2 includes features that may cause a client to cross an LFS\n   boundary\
    \ when accessing what appears to be a single file system.  If\n   LFS negotiation\
    \ is supported by the client and the server, the server\n   SHOULD negotiate a\
    \ new, concurrent agreement with the client, acting\n   on behalf of the externally\
    \ located source of the files.\n"
- title: 3.4.  Labeling
  contents:
  - "3.4.  Labeling\n   Implementations MUST validate security labels supplied over\
    \ the\n   network to ensure that they are within a set of labels permitted from\n\
    \   a specific peer and, if not, reject them.  Note that a system may\n   permit\
    \ a different set of labels to be accepted from each peer.\n"
- title: 3.4.1.  Client Labeling
  contents:
  - "3.4.1.  Client Labeling\n   At the client, labeling semantics for NFS mounted\
    \ file systems MUST\n   remain consistent with those for locally mounted file\
    \ systems.  In\n   particular, user-level labeling operations local to the client\
    \ MUST\n   be enacted locally via existing APIs, to ensure compatibility and\n\
    \   consistency for applications and libraries.\n   Note that this does not imply\
    \ any specific mechanism for conveying\n   labels over the network.\n   When an\
    \ object is newly created by the client, it will calculate the\n   label for the\
    \ object based on its policy.  Once that is done, it will\n   send the request\
    \ to the server, which has the ability to deny the\n   creation of the object\
    \ with that label based on the server's policy.\n   In creating the file, the\
    \ server MUST ensure that the label is bound\n   to the object before the object\
    \ becomes visible to the rest of the\n   system.  This ensures that any access\
    \ control or further labeling\n   decisions are correct for the object.\n"
- title: 3.4.2.  Server Labeling
  contents:
  - "3.4.2.  Server Labeling\n   The server MUST provide the capability for clients\
    \ to retrieve\n   security labels on all exported file system objects where possible.\n\
    \   This includes cases where only in-core and/or read-only security\n   labels\
    \ are available at the server for any of its exported file\n   systems.\n   The\
    \ server MUST honor the ability for a client to specify the label\n   of an object\
    \ on creation.  If the server is MAC enabled, it may\n   choose to reject the\
    \ label specified by the client, due to\n   restrictions in the server policy.\
    \  The server SHOULD NOT attempt to\n   find a suitable label for an object in\
    \ the event of different\n   labeling rules on its end.  The server is allowed\
    \ to translate the\n   label but MUST NOT change the semantic meaning of the label.\n"
- title: 3.5.  Policy Enforcement
  contents:
  - "3.5.  Policy Enforcement\n   The MAC-Functional client determines if a process\
    \ request is sent to\n   the remote server.  Upon a successful response from the\
    \ server, it\n   must use its own policies on the object's security labels to\n\
    \   determine if the process can be given access.  The client SHOULD NOT\n   need\
    \ to be cognizant of whether the server is a Limited Server or is\n   fully MAC-Functional.\n"
- title: 3.5.1.  Client Enforcement
  contents:
  - "3.5.1.  Client Enforcement\n   The client MUST apply its own policy to remotely\
    \ located objects,\n   using security labels for the objects obtained from the\
    \ server.  It\n   MUST be possible to configure the maximum length of time a client\
    \ may\n   cache state regarding remote labels before revalidating that state\n\
    \   with the server.\n   If the server's policy changes, the client MUST flush\
    \ all object\n   state back to the server.  The server MUST ensure that any flushed\n\
    \   state received is consistent with current policy before committing it\n  \
    \ to stable storage.\n   Any local security state associated with cached or delegated\
    \ objects\n   MUST also be flushed back to the server when any other state of\
    \ the\n   objects is required to be flushed back.\n   The implication here is\
    \ that if the client holds a delegation on an\n   object, then it enforces policy\
    \ to local changes based on the object\n   label it got from the server.  When\
    \ it tries to commit those changes\n   to the server, it SHOULD be prepared for\
    \ the server to reject those\n   changes based on the policies of the server.\n"
- title: 3.5.2.  Server Enforcement
  contents:
  - "3.5.2.  Server Enforcement\n   A MAC-Functional server MUST enforce its security\
    \ policy over all\n   exported objects, for operations that originate both locally\
    \ and\n   remotely.\n   Requests from authenticated clients MUST be processed\
    \ using security\n   labels and credentials supplied by the client as if they\
    \ originated\n   locally.\n   As with labeling, the system MUST also take into\
    \ account any other\n   volatile client security state, such as a change in process\
    \ security\n   context via dynamic transition.  Access decisions SHOULD also be\
    \ made\n   based upon the current client security label accessing the object,\n\
    \   rather than the security label that opened it, if different.\n   The server\
    \ SHOULD recall delegation of an object if the object's\n   security label changes.\n"
- title: 3.6.  Namespace Access
  contents:
  - "3.6.  Namespace Access\n   The server SHOULD provide a means to authorize selective\
    \ access to\n   the exported file system namespace based upon client credentials\
    \ and\n   according to security policy.\n   This is a common requirement of MLS-enabled\
    \ systems, which often need\n   to present selective views of namespaces based\
    \ upon the clearances of\n   the subjects.\n"
- title: 3.7.  Upgrading Existing Server
  contents:
  - "3.7.  Upgrading Existing Server\n   Note that under the MAC model, all objects\
    \ MUST have labels.\n   Therefore, if an existing server is upgraded to include\
    \ Labeled NFS\n   support, then it is the responsibility of the security system\
    \ to\n   define the behavior for existing objects.\n"
- title: 4.  Modes of Operation
  contents:
  - "4.  Modes of Operation\n   In a Labeled NFS client and server interaction, we\
    \ can describe three\n   modes of operation:\n   1.  Full\n   2.  Limited Server\n\
    \   3.  Guest\n   These modes arise from the level of MAC functionality in the\
    \ clients\n   and servers.  The clients can be non-MAC-Functional and\n   MAC-Functional.\
    \  The servers can be non-MAC-Functional, MAC-Aware,\n   and MAC-Functional.\n\
    \   A MAC-Functional client MUST be able to determine the level of MAC\n   functionality\
    \ in the server.  Likewise, a MAC-Functional server MUST\n   be able to determine\
    \ whether or not a client is MAC-Functional.  As\n   discussed in Section 3.3,\
    \ the protocol MUST provide for the client\n   and server to make those determinations.\n"
- title: 4.1.  Full Mode
  contents:
  - "4.1.  Full Mode\n   The server and the client have mutually recognized MAC functionality\n\
    \   enabled, and full Labeled NFS functionality is extended over the\n   network\
    \ between both client and server.\n   An example of an operation in Full Mode\
    \ is as follows.  On the\n   initial lookup, the client requests access to an\
    \ object on the\n   server.  It sends its process security context over to the\
    \ server.\n   The server checks all relevant policies to determine if that process\n\
    \   context from that client is allowed to access the resource.  Once\n   this\
    \ has succeeded, the object, with its associated security\n   information, is\
    \ released to the client.  Once the client receives the\n   object, it determines\
    \ if its policies allow the process running on\n   the client access to the object.\n\
    \   On subsequent operations where the client already has a handle for\n   the\
    \ file, the order of enforcement is reversed.  Since the client\n   already has\
    \ the security context, it may make an access decision\n   against its policy\
    \ first.  This enables the client to avoid sending\n   requests to the server\
    \ that it knows will fail, regardless of the\n   server's policy.  If the client\
    \ passes its policy checks, then it\n   sends the request to the server, where\
    \ the client's process context\n   is used to determine if the server will release\
    \ that resource to the\n   client.  If both checks pass, the client is given the\
    \ resource and\n   everything succeeds.\n   In the event that the client does\
    \ not trust the server, it may opt to\n   use an alternate labeling mechanism,\
    \ regardless of the server's\n   ability to return security information.\n"
- title: 4.2.  Limited Server Mode
  contents:
  - "4.2.  Limited Server Mode\n   The server is MAC-Aware, and the clients are MAC-Functional.\
    \  The\n   server can store and transmit labels.  It cannot enforce labels.  The\n\
    \   server MUST inform clients when an object label changes for a file\n   the\
    \ client has open.\n   In this mode, the server may not be aware of the format\
    \ of any of its\n   object labels.  Indeed, it may service several different security\n\
    \   models at the same time.  A client MUST process foreign labels as\n   discussed\
    \ in Section 3.3.  As with the Guest Mode, this mode's level\n   of trust can\
    \ be degraded if non-MAC-Functional clients have access to\n   the server.\n"
- title: 4.3.  Guest Mode
  contents:
  - "4.3.  Guest Mode\n   Only one of the server or client is MAC-Functional enabled.\n\
    \   In the case of the server only being MAC-Functional, the server\n   enforces\
    \ its policy and may selectively provide standard NFS services\n   to clients\
    \ based on their authentication credentials and/or\n   associated network attributes\
    \ (e.g., IP address, network interface)\n   according to security policy.  The\
    \ level of trust and access extended\n   to a client in this mode is configuration-specific.\n\
    \   In the case of the client only being MAC-Functional, the client MUST\n   operate\
    \ as a standard NFSv4.2 (see [NFSv4_2]) client and SHOULD\n   selectively provide\
    \ processes access to servers based upon the\n   security attributes of the local\
    \ process, and network attributes of\n   the server, according to policy.  The\
    \ client may also override\n   default labeling of the remote file system based\
    \ upon these security\n   attributes or other labeling methods such as mount point\
    \ labeling.\n   In other words, the Guest Mode is standard NFSv4.2 over the wire,\n\
    \   with the MAC-Functional system mapping the non-MAC-Functional\n   system's\
    \ processes or objects to security labels based on other\n   characteristics in\
    \ order to preserve its MAC guarantees.\n"
- title: 5.  Use Cases
  contents:
  - "5.  Use Cases\n   MAC labeling is meant to allow NFSv4.2 to be deployed in site-\n\
    \   configurable security schemes.  The LFS and opaque data scheme allows\n  \
    \ for flexibility to meet these different implementations.  In this\n   section,\
    \ we provide some examples of how NFSv4.2 could be deployed to\n   meet existing\
    \ needs.  This is not an exhaustive listing.\n"
- title: 5.1.  Full MAC Labeling Support for Remotely Mounted File Systems
  contents:
  - "5.1.  Full MAC Labeling Support for Remotely Mounted File Systems\n   In this\
    \ case, we assume a local networked environment where the\n   servers and clients\
    \ are under common administrative control.  All\n   systems in this network have\
    \ the same MAC implementation and\n   semantically identical MAC security labels\
    \ for objects (i.e., labels\n   mean the same thing on different systems, even\
    \ if the policies on\n   each system may differ to some extent).  Clients will\
    \ be able to\n   apply fine-grained MAC policy to objects accessed via NFS mounts\
    \ and\n   thus improve the overall consistency of MAC policy application within\n\
    \   this environment.\n   An example of this case would be where user home directories\
    \ are\n   remotely mounted, and fine-grained MAC policy is implemented to\n  \
    \ protect, for example, private user data from being read by malicious\n   web\
    \ scripts running in the user's browser.  With Labeled NFS, fine-\n   grained\
    \ MAC labeling of the user's files will allow the MAC policy to\n   be implemented\
    \ and provide the desired protection.\n"
- title: 5.2.  MAC Labeling of Virtual Machine Images Stored on the Network
  contents:
  - "5.2.  MAC Labeling of Virtual Machine Images Stored on the Network\n   Virtualization\
    \ is now a commonly implemented feature of modern\n   operating systems, and there\
    \ is a need to ensure that MAC security\n   policy is able to protect virtualized\
    \ resources.  A common\n   implementation scheme involves storing virtualized\
    \ guest file systems\n   on a networked server; these file systems are then mounted\
    \ remotely\n   by guests upon instantiation.  In this case, there is a need to\n\
    \   ensure that the local guest kernel is able to access fine-grained MAC\n  \
    \ labels on the remotely mounted file system so that its MAC security\n   policy\
    \ can be applied.\n"
- title: 5.3.  Simple Security Label Storage
  contents:
  - "5.3.  Simple Security Label Storage\n   In this case, a mixed and loosely administered\
    \ network is assumed,\n   where nodes may be running a variety of operating systems\
    \ with\n   different security mechanisms and security policies.  It is desired\n\
    \   that network file servers be simply capable of storing and retrieving\n  \
    \ MAC security labels for clients that use such labels.  The Labeled\n   NFS protocol\
    \ would be implemented here solely to enable transport of\n   MAC security labels\
    \ across the network.  It should be noted that in\n   such an environment, overall\
    \ security cannot be as strongly enforced\n   as when the server is also enforcing\
    \ and that this scheme is aimed at\n   allowing MAC-capable clients to function\
    \ with its MAC security policy\n   enabled rather than perhaps disabling it entirely.\n"
- title: 5.4.  Diskless Linux
  contents:
  - "5.4.  Diskless Linux\n   A number of popular operating system distributions depend\
    \ on a\n   Mandatory Access Control (MAC) model to implement a kernel-enforced\n\
    \   security policy.  Typically, such models assign particular roles to\n   individual\
    \ processes, which limit or permit performing certain\n   operations on a set\
    \ of files, directories, sockets, or other objects.\n   While the enforcing of\
    \ the policy is typically a matter for the\n   diskless NFS client itself, the\
    \ file system objects in such models\n   will typically carry MAC labels that\
    \ are used to define policy on\n   access.  These policies may, for instance,\
    \ describe privilege\n   transitions that cannot be replicated using standard\
    \ NFS ACL-based\n   models.\n   For instance, on a SYSV-compatible system (see\
    \ [SYSV]), if the 'init'\n   process spawns a process that attempts to start the\
    \ 'NetworkManager'\n   executable, there may be a policy that sets up a role transition\
    \ if\n   the 'init' process and 'NetworkManager' file labels match a\n   particular\
    \ rule.  Without this role transition, the process may find\n   itself having\
    \ insufficient privileges to perform its primary job of\n   configuring network\
    \ interfaces.\n   In setups of this type, a lot of the policy targets (such as\
    \ sockets\n   or privileged system calls) are entirely local to the client.  The\n\
    \   use of RPCSEC_GSSv3 ([RPC_SEC]) for enforcing compliance at the\n   server\
    \ level is therefore of limited value.  The ability to\n   permanently label files\
    \ and have those labels read back by the client\n   is, however, crucial to the\
    \ ability to enforce that policy.\n"
- title: 5.5.  Multi-Level Security
  contents:
  - "5.5.  Multi-Level Security\n   In an MLS system, objects are generally assigned\
    \ a sensitivity level\n   and a set of compartments.  The sensitivity levels within\
    \ the system\n   are given an order ranging from lowest to highest classification\n\
    \   level.  Read access to an object is allowed when the sensitivity\n   level\
    \ of the subject \"dominates\" the object it wants to access.  This\n   means\
    \ that the sensitivity level of the subject is higher than that\n   of the object\
    \ it wishes to access and that its set of compartments is\n   a superset of the\
    \ compartments on the object.\n   The rest of this section will just use sensitivity\
    \ levels.  In\n   general, the example is a client that wishes to list the contents\
    \ of\n   a directory.  The system defines the sensitivity levels as\n   Unclassified\
    \ (U), Secret (S), and Top Secret (TS).  The directory to\n   be searched is labeled\
    \ Top Secret, which means access to read the\n   directory will only be granted\
    \ if the subject making the request is\n   also labeled Top Secret.\n"
- title: 5.5.1.  Full Mode - MAC-Functional Client and Server
  contents:
  - "5.5.1.  Full Mode - MAC-Functional Client and Server\n   In the first part of\
    \ this example, a process on the client is running\n   at the Secret level.  The\
    \ process issues a readdir() system call,\n   which enters the kernel.  Before\
    \ translating the readdir() system\n   call into a request to the NFSv4.2 server,\
    \ the host operating system\n   will consult the MAC module to see if the operation\
    \ is allowed.\n   Since the process is operating at Secret and the directory to\
    \ be\n   accessed is labeled Top Secret, the MAC module will deny the request\n\
    \   and an error code is returned to user space.\n   Consider a second case where\
    \ instead of running at Secret the process\n   is running at Top Secret.  In this\
    \ case, the sensitivity of the\n   process is equal to or greater than that of\
    \ the directory, so the MAC\n   module will allow the request.  Now the readdir()\
    \ is translated into\n   the necessary NFSv4.2 call to the server.  For the remote\
    \ procedure\n   call (RPC) request, the client is using the proper credential\
    \ to\n   assert to the server that the process is running at Top Secret.\n   When\
    \ the server receives the request, it extracts the security label\n   from the\
    \ RPC session and retrieves the label on the directory.  The\n   server then checks\
    \ with its MAC module to see if a Top Secret process\n   is allowed to read the\
    \ contents of the Top Secret directory.  Since\n   this is allowed by the policy,\
    \ then the server will return the\n   appropriate information back to the client.\n\
    \   In this example, the policy on both the client and server is the\n   same.\
    \  In the event that they were running different policies, a\n   translation of\
    \ the labels might be needed.  In this case, it could be\n   possible for a check\
    \ to pass on the client and fail on the server.\n   The server may consider additional\
    \ information when making its policy\n   decisions.  For example, the server could\
    \ determine that a certain\n   subnet is only cleared for data up to Secret classification.\
    \  If that\n   constraint was in place for the example above, the client would\
    \ still\n   succeed, but the server would fail, since the client is asserting\
    \ a\n   label that it is not able to use (Top Secret on a Secret network).\n"
- title: 5.5.2.  MAC-Functional Client
  contents:
  - "5.5.2.  MAC-Functional Client\n   In these scenarios, the server is either non-MAC-Aware\
    \ or MAC-Aware.\n   The actions of the client will depend on whether it is configured\
    \ to\n   treat the MAC-Aware server in the same manner as the non-MAC-Aware\n\
    \   one.  That is, does it utilize the approach presented in Section 4.3,\n  \
    \ or does it allow the MAC-Aware server to return labels?\n   With a client that\
    \ is MAC-Functional and using the example in the\n   previous section, the result\
    \ should be the same.  The one difference\n   is that all decisions are made on\
    \ the client.\n"
- title: 5.5.2.1.  MAC-Aware Server
  contents:
  - "5.5.2.1.  MAC-Aware Server\n   A process on the client labeled Secret wishes\
    \ to access a directory\n   labeled Top Secret on the server.  This is denied,\
    \ since Secret does\n   not dominate Top Secret.  Note that there will be NFSv4.2\
    \ operations\n   issued that return an object label for the client to process.\n\
    \   Note that in this scenario, all of the clients must be\n   MAC-Functional.\
    \  A single client that does not do its access control\n   checks would violate\
    \ the model.\n"
- title: 5.5.2.2.  Non-MAC-Aware Server
  contents:
  - "5.5.2.2.  Non-MAC-Aware Server\n   A process on the client labeled Secret wishes\
    \ to access a directory\n   that the client's policies label as Top Secret on\
    \ the server.  This\n   is denied, since Secret does not dominate Top Secret.\
    \  Note that\n   there will not be NFSv4.2 operations issued.  If the process\
    \ had a\n   Top Secret process label instead of Secret, the client would issue\n\
    \   NFSv4.2 operations to access the directory on the server.\n"
- title: 5.5.3.  MAC-Functional Server
  contents:
  - "5.5.3.  MAC-Functional Server\n   With a MAC-Functional server and a client that\
    \ is not, the client\n   behaves as if it were in a normal NFSv4.2 environment.\
    \  Since the\n   process on the client does not provide a security attribute,\
    \ the\n   server must define a mechanism for labeling all requests from a\n  \
    \ client.  Assume that the server is using the same criteria used in\n   the first\
    \ example.  The server sees the request as coming from a\n   subnet that is a\
    \ Secret network.  The server determines that all\n   clients on that subnet will\
    \ have their requests labeled with Secret.\n   Since the directory on the server\
    \ is labeled Top Secret and Secret\n   does not dominate Top Secret, the server\
    \ would fail the request with\n   NFS4ERR_ACCESS.\n"
- title: 6.  Security Considerations
  contents:
  - '6.  Security Considerations

    '
- title: 6.1.  Trust Needed for a Community
  contents:
  - "6.1.  Trust Needed for a Community\n   Labeled NFS is a transport mechanism for\
    \ labels, a storage\n   requirement for labels, and a definition of how to interpret\
    \ labels.\n   It defines the responsibilities of the client and the server in\
    \ the\n   various permutations of being MAC-Functional.  It does not, however,\n\
    \   dictate in any manner whether assumptions can be made about other\n   entities\
    \ in the relationship.  For example, it does not define\n   whether a MAC-Functional\
    \ client can demand that a MAC-Aware server\n   only accept requests from other\
    \ MAC-Functional clients.  That is a\n   policy based on a MAC model, and this\
    \ document does not impose\n   policies on systems.\n   As the requirement is\
    \ a policy, it can be met with the use of a MAC\n   model.  Let L be an LFS that\
    \ implements the Limited Server mode,\n   i.e., a MAC-Aware server connected to\
    \ MAC-Functional clients.  Then\n   a new LFS, L', can be created that has the\
    \ additional policy that\n   the MAC-Aware server MUST NOT accept any requests\
    \ from a\n   non-MAC-Functional client.\n"
- title: 6.2.  Guest Mode
  contents:
  - "6.2.  Guest Mode\n   When either the client or server is operating in Guest Mode,\
    \ it is\n   important to realize that one side is not enforcing MAC protections.\n\
    \   Alternate methods are being used to handle the lack of MAC support,\n   and\
    \ care should be taken to identify and mitigate threats from\n   possible tampering\
    \ outside of these methods.\n"
- title: 6.3.  MAC-Functional Client Configuration
  contents:
  - "6.3.  MAC-Functional Client Configuration\n   We defined a MAC model as an access\
    \ control decision made on a system\n   in which normal users do not have the\
    \ ability to override policies\n   (see Section 1).  If the process labels are\
    \ created solely on the\n   client, then if a malicious user has sufficient access\
    \ on that\n   client, the Labeled NFS model is compromised.  Note that this is\
    \ no\n   different from:\n   o  current implementations in which the server uses\
    \ policies to\n      effectively determine the object label for requests from\
    \ the\n      client, or\n   o  local decisions made on the client by the MAC security\
    \ system.\n   Either the server must explicitly trust the client (as in [SENFSv3])\n\
    \   or the MAC model should enforce that users cannot override policies,\n   perhaps\
    \ via an externally managed source.\n   Once the labels leave the client, they\
    \ can be protected by the\n   transport mechanism as described in Section 3.2.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [DTOS]     Smalley, S., \"The Distributed Trusted\
    \ Operating System\n              (DTOS) Home Page\", December 2000, <http://www.cs.utah.edu/\n\
    \              flux/fluke/html/dtos/HTML/dtos.html>.\n   [NFSv4_2]  Haynes, T.,\
    \ \"NFS Version 4 Minor Version 2\", Work in\n              Progress, February\
    \ 2014.\n   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\
    \ RFC\n              4949, August 2007.\n   [RH_MLS]   \"Multi-Level Security\
    \ (MLS)\", \"Deployment, configuration\n              and administration of Red\
    \ Hat Enterprise Linux 5, Edition\n              10\", Section 49.6, 2014, <http://docs.redhat.com/docs/\n\
    \              en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/\n     \
    \         sec-mls-ov.html>.\n   [RPC_SEC]  Adamson, W. and N. Williams, \"Remote\
    \ Procedure Call (RPC)\n              Security Version 3\", Work in Progress,\
    \ February 2014.\n   [SENFSv3]  Carter, J., \"Implementing SELinux Support for\
    \ NFS\",\n              <http://www.nsa.gov/research/_files/selinux/papers/\n\
    \              nfsv3.pdf>.\n   [SYSV]     AT&T, \"System V Interface Definition\
    \ (SVID)\", Third\n              Edition, Addison-Wesley, Reading, MA, 1989.\n"
- title: Appendix A.  Acknowledgments
  contents:
  - "Appendix A.  Acknowledgments\n   David Quigley was the early energy in motivating\
    \ the entire Labeled\n   NFS effort.\n   James Morris, Jarrett Lu, and Stephen\
    \ Smalley all were key\n   contributors to both early versions of this document\
    \ and to many\n   conference calls.\n   Kathleen Moriarty provided use cases for\
    \ earlier versions of the\n   document.\n   Dan Walsh provided use cases for Secure\
    \ Virtualization, Sandboxing,\n   and NFS homedir labeling to handle process separation.\n\
    \   Trond Myklebust provided use cases for secure diskless NFS clients.\n   Both\
    \ Nico Williams and Bryce Nordgren challenged assumptions during\n   the review\
    \ processes.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Thomas Haynes\n   NetApp\n   495 East Java Dr.\n   Sunnyvale,\
    \ CA  94089\n   USA\n   Phone: +1 408 215 1519\n   EMail: tdh@excfb.com\n"
