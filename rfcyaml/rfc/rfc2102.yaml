- title: __initial_text__
  contents:
  - '  Multicast Support for Nimrod :  Requirements and Solution Approaches

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   Nimrod does not specify a particular solution for multicasting.\n\
    \   Rather, Nimrod may use any of a number of emerging multicast\n   techniques.\
    \  We identify the requirements that Nimrod has of a\n   solution for multicast\
    \ support.  We compare existing approaches for\n   multicasting within an internetwork\
    \ and discuss their advantages and\n   disadvantages.  Finally, as an example,\
    \ we outline the mechanisms to\n   support multicast in Nimrod using the scheme\
    \ currently being\n   developed within the IETF - namely, the Protocol Indpendent\
    \ Multicast\n   (PIM) protocol.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1  Introduction.................................................\
    \  2\n   2  Multicast vs Unicast.........................................  3\n\
    \   3  Goals and Requirements.......................................  4\n   4\
    \  Approaches...................................................  6\n   5  A Multicasting\
    \ Scheme based on PIM........................... 10\n      5.1 Overview ................................................\
    \ 10\n      5.2 Joining and Leaving a Tree .............................. 12\n\
    \          5.2.1 An Example ........................................ 15\n    \
    \  5.3 Establishing a Shared Tree .............................. 16\n      5.4\
    \ Switching to a Source-Rooted Shortest Path Tree.......... 18\n      5.5 Miscellaneous\
    \ Issues..................................... 20\n   6  Security Considerations......................................\
    \ 21\n   7  Summary...................................................... 21\n\
    \   8  References................................................... 22\n   9\
    \  Acknowledgements............................................. 23\n   10 Author's\
    \ Address............................................. 23\n"
- title: 1  Introduction
  contents:
  - "1  Introduction\n   The nature of emerging applications such as videoconferencing,\
    \ remote\n   classroom, etc.  makes the support for multicasting essential for\
    \ any\n   future routing architecture.  Multicasting is performed by using a\n\
    \   multicast delivery tree whose leaves are the multicast destinations.\n   Nimrod\
    \ does not propose a solution for the multicasting problem.\n   There are two\
    \ chief reasons for this.  First, multicasting is a non-\n   trivial problem whose\
    \ requirements are still not well understood.\n   Second, a number of groups (for\
    \ instance the IDMR working group of\n   the IETF) are studying the problem by\
    \ itself and it is not our\n   intention to duplicate those efforts.\n   This\
    \ attitude towards multicasting is consistent with Nimrod's\n   general philosophy\
    \ of flexibility, adaptability and incremental\n   change.\n   While a multicasting\
    \ solution per se is not part of the \"core\" Nimrod\n   architecture, Nimrod\
    \ does require that the solution have certain\n   characteristics.  It is the\
    \ purpose of this document to discuss some\n   of these requirements and evaluate\
    \ approaches towards meeting them.\n   This document is organized as follows.\
    \  In section 2 we discuss why\n   multicasting is treated a little differently\
    \ than unicast despite the\n   fact that the former is essentially a generalization\
    \ of the latter.\n   Following that, in section 4 we discuss current approaches\
    \ toward\n   multicasting .  In section 5, we give an example of how Nimrod\n\
    \   multicasting may be done using PIM [DEF+94a].  For readers who do not\n  \
    \ have the time to go through the entire document, a summary is given\n   at the\
    \ end.\n   This document uses many terms and concepts from the Nimrod\n   Architecture\
    \ document [CCS96] and some terms and concepts (in section\n   5) from the Nimrod\
    \ Functionality document [RS96].  Much of the\n   discussion assumes that you\
    \ have read at least the Nimrod\n   Architecture document [CCS96].\n"
- title: 2  Multicast vs Unicast
  contents:
  - "2  Multicast vs Unicast\n   We begin by looking at the similarities and differences\
    \ between\n   unicast routing and multicast routing.  Both unicast and multicast\n\
    \   routing require two phases - route generation and packet forwarding.\n   In\
    \ the case of unicast routing, Nimrod specifies modes of packet\n   forwarding;\
    \ route generation itself is not specified but left to the\n   particular routing\
    \ agent.  For multicasting, Nimrod leaves both route\n   generation and packet\
    \ forwarding mechanisms unspecified.  To explain\n   why, we first point out three\
    \ aspects that make multicasting quite\n   different from unicasting :\n"
- title: o Groups and group dynamism.  In multicasting, the destinations are part
  contents:
  - "o Groups and group dynamism.  In multicasting, the destinations are part\n  of\
    \ a group, whose membership is dynamic.  This brings up the following\n  issues\
    \ :\n  -  An association between the multicast group and the EIDs and\n     locators\
    \ of the members comprising that group.  This is especially\n     relevant in\
    \ the case of sender initiated multicasting and policy\n     support.\n  -  A\
    \ mechanism to accommodate new group members in the delivery in\n     response\
    \ to addition of members, and a mechanism to \"prune\" the\n     delivery in response\
    \ to departures.\n"
- title: o State creation.  Most solutions to multicasting can essentially be
  contents:
  - "o State creation.  Most solutions to multicasting can essentially be\n  viewed\
    \ as creating state in routers for multicast packet forwarding.\n  Based on who\
    \ creates the state, multicasting solutions differ.  In\n  multicasting, we have\
    \ several options for this - e.g., the sender, the\n  receivers or the intermediate\
    \ routers.\n"
- title: o Route generation.  Even more so than in unicast routing, one can choose
  contents:
  - "o Route generation.  Even more so than in unicast routing, one can choose\n \
    \ from a rich spectrum of heuristics with different tradeoffs between a\n  number\
    \ of parameters (such as cost and delay, algorithmic time\n  complexity and optimality\
    \ etc.).  For instance, some heuristics produce\n  a low-cost tree with high end-to-end\
    \ delay and some produce trees that\n  give the shortest path to each destination\
    \ but with a higher cost.\n  Heuristics for multicasting are a significant research\
    \ area today, and\n  we expect advances to result in sophisticated heuristics\
    \ in the near\n  future.\n   Noting that there are various possible combinations\
    \ of route\n   generation, group dynamism handling and state creation for a solution\n\
    \   and that each solution conceivably has applications for which it is\n   the\
    \ most suitable, we do not specify one particular approach to\n   multicasting\
    \ in Nimrod.  Every implementation of Nimrod is free to\n   use its own multicasting\
    \ technique, as long as it meets the goals and\n   requirements of Nimrod.  However,\
    \ for interoperability, it is\n   necessary that certain things are agreed upon\
    \ - for instance, the\n   structure of the forwarding information database that\
    \ they create (we\n   discuss this in more detail in section 4).\n   Thus, we\
    \ do not discuss the details of any multicast solution here,\n   only its requirements\
    \ in the context of Nimrod.  Specifically, we\n   structure the discussion in\
    \ the remainder of this document on the\n   following two themes :\n  o What are\
    \ the goals that we want to meet in providing multicasting in\n    Nimrod, and\
    \ what specific requirements do these goals imply for the\n    multicast solution?\n\
    \  o What are some of the approaches to multicasting being discussed\n    currently,\
    \ and how relevant are each of these approaches to Nimrod?\n"
- title: 3  Goals and Requirements
  contents:
  - "3  Goals and Requirements\n   The chief goals of Nimrod multicasting and their\
    \ implications on\n   solution requirements are as follows:\n"
- title: 1. Scalability.  Nimrod multicasting must scale in terms of the size of
  contents:
  - "1. Scalability.  Nimrod multicasting must scale in terms of the size of\n   the\
    \ internetwork, the number of groups supported and the number of\n   members per\
    \ group.  It must also support group dynamism efficiently.\n   This has the following\
    \ implications for the solution:\n   o Routers not on the direct path to the multicast\
    \ destinations should\n     not be involved in state management.  In a network\
    \ with a large\n     number of routers, a solution that does involve such routers\
    \ is\n     unlikely to scale.\n   o It is likely that there will be a number of\
    \ applications that have\n     a few members per group (e.g., medical imaging)\
    \ and a number of\n     applications that have a large number of members per group\
    \ (e.g.,\n     news distribution).  Nimrod multicasting should scale for both\n\
    \     these situations.  If no single mechanism adequately scales for\n     both\
    \ sparse and dense group memberships simultaneously, a\n     combination of mechanisms\
    \ should be considered.\n   o In the face of group membership change, there must\
    \ be a facility\n     for incremental addition or deletion of \"branches\" in\
    \ the\n     multicast tree.  Reconstructing the tree from scratch is not likely\n\
    \     to scale.\n   o It is likely that we will have some well-known groups (i.e.,\
    \ groups\n     which are more or less permanent in existence) and some ephemeral\n\
    \     groups.  The dynamics of group membership are likely to be\n     different\
    \ for each class of groups, and the solution should take\n     that into account\
    \ as appropriate.\n"
- title: 2. Policy support.  This includes both quality of service (QOS) as
  contents:
  - "2. Policy support.  This includes both quality of service (QOS) as\n   well as\
    \ access restrictions, although currently, demand is probably\n   higher for QOS.\
    \ In particular, every path from a source to each\n   destination in the multicast\
    \ group should satisfy the requested\n   quality of service and conform to the\
    \ access restrictions.  The\n   implications for the multicasting solution are\
    \ :\n  o It is likely that many multicasting applications will be cost\n    conscious\
    \ in addition to having strict quality of service bounds\n    (such as delay and\
    \ jitter).  Balancing these will necessitate\n    dealing with some new parameters\
    \ - e.g., the tree cost (sum of the\n    \"cost\" of each link), the tree delay\
    \ (maximum, mean and variance\n    in end-to-end delay) etc.\n  o In order to\
    \ support policy-based routing, we need to know where the\n    destinations are\
    \ (so that we can decide what route we can take to\n    them).  In such a case,\
    \ a mechanism that provides an association\n    between a group id and a set of\
    \ destination locators is probably\n    required.\n  o Some policy constraints\
    \ are likely to be destination specific.  For\n    instance, a domain might refuse\
    \ transit service to traffic going to\n    certain destination domains.  This\
    \ presents certain unique problems\n    - in particular, for a single group, multiple\
    \ trees may need to be\n    built, each tree \"servicing\" disjoint partitions\
    \ of the multicast\n    destinations.\n"
- title: 3. Resource sharing.  Multicasting typically goes hand in hand with large
  contents:
  - "3. Resource sharing.  Multicasting typically goes hand in hand with large\n \
    \  traffic volume or applications with a high demand for resources.\n   These,\
    \ in turn, imply efficient resource management and sharing if\n   possible.  Therefore,\
    \ it is important that we place an emphasis on\n   interaction with resource reservation.\
    \  For instance, Nimrod must be\n   able to provide information on which tree\
    \ resources are shareable and\n   which are not so that resource reservation may\
    \ use it while allocating\n   resources to flows.\n"
- title: 4. Interoperability.  There are two issues in this context.  First, the
  contents:
  - "4. Interoperability.  There are two issues in this context.  First, the\n   solution\
    \ must be independent of mechanisms that provide the solution\n   with information\
    \ it needs.  For instance, many multicast solutions\n   (e.g., PIM) make use of\
    \ information supplied by unicast routing\n   protocols.  The multicast solution\
    \ must not be dependent on which\n   unicast protocol is used.\n   Second, a multicast\
    \ solution must interoperate with other multicast\n   solutions in the construction\
    \ of a delivery tree.  This implies some\n   kind of \"agreement\" at some \"\
    level\".  For instance, the agreement\n   could be that everybody use the same\
    \ structure for storing forwarding\n   information in the routers.  Since the\
    \ delivery tree is defined by the\n   nature of forwarding information in the\
    \ routers and not by the\n   particular mechanism used to create that information,\
    \ multiple\n   implementations can coexist.\n"
- title: 4  Approaches
  contents:
  - "4  Approaches\n   The approaches to multicasting currently in operation and those\
    \ being\n   considered by the IETF include the following :\n"
- title: 1. Distance vector multicast routing protocol (DVMRP)[DC90].  This
  contents:
  - "1. Distance vector multicast routing protocol (DVMRP)[DC90].  This\n   approach\
    \ is based upon distance-vector routing information distribution\n   and hop-by-hop\
    \ forwarding.  It uses Reverse Path Forwarding (RPF)[DM78]\n   - a distributed\
    \ algorithm for constructing an internetwork broadcast\n   tree.  DVMRP uses a\
    \ modified RPF algorithm, essentially a truncated\n   broadcast tree, to build\
    \ a reverse shortest path sender-based multicast\n   delivery tree.  A reverse\
    \ shortest path from s to d is a path that uses\n   the same intermediate nodes\
    \ as those in the shortest path from d to\n   s (If the paths are symmetric (i.e.,\
    \ cost the same) in either\n   direction, the reverse shortest path is same as\
    \ the shortest path.)\n   An implementation of RPF exists in the current Internet\
    \ in what\n   is commonly referred to as the MBONE. An improvement to this is\
    \ in the\n   process of being deployed.  It incorporates \"prune\" messages to\n\
    \   truncate further the routers not on the path to the destinations and\n   \"\
    graft\" messages to undo this truncation, if later necessary.\n   The main advantage\
    \ of this scheme is that it is simple.  The major\n   handicap is scalability.\
    \  Two issues have been raised in this\n   context[BFC93].  First, if S is the\
    \ number of active sources and G\n   the number of groups, then the state overhead\
    \ is O(GS) and might be\n   unacceptable when resources are limited.  Second,\
    \ routers not on a\n   multicast tree are involved (in terms of sending/tracking\
    \ prune and\n   graft messages) even though they might not be interested in the\n\
    \   particular source-group pair.  The performance of this scheme is\n   expected\
    \ to be relatively poor for large networks with sparsely\n   distributed group\
    \ membership.  Furthermore, no support for policies\n   or QOS is provided.\n"
- title: 2. Core Based Trees (CBT)[BFC93].  This scheme uses a single tree shared
  contents:
  - "2. Core Based Trees (CBT)[BFC93].  This scheme uses a single tree shared\n  \
    \ by all sources per group.  This tree has a single router as the core\n   (with\
    \ additional routers for robustness) from which branches emanate.\n   The chief\
    \ distinguishing characteristic of CBT is that it is receiver\n   initiated, i.e.,\
    \ receivers wishing to join a multicast group find the\n   tree (or its core)\
    \ and attach themselves to it, without any\n   participation from the sources.\n\
    \   The chief motivation behind this scheme is the reduction of the state\n  \
    \ overhead, to O(G), in comparison to DVMRP and PIM(described below).\n   Also,\
    \ only routers in the path between the core and the potential\n   members are\
    \ involved in the process.  Core-based tree formation and\n   packet flow are\
    \ decoupled from underlying unicast routing.\n   The main disadvantage is that\
    \ packets no longer traverse the shortest\n   path from the source to their destinations.\
    \  The performance in\n   general depends on judicious placement of cores and\
    \ coordination\n   between them.  Traffic concentration on links incident to the\
    \ core is\n   another problem.  There is also a dependence on network entities\
    \ (in\n   other administrative domains, for instance) for resource reservation\n\
    \   and policy routing.\n"
- title: 3. Protocol Independent Multicasting (PIM)[DEFJ93].  Yet another approach
  contents:
  - "3. Protocol Independent Multicasting (PIM)[DEFJ93].  Yet another approach\n \
    \  based on the receiver initiated philosophy, this is designed to reap\n   the\
    \ advantages of DVMRP and CBT. Using a \"rendezvous point\", a\n   concept similar\
    \ to the core discussed above, it allows for the\n   simultaneous existence of\
    \ shared and source-specific multicast trees.\n   In the steady state, data can\
    \ be delivered over the reverse shortest\n   path from the sender to the receiver\
    \ (for better end-to-end delay) or\n   over the shared tree.\n   Using two modes\
    \ of operation, sparse and dense, this provides\n   improved performance, both\
    \ when the group membership in an\n   internetwork is sparse and when it is dense.\
    \  It is however, a\n   complex protocol.  A limitation of PIM is that the shortest\
    \ paths are\n   based on the reverse metrics and therefore truly \"shortest\"\
    \ only when\n   the links are symmetric.\n"
- title: 4. Multicast Open Shortest Path First (MOSPF)[Moy92].  Unlike the
  contents:
  - "4. Multicast Open Shortest Path First (MOSPF)[Moy92].  Unlike the\n   abovementioned\
    \ approaches, this is based on link-state routing\n   information distribution.\
    \  The packet forwarding mechanism is\n   hop-by-hop.  Since every router has\
    \ complete topology information,\n   every router computes the shortest path multicast\
    \ tree from any\n   source to any group using Dijkstra's algorithm.  If the router\n\
    \   doing the computation falls within the tree computed, it can\n   determine\
    \ which links it must forward copies onto.\n   MOSPF inherits advantages of OSPF\
    \ and link-state distribution, namely\n   localized route computation (and easy\
    \ verification of loop-freedom),\n   fast convergence to link-state changes etc.\
    \ However, group membership\n   information is sent throughout the network, including\
    \ links that are\n   not in the direct path to the multicast destinations.  Thus,\
    \ like\n   DVMRP, this is most suitable for small internetworks, that is, as an\n\
    \   intra-domain routing mechanism.\n"
- title: 5. Inter-Domain Policy Routing (IDPR)[Ste].  This approach uses
  contents:
  - "5. Inter-Domain Policy Routing (IDPR)[Ste].  This approach uses\n   link-state\
    \ routing information distribution like MOSPF, but uses\n   source-specified packet\
    \ forwarding.  Using the link-state\n   database, the source generates a policy\
    \ multicast route to the\n   destinations.  Using this, the IDPR path-setup procedure\
    \ sets up\n   state in intermediate entities for packet duplication and\n   forwarding.\
    \ The state contains information about the next-hop\n   entities for the multicast\
    \ flow.  When a data packet arrives,\n   it is forwarded to each next hop entity\
    \ obtained from the state.\n   Among the advantages of this approach are its ability\
    \ to support\n   policy based multicast routing with ease and independence\n \
    \  (flexibility) in the choice of multicasting algorithm used at the\n   source.\
    \  IDPR also allows resource sharing over multiple multicast\n   trees.  The major\
    \ disadvantage is that it makes it relatively more\n   difficult to handle group\
    \ membership changes (additions and\n   deletions) since such changes must be\
    \ first communicated to the\n   source of the tree which will then add branches\
    \ appropriately.\n   We now discuss the applicability of these approaches to Nimrod.\n\
    \   Common to all of the approaches described is the fact that we need to\n  \
    \ set up state in the intermediate routers for multicast packet\n   forwarding.\
    \  The approaches differ mainly on who initiates the state\n   creation - the\
    \ sender (e.g., IDPR, PIM), the receiver (e.g., CBT,\n   PIM) or the routers themselves\
    \ create state without intitiation by\n   the sender or receivers (e.g., DVMRP,\
    \ MOSPF).\n   Nimrod should be able to accommodate both sender initiated as well\
    \ as\n   receiver initiated state creation for multicasting.  In the remainder\n\
    \   of this section, we discuss the pros and cons of these approaches for\n  \
    \ Nimrod.\n   Nimrod uses link-state routing information distribution (topology\n\
    \   maps) and has four modes of packet forwarding - flow mode,\n   Connectivity\
    \ Specification Chain (CSC) mode, Connectivity\n   Specification Sequence (CSS)\
    \ mode and datagram mode [CCS96].\n   An approach similar to that used in IDPR\
    \ is viable for multicasting\n   using the flow mode.  The source can set up state\
    \ in intermediate\n   routers which can then appropriately duplicate packets.\
    \  For the CSC,\n   BTES and datagram modes, an approach similar to the one used\
    \ in MOSPF\n   is applicable.  In these situations, the advantages and disadvantages\n\
    \   of these approaches in the context of Nimrod is similar to the\n   advantages\
    \ and disadvantages of IDPR and MOSPF respectively.\n   Sender based trees can\
    \ be set up using an approach similar to IDPR\n   and generalizing it to an \"\
    n\" level hierarchy.  A significant\n   advantage of this approach is policy-based\
    \ routing.  The source knows\n   about the policies of nodes that care to advertise\
    \ them and can\n   choose a route the way it wants (i.e., not depend upon other\
    \ entities\n   to choose the route, as in some schemes mentioned above).  Another\n\
    \   advantage is that each source can use the multicast route generation\n   algorithm\
    \ and packet forwarding scheme that best suits it, instead of\n   being forced\
    \ to use whatever is implemented elsewhere in the network.\n   Further, this approach\
    \ allows for incrementally deploying new\n   multicast tree generation algorithms\
    \ as research in that area\n   progresses.\n   CBT-like methods may be used to\
    \ set up receiver initiated trees.\n   Nimrod provides link-state maps for generating\
    \ routes and a CBT-like\n   method is compatible with this.  For instance, a receiver\
    \ wishing to\n   join a group may generate a (policy) route to the core for that\
    \ group\n   using its link-state map and attach itself to the tree.\n   A disadvantage\
    \ of sender based methods in general seems to be the\n   support of group dynamism.\
    \  Specifically, if there is a change in the\n   membership of the group, the\
    \ particular database which contains the\n   group-destination mapping must be\
    \ updated.  In comparison, receiver\n   oriented approaches seem to be able to\
    \ accommodate group dynamism\n   more naturally.\n   Nimrod does not preclude\
    \ the simultaneous existence of multiple\n   approaches to multicasting and the\
    \ possibility of switching from one\n   to the other depending on the dynamics\
    \ of group distributions.\n   Interoperability is an issue - that is, the question\
    \ of whether or\n   not different implementations of Nimrod can participate in\
    \ the same\n   tree.  However, as long as there is agreement in the structure\
    \ of the\n   state created (i.e., the states can be interpreted uniformly for\n\
    \   packet forwarding), this should not be a problem.  For instance, a\n   receiver\
    \ wishing to join a sender created tree might set up state on\n   a path between\
    \ itself and a router on the tree with the sender itself\n   being unaware of\
    \ it.  Packets entering the router would now be\n   additionally forwarded along\
    \ this new \"branch\" to the new receiver.\n   In conclusion, the architecture\
    \ of Nimrod can accommodate diverse\n   approaches to multicasting.  Each approach\
    \ has its disadvantages with\n   respect to the requirements mentioned in the\
    \ previous section.  The\n   architecture does not demand that one particular\
    \ solution be used,\n   and indeed, we expect that a combination of approaches\
    \ will be\n   employed and engineered in a manner most appropriate to the\n  \
    \ requirements of the particular application or subscriber.\n"
- title: 5  A Multicasting Scheme based on PIM
  contents:
  - "5  A Multicasting Scheme based on PIM\n   The Inter-Domain Multicast Routing\
    \ (IDMR) working group of the IETF\n   has developed a specification for a new\
    \ multicast scheme, namely,\n   Protocol Independent Multicasting (PIM) for use\
    \ in the Internet\n   [DEF+94a, DEF+94b].  In this section, we decribe how the\
    \ schemes\n   mentioned therein may be implemented using the facilities provided\
    \ by\n   Nimrod.\n   We note that the path setup facility provided in Nimrod makes\
    \ it very\n   conducive to PIM-style multicasting; despite the length of the\n\
    \   description given here, we assure the reader that it is quite simple\n   to\
    \ implement PIM style multicasting in Nimrod.\n   Before reading this section,\
    \ we recommend that the reader acquire\n   some familiarity with PIM (see [DEF+94a,\
    \ DEF+94b]).\n"
- title: 5.1  Overview
  contents:
  - "5.1  Overview\n   The PIM architecture maintains the traditional IP multicast\
    \ service\n   model of receiver-initiated membership and is independent of any\n\
    \   specific unicast routing protocol (hence the name).\n   A significant aspect\
    \ of PIM is that it provides mechanisms for\n   establishing two kinds of trees\
    \ - a shared tree, which is intended\n   for low \"cost\" multicasting and a source-based\
    \ tree, intended for low\n   delay multicasting.\n   A shared tree is rooted at\
    \ a rendezvous point (RP), which is\n   typically a prespecified router for the\
    \ multicast group in question.\n   In order to establish a shared tree, a designated\
    \ router (DR) for a\n   host wishing to join a group G initiates a flow setup\
    \ from the RP for\n   G to the DR. A source S wishing to send to a group G initiates\
    \ a flow\n   setup between S and the RP for group G. At the conclusion of these\n\
    \   flow setups, packets can be forwarded from S to H through the RP. For\n  \
    \ details on the protocol used to implement this flow setup please\n   refer to\
    \ [DEF+94b].\n   After the shared tree has been setup, a recipient for group G\
    \ has the\n   option of switching to a source-based shortest path tree.  In such\
    \ a\n   tree, packets are delivered from the source to each recipient along\n\
    \   the shortest path.  To establish a source-based shortest path tree,\n   the\
    \ DR for H looks at the source S of the packets it is receiving via\n   the shared\
    \ tree and establishes a flow between S and the DR. The flow\n   is established\
    \ along the shortest path from the DR to S (Thus,\n   strictly speaking, it is\
    \ the reverse shortest path that is being\n   used.) Subsequently, packets can\
    \ be forwarded from S to H using this\n   shortest path and thereby bypassing\
    \ the RP. For details on the\n   protocol used to implement source-based trees\
    \ in PIM please refer to\n   [DEF+94b].\n   When a host wishes to leave a multicast\
    \ group, its designated router\n   sends a prune message towards the source (for\
    \ source-based trees) or\n   towards the RP (for shared trees).  For details on\
    \ this and other\n   features of PIM please refer to [DEF+94b].\n   In Nimrod,\
    \ PIM is implemented as follows (we refer to PIM based\n   multicast as Nimpim).\
    \  In order to join a shared tree, an endpoint\n   (or an agent acting on behalf\
    \ of the endpoint) wishing to join a\n   group G queries the association database\
    \ for the EID and locator of\n   the RP for G (for well-known groups the association\
    \ may be\n   configured).  It is required that such an association be maintained\n\
    \   for every multicast group G. The endpoint gets a route for the RP and\n  \
    \ initiates a multicast flow setup to the RP (a multicast flow setup is\n   similar\
    \ to an unicast flow setup described in [CCS96] except for one\n   feature - when\
    \ a multicast flow setup request reaches a node that\n   already has that flow\
    \ present, the request is not forwarded further.\n   The new flow gets \"spliced\"\
    \ in as a new branch of the existing\n   multicast tree).  Similarly, the source\
    \ establishes a flow to the RP.\n   The RP creates state to associate these two\
    \ flows and now packets can\n   be forwarded to the endpoints from the source.\
    \  Note that each flow\n   setup may be \"hierarchical\" and involve many subflows.\
    \  All this,\n   however, is transparent to Nimpim.  For details on management\
    \ of\n   hierarchical flows please refer to [CCS96].\n   To create the source-based\
    \ tree, the representative for a recipient\n   node N obtains the EID or locator\
    \ of the source from the data packets\n   and initiates a multicast flow setup\
    \ to the source.  The route agent\n   for the node N uses its map in order to\
    \ calculate the shortest path\n   from the source to N. The flow request is sent\
    \ along the reverse of\n   this path.  We note that the \"shortness\" of the path\
    \ is constrained\n   by the amount of routing information available locally. \
    \ However,\n   since the map is available locally, one can find the actual shortest\n\
    \   path from the source to N and not use the shortest path from N to S.\n   Thus,\
    \ with Nimrod one can actually surmount a shortcoming of PIM with\n   relative\
    \ ease.\n   We now discuss some more details of Nimpim.  We start with a\n   description\
    \ of multicast flow setup.  This is the \"basic\"\n   functionality required to\
    \ implement multicasting.  Having this\n   \"building-block\" spelt out, we use\
    \ this to specify the establishment\n   of the shared tree (in section 5.3) and\
    \ the establishment of a\n   source-based tree (in section 5.4).\n   We only discuss\
    \ sparse-mode multicasting, as described in [DEF+94a]\n   here.  Further, to simplify\
    \ the discussion, we assume a single\n   Rendezvous Point per group.  Finally,\
    \ we \"address\" all entities in\n   terms of their EIDs alone for reasons of\
    \ conciseness - the locators\n   could be used in conjuction to reduce the overhead\
    \ of database\n   lookups.\n"
- title: 5.2  Joining and Leaving a Tree
  contents:
  - "5.2  Joining and Leaving a Tree\n   Nimpim uses two control packets in order\
    \ to setup a flow - the Nimrod\n   Multicast Flow-Request packet (NMFReq) and\
    \ the Nimrod Multicast\n   Flow-Reply packet (NMFRep).\n   The NMFReq packet is\
    \ a control packet identified by a prespecified\n   \"payload type\".  The protocol-specific\
    \ part of this packet includes\n   the following fields (except for the Code field,\
    \ these fields are\n   present in the Unicast Flow-Request packet too) :\n   1.\
    \ S-EID : The EID of the initiator of the flow.\n   2. T-EID : The EID of the\
    \ target of the flow.\n   3. Flow-id :  A label denoting the flow.\n   4. Direction\
    \ :  The direction of the flow - whether from the initiator\n      to the target\
    \ (FORW) or from the target to the initiator (REVERSE)\n      or both (BOTH).\n\
    \   5. Code :  Denotes whether the packet is for joining a flow\n      (NMFReq-Join)\
    \ for leaving a flow (NMFReq-Prune).\n   6. Source Route :  A sequence of node\
    \ locators through which the packet\n      must travel.\n   The processing of\
    \ the NMFReq by a forwarding agent at node N is\n   similar to that of the unicast\
    \ flow request (see [CCS96]), except for\n   the fact that now we provide the\
    \ ability for the new flow to \"splice\"\n   onto an existing delivery tree or\
    \ \"un-splice\" from an existing\n   delivery tree.  Specifically,\n   o If the\
    \ Code is NMFReq-Join then the algorithm executed by the\n     forwarding agent\
    \ for node N is shown in Figure 1.\n   o If the Code is NMFReq-Prune then the\
    \ algorithm is executed by the\n     forwarding agent at node N is shown in Figure\
    \ 2.\n   The NMFRep packet is used to accept or reject an NMFReq-Join or\n   NMFReq-Prune.\
    \  The packet format is the same as that for unicast flow\n   request.  However,\
    \ an NMFRep packet is generated now by the first\n   node N that grafts the new\
    \ flow to the existing tree.  This may be\n   different from the target of the\
    \ NMFReq.\n   It is required that a leaf router keep track of all hosts currently\n\
    \   joined to the group and send a prune message only if there is no host\n  \
    \ in the local network for the group.\n   The NMFReq - NMFRep exchanges constitute\
    \ a procedure for joining a\n   multicast delivery tree (when the Code is Join)\
    \ and for leaving a\n   multicast delivery tree (when the Code is Prune).  We\
    \ term these\n   procedures Tree-Join and Tree-Leave respectively; we shall be\
    \ using\n   these procedures as \"building-blocks\" in the construction of shared\n\
    \   trees (section 5.3) and of source-based trees (section 5.4).\n"
- title: begin
  contents:
  - 'begin

    '
- title: if the flow-id F in NMFReq-Join is in flow-list then
  contents:
  - "if the flow-id F in NMFReq-Join is in flow-list then\n   if T-EID in NMFReq-Join\
    \ = target in flow state for F then\n      if Direction in NMFReq-Join is REVERSE\
    \ or BOTH then\n         Add the node preceding N in source route to child list\
    \ for F\n      else\n         discard packet\n   else\n      discard packet\n"
- title: else
  contents:
  - "else\n   begin\n     install state for F in N, i.e.,\n        assign parent(F)\
    \ = node succeeding N in source route\n        assign child(F)  = node preceeding\
    \ N in source route\n        assign target(F) = T-EID in NMFReq-Join\n     forward\
    \ NMFReq-Join to parent(F)\n   end\n"
- title: end.
  contents:
  - 'end.

    '
- title: 'Figure 1:  Algorithm executed by a forwarding agent for node N when'
  contents:
  - 'Figure 1:  Algorithm executed by a forwarding agent for node N when

    '
- title: when it receives an NMFReq-Join.
  contents:
  - 'when it receives an NMFReq-Join.

    '
- title: begin
  contents:
  - "begin\n  if the flow-id F in NMFReq-Prune is in flow-list\n  then begin\n   \
    \    delete previous hop in source route from child list for F, if exists\n  \
    \     if child list for F is empty\n       then begin\n             delete the\
    \ flow-id and state associated with it\n             forward to next hop in source\
    \ route\n            end\n       else discard packet\n       end\n  else forward\
    \ to next hop in source-route\n"
- title: end.
  contents:
  - 'end.

    '
- title: 'Figure 2:  Algorithm executed by a forwarding agent for node N when it'
  contents:
  - 'Figure 2:  Algorithm executed by a forwarding agent for node N when it

    '
- title: receives an NMFReq-Prune.
  contents:
  - 'receives an NMFReq-Prune.

    '
- title: 5.2.1  An Example
  contents:
  - "5.2.1  An Example\n   An example of how a tree is joined is given here with the\
    \ help of\n   Figure 3.  In the figure, bold lines indicate an existing tree.\n\
    \   Representative R on behalf of host H joins the tree by sending an\n   NMFJoin-Req\
    \ towards a target T. When used in the shared tree mode,\n   the target is the\
    \ RP and when used in the source tree mode, it is the\n   source (root) of the\
    \ multicast tree.  Suppose that a host H wants to\n   join the multicast tree.\
    \  The following steps are executed :\n"
- title: Step 1.  A representative R of H queries the route agent for a route
  contents:
  - "Step 1.  A representative R of H queries the route agent for a route\n    from\
    \ T to R. It obtains the route T - C- B - A - R. It builds a\n    NMFJoin-Req\
    \ packet with source route as R, A, B, C, T and flow\n    as F forwards it to\
    \ A.\n"
- title: Step 2.  A looks for flow F in its installed flow database and
  contents:
  - "Step 2.  A looks for flow F in its installed flow database and\n    doesn't find\
    \ it.  It installs state for F (makes R a child and\n    B a parent in the multicast\
    \ tree) and sends the NMFJoin-Req packet\n    to B.\n"
- title: Step 3.  B looks for flow F in its installed flow database and finds it.
  contents:
  - "Step 3.  B looks for flow F in its installed flow database and finds it.\n  \
    \  It adds B to its child list and constructs an NMFJoin-Rep packet and\n    sends\
    \ it to A.\n"
- title: Step 4.  A forwards the packet to R and the tree joining is complete.
  contents:
  - "Step 4.  A forwards the packet to R and the tree joining is complete.\n    Branch\
    \ B-A-R is now added to the tree.\n"
- title: 5.3  Establishing a Shared Tree
  contents:
  - "5.3  Establishing a Shared Tree\n   There are two parts to establishing a shared\
    \ tree - the receiver-to-\n   RP communication wherein the receiver joins the\
    \ delivery tree rooted\n   at RP and the sender-to-RP communication wherein the\
    \ RP joins the\n   delivery tree rooted at the sender.\n                     \
    \                  T\n                                    +---+\n            \
    \                        |   |\\\n                                    +---+  \\\
    \n                                      /      \\\n                          \
    \           /         \\\n                                  C /            \\\
    \ X\n                                +---+           +---+\n                 \
    \               |   |           |   |\n                                +---+ \
    \          +---+\n                                     \\\n                  \
    \                     \\\n                                         \\\n      R\
    \    join-req           join-req     \\  B\n      +---+ - - - - ->  +---+ - -\
    \ - - -> +---+\n      |   |<------------|   |<-----------|   |\n      +---+  \
    \ join-rep  +---+   join-rep +---+\n        |                 A              \
    \   \\\n        |                                     \\\n        |          \
    \                             \\     Y\n       ( )                           \
    \             +---+\n         H                                        |   |\n\
    \                                                  +---+\n"
- title: 'Figure 3:  Illustration for the example describing joining an existing'
  contents:
  - 'Figure 3:  Illustration for the example describing joining an existing

    '
- title: multicast tree.
  contents:
  - "multicast tree.\n   Receiver-RP Communications:  When an endpoint wishes to join\
    \ a\n   multicast group G, the endpoint representative obtains the Rendezvous\n\
    \   Point EID for G.  We assume that the association database contains\n   such\
    \ a mapping.  For details on how the association database query is\n   implemented,\
    \ please refer [CCS96].\n   The representative also obtains the flow-id to be\
    \ used for the flow.\n   The flow-id is constructed as the tuple (RP-EID, G) or\
    \ an equivalent\n   thereof.  Note that the flow-id must be unique to the particular\n\
    \   multicast flow.  This is not the only method or perhaps even the best\n  \
    \ method for obtaining a flow id.  Alternate methods for obtaining the\n   flow-id\
    \ are discussed in section 5.5.\n   The representative then initiates a Tree-Join\
    \ procedure.\n   The NMFReq packet fields are as follows:\n     o S-EID : The\
    \ EID of the endpoint wishing to join.\n     o T-EID : The RP EID (obtained from\
    \ the Association Database).\n     o Flow-id : The flow-id for this group (obtained\
    \ as mentioned\n       above).\n     o Direction : REVERSE (from the RP to the\
    \ receiving endpoint).\n     o Code : Join.\n     o Source Route : Reverse of\
    \ the route obtained from the map agent\n       for a query \"from RP-EID to Receiver-EID\"\
    .\n   At the first node already containing this Flow-id or the RP, an\n   NMFRep\
    \ packet is generated.  The S-EID, T-EID, Direction and Flow-id\n   fields are\
    \ copied from the NMFReq packet and the Code is set to\n   Join-Accept or Join-Refuse\
    \ as the case may be.  The source route is\n   reversed from the NMFReq packet.\n\
    \   Sender-RP Communications: When an endpoint wishes to send to a\n   multicast\
    \ group G, the endpoint representative obtains the Rendezvous\n   Point EID for\
    \ G.  We assume that the association database contains\n   such a mapping.  For\
    \ details on how the association database query is\n   implemented, please refer\
    \ [CCS96].\n   The representative also obtains the flow-id to be used for the\
    \ flow.\n   The flow-id is constructed as the tuple (Sender-EID, G) or an\n  \
    \ equivalent thereof.  Note that the flow-id must be unique to the\n   particular\
    \ multicast flow.  This is not the only method or perhaps\n   even the best method\
    \ for obtaining a flow id.  Alternate methods for\n   obtaining the flow-id are\
    \ discussed in section 5.5.\n   The representative then sends a RP-Register Message\
    \ to the RP. This\n   register message is equivalent to the PIM-Register described\
    \ in\n   [DEF+94b].  The RP-Register message contains the group G and the\n  \
    \ flow-id (obtained as discussed above) and the sender EID.\n   The RP then initiates\
    \ a Tree-Join with the Sender EID as the target.\n   The NMFReq fields are as\
    \ follows :\n     o S-EID : RP-EID.\n     o T-EID : Sender EID (copied from RP-Register\
    \ Message).\n     o Flow-id :  The flow-id field from RP-Register Message.\n \
    \    o Code :  Join.\n     o Direction :  REVERSE.\n     o Source Route :  Reverse\
    \ of the route obtained from map agent\n       query \"from Sender-EID to RP-EID\"\
    .\n   The NMFRep fields are obvious.\n   Shared Tree Data Forwarding: Packets\
    \ sent from the source for group G\n   contain the Flow-id used by the sender(s)\
    \ and receiver(s) for setting\n   up the delivery tree.  The packets from the\
    \ sender are sent to the RP\n   where they are multicast, using the state created\
    \ for the flow, into\n   the delivery tree rooted at the RP to all of the receivers\
    \ that did a\n   Tree-Join.\n"
- title: 5.4  Switching to a Source-Rooted Shortest Path Tree
  contents:
  - "5.4  Switching to a Source-Rooted Shortest Path Tree\n   There are two parts\
    \ involved in switching to a Source-Rooted Shortest\n   Path Tree - the receiver-source\
    \ communications wherein the receiver\n   joins a multicast delivery tree rooted\
    \ at the source and the\n   receiver-RP communications wherein the receiver leaves\
    \ the shared\n   tree.\n   Receiver-Source Communications:  An endpoint E that\
    \ is receiving\n   packets through the shared tree from source S has the option\
    \ of\n   switching to a delivery tree rooted at the source such that packets\n\
    \   from S to E traverse the shortest path (using whatever metric).\n   The endpoint\
    \ representative of E obtains the flow-id to be used for\n   the flow.  The flow-id\
    \ is constructed equivalently to the tuple\n   (Source-EID, G).  Note that the\
    \ flow-id must be unique to the\n   particular multicast flow.  This is not the\
    \ only method or perhaps\n   even the best method for obtaining a flow id.  Alternate\
    \ methods for\n   obtaining the flow-id are discussed in section 5.5.\n   The\
    \ representative for E initiates a Tree-Join toward S with NMFReq\n   fields as\
    \ follows:\n   o S-EID : EID of the Endpoint E.\n   o T-EID : EID of the source.\n\
    \   o Flow-id :  Flow id for the multicast (obtained as mentioned above).\n  \
    \ o Code :  Join.\n   o Direction :  REVERSE.\n   o Source Route : To obtain the\
    \ route, the route agent is queried for\n     a shortest path route (based on\
    \ the chosen metric, typically, the\n     delay) from the source to the endpoint.\
    \  We note that the quality\n     of the route is constrained by the amount of\
    \ routing information\n     available, directly or indirectly, to the route agent.\
    \  The Source\n     Route is the reverse of the route thus obtained.\n   A comment\
    \ on the difference between the shortest-path trees obtained\n   using the RPF\
    \ tree as in [DEF+94b, DC90] and the trees that are be\n   obtained here.  When\
    \ using the RPF scheme, the packets from the\n   source S to the endpoint E follow\
    \ a path that is the shortest path\n   from E to S. This is the desired path if\
    \ and only if the path is\n   symmetric in either direction.  However, in the\
    \ mechanism described\n   here for Nimrod, the packets do follow the \"actual\"\
    \ shortest path\n   from S to E whether or not the path is symmetric.\n   The\
    \ NMFRep fields are obvious.\n   Receiver-RP Communications: After the receiver\
    \ has joined the\n   source-rooted tree, it can optionally disassociate itself\
    \ from the\n   shared tree.  This is done by initiating a Tree-Leave procedure.\n\
    \   The representative sends a NMFReq packet toward the RP with the\n   fields\
    \ as follows.\n   o S-EID : The EID of the endpoint wishing to leave the shared\
    \ tree.\n   o T-EID : The RP-EID.\n   o Flow-id :  The flow-id it used to join\
    \ the shared tree.\n   o Code :  Prune.\n   o Direction :  REVERSE.\n   o Source\
    \ Route :  Obtained as for the Tree-Join.\n   The prune packet is processed by\
    \ the intermediate forwarding agents\n   as mentioned in section 5.2.  When the\
    \ receiver gets back the NMFRep\n   packet, the receiver has left the shared tree.\n\
    \   Source Tree Data Forwarding: Packets from the source contain the\n   flow-id\
    \ that was used to join the source tree for a given multicast\n   group.  Forwarding\
    \ agents simply use the state created by the Tree-\n   Join procedure in order\
    \ to duplicate and forward packets toward the\n   receivers.\n"
- title: 5.5  Miscellaneous Issues
  contents:
  - "5.5  Miscellaneous Issues\n   Obtaining the Flow-Id: In the above scheme the\
    \ flow-id for a\n   particular multicast group G was obtained by combining the\
    \ RP-EID and\n   the group set-id (G-SID) (in case of shared tree) or by combining\
    \ the\n   Source-EID and the G-SID (in case of source-based tree).  A\n   disadvantage\
    \ of this approach is that the bit-length of EID/SID is\n   potentially high (more\
    \ than 64 bits) and thus the flow-id could be\n   very long.  While there do exist\
    \ bit-based data structures and search\n   algorithms (such as Patricia Trees)\
    \ that may be used for an efficient\n   implementation, it is worth considering\
    \ some other methods in lieu of\n   using the EID/SID combination.  We describe\
    \ some methods below :\n"
- title: 1. For shared trees, the flow-id for a particular group G may be stored
  contents:
  - "1. For shared trees, the flow-id for a particular group G may be stored\n   and\
    \ updated in the association database.  Since we have to use the\n   association\
    \ database anyway to obtain the RP-EID, these does not cause\n   much additional\
    \ burden.\n   However, this cannot be used efficiently for source-based trees\
    \ because\n   we need a flow-id for each combination of Source and Group.\n"
- title: 2. The flow-id for shared trees could be done as above.  When the sender
  contents:
  - "2. The flow-id for shared trees could be done as above.  When the sender\n  \
    \ does an RP-Register, it could send the RP the flow-id that it wishes to\n  \
    \ be used by receivers when they switch to a source-based tree.  This\n   could\
    \ be included in the RP-Register message.  The RP could then\n   multicast that\
    \ flow-id to all receivers in a special packet.  When the\n   receivers wish to\
    \ switch, they use that flow-id.\n   This needs the definition of the \"special\"\
    \ packet.\n"
- title: 3. The flow-id is handed out only by the source (for source-based trees)
  contents:
  - "3. The flow-id is handed out only by the source (for source-based trees)\n  \
    \ or the RP (for shared trees).  The receivers use a \"dummy\" flow-id in\n  \
    \ the NMFReq when doing a Tree-Join.  The correct flow-id to be used is\n   returned\
    \ in the NMFRep message generated by the forwarding agent where\n   the new branch\
    \ meets the existing tree.  Forwarding agents in the path\n   of the NMFRep packet\
    \ update the state information by rewriting the\n   dummy flow-id by the correct\
    \ flow-id contained in the NMFRep packet.\n   This requires the re-definition\
    \ of the NMFRep packet.  Note that now\n   there must be space for two flow-ids\
    \ in the NMFRep packet - one for the\n   \"dummy\" flow-id and the other for the\
    \ \"correct\" flow-id that must\n   replace the dummy flow-id.\n   We claim that\
    \ each of the above schemes achieves synchronization in\n   the flow-id in various\
    \ parts of the internetwork and that each flow-\n   id is unique to the multicast\
    \ delivery tree.  A formal proof of these\n   claims is beyond the scope of this\
    \ document.\n   Dense Mode Multicast:  The PIM architecture [DEF+94a] includes\
    \ a\n   multicast protocol when the group membership is densely distributed\n\
    \   within the internetwork.  In this mode, no Rendezvous Points are used\n  \
    \ and a source rooted tree is formed based on Reverse Path Forwarding\n   in a\
    \ manner similar to that of DVMRP [DC90].\n   We do not give details of how Nimrod\
    \ can implement Dense Mode\n   Multicast here.\n   Multiple RPs:  Our discussion\
    \ above has been based on the assumption\n   that there is one RP per group. \
    \ PIM allows more than one RP per\n   group.  We do not discuss multiple-RP PIM\
    \ here.\n"
- title: 6  Security Considerations
  contents:
  - "6  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 7  Summary
  contents:
  - '7  Summary

    '
- title: o Nimrod does not specify a particular multicast route generation
  contents:
  - "o Nimrod does not specify a particular multicast route generation\n  algorithm\
    \ or state creation procedure.  Nimrod can accommodate diverse\n  multicast techniques\
    \ and leaves the choice of the technique to the\n  particular instantiation of\
    \ Nimrod.\n"
- title: 'o A solution for multicasting within Nimrod should be capable of:'
  contents:
  - "o A solution for multicasting within Nimrod should be capable of:\n  -  Scaling\
    \ to large networks, large numbers of multicast groups and\n     large multicast\
    \ groups.\n  -  Supporting policy, including quality of service and access\n \
    \    restrictions.\n  -  Resource sharing.\n  -  Interoperability with other solutions.\n"
- title: o Multicasting typically requires the setting up of state in intermediate
  contents:
  - "o Multicasting typically requires the setting up of state in intermediate\n \
    \ routers for packet forwarding.  The state setup may be initiated by the\n  sender\
    \ (e.g., IDPR), by the receiver (e.g., CBT), by both (e.g., PIM)\n  or by neither.\
    \  The architecture of Nimrod provides sufficient\n  flexibility to accommodate\
    \ any of these approaches.\n"
- title: o A receiver-initiated multicast protocol, PIM, is being designed by the
  contents:
  - "o A receiver-initiated multicast protocol, PIM, is being designed by the\n  IDMR\
    \ working group of the IETF. The facilities provided by Nimrod make\n  the use\
    \ of PIM as a multicast protocol quite straightforward.\n"
- title: 8  References
  contents:
  - '8  References

    '
- title: '[BFC93]   A. J. Ballardie, P. F. Francis, and J. Crowcroft. Core based'
  contents:
  - "[BFC93]   A. J. Ballardie, P. F. Francis, and J. Crowcroft. Core based\n    \
    \      trees. In Proceedings of ACM SIGCOMM, 1993.\n"
- title: '[CCS96]   Castineyra, I., Chiappa, N., and M. Steenstrup, "The Nimrod'
  contents:
  - "[CCS96]   Castineyra, I., Chiappa, N., and M. Steenstrup, \"The Nimrod\n    \
    \      Routing Architecture\", RFC 1992, August 1996.\n"
- title: '[DC90]    S. Deering and D. Cheriton. Multicast routing in datagram'
  contents:
  - "[DC90]    S. Deering and D. Cheriton. Multicast routing in datagram\n       \
    \   internetworks and extended lans. ACM Transactions on Computer\n          Systems,\
    \ pages 85--111, May 1990.\n"
- title: '[DEF+94a] Deering, S., Estrin, D., Farinacci, D., Jacobson, V., Liu,'
  contents:
  - "[DEF+94a] Deering, S., Estrin, D., Farinacci, D., Jacobson, V., Liu,\n      \
    \    C., and L. Wei, \"Protocol Independent Multicast (PIM) :\n          Motivation\
    \ and Architecture, Work in Progress.\n"
- title: '[DEF+94b] Deering, S., Estrin, D., Farinacci, D., Jacobson, V., Liu,'
  contents:
  - "[DEF+94b] Deering, S., Estrin, D., Farinacci, D., Jacobson, V., Liu,\n      \
    \    C., and L. Wei, \"Protocol Independent Multicast (PIM) :\n          Sparse\
    \ Mode Protocol Specification, Work in Progress.\n"
- title: '[DEFJ93]  Deering, S., Estrin, D., Farinacci, D., and V. Jacobson,'
  contents:
  - "[DEFJ93]  Deering, S., Estrin, D., Farinacci, D., and V. Jacobson,\n        \
    \  \"IGMP router extensions for routing to sparse multicast\n          groups,\
    \ Work in Progress.\n"
- title: '[DM78]    Y. K. Dalal and R. M. Metcalfe. Reverse path forwarding of'
  contents:
  - "[DM78]    Y. K. Dalal and R. M. Metcalfe. Reverse path forwarding of\n      \
    \    broadcast packets. Communications of the ACM, 21(12), pages\n          1040--1048,\
    \ 1978.\n"
- title: '[Moy92]   Moy, J., "Multicast Extensions to OSPF, RFC 1584, March 1994.'
  contents:
  - '[Moy92]   Moy, J., "Multicast Extensions to OSPF, RFC 1584, March 1994.

    '
- title: '[RS96]    Ramanathan, S., and M. Steenstrup, "Nimrod functional and'
  contents:
  - "[RS96]    Ramanathan, S., and M. Steenstrup, \"Nimrod functional and\n      \
    \    protocol specifications, Work in Progress.\n"
- title: '[Ste]     Steenstrup, M., "Inter-domain policy routing protocol'
  contents:
  - "[Ste]     Steenstrup, M., \"Inter-domain policy routing protocol\n          specification:\
    \  Version 2\", Work in Progress.\n"
- title: 9  Acknowledgements
  contents:
  - "9  Acknowledgements\n   We thank Isidro Castineyra (BBN), Charles Lynn (BBN),\
    \ Martha\n   Steenstrup (BBN) and other members of the Nimrod Working Group for\n\
    \   their comments and suggestions on this memo.\n"
- title: 10  Author's Address
  contents:
  - "10  Author's Address\n   Ram Ramanathan\n   BBN Systems and Technologies\n  \
    \ 10 Moulton Street\n   Cambridge, MA 02138\n   Phone:  (617) 873-2736\n   EMail:\
    \  ramanath@bbn.com\n"
