- contents:
  - '                       Hash-Based Addresses (HBA)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo describes a mechanism to provide a secure binding between\n
    \  the multiple addresses with different prefixes available to a host\n   within
    a multihomed site.  This mechanism employs either\n   Cryptographically Generated
    Addresses (CGAs) or a new variant of the\n   same theme that uses the same format
    in the addresses.  The main idea\n   in the new variant is that information about
    the multiple prefixes is\n   included within the addresses themselves.  This is
    achieved by\n   generating the interface identifiers of the addresses of a host
    as\n   hashes of the available prefixes and a random number.  Then, the\n   multiple
    addresses are generated by prepending the different prefixes\n   to the generated
    interface identifiers.  The result is a set of\n   addresses, called Hash-Based
    Addresses (HBAs), that are inherently\n   bound to each other.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Terminology .....................................................4\n   3.
    Overview ........................................................4\n      3.1.
    Threat Model ...............................................4\n      3.2. Overview
    ...................................................4\n      3.3. Motivations for
    the HBA Design .............................5\n   4. Cryptographic Generated Addresses
    (CGAs) Compatibility\n      Considerations ..................................................6\n
    \  5. Multi-Prefix Extension for CGA ..................................8\n   6.
    HBA-Set Generation ..............................................9\n   7. HBA
    Verification ...............................................11\n      7.1. Verification
    That a Particular HBA Address\n           Corresponds to a Given CGA Parameter
    Data Structure .......11\n      7.2. Verification That a Particular HBA Address
    Belongs to the\n           HBA Set Associated with a Given CGA Parameter Data\n
    \          Structure .................................................11\n   8.
    Example of HBA Application in a Multihoming Scenario ...........13\n      8.1.
    Dynamic Address Set Support ...............................16\n   9. DNS Considerations
    .............................................17\n   10. IANA Considerations ...........................................18\n
    \  11. Security Considerations .......................................18\n      11.1.
    Security Considerations When Using HBAs in the\n            Shim6 Protocol ...........................................20\n
    \     11.2. Privacy Considerations ...................................22\n      11.3.
    SHA-1 Dependency Considerations ..........................22\n      11.4. DoS
    Attack Considerations ................................22\n   12. Contributors
    ..................................................23\n   13. Acknowledgments ...............................................23\n
    \  14. References ....................................................24\n      14.1.
    Normative References .....................................24\n      14.2. Informative
    References ...................................24\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In order to preserve inter-domain routing system scalability,
    IPv6\n   sites obtain addresses from their Internet Service Providers (ISPs).\n
    \  Such an addressing strategy significantly reduces the amount of\n   routes
    in the global routing tables, since each ISP only announces\n   routes to its
    own address blocks, rather than announcing one route\n   per customer site.  However,
    this addressing scheme implies that\n   multihomed sites will obtain multiple
    prefixes, one per ISP.\n   Moreover, since each ISP only announces its own address
    block, a\n   multihomed site will be reachable through a given ISP if the ISP\n
    \  prefix is contained in the destination address of the packets.  This\n   means
    that, if an established communication needs to be routed\n   through different
    ISPs during its lifetime, addresses with different\n   prefixes will have to be
    used.  Changing the address used to carry\n   packets of an established communication
    exposes the communication to\n   numerous attacks, as described in [11], so security
    mechanisms are\n   required to provide the required protection to the involved
    parties.\n   This memo describes a tool that can be used to provide protection\n
    \  against some of the potential attacks, in particular against future/\n   premeditated
    attacks (aka time shifting attacks in [12]).\n   This memo describes a mechanism
    to provide a secure binding between\n   the multiple addresses with different
    prefixes available to a host\n   within a multihomed site.\n   It should be noted
    that, as opposed to the mobility case where the\n   addresses that will be used
    by the mobile node are not known a\n   priori, the multiple addresses available
    to a host within the\n   multihomed site are pre-defined and known in advance
    in most of the\n   cases.  The mechanism proposed in this memo employs either\n
    \  Cryptographically Generated Addresses (CGAs) [2] or a new variant of\n   the
    same theme that uses the same format in the addresses.  The new\n   variant, Hash-Based
    Address (HBA), takes advantage of the address set\n   stability.  In either case,
    a secure binding between the addresses of\n   a node in a multihomed site can
    be provided.  CGAs employ public key\n   cryptography and can deal with changing
    address sets.  HBAs employ\n   only symmetric key cryptography, and have smaller
    computational\n   requirements.\n   For the purposes of the Shim6 protocol, the
    other characteristics of\n   the CGAs and HBAs are similar.  Both can be generated
    by the host\n   itself without any reliance on external infrastructure.  Both
    employ\n   the same format of addresses and same format of data fed to generate\n
    \  the addresses.  It is not required that all interface identifiers of\n   a
    node's addresses be equal, preserving some degree of privacy\n   through changes
    in the addresses used during the communications.\n   The main idea in HBAs is
    that information about the multiple prefixes\n   is included within the addresses
    themselves.  This is achieved by\n   generating the interface identifiers of the
    addresses of a host as\n   hashes of the available prefixes and a random number.
    \ Then, the\n   multiple addresses are obtained by prepending the different prefixes\n
    \  to the generated interface identifiers.  The result is a set of\n   addresses
    that are inherently bound.  A cost-efficient mechanism is\n   available to determine
    if two addresses belong to the same set, since\n   given the prefix set and the
    additional parameters used to generate\n   the HBA, a single hash operation is
    enough to verify if an HBA\n   belongs to a given HBA set.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [1].\n"
  title: 2.  Terminology
- contents:
  - '3.  Overview

    '
  - contents:
    - "3.1.  Threat Model\n   The threat analysis for the multihoming problem is described
      in [11].\n   This analysis basically identifies attacks based on redirection
      of\n   packets by a malicious attacker towards addresses that do not belong\n
      \  to the multihomed node.  There are essentially two types of\n   redirection
      attacks: communication hijacking and flooding attacks.\n   Communication hijacking
      attacks are about an attacker stealing on-\n   going and/or future communications
      from a victim.  Flooding attacks\n   are about redirecting the traffic generated
      by a legitimate source\n   towards a third party, flooding it.  The HBA solution
      provides full\n   protection against the communication hijacking attacks.  The
      Shim6\n   protocol [9] protects against flooding attacks.  Residual threats
      are\n   described in the \"Security Considerations\" section.\n"
    title: 3.1.  Threat Model
  - contents:
    - "3.2.  Overview\n   The basic goal of the HBA mechanism is to securely bind
      together\n   multiple IPv6 addresses that belong to the same multihomed host.\n
      \  This allows rerouting of traffic without worrying that the\n   communication
      is being redirected to an attacker.  The technique that\n   is used is to include
      a hash of the permitted prefixes in the\n   low-order bits of the IPv6 address.\n
      \  So, eliding some details, say the available prefixes are A, B, C, and\n   D,
      the host would generate a prefix list P consisting of (A,B,C,D)\n   and a random
      number called Modifier M.  Then it would generate the\n   new addresses:\n   A
      || H(M || A || P)\n   B || H(M || B || P)\n   C || H(M || C || P)\n   D || H(M
      || D || P)\n   Thus, given one valid address out of the group and the prefix
      list P\n   and the random Modifier M it is possible to determine whether another\n
      \  address is part of the group by computing the hash and checking\n   against
      the low-order bits.\n"
    title: 3.2.  Overview
  - contents:
    - "3.3.  Motivations for the HBA Design\n   The design of the HBA technique was
      driven by the following\n   considerations:\n   First of all, the goal of HBA
      is to provide a secure binding between\n   the IPv6 address used as an identifier
      by the upper-layer protocols\n   and the alternative locators available in the
      multihomed node so that\n   redirection attacks are prevented.\n   Second, in
      order to achieve such protection, the selected approach\n   was to include security
      information in the identifier itself, instead\n   of relying on third trusted
      parties to secure the binding, such as\n   the ones based on repositories or
      Public Key Infrastructure.  This\n   decision was driven by deployment considerations,
      i.e., the cost of\n   deploying the trusted third-party infrastructure.\n   Third,
      application support considerations described in [16] resulted\n   in selecting
      routable IPv6 addresses to be used as identifiers.\n   Hence, security information
      is stuffed within the interface\n   identifier part of the IPv6 address.\n   Fourth,
      performance considerations as described in [17] motivated the\n   usage of a
      hash-based approach as opposed to a public-key-based\n   approach based on pure
      Cryptographic Generated Addresses (CGA), in\n   order to avoid imposing the
      performance of public key operations for\n   every communication in multihomed
      environments.  The HBA approach\n   presented in this document presents a cheaper
      alternative that is\n   attractive to many common usage cases.  Note that the
      HBA approach\n   and the CGA approaches are not mutually exclusive and that
      it is\n   possible to generate addresses that are both valid CGA and HBA\n   addresses
      providing the benefits of both approaches if needed.\n"
    title: 3.3.  Motivations for the HBA Design
  title: 3.  Overview
- contents:
  - "4.  Cryptographic Generated Addresses (CGAs) Compatibility\n    Considerations\n
    \  As described in the previous section, the HBA technique uses the\n   interface
    identifier part of the IPv6 address to encode information\n   about the multiple
    prefixes available to a multihomed host.  However,\n   the interface identifier
    is also used to carry cryptographic\n   information when Cryptographic Generated
    Addresses (CGAs) [2] are\n   used.  Therefore, conflicting usages of the interface
    identifier bits\n   may result if this is not taken into account during the HBA
    design.\n   There are at least two valid reasons to provide CGA-HBA\n   compatibility:\n
    \  First, the current Secure Neighbor Discovery (SeND) specification [3]\n   uses
    the CGAs defined in [2] to prove address ownership.  If HBAs are\n   not compatible
    with CGAs, then nodes using HBAs for multihoming\n   wouldn't be able to do Secure
    Neighbor Discovery using the same\n   addresses (at least the parts of SeND that
    require CGAs).  This would\n   imply that nodes would have to choose between security
    (from SeND)\n   and fault tolerance (from IPv6 multihoming support provided by
    the\n   Shim6 protocol [9]).  In addition to SeND, there are other protocols\n
    \  that are considered to benefit from the advantages offered by the CGA\n   scheme,
    such as mobility support protocols [13].  Those protocols\n   could not be used
    with HBAs if HBAs are not compatible with CGAs.\n   Second, CGAs provide additional
    features that cannot be achieved\n   using only HBAs.  In particular, because
    of its own nature, the HBA\n   technique only supports a predetermined prefix
    set that is known at\n   the time of the generation of the HBA set.  No additions
    of new\n   prefixes to this original set are supported after the HBA set\n   generation.
    \ In most of the cases relevant for site multihoming, this\n   is not a problem
    because the prefix set available to a multihomed set\n   is not very dynamic.
    \ New prefixes may be added in a multihomed site\n   when a new ISP is available,
    but the timing of those events are\n   rarely in the same time scale as the lifetime
    of established\n   communications.  It is then enough for many situations that
    the new\n   prefix is not available for established communications and that only\n
    \  new communications benefit from it.  However, in the case that such\n   functionality
    is required, it is possible to use CGAs to provide it.\n   This approach clearly
    requires that HBA and CGA approaches be\n   compatible.  If this is the case,
    it then would be possible to create\n   HBA/CGA addresses that support CGA and
    HBA functionality\n   simultaneously.  The inputs to the HBA/CGA generation process
    will be\n   both a prefix set and a public key.  In this way, a node that has\n
    \  established a communication using one address of the CGA/HBA set can\n   tell
    its peer to use the HBA verification when one of the addresses\n   of its HBA/CGA
    set is used as locator in the communication or to use\n   CGA (public-/private-key-based)
    verification when a new address that\n   does not belong to the HBA/CGA set is
    used as locator in the\n   communication.\n   So, because of the aforementioned
    reasons, it is a goal of the HBA\n   design to define HBAs in such a way that
    they are compatible with\n   CGAs as defined in [2] and their usages described
    in [3]\n   (consequently, to understand the rest of this note, the reader should\n
    \  be familiar with the CGA specification defined in [2]).  This means\n   that
    it must be possible to generate addresses that are both an HBA\n   and a CGA,
    i.e., that the interface identifier contains cryptographic\n   information of
    CGA and the prefix-set information of an HBA.  The CGA\n   specification already
    considers the possibility of including\n   additional information into the CGA
    generation process through the\n   usage of Extension Fields in the CGA Parameter
    Data Structure.  It is\n   then possible to define a Multi-Prefix extension for
    CGA so that the\n   prefix set information is included in the interface identifier\n
    \  generation process.\n   Even though a CGA compatible approach is adopted, it
    should be noted\n   that HBAs and CGAs are different concepts.  In particular,
    the CGA is\n   inherently bound to a public key, while an HBA is inherently bound
    to\n   a prefix set.  This means that a public key is not required to\n   generate
    an HBA-only address.  Because of that, we define three\n   different types of
    addresses:\n   -  CGA-only addresses:  These are addresses generated as specified
    in\n      [2] without including the Multi-Prefix extension.  They are bound\n
    \     to a public key and to a single prefix (contained in the basic CGA\n      Parameter
    Data Structure).  These addresses can be used for SeND\n      [3]; if used for
    multihoming, their application will have to be\n      based on the public key
    usage.\n   -  CGA/HBA addresses:  These addresses are CGAs that include the\n
    \     Multi-Prefix extension in the CGA Parameter Data Structure used\n      for
    their generation.  These addresses are bound to a public key\n      and a prefix
    set and they provide both CGA and HBA\n      functionalities.  They can be used
    for SeND as defined in [3] and\n      for any usage defined for HBA (such as a
    Shim6 protocol).\n   -  HBA-only addresses:  These addresses are bound to a prefix
    set but\n      they are not bound to a public key.  Because HBAs are compatible\n
    \     with CGA, the CGA Parameter Data Structure will be used for their\n      generation,
    but a random nonce will be included in the Public Key\n      field instead of
    a public key.  These addresses can be used for\n      HBA-based multihoming protocols,
    but they cannot be used for SeND.\n"
  title: 4.  Cryptographic Generated Addresses (CGAs) Compatibility
- contents:
  - "5.  Multi-Prefix Extension for CGA\n   The Multi-Prefix extension has the following
    TLV format as defined in\n   [8]:\n      0                   1                   2
    \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Extension Type        |   Extension Data Length       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |P|                         Reserved                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     +
    \                          Prefix[1]                           +\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \                                                              |\n     +                           Prefix[2]
    \                          +\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     .
    \                              .                               .\n     .                               .
    \                              .\n     .                               .                               .\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \                                                              |\n     +                           Prefix[n]
    \                          +\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Ext
    Type:  16-bit type identifier of the Multi-Prefix extension (see\n      the \"IANA
    Considerations\" section).\n   Ext Len:  16-bit unsigned integer.  Length of the
    Extension in\n      octets, not including the first 4 octets.\n   P flag:  Set
    if a public key is included in the Public Key field of\n      the CGA Parameter
    Data Structure, reset otherwise.\n   Reserved:  31-bit reserved field.  MUST be
    initialized to zero, and\n      ignored upon receipt.\n   Prefix[1...n]:  Vector
    of 64-bit prefixes, numbered 1 to n.\n"
  title: 5.  Multi-Prefix Extension for CGA
- contents:
  - "6.  HBA-Set Generation\n   The HBA generation process is based on the CGA generation
    process\n   defined in Section 4 of [2].  The goal is to require the minimum\n
    \  amount of changes to the CGA generation process.  It should be noted\n   that
    the following procedure is only valid for Sec values of 0, 1,\n   and 2.  For
    other Sec values, RFC 4982 [10] has defined a CGA SEC\n   registry that will contain
    the specifications used to generate CGAs.\n   The generation procedures defined
    in such specifications must be used\n   for Sec values other than 0, 1, or 2.\n
    \  The CGA generation process has three inputs: a 64-bit subnet prefix,\n   a
    public key (encoded in DER as an ASN.1 structure of the type\n   SubjectPublicKeyInfo),
    and the security parameter Sec.\n   The main difference between the CGA generation
    and the HBA generation\n   is that while a CGA can be generated independently,
    all the HBAs of a\n   given HBA set have to be generated using the same parameters,
    which\n   implies that the generation of the addresses of an HBA set will occur\n
    \  in a coordinated fashion.  In this memo, we will describe a mechanism\n   to
    generate all the addresses of a given HBA set.  The generation\n   process of
    each one of the HBA address of an HBA set will be heavily\n   based in the CGA
    generation process defined in [2].  More precisely,\n   the HBA set generation
    process will be defined as a sequence of\n   lightly modified CGA generations.\n
    \  The changes required in the CGA generation process when generating a\n   single
    HBA are the following: First, the Multi-Prefix extension has\n   to be included
    in the CGA Parameter Data Structure.  Second, in the\n   case that the address
    being generated is an HBA-only address, a\n   random nonce will have to be used
    as input instead of a valid public\n   key.  For backwards compatibility issues
    with pure CGAs, the random\n   nonce MUST be encoded as a public key as defined
    in [2].  In\n   particular, the random nonce MUST be formatted as a DER-encoded
    ASN.1\n   structure of the type SubjectPublicKeyInfo, defined in the Internet\n
    \  X.509 certificate profile [5].  The algorithm identifier MUST be\n   rsaEncryption,
    which is 1.2.840.113549.1.1.1, and the random nonce\n   MUST be formatted by using
    the RSAPublicKey type as specified in\n   Section 2.3.1 of RFC 3279 [4].  The
    random nonce length is 384 bits.\n   The resulting HBA-set generation process
    is the following:\n   The inputs to the HBA generation process are:\n   o  A vector
    of n 64-bit prefixes,\n   o  A Sec parameter, and\n   o  In the case of the generation
    of a set of HBA/CGA addresses, a\n      public key is also provided as input (not
    required when generating\n      HBA-only addresses).\n   The output of the HBA
    generation process are:\n   o  An HBA-set\n   o  their respective CGA Parameter
    Data Structures\n   The steps of the HBA-set generation process are:\n   1. Multi-Prefix
    extension generation.  Generate the Multi-Prefix\n      extension with the format
    defined in Section 5.  Include the\n      vector of n 64-bit prefixes in the Prefix[1...n]
    fields.  The Ext\n      Len field value is (n*8 + 4).  If a public key is provided,
    then\n      the P flag is set to one.  Otherwise, the P flag is set to zero.\n
    \  2. Modifier generation.  Generate a Modifier as a random or\n      pseudorandom
    128-bit value.  If a public key has not been provided\n      as an input, generate
    the Extended Modifier as a 384-bit random or\n      pseudorandom value.  Encode
    the Extended Modifier value as an RSA\n      key in a DER-encoded ASN.1 structure
    of the type\n      SubjectPublicKeyInfo defined in the Internet X.509 certificate\n
    \     profile [5].\n   3. Concatenate from left to right the Modifier, 9 zero
    octets, the\n      encoded public key or the encoded Extended Modifier (if no
    public\n      key was provided), and the Multi-Prefix extension.  Execute the\n
    \     SHA-1 algorithm on the concatenation.  Take the 112 leftmost bits\n      of
    the SHA-1 hash value.  The result is Hash2.\n   4. Compare the 16*Sec leftmost
    bits of Hash2 with zero.  If they are\n      all zero (or if Sec=0), continue
    with step (5).  Otherwise,\n      increment the Modifier by one and go back to
    step (3).\n   5. Set the 8-bit collision count to zero.\n   6. For i=1 to n (number
    of prefixes) do:\n      6.1.  Concatenate from left to right the final Modifier
    value,\n         Prefix[i], the collision count, the encoded public key or the\n
    \        encoded Extended Modifier (if no public key was provided), and\n         the
    Multi-Prefix extension.  Execute the SHA-1 algorithm on the\n         concatenation.
    \ Take the 64 leftmost bits of the SHA-1 hash\n         value.  The result is
    Hash1[i].\n      6.2.  Form an interface identifier from Hash1[i] by writing the\n
    \        value of Sec into the three leftmost bits and by setting bits 6\n         and
    7 (i.e., the \"u\" and \"g\" bits) both to zero.\n      6.3.  Generate address
    HBA[i] by concatenating Prefix[i] and the\n         64-bit interface identifier
    to form a 128-bit IPv6 address with\n         the subnet prefix to the left and
    interface identifier to the\n         right as in a standard IPv6 address [6].\n
    \     6.4.  Perform duplicate address detection if required.  If an\n         address
    collision is detected, increment the collision count by\n         one and go back
    to step (6).  However, after three collisions,\n         stop and report the error.\n
    \     6.5.  Form the CGA Parameter Data Structure that corresponds to\n         HBA[i]
    by concatenating from left to right the final Modifier\n         value, Prefix[i],
    the final collision count value, the encoded\n         public key or the encoded
    Extended Modifier, and the Multi-\n         Prefix extension.\n   Note: most of
    the steps of the process are taken from [2].\n"
  title: 6.  HBA-Set Generation
- contents:
  - "7.  HBA Verification\n   The following procedure is only valid for Sec values
    of 0, 1, and 2.\n   For other Sec values, RFC 4982 [10] has defined a CGA SEC
    registry\n   that will contain the specifications used to verify CGAs.  The\n
    \  verification procedures defined in such specifications must be used\n   for
    Sec values other than 0,1, or 2.\n"
  - contents:
    - "7.1.  Verification That a Particular HBA Address Corresponds to a Given\n      CGA
      Parameter Data Structure\n   HBAs are constructed as a CGA Extension, so a properly
      formatted HBA\n   and its correspondent CGA Parameter Data Structure will successfully\n
      \  finish the verification process described in Section 5 of [2].  Such\n   verification
      is useful when the goal is the verification of the\n   binding between the public
      key and the HBA.\n"
    title: 7.1.  Verification That a Particular HBA Address Corresponds to a Given
  - contents:
    - "7.2.  Verification That a Particular HBA Address Belongs to the HBA Set\n      Associated
      with a Given CGA Parameter Data Structure\n   For multihoming applications,
      it is also relevant that the receiver\n   of the HBA information verifies if
      a given HBA address belongs to a\n   certain HBA set.  An HBA set is identified
      by a CGA Parameter Data\n   structure that contains a Multi-Prefix extension.
      \ So, the receiver\n   needs to verify if a given HBA belongs to the HBA set
      defined by a\n   CGA Parameter Data Structure.  It should be noted that the
      receiver\n   may need to verify if an HBA belongs to the HBA set defined by
      the\n   CGA Parameter Data Structure of another HBA of the set.  If this is\n
      \  the case, HBAs will fail to pass the CGA verification process defined\n   in
      [2], because the prefix included in the Subnet Prefix field of the\n   CGA Parameter
      Data Structure will not match the prefix of the HBA\n   that is being verified.
      \ To verify if an HBA belongs to an HBA set\n   associated with another HBA,
      verify that the HBA prefix is included\n   in the prefix set defined in the
      Multi-Prefix extension, and if this\n   is the case, then substitute the prefix
      included in the Subnet Prefix\n   field by the prefix of the HBA, and then perform
      the CGA verification\n   process defined in [2].\n   So, the process to verify
      that an HBA belongs to an HBA set\n   determined by a CGA Parameter Data Structure
      is called HBA\n   verification and it is the following:\n   The inputs to the
      HBA verification process are:\n   o  An HBA\n   o  A CGA Parameter Data Structure\n
      \  The steps of the HBA verification process are the following:\n   1. Verify
      that the 64-bit HBA prefix is included in the prefix set of\n      the Multi-Prefix
      extension.  If it is not included, the\n      verification fails.  If it is
      included, replace the prefix\n      contained in the Subnet Prefix field of
      the CGA Parameter Data\n      Structure by the 64-bit HBA prefix.\n   2. Run
      the verification process described in Section 5 of [2] with\n      the HBA and
      the new CGA Parameters Data Structure (including the\n      Multi-Prefix extension)
      as inputs.  The steps of the process are\n      included below, extracted from
      [2]:\n      2.1.  Check that the collision count in the CGA Parameter Data\n
      \        Structure is 0, 1, or 2.  The CGA verification fails if the\n         collision
      count is out of the valid range.\n      2.2.  Check that the subnet prefix in
      the CGA Parameter Data\n         Structure is equal to the subnet prefix (i.e.,
      the leftmost 64\n         bits) of the address.  The CGA verification fails
      if the prefix\n         values differ.  Note: This step always succeeds because
      of the\n         action taken in step 1.\n      2.3.  Execute the SHA-1 algorithm
      on the CGA Parameter Data\n         Structure.  Take the 64 leftmost bits of
      the SHA-1 hash value.\n         The result is Hash1.\n      2.4.  Compare Hash1
      with the interface identifier (i.e., the\n         rightmost 64 bits) of the
      address.  Differences in the three\n         leftmost bits and in bits 6 and
      7 (i.e., the \"u\" and \"g\" bits)\n         are ignored.  If the 64-bit values
      differ (other than in the\n         five ignored bits), the CGA verification
      fails.\n      2.5.  Read the security parameter Sec from the three leftmost
      bits\n         of the 64-bit interface identifier of the address.  (Sec is an\n
      \        unsigned 3-bit integer.)\n      2.6.  Concatenate from left to right
      the Modifier, 9 zero octets,\n         the public key, and any extension fields
      (in this case, the\n         Multi-Prefix extension will be included, at least)
      that follow\n         the public key in the CGA Parameter Data Structure.  Execute\n
      \        the SHA-1 algorithm on the concatenation.  Take the 112\n         leftmost
      bits of the SHA-1 hash value.  The result is Hash2.\n      2.7.  Compare the
      16*Sec leftmost bits of Hash2 with zero.  If any\n         one of them is non-zero,
      the CGA verification fails.\n         Otherwise, the verification succeeds.
      \ (If Sec=0, the CGA\n         verification never fails at this step.)\n"
    title: 7.2.  Verification That a Particular HBA Address Belongs to the HBA Set
  title: 7.  HBA Verification
- contents:
  - "8.  Example of HBA Application in a Multihoming Scenario\n   In this section,
    we will describe a possible application of the HBA\n   technique to IPv6 multihoming.\n
    \  We will consider the following scenario: a multihomed site obtains\n   Internet
    connectivity through two providers: ISPA and ISPB.  Each\n   provider has delegated
    a prefix to the multihomed site (PrefA::/nA\n   and PrefB::/nb, respectively).
    \ In order to benefit from multihoming,\n   the hosts within the multihomed site
    will configure multiple IP\n   addresses, one per available prefix.  The resulting
    configuration is\n   depicted in the next figure.\n                  +-------+\n
    \                 | Host2 |\n                  |IPHost2|\n                  +-------+\n
    \                     |\n                      |\n                  (Internet)\n
    \                  /      \\\n                  /        \\\n            +------+
    \     +------+\n            | ISPA |      | ISPB |\n            |      |      |
    \     |\n            +------+      +------+\n               |             |\n
    \               \\            /\n                 \\          /\n            +---------------------+\n
    \           | multihomed site     |\n            | PA::/nA             |\n            |
    PB::/nB    +------+ |\n            |            |Host1 | |\n            |            +------+
    |\n            +---------------------+\n   We assume that both Host1 and Host2
    support the Shim6 protocol.\n   Host2 is not located in a multihomed site, so
    there is no need for it\n   to create HBAs (it must be able to verify them though,
    in order to\n   support the Shim6 protocol, as we will describe next).\n   Host1
    is located in the multihomed site, so it will generate its\n   addresses as HBAs.
    \ In order to do that, it needs to execute the\n   HBA-set generation process
    as detailed in Section 6 of this memo.\n   The inputs of the HBA-set generation
    process will be: a prefix vector\n   containing the two prefixes available in
    its link, i.e., PA:LA::/64\n   and PB:LB::/64, a Sec parameter value, and optionally
    a public key.\n   In this case, we will assume that a public key is provided so
    that we\n   can also illustrate how a renumbering event can be supported when\n
    \  HBA/CGA addresses are used (see the sub-section referring to dynamic\n   address
    set support).  So, after executing the HBA-set generation\n   process, Host1 will
    have: an HBA-set consisting in two addresses,\n   i.e., PA:LA:iidA and PB:LB:iidB
    with their respective CGA Parameter\n   Data Structures, i.e., CGA_PDS_A and CGA_PDS_B.
    \ Note that iidA and\n   iidB are different but both contain information about
    the prefix set\n   available in the multihomed site.\n   We will next consider
    a communication between Host1 and Host2.\n   Assume that both ISPs of the multihomed
    site are working properly, so\n   any of the available addresses in Host1 can
    be used for the\n   communication.  Suppose then that the communication is established\n
    \  using PA:LA:iidA and IPHost2 for Host1 and Host2, respectively.  So\n   far,
    no special Shim6 support has been required, and PA:LA:iidA is\n   used as any
    other global IP address.\n   Suppose that at a certain moment, one of the hosts
    involved in the\n   communication decides that multihoming support is required
    in this\n   communication (this basically means that one of the hosts involved
    in\n   the communication desires enhanced fault-tolerance capabilities for\n   this
    communication, so that if an outage occurs, the communication\n   can be re-homed
    to an alternative provider).\n   At this moment, the Shim6 protocol Host-Pair
    Context establishment\n   exchange will be performed between the two hosts (see
    [9]).  In this\n   exchange, Host1 will send CGA_PDS_A to Host2.\n   After the
    reception of CGA_PDS_A, Host2 will verify that the received\n   CGA Parameter
    Data Structure corresponds to the address being used in\n   the communication
    PA:LA:iidA.  This means that Host2 will execute the\n   HBA verification process
    described in Section 7 of this memo with PA:\n   LA:iidA and CGA_PDS_A as inputs.
    \ In this case, the verification will\n   succeed since the CGA Parameter Data
    Structure and the addresses used\n   in the verification match.\n   As long as
    there are no outages affecting the communication path\n   through ISPA, packets
    will continue flowing.  If a failure affects\n   the path through ISPA, Host1
    will attempt to re-home the\n   communication to an alternative address, i.e.,
    PB:LB:iidB.  In order\n   to accomplish this, after detecting the outage, Host1
    will inform\n   Host2 about the alternative address.  Host2 will verify that the
    new\n   address belongs to the HBA set of the initial address.  In order to\n
    \  accomplish this, Host2 will execute the HBA verification process with\n   the
    CGA Parameter Data Structure of the original address (i.e.,\n   CGA_PDS_A) and
    the new address (i.e., PB:LB:iidB) as inputs.  The\n   verification process will
    succeed because PB:LB::/64 has been\n   included in the Multi-Prefix extension
    during the HBA-set generation\n   process.  Additional verifications may be required
    to prevent\n   flooding attacks (see the comments about flooding attacks prevention\n
    \  in the Security Considerations section of this memo).\n   Once the new address
    is verified, it can be used as an alternative\n   locator to re-home the communication,
    while preserving the original\n   address (PA:LA:iidA) as an identifier for the
    upper layers.  This\n   means that following packets will be addressed to/from
    this new\n   address.  Note that no additional HBA verification is required for\n
    \  the following packets, since the new valid address can be stored in\n   Host2.\n
    \  In this example, only the HBA capabilities of the Host1 addresses\n   were
    used.  In other words, neither the public key included in the\n   CGA Parameter
    Data Structure nor its correspondent private key was\n   used in the protocol.
    \ In the following section, we will consider a\n   case where its usage is required.\n"
  - contents:
    - "8.1.  Dynamic Address Set Support\n   In the previous section, we have presented
      the mechanisms that allow\n   a host to use different addresses of a predetermined
      set to exchange\n   packets of a communication.  The set of addresses involved
      was\n   predetermined and known when the communication was initiated.  To\n
      \  achieve such functionality, only HBA functionalities of the addresses\n   were
      needed.  In this section, we will explore the case where the\n   goal is to
      exchange packets using additional addresses that were not\n   known when the
      communication was established.  An example of such a\n   situation is when a
      new prefix is available in a site after a\n   renumbering event.  In this case,
      the hosts that have the new address\n   available may want to use it in communications
      that were established\n   before the renumbering event.  In this case, HBA functionalities
      of\n   the addresses are not enough and CGA capabilities are to be used.\n   Consider
      then the previous case of the communication between Host1\n   and Host2.  Suppose
      that the communication is up and running, as\n   described earlier.  Host1 is
      using PA:LA:iidA and Host2 is using\n   IPHost2 to exchange packets.  Now suppose
      that a new address, PC:LC:\n   addC is available in Host1.  Note that this address
      is just a regular\n   IPv6 address, and it is neither an HBA nor a CGA.  Host1
      wants to use\n   this new address in the existent communication with Host2.
      \ It should\n   be noted that the HBA mechanism described in the previous section\n
      \  cannot be used to verify this new address, since this address does\n   not
      belong to the HBA set (since the prefix was not available at the\n   moment
      of the generation of the HBA set).  This means that\n   alternative verification
      mechanisms will be needed.\n   In order to verify this new address, CGA capabilities
      of PA:LA:iidA\n   are used.  Note that the same address is used, only that the\n
      \  verification mechanism is different.  So, if Host1 wants to use PC:\n   LC:addC
      to exchange packets in the established communication, it will\n   use the UPDATE
      message defined in the Shim6 protocol [9], conveying\n   the new address, PC:LC:addC,
      and this message will be signed using\n   the private key corresponding to the
      public key contained in\n   CGA_PDS_A.  When Host2 receives the message, it
      will verify the\n   signature using the public key contained in the CGA Parameter
      Data\n   Structure associated with the address used for establishing the\n   communication,
      i.e., CGA_PDS_A and PA:LA:iidA, respectively.  Once\n   that the signature is
      verified, the new address (PC:LC:addC) can be\n   used in the communication.\n
      \  In any case, a renumbering event has an impact on a site that is\n   using
      the HBA technique.  In particular, the new prefix added will\n   not be included
      in the existing HBA set, so it is only possible to\n   use the new prefix with
      the existing HBA set if CGA capabilities are\n   used.  While this is acceptable
      for the short term, in the long run,\n   the site will need to renumber its
      HBA addresses.  In order to do\n   that, it will need to re-generate the HBA
      sets assigned to hosts\n   including the new prefix in the prefix set, which
      will result in\n   different addresses, not only because we need to add a new
      address\n   with the new prefix, but also because the addresses with the existing\n
      \  prefixes will also change because of the inclusion of a new prefix in\n   the
      prefix set.  Moreover, since HBA addresses need to be generated\n   locally,
      once these are generated after the renumbering event, the\n   new address information
      needs to be conveyed to the DNS manager in\n   case that such address information
      is to be published in the DNS (see\n   DNS considerations section for more details).\n"
    title: 8.1.  Dynamic Address Set Support
  title: 8.  Example of HBA Application in a Multihoming Scenario
- contents:
  - "9.  DNS Considerations\n   HBA sets can be generated using any prefix set.  Actually,
    the only\n   particularity of the HBA is that they contain information about the\n
    \  prefix set in the interface identifier part of the address in the\n   form
    of a hash, but no assumption about the properties of prefixes\n   used for the
    HBA generation is made.  This basically means that\n   depending on the prefixes
    used for the HBA set generation, it may or\n   may not be recommended to publish
    the resulting (HBA) addresses in\n   the DNS.  For instance, when Unique Local
    Address (ULA) prefixes [18]\n   are included in the HBA generation process, specific
    DNS\n   considerations related to the local nature of the ULA should be taken\n
    \  into account and proper recommendations related to publishing such\n   prefixes
    in the DNS should followed.  Moreover, among its addresses,\n   a given host can
    have some HBAs and some other IPv6 addresses.  The\n   consequence from this is
    that only HBA addresses will be bound\n   together by the HBA technique, while
    other addresses would not be\n   bound to the HBA set.  This would basically mean
    that if one of the\n   other addresses is used for initiating a Shim6 communication,
    it\n   won't be possible to use the HBA technique to bind the address used\n   with
    the HBA set.  Furthermore, since HBA addresses are\n   indistinguishable from
    other IPv6 addresses in their format, an\n   initiator will not be able to distinguish,
    by merely looking at the\n   different addresses, which ones belong to the HBA
    set and which ones\n   do not, so alternative means would be required the initiator
    is\n   supposed to use only HBA for establishing communications in the\n   presence
    of non-HBA addresses in the DNS.\n   In addition, it should be noted that the
    actual HBA values are a\n   result of the HBA generation procedure, meaning that
    they cannot be\n   arbitrarily chosen.  This has an implication with respect to
    DNS\n   management, because the party that generates the HBA address set\n   needs
    to convey the address information to the DNS manager, so that\n   the addresses
    are published and not the other way around.  The\n   situation is similar to regular
    CGA addresses and even to the case\n   where stateless address autoconfiguration
    is used.  In order to do\n   that, it is possible to use Dynamic DNS updates [19]
    or other\n   proprietary tools.  A similar consideration applies when the host\n
    \  wants to publish reverse-DNS entries.  Since the host needs to\n   generate
    its HBA addresses, it will need to convey the address\n   information to the DNS
    manager so the proper reverse-DNS entry is\n   populated in case it is needed.
    \ It should be noted that neither the\n   Shim6 protocol nor the HBA technique
    rely on the reverse DNS for its\n   proper functioning and the general reasons
    for requiring reverse-DNS\n   population apply as for any other regular IPv6 address.\n"
  title: 9.  DNS Considerations
- contents:
  - "10.  IANA Considerations\n   This document defines a new CGA Extension, the Multi-Prefix\n
    \  extension.  This extension has been assigned the CGA Extension Type\n   value
    0x0012.\n"
  title: 10.  IANA Considerations
- contents:
  - "11.  Security Considerations\n   The goal of HBAs is to create a group of addresses
    that are securely\n   bound, so that they can be used interchangeably when communicating\n
    \  with a node.  If there is no secure binding between the different\n   addresses
    of a node, a number of attacks are enabled, as described in\n   [11].  In particular,
    it would be possible for an attacker to\n   redirect the communications of a victim
    to an address selected by the\n   attacker, hijacking the communication.  When
    using HBAs, only the\n   addresses belonging to an HBA set can be used interchangeably,\n
    \  limiting the addresses that can be used to redirect the communication\n   to
    a predetermined set that belongs to the original node involved in\n   the communication.
    \ So, when using HBAs, a node that is communicating\n   using address A can redirect
    the communication to a new address B if\n   and only if B belongs to the same
    HBA set as A.\n   This means that if an attacker wants to redirect communications\n
    \  addressed to address HBA1 to an alternative address IPX, the attacker\n   will
    need to create a CGA Parameter Data Structure that generates an\n   HBA set that
    contains both HBA1 and IPX.\n   In order to generate the required HBA set, the
    attacker needs to find\n   a CGA Parameter Data Structure that fulfills the following\n
    \  conditions:\n   o  the prefix of HBA1 and the prefix of IPX are included in
    the\n      Multi-Prefix extension.\n   o  HBA1 is included in the HBA set generated.\n
    \  Note: this assumes that it is acceptable for the attacker to redirect\n   HBA1
    to any address of the prefix of IPX.\n   The remaining fields that can be changed
    at will by the attacker in\n   order to meet the above conditions are: the Modifier,
    other prefixes\n   in the Multi-Prefix extension, and other extensions.  In any
    case, in\n   order to obtain the desired HBA set, the attacker will have to use
    a\n   brute-force attack, which implies the generation of multiple HBA sets\n
    \  with different parameters (for instance with a different Modifier)\n   until
    the desired conditions are meet.  The expected number of times\n   that the generation
    process will have to be repeated until the\n   desired HBA set is found is exponentially
    related with the number of\n   bits containing hash information included in the
    interface identifier\n   of the HBA.  Since 59 of the 64 bits of the interface
    identifier\n   contain hash bits, then the expected number of generations that
    will\n   have to be performed by the attacker are O(2^59).  Note: We assume\n
    \  brute force is the best attack against HBA/CGAs.  Also, note that the\n   assumption
    that the Sec tool defined in [2] multiplies the attack\n   factor holds for brute-force
    attacks but may not hold for other\n   attack classes.\n   The protection against
    brute-force attacks can be improved by\n   increasing the Sec parameter.  A non-zero
    Sec parameter implies that\n   steps 3-4 of the generation process will be repeated
    O(2^(16*Sec))\n   times (expected number of times).  If we assimilate the cost
    of\n   repeating the steps 3-4 to the cost of generating the HBA address, we\n
    \  can estimate the number of times that the generation is to be\n   repeated
    in O(2^(59+16*Sec)), in the case of Sec values of 1 and 2.\n   For other Sec values,
    Sec protection mechanisms will be defined by\n   the specifications pointed by
    the CGA SEC registry defined in RFC\n   4982 [10].\n"
  - contents:
    - "11.1.  Security Considerations When Using HBAs in the Shim6 Protocol\n   In
      this section, we will analyze the security provided by HBAs in the\n   context
      of a Shim6 protocol as described in Section 8 of this memo.\n   First of all,
      it must be noted that HBAs cannot prevent\n   man-in-the-middle (hereafter MITM)
      attacks.  This means that in the\n   scenario described in Section 8, if an
      attacker is located along the\n   path between Host1 and Host2 during the lifetime
      of the\n   communication, the attacker will be able to change the addresses
      used\n   for the communication.  This means that he will be able to change the\n
      \  addresses used in the communication, adding or removing prefixes at\n   his
      will.  However, the attacker must make sure that the CGA\n   Parameter Data
      Structure and the HBA set is changed accordingly.\n   This essentially means
      that the attacker will have to change the\n   interface identifier part of the
      addresses involved, since a change\n   in the prefix set will result in different
      interface identifiers of\n   the addresses of the HBA set, unless the appropriate
      Modifier value\n   is used (which would require O(2(59+16*Sec)) attempts).  So,
      HBA\n   doesn't provide MITM attacks protection, but a MITM attacker will\n
      \  have to change the address used in the communication in order to\n   change
      the prefix set valid for the communication.\n   HBAs provide protection against
      time shifting attacks [11], [12].  In\n   the multihoming context, an attacker
      would perform a time shifted\n   attack in the following way: an attacker placed
      along the path of the\n   communication will modify the packets to include an
      additional\n   address as a valid address for the communication.  Then the attacker\n
      \  would leave the on-path location, but the effects of the attack would\n   remain
      (i.e., the address would still be considered as a valid\n   address for that
      communication).  Next we will present how HBAs can\n   be used to prevent such
      attacks.\n   If the attacker is not on-path when the initial CGA Parameter Data\n
      \  Structure is exchanged, his only possibility to launch a redirection\n   attack
      is to fake the signature of the message for adding new\n   addresses using CGA
      capabilities of the addresses.  This implies\n   discovering the public key
      used in the CGA Parameter Data Structure\n   and then cracking the key pair,
      which doesn't seem feasible.  So in\n   order to launch a redirection attack,
      the attacker needs to be\n   on-path when the CGA Parameter Data Structure is
      exchanged, so he can\n   modify it.  Now, in order to launch the redirection
      attack, the\n   attacker needs to add his own prefix in the prefix set of the
      CGA\n   Parameter Data Structure.  We have seen in the previous section that\n
      \  there are two possible approaches for this:\n   1. Find the right Modifier
      value, so that the address initially used\n      in the communication is contained
      in the new HBA set.  The cost of\n      this attack is O(2(59+16*Sec)) iterations
      of the generation\n      process, so it is deemed unfeasible.\n   2. Use any
      Modifier value, so that the address initially used in the\n      communication
      is probably not included in the HBA set.  In this\n      case, the attacker
      must remain on-path, since he needs to rewrite\n      the address carried in
      the packets (if not, the endpoints will\n      notice a change in the address
      used in the communication).  This\n      essentially means that the attacker
      cannot launch a time shifted\n      attack, but he must be a full-time man-in-the-middle.\n
      \  So, the conclusion is that HBAs provide protection against time\n   shifted
      attacks\n   HBAs do not provide complete protection against flooding attacks,\n
      \  and, as a result, the SHIM6 protocol has other means to deal with\n   them.
      \ However, HBAs make it very difficult to launch a flooding\n   attack towards
      a specific address.  It is possible though, to launch\n   a flooding attack
      against a prefix.  And of course, the protection\n   that HBA offers applies
      only to nodes that employ it; HBA provides no\n   solution for general-purpose
      flooding-attack protection for other\n   nodes.\n   Suppose that an attacker
      has easy access to a prefix PX::/nX and that\n   he wants to launch a flooding
      attack on a host located in the address\n   P:iid.  The attack would consist
      of establishing communication with a\n   server S and requesting a heavy flow
      from it.  Then simply\n   redirecting the flow to P:iid, flooding the target.
      \ In order to\n   perform this attack, the attacker needs to generate an HBA
      set\n   including P and PX in the prefix set, and be sure that the resulting\n
      \  HBA set contains P:iid.  In order to do this, the attacker needs to\n   find
      the appropriate Modifier value.  The expected number of attempts\n   required
      to find such Modifier value is O(2(59+16*Sec)), as presented\n   earlier.  So,
      we can conclude that such attack is not feasible.\n   However, the target of
      a flooding attack is not limited to specific\n   hosts, but it can also be launched
      against other elements of the\n   infrastructure, such as router or access links.
      \ In order to do that,\n   the attacker can establish a communication with a
      server S and\n   request a download of a heavy flow.  Then, the attacker redirects
      the\n   communication to any address of the target network.  Even if the\n   target
      address is not assigned to any host, the flow will flood the\n   access link
      of the target site, and the site access router will also\n   suffer the overload.
      \ Such attack cannot be prevented using HBAs,\n   since the attacker can easily
      generate an HBA set using his own\n   prefix and the target network prefix.
      \ In order to prevent such\n   attacks, additional mechanisms are required,
      such as reachability\n   tests.\n"
    title: 11.1.  Security Considerations When Using HBAs in the Shim6 Protocol
  - contents:
    - "11.2.  Privacy Considerations\n   HBAs can be used as RFC 4941 [7] addresses.
      \ If a node wants to use\n   temporary addresses, it will need to periodically
      generate new HBA\n   sets.  The effort required for this operation depends on
      the Sec\n   parameter value.  If Sec=0, then the cost of generating a new HBA
      set\n   is similar to the cost of generating a random number, i.e., one\n   iteration
      of the HBA set generation procedure.  However, if Sec>0,\n   then the cost of
      generating an HBA set is significantly increased,\n   since it required O(2(16*Sec))
      iterations of the generation process.\n   In this case, depending on the frequency
      of address change required,\n   the support for RFC 4941 address may be more
      expensive.\n"
    title: 11.2.  Privacy Considerations
  - contents:
    - "11.3.  SHA-1 Dependency Considerations\n   Recent attacks on currently used
      hash functions have motivated a\n   considerable amount of concern in the Internet
      community.  The\n   recommended approach [14] [15] to deal with this issue is
      first to\n   analyze the impact of these attacks on the different Internet\n
      \  protocols that use hash functions, and second to make sure that the\n   different
      Internet protocols that use hash functions are capable of\n   migrating to an
      alternative (more secure) hash function without a\n   major disruption in the
      Internet operation.\n   The aforementioned analysis for CGAs and their extensions
      (including\n   HBAs) is performed in RFC 4982 [10].  The conclusion of the analysis\n
      \  is that the security of the protocols using CGAs and their extensions\n   are
      not affected by the recently available attacks against hash\n   functions.  In
      spite of that, the CGA specification [2] was updated\n   by RFC 4982 [10] to
      enable the support of alternative hash functions.\n"
    title: 11.3.  SHA-1 Dependency Considerations
  - contents:
    - "11.4.  DoS Attack Considerations\n   In order to use the HBA technique, the
      owner of the HBA set must\n   inform its peer about the CGA Parameter Data Structure
      in order to\n   allow the peer to verify that the different HBAs belong to the
      same\n   HBA set.  Such information must then be stored by the peer to verify\n
      \  alternative addresses in the future.  This can be a vector for DoS\n   attacks,
      since the peer must commit resources (in this particular\n   case memory) to
      be able to use the HBA technique for address\n   verification.  It is then possible
      for an attacker to launch a DoS\n   attack by conveying HBA information to a
      victim, imposing on the\n   victim to use memory for storing HBA related state,
      and eventually\n   running out of memory for other genuine operations.  In order
      to\n   prevent such an attack, protocols that use the HBA technique should\n
      \  implement proper DoS prevention techniques.\n   For instance, the Shim6 protocol
      [9] includes a 4-way handshake to\n   establish the Shim6 context and, in particular,
      to establish the HBA-\n   related state.  In this 4-way handshake, the receiver
      remains\n   stateless during the first 2 messages, while the initiator must
      keep\n   state throughout the exchange of the 4 messages so that the cost of\n
      \  the context establishment is higher in memory terms for the initiator\n   (i.e.,
      the potential attacker) than for the receiver (i.e., the\n   potential victim).
      \ In addition to that, the 4-way handshake prevents\n   the usage of spoofed
      addresses from off-path attacker, since the\n   initiator must be able to receive
      information through the address it\n   has used as source address, enabling
      the tracking of the location\n   from which the attack was launched.\n"
    title: 11.4.  DoS Attack Considerations
  title: 11.  Security Considerations
- contents:
  - "12.  Contributors\n   This document was originally produced by a MULTI6 design
    team\n   consisting of (in alphabetical order): Jari Arkko, Marcelo Bagnulo,\n
    \  Iljitsch van Beijnum, Geoff Huston, Erik Nordmark, Margaret\n   Wasserman,
    and Jukka Ylitalo.\n"
  title: 12.  Contributors
- contents:
  - "13.  Acknowledgments\n   The initial discussion about HBA benefited from contributions
    from\n   Alberto Garcia-Martinez, Tuomas Aura, and Arturo Azcorra.\n   The HBA-set
    generation and HBA verification processes described in\n   this document contain
    several steps extracted from [2].\n   Jari Arkko, Matthew Ford, Francis Dupont,
    Mohan Parthasarathy, Pekka\n   Savola, Brian Carpenter, Eric Rescorla, Robin Whittle,
    Matthijs\n   Mekking, Hannes Tschofenig, Spencer Dawkins, Lars Eggert, Tim Polk,\n
    \  Peter Koch, Niclas Comstedt, David Ward, and Sam Hartman have\n   reviewed
    this document and provided valuable comments.\n   The text included in Section
    3.2 was provided by Eric Rescorla.\n   The author would also like to thank Francis
    Dupont for providing the\n   first implementation of HBA.\n"
  title: 13.  Acknowledgments
- contents:
  - '14.  References

    '
  - contents:
    - "14.1.  Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs
      to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n
      \  [2]   Aura, T., \"Cryptographically Generated Addresses (CGA)\",\n         RFC
      3972, March 2005.\n   [3]   Arkko, J., Kempf, J., Zill, B., and P. Nikander,
      \"SEcure\n         Neighbor Discovery (SEND)\", RFC 3971, March 2005.\n   [4]
      \  Bassham, L., Polk, W., and R. Housley, \"Algorithms and\n         Identifiers
      for the Internet X.509 Public Key Infrastructure\n         Certificate and Certificate
      Revocation List (CRL) Profile\",\n         RFC 3279, April 2002.\n   [5]   Cooper,
      D., Santesson, S., Farrell, S., Boeyen, S., Housley,\n         R., and W. Polk,
      \"Internet X.509 Public Key Infrastructure\n         Certificate and Certificate
      Revocation List (CRL) Profile\",\n         RFC 5280, May 2008.\n   [6]   Hinden,
      R. and S. Deering, \"IP Version 6 Addressing\n         Architecture\", RFC 4291,
      February 2006.\n   [7]   Narten, T., Draves, R., and S. Krishnan, \"Privacy
      Extensions\n         for Stateless Address Autoconfiguration in IPv6\", RFC
      4941,\n         September 2007.\n   [8]   Bagnulo, M. and J. Arkko, \"Cryptographically
      Generated\n         Addresses (CGA) Extension Field Format\", RFC 4581,\n         October
      2006.\n   [9]   Nordmark, E. and M. Bagnulo, \"Shim6: Level 3 Multihoming Shim\n
      \        Protocol for IPv6\", RFC 5533, June 2009.\n   [10]  Bagnulo, M. and
      J. Arkko, \"Support for Multiple Hash Algorithms\n         in Cryptographically
      Generated Addresses (CGAs)\", RFC 4982,\n         July 2007.\n"
    title: 14.1.  Normative References
  - contents:
    - "14.2.  Informative References\n   [11]  Nordmark, E. and T. Li, \"Threats Relating
      to IPv6 Multihoming\n         Solutions\", RFC 4218, October 2005.\n   [12]
      \ Nikander, P., Arkko, J., Aura, T., Montenegro, G., and E.\n         Nordmark,
      \"Mobile IP Version 6 Route Optimization Security\n         Design Background\",
      RFC 4225, December 2005.\n   [13]  Arkko, J., Vogt, C., and W. Haddad, \"Enhanced
      Route\n         Optimization for Mobile IPv6\", RFC 4866, May 2007.\n   [14]
      \ Hoffman, P. and B. Schneier, \"Attacks on Cryptographic Hashes\n         in
      Internet Protocols\", RFC 4270, November 2005.\n   [15]  Bellovin, S. and E.
      Rescorla, \"Deploying a New Hash Algorithm\",\n         2005 September.\n   [16]
      \ Nordmark, E., \"Multi6 Application Referral Issues\", Work\n         in Progress,
      October 2004.\n   [17]  Bagnulo, M., Garcia-Martinez, A., and A. Azcorra, \"Efficient\n
      \        Security for IPv6 Multihoming\", ACM Computer Communications\n         Review
      Vol 35 n 2, April 2005.\n   [18]  Hinden, R. and B. Haberman, \"Unique Local
      IPv6 Unicast\n         Addresses\", RFC 4193, October 2005.\n   [19]  Vixie,
      P., Thomson, S., Rekhter, Y., and J. Bound, \"Dynamic\n         Updates in the
      Domain Name System (DNS UPDATE)\", RFC 2136,\n         April 1997.\n"
    title: 14.2.  Informative References
  title: 14.  References
- contents:
  - "Author's Address\n   Marcelo Bagnulo\n   Universidad Carlos III de Madrid\n   Av.
    Universidad 30\n   Leganes, Madrid  28911\n   SPAIN\n   Phone: 34 91 6249500\n
    \  EMail: marcelo@it.uc3m.es\n   URI:   http://www.it.uc3m.es\n"
  title: Author's Address
