- title: __initial_text__
  contents:
  - '                       OAuth 2.0 for Native Apps

    '
- title: Abstract
  contents:
  - "Abstract\n   OAuth 2.0 authorization requests from native apps should only be\
    \ made\n   through external user-agents, primarily the user's browser.  This\n\
    \   specification details the security and usability reasons why this is\n   the\
    \ case and how native apps and authorization servers can implement\n   this best\
    \ practice.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 7841.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8252.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Notational Conventions  . . . . . . . . . . . . . . .\
    \ . . . .   3\n   3.  Terminology . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   3\n   4.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   4\n     4.1.  Authorization Flow for Native Apps Using the Browser  .\
    \ .   5\n   5.  Using Inter-App URI Communication for OAuth . . . . . . . . .\
    \   6\n   6.  Initiating the Authorization Request from a Native App  . . .  \
    \ 6\n   7.  Receiving the Authorization Response in a Native App  . . . .   7\n\
    \     7.1.  Private-Use URI Scheme Redirection  . . . . . . . . . . .   8\n  \
    \   7.2.  Claimed \"https\" Scheme URI Redirection  . . . . . . . . .   9\n  \
    \   7.3.  Loopback Interface Redirection  . . . . . . . . . . . . .   9\n   8.\
    \  Security Considerations . . . . . . . . . . . . . . . . . . .  10\n     8.1.\
    \  Protecting the Authorization Code . . . . . . . . . . . .  10\n     8.2.  OAuth\
    \ Implicit Grant Authorization Flow . . . . . . . . .  11\n     8.3.  Loopback\
    \ Redirect Considerations  . . . . . . . . . . . .  11\n     8.4.  Registration\
    \ of Native App Clients  . . . . . . . . . . .  12\n     8.5.  Client Authentication\
    \ . . . . . . . . . . . . . . . . . .  12\n     8.6.  Client Impersonation  .\
    \ . . . . . . . . . . . . . . . . .  13\n     8.7.  Fake External User-Agents\
    \ . . . . . . . . . . . . . . . .  13\n     8.8.  Malicious External User-Agents\
    \  . . . . . . . . . . . . .  14\n     8.9.  Cross-App Request Forgery Protections\
    \ . . . . . . . . . .  14\n     8.10. Authorization Server Mix-Up Mitigation \
    \ . . . . . . . . .  14\n     8.11. Non-Browser External User-Agents  . . . .\
    \ . . . . . . . .  15\n     8.12. Embedded User-Agents  . . . . . . . . . . .\
    \ . . . . . . .  15\n   9.  IANA Considerations . . . . . . . . . . . . . . .\
    \ . . . . . .  16\n   10. References  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  16\n     10.1.  Normative References . . . . . . . . . . . . . .\
    \ . . . .  16\n     10.2.  Informative References . . . . . . . . . . . . . .\
    \ . . .  17\n   Appendix A.  Server Support Checklist . . . . . . . . . . . .\
    \ . .  18\n   Appendix B.  Platform-Specific Implementation Details . . . . .\
    \ .  18\n     B.1.  iOS Implementation Details  . . . . . . . . . . . . . . .\
    \  18\n     B.2.  Android Implementation Details  . . . . . . . . . . . . .  19\n\
    \     B.3.  Windows Implementation Details  . . . . . . . . . . . . .  19\n  \
    \   B.4.  macOS Implementation Details  . . . . . . . . . . . . . .  20\n    \
    \ B.5.  Linux Implementation Details  . . . . . . . . . . . . . .  21\n   Acknowledgements\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  21\n   Authors' Addresses\
    \  . . . . . . . . . . . . . . . . . . . . . . .  21\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Section 9 of the OAuth 2.0 authorization framework [RFC6749]\n\
    \   documents two approaches for native apps to interact with the\n   authorization\
    \ endpoint: an embedded user-agent and an external user-\n   agent.\n   This best\
    \ current practice requires that only external user-agents\n   like the browser\
    \ are used for OAuth by native apps.  It documents how\n   native apps can implement\
    \ authorization flows using the browser as\n   the preferred external user-agent\
    \ as well as the requirements for\n   authorization servers to support such usage.\n\
    \   This practice is also known as the \"AppAuth pattern\", in reference to\n\
    \   open-source libraries [AppAuth] that implement it.\n"
- title: 2.  Notational Conventions
  contents:
  - "2.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   In addition to the terms defined in referenced specifications,\
    \ this\n   document uses the following terms:\n   \"native app\"  An app or application\
    \ that is installed by the user to\n      their device, as distinct from a web\
    \ app that runs in the browser\n      context only.  Apps implemented using web-based\
    \ technology but\n      distributed as a native app, so-called \"hybrid apps\"\
    , are\n      considered equivalent to native apps for the purpose of this\n  \
    \    specification.\n   \"app\"  A \"native app\" unless further specified.\n\
    \   \"app store\"  An e-commerce store where users can download and\n      purchase\
    \ apps.\n   \"OAuth\"  Authorization protocol specified by the OAuth 2.0\n   \
    \   Authorization Framework [RFC6749].\n   \"external user-agent\"  A user-agent\
    \ capable of handling the\n      authorization request that is a separate entity\
    \ or security domain\n      to the native app making the request, such that the\
    \ app cannot\n      access the cookie storage, nor inspect or modify page content.\n\
    \   \"embedded user-agent\"  A user-agent hosted by the native app making\n  \
    \    the authorization request that forms a part of the app or shares\n      the\
    \ same security domain such that the app can access the cookie\n      storage\
    \ and/or inspect or modify page content.\n   \"browser\"  The default application\
    \ launched by the operating system\n      to handle \"http\" and \"https\" scheme\
    \ URI content.\n   \"in-app browser tab\"  A programmatic instantiation of the\
    \ browser\n      that is displayed inside a host app but that retains the full\n\
    \      security properties and authentication state of the browser.  It\n    \
    \  has different platform-specific product names, several of which\n      are\
    \ detailed in Appendix B.\n   \"web-view\"  A web browser UI (user interface)\
    \ component that is\n      embedded in apps to render web pages under the control\
    \ of the app.\n   \"inter-app communication\"  Communication between two apps\
    \ on a\n      device.\n   \"claimed \"https\" scheme URI\"  Some platforms allow\
    \ apps to claim an\n      \"https\" scheme URI after proving ownership of the\
    \ domain name.\n      URIs claimed in such a way are then opened in the app instead\
    \ of\n      the browser.\n   \"private-use URI scheme\"  As used by this document,\
    \ a URI scheme\n      defined by the app (following the requirements of Section\
    \ 3.8 of\n      [RFC7595]) and registered with the operating system.  URI requests\n\
    \      to such schemes launch the app that registered it to handle the\n     \
    \ request.\n   \"reverse domain name notation\"  A naming convention based on\
    \ the\n      domain name system, but one where the domain components are\n   \
    \   reversed, for example, \"app.example.com\" becomes\n      \"com.example.app\"\
    .\n"
- title: 4.  Overview
  contents:
  - "4.  Overview\n   For authorizing users in native apps, the best current practice\
    \ is to\n   perform the OAuth authorization request in an external user-agent\n\
    \   (typically the browser) rather than an embedded user-agent (such as\n   one\
    \ implemented with web-views).\n   Previously, it was common for native apps to\
    \ use embedded user-agents\n   (commonly implemented with web-views) for OAuth\
    \ authorization\n   requests.  That approach has many drawbacks, including the\
    \ host app\n   being able to copy user credentials and cookies as well as the\
    \ user\n   needing to authenticate from scratch in each app.  See Section 8.12\n\
    \   for a deeper analysis of the drawbacks of using embedded user-agents\n   for\
    \ OAuth.\n   Native app authorization requests that use the browser are more\n\
    \   secure and can take advantage of the user's authentication state.\n   Being\
    \ able to use the existing authentication session in the browser\n   enables single\
    \ sign-on, as users don't need to authenticate to the\n   authorization server\
    \ each time they use a new app (unless required by\n   the authorization server\
    \ policy).\n   Supporting authorization flows between a native app and the browser\n\
    \   is possible without changing the OAuth protocol itself, as the OAuth\n   authorization\
    \ request and response are already defined in terms of\n   URIs.  This encompasses\
    \ URIs that can be used for inter-app\n   communication.  Some OAuth server implementations\
    \ that assume all\n   clients are confidential web clients will need to add an\n\
    \   understanding of public native app clients and the types of redirect\n   URIs\
    \ they use to support this best practice.\n"
- title: 4.1.  Authorization Flow for Native Apps Using the Browser
  contents:
  - "4.1.  Authorization Flow for Native Apps Using the Browser\n  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \  |          User Device          |\n  |                               |\n  |\
    \ +--------------------------+  | (5) Authorization  +---------------+\n  | |\
    \                          |  |     Code           |               |\n  | |  \
    \      Client App        |---------------------->|     Token     |\n  | |    \
    \                      |<----------------------|    Endpoint   |\n  | +--------------------------+\
    \  | (6) Access Token,  |               |\n  |   |             ^             |\
    \     Refresh Token  +---------------+\n  |   |             |             |\n\
    \  |   |             |             |\n  |   | (1)         | (4)         |\n  |\
    \   | Authorizat- | Authoriza-  |\n  |   | ion Request | tion Code   |\n  |  \
    \ |             |             |\n  |   |             |             |\n  |   v\
    \             |             |\n  | +---------------------------+ | (2) Authorization\
    \  +---------------+\n  | |                           | |     Request        |\
    \               |\n  | |          Browser          |--------------------->| Authorization\
    \ |\n  | |                           |<---------------------|    Endpoint   |\n\
    \  | +---------------------------+ | (3) Authorization  |               |\n  |\
    \                               |     Code           +---------------+\n  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \       Figure 1: Native App Authorization via an External User-Agent\n   Figure\
    \ 1 illustrates the interaction between a native app and the\n   browser to authorize\
    \ the user.\n   (1)  Client app opens a browser tab with the authorization request.\n\
    \   (2)  Authorization endpoint receives the authorization request,\n        authenticates\
    \ the user, and obtains authorization.\n        Authenticating the user may involve\
    \ chaining to other\n        authentication systems.\n   (3)  Authorization server\
    \ issues an authorization code to the\n        redirect URI.\n   (4)  Client receives\
    \ the authorization code from the redirect URI.\n   (5)  Client app presents the\
    \ authorization code at the token\n        endpoint.\n   (6)  Token endpoint validates\
    \ the authorization code and issues the\n        tokens requested.\n"
- title: 5.  Using Inter-App URI Communication for OAuth
  contents:
  - "5.  Using Inter-App URI Communication for OAuth\n   Just as URIs are used for\
    \ OAuth 2.0 [RFC6749] on the web to initiate\n   the authorization request and\
    \ return the authorization response to\n   the requesting website, URIs can be\
    \ used by native apps to initiate\n   the authorization request in the device's\
    \ browser and return the\n   response to the requesting native app.\n   By adopting\
    \ the same methods used on the web for OAuth, benefits seen\n   in the web context\
    \ like the usability of a single sign-on session and\n   the security of a separate\
    \ authentication context are likewise gained\n   in the native app context.  Reusing\
    \ the same approach also reduces\n   the implementation complexity and increases\
    \ interoperability by\n   relying on standards-based web flows that are not specific\
    \ to a\n   particular platform.\n   To conform to this best practice, native apps\
    \ MUST use an external\n   user-agent to perform OAuth authorization requests.\
    \  This is achieved\n   by opening the authorization request in the browser (detailed\
    \ in\n   Section 6) and using a redirect URI that will return the\n   authorization\
    \ response back to the native app (defined in Section 7).\n"
- title: 6.  Initiating the Authorization Request from a Native App
  contents:
  - "6.  Initiating the Authorization Request from a Native App\n   Native apps needing\
    \ user authorization create an authorization\n   request URI with the authorization\
    \ code grant type per Section 4.1 of\n   OAuth 2.0 [RFC6749], using a redirect\
    \ URI capable of being received\n   by the native app.\n   The function of the\
    \ redirect URI for a native app authorization\n   request is similar to that of\
    \ a web-based authorization request.\n   Rather than returning the authorization\
    \ response to the OAuth\n   client's server, the redirect URI used by a native\
    \ app returns the\n   response to the app.  Several options for a redirect URI\
    \ that will\n   return the authorization response to the native app in different\n\
    \   platforms are documented in Section 7.  Any redirect URI that allows\n   the\
    \ app to receive the URI and inspect its parameters is viable.\n   Public native\
    \ app clients MUST implement the Proof Key for Code\n   Exchange (PKCE [RFC7636])\
    \ extension to OAuth, and authorization\n   servers MUST support PKCE for such\
    \ clients, for the reasons detailed\n   in Section 8.1.\n   After constructing\
    \ the authorization request URI, the app uses\n   platform-specific APIs to open\
    \ the URI in an external user-agent.\n   Typically, the external user-agent used\
    \ is the default browser, that\n   is, the application configured for handling\
    \ \"http\" and \"https\" scheme\n   URIs on the system; however, different browser\
    \ selection criteria and\n   other categories of external user-agents MAY be used.\n\
    \   This best practice focuses on the browser as the RECOMMENDED external\n  \
    \ user-agent for native apps.  An external user-agent designed\n   specifically\
    \ for user authorization and capable of processing\n   authorization requests\
    \ and responses like a browser MAY also be used.\n   Other external user-agents,\
    \ such as a native app provided by the\n   authorization server may meet the criteria\
    \ set out in this best\n   practice, including using the same redirection URI\
    \ properties, but\n   their use is out of scope for this specification.\n   Some\
    \ platforms support a browser feature known as \"in-app browser\n   tabs\", where\
    \ an app can present a tab of the browser within the app\n   context without switching\
    \ apps, but still retain key benefits of the\n   browser such as a shared authentication\
    \ state and security context.\n   On platforms where they are supported, it is\
    \ RECOMMENDED, for\n   usability reasons, that apps use in-app browser tabs for\
    \ the\n   authorization request.\n"
- title: 7.  Receiving the Authorization Response in a Native App
  contents:
  - "7.  Receiving the Authorization Response in a Native App\n   There are several\
    \ redirect URI options available to native apps for\n   receiving the authorization\
    \ response from the browser, the\n   availability and user experience of which\
    \ varies by platform.\n   To fully support this best practice, authorization servers\
    \ MUST offer\n   at least the three redirect URI options described in the following\n\
    \   subsections to native apps.  Native apps MAY use whichever redirect\n   option\
    \ suits their needs best, taking into account platform-specific\n   implementation\
    \ details.\n"
- title: 7.1.  Private-Use URI Scheme Redirection
  contents:
  - "7.1.  Private-Use URI Scheme Redirection\n   Many mobile and desktop computing\
    \ platforms support inter-app\n   communication via URIs by allowing apps to register\
    \ private-use URI\n   schemes (sometimes colloquially referred to as \"custom\
    \ URL schemes\")\n   like \"com.example.app\".  When the browser or another app\
    \ attempts to\n   load a URI with a private-use URI scheme, the app that registered\
    \ it\n   is launched to handle the request.\n   To perform an OAuth 2.0 authorization\
    \ request with a private-use URI\n   scheme redirect, the native app launches\
    \ the browser with a standard\n   authorization request, but one where the redirection\
    \ URI utilizes a\n   private-use URI scheme it registered with the operating system.\n\
    \   When choosing a URI scheme to associate with the app, apps MUST use a\n  \
    \ URI scheme based on a domain name under their control, expressed in\n   reverse\
    \ order, as recommended by Section 3.8 of [RFC7595] for\n   private-use URI schemes.\n\
    \   For example, an app that controls the domain name \"app.example.com\"\n  \
    \ can use \"com.example.app\" as their scheme.  Some authorization\n   servers\
    \ assign client identifiers based on domain names, for example,\n   \"client1234.usercontent.example.net\"\
    , which can also be used as the\n   domain name for the scheme when reversed in\
    \ the same manner.  A\n   scheme such as \"myapp\", however, would not meet this\
    \ requirement, as\n   it is not based on a domain name.\n   When there are multiple\
    \ apps by the same publisher, care must be\n   taken so that each scheme is unique\
    \ within that group.  On platforms\n   that use app identifiers based on reverse-order\
    \ domain names, those\n   identifiers can be reused as the private-use URI scheme\
    \ for the OAuth\n   redirect to help avoid this problem.\n   Following the requirements\
    \ of Section 3.2 of [RFC3986], as there is\n   no naming authority for private-use\
    \ URI scheme redirects, only a\n   single slash (\"/\") appears after the scheme\
    \ component.  A complete\n   example of a redirect URI utilizing a private-use\
    \ URI scheme is:\n     com.example.app:/oauth2redirect/example-provider\n   When\
    \ the authorization server completes the request, it redirects to\n   the client's\
    \ redirection URI as it would normally.  As the\n   redirection URI uses a private-use\
    \ URI scheme, it results in the\n   operating system launching the native app,\
    \ passing in the URI as a\n   launch parameter.  Then, the native app uses normal\
    \ processing for\n   the authorization response.\n"
- title: 7.2.  Claimed "https" Scheme URI Redirection
  contents:
  - "7.2.  Claimed \"https\" Scheme URI Redirection\n   Some operating systems allow\
    \ apps to claim \"https\" scheme [RFC7230]\n   URIs in the domains they control.\
    \  When the browser encounters a\n   claimed URI, instead of the page being loaded\
    \ in the browser, the\n   native app is launched with the URI supplied as a launch\
    \ parameter.\n   Such URIs can be used as redirect URIs by native apps.  They\
    \ are\n   indistinguishable to the authorization server from a regular web-\n\
    \   based client redirect URI.  An example is:\n     https://app.example.com/oauth2redirect/example-provider\n\
    \   As the redirect URI alone is not enough to distinguish public native\n   app\
    \ clients from confidential web clients, it is REQUIRED in\n   Section 8.4 that\
    \ the client type be recorded during client\n   registration to enable the server\
    \ to determine the client type and\n   act accordingly.\n   App-claimed \"https\"\
    \ scheme redirect URIs have some advantages\n   compared to other native app redirect\
    \ options in that the identity of\n   the destination app is guaranteed to the\
    \ authorization server by the\n   operating system.  For this reason, native apps\
    \ SHOULD use them over\n   the other options where possible.\n"
- title: 7.3.  Loopback Interface Redirection
  contents:
  - "7.3.  Loopback Interface Redirection\n   Native apps that are able to open a\
    \ port on the loopback network\n   interface without needing special permissions\
    \ (typically, those on\n   desktop operating systems) can use the loopback interface\
    \ to receive\n   the OAuth redirect.\n   Loopback redirect URIs use the \"http\"\
    \ scheme and are constructed with\n   the loopback IP literal and whatever port\
    \ the client is listening on.\n   That is, \"http://127.0.0.1:{port}/{path}\"\
    \ for IPv4, and\n   \"http://[::1]:{port}/{path}\" for IPv6.  An example redirect\
    \ using the\n   IPv4 loopback interface with a randomly assigned port:\n     http://127.0.0.1:51004/oauth2redirect/example-provider\n\
    \   An example redirect using the IPv6 loopback interface with a randomly\n  \
    \ assigned port:\n     http://[::1]:61023/oauth2redirect/example-provider\n  \
    \ The authorization server MUST allow any port to be specified at the\n   time\
    \ of the request for loopback IP redirect URIs, to accommodate\n   clients that\
    \ obtain an available ephemeral port from the operating\n   system at the time\
    \ of the request.\n   Clients SHOULD NOT assume that the device supports a particular\n\
    \   version of the Internet Protocol.  It is RECOMMENDED that clients\n   attempt\
    \ to bind to the loopback interface using both IPv4 and IPv6\n   and use whichever\
    \ is available.\n"
- title: 8.  Security Considerations
  contents:
  - '8.  Security Considerations

    '
- title: 8.1.  Protecting the Authorization Code
  contents:
  - "8.1.  Protecting the Authorization Code\n   The redirect URI options documented\
    \ in Section 7 share the benefit\n   that only a native app on the same device\
    \ or the app's own website\n   can receive the authorization code, which limits\
    \ the attack surface.\n   However, code interception by a different native app\
    \ running on the\n   same device may be possible.\n   A limitation of using private-use\
    \ URI schemes for redirect URIs is\n   that multiple apps can typically register\
    \ the same scheme, which\n   makes it indeterminate as to which app will receive\
    \ the authorization\n   code.  Section 1 of PKCE [RFC7636] details how this limitation\
    \ can be\n   used to execute a code interception attack.\n   Loopback IP-based\
    \ redirect URIs may be susceptible to interception by\n   other apps accessing\
    \ the same loopback interface on some operating\n   systems.\n   App-claimed \"\
    https\" scheme redirects are less susceptible to URI\n   interception due to the\
    \ presence of the URI authority, but the app is\n   still a public client; further,\
    \ the URI is sent using the operating\n   system's URI dispatch handler with unknown\
    \ security properties.\n   The PKCE [RFC7636] protocol was created specifically\
    \ to mitigate this\n   attack.  It is a proof-of-possession extension to OAuth\
    \ 2.0 that\n   protects the authorization code from being used if it is intercepted.\n\
    \   To provide protection, this extension has the client generate a\n   secret\
    \ verifier; it passes a hash of this verifier in the initial\n   authorization\
    \ request, and must present the unhashed verifier when\n   redeeming the authorization\
    \ code.  An app that intercepted the\n   authorization code would not be in possession\
    \ of this secret,\n   rendering the code useless.\n   Section 6 requires that\
    \ both clients and servers use PKCE for public\n   native app clients.  Authorization\
    \ servers SHOULD reject\n   authorization requests from native apps that don't\
    \ use PKCE by\n   returning an error message, as defined in Section 4.4.1 of PKCE\n\
    \   [RFC7636].\n"
- title: 8.2.  OAuth Implicit Grant Authorization Flow
  contents:
  - "8.2.  OAuth Implicit Grant Authorization Flow\n   The OAuth 2.0 implicit grant\
    \ authorization flow (defined in\n   Section 4.2 of OAuth 2.0 [RFC6749]) generally\
    \ works with the practice\n   of performing the authorization request in the browser\
    \ and receiving\n   the authorization response via URI-based inter-app communication.\n\
    \   However, as the implicit flow cannot be protected by PKCE [RFC7636]\n   (which\
    \ is required in Section 8.1), the use of the Implicit Flow with\n   native apps\
    \ is NOT RECOMMENDED.\n   Access tokens granted via the implicit flow also cannot\
    \ be refreshed\n   without user interaction, making the authorization code grant\
    \ flow --\n   which can issue refresh tokens -- the more practical option for\n\
    \   native app authorizations that require refreshing of access tokens.\n"
- title: 8.3.  Loopback Redirect Considerations
  contents:
  - "8.3.  Loopback Redirect Considerations\n   Loopback interface redirect URIs use\
    \ the \"http\" scheme (i.e., without\n   Transport Layer Security (TLS)).  This\
    \ is acceptable for loopback\n   interface redirect URIs as the HTTP request never\
    \ leaves the device.\n   Clients should open the network port only when starting\
    \ the\n   authorization request and close it once the response is returned.\n\
    \   Clients should listen on the loopback network interface only, in\n   order\
    \ to avoid interference by other network actors.\n   While redirect URIs using\
    \ localhost (i.e.,\n   \"http://localhost:{port}/{path}\") function similarly\
    \ to loopback IP\n   redirects described in Section 7.3, the use of localhost\
    \ is NOT\n   RECOMMENDED.  Specifying a redirect URI with the loopback IP literal\n\
    \   rather than localhost avoids inadvertently listening on network\n   interfaces\
    \ other than the loopback interface.  It is also less\n   susceptible to client-side\
    \ firewalls and misconfigured host name\n   resolution on the user's device.\n"
- title: 8.4.  Registration of Native App Clients
  contents:
  - "8.4.  Registration of Native App Clients\n   Except when using a mechanism like\
    \ Dynamic Client Registration\n   [RFC7591] to provision per-instance secrets,\
    \ native apps are\n   classified as public clients, as defined by Section 2.1\
    \ of OAuth 2.0\n   [RFC6749]; they MUST be registered with the authorization server\
    \ as\n   such.  Authorization servers MUST record the client type in the\n   client\
    \ registration details in order to identify and process requests\n   accordingly.\n\
    \   Authorization servers MUST require clients to register their complete\n  \
    \ redirect URI (including the path component) and reject authorization\n   requests\
    \ that specify a redirect URI that doesn't exactly match the\n   one that was\
    \ registered; the exception is loopback redirects, where\n   an exact match is\
    \ required except for the port URI component.\n   For private-use URI scheme-based\
    \ redirects, authorization servers\n   SHOULD enforce the requirement in Section\
    \ 7.1 that clients use\n   schemes that are reverse domain name based.  At a minimum,\
    \ any\n   private-use URI scheme that doesn't contain a period character (\".\"\
    )\n   SHOULD be rejected.\n   In addition to the collision-resistant properties,\
    \ requiring a URI\n   scheme based on a domain name that is under the control\
    \ of the app\n   can help to prove ownership in the event of a dispute where two\
    \ apps\n   claim the same private-use URI scheme (where one app is acting\n  \
    \ maliciously).  For example, if two apps claimed \"com.example.app\",\n   the\
    \ owner of \"example.com\" could petition the app store operator to\n   remove\
    \ the counterfeit app.  Such a petition is harder to prove if a\n   generic URI\
    \ scheme was used.\n   Authorization servers MAY request the inclusion of other\
    \ platform-\n   specific information, such as the app package or bundle name,\
    \ or\n   other information that may be useful for verifying the calling app's\n\
    \   identity on operating systems that support such functions.\n"
- title: 8.5.  Client Authentication
  contents:
  - "8.5.  Client Authentication\n   Secrets that are statically included as part\
    \ of an app distributed to\n   multiple users should not be treated as confidential\
    \ secrets, as one\n   user may inspect their copy and learn the shared secret.\
    \  For this\n   reason, and those stated in Section 5.3.1 of [RFC6819], it is\
    \ NOT\n   RECOMMENDED for authorization servers to require client\n   authentication\
    \ of public native apps clients using a shared secret,\n   as this serves little\
    \ value beyond client identification which is\n   already provided by the \"client_id\"\
    \ request parameter.\n   Authorization servers that still require a statically\
    \ included shared\n   secret for native app clients MUST treat the client as a\
    \ public\n   client (as defined by Section 2.1 of OAuth 2.0 [RFC6749]), and not\n\
    \   accept the secret as proof of the client's identity.  Without\n   additional\
    \ measures, such clients are subject to client impersonation\n   (see Section\
    \ 8.6).\n"
- title: 8.6.  Client Impersonation
  contents:
  - "8.6.  Client Impersonation\n   As stated in Section 10.2 of OAuth 2.0 [RFC6749],\
    \ the authorization\n   server SHOULD NOT process authorization requests automatically\n\
    \   without user consent or interaction, except when the identity of the\n   client\
    \ can be assured.  This includes the case where the user has\n   previously approved\
    \ an authorization request for a given client id --\n   unless the identity of\
    \ the client can be proven, the request SHOULD\n   be processed as if no previous\
    \ request had been approved.\n   Measures such as claimed \"https\" scheme redirects\
    \ MAY be accepted by\n   authorization servers as identity proof.  Some operating\
    \ systems may\n   offer alternative platform-specific identity features that MAY\
    \ be\n   accepted, as appropriate.\n"
- title: 8.7.  Fake External User-Agents
  contents:
  - "8.7.  Fake External User-Agents\n   The native app that is initiating the authorization\
    \ request has a\n   large degree of control over the user interface and can potentially\n\
    \   present a fake external user-agent, that is, an embedded user-agent\n   made\
    \ to appear as an external user-agent.\n   When all good actors are using external\
    \ user-agents, the advantage is\n   that it is possible for security experts to\
    \ detect bad actors, as\n   anyone faking an external user-agent is provably bad.\
    \  On the other\n   hand, if good and bad actors alike are using embedded user-agents,\n\
    \   bad actors don't need to fake anything, making them harder to detect.\n  \
    \ Once a malicious app is detected, it may be possible to use this\n   knowledge\
    \ to blacklist the app's signature in malware scanning\n   software, take removal\
    \ action (in the case of apps distributed by app\n   stores) and other steps to\
    \ reduce the impact and spread of the\n   malicious app.\n   Authorization servers\
    \ can also directly protect against fake external\n   user-agents by requiring\
    \ an authentication factor only available to\n   true external user-agents.\n\
    \   Users who are particularly concerned about their security when using\n   in-app\
    \ browser tabs may also take the additional step of opening the\n   request in\
    \ the full browser from the in-app browser tab and complete\n   the authorization\
    \ there, as most implementations of the in-app\n   browser tab pattern offer such\
    \ functionality.\n"
- title: 8.8.  Malicious External User-Agents
  contents:
  - "8.8.  Malicious External User-Agents\n   If a malicious app is able to configure\
    \ itself as the default handler\n   for \"https\" scheme URIs in the operating\
    \ system, it will be able to\n   intercept authorization requests that use the\
    \ default browser and\n   abuse this position of trust for malicious ends such\
    \ as phishing the\n   user.\n   This attack is not confined to OAuth; a malicious\
    \ app configured in\n   this way would present a general and ongoing risk to the\
    \ user beyond\n   OAuth usage by native apps.  Many operating systems mitigate\
    \ this\n   issue by requiring an explicit user action to change the default\n\
    \   handler for \"http\" and \"https\" scheme URIs.\n"
- title: 8.9.  Cross-App Request Forgery Protections
  contents:
  - "8.9.  Cross-App Request Forgery Protections\n   Section 5.3.5 of [RFC6819] recommends\
    \ using the \"state\" parameter to\n   link client requests and responses to prevent\
    \ CSRF (Cross-Site\n   Request Forgery) attacks.\n   To mitigate CSRF-style attacks\
    \ over inter-app URI communication\n   channels (so called \"cross-app request\
    \ forgery\"), it is similarly\n   RECOMMENDED that native apps include a high-entropy\
    \ secure random\n   number in the \"state\" parameter of the authorization request\
    \ and\n   reject any incoming authorization responses without a state value\n\
    \   that matches a pending outgoing authorization request.\n"
- title: 8.10.  Authorization Server Mix-Up Mitigation
  contents:
  - "8.10.  Authorization Server Mix-Up Mitigation\n   To protect against a compromised\
    \ or malicious authorization server\n   attacking another authorization server\
    \ used by the same app, it is\n   REQUIRED that a unique redirect URI is used\
    \ for each authorization\n   server used by the app (for example, by varying the\
    \ path component),\n   and that authorization responses are rejected if the redirect\
    \ URI\n   they were received on doesn't match the redirect URI in an outgoing\n\
    \   authorization request.\n   The native app MUST store the redirect URI used\
    \ in the authorization\n   request with the authorization session data (i.e.,\
    \ along with \"state\"\n   and other related data) and MUST verify that the URI\
    \ on which the\n   authorization response was received exactly matches it.\n \
    \  The requirement of Section 8.4, specifically that authorization\n   servers\
    \ reject requests with URIs that don't match what was\n   registered, is also\
    \ required to prevent such attacks.\n"
- title: 8.11.  Non-Browser External User-Agents
  contents:
  - "8.11.  Non-Browser External User-Agents\n   This best practice recommends a particular\
    \ type of external user-\n   agent: the user's browser.  Other external user-agent\
    \ patterns may\n   also be viable for secure and usable OAuth.  This document\
    \ makes no\n   comment on those patterns.\n"
- title: 8.12.  Embedded User-Agents
  contents:
  - "8.12.  Embedded User-Agents\n   Section 9 of OAuth 2.0 [RFC6749] documents two\
    \ approaches for native\n   apps to interact with the authorization endpoint.\
    \  This best current\n   practice requires that native apps MUST NOT use embedded\
    \ user-agents\n   to perform authorization requests and allows that authorization\n\
    \   endpoints MAY take steps to detect and block authorization requests\n   in\
    \ embedded user-agents.  The security considerations for these\n   requirements\
    \ are detailed herein.\n   Embedded user-agents are an alternative method for\
    \ authorizing native\n   apps.  These embedded user-agents are unsafe for use\
    \ by third parties\n   to the authorization server by definition, as the app that\
    \ hosts the\n   embedded user-agent can access the user's full authentication\n\
    \   credential, not just the OAuth authorization grant that was intended\n   for\
    \ the app.\n   In typical web-view-based implementations of embedded user-agents,\n\
    \   the host application can record every keystroke entered in the login\n   form\
    \ to capture usernames and passwords, automatically submit forms\n   to bypass\
    \ user consent, and copy session cookies and use them to\n   perform authenticated\
    \ actions as the user.\n   Even when used by trusted apps belonging to the same\
    \ party as the\n   authorization server, embedded user-agents violate the principle\
    \ of\n   least privilege by having access to more powerful credentials than\n\
    \   they need, potentially increasing the attack surface.\n   Encouraging users\
    \ to enter credentials in an embedded user-agent\n   without the usual address\
    \ bar and visible certificate validation\n   features that browsers have makes\
    \ it impossible for the user to know\n   if they are signing in to the legitimate\
    \ site; even when they are, it\n   trains them that it's OK to enter credentials\
    \ without validating the\n   site first.\n   Aside from the security concerns,\
    \ embedded user-agents do not share\n   the authentication state with other apps\
    \ or the browser, requiring\n   the user to log in for every authorization request,\
    \ which is often\n   considered an inferior user experience.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This document does not require any IANA actions.\n\
    \   Section 7.1 specifies how private-use URI schemes are used for inter-\n  \
    \ app communication in OAuth protocol flows.  This document requires in\n   Section\
    \ 7.1 that such schemes are based on domain names owned or\n   assigned to the\
    \ app, as recommended in Section 3.8 of [RFC7595].  Per\n   Section 6 of [RFC7595],\
    \ registration of domain-based URI schemes with\n   IANA is not required.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC6749]  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n  \
    \            RFC 6749, DOI 10.17487/RFC6749, October 2012,\n              <https://www.rfc-editor.org/info/rfc6749>.\n\
    \   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n           \
    \   RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7595]  Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines\n    \
    \          and Registration Procedures for URI Schemes\", BCP 35,\n          \
    \    RFC 7595, DOI 10.17487/RFC7595, June 2015,\n              <https://www.rfc-editor.org/info/rfc7595>.\n\
    \   [RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, \"Proof Key\n \
    \             for Code Exchange by OAuth Public Clients\", RFC 7636,\n       \
    \       DOI 10.17487/RFC7636, September 2015,\n              <https://www.rfc-editor.org/info/rfc7636>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC6819]  Lodderstedt, T., Ed., McGloin, M.,\
    \ and P. Hunt, \"OAuth 2.0\n              Threat Model and Security Considerations\"\
    , RFC 6819,\n              DOI 10.17487/RFC6819, January 2013,\n             \
    \ <https://www.rfc-editor.org/info/rfc6819>.\n   [RFC7591]  Richer, J., Ed., Jones,\
    \ M., Bradley, J., Machulak, M., and\n              P. Hunt, \"OAuth 2.0 Dynamic\
    \ Client Registration Protocol\",\n              RFC 7591, DOI 10.17487/RFC7591,\
    \ July 2015,\n              <https://www.rfc-editor.org/info/rfc7591>.\n   [AppAuth]\
    \  OpenID Connect Working Group, \"AppAuth\", September 2017,\n              <https://openid.net/code/AppAuth>.\n\
    \   [AppAuth.iOSmacOS]\n              Wright, S., Denniss, W., et al., \"AppAuth\
    \ for iOS and\n              macOS\", February 2016,\n              <https://openid.net/code/AppAuth-iOS>.\n\
    \   [AppAuth.Android]\n              McGinniss, I., Denniss, W., et al., \"AppAuth\
    \ for Android\",\n              February 2016, <https://openid.net/code/AppAuth-Android>.\n\
    \   [SamplesForWindows]\n              Denniss, W., \"OAuth for Apps: Samples\
    \ for Windows\", July\n              2016,\n              <https://openid.net/code/sample-oauth-apps-for-windows>.\n"
- title: Appendix A.  Server Support Checklist
  contents:
  - "Appendix A.  Server Support Checklist\n   OAuth servers that support native apps\
    \ must:\n   1.  Support private-use URI scheme redirect URIs.  This is required\n\
    \       to support mobile operating systems.  See Section 7.1.\n   2.  Support\
    \ \"https\" scheme redirect URIs for use with public native\n       app clients.\
    \  This is used by apps on advanced mobile operating\n       systems that allow\
    \ app-claimed \"https\" scheme URIs.  See\n       Section 7.2.\n   3.  Support\
    \ loopback IP redirect URIs.  This is required to support\n       desktop operating\
    \ systems.  See Section 7.3.\n   4.  Not assume that native app clients can keep\
    \ a secret.  If secrets\n       are distributed to multiple installs of the same\
    \ native app, they\n       should not be treated as confidential.  See Section\
    \ 8.5.\n   5.  Support PKCE [RFC7636].  Required to protect authorization code\n\
    \       grants sent to public clients over inter-app communication\n       channels.\
    \  See Section 8.1\n"
- title: Appendix B.  Platform-Specific Implementation Details
  contents:
  - "Appendix B.  Platform-Specific Implementation Details\n   This document primarily\
    \ defines best practices in a generic manner,\n   referencing techniques commonly\
    \ available in a variety of\n   environments.  This non-normative section documents\
    \ implementation\n   details of the best practice for various operating systems.\n\
    \   The implementation details herein are considered accurate at the time\n  \
    \ of publishing but will likely change over time.  It is hoped that\n   such a\
    \ change won't invalidate the generic principles in the rest of\n   the document\
    \ and that those principles should take precedence in the\n   event of a conflict.\n"
- title: B.1.  iOS Implementation Details
  contents:
  - "B.1.  iOS Implementation Details\n   Apps can initiate an authorization request\
    \ in the browser, without\n   the user leaving the app, through the \"SFSafariViewController\"\
    \ class\n   or its successor \"SFAuthenticationSession\", which implement the\
    \ in-\n   app browser tab pattern.  Safari can be used to handle requests on\n\
    \   old versions of iOS without in-app browser tab functionality.\n   To receive\
    \ the authorization response, both private-use URI scheme\n   (referred to as\
    \ \"custom URL scheme\") redirects and claimed \"https\"\n   scheme URIs (known\
    \ as \"Universal Links\") are viable choices.  Apps\n   can claim private-use\
    \ URI schemes with the \"CFBundleURLTypes\" key in\n   the application's property\
    \ list file, \"Info.plist\", and \"https\"\n   scheme URIs using the Universal\
    \ Links feature with an entitlement\n   file in the app and an association file\
    \ hosted on the domain.\n   Claimed \"https\" scheme URIs are the preferred redirect\
    \ choice on iOS\n   9 and above due to the ownership proof that is provided by\
    \ the\n   operating system.\n   A complete open-source sample is included in the\
    \ AppAuth for iOS and\n   macOS [AppAuth.iOSmacOS] library.\n"
- title: B.2.  Android Implementation Details
  contents:
  - "B.2.  Android Implementation Details\n   Apps can initiate an authorization request\
    \ in the browser, without\n   the user leaving the app, through the Android Custom\
    \ Tab feature,\n   which implements the in-app browser tab pattern.  The user's\
    \ default\n   browser can be used to handle requests when no browser supports\n\
    \   Custom Tabs.\n   Android browser vendors should support the Custom Tabs protocol\
    \ (by\n   providing an implementation of the \"CustomTabsService\" class), to\n\
    \   provide the in-app browser tab user-experience optimization to their\n   users.\
    \  Chrome is one such browser that implements Custom Tabs.\n   To receive the\
    \ authorization response, private-use URI schemes are\n   broadly supported through\
    \ Android Implicit Intents.  Claimed \"https\"\n   scheme redirect URIs through\
    \ Android App Links are available on\n   Android 6.0 and above.  Both types of\
    \ redirect URIs are registered in\n   the application's manifest.\n   A complete\
    \ open-source sample is included in the AppAuth for Android\n   [AppAuth.Android]\
    \ library.\n"
- title: B.3.  Windows Implementation Details
  contents:
  - "B.3.  Windows Implementation Details\n   Both traditional and Universal Windows\
    \ Platform (UWP) apps can\n   perform authorization requests in the user's browser.\
    \  Traditional\n   apps typically use a loopback redirect to receive the authorization\n\
    \   response, and listening on the loopback interface is allowed by\n   default\
    \ firewall rules.  When creating the loopback network socket,\n   apps SHOULD\
    \ set the \"SO_EXCLUSIVEADDRUSE\" socket option to prevent\n   other apps binding\
    \ to the same socket.\n   UWP apps can use private-use URI scheme redirects to\
    \ receive the\n   authorization response from the browser, which will bring the\
    \ app to\n   the foreground.  Known on the platform as \"URI Activation\", the\
    \ URI\n   scheme is limited to 39 characters in length, and it may include the\n\
    \   \".\" character, making short reverse domain name based schemes (as\n   required\
    \ in Section 7.1) possible.\n   UWP apps can alternatively use the Web Authentication\
    \ Broker API in\n   Single Sign-on (SSO) mode, which is an external user-agent\
    \ designed\n   for authorization flows.  Cookies are shared between invocations\
    \ of\n   the broker but not the user's preferred browser, meaning the user\n \
    \  will need to log in again, even if they have an active session in\n   their\
    \ browser; but the session created in the broker will be\n   available to subsequent\
    \ apps that use the broker.  Personalizations\n   the user has made to their browser,\
    \ such as configuring a password\n   manager, may not be available in the broker.\
    \  To qualify as an\n   external user-agent, the broker MUST be used in SSO mode.\n\
    \   To use the Web Authentication Broker in SSO mode, the redirect URI\n   must\
    \ be of the form \"msapp://{appSID}\" where \"{appSID}\" is the app's\n   security\
    \ identifier (SID), which can be found in the app's\n   registration information\
    \ or by calling the\n   \"GetCurrentApplicationCallbackUri\" method.  While Windows\
    \ enforces\n   the URI authority on such redirects, ensuring that only the app\
    \ with\n   the matching SID can receive the response on Windows, the URI scheme\n\
    \   could be claimed by apps on other platforms without the same\n   authority\
    \ present; thus, this redirect type should be treated\n   similarly to private-use\
    \ URI scheme redirects for security purposes.\n   An open-source sample demonstrating\
    \ these patterns is available\n   [SamplesForWindows].\n"
- title: B.4.  macOS Implementation Details
  contents:
  - "B.4.  macOS Implementation Details\n   Apps can initiate an authorization request\
    \ in the user's default\n   browser using platform APIs for opening URIs in the\
    \ browser.\n   To receive the authorization response, private-use URI schemes\
    \ are a\n   good redirect URI choice on macOS, as the user is returned right back\n\
    \   to the app they launched the request from.  These are registered in\n   the\
    \ application's bundle information property list using the\n   \"CFBundleURLSchemes\"\
    \ key.  Loopback IP redirects are another viable\n   option, and listening on\
    \ the loopback interface is allowed by default\n   firewall rules.\n   A complete\
    \ open-source sample is included in the AppAuth for iOS and\n   macOS [AppAuth.iOSmacOS]\
    \ library.\n"
- title: B.5.  Linux Implementation Details
  contents:
  - "B.5.  Linux Implementation Details\n   Opening the authorization request in the\
    \ user's default browser\n   requires a distro-specific command: \"xdg-open\"\
    \ is one such tool.\n   The loopback redirect is the recommended redirect choice\
    \ for desktop\n   apps on Linux to receive the authorization response.  Apps SHOULD\
    \ NOT\n   set the \"SO_REUSEPORT\" or \"SO_REUSEADDR\" socket options in order\
    \ to\n   prevent other apps binding to the same socket.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to acknowledge the work of Marius\
    \ Scurtescu\n   and Ben Wiley Sittler, whose design for using private-use URI\
    \ schemes\n   in native app OAuth 2.0 clients at Google formed the basis of\n\
    \   Section 7.1.\n   The following individuals contributed ideas, feedback, and\
    \ wording\n   that shaped and formed the final specification:\n   Andy Zmolek,\
    \ Steven E. Wright, Brian Campbell, Nat Sakimura, Eric\n   Sachs, Paul Madsen,\
    \ Iain McGinniss, Rahul Ravikumar, Breno de\n   Medeiros, Hannes Tschofenig, Ashish\
    \ Jain, Erik Wahlstrom, Bill\n   Fisher, Sudhi Umarji, Michael B. Jones, Vittorio\
    \ Bertocci, Dick\n   Hardt, David Waite, Ignacio Fiorentino, Kathleen Moriarty,\
    \ and Elwyn\n   Davies.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   William Denniss\n   Google\n   1600 Amphitheatre Pkwy\n\
    \   Mountain View, CA  94043\n   United States of America\n   Email: rfc8252@wdenniss.com\n\
    \   URI:   http://wdenniss.com/appauth\n   John Bradley\n   Ping Identity\n  \
    \ Phone: +1 202-630-5272\n   Email: rfc8252@ve7jtb.com\n   URI:   http://www.thread-safe.com/p/appauth.html\n"
