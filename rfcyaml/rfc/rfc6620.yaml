- contents:
  - "     FCFS SAVI: First-Come, First-Served Source Address Validation\n            Improvement
    for Locally Assigned IPv6 Addresses\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This memo describes First-Come, First-Served Source Address\n   Validation
    Improvement (FCFS SAVI), a mechanism that provides source\n   address validation
    for IPv6 networks using the FCFS principle.  The\n   proposed mechanism is intended
    to complement ingress filtering\n   techniques to help detect and prevent source
    address spoofing.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6620.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Terminology ................................................4\n   2.
    Background to FCFS SAVI .........................................4\n      2.1.
    Scope of FCFS SAVI .........................................4\n      2.2. Constraints
    for FCFS SAVI Design ...........................5\n      2.3. Address Ownership
    Proof ....................................5\n      2.4. Binding Anchor Considerations
    ..............................6\n      2.5. FCFS SAVI Protection Perimeter .............................6\n
    \     2.6. Special Cases .............................................10\n   3.
    FCFS SAVI Specification ........................................11\n      3.1.
    FCFS SAVI Data Structures .................................12\n      3.2. FCFS
    SAVI Algorithm .......................................12\n           3.2.1. Discovering
    On-Link Prefixes .......................12\n           3.2.2. Processing of Transit
    Traffic ......................13\n           3.2.3. Processing of Local Traffic
    ........................13\n           3.2.4. FCFS SAVI Port Configuration Guidelines
    ............21\n           3.2.5. VLAN Support .......................................22\n
    \     3.3. Default Protocol Values ...................................22\n   4.
    Security Considerations ........................................22\n      4.1.
    Denial-of-Service Attacks .................................22\n      4.2. Residual
    Threats ..........................................23\n      4.3. Privacy Considerations
    ....................................24\n      4.4. Interaction with Secure Neighbor
    Discovery ................25\n   5. Contributors ...................................................25\n
    \  6. Acknowledgments ................................................25\n   7.
    References .....................................................26\n      7.1.
    Normative References ......................................26\n      7.2. Informative
    References ....................................26\n   Appendix A.  Implications
    of Not Following the Recommended\n                Behavior .............................................28\n
    \    A.1.  Implications of Not Generating DAD_NS Packets upon the\n           Reception
    of Non-Compliant Data Packets ...................28\n       A.1.1.  Lack of Binding
    State due to Packet Loss...............28\n       A.1.2.  Lack of Binding State
    due to a Change in the\n               Topology ..............................................31\n
    \      A.1.3.  Lack of Binding State due to State Loss ...............31\n     A.2.
    \ Implications of Not Discarding Non-Compliant Data\n           Packets ...................................................35\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo describes FCFS SAVI, a mechanism that provides
    source\n   address validation for IPv6 networks using the FCFS principle.  The\n
    \  proposed mechanism is intended to complement ingress filtering\n   techniques
    to help detect and prevent source address spoofing.\n   Section 2 gives the background
    and description of FCFS SAVI, and\n   Section 3 specifies the FCFS SAVI protocol.\n"
  - contents:
    - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
      2119 [RFC2119].\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - '2.  Background to FCFS SAVI

    '
  - contents:
    - "2.1.  Scope of FCFS SAVI\n   The application scenario for FCFS SAVI is limited
      to the local link.\n   Hence, the goal of FCFS SAVI is to verify that the source
      address of\n   the packets generated by the hosts attached to the local link
      have\n   not been spoofed.\n   In a link, hosts and routers are usually attached.
      \ Hosts generate\n   packets with their own address as the source address.  This
      is called\n   \"local traffic\".  Routers send packets containing a source IP
      address\n   other than their own, since they are forwarding packets generated
      by\n   other hosts (usually located in a different link).  This is called\n
      \  \"transit traffic\".\n   The applicability of FCFS SAVI is limited to the
      local traffic, i.e.,\n   to verify if the traffic generated by the hosts attached
      to the local\n   link contains a valid source address.  The verification of
      the source\n   address of the transit traffic is out of the scope of FCFS SAVI.\n
      \  Other techniques, like ingress filtering [RFC2827], are recommended\n   to
      validate transit traffic.  In that sense, FCFS SAVI complements\n   ingress
      filtering, since it relies on ingress filtering to validate\n   transit traffic,
      but it provides validation of local traffic, which\n   is not provided by ingress
      filtering.  Hence, the security level is\n   increased by using these two techniques.\n
      \  In addition, FCFS SAVI is designed to be used with locally assigned\n   IPv6
      addresses, in particular with IPv6 addresses configured through\n   Stateless
      Address Autoconfiguration (SLAAC) [RFC4862].  Manually\n   configured IPv6 addresses
      can be supported by FCFS SAVI, but manual\n   configuration of the binding on
      the FCFS SAVI device provides higher\n   security and seems compatible with
      manual address management.  FCFS\n   SAVI can also be used with IPv6 addresses
      assigned via DHCPv6, since\n   they ought to perform the Duplicate Address Detection
      (DAD)\n   procedure, but there is a specific mechanism tailored for dealing\n
      \  with DHCP-assigned addresses defined in [SAVI-DHCP].  Additional\n   considerations
      about how to use FCFS SAVI depending on the type of\n   address management used
      and the nature of the addresses are discussed\n   in the framework document
      [SAVI-FRAMEWORK].\n"
    title: 2.1.  Scope of FCFS SAVI
  - contents:
    - "2.2.  Constraints for FCFS SAVI Design\n   FCFS SAVI is designed to be deployed
      in existing networks requiring a\n   minimum set of changes.  For that reason,
      FCFS SAVI does not require\n   any changes in the host whose source address
      is to be verified.  Any\n   verification solely relies on the usage of already
      available\n   protocols.  That is, FCFS SAVI does not define a new protocol,
      define\n   any new message on existing protocols, or require that a host use
      an\n   existent protocol message in a different way.  In other words, no\n   host
      changes are required.\n   FCFS SAVI validation is performed by the FCFS SAVI
      function.  The\n   function can be placed in different types of devices, including
      a\n   router or a Layer 2 (L2) bridge.  The basic idea is that the FCFS\n   SAVI
      function is located in the points of the topology that can\n   enforce the correct
      usage of the source address by dropping the non-\n   compliant packets.\n"
    title: 2.2.  Constraints for FCFS SAVI Design
  - contents:
    - "2.3.  Address Ownership Proof\n   The main function performed by FCFS SAVI
      is to verify that the source\n   address used in data packets actually belongs
      to the originator of\n   the packet.  Since the FCFS SAVI scope is limited to
      the local link,\n   the originator of the packet is attached to the local link.
      \ In order\n   to define a source address validation solution, we need to define
      the\n   meaning of \"address ownership\", i.e., what it means that a given host\n
      \  owns a given address in the sense that the host is entitled to send\n   packets
      with that source address.  With that definition, we can\n   define how a device
      can confirm that the source address in a datagram\n   is owned by the originator
      of the datagram.\n   In FCFS SAVI, proof of address ownership is based on the
      First-Come,\n   First-Served principle.  The first host that claims a given
      source\n   address is the owner of the address until further notice.  Since
      no\n   host changes are acceptable, we need to find the means to confirm\n   address
      ownership without requiring a new protocol.  So, whenever a\n   source address
      is used for the first time, a state is created in the\n   device that is performing
      the FCFS SAVI function binding the source\n   address to a binding anchor that
      consists of Layer 2 information that\n   the FCFS SAVI box has available (e.g.,
      the port in a switched LAN).\n   Subsequent data packets containing that IP
      source address can be\n   checked against the same binding anchor to confirm
      that the\n   originator owns the source IP address.\n   There are, however,
      additional considerations to be taken into\n   account.  For instance, consider
      the case of a host that moves from\n   one segment of a LAN to another segment
      of the same subnetwork and\n   keeps the same IP address.  In this case, the
      host is still the owner\n   of the IP address, but the associated binding anchor
      may have\n   changed.  In order to cope with this case, the defined FCFS SAVI\n
      \  behavior implies verification of whether or not the host is still\n   reachable
      using the previous binding anchor.  In order to do that,\n   FCFS SAVI uses
      the Neighbor Discovery (ND) protocol.  If the host is\n   no longer reachable
      at the previously recorded binding anchor, FCFS\n   SAVI assumes that the new
      location is valid and creates a new binding\n   using the new binding anchor.
      \ In case the host is still reachable\n   using the previously recorded binding
      anchor, the packets coming from\n   the new binding anchor are dropped.\n   Note
      that this only applies to local traffic.  Transit traffic\n   generated by a
      router would be verified using alternative techniques,\n   such as ingress filtering.
      \ FCFS SAVI checks would not be fulfilled\n   by the transit traffic, since
      the router is not the owner of the\n   source address contained in the packets.\n"
    title: 2.3.  Address Ownership Proof
  - contents:
    - "2.4.  Binding Anchor Considerations\n   Any SAVI solution is not stronger than
      the binding anchor it uses.\n   If the binding anchor is easily spoofable (e.g.,
      a Media Access\n   Control (MAC) address), then the resulting solution will
      be weak.\n   The treatment of non-compliant packets needs to be tuned accordingly.\n
      \  In particular, if the binding anchor is easily spoofable and the FCFS\n   SAVI
      device is configured to drop non-compliant packets, then the\n   usage of FCFS
      SAVI may open a new vector of Denial-of-Service (DoS)\n   attacks, based on
      spoofed binding anchors.  For that reason, in this\n   specification, only switch
      ports MUST be used as binding anchors.\n   Other forms of binding anchors are
      out of the scope of this\n   specification, and proper analysis of the implications
      of using them,\n   should be performed before their usage.\n"
    title: 2.4.  Binding Anchor Considerations
  - contents:
    - "2.5.  FCFS SAVI Protection Perimeter\n   FCFS SAVI provides perimetrical security.
      \ FCFS SAVI devices form\n   what can be called an FCFS SAVI protection perimeter,
      and they verify\n   that any packet that crosses the perimeter is compliant
      (i.e., the\n   source address is validated).  Once the packet is inside the\n
      \  perimeter, no further validations are performed on the packet.  This\n   model
      has implications both on how FCFS SAVI devices are deployed in\n   the topology
      and on the configuration of the FCFS SAVI boxes.\n   The implication of this
      perimetrical security approach is that there\n   is part of the topology that
      is inside the perimeter and part of the\n   topology that is outside the perimeter.
      \ So, while packets coming\n   from interfaces connected to the external part
      of the topology need\n   to be validated by the FCFS SAVI device, packets coming
      from\n   interfaces connected to the internal part of the topology do not need\n
      \  to be validated.  This significantly reduces the processing\n   requirements
      of the FCFS SAVI device.  It also implies that each FCFS\n   SAVI device that
      is part of the perimeter must be able to verify the\n   source addresses of
      the packets coming from the interfaces connected\n   to the external part of
      the perimeter.  In order to do so, the FCFS\n   SAVI device binds the source
      address to a binding anchor.\n   One possible approach would be for every FCFS
      SAVI device to store\n   binding information about every source address in the
      subnetwork.  In\n   this case, every FCFS SAVI device would store a binding
      for each\n   source address of the local link.  The problem with this approach
      is\n   that it imposes a significant memory burden on the FCFS SAVI devices.\n
      \  In order to reduce the memory requirements imposed on each device,\n   the
      FCFS SAVI solution described in this specification distributes\n   the storage
      of FCFS SAVI binding information among the multiple FCFS\n   SAVI devices of
      a subnetwork.  The FCFS SAVI binding state is\n   distributed across the FCFS
      SAVI devices according to the following\n   criterion: each FCFS SAVI device
      only stores binding information\n   about the source addresses bound to anchors
      corresponding to the\n   interfaces that connect to the part of the topology
      that is outside\n   of the FCFS SAVI protection perimeter.  Since all the untrusted\n
      \  packet sources are by definition in the external part of the\n   perimeter,
      packets generated by each of the untrusted sources will\n   reach the perimeter
      through an interface of an FCFS SAVI device.  The\n   binding information for
      that particular source address will be stored\n   in the first FCFS SAVI device
      the packet reaches.\n   The result is that the FCFS SAVI binding information
      will be\n   distributed across multiple devices.  In order to provide proper\n
      \  source address validation, it is critical that the information\n   distributed
      among the different FCFS SAVI devices be coherent.  In\n   particular, it is
      important to avoid having the same source address\n   bound to different binding
      anchors in different FCFS SAVI devices.\n   Should that occur, then it would
      mean that two hosts are allowed to\n   send packets with the same source address,
      which is what FCFS SAVI is\n   trying to prevent.  In order to preserve the
      coherency of the FCFS\n   SAVI bindings distributed among the FCFS SAVI devices
      within a realm,\n   the Neighbor Discovery (ND) protocol [RFC4861] is used,
      in particular\n   the Neighbor Solicitation (NS) and Neighbor Advertisement
      (NA)\n   messages.  Following is a simplified example of how this might work.\n
      \  Before creating an FCFS SAVI binding in the local FCFS SAVI database,\n   the
      FCFS SAVI device will send an NS message querying for the address\n   involved.
      \ Should any host reply to that message with an NA message,\n   the FCFS SAVI
      device that sent the NS will infer that a binding for\n   that address exists
      in another FCFS SAVI device and will not create a\n   local binding for it.
      \ If no NA message is received as a reply to the\n   NS, then the local FCFS
      SAVI device will infer that no binding for\n   that address exists in other
      FCFS SAVI device and will create the\n   local FCFS SAVI binding for that address.\n
      \  To summarize, the proposed FCFS SAVI approach relies on the following\n   design
      choices:\n   o  An FCFS SAVI provides perimetrical security, so some interfaces
      of\n      an FCFS SAVI device will connect to the internal (trusted) part of\n
      \     the topology, and other interfaces will connect to the external\n      (untrusted)
      part of the topology.\n   o  An FCFS SAVI device only verifies packets coming
      through an\n      interface connected to the untrusted part of the topology.\n
      \  o  An FCFS SAVI device only stores binding information for the source\n      addresses
      that are bound to binding anchors that correspond to\n      interfaces that
      connect to the untrusted part of the topology.\n   o  An FCFS SAVI uses NS and
      NA messages to preserve the coherency of\n      the FCFS SAVI binding state
      distributed among the FCFS SAVI\n      devices within a realm.\n   So, in a
      link that is constituted of multiple L2 devices, some of\n   which are FCFS
      SAVI capable and some of which are not, the FCFS-SAVI-\n   capable devices MUST
      be deployed forming a connected perimeter (i.e.,\n   no data packet can get
      inside the perimeter without passing through\n   an FCFS SAVI device).  Packets
      that cross the perimeter will be\n   validated while packets that do not cross
      the perimeter are not\n   validated (hence, FCFS SAVI protection is not provided
      for these\n   packets).  Consider the deployment of FCFS SAVI in the topology\n
      \  depicted in the following figure:\n                                                +--------+\n
      \     +--+   +--+                          +--+ | +--+   |\n      |H1|   |H2|
      \                         |H3| | |R1|   |\n      +--+   +--+                          +--+
      | +--+   |\n        |     |                              |  |  |     |\n   +-------------SAVI-PROTECTION-PERIMETER------+
      \ |     |\n   |    |     |                              |     |     |\n   |
      \ +-1-----2-+                          +-1-----2-+   |\n   |  |  SAVI1  |                          |
      \ SAVI2  |   |\n   |  +-3--4----+                          +--3------+   |\n
      \  |    |  |          +--------------+        |          |\n   |    |  +----------|
      \             |--------+          |\n   |    |             |   SWITCH-A   |
      \                  |\n   |    |  +----------|              |--------+          |\n
      \  |    |  |          +--------------+        |          |\n   |  +-1--2----+
      \                         +--1------+   |\n   |  |  SAVI3  |                          |
      \ SAVI4  |   |\n   |  +-3-----4-+                          +----4----+   |\n
      \  |    |     |                                 |        |\n   |      +------SAVI-PROTECTION-PERIMETER---------------+\n
      \  |    | |   |                                 |\n   |  +--+|  +--+                            +---------+\n
      \  |  |R2||  |H4|                            |SWITCH-B |\n   |  +--+|  +--+
      \                           +---------+\n   +------+                                    |
      \   |\n                                             +--+  +--+\n                                             |H5|
      \ |H6|\n                                             +--+  +--+\n                    Figure
      1: SAVI Protection Perimeter\n   In Figure 1, the FCFS SAVI protection perimeter
      is provided by four\n   FCFS SAVI devices, namely SAVI1, SAVI2, SAVI3, and SAVI4.
      \ These\n   devices verify the source address and filter packets accordingly.\n
      \  FCFS SAVI devices then have two types of ports: Trusted Ports and\n   Validating
      Ports.\n   o  Validating Ports (VPs) are those in which FCFS SAVI processing
      is\n      performed.  When a packet is received through one of the\n      Validating
      Ports, FCFS SAVI processing and filtering will be\n      executed.\n   o  Trusted
      Ports (TPs) are those in which FCFS SAVI processing is not\n      performed.
      \ So, packets received through Trusted Ports are not\n      validated, and no
      FCFS SAVI processing is performed on them.\n   Trusted Ports are used for connections
      with trusted infrastructure,\n   including the communication between FCFS SAVI
      devices, the\n   communication with routers, and the communication of other
      switches\n   that, while not FCFS SAVI devices, only connect to trusted\n   infrastructure
      (i.e., other FCFS SAVI devices, routers, or other\n   trusted nodes).  So, in
      Figure 1, Port 3 of SAVI1 and Port 1 of SAVI3\n   are trusted because they connect
      two FCFS SAVI devices.  Port 4 of\n   SAVI1, Port 3 of SAVI2, Port 2 of SAVI3,
      and Port 1 of SAVI4 are\n   trusted because they connect to SWITCH-A, to which
      only trusted nodes\n   are connected.  In Figure 1, Port 2 of SAVI2 and Port
      3 of SAVI3 are\n   Trusted Ports because they connect to routers.\n   Validating
      Ports are used for connection with non-trusted\n   infrastructure.  In particular,
      hosts are normally connected to\n   Validating Ports.  Non-SAVI switches that
      are outside of the FCFS\n   SAVI protection perimeter also are connected through
      Validating\n   Ports.  In particular, non-SAVI devices that connect directly
      to\n   hosts or that have no SAVI-capable device between themselves and the\n
      \  hosts are connected through a Validating Port.  So, in Figure 1,\n   Ports
      1 and 2 of SAVI1, Port 1 of SAVI2, and Port 4 of SAVI 3 are\n   Validating Ports
      because they connect to hosts.  Port 4 of SAVI4 is\n   also a Validating Port
      because it is connected to SWITCH-B, which is\n   a non-SAVI-capable switch
      that is connected to hosts H5 and H6.\n"
    title: 2.5.  FCFS SAVI Protection Perimeter
  - contents:
    - "2.6.  Special Cases\n   Multi-subnet links: In some cases, a given subnet may
      have several\n   prefixes.  This is directly supported by SAVI as any port can
      support\n   multiple prefixes.  Forwarding of packets between different prefixes\n
      \  involving a router is even supported, as long as the router is\n   connected
      to a Trusted Port, as recommended for all the routers.\n   Multihomed hosts:
      A multihomed host is a host with multiple\n   interfaces.  The interaction between
      SAVI and multihomed hosts is as\n   follows.  If the different interfaces of
      the host are assigned\n   different IP addresses and packets sent from each
      interface always\n   carry the address assigned to that interface as the source
      address,\n   then from the perspective of a SAVI device, this is equivalent
      to two\n   hosts with a single interface, each with an IP address.  This is\n
      \  supported by SAVI without the need for additional considerations.  If\n   the
      different interfaces share the same IP address or if the\n   interfaces have
      different addresses but the host sends packets using\n   the address of one
      of the interfaces through any of the interfaces,\n   then SAVI does not directly
      support it.  It would require either\n   connecting at least one interface of
      the multihomed host to a Trusted\n   Port or manually configuring the SAVI bindings
      to allow binding the\n   address of the multihomed host to multiple anchors
      simultaneously.\n   Untrusted routers: One can envision scenarios where routers
      are\n   dynamically attached to an FCFS SAVI network.  A typical example\n   would
      be a mobile phone connecting to an FCFS SAVI switch where the\n   mobile phone
      is acting as a router for other personal devices that\n   are accessing the
      network through it.  In this case, the router does\n   not seem to directly
      fall in the category of trusted infrastructure\n   (if this was the case, it
      is likely that all devices would be\n   trusted); hence, it cannot be connected
      to a Trusted Port and if it\n   is connected to a Validating Port, the FCFS
      SAVI switch would discard\n   all the packets containing an off-link source
      address coming from\n   that device.  As a result, the default recommendation
      specified in\n   this specification does not support such a scenario.\n"
    title: 2.6.  Special Cases
  title: 2.  Background to FCFS SAVI
- contents:
  - '3.  FCFS SAVI Specification

    '
  - contents:
    - "3.1.  FCFS SAVI Data Structures\n   The FCFS SAVI function relies on state
      information binding the source\n   address used in data packets to the binding
      anchor that contained the\n   first packet that used that source IP address.
      \ Such information is\n   stored in an FCFS SAVI database (DB).  The FCFS SAVI
      DB will contain\n   a set of entries about the currently used IP source addresses.
      \ Each\n   entry will contain the following information:\n   o  IP source address\n
      \  o  Binding anchor: port through which the packet was received\n   o  Lifetime\n
      \  o  Status: either TENTATIVE, VALID, TESTING_VP, or TESTING_TP-LT\n   o  Creation
      time: the value of the local clock when the entry was\n      firstly created\n
      \  In addition, FCFS SAVI needs to know what prefixes are directly\n   connected,
      so it maintains a data structure called the FCFS SAVI\n   Prefix List, which
      contains:\n   o  Prefix\n   o  Interface where prefix is directly connected\n"
    title: 3.1.  FCFS SAVI Data Structures
  - contents:
    - '3.2.  FCFS SAVI Algorithm

      '
    - contents:
      - "3.2.1.  Discovering On-Link Prefixes\n   In order to distinguish local traffic
        from transit traffic, the FCFS\n   SAVI device relies on the FCFS SAVI Prefix
        List, which contains the\n   set of on-link IPv6 prefixes.  An FCFS SAVI device
        MUST support the\n   following two methods for populating the Prefix List:
        manual\n   configuration and Router Advertisement, as detailed next.\n   Manual
        configuration: An FCFS SAVI device MUST support manual\n   configuration of
        the on-link prefixes included in the Prefix List.\n   For example, this can
        be used when there are no prefixes being\n   advertised on the link.\n   Router
        Advertisement: An FCFS SAVI device MUST support discovery of\n   on-link prefixes
        through Router Advertisement messages in Trusted\n   Ports.  For Trusted Ports,
        the FCFS SAVI device will learn the on-\n   link prefixes following the procedure
        defined for a host to process\n   the Prefix Information options described
        in Section 6.3.4 of\n   [RFC4861] with the difference that the prefixes will
        be configured in\n   the FCFS SAVI Prefix List rather than in the ND Prefix
        List.  In\n   addition, when the FCFS SAVI device boots, it MUST send a Router\n
        \  Solicitation message as described in Section 6.3.7 of [RFC4861],\n   using
        the unspecified source address.\n"
      title: 3.2.1.  Discovering On-Link Prefixes
    - contents:
      - "3.2.2.  Processing of Transit Traffic\n   The FCFS SAVI function is located
        in a forwarding device, such as a\n   router or a Layer 2 switch.  The following
        processing is performed\n   depending on the type of port through which the
        packet has been\n   received:\n   o  If the data packet is received through
        a Trusted Port, the data\n      packet is forwarded, and no SAVI processing
        performed on the\n      packet.\n   o  If the data packet is received through
        a Validating Port, then the\n      FCFS SAVI function checks whether the received
        data packet is\n      local traffic or transit traffic.  It does so by verifying
        if the\n      source address of the packet belongs to one of the directly\n
        \     connected prefixes available in the receiving interface.  It does\n
        \     so by searching the FCFS SAVI Prefix List.\n      *  If the IP source
        address does not belong to one of the on-link\n         prefixes of the receiving
        interface, the data packet is transit\n         traffic, and the packet SHOULD
        be discarded.  (If for some\n         reason, discarding the packets is not
        acceptable, logging or\n         triggering of alarms MAY be used).  The FCFS
        SAVI function MAY\n         send an ICMP Destination Unreachable Error back
        to the source\n         address of the data packet, and ICMPv6, code 5 (Source
        address\n         failed ingress/egress policy), should be used.\n      *
        \ If the source address of the packet does belong to one of the\n         prefixes
        available in the receiving port, then the FCFS SAVI\n         local traffic
        validation process is executed as described\n         below.\n      *  If
        the source address of the packet is an unspecified address,\n         the
        packet is forwarded, and no SAVI processing is performed\n         except
        for the case of the Neighbor Solicitation messages\n         involved in the
        Duplicate Address Detection, which are treated\n         as described in Section
        3.2.3.\n"
      title: 3.2.2.  Processing of Transit Traffic
    - contents:
      - "3.2.3.  Processing of Local Traffic\n   We next describe how local traffic,
        including both control and data\n   packets, is processed by the FCFS SAVI
        device using a state machine\n   approach.\n   The state machine described
        is for the binding of a given source IP\n   address (called IPAddr) in a given
        FCFS SAVI device.  This means that\n   all the packets described as inputs
        in the state machine above refer\n   to that given IP address.  In the case
        of data packets, the source\n   address of the packet is IPAddr.  In the case
        of the DAD_NS packets,\n   the Target Address is IPAddr.  The key attribute
        is the IP address.\n   The full state information is as follows:\n   o  IP
        ADDRESS: IPAddr\n   o  BINDING ANCHOR: P\n   o  LIFETIME: LT\n   The possible
        states are as follows:\n   o  NO_BIND\n   o  TENTATIVE\n   o  VALID\n   o
        \ TESTING_TP-LT\n   o  TESTING_VP\n   We will use VP for Validating Port and
        TP for Trusted Port.\n   After bootstrapping (when no binding exists), the
        state for all\n   source IP addresses is NO-BIND, i.e., there is no binding
        for the IP\n   address to any binding anchor.\n   NO_BIND: The binding for
        a source IP address entry is in this state\n   when it does not have any binding
        to an anchor.  All addresses are in\n   this state by default after bootstrapping,
        unless bindings were\n   created for them.\n   TENTATIVE: The binding for
        a source address for which a data packet\n   or an NS generated by the Duplicate
        Address Detection (DAD) procedure\n   has been received is in this state during
        the waiting period during\n   which the DAD procedure is being executed (either
        by the host itself\n   or the FCFS SAVI device on its behalf).\n   VALID:
        The binding for the source address is in this state after it\n   has been
        verified.  It means that it is valid and usable for\n   filtering traffic.\n
        \  TESTING_TP-LT: A binding for a source address enters this state due\n   to
        one of two reasons:\n   o  When a Duplicate Address Detection Neighbor Solicitation
        has been\n      received through a Trusted Port.  This implies that a host
        is\n      performing the DAD procedure for that source address in another\n
        \     switch.  This may be due to an attack or to the fact that the host\n
        \     may have moved.  The binding in this state is then being tested to\n
        \     determine which is the situation.\n   o  The lifetime of the binding
        entry is about to expire.  This is due\n      to the fact that no packets
        have been seen by the FCFS SAVI device\n      for the LIFETIME period.  This
        may be due to the host simply being\n      silent or because the host has
        left the location.  In order to\n      determine which is the case, a test
        is performed to determine if\n      the binding information should be discarded.\n
        \  TESTING_VP: A binding for a source address enters this state when a\n   Duplicate
        Address Detection Neighbor Solicitation or a data packet\n   has been received
        through a Validating Port other than the one\n   address to which it is currently
        bound.  This implies that a host is\n   performing the DAD procedure for that
        source address through a\n   different port.  This may be due to an attack,
        the fact that the host\n   may have moved, or just because another host tries
        to configure an\n   address already used.  The binding in this state is then
        being tested\n   to determine which is the situation.\n   Next, we describe
        how the different inputs are processed depending on\n   the state of the binding
        of the IP address (IPAddr).\n   A simplified figure of the state machine is
        included in Figure 2\n   below.\n   NO_BIND\n   o  Upon the reception through
        a Validating Port (VP) of a Neighbor\n      Solicitation (NS) generated by
        the Duplicate Address Detection\n      (DAD) procedure (hereafter named DAD_NS)
        containing Target Address\n      IPAddr, the FCFS SAVI device MUST forward
        the NS, and T_WAIT\n      milliseconds later, it MUST send a copy of the same
        message.\n      These DAD_NS messages are not sent through any of the ports\n
        \     configured as Validating Ports.  The DAD_NS messages are sent\n      through
        the Trusted Ports (but, of course, subject to usual switch\n      behavior
        and possible Multicast Listener Discovery (MLD) snooping\n      optimizations).
        \ The state is moved to TENTATIVE.  The LIFETIME is\n      set to TENT_LT
        (i.e., LT:=TENT_LT), the BINDING ANCHOR is set to\n      VP (i.e., P:=VP),
        and the Creation time is set to the current\n      value of the local clock.\n
        \  o  Upon the reception through a Validating Port (VP) of a DATA packet\n
        \     containing IPAddr as the source address, the SAVI device SHOULD\n      execute
        the process of sending Neighbor Solicitation messages of\n      the Duplicate
        Address Detection process as described in Section\n      5.4.2 of [RFC4862]
        for the IPAddr using the following default\n      parameters: DupAddrDetectTransmits
        set to 2 (i.e., 2 Neighbor\n      Solicitation messages for that address will
        be sent by the SAVI\n      device) and RetransTimer set to T_WAIT milliseconds
        (i.e., the\n      time between two Neighbor Solicitation messages is T_WAIT\n
        \     milliseconds).  The implications of not following the recommended\n
        \     behavior are described in Appendix A.  The DAD_NS messages are not\n
        \     sent through any of the ports configured as Validating Ports.  The\n
        \     DAD_NSOL messages are sent through Trusted Ports (but, of course,\n
        \     subject to usual switch behavior and possible MLD snooping\n      optimizations).
        \ The SAVI device MAY discard the data packets\n      while the DAD procedure
        is being executed, or it MAY store them\n      until the binding is created.
        \ In any case, it MUST NOT forward\n      the data packets until the binding
        has been verified.  The state\n      is moved to TENTATIVE.  The LIFETIME
        is set to TENT_LT (i.e., LT:\n      =TENT_LT), the BINDING ANCHOR is set to
        VP (i.e., P:=VP), and the\n      Creation time is set to the current value
        of the local clock.\n   o  Data packets containing IPAddr as the source address
        received\n      through Trusted Ports are processed and forwarded as usual
        (i.e.,\n      no special SAVI processing).\n   o  DAD_NS packets containing
        IPAddr as the Target Address that are\n      received through a Trusted Port
        MUST NOT be forwarded through any\n      of the Validating Ports, but they
        are sent through the Trusted\n      Ports (but, of course, subject to usual
        switch behavior and\n      possible MLD snooping optimizations).\n   o  Neighbor
        Advertisement packets sent to all nodes as a reply to the\n      DAD_NS (hereafter
        called DAD_NA) containing IPAddr as the Target\n      Address coming through
        a Validating Port are discarded.\n   o  Other signaling packets are processed
        and forwarded as usual\n      (i.e., no SAVI processing).\n   TENTATIVE\n
        \  o  If the LIFETIME times out, the state is moved to VALID.  The\n      LIFETIME
        is set to DEFAULT_LT (i.e., LT:= DEFAULT_LT).  Stored\n      data packets
        (if any) are forwarded.\n   o  If a Neighbor Advertisement (NA) is received
        through a Trusted\n      Port with the Target Address set to IPAddr, then
        the message is\n      forwarded through port P, the state is set to NO_BIND,
        and the\n      BINDING ANCHOR and the LIFETIME are cleared.  Data packets
        stored\n      corresponding to this binding are discarded.\n   o  If an NA
        is received through a Validating Port with the Target\n      Address set to
        IPAddr, the NA packet is discarded\n   o  If a data packet with source address
        IPAddr is received with\n      binding anchor equal to P, then the packet
        is either stored or\n      discarded.\n   o  If a data packet with source
        address IPAddr is received through a\n      Trusted Port, the data packet
        is forwarded.  The state is\n      unchanged.\n   o  If a data packet with
        source address IPAddr is received through a\n      Validating Port other than
        P, the data packet is discarded.\n   o  If a DAD_NS is received from a Trusted
        Port, with the Target\n      Address set to IPAddr, then the message is forwarded
        to the\n      Validating Port P, the state is set to NO_BIND, and the BINDING\n
        \     ANCHOR and LIFETIME are cleared.  Data packets stored\n      corresponding
        to this binding are discarded.\n   o  If a DAD_NS with the Target Address
        set to IPAddr is received from\n      a Validating Port P' other than P, the
        message is forwarded to the\n      Validating Port P and to the Trusted Ports,
        and the state remains\n      in TENTATIVE; however, the BINDING ANCHOR is
        changed from P to P',\n      and LIFETIME is set to TENT_LT.  Data packets
        stored corresponding\n      to the binding with P are discarded.\n   o  Other
        signaling packets are processed and forwarded as usual\n      (i.e., no SAVI
        processing).\n   VALID\n   o  If a data packet containing IPAddr as the source
        address arrives\n      from Validating Port P, then the LIFETIME is set to
        DEFAULT_LT and\n      the packet is forwarded as usual.\n   o  If a DAD_NS
        is received from a Trusted Port, then the DAD_NS\n      message is forwarded
        to port P and is also forwarded to the\n      Trusted Ports (but, of course,
        subject to usual switch behavior\n      and possible MLD snooping optimizations).
        \ The state is changed to\n      TESTING_TP-LT.  The LIFETIME is set to TENT_LT.\n
        \  o  If a data packet containing source address IPAddr or a DAD_NA\n      packet
        with the Target Address set to IPAddr is received through a\n      Validating
        Port P' other than P, then the SAVI device will execute\n      the process
        of sending DAD_NS messages as described in Section\n      5.4.2 of [RFC4862]
        for the IPAddr using the following default\n      parameters: DupAddrDetectTransmits
        set to 2 (i.e., two NS messages\n      for that address will be sent by the
        SAVI device) and RetransTimer\n      set to T_WAIT milliseconds (i.e., the
        time between two NS messages\n      is T_WAIT milliseconds).  The DAD_NS message
        will be forwarded to\n      the port P.  The state is moved to TESTING_VP.
        \ The LIFETIME is\n      set to TENT_LT.  The SAVI device MAY discard the
        data packet while\n      the DAD procedure is being executed, or it MAY store
        them until\n      the binding is created.  In any case, it MUST NOT forward
        the data\n      packets until the binding has been verified.\n   o  If a DAD_NS
        packet with the Target Address set to IPAddr is\n      received through a
        Validating Port P' other than P, then the SAVI\n      device will forward
        the DAD_NS packet, and T_WAIT milliseconds\n      later, it will execute the
        process of sending DAD_NS messages as\n      described in Section 5.4.2 of
        [RFC4862] for the IPAddr using the\n      following default parameters: DupAddrDetectTransmits
        set to 1 and\n      RetransTimer set to T_WAIT milliseconds.  The DAD_NS messages
        will\n      be forwarded to the port P.  The state is moved to TESTING_VP.\n
        \     The LIFETIME is set to TENT_LT.  The SAVI device MAY discard the\n      data
        packets while the DAD procedure is being executed, or it MAY\n      store
        them until the binding is created.  In any case, it MUST NOT\n      forward
        the data packets until the binding has been verified.\n   o  If the LIFETIME
        expires, then the SAVI device will execute the\n      process of sending DAD_NS
        messages as described in Section 5.4.2\n      of [RFC4862] for the IPAddr
        using the following default\n      parameters: DupAddrDetectTransmits set
        to 2 (i.e., two NS messages\n      for that address will be sent by the SAVI
        device) and RetransTimer\n      set to T_WAIT milliseconds (i.e., the time
        between two NS messages\n      is T_WAIT milliseconds).  The DAD_NS messages
        will be forwarded to\n      the port P.  The state is changed to TESTING_TP-LT,
        and the\n      LIFETIME is set to TENT_LT.\n   o  If a data packet containing
        IPAddr as a source address arrives\n      from Trusted Port, the packet MAY
        be discarded.  The event MAY be\n      logged.\n   o  Other signaling packets
        are processed and forwarded as usual\n      (i.e., no SAVI processing).  In
        particular, a DAD_NA coming from\n      port P and containing IPAddr as the
        Target Address is forwarded as\n      usual.\n   TESTING_TP-LT\n   o  If the
        LIFETIME expires, the BINDING ANCHOR is cleared, and the\n      state is changed
        to NO_BIND.\n   o  If an NA message containing the IPAddr as the Target Address
        is\n      received through the Validating Port P as a reply to the DAD_NS\n
        \     message, then the NA is forwarded as usual, and the state is\n      changed
        to VALID.  The LIFETIME is set to DEFAULT_LT\n   o  If a data packet containing
        IPAddr as the source address is\n      received through port P, then the packet
        is forwarded and the\n      state is changed to VALID.  The LIFETIME is set
        to DEFAULT_LT.\n   o  If a DAD_NS is received from a Trusted Port, the DAD_NS
        is\n      forwarded as usual.\n   o  If a DAD_NS is received from a Validating
        Port P' other than P,\n      the DAD_NS is forwarded as usual, and the state
        is moved to\n      TESTING_VP.\n   o  If a data packet is received through
        a Validating Port P' that is\n      other than port P, then the packet is
        discarded.\n   o  If a data packet is received through a Trusted Port, then
        the\n      packet MAY be discarded.  The event MAY be logged.\n   TESTING_VP\n
        \  o  If the LIFETIME expires, the BINDING ANCHOR is modified from P to\n
        \     P', the LIFETIME is set to DEFAULT_LT, and the state is changed to\n
        \     VALID.  Stored data packet coming from P' are forwarded.\n   o  If an
        NA message containing the IPAddr as the Target Address is\n      received
        through the Validating Port P as a reply to the DAD_NS\n      message, then
        the NA is forwarded as usual and the state is\n      changed to VALID.  The
        LIFETIME is set to DEFAULT_LT.\n   o  If a data packet containing IPAddr as
        the source address is\n      received through port P, then the packet is forwarded.\n
        \  o  If a data packet containing IPAddr as the source address is\n      received
        through a Validating Port P'' that is other than port P\n      or P', then
        the packet is discarded.\n   o  If a data packet containing IPAddr as the
        source address is\n      received through a Trusted Port (i.e., other than
        port P), the\n      state is moved to TESTING_TP-LT, and the packet MAY be
        discarded.\n   o  If a DAD_NS is received through a Trusted Port, the packet
        is\n      forwarded as usual, and the state is moved to TESTING_TP-LT.\n   o
        \ If a DAD_NS is received through Validating Port P'' other than P\n      or
        P', the packet is forwarded as usual, and P'' is stored as the\n      tentative
        port, i.e., P':=P''.  The state remains the same.\n   +---------+  VP_NS,
        VP_DATA/2xNS                    +-----------+\n   |         |---------------------------------------->|
        \          |\n   | NO_BIND |                                         | TENTATIVE
        |\n   |         |<----------------------------------------|           |\n
        \  +---------+                    TP_NA, TP_NS/-       +-----------+\n          ^
        \                                               |\n          |                                                |
        TimeOut\n   Timeout|                                                |\n          |
        \                                               v\n   +---------+  VP_NA/-
        \                               +-----------+\n   |         |---------------------------------------->|
        \          |\n   | TESTING |                                TP_NS/-  |           |\n
        \  |  TP-LT  |<----------------------------------------|   VALID   |\n   |
        \        |                           TimeOut/2xNS  |           |\n   |         |<----------------------------------------|
        \          |\n   +---------+                                         +-----------+\n
        \    ^   |                                                ^    |\n     |   |
        \                                               |    |\n     |   +---------------------
        \     ---------------------+    |\n     |       VP_NS/-          |     |  NP_NA,
        TimeOut/-        |\n     |                        v     |                          |\n
        \    |                     +-----------+                       |\n     |                     |
        \          |                       |\n     +---------------------|  TESTING
        \ |<----------------------+\n          VP_NS, VP_DATA/- |    VP     |  VP_DATA,
        VP_NS,\n                           +-----------+  VP_NA/2xNS\n                    Figure
        2: Simplified State Machine\n   MLD Considerations\n   The FCFS SAVI device
        MUST join the solicited node multicast group for\n   all the addresses with
        a state other than NO_BIND.  This is needed to\n   make sure that the FCFS
        SAVI device will receive the DAD_NS for those\n   addresses.  Please note
        that it may not be enough to rely on the host\n   behind the Validating Port
        to do so, since the node may move, and\n   after a while, the packets for
        that particular solicited node\n   multicast group will no longer be forwarded
        to the FCFS SAVI device.\n   Therefore, the FCFS SAVI device MUST join the
        solicited node\n   multicast groups for all the addresses that are in a state
        other than\n   NO_BIND.\n"
      title: 3.2.3.  Processing of Local Traffic
    - contents:
      - "3.2.4.  FCFS SAVI Port Configuration Guidelines\n   The guidelines for port
        configuration in FCFS SAVI devices are as\n   follows:\n   o  The FCFS SAVI
        realm (i.e., the realm that is inside the FCFS SAVI\n      protection perimeter)
        MUST be connected.  If this is not the case,\n      legitimate transit traffic
        may be dropped.\n   o  Ports that are connected to another FCFS SAVI device
        MUST be\n      configured as Trusted Ports.  Not doing so will significantly\n
        \     increase the memory consumption in the FCFS SAVI devices and may\n      result
        in legitimate transit traffic being dropped.\n   o  Ports connected to hosts
        SHOULD be configured as Validating Ports.\n      Not doing so will allow the
        host connected to that port to send\n      packets with spoofed source addresses.
        \ A valid exception is the\n      case of a trusted host (e.g., a server)
        that could be connected to\n      a Trusted Port, but untrusted hosts MUST
        be connected to\n      Validating Ports.\n   o  Ports connected to routers
        MUST be configured as Trusted Ports.\n      Configuring them as Validating
        Ports should result in transit\n      traffic being dropped.\n   o  Ports
        connected to a chain of one or more legacy switches that\n      have hosts
        connected SHOULD be configured as Validating Ports.\n      Not doing so will
        allow the host connected to any of these\n      switches to send packets with
        spoofed source addresses.  A valid\n      exception is the case where the
        legacy switch only has trusted\n      hosts attached, in which case it could
        be connected to a Trusted\n      Port, but if there is at least one untrusted
        hosts connected to\n      the legacy switch, then it MUST be connected to
        Validating Ports.\n   o  Ports connected to a chain of one or more legacy
        switches that\n      have other FCFS SAVI devices and/or routers connected
        but had no\n      hosts attached to them MUST be configured as Trusted Ports.
        \ Not\n      doing so will at least significantly increase the memory\n      consumption
        in the FCFS SAVI devices, increase the signaling\n      traffic due to FCFS
        SAVI validation, and may result in legitimate\n      transit traffic being
        dropped.\n"
      title: 3.2.4.  FCFS SAVI Port Configuration Guidelines
    - contents:
      - "3.2.5.  VLAN Support\n   If the FCFS SAVI device is a switch that supports
        customer VLANs\n   [IEEE.802-1Q.2005], the FCFS SAVI implementation MUST behave
        as if\n   there was one FCFS SAVI process per customer VLAN.  The FCFS SAVI\n
        \  process of each customer VLAN will store the binding information\n   corresponding
        to the nodes attached to that particular customer VLAN.\n"
      title: 3.2.5.  VLAN Support
    title: 3.2.  FCFS SAVI Algorithm
  - contents:
    - "3.3.  Default Protocol Values\n   Following are the default values used in
      the FCFS SAVI specification.\n   TENT_LT is 500 milliseconds\n   DEFAULT_LT
      is 5 minutes\n   T_WAIT is 250 milliseconds\n   An implementation MAY allow
      these values to be modified, but tuning\n   them precisely is considered out
      of the scope of this document.\n"
    title: 3.3.  Default Protocol Values
  title: 3.  FCFS SAVI Specification
- contents:
  - '4.  Security Considerations

    '
  - contents:
    - "4.1.  Denial-of-Service Attacks\n   There are two types of Denial-of-Service
      (DoS) attacks [RFC4732] that\n   can be envisaged in an FCFS SAVI environment.
      \ On one hand, we can\n   envision attacks against the FCFS SAVI device resources.
      \ On the\n   other hand, we can envision DoS attacks against the hosts connected\n
      \  to the network where FCFS SAVI is running.\n   The attacks against the FCFS
      SAVI device basically consist of making\n   the FCFS SAVI device consume its
      resources until it runs out of them.\n   For instance, a possible attack would
      be to send packets with\n   different source addresses, making the FCFS SAVI
      device create state\n   for each of the addresses and waste memory.  At some
      point, the FCFS\n   SAVI device runs out of memory and needs to decide how to
      react.  The\n   result is that some form of garbage collection is needed to
      prune the\n   entries.  When the FCFS SAVI device runs out of the memory allocated\n
      \  for the FCFS SAVI DB, it is RECOMMENDED that it create new entries by\n   deleting
      the entries with a higher Creation time.  This implies that\n   older entries
      are preserved and newer entries overwrite each other.\n   In an attack scenario
      where the attacker sends a batch of data\n   packets with different source addresses,
      each new source address is\n   likely to rewrite another source address created
      by the attack\n   itself.  It should be noted that entries are also garbage
      collected\n   using the LIFETIME, which is updated using data packets.  The
      result\n   is that in order for an attacker to actually fill the FCFS SAVI DB\n
      \  with false source addresses, it needs to continuously send data\n   packets
      for all the different source addresses so that the entries\n   grow old and
      compete with the legitimate entries.  The result is that\n   the cost of the
      attack is highly increased for the attacker.\n   In addition, it is RECOMMENDED
      that an FCFS SAVI device reserves a\n   minimum amount of memory for each available
      port (in the case where\n   the port is used as part of the L2 anchor).  The
      recommended minimum\n   is the memory needed to store four bindings associated
      with the port.\n   The motivation for this recommendation is as follows.  An
      attacker\n   attached to a given port of an FCFS SAVI device may attempt to
      launch\n   a DoS attack towards the FCFS SAVI device by creating many bindings\n
      \  for different addresses.  It can do so by sending DAD_NS for\n   different
      addresses.  The result is that the attack will consume all\n   the memory available
      in the FCFS SAVI device.  The above\n   recommendation aims to reserve a minimum
      amount of memory per port,\n   so that hosts located in different ports can
      make use of the reserved\n   memory for their port even if a DoS attack is occurring
      in a\n   different port.\n   As the FCFS SAVI device may store data packets
      while the address is\n   being verified, the memory for data packet storage
      may also be a\n   target of DoS attacks.  The effects of such attacks may be
      limited to\n   the lack of capacity to store new data packets.  The effect of
      such\n   attacks will be that data packets will be dropped during the\n   verification
      period.  An FCFS SAVI device MUST limit the amount of\n   memory used to store
      data packets, allowing the other functions to\n   have available memory even
      in the case of attacks such those\n   described above.\n   The FCFS SAVI device
      generates two DAD_NS packets upon the reception\n   of a DAD_NS or a data packet.
      \ As such, the FCFS SAVI device can be\n   used as an amplifier by attackers.
      \ In order to limit this type of\n   attack, the FCFS SAVI device MUST perform
      rate limiting of the\n   messages it generates.  Rate limiting is performed
      on a per-port\n   basis, since having an attack on a given port should not prevent
      the\n   FCFS SAVI device from functioning normally in the rest of the ports.\n"
    title: 4.1.  Denial-of-Service Attacks
  - contents:
    - "4.2.  Residual Threats\n   FCFS SAVI performs its function by binding an IP
      source address to a\n   binding anchor.  If the attacker manages to send packets
      using the\n   binding anchor associated to a given IP address, FCFS SAVI validation\n
      \  will be successful, and the FCFS SAVI device will allow the packet\n   through.
      \ This can be achieved by spoofing the binding anchor or by\n   sharing of the
      binding anchor between the legitimate owner of the\n   address and the attacker.
      \ An example of the latter is the case where\n   the binding anchor is a port
      of a switched network and a legacy\n   switch (i.e., not a SAVI-capable switch)
      is connected to that port.\n   All the source addresses of the hosts connected
      to the legacy switch\n   will share the same binding anchor (i.e., the switch
      port).  This\n   means that hosts connected to the legacy switch can spoof each\n
      \  other's IP address and will not be detected by the FCFS SAVI device.\n   This
      can be prevented by not sharing binding anchors among hosts.\n   FCFS SAVI assumes
      that a host will be able to defend its address when\n   the DAD procedure is
      executed for its addresses.  This is needed,\n   among other things, to support
      mobility within a link (i.e., to allow\n   a host to detach and reconnect to
      a different Layer 2 anchor of the\n   same IP subnetwork without changing its
      IP address).  So, when a\n   DAD_NS is issued for a given IP address for which
      a binding exists in\n   an FCFS SAVI device, the FCFS SAVI device expects to
      see a DAD_NA\n   coming from the binding anchor associated to that IP address
      in order\n   to preserve the binding.  If the FCFS SAVI device does not see
      the\n   DAD_NA, it may grant the binding to a different binding anchor.  This\n
      \  means that if an attacker manages to prevent a host from defending\n   its
      source address, it will be able to destroy the existing binding\n   and create
      a new one, with a different binding anchor.  An attacker\n   may do so, for
      example, by intercepting the DAD_NA or launching a DoS\n   attack to the host
      that will prevent it from issuing proper DAD\n   replies.\n   Even if routers
      are considered trusted, nothing can prevent a router\n   from being compromised
      and sending traffic with spoofed IP source\n   addresses.  Such traffic would
      be allowed with the present FCFS SAVI\n   specification.  A way to mitigate
      this issue could be to specify a\n   new port type (e.g., Router Port (RP))
      that would act as Trusted Port\n   for the transit traffic and as Validating
      Port for the local traffic.\n   A detailed solution about this issue is outside
      the scope of this\n   document.\n"
    title: 4.2.  Residual Threats
  - contents:
    - "4.3.  Privacy Considerations\n   Personally identifying information MUST NOT
      be included in the FCFS\n   SAVI DB with the MAC address as the canonical example,
      except when\n   there is an attack attempt involved.  Moreover, compliant\n
      \  implementations MUST NOT log binding anchor information except where\n   there
      is an identified reason why that information is likely to be\n   involved in
      detection, prevention, or tracing of actual source\n   address spoofing.  Information
      that is not logged MUST be deleted as\n   soon as possible (i.e., as soon as
      the state for a given address is\n   back to NO_BIND).  Information about the
      majority of hosts that never\n   spoof SHOULD NOT be logged.\n"
    title: 4.3.  Privacy Considerations
  - contents:
    - "4.4.  Interaction with Secure Neighbor Discovery\n   Even if the FCFS SAVI
      could get information from ND messages secured\n   with Secure Neighbor Discovery
      (SEND) [RFC3971], in some case, the\n   FCFS SAVI device must spoof DAD_NS messages
      but doesn't know the\n   security credentials associated with the IPAddr (i.e.,
      the private\n   key used to sign the DAD_NS messages).  So, when SEND is deployed,
      it\n   is recommended to use SEND SAVI [SAVI-SEND] rather than FCFS SAVI.\n"
    title: 4.4.  Interaction with Secure Neighbor Discovery
  title: 4.  Security Considerations
- contents:
  - "5.  Contributors\n   Jun Bi\n   CERNET\n   Network Research Center, Tsinghua
    University\n   Beijing 100084\n   China\n   EMail: junbi@cernet.edu.cn\n   Guang
    Yao\n   CERNET\n   Network Research Center, Tsinghua University\n   Beijing 100084\n
    \  China\n   EMail: yaog@netarchlab.tsinghua.edu.cn\n   Fred Baker\n   Cisco Systems\n
    \  EMail: fred@cisco.com\n   Alberto Garcia Martinez\n   University Carlos III
    of Madrid\n   EMail: alberto@it.uc3m.es\n"
  title: 5.  Contributors
- contents:
  - "6.  Acknowledgments\n   This document benefited from the input of the following
    individuals:\n   Joel Halpern, Christian Vogt, Dong Zhang, Frank Xia, Jean-Michel\n
    \  Combes, Jari Arkko, Stephen Farrel, Dan Romascanu, Russ Housley, Pete\n   Resnick,
    Ralph Droms, Wesley Eddy, Dave Harrington, and Lin Tao.\n   Marcelo Bagnulo is
    partly funded by Trilogy, a research project\n   supported by the European Commission
    under its Seventh Framework\n   Program.\n"
  title: 6.  Acknowledgments
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC2827]   Ferguson, P. and D. Senie, \"Network Ingress Filtering:\n
      \              Defeating Denial of Service Attacks which employ IP\n               Source
      Address Spoofing\", BCP 38, RFC 2827, May 2000.\n   [RFC4861]   Narten, T.,
      Nordmark, E., Simpson, W., and H. Soliman,\n               \"Neighbor Discovery
      for IP version 6 (IPv6)\", RFC 4861,\n               September 2007.\n   [RFC4862]
      \  Thomson, S., Narten, T., and T. Jinmei, \"IPv6 Stateless\n               Address
      Autoconfiguration\", RFC 4862, September 2007.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [SAVI-FRAMEWORK]\n               Wu, J., Bi,
      J., Bagnulo, M., Baker, F., and C. Vogt,\n               \"Source Address Validation
      Improvement Framework\", Work\n               in Progress, December 2011.\n
      \  [SAVI-DHCP] Bi, J., Wu, J., Yao, G., and F. Baker, \"SAVI Solution for\n
      \              DHCP\", Work in Progress, February 2012.\n   [SAVI-SEND] Bagnulo,
      M. and A. Garcia-Martinez, \"SEND-based Source-\n               Address Validation
      Implementation\", Work in Progress,\n               March 2012.\n   [RFC1958]
      \  Carpenter, B., \"Architectural Principles of the\n               Internet\",
      RFC 1958, June 1996.\n   [RFC3971]   Arkko, J., Kempf, J., Zill, B., and P.
      Nikander, \"SEcure\n               Neighbor Discovery (SEND)\", RFC 3971, March
      2005.\n   [RFC4732]   Handley, M., Rescorla, E., and IAB, \"Internet Denial-of-\n
      \              Service Considerations\", RFC 4732, December 2006.\n   [IEEE.802-1D.1998]\n
      \              Institute of Electrical and Electronics Engineers, \"IEEE\n               Standard
      for Local and Metropolitan Area Networks Media\n               Access Control
      (MAC) Bridges\", IEEE Standard 802.1D,\n               1998.\n   [IEEE.802-1D.2004]\n
      \              Institute of Electrical and Electronics Engineers, \"IEEE\n               Standard
      for Local and Metropolitan Area Networks Media\n               Access Control
      (MAC) Bridges\", IEEE Standard 802.1D,\n               2004.\n   [IEEE.802-1Q.2005]\n
      \              Institute of Electrical and Electronics Engineers, \"IEEE\n               Standard
      for Local and metropolitan area networks -\n               Virtual Bridged Local
      Area Networks\", IEEE Standard\n               802.1Q, May 2005.\n   [IEEE.802-1X.2004]\n
      \              Institute of Electrical and Electronics Engineers, \"IEEE\n               Standard
      for Local and metropolitan area networks - Port-\n               Based Network
      Access Control\", IEEE Standard 802.1X,\n               2004.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Appendix A.  Implications of Not Following the Recommended Behavior\n   This
    section qualifies some of the SHOULDs that are included in this\n   specification
    by explaining the implications of not following the\n   recommended behavior.
    \ We start by describing the implication of not\n   following the recommendation
    of generating DAD_NS upon the reception\n   of a data packet for which there is
    no binding, and then we describe\n   the implications of not discarding the non-compliant
    packets.\n"
  - contents:
    - "A.1.  Implications of Not Generating DAD_NS Packets upon the Reception\n      of
      Non-Compliant Data Packets\n   This specification recommends that SAVI implementations
      generate a\n   DAD_NS message upon the reception of a data packet for which
      they\n   have no binding.  In this section, we describe the implications of\n
      \  not doing so and simply discarding the data packet instead.\n   The main
      argument against discarding the data packet is the overall\n   robustness of
      the resulting network.  The main concern that has been\n   stated is that a
      network running SAVI that discards data packets in\n   this case may end up
      disconnecting legitimate users from the network,\n   by filtering packets coming
      from them.  The net result would be a\n   degraded robustness of the network
      as a whole, since legitimate users\n   would perceive this as a network failure.
      \ There are three different\n   causes that resulted in the lack of state in
      the binding device for a\n   legitimate address, namely, packet loss, state
      loss, and topology\n   change.  We will next perform an analysis for each of
      them.\n"
    - contents:
      - "A.1.1.  Lack of Binding State due to Packet Loss\n   The DAD procedure is
        inherently unreliable.  It consists of sending\n   an NS packet, and if no
        NA packet is received back, success is\n   assumed, and the host starts using
        the address.  In general, the lack\n   of response is because no other host
        has that particular address\n   configured in its interface, but it may also
        be the case that the NS\n   packet or the NA packet has been lost.  From the
        perspective of the\n   sending host, there is no difference, and the host
        assumes that it\n   can use the address.  In other words, the default action
        is to allow\n   the host to obtain network connectivity.\n   It should be
        noted that the loss of a DAD packet has little impact on\n   the network performance,
        since address collision is very rare, and\n   the host assumes success in
        that case.  By designing a SAVI solution\n   that would discard packets for
        which there is no binding, we are\n   diametrically changing the default behavior
        in this respect, since\n   the default would be that if the DAD packets are
        lost, then the node\n   is disconnected from the network (as its packets are
        filtered).  What\n   is worse, the node has little clue of what is going wrong,
        since it\n   has successfully configured an address, but it has no connectivity.\n
        \  The net result is that the overall reliability of the network has\n   significantly
        decreased as the loss of a single packet would imply\n   that a host is disconnected
        from the network.\n   The only mechanism that the DAD has to improve its reliability
        is\n   sending multiple NSs.  However, [RFC4862] defines a default value of\n
        \  1 NS message for the DAD procedure, so requiring any higher value\n   would
        imply manual configuration of all the hosts connected to the\n   SAVI domain.\n"
      - contents:
        - "A.1.1.1.  Why Initial Packets May Be (Frequently) Lost\n   The Case of
          LANs\n   Devices connecting to a network may experience periods of packet
          loss\n   after the link-layer becomes available for two reasons: Invalid\n
          \  Authentication state and incomplete topology assessment.  In both\n   cases,
          physical-layer connection occurs initially and presents a\n   medium where
          packets are transmissible, but frame forwarding is not\n   available across
          the LAN.\n   For the authentication system, devices on a controlled port
          are\n   forced to complete 802.1X authentication, which may take multiple\n
          \  round trips and many milliseconds to complete (see\n   [IEEE.802-1X.2004]).
          \ In this time, initial DHCP, IPv6 Neighbor\n   Discovery, Multicast Listener,
          or Duplicate Address Detection\n   messages may be transmitted.  However,
          it has also been noted that\n   some devices have the ability for the IP
          stack to not see the port as\n   up until 802.1X has completed.  Hence,
          that issue needs investigation\n   to determine how common it is now.\n
          \  Additionally, any system that requires user input at this stage can\n
          \  extend the authentication time and thus the outage.  This is\n   problematic
          where hosts relying upon DHCP for address configuration\n   time out.\n
          \  Upon completion of authentication, it is feasible to signal upper-\n
          \  layer protocols as to LAN forwarding availability.  This is not\n   typical
          today, so it is necessary to assume that protocols are not\n   aware of
          the preceding loss period.\n   For environments that do not require authentication,
          addition of a\n   new link can cause loops where LAN frames are forwarded
          continually.\n   In order to prevent loops, all LANs today run a spanning
          tree\n   protocol, which selectively disables redundant ports.  Devices
          that\n   perform spanning tree calculations are either traditional Spanning\n
          \  Tree Protocol (STP) (see [IEEE.802-1D.1998]) or rapidly converging\n
          \  versions of the same (Rapid Spanning Tree Protocol (RSTP) / Multiple\n
          \  Spanning Tree Protocol (RSTP)) (see [IEEE.802-1D.2004] and\n   [IEEE.802-1Q.2005]).\n
          \  Until a port is determined to be an edge port (RSTP/MSTP), the rapid\n
          \  protocol speaker has identified its position within the spanning tree\n
          \  (RSTP/MSTP) or completed a Listening phase (STP), its packets are\n   discarded.\n
          \  For ports that are not connected to rapid protocol switches, it takes\n
          \  a minimum of three seconds to perform edge port determination (see\n
          \  [IEEE.802-1D.2004]).  Alternatively, completion of the Listening\n   phase
          takes 15 seconds (see [IEEE.802-1D.1998]).  During this period,\n   the
          link-layer appears available, but initial packet transmissions\n   into
          and out of this port will fail.\n   It is possible to pre-assess ports as
          edge ports using manual\n   configuration of all the involved devices and
          thus make them\n   immediately transmissible.  This is never default behavior
          though.\n   The Case of Fixed Access Networks\n   In fixed access networks
          such as DSL and cable, the end hosts are\n   usually connected to the access
          network through a residential gateway\n   (RG).  If the host interface is
          initialized prior to the RG getting\n   authenticated and connected to the
          access network, the access network\n   is not aware of the DAD packets that
          the host sent out.  As an\n   example, in DSL networks, the Access Node
          (Digital Subscriber Link\n   Access Multiplexer (DSLAM)) that needs to create
          and maintain binding\n   state will never see the DAD message that is required
          to create such\n   a state.\n"
        - contents:
          - "A.1.1.1.1.  Special Sub-Case:  SAVI Device Rate-Limiting Packets\n   A
            particular sub-case is the one where the SAVI device itself \"drops\"\n
            \  ND packets.  In order to protect itself against DoS attacks and\n   flash-crowds,
            the SAVI device will have to rate limit the processing\n   of packets
            triggering the state-creation process (which requires\n   processing from
            the SAVI device).  This implies that the SAVI device\n   may not process
            all the ND packets if it is under heavy conditions.\n   The result is
            that the SAVI device will fail to create a binding for\n   a given DAD_NS
            packet, which implies that the data packets coming\n   from the host that
            sent the DAD_NS packet will be filtered if this\n   approach is adopted.
            \ The problem is that the host will assume that\n   the DAD procedure
            was successful and will not perform the DAD\n   procedure again, which
            in turn will imply that the host will be\n   disconnected from the network.
            \ While it is true that the SAVI device\n   will also have to rate limit
            the processing of the data packets, the\n   host will keep on sending
            data packets, so it is possible to recover\n   from the alternative approach
            where data packets trigger the binding-\n   creation procedure.\n"
          title: 'A.1.1.1.1.  Special Sub-Case:  SAVI Device Rate-Limiting Packets'
        title: A.1.1.1.  Why Initial Packets May Be (Frequently) Lost
      title: A.1.1.  Lack of Binding State due to Packet Loss
    - contents:
      - "A.1.2.  Lack of Binding State due to a Change in the Topology\n   If SAVI
        is deployed in a switched Ethernet network, topology changes\n   may result
        in a SAVI device receiving packets from a legitimate user\n   for which the
        SAVI device does not have a binding.  Consider the\n   following example:\n
        \         +------+             +--------+       +---------------+\n          |SAVI
        I|-------------|SWITCH I|-------|rest of the net|\n          +------+             +--------+
        \      +---------------+\n             |                    |\n             |
        \                +--------+\n             |                 | SAVI II|\n             |
        \                +--------+\n             |   +----------+     |\n             +---|SWITCH
        II |-----+\n                 +----------+\n                             |\n
        \                         +-----+\n                          | Host|\n                          +-----+\n
        \                       Figure 3: Topology Example\n   Suppose that after
        bootstrapping, all the elements are working\n   properly and the spanning
        tree is rooted in the router and includes\n   one branch that follows the
        path SWITCH I - SAVI I - SWITCH II, and\n   another branch that follows SWITCH
        I-SAVI II.\n   Suppose that the host boots at this moment and sends the DAD_NS.
        \ The\n   message is propagated through the spanning tree and is received
        by\n   SAVI I but not by SAVI II.  SAVI I creates the binding.\n   Suppose
        that SAVI I fails and the spanning tree reconverges to SWITCH\n   I - SAVI
        II - SWITCH II.  Now, data packets coming from the host will\n   be coursed
        through SAVI II, which does not have binding state and\n   will drop the packets.\n"
      title: A.1.2.  Lack of Binding State due to a Change in the Topology
    - contents:
      - "A.1.3.  Lack of Binding State due to State Loss\n   The other reason a SAVI
        device may not have state for a legitimate\n   address is simply because it
        lost it.  State can be lost due to a\n   reboot of the SAVI device or other
        reasons such as memory corruption.\n   So, the situation would be as follows.
        \ The host performs the DAD\n   procedure, and the SAVI device creates a binding
        for the host's\n   address.  The host successfully communicates for a while.
        \ The SAVI\n   device reboots and loses the binding state.  The packets coming
        from\n   the host are now discarded as there is no binding state for that\n
        \  address.  It should be noted that in this case, the host has been\n   able
        to use the address successfully for a certain period of time.\n   Architecturally,
        the degradation of the network robustness in this\n   case can be easily explained
        by observing that this approach to SAVI\n   implementation breaks the fate-sharing
        principle.  [RFC1958] reads:\n      An end-to-end protocol design should not
        rely on the maintenance\n      of state (i.e. information about the state
        of the end-to-end\n      communication) inside the network.  Such state should
        be\n      maintained only in the endpoints, in such a way that the state can\n
        \     only be destroyed when the endpoint itself breaks (known as fate-\n
        \     sharing).\n   By binding the fate of the host's connectivity to the
        state in the\n   SAVI device, we are breaking this principle, and the result
        is\n   degraded network resilience.\n   Moving on to more practical matters,
        we can dig deeper into the\n   actual behavior by considering two scenarios,
        namely, the case where\n   the host is directly connected to the SAVI device
        and the case where\n   there is an intermediate device between the two.\n"
      - contents:
        - "A.1.3.1.  The Case of a Host Directly Connected to the SAVI Device\n   The
          considered scenario is depicted in the following diagram:\n         +------+
          \            +-----------+       +---------------+\n         | Host |-------------|SAVI
          device|-------|rest of the net|\n         +------+             +-----------+
          \      +---------------+\n              Figure 4: Host Attached Directly
          to SAVI Device\n   The key distinguishing element of this scenario is that
          the host is\n   directly connected to the SAVI device.  As a result, if
          the SAVI\n   device reboots, the host will see the carrier disappear and
          appear\n   again.\n   [RFC4862] requires that the DAD procedure is performed
          when the IP\n   address is assigned to the interface (see [RFC4862], Section
          5.4):\n      Duplicate Address Detection:\n      Duplicate Address Detection
          MUST be performed on all unicast\n      addresses prior to assigning them
          to an interface, regardless of\n      whether they are obtained through
          stateless autoconfiguration,\n      DHCPv6, or manual configuration, with
          the following exceptions:\n      ...\n   However, it has been stated that
          some of the widely used OSs actually\n   do perform DAD each time the link
          is up, but further data would be\n   required for this to be taken for granted.
          \ Assuming that behavior,\n   this implies that if the loss of state in
          the SAVI device also\n   results in the link to the host going down, then
          the host using the\n   tested OSs would redo the DAD procedure allowing
          the recreation of\n   the binding state in the SAVI device and preserving
          the connectivity\n   of the host.  This would be the case if the SAVI device
          reboots.  It\n   should be noted, however, that it is also possible that
          the binding\n   state is lost because of an error in the SAVI process and
          that the\n   SAVI link does not goes down.  In this case, the host would
          not redo\n   the DAD procedure.  However, it has been pointed out that it
          would be\n   possible to require the SAVI process to flap the links of the
          device\n   it is running, in order to make sure that the link goes down
          each\n   time the SAVI process restarts and to improve the chances the host\n
          \  will redo the DAD procedure when the SAVI process is rebooted.\n"
        title: A.1.3.1.  The Case of a Host Directly Connected to the SAVI Device
      - contents:
        - "A.1.3.2.  The Case of a Host Connected to the SAVI Device through One or\n
          \         More Legacy Devices\n   The considered scenario is depicted in
          the following diagram:\n     +------+    +-------------+     +-----------+
          \   +---------------+\n     | Host |----|Legacy device|-----|SAVI device|----|rest
          of the net|\n     +------+    +-------------+     +-----------+    +---------------+\n
          \               Figure 5: Host Attached to a Legacy Device\n   The key distinguishing
          element of this scenario is that the host is\n   not directly connected
          to the SAVI device.  As a result, if the SAVI\n   device reboots, the host
          will not see any changes.\n   In this case, the host would get disconnected
          from the rest of the\n   network since the SAVI device would filter all
          its packets once the\n   state has gone.  As the node will not perform the
          DAD procedure\n   again, it will remain disconnected until it reboots.\n
          \  As a final comment, it should be noted that it may not be obvious to\n
          \  the network admin which scenario its network is running.  Consider\n
          \  the case of a campus network where all the switches in the network\n
          \  are SAVI capable.  A small hub connected in the office would turn\n   this
          into the scenario where the host is not directly connected to\n   the SAVI
          device.  Moreover, consider the case of a host running\n   multiple virtual
          machines connected through a virtual hub.  Depending\n   on the implementation
          of such a virtual hub, this may turn a directly\n   connected host scenario
          to the scenario where the multiple (virtual)\n   hosts are connected through
          a legacy (virtual) hub.\n"
        - contents:
          - "A.1.3.2.1.  Enforcing Direct Connectivity between the SAVI Device and\n
            \           the Host\n   It has been argued that enforcing direct connectivity
            between the\n   SAVI device and the end host is actually a benefit.  There
            are\n   several comments that can be made in this respect:\n   o  First,
            it may well be the case in some scenarios that this is\n      desirable,
            but it is certainly not the case in most scenarios.\n      Because of
            that, the issue of enforcing direct connectivity must\n      be treated
            as orthogonal to how data packets for which there is no\n      binding
            are treated, since a general solution must support\n      directly connected
            nodes and nodes connected through legacy\n      switches.\n   o  Second,
            as a matter of fact, the resulting behavior described\n      above would
            not actually enforce direct connectivity between the\n      end host and
            the SAVI device as it would work as long as the SAVI\n      device does
            not reboot.  So, the argument being made is that this\n      approach
            is not good enough to provide a robust network service,\n      but it
            is not bad enough to enforce the direct connectivity of the\n      host
            to the SAVI switch.\n   o  Third, it should be noted that topology enforcement
            is not part of\n      the SAVI problem space and that the SAVI problem
            by itself is\n      complex enough without adding additional requirements.\n"
          title: A.1.3.2.1.  Enforcing Direct Connectivity between the SAVI Device
            and
        title: A.1.3.2.  The Case of a Host Connected to the SAVI Device through One
          or
      title: A.1.3.  Lack of Binding State due to State Loss
    title: A.1.  Implications of Not Generating DAD_NS Packets upon the Reception
  - contents:
    - "A.2.  Implications of Not Discarding Non-Compliant Data Packets\n   The FCFS
      SAVI mechanism is composed of two main functions, namely,\n   the mechanisms
      for tracking compliant and non-compliant data packets\n   and the actions to
      be performed upon the detection of a non-compliant\n   packet.  Throughout this
      specification, we recommend discarding non-\n   compliant data packets.  This
      is because forwarding non-compliant\n   data packets is essentially allowing
      packets with spoofed source\n   addresses to flow throughout the network.  However,
      there are\n   alternative actions that can be taken with respect to these packets.\n
      \  For instance, it would be possible to forward the packets and trigger\n   an
      alarm to network administrators to make them aware of the\n   situation.  Similarly,
      it would be possible to log these events and\n   allow the tracking down cases
      where packets with spoofed addresses\n   were used for malicious purposes.  The
      reason a site deploying SAVI\n   may not want to take milder actions like the
      ones mentioned above\n   instead of discarding packets is because there may
      be cases where the\n   non-compliant packets may be legitimate packets (for
      example, in the\n   case that the SAVI device is malfunctioning and has failed
      to create\n   the appropriate bindings upon the reception of a DAD packet).\n"
    title: A.2.  Implications of Not Discarding Non-Compliant Data Packets
  title: Appendix A.  Implications of Not Following the Recommended Behavior
- contents:
  - "Authors' Addresses\n   Erik Nordmark\n   Cisco Systems\n   510 McCarthy Blvd.\n
    \  Milpitas, CA  95035\n   United States\n   EMail: nordmark@acm.org\n   Marcelo
    Bagnulo\n   Universidad Carlos III de Madrid\n   Av. Universidad 30\n   Leganes,
    Madrid  28911\n   Spain\n   Phone: 34 91 6248814\n   EMail: marcelo@it.uc3m.es\n
    \  URI:   http://www.it.uc3m.es\n   Eric Levy-Abegnoli\n   Cisco Systems\n   Village
    d'Entreprises Green Side - 400, Avenue Roumanille\n   Biot-Sophia Antipolis -
    06410\n   France\n   EMail: elevyabe@cisco.com\n"
  title: Authors' Addresses
