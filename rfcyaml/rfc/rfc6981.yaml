- title: __initial_text__
  contents:
  - '    A Framework for IP and MPLS Fast Reroute Using Not-Via Addresses

    '
- title: Abstract
  contents:
  - "Abstract\n   This document presents an illustrative framework for providing fast\n\
    \   reroute in an IP or MPLS network through encapsulation and forwarding\n  \
    \ to \"not-via\" addresses.  The general approach described here uses a\n   single\
    \ level of encapsulation and could be used to protect unicast,\n   multicast,\
    \ and LDP traffic against link, router, and shared risk\n   group failure, regardless\
    \ of network topology and metrics.\n   The mechanisms presented in this document\
    \ are purely illustrative of\n   the general approach and do not constitute a\
    \ protocol specification.\n   The document represents a snapshot of the work of\
    \ the Routing Area\n   Working Group at the time of publication and is published\
    \ as a\n   document of record.  Further work is needed before implementation or\n\
    \   deployment.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6981.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. The Purpose of This Document ...............................4\n  \
    \    1.2. Overview ...................................................4\n   2.\
    \ Requirements Language ...........................................5\n   3. Overview\
    \ of Not-Via Repairs .....................................5\n      3.1. Use of\
    \ Equal-Cost Multi-Path ...............................6\n      3.2. Use of LFA\
    \ Repairs .........................................6\n   4. Not-Via Repair Path\
    \ Computation .................................7\n      4.1. Computing Not-Via\
    \ Repairs in Distance and Path\n           Vector Routing Protocols ...................................8\n\
    \   5. Operation of Repairs ............................................8\n  \
    \    5.1. Node Failure ...............................................8\n    \
    \  5.2. Link Failure ...............................................9\n      \
    \     5.2.1. Loop Prevention under Node Failure ..................9\n      5.3.\
    \ Multi-Homed Prefixes .......................................9\n      5.4. Installation\
    \ of Repair Paths ..............................11\n   6. Compound Failures ..............................................12\n\
    \      6.1. Shared Risk Link Groups ...................................12\n  \
    \    6.2. Local Area Networks .......................................17\n    \
    \       6.2.1. Simple LAN Repair ..................................18\n      \
    \     6.2.2. LAN Component Repair ...............................19\n        \
    \   6.2.3. LAN Repair Using Diagnostics .......................19\n      6.3.\
    \ Multiple Independent Failures .............................20\n           6.3.1.\
    \ Looping Repairs ....................................20\n           6.3.2. Outline\
    \ Solution ...................................21\n           6.3.3. Mutually Looping\
    \ Repairs ...........................22\n                  6.3.3.1. Dropping Looping\
    \ Packets ..................23\n                  6.3.3.2. Computing Non-looping\
    \ Repairs of Repairs ..23\n           6.3.4. Mixing LFAs and Not-Via ............................25\n\
    \   7. Optimizing Not-Via Computations Using LFAs .....................26\n  \
    \ 8. Multicast ......................................................27\n   9.\
    \ Fast Reroute in an MPLS LDP Network ............................27\n   10. Encapsulation\
    \ .................................................28\n   11. Routing Extensions\
    \ ............................................28\n   12. Incremental Deployment\
    \ ........................................28\n   13. Manageability Considerations\
    \ ..................................29\n      13.1. Pre-failure Configuration\
    \ ................................29\n      13.2. Pre-failure Monitoring and Operational\
    \ Support ...........29\n      13.3. Failure Action Monitoring ................................30\n\
    \   14. Security Considerations .......................................30\n  \
    \ 15. Acknowledgements ..............................................31\n   16.\
    \ References ....................................................31\n      16.1.\
    \ Normative References .....................................31\n      16.2. Informative\
    \ References ...................................31\n   Appendix A. Q-Space ...............................................33\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  The Purpose of This Document
  contents:
  - "1.1.  The Purpose of This Document\n   This document presents an illustrative\
    \ framework for providing fast\n   reroute around a failure in an IP or MPLS network\
    \ based on the\n   concept of tunneling or encapsulating packets via an IP address\
    \ that\n   is known to avoid the failure.  The general approach described here\n\
    \   uses a single level of encapsulation and could be used to protect\n   unicast,\
    \ multicast, and LDP traffic against link, router, and shared\n   risk group failure,\
    \ regardless of network topology and metrics.\n   At the time of publication,\
    \ there is no demand to deploy this\n   technology; however, in view of the subtleties\
    \ involved in the design\n   of routing protocol extensions to provide IP Fast\
    \ Reroute (IPFRR)\n   [RFC5714], the Routing Area Working Group considered it\
    \ desirable to\n   publish this document to place on record the design considerations\
    \ of\n   the not-via address approach.\n   The mechanisms presented in this document\
    \ are purely illustrative of\n   the general approach and do not constitute a\
    \ protocol specification.\n   The document represents a snapshot of the work of\
    \ the working group\n   at the time of publication and is published as a document\
    \ of record.\n   Additional work is needed to specify the necessary routing protocol\n\
    \   extensions necessary to support this IPFRR method before\n   implementation\
    \ or deployment.\n"
- title: 1.2.  Overview
  contents:
  - "1.2.  Overview\n   When a link or a router fails, only the neighbors of the failure\
    \ are\n   initially aware that the failure has occurred.  In a network\n   operating\
    \ IPFRR [RFC5714], the routers that are the neighbors of the\n   failure repair\
    \ the failure.  These repairing routers have to steer\n   packets to their destinations\
    \ despite the fact that most other\n   routers in the network are unaware of the\
    \ nature and location of the\n   failure.\n   A common limitation in most IPFRR\
    \ mechanisms is an inability to\n   indicate the identity of the failure and explicitly\
    \ steer the\n   repaired packet around the failure.  The extent to which this\n\
    \   limitation affects the repair coverage is topology dependent.  The\n   mechanism\
    \ proposed here is to encapsulate the packet to an address\n   that explicitly\
    \ identifies the network component that the repair must\n   avoid.  This produces\
    \ a repair mechanism that, provided the network\n   is not partitioned by the\
    \ failure, will always achieve a repair.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 3.  Overview of Not-Via Repairs
  contents:
  - "3.  Overview of Not-Via Repairs\n   This section provides a brief overview of\
    \ the not-via method of\n   IPFRR.  Consider the network fragment shown in Figure\
    \ 1 below, in\n   which S has a packet for some destination D that it would normally\n\
    \   send via P and B, and that S suspects that P has failed.\n               \
    \      A\n                     |                Bp is the address to use to get\n\
    \                     |                  a packet to B not via P\n           \
    \          |\n          S----------P----------B. . . . . . . . . .D\n        \
    \   \\         |        Bp^\n            \\        |          |\n            \
    \ \\       |          |\n              \\      C          |\n               \\\
    \                |\n                X-------Y-------Z\n                  Repair\
    \ to Bp\n                Figure 1: Not-Via Repair of Router Failure\n   In the\
    \ not-via IPFRR method, S encapsulates the packet to Bp, where\n   Bp is an address\
    \ on node B that has the property of not being\n   reachable from node P, i.e.,\
    \ the notation Bp means \"an address of\n   node B that is only reachable not\
    \ via node P\".  We later show how to\n   install the path from S to Bp such that\
    \ it is the shortest path from\n   S to B not going via P.  If the network contains\
    \ a path from S to B\n   that does not transit router P, i.e., the network is\
    \ not partitioned\n   by the failure of P and the path from S to Bp has been installed,\n\
    \   then the packet will be successfully delivered to B.  In the example\n   in\
    \ Figure 1, this is the path S-X-Y-Z-B.  When the packet addressed\n   to Bp arrives\
    \ at B, B removes the encapsulation and forwards the\n   repaired packet towards\
    \ its final destination.\n   Note that if the path from B to the final destination\
    \ includes one or\n   more nodes that are included in the repair path, a packet\
    \ may\n   backtrack after the encapsulation is removed.  However, because the\n\
    \   decapsulating router is always closer to the packet destination than\n   the\
    \ encapsulating router, the packet will not loop.\n   For complete protection,\
    \ all of P's neighbors will require a not-via\n   address that allows traffic\
    \ to be directed to them without traversing\n   P.  This is shown in Figure 2.\
    \  Similarly, P will require a set of\n   not-via addresses (one for each neighbor)\
    \ allowing traffic to be\n   directed to P without traversing each of those neighbors.\n\
    \   The not-via addresses are advertised in the routing protocol in a way\n  \
    \ that clearly identifies them as not-via addresses and not 'ordinary'\n   addresses.\n\
    \                                       A\n                                  \
    \     |Ap\n                                       |\n                        \
    \     Sp      Pa|Pb\n                            S----------P----------B\n   \
    \                                  Ps|Pc      Bp\n                           \
    \            |\n                                     Cp|\n                   \
    \                    C\n                 Figure 2: The Set of Not-Via P Addresses\n"
- title: 3.1.  Use of Equal-Cost Multi-Path
  contents:
  - "3.1.  Use of Equal-Cost Multi-Path\n   A router can use an Equal-Cost Multi-Path\
    \ (ECMP) repair in place of a\n   not-via repair.\n   A router computing a not-via\
    \ repair path MAY subject the repair\n   to ECMP.\n"
- title: 3.2.  Use of LFA Repairs
  contents:
  - "3.2.  Use of LFA Repairs\n   The not-via approach provides complete repair coverage\
    \ and therefore\n   may be used as the sole repair mechanism.  There are, however,\n\
    \   advantages in using not-via in combination with Loop-Free Alternates\n   (LFAs)\
    \ and/or downstream paths as documented in [RFC5286].  In\n   particular, LFAs\
    \ do not require the assignment and management of\n   additional IP addresses\
    \ to nodes, they do not require nodes in the\n   network to be upgraded in order\
    \ to calculate not-via repair paths,\n   and they do not require the use of encapsulation.\n\
    \   LFAs are computed on a per-destination basis, and in general only a\n   subset\
    \ of the destinations requiring repair will have a suitable LFA\n   repair.  In\
    \ this case, those destinations that are repairable by LFAs\n   are so repaired,\
    \ and the remainder of the destinations are repaired\n   using the not-via encapsulation.\
    \  On the other hand, the path taken\n   by an LFA repair may be less optimal\
    \ than that of the equivalent\n   not-via repair for traffic destined to nodes\
    \ close to the far end of\n   the failure, but it may be more optimal for some\
    \ other traffic.  This\n   document assumes that LFAs will be used where available,\
    \ but the\n   distribution of repairs between the two mechanisms is a local\n\
    \   implementation choice.\n"
- title: 4.  Not-Via Repair Path Computation
  contents:
  - "4.  Not-Via Repair Path Computation\n   The not-via repair mechanism requires\
    \ that all routers on the path\n   from S to B (Figure 1) have a route to Bp.\
    \  They can calculate this\n   by failing node P, running a Shortest Path First\
    \ (SPF) algorithm, and\n   finding the shortest route to B.\n   A router has no\
    \ simple way of knowing whether it is on the shortest\n   path for any particular\
    \ repair.  It is therefore necessary for every\n   router to calculate the path\
    \ it would use in the event of any\n   possible router failure.  Each router therefore\
    \ \"fails\" every router\n   in the network, one at a time, and calculates its\
    \ own best route to\n   each of the neighbors of that router.  In other words,\
    \ with reference\n   to Figure 1, routers A, B, C, X, Y, Z, and P will consider\
    \ each\n   router in turn, assume that the router has failed, and then calculate\n\
    \   its own route to each of the not-via addresses advertised by the\n   neighbors\
    \ of that router.  In other words, in the case of a presumed\n   failure of P,\
    \ ALL routers (S, A, B, C, X, Y, and Z in this case)\n   calculate their routes\
    \ to Sp, Ap, Bp, and Cp -- in each case,\n   not via P.\n   To calculate the repair\
    \ paths, a router has to calculate n-1 SPFs\n   where n is the number of routers\
    \ in the network.  This is expensive\n   to compute.  However, the problem is\
    \ amenable to a solution in which\n   each router (X) proceeds as follows.  X\
    \ first calculates the base\n   topology with all routers functional and determines\
    \ its normal path\n   to all not-via addresses.  This can be performed as part\
    \ of the\n   normal SPF computation.  For each router P in the topology, X then\n\
    \   performs the following actions:\n   1.  Removes router P from the topology.\n\
    \   2.  Performs an incremental SPF (iSPF) [ISPF] on the modified\n       topology.\
    \  The iSPF process involves detaching the sub-tree\n       affected by the removal\
    \ of router P and then reattaching the\n       detached nodes.  However, it is\
    \ not necessary to run the iSPF\n       to completion.  It is sufficient to run\
    \ the iSPF up to the point\n       where all of the nodes advertising not-via\
    \ P addresses have\n       been reattached to the Shortest Path Tree (SPT), and\
    \ then\n       terminate it.\n   3.  Reverts to the base topology.\n   This algorithm\
    \ is significantly less expensive than a set of full\n   SPFs.  Thus, although\
    \ a router has to calculate the repair paths for\n   n-1 failures, the computational\
    \ effort is much less than n-1 SPFs.\n   Experiments on a selection of real-world\
    \ network topologies with\n   between 40 and 400 nodes suggest that the worst-case\
    \ computational\n   complexity using the above optimizations is equivalent to\
    \ performing\n   between 5 and 13 full SPFs.  Further optimizations are described\
    \ in\n   Section 6.\n"
- title: 4.1.  Computing Not-Via Repairs in Distance and Path Vector Routing
  contents:
  - "4.1.  Computing Not-Via Repairs in Distance and Path Vector Routing\n      Protocols\n\
    \   While this document focuses on link-state routing protocols, it is\n   equally\
    \ possible to compute not-via repairs in distance vector (e.g.,\n   RIP) or path\
    \ vector (e.g., BGP) routing protocols.  This can be\n   achieved with very little\
    \ protocol modification by advertising the\n   not-via address in the normal way\
    \ but ensuring that the information\n   about a not-via address Ps is not propagated\
    \ through the node S.  In\n   the case of link protection, this simply means that\
    \ the advertisement\n   from P to S is suppressed, with the result that S and\
    \ all other nodes\n   compute a route to Ps that doesn't traverse S, as required.\n\
    \   In the case of node protection, where P is the protected node and N\n   is\
    \ some neighbor, the advertisement of Np needs to be suppressed not\n   only across\
    \ the link N-P but also across any link to P.  The simplest\n   way of achieving\
    \ this is for P itself to perform the suppression of\n   any address of the form\
    \ Xp.\n"
- title: 5.  Operation of Repairs
  contents:
  - "5.  Operation of Repairs\n   This section explains the basic operation of the\
    \ not-via repair of\n   node and link failure.\n"
- title: 5.1.  Node Failure
  contents:
  - "5.1.  Node Failure\n   When router P fails (Figure 2), S encapsulates any packet\
    \ that it\n   would send to B via P to Bp and then sends the encapsulated packet\
    \ on\n   the shortest path to Bp.  S follows the same procedure for routers A\n\
    \   and C in Figure 2.  The packet is decapsulated at the repair target\n   (A,\
    \ B, or C) and then forwarded normally to its destination.  The\n   repair target\
    \ can be determined as part of the normal SPF by\n   recording the \"next-next\
    \ hop\" for each destination in addition to the\n   normal next hop.  The next-next\
    \ hop is the router that the next-hop\n   router regards as its own next hop to\
    \ the destination.  In Figure 1,\n   B is S's next-next hop to D.\n   Notice that\
    \ with this technique only one level of encapsulation is\n   needed, and that\
    \ it is possible to repair ANY failure regardless of\n   link metrics and any\
    \ asymmetry that may be present in the network.\n   The only exception to this\
    \ is where the failure was a single point of\n   failure that partitioned the\
    \ network, in which case ANY repair is\n   clearly impossible.\n"
- title: 5.2.  Link Failure
  contents:
  - "5.2.  Link Failure\n   The normal mode of operation of the network would be to\
    \ assume router\n   failure.  However, where some destinations are only reachable\
    \ through\n   the failed router, it is desirable that an attempt be made to repair\n\
    \   to those destinations by assuming that only a link failure has\n   occurred.\n\
    \   To perform a link repair, S encapsulates to Ps (i.e., it instructs\n   the\
    \ network to deliver the packet to P not via S).  All of the\n   neighbors of\
    \ S will have calculated a path to Ps in case S itself had\n   failed.  S could\
    \ therefore give the packet to any of its neighbors\n   (except, of course, P).\
    \  However, S SHOULD send the encapsulated\n   packet on the shortest available\
    \ path to P.  This path is calculated\n   by running an SPF with the link S-P\
    \ removed.  Note that this may\n   again be an incremental calculation, which\
    \ can terminate when address\n   Ps has been reattached.\n"
- title: 5.2.1.  Loop Prevention under Node Failure
  contents:
  - "5.2.1.  Loop Prevention under Node Failure\n   It is necessary to consider the\
    \ behavior of IPFRR solutions when a\n   link repair is attempted in the presence\
    \ of node failure.  In its\n   simplest form, the not-via IPFRR solution prevents\
    \ the formation of\n   loops as a result of mutual repair, by never providing\
    \ a repair path\n   for a not-via address.  The repair of packets with not-via\
    \ addresses\n   is considered in more detail in Section 6.3.  Referring to Figure\
    \ 2,\n   if A was the neighbor of P that was on the link repair path from S to\n\
    \   P, and P itself had failed, the repaired packet from S would arrive\n   at\
    \ A encapsulated to Ps.  A would have detected that the A-P link had\n   failed\
    \ and would normally attempt to repair the packet.  However, no\n   repair path\
    \ is provided for any not-via address, and so A would be\n   forced to drop the\
    \ packet, thus preventing the formation of a loop.\n"
- title: 5.3.  Multi-Homed Prefixes
  contents:
  - "5.3.  Multi-Homed Prefixes\n   A Multi-Homed Prefix (MHP) is a prefix that is\
    \ reachable via more\n   than one router in the network.  Some of these may be\
    \ repairable\n   using LFAs as described in [RFC5286].  Only those without such\
    \ a\n   repair need be considered here.\n   When IPFRR router S (Figure 3) discovers\
    \ that P has failed, it needs\n   to send packets addressed to the MHP X, which\
    \ is normally reachable\n   through P, to an alternate router that is still able\
    \ to reach X.\n            X                          X                      \
    \    X\n            |                          |                          |\n\
    \            |                          |                          |\n       \
    \     |                Sp        |Pb                        |\n            Z...............S----------P----------B...............Y\n\
    \                                     Ps|Pc      Bp\n                        \
    \               |\n                                     Cp|\n                \
    \                       C\n                      Figure 3: Multi-Homed Prefixes\n\
    \   S SHOULD choose the closest router that can reach X during the\n   failure\
    \ as the alternate router.  S determines which router to use as\n   the alternate\
    \ while running the SPF with P removed.  This is\n   accomplished by the normal\
    \ process of reattaching a leaf node to the\n   core topology (this is sometimes\
    \ known as a \"partial SPF\").\n   First, consider the case where the shortest\
    \ alternate path to X is\n   via Z.  S can reach Z without using the removed router\
    \ P.  However, S\n   cannot just send the packet towards Z, because the other\
    \ routers in\n   the network will not be aware of the failure of P and may loop\
    \ the\n   packet back to S.  S therefore encapsulates the packet to Z (using a\n\
    \   normal address for Z).  When Z receives the encapsulated packet, it\n   removes\
    \ the encapsulation and forwards the packet to X.\n   Now consider the case where\
    \ the shortest alternate path to X is via\n   Y, which S reaches via P and B.\
    \  To reach Y, S must first repair the\n   packet to B using the normal not-via\
    \ repair mechanism.  To do this, S\n   encapsulates the packet for X to Bp.  When\
    \ B receives the packet, it\n   removes the encapsulation and discovers that the\
    \ packet is intended\n   for MHP X.  The situation now reverts to the previous\
    \ case, in which\n   the shortest alternate path does not require traversal of\
    \ the\n   failure.  B therefore follows the algorithm above and encapsulates\n\
    \   the packet to Y (using a normal address for Y).  Y removes the\n   encapsulation\
    \ and forwards the packet to X.\n   It may be that the cost of reaching X using\
    \ local delivery from the\n   alternate router (i.e., Z or Y) is greater than\
    \ the cost of reaching\n   X via P.  Under those circumstances, the alternate\
    \ router would\n   normally forward to X via P, which would cause the IPFRR repair\
    \ to\n   loop.  To prevent the repair from looping, the alternate router MUST\n\
    \   locally deliver a packet received via a repair encapsulation.  This\n   may\
    \ be specified by using a special address with the above semantics.\n   Note that\
    \ only one such address is required per node.  Notice that\n   using the not-via\
    \ approach, only one level of encapsulation was\n   needed to repair MHPs to the\
    \ alternate router.\n"
- title: 5.4.  Installation of Repair Paths
  contents:
  - "5.4.  Installation of Repair Paths\n   The following algorithm is used by node\
    \ S (Figure 3) to pre-calculate\n   and install repair paths in the Forwarding\
    \ Information Base (FIB),\n   ready for immediate use in the event of a failure.\
    \  It is assumed\n   that the not-via repair paths have already been calculated\
    \ as\n   described above.\n   For each neighbor P, consider all destinations that\
    \ are reachable via\n   P in the current topology:\n   1.  For all destinations\
    \ with an ECMP or LFA repair (as described in\n       [RFC5286]), install that\
    \ repair.\n   2.  For each destination (DR) that remains, identify in the current\n\
    \       topology the next-next hop (H) (i.e., the neighbor of P that P\n     \
    \  will use to send the packet to DR).  This can be determined\n       during\
    \ the normal SPF run by recording the additional\n       information.  If S has\
    \ a path to the not-via address Hp (H not\n       via P), install a not-via repair\
    \ to Hp for the destination DR.\n   3.  Identify all remaining destinations (M)\
    \ that can still be reached\n       when node P fails.  These will be multi-homed\
    \ prefixes that are\n       not repairable by LFA, and for which the normal attachment\
    \ node\n       is P (or a router for which P is a single point of failure), and\n\
    \       that have an alternative attachment point that is reachable after\n  \
    \     P has failed.  One way of determining these destinations would be\n    \
    \   to run an SPF rooted at S with node P removed, but an\n       implementation\
    \ may record alternative attachment points during\n       the normal SPF run.\
    \  In either case, the next-best point of\n       attachment can also be determined\
    \ for use in step (4) below.\n   4.  For each multi-homed prefix (M) identified\
    \ in step (3):\n       A.  Identify the new attachment node (as shown in Figure\
    \ 3).\n           This may be:\n           o  Y, where the next hop towards Y\
    \ is P, or\n           o  Z, where the next hop towards Z is not P.\n        \
    \   If the attachment node is Z, install the repair for M as a\n           tunnel\
    \ to Z' (where Z' is the address of Z that is used to\n           force local\
    \ forwarding).\n       B.  For the subset of prefixes (M) that remain (having\
    \ attachment\n           point Y), install the repair path previously installed\
    \ for\n           destination Y.\n       For each destination (DS) that remains,\
    \ install a not-via repair\n       to Ps (P not via S).  Note that these are destinations\
    \ for which\n       node P is a single point of failure, and they can only be\n\
    \       repaired by assuming that the apparent failure of node P was\n       simply\
    \ a failure of the S-P link.  Note that, if available, a\n       downstream path\
    \ to P MAY be used for such a repair.  This cannot\n       generate a persistent\
    \ loop in the event of the failure of node P,\n       but if one neighbor of P\
    \ uses a not-via repair and another uses a\n       downstream path, it is possible\
    \ for a packet sent on the\n       downstream path to be returned to the sending\
    \ node inside a\n       not-via encapsulation.  Since packets destined to not-via\n\
    \       addresses are not repaired, the packet will be dropped after\n       executing\
    \ a single turn of the loop.\n   Note that where multiple next-next hops are available\
    \ to reach DR,\n   any or several of them may be chosen from a routing correctness\
    \ point\n   of view.  Unless other factors require consideration, the closest\n\
    \   next-next hop to the repairing router would be the normal choice.\n"
- title: 6.  Compound Failures
  contents:
  - "6.  Compound Failures\n   The following types of failures involve more than one\
    \ component:\n   1.  Shared Risk Link Groups\n   2.  Local Area Networks\n   3.\
    \  Multiple Independent Failures\n   The considerations that apply in each of\
    \ the above situations are\n   described in the following sections.\n"
- title: 6.1.  Shared Risk Link Groups
  contents:
  - "6.1.  Shared Risk Link Groups\n   A Shared Risk Link Group (SRLG) is a set of\
    \ links whose failure can\n   be caused by a single action such as a conduit cut\
    \ or line card\n   failure.  When repairing the failure of a link that is a member\
    \ of an\n   SRLG, it MUST be assumed that all the other links that are also\n\
    \   members of the SRLG have also failed.  Consequently, any repair path\n   needs\
    \ to be computed to avoid not only the adjacent link but also all\n   the links\
    \ that are members of the same SRLG.\n   In Figure 4 below, the links S-P and\
    \ A-B are both members of SRLG\n   \"a\".  The semantics of the not-via address\
    \ Ps changes from simply \"P\n   not via the link S-P\" to be \"P not via the\
    \ link S-P or any other link\n   with which S-P shares an SRLG\".  In Figure 4,\
    \ these are the links\n   that are members of SRLG \"a\", i.e., links S-P and\
    \ A-B.  Since the\n   information about SRLG membership of all links is available\
    \ in the\n   link-state database, all nodes computing routes to the not-via\n\
    \   address Ps can infer these semantics and perform the computation by\n   failing\
    \ all the links in the SRLG when running the iSPF.\n   Note that it is not necessary\
    \ for S to consider repairs to any other\n   nodes attached to members of the\
    \ SRLG (such as B).  It is sufficient\n   for S to repair to the other end of\
    \ the adjacent link (P in this\n   case).\n                                  a\
    \   Ps\n                             S----------P---------D\n                \
    \             |          |\n                             |    a     |\n      \
    \                       A----------B\n                             |         \
    \ |\n                             |          |\n                             C----------E\n\
    \                     Figure 4: Shared Risk Link Group\n   In some cases, it may\
    \ be that the links comprising the SRLG occur in\n   series on the path from S\
    \ to the destination D, as shown in Figure 5.\n   In this case, multiple consecutive\
    \ repairs may be necessary.  S will\n   first repair to Ps, then P will repair\
    \ to Dp.  In both cases, because\n   the links concerned are members of SRLG \"\
    a\", the paths are computed\n   to avoid all members of SRLG \"a\".\n        \
    \                         a   Ps    a   Dp\n                            S----------P---------D\n\
    \                            |          |         |\n                        \
    \    |    a     |         |\n                            A----------B        \
    \ |\n                            |          |         |\n                    \
    \        |          |         |\n                            C----------E---------F\n\
    \           Figure 5: Shared Risk Link Group Members in Series -\n           \
    \   Decapsulation and Re-encapsulation by One Node\n   While the use of multiple\
    \ repairs in series introduces some\n   additional overhead, these semantics avoid\
    \ the potential\n   combinatorial explosion of not-via addresses that could otherwise\n\
    \   occur.\n   Note that although multiple repairs are used, only a single level\
    \ of\n   encapsulation is required.  This is because the first repair packet\n\
    \   is decapsulated before the packet is re-encapsulated using the\n   not-via\
    \ address corresponding to the far side of the next link that\n   is a member\
    \ of the same SRLG.  In some cases, the decapsulation and\n   re-encapsulation\
    \ take place (at least notionally) at a single node,\n   while in other cases,\
    \ these functions may be performed by different\n   nodes.  This scenario is illustrated\
    \ in Figure 6 below.\n                             a   Ps              a  Dg\n\
    \                        S----------P---------G--------D\n                   \
    \     |          |         |        |\n                        |    a     |  \
    \       |        |\n                        A----------B         |        |\n\
    \                        |          |         |        |\n                   \
    \     |          |         |        |\n                        C----------E---------F--------H\n\
    \           Figure 6: Shared Risk Link Group Members in Series -\n           Decapsulation\
    \ and Re-encapsulation by Different Nodes\n   In this case, S first encapsulates\
    \ to Ps, and node P decapsulates the\n   packet and forwards it \"native\" to\
    \ G using its normal FIB entry for\n   destination D.  G then repairs the packet\
    \ to Dg.\n   It can be shown that such multiple repairs can never form a loop,\n\
    \   because each repair causes the packet to move closer to its\n   destination.\n\
    \   It is often the case that a single link may be a member of multiple\n   SRLGs,\
    \ and those SRLGs may not be isomorphic.  This is illustrated in\n   Figure 7\
    \ below.\n                               ab  Ps              a  Dg\n         \
    \                 S----------P---------G--------D\n                          |\
    \          |         |        |\n                          |    a     |      \
    \   |        |\n                          A----------B         |        |\n  \
    \                        |          |         |        |\n                   \
    \       |    b     |         |   b    |\n                          C----------E---------F--------H\n\
    \                          |          |\n                          |         \
    \ |\n                          J----------K\n                Figure 7: Multiple\
    \ Shared Risk Link Groups\n   The link S-P is a member of SRLGs \"a\" and \"b\"\
    .  When a failure of the\n   link S-P is detected, it MUST be assumed that BOTH\
    \ SRLGs have failed.\n   Therefore, the not-via path to Ps needs to be computed\
    \ by failing all\n   links that are members of SRLG \"a\" or SRLG \"b\", i.e.,\
    \ the semantics\n   of Ps is now \"P not via any links that are members of any\
    \ of the\n   SRLGs of which link S-P is a member\".  This is illustrated in\n\
    \   Figure 8 below.\n                              ab  Ps              a  Dg\n\
    \                         S----/-----P---------G---/----D\n                  \
    \       |          |         |        |\n                         |    a     |\
    \         |        |\n                         A----/-----B         |        |\n\
    \                         |          |         |        |\n                  \
    \       |    b     |         |   b    |\n                         C----/-----E---------F---/----H\n\
    \                         |          |\n                         |          |\n\
    \                         J----------K\n        Figure 8: Topology Used for Repair\
    \ Computation for Link S-P\n   In this case, the repair path to Ps will be S-A-C-J-K-E-B-P.\
    \  It may\n   appear that there is no path to D because G-D is a member of SRLG\
    \ \"a\"\n   and F-H is a member of SRLG \"b\".  This is true if BOTH SRLGs \"\
    a\" and\n   \"b\" have in fact failed, which would be an instance of multiple\n\
    \   independent failures.  In practice, it is likely that there is only a\n  \
    \ single failure, i.e., either SRLG \"a\" or SRLG \"b\" has failed but not\n \
    \  both.  These two possibilities are indistinguishable from the point\n   of\
    \ view of the repairing router S, and so it needs to repair on the\n   assumption\
    \ that both are unavailable.  However, each link repair is\n   considered independently.\
    \  The repair to Ps delivers the packet to P,\n   which then forwards the packet\
    \ to G.  When the packet arrives at G,\n   if SRLG \"a\" has failed, it will be\
    \ repaired around the path G-F-H-D.\n    This is illustrated in Figure 9 below.\
    \  If, on the other hand, SRLG\n   \"b\" has failed, link G-D will still be available.\
    \  In this case, the\n   packet will be delivered as normal across the link G-D.\n\
    \                              ab  Ps              a  Dg\n                   \
    \      S----/-----P---------G---/----D\n                         |          |\
    \         |        |\n                         |    a     |         |        |\n\
    \                         A----/-----B         |        |\n                  \
    \       |          |         |        |\n                         |    b     |\
    \         |   b    |\n                         C----------E---------F--------H\n\
    \                         |          |\n                         |          |\n\
    \                         J----------K\n        Figure 9: Topology Used for Repair\
    \ Computation for Link G-D\n   If both SRLG \"a\" and SRLG \"b\" had failed, the\
    \ packet would be\n   repaired as far as P by S and would be forwarded by P to\
    \ G.  G would\n   encapsulate the packet to D using the not-via address Dg and\
    \ forward\n   it to F.  F would recognize that its next hop to Dg (H) was\n  \
    \ unreachable due to the failure of link F-H (part of SRLG \"b\") and\n   would\
    \ drop the packet, because packets addressed to a not-via address\n   are not\
    \ repaired in basic not-via IPFRR.\n   The repair of multiple independent failures\
    \ is not provided by the\n   basic not-via IPFRR method described so far in this\
    \ memo.\n   A repair strategy that assumes the worst-case failure for each link\n\
    \   can often result in longer repair paths than necessary.  In cases\n   where\
    \ only a single link fails rather than the full SRLG, this\n   strategy may occasionally\
    \ fail to identify a repair even though a\n   viable repair path exists in the\
    \ network.  The use of suboptimal\n   repair paths is an inevitable consequence\
    \ of this compromise\n   approach.  The failure to identify any repair is a serious\
    \ deficiency\n   but is a rare occurrence in a robustly designed network.  This\n\
    \   problem can be addressed by:\n   1.  Reporting that the link in question is\
    \ irreparable, so that the\n       network designer can take appropriate action.\n\
    \   2.  Modifying the design of the network to avoid this possibility.\n   3.\
    \  Using some form of SRLG diagnostic (for example, by running\n       Bidirectional\
    \ Forwarding Detection (BFD) [RFC5880] over alternate\n       repair paths) to\
    \ determine which SRLG member(s) have actually\n       failed and using this information\
    \ to select an appropriate\n       pre-computed repair path.  However, aside from\
    \ the complexity of\n       performing the diagnostics, this requires multiple\
    \ not-via\n       addresses per interface, which has poor scaling properties.\n\
    \   4.  Using the mechanism described in Section 6.3.\n"
- title: 6.2.  Local Area Networks
  contents:
  - "6.2.  Local Area Networks\n   LANs are a special type of SRLG and are solved\
    \ using the SRLG\n   mechanisms outlined above.  With all SRLGs, there is a trade-off\n\
    \   between the sophistication of the fault detection and the size of the\n  \
    \ SRLG.  Protecting against link failure of the LAN link(s) is\n   relatively\
    \ straightforward, but as with all fast-reroute mechanisms,\n   the problem becomes\
    \ more complex when it is desired to protect\n   against the possibility of failure\
    \ of the nodes attached to the LAN,\n   as well as the LAN itself.\n         \
    \                            +--------------Q------C\n                       \
    \              |\n                                     |\n                   \
    \                  |\n                   A--------S-------(N)-------------P------B\n\
    \                                     |\n                                    \
    \ |\n                                     |\n                                \
    \     +--------------R------D\n                      Figure 10: Local Area Networks\n\
    \   Consider the LAN shown in Figure 10.  For connectivity purposes, we\n   consider\
    \ that the LAN is represented by the pseudonode (N).  To\n   provide IPFRR protection,\
    \ S needs to run a connectivity check to each\n   of its protected LAN adjacencies\
    \ P, Q, and R, using, for example, BFD\n   [RFC5880].\n   When S discovers that\
    \ it has lost connectivity to P, it is unsure\n   whether the failure is:\n  \
    \ o  its own interface to the LAN\n   o  the LAN itself\n   o  the LAN interface\
    \ of P\n   o  the node P\n"
- title: 6.2.1.  Simple LAN Repair
  contents:
  - "6.2.1.  Simple LAN Repair\n   A simple approach to LAN repair is to consider\
    \ the LAN and all of its\n   connected routers as a single SRLG.  Thus, the address\
    \ P not via the\n   LAN (Pl) would require P to be reached not via any router\
    \ connected\n   to the LAN.  This is shown in Figure 11.\n                   \
    \                              Ql       Cl\n                                 \
    \    +-------------Q--------C\n                                     |        \
    \      Qc\n                                     |\n                    As    \
    \   Sl      |           Pl       Bl\n                   A--------S-------(N)------------P--------B\n\
    \                          Sa         |              Pb\n                    \
    \                 |\n                                     |           Rl     \
    \  Dl\n                                     +-------------R--------D\n       \
    \                                             Rd\n                 Figure 11:\
    \ Local Area Networks - LAN SRLG\n   In this case, if S detected that P had failed,\
    \ it would send traffic\n   reached via P and B to B not via the LAN or any router\
    \ attached to\n   the LAN (i.e., to Bl).  Any destination only reachable through\
    \ P\n   would be addressed to P not via the LAN or any router attached to the\n\
    \   LAN (except, of course, P).\n   While this approach is simple, it assumes\
    \ that a large portion of the\n   network adjacent to the failure has also failed.\
    \  This will result in\n   the use of suboptimal repair paths and, in some cases,\
    \ the inability\n   to identify a viable repair.\n"
- title: 6.2.2.  LAN Component Repair
  contents:
  - "6.2.2.  LAN Component Repair\n   In this approach, possible failures are considered\
    \ at a finer\n   granularity but without the use of diagnostics to identify the\n\
    \   specific component that has failed.  Because S is unable to diagnose\n   the\
    \ failure, it needs to repair traffic sent through P and B, to an\n   address\
    \ Bpn (B not-via P,N, i.e., B not via P and not via N), on the\n   conservative\
    \ assumption that both the entire LAN and P have failed.\n   Destinations for\
    \ which P is a single point of failure MUST, as usual,\n   be sent to P using\
    \ an address that avoids the interface by which P is\n   reached from S, i.e.,\
    \ to P not via N.  A similar process would also\n   apply for routers Q and R.\n\
    \   Notice that each router that is connected to a LAN MUST, as usual,\n   advertise\
    \ one not-via address for each neighbor.  In addition, each\n   router on the\
    \ LAN MUST advertise an extra address not via the\n   pseudonode (P).\n   Notice\
    \ also that each neighbor of a router connected to a LAN needs\n   to advertise\
    \ two not-via addresses: the usual one not via the\n   neighbor, and an additional\
    \ one not via either the neighbor or the\n   pseudonode.  The required set of\
    \ LAN address assignments is shown in\n   Figure 12 below.  Each router on the\
    \ LAN, and each of its neighbors,\n   are advertising exactly one address more\
    \ than they would otherwise\n   have advertised if this degree of connectivity\
    \ had been achieved\n   using point-to-point links.\n                        \
    \                        Qs Qp Qc    Cqn\n                                   \
    \   +--------------Q---------C\n                                      |      \
    \   Qr Qn        Cq\n                                      |\n               \
    \      Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn\n                    A--------S-------(N)-------------P---------B\n\
    \                     As       Sr Sn   |         Pr Pn        Bp\n           \
    \                           |\n                                      |       \
    \  Rs Rp Pd    Drn\n                                      +--------------R---------D\n\
    \                                                Rq Rn        Dr\n           \
    \  Figure 12: Local Area Networks - Component Repair\n"
- title: 6.2.3.  LAN Repair Using Diagnostics
  contents:
  - "6.2.3.  LAN Repair Using Diagnostics\n   A more specific LAN repair can be undertaken\
    \ by using diagnostics.\n   In order to explicitly diagnose the failed network\
    \ component, S\n   correlates the connectivity reports from P and one or more\
    \ of the\n   other routers on the LAN, in this case Q and R.  If it lost\n   connectivity\
    \ to P alone, it could deduce that the LAN was still\n   functioning and that\
    \ the fault lay with either P or the interface\n   connecting P to the LAN.  It\
    \ would then repair to B not-via P (and P\n   not-via N for destinations for which\
    \ P is a single point of failure)\n   in the usual way.  If S lost connectivity\
    \ to more than one router on\n   the LAN, it could conclude that the fault lay\
    \ only with the LAN and\n   could repair to P, Q, and R not-via N, again in the\
    \ usual way.\n"
- title: 6.3.  Multiple Independent Failures
  contents:
  - "6.3.  Multiple Independent Failures\n   IPFRR repair of multiple simultaneous\
    \ failures that are not members\n   of a known SRLG is complicated by the problem\
    \ that the use of\n   multiple concurrent repairs may result in looping repair\
    \ paths.  As\n   described in Section 5.2.1, the simplest method of preventing\
    \ such\n   loops is to ensure that packets addressed to a not-via address are\n\
    \   not repaired but instead are dropped.  It is possible that a network\n   may\
    \ experience multiple simultaneous failures.  This may be due to\n   simple statistical\
    \ effects, but the more likely cause is\n   unanticipated SRLGs.  When multiple\
    \ failures that are not part of an\n   anticipated group are detected, repairs\
    \ are abandoned, and the\n   network reverts to normal convergence.  Although\
    \ safe, this approach\n   is somewhat draconian, since there are many circumstances\
    \ where\n   multiple repairs do not induce loops.\n   This section describes the\
    \ properties of multiple unrelated failures\n   and proposes some methods that\
    \ may be used to address this problem.\n"
- title: 6.3.1.  Looping Repairs
  contents:
  - "6.3.1.  Looping Repairs\n   Let us assume that the repair mechanism is based\
    \ solely on not-via\n   repairs.  LFA or downstream routes MAY be incorporated\
    \ and will be\n   dealt with later.\n                           A------//------B------------D\n\
    \                          /                \\\n                         /   \
    \               \\\n                        F                    G\n         \
    \                \\                  /\n                          \\         \
    \       /\n                           X------//------Y\n             Figure 13:\
    \ The General Case of Multiple Failures\n   The essential case is as illustrated\
    \ in Figure 13.  Note that,\n   depending on the repair case under consideration,\
    \ there may be other\n   paths present in Figure 13, in addition to those shown\
    \ in the figure.\n   For example, there may be paths between A and B, and/or between\
    \ X\n   and Y.  These paths are omitted for graphical clarity.\n   There are three\
    \ cases to consider:\n   1.  Consider the general case of a pair of protected\
    \ links A-B and\n       X-Y, as shown in the network fragment shown in Figure\
    \ 13.  If the\n       repair path for A-B does not traverse X-Y and the repair\
    \ path for\n       X-Y does not traverse A-B, this case is completely safe and\
    \ will\n       not cause looping or packet loss.\n      A more common variation\
    \ of this case is shown in Figure 14, which\n      shows two failures in different\
    \ parts of the network in which a\n      packet from A to D traverses two concatenated\
    \ repairs.\n                 A------//------B------------X------//------Y------D\n\
    \                 |              |            |              |\n             \
    \    |              |            |              |\n                 M--------------+\
    \            N--------------+\n                      Figure 14: Concatenated Repairs\n\
    \   2.  In Figure 13, the repair for A-B traverses X-Y, but the repair\n     \
    \  for X-Y does not traverse A-B.  This case occurs when the not-via\n       path\
    \ from A to B traverses link X-Y but the not-via path from X\n       to Y traverses\
    \ some path not shown in Figure 13.  Without the\n       multi-failure mechanism\
    \ described in this section, the repaired\n       packet for A-B would be dropped\
    \ when it reached X-Y, since the\n       repair of repaired packets would be forbidden.\
    \  However, if this\n       packet were allowed to be repaired, the path to D\
    \ would be\n       complete and no harm would be done, although two levels of\n\
    \       encapsulation would be required.\n   3.  The repair for A-B traverses\
    \ X-Y AND the repair for X-Y traverses\n       A-B.  In this case, unrestricted\
    \ repair would result in looping\n       packets and increasing levels of encapsulation.\n\
    \   The challenge in applying IPFRR to a network that is undergoing\n   multiple\
    \ failures is, therefore, to identify which of these cases\n   exist in the network\
    \ and react accordingly.\n"
- title: 6.3.2.  Outline Solution
  contents:
  - "6.3.2.  Outline Solution\n   When A is computing the not-via repair path for\
    \ A-B (i.e., the path\n   for packets addressed to Ba, read as \"B not via A\"\
    ), it is aware of\n   the list of nodes that this path traverses.  This can be\
    \ recorded by\n   a simple addition to the SPF process, and the not-via addresses\n\
    \   associated with each forward link can be determined.  If the path\n   were\
    \ A, F, X, Y, G, B, (Figure 13), the list of not-via addresses\n   would be Fa,\
    \ Xf, Yx, Gy, Bg.  Under standard not-via operation, A\n   would populate its\
    \ FIB such that all normal addresses normally\n   reachable via A-B would be encapsulated\
    \ to Ba when A-B fails, but\n   traffic addressed to any not-via address arriving\
    \ at A would be\n   dropped.  The new procedure modifies this such that any traffic\
    \ for a\n   not-via address normally reachable over A-B is also encapsulated to\n\
    \   Ba, unless the not-via address is one of those previously identified\n   as\
    \ being on the path to Ba -- for example, Yx, in which case the\n   packet is\
    \ dropped.\n   The above procedure allows cases 1 and 2 above to be repaired while\n\
    \   preventing the loop that would result from case 3.\n   Note that this is accomplished\
    \ by pre-computing the required FIB\n   entries and does not require any detailed\
    \ packet inspection.  The\n   same result could be achieved by checking for multiple\
    \ levels of\n   encapsulation and dropping any attempt to triple encapsulate.\n\
    \   However, this would require more detailed inspection of the packet\n   and\
    \ causes difficulties when more than 2 \"simultaneous\" failures are\n   contemplated.\n\
    \   So far, we have permitted benign repairs to coexist, albeit sometimes\n  \
    \ requiring multiple encapsulation.  Note that in many cases there will\n   be\
    \ no performance impact, since unless both failures are on the same\n   node the\
    \ two encapsulations or two decapsulations will be performed\n   at different\
    \ nodes.  There is, however, the issue of the maximum\n   transmission unit (MTU)\
    \ impact of multiple encapsulations.\n   In the following sub-section we consider\
    \ the various strategies that\n   may be applied to case 3 -- mutual repairs that\
    \ would loop.\n"
- title: 6.3.3.  Mutually Looping Repairs
  contents:
  - "6.3.3.  Mutually Looping Repairs\n   In case 3, the simplest approach is to simply\
    \ not install repairs for\n   repair paths that might loop.  In this case, although\
    \ the potentially\n   looping traffic is dropped, the traffic is not repaired.\
    \  If we\n   assume that a hold-down is applied before reconvergence in case the\n\
    \   link failure was just a short glitch, and if a loop-free convergence\n   mechanism\
    \ further delays convergence, then the traffic will be\n   dropped for an extended\
    \ period.  In these circumstances, it would be\n   better to apply the \"Abandoning\
    \ All Hope\" (AAH) mechanism ([RFC6976],\n   Appendix A) and immediately invoke\
    \ normal reconvergence.\n   Note that it is not sufficient to expedite the issuance\
    \ of a Link\n   State Packet (LSP) reporting the failure, since this may be treated\n\
    \   as a permitted simultaneous failure by the ordered FIB (oFIB)\n   algorithm\
    \ [RFC6976].  It is therefore necessary to explicitly trigger\n   an oFIB AAH.\n"
- title: 6.3.3.1.  Dropping Looping Packets
  contents:
  - "6.3.3.1.  Dropping Looping Packets\n   One approach to case 3 is to allow the\
    \ repair, and to experimentally\n   discover the incompatibility of the repairs\
    \ if and when they occur.\n   With this method, we permit the repair in case 3\
    \ and trigger AAH when\n   a packet drop count on the not-via address has been\
    \ incremented.\n   Alternatively, it is possible to wait until the LSP describing\
    \ the\n   change is issued normally (i.e., when X announces the failure of\n \
    \  X-Y).  When the repairing node A, which has precomputed that X-Y\n   failures\
    \ are mutually incompatible with its own repairs, receives\n   this LSP, it can\
    \ then issue the AAH.  This has the disadvantage\n   that it does not overcome\
    \ the hold-down delay, but it requires no\n   \"data-driven\" operation, and it\
    \ still has the required effect of\n   abandoning the oFIB, which is probably\
    \ the longer of the delays\n   (although with signaled oFIB this should be sub-second).\n\
    \   While both of the experimental approaches described above are\n   feasible,\
    \ they tend to induce AAH in the presence of otherwise\n   feasible repairs, and\
    \ they are contrary to the philosophy of repair\n   predetermination that has\
    \ been applied to existing IPFRR solutions.\n"
- title: 6.3.3.2.  Computing Non-looping Repairs of Repairs
  contents:
  - "6.3.3.2.  Computing Non-looping Repairs of Repairs\n   An alternative approach\
    \ to simply dropping the looping packets, or to\n   detecting the loop after it\
    \ has occurred, is to use secondary SRLGs.\n   With a link-state routing protocol,\
    \ it is possible to pre-compute the\n   incompatibility of the repairs in advance\
    \ and to compute an\n   alternative SRLG repair path.  Although this does considerably\n\
    \   increase the computational complexity, it may be possible to compute\n   repair\
    \ paths that avoid the need to simply drop the offending\n   packets.\n   This\
    \ approach requires us to identify the mutually incompatible\n   failures and\
    \ advertise them as \"secondary SRLGs\".  When computing the\n   repair paths\
    \ for the affected not-via addresses, these links are\n   simultaneously removed.\
    \  Note that the assumed simultaneous failure\n   and resulting repair path only\
    \ apply to the repair path computed for\n   the conflicting not-via addresses\
    \ and are not used for normal\n   addresses.  This implies that although there\
    \ will be a longer repair\n   path when there is more than one failure, if there\
    \ is a single\n   failure the repair path length will be \"normal\".\n   Ideally,\
    \ we would wish to only invoke secondary SRLG computation when\n   we are sure\
    \ that the repair paths are mutually incompatible.\n   Consider the case of node\
    \ A in Figure 13.  Node A first identifies\n   that the repair path for A-B is\
    \ via F-X-Y-G-B.  It then explores this\n   path, determining the repair path\
    \ for each link in the path.  Thus,\n   for example, it performs a check at X\
    \ by running an SPF rooted at X\n   with the X-Y link removed to determine whether\
    \ A-B is indeed on X's\n   repair path for packets addressed to Yx.\n   Some optimizations\
    \ are possible in this calculation, which appears at\n   first sight to be order\
    \ hk (where h is the average hop length of\n   repair paths and k is the average\
    \ number of neighbors of a router).\n   When A is computing its set of repair\
    \ paths, it does so for all its k\n   neighbors.  In each case, it identifies\
    \ a list of node pairs\n   traversed by each repair.  These lists may often have\
    \ one or more\n   node pairs in common, so the actual number of link failures\
    \ that\n   require investigation is the union of these sets.  It is then\n   necessary\
    \ to run an SPF rooted at the first node of each pair (the\n   first node, because\
    \ the pairings are ordered representing the\n   direction of the path), with the\
    \ link to the second node removed.\n   This SPF, while not an incremental, can\
    \ be terminated as soon as the\n   not-via address is reached.  For example, when\
    \ running the SPF rooted\n   at X, with the link X-Y removed, the SPF can be terminated\
    \ when Yx is\n   reached.  Once the path has been found, the path is checked to\n\
    \   determine if it traverses any of A's links in the direction away from\n  \
    \ A.  Note that because the node pair X-Y may exist in the list for\n   more than\
    \ one of A's links (i.e., it lies on more than one repair\n   path), it is necessary\
    \ to identify the correct list, and hence link,\n   that has a mutually looping\
    \ repair path.  That link of A is then\n   advertised by A as a secondary SRLG\
    \ paired with the link X-Y.  Also\n   note that X will be running this algorithm\
    \ as well, and will identify\n   that X-Y is paired with A-B and so advertise\
    \ it.  This could perhaps\n   be used as a further check.\n   The ordering of\
    \ the pairs in the lists is important, i.e., X-Y and\n   Y-X are dealt with separately.\
    \  If and only if the repairs are\n   mutually incompatible, we need to advertise\
    \ the pair of links as a\n   secondary SRLG, and then ALL nodes compute repair\
    \ paths around both\n   failures using an additional not-via address with the\
    \ semantics\n   not-via A-B AND not-via X-Y.\n   A further possibility is that\
    \ because we are going to the trouble of\n   advertising these SRLG sets, we could\
    \ also advertise the new repair\n   path and only get the nodes on that path to\
    \ perform the necessary\n   computation.  Note also that once we have reached\
    \ Q-space\n   (Appendix A) with respect to the two failures, we need no longer\n\
    \   continue the computation, so we only need to notify the nodes on the\n   path\
    \ that are not in Q-space.\n   One cause of mutually looping repair paths is the\
    \ existence of nodes\n   with only two links, or sections of the network that\
    \ are only\n   bi-connected.  In these cases, repair is clearly impossible --\
    \ the\n   failure of both links partitions the network.  It would be\n   advantageous\
    \ to be able to identify these cases and inhibit the\n   fruitless advertisement\
    \ of the secondary SRLG information.  This\n   could be achieved by the node detecting\
    \ the requirement for a\n   secondary SRLG, first running the not-via computation\
    \ with both links\n   removed.  If this does not result in a path, it is clear\
    \ that the\n   network would be partitioned by such a failure, and so no\n   advertisement\
    \ is required.\n"
- title: 6.3.4.  Mixing LFAs and Not-Via
  contents:
  - "6.3.4.  Mixing LFAs and Not-Via\n   So far in this section, we have assumed that\
    \ all repairs use not-via\n   tunnels.  However, in practice we may wish to use\
    \ LFAs or downstream\n   routes where available.  This complicates the issue,\
    \ because their\n   use results in packets that are being repaired but NOT addressed\
    \ to\n   not-via addresses.  If BOTH links are using downstream routes, there\n\
    \   is no possibility of looping, since it is impossible to have a pair\n   of\
    \ nodes that are both downstream of each other [RFC5286].\n   Loops can, however,\
    \ occur when LFAs are used.  An obvious example is\n   the well-known node repair\
    \ problem with LFAs [RFC5286].  If one link\n   is using a downstream route while\
    \ the other is using a not-via\n   tunnel, the potential mechanism described above\
    \ would work, provided\n   it were possible to determine the nodes on the path\
    \ of the downstream\n   route.  Some methods of computing downstream routes do\
    \ not provide\n   this path information.  However, if the path information is\n\
    \   available, the link using a downstream route will have a discard FIB\n   entry\
    \ for the not-via address of the other link.  The consequence is\n   that potentially\
    \ looping packets will be discarded when they attempt\n   to cross this link.\n\
    \   In the case where the mutual repairs are both using not-via repairs,\n   the\
    \ loop will be broken when the packet arrives at the second\n   failure.  However,\
    \ packets are unconditionally repaired by means of a\n   downstream routes, and\
    \ thus when the mutual pair consists of a\n   downstream route and a not-via repair,\
    \ the looping packet will only\n   be dropped when it gets back to the first failure,\
    \ i.e., it will\n   execute a single turn of the loop before being dropped.\n\
    \   There is a further complication with downstream routes, since\n   although\
    \ the path may be computed to the far side of the failure, the\n   packet may\
    \ \"peel off\" to its destination before reaching the far side\n   of the failure.\
    \  In this case, it may traverse some other link that\n   has failed and was not\
    \ accounted for on the computed path.  If the\n   A-B repair (Figure 13) is a\
    \ downstream route and the X-Y repair is a\n   not-via repair, we can have the\
    \ situation where the X-Y repair\n   packets encapsulated to Yx follow a path\
    \ that attempts to traverse\n   A-B.  If the A-B repair path for \"normal\" addresses\
    \ is a downstream\n   route, it cannot be assumed that the repair path for packets\n\
    \   addressed to Yx can be sent to the same neighbor.  This is because\n   the\
    \ validity of a downstream route MUST be ascertained in the\n   topology represented\
    \ by Yx, i.e., that with the link X-Y removed.\n   This is not the same topology\
    \ that was used for the normal downstream\n   calculation, and use of the normal\
    \ downstream route for the\n   encapsulated packets may result in an undetected\
    \ loop.  If it is\n   computationally feasible to check the downstream route in\
    \ this\n   topology (i.e., for any not-via address Qp that traverses A-B, we\n\
    \   must perform the downstream calculation for that not-via address in\n   the\
    \ topology with link Q-P removed), then the downstream repair for\n   Yx can safely\
    \ be used.  These packets cannot revisit X-Y, since by\n   definition they will\
    \ avoid that link.  Alternatively, the packet\n   could be always repaired in\
    \ a not-via tunnel, i.e., even though the\n   normal repair for traffic traversing\
    \ A-B would be to use a downstream\n   route, we could insist that such traffic\
    \ addressed to a not-via\n   address must use a tunnel to Ba.  Such a tunnel would\
    \ only be\n   installed for an address Qp if it were established that it did not\n\
    \   traverse Q-P (using the rules described above).\n"
- title: 7.  Optimizing Not-Via Computations Using LFAs
  contents:
  - "7.  Optimizing Not-Via Computations Using LFAs\n   If repairing node S has an\
    \ LFA to the repair endpoint, it is not\n   necessary for any router to perform\
    \ the incremental SPF with the link\n   S-P removed in order to compute the route\
    \ to the not-via address Ps.\n   This is because the correct routes will already\
    \ have been computed as\n   a result of the SPF on the base topology.  Node S\
    \ can signal this\n   condition to all other routers by including a bit in its\
    \ LSP or Link\n   State Advertisement (LSA) associated with each link protected\
    \ by an\n   LFA.  Routers computing not-via routes can then omit the running of\n\
    \   the iSPF for links with this bit set.\n   When running the iSPF for a particular\
    \ link A-B, the calculating\n   router first checks whether the link A-B is present\
    \ in the existing\n   SPT.  If the link is not present in the SPT, no further\
    \ work is\n   required.  This check is a normal part of the iSPF computation.\n\
    \   If the link is present in the SPT, this optimization introduces a\n   further\
    \ check to determine whether the link is marked as protected by\n   an LFA in\
    \ the direction in which the link appears in the SPT.  If so,\n   the iSPF need\
    \ not be performed.  For example, if the link appears in\n   the SPT in the direction\
    \ A->B and A has indicated that the link A-B\n   is protected by an LFA, no further\
    \ action is required for this link.\n   If the receipt of this information is\
    \ delayed, the correct operation\n   of the protocol is not compromised, provided\
    \ that the necessity to\n   perform a not-via computation is re-evaluated whenever\
    \ new\n   information arrives.\n   This optimization is not particularly beneficial\
    \ to nodes close to\n   the repair, since (as has been observed above) the computation\
    \ for\n   nodes on the LFA path is trivial.  However, for nodes upstream of the\n\
    \   link S-P for which S-P is in the path to P, there is a significant\n   reduction\
    \ in the computation required.\n"
- title: 8.  Multicast
  contents:
  - "8.  Multicast\n   Multicast traffic can be repaired in a way similar to unicast.\
    \  The\n   multicast forwarder is able to use the not-via address to which the\n\
    \   multicast packet was addressed as an indication of the expected\n   receive\
    \ interface and hence to correctly run the required Reverse\n   Path Forwarding\
    \ (RPF) check.\n   In some cases, all the destinations, including the repair endpoint,\n\
    \   are repairable by an LFA.  In this case, all unicast traffic may be\n   repaired\
    \ without encapsulation.  Multicast traffic still requires\n   encapsulation,\
    \ but for the nodes on the LFA repair path, the\n   computation of the not-via\
    \ forwarding entry is unnecessary: by\n   definition, their normal path to the\
    \ repair endpoint is not via the\n   failure.\n   A more complete description\
    \ of multicast operation is left for\n   further study.\n"
- title: 9.  Fast Reroute in an MPLS LDP Network
  contents:
  - "9.  Fast Reroute in an MPLS LDP Network\n   Not-via addresses are IP addresses,\
    \ and LDP [RFC5036] will distribute\n   labels for them in the usual way.  The\
    \ not-via repair mechanism may\n   therefore be used to provide fast reroute in\
    \ an MPLS network by first\n   pushing the label that the repair endpoint uses\
    \ to forward the packet\n   and then pushing the label corresponding to the not-via\
    \ address\n   needed to effect the repair.  Referring once again to Figure 1,\
    \ if S\n   has a packet destined for D that it must reach via P and B, S first\n\
    \   pushes B's label for D.  S then pushes the label that its next hop to\n  \
    \ Bp needs to reach Bp.\n   Note that in an MPLS LDP network, it is necessary\
    \ for S to have the\n   repair endpoint's label for the destination.  When S is\
    \ effecting a\n   link repair, it already has this.  In the case of a node repair,\
    \ S\n   either needs to set up a directed LDP session with each of its\n   neighbor's\
    \ neighbors or it needs to use a method similar to the\n   next-next-hop label\
    \ distribution mechanism proposed in [NNHL].\n"
- title: 10.  Encapsulation
  contents:
  - "10.  Encapsulation\n   Any IETF-specified IP-in-IP encapsulation may be used\
    \ to carry a\n   not-via repair.  IP in IP [RFC2003], Generic Routing Encapsulation\n\
    \   (GRE) [RFC1701], and the Layer 2 Tunneling Protocol (L2TPv3)\n   [RFC3931]\
    \ all have the necessary and sufficient properties.  The\n   requirement is that\
    \ both the encapsulating router and the router to\n   which the encapsulated packet\
    \ is addressed have a common ability to\n   process the chosen encapsulation type.\
    \  When an MPLS LDP network is\n   being protected, the encapsulation would normally\
    \ be an additional\n   MPLS label.  In an MPLS-enabled IP network, an MPLS label\
    \ may be used\n   in place of an IP-in-IP encapsulation in the case above.\n \
    \  Care needs to be taken to ensure that the encapsulation used to\n   provide\
    \ a repair tunnel does not result in the packet exceeding the\n   MTU of the links\
    \ traversed by that repair.\n"
- title: 11.  Routing Extensions
  contents:
  - "11.  Routing Extensions\n   IPFRR requires routing protocol extensions.  Each\
    \ IPFRR router that\n   is directly connected to a protected network component\
    \ must advertise\n   a not-via address for that component.  This must be advertised\
    \ in\n   such a way that the association between the protected component\n   (link,\
    \ router, or SRLG) and the not-via address can be determined by\n   the other\
    \ routers in the network.\n   It is necessary that routers capable of supporting\
    \ not-via routes\n   advertise in the IGP that they will calculate not-via routes.\n\
    \   It is necessary for routers to advertise the type of encapsulation\n   that\
    \ they support (MPLS, GRE, L2TPv3, etc.).  However, the deployment\n   of mixed\
    \ IP encapsulation types within a network is discouraged.\n   If the optimization\
    \ proposed in Section 7 is to be used, then the use\n   of the LFA in place of\
    \ the not-via repair MUST also be signaled in\n   the routing protocol.\n"
- title: 12.  Incremental Deployment
  contents:
  - "12.  Incremental Deployment\n   Incremental deployment is supported by excluding\
    \ routers that are not\n   calculating not-via routes (as indicated by their capability\n\
    \   information flooded with their link-state information) from the base\n   topology\
    \ used for the computation of repair paths.  In that way,\n   repairs may be steered\
    \ around islands of routers that are not IPFRR\n   capable.  Routers that are\
    \ protecting a network component need to\n   have the capability to encapsulate\
    \ and decapsulate packets.  However,\n   routers that are on the repair path only\
    \ need to be capable of\n   calculating not-via paths and including the not-via\
    \ addresses in\n   their FIB, i.e., these routers do not need any changes to their\n\
    \   forwarding mechanism.\n"
- title: 13.  Manageability Considerations
  contents:
  - "13.  Manageability Considerations\n   [RFC5714] outlines the general set of manageability\
    \ considerations\n   that apply to the general case of IPFRR.  We slightly expand\
    \ this and\n   add details that are not-via specific.  There are three classes\
    \ of\n   manageability considerations:\n   1.  Pre-failure configuration\n   2.\
    \  Pre-failure monitoring and operational support\n   3.  Failure action monitoring\n"
- title: 13.1.  Pre-failure Configuration
  contents:
  - "13.1.  Pre-failure Configuration\n   Pre-failure configuration for not-via includes:\n\
    \   o  Enabling/disabling not-via IPFRR support.\n   o  Enabling/disabling protection\
    \ on a per-link or per-node basis.\n   o  Expressing preferences regarding the\
    \ links/nodes used for repair\n      paths.\n   o  Configuration of failure detection\
    \ mechanisms.\n   o  Setting a preference concerning the use of LFAs.\n   o  Configuring\
    \ a not-via address (per interface) or not-via address\n      set (per node).\n\
    \   o  Configuring any SRLG rules or preferences.\n   Any standard configuration\
    \ method may be used.  The selection of the\n   method to be used is outside the\
    \ scope of this document.\n"
- title: 13.2.  Pre-failure Monitoring and Operational Support
  contents:
  - "13.2.  Pre-failure Monitoring and Operational Support\n   Pre-failure monitoring\
    \ and operational support for not-via include:\n   o  Notification of links/nodes/destinations\
    \ that cannot be protected.\n   o  Notification of pre-computed repair paths.\n\
    \   o  Notification of repair type to be used (LFA or not-via).\n   o  Notification\
    \ of not-via address assignment.\n   o  Notification of path or address optimizations\
    \ used.\n   o  Testing repair paths.  Note that not-via addresses look identical\n\
    \      to \"ordinary\" addresses as far as tools such as traceroute and\n    \
    \  ping are concerned, and thus it is anticipated that these will be\n      used\
    \ to verify the established repair path.\n   Any standard IETF method may be used\
    \ for the above.  The selection of\n   the method to be used is outside the scope\
    \ of this document.\n"
- title: 13.3.  Failure Action Monitoring
  contents:
  - "13.3.  Failure Action Monitoring\n   Failure action monitoring for not-via includes:\n\
    \   o  Counts of failure detections, protection invocations, and packets\n   \
    \   forwarded over repair paths.\n   o  Logging of the events, using a sufficiently\
    \ accurate and precise\n      timestamp.\n   o  Validation that the packet loss\
    \ was within specification, using a\n      suitable loss verification tool.\n\
    \   o  Capture of the in-flight repair packet flows, using a tool such as\n  \
    \    IP Flow Information Export (IPFIX) [RFC5101].\n   Note that monitoring the\
    \ repair in action requires the capture of the\n   signatures of a short, possibly\
    \ sub-second network transient; this\n   technique is not a well-developed IETF\
    \ technology.\n"
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   The repair endpoints present vulnerability in\
    \ that they might be used\n   as a method of disguising the delivery of a packet\
    \ to a point in the\n   network [RFC6169].  The primary method of protection SHOULD\
    \ be\n   through the use of a private address space for the not-via addresses\n\
    \   [RFC1918] [RFC4193].  Repair endpoint addresses MUST NOT be\n   advertised\
    \ outside the routing domain over which not-via is deployed\n   and MUST be filtered\
    \ at the network entry points.  In addition, a\n   mechanism might be developed\
    \ that allows the use of the mild security\n   available through the use of a\
    \ key [RFC1701] [RFC3931].  With the\n   deployment of such mechanisms, the repair\
    \ endpoints would not\n   increase the security risk beyond that of existing IP\
    \ tunnel\n   mechanisms.  An attacker may attempt to overload a router by\n  \
    \ addressing an excessive traffic load to the decapsulation endpoint.\n   Typically,\
    \ routers take a 50% performance penalty in decapsulating a\n   packet.  The attacker\
    \ could not be certain that the router would be\n   impacted, and the extremely\
    \ high volume of traffic needed would\n   easily be detected as an anomaly.  If\
    \ an attacker were able to\n   influence the availability of a link, they could\
    \ cause the network to\n   invoke the not-via repair mechanism.  A network protected\
    \ by not-via\n   IPFRR is less vulnerable to such an attack than a network that\n\
    \   undertook a full convergence in response to a link up/down event.\n"
- title: 15.  Acknowledgements
  contents:
  - "15.  Acknowledgements\n   The authors would like to acknowledge contributions\
    \ made by Alia\n   Atlas and John Harper.\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [RFC2119]     Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                 Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [ISPF]        McQuillan, J., Richer, I., and\
    \ E. Rosen, \"ARPANET\n                 Routing Algorithm Improvements\", BBN\
    \ Technical\n                 Report 3803, 1978.\n   [NNHL]        Shen, N., Chen,\
    \ E., and A. Tian, \"Discovering LDP Next-\n                 Nexthop Labels\"\
    , Work in Progress, May 2005.\n   [REMOTE-LFA]  Bryant, S., Filsfils, C., Previdi,\
    \ S., Shand, M., and\n                 N. So, \"Remote LFA FRR\", Work in Progress,\
    \ May 2013.\n   [RFC1701]     Hanks, S., Li, T., Farinacci, D., and P. Traina,\n\
    \                 \"Generic Routing Encapsulation (GRE)\", RFC 1701,\n       \
    \          October 1994.\n   [RFC1918]     Rekhter, Y., Moskowitz, R., Karrenberg,\
    \ D., Groot, G.,\n                 and E. Lear, \"Address Allocation for Private\n\
    \                 Internets\", BCP 5, RFC 1918, February 1996.\n   [RFC2003] \
    \    Perkins, C., \"IP Encapsulation within IP\", RFC 2003,\n                \
    \ October 1996.\n   [RFC3931]     Lau, J., Townsley, M., and I. Goyret, \"Layer\
    \ Two\n                 Tunneling Protocol - Version 3 (L2TPv3)\", RFC 3931,\n\
    \                 March 2005.\n   [RFC4193]     Hinden, R. and B. Haberman, \"\
    Unique Local IPv6 Unicast\n                 Addresses\", RFC 4193, October 2005.\n\
    \   [RFC5036]     Andersson, L., Minei, I., and B. Thomas, \"LDP\n           \
    \      Specification\", RFC 5036, October 2007.\n   [RFC5101]     Claise, B.,\
    \ \"Specification of the IP Flow Information\n                 Export (IPFIX)\
    \ Protocol for the Exchange of IP Traffic\n                 Flow Information\"\
    , RFC 5101, January 2008.\n   [RFC5286]     Atlas, A. and A. Zinin, \"Basic Specification\
    \ for IP\n                 Fast Reroute: Loop-Free Alternates\", RFC 5286,\n \
    \                September 2008.\n   [RFC5714]     Shand, M. and S. Bryant, \"\
    IP Fast Reroute Framework\",\n                 RFC 5714, January 2010.\n   [RFC5880]\
    \     Katz, D. and D. Ward, \"Bidirectional Forwarding\n                 Detection\
    \ (BFD)\", RFC 5880, June 2010.\n   [RFC6169]     Krishnan, S., Thaler, D., and\
    \ J. Hoagland, \"Security\n                 Concerns with IP Tunneling\", RFC\
    \ 6169, April 2011.\n   [RFC6976]     Shand, M., Bryant, S., Previdi, S., Filsfils,\
    \ C.,\n                 Francois, P., and O. Bonaventure, \"Framework for Loop-\n\
    \                 Free Convergence Using the Ordered Forwarding\n            \
    \     Information Base (oFIB) Approach\", RFC 6976, July 2013.\n"
- title: Appendix A.  Q-Space
  contents:
  - "Appendix A.  Q-Space\n   Q-space is the set of routers from which a specific\
    \ router can be\n   reached without any path (including equal-cost path splits)\n\
    \   transiting the protected link (or node).  It is described fully in\n   [REMOTE-LFA].\n\
    \                                   S---Eq\n                                 \
    \ /     \\\n                                 A       Dq\n                    \
    \              \\     /\n                                   B---Cq\n         Figure\
    \ 15: The Q Space of E with Respect to the Link S-E\n   Consider a repair of link\
    \ S-E (Figure 15).  The set of routers from\n   which the node E can be reached,\
    \ by normal forwarding, without\n   traversing the link S-E is termed the Q-space\
    \ of E with respect to\n   the link S-E.  The Q-space can be obtained by computing\
    \ a reverse\n   Shortest Path Tree (rSPT) rooted at E, with the sub-tree that\n\
    \   traverses the failed link excised (including those that are members\n   of\
    \ an ECMP).  The rSPT uses the cost towards the root rather than\n   from it and\
    \ yields the best paths towards the root from other nodes\n   in the network.\
    \  In the case of Figure 15, the Q-space comprises\n   nodes E, D, and C only.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stewart Bryant\n   Cisco Systems\n   10 New Square, Bedfont\
    \ Lakes\n   Feltham, Middlesex  TW18 8HA\n   UK\n   EMail: stbryant@cisco.com\n\
    \   Stefano Previdi\n   Cisco Systems\n   Via Del Serafico, 200\n   00142 Rome\n\
    \   Italy\n   EMail: sprevidi@cisco.com\n   Mike Shand\n   Individual Contributor\n\
    \   EMail: imc.shand@googlemail.com\n"
