- contents:
  - '     Internet Message Access Protocol - SORT and THREAD Extensions

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document describes the base-level server-based sorting and\n
    \  threading extensions to the IMAP protocol.  These extensions provide\n   substantial
    performance improvements for IMAP clients that offer\n   sorted and threaded views.\n"
  title: Abstract
- contents:
  - "1.  Introduction\n   The SORT and THREAD extensions to the [IMAP] protocol provide
    a means\n   of server-based sorting and threading of messages, without requiring\n
    \  that the client download the necessary data to do so itself.  This is\n   particularly
    useful for online clients as described in [IMAP-MODELS].\n   A server that supports
    the base-level SORT extension indicates this\n   with a capability name which
    starts with \"SORT\".  Future, upwards-\n   compatible extensions to the SORT
    extension will all start with\n   \"SORT\", indicating support for this base level.\n
    \  A server that supports the THREAD extension indicates this with one\n   or
    more capability names consisting of \"THREAD=\" followed by a\n   supported threading
    algorithm name as described in this document.\n   This provides for future upwards-compatible
    extensions.\n   A server that implements the SORT and/or THREAD extensions MUST\n
    \  collate strings in accordance with the requirements of I18NLEVEL=1,\n   as
    described in [IMAP-I18N], and SHOULD implement and advertise the\n   I18NLEVEL=1
    extension.  Alternatively, a server MAY implement\n   I18NLEVEL=2 (or higher)
    and comply with the rules of that level.\n      Discussion: The SORT and THREAD
    extensions predate [IMAP-I18N] by\n      several years.  At the time of this writing,
    all known server\n      implementations of SORT and THREAD comply with the rules
    of\n      I18NLEVEL=1, but do not necessarily advertise it.  As discussed in\n
    \     [IMAP-I18N] section 4.5, all server implementations should\n      eventually
    be updated to comply with the I18NLEVEL=2 extension.\n   Historical note: The
    REFERENCES threading algorithm is based on the\n   [THREADING] algorithm written
    and used in \"Netscape Mail and News\"\n   versions 2.0 through 3.0.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [KEYWORDS].\n   The
    word \"can\" (not \"may\") is used to refer to a possible\n   circumstance or
    situation, as opposed to an optional facility of the\n   protocol.\n   \"User\"
    is used to refer to a human user, whereas \"client\" refers to\n   the software
    being run by the user.\n   In examples, \"C:\" and \"S:\" indicate lines sent
    by the client and\n   server, respectively.\n"
  - contents:
    - "2.1.  Base Subject\n   Subject sorting and threading use the \"base subject\",
      which has\n   specific subject artifacts removed.  Due to the complexity of
      these\n   artifacts, the formal syntax for the subject extraction rules is\n
      \  ambiguous.  The following procedure is followed to determine the\n   \"base
      subject\", using the [ABNF] formal syntax rules described in\n   section 5:\n
      \     (1) Convert any RFC 2047 encoded-words in the subject to [UTF-8]\n          as
      described in \"Internationalization Considerations\".\n          Convert all
      tabs and continuations to space.  Convert all\n          multiple spaces to
      a single space.\n      (2) Remove all trailing text of the subject that matches
      the\n          subj-trailer ABNF; repeat until no more matches are possible.\n
      \     (3) Remove all prefix text of the subject that matches the subj-\n          leader
      ABNF.\n      (4) If there is prefix text of the subject that matches the subj-\n
      \         blob ABNF, and removing that prefix leaves a non-empty subj-\n          base,
      then remove the prefix text.\n      (5) Repeat (3) and (4) until no matches
      remain.\n   Note: It is possible to defer step (2) until step (6), but this\n
      \  requires checking for subj-trailer in step (4).\n      (6) If the resulting
      text begins with the subj-fwd-hdr ABNF and\n          ends with the subj-fwd-trl
      ABNF, remove the subj-fwd-hdr and\n          subj-fwd-trl and repeat from step
      (2).\n      (7) The resulting text is the \"base subject\" used in the SORT.\n
      \  All servers and disconnected (as described in [IMAP-MODELS]) clients\n   MUST
      use exactly this algorithm to determine the \"base subject\".\n   Otherwise,
      there is potential for a user to get inconsistent results\n   based on whether
      they are running in connected or disconnected mode.\n"
    title: 2.1.  Base Subject
  - contents:
    - "2.2.  Sent Date\n   As used in this document, the term \"sent date\" refers
      to the date and\n   time from the Date: header, adjusted by time zone to normalize
      to\n   UTC.  For example, \"31 Dec 2000 16:01:33 -0800\" is equivalent to the\n
      \  UTC date and time of \"1 Jan 2001 00:01:33 +0000\".\n   If the time zone
      is invalid, the date and time SHOULD be treated as\n   UTC.  If the time is
      also invalid, the time SHOULD be treated as\n   00:00:00.  If there is no valid
      date or time, the date and time\n   SHOULD be treated as 00:00:00 on the earliest
      possible date.\n   This differs from the date-related criteria in the SEARCH
      command\n   (described in [IMAP] section 6.4.4), which use just the date and
      not\n   the time, and are not adjusted by time zone.\n   If the sent date cannot
      be determined (a Date: header is missing or\n   cannot be parsed), the INTERNALDATE
      for that message is used as the\n   sent date.\n   When comparing two sent dates
      that match exactly, the order in which\n   the two messages appear in the mailbox
      (that is, by sequence number)\n   is used as a tie-breaker to determine the
      order.\n"
    title: 2.2.  Sent Date
  title: 2.  Terminology
- contents:
  - "3.  Additional Commands\n   These commands are extensions to the [IMAP] base
    protocol.\n   The section headings are intended to correspond with where they
    would\n   be located in the main document if they were part of the base\n   specification.\n"
  - "BASE.6.4.SORT. SORT Command\n   Arguments:  sort program\n               charset
    specification\n               searching criteria (one or more)\n   Data:       untagged
    responses: SORT\n   Result:     OK - sort completed\n               NO - sort
    error: can't sort that charset or\n                    criteria\n               BAD
    - command unknown or arguments invalid\n      The SORT command is a variant of
    SEARCH with sorting semantics for\n      the results.  There are two arguments
    before the searching\n      criteria argument: a parenthesized list of sort criteria,
    and the\n      searching charset.\n      The charset argument is mandatory (unlike
    SEARCH) and indicates\n      the [CHARSET] of the strings that appear in the searching\n
    \     criteria.  The US-ASCII and [UTF-8] charsets MUST be implemented.\n      All
    other charsets are optional.\n      There is also a UID SORT command that returns
    unique identifiers\n      instead of message sequence numbers.  Note that there
    are separate\n      searching criteria for message sequence numbers and UIDs;
    thus,\n      the arguments to UID SORT are interpreted the same as in SORT.\n
    \     This is analogous to the behavior of UID SEARCH, as opposed to UID\n      COPY,
    UID FETCH, or UID STORE.\n      The SORT command first searches the mailbox for
    messages that\n      match the given searching criteria using the charset argument
    for\n      the interpretation of strings in the searching criteria.  It then\n
    \     returns the matching messages in an untagged SORT response, sorted\n      according
    to one or more sort criteria.\n      Sorting is in ascending order.  Earlier dates
    sort before later\n      dates; smaller sizes sort before larger sizes; and strings
    are\n      sorted according to ascending values established by their\n      collation
    algorithm (see \"Internationalization Considerations\").\n      If two or more
    messages exactly match according to the sorting\n      criteria, these messages
    are sorted according to the order in\n      which they appear in the mailbox.
    \ In other words, there is an\n      implicit sort criterion of \"sequence number\".\n
    \     When multiple sort criteria are specified, the result is sorted in\n      the
    priority order that the criteria appear.  For example,\n      (SUBJECT DATE) will
    sort messages in order by their base subject\n      text; and for messages with
    the same base subject text, it will\n      sort by their sent date.\n      Untagged
    EXPUNGE responses are not permitted while the server is\n      responding to a
    SORT command, but are permitted during a UID SORT\n      command.\n      The defined
    sort criteria are as follows.  Refer to the Formal\n      Syntax section for the
    precise syntactic definitions of the\n      arguments.  If the associated RFC-822
    header for a particular\n      criterion is absent, it is treated as the empty
    string.  The empty\n      string always collates before non-empty strings.\n      ARRIVAL\n
    \        Internal date and time of the message.  This differs from the\n         ON
    criteria in SEARCH, which uses just the internal date.\n      CC\n         [IMAP]
    addr-mailbox of the first \"cc\" address.\n      DATE\n         Sent date and
    time, as described in section 2.2.\n      FROM\n         [IMAP] addr-mailbox of
    the first \"From\" address.\n      REVERSE\n         Followed by another sort
    criterion, has the effect of that\n         criterion but in reverse (descending)
    order.\n            Note: REVERSE only reverses a single criterion, and does not\n
    \           affect the implicit \"sequence number\" sort criterion if all\n            other
    criteria are identical.  Consequently, a sort of\n            REVERSE SUBJECT
    is not the same as a reverse ordering of a\n            SUBJECT sort.  This can
    be avoided by use of additional\n            criteria, e.g., SUBJECT DATE vs.
    REVERSE SUBJECT REVERSE\n            DATE.  In general, however, it's better (and
    faster, if the\n            client has a \"reverse current ordering\" command)
    to reverse\n            the results in the client instead of issuing a new SORT.\n
    \     SIZE\n         Size of the message in octets.\n      SUBJECT\n         Base
    subject text.\n      TO\n         [IMAP] addr-mailbox of the first \"To\" address.\n
    \  Example:    C: A282 SORT (SUBJECT) UTF-8 SINCE 1-Feb-1994\n               S:
    * SORT 2 84 882\n               S: A282 OK SORT completed\n               C: A283
    SORT (SUBJECT REVERSE DATE) UTF-8 ALL\n               S: * SORT 5 3 4 1 2\n               S:
    A283 OK SORT completed\n               C: A284 SORT (SUBJECT) US-ASCII TEXT \"not
    in mailbox\"\n               S: * SORT\n               S: A284 OK SORT completed\n"
  - 'BASE.6.4.THREAD. THREAD Command

    '
  - "Arguments:  threading algorithm\n            charset specification\n            searching
    criteria (one or more)\n"
  - 'Data:       untagged responses: THREAD

    '
  - "Result:     OK - thread completed\n            NO - thread error: can't thread
    that charset or\n                 criteria\n            BAD - command unknown
    or arguments invalid\n      The THREAD command is a variant of SEARCH with threading
    semantics\n      for the results.  Thread has two arguments before the searching\n
    \     criteria argument: a threading algorithm and the searching\n      charset.\n
    \     The charset argument is mandatory (unlike SEARCH) and indicates\n      the
    [CHARSET] of the strings that appear in the searching\n      criteria.  The US-ASCII
    and [UTF-8] charsets MUST be implemented.\n      All other charsets are optional.\n
    \     There is also a UID THREAD command that returns unique identifiers\n      instead
    of message sequence numbers.  Note that there are separate\n      searching criteria
    for message sequence numbers and UIDs; thus the\n      arguments to UID THREAD
    are interpreted the same as in THREAD.\n      This is analogous to the behavior
    of UID SEARCH, as opposed to UID\n      COPY, UID FETCH, or UID STORE.\n      The
    THREAD command first searches the mailbox for messages that\n      match the given
    searching criteria using the charset argument for\n      the interpretation of
    strings in the searching criteria.  It then\n      returns the matching messages
    in an untagged THREAD response,\n      threaded according to the specified threading
    algorithm.\n      All collation is in ascending order.  Earlier dates collate
    before\n      later dates and strings are collated according to ascending values\n
    \     established by their collation algorithm (see\n      \"Internationalization
    Considerations\").\n      Untagged EXPUNGE responses are not permitted while the
    server is\n      responding to a THREAD command, but are permitted during a UID\n
    \     THREAD command.\n      The defined threading algorithms are as follows:\n
    \     ORDEREDSUBJECT\n         The ORDEREDSUBJECT threading algorithm is also
    referred to as\n         \"poor man's threading\".  The searched messages are
    sorted by\n         base subject and then by the sent date.  The messages are
    then\n         split into separate threads, with each thread containing\n         messages
    with the same base subject text.  Finally, the threads\n         are sorted by
    the sent date of the first message in the thread.\n         The top level or \"root\"
    in ORDEREDSUBJECT threading contains\n         the first message of every thread.
    \ All messages in the root\n         are siblings of each other.  The second message
    of a thread is\n         the child of the first message, and subsequent messages
    of the\n         thread are siblings of the second message and hence children
    of\n         the message at the root.  Hence, there are no grandchildren in\n
    \        ORDEREDSUBJECT threading.\n         Children in ORDEREDSUBJECT threading
    do not have descendents.\n         Client implementations SHOULD treat descendents
    of a child in a\n         server response as being siblings of that child.\n      REFERENCES\n
    \        The REFERENCES threading algorithm threads the searched\n         messages
    by grouping them together in parent/child\n         relationships based on which
    messages are replies to others.\n         The parent/child relationships are built
    using two methods:\n         reconstructing a message's ancestry using the references\n
    \        contained within it; and checking the original (not base)\n         subject
    of a message to see if it is a reply to (or forward of)\n         another message.\n
    \           Note: \"Message ID\" in the following description refers to a\n            normalized
    form of the msg-id in [RFC2822].  The actual text\n            in RFC 2822 may
    use quoting, resulting in multiple ways of\n            expressing the same Message
    ID.  Implementations of the\n            REFERENCES threading algorithm MUST normalize
    any msg-id in\n            order to avoid false non-matches due to differences
    in\n            quoting.\n            For example, the msg-id\n               <\"01KF8JCEOCBS0045PS\"@xxx.yyy.com>\n
    \           and the msg-id\n               <01KF8JCEOCBS0045PS@xxx.yyy.com>\n
    \           MUST be interpreted as being the same Message ID.\n         The references
    used for reconstructing a message's ancestry are\n         found using the following
    rules:\n            If a message contains a References header line, then use the\n
    \           Message IDs in the References header line as the references.\n            If
    a message does not contain a References header line, or\n            the References
    header line does not contain any valid\n            Message IDs, then use the
    first (if any) valid Message ID\n            found in the In-Reply-To header line
    as the only reference\n            (parent) for this message.\n               Note:
    Although [RFC2822] permits multiple Message IDs in\n               the In-Reply-To
    header, in actual practice this\n               discipline has not been followed.
    \ For example,\n               In-Reply-To headers have been observed with message\n
    \              addresses after the Message ID, and there are no good\n               heuristics
    for software to determine the difference.\n               This is not a problem
    with the References header,\n               however.\n            If a message
    does not contain an In-Reply-To header line, or\n            the In-Reply-To header
    line does not contain a valid Message\n            ID, then the message does not
    have any references (NIL).\n         A message is considered to be a reply or
    forward if the base\n         subject extraction rules, applied to the original
    subject,\n         remove any of the following: a subj-refwd, a \"(fwd)\" subj-\n
    \        trailer, or a subj-fwd-hdr and subj-fwd-trl.\n         The REFERENCES
    algorithm is significantly more complex than\n         ORDEREDSUBJECT and consists
    of six main steps.  These steps are\n         outlined in detail below.\n         (1)
    For each searched message:\n             (A) Using the Message IDs in the message's
    references, link\n                 the corresponding messages (those whose Message-ID\n
    \                header line contains the given reference Message ID)\n                 together
    as parent/child.  Make the first reference the\n                 parent of the
    second (and the second a child of the\n                 first), the second the
    parent of the third (and the\n                 third a child of the second), etc.
    \ The following rules\n                 govern the creation of these links:\n
    \                    If a message does not contain a Message-ID header\n                     line,
    or the Message-ID header line does not\n                     contain a valid Message
    ID, then assign a unique\n                     Message ID to this message.\n                     If
    two or more messages have the same Message ID,\n                     then only
    use that Message ID in the first (lowest\n                     sequence number)
    message, and assign a unique\n                     Message ID to each of the subsequent
    messages with\n                     a duplicate of that Message ID.\n                     If
    no message can be found with a given Message ID,\n                     create
    a dummy message with this ID.  Use this\n                     dummy message for
    all subsequent references to this\n                     ID.\n                     If
    a message already has a parent, don't change the\n                     existing
    link.  This is done because the References\n                     header line may
    have been truncated by a Mail User\n                     Agent (MUA).  As a result,
    there is no guarantee\n                     that the messages corresponding to
    adjacent Message\n                     IDs in the References header line are parent
    and\n                     child.\n                     Do not create a parent/child
    link if creating that\n                     link would introduce a loop.  For
    example, before\n                     making message A the parent of B, make sure
    that A\n                     is not a descendent of B.\n                        Note:
    Message ID comparisons are case-sensitive.\n             (B) Create a parent/child
    link between the last reference\n                 (or NIL if there are no references)
    and the current\n                 message.  If the current message already has
    a parent,\n                 it is probably the result of a truncated References\n
    \                header line, so break the current parent/child link\n                 before
    creating the new correct one.  As in step 1.A,\n                 do not create
    the parent/child link if creating that\n                 link would introduce
    a loop.  Note that if this message\n                 has no references, it will
    now have no parent.\n                    Note: The parent/child links created
    in steps 1.A\n                    and 1.B MUST be kept consistent with one another
    at\n                    ALL times.\n         (2) Gather together all of the messages
    that have no parents\n             and make them all children (siblings of one
    another) of a\n             dummy parent (the \"root\").  These messages constitute
    the\n             first (head) message of the threads created thus far.\n         (3)
    Prune dummy messages from the thread tree.  Traverse each\n             thread
    under the root, and for each message:\n                 If it is a dummy message
    with NO children, delete it.\n                 If it is a dummy message with children,
    delete it, but\n                 promote its children to the current level.  In
    other\n                 words, splice them in with the dummy's siblings.\n                 Do
    not promote the children if doing so would make them\n                 children
    of the root, unless there is only one child.\n         (4) Sort the messages under
    the root (top-level siblings only)\n             by sent date as described in
    section 2.2.  In the case of a\n             dummy message, sort its children
    by sent date and then use\n             the first child for the top-level sort.\n
    \        (5) Gather together messages under the root that have the same\n             base
    subject text.\n             (A) Create a table for associating base subjects with\n
    \                messages, called the subject table.\n             (B) Populate
    the subject table with one message per each\n                 base subject.  For
    each child of the root:\n                 (i)   Find the subject of this thread,
    by using the\n                       base subject from either the current message
    or\n                       its first child if the current message is a\n                       dummy.
    \ This is the thread subject.\n                 (ii)  If the thread subject is
    empty, skip this\n                       message.\n                 (iii) Look
    up the message associated with the thread\n                       subject in the
    subject table.\n                 (iv)  If there is no message in the subject table
    with\n                       the thread subject, add the current message and\n
    \                      the thread subject to the subject table.\n                       Otherwise,
    if the message in the subject table is\n                       not a dummy, AND
    either of the following criteria\n                       are true:\n                           The
    current message is a dummy, OR\n                           The message in the
    subject table is a reply\n                           or forward and the current
    message is not.\n                       then replace the message in the subject
    table\n                       with the current message.\n             (C) Merge
    threads with the same thread subject.  For each\n                 child of the
    root:\n                 (i)   Find the message's thread subject as in step\n                       5.B.i
    above.\n                 (ii)  If the thread subject is empty, skip this\n                       message.\n
    \                (iii) Lookup the message associated with this thread\n                       subject
    in the subject table.\n                 (iv)  If the message in the subject table
    is the\n                       current message, skip this message.\n                 Otherwise,
    merge the current message with the one in\n                 the subject table
    using the following rules:\n                     If both messages are dummies,
    append the current\n                     message's children to the children of
    the message\n                     in the subject table (the children of both messages\n
    \                    become siblings), and then delete the current\n                     message.\n
    \                    If the message in the subject table is a dummy and\n                     the
    current message is not, make the current\n                     message a child
    of the message in the subject table\n                     (a sibling of its children).\n
    \                    If the current message is a reply or forward and\n                     the
    message in the subject table is not, make the\n                     current message
    a child of the message in the\n                     subject table (a sibling of
    its children).\n                     Otherwise, create a new dummy message and
    make both\n                     the current message and the message in the subject\n
    \                    table children of the dummy.  Then replace the\n                     message
    in the subject table with the dummy\n                     message.\n                        Note:
    Subject comparisons are case-insensitive,\n                        as described
    under \"Internationalization\n                        Considerations\".\n         (6)
    Traverse the messages under the root and sort each set of\n             siblings
    by sent date as described in section 2.2.\n             Traverse the messages
    in such a way that the \"youngest\" set\n             of siblings are sorted first,
    and the \"oldest\" set of\n             siblings are sorted last (grandchildren
    are sorted before\n             children, etc).  In the case of a dummy message
    (which can\n             only occur with top-level siblings), use its first child\n
    \            for sorting.\n   Example:    C: A283 THREAD ORDEREDSUBJECT UTF-8
    SINCE 5-MAR-2000\n               S: * THREAD (166)(167)(168)(169)(172)(170)(171)\n
    \                 (173)(174 (175)(176)(178)(181)(180))(179)(177\n                  (183)(182)(188)(184)(185)(186)(187)(189))(190)\n
    \                 (191)(192)(193)(194 195)(196 (197)(198))(199)\n                  (200
    202)(201)(203)(204)(205)(206 207)(208)\n               S: A283 OK THREAD completed\n
    \              C: A284 THREAD ORDEREDSUBJECT US-ASCII TEXT \"gewp\"\n               S:
    * THREAD\n               S: A284 OK THREAD completed\n               C: A285 THREAD
    REFERENCES UTF-8 SINCE 5-MAR-2000\n               S: * THREAD (166)(167)(168)(169)(172)((170)(179))\n
    \                 (171)(173)((174)(175)(176)(178)(181)(180))\n                  ((177)(183)(182)(188
    (184)(189))(185 186)(187))\n                  (190)(191)(192)(193)((194)(195 196))(197
    198)\n                  (199)(200 202)(201)(203)(204)(205 206 207)(208)\n               S:
    A285 OK THREAD completed\n             Note: The line breaks in the first and
    third server\n             responses are for editorial clarity and do not appear
    in\n             real THREAD responses.\n"
  title: 3.  Additional Commands
- contents:
  - "4.  Additional Responses\n   These responses are extensions to the [IMAP] base
    protocol.\n   The section headings of these responses are intended to correspond\n
    \  with where they would be located in the main document.\n"
  - "BASE.7.2.SORT. SORT Response\n   Data:       zero or more numbers\n      The
    SORT response occurs as a result of a SORT or UID SORT\n      command.  The number(s)
    refer to those messages that match the\n      search criteria.  For SORT, these
    are message sequence numbers;\n      for UID SORT, these are unique identifiers.
    \ Each number is\n      delimited by a space.\n   Example:    S: * SORT 2 3 6\n"
  - "BASE.7.2.THREAD. THREAD Response\n   Data:       zero or more threads\n      The
    THREAD response occurs as a result of a THREAD or UID THREAD\n      command.  It
    contains zero or more threads.  A thread consists of\n      a parenthesized list
    of thread members.\n      Thread members consist of zero or more message numbers,
    delimited\n      by spaces, indicating successive parent and child.  This continues\n
    \     until the thread splits into multiple sub-threads, at which point,\n      the
    thread nests into multiple sub-threads with the first member\n      of each sub-thread
    being siblings at this level.  There is no\n      limit to the nesting of threads.\n
    \     The messages numbers refer to those messages that match the search\n      criteria.
    \ For THREAD, these are message sequence numbers; for UID\n      THREAD, these
    are unique identifiers.\n   Example:    S: * THREAD (2)(3 6 (4 23)(44 7 96))\n
    \     The first thread consists only of message 2.  The second thread\n      consists
    of the messages 3 (parent) and 6 (child), after which it\n      splits into two
    sub-threads; the first of which contains messages\n      4 (child of 6, sibling
    of 44) and 23 (child of 4), and the second\n      of which contains messages 44
    (child of 6, sibling of 4), 7 (child\n      of 44), and 96 (child of 7).  Since
    some later messages are\n      parents of earlier messages, the messages were
    probably moved from\n      some other mailbox at different times.\n            --
    2\n            -- 3\n               \\-- 6\n                   |-- 4\n                   |
    \  \\-- 23\n                   |\n                   \\-- 44\n                        \\--
    7\n                            \\-- 96\n   Example:    S: * THREAD ((3)(5))\n
    \     In this example, 3 and 5 are siblings of a parent that does not\n      match
    the search criteria (and/or does not exist in the mailbox);\n      however they
    are members of the same thread.\n"
  title: 4.  Additional Responses
- contents:
  - "5.  Formal Syntax of SORT and THREAD Commands and Responses\n   The following
    syntax specification uses the Augmented Backus-Naur\n   Form (ABNF) notation as
    specified in [ABNF].  It also uses [ABNF]\n   rules defined in [IMAP].\n"
  - 'sort            = ["UID" SP] "SORT" SP sort-criteria SP search-criteria

    '
  - 'sort-criteria   = "(" sort-criterion *(SP sort-criterion) ")"

    '
  - 'sort-criterion  = ["REVERSE" SP] sort-key

    '
  - "sort-key        = \"ARRIVAL\" / \"CC\" / \"DATE\" / \"FROM\" / \"SIZE\" /\n                  \"SUBJECT\"
    / \"TO\"\n"
  - 'thread          = ["UID" SP] "THREAD" SP thread-alg SP search-criteria

    '
  - 'thread-alg      = "ORDEREDSUBJECT" / "REFERENCES" / thread-alg-ext

    '
  - "thread-alg-ext  = atom\n                    ; New algorithms MUST be registered
    with IANA\n"
  - 'search-criteria = charset 1*(SP search-key)

    '
  - "charset         = atom / quoted\n                    ; CHARSET values MUST be
    registered with IANA\n"
  - 'sort-data       = "SORT" *(SP nz-number)

    '
  - 'thread-data     = "THREAD" [SP 1*thread-list]

    '
  - 'thread-list     = "(" (thread-members / thread-nested) ")"

    '
  - 'thread-members  = nz-number *(SP nz-number) [SP thread-nested]

    '
  - "thread-nested   = 2*thread-list\n   The following syntax describes base subject
    extraction rules (2)-(6):\n"
  - 'subject         = *subj-leader [subj-middle] *subj-trailer

    '
  - 'subj-refwd      = ("re" / ("fw" ["d"])) *WSP [subj-blob] ":"

    '
  - 'subj-blob       = "[" *BLOBCHAR "]" *WSP

    '
  - 'subj-fwd        = subj-fwd-hdr subject subj-fwd-trl

    '
  - 'subj-fwd-hdr    = "[fwd:"

    '
  - 'subj-fwd-trl    = "]"

    '
  - 'subj-leader     = (*subj-blob subj-refwd) / WSP

    '
  - "subj-middle     = *subj-blob (subj-base / subj-fwd)\n                    ; last
    subj-blob is subj-base if subj-base would\n                    ; otherwise be
    empty\n"
  - 'subj-trailer    = "(fwd)" / WSP

    '
  - "subj-base       = NONWSP *(*WSP NONWSP)\n                    ; can be a subj-blob\n"
  - "BLOBCHAR        = %x01-5a / %x5c / %x5e-ff\n                    ; any CHAR8 except
    '[' and ']'.\n                    ; SHOULD comply with [UTF-8]\n"
  - "NONWSP          = %x01-08 / %x0a-1f / %x21-ff\n                    ; any CHAR8
    other than WSP.\n                    ; SHOULD comply with [UTF-8]\n"
  title: 5.  Formal Syntax of SORT and THREAD Commands and Responses
- contents:
  - "6.  Security Considerations\n   The SORT and THREAD extensions do not raise any
    security\n   considerations that are not present in the base [IMAP] protocol,
    and\n   these issues are discussed in [IMAP].  Nevertheless, it is important\n
    \  to remember that [IMAP] protocol transactions, including message\n   data,
    are sent in the clear over the network unless protection from\n   snooping is
    negotiated, either by the use of STARTTLS, privacy\n   protection in AUTHENTICATE,
    or some other protection mechanism.\n   Although not a security consideration,
    it is important to recognize\n   that sorting by REFERENCES can lead to misleading
    threading trees.\n   For example, a message with false References: header data
    will cause\n   a thread to be incorporated into another thread.\n   The process
    of extracting the base subject may lead to incorrect\n   collation if the extracted
    data was significant text as opposed to a\n   subject artifact.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  Internationalization Considerations\n   As stated in the introduction, the
    rules of I18NLEVEL=1 as described\n   in [IMAP-I18N] MUST be followed; that is,
    the SORT and THREAD\n   extensions MUST collate strings according to the i;unicode-casemap\n
    \  collation described in [UNICASEMAP].  Servers SHOULD also advertise\n   the
    I18NLEVEL=1 extension.  Alternatively, a server MAY implement\n   I18NLEVEL=2
    (or higher) and comply with the rules of that level.\n   As discussed in [IMAP-I18N]
    section 4.5, all server implementations\n   should eventually be updated to support
    the [IMAP-I18N] I18NLEVEL=2\n   extension.\n   Translations of the \"re\" or \"fw\"/\"fwd\"
    tokens are not specified for\n   removal in the base subject extraction process.
    \ An attempt to add\n   such translated tokens would result in a geometrically
    complex, and\n   ultimately unimplementable, task.\n   Instead, note that [RFC2822]
    section 3.6.5 recommends that \"re:\"\n   (from the Latin \"res\", meaning \"in
    the matter of\") be used to\n   identify a reply.  Although it is evident that,
    from the multiple\n   forms of token to identify a forwarded message, there is
    considerable\n   variation found in the wild, the variations are (still) manageable.\n
    \  Consequently, it is suggested that \"re:\" and one of the variations of\n   the
    tokens for a forward supported by the base subject extraction\n   rules be adopted
    for Internet mail messages, since doing so makes it\n   a simple display-time
    task to localize the token language for the\n   user.\n"
  title: 7.  Internationalization Considerations
- contents:
  - "8.  IANA Considerations\n   [IMAP] capabilities are registered by publishing
    a standards track or\n   IESG-approved experimental RFC.  This document constitutes\n
    \  registration of the SORT and THREAD capabilities in the [IMAP]\n   capabilities
    registry.\n   This document creates a new [IMAP] threading algorithms registry,\n
    \  which registers threading algorithms by publishing a standards track\n   or
    IESG-approved experimental RFC.  This document constitutes\n   registration of
    the ORDEREDSUBJECT and REFERENCES algorithms in that\n   registry.\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Normative References\n   [ABNF]        Crocker, D., Ed., and P. Overell,
    \"Augmented BNF for\n                 Syntax Specifications: ABNF\", STD 68, RFC
    5234, January\n                 2008.\n   [CHARSET]     Freed, N. and J. Postel,
    \"IANA Charset Registration\n                 Procedures\", BCP 19, RFC 2978,
    October 2000.\n   [IMAP]        Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL
    -\n                 VERSION 4rev1\", RFC 3501, March 2003.\n   [IMAP-I18N]   Newman,
    C., Gulbrandsen, A., and A. Melnikov, \"Internet\n                 Message Access
    Protocol Internationalization\", RFC\n                 5255, June 2008.\n   [KEYWORDS]
    \   Bradner, S., \"Key words for use in RFCs to Indicate\n                 Requirement
    Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2822]     Resnick, P., Ed., \"Internet
    Message Format\", RFC 2822,\n                 April 2001.\n   [UNICASEMAP]  Crispin,
    M., \"i;unicode-casemap - Simple Unicode\n                 Collation Algorithm\",
    RFC 5051, October 2007.\n   [UTF-8]       Yergeau, F., \"UTF-8, a transformation
    format of ISO\n                 10646\", STD 63, RFC 3629, November 2003.\n"
  title: 9.  Normative References
- contents:
  - "10.  Informative References\n   [IMAP-MODELS] Crispin, M., \"Distributed Electronic
    Mail Models in\n                 IMAP4\", RFC 1733, December 1994.\n   [THREADING]
    \  Zawinski, J. \"Message Threading\",\n                 http://www.jwz.org/doc/threading.html,
    1997-2002.\n"
  title: 10.  Informative References
- contents:
  - "Authors' Addresses\n   Mark R. Crispin\n   Panda Programming\n   6158 NE Lariat
    Loop\n   Bainbridge Island, WA 98110-2098\n   Phone: +1 (206) 842-2385\n   EMail:
    IMAP+SORT+THREAD@Lingling.Panda.COM\n   Kenneth Murchison\n   Carnegie Mellon
    University\n   5000 Forbes Avenue\n   Cyert Hall 285\n   Pittsburgh, PA  15213\n
    \  Phone: +1 (412) 268-2638\n   EMail: murch@andrew.cmu.edu\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
