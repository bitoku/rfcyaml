- contents:
  - "   IMAP Extensions: Quick Flag Changes Resynchronization (CONDSTORE)\n             and
    Quick Mailbox Resynchronization (QRESYNC)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   Often, multiple IMAP (RFC 3501) clients need to coordinate changes
    to\n   a common IMAP mailbox.  Examples include different clients working on\n
    \  behalf of the same user and multiple users accessing shared\n   mailboxes.
    \ These clients need a mechanism to efficiently synchronize\n   state changes
    for messages within the mailbox.\n   Initially defined in RFC 4551, the Conditional
    Store facility\n   provides a protected update mechanism for message state information\n
    \  and a mechanism for requesting only changes to the message state.\n   This
    memo updates that mechanism and obsoletes RFC 4551, based on\n   operational experience.\n
    \  This document additionally updates another IMAP extension, Quick\n   Resynchronization,
    which builds on the Conditional STORE extension to\n   provide an IMAP client
    the ability to fully resynchronize a mailbox\n   as part of the SELECT/EXAMINE
    command, without the need for\n   additional server-side state or client round
    trips.  Hence, this memo\n   obsoletes RFC 5162.\n   Finally, this document also
    updates the line-length recommendation in\n   Section 3.2.1.5 of RFC 2683.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7162.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Requirements Notation . . . . . . . . . . . . . . . . .
    . . .   5\n   3.  IMAP Protocol Changes . . . . . . . . . . . . . . . . . . .
    .   5\n     3.1.  CONDSTORE Extension . . . . . . . . . . . . . . . . . . .   5\n
    \      3.1.1.  Advertising Support for CONDSTORE . . . . . . . . . .   8\n       3.1.2.
    \ New OK Untagged Responses for SELECT and EXAMINE  . .   8\n       3.1.3.  STORE
    and UID STORE Commands  . . . . . . . . . . . .  10\n       3.1.4.  FETCH and
    UID FETCH Commands  . . . . . . . . . . . .  16\n       3.1.5.  MODSEQ Search
    Criterion in SEARCH . . . . . . . . . .  19\n       3.1.6.  Modified SEARCH Untagged
    Response . . . . . . . . . .  20\n       3.1.7.  HIGHESTMODSEQ Status Data Items
    . . . . . . . . . . .  21\n       3.1.8.  CONDSTORE Parameter to SELECT and EXAMINE
    . . . . . .  21\n       3.1.9.  Interaction with IMAP SORT and THREAD Extensions
    \ . .  22\n       3.1.10. Interaction with IMAP ESORT and ESEARCH Extensions  .
    \ 22\n       3.1.11. Additional Quality-of-Implementation Issues . . . . .  23\n
    \      3.1.12. CONDSTORE Server Implementation Considerations  . . .  23\n     3.2.
    \ QRESYNC Extension . . . . . . . . . . . . . . . . . . . .  24\n       3.2.1.
    \ Impact on CONDSTORE-only Clients  . . . . . . . . . .  25\n       3.2.2.  Advertising
    Support for QRESYNC . . . . . . . . . . .  25\n       3.2.3.  Use of ENABLE .
    . . . . . . . . . . . . . . . . . . .  25\n       3.2.4.  Additional Requirements
    on QRESYNC Servers  . . . . .  26\n       3.2.5.  QRESYNC Parameter to SELECT/EXAMINE
    . . . . . . . . .  26\n       3.2.6.  VANISHED UID FETCH Modifier . . . . . .
    . . . . . . .  31\n       3.2.7.  EXPUNGE Command . . . . . . . . . . . . . .
    . . . . .  32\n       3.2.8.  CLOSE Command . . . . . . . . . . . . . . . . .
    . . .  33\n       3.2.9.  UID EXPUNGE Command . . . . . . . . . . . . . . . .
    .  34\n       3.2.10. VANISHED Response . . . . . . . . . . . . . . . . . .  35\n
    \      3.2.11. CLOSED Response Code  . . . . . . . . . . . . . . . .  38\n   4.
    \ Long Command Lines (Update to RFC 2683) . . . . . . . . . . .  39\n   5.  QRESYNC
    Server Implementation Considerations  . . . . . . . .  39\n     5.1.  Server Implementations
    That Don't Store Extra State . . .  39\n     5.2.  Server Implementations Storing
    Minimal State  . . . . . .  40\n     5.3.  Additional State Required on the Server
    . . . . . . . . .  40\n   6.  Updated Synchronization Sequence  . . . . . . .
    . . . . . . .  41\n   7.  Formal Syntax . . . . . . . . . . . . . . . . . . .
    . . . . .  44\n   8.  Security Considerations . . . . . . . . . . . . . . . .
    . . .  48\n   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . .
    .  48\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  48\n
    \    10.1.  Normative References . . . . . . . . . . . . . . . . . .  48\n     10.2.
    \ Informative References . . . . . . . . . . . . . . . . .  49\n   Appendix A.
    \ Changes since RFC 4551 . . . . . . . . . . . . . . .  50\n   Appendix B.  Changes
    since RFC 5162 . . . . . . . . . . . . . . .  50\n   Appendix C.  Acknowledgements
    . . . . . . . . . . . . . . . . . .  51\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Often, multiple IMAP [RFC3501] clients need to coordinate
    changes to\n   a common IMAP mailbox.  Examples include different clients working
    on\n   behalf of the same user and clients representing multiple users\n   accessing
    shared mailboxes.  These clients need a mechanism to\n   synchronize state changes
    for messages within the mailbox.  The\n   Conditional Store (\"CONDSTORE\") facility
    allows a client to quickly\n   resynchronize mailbox flag changes.\n   The Conditional
    Store facility also provides a protected update\n   mechanism for message state
    information that can detect and resolve\n   conflicts between multiple writing
    mail clients.  The mechanism can\n   be used to guarantee that only one client
    can change the message\n   state at any given time.  For example, this can be
    used by multiple\n   clients that treat a mailbox as a message queue.\n   The
    Conditional Store facility is provided by associating a\n   modification sequence
    (mod-sequence) with every IMAP message.  This\n   is updated whenever metadata
    (such as a message flag) is modified.\n   The CONDSTORE extension is described
    in more detail in Section 3.1.\n   The CONDSTORE extension gives a disconnected
    client the ability to\n   quickly resynchronize IMAP flag changes for previously
    seen messages.\n   This can be done using the CHANGEDSINCE FETCH modifier once
    a mailbox\n   is opened.  In order for the client to discover which messages have\n
    \  been expunged, the client still has to issue a UID FETCH or a UID\n   SEARCH
    command.  The Quick Mailbox Resynchronization (QRESYNC) IMAP\n   extension is
    an extension to CONDSTORE that allows a reconnecting\n   client to perform full
    resynchronization, including discovery of\n   expunged messages, in a single round
    trip.  QRESYNC also introduces a\n   new response, VANISHED, that allows for a
    more compact representation\n   of a list of expunged messages.\n   QRESYNC can
    be useful for mobile clients that can experience frequent\n   disconnects caused
    by environmental factors (such as battery life,\n   signal strength, etc.).  Such
    clients need a way to quickly reconnect\n   to the IMAP server, while minimizing
    delay experienced by the user as\n   well as the amount of traffic generated by
    resynchronization.\n   By extending the SELECT command to perform the additional\n
    \  resynchronization, this also allows clients to reduce concurrent\n   connections
    to the IMAP server held purely for the sake of avoiding\n   the resynchronization.\n
    \  The QRESYNC extension is described in more detail in Section 3.2.\n"
  title: 1.  Introduction
- contents:
  - "2.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n
    \  In the examples that follow, \"C:\" and \"S:\" indicate lines sent by the\n
    \  client and server, respectively.  If a single \"C:\" or \"S:\" label\n   applies
    to multiple lines, then the line breaks between those lines\n   are for editorial
    clarity only and are not part of the actual\n   protocol exchange.  The five characters
    [...] means that something\n   has been elided.\n   Formal syntax is defined using
    ABNF [RFC5234].\n   The term \"metadata\" or \"metadata item\" is used throughout
    this\n   document.  It refers to any system- or user-defined keyword.  If the\n
    \  server supports the IMAP ANNOTATE-EXPERIMENT-1 extension [RFC5257],\n   then
    metadata also includes message annotations.  Future documents\n   may extend \"metadata\"
    to include other dynamic message data.\n   Some IMAP mailboxes are private, accessible
    only to the owning user.\n   Other mailboxes are not, either because the owner
    has set an Access\n   Control List [RFC4314] that permits access by other users
    or because\n   it is a shared mailbox.  Let's call a metadata item \"shared\"
    for the\n   mailbox if any changes to the metadata items are persistent and\n
    \  visible to all other users accessing the mailbox.  Otherwise, the\n   metadata
    item is called \"private\".  Note that private metadata items\n   are still visible
    to all sessions accessing the mailbox as the same\n   user.  Also, note that different
    mailboxes may have different\n   metadata items as shared.\n   See Section 3.1
    for the definition of a \"CONDSTORE-aware client\" and\n   a \"CONDSTORE enabling
    command\".\n   Understanding of the IMAP message sequence numbers and UIDs (see\n
    \  Section 2.3.1 of [RFC3501]) and the EXPUNGE response (see\n   Section 7.4.1
    of [RFC3501]) is essential when reading this document.\n"
  title: 2.  Requirements Notation
- contents:
  - '3.  IMAP Protocol Changes

    '
  - contents:
    - "3.1.  CONDSTORE Extension\n   An IMAP server that supports CONDSTORE MUST associate
      a positive\n   unsigned 63-bit (*) value, called a mod-sequence, with every
      IMAP\n   message.  This is an opaque value updated by the server whenever a\n
      \  metadata item is modified.  The server MUST guarantee that each STORE\n   command
      performed on the same mailbox (including simultaneous stores\n   to different
      metadata items from different connections) will get a\n   different mod-sequence
      value.  Also, for any two successful STORE\n   operations performed in the same
      session on the same mailbox, the\n   mod-sequence of the second completed operation
      MUST be greater than\n   the mod-sequence of the first completed operation.
      \ Note that the\n   latter rule disallows the direct use of the system clock
      as a mod-\n   sequence because if system time changes (e.g., an NTP [NTP] client\n
      \  adjusting the time), the next generated value might be less than the\n   previous
      one.\n   (*) Note: RFC 4551 defined mod-sequences as unsigned 64-bit values.\n
      \  In order to make implementations on various platforms (such as Java)\n   easier,
      this version of the document redefines them as unsigned\n   63-bit values.\n
      \  These rules allow a client to list all metadata changes since a well-\n   known
      point in time, as well as to perform conditional metadata\n   modifications
      based on an assumption that the metadata state hasn't\n   changed for a particular
      message.\n   In particular, mod-sequences allow a client that supports the\n
      \  CONDSTORE extension to determine if a message metadata has changed\n   since
      some known moment.  Whenever the state of a flag changes (i.e.,\n   the flag
      is added where previously it wasn't set, or the flag is\n   removed where previously
      it was set), the value of the modification\n   sequence for the message MUST
      be updated.  Setting a flag that is\n   already set, or clearing a flag that
      is not set, SHOULD NOT change\n   the mod-sequence.\n   When a message is appended
      to a mailbox (via the IMAP APPEND command,\n   COPY to the mailbox, or using
      an external mechanism), the server\n   generates a new modification sequence
      that is higher than the highest\n   modification sequence of all messages in
      the mailbox and assigns it\n   to the appended message.\n   The server MAY store
      separate (per-message) modification sequence\n   values for different metadata
      items.  If the server does so, per-\n   message mod-sequence is the highest
      mod-sequence of all metadata\n   items accessible to the currently logged-in
      user for the specified\n   message.\n   The server that supports CONDSTORE is
      not required to be able to\n   store mod-sequences for every available mailbox.
      \ Section 3.1.2.2\n   describes how the server may act if a particular mailbox
      doesn't\n   support the persistent storage of mod-sequences.\n   CONDSTORE makes
      the following changes to the IMAP4 protocol:\n   a.  adds the UNCHANGEDSINCE
      STORE modifier.\n   b.  adds the MODIFIED response code that is used with an
      OK response\n       to the STORE command.  (It can also be used in a NO response.)\n
      \  c.  adds a new MODSEQ message data item for use with the FETCH\n       command.\n
      \  d.  adds the CHANGEDSINCE FETCH modifier.\n   e.  adds a new MODSEQ search
      criterion.\n   f.  extends the syntax of untagged SEARCH and ESEARCH responses
      to\n       include mod-sequence.\n   g.  adds new OK untagged responses (HIGHESTMODSEQ
      and NOMODSEQ) for\n       the SELECT and EXAMINE commands.\n   h.  defines an
      additional CONDSTORE parameter to SELECT/EXAMINE\n       commands.\n   i.  adds
      the HIGHESTMODSEQ status data item to the STATUS command.\n   A client supporting
      the CONDSTORE extension indicates its willingness\n   to receive mod-sequence
      updates in all untagged FETCH responses by\n   issuing one of the following,
      which are called \"CONDSTORE enabling\n   commands\":\n   o  a SELECT or EXAMINE
      command with the CONDSTORE parameter,\n   o  a STATUS (HIGHESTMODSEQ) command,\n
      \  o  a FETCH or SEARCH command that includes the MODSEQ message data\n      item,\n
      \  o  a FETCH command with the CHANGEDSINCE modifier,\n   o  a STORE command
      with the UNCHANGEDSINCE modifier, or\n   o  an ENABLE command containing \"CONDSTORE\"
      as one of the parameters.\n      (This option only applies when the client is
      communicating with a\n      server that also implements the ENABLE extension
      [RFC5161].)\n   Once a client issues a CONDSTORE enabling command, it has announced\n
      \  itself as a \"CONDSTORE-aware client\".  The server MUST then include\n   mod-sequence
      data in all subsequent untagged FETCH responses (until\n   the connection is
      closed), whether they were caused by a regular\n   STORE, a STORE with an UNCHANGEDSINCE
      modifier, or an external agent.\n   A future extension to this document may
      extend the list of CONDSTORE\n   enabling commands.  A first CONDSTORE enabling
      command executed in\n   the session with a mailbox selected MUST cause the server
      to return\n   HIGHESTMODSEQ (Section 3.1.2.1) for the mailbox (if any is selected),\n
      \  unless the server has sent a NOMODSEQ (Section 3.1.2.2) response code\n   when
      the currently selected mailbox was selected.\n"
    - contents:
      - "3.1.1.  Advertising Support for CONDSTORE\n   The Conditional STORE extension
        is present in any IMAP4\n   implementation that returns \"CONDSTORE\" as one
        of the supported\n   capabilities in the CAPABILITY command response.\n"
      title: 3.1.1.  Advertising Support for CONDSTORE
    - contents:
      - "3.1.2.  New OK Untagged Responses for SELECT and EXAMINE\n   This document
        adds two new response codes: HIGHESTMODSEQ and\n   NOMODSEQ.  One of these
        two response codes MUST be returned in an OK\n   untagged response for any
        successful SELECT/EXAMINE command issued\n   after a CONDSTORE enabling command.\n
        \  When opening a mailbox, the server must check if the mailbox supports\n
        \  the persistent storage of mod-sequences.  If the mailbox supports the\n
        \  persistent storage of mod-sequences and the mailbox open operation\n   succeeds,
        the server MUST send an OK untagged response, including the\n   HIGHESTMODSEQ
        response code.  If the persistent storage for the\n   mailbox is not supported,
        the server MUST send an OK untagged\n   response, including the NOMODSEQ response
        code instead.\n"
      - contents:
        - "3.1.2.1.  HIGHESTMODSEQ Response Code\n   This document adds a new response
          code that is returned in an OK\n   untagged response for the SELECT and
          EXAMINE commands.  Once a\n   CONDSTORE enabling command is issued, a server
          supporting the\n   persistent storage of mod-sequences for the mailbox MUST
          send an OK\n   untagged response, including the HIGHESTMODSEQ response code
          with\n   every successful SELECT or EXAMINE command:\n      OK [HIGHESTMODSEQ
          <mod-sequence-value>]\n      where <mod-sequence-value> is the highest mod-sequence
          value of\n      all messages in the mailbox.  When the server changes UIDVALIDITY\n
          \     for a mailbox, it doesn't have to keep the same HIGHESTMODSEQ for\n
          \     the mailbox.\n   Note that some existing CONDSTORE servers don't start
          tracking mod-\n   sequences or don't report them until after a CONDSTORE
          enabling\n   command is issued.  Because of that, a client wishing to receive\n
          \  HIGHESTMODSEQ/NOMODSEQ information must first send a CONDSTORE\n   enabling
          command, for example, by using SELECT/EXAMINE with the\n   CONDSTORE parameter
          (see Section 3.1.8).\n   A disconnected client can use the value of HIGHESTMODSEQ
          to check if\n   it has to refetch metadata from the server.  If the UIDVALIDITY
          value\n   has changed for the selected mailbox, the client MUST delete the\n
          \  cached value of HIGHESTMODSEQ.  If UIDVALIDITY for the mailbox is the\n
          \  same, and if the HIGHESTMODSEQ value stored in the client's cache is\n
          \  less than the value returned by the server, then some metadata items\n
          \  on the server have changed since the last synchronization, and the\n
          \  client needs to update its cache.  The client MAY use SEARCH MODSEQ\n
          \  (Section 3.1.5) to find out exactly which metadata items have\n   changed.
          \ Alternatively, the client MAY issue FETCH with the\n   CHANGEDSINCE modifier
          (Section 3.1.4.1) in order to fetch data for\n   all messages that have
          metadata items changed since some known\n   modification sequence.\n   C:
          A142 SELECT INBOX\n   S: * 172 EXISTS\n   S: * 1 RECENT\n   S: * OK [UNSEEN
          12] Message 12 is first unseen\n   S: * OK [UIDVALIDITY 3857529045] UIDs
          valid\n   S: * OK [UIDNEXT 4392] Predicted next UID\n   S: * FLAGS (\\Answered
          \\Flagged \\Deleted \\Seen \\Draft)\n   S: * OK [PERMANENTFLAGS (\\Deleted
          \\Seen \\*)] Limited\n   S: * OK [HIGHESTMODSEQ 715194045007]\n   S: A142
          OK [READ-WRITE] SELECT completed\n                                 Example
          1\n"
        title: 3.1.2.1.  HIGHESTMODSEQ Response Code
      - contents:
        - "3.1.2.2.  NOMODSEQ Response Code\n   Once a CONDSTORE enabling command
          is issued, a server that doesn't\n   support the persistent storage of mod-sequences
          for the mailbox MUST\n   send an OK untagged response, including the NOMODSEQ
          response code\n   with every successful SELECT or EXAMINE command.  Note
          that some\n   existing CONDSTORE servers don't return NOMODSEQ until after
          a\n   CONDSTORE enabling command is issued.  Because of that, a client\n
          \  wishing to receive HIGHESTMODSEQ/NOMODSEQ information must first send\n
          \  a CONDSTORE enabling command, for example, by using SELECT/EXAMINE\n
          \  with the CONDSTORE parameter (see Section 3.1.8).\n   A server that returned
          the NOMODSEQ response code for a mailbox MUST\n   reject (with a tagged
          BAD response) any of the following commands\n   while the mailbox remains
          selected:\n   o  a FETCH command with the CHANGEDSINCE modifier,\n   o  a
          FETCH or SEARCH command that includes the MODSEQ message data\n      item,
          or\n   o  a STORE command with the UNCHANGEDSINCE modifier.\n   C: A142
          SELECT INBOX\n   S: * 172 EXISTS\n   S: * 1 RECENT\n   S: * OK [UNSEEN 12]
          Message 12 is first unseen\n   S: * OK [UIDVALIDITY 3857529045] UIDs valid\n
          \  S: * OK [UIDNEXT 4392] Predicted next UID\n   S: * FLAGS (\\Answered
          \\Flagged \\Deleted \\Seen \\Draft)\n   S: * OK [PERMANENTFLAGS (\\Deleted
          \\Seen \\*)] Limited\n   S: * OK [NOMODSEQ] Sorry, this mailbox format doesn't
          support\n       modsequences\n   S: A142 OK [READ-WRITE] SELECT completed\n
          \                                Example 2\n"
        title: 3.1.2.2.  NOMODSEQ Response Code
      title: 3.1.2.  New OK Untagged Responses for SELECT and EXAMINE
    - contents:
      - "3.1.3.  STORE and UID STORE Commands\n   This document defines the following
        STORE modifier (see Section 2.5\n   of [RFC4466]):\n   UNCHANGEDSINCE <mod-sequence>\n
        \  For each message specified in the message set, the server performs\n   the
        following.  If the mod-sequence of every metadata item of the\n   message
        affected by the STORE/UID STORE is equal to or less than the\n   specified
        UNCHANGEDSINCE value, then the requested operation (as\n   described by the
        message data item) is performed.  If the operation\n   is successful, the
        server MUST update the mod-sequence attribute of\n   the message.  An untagged
        FETCH response MUST be sent, even if the\n   .SILENT suffix is specified,
        and the response MUST include the MODSEQ\n   message data item.  This is required
        to update the client's cache\n   with the correct mod-sequence values.  See
        Section 3.1.4.2 for more\n   details.\n   However, if the mod-sequence of
        any metadata item of the message is\n   greater than the specified UNCHANGEDSINCE
        value, then the requested\n   operation MUST NOT be performed.  In this case,
        the mod-sequence\n   attribute of the message is not updated, and the message
        number (or\n   unique identifier in the case of the UID STORE command) is
        added to\n   the list of messages that failed the UNCHANGEDSINCE test.\n   When
        the server finishes performing the operation on all the messages\n   in the
        message set, it checks for a non-empty list of messages that\n   failed the
        UNCHANGEDSINCE test.  If this list is non-empty, the\n   server MUST return
        in the tagged response a MODIFIED response code.\n   The MODIFIED response
        code includes the message set (for STORE) or\n   set of UIDs (for UID STORE)
        of all messages that failed the\n   UNCHANGEDSINCE test.\n   All messages
        pass the UNCHANGEDSINCE test.\n   C: a103 UID STORE 6,4,8 (UNCHANGEDSINCE
        12121230045)\n       +FLAGS.SILENT (\\Deleted)\n   S: * 1 FETCH (UID 4 MODSEQ
        (12121231000))\n   S: * 2 FETCH (UID 6 MODSEQ (12121230852))\n   S: * 4 FETCH
        (UID 8 MODSEQ (12121230956))\n   S: a103 OK Conditional Store completed\n
        \                                Example 3\n   C: a104 STORE * (UNCHANGEDSINCE
        12121230045) +FLAGS.SILENT\n       (\\Deleted $Processed)\n   S: * 50 FETCH
        (MODSEQ (12111230047))\n   S: a104 OK Store (conditional) completed\n                                 Example
        4\n   C: c101 STORE 50 (UNCHANGEDSINCE 12121230045) -FLAGS.SILENT\n       (\\Deleted)\n
        \  S: * OK [HIGHESTMODSEQ 12111230047]\n   S: * 50 FETCH (MODSEQ (12111230048))\n
        \  S: c101 OK Store (conditional) completed\n   The HIGHESTMODSEQ response
        code was sent by the server presumably\n   because this was the first CONDSTORE
        enabling command.\n                                 Example 5\n   The failure
        of the conditional STORE operation for any particular\n   message or messages
        (7 in this example) does not stop the server from\n   finding all messages
        that fail the UNCHANGEDSINCE test.  All such\n   messages are returned in
        the MODIFIED response code.\n   C: d105 STORE 7,5,9 (UNCHANGEDSINCE 320162338)\n
        \      +FLAGS.SILENT (\\Deleted)\n   S: * 5 FETCH (MODSEQ (320162350))\n   S:
        d105 OK [MODIFIED 7,9] Conditional STORE failed\n                                 Example
        6\n   Same as above, but the server follows the SHOULD recommendation in\n
        \  Section 6.4.6 of [RFC3501].\n   C: d105 STORE 7,5,9 (UNCHANGEDSINCE 320162338)\n
        \      +FLAGS.SILENT (\\Deleted)\n   S: * 7 FETCH (MODSEQ (320162342) FLAGS
        (\\Seen \\Deleted))\n   S: * 5 FETCH (MODSEQ (320162350))\n   S: * 9 FETCH
        (MODSEQ (320162349) FLAGS (\\Answered))\n   S: d105 OK [MODIFIED 7,9] Conditional
        STORE failed\n   Use of UNCHANGEDSINCE with a modification sequence of 0 always
        fails\n   if the metadata item exists.  A system flag MUST always be considered\n
        \  existent, whether it was set or not.\n                                 Example
        7\n   C: a102 STORE 12 (UNCHANGEDSINCE 0)\n       +FLAGS.SILENT ($MDNSent)\n
        \  S: a102 OK [MODIFIED 12] Conditional STORE failed\n   The client has tested
        the presence of the $MDNSent user-defined\n   keyword.\n                                 Example
        8\n   Note: A client trying to make an atomic change to the state of a\n   particular
        metadata item (or a set of metadata items) MUST be\n   prepared to deal with
        the case when the server returns the MODIFIED\n   response code if the state
        of the metadata item being watched hasn't\n   changed (but the state of some
        other metadata item has).  This is\n   necessary because some servers don't
        store separate mod-sequences for\n   different metadata items.  However, a
        server implementation SHOULD\n   avoid generating spurious MODIFIED responses
        for +FLAGS/-FLAGS STORE\n   operations, even when the server stores a single
        mod-sequence per\n   message.  Section 3.1.12 describes how this can be achieved.\n
        \  Unless the server has included an unsolicited FETCH to update the\n   client's
        knowledge about messages that have failed the UNCHANGEDSINCE\n   test, upon
        receipt of the MODIFIED response code, the client SHOULD\n   try to figure
        out if the required metadata items have indeed changed\n   by issuing the
        FETCH or NOOP command.  It is RECOMMENDED that the\n   server avoids the need
        for the client to do that by sending an\n   unsolicited FETCH response (see
        Examples 9 and 10).\n   If the required metadata items haven't changed, the
        client SHOULD\n   retry the command with the new mod-sequence.  The client
        needs to\n   allow for a reasonable number of retries (at least 2).\n   In
        the example below, the server returns the MODIFIED response code\n   without
        sending information describing why the STORE UNCHANGEDSINCE\n   operation
        has failed.\n   C: a106 STORE 100:150 (UNCHANGEDSINCE 212030000000)\n       +FLAGS.SILENT
        ($Processed)\n   S: * 100 FETCH (MODSEQ (303181230852))\n   S: * 102 FETCH
        (MODSEQ (303181230852))\n      ...\n   S: * 150 FETCH (MODSEQ (303181230852))\n
        \  S: a106 OK [MODIFIED 101] Conditional STORE failed\n   The flag $Processed
        was set on the message 101...\n   C: a107 NOOP\n   S: * 101 FETCH (MODSEQ
        (303011130956) FLAGS ($Processed))\n   S: a107 OK\n                                 Example
        9\n   Or, the flag hasn't changed, but another has (note that this server\n
        \  behavior is discouraged.  Server implementers should also see\n   Section
        3.1.12)...\n   C: b107 NOOP\n   S: * 101 FETCH (MODSEQ (303011130956) FLAGS
        (\\Deleted \\Answered))\n   S: b107 OK\n   ...and the client retries the operation
        for the message 101 with\n   the updated UNCHANGEDSINCE value.\n   C: b108
        STORE 101 (UNCHANGEDSINCE 303011130956)\n       +FLAGS.SILENT ($Processed)\n
        \  S: * 101 FETCH (MODSEQ (303181230852))\n   S: b108 OK Conditional Store
        completed\n   Same as above, but the server avoids the need for the client
        to poll\n   for changes.\n   The flag $Processed was set on the message 101
        by another\n   client...\n   C: a106 STORE 100:150 (UNCHANGEDSINCE 212030000000)\n
        \      +FLAGS.SILENT ($Processed)\n   S: * 100 FETCH (MODSEQ (303181230852))\n
        \  S: * 101 FETCH (MODSEQ (303011130956) FLAGS ($Processed))\n   S: * 102
        FETCH (MODSEQ (303181230852))\n   ...\n   S: * 150 FETCH (MODSEQ (303181230852))\n
        \  S: a106 OK [MODIFIED 101] Conditional STORE failed\n                                Example
        10\n   Or, the flag hasn't changed, but another has (note that this server\n
        \  behavior is discouraged.  Server implementers should also see\n   Section
        3.1.12)...\n   C: a106 STORE 100:150 (UNCHANGEDSINCE 212030000000)\n       +FLAGS.SILENT
        ($Processed)\n   S: * 100 FETCH (MODSEQ (303181230852))\n   S: * 101 FETCH
        (MODSEQ (303011130956) FLAGS (\\Deleted \\Answered))\n   S: * 102 FETCH (MODSEQ
        (303181230852))\n   ...\n   S: * 150 FETCH (MODSEQ (303181230852))\n   S:
        a106 OK [MODIFIED 101] Conditional STORE failed\n   ...and the client retries
        the operation for the message 101 with\n   the updated UNCHANGEDSINCE value.\n
        \  C: b108 STORE 101 (UNCHANGEDSINCE 303011130956)\n       +FLAGS.SILENT ($Processed)\n
        \  S: * 101 FETCH (MODSEQ (303181230852))\n   S: b108 OK Conditional Store
        completed\n   Or, the flag hasn't changed, but another has (nice server behavior.\n
        \  Server implementers should also see Section 3.1.12)...\n   C: a106 STORE
        100:150 (UNCHANGEDSINCE 212030000000)\n       +FLAGS.SILENT ($Processed)\n
        \  S: * 100 FETCH (MODSEQ (303181230852))\n   S: * 101 FETCH (MODSEQ (303011130956)
        FLAGS ($Processed \\Deleted\n       \\Answered))\n   S: * 102 FETCH (MODSEQ
        (303181230852))\n   ...\n   S: * 150 FETCH (MODSEQ (303181230852))\n   S:
        a106 OK Conditional STORE completed\n   The following example is based on
        the example from Section 4.2.3 of\n   [RFC2180] and demonstrates that the
        MODIFIED response code MAY also\n   be returned in the tagged NO response.\n
        \  The client tries to conditionally STORE flags on a mixture of\n   expunged
        and non-expunged messages; one message fails the\n   UNCHANGEDSINCE test.\n
        \  C: B001 STORE 1:7 (UNCHANGEDSINCE 320172338) +FLAGS (\\SEEN)\n   S: * 1
        FETCH (MODSEQ (320172342) FLAGS (\\SEEN))\n   S: * 3 FETCH (MODSEQ (320172342)
        FLAGS (\\SEEN))\n   S: B001 NO [MODIFIED 2] Some of the messages no longer
        exist.\n   C: B002 NOOP\n   S: * 4 EXPUNGE\n   S: * 4 EXPUNGE\n   S: * 4 EXPUNGE\n
        \  S: * 4 EXPUNGE\n   S: * 2 FETCH (MODSEQ (320172340) FLAGS (\\Deleted \\Answered))\n
        \  S: B002 OK NOOP Completed.\n   By receiving FETCH responses for messages
        1 and 3, and EXPUNGE\n   responses that indicate that messages 4 through 7
        have been\n   expunged, the client retries the operation only for message
        2.\n   The updated UNCHANGEDSINCE value is used.\n   C: b003 STORE 2 (UNCHANGEDSINCE
        320172340) +FLAGS (\\Seen)\n   S: * 2 FETCH (MODSEQ (320180050) FLAGS (\\SEEN
        \\Flagged))\n   S: b003 OK Conditional Store completed\n                                Example
        11\n   Note: If a message is specified multiple times in the message set,\n
        \  and the server doesn't internally eliminate duplicates from the\n   message
        set, it MUST NOT fail the conditional STORE operation for the\n   second (or
        subsequent) occurrence of the message if the operation\n   completed successfully
        for the first occurrence.  For example, if the\n   client specifies:\n      e105
        STORE 7,3:9 (UNCHANGEDSINCE 12121230045) +FLAGS.SILENT\n      (\\Deleted)\n
        \  the server must not fail the operation for message 7 as part of\n   processing
        \"3:9\" if it succeeded when message 7 was processed the\n   first time.\n
        \  As specified in Section 3.1, once the client specifies the\n   UNCHANGEDSINCE
        modifier in a STORE command, the server starts\n   including the MODSEQ FETCH
        response data items in all subsequent\n   unsolicited FETCH responses.\n   This
        document also changes the behavior of the server when it has\n   performed
        a STORE or UID STORE command and the UNCHANGEDSINCE\n   modifier is not specified.
        \ If the operation is successful for a\n   message, the server MUST update
        the mod-sequence attribute of the\n   message.  The server is REQUIRED to
        include the mod-sequence value\n   whenever it decides to send the unsolicited
        FETCH response to all\n   CONDSTORE-aware clients that have opened the mailbox
        containing the\n   message.\n   Server implementers should also see Section
        3.1.11 for additional\n   quality of implementation issues related to the
        STORE command.\n"
      title: 3.1.3.  STORE and UID STORE Commands
    - contents:
      - '3.1.4.  FETCH and UID FETCH Commands

        '
      - contents:
        - "3.1.4.1.  CHANGEDSINCE FETCH Modifier\n   This document defines the following
          FETCH modifier (see Section 2.4\n   of [RFC4466]):\n   CHANGEDSINCE <mod-sequence>:
          \ The CHANGEDSINCE FETCH modifier allows\n      the client to further subset
          the list of messages described by the\n      sequence set.  The information
          described by message data items is\n      only returned for messages that
          have a mod-sequence bigger than\n      <mod-sequence>.\n      When the CHANGEDSINCE
          FETCH modifier is specified, it implicitly\n      adds the MODSEQ FETCH
          message data item (Section 3.1.4.2).\n   C: s100 UID FETCH 1:* (FLAGS) (CHANGEDSINCE
          12345)\n   S: * 1 FETCH (UID 4 MODSEQ (65402) FLAGS (\\Seen))\n   S: * 2
          FETCH (UID 6 MODSEQ (75403) FLAGS (\\Deleted))\n   S: * 4 FETCH (UID 8 MODSEQ
          (29738) FLAGS ($NoJunk $AutoJunk\n       $MDNSent))\n   S: s100 OK FETCH
          completed\n                                Example 12\n"
        title: 3.1.4.1.  CHANGEDSINCE FETCH Modifier
      - contents:
        - "3.1.4.2.  MODSEQ Message Data Item in FETCH Command\n   CONDSTORE adds
          a MODSEQ message data item to the FETCH command.  The\n   MODSEQ message
          data item allows clients to retrieve mod-sequence\n   values for a range
          of messages in the currently selected mailbox.\n   As specified in Section
          3.1, once the client has specified the MODSEQ\n   message data item in a
          FETCH request, the server starts including the\n   MODSEQ FETCH response
          data items in all subsequent unsolicited FETCH\n   responses.\n   Syntax:
          \ MODSEQ\n      The MODSEQ message data item causes the server to return
          MODSEQ\n      FETCH response data items.\n   Syntax:  MODSEQ ( <permsg-modsequence>
          )\n      MODSEQ response data items contain per-message mod-sequences.\n
          \     The MODSEQ response data item is returned if the client issued\n      FETCH
          with the MODSEQ message data item.  It also allows the\n      server to
          notify the client about mod-sequence changes caused by\n      conditional
          STOREs (Section 3.1.3) and/or changes caused by\n      external sources.\n
          \  C: a FETCH 1:3 (MODSEQ)\n   S: * 1 FETCH (MODSEQ (624140003))\n   S:
          * 2 FETCH (MODSEQ (624140007))\n   S: * 3 FETCH (MODSEQ (624140005))\n   S:
          a OK Fetch complete\n   In this example, the client requests per-message
          mod-sequences for a\n   set of messages.\n                                Example
          13\n   Servers that only support the CONDSTORE extension (and not QRESYNC)\n
          \  SHOULD comply with requirements from Section 3.2.4.\n   When a flag for
          a message is modified in a different session, the\n   server sends an unsolicited
          FETCH response containing the mod-\n   sequence for the message, as demonstrated
          in Example 14.  Note that\n   when the server also supports the QRESYNC
          extension (Section 3.2.3)\n   and a CONDSTORE enabling command has been
          issued, all FETCH responses\n   in Example 14 must also include UID FETCH
          items as prescribed by\n   Section 3.2.4.\n   (Session 1, authenticated
          as the user \"alex\".)  The user adds a\n   shared flag \\Deleted:\n       C:
          A142 SELECT INBOX\n       ...\n       S: * FLAGS (\\Answered \\Flagged \\Deleted
          \\Seen \\Draft)\n       S: * OK [PERMANENTFLAGS (\\Answered \\Deleted \\Seen
          \\*)] Limited\n       ...\n       C: A160 STORE 7 +FLAGS.SILENT (\\Deleted)\n
          \      S: * 7 FETCH (MODSEQ (2121231000))\n       S: A160 OK Store completed\n
          \  (Session 2, also authenticated as the user \"alex\".)  Any changes\n
          \  to flags are always reported to all sessions authenticated as the\n   same
          user as in session 1.\n       C: C180 NOOP\n       S: * 7 FETCH (FLAGS (\\Deleted
          \\Answered) MODSEQ (12121231000))\n       S: C180 OK Noop completed\n   (Session
          3, authenticated as the user \"andrew\".)  As \\Deleted is a\n   shared
          flag, changes in session 1 are also reported in session 3:\n       C: D210
          NOOP\n       S: * 7 FETCH (FLAGS (\\Deleted \\Answered) MODSEQ (12121231000))\n
          \      S: D210 OK Noop completed\n   The user modifies a private flag, \\Seen,
          in session 1...\n       C: A240 STORE 7 +FLAGS.SILENT (\\Seen)\n       S:
          * 7 FETCH (MODSEQ (12121231777))\n       S: A240 OK Store completed\n   ...which
          is only reported in session 2...\n       C: C270 NOOP\n       S: * 7 FETCH
          (FLAGS (\\Deleted \\Answered \\Seen) MODSEQ\n           (12121231777))\n
          \      S: C270 OK Noop completed\n   ...but not in session 3.\n       C:
          D300 NOOP\n       S: D300 OK Noop completed\n   And, finally, the user removes
          flags \\Answered (shared) and \\Seen\n   (private) in session 1.\n       C:
          A330 STORE 7 -FLAGS.SILENT (\\Answered \\Seen)\n       S: * 7 FETCH (MODSEQ
          (12121245160))\n       S: A330 OK Store completed\n   Both changes are reported
          in session 2...\n       C: C360 NOOP\n       S: * 7 FETCH (FLAGS (\\Deleted)
          MODSEQ (12121245160))\n       S: C360 OK Noop completed\n   ...and only
          changes to shared flags are reported in session 3.\n       C: D390 NOOP\n
          \      S: * 7 FETCH (FLAGS (\\Deleted) MODSEQ (12121245160))\n       S:
          D390 OK Noop completed\n                                Example 14\n   Server
          implementers should also see Section 3.1.11 for additional\n   quality of
          implementation issues related to the FETCH command.\n"
        title: 3.1.4.2.  MODSEQ Message Data Item in FETCH Command
      title: 3.1.4.  FETCH and UID FETCH Commands
    - contents:
      - "3.1.5.  MODSEQ Search Criterion in SEARCH\n   The MODSEQ criterion for the
        SEARCH (or UID SEARCH) command allows a\n   client to search for the metadata
        items that were modified since a\n   specified moment.\n   Syntax: MODSEQ
        [<entry-name> <entry-type-req>] <mod-sequence-valzer>\n      Messages that
        have modification values that are equal to or\n      greater than <mod-sequence-valzer>.
        \ This allows a client, for\n      example, to find out which messages contain
        metadata items that\n      have changed since the last time it updated its
        disconnected\n      cache.  The client may also specify <entry-name> (name
        of the\n      metadata item) and <entry-type-req> (type of metadata item)
        before\n      <mod-sequence-valzer>.  <entry-type-req> can be one of \"shared\",\n
        \     \"priv\" (private), or \"all\".  The last means that the server MUST\n
        \     use the biggest value among \"priv\" and \"shared\" mod-sequences for\n
        \     the metadata item.  If the server doesn't store separate mod-\n      sequences
        for different metadata items, it MUST ignore <entry-\n      name> and <entry-type-req>.
        \ Otherwise, the server should use them\n      to narrow down the search.\n
        \     For a flag <flagname>, the corresponding <entry-name> has the form\n
        \     \"/flags/<flagname>\".  Note that the leading \"\\\" character that\n
        \     denotes a system flag has to be escaped as per Section 4.3 of\n      [RFC3501],
        as <entry-name> uses the syntax for quoted strings (see\n      the examples
        below).\n   If the client specifies a MODSEQ criterion in a SEARCH (or UID\n
        \  SEARCH) command and the server returns a non-empty SEARCH result, the\n
        \  server MUST also append (to the end of the untagged SEARCH response)\n
        \  the highest mod-sequence for all messages being returned.  See also\n   Section
        3.1.6.  Note that other IMAP extensions such as ESEARCH\n   [RFC4731] can
        override this requirement (see Section 3.1.10 for more\n   details.)\n   C:
        a SEARCH MODSEQ \"/flags/\\\\draft\" all 620162338\n   S: * SEARCH 2 5 6 7
        11 12 18 19 20 23 (MODSEQ 917162500)\n   S: a OK Search complete\n   In the
        above example, the message numbers of any messages having a\n   mod-sequence
        equal to or greater than 620162338 for the \"\\Draft\" flag\n   are returned
        in the search results.\n                                Example 15\n   C:
        t SEARCH OR NOT MODSEQ 720162338 LARGER 50000\n   S: * SEARCH\n   S: t OK
        Search complete, nothing found\n                                Example 16\n"
      title: 3.1.5.  MODSEQ Search Criterion in SEARCH
    - contents:
      - "3.1.6.  Modified SEARCH Untagged Response\n   Data:       zero or more numbers\n
        \              mod-sequence value (omitted if no match)\n   This document
        extends the syntax of the untagged SEARCH response to\n   include the highest
        mod-sequence for all messages being returned.\n   If a client specifies a
        MODSEQ criterion in a SEARCH (or UID SEARCH)\n   command and the server returns
        a non-empty SEARCH result, the server\n   MUST also append (to the end of
        the untagged SEARCH response) the\n   highest mod-sequence for all messages
        being returned.  See\n   Section 3.1.5 for examples.\n"
      title: 3.1.6.  Modified SEARCH Untagged Response
    - contents:
      - "3.1.7.  HIGHESTMODSEQ Status Data Items\n   This document defines a new status
        data item:\n   HIGHESTMODSEQ:  The highest mod-sequence value of all messages
        in the\n      mailbox.  This is the same value that is returned by the server
        in\n      the HIGHESTMODSEQ response code in an OK untagged response (see\n
        \     Section 3.1.2.1).  If the server doesn't support the persistent\n      storage
        of mod-sequences for the mailbox (see Section 3.1.2.2),\n      the server
        MUST return 0 as the value of the HIGHESTMODSEQ status\n      data item.\n
        \  C: A042 STATUS blurdybloop (UIDNEXT MESSAGES HIGHESTMODSEQ)\n   S: * STATUS
        blurdybloop (MESSAGES 231 UIDNEXT 44292\n       HIGHESTMODSEQ 7011231777)\n
        \  S: A042 OK STATUS completed\n                                Example 17\n"
      title: 3.1.7.  HIGHESTMODSEQ Status Data Items
    - contents:
      - "3.1.8.  CONDSTORE Parameter to SELECT and EXAMINE\n   The CONDSTORE extension
        defines a single optional select parameter,\n   \"CONDSTORE\", which tells
        the server that it MUST include the MODSEQ\n   FETCH response data items in
        all subsequent unsolicited FETCH\n   responses.\n   The CONDSTORE parameter
        to SELECT/EXAMINE helps avoid a race\n   condition that might arise when one
        or more metadata items are\n   modified in another session after the server
        has sent the\n   HIGHESTMODSEQ response code and before the client was able
        to issue a\n   CONDSTORE enabling command.\n   C: A142 SELECT INBOX (CONDSTORE)\n
        \  S: * 172 EXISTS\n   S: * 1 RECENT\n   S: * OK [UNSEEN 12] Message 12 is
        first unseen\n   S: * OK [UIDVALIDITY 3857529045] UIDs valid\n   S: * OK [UIDNEXT
        4392] Predicted next UID\n   S: * FLAGS (\\Answered \\Flagged \\Deleted \\Seen
        \\Draft)\n   S: * OK [PERMANENTFLAGS (\\Deleted \\Seen \\*)] Limited\n   S:
        * OK [HIGHESTMODSEQ 715194045007]\n   S: A142 OK [READ-WRITE] SELECT completed,
        CONDSTORE is now enabled\n                                Example 18\n"
      title: 3.1.8.  CONDSTORE Parameter to SELECT and EXAMINE
    - contents:
      - "3.1.9.  Interaction with IMAP SORT and THREAD Extensions\n   The MODSEQ Search
        Criterion (see Section 3.1.5) causes modifications\n   to SORT [RFC5256] responses
        similar to modifications to SEARCH\n   responses defined in Section 3.1.6:\n
        \  SORT Response Data:       zero or more numbers\n                             mod-sequence
        value (omitted if no match)\n   This document extends the syntax of the untagged
        SORT response to\n   include the highest mod-sequence for all messages being
        returned.\n   If a client specifies a MODSEQ criterion in a SORT (or UID SORT)\n
        \  command and the server returns a non-empty SORT result, the server\n   MUST
        also append (to the end of the untagged SORT response) the\n   highest mod-sequence
        for all messages being returned.  Note that\n   other IMAP extensions such
        as ESORT [RFC5267] can override this\n   requirement (see Section 3.1.10 for
        more details.)\n   THREAD commands that include a MODSEQ Search Criterion
        return THREAD\n   responses as specified in [RFC5256], i.e., THREAD responses
        are\n   unchanged by the CONDSTORE extension.\n"
      title: 3.1.9.  Interaction with IMAP SORT and THREAD Extensions
    - contents:
      - "3.1.10.  Interaction with IMAP ESORT and ESEARCH Extensions\n   If a client
        specifies a MODSEQ criterion in an extended SEARCH (or\n   extended UID SEARCH)
        [RFC4731] command and the server returns a non-\n   empty SEARCH result, the
        server MUST return the ESEARCH response\n   containing the MODSEQ result option
        as defined in Section 3.2 of\n   [RFC4731].\n   C: a SEARCH RETURN (ALL) MODSEQ
        1234\n   S: * ESEARCH (TAG \"a\") ALL 1:3,5 MODSEQ 1236\n   S: a OK Extended
        SEARCH completed\n                                Example 19\n   If a client
        specifies a MODSEQ criterion in an extended SORT (or\n   extended UID SORT)
        [RFC5267] command and the server returns a non-\n   empty SORT result, the
        server MUST return the ESEARCH response\n   containing the MODSEQ result option
        defined in Section 3.2 of\n   [RFC4731].\n   C: a SORT RETURN (ALL) (DATE)
        UTF-8 MODSEQ 1234\n   S: * ESEARCH (TAG \"a\") ALL 5,3,2,1 MODSEQ 1236\n   S:
        a OK Extended SORT completed\n                                Example 20\n"
      title: 3.1.10.  Interaction with IMAP ESORT and ESEARCH Extensions
    - contents:
      - "3.1.11.  Additional Quality-of-Implementation Issues\n   Server implementations
        should follow the following rule, which\n   applies to any successfully completed
        STORE/UID STORE (with and\n   without an UNCHANGEDSINCE modifier), as well
        as to a FETCH command\n   that implicitly sets the \\Seen flag:\n      Adding
        the flag when it is already present or removing it when it\n      is not present
        SHOULD NOT change the mod-sequence.\n   This will prevent spurious client
        synchronization requests.\n   However, note that client implementers MUST
        NOT rely on this server\n   behavior.  A client can't distinguish between
        the case when a server\n   has violated the SHOULD mentioned above and when
        one or more clients\n   set and unset (or unset and set) the flag in another
        session.\n"
      title: 3.1.11.  Additional Quality-of-Implementation Issues
    - contents:
      - "3.1.12.  CONDSTORE Server Implementation Considerations\n   This section
        describes how a server implementation that doesn't store\n   separate per-metadata
        mod-sequences for different metadata items can\n   avoid sending the MODIFIED
        response to any of the following\n   conditional STORE operations:\n      +FLAGS\n
        \     -FLAGS\n      +FLAGS.SILENT\n      -FLAGS.SILENT\n   Note that the optimization
        described in this section can't be\n   performed in case of a conditional
        STORE FLAGS (without \"+\" or \"-\")\n   operation.\n   Let's use the following
        example.  The client has issued:\n   C: a106 STORE 100:150 (UNCHANGEDSINCE
        212030000000)\n       +FLAGS.SILENT ($Processed)\n   When the server receives
        the command and parses it successfully, it\n   iterates through the message
        set and tries to execute the conditional\n   STORE command for each message.\n
        \  Each server internally works as a client, i.e., it has to cache the\n   current
        state of all IMAP flags as it is known to the client.  In\n   order to report
        flag changes to the client, the server compares the\n   cached values with
        the values in its database for IMAP flags.\n   Imagine that another client
        has changed the state of a flag \\Deleted\n   on the message 101 and that
        the change updated the mod-sequence for\n   the message.  The server knows
        that the mod-sequence for the mailbox\n   has changed; however, it also knows
        that:\n   a.  the client is not interested in the \\Deleted flag, as it hasn't\n
        \      included it in the +FLAGS.SILENT operation and\n   b.  the state of
        the flag $Processed hasn't changed (the server can\n       determine this
        by comparing the cached flag state with the state\n       of the flag in the
        database).\n   Therefore, the server doesn't have to report MODIFIED to the
        client.\n   Instead, the server may set the $Processed flag, update the mod-\n
        \  sequence for the message 101 once again, and send an untagged FETCH\n   response
        with a new mod-sequence and flags:\n   S: * 101 FETCH (MODSEQ (303011130956)
        FLAGS ($Processed \\Deleted\n       \\Answered))\n   See also Section 3.1.11
        for additional quality-of-implementation\n   issues.\n"
      title: 3.1.12.  CONDSTORE Server Implementation Considerations
    title: 3.1.  CONDSTORE Extension
  - contents:
    - "3.2.  QRESYNC Extension\n   All protocol changes and requirements specified
      for the CONDSTORE\n   extension are also a part of the QRESYNC extension.\n
      \  The QRESYNC extension puts additional requirements on a server\n   implementing
      the CONDSTORE extension.  Each mailbox that supports\n   persistent storage
      of mod-sequences, i.e., for which the server would\n   send a HIGHESTMODSEQ
      untagged OK response code on a successful\n   SELECT/EXAMINE, MUST increment
      the per-mailbox mod-sequence when one\n   or more messages are expunged due
      to EXPUNGE, UID EXPUNGE, CLOSE, or\n   MOVE [RFC6851]; the server MUST associate
      the incremented mod-\n   sequence with the UIDs of the expunged messages.  Additionally,
      if\n   the server also supports the IMAP METADATA extension [RFC5464], it\n
      \  MUST increment the per-mailbox mod-sequence when SETMETADATA\n   successfully
      changes an annotation on the corresponding mailbox.\n   A server implementing
      QRESYNC MUST send untagged events to a client\n   in a way that the client doesn't
      lose any changes in case of\n   connectivity loss.  In particular, this means
      that if the server\n   sends MODSEQ FETCH data items while EXPUNGE (or VANISHED)
      replies\n   with lower mod-sequences being delayed, the server MUST send the\n
      \  HIGHESTMODSEQ response code with a lower value than the EXPUNGE's\n   mod-sequence.
      \ See the example in Section 6.\n"
    - contents:
      - "3.2.1.  Impact on CONDSTORE-only Clients\n   A client that supports CONDSTORE
        but not QRESYNC might resynchronize\n   a mailbox and discover that its HIGHESTMODSEQ
        has increased from the\n   value cached by the client.  If the increase is
        only due to messages\n   having been expunged since the client last synchronized,
        the client\n   is likely to send a FETCH ... CHANGEDSINCE command that returns
        no\n   data.  Thus, a client that supports CONDSTORE but not QRESYNC might\n
        \  incur a penalty of an unneeded round trip when resynchronizing some\n   mailboxes
        (those that have had messages expunged but no flag changes\n   since the last
        synchronization).\n   This extra round trip is only incurred by clients that
        support\n   CONDSTORE but not QRESYNC and only when a mailbox has had messages\n
        \  expunged but no flag changes to non-expunged messages.  Since\n   CONDSTORE
        is a relatively new extension, it is strongly encouraged\n   that clients
        that support it also support QRESYNC.\n"
      title: 3.2.1.  Impact on CONDSTORE-only Clients
    - contents:
      - "3.2.2.  Advertising Support for QRESYNC\n   The quick resync IMAP extension
        is present if an IMAP4 server returns\n   \"QRESYNC\" as one of the supported
        capabilities to the CAPABILITY\n   command.\n   For compatibility with clients
        that only support the CONDSTORE IMAP\n   extension, servers SHOULD also advertise
        \"CONDSTORE\" in the\n   CAPABILITY response.\n"
      title: 3.2.2.  Advertising Support for QRESYNC
    - contents:
      - "3.2.3.  Use of ENABLE\n   Servers supporting QRESYNC MUST implement and advertise
        support for\n   the ENABLE [RFC5161] IMAP extension.  Also, the presence of
        the\n   \"QRESYNC\" capability implies support for the CONDSTORE IMAP extension\n
        \  even if the \"CONDSTORE\" capability isn't advertised.  A server\n   compliant
        with this specification is REQUIRED to support \"ENABLE\n   QRESYNC\" and
        \"ENABLE QRESYNC CONDSTORE\" (which are \"CONDSTORE\n   enabling commands\",
        see Section 3.1, and have identical results).\n   Note that the order of parameters
        is not significant, but there is no\n   requirement for a compliant server
        to support \"ENABLE CONDSTORE\" by\n   itself.  The \"ENABLE QRESYNC\"/\"ENABLE
        QRESYNC CONDSTORE\" command also\n   tells the server that it MUST start sending
        VANISHED responses (see\n   Section 3.2.10) instead of EXPUNGE responses for
        all mailboxes for\n   which the server doesn't return the NOMODSEQ response
        code.  This\n   change remains in effect until the connection is closed.\n
        \  A client making use of QRESYNC MUST issue \"ENABLE QRESYNC\" once it is\n
        \  authenticated.  A server MUST respond with a tagged BAD response if\n   the
        QRESYNC parameter to the SELECT/EXAMINE command or the VANISHED\n   UID FETCH
        modifier is specified and the client hasn't issued \"ENABLE\n   QRESYNC\",
        or the server has not positively responded (in the current\n   connection)
        to that command with the untagged ENABLED response\n   containing QRESYNC.\n"
      title: 3.2.3.  Use of ENABLE
    - contents:
      - "3.2.4.  Additional Requirements on QRESYNC Servers\n   Once a CONDSTORE enabling
        command is issued by the client, the server\n   MUST automatically include
        both UID and mod-sequence data in all\n   subsequent untagged FETCH responses
        (until the connection is closed),\n   whether they were caused by a regular
        STORE/UID STORE, a STORE/UID\n   STORE with an UNCHANGEDSINCE modifier, a
        FETCH/UID FETCH that\n   implicitly set the \\Seen flag, or an external agent.
        \ Note that this\n   rule doesn't affect untagged FETCH responses caused by
        a FETCH\n   command that doesn't include UID and/or a MODSEQ FETCH data item
        (and\n   doesn't implicitly set the \\Seen flag) or UID FETCH without the\n
        \  MODSEQ FETCH data item.\n"
      title: 3.2.4.  Additional Requirements on QRESYNC Servers
    - contents:
      - "3.2.5.  QRESYNC Parameter to SELECT/EXAMINE\n   The Quick Resynchronization
        parameter to SELECT/EXAMINE commands has\n   four arguments:\n   o  the last
        known UIDVALIDITY,\n   o  the last known modification sequence,\n   o  the
        optional set of known UIDs, and\n   o  an optional parenthesized list of known
        sequence ranges and their\n      corresponding UIDs.\n   A server MUST respond
        with a tagged BAD response if the Quick\n   Resynchronization parameter to
        the SELECT/EXAMINE command is\n   specified and the client hasn't issued \"ENABLE
        QRESYNC\" in the\n   current connection, or the server has not positively
        responded to\n   that command with the untagged ENABLED response containing
        QRESYNC.\n   Before opening the specified mailbox, the server verifies all\n
        \  arguments for syntactic validity.  If any parameter is not\n   syntactically
        valid, the server returns the tagged BAD response, and\n   the mailbox remains
        unselected.  Once the check is done, the server\n   opens the mailbox as if
        no SELECT/EXAMINE parameters are specified\n   (this is subject to the processing
        of other parameters as defined in\n   other extensions).  In particular, this
        means that the server MUST\n   send all untagged responses as specified in
        Sections 6.3.1 and 6.3.2\n   of [RFC3501].\n   After that, the server checks
        the UIDVALIDITY value provided by the\n   client.  If the provided UIDVALIDITY
        doesn't match the UIDVALIDITY\n   for the mailbox being opened, then the server
        MUST ignore the\n   remaining parameters and behave as if no dynamic message
        data\n   changed.  The client can discover this situation by comparing the\n
        \  UIDVALIDITY value returned by the server.  This behavior allows the\n   client
        not to synchronize the mailbox or decide on the best\n   synchronization strategy.\n
        \  Example: Attempting to resynchronize INBOX, but the provided\n            UIDVALIDITY
        parameter doesn't match the current UIDVALIDITY\n            value.\n            C:
        A02 SELECT INBOX (QRESYNC (67890007 20050715194045000\n                41,43:211,214:541))\n
        \           S: * 464 EXISTS\n            S: * 3 RECENT\n            S: * OK
        [UIDVALIDITY 3857529045] UIDVALIDITY\n            S: * OK [UIDNEXT 550] Predicted
        next UID\n            S: * OK [HIGHESTMODSEQ 90060128194045007] Highest mailbox\n
        \           mod-sequence\n            S: * OK [UNSEEN 12] Message 12 is first
        unseen\n            S: * FLAGS (\\Answered \\Flagged \\Draft \\Deleted \\Seen)\n
        \           S: * OK [PERMANENTFLAGS (\\Answered \\Flagged \\Draft\n            \\Deleted
        \\Seen \\*)] Permanent flags\n            S: A02 OK [READ-WRITE] Sorry, UIDVALIDITY
        mismatch\n   Remaining parameters are described in the following subsections.\n"
      - contents:
        - "3.2.5.1.  Modification Sequence and UID Parameters\n   A server that doesn't
          support the persistent storage of mod-sequences\n   for the mailbox MUST
          send an OK untagged response including the\n   NOMODSEQ response code with
          every successful SELECT or EXAMINE\n   command (see Section 3.1.2.2).  Such
          a server doesn't need to\n   remember mod-sequences for expunged messages
          in the mailbox.  It MUST\n   ignore the remaining parameters and behave
          as if no dynamic message\n   data changed.\n   If the provided UIDVALIDITY
          matches that of the selected mailbox, the\n   server then checks the last
          known modification sequence.\n   The server sends the client any pending
          flag changes (using FETCH\n   responses that MUST contain UIDs) and expunges
          those that have\n   occurred in this mailbox since the provided modification
          sequence.\n   If the list of known UIDs was also provided, the server should
          only\n   report flag changes and expunges for the specified messages.  If
          the\n   client did not provide the list of UIDs, the server acts as if the\n
          \  client has specified \"1:<maxuid>\", where <maxuid> is the mailbox's\n
          \  UIDNEXT value minus 1.  If the mailbox is empty and never had any\n   messages
          in it, then lack of the list of UIDs is interpreted as an\n   empty set
          of UIDs.\n   Thus, the client can process just these pending events and
          need not\n   perform a full resynchronization.  Without the message sequence\n
          \  number matching information, the result of this step is semantically\n
          \  equivalent to the client issuing:\n   tag1 UID FETCH \"known-uids\" (FLAGS)
          (CHANGEDSINCE \"mod-sequence-\n   value\" VANISHED)\n   In particular, this
          means that all requirements specified in\n   Section 3.2.6 apply.\n   Example:\n
          \     C: A03 SELECT INBOX (QRESYNC (67890007\n          90060115194045000
          41:211,214:541))\n      S: * OK [CLOSED]\n      S: * 100 EXISTS\n      S:
          * 11 RECENT\n      S: * OK [UIDVALIDITY 67890007] UIDVALIDITY\n      S:
          * OK [UIDNEXT 600] Predicted next UID\n      S: * OK [HIGHESTMODSEQ 90060115205545359]
          Highest\n          mailbox mod-sequence\n      S: * OK [UNSEEN 7] There
          are some unseen\n          messages in the mailbox\n      S: * FLAGS (\\Answered
          \\Flagged \\Draft \\Deleted \\Seen)\n      S: * OK [PERMANENTFLAGS (\\Answered
          \\Flagged \\Draft\n          \\Deleted \\Seen \\*)] Permanent flags\n      S:
          * VANISHED (EARLIER) 41,43:116,118,120:211,214:540\n      S: * 49 FETCH
          (UID 117 FLAGS (\\Seen \\Answered) MODSEQ\n          (90060115194045001))\n
          \     S: * 50 FETCH (UID 119 FLAGS (\\Draft $MDNSent) MODSEQ\n          (90060115194045308))\n
          \     S: * 51 FETCH (UID 541 FLAGS (\\Seen $Forwarded) MODSEQ\n          (90060115194045001))\n
          \     S: A03 OK [READ-WRITE] mailbox selected\n   In the above example,
          flag information for UID 42 is not returned,\n   presumably because its
          flags haven't changed since the MODSEQ\n   90060115194045000.\n"
        title: 3.2.5.1.  Modification Sequence and UID Parameters
      - contents:
        - "3.2.5.2.  Message Sequence Match Data\n   A client MAY provide a parenthesized
          list of a message sequence set\n   and the corresponding UID sets.  Both
          MUST be provided in ascending\n   order.  The server uses this data to restrict
          the range for which it\n   provides expunged message information.\n   Conceptually,
          the client provides a small sample of sequence numbers\n   for which it
          knows the corresponding UIDs.  The server then compares\n   each sequence
          number and UID pair the client provides with the\n   current state of the
          mailbox.  If a pair matches, then the client\n   knows of any expunges up
          to, and including, the message; thus, it\n   will not include that range
          in the VANISHED response, even if the\n   \"mod-sequence-value\" provided
          by the client is too old for the server\n   to have data of when those messages
          were expunged.\n   Thus, if the Nth message number in the first set in the
          list is 4,\n   and the Nth UID in the second set in the list is 8, and the
          mailbox's\n   fourth message has UID 8, then no UIDs equal to or less than
          8 are\n   present in the VANISHED response.  If the (N+1)th message number
          is\n   12, and the (N+1)th UID is 24, and the (N+1)th message in the mailbox\n
          \  has UID 25, then the lowest UID included in the VANISHED response\n   would
          be 9.\n   In the following two examples, the server is unable to remember\n
          \  expunges at all, and only UIDs with messages divisible by three are\n
          \  present in the mailbox.  In the first example, the client does not\n
          \  use the fourth parameter; in the second, it provides it.  This\n   example
          is somewhat extreme, but it shows that judicious usage of the\n   sequence
          match data can save a substantial amount of bandwidth.\n   Example:\n      C:
          A04 SELECT INBOX (QRESYNC (67890007\n          90060115194045000 1:29997))\n
          \     S: * 10003 EXISTS\n      S: * 4 RECENT\n      S: * OK [UIDVALIDITY
          67890007] UIDVALIDITY\n      S: * OK [UIDNEXT 30013] Predicted next UID\n
          \     S: * OK [HIGHESTMODSEQ 90060115205545359] Highest mailbox\n          mod-sequence\n
          \     S: * OK [UNSEEN 7] There are some unseen messages in the mailbox\n
          \     S: * FLAGS (\\Answered \\Flagged \\Draft \\Deleted \\Seen)\n      S:
          * OK [PERMANENTFLAGS (\\Answered \\Flagged \\Draft\n          \\Deleted
          \\Seen \\*)] Permanent flags\n      S: * VANISHED (EARLIER) 1:2,4:5,7:8,10:11,13:14,[...],\n
          \         29668:29669,29671:29996\n      S: * 1 FETCH (UID 3 FLAGS (\\Seen
          \\Answered $Important) MODSEQ\n          (90060115194045001))\n      S:
          ...\n      S: * 9889 FETCH (UID 29667 FLAGS (\\Seen \\Answered) MODSEQ\n
          \         (90060115194045027))\n      S: * 9890 FETCH (UID 29670 FLAGS (\\Draft
          $MDNSent) MODSEQ\n          (90060115194045028))\n      S: ...\n      S:
          * 9999 FETCH (UID 29997 FLAGS (\\Seen $Forwarded) MODSEQ\n          (90060115194045031))\n
          \     S: A04 OK [READ-WRITE] mailbox selected\n   Example:\n      C: B04
          SELECT INBOX (QRESYNC (67890007\n         90060115194045000 1:29997 (5000,7500,9000,9990:9999
          15000,\n         22500,27000,29970,29973,29976,29979,29982,29985,29988,29991,\n
          \        29994,29997)))\n      S: * 10003 EXISTS\n      S: * 4 RECENT\n
          \     S: * OK [UIDVALIDITY 67890007] UIDVALIDITY\n      S: * OK [UIDNEXT
          30013] Predicted next UID\n      S: * OK [HIGHESTMODSEQ 90060115205545359]
          Highest mailbox mod-\n         sequence\n      S: * OK [UNSEEN 7] There
          are some unseen messages in the mailbox\n      S: * FLAGS (\\Answered \\Flagged
          \\Draft \\Deleted \\Seen)\n      S: * OK [PERMANENTFLAGS (\\Answered \\Flagged
          \\Draft\n         \\Deleted \\Seen \\*)] Permanent flags\n      S: * 1 FETCH
          (UID 3 FLAGS (\\Seen \\Answered $Important) MODSEQ\n         (90060115194045001))\n
          \     S: ...\n      S: * 9889 FETCH (UID 29667 FLAGS (\\Seen \\Answered)
          MODSEQ\n         (90060115194045027))\n      S: * 9890 FETCH (UID 29670
          FLAGS (\\Draft $MDNSent) MODSEQ\n         (90060115194045028))\n      S:
          ...\n      S: * 9999 FETCH (UID 29997 FLAGS (\\Seen $Forwarded) MODSEQ\n
          \        (90060115194045031))\n      S: B04 OK [READ-WRITE] mailbox selected\n"
        title: 3.2.5.2.  Message Sequence Match Data
      title: 3.2.5.  QRESYNC Parameter to SELECT/EXAMINE
    - contents:
      - "3.2.6.  VANISHED UID FETCH Modifier\n   [RFC4466] has extended the syntax
        of the FETCH and UID FETCH commands\n   to include an optional FETCH modifier.
        \ This document defines a new\n   UID FETCH modifier: VANISHED.\n   Note that
        the VANISHED UID FETCH modifier is NOT allowed with a FETCH\n   command.  The
        server MUST return a tagged BAD response if this\n   response is specified
        as a modifier to the FETCH command.\n   A server MUST respond with a tagged
        BAD response if the VANISHED UID\n   FETCH modifier is specified and the client
        hasn't issued \"ENABLE\n   QRESYNC\" in the current connection.\n   The VANISHED
        UID FETCH modifier MUST only be specified together with\n   the CHANGEDSINCE
        UID FETCH modifier.  If the VANISHED UID FETCH\n   modifier is used without
        the CHANGEDSINCE UID FETCH modifier, the\n   server MUST respond with a tagged
        BAD response.\n   The VANISHED UID FETCH modifier instructs the server to
        report those\n   messages from the UID set parameter that have been expunged
        and whose\n   associated mod-sequence is larger than the specified mod-sequence.\n
        \  That is, the client requests to be informed of messages from the\n   specified
        set that were expunged since the specified mod-sequence.\n   Note that the
        mod-sequence(s) associated with these messages was\n   updated when the messages
        were expunged (as described above).  The\n   expunged messages are reported
        using the VANISHED (EARLIER) response\n   as described in Section 3.2.10.1.
        \ Any VANISHED (EARLIER) responses\n   MUST be returned before any FETCH responses,
        otherwise the client\n   might get confused about how message numbers map
        to UIDs.\n   Note: A server that receives a mod-sequence smaller than <minmodseq>,\n
        \  where <minmodseq> is the value of the smallest expunged mod-sequence\n
        \  it remembers minus one, MUST behave as if it was requested to report\n
        \  all expunged messages from the provided UID set parameter.\n   Example
        1: Without the VANISHED UID FETCH modifier, a CONDSTORE-aware\n   client needs
        to issue separate commands to learn of flag changes and\n   expunged messages
        since the last synchronization:\n   C: s100 UID FETCH 300:500 (FLAGS) (CHANGEDSINCE
        12345)\n   S: * 1 FETCH (UID 404 MODSEQ (65402) FLAGS (\\Seen))\n   S: * 2
        FETCH (UID 406 MODSEQ (75403) FLAGS (\\Deleted))\n   S: * 4 FETCH (UID 408
        MODSEQ (29738) FLAGS ($NoJunk\n       $AutoJunk $MDNSent))\n   S: s100 OK
        FETCH completed\n   C: s101 UID SEARCH 300:500\n   S: * SEARCH 404 406 407
        408 410 412\n   S: s101 OK search completed\n   Where 300 and 500 are the
        lowest and highest UIDs from the client's\n   cache.  The second SEARCH response
        tells the client that the messages\n   with UIDs 407, 410, and 412 are still
        present, but their flags\n   haven't changed since the specified modification
        sequence.\n   Using the VANISHED UID FETCH modifier, it is sufficient to issue
        only\n   a single command:\n   C: s100 UID FETCH 300:500 (FLAGS) (CHANGEDSINCE
        12345\n       VANISHED)\n   S: * VANISHED (EARLIER) 300:310,405,411\n   S:
        * 1 FETCH (UID 404 MODSEQ (65402) FLAGS (\\Seen))\n   S: * 2 FETCH (UID 406
        MODSEQ (75403) FLAGS (\\Deleted))\n   S: * 4 FETCH (UID 408 MODSEQ (29738)
        FLAGS ($NoJunk\n       $AutoJunk $MDNSent))\n   S: s100 OK FETCH completed\n"
      title: 3.2.6.  VANISHED UID FETCH Modifier
    - contents:
      - "3.2.7.  EXPUNGE Command\n   Arguments: none\n   Responses: untagged responses:
        EXPUNGE or VANISHED\n   Result: OK - expunge completed\n           NO - expunge
        failure: can't expunge (e.g., permission denied)\n           BAD - command
        unknown or arguments invalid\n   This section updates the definition of the
        EXPUNGE command described\n   in Section 6.4.3 of [RFC3501].\n   The EXPUNGE
        command permanently removes all messages that have the\n   \\Deleted flag
        set from the currently selected mailbox.  Before\n   returning an OK to the
        client, those messages that are removed are\n   reported using a VANISHED
        response or EXPUNGE responses.\n   If the server is capable of storing modification
        sequences for the\n   selected mailbox, it MUST increment the per-mailbox
        mod-sequence if\n   at least one message was permanently removed due to the
        execution of\n   the EXPUNGE command.  For each permanently removed message,
        the\n   server MUST remember the incremented mod-sequence and corresponding\n
        \  UID.  If at least one message got expunged and QRESYNC was enabled,\n   the
        server MUST send the updated per-mailbox modification sequence\n   using the
        HIGHESTMODSEQ response code (see Section 3.1.2.1) in the\n   tagged OK response.\n
        \     Example:    C: A202 EXPUNGE\n                  S: * 3 EXPUNGE\n                  S:
        * 3 EXPUNGE\n                  S: * 5 EXPUNGE\n                  S: * 8 EXPUNGE\n
        \                 S: A202 OK [HIGHESTMODSEQ 20010715194045319] expunged\n
        \  Note: In this example, the client hasn't enabled QRESYNC, so the\n   server
        is still using untagged EXPUNGE responses.  Note that the\n   presence of
        the HIGHESTMODSEQ response code is optional in this case.\n   If the selected
        mailbox returned NOMODSEQ, the HIGHESTMODSEQ response\n   code will be absent.
        \ In this example, messages 3, 4, 7, and 11 had\n   the \\Deleted flag set.
        \ The first \"* 3 EXPUNGE\" reports message #3 as\n   expunged.  The second
        \"* 3 EXPUNGE\" reports message #4 as expunged\n   (the message number was
        decremented due to the previous EXPUNGE\n   response).  See the description
        of the EXPUNGE response in [RFC3501]\n   for further explanation.\n   Once
        the client enables QRESYNC, the server will always send VANISHED\n   responses
        instead of EXPUNGE responses for mailboxes that support the\n   storing of
        modification sequences, so the previous example might look\n   like this:\n
        \     Example:    C: B202 EXPUNGE\n                  S: * VANISHED 405,407,410,425\n
        \                 S: B202 OK [HIGHESTMODSEQ 20010715194045319] expunged\n
        \  Here, messages with message numbers 3, 4, 7, and 11 have respective\n   UIDs
        405, 407, 410, and 425.\n"
      title: 3.2.7.  EXPUNGE Command
    - contents:
      - "3.2.8.  CLOSE Command\n   Arguments: none\n   Responses: no specific responses
        for this command\n   Result: OK - close completed, now in authenticated state\n
        \          BAD - command unknown or arguments invalid\n   This section updates
        the definition of the CLOSE command described in\n   Section 6.4.2 of [RFC3501].\n
        \  The CLOSE command permanently removes all messages that have the\n   \\Deleted
        flag set from the currently selected mailbox and returns to\n   the authenticated
        state from the selected state.  No untagged EXPUNGE\n   (or VANISHED) responses
        are sent.\n   If the server is capable of storing modification sequences for
        the\n   selected mailbox, it MUST increment the per-mailbox mod-sequence if\n
        \  at least one message was permanently removed due to the execution of\n
        \  the CLOSE command.  For each permanently removed message, the server\n
        \  MUST remember the incremented mod-sequence and corresponding UID.\n   The
        server MUST NOT send the updated per-mailbox modification\n   sequence using
        the HIGHESTMODSEQ response code (see Section 3.1.2.1)\n   in the tagged OK
        response, as this might cause loss of\n   synchronization on the client.\n
        \     Example:    C: A202 CLOSE\n                  S: A202 OK done\n"
      title: 3.2.8.  CLOSE Command
    - contents:
      - "3.2.9.  UID EXPUNGE Command\n   Arguments: message set\n   Responses: untagged
        responses: EXPUNGE or VANISHED\n   Result: OK - expunge completed\n           NO
        - expunge failure: can't expunge (e.g., permission denied)\n           BAD
        - command unknown or arguments invalid\n   This section updates the definition
        of the UID EXPUNGE command\n   described in Section 2.1 of [UIDPLUS], in the
        presence of QRESYNC.\n   Servers that implement both [UIDPLUS] and QRESYNC
        extensions must\n   implement UID EXPUNGE as described in this section.\n
        \  The UID EXPUNGE command permanently removes from the currently\n   selected
        mailbox all messages that have both the \\Deleted flag set\n   and a UID that
        is included in the specified message set.  If a\n   message either does not
        have the \\Deleted flag set or has a UID that\n   is not included in the specified
        message set, it is not affected.\n   This command is particularly useful for
        disconnected mode clients.\n   By using UID EXPUNGE instead of EXPUNGE when
        resynchronizing with the\n   server, the client can avoid inadvertently removing
        any messages that\n   have been marked as \\Deleted by other clients between
        the time that\n   the client was last connected and the time the client resynchronizes.\n
        \  Before returning an OK to the client, those messages that are removed\n
        \  are reported using a VANISHED response or EXPUNGE responses.\n   If the
        server is capable of storing modification sequences for the\n   selected mailbox,
        it MUST increment the per-mailbox mod-sequence if\n   at least one message
        was permanently removed due to the execution of\n   the UID EXPUNGE command.
        \ For each permanently removed message, the\n   server MUST remember the incremented
        mod-sequence and corresponding\n   UID.  If at least one message got expunged
        and QRESYNC was enabled,\n   the server MUST send the updated per-mailbox
        modification sequence\n   using the HIGHESTMODSEQ response code (see Section
        3.1.2.1) in the\n   tagged OK response.\n   Example:    C: . UID EXPUNGE 3000:3002\n
        \              S: * 3 EXPUNGE\n               S: * 3 EXPUNGE\n               S:
        * 3 EXPUNGE\n               S: . OK [HIGHESTMODSEQ 20010715194045319] Ok\n
        \  Note: In this example, the client hasn't enabled QRESYNC, so the\n   server
        is still using untagged EXPUNGE responses instead of VANISHED\n   responses.
        \ Note that the presence of the HIGHESTMODSEQ response code\n   is optional.
        \ If the selected mailbox returned NOMODSEQ, the\n   HIGHESTMODSEQ response
        code will be absent.  In this example, at\n   least messages with message
        numbers 3, 4, and 5 (UIDs 3000 to 3002)\n   had the \\Deleted flag set.  The
        first \"* 3 EXPUNGE\" reports message\n   #3 as expunged.  The second \"*
        3 EXPUNGE\" reports message #4 as\n   expunged (the message number was decremented
        due to the previous\n   EXPUNGE response).  See the description of the EXPUNGE
        response in\n   [RFC3501] for further explanation.\n"
      title: 3.2.9.  UID EXPUNGE Command
    - contents:
      - "3.2.10.  VANISHED Response\n   The VANISHED response reports that the specified
        UIDs have been\n   permanently removed from the mailbox.  This response is
        similar to\n   the EXPUNGE response [RFC3501]; however, it can return information\n
        \  about multiple messages, and it returns UIDs instead of message\n   numbers.
        \ The first benefit saves bandwidth, while the second is more\n   convenient
        for clients that only use UIDs to access the IMAP server.\n   The VANISHED
        response has the same restrictions on when it can be\n   sent as does the
        EXPUNGE response (see below).  Once a client has\n   issued \"ENABLE QRESYNC\"
        (and the server has positively responded to\n   that command with the untagged
        ENABLED response containing QRESYNC),\n   the server MUST use the VANISHED
        response without the EARLIER tag\n   instead of the EXPUNGE response for all
        mailboxes that don't return\n   NOMODSEQ when selected.  The server continues
        using VANISHED in lieu\n   of EXPUNGE for the duration of the connection.
        \ In particular, this\n   affects the EXPUNGE [RFC3501] and UID EXPUNGE [UIDPLUS]
        commands, as\n   well as messages expunged in other connections.  Such a VANISHED\n
        \  response MUST NOT contain the EARLIER tag.\n   The VANISHED response has
        two forms.  The first form contains the\n   EARLIER tag, which signifies that
        the response was caused by a UID\n   FETCH (VANISHED) or a SELECT/EXAMINE
        (QRESYNC) command.  The second\n   form doesn't contain the EARLIER tag and
        is used for announcing\n   message removals within an already selected mailbox.\n
        \  Because clients handle the two different forms of the VANISHED\n   response
        differently, servers MUST NOT combine them.  Messages are\n   reported in
        VANISHED responses with or without the EARLIER tag, as\n   appropriate to
        the cause, and, if necessary, two VANISHED responses\n   are sent (one with
        EARLIER and one without).\n"
      - contents:
        - "3.2.10.1.  VANISHED (EARLIER) Response\n   Contents:  an EARLIER tag\n
          \             list of UIDs\n   The VANISHED (EARLIER) response is caused
          by a UID FETCH (VANISHED)\n   or a SELECT/EXAMINE (QRESYNC) command.  This
          response is sent if the\n   UID set parameter to the UID FETCH (VANISHED)
          command includes UIDs\n   of messages that are no longer in the mailbox.
          \ When the client sees\n   a VANISHED EARLIER response, it MUST NOT decrement
          message sequence\n   numbers for each successive message in the mailbox.\n"
        title: 3.2.10.1.  VANISHED (EARLIER) Response
      - contents:
        - "3.2.10.2.  VANISHED Response without the (EARLIER) Tag\n   Contents:  list
          of UIDs\n   Once a client has issued \"ENABLE QRESYNC\" (and the server
          has\n   positively responded to that command with the untagged ENABLED\n
          \  response containing QRESYNC), the server MUST use the VANISHED\n   response
          without the EARLIER tag instead of the EXPUNGE response for\n   all mailboxes
          that don't return NOMODSEQ when selected.  The server\n   continues using
          VANISHED in lieu of EXPUNGE for the duration of the\n   connection.  In
          particular, this affects the EXPUNGE [RFC3501] and\n   UID EXPUNGE [UIDPLUS]
          commands, as well as messages expunged in other\n   connections.  Such a
          VANISHED response MUST NOT contain the EARLIER\n   tag.\n   Unlike VANISHED
          (EARLIER), this response also decrements the number\n   of messages in the
          mailbox and adjusts the message sequence numbers\n   for the messages remaining
          in the mailbox to account for the expunged\n   messages.  Because of this
          housekeeping, it is not necessary for the\n   server to send an EXISTS response
          to report the new message count.\n   See the example at the end of this
          section.\n   A VANISHED response without the EARLIER tag MUST refer only
          to\n   messages that are visible to the client in the current session at
          the\n   time the VANISHED response is sent.  That is, servers MUST NOT send\n
          \  UIDs for previously expunged messages or messages that were not\n   announced
          to the client via EXISTS.  This means that each UID listed\n   in a VANISHED
          response results in the client decrementing the message\n   count by one.
          \ This is required to prevent a possible race condition\n   where new arrivals
          for which the UID is not yet known by the client\n   are immediately expunged.\n
          \  A VANISHED response MUST NOT be sent when no command is in progress,\n
          \  nor while responding to a FETCH, STORE, or SEARCH command.  This rule\n
          \  is necessary to prevent a loss of synchronization of message sequence\n
          \  numbers between the client and server.  A command is not \"in\n   progress\"
          until the complete command has been received; in\n   particular, a command
          is not \"in progress\" during the negotiation of\n   command continuation.\n
          \  Note: UID FETCH, UID STORE, and UID SEARCH are different commands\n   from
          FETCH, STORE, and SEARCH.  A VANISHED response MAY be sent\n   during a
          UID command.  However, the VANISHED response MUST NOT be\n   sent during
          a UID SEARCH command that contains message numbers in the\n   search criteria.\n
          \  The update from the VANISHED response MUST be recorded by the client.\n
          \  Example: Let's assume that there is the following mapping between\n   message
          numbers and UIDs in the currently selected mailbox (here \"D\"\n   marks
          messages with the \\Deleted flag set, and \"x\" represents UIDs,\n   which
          are not relevant for the example):\n   Message numbers:   1    2    3    4
          \   5  6   7  8  9 10  11\n   UIDs:              x  504  505  507  508  x
          510  x  x  x 625\n   \\Deleted messages:           D    D           D            D\n
          \  In the presence of the extension defined in this document:\n   C: A202
          EXPUNGE\n   S: * VANISHED 505,507,510,625\n   S: A202 OK EXPUNGE completed\n
          \  Without the QRESYNC extension, the same example might look like:\n   C:
          A202 EXPUNGE\n   S: * 3 EXPUNGE\n   S: * 3 EXPUNGE\n   S: * 5 EXPUNGE\n
          \  S: * 8 EXPUNGE\n   S: A202 OK EXPUNGE completed\n   (Continuing from
          the previous example.)  If subsequently messages\n   with UIDs 504 and 508
          got marked as \\Deleted:\n   C: A210 EXPUNGE\n   S: * VANISHED 504,508\n
          \  S: A210 OK EXPUNGE completed\n   For Example, the last VANISHED response
          only contains UIDs of\n   messages expunged since the previous VANISHED
          response.\n   To illustrate the difference between VANISHED and VANISHED
          (EARLIER),\n   suppose the mailbox contains UIDs 2 and 4.  Any of the following\n
          \  responses would constitute a broken server implementation:\n   S: * VANISHED
          1\n   S: * VANISHED 3\n   S: * VANISHED 5\n   However, any of these UIDs
          can easily be referenced by the VANISHED\n   (EARLIER) response.\n"
        title: 3.2.10.2.  VANISHED Response without the (EARLIER) Tag
      title: 3.2.10.  VANISHED Response
    - contents:
      - "3.2.11.  CLOSED Response Code\n   The CLOSED response code has no parameters.
        \ A server implementing\n   the extension defined in this document MUST return
        the CLOSED\n   response code when the currently selected mailbox is closed\n
        \  implicitly using the SELECT/EXAMINE command on another mailbox.  The\n
        \  CLOSED response code serves as a boundary between responses for the\n   previously
        opened mailbox (which was closed) and the newly selected\n   mailbox; all
        responses before the CLOSED response code relate to the\n   mailbox that was
        closed, and all subsequent responses relate to the\n   newly opened mailbox.\n
        \  A server that advertises \"QRESYNC\" or \"CONDSTORE\" in the capability\n
        \  string must return the CLOSED response code in this case, whether or\n
        \  not a CONDSTORE enabling command was issued.\n   There is no need to return
        the CLOSED response code on completion of\n   the CLOSE or the UNSELECT [UNSELECT]
        command (or similar), whose\n   purpose is to close the currently selected
        mailbox without opening a\n   new one.\n"
      title: 3.2.11.  CLOSED Response Code
    title: 3.2.  QRESYNC Extension
  title: 3.  IMAP Protocol Changes
- contents:
  - "4.  Long Command Lines (Update to RFC 2683)\n   While [RFC3501] doesn't specify
    a specific line-length limit, several\n   server implementations chose to implement
    the recommended line-length\n   limit suggested in Section 3.2.1.5 of [RFC2683]
    in order to protect\n   from Denial-of-Service attacks.  When the line-length
    limit is\n   exceeded, such servers return a BAD response (as required by\n   [RFC3501]
    in case of a syntactic error) and may even close the\n   connection.  Clients
    that support CONDSTORE/QRESYNC extensions can\n   trigger this limit by sending
    a long UID sequence (previously\n   returned by the server) in an extended SELECT
    or FETCH command.\n   This document updates recommended line-length limits specified
    in\n   Section 3.2.1.5 of [RFC2683].  While the advice in the first\n   paragraph
    of that section still applies (use compact message/UID set\n   representations),
    the 1000-octet limit suggested in the second\n   paragraph turns out to be quite
    problematic when the CONDSTORE and/or\n   QRESYNC extension is used.\n   The updated
    recommendation is as follows: a client should limit the\n   length of the command
    lines it generates to approximately 8192 octets\n   (including all quoted strings
    but not including literals).  If the\n   client is unable to group things into
    ranges so that the command line\n   is within that length, it should split the
    request into multiple\n   commands.  The client should use literals instead of
    long quoted\n   strings in order to keep the command length down.\n"
  title: 4.  Long Command Lines (Update to RFC 2683)
- contents:
  - "5.  QRESYNC Server Implementation Considerations\n   This section describes a
    minimalist implementation, a moderate\n   implementation, and an example of a
    full implementation.\n"
  - contents:
    - "5.1.  Server Implementations That Don't Store Extra State\n   Strictly speaking,
      a server implementation that doesn't remember mod-\n   sequences associated
      with expunged messages can be considered\n   compliant with this specification.
      \ Such implementations return all\n   expunged messages specified in the UID
      set of the UID FETCH\n   (VANISHED) command every time, without paying attention
      to the\n   specified CHANGEDSINCE mod-sequence.  Such implementations are\n
      \  discouraged as they can end up returning VANISHED responses that are\n   bigger
      than the result of a UID SEARCH command for the same UID set.\n   A client can
      substantially reduce the size of VANISHED responses by\n   providing the server
      with message sequence match data (see\n   Section 3.2.5.2).  This is especially
      effective in the typical case\n   where no messages have been expunged, or all
      expunges were toward the\n   end of the mailbox.\n"
    title: 5.1.  Server Implementations That Don't Store Extra State
  - contents:
    - "5.2.  Server Implementations Storing Minimal State\n   A server that stores
      the HIGHESTMODSEQ value at the time of the last\n   EXPUNGE can omit the VANISHED
      response when a client provides a\n   MODSEQ value that is equal to or higher
      than that HIGHESTMODSEQ value\n   because there have been no messages expunged
      during the time period\n   the client is concerned about.\n   A client providing
      message sequence match data can reduce the scope\n   as above.  In the case
      where there have been no expunges, the server\n   can ignore this data.\n"
    title: 5.2.  Server Implementations Storing Minimal State
  - contents:
    - "5.3.  Additional State Required on the Server\n   When compared to the CONDSTORE
      extension, QRESYNC requires servers to\n   store an additional state associated
      with expunged messages.  Note\n   that implementations are not required to store
      this state in\n   persistent storage; however, use of persistent storage is
      advisable.\n   One possible way to correctly implement QRESYNC is to store a
      queue\n   of <UID set, mod-sequence> pairs. <UID set> can be represented as
      a\n   sequence of <min UID, max UID> pairs.\n   When messages are expunged,
      one or more entries are added to the\n   queue tail.\n   When the server receives
      a request to return messages expunged since\n   a given mod-sequence, it will
      search the queue from the tail (i.e.,\n   going from the highest expunged mod-sequence
      to the lowest) until it\n   sees the first record with a mod-sequence less than
      or equal to the\n   given mod-sequence or it reaches the head of the queue.\n
      \  Note that indefinitely storing information about expunged messages\n   can
      cause storage and related problems for an implementation.  In the\n   worst
      case, this could result in almost 64 GB of storage for each\n   IMAP mailbox.
      \ For example, consider an implementation that stores\n   <min UID, max UID,
      mod-sequence> triples for each range of messages\n   expunged at the same time.
      \ Each triple requires 16 octets: 4 octets\n   for each of the two UIDs and
      8 octets for the mod-sequence.  Assume\n   that there is a mailbox containing
      a single message with a UID of\n   2**32-1 (the maximum possible UID value),
      where messages had\n   previously existed with UIDs starting at 1 and have been
      expunged one\n   at a time.  For this mailbox alone, storage is required for
      the\n   triples <1, 1, modseq1>, <2, 2, modseq2>, ..., <2**32-2, 2**32-2,\n
      \  modseq4294967294>.\n   Hence, implementations are encouraged to adopt strategies
      to protect\n   against such storage problems, such as limiting the size of the
      queue\n   used to store mod-sequences for expunged messages and \"expiring\"\n
      \  older records when this limit is reached.  When the selected\n   implementation-specific
      queue limit is reached, the oldest record(s)\n   is deleted from the queue (note
      that such records are located at the\n   queue head).  For all such \"expired\"
      records, the server needs to\n   store a single mod-sequence, which is the highest
      mod-sequence for\n   all \"expired\" expunged messages.\n   If the client provides
      the message sequence match data, this can\n   heavily reduce the data cost of
      sending a complete set of missing\n   UIDs; thus, it reduces the problems for
      clients if a server is unable\n   to persist much of this queue.  If the queue
      contains data back to\n   the requested mod-sequence, this data can be ignored.\n
      \  Also, note that if the UIDVALIDITY of the mailbox changes or if the\n   mailbox
      is deleted, then any state associated with expunged messages\n   doesn't need
      to be preserved and SHOULD be deleted.\n"
    title: 5.3.  Additional State Required on the Server
  title: 5.  QRESYNC Server Implementation Considerations
- contents:
  - "6.  Updated Synchronization Sequence\n   This section updates the description
    of optimized synchronization in\n   Section 6.1 of [IMAP-DISC], in the presence
    of QRESYNC.\n   An advanced disconnected mail client SHOULD use the QRESYNC extension\n
    \  when it is supported by the server and SHOULD use CONDSTORE if it is\n   supported
    and QRESYNC is not.  The client uses the value from the\n   HIGHESTMODSEQ OK response
    code received on the mailbox opening to\n   determine if it needs to resynchronize.
    \ Once the synchronization is\n   complete, it MUST cache the received value (unless
    the mailbox\n   UIDVALIDITY value has changed; see below).  The client MUST update\n
    \  its copy of the HIGHESTMODSEQ value whenever the server sends a\n   subsequent
    HIGHESTMODSEQ OK response code.\n   After completing a full synchronization, the
    client MUST also take\n   note of any unsolicited MODSEQ FETCH data items and
    HIGHESTMODSEQ\n   response codes received from the server.  Whenever the client\n
    \  receives a tagged response to a command, it checks the received\n   unsolicited
    responses to calculate the new HIGHESTMODSEQ value.  If\n   the HIGHESTMODSEQ
    response code is received, the client MUST use it\n   even if it has seen higher
    mod-sequences.  Otherwise, the client\n   calculates the highest value among all
    MODSEQ FETCH data items\n   received since the last tagged response.  If this
    value is bigger\n   than the client's copy of the HIGHESTMODSEQ value, then the
    client\n   MUST use this value as its new HIGHESTMODSEQ value.\n   Example:\n
    \  C: A150 STORE 1:2 (UNCHANGEDSINCE 96) +FLAGS.SILENT \\Seen\n   S: * 1 FETCH
    (UID 6 MODSEQ (103))\n   S: * 2 FETCH (UID 7 MODSEQ (101))\n   S: * OK [HIGHESTMODSEQ
    99] VANISHED reply with MODSEQ 100 is delayed\n   S: A150 OK [MODIFIED 3] done\n
    \  C: A151 STORE 3 +FLAGS.SILENT \\Seen\n   S: * 3 FETCH (UID 8 MODSEQ (104))\n
    \  S: A151 OK [HIGHESTMODSEQ 99] Still delaying VANISHED\n   C: A152 NOOP\n   S:
    * VANISHED 8\n   S: A153 OK [HIGHESTMODSEQ 104] done\n   Note: It is not safe
    to update the client's copy of the HIGHESTMODSEQ\n   value with a MODSEQ FETCH
    data item value as soon as it is received\n   because servers are not required
    to send MODSEQ FETCH data items in\n   increasing mod-sequence order.  Some commands
    may also delay EXPUNGE\n   (or VANISHED) replies with smaller mod-sequences.  These
    can lead to\n   the client missing some changes in case of connectivity loss.\n
    \  When opening the mailbox for synchronization, the client uses the\n   QRESYNC
    parameter to the SELECT/EXAMINE command.  The QRESYNC\n   parameter is followed
    by the UIDVALIDITY and mailbox HIGHESTMODSEQ\n   values, as known to the client.
    \ It can be optionally followed by the\n   set of UIDs, for example, if the client
    is only interested in partial\n   synchronization of the mailbox.  The client
    may also transmit a list\n   containing its knowledge of message numbers.\n   If
    the SELECT/EXAMINE command is successful, the client compares\n   UIDVALIDITY
    as described in step d-1 in Section 3 of the [IMAP-DISC].\n   If the cached UIDVALIDITY
    value matches the one returned by the\n   server and the server also returns the
    HIGHESTMODSEQ response code,\n   then the server reports expunged messages and
    returns flag changes\n   for all messages specified by the client in the UID set
    parameter (or\n   for all messages in the mailbox, if the client omitted the UID
    set\n   parameter).  At this point, the client is synchronized, except for\n   maybe
    the new messages.\n   If upon a successful SELECT/EXAMINE (QRESYNC) command the
    client\n   receives a NOMODSEQ OK untagged response (instead of the\n   HIGHESTMODSEQ
    response code), it MUST remove the last known\n   HIGHESTMODSEQ value from its
    cache and follow the more general\n   instructions in Section 3 of the [IMAP-DISC].\n
    \  At this point, the client is in sync with the server regarding old\n   messages.
    \ This client can now fetch information about new messages\n   (if requested by
    the user).\n   Step d (\"Server-to-client synchronization\") in Section 6.1 of\n
    \  [IMAP-DISC] in the presence of the QRESYNC & CONDSTORE extensions is\n   amended
    as follows:\n   d) \"Server-to-client synchronization\" -- for each mailbox that\n
    \     requires synchronization, do the following:\n   1a) Check the mailbox UIDVALIDITY
    (see Section 4.1 of [IMAP-DISC] for\n       more details) after issuing the SELECT/EXAMINE
    (QRESYNC) command.\n       If the UIDVALIDITY value returned by the server differs,
    the\n       client MUST:\n       *  empty the local cache of that mailbox;\n       *
    \ \"forget\" the cached HIGHESTMODSEQ value for the mailbox; and\n       *  remove
    any pending \"actions\" that refer to UIDs in that\n          mailbox.  Note,
    this doesn't affect actions performed on\n          client-generated fake UIDs
    (see Section 5 of the [IMAP-DISC]).\n   1b) This step is no longer required.\n
    \  2)  Fetch the current \"descriptors\".\n       I) Discover new messages.\n
    \  3)  Fetch the bodies of any \"interesting\" messages that the client\n       doesn't
    already have.\n   Example: The UIDVALIDITY value is the same, but the HIGHESTMODSEQ\n
    \           value has changed on the server while the client was\n            offline:\n
    \   C: A142 SELECT INBOX (QRESYNC (3857529045 20010715194032001 1:198))\n    S:
    * 172 EXISTS\n    S: * 1 RECENT\n    S: * OK [UNSEEN 12] Message 12 is first unseen\n
    \   S: * OK [UIDVALIDITY 3857529045] UIDs valid\n    S: * OK [UIDNEXT 201] Predicted
    next UID\n    S: * FLAGS (\\Answered \\Flagged \\Deleted \\Seen \\Draft)\n    S:
    * OK [PERMANENTFLAGS (\\Deleted \\Seen \\*)] Limited\n    S: * OK [HIGHESTMODSEQ
    20010715194045007] Highest\n          mailbox mod-sequence\n    S: * VANISHED
    (EARLIER) 1:5,7:8,10:15\n    S: * 2 FETCH (UID 6 MODSEQ (20010715205008000)\n
    \       FLAGS (\\Deleted))\n    S: * 5 FETCH (UID 9 MODSEQ (20010715195517000)\n
    \       FLAGS ($NoJunk $AutoJunk $MDNSent))\n       ...\n    S: A142 OK [READ-WRITE]
    SELECT completed\n"
  title: 6.  Updated Synchronization Sequence
- contents:
  - "7.  Formal Syntax\n   The following syntax specification uses the Augmented Backus-Naur\n
    \  Form (ABNF) notation as specified in [RFC5234].\n   Non-terminals referenced
    but not defined below are as defined by\n   [RFC5234], [RFC3501], or [RFC4466].\n
    \  Except as noted otherwise, all alphabetic characters are case-\n   insensitive.
    \ The use of upper- or lower-case characters to define\n   token strings is for
    editorial clarity only.  Implementations MUST\n   accept these strings in a case-insensitive
    fashion.\n   capability          =/ \"CONDSTORE\" / \"QRESYNC\"\n   status-att
    \         =/ \"HIGHESTMODSEQ\"\n                          ;; Extends non-terminal
    defined in [RFC3501].\n   status-att-val      =/ \"HIGHESTMODSEQ\" SP mod-sequence-valzer\n
    \                         ;; Extends non-terminal defined in [RFC4466].\n                          ;;
    Value 0 denotes that the mailbox doesn't\n                          ;; support
    persistent mod-sequences\n                          ;; as described in Section
    3.1.2.2.\n   store-modifier      =/ \"UNCHANGEDSINCE\" SP mod-sequence-valzer\n
    \                         ;; Only a single \"UNCHANGEDSINCE\" may be\n                          ;;
    specified in a STORE operation.\n   fetch-modifier      =/ chgsince-fetch-mod\n
    \                         ;; Conforms to the generic \"fetch-modifier\"\n                          ;;
    syntax defined in [RFC4466].\n   chgsince-fetch-mod  = \"CHANGEDSINCE\" SP mod-sequence-value\n
    \                         ;; CHANGEDSINCE FETCH modifier conforms to\n                          ;;
    the fetch-modifier syntax.\n   fetch-att           =/ fetch-mod-sequence\n                          ;;
    Modifies original IMAP4 fetch-att.\n   fetch-mod-sequence  = \"MODSEQ\"\n   fetch-mod-resp
    \     = \"MODSEQ\" SP \"(\" permsg-modsequence \")\"\n   msg-att-dynamic     =/
    fetch-mod-resp\n   search-key          =/ search-modsequence\n                          ;;
    Modifies original IMAP4 search-key.\n                          ;;\n                          ;;
    This change applies to all commands\n                          ;; referencing
    this non-terminal -- in\n                          ;; particular, SEARCH, SORT,
    and THREAD.\n   search-modsequence  = \"MODSEQ\" [search-modseq-ext] SP\n                         mod-sequence-valzer\n
    \  search-modseq-ext   = SP entry-name SP entry-type-req\n   resp-text-code      =/
    \"HIGHESTMODSEQ\" SP mod-sequence-value /\n                          \"NOMODSEQ\"
    /\n                          \"MODIFIED\" SP sequence-set\n   entry-name          =
    entry-flag-name\n   entry-flag-name     = DQUOTE \"/flags/\" attr-flag DQUOTE\n
    \                         ;; Each system or user-defined flag <flag>\n                          ;;
    is mapped to \"/flags/<flag>\".\n                          ;;\n                          ;;
    <entry-flag-name> follows the escape rules\n                          ;; used
    by \"quoted\" string as described in\n                          ;; Section 4.3
    of [RFC3501]; e.g., for the\n                          ;; flag \\Seen, the corresponding
    <entry-name>\n                          ;; is \"/flags/\\\\seen\", and for the
    flag\n                          ;; $MDNSent, the corresponding <entry-name>\n
    \                         ;; is \"/flags/$mdnsent\".\n   entry-type-resp     =
    \"priv\" / \"shared\"\n                          ;; Metadata item type.\n   entry-type-req
    \     = entry-type-resp / \"all\"\n                          ;; Perform SEARCH
    operation on a private\n                          ;; metadata item, shared metadata
    item,\n                          ;; or both.\n   permsg-modsequence  = mod-sequence-value\n
    \                         ;; Per-message mod-sequence.\n   mod-sequence-value
    \ = 1*DIGIT\n                          ;; Positive unsigned 63-bit integer\n                          ;;
    (mod-sequence)\n                          ;; (1 <= n <= 9,223,372,036,854,775,807).\n
    \  mod-sequence-valzer = \"0\" / mod-sequence-value\n   search-sort-mod-seq =
    \"(\" \"MODSEQ\" SP mod-sequence-value \")\"\n   select-param        =/ condstore-param\n
    \                         ;; Conforms to the generic \"select-param\"\n                          ;;
    non-terminal syntax defined in [RFC4466].\n   condstore-param     = \"CONDSTORE\"\n
    \  mailbox-data        =/ \"SEARCH\" [1*(SP nz-number) SP\n                          search-sort-mod-seq]\n
    \  sort-data           = \"SORT\" [1*(SP nz-number) SP\n                          search-sort-mod-seq]\n
    \                         ; Updates the SORT response from RFC 5256.\n   attr-flag
    \          = \"\\\\Answered\" / \"\\\\Flagged\" / \"\\\\Deleted\" /\n                         \"\\\\Seen\"
    / \"\\\\Draft\" / attr-flag-keyword /\n                         attr-flag-extension\n
    \                         ;; Does not include \"\\\\Recent\".\n   attr-flag-extension
    = \"\\\\\" atom\n                          ;; Future expansion.  Client implementations\n
    \                         ;; MUST accept flag-extension flags.  Server\n                          ;;
    implementations MUST NOT generate\n                          ;; flag-extension
    flags, except as defined by\n                          ;; future standards or
    Standards Track\n                          ;; revisions of [RFC3501].\n   attr-flag-keyword
    \  = atom\n   select-param        =/  \"QRESYNC\" SP \"(\" uidvalidity SP\n                       mod-sequence-value
    [SP known-uids]\n                       [SP seq-match-data] \")\"\n                       ;;
    Conforms to the generic select-param\n                       ;; syntax defined
    in [RFC4466].\n   seq-match-data      =  \"(\" known-sequence-set SP known-uid-set
    \")\"\n   uidvalidity         =  nz-number\n   known-uids          =  sequence-set\n
    \                      ;; Sequence of UIDs; \"*\" is not allowed.\n   known-sequence-set
    \ =  sequence-set\n                       ;; Set of message numbers corresponding
    to\n                       ;; the UIDs in known-uid-set, in ascending order.\n
    \                      ;; * is not allowed.\n   known-uid-set       =  sequence-set\n
    \                      ;; Set of UIDs corresponding to the messages in\n                       ;;
    known-sequence-set, in ascending order.\n                       ;; * is not allowed.\n
    \  message-data        =/ expunged-resp\n   expunged-resp       =  \"VANISHED\"
    [SP \"(EARLIER)\"] SP known-uids\n   rexpunges-fetch-mod =  \"VANISHED\"\n                       ;;
    VANISHED UID FETCH modifier conforms\n                       ;; to the fetch-modifier
    syntax\n                       ;; defined in [RFC4466].  It is only\n                       ;;
    allowed in the UID FETCH command.\n   resp-text-code      =/ \"CLOSED\"\n"
  title: 7.  Formal Syntax
- contents:
  - "8.  Security Considerations\n   As always, it is important to thoroughly test
    clients and servers\n   implementing QRESYNC, as it changes how the server reports
    expunged\n   messages to the client.\n   It is believed that the CONDSTORE or
    the QRESYNC extensions don't\n   raise any new security concerns that are not
    already discussed in\n   [RFC3501].  However, the availability of CONDSTORE may
    make it\n   possible for IMAP4 to be used in critical applications it could not\n
    \  be used for previously, making correct IMAP server implementation and\n   operation
    even more important.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   IMAP4 capabilities are registered by publishing a
    Standards Track or\n   IESG-approved Experimental RFC.  The registry is currently
    located\n   at:\n      http://www.iana.org/assignments/imap-capabilities\n   This
    document defines the CONDSTORE and QRESYNC IMAP capabilities.\n   IANA has updated
    references for both extensions to point to this\n   document.\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2683]  Leiba, B., \"IMAP4 Implementation Recommendations\", RFC\n
      \             2683, September 1999.\n   [RFC3501]  Crispin, M., \"INTERNET MESSAGE
      ACCESS PROTOCOL - VERSION\n              4rev1\", RFC 3501, March 2003.\n   [RFC4466]
      \ Melnikov, A. and C. Daboo, \"Collected Extensions to IMAP4\n              ABNF\",
      RFC 4466, April 2006.\n   [RFC5161]  Gulbrandsen, A. and A. Melnikov, \"The
      IMAP ENABLE\n              Extension\", RFC 5161, March 2008.\n   [RFC5234]
      \ Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC5256]  Crispin, M. and K. Murchison,
      \"Internet Message Access\n              Protocol - SORT and THREAD Extensions\",
      RFC 5256, June\n              2008.\n   [RFC5464]  Daboo, C., \"The IMAP METADATA
      Extension\", RFC 5464,\n              February 2009.\n   [UIDPLUS]  Crispin,
      M., \"Internet Message Access Protocol (IMAP) -\n              UIDPLUS extension\",
      RFC 4315, December 2005.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [IMAP-DISC]\n              Melnikov, A.,
      Ed., \"Synchronization Operations For\n              Disconnected Imap4 Clients\",
      RFC 4549, June 2006.\n   [NTP]      Mills, D., Martin, J., Burbank, J., and
      W. Kasch, \"Network\n              Time Protocol Version 4: Protocol and Algorithms\n
      \             Specification\", RFC 5905, June 2010.\n   [RFC2180]  Gahrns, M.,
      \"IMAP4 Multi-Accessed Mailbox Practice\", RFC\n              2180, July 1997.\n
      \  [RFC4314]  Melnikov, A., \"IMAP4 Access Control List (ACL) Extension\",\n
      \             RFC 4314, December 2005.\n   [RFC4731]  Melnikov, A. and D. Cridland,
      \"IMAP4 Extension to SEARCH\n              Command for Controlling What Kind
      of Information Is\n              Returned\", RFC 4731, November 2006.\n   [RFC5257]
      \ Daboo, C. and R. Gellens, \"Internet Message Access\n              Protocol
      - ANNOTATE Extension\", RFC 5257, June 2008.\n   [RFC5267]  Cridland, D. and
      C. King, \"Contexts for IMAP4\", RFC 5267,\n              July 2008.\n   [RFC6851]
      \ Gulbrandsen, A. and N. Freed, \"Internet Message Access\n              Protocol
      (IMAP) - MOVE Extension\", RFC 6851, January 2013.\n   [UNSELECT] Melnikov,
      A., \"Internet Message Access Protocol (IMAP)\n              UNSELECT command\",
      RFC 3691, February 2004.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Changes since RFC 4551\n   Changed mod-sequences to be unsigned
    63-bit values (instead of\n   unsigned 64-bit values).\n   Fixed the following
    errata, as posted on <http://www.rfc-editor.org>:\n   o  Errata ID 3401 (\"several
    typos in UNCHANGEDSINCE spelling\")\n   o  Errata ID 3506 (\"invalid ABNF for
    the MODIFIED response code\")\n   o  Errata ID 3509 (\"correction to an example\")\n
    \  Clarified that the returning of HIGHESTMODSEQ/NOMODSEQ response codes\n   is
    only required once a CONDSTORE enabling command is issued.\n   Clarified that
    if multiple mod-sequences (for different metadata\n   items) are associated with
    a message, then all of them affecting a\n   particular STORE UNCHANGEDSINCE must
    be checked.\n   Updated references.\n   Made editorial corrections.\n"
  title: Appendix A.  Changes since RFC 4551
- contents:
  - "Appendix B.  Changes since RFC 5162\n   Changed mod-sequences to be unsigned
    63-bit values (instead of\n   unsigned 64-bit values).\n   Addressed the following
    errata, as posted on\n   <http://www.rfc-editor.org>:\n   o  Errata ID 1365 (\"clarified
    that QRESYNC is only enabled when\n      ENABLED QRESYNC is returned\")\n   o
    \ Errata ID 1807 (\"unsolicited FETCH responses must include UID\n      fetch
    response item\")\n   o  Errata ID 1808 (\"HIGHESTMODSEQ response code must not
    be returned\n      for CLOSE\")\n   o  Errata ID 1809 (\"clarify how updated mailbox
    mod-sequence is\n      calculated\")\n   o  Errata ID 1810 (\"server must send
    untagged events to client in a\n      way that client doesn't lose any changes
    in case of connectivity\n      loss\")\n   o  Errata ID 3322 (\"VANISHED responses
    must not reference non-\n      existing UIDs\")\n   Clarified that ENABLE QRESYNC
    CONDSTORE and ENABLE CONDSTORE QRESYNC\n   are equivalent.\n   Changed the requirement
    to return VANISHED from SHOULD to MUST as per\n   the mailing list discussion.
    \ The only exception is for mailboxes\n   that return the NOMODSEQ response code
    when they are selected.\n   Specified that IMAP SETMETADATA changes update per-mailbox\n
    \  HIGHESTMODSEQ.\n   Clarified that per-message annotations are also considered\n
    \  \"metadata\".\n   Fixed some examples to report data that match requirements
    specified\n   in the document.\n   Clarified some text and made some requirements
    normative.  Also,\n   corrected a couple of SHOULDs to be MUSTs.\n   Updated references.\n
    \  Made editorial corrections.\n"
  title: Appendix B.  Changes since RFC 5162
- contents:
  - "Appendix C.  Acknowledgements\n   Thank you to Steve Hole for co-editing RFC
    4551.\n   In this revision of the document, the authors also acknowledge the\n
    \  feedback provided by Timo Sirainen, Jan Kundrat, Pete Maclean, Barry\n   Leiba,
    Eliot Lear, Chris Newman, Claudio Allocchio, Michael Slusarz,\n   Bron Gondwana,
    Arnt Gulbrandsen, David Black, Hoa V. DINH, and Nick\n   Hudson.\n   Mark Crispin
    contributed to RFCs 4551 and 5162 that this document is\n   replacing, and much
    of his contribution remains in this merged\n   document.\n   See also the list
    of people who contributed to RFC 4551, which this\n   document obsoletes.\n"
  title: Appendix C.  Acknowledgements
- contents:
  - "Authors' Addresses\n   Alexey Melnikov\n   Isode Ltd\n   5 Castle Business Village\n
    \  36 Station Road\n   Hampton, Middlesex  TW12 2BX\n   UK\n   EMail: Alexey.Melnikov@isode.com\n
    \  Dave Cridland\n   Surevine Ltd\n   PO Box 1136\n   Guildford, Surrey  GU1 9ND\n
    \  UK\n   EMail: dave.cridland@surevine.com\n"
  title: Authors' Addresses
