- title: __initial_text__
  contents:
  - '          Simple Cryptographic Program Interface (Crypto API)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a simple Application Program Interface to\n\
    \   cryptographic functions. The main purpose of such an interface is to\n   separate\
    \ cryptographic libraries from internet applications, thus\n   allowing an independent\
    \ development of both. It can be used in\n   various internet applications such\
    \ as [IPsec], [ISAKMP], [IKE],\n   [TLS].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   1.1. Summary . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  2\n   1.2. Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  2\n   1.3. Objectives of Development . . . . . . . . . . . . . . .\
    \ . . .  3\n   2. Cryptoplugin Structure. . . . . . . . . . . . . . . . . . .\
    \ . .  3\n   3. Program Interface . . . . . . . . . . . . . . . . . . . . . .\
    \ .  4\n   3.1. Cryptoplugin Initialization Function. . . . . . . . . . . . .\
    \  4\n   3.1.1. Description of CryptoPluginInfo structure . . . . . . . . .  6\n\
    \   3.1.2. Description of CryptoAlgInfo structure. . . . . . . . . . .  6\n  \
    \ 3.2. Cryptoplugin Deinitialization Function. . . . . . . . . . . .  9\n   3.3.\
    \ Cryptographic Context Opening Function. . . . . . . . . . . . 10\n   3.4. Cryptographic\
    \ Context Reopening Function. . . . . . . . . . . 11\n   3.5. Cryptographic Context\
    \ Closing Function. . . . . . . . . . . . 12\n   3.6. Key Verification Function\
    \ . . . . . . . . . . . . . . . . . . 12\n   3.7. Data Transformation Function.\
    \ . . . . . . . . . . . . . . . . 13\n   3.7.1. For CRYPTO_TYPE_ENCRYPT Algorithm\
    \ Type. . . . . . . . . . . 13\n   3.7.2. For CRYPTO_TYPE_DECRYPT Algorithm Type.\
    \ . . . . . . . . . . 14\n   3.7.3. For CRYPTO_TYPE_SIGN Algorithm Type . . .\
    \ . . . . . . . . . 15\n   3.7.4. For CRYPTO_TYPE_VERIFY Algorithm Type . . .\
    \ . . . . . . . . 17\n   3.7.5. For CRYPTO_TYPE_COMPRESS Algorithm Type . . .\
    \ . . . . . . . 18\n   3.7.6. For CRYPTO_TYPE_UNCOMPRESS Algorithm Type . . .\
    \ . . . . . . 18\n   3.7.7. For CRYPTO_TYPE_HASH Algorithm Type . . . . . . .\
    \ . . . . . 19\n   3.7.8. For CRYPTO_TYPE_RANDOM Algorithm Type.  . . . . . .\
    \ . . . . 21\n   3.8. Cryptographic Context Control Function. . . . . . . . .\
    \ . . . 22\n   4. Cryptoplugin Registration Procedure . . . . . . . . . . . .\
    \ . . 23\n   5. Security Considerations . . . . . . . . . . . . . . . . . . .\
    \ . 23\n   6. References. . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 23\n   7. Author's Address  . . . . . . . . . . . . . . . . . . . . . . . 24\n\
    \   Appendix A. The interface specification as a C header file . . . . 25\n  \
    \ Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 30\n"
- title: 1. Introduction
  contents:
  - '1. Introduction

    '
- title: 1.1. Summary
  contents:
  - "1.1. Summary\n   Nowadays internet applications that require cryptographic functions\n\
    \   at the level of operating system kernel, use the method that assumes\n   the\
    \ libraries must be compiled/linked together with the module\n   (driver) which\
    \ provides product functionality. For the sake of\n   possibility of independent\
    \ development of the cryptographic modules\n   and in order to provide a simple,\
    \ effective and universal (suitable\n   for application and as well kernel level\
    \ of operating system)\n   solution this specification offers the method to extract\
    \ encrypting\n   algorithms to the separate cryptographic modules.\n   This document\
    \ describes simple open interface (Crypto API) to\n   external cryptographic libraries\
    \ optimized both for the application\n   and kernel level of the operating system.\n"
- title: 1.2. Terminology
  contents:
  - "1.2. Terminology\n   Cryptoplugin\n      Operation system unit (driver, shared\
    \ library, module) that\n      provides cryptographic functions via well-defined\
    \ (but OS-\n      specific) interface.\n   Cryptolibrary\n      Part of cryptoplugin\
    \ that provides its cryptographic functionality\n      via Crypto API.\n   Wrapper\n\
    \      Part of cryptoplugin that provides interfaces translation between\n   \
    \   Crypto API and OS-specific interface.\n   Definition of all cryptography related\
    \ terms can be found in\n   [Schneier].\n"
- title: 1.3. Objectives of Development
  contents:
  - "1.3. Objectives of Development\n   The objectives of Simple CryptoAPI development\
    \ are as follows:\n      1) To extract program implementations of encryption,\
    \ one-way hash\n         function, digital signature and random numbers generation\n\
    \         algorithms to separate, independently developed modules.\n      2) To\
    \ provide version independence between using encryption\n         modules and\
    \ external cryptoplugin.\n      3) To ensure platform independent developments\
    \ of encrypting\n         algorithm modules with portable source code.\n     \
    \ 4) To enable independent development of modules and compatibility\n        \
    \ of modules developed independently.\n"
- title: 2. Cryptoplugin Structure
  contents:
  - "2. Cryptoplugin Structure\n   In order to provide fast exchange between the cryptoplugin\
    \ and its\n   client the cryptoplugin is implemented as a separate driver (or\n\
    \   module) of the particular operating system (Fig.1). Cryptoplugin\n   consists\
    \ of two parts (Fig.2):\n      1) cryptolibrary itself (1)\n      2) system-dependent\
    \ module (wrapper) for interaction between\n         cryptolibrary and its client\
    \ (2)\n                                       Cryptoplugin initialization\n  \
    \                                   / by the operating system\n              \
    \                       |\n                                     |\n     +------------------+\
    \          +-|-+-------------+\n     |                  |          |   |     \
    \        |\n     |  Cryptoplugin's  | -------> |                 |\n     |   \
    \               |          |  Cryptoplugin   |\n     |     client       | <-------\
    \ |                 |\n     |                  |          |   |             |\n\
    \     +------------------+     |    +---+-------------+\n                    \
    \          |\n                              \\\n                             \
    \  \\ System-dependent CPI\n    Fig. 1  Interaction between cryptoplugin and its\
    \ client\n     +---------------+-------------------------------+\n     |     \
    \          |                               |\n     |              -->       Submodule\
    \ of           |\n     |  Submodule -  |                               |\n   \
    \  |               |   encrypting algorithms (1)   |\n     |  wrapper (2)  | \
    \                              |\n     |              <--       (cryptolibrary)\
    \        |\n     |               |                               |\n     +---------------+-------------------------------+\n\
    \                     |\n                     \\\n                      \\ Cryptographic\
    \ Program Interface\n                Fig. 2  Cryptoplugin structure\n   The system-dependent\
    \ module (wrapper) is delivered by the driver-\n   client developer in the form\
    \ of source code or in the form of\n   libraries (for example, in the form of\
    \ object files) for particular\n   operating system.  The wrapper is intended\
    \ for translation of\n   system-independent application interface to the particular\
    \ system-\n   dependent interface with the cryptoplugin's client. The wrapper\n\
    \   context does not include components specific to cryptoplugin's client\n  \
    \ functionality or to some cryptographic algorithm. The interface\n   described\
    \ in section 3 is the standard for interaction between the\n   submodules (1)\
    \ and (2).\n   A cryptoplugin can contain a number of different algorithms.\n\
    \   Moreover, it can contain some different implementations of one\n   particular\
    \ algorithm.\n"
- title: 3. Program Interface
  contents:
  - "3. Program Interface\n   The CPI (Cryptographic Program Interface) consists of\
    \ a set of\n   functions exported by encrypting algorithm submodule (cryptolibrary).\n\
    \   The interface functions are described below (see also Appendix A).\n"
- title: 3.1. Cryptoplugin Initialization Function
  contents:
  - "3.1. Cryptoplugin Initialization Function\n   The function is intended for cryptoplugin\
    \ initialization and\n   obtaining information about algorithms contained in cryptoplugin.\
    \ The\n   function is called once before the beginning of cryptoplugin\n   operation.\n\
    \   /* CryptoPlugin initialization. Returns pointer to CryptoPluginInfo\n   structure\
    \ on success or NULL on fatal error. */\n   CryptoPluginInfo *CryptoPluginInit(\n\
    \                   void            *param);/* Ptr to OS parameters\n        \
    \                                      (platform-specific) */\n   Description\
    \ of parameters:\n      param - pointer to system-dependent parameters transmitted\
    \ to\n         cryptoplugin by the operating system. Intention and format of\n\
    \         parameters are specific to each operating system and should be\n   \
    \      described in documentation on the cryptoplugin wrapper.\n   The function\
    \ is called at the moment of cryptoplugin initialization.\n   If succeeded it\
    \ returns the pointer to CryptoPluginInfo structure\n   that describes the module\
    \ and algorithms implemented in the\n   cryptolibrary.  If function call did not\
    \ succeed, function will\n   return NULL or appropriate error code in CryptoPluginInfo\
    \ structure\n   status field. If the initialization is partially succeeded then\
    \ the\n   cryptoplugin either returns CryptoPluginInfo structure transformed so\n\
    \   that it contains only successfully initialized algorithms or returns\n   appropriate\
    \ error code in status field of CryptoAlgInfo structures\n   that describes the\
    \ reason for the failure.\n   Error codes for the function:\n      NULL - fatal\
    \ unsuccessful cryptoplugin initialization. The module\n         is unable even\
    \ to indicate the reason of failure.\n   The pointer to cryptoplugin description\
    \ structure in the case of full\n   or partial success. The status fields in CryptoPluginInfo\
    \ structure\n   and in comprised CryptoAlgInfo structures can be set to the following\n\
    \   values:\n      CRYPTO_OK - cryptoplugin (algorithm) is initialized successfully.\n\
    \      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_NOT_SUPPORTED -\
    \ (only for algorithm) - the algorithm\n         is not supported by the module\
    \ at the moment.\n      CRYPTO_ERR_HARDWARE - error of hardware initialization.\n\
    \      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n      CRYPTO_ERR_NO_MEMORY\
    \ - not enough memory. Contrary to general\n         CRYPTO_ERR_NO_RESOURCES error\
    \ this code assumes that the\n         calling module can release system memory\
    \ (if it is in position\n         to) and try to call the function once again.\n"
- title: 3.1.1. Description of CryptoPluginInfo structure
  contents:
  - "3.1.1. Description of CryptoPluginInfo structure\n   The CryptoPluginInfo structure\
    \ consists of header of fixed size that\n   generally describes cryptoplugin and\
    \ array of CryptoAlgInfo\n   structures following the header. Each structure describes\
    \ particular\n   algorithm implemented in the cryptolibrary (see Appendix A)\n\
    \   Structure fields description:\n      cpi_version -  CPI version (should be\
    \ CRYPTO_VER (1,0)). CPI\n         version determines both functions set and fields\
    \ layout in\n         CryptoPluginInfo/CryptoAlgInfo structures.\n      status\
    \ - returns the error code if cryptoplugin initialization\n         failed (otherwise\
    \ should be CRYPTO_OK)\n      name - text cryptoplugin description (ASCII-7 characters\
    \ only; all\n         unused bytes must be set to 0).\n      version - cryptoplugin\
    \ version (CRYPTO_VER(maj,min)).\n      flags - various flags that characterize\
    \ the cryptoplugin.\n      number_of_algs - number of algorithms the cryptolibrary\
    \ comprises\n         of (i.e. the number of consequent CryptoAlgInfo structures).\n"
- title: 3.1.2. Description of CryptoAlgInfo structure
  contents:
  - "3.1.2. Description of CryptoAlgInfo structure\n   Structure fields description\n\
    \      status - returns the error code if particular algorithm\n         initialization\
    \ failed (otherwise should be CRYPTO_OK).\n      id - algorithm identifier (CRYPTO_A_XXX).\
    \ Values in the range of\n         0..249 are reserved; Values in the range of\
    \ 250..32767 indicate\n         algorithms not enrolled in standard list. It should\
    \ be\n         emphasized that algorithm IDs are independent for each\n      \
    \   algorithm type. But it is considered that pairs of types\n         CRYPTO_TYPE_ENCRYPT\
    \ and CRYPTO_TYPE_DECRYPT, CRYPTO_TYPE_SIGN\n         and CRYPTO_TYPE_VERIFY,\
    \ CRYPTO_TYPE_COMPRESS and\n         CRYPTO_TYPE_UNCOMPRESS are equivalent because\
    \ they define\n         reverse actions of the same nature.\n      group - algorithm\
    \ implementation group (variants algorithm\n         implementations with various\
    \ parameters not covered by\n         CryptoAlgInfo structure). Values in the\
    \ range of 0..32767 are\n         well-known numbers defined in Appendix A; vendors\
    \ may\n         arbitrarily use values in the range of 32768..65535.\n      type\
    \ - algorithm type (CRYPTO_TYPE_XXX). Unambiguously determines\n         algorithm\
    \ application.\n      version - version of algorithm implementation (CRYPTO_VER\n\
    \         (maj,min)).\n      flags - flags that characterize the algorithm and\
    \ its\n         implementation. All bits, that are not defined in Appendix A,\n\
    \         must be zeroed.\n      maxcontexts - maximum cryptographic contexts\
    \ number that are\n         simultaneously supported by the algorithm implementation\
    \ (0 if\n         the number is unlimited or is limited only by environmental\n\
    \         conditions like memory size).\n      name - text algorithm name (ASCII\
    \ characters use only; all unused\n         bytes must be set to 0).\n   The next\
    \ information depends on algorithm type:\n   For encryption algorithms (CRYPTO_TYPE_ENCRYPT\
    \ and\n   CRYPTO_TYPE_DECRYPT):\n      blocklen - data block length in bytes (value\
    \ 1 must be used for\n         stream cipher algorithms).\n      keylen - encrypting\
    \ (or decrypting) key length in bytes.\n      outlen - output data size for conversion\
    \ of one input data block\n         in bytes. Usually it is equal to blocklen.\
    \ When prediction of\n         this value is impossible zero value must be indicated.\n\
    \      milen - size of initialization vector (for block algorithms) or\n     \
    \    message indicator (for stream algorithms) in bytes. For block\n         algorithms\
    \ zero value of the parameter means that the algorithm\n         implements ECB\
    \ encoding. Non-zero milen parameter means that\n         the algorithm implements\
    \ CBC encoding. For stream algorithms\n         zero value of the parameter means\
    \ that the message indicator is\n         not required.\n   For signature algorithms\
    \ (CRYPTO_TYPE_SIGN):\n      blocklen - block size in bytes. The length of input\
    \ signature data\n         will be padded up to this value. When there is no need\
    \ in\n         padding the value of 1 must be set.\n      keylen - private key\
    \ length in bytes.\n      outlen - signature length in bytes. When prediction\
    \ of this value\n         is impossible 0 value must be indicated. If the signature\n\
    \         consists of several values then the total length is indicated.\n   \
    \   milen - non-zero value specifies signature parameter length\n         (random\
    \ number), zero value indicates that the parameter is not\n         required.\n\
    \   For signature verification algorithms (CRYPTO_TYPE_VERIFY):\n      blocklen\
    \ - is not used.\n      keylen - length of public key in bytes.\n      outlen\
    \ - signature length in bytes. When prediction of this value\n         is impossible\
    \ 0 value must be indicated. If the signature\n         consists of several values\
    \ then the total length is indicated.\n      milen - is not used.\n   For data\
    \ compression algorithms (CRYPTO_TYPE_COMPRESS):\n      blocklen - see outlen.\n\
    \      keylen - is not used.\n      outlen - if the algorithm provides the fixed\
    \ compression with\n         known value then it is indicated as blocklen/outlen\
    \ ratio. The\n         values can be arbitrary. If the compression value is not\
    \ known\n         then outlen is set to 0 and blocklen is not used.\n      milen\
    \ - is not used.\n   For data uncompressing algorithms (CRYPTO_TYPE_UNCOMPRESS):\n\
    \      blocklen - see outlen.\n      keylen - is not used.\n      outlen - if\
    \ the algorithm provides the fixed compression with\n         known value then\
    \ it is indicated as blocklen/outlen ratio. The\n         values can be arbitrary.\
    \ It is natural that the ratio will be\n         reverse to the similar value\
    \ for the same algorithm but of\n         CRYPTO_TYPE_COMPRESS type. If the compression\
    \ value is not\n         known then outlen is set to 0 and blocklen is not used.\n\
    \      milen - is not used.\n   For one-way hash function algorithms (CRYPTO_TYPE_HASH):\n\
    \      blocklen - block size in bytes. The length of input data will be\n    \
    \     padded up to this value. When there is no need in padding value\n      \
    \   1 should be used.\n      keylen - is not used.\n      outlen - resulting hash\
    \ value length in bytes.\n      milen - is not used.\n   For random number generation\
    \ algorithms (CRYPTO_TYPE_RANDOM):\n      blocklen - is not used.\n      keylen\
    \ - initial seed length (0 - if not required, for example in\n         a physical\
    \ effects based generators).\n      outlen - resulting random number length in\
    \ bytes (0 - arbitrary)\n      milen - is not used.\n"
- title: 3.2. Cryptoplugin Deinitialization Function
  contents:
  - "3.2. Cryptoplugin Deinitialization Function\n   /* Plugin deinitialization */\n\
    \   CRYPTO_STATUS   CryptoPluginFini(void);\n   The function is called before\
    \ the cryptoplugin operation is to be\n   terminated. Function execution causes\
    \ closing of all open\n   cryptographic contexts, system resources deallocation\
    \ and hardware\n   deinitialization.  The value returned is informational only.\n\
    \   Return codes for the function:\n      CRYPTO_OK - cryptoplugin is deinitialized\
    \ successfully.\n      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_UNCLOSED_HANDLES\
    \ - warning that there were open\n         cryptographic contexts during cryptoplugin\
    \ deinitialization.\n         The warning is informational only. The open contexts\
    \ are\n         destroyed anyway.\n"
- title: 3.3. Cryptographic Context Opening Function
  contents:
  - "3.3. Cryptographic Context Opening Function\n   New algorithm instance (cipher\
    \ state) */\n   CRYPTO_STATUS   CryptoOpen(\n         CRYPTO_HANDLE   *state,\
    \ /* Pointer to cipher state\n                                    handle (filled\
    \ on exit) */\n         long            algnum, /* Algorithm number in\n     \
    \                               CryptoPluginInfo structure */\n         const\
    \ char      *key);  /* key (in plain) */\n   The function creates cryptographic\
    \ context copy inside cryptoplugin\n   and initializes it with the provided key.\
    \ Later the handle of the\n   context is used in calls of other algorithm functions.\n\
    \   Description of parameters:\n      state - pointer to the variable that will\
    \ be set to the handle of\n         the context created if succeeded. NULL parameter\
    \ value should\n         result in the CRYPTO_ERR_BAD_PARAMS code returned by\
    \ the\n         function.\n      algnum - algorithm number in the cryptoplugin.\
    \ It is equal to the\n         number of CryptoAlgInfo structure (that describes\
    \ the\n         algorithm) in CryptoPluginInfo structure. The number begins\n\
    \         with zero value. It should be taken into account that it is not\n  \
    \       an algorithm identifier but its number in the cryptoplugin.\n      key\
    \ - pointer to the key (if it is required) or to the seed (for\n         random\
    \ number generation algorithm).\n"
- title: Notes.
  contents:
  - "Notes.\n   1. Generated cryptographic context is stored inside the cryptoplugin\n\
    \      until it will be destroyed by the CryptoAlgClose function call.\n     \
    \ The maximum number of cryptographic contexts supported by\n      cryptoplugin\
    \ can be indicated in algorithm parameters description.\n      If maximum number\
    \ of cryptographic contexts equals to zero then\n      the cryptographic contexts\
    \ number is either unlimited (for\n      example, for stateless algorithms like\
    \ random number generators\n      and one-way hash functions) or it is limited\
    \ by external factors\n      only (like memory size).\n      Return codes for\
    \ the function:\n      CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n       \
    \  CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n         calling\
    \ module can release system memory (if it is in\n         position to) and try\
    \ to call the function once again.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters\
    \ (invalid algorithm\n         number, zero pointer to the handle or to key (seed)\
    \ if it is\n      required.\n"
- title: 3.4. Cryptographic Context Reopening Function
  contents:
  - '3.4. Cryptographic Context Reopening Function

    '
- title: /* Reinitialize algorithm instance */
  contents:
  - '/* Reinitialize algorithm instance */

    '
- title: CRYPTO_STATUS   CryptoReOpen(
  contents:
  - "CRYPTO_STATUS   CryptoReOpen(\n                CRYPTO_HANDLE   state, /* current\
    \ cipher state handle */\n                const char      *key);  /* key (in plain)\
    \ */\n   The function reinitializes an existing context. This function is used\n\
    \   for key change without new system resources allocation. The function\n   parameters\
    \ are handle of opened earlier context and pointer to a new\n   key.\n   Return\
    \ codes for the function:\n      CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context\
    \ handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n      CRYPTO_ERR_NO_RESOURCES\
    \ error this code assumes that the\n         calling module may release system\
    \ memory and try function\n         call once more.\n      CRYPTO_ERR_BAD_PARAMS\
    \ - invalid parameters (invalid algorithm\n         number, zero pointer to the\
    \ handle or to key (seed) if it is\n         required.\n"
- title: 3.5. Cryptographic Context Closing Function
  contents:
  - '3.5. Cryptographic Context Closing Function

    '
- title: /* Destroy algorithm instance */
  contents:
  - '/* Destroy algorithm instance */

    '
- title: CRYPTO_STATUS   CryptoClose(
  contents:
  - "CRYPTO_STATUS   CryptoClose(\n                CRYPTO_HANDLE   state); /* Handle\
    \ of cipher state */\n   The function provides cryptographic context destruction.\
    \ The\n   cryptographic context handle is its parameter. The value returned is\n\
    \   informational only.\n   Return codes for the function:\n      CRYPTO_OK -\
    \ successful completion.\n      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_BAD_HANDLE\
    \ - invalid cryptographic context handle.\n"
- title: 3.6. Key Verification Function
  contents:
  - "3.6. Key Verification Function\n      /* Check key for possible weakness */\n\
    \      CRYPTO_STATUS   CryptoCheckForWeakKey(\n                    long      \
    \      algnum, /* Algorithm number in\n                                    CryptoPluginInfo\
    \ structure */\n                    const char      *key);  /* Proposed key */\n\
    \   The function verifies key material whether it is weak (from the\n   algorithm's\
    \ point of view). The function is actual for\n   encryption/decryption or signing/verification\
    \ algorithms only.\n   Algorithm number (similar to CryptoAlgOpen) and pointer\
    \ to the key to\n   be verified are the parameters.\n   Return codes for the function:\n\
    \      CRYPTO_O - the key has passed the test.\n      CRYPTO_ERR_WEAK_KEY - the\
    \ key has not passed the test (being weak\n         or possibly weak).\n     \
    \ CRYPTO_ERR_NOT_SUPPORTED - is not supported.\n      CRYPTO_ERR_NO_RESOURCES\
    \ - insufficient internal resources.\n      CRYPTO_ERR_NO_MEMORY - not enough\
    \ memory. Contrary to general\n         CRYPTO_ERR_NO_RESOURCES error this code\
    \ assumes that the\n         calling module can release system memory (if it is\
    \ in\n         position to) and try to call the function once again.\n"
- title: 3.7. Data Transformation Function
  contents:
  - '3.7. Data Transformation Function

    '
- title: /* Perform CryptoTransform (depends on cipher state type) */
  contents:
  - '/* Perform CryptoTransform (depends on cipher state type) */

    '
- title: CRYPTO_STATUS   CryptoTransform(
  contents:
  - "CRYPTO_STATUS   CryptoTransform(\n                CRYPTO_HANDLE   state,  /*\
    \ Cipher state */\n                const char      *inbuff,/* input data */\n\
    \                long            inlen,  /* input data length */\n           \
    \     char            *outbuff,/* output buffer */\n                long     \
    \       *outlen,/* On entry - output buffer\n                                \
    \          length, on exit -  number of\n                                    \
    \      bytes written to outbuff */\n                char            *mi);   /*\
    \ Message indicator  */\n   This is a cryptographic data transformation function.\
    \ Function call\n   results and function parameters are dependent on algorithm\
    \ type. For\n   algorithm types CRYTO_TYPE_ENCRYPT, CRYPTO_TYPE_DECRYPT,\n   CRYPTO_TYPE_SIGN\
    \ and CRYPTO_TYPE_VERIFY (items 3.7.1 - 3.7.4)\n   function call results are history\
    \ independent.\n   Note. Stream encryption algorithms may seem an \"exception\"\
    . However\n   the same cryptoalgorithm handle must hide its history dependence.\
    \ For\n   algorithm types CRYPTO_TYPE_COMPRESS, CRYPTO_TYPE_UNCOMPRESS and\n \
    \  CRYPTO_TYPE_HASH (items 3.7.5 - 3.7.7) function calls are history\n   dependent.\
    \ For the CRYPTO_TYPE_RANDOM algorithm function call may be\n   for different\
    \ implementations either dependent or independent on the\n   history.\n"
- title: '3.7.1. For CRYPTO_TYPE_ENCRYPT Algorithm Type:'
  contents:
  - "3.7.1. For CRYPTO_TYPE_ENCRYPT Algorithm Type:\n      The function encrypts input\
    \ data. Its parameters are intended for:\n      inbuff - pointer to the input\
    \ data. If this parameter is equal to\n         NULL then the function should\
    \ return the\n         CRYPTO_ERR_BAD_PARAMS error code.\n      inlen - input\
    \ data size (in bytes). If the size indicated in\n         algorithm description\
    \ is divisible by blocklen then\n         padding is not carried out. Otherwise\
    \ the algorithm\n         either caries out padding according to the algorithm\n\
    \         standard or returns appropriate error code\n         (CRYPTO_ERR_BAD_PARAMS).\
    \ The zero parameter is allowed so\n         that the function quits at once and\
    \ returns CRYPTO_OK\n         code.\n      outbuff - output data buffer. NULL\
    \ parameter value results in the\n         outlen parameter setting to output\
    \ buffer size required\n         to encrypt the input buffer represented. In this\
    \ case the\n         CRYPTO_ERR_SMALL_BUFFER error should not be returned.\n \
    \     outlen - Output buffer size is an input function parameter while\n     \
    \    the number of bytes written in the output buffer is the\n         output\
    \ parameter. Both the NULL parameter value and the\n         zero value addressed\
    \ result in CRYPTO_ERR_BAD_PARAMS code\n         returned by the function.\n \
    \     mi - message indicator. Its content depends on whether the\n         block\
    \ or stream algorithm is applied. In the block\n         algorithm case it is\
    \ set to the last block encrypted.\n         When the first block is encrypted\
    \ mi parameter specifies\n         initial initialization vector. In the stream\
    \ algorithm\n         case it is set to the offset of the first byte encrypted\n\
    \         in the stream. If the algorithm uses the message\n         indicator\
    \ and the mi parameter value is set to NULL then\n         function should return\
    \ CRYPTO_ERR_BAD_PARAMS. If the\n         algorithm (ECB Mode encrypting as an\
    \ example) does not\n         apply the message indicator then NULL value of mi\
    \ is\n         acceptable while non-NULL value should be ignored.\n   Returned\
    \ values:\n      CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context\
    \ handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n       \
    \  CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n         calling\
    \ module can release system memory (if it is in\n         position to) and try\
    \ to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER - insufficient\
    \ output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: '3.7.2. For CRYPTO_TYPE_DECRYPT Algorithm Type:'
  contents:
  - "3.7.2. For CRYPTO_TYPE_DECRYPT Algorithm Type:\n   The function decrypts the\
    \ input data. Its parameters are intended for:\n      inbuff - pointer to the\
    \ input data. If the parameter is equal to\n         NULL then the function should\
    \ return the\n         CRYPTO_ERR_BAD_PARAMS error code.\n      inlen - input\
    \ data size (in bytes). When the parameter is set to\n         zero the function\
    \ quits at once and CRYPTO_OK code is returned.\n      outbuff - output data buffer.\
    \ NULL parameter value results in the\n         outlen parameter setting to output\
    \ buffer size required\n         to decrypt the input buffer represented. In this\
    \ case the\n         CRYPTO_ERR_SMALL_BUFFER error should not be returned.\n \
    \     outlen - Output buffer size is an input function parameter while\n     \
    \    the number of bytes written in the output buffer is the\n         output\
    \ parameter. Both the NULL parameter value and the\n         zero value addressed\
    \ result in CRYPTO_ERR_BAD_PARAMS code\n         returned by the function.\n \
    \     mi - message indicator. The content depends on whether the\n         block\
    \ or stream algorithm is applied. In the block\n         algorithm case it is\
    \ set to the last block encrypted.\n         When the first block is decrypted\
    \ mi specifies initial\n         initialization vector. In the stream algorithm\
    \ case it is\n         set to the offset of the first byte decrypted in the\n\
    \         stream. If the algorithm uses the message indicator and\n         the\
    \ mi parameter is set to NULL then function should\n         return CRYPTO_ERR_BAD_PARAMS.\
    \ If the algorithm (ECB Mode\n         as an example) does not apply the message\
    \ indicator then\n         NULL value of mi is acceptable while non-NULL value\n\
    \         should be ignored.\n   Returned values:\n      CRYPTO_OK - successful\
    \ completion.\n      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_BAD_HANDLE\
    \ - invalid cryptographic context handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient\
    \ internal resources.\n      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary\
    \ to general\n         CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n\
    \         calling module can release system memory (if it is in\n         position\
    \ to) and try to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER\
    \ - insufficient output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: '3.7.3. For CRYPTO_TYPE_SIGN Type Algorithm:'
  contents:
  - "3.7.3. For CRYPTO_TYPE_SIGN Type Algorithm:\n   The function signs the input\
    \ data. Its parameters are intended for:\n   inbuff - pointer to the input data.\
    \ If the parameter is equal to\n      NULL then the function should return the\n\
    \      CRYPTO_ERR_BAD_PARAMS code error.\n   inlen - input data size (in bytes).\
    \ If the size indicated in\n      algorithm description is divisible by blocklen\
    \ then\n      padding is not carried out. Otherwise the algorithm\n      either\
    \ caries out padding according to the algorithm\n      standard or returns appropriate\
    \ error code\n      (CRYPTO_ERR_BAD_PARAMS). The zero parameter is allowed so\n\
    \      that the function quits at once and returns CRYPTO_OK\n      code.\n  \
    \ outbuff - output data buffer. NULL parameter value results in the\n      outlen\
    \ parameter setting to output buffer size required\n      to sign the input buffer\
    \ represented. In this case the\n      CRYPTO_ERR_SMALL_BUFFER error should not\
    \ be returned.\n   outlen - Output buffer size is an input function parameter\
    \ while\n      the number of bytes written in the output buffer is the\n     \
    \ output parameter. Both the NULL parameter value and the\n      zero value addressed\
    \ result in CRYPTO_ERR_BAD_PARAMS code\n      returned by the function.\n   mi\
    \ - pointer to signature parameter (random number usually) if\n      milen parameter\
    \ in algorithm description is non-zero. In\n      this case zero mi parameter\
    \ indicates that the parameter\n      should be chosen (generated) inside the\
    \ algorithm. If\n      milen parameter in algorithm description is set to zero\n\
    \      then mi parameter is ignored.\n   Returned values:\n      CRYPTO_OK - successful\
    \ completion.\n      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_BAD_HANDLE\
    \ - invalid cryptographic context handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient\
    \ internal resources.\n      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary\
    \ to general\n         CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n\
    \         calling module can release system memory (if it is in\n         position\
    \ to) and try to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER\
    \ - insufficient output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: '3.7.4. For CRYPTO_TYPE_VERIFY Algorithm Type:'
  contents:
  - "3.7.4. For CRYPTO_TYPE_VERIFY Algorithm Type:\n   The function verifies input\
    \ data signature. Its parameters are\n   intended for:\n      inbuff - pointer\
    \ to the input data. If the parameter is equal to\n         NULL then the function\
    \ should return the CRYPTO_ERR_BAD_PARAMS\n         code error.\n      inlen -\
    \ input data size (in bytes). The zero parameter is allowed\n         so that\
    \ the function quits at once and returns CRYPTO_OK code.\n      outbuff -pointer\
    \ to the signature. If the parameter is set to NULL\n         then the function\
    \ returns CRYPTO_ERR_BAD_PARAMS error code. If\n         the signature consists\
    \ of several parts then they are combined\n         to one array.\n      outlen\
    \ - specifies the signature length if the signature length is\n         set to\
    \ zero in algorithm description structure. If non-zero\n         value is specified\
    \ in algorithm description structure then the\n         parameter is ignored.\
    \ If the signature consists of several\n         parts then the maximum part length\
    \ multiplied by the number of\n         parts is specified.\n      mi - is not\
    \ used.\n   Returned values:\n      CRYPTO_OK - successful completion.\n     \
    \ CRYPTO_ERR_INVALID_SIGNATURE - invalid signature.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context\
    \ handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n       \
    \  CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n         calling\
    \ module can release system memory (if it is in\n         position to) and try\
    \ to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER - insufficient\
    \ output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: '3.7.5. For CRYPTO_TYPE_COMPRESS Algorithm Type:'
  contents:
  - "3.7.5. For CRYPTO_TYPE_COMPRESS Algorithm Type:\n   The function compresses the\
    \ input data. Its parameters are intended\n   for:\n      inbuff - pointer to\
    \ the input data.\n      inlen - input data size (in bytes). The zero parameter\
    \ is allowed\n         so that the function quits at once and returns CRYPTO_OK\
    \ code.\n      outbuff - output data buffer. NULL parameter value results in the\n\
    \         outlen parameter setting to output buffer size required to\n       \
    \  compress the input buffer represented. In this case the\n         CRYPTO_ERR_SMALL_BUFFER\
    \ error should not be returned.\n      outlen - Output buffer size is an input\
    \ function parameter while\n         the number of bytes written in the output\
    \ buffer is the output\n         parameter. Both the NULL parameter value and\
    \ the zero value\n         addressed result in CRYPTO_ERR_BAD_PARAMS code returned\
    \ by the\n         function.\n      mi - is not used.\n   Returned values:\n \
    \     CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL - internal\
    \ error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.\n\
    \      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources\n         CRYPTO_ERR_NO_MEMORY\
    \ - not enough memory. Contrary to general\n         CRYPTO_ERR_NO_RESOURCES error\
    \ this code assumes that the\n         calling module can release system memory\
    \ (if it is in\n         position to) and try to call the function once again.\n\
    \      CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.\n      CRYPTO_ERR_BAD_PARAMS\
    \ - invalid parameters.\n"
- title: '3.7.6. For CRYPTO_TYPE_UNCOMPRESS Algorithm Type:'
  contents:
  - "3.7.6. For CRYPTO_TYPE_UNCOMPRESS Algorithm Type:\n      The function decompresses\
    \ the input data. Its parameters are\n      intended for:\n      inbuff - pointer\
    \ to the input data.\n      inlen - input data size (in bytes). The zero parameter\
    \ is allowed\n         so that the function quits at once and returns CRYPTO_OK\
    \ code.\n      outbuff - output data buffer. NULL parameter value results in the\n\
    \         outlen parameter setting to output buffer size required to\n       \
    \  decompress the input buffer represented. In this case the\n         CRYPTO_ERR_SMALL_BUFFER\
    \ error should not be returned.\n      outlen - Output buffer size is an input\
    \ function parameter while\n         the number of bytes written in the output\
    \ buffer is the output\n         parameter. Both the NULL parameter value and\
    \ the zero value\n         addressed result in CRYPTO_ERR_BAD_PARAMS code returned\
    \ by the\n         function.\n      mi - is not used.\n   Returned values:\n \
    \     CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL - internal\
    \ error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context handle.\n\
    \      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n      CRYPTO_ERR_NO_MEMORY\
    \ - not enough memory. Contrary to general\n         CRYPTO_ERR_NO_RESOURCES error\
    \ this code assumes that the\n         calling module can release system memory\
    \ (if it is in\n         position to) and try to call the function once again.\n\
    \      CRYPTO_ERR_SMALL_BUFFER - insufficient output buffer size.\n      CRYPTO_ERR_BAD_PARAMS\
    \ - invalid parameters.\n"
- title: '3.7.7. For CRYPTO_TYPE_HASH Algorithm Type:'
  contents:
  - "3.7.7. For CRYPTO_TYPE_HASH Algorithm Type:\n   The function calculates the hash\
    \ value of the input data. Its\n   parameters are intended for:\n      inbuff\
    \ - pointer to the input data. If the parameter is of NULL\n         value then\
    \ the function calculates cumulative hash value for\n         the data represented\
    \ (taking into account all previous data\n         represented). If total length\
    \ of all the data represented by\n         the moment is divisible by blocklen\
    \ and outbuff is non-NULL\n         then it is returned to outbuff.  Nothing is\
    \ written in outbuff\n         when the length is not divisible by blocklen. NULL\
    \ inbuff\n         indicates the last conversion when the input data is padded\
    \ up\n         to the blocklen size and the result is written to outbuff\n   \
    \      address. The padding procedure is defined for the algorithm.\n      inlen\
    \ - input data size (in bytes). The zero parameter is allowed\n         when the\
    \ function quits at once and returns CRYPTO_OK code.\n      outbuff - output data\
    \ buffer.\n      outlen - Output buffer size is an input function parameter while\n\
    \         the number of bytes written in the output buffer is the output\n   \
    \      parameter. If intermediate conversion value (inbuff is not\n         NULL)\
    \ and total length of data represented by the moment are\n         not divisible\
    \ by blocklen then outlen is set to zero and the\n         hash value is not written\
    \ in outbuff. Both the NULL parameter\n         value and the zero value addressed\
    \ result in\n         CRYPTO_ERR_BAD_PARAMS code returned by the function.\n \
    \     mi - is not used.\n   Returned values:\n      CRYPTO_OK - successful completion.\n\
    \      CRYPTO_ERR_GENERAL - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid\
    \ cryptographic context handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient\
    \ internal resources.\n      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary\
    \ to general\n         CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n\
    \         calling module can release system memory (if it is in position\n   \
    \      to) and try to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER\
    \ - insufficient output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: '3.7.8. For CRYPTO_TYPE_RANDOM Algorithm Type:'
  contents:
  - "3.7.8. For CRYPTO_TYPE_RANDOM Algorithm Type:\n   The function generates a random\
    \ number. Its parameters are intended\n   for:\n      inbuff - pointer to the\
    \ input data used for generation (when one\n         of the pseudorandom algorithms\
    \ is implemented). NULL parameter\n         indicates absence of the input data.\n\
    \      inlen - input data size (in bytes).\n      outbuff - output data\n    \
    \  outlen - Output buffer size is an input function parameter while\n        \
    \ the number of bytes written in the output buffer is the output\n         parameter.\
    \ If zero (i.e. arbitrary) generated number size is\n         set in the algorithm\
    \ description then the outlen value\n         determines the number of random\
    \ bytes required by the calling\n         procedure.\n      mi - is not used.\n\
    \   Returned values:\n      CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context\
    \ handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n       \
    \  CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n         calling\
    \ module can release system memory (if it is in\n         position to) and try\
    \ to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER - insufficient\
    \ output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: 3.8. Cryptographic Context Control Function
  contents:
  - '3.8. Cryptographic Context Control Function

    '
- title: /* Algorithm control */
  contents:
  - '/* Algorithm control */

    '
- title: CRYPTO_STATUS   CryptoControl(
  contents:
  - "CRYPTO_STATUS   CryptoControl(\n                CRYPTO_HANDLE   state,  /* Cipher\
    \ state handle */\n                long            cmd,    /* Control command\
    \ */\n                long            param,  /* Parameter id */\n           \
    \     char            val,    /* Parameter value */\n                long    \
    \        *len);  /* For CRYPTO_GET: on entry -\n                             \
    \              val buffer length, on exit -\n                                \
    \           number of bytes written to\n                                     \
    \      val; for CRYPTO_SET: length\n                                         \
    \  of value to set */\n   The function provides cryptographic context internal\
    \ parameters\n   management. It may be used to check context parameters or to\
    \ change\n   the context state, for example it may return information about\n\
    \   cryptoalgorithm (is given context uses hardware encryption\n   facilities),\
    \ or it may \"scroll\" stream algorithms context if\n   necessary, etc.\n   Description\
    \ of parameters:\n      state - cryptographic context handle.\n      cmd - command\
    \ (CRYPTO_GET or CRYPTO_SET).\n   param - identifier of parameter. Values in the\
    \ range of 0..32767\n      are assigned well-known numbers for all algorithms.\n\
    \      Values in the range of 32768..65535 mean various\n      variables for various\
    \ algorithms (may be arbitrarily used\n      by cryptolibrary developer).\n  \
    \ val - pointer to the data buffer.\n   len - data size (in bytes).\n   Returned\
    \ values:\n      CRYPTO_OK - successful completion.\n      CRYPTO_ERR_GENERAL\
    \ - internal error.\n      CRYPTO_ERR_BAD_HANDLE - invalid cryptographic context\
    \ handle.\n      CRYPTO_ERR_NO_RESOURCES - insufficient internal resources.\n\
    \      CRYPTO_ERR_NO_MEMORY - not enough memory. Contrary to general\n       \
    \  CRYPTO_ERR_NO_RESOURCES error this code assumes that the\n         calling\
    \ module can release system memory (if it is in\n         position to) and try\
    \ to call the function once again.\n      CRYPTO_ERR_SMALL_BUFFER - insufficient\
    \ output buffer size.\n      CRYPTO_ERR_BAD_PARAMS - invalid parameters.\n"
- title: 4. Cryptoplugin Registration Procedure
  contents:
  - "4. Cryptoplugin Registration Procedure\n   Cryptoplugin should be linked together\
    \ with the cryptoplugin wrapper\n   library delivered by the cryptoplugin's client\
    \ developer according to\n   the rules specified by the module-client developer\
    \ for each platform.\n   It should result in a driver (module) of appropriate\
    \ operating system\n   that implements the cryptolibrary functions. The driver\
    \ should be one\n   of the drivers loaded during operating system boot. The procedure\
    \ of\n   cryptoplugin driver installation should be defined, documented, and\n\
    \   automated when necessary, by the cryptoplugin developer. At the\n   beginning\
    \ of operation the driver-client determines cryptoplugin\n   driver availability\
    \ and establishes interconnection with it. Both\n   module-client configuration\
    \ and current security policy determine\n   data conversion algorithms to be chosen.\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   Security issues are addressed throughout this\
    \ memo.\n"
- title: 6. References
  contents:
  - "6. References\n   [Schneier] Bruce Schneier, Applied Cryptography - Protocols,\n\
    \              Algorithms, and Source Code in C (Second Edition), John\n     \
    \         Wiley & Sons, Inc., 1996.\n   [IPsec]    Kent, S. and R. Atkinson, \"\
    Security Architecture for the\n              Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [ISAKMP]   Maughhan, D., Schertler, M. Schneider, M. and J. Turner,\n\
    \              \"Internet Security Association and Key Management Protocol\n \
    \             (ISAKMP)\", RFC 2408, November 1998.\n   [IKE]      Harkins, D.\
    \ and D. Carrel, \"The Internet Key Exchange\n              (IKE)\", RFC 2409,\
    \ November 1998.\n   [TLS]      Dierks, T. and C. Allen, \"The TLS protocol Version\
    \ 1.0\",\n              RFC 2246, January 1999.\n"
- title: 7. Author's Address
  contents:
  - "7. Author's Address\n   Valery Smyslov\n   TWS\n   Centralny prospekt, 11,\n\
    \   Moscow, Russia\n   Phone: +7 (095) 531 4633\n   Fax:   +7 (095) 531 2403\n\
    \   EMail: svan@trustworks.com\n"
- title: Appendix A. The interface specification as a C header file
  contents:
  - 'Appendix A. The interface specification as a C header file

    '
- title: '#ifndef __CRYPTPI_H'
  contents:
  - '#ifndef __CRYPTPI_H

    '
- title: '#define __CRYPTPI_H'
  contents:
  - '#define __CRYPTPI_H

    '
- title: '#define CRYPTO_VER(maj,min)     (((maj & 0xff) << 8) | (min & 0xff))'
  contents:
  - '#define CRYPTO_VER(maj,min)     (((maj & 0xff) << 8) | (min & 0xff))

    '
- title: '#define CRYPTO_MAJ_VER(ver)     ((ver >> 8) & 0xff)'
  contents:
  - '#define CRYPTO_MAJ_VER(ver)     ((ver >> 8) & 0xff)

    '
- title: '#define CRYPTO_MIN_VER(ver)     (ver & 0xff)'
  contents:
  - '#define CRYPTO_MIN_VER(ver)     (ver & 0xff)

    '
- title: '#define CRYPTO_PLUGIN_NAME_LEN  64      /* Must be multiple of 4 to */'
  contents:
  - '#define CRYPTO_PLUGIN_NAME_LEN  64      /* Must be multiple of 4 to */

    '
- title: '#define CRYPTO_ALG_NAME_LEN     32      /* avoid alignment problems */'
  contents:
  - '#define CRYPTO_ALG_NAME_LEN     32      /* avoid alignment problems */

    '
- title: '#ifndef CRYPTO_HANDLE'
  contents:
  - '#ifndef CRYPTO_HANDLE

    '
- title: '#define CRYPTO_HANDLE           void*   /* cipher state handle */'
  contents:
  - '#define CRYPTO_HANDLE           void*   /* cipher state handle */

    '
- title: '#endif'
  contents:
  - '#endif

    '
- title: typedef enum tag_CRYPTO_STATUS {
  contents:
  - "typedef enum tag_CRYPTO_STATUS {\n        CRYPTO_OK = 1,                  /*\
    \ success */\n        CRYPTO_ERR_GENERAL,             /* undefined (internal)\
    \ error */\n        CRYPTO_ERR_NOT_SUPPORTED,       /* unsupported */\n      \
    \  CRYPTO_ERR_BAD_HANDLE,          /* invalid handle */\n        CRYPTO_ERR_SMALL_BUFFER,\
    \        /* insufficient output buffer\n                                     \
    \      size */\n        CRYPTO_ERR_WEAK_KEY,            /* key is considered to\
    \ be weak\n                                           (semiweak, pseudoweak) */\n\
    \        CRYPTO_ERR_NO_RESOURCES,        /* insufficient resources to\n      \
    \                                     perform operation */\n        CRYPTO_ERR_NO_MEMORY,\
    \           /* insufficient memory to\n                                      \
    \     perform operation */\n        CRYPTO_ERR_BAD_PARAMS,          /* invalid\
    \ parameters */\n        CRYPTO_ERR_HARDWARE,            /* hardware error */\n\
    \        CRYPTO_ERR_INVALID_SIGNATURE,   /* invalid signature */\n        CRYPTO_ERR_UNCLOSED_HANDLES\
    \     /* unclosed handles exist while\n                                      \
    \     plugin deinitializises */\n"
- title: '} CRYPTO_STATUS;'
  contents:
  - '} CRYPTO_STATUS;

    '
- title: /* CryptoControl commands */
  contents:
  - '/* CryptoControl commands */

    '
- title: '#define CRYPTO_GET                      1       /* get parameter */'
  contents:
  - '#define CRYPTO_GET                      1       /* get parameter */

    '
- title: '#define CRYPTO_SET                      2       /* set parameter */'
  contents:
  - '#define CRYPTO_SET                      2       /* set parameter */

    '
- title: /* Currently defined algorithm types */
  contents:
  - '/* Currently defined algorithm types */

    '
- title: '#define CRYPTO_TYPE_ENCRYPT             1'
  contents:
  - '#define CRYPTO_TYPE_ENCRYPT             1

    '
- title: '#define CRYPTO_TYPE_DECRYPT             2'
  contents:
  - '#define CRYPTO_TYPE_DECRYPT             2

    '
- title: '#define CRYPTO_TYPE_SIGN                3'
  contents:
  - '#define CRYPTO_TYPE_SIGN                3

    '
- title: '#define CRYPTO_TYPE_VERIFY              4'
  contents:
  - '#define CRYPTO_TYPE_VERIFY              4

    '
- title: '#define CRYPTO_TYPE_COMPRESS            5'
  contents:
  - '#define CRYPTO_TYPE_COMPRESS            5

    '
- title: '#define CRYPTO_TYPE_UNCOMPRESS          6'
  contents:
  - '#define CRYPTO_TYPE_UNCOMPRESS          6

    '
- title: '#define CRYPTO_TYPE_HASH                7'
  contents:
  - '#define CRYPTO_TYPE_HASH                7

    '
- title: '#define CRYPTO_TYPE_RANDOM              8'
  contents:
  - '#define CRYPTO_TYPE_RANDOM              8

    '
- title: /* Currently defined algorithm IDs (for types
  contents:
  - "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_ENCRYPT & CRYPTO_TYPE_DECRYPT)\
    \ */\n"
- title: '#define CRYPTO_AE_DUMMY                 1       /* no encryption */'
  contents:
  - '#define CRYPTO_AE_DUMMY                 1       /* no encryption */

    '
- title: '#define CRYPTO_AE_DES                   2       /* DES-CBC */'
  contents:
  - '#define CRYPTO_AE_DES                   2       /* DES-CBC */

    '
- title: '#define CRYPTO_AE_3DES_EDE              3       /* Triple DES-EDE-CBC */'
  contents:
  - '#define CRYPTO_AE_3DES_EDE              3       /* Triple DES-EDE-CBC */

    '
- title: '#define CRYPTO_AE_IDEA                  4       /* IDEA-CBC */'
  contents:
  - '#define CRYPTO_AE_IDEA                  4       /* IDEA-CBC */

    '
- title: '#define CRYPTO_AE_RC2                   5       /* RC2 */'
  contents:
  - '#define CRYPTO_AE_RC2                   5       /* RC2 */

    '
- title: '#define CRYPTO_AE_RC4                   6       /* RC4 */'
  contents:
  - '#define CRYPTO_AE_RC4                   6       /* RC4 */

    '
- title: '#define CRYPTO_AE_RC5                   7       /* RC5 */'
  contents:
  - '#define CRYPTO_AE_RC5                   7       /* RC5 */

    '
- title: '#define CRYPTO_AE_SAFER                 8       /* SAFER */'
  contents:
  - '#define CRYPTO_AE_SAFER                 8       /* SAFER */

    '
- title: '#define CRYPTO_AE_CAST                  9       /* CAST */'
  contents:
  - '#define CRYPTO_AE_CAST                  9       /* CAST */

    '
- title: '#define CRYPTO_AE_BLOWFISH              10      /* Blowfish */'
  contents:
  - '#define CRYPTO_AE_BLOWFISH              10      /* Blowfish */

    '
- title: '#define CRYPTO_AE_RSA                   11      /* RSA */'
  contents:
  - '#define CRYPTO_AE_RSA                   11      /* RSA */

    '
- title: '#define CRYPTO_AE_GOST                  12      /* GOST */'
  contents:
  - '#define CRYPTO_AE_GOST                  12      /* GOST */

    '
- title: /* Currently defined algorithm IDs (for types
  contents:
  - "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_SIGN & CRYPTO_TYPE_VERIFY)\
    \ */\n"
- title: '#define CRYPTO_AS_RSA                   2       /* RSA */'
  contents:
  - '#define CRYPTO_AS_RSA                   2       /* RSA */

    '
- title: '#define CRYPTO_AS_DSA                   3       /* DSA */'
  contents:
  - '#define CRYPTO_AS_DSA                   3       /* DSA */

    '
- title: '#define CRYPTO_AS_GOST                  4       /* GOST */'
  contents:
  - '#define CRYPTO_AS_GOST                  4       /* GOST */

    '
- title: /* Currently defined algorithm IDs (for types
  contents:
  - "/* Currently defined algorithm IDs (for types\n   CRYPTO_TYPE_COMPRESS & CRYPTO_TYPE_UNCOMPRESS)\
    \ */\n"
- title: '#define CRYPTO_AC_DUMMY                 1       /* no compression */'
  contents:
  - '#define CRYPTO_AC_DUMMY                 1       /* no compression */

    '
- title: '#define CRYPTO_AC_DEFLATE               2       /* Deflate */'
  contents:
  - '#define CRYPTO_AC_DEFLATE               2       /* Deflate */

    '
- title: '#define CRYPTO_AC_LZS                   3       /* LZS */'
  contents:
  - '#define CRYPTO_AC_LZS                   3       /* LZS */

    '
- title: /* Currently defined algorithm IDs (for type CRYPTO_TYPE_HASH) */
  contents:
  - '/* Currently defined algorithm IDs (for type CRYPTO_TYPE_HASH) */

    '
- title: '#define CRYPTO_AH_MD5                   1       /* MD5 */'
  contents:
  - '#define CRYPTO_AH_MD5                   1       /* MD5 */

    '
- title: '#define CRYPTO_AH_SHA                   2       /* SHA-1 */'
  contents:
  - '#define CRYPTO_AH_SHA                   2       /* SHA-1 */

    '
- title: '#define CRYPTO_AH_GOST                  3       /* GOST */'
  contents:
  - '#define CRYPTO_AH_GOST                  3       /* GOST */

    '
- title: /* Currently defined algorithm IDs (for type CRYPTO_TYPE_RANDOM) */
  contents:
  - '/* Currently defined algorithm IDs (for type CRYPTO_TYPE_RANDOM) */

    '
- title: '#define         CRYPTO_AR_UNKNOWN       1'
  contents:
  - '#define         CRYPTO_AR_UNKNOWN       1

    '
- title: /* Currently defined plugin flags */
  contents:
  - '/* Currently defined plugin flags */

    '
- title: '#define CRYPTO_PLUGIN_HARDWARE          1       /* plugin uses hdw */'
  contents:
  - '#define CRYPTO_PLUGIN_HARDWARE          1       /* plugin uses hdw */

    '
- title: /* TBD more */
  contents:
  - '/* TBD more */

    '
- title: /* Currently defined algorithm flags */
  contents:
  - '/* Currently defined algorithm flags */

    '
- title: '#define CRYPTO_ALG_HARDWARE             1       /* algorithm implemented'
  contents:
  - "#define CRYPTO_ALG_HARDWARE             1       /* algorithm implemented\n  \
    \                                                 in hardware */\n"
- title: '#define CRYPTO_ALG_MULTITHREADED        2       /* implementation allows'
  contents:
  - "#define CRYPTO_ALG_MULTITHREADED        2       /* implementation allows\n  \
    \                                                 multithreading */\n"
- title: /* TBD more */
  contents:
  - '/* TBD more */

    '
- title: /* Currently defined parameters identifiers for CryptoControl */
  contents:
  - '/* Currently defined parameters identifiers for CryptoControl */

    '
- title: '#define CRYPTO_PARAM_KEY                1       /* Only for CRYPTO_GET -'
  contents:
  - "#define CRYPTO_PARAM_KEY                1       /* Only for CRYPTO_GET -\n  \
    \                                                 get current key */\n"
- title: /* TBD more */
  contents:
  - '/* TBD more */

    '
- title: typedef struct  tag_CryptoAlgInfo {
  contents:
  - "typedef struct  tag_CryptoAlgInfo {\n        long    status;                \
    \ /* Algorithm status */\n        long    type;                   /* algorithm\
    \ type (One of\n                                           CRYPTO_TYPE_XXX) */\n\
    \        long    id;                     /* algorithm ID */\n        long    group;\
    \                  /* algorithm group */\n        long    version;           \
    \     /* algorithm version\n                                           (CRYPTO_VER)\
    \ */\n        long    flags;                  /* algorithm flags\n           \
    \                                (CRYPTO_ALG_XXX) */\n        long    maxcontexts;\
    \            /* max number of cipher states\n                                \
    \           supported (0 - any) */\n        char    name[CRYPTO_ALG_NAME_LEN];\
    \      /* algorithm name */\n                          /* CRYPT   SIGN    COMPRESS\
    \ HASH    RANDOM  */\n                          /* DECRYPT VERIFY            \
    \               */\n        long    blocklen; /* blklen (blklen)  inlen   blklen\
    \    -     */\n        long    keylen;   /* keylen  keylen     -       -     seedlen\
    \ */\n        long    outlen;   /* outlen (signlen) outlen  hashlen randlen */\n\
    \        long    milen;    /* milen   (param)    -       -       -     */\n"
- title: '} CryptoAlgInfo;'
  contents:
  - '} CryptoAlgInfo;

    '
- title: typedef struct  tag_CryptoPluginInfo {
  contents:
  - "typedef struct  tag_CryptoPluginInfo {\n        long    cpi_version;        \
    \    /* Crypto PI version (currently\n                                       \
    \    CRYPTO_VER(1,0)) */\n        long    status;                 /* Plugin status\
    \ */\n        char    name[CRYPTO_PLUGIN_NAME_LEN];   /* plugin text\n       \
    \                                            description */\n        long    version;\
    \                /* plugin version\n                                         \
    \  (CRYPTO_VER) */\n        long    flags;                  /* plugin flags\n\
    \                                           (CRYPTO_PLUGIN_XXX) */\n        long\
    \    number_of_algs;         /* number of AlgInfo structures\n               \
    \                            followed (min 1) */\n        CryptoAlgInfo   algs[1];\
    \        /* array of AlgInfo structures\n                                    \
    \       (min 1) */\n"
- title: '} CryptoPluginInfo;'
  contents:
  - '} CryptoPluginInfo;

    '
- title: '#ifdef __cplusplus'
  contents:
  - '#ifdef __cplusplus

    '
- title: extern "C" {
  contents:
  - 'extern "C" {

    '
- title: '#endif'
  contents:
  - '#endif

    '
- title: /* CryptoPlugin initialization. Returns pointer to CryptoPluginInfo
  contents:
  - '/* CryptoPlugin initialization. Returns pointer to CryptoPluginInfo

    '
- title: structure on success or NULL on fatal error. */
  contents:
  - 'structure on success or NULL on fatal error. */

    '
- title: CryptoPluginInfo *CryptoPluginInit(
  contents:
  - "CryptoPluginInfo *CryptoPluginInit(\n                void            *param);/*\
    \ Ptr to OS parameters\n                                           (platform-specific)\
    \ */\n"
- title: /* Plugin deinitialization */
  contents:
  - '/* Plugin deinitialization */

    '
- title: CRYPTO_STATUS   CryptoPluginFini(void);
  contents:
  - 'CRYPTO_STATUS   CryptoPluginFini(void);

    '
- title: /* Get new algorithm instance (cipher state) */
  contents:
  - '/* Get new algorithm instance (cipher state) */

    '
- title: CRYPTO_STATUS   CryptoOpen(
  contents:
  - "CRYPTO_STATUS   CryptoOpen(\n                CRYPTO_HANDLE   *state, /* Pointer\
    \ to cipher state\n                                            handle (filled\
    \ on exit) */\n                 long            algnum, /* Algorithm number in\n\
    \                                            CryptoPluginInfo structure */\n \
    \                const char      *key);  /* key (in plain) */\n /* Reinitialize\
    \ algorithm instance */\n CRYPTO_STATUS   CryptoReOpen(\n                 CRYPTO_HANDLE\
    \   state, /* current cipher state handle */\n                 const char    \
    \  *key);  /* key (in plain) */\n /* Destroy algorithm instance */\n CRYPTO_STATUS\
    \   CryptoClose(\n                 CRYPTO_HANDLE   state); /* Handle of cipher\
    \ state */\n /* Check key for possible weakness */\n CRYPTO_STATUS   CryptoCheckForWeakKey(\n\
    \                 long            algnum, /* Algorithm number in\n           \
    \                                 CryptoPluginInfo structure */\n            \
    \     const char      *key);  /* Proposed key */\n /* Perform CryptoTransform\
    \ (depends on cipher state type) */\n CRYPTO_STATUS   CryptoTransform(\n     \
    \            CRYPTO_HANDLE   state,  /* Cipher state handle */\n             \
    \    const char      *inbuff,/* input data */\n                 long         \
    \   inlen,  /* input data length */\n                 char            *outbuff,/*\
    \ output buffer */\n                 long            *outlen,/* On entry - output\
    \ buffer\n                                           length, on exit -  number\
    \ of\n                                           bytes written to outbuff */\n\
    \                 char            *mi);   /* Message indicator  */\n /* Algorithm\
    \ control */\n CRYPTO_STATUS   CryptoControl(\n                 CRYPTO_HANDLE\
    \   state,  /* Cipher state handle */\n                 long            cmd, \
    \   /* Control command */\n                 long            param,  /* Parameter\
    \ id */\n                 char            val,    /* Parameter value */\n    \
    \             long            *len);  /* For CRYPTO_GET: on entry -\n        \
    \                                    val buffer length, on exit -\n          \
    \                                  number of bytes written to\n              \
    \                              val; for CRYPTO_SET: length\n                 \
    \                           of value to set */\n #ifdef __cplusplus\n }\n #endif\n\
    \ #endif  /* __CRYPTPI_H */\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
