- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                        S. Barbato
  contents:
  - "Independent Submission                                        S. Barbato\n  \
    \          SCS: KoanLogic's Secure Cookie Sessions for HTTP\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a generic URI and HTTP-header-friendly envelope\
    \ for\n   carrying symmetrically encrypted, authenticated, and origin-\n   timestamped\
    \ tokens.  It also describes one possible usage of such\n   tokens via a simple\
    \ protocol based on HTTP cookies.\n   Secure Cookie Session (SCS) use cases cover\
    \ a wide spectrum of\n   applications, ranging from distribution of authorized\
    \ content via\n   HTTP (e.g., with out-of-band signed URIs) to securing browser\n\
    \   sessions with diskless embedded devices (e.g., Small Office, Home\n   Office\
    \ (SOHO) routers) or web servers with high availability or load-\n   balancing\
    \ requirements that may want to delegate the handling of the\n   application state\
    \ to clients instead of using shared storage or\n   forced peering.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6896.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Requirements Language ...........................................4\n  \
    \ 3. SCS Protocol ....................................................5\n    \
    \  3.1. SCS Cookie Description .....................................5\n      \
    \     3.1.1. ATIME ...............................................6\n        \
    \   3.1.2. DATA ................................................6\n          \
    \ 3.1.3. TID .................................................7\n           3.1.4.\
    \ IV ..................................................7\n           3.1.5. AUTHTAG\
    \ .............................................7\n      3.2. Crypto Transform\
    \ ...........................................8\n           3.2.1. Choice and Role\
    \ of the Framing Symbol ...............8\n           3.2.2. Cipher Set ..........................................9\n\
    \           3.2.3. Compression .........................................9\n  \
    \         3.2.4. Cookie Encoding .....................................9\n    \
    \       3.2.5. Outbound Transform ..................................9\n      \
    \     3.2.6. Inbound Transform ..................................10\n      3.3.\
    \ PDU Exchange ..............................................12\n           3.3.1.\
    \ Cookie Attributes ..................................12\n                  3.3.1.1.\
    \ Expires ...................................12\n                  3.3.1.2. Max-Age\
    \ ...................................12\n                  3.3.1.3. Domain ....................................13\n\
    \                  3.3.1.4. Secure ....................................13\n  \
    \                3.3.1.5. HttpOnly ..................................13\n   4.\
    \ Key Management and Session State ...............................13\n   5. Cookie\
    \ Size Considerations .....................................15\n   6. Acknowledgements\
    \ ...............................................15\n   7. Security Considerations\
    \ ........................................15\n      7.1. Security of the Cryptographic\
    \ Protocol ....................15\n      7.2. Impact of the SCS Cookie Model ............................16\n\
    \           7.2.1. Old Cookie Replay ..................................16\n  \
    \         7.2.2. Cookie Deletion ....................................17\n    \
    \       7.2.3. Cookie Sharing or Theft ............................18\n      \
    \     7.2.4. Session Fixation ...................................18\n      7.3.\
    \ Advantages of SCS over Server-Side Sessions ...............19\n   8. References\
    \ .....................................................20\n      8.1. Normative\
    \ References ......................................20\n      8.2. Informative\
    \ References ....................................20\n   Appendix A. Examples ..............................................22\n\
    \      A.1. No Compression ............................................22\n  \
    \    A.2. Use Compression ...........................................22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines a generic URI and HTTP-header-friendly\
    \ envelope for\n   carrying symmetrically encrypted, authenticated, and origin-\n\
    \   timestamped tokens.\n   It is generic in that it does not force any specific\
    \ format upon the\n   authenticated information, which makes SCS tokens flexible,\
    \ easy, and\n   secure to use in many different scenarios.\n   It is URI and HTTP\
    \ header friendly, as it has been explicitly\n   designed to be compatible with\
    \ both the ABNF \"token\" syntax [RFC2616]\n   (the one used for, e.g., Set-Cookie\
    \ and Cookie headers) and the path\n   or query syntax of HTTP URIs.\n   This\
    \ memo also describes one possible usage of such tokens via a\n   simple protocol\
    \ based on HTTP cookies that allows the establishment\n   of \"client mode\" sessions.\
    \  This is not their sole possible use.\n   While no other operational patterns\
    \ are outlined here, it is expected\n   that SCS tokens may be easily employed\
    \ as a building block for other\n   types of HTTP-based applications that need\
    \ to carry in-band secured\n   information.\n   When SCS tokens are used to implement\
    \ client-mode cookie sessions,\n   the SCS implementer must fully understand the\
    \ security implications\n   entailed by the act of delegating the whole application\
    \ state to the\n   client (browser).  In this regard, some hopefully useful security\n\
    \   considerations have been collected in Section 7.2.  However, please\n   note\
    \ that they may not cover all possible scenarios; therefore, they\n   must be\
    \ weighed carefully against the specific application threat\n   model.\n   An\
    \ SCS server may be implemented within a web application by means of\n   a user\
    \ library that exposes the core SCS functionality and leaves\n   explicit control\
    \ over SCS tokens to the programmer, or transparently,\n   by hiding a \"diskless\
    \ session\" facility behind a generic session API\n   abstraction, for example.\
    \  SCS implementers are free to choose the\n   model that best suits their needs.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  SCS Protocol
  contents:
  - "3.  SCS Protocol\n   The SCS protocol defines:\n   o  the SCS cookie structure\
    \ and encoding (Section 3.1);\n   o  the cryptographic transformations involved\
    \ in SCS cookie creation\n      and verification (Section 3.2);\n   o  the HTTP-based\
    \ PDU exchange that uses the Set-Cookie and Cookie\n      HTTP headers (Section\
    \ 3.3);\n   o  the underlying key management model (Section 4).\n   Note that\
    \ the PDU is transmitted to the client as an opaque data\n   block; hence, no\
    \ interpretation nor validation is necessary.  The\n   single requirement for\
    \ client-side support of SCS is cookie\n   activation on the user agent.  The\
    \ origin server is the sole actor\n   involved in the PDU manipulation process,\
    \ which greatly simplifies\n   the crypto operations -- especially key management,\
    \ which is usually\n   a pesky task.\n   In the following sections, we assume\
    \ S to be one or more\n   interchangeable HTTP server entities (e.g., a server\
    \ pool in a load-\n   balanced or high-availability environment) and C to be the\
    \ client\n   with a cookie-enabled browser or any user agent with equivalent\n\
    \   capabilities.\n"
- title: 3.1.  SCS Cookie Description
  contents:
  - "3.1.  SCS Cookie Description\n   S and C exchange a cookie (Section 3.3) whose\
    \ cookie value consists\n   of a sequence of adjacent non-empty values, each of\
    \ which is the 'URL\n   and Filename safe' Base64 encoding [RFC4648] of a specific\
    \ SCS field.\n   (Hereafter, the encoded and raw versions of each SCS field are\n\
    \   distinguished based on the presence, or lack thereof, of the 'e'\n   prefix\
    \ in their name, e.g., eATIME and ATIME.)\n   Each SCS field is separated by its\
    \ left and/or right sibling by means\n   of the %x7c ASCII character (i.e., '|'),\
    \ as follows:\n   scs-cookie        = scs-cookie-name \"=\" scs-cookie-value\n\
    \   scs-cookie-name   = token\n   scs-cookie-value  = eDATA \"|\" eATIME \"|\"\
    \ eTID \"|\" eIV \"|\" eAUTHTAG\n   eDATA             = 1*base64url-character\n\
    \   eATIME            = 1*base64url-character\n   eTID              = 1*base64url-character\n\
    \   eIV               = 1*base64url-character\n   eAUTHTAG          = 1*base64url-character\n\
    \                                 Figure 1\n   Confidentiality is limited to the\
    \ application-state information\n   (i.e., the DATA field), while integrity and\
    \ authentication apply to\n   the entire cookie value.\n   The following subsections\
    \ describe the syntax and semantics of each\n   SCS cookie field.\n"
- title: 3.1.1.  ATIME
  contents:
  - "3.1.1.  ATIME\n   Absolute timestamp relating to the last read or write operation\n\
    \   performed on session DATA, encoded as a HEX string holding the number\n  \
    \ of seconds since the UNIX epoch (i.e., since 00:00:00, Jan 1 1970).\n   This\
    \ value is updated with each client contact and is used to\n   identify expired\
    \ sessions.  If the delta between the received ATIME\n   value and the current\
    \ time on S is larger than a predefined\n   \"session_max_age\" (which is chosen\
    \ by S as an application-level\n   parameter), a session is considered to be no\
    \ longer valid, and is\n   therefore rejected.\n   Such an expiration error may\
    \ be used to force user logout from an\n   SCS-cookie-based session, or hooked\
    \ in the web application logic to\n   display an HTML form requiring revalidation\
    \ of user credentials.\n"
- title: 3.1.2.  DATA
  contents:
  - "3.1.2.  DATA\n   Block of encrypted and optionally compressed data, possibly\n\
    \   containing the current session state.  Note that no restriction is\n   imposed\
    \ on the cleartext structure: the protocol is completely\n   agnostic as to inner\
    \ data layout.\n   Generally speaking, the plaintext is the \"normal\" cookie\
    \ that would\n   have been exchanged by S and C if SCS had not been used.\n"
- title: 3.1.3.  TID
  contents:
  - "3.1.3.  TID\n   This identifier is equivalent to a Security Parameter Index (SPI)\
    \ in\n   a Data Security SA [RFC3740]) and consists of an ASCII string that\n\
    \   uniquely identifies the transform set (keys and algorithms) used to\n   generate\
    \ this SCS cookie.\n   SCS assumes that a key-agreement/distribution mechanism\
    \ exists for\n   environments in which S consists of multiple servers that provide\
    \ a\n   unique external identifier for each transform set shared amongst pool\n\
    \   members.\n   Such a mechanism may safely downgrade to a periodic key refresh,\
    \ if\n   there is only one server in the pool and the key is generated in\n  \
    \ place -- i.e., it is not handled by an external source.\n   However, when many\
    \ servers act concurrently upon the same pool, a\n   more sophisticated protocol,\
    \ whose specification is out of the scope\n   of the present document, must be\
    \ devised (ideally, one that is able\n   to handle key agreement for dynamic peer\
    \ groups in a secure and\n   efficient way, e.g., [CLIQUES] or [Steiner]).\n"
- title: 3.1.4.  IV
  contents:
  - "3.1.4.  IV\n   Initialization Vector used for the encryption algorithm (see\n\
    \   Section 3.2).\n   In order to avoid providing correlation information to a\
    \ possible\n   attacker with access to a sample of SCS cookies created using the\n\
    \   same TID, the IV MUST be created randomly for each SCS cookie.\n"
- title: 3.1.5.  AUTHTAG
  contents:
  - "3.1.5.  AUTHTAG\n   Authentication tag that is based on the plain string concatenation\
    \ of\n   the base64url-encoded DATA, ATIME, TID, and IV fields and is framed\n\
    \   by the \"|\" separator (see also the definition of the Box() function\n  \
    \ in Section 3.2):\n   AUTHTAG = HMAC(base64url(DATA)  \"|\"\n               \
    \   base64url(ATIME) \"|\"\n                  base64url(TID)   \"|\"\n       \
    \           base64url(IV))\n   Note that, from a cryptographic point of view,\
    \ the \"|\" character\n   provides explicit authentication of the length of each\
    \ supplied\n   field, which results in a robust countermeasure against splicing\n\
    \   attacks.\n"
- title: 3.2.  Crypto Transform
  contents:
  - "3.2.  Crypto Transform\n   SCS could potentially use any combination of primitives\
    \ capable of\n   performing authenticated encryption.  In practice, an\n   encrypt-then-MAC\
    \ approach [Kohno] with encryption utilizing the\n   Cipher Block Chaining (CBC)\
    \ mode and Hashed Message Authentication\n   Code (HMAC) [RFC2104] authentication\
    \ was chosen.\n   The two algorithms MUST be associated with two independent keys.\n\
    \   The following conventions will be used in the algorithm description\n   (Sections\
    \ 3.2.5 and 3.2.6):\n   o  Enc/Dec(): block encryption/decryption functions (Section\
    \ 3.2.2);\n   o  HMAC(): authentication function (Section 3.2.2);\n   o  Comp/Uncomp():\
    \ compression/decompression functions\n      (Section 3.2.3);\n   o  e/d(): cookie-value\
    \ encoding/decoding functions (Section 3.2.4);\n   o  RAND(): random number generator\
    \ [RFC4086];\n   o  Box(): string boxing function.  It takes an arbitrary number\
    \ of\n      base64url-encoded strings and returns the string obtained by\n   \
    \   concatenating each input in the exact order in which they are\n      listed,\
    \ separated by the \"|\" char.  For example:\n         Box(\"akxI\", \"MTM\",\
    \ \"Hadvo\") = \"akxI|MTM|Hadvo\".\n"
- title: 3.2.1.  Choice and Role of the Framing Symbol
  contents:
  - "3.2.1.  Choice and Role of the Framing Symbol\n   Note that the adoption of \"\
    |\" as the framing symbol in the Box()\n   function is arbitrary: any char allowed\
    \ by the cookie-value ABNF in\n   [RFC6265] is safe to be used as long it has\
    \ empty intersection with\n   the base64url alphabet.\n   It is also worth noting\
    \ that the role of the framing symbol, which\n   provides an implicit length indicator\
    \ for each of the atoms, is key\n   to the accuracy and security of SCS.\n   This\
    \ is especially relevant when the authentication tag is computed\n   (see Section\
    \ 3.1.5).  More specifically, the explicit inclusion of\n   the framing symbol\
    \ within the HMAC input seals the integrity of the\n   blob as a whole together\
    \ with each of its composing atoms in their\n   exact position.\n   This feature\
    \ makes the protocol robust against attacks aimed at\n   disrupting the security\
    \ of SCS PDUs by freely moving boundaries\n   between adjacent atoms.\n"
- title: 3.2.2.  Cipher Set
  contents:
  - "3.2.2.  Cipher Set\n   Implementers MUST support at least the following algorithms:\n\
    \   o  AES-CBC-128 for encryption [NIST-AES];\n   o  HMAC-SHA1 with a 128-bit\
    \ key for authenticity and integrity,\n   which appear to be sufficiently secure\
    \ in a broad range of use cases\n   ([Bellare] [RFC6194]), are widely available,\
    \ and can be implemented\n   in a few kilobytes of memory, providing an extremely\
    \ valuable feature\n   for constrained devices.\n   One should consider using\
    \ larger cryptographic key lengths (192- or\n   256-bit) according to the actual\
    \ security and overall system\n   performance requirements.\n"
- title: 3.2.3.  Compression
  contents:
  - "3.2.3.  Compression\n   Compression, which may be useful or even necessary when\
    \ handling\n   large quantities of data, is not compulsory (in such a case, Comp/\n\
    \   Uncomp is replaced by an identity matrix).  If this function is\n   enabled,\
    \ the DEFLATE [RFC1951] format MUST be supported.\n   Some advice to SCS users:\
    \ compression should not be enabled when\n   handling relatively short and entropic\
    \ state, such as pseudorandom\n   session identifiers.  Instead, large and quite\
    \ regular state blobs\n   could get a significant boost when compressed.\n"
- title: 3.2.4.  Cookie Encoding
  contents:
  - "3.2.4.  Cookie Encoding\n   SCS cookie values MUST be encoded using the alphabet\
    \ that is URL and\n   filename safe (i.e., base64url) defined in Section 5 of\
    \ Base64\n   [RFC4648].  This encoding is very widespread, falls smoothly into\
    \ the\n   encoding rules defined in Section 4.1.1 of [RFC6265], and can be\n \
    \  safely used to supply SCS-based authorization tokens within a URI\n   (e.g.,\
    \ in a query string or straight into a path segment).\n"
- title: 3.2.5.  Outbound Transform
  contents:
  - "3.2.5.  Outbound Transform\n   The output data transformation, as seen by the\
    \ server (the only actor\n   that explicitly manipulates SCS cookies), is illustrated\
    \ by the\n   pseudocode in Figure 2.\n         1.  IV := RAND()\n         2. \
    \ ATIME := NOW\n         3.  DATA := Enc(Comp(plain-text-cookie-value), IV)\n\
    \         4.  AUTHTAG := HMAC(Box(e(DATA), e(ATIME), e(TID), e(IV)))\n       \
    \                          Figure 2\n   A new Initialization Vector is randomly\
    \ picked (step 1).  As\n   previously mentioned (Section 3.1.4), this step is\
    \ necessary to avoid\n   providing correlation information to an attacker.\n \
    \  A new ATIME value is taken as the current timestamp according to the\n   server\
    \ clock (step 2).\n   Since the only user of the ATIME field is the server, it\
    \ is\n   unnecessary for it to be synchronized with the client -- though it\n\
    \   needs to use a fairly stable clock.  However, if multiple servers are\n  \
    \ active in a load-balancing configuration, clocks SHOULD be\n   synchronized\
    \ to avoid errors in the calculation of session expiry.\n   The plaintext cookie\
    \ value is then compressed (if needed) and\n   encrypted by using the key-set\
    \ identified by TID (step 3).\n   If the length of (compressed) state is not a\
    \ multiple of the block\n   size, its value MUST be filled with as many padding\
    \ bytes of equal\n   value as the pad length -- as defined by the scheme given\
    \ in Section\n   6.3 of [RFC5652].\n   Then, the authentication tag, which encompasses\
    \ each SCS field (along\n   with lengths and relative positions), is computed\
    \ by HMAC'ing the\n   \"|\"-separated concatenation of their base64url representations\
    \ using\n   the key-set identified by TID (step 4).\n   Finally, the SCS-cookie-value\
    \ is created as follows:\n      scs-cookie-value = Box(e(DATA), e(ATIME), e(TID),\
    \ e(IV),\n                             e(AUTHTAG))\n"
- title: 3.2.6.  Inbound Transform
  contents:
  - "3.2.6.  Inbound Transform\n   The inbound transformation is described in Figure\
    \ 3.  Each of the\n   'e'-prefixed names shown has to be interpreted as the\n\
    \   base64url-encoded value of the corresponding SCS field.\n           0.  If\
    \ (split_fields(scs-cookie-value) == ok)\n           1.      tid' := d(eTID)\n\
    \           2.      If (tid' is available)\n           3.          tag' := d(eAUTHTAG)\n\
    \           4.          tag := HMAC(Box(eDATA, eATIME, eTID, eIV))\n         \
    \  5.          If (tag = tag')\n           6.              atime' := d(eATIME)\n\
    \           7.              If (NOW - atime' <= session_max_age)\n           8.\
    \                  iv' := d(eIV)\n                               data' := d(eDATA)\n\
    \           9.                  state := Uncomp(Dec(data', iv'))\n           10.\
    \             Else discard PDU\n           11.         Else discard PDU\n    \
    \       12.     Else discard PDU\n           13. Else discard PDU\n          \
    \                       Figure 3\n   First, the inbound scs-cookie-value is broken\
    \ into its component\n   fields, which MUST be exactly 5, and each at least the\
    \ minimum length\n   specified in Figure 3 (step 0).  In case any of these preliminary\n\
    \   checks fails, the PDU is discarded (step 13); else, TID is decoded to\n  \
    \ allow key-set lookup (step 1).\n   If the cryptographic credentials (encryption\
    \ and authentication\n   algorithms and keys identified by TID) are unavailable\
    \ (step 12), the\n   inbound SCS cookie is discarded since its value has no chance\
    \ to be\n   interpreted correctly.  This may happen for several reasons: e.g.,\
    \ if\n   a device without storage has been reset and loses the credentials\n \
    \  stored in RAM, if a server pool node desynchronizes, or in case of a\n   key\
    \ compromise that forces the invalidation of all current TIDs, etc.\n   When a\
    \ valid key-set is found (step 2), the AUTHTAG field is decoded\n   (step 3) and\
    \ the (still) encoded DATA, ATIME, TID, and IV fields are\n   supplied to the\
    \ primitive that computes the authentication tag (step\n   4).\n   If the tag\
    \ computed using the local key-set matches the one carried\n   by the supplied\
    \ SCS cookie, we can be confident that the cookie\n   carries authentic material;\
    \ otherwise, the SCS cookie is discarded\n   (step 11).\n   Then the age of the\
    \ SCS cookie (as deduced by ATIME field value and\n   current time provided by\
    \ the server clock) is decoded and compared to\n   the maximum time-to-live (TTL)\
    \ defined by the session_max_age\n   parameter.\n   If the \"age\" check passes,\
    \ the DATA and IV fields are finally decoded\n   (step 8), so that the original\
    \ plaintext data can be extracted from\n   the encrypted, and optionally compressed,\
    \ blob (step 9).\n   Note that steps 5 and 7 allow any altered packets or expired\
    \ sessions\n   to be discarded, hence avoiding unnecessary state decryption and\n\
    \   decompression.\n"
- title: 3.3.  PDU Exchange
  contents:
  - "3.3.  PDU Exchange\n   SCS can be modeled in the same manner as a typical store-and-forward\n\
    \   protocol in which the endpoints are S, consisting of one or more HTTP\n  \
    \ servers and the client C, an intermediate node used to \"temporarily\"\n   store\
    \ the data to be successively forwarded to S.\n   In brief, S and C exchange an\
    \ immutable cookie data block\n   (Section 3.1): the state is stored on the client\
    \ at the first hop and\n   then restored on the server at the second, as in Figure\
    \ 4.\n     1.  dump-state:\n         S --> C\n             Set-Cookie: ANY_COOKIE_NAME=KrdPagFes_5ma-ZUluMsww|MTM0...\n\
    \                Expires=...; Path=...; Domain=...;\n     2.  restore-state:\n\
    \         C --> S\n             Cookie: ANY_COOKIE_NAME=KrdPagFes_5ma-ZUluMsww|MTM0...\n\
    \                                 Figure 4\n"
- title: 3.3.1.  Cookie Attributes
  contents:
  - "3.3.1.  Cookie Attributes\n   In the following subsections, a series of recommendations\
    \ is provided\n   in order to maximize SCS PDU fitness in the generic cookie ecosystem.\n"
- title: 3.3.1.1.  Expires
  contents:
  - "3.3.1.1.  Expires\n   If an SCS cookie includes an Expires attribute, then the\
    \ attribute\n   MUST be set to a value consistent with session_max_age.\n   For\
    \ maximum compatibility with existing user agents, the timestamp\n   value MUST\
    \ be encoded in rfc1123-date format, which requires a\n   4-digit year.\n"
- title: 3.3.1.2.  Max-Age
  contents:
  - "3.3.1.2.  Max-Age\n   Since not all User Agents (UAs) support this attribute,\
    \ it MUST NOT\n   be present in any SCS cookie.\n"
- title: 3.3.1.3.  Domain
  contents:
  - "3.3.1.3.  Domain\n   SCS cookies MUST include a Domain attribute compatible with\n\
    \   application usage.\n   A trailing '.'  MUST NOT be present in order to minimize\
    \ the\n   possibility of a user agent ignoring the attribute value.\n"
- title: 3.3.1.4.  Secure
  contents:
  - "3.3.1.4.  Secure\n   This attribute MUST always be asserted when SCS sessions\
    \ are carried\n   over a Transport Layer Security (TLS) channel.\n"
- title: 3.3.1.5.  HttpOnly
  contents:
  - "3.3.1.5.  HttpOnly\n   This attribute SHOULD always be asserted.\n"
- title: 4.  Key Management and Session State
  contents:
  - "4.  Key Management and Session State\n   This specification provides some common\
    \ recommendations and practices\n   relevant to cryptographic key management.\n\
    \   In the following, the term 'key' references both encryption and HMAC\n   keys.\n\
    \   o  The key SHOULD be generated securely following the randomness\n      recommendations\
    \ in [RFC4086];\n   o  the key SHOULD only be used to generate and verify SCS\
    \ PDUs;\n   o  the key SHOULD be replaced regularly as well as any time the\n\
    \      format of SCS PDUs or cryptographic algorithms changes.\n   Furthermore,\
    \ to preserve the validity of active HTTP sessions upon\n   renewal of cryptographic\
    \ credentials (whenever the value of TID\n   changes), an SCS server MUST be capable\
    \ of managing at least two\n   transforms contemporarily: the currently instantiated\
    \ one and its\n   predecessor.\n   Each transform set SHOULD be associated with\
    \ an attribute pair,\n   \"refresh\" and \"expiry\", which is used to identify\
    \ the exposure limits\n   (in terms of time or quantity of encrypted and/or authenticated\n\
    \   bytes, etc.) of related cryptographic material.\n   In particular, the \"\
    refresh\" attribute specifies the time limit for\n   substitution of transform\
    \ set T with new material T'.  From that\n   moment onwards, and for an amount\
    \ of time determined by \"expiry\", all\n   new sessions will be created using\
    \ T', while the active T-protected\n   ones go through a translation phase in\
    \ which:\n   o  the inbound transformation authenticates and decrypts/decompresses\n\
    \      using T (identified by TID);\n   o  the outbound transformation encrypts/compresses\
    \ and authenticates\n      using T'.\n        T' {not valid yet} |---------------------|----------------\n\
    \                           |  translation stage  |\n        T  ----------------|---------------------|\
    \ {no longer valid}\n                         refresh         refresh + expiry\n\
    \                                 Figure 5\n   As shown in Figure 5, the duration\
    \ of the HTTP session MUST fit\n   within the lifetime of a given transform set\
    \ (i.e., from creation\n   time until \"refresh\" + \"expiry\").\n   In practice,\
    \ this should not be an obstacle because the longevity of\n   the two entities\
    \ (HTTP session and SCS transform set) should differ\n   by one or two orders\
    \ of magnitude.\n   An SCS server may take this into account by determining the\
    \ duration\n   of a session adaptively according to the expected deletion time\
    \ of\n   the active T, or by setting the \"expiry\" value to at least the\n  \
    \ maximum lifetime allowed by an HTTP session.\n   Since there is also only one\
    \ refresh attribute in situations with\n   more than one key (e.g., one for encryption\
    \ and one for\n   authentication) within the same T, the smallest value is chosen.\n\
    \   It is critical for the correctness of the protocol that in case\n   multiple\
    \ equivalent SCS servers are used in a pool, all of them share\n   the same view\
    \ of time (see also Section 3.2.5) and keying material.\n   As far as the latter\
    \ is concerned, SCS does not mandate the use of\n   any specific key-sharing mechanism,\
    \ and will keep working correctly\n   as long as the said mechanism is able to\
    \ provide a single, coherent\n   view of the keys shared by pool members -- while\
    \ conforming to the\n   recommendations given in this section.\n"
- title: 5.  Cookie Size Considerations
  contents:
  - "5.  Cookie Size Considerations\n   In general, SCS cookies are bigger than their\
    \ plaintext counterparts.\n   This is due to the following reasons:\n   o  inflation\
    \ of the Base64 encoding of state data (approximately 1.4\n      times the original\
    \ size, including the encryption padding);\n   o  the fixed size increment (approximately\
    \ 80/90 bytes) caused by SCS\n      fields and framing overhead.\n   While the\
    \ former is a price the user must always pay proportionally\n   to the original\
    \ data size, the latter is a fixed quantum, which can\n   be huge on small amounts\
    \ of data but is quickly absorbed as soon as\n   data becomes big enough.\n  \
    \ The following table compares byte lengths of SCS cookies (with a\n   four-byte\
    \ TID) and corresponding plaintext cookies in a worst-case\n   scenario, i.e.,\
    \ when no compression is in use (or applicable).\n                           \
    \    plain |  SCS\n                               -------+-------\n          \
    \                       11  |  128\n                                102  |  256\n\
    \                                285  |  512\n                               \
    \ 651  | 1024\n                               1382  | 2048\n                 \
    \              2842  | 4096\n   The largest uncompressed cookie value that can\
    \ be safely supplied to\n   SCS is about 2.8 KB.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   We would like to thank Jim Schaad, David Wagner, Lorenzo\
    \ Cavallaro,\n   Willy Tarreau, Tobias Gondrom, John Michener, Sean Turner, Barry\n\
    \   Leiba, Robert Sparks, Stephen Farrell, Stewart Bryant, and Nevil\n   Brownlee\
    \ for their valuable feedback on this document.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Security of the Cryptographic Protocol
  contents:
  - "7.1.  Security of the Cryptographic Protocol\n   From a cryptographic architecture\
    \ perspective, the described\n   mechanism can be easily traced to an \"encode\
    \ then encrypt-then-MAC\"\n   scheme (Encode-then-EtM) as described in [Kohno].\n\
    \   Given a \"provably-secure\" encryption scheme and MAC (as for the\n   algorithms\
    \ mandated in Section 3.2.2), the authors of [Kohno]\n   demonstrate that their\
    \ composition results in a secure authenticated\n   encryption scheme.\n"
- title: 7.2.  Impact of the SCS Cookie Model
  contents:
  - "7.2.  Impact of the SCS Cookie Model\n   The fact that the server does not own\
    \ the cookie it produces, gives\n   rise to a series of consequences that must\
    \ be clearly understood when\n   one envisages the use of SCS as a cookie provider\
    \ and validator for\n   his/her application.\n   In the following subsections,\
    \ a set of different attack scenarios\n   (together with corresponding countermeasures\
    \ where applicable) are\n   identified and analyzed.\n"
- title: 7.2.1.  Old Cookie Replay
  contents:
  - "7.2.1.  Old Cookie Replay\n   SCS doesn't address replay of old cookie values.\n\
    \   In fact, there is nothing that assures an SCS application about the\n   client\
    \ having returned the most recent version of the cookie.\n   As with \"server-side\"\
    \ sessions, if an attacker gains possession of a\n   given user's cookies -- via\
    \ simple passive interception or another\n   technique -- he/she will always be\
    \ able to restore the state of an\n   intercepted session by representing the\
    \ captured data to the server.\n   The ATIME value, along with the session_max_age\
    \ configuration\n   parameter, allows SCS to mitigate the chances of an attack\
    \ (by\n   forcing a time window outside of which a given cookie is no longer\n\
    \   valid) but cannot exclude it completely.\n   A countermeasure against the\
    \ \"passive interception and replay\"\n   scenario can be applied at transport/network\
    \ level using the anti-\n   replay services provided by e.g., Secure Socket Layer/Transport\
    \ Layer\n   Security (SSL/TLS) [RFC5246] or IPsec [RFC4301].\n   A native solution\
    \ is not in scope with the security properties\n   inherent to an SCS cookie.\
    \  Hence, an application wishing to be\n   replay-resistant must put in place\
    \ some ad hoc mechanism to prevent\n   clients (both rogue and legitimate) from\
    \ (a) being able to replay old\n   cookies as valid credentials and/or (b) getting\
    \ any advantage by\n   replaying them.\n   The following illustrate some typical\
    \ use cases:\n   o  Session inactivity timeout scenario (implicit invalidation):\
    \ use\n      the session_max_age parameter if a global setting is viable, else\n\
    \      place an explicit TTL in the cookie (e.g.,\n      validity_period=\"start_time,\
    \ duration\") that can be verified by\n      the application each time the client\
    \ presents the SCS cookie.\n   o  Session voidance scenario (explicit invalidation):\
    \ put a randomly\n      chosen string into each SCS cookie (cid=\"$(random())\"\
    ) and keep a\n      list of valid session cids against which the SCS cookie presented\n\
    \      by the client can be checked.  When a cookie needs to be\n      invalidated,\
    \ delete the corresponding cid from the list.  The\n      described method has\
    \ the drawback that, in case a non-permanent\n      storage is used to archive\
    \ valid cids, a reboot/restart would\n      invalidate all sessions (it can't\
    \ be used when |S| > 1).\n   o  One-shot transaction scenario (ephemeral): this\
    \ is a variation on\n      the previous theme when sessions are consumed within\
    \ a single\n      request/response.  Put a nonce=\"$(random())\" within the state\n\
    \      information and keep a list of not-yet-consumed nonces in RAM.\n      Once\
    \ the client presents its cookie credential, the embodied nonce\n      is deleted\
    \ from the list and will be therefore discarded whenever\n      replayed.\n  \
    \ o  TLS binding scenario: the server application must run on TLS, be\n      able\
    \ to extract information related to the current TLS session,\n      and store\
    \ it in the DATA field of the SCS cookie itself [RFC5056].\n      The establishment\
    \ of this secure channel binding prevents any\n      third party from reusing\
    \ the SCS cookie, and drops its value\n      altogether after the TLS session\
    \ is terminated -- regardless of\n      the lifetime of the cookie.  This approach\
    \ suffers a scalability\n      problem in that it requires each SCS session to\
    \ be handled by the\n      same client-server pair.  However, it provides a robust\
    \ model and\n      an affordable compromise when security of the session is\n\
    \      exceptionally valuable (e.g., a user interacting with his/her\n      online\
    \ banking site).\n   It is worth noting that in all but the latter scenario, if\
    \ an\n   attacker is able to use the cookie before the legitimate client gets\n\
    \   a chance to, then the impersonation attack will always succeed.\n"
- title: 7.2.2.  Cookie Deletion
  contents:
  - "7.2.2.  Cookie Deletion\n   A direct and important consequence of the missing\
    \ owner role in SCS\n   is that a client could intentionally delete its cookie\
    \ and return\n   nothing.\n   The application protocol has to be designed so there\
    \ is no incentive\n   to do so, for instance:\n   o  it is safe for the cookie\
    \ to represent some kind of positive\n      capability -- the possession of which\
    \ increases the client's\n      powers;\n   o  it is not safe to use the cookie\
    \ to represent negative\n      capabilities -- where possession reduces the client's\
    \ powers -- or\n      for revocation.\n   Note that this behavior is not equivalent\
    \ to cookie removal in the\n   \"server-side\" cookie model, because in case of\
    \ missing cookie backup\n   by other parties (e.g., the application using SCS),\
    \ the client could\n   simply make it disappear once and for all.\n"
- title: 7.2.3.  Cookie Sharing or Theft
  contents:
  - "7.2.3.  Cookie Sharing or Theft\n   Just like with plain cookies, SCS doesn't\
    \ prevent sharing (both\n   voluntary and illegitimate) of cookies between multiple\
    \ clients.\n   In the context of voluntary cookie sharing, using HTTPS only as\
    \ a\n   separate secure transport provider is useless: in fact, client\n   certificates\
    \ are just as shareable as cookies.  Instead, using some\n   form of secure channel\
    \ binding (as illustrated in Section 7.2.1) may\n   cancel this risk.\n   The\
    \ risk of theft could be mitigated by securing the wire (e.g., via\n   HTTPS,\
    \ IPsec, VPN, etc.), thus reducing the opportunity of cookie\n   stealing to a\
    \ successful attack on the protocol endpoints.\n   In order to reduce the attack\
    \ window on stolen cookies, an\n   application may choose to generate cookies\
    \ whose lifetime is upper\n   bounded by the browsing session lifetime (i.e.,\
    \ by not attaching an\n   Expires attribute to them.)\n"
- title: 7.2.4.  Session Fixation
  contents:
  - "7.2.4.  Session Fixation\n   Session fixation vulnerabilities [Kolsec] are not\
    \ addressed by SCS.\n   A more sophisticated protocol involving active participation\
    \ of the\n   UA in the SCS cookie manipulation process would be needed: e.g.,\
    \ some\n   form of challenge/response exchange initiated by the server in the\n\
    \   HTTP response and replied to by the UA in the next chained HTTP\n   request.\n\
    \   Unfortunately, the present specification, which is based on\n   [RFC6265],\
    \ sees the UA as a completely passive actor whose role is to\n   blindly paste\
    \ the cookie value set by the server.\n   Nevertheless, the SCS cookies wrapping\
    \ mechanism may be used in the\n   future as a building block for a more robust\
    \ HTTP state management\n   protocol.\n"
- title: 7.3.  Advantages of SCS over Server-Side Sessions
  contents:
  - "7.3.  Advantages of SCS over Server-Side Sessions\n   Note that all the above-mentioned\
    \ vulnerabilities also apply to plain\n   cookies, making SCS at least as secure,\
    \ but there are a few good\n   reasons to consider its security level enhanced.\n\
    \   First of all, the confidentiality and authentication features\n   provided\
    \ by SCS protect the cookie value, which is normally plaintext\n   and tamperable.\n\
    \   Furthermore, neither of the common vulnerabilities of server-side\n   sessions\
    \ (session identifier (SID) prediction and SID brute-forcing)\n   can be exploited\
    \ when using SCS, unless the attacker possesses\n   encryption and HMAC keys (both\
    \ current ones and those relating to the\n   previous set of credentials).\n \
    \  More in general, no slicing nor altering operations can be done over\n   an\
    \ SCS PDU without controlling the cryptographic key-set.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [NIST-AES]  National Institute of Standards and\
    \ Technology, \"Advanced\n               Encryption Standard (AES)\", FIPS PUB\
    \ 197, November 2001,\n               <http://csrc.nist.gov/publications/fips/fips197/\n\
    \               fips-197.pdf>.\n   [RFC1951]   Deutsch, P., \"DEFLATE Compressed\
    \ Data Format\n               Specification version 1.3\", RFC 1951, May 1996.\n\
    \   [RFC2104]   Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n  \
    \             Hashing for Message Authentication\", RFC 2104,\n              \
    \ February 1997.\n   [RFC2119]   Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \               Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2616]\
    \   Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n               Masinter,\
    \ L., Leach, P., and T. Berners-Lee, \"Hypertext\n               Transfer Protocol\
    \ -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC4086]   Eastlake, D., Schiller,\
    \ J., and S. Crocker, \"Randomness\n               Requirements for Security\"\
    , BCP 106, RFC 4086, June 2005.\n   [RFC4648]   Josefsson, S., \"The Base16, Base32,\
    \ and Base64 Data\n               Encodings\", RFC 4648, October 2006.\n   [RFC5652]\
    \   Housley, R., \"Cryptographic Message Syntax (CMS)\",\n               STD 70,\
    \ RFC 5652, September 2009.\n   [RFC6194]   Polk, T., Chen, L., Turner, S., and\
    \ P. Hoffman, \"Security\n               Considerations for the SHA-0 and SHA-1\
    \ Message-Digest\n               Algorithms\", RFC 6194, March 2011.\n   [RFC6265]\
    \   Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n              \
    \ April 2011.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [Bellare]   Bellare, M., \"New Proofs for NMAC\
    \ and HMAC: Security\n               Without Collision-Resistance\", 2006.\n \
    \  [CLIQUES]   Steiner, M., Tsudik, G., and M. Waidner, \"Cliques: A New\n   \
    \            Approach to Group Key Agreement\", 1996.\n   [Kohno]     Kohno, T.,\
    \ Palacio, A., and J. Black, \"Building Secure\n               Cryptographic Transforms,\
    \ or How to Encrypt and MAC\",\n               2003.\n   [Kolsec]    Kolsec, M.,\
    \ \"Session Fixation Vulnerability in Web-based\n               Applications\"\
    , 2002.\n   [RFC3740]   Hardjono, T. and B. Weis, \"The Multicast Group Security\n\
    \               Architecture\", RFC 3740, March 2004.\n   [RFC4301]   Kent, S.\
    \ and K. Seo, \"Security Architecture for the\n               Internet Protocol\"\
    , RFC 4301, December 2005.\n   [RFC5056]   Williams, N., \"On the Use of Channel\
    \ Bindings to Secure\n               Channels\", RFC 5056, November 2007.\n  \
    \ [RFC5246]   Dierks, T. and E. Rescorla, \"The Transport Layer Security\n   \
    \            (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n   [Steiner]\
    \   Steiner, M., Tsudik, G., and M. Waidner, \"Diffie-Hellman\n              \
    \ Key Distribution Extended to Group Communication\", 1996.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   The examples in this section have been created using\
    \ the 'scs' test\n   tool bundled with LibSCS, a free and opensource reference\n\
    \   implementation of the SCS protocol that can be found at\n   (http://github.com/koanlogic/libscs).\n"
- title: A.1.  No Compression
  contents:
  - "A.1.  No Compression\n   The following parameters:\n   o  Plaintext cookie: \"\
    a state string\"\n   o  AES-CBC-128 key: \"123456789abcdef\"\n   o  HMAC-SHA1\
    \ key: \"12345678901234567890\"\n   o  TID: \"tid\"\n   o  ATIME: 1347265955\n\
    \   o  IV:\n      \\xb4\\xbd\\xe5\\x24\\xf7\\xf6\\x9d\\x44\\x85\\x30\\xde\\x9d\\\
    xb5\\x55\\xc9\\x4f\n   produce the following tokens:\n   o  DATA: DqfW4SFqcjBXqSTvF2qnRA\n\
    \   o  ATIME: MTM0NzI2NTk1NQ\n   o  TID: OHU7M1cqdDQt\n   o  IV: tL3lJPf2nUSFMN6dtVXJTw\n\
    \   o  AUTHTAG: AznYHKga9mLL8ioi3If_1iy2KSA\n"
- title: A.2.  Use Compression
  contents:
  - "A.2.  Use Compression\n   The same parameters as above, except ATIME and IV:\n\
    \   o  Plaintext cookie: \"a state string\"\n   o  AES-CBC-128 key: \"123456789abcdef\"\
    \n   o  HMAC-SHA1 key: \"12345678901234567890\"\n   o  TID: \"tid\"\n   o  ATIME:\
    \ 1347281709\n   o  IV:\n      \\x1d\\xa7\\x6f\\xa0\\xff\\x11\\xd7\\x95\\xe3\\\
    x4b\\xfb\\xa9\\xff\\x65\\xf9\\xc7\n   produce the following tokens:\n   o  DATA:\
    \ PbE-ypmQ43M8LzKZ6fMwFg-COrLP2l-Bvgs\n   o  ATIME: MTM0NzI4MTcwOQ\n   o  TID:\
    \ akxIKmhbMTE8\n   o  IV: HadvoP8R15XjS_up_2X5xw\n   o  AUTHTAG: A6qevPr-ugHQChlr_EiKYWPvpB0\n\
    \   In both cases, the resulting SCS cookie is obtained via ordered\n   concatenation\
    \ of the produced tokens, as described in Section 3.1.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stefano Barbato\n   KoanLogic\n   Via Marmolada, 4\n \
    \  Vitorchiano (VT),   01030\n   Italy\n   EMail: tat@koanlogic.com\n   Steven\
    \ Dorigotti\n   KoanLogic\n   Via Maso della Pieve 25/C\n   Bolzano,   39100\n\
    \   Italy\n   EMail: stewy@koanlogic.com\n   Thomas Fossati (editor)\n   KoanLogic\n\
    \   Via di Sabbiuno 11/5\n   Bologna,   40136\n   Italy\n   EMail: tho@koanlogic.com\n"
