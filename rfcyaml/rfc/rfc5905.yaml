- contents:
  - ' Network Time Protocol Version 4: Protocol and Algorithms Specification

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Network Time Protocol (NTP) is widely used to synchronize\n
    \  computer clocks in the Internet.  This document describes NTP version\n   4
    (NTPv4), which is backwards compatible with NTP version 3 (NTPv3),\n   described
    in RFC 1305, as well as previous versions of the protocol.\n   NTPv4 includes
    a modified protocol header to accommodate the Internet\n   Protocol version 6
    address family.  NTPv4 includes fundamental\n   improvements in the mitigation
    and discipline algorithms that extend\n   the potential accuracy to the tens of
    microseconds with modern\n   workstations and fast LANs.  It includes a dynamic
    server discovery\n   scheme, so that in many cases, specific server configuration
    is not\n   required.  It corrects certain errors in the NTPv3 design and\n   implementation
    and includes an optional extension mechanism.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5905.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Requirements Notation ......................................5\n   2.
    Modes of Operation ..............................................6\n   3. Protocol
    Modes ..................................................6\n      3.1. Dynamic
    Server Discovery ...................................7\n   4. Definitions .....................................................8\n
    \  5. Implementation Model ...........................................10\n   6.
    Data Types .....................................................12\n   7. Data
    Structures ................................................16\n      7.1. Structure
    Conventions .....................................16\n      7.2. Global Parameters
    .........................................16\n      7.3. Packet Header Variables
    ...................................17\n      7.4. The Kiss-o'-Death Packet ..................................24\n
    \     7.5. NTP Extension Field Format ................................25\n   8.
    On-Wire Protocol ...............................................26\n   9. Peer
    Process ...................................................30\n      9.1. Peer
    Process Variables ....................................31\n      9.2. Peer Process
    Operations ...................................33\n   10. Clock Filter Algorithm
    ........................................37\n   11. System Process ................................................39\n
    \     11.1. System Process Variables .................................40\n      11.2.
    System Process Operations ................................41\n           11.2.1.
    Selection Algorithm ...............................43\n           11.2.2. Cluster
    Algorithm .................................44\n           11.2.3. Combine Algorithm
    .................................45\n      11.3. Clock Discipline Algorithm ...............................47\n
    \  12. Clock-Adjust Process ..........................................51\n   13.
    Poll Process ..................................................51\n      13.1.
    Poll Process Variables ...................................51\n      13.2. Poll
    Process Operations ..................................52\n   14. Simple Network
    Time Protocol (SNTP) ...........................54\n   15. Security Considerations
    .......................................55\n   16. IANA Considerations ...........................................58\n
    \  17. Acknowledgements ..............................................59\n   18.
    References ....................................................59\n      18.1.
    Normative References .....................................59\n      18.2. Informative
    References ...................................59\n   Appendix A.  Code Skeleton
    \ .......................................61\n     A.1.  Global Definitions  .......................................61\n
    \      A.1.1. Definitions, Constants, Parameters .....................61\n       A.1.2.
    Packet Data Structures .................................65\n       A.1.3. Association
    Data Structures ............................66\n       A.1.4. System Data Structures
    .................................68\n       A.1.5. Local Clock Data Structures
    ............................69\n       A.1.6. Function Prototypes ....................................69\n
    \    A.2. Main Program and Utility Routines ..........................70\n     A.3.
    Kernel Input/Output Interface ..............................73\n     A.4. Kernel
    System Clock Interface ..............................74\n     A.5. Peer Process
    ...............................................76\n       A.5.1. receive() ..............................................77\n
    \      A.5.2. clock_filter() .........................................85\n       A.5.3.
    fast_xmit() ............................................88\n       A.5.4. access()
    ...............................................89\n       A.5.5. System Process
    .........................................90\n       A.5.6. Clock Adjust Process
    ..................................103\n       A.5.7. Poll Process ..........................................104\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines the Network Time Protocol version
    4 (NTPv4),\n   which is widely used to synchronize system clocks among a set of\n
    \  distributed time servers and clients.  It describes the core\n   architecture,
    protocol, state machines, data structures, and\n   algorithms.  NTPv4 introduces
    new functionality to NTPv3, as\n   described in [RFC1305], and functionality expanded
    from Simple NTP\n   version 4 (SNTPv4) as described in [RFC4330] (SNTPv4 is a
    subset of\n   NTPv4).  This document obsoletes [RFC1305] and [RFC4330].  While\n
    \  certain minor changes have been made in some protocol header fields,\n   these
    do not affect the interoperability between NTPv4 and previous\n   versions of
    NTP and SNTP.\n   The NTP subnet model includes a number of widely accessible
    primary\n   time servers synchronized by wire or radio to national standards.\n
    \  The purpose of the NTP protocol is to convey timekeeping information\n   from
    these primary servers to secondary time servers and clients via\n   both private
    networks and the public Internet.  Precisely tuned\n   algorithms mitigate errors
    that may result from network disruptions,\n   server failures, and possible hostile
    actions.  Servers and clients\n   are configured such that values flow towards
    clients from the primary\n   servers at the root via branching secondary servers.\n
    \  The NTPv4 design overcomes significant shortcomings in the NTPv3\n   design,
    corrects certain bugs, and incorporates new features.  In\n   particular, expanded
    NTP timestamp definitions encourage the use of\n   the floating double data type
    throughout the implementation.  As a\n   result, the time resolution is better
    than one nanosecond, and\n   frequency resolution is less than one nanosecond
    per second.\n   Additional improvements include a new clock discipline algorithm
    that\n   is more responsive to system clock hardware frequency fluctuations.\n
    \  Typical primary servers using modern machines are precise within a\n   few
    tens of microseconds.  Typical secondary servers and clients on\n   fast LANs
    are within a few hundred microseconds with poll intervals\n   up to 1024 seconds,
    which was the maximum with NTPv3.  With NTPv4,\n   servers and clients are precise
    within a few tens of milliseconds\n   with poll intervals up to 36 hours.\n   The
    main body of this document describes the core protocol and data\n   structures
    necessary to interoperate between conforming\n   implementations.  Appendix A
    contains a full-featured example in the\n   form of a skeleton program, including
    data structures and code\n   segments for the core algorithms as well as the mitigation
    algorithms\n   used to enhance reliability and accuracy.  While the skeleton program\n
    \  and other descriptions in this document apply to a particular\n   implementation,
    they are not intended as the only way the required\n   functions can be implemented.
    \ The contents of Appendix A are non-\n   normative examples designed to illustrate
    the protocol's operation\n   and are not a requirement for a conforming implementation.
    \ While the\n   NTPv3 symmetric key authentication scheme described in this document\n
    \  has been carried over from NTPv3, the Autokey public key\n   authentication
    scheme new to NTPv4 is described in [RFC5906].\n   The NTP protocol includes modes
    of operation described in Section 2\n   using data types described in Section
    6 and data structures described\n   in Section 7.  The implementation model described
    in Section 5 is\n   based on a threaded, multi-process architecture, although
    other\n   architectures could be used as well.  The on-wire protocol described\n
    \  in Section 8 is based on a returnable-time design that depends only\n   on
    measured clock offsets, but does not require reliable message\n   delivery.  Reliable
    message delivery such as TCP [RFC0793] can\n   actually make the delivered NTP
    packet less reliable since retries\n   would increase the delay value and other
    errors.  The synchronization\n   subnet is a self-organizing, hierarchical, master-slave
    network with\n   synchronization paths determined by a shortest-path spanning
    tree and\n   defined metric.  While multiple masters (primary servers) may exist,\n
    \  there is no requirement for an election protocol.\n   This document includes
    material from [ref9], which contains flow\n   charts and equations unsuited for
    RFC format.  There is much\n   additional information in [ref7], including an
    extensive technical\n   analysis and performance assessment of the protocol and
    algorithms in\n   this document.  The reference implementation is available at\n
    \  www.ntp.org.\n   The remainder of this document contains numerous variables
    and\n   mathematical expressions.  Some variables take the form of Greek\n   characters,
    which are spelled out by their full case-sensitive name.\n   For example, DELTA
    refers to the uppercase Greek character, while\n   delta refers to the lowercase
    character.  Furthermore, subscripts are\n   denoted with '_'; for example, theta_i
    refers to the lowercase Greek\n   character theta with subscript i, or phonetically
    theta sub i.  In\n   this document, all time values are in seconds (s), and all\n
    \  frequencies will be specified as fractional frequency offsets (FFOs)\n   (pure
    number).  It is often convenient to express these FFOs in parts\n   per million
    (ppm).\n"
  - contents:
    - "1.1.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n"
    title: 1.1.  Requirements Notation
  title: 1.  Introduction
- contents:
  - "2.  Modes of Operation\n   An NTP implementation operates as a primary server,
    secondary server,\n   or client.  A primary server is synchronized to a reference
    clock\n   directly traceable to UTC (e.g., GPS, Galileo, etc.).  A client\n   synchronizes
    to one or more upstream servers, but does not provide\n   synchronization to dependent
    clients.  A secondary server has one or\n   more upstream servers and one or more
    downstream servers or clients.\n   All servers and clients who are fully NTPv4-compliant
    MUST implement\n   the entire suite of algorithms described in this document.
    \ In order\n   to maintain stability in large NTP subnets, secondary servers SHOULD\n
    \  be fully NTPv4-compliant.  Alternative algorithms MAY be used, but\n   their
    output MUST be identical to the algorithms described in this\n   specification.\n"
  title: 2.  Modes of Operation
- contents:
  - "3.  Protocol Modes\n   There are three NTP protocol variants: symmetric, client/server,
    and\n   broadcast.  Each is associated with an association mode (a\n   description
    of the relationship between two NTP speakers) as shown in\n   Figure 1.  In addition,
    persistent associations are mobilized upon\n   startup and are never demobilized.
    \ Ephemeral associations are\n   mobilized upon the arrival of a packet and are
    demobilized upon error\n   or timeout.\n          +-------------------+-------------------+------------------+\n
    \         |  Association Mode | Assoc. Mode Value | Packet Mode Value|\n          +-------------------+-------------------+------------------+\n
    \         | Symmetric Active  |         1         | 1 or 2           |\n          |
    Symmetric Passive |         2         | 1                |\n          | Client
    \           |         3         | 4                |\n          | Server            |
    \        4         | 3                |\n          | Broadcast Server  |         5
    \        | 5                |\n          | Broadcast Client  |         6         |
    N/A              |\n          +-------------------+-------------------+------------------+\n
    \                 Figure 1: Association and Packet Modes\n   In the client/server
    variant, a persistent client sends packet mode 4\n   packets to a server, which
    returns packet mode 3 packets.  Servers\n   provide synchronization to one or
    more clients, but do not accept\n   synchronization from them.  A server can also
    be a reference clock\n   driver that obtains time directly from a standard source
    such as a\n   GPS receiver or telephone modem service.  In this variant, clients\n
    \  pull synchronization from servers.\n   In the symmetric variant, a peer operates
    as both a server and client\n   using either a symmetric active or symmetric passive
    association.  A\n   persistent symmetric active association sends symmetric active
    (mode\n   1) packets to a symmetric active peer association.  Alternatively, an\n
    \  ephemeral symmetric passive association can be mobilized upon the\n   arrival
    of a symmetric active packet with no matching association.\n   That association
    sends symmetric passive (mode 2) packets and\n   persists until error or timeout.
    \ Peers both push and pull\n   synchronization to and from each other.  For the
    purposes of this\n   document, a peer operates like a client, so references to
    client\n   imply peer as well.\n   In the broadcast variant, a persistent broadcast
    server association\n   sends periodic broadcast server (mode 5) packets that can
    be received\n   by multiple clients.  Upon reception of a broadcast server packet\n
    \  without a matching association, an ephemeral broadcast client (mode\n   6)
    association is mobilized and persists until error or timeout.  It\n   is useful
    to provide an initial volley where the client operating in\n   client mode exchanges
    several packets with the server, so as to\n   calibrate the propagation delay
    and to run the Autokey security\n   protocol, after which the client reverts to
    broadcast client mode.  A\n   broadcast server pushes synchronization to clients
    and other servers.\n   Loosely following the conventions established by the telephone\n
    \  industry, the level of each server in the hierarchy is defined by a\n   stratum
    number.  Primary servers are assigned stratum one; secondary\n   servers at each
    lower level are assigned stratum numbers one greater\n   than the preceding level.
    \ As the stratum number increases, its\n   accuracy degrades depending on the
    particular network path and system\n   clock stability.  Mean errors, measured
    by synchronization distances,\n   increase approximately in proportion to stratum
    numbers and measured\n   round-trip delay.\n   As a standard practice, timing
    network topology should be organized\n   to avoid timing loops and minimize the
    synchronization distance.  In\n   NTP, the subnet topology is determined using
    a variant of the\n   Bellman-Ford distributed routing algorithm, which computes
    the\n   shortest-path spanning tree rooted on the primary servers.  As a\n   result
    of this design, the algorithm automatically reorganizes the\n   subnet, so as
    to produce the most accurate and reliable time, even\n   when there are failures
    in the timing network.\n"
  - contents:
    - "3.1.  Dynamic Server Discovery\n   There are two special associations, manycast
      client and manycast\n   server, which provide a dynamic server discovery function.
      \ There are\n   two types of manycast client associations: persistent and ephemeral.\n
      \  The persistent manycast client sends client (mode 3) packets to a\n   designated
      IPv4 or IPv6 broadcast or multicast group address.\n   Designated manycast servers
      within range of the time-to-live (TTL)\n   field in the packet header listen
      for packets with that address.  If\n   a server is suitable for synchronization,
      it returns an ordinary\n   server (mode 4) packet using the client's unicast
      address.  Upon\n   receiving this packet, the client mobilizes an ephemeral
      client (mode\n   3) association.  The ephemeral client association persists
      until\n   error or timeout.\n   A manycast client continues sending packets
      to search for a minimum\n   number of associations.  It starts with a TTL equal
      to one and\n   continuously adding one to it until the minimum number of\n   associations
      is made or when the TTL reaches a maximum value.  If the\n   TTL reaches its
      maximum value and yet not enough associations are\n   mobilized, the client
      stops transmission for a time-out period to\n   clear all associations, and
      then repeats the search cycle.  If a\n   minimum number of associations has
      been mobilized, then the client\n   starts transmitting one packet per time-out
      period to maintain the\n   associations.  Field constraints limit the minimum
      value to 1 and the\n   maximum to 255.  These limits may be tuned for individual
      application\n   needs.\n   The ephemeral associations compete among themselves.
      \ As new\n   ephemeral associations are mobilized, the client runs the mitigation\n
      \  algorithms described in Sections 10 and 11.2 for the best candidates\n   out
      of the population, the remaining ephemeral associations are timed\n   out and
      demobilized.  In this way, the population includes only the\n   best candidates
      that have most recently responded with an NTP packet\n   to discipline the system
      clock.\n"
    title: 3.1.  Dynamic Server Discovery
  title: 3.  Protocol Modes
- contents:
  - "4.  Definitions\n   A number of technical terms are defined in this section.
    \ A timescale\n   is a frame of reference where time is expressed as the value
    of a\n   monotonically increasing binary counter with an indefinite number of\n
    \  bits.  It counts in seconds and fractions of a second, when a decimal\n   point
    is employed.  The Coordinated Universal Time (UTC) timescale is\n   defined by
    ITU-R TF.460 [ITU-R_TF.460].  Under the auspices of the\n   Metre Convention of
    1865, in 1975 the CGPM [CGPM] strongly endorsed\n   the use of UTC as the basis
    for civil time.\n   The Coordinated Universal Time (UTC) timescale represents
    mean solar\n   time as disseminated by national standards laboratories.  The system\n
    \  time is represented by the system clock maintained by the hardware\n   and
    operating system.  The goal of the NTP algorithms is to minimize\n   both the
    time difference and frequency difference between UTC and the\n   system clock.
    \ When these differences have been reduced below nominal\n   tolerances, the system
    clock is said to be synchronized to UTC.\n   The date of an event is the UTC time
    at which the event takes place.\n   Dates are ephemeral values designated with
    uppercase T.  Running time\n   is another timescale that is coincident to the
    synchronization\n   function of the NTP program.\n   A timestamp T(t) represents
    either the UTC date or time offset from\n   UTC at running time t.  Which meaning
    is intended should be clear\n   from the context.  Let T(t) be the time offset,
    R(t) the frequency\n   offset, and D(t) the aging rate (first derivative of R(t)
    with\n   respect to t).  Then, if T(t_0) is the UTC time offset determined at\n
    \  t = t_0, the UTC time offset at time t is\n   T(t) = T(t_0) + R(t_0)(t-t_0)
    + 1/2 * D(t_0)(t-t_0)^2 + e,\n   where e is a stochastic error term discussed
    later in this document.\n   While the D(t) term is important when characterizing
    precision\n   oscillators, it is ordinarily neglected for computer oscillators.
    \ In\n   this document, all time values are in seconds (s) and all frequency\n
    \  values are in seconds-per-second (s/s).  It is sometimes convenient\n   to
    express frequency offsets in parts-per-million (ppm), where 1 ppm\n   is equal
    to 10^(-6) s/s.\n   It is important in computer timekeeping applications to assess
    the\n   performance of the timekeeping function.  The NTP performance model\n
    \  includes four statistics that are updated each time a client makes a\n   measurement
    with a server.  The offset (theta) represents the\n   maximum-likelihood time
    offset of the server clock relative to the\n   system clock.  The delay (delta)
    represents the round-trip delay\n   between the client and server.  The dispersion
    (epsilon) represents\n   the maximum error inherent in the measurement.  It increases
    at a\n   rate equal to the maximum disciplined system clock frequency\n   tolerance
    (PHI), typically 15 ppm.  The jitter (psi) is defined as\n   the root-mean-square
    (RMS) average of the most recent offset\n   differences, and it represents the
    nominal error in estimating the\n   offset.\n   While the theta, delta, epsilon,
    and psi statistics represent\n   measurements of the system clock relative to
    each server clock\n   separately, the NTP protocol includes mechanisms to combine
    the\n   statistics of several servers to more accurately discipline and\n   calibrate
    the system clock.  The system offset (THETA) represents the\n   maximum-likelihood
    offset estimate for the server population.  The\n   system jitter (PSI) represents
    the nominal error in estimating the\n   system offset.  The delta and epsilon
    statistics are accumulated at\n   each stratum level from the reference clock
    to produce the root delay\n   (DELTA) and root dispersion (EPSILON) statistics.
    \ The\n   synchronization distance (LAMBDA) equal to EPSILON + DELTA / 2\n   represents
    the maximum error due to all causes.  The detailed\n   formulations of these statistics
    are given in Section 11.2.  They are\n   available to the dependent applications
    in order to assess the\n   performance of the synchronization function.\n"
  title: 4.  Definitions
- contents:
  - "5.  Implementation Model\n   Figure 2 shows the architecture of a typical, multi-threaded\n
    \  implementation.  It includes two processes dedicated to each server,\n   a
    peer process to receive messages from the server or reference\n   clock, and a
    poll process to transmit messages to the server or\n   reference clock.\n   .....................................................................\n
    \  . Remote   .   Peer/Poll  .              System          .  Clock   .\n   .
    Servers  .   Processes  .              Process         .Discipline.\n   .          .
    \             .                              . Process  .\n   .+--------+. +-----------+.
    +------------+               .          .\n   .|        |->|           |. |            |
    \              .          .\n   .|Server 1|  |Peer/Poll 1|->|            |               .
    \         .\n   .|        |<-|           |. |            |               .          .\n
    \  .+--------+. +-----------+. |            |               .          .\n   .
    \         .       ^      . |            |               .          .\n   .          .
    \      |      . |            |               .          .\n   .+--------+. +-----------+.
    |            |  +-----------+.          .\n   .|        |->|           |. | Selection
    \ |->|           |. +------+ .\n   .|Server 2|  |Peer/Poll 2|->|    and     |
    \ | Combine   |->| Loop | .\n   .|        |<-|           |. | Cluster    |  |
    Algorithm |. |Filter| .\n   .+--------+. +-----------+. | Algorithms |->|           |.
    +------+ .\n   .          .       ^      . |            |  +-----------+.    |
    \    .\n   .          .       |      . |            |               .    |     .\n
    \  .+--------+. +-----------+. |            |               .    |     .\n   .|
    \       |->|           |. |            |               .    |     .\n   .|Server
    3|  |Peer/Poll 3|->|            |               .    |     .\n   .|        |<-|
    \          |. |            |               .    |     .\n   .+--------+. +-----------+.
    +------------+               .    |     .\n   ....................^.........................................|......\n
    \                      |                                    .    V     .\n                       |
    \                                   . +-----+  .\n                       +--------------------------------------|
    VFO |  .\n                                                            . +-----+
    \ .\n                                                            .  Clock   .\n
    \                                                           .  Adjust  .\n                                                            .
    \ Process .\n                                                            ............\n
    \                     Figure 2: Implementation Model\n   These processes operate
    on a common data structure, called an\n   association, which contains the statistics
    described above along with\n   various other data described in Section 9.  A client
    sends packets to\n   one or more servers and then processes returned packets when
    they are\n   received.  The server interchanges source and destination addresses\n
    \  and ports, overwrites certain fields in the packet and returns it\n   immediately
    (in the client/server mode) or at some time later (in the\n   symmetric modes).
    \ As each NTP message is received, the offset theta\n   between the peer clock
    and the system clock is computed along with\n   the associated statistics delta,
    epsilon, and psi.\n   The system process includes the selection, cluster, and
    combine\n   algorithms that mitigate among the various servers and reference\n
    \  clocks to determine the most accurate and reliable candidates to\n   synchronize
    the system clock.  The selection algorithm uses Byzantine\n   fault detection
    principles to discard the presumably incorrect\n   candidates called \"falsetickers\"
    from the incident population,\n   leaving only good candidates called \"truechimers\".
    \ A truechimer is a\n   clock that maintains timekeeping accuracy to a previously
    published\n   and trusted standard, while a falseticker is a clock that shows\n
    \  misleading or inconsistent time.  The cluster algorithm uses\n   statistical
    principles to find the most accurate set of truechimers.\n   The combine algorithm
    computes the final clock offset by\n   statistically averaging the surviving truechimers.\n
    \  The clock discipline process is a system process that controls the\n   time
    and frequency of the system clock, here represented as a\n   variable frequency
    oscillator (VFO).  Timestamps struck from the VFO\n   close the feedback loop
    that maintains the system clock time.\n   Associated with the clock discipline
    process is the clock-adjust\n   process, which runs once each second to inject
    a computed time offset\n   and maintain constant frequency.  The RMS average of
    past time offset\n   differences represents the nominal error or system clock
    jitter.  The\n   RMS average of past frequency offset differences represents the\n
    \  oscillator frequency stability or frequency wander.  These terms are\n   given
    precise interpretation in Section 11.3.\n   A client sends messages to each server
    with a poll interval of 2^tau\n   seconds, as determined by the poll exponent
    tau.  In NTPv4, tau\n   ranges from 4 (16 s) to 17 (36 h).  The value of tau is
    determined by\n   the clock discipline algorithm to match the loop-time constant
    T_c =\n   2^tau.  In client/server mode, the server responds immediately;\n   however,
    in symmetric modes, each of two peers manages tau as a\n   function of current
    system offset and system jitter, so they may not\n   agree with the same value.
    \ It is important that the dynamic behavior\n   of the clock discipline algorithm
    be carefully controlled in order to\n   maintain stability in the NTP subnet at
    large.  This requires that\n   the peers agree on a common tau equal to the minimum
    poll exponent of\n   both peers.  The NTP protocol includes provisions to properly\n
    \  negotiate this value.\n   The implementation model includes some means to set
    and adjust the\n   system clock.  The operating system is assumed to provide two\n
    \  functions: one to set the time directly, for example, the Unix\n   settimeofday()
    function, and another to adjust the time in small\n   increments advancing or
    retarding the time by a designated amount,\n   for example, the Unix adjtime()
    function.  In this and following\n   references, parentheses following a name
    indicate reference to a\n   function rather than a simple variable.  In the intended
    design the\n   clock discipline process uses the adjtime() function if the\n   adjustment
    is less than a designated threshold, and the\n   settimeofday() function if above
    the threshold.  The manner in which\n   this is done and the value of the threshold
    as described in\n   Section 10.\n"
  title: 5.  Implementation Model
- contents:
  - "6.  Data Types\n   All NTP time values are represented in twos-complement format,
    with\n   bits numbered in big-endian (as described in Appendix A of [RFC0791])\n
    \  fashion from zero starting at the left, or high-order, position.\n   There
    are three NTP time formats, a 128-bit date format, a 64-bit\n   timestamp format,
    and a 32-bit short format, as shown in Figure 3.\n   The 128-bit date format is
    used where sufficient storage and word\n   size are available.  It includes a
    64-bit signed seconds field\n   spanning 584 billion years and a 64-bit fraction
    field resolving .05\n   attosecond (i.e., 0.5e-18).  For convenience in mapping
    between\n   formats, the seconds field is divided into a 32-bit Era Number field\n
    \  and a 32-bit Era Offset field.  Eras cannot be produced by NTP\n   directly,
    nor is there need to do so.  When necessary, they can be\n   derived from external
    means, such as the filesystem or dedicated\n   hardware.\n       0                   1
    \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |          Seconds              |           Fraction            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                              NTP Short Format\n       0                   1
    \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |                            Seconds                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |                            Fraction                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                            NTP Timestamp Format\n       0                   1
    \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |                           Era Number                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |                           Era Offset                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     |                                                               |\n      |
    \                          Fraction                            |\n      |                                                               |\n
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                              NTP
    Date Format\n                        Figure 3: NTP Time Formats\n   The 64-bit
    timestamp format is used in packet headers and other\n   places with limited word
    size.  It includes a 32-bit unsigned seconds\n   field spanning 136 years and
    a 32-bit fraction field resolving 232\n   picoseconds.  The 32-bit short format
    is used in delay and dispersion\n   header fields where the full resolution and
    range of the other\n   formats are not justified.  It includes a 16-bit unsigned
    seconds\n   field and a 16-bit fraction field.\n   In the date and timestamp formats,
    the prime epoch, or base date of\n   era 0, is 0 h 1 January 1900 UTC, when all
    bits are zero.  It should\n   be noted that strictly speaking, UTC did not exist
    prior to 1 January\n   1972, but it is convenient to assume it has existed for
    all eternity,\n   even if all knowledge of historic leap seconds has been lost.
    \ Dates\n   are relative to the prime epoch; values greater than zero represent\n
    \  times after that date; values less than zero represent times before\n   it.
    \ Note that the Era Offset field of the date format and the\n   Seconds field
    of the timestamp format have the same interpretation.\n   Timestamps are unsigned
    values, and operations on them produce a\n   result in the same or adjacent eras.
    \ Era 0 includes dates from the\n   prime epoch to some time in 2036, when the
    timestamp field wraps\n   around and the base date for era 1 is established.  In
    either format,\n   a value of zero is a special case representing unknown or\n
    \  unsynchronized time.  Figure 4 shows a number of historic NTP dates\n   together
    with their corresponding Modified Julian Day (MJD), NTP era,\n   and NTP timestamp.\n
    \  +-------------+------------+-----+---------------+------------------+\n   |
    Date        | MJD        | NTP | NTP Timestamp | Epoch            |\n   |             |
    \           | Era | Era Offset    |                  |\n   +-------------+------------+-----+---------------+------------------+\n
    \  | 1 Jan -4712 | -2,400,001 | -49 | 1,795,583,104 | 1st day Julian   |\n   |
    1 Jan -1    | -679,306   | -14 | 139,775,744   | 2 BCE            |\n   | 1 Jan
    0     | -678,491   | -14 | 171,311,744   | 1 BCE            |\n   | 1 Jan 1     |
    -678,575   | -14 | 202,939,144   | 1 CE             |\n   | 4 Oct 1582  | -100,851
    \  | -3  | 2,873,647,488 | Last day Julian  |\n   | 15 Oct 1582 | -100,840   |
    -3  | 2,874,597,888 | First day        |\n   |             |            |     |
    \              | Gregorian        |\n   | 31 Dec 1899 | 15019      | -1  | 4,294,880,896
    | Last day NTP Era |\n   |             |            |     |               | -1
    \              |\n   | 1 Jan 1900  | 15020      | 0   | 0             | First
    day NTP    |\n   |             |            |     |               | Era 0            |\n
    \  | 1 Jan 1970  | 40,587     | 0   | 2,208,988,800 | First day UNIX   |\n   |
    1 Jan 1972  | 41,317     | 0   | 2,272,060,800 | First day UTC    |\n   | 31 Dec
    1999 | 51,543     | 0   | 3,155,587,200 | Last day 20th    |\n   |             |
    \           |     |               | Century          |\n   | 8 Feb 2036  | 64,731
    \    | 1   | 63,104        | First day NTP    |\n   |             |            |
    \    |               | Era 1            |\n   +-------------+------------+-----+---------------+------------------+\n
    \                Figure 4: Interesting Historic NTP Dates\n   Let p be the number
    of significant bits in the second fraction.  The\n   clock resolution is defined
    as 2^(-p), in seconds.  In order to\n   minimize bias and help make timestamps
    unpredictable to an intruder,\n   the non-significant bits should be set to an
    unbiased random bit\n   string.  The clock precision is defined as the running
    time to read\n   the system clock, in seconds.  Note that the precision defined
    in\n   this way can be larger or smaller than the resolution.  The term rho,\n
    \  representing the precision used in the protocol, is the larger of the\n   two.\n
    \  The only arithmetic operation permitted on dates and timestamps is\n   twos-complement
    subtraction, yielding a 127-bit or 63-bit signed\n   result.  It is critical that
    the first-order differences between two\n   dates preserve the full 128-bit precision
    and the first-order\n   differences between two timestamps preserve the full 64-bit\n
    \  precision.  However, the differences are ordinarily small compared to\n   the
    seconds span, so they can be converted to floating double format\n   for further
    processing and without compromising the precision.\n   It is important to note
    that twos-complement arithmetic does not\n   distinguish between signed and unsigned
    values (although comparisons\n   can take sign into account); only the conditional
    branch instructions\n   do.  Thus, although the distinction is made between signed
    dates and\n   unsigned timestamps, they are processed the same way.  A perceived\n
    \  hazard with 64-bit timestamp calculations spanning an era, such as is\n   possible
    in 2036, might result in over-run.  In point of fact, if the\n   client is set
    within 68 years of the server before the protocol is\n   started, correct values
    are obtained even if the client and server\n   are in adjacent eras.\n   Some
    time values are represented in exponent format, including the\n   precision, time
    constant, and poll interval.  These are in 8-bit\n   signed integer format in
    log2 (log base 2) seconds.  The only\n   arithmetic operations permitted on them
    are increment and decrement.\n   For the purpose of this document and to simplify
    the presentation, a\n   reference to one of these variables by name means the
    exponentiated\n   value, e.g., the poll interval is 1024 s, while reference by
    name and\n   exponent means the actual value, e.g., the poll exponent is 10.\n
    \  To convert system time in any format to NTP date and timestamp\n   formats
    requires that the number of seconds s from the prime epoch to\n   the system time
    be determined.  To determine the integer era and\n   timestamp given s,\n   era
    = s / 2^(32) and timestamp = s - era * 2^(32),\n   which works for positive and
    negative dates.  To determine s given\n   the era and timestamp,\n   s = era *
    2^(32) + timestamp.\n   Converting between NTP and system time can be a little
    messy, and is\n   beyond the scope of this document.  Note that the number of
    days in\n   era 0 is one more than the number of days in most other eras, and\n
    \  this won't happen again until the year 2400 in era 3.\n   In the description
    of state variables to follow, explicit reference\n   to integer type implies a
    32-bit unsigned integer.  This simplifies\n   bounds checks, since only the upper
    limit needs to be defined.\n   Without explicit reference, the default type is
    64-bit floating\n   double.  Exceptions will be noted as necessary.\n"
  title: 6.  Data Types
- contents:
  - "7.  Data Structures\n   The NTP state machines are defined in the following sections.
    \ State\n   variables are separated into classes according to their function in\n
    \  packet headers, peer and poll processes, the system process, and the\n   clock
    discipline process.  Packet variables represent the NTP header\n   values in transmitted
    and received packets.  Peer and poll variables\n   represent the contents of the
    association for each server separately.\n   System variables represent the state
    of the server as seen by its\n   dependent clients.  Clock discipline variables
    represent the internal\n   workings of the clock discipline algorithm.  An example
    is described\n   in Appendix A.\n"
  - contents:
    - "7.1.  Structure Conventions\n   In order to distinguish between different variables
      of the same name\n   but used in different processes, the naming convention
      summarized in\n   Figure 5 is adopted.  A receive packet variable v is a member
      of the\n   packet structure r with fully qualified name r.v.  In a similar\n
      \  manner, x.v is a transmit packet variable, p.v is a peer variable,\n   s.v
      is a system variable, and c.v is a clock discipline variable.\n   There is a
      set of peer variables for each association; there is only\n   one set of system
      and clock variables.\n                   +------+---------------------------------+\n
      \                  | Name | Description                     |\n                   +------+---------------------------------+\n
      \                  | r.   | receive packet header variable  |\n                   |
      x.   | transmit packet header variable |\n                   | p.   | peer/poll
      variable              |\n                   | s.   | system variable                 |\n
      \                  | c.   | clock discipline variable       |\n                   +------+---------------------------------+\n
      \                      Figure 5: Prefix Conventions\n"
    title: 7.1.  Structure Conventions
  - contents:
    - "7.2.  Global Parameters\n   In addition to the variable classes, a number of
      global parameters\n   are defined in this document, including those shown with
      values in\n   Figure 6.\n            +-----------+-------+----------------------------------+\n
      \           | Name      | Value | Description                      |\n            +-----------+-------+----------------------------------+\n
      \           | PORT      | 123   | NTP port number                  |\n            |
      VERSION   | 4     | NTP version number                   |\n            | TOLERANCE
      | 15e-6 | frequency tolerance PHI (s/s)    |\n            | MINPOLL   | 4     |
      minimum poll exponent (16 s)     |\n            | MAXPOLL   | 17    | maximum
      poll exponent (36 h)     |\n            | MAXDISP   | 16    | maximum dispersion
      (16 s)        |\n            | MINDISP   | .005  | minimum dispersion increment
      (s) |\n            | MAXDIST   | 1     | distance threshold (1 s)         |\n
      \           | MAXSTRAT  | 16    | maximum stratum number           |\n            +-----------+-------+----------------------------------+\n
      \                       Figure 6: Global Parameters\n   While these are the
      only global parameters needed for\n   interoperability, a larger collection
      is necessary in any\n   implementation.  Appendix A.1.1 contains those used
      by the skeleton\n   for the mitigation algorithms, clock discipline algorithm,
      and\n   related implementation-dependent functions.  Some of these parameter\n
      \  values are cast in stone, like the NTP port number assigned by the\n   IANA
      and the version number assigned NTPv4 itself.  Others, like the\n   frequency
      tolerance (also called PHI), involve an assumption about\n   the worst-case
      behavior of a system clock once synchronized and then\n   allowed to drift when
      its sources have become unreachable.  The\n   minimum and maximum parameters
      define the limits of state variables\n   as described in later sections of this
      document.\n   While shown with fixed values in this document, some implementations\n
      \  may make them variables adjustable by configuration commands.  For\n   instance,
      the reference implementation computes the value of\n   PRECISION as log2 of
      the minimum time in several iterations to read\n   the system clock.\n"
    title: 7.2.  Global Parameters
  - contents:
    - "7.3.  Packet Header Variables\n   The most important state variables from an
      external point of view are\n   the packet header variables described in Figure
      7 and below.  The NTP\n   packet header consists of an integral number of 32-bit
      (4 octet)\n   words in network byte order.  The packet format consists of three\n
      \  components: the header itself, one or more optional extension fields,\n   and
      an optional message authentication code (MAC).  The header\n   component is
      identical to the NTPv3 header and previous versions.\n   The optional extension
      fields are used by the Autokey public key\n   cryptographic algorithms described
      in [RFC5906].  The optional MAC is\n   used by both Autokey and the symmetric
      key cryptographic algorithm\n   described in this RFC.\n               +-----------+------------+-----------------------+\n
      \              | Name      | Formula    | Description           |\n               +-----------+------------+-----------------------+\n
      \              | leap      | leap       | leap indicator (LI)   |\n               |
      version   | version    | version number (VN)   |\n               | mode      |
      mode       | mode                  |\n               | stratum   | stratum    |
      stratum               |\n               | poll      | poll       | poll exponent
      \        |\n               | precision | rho        | precision exponent    |\n
      \              | rootdelay | delta_r    | root delay            |\n               |
      rootdisp  | epsilon_r  | root dispersion       |\n               | refid     |
      refid      | reference ID          |\n               | reftime   | reftime    |
      reference timestamp   |\n               | org       | T1         | origin timestamp
      \     |\n               | rec       | T2         | receive timestamp     |\n
      \              | xmt       | T3         | transmit timestamp    |\n               |
      dst       | T4         | destination timestamp |\n               | keyid     |
      keyid      | key ID                |\n               | dgst      | dgst       |
      message digest        |\n               +-----------+------------+-----------------------+\n
      \                    Figure 7: Packet Header Variables\n   The NTP packet is
      a UDP datagram [RFC0768].  Some fields use multiple\n   words and others are
      packed in smaller fields within a word.  The NTP\n   packet header shown in
      Figure 8 has 12 words followed by optional\n   extension fields and finally
      an optional message authentication code\n   (MAC) consisting of the Key Identifier
      field and Message Digest\n   field.\n       0                   1                   2
      \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |LI | VN  |Mode |    Stratum     |     Poll      |  Precision   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                         Root Delay                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                         Root Dispersion                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                          Reference ID                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      +
      \                    Reference Timestamp (64)                  +\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                                                              |\n      +                      Origin
      Timestamp (64)                    +\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                                                              |\n      +                      Receive
      Timestamp (64)                   +\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                                                              |\n      +                      Transmit
      Timestamp (64)                  +\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                                                              |\n      .                                                               .\n
      \     .                    Extension Field 1 (variable)               .\n      .
      \                                                              .\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                                                              |\n      .                                                               .\n
      \     .                    Extension Field 2 (variable)               .\n      .
      \                                                              .\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                         Key Identifier                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      |
      \                           dgst (128)                         |\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      Figure
      8: Packet Header Format\n   The extension fields are used to add optional capabilities,
      for\n   example, the Autokey security protocol [RFC5906].  The extension\n   field
      format is presented in order for the packet to be parsed\n   without the knowledge
      of the extension field functions.  The MAC is\n   used by both Autokey and the
      symmetric key authentication scheme.\n   A list of the packet header variables
      is shown in Figure 7 and\n   described in detail below.  Except for a minor
      variation when using\n   the IPv6 address family, these fields are backwards
      compatible with\n   NTPv3.  The packet header fields apply to both transmitted
      packets (x\n   prefix) and received packets (r prefix).  In Figure 8, the size
      of\n   some multiple-word fields is shown in bits if not the default 32\n   bits.
      \ The basic header extends from the beginning of the packet to\n   the end of
      the Transmit Timestamp field.\n   The fields and associated packet variables
      (in parentheses) are\n   interpreted as follows:\n   LI Leap Indicator (leap):
      2-bit integer warning of an impending leap\n   second to be inserted or deleted
      in the last minute of the current\n   month with values defined in Figure 9.\n
      \          +-------+----------------------------------------+\n           |
      Value | Meaning                                |\n           +-------+----------------------------------------+\n
      \          | 0     | no warning                             |\n           |
      1     | last minute of the day has 61 seconds  |\n           | 2     | last
      minute of the day has 59 seconds  |\n           | 3     | unknown (clock unsynchronized)
      \        |\n           +-------+----------------------------------------+\n
      \                        Figure 9: Leap Indicator\n   VN Version Number (version):
      3-bit integer representing the NTP\n   version number, currently 4.\n   Mode
      (mode): 3-bit integer representing the mode, with values defined\n   in Figure
      10.\n                      +-------+--------------------------+\n                      |
      Value | Meaning                  |\n                      +-------+--------------------------+\n
      \                     | 0     | reserved                 |\n                      |
      1     | symmetric active         |\n                      | 2     | symmetric
      passive        |\n                      | 3     | client                   |\n
      \                     | 4     | server                   |\n                      |
      5     | broadcast                |\n                      | 6     | NTP control
      message      |\n                      | 7     | reserved for private use |\n
      \                     +-------+--------------------------+\n                       Figure
      10: Association Modes\n   Stratum (stratum): 8-bit integer representing the
      stratum, with\n   values defined in Figure 11.\n        +--------+-----------------------------------------------------+\n
      \       | Value  | Meaning                                             |\n        +--------+-----------------------------------------------------+\n
      \       | 0      | unspecified or invalid                              |\n        |
      1      | primary server (e.g., equipped with a GPS receiver) |\n        | 2-15
      \  | secondary server (via NTP)                          |\n        | 16     |
      unsynchronized                                      |\n        | 17-255 | reserved
      \                                           |\n        +--------+-----------------------------------------------------+\n
      \                        Figure 11: Packet Stratum\n   It is customary to map
      the stratum value 0 in received packets to\n   MAXSTRAT (16) in the peer variable
      p.stratum and to map p.stratum\n   values of MAXSTRAT or greater to 0 in transmitted
      packets.  This\n   allows reference clocks, which normally appear at stratum
      0, to be\n   conveniently mitigated using the same clock selection algorithms
      used\n   for external sources (see Appendix A.5.5.1 for an example).\n   Poll:
      8-bit signed integer representing the maximum interval between\n   successive
      messages, in log2 seconds.  Suggested default limits for\n   minimum and maximum
      poll intervals are 6 and 10, respectively.\n   Precision: 8-bit signed integer
      representing the precision of the\n   system clock, in log2 seconds.  For instance,
      a value of -18\n   corresponds to a precision of about one microsecond.  The
      precision\n   can be determined when the service first starts up as the minimum\n
      \  time of several iterations to read the system clock.\n   Root Delay (rootdelay):
      Total round-trip delay to the reference\n   clock, in NTP short format.\n   Root
      Dispersion (rootdisp): Total dispersion to the reference clock,\n   in NTP short
      format.\n   Reference ID (refid): 32-bit code identifying the particular server\n
      \  or reference clock.  The interpretation depends on the value in the\n   stratum
      field.  For packet stratum 0 (unspecified or invalid), this\n   is a four-character
      ASCII [RFC1345] string, called the \"kiss code\",\n   used for debugging and
      monitoring purposes.  For stratum 1 (reference\n   clock), this is a four-octet,
      left-justified, zero-padded ASCII\n   string assigned to the reference clock.
      \ The authoritative list of\n   Reference Identifiers is maintained by IANA;
      however, any string\n   beginning with the ASCII character \"X\" is reserved
      for unregistered\n   experimentation and development.  The identifiers in Figure
      12 have\n   been used as ASCII identifiers:\n     +------+----------------------------------------------------------+\n
      \    | ID   | Clock Source                                             |\n     +------+----------------------------------------------------------+\n
      \    | GOES | Geosynchronous Orbit Environment Satellite               |\n     |
      GPS  | Global Position System                                   |\n     | GAL
      \ | Galileo Positioning System                               |\n     | PPS  |
      Generic pulse-per-second                                 |\n     | IRIG | Inter-Range
      Instrumentation Group                        |\n     | WWVB | LF Radio WWVB
      Ft. Collins, CO 60 kHz                     |\n     | DCF  | LF Radio DCF77 Mainflingen,
      DE 77.5 kHz                  |\n     | HBG  | LF Radio HBG Prangins, HB 75 kHz
      \                        |\n     | MSF  | LF Radio MSF Anthorn, UK 60 kHz                          |\n
      \    | JJY  | LF Radio JJY Fukushima, JP 40 kHz, Saga, JP 60 kHz       |\n     |
      LORC | MF Radio LORAN C station, 100 kHz                        |\n     | TDF
      \ | MF Radio Allouis, FR 162 kHz                             |\n     | CHU  |
      HF Radio CHU Ottawa, Ontario                             |\n     | WWV  | HF
      Radio WWV Ft. Collins, CO                             |\n     | WWVH | HF Radio
      WWVH Kauai, HI                                  |\n     | NIST | NIST telephone
      modem                                     |\n     | ACTS | NIST telephone modem
      \                                    |\n     | USNO | USNO telephone modem                                     |\n
      \    | PTB  | European telephone modem                                 |\n     +------+----------------------------------------------------------+\n
      \                    Figure 12: Reference Identifiers\n   Above stratum 1 (secondary
      servers and clients): this is the\n   reference identifier of the server and
      can be used to detect timing\n   loops.  If using the IPv4 address family, the
      identifier is the four-\n   octet IPv4 address.  If using the IPv6 address family,
      it is the\n   first four octets of the MD5 hash of the IPv6 address.  Note that,\n
      \  when using the IPv6 address family on an NTPv4 server with a NTPv3\n   client,
      the Reference Identifier field appears to be a random value\n   and a timing
      loop might not be detected.\n   Reference Timestamp: Time when the system clock
      was last set or\n   corrected, in NTP timestamp format.\n   Origin Timestamp
      (org): Time at the client when the request departed\n   for the server, in NTP
      timestamp format.\n   Receive Timestamp (rec): Time at the server when the request
      arrived\n   from the client, in NTP timestamp format.\n   Transmit Timestamp
      (xmt): Time at the server when the response left\n   for the client, in NTP
      timestamp format.\n   Destination Timestamp (dst): Time at the client when the
      reply\n   arrived from the server, in NTP timestamp format.\n   Note: The Destination
      Timestamp field is not included as a header\n   field; it is determined upon
      arrival of the packet and made available\n   in the packet buffer data structure.\n
      \  If the NTP has access to the physical layer, then the timestamps are\n   associated
      with the beginning of the symbol after the start of frame.\n   Otherwise, implementations
      should attempt to associate the timestamp\n   to the earliest accessible point
      in the frame.\n   The MAC consists of the Key Identifier followed by the Message\n
      \  Digest.  The message digest, or cryptosum, is calculated as in\n   [RFC1321]
      over all NTP-header and optional extension fields, but not\n   the MAC itself.\n
      \  Extension Field n: See Section 7.5 for a description of the format of\n   this
      field.\n   Key Identifier (keyid): 32-bit unsigned integer used by the client\n
      \  and server to designate a secret 128-bit MD5 key.\n   Message Digest (digest):
      128-bit MD5 hash computed over the key\n   followed by the NTP packet header
      and extensions fields (but not the\n   Key Identifier or Message Digest fields).\n
      \  It should be noted that the MAC computation used here differs from\n   those
      defined in [RFC1305] and [RFC4330] but is consistent with how\n   existing implementations
      generate a MAC.\n"
    title: 7.3.  Packet Header Variables
  - contents:
    - "7.4.  The Kiss-o'-Death Packet\n   If the Stratum field is 0, which implies
      unspecified or invalid, the\n   Reference Identifier field can be used to convey
      messages useful for\n   status reporting and access control.  These are called
      Kiss-o'-Death\n   (KoD) packets and the ASCII messages they convey are called
      kiss\n   codes.  The KoD packets got their name because an early use was to\n
      \  tell clients to stop sending packets that violate server access\n   controls.
      \ The kiss codes can provide useful information for an\n   intelligent client,
      either NTPv4 or SNTPv4.  Kiss codes are encoded\n   in four-character ASCII
      strings that are left justified and zero\n   filled.  The strings are designed
      for character displays and log\n   files.  A list of the currently defined kiss
      codes is given in\n   Figure 13.  Recipients of kiss codes MUST inspect them
      and, in the\n   following cases, take these actions:\n   a.  For kiss codes
      DENY and RSTR, the client MUST demobilize any\n       associations to that server
      and stop sending packets to that\n       server;\n   b.  For kiss code RATE,
      the client MUST immediately reduce its\n       polling interval to that server
      and continue to reduce it each\n       time it receives a RATE kiss code.\n
      \  c.  Kiss codes beginning with the ASCII character \"X\" are for\n       unregistered
      experimentation and development and MUST be ignored\n       if not recognized.\n
      \  d.  Other than the above conditions, KoD packets have no protocol\n       significance
      and are discarded after inspection.\n   +------+------------------------------------------------------------+\n
      \  | Code |                           Meaning                          |\n   +------+------------------------------------------------------------+\n
      \  | ACST | The association belongs to a unicast server.               |\n   |
      AUTH | Server authentication failed.                              |\n   | AUTO
      | Autokey sequence failed.                                   |\n   | BCST |
      The association belongs to a broadcast server.             |\n   | CRYP | Cryptographic
      authentication or identification failed.     |\n   | DENY | Access denied by
      remote server.                            |\n   | DROP | Lost peer in symmetric
      mode.                               |\n   | RSTR | Access denied due to local
      policy.                         |\n   | INIT | The association has not yet synchronized
      for the first     |\n   |      | time.                                                      |\n
      \  | MCST | The association belongs to a dynamically discovered server.|\n   |
      NKEY | No key found. Either the key was never installed or is     |\n   |      |
      not trusted.                                               |\n   | RATE | Rate
      exceeded. The server has temporarily denied access    |\n   |      | because
      the client exceeded the rate threshold.            |\n   | RMOT | Alteration
      of association from a remote host running       |\n   |      | ntpdc.                                                     |\n
      \  | STEP | A step change in system time has occurred, but the         |\n   |
      \     | association has not yet resynchronized.                    |\n   +------+------------------------------------------------------------+\n
      \                          Figure 13: Kiss Codes\n   The Receive Timestamp and
      the Transmit Timestamp (set by the server)\n   are undefined when in a KoD packet
      and MUST NOT be relied upon to\n   have valid values and MUST be discarded.\n"
    title: 7.4.  The Kiss-o'-Death Packet
  - contents:
    - "7.5.  NTP Extension Field Format\n   In NTPv4, one or more extension fields
      can be inserted after the\n   header and before the MAC, which is always present
      when an extension\n   field is present.  Other than defining the field format,
      this\n   document makes no use of the field contents.  An extension field\n
      \  contains a request or response message in the format shown in\n   Figure
      14.\n       0                   1                   2                   3\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |          Field Type           |            Length             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     .                                                               .\n      .
      \                           Value                              .\n      .                                                               .\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
      \                      Padding (as needed)                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                    Figure 14: Extension Field Format\n   All extension fields
      are zero-padded to a word (four octets)\n   boundary.  The Field Type field
      is specific to the defined function\n   and is not elaborated here.  While the
      minimum field length\n   containing required fields is four words (16 octets),
      a maximum field\n   length remains to be established.\n   The Length field is
      a 16-bit unsigned integer that indicates the\n   length of the entire extension
      field in octets, including the Padding\n   field.\n"
    title: 7.5.  NTP Extension Field Format
  title: 7.  Data Structures
- contents:
  - "8.  On-Wire Protocol\n   The heart of the NTP on-wire protocol is the core mechanism
    that\n   exchanges time values between servers, peers, and clients.  It is\n   inherently
    resistant to lost or duplicate packets.  Data integrity is\n   provided by the
    IP and UDP checksums.  No flow control or\n   retransmission facilities are provided
    or necessary.  The protocol\n   uses timestamps, which are either extracted from
    packet headers or\n   struck from the system clock upon the arrival or departure
    of a\n   packet.  Timestamps are precision data and should be restruck in the\n
    \  case of link-level retransmission and corrected for the time to\n   compute
    a MAC in transmit.\n   NTP messages make use of two different communication modes,
    one-to-\n   one and one-to-many, commonly referred to as unicast and broadcast.\n
    \  For the purposes of this document, the term broadcast is interpreted\n   as
    any available one-to-many mechanism.  For IPv4, this equates to\n   either IPv4
    broadcast or IPv4 multicast.  For IPv6, this equates to\n   IPv6 multicast.  For
    this purpose, IANA has allocated the IPv4\n   multicast address 224.0.1.1 and
    the IPv6 multicast address ending\n   :101, with the prefix determined by scoping
    rules.  Any other non-\n   allocated multicast address may also be used in addition
    to these\n   allocated multicast addresses.\n   The on-wire protocol uses four
    timestamps numbered t1 through t4 and\n   three state variables org, rec, and
    xmt, as shown in Figure 15.  This\n   figure shows the most general case where
    each of two peers, A and B,\n   independently measure the offset and delay relative
    to the other.\n   For purposes of illustration, the packet timestamps are shown
    in\n   lowercase, while the state variables are shown in uppercase.  The\n   state
    variables are copied from the packet timestamps upon arrival or\n   departure
    of a packet.\n             t2            t3           t6            t7\n        +---------+
    \  +---------+   +---------+   +---------+\n        |    0    |   |    t1   |
    \  |   t3    |   |    t5   |\n        +---------+   +---------+   +---------+
    \  +---------+\n        |    0    |   |    t2   |   |   t4    |   |    t6   |
    \ Packet\n        +---------+   +---------+   +---------+   +---------+ Timestamps\n
    \       |   t1    |   |t3=clock |   |   t5    |   |t7=clock |\n        +---------+
    \  +---------+   +---------+   +---------+\n        |t2=clock |                 |t6=clock
    |\n        +---------+                 +---------+\n                                                               Peer
    B\n        +---------+   +---------+   +---------+   +---------+\n   org  |   T1
    \   |   |    T1   |   | t5<>T1? |   |    T5   |\n        +---------+   +---------+
    \  +---------+   +---------+   State\n   rec  |   T2    |   |    T2   |   |   T6
    \   |   |    T6   | Variables\n        +---------+   +---------+   +---------+
    \  +---------+\n   xmt  |    0    |   |    T3   |   |  t3=T3? |   |    T7   |\n
    \       +---------+   +---------+   +---------+   +---------+\n                  t2
    \     t3                 t6          t7\n        ---------------------------------------------------------\n
    \                /\\         \\                 /\\            \\\n                 /
    \          \\                /              \\\n                /             \\
    \             /                \\\n               /               \\/           /
    \                \\/\n        ---------------------------------------------------------\n
    \            t1                t4         t5                  t8\n            t1
    \           t4            t5             t8\n        +---------+   +---------+
    \  +---------+   +---------+\n        |    0    |   |    t1   |   |   t3    |
    \  |    t5   |\n        +---------+   +---------+   +---------+   +---------+\n
    \       |    0    |   |    t2   |   |   t4    |   |    t6   |  Packet\n        +---------+
    \  +---------+   +---------+   +---------+ Timestamps\n        |t1=clock |   |
    \   t3   |   |t5=clock |   |    t7   |\n        +---------+   +---------+   +---------+
    \  +---------+\n                      |t4=clock |                 |t8=clock |\n
    \                     +---------+                 +---------+\n                                                               Peer
    A\n        +---------+   +---------+   +---------+   +---------+\n   org  |    0
    \   |   |  t3<>0? |   |   T3    |   | t7<>T3? |\n        +---------+   +---------+
    \  +---------+   +---------+   State\n   rec  |    0    |   |    T4   |   |   T4
    \   |   |    T8   | Variables\n        +---------+   +---------+   +---------+
    \  +---------+\n   xmt  |   T1    |   |  t1=T1? |   |   T5    |   |  t5=T5? |\n
    \       +---------+   +---------+   +---------+   +---------+\n                        Figure
    15: On-Wire Protocol\n   In the figure, the first packet transmitted by A contains
    only the\n   origin timestamp t1, which is then copied to T1.  B receives the\n
    \  packet at t2 and copies t1 to T1 and the receive timestamp t2 to T2.\n   At
    this time or some time later at t3, B sends a packet to A\n   containing t1 and
    t2 and the transmit timestamp t3.  All three\n   timestamps are copied to the
    corresponding state variables.  A\n   receives the packet at t4 containing the
    three timestamps t1, t2, and\n   t3 and the destination timestamp t4.  These four
    timestamps are used\n   to compute the offset and delay of B relative to A, as
    described\n   below.\n   Before the xmt and org state variables are updated, two
    sanity checks\n   are performed in order to protect against duplicate, bogus,
    or\n   replayed packets.  In the exchange above, a packet is duplicate or\n   replay
    if the transmit timestamp t3 in the packet matches the org\n   state variable
    T3.  A packet is bogus if the origin timestamp t1 in\n   the packet does not match
    the xmt state variable T1.  In either of\n   these cases, the state variables
    are updated, then the packet is\n   discarded.  To protect against replay of the
    last transmitted packet,\n   the xmt state variable is set to zero immediately
    after a successful\n   bogus check.\n   The four most recent timestamps, T1 through
    T4, are used to compute\n   the offset of B relative to A\n   theta = T(B) - T(A)
    = 1/2 * [(T2-T1) + (T3-T4)]\n   and the round-trip delay\n   delta = T(ABA) =
    (T4-T1) - (T3-T2).\n   Note that the quantities within parentheses are computed
    from 64-bit\n   unsigned timestamps and result in signed values with 63 significant\n
    \  bits plus sign.  These values can represent dates from 68 years in\n   the
    past to 68 years in the future.  However, the offset and delay\n   are computed
    as sums and differences of these values, which contain\n   62 significant bits
    and two sign bits, so they can represent\n   unambiguous values from 34 years
    in the past to 34 years in the\n   future.  In other words, the time of the client
    must be set within 34\n   years of the server before the service is started.  This
    is a\n   fundamental limitation with 64-bit integer arithmetic.\n   In implementations
    where floating double arithmetic is available, the\n   first-order differences
    can be converted to floating double and the\n   second-order sums and differences
    computed in that arithmetic.  Since\n   the second-order terms are typically very
    small relative to the\n   timestamp magnitudes, there is no loss in significance,
    yet the\n   unambiguous range is restored from 34 years to 68 years.\n   In some
    scenarios where the initial frequency offset of the client is\n   relatively large
    and the actual propagation time small, it is\n   possible for the delay computation
    to become negative.  For instance,\n   if the frequency difference is 100 ppm
    and the interval T4-T1 is 64\n   s, the apparent delay is -6.4 ms.  Since negative
    values are\n   misleading in subsequent computations, the value of delta should
    be\n   clamped not less than s.rho, where s.rho is the system precision\n   described
    in Section 11.1, expressed in seconds.\n   The discussion above assumes the most
    general case where two\n   symmetric peers independently measure the offsets and
    delays between\n   them.  In the case of a stateless server, the protocol can
    be\n   simplified.  A stateless server copies T3 and T4 from the client\n   packet
    to T1 and T2 of the server packet and tacks on the transmit\n   timestamp T3 before
    sending it to the client.  Additional details for\n   filling in the remaining
    protocol fields are given in a Section 9 and\n   following sections and in the
    appendix.\n   Note that the on-wire protocol as described resists replay of a\n
    \  server response packet.  However, it does not resist replay of the\n   client
    request packet, which would result in a server reply packet\n   with new values
    of T2 and T3 and result in incorrect offset and\n   delay.  This vulnerability
    can be avoided by setting the xmt state\n   variable to zero after computing the
    offset and delay.\n"
  title: 8.  On-Wire Protocol
- contents:
  - "9.  Peer Process\n   The process descriptions to follow include a listing of
    the important\n   state variables followed by an overview of the process operations\n
    \  implemented as routines.  Frequent reference is made to the skeleton\n   in
    the appendix.  The skeleton includes C-language fragments that\n   describe the
    functions in more detail.  It includes the parameters,\n   variables, and declarations
    necessary for a conforming NTPv4\n   implementation.  However, many additional
    variables and routines may\n   be necessary in a working implementation.\n   The
    peer process is called upon arrival of a server or peer packet.\n   It runs the
    on-wire protocol to determine the clock offset and round-\n   trip delay and computes
    statistics used by the system and poll\n   processes.  Peer variables are instantiated
    in the association data\n   structure when the structure is initialized and updated
    by arriving\n   packets.  There is a peer process, poll process, and association\n
    \  process for each server.\n"
  - contents:
    - "9.1.  Peer Process Variables\n   Figures 16, 17, 18, and 19 summarize the common
      names, formula names,\n   and a short description of the peer variables.  The
      common names and\n   formula names are interchangeable; formula names are intended
      to\n   increase readability of equations in this specification.  Unless\n   noted
      otherwise, all peer variables have assumed prefix p.\n                 +---------+----------+-----------------------+\n
      \                | Name    | Formula  | Description           |\n                 +---------+----------+-----------------------+\n
      \                | srcaddr | srcaddr  | source address        |\n                 |
      srcport | srcport  | source port           |\n                 | dstaddr | dstaddr
      \ | destination address   |\n                 | dstport | destport | destination
      port      |\n                 | keyid   | keyid    | key identifier key ID |\n
      \                +---------+----------+-----------------------+\n              Figure
      16: Peer Process Configuration Variables\n                +-----------+------------+---------------------+\n
      \               | Name      | Formula    | Description         |\n                +-----------+------------+---------------------+\n
      \               | leap      | leap       | leap indicator      |\n                |
      version   | version    | version number      |\n                | mode      |
      mode       | mode                |\n                | stratum   | stratum    |
      stratum             |\n                | ppoll     | ppoll      | peer poll
      exponent  |\n                | rootdelay | delta_r    | root delay          |\n
      \               | rootdisp  | epsilon_r  | root dispersion     |\n                |
      refid     | refid      | reference ID        |\n                | reftime   |
      reftime    | reference timestamp |\n                +-----------+------------+---------------------+\n
      \                Figure 17: Peer Process Packet Variables\n                     +------+---------+--------------------+\n
      \                    | Name | Formula | Description        |\n                     +------+---------+--------------------+\n
      \                    | org  | T1      | origin timestamp   |\n                     |
      rec  | T2      | receive timestamp  |\n                     | xmt  | T3      |
      transmit timestamp |\n                     | t    | t       | packet time        |\n
      \                    +------+---------+--------------------+\n                Figure
      18: Peer Process Timestamp Variables\n                     +--------+---------+-----------------+\n
      \                    | Name   | Formula | Description     |\n                     +--------+---------+-----------------+\n
      \                    | offset | theta   | clock offset    |\n                     |
      delay  | delta   | round-trip delay|\n                     | disp   | epsilon
      | dispersion      |\n                     | jitter | psi     | jitter          |\n
      \                    | filter | filter  | clock filter    |\n                     |
      tp     | t_p     | filter time     |\n                     +--------+---------+-----------------+\n
      \              Figure 19: Peer Process Statistics Variables\n   The following
      configuration variables are normally initialized when\n   the association is
      mobilized, either from a configuration file or\n   upon the arrival of the first
      packet for an unknown association.\n   srcaddr: IP address of the remote server
      or reference clock.  This\n   becomes the destination IP address in packets
      sent from this\n   association.\n   srcport: UDP port number of the server or
      reference clock.  This\n   becomes the destination port number in packets sent
      from this\n   association.  When operating in symmetric modes (1 and 2), this
      field\n   must contain the NTP port number PORT (123) assigned by the IANA.
      \ In\n   other modes, it can contain any number consistent with local policy.\n
      \  dstaddr: IP address of the client.  This becomes the source IP\n   address
      in packets sent from this association.\n   dstport: UDP port number of the client,
      ordinarily the NTP port\n   number PORT (123) assigned by the IANA.  This becomes
      the source port\n   number in packets sent from this association.\n   keyid:
      Symmetric key ID for the 128-bit MD5 key used to generate and\n   verify the
      MAC.  The client and server or peer can use different\n   values, but they must
      map to the same key.\n   The variables defined in Figure 17 are updated from
      the packet header\n   as each packet arrives.  They are interpreted in the same
      way as the\n   packet variables of the same names.  It is convenient for later\n
      \  processing to convert the NTP short format packet values r.rootdelay\n   and
      r.rootdisp to floating doubles as peer variables.\n   The variables defined
      in Figure 18 include the timestamps exchanged\n   by the on-wire protocol in
      Section 8.  The t variable is the seconds\n   counter c.t associated with these
      values.  The c.t variable is\n   maintained by the clock-adjust process described
      in Section 12.  It\n   counts the seconds since the service was started.  The
      variables\n   defined in Figure 19 include the statistics computed by the\n
      \  clock_filter() routine described in Section 10.  The tp variable is\n   the
      seconds counter associated with these values.\n"
    title: 9.1.  Peer Process Variables
  - contents:
    - "9.2.  Peer Process Operations\n   The receive routine defines the process flow
      upon the arrival of a\n   packet.  An example is described by the receive()
      routine in\n   Appendix A.5.1.  There is no specific method required for access\n
      \  control, although it is recommended that implementations include such\n   a
      scheme, which is similar to many others now in widespread use.  The\n   access()
      routine in Appendix A.5.4 describes a method of implementing\n   access restrictions
      using an access control list (ACL).  Format\n   checks require correct field
      length and alignment, acceptable version\n   number (1-4), and correct extension
      field syntax, if present.\n   There is no specific requirement for authentication;
      however, if\n   authentication is implemented, then the MD5-keyed hash algorithm\n
      \  described in [RFC1321] must be supported.\n   Next, the association table
      is searched for matching source address\n   and source port, for example, using
      the find_assoc() routine in\n   Appendix A.5.1.  Figure 20 is a dispatch table
      where the columns\n   correspond to the packet mode and rows correspond to the
      association\n   mode.  The intersection of the association and packet modes\n
      \  dispatches processing to one of the following steps.\n           +------------------+---------------------------------------+\n
      \          |                  |              Packet Mode              |\n           +------------------+-------+-------+-------+-------+-------+\n
      \          | Association Mode |   1   |   2   |   3   |   4   |   5   |\n           +------------------+-------+-------+-------+-------+-------+\n
      \          | No Association 0 | NEWPS | DSCRD | FXMIT | MANY  | NEWBC |\n           |
      Symm. Active   1 | PROC  | PROC  | DSCRD | DSCRD | DSCRD |\n           | Symm.
      Passive  2 | PROC  | ERR   | DSCRD | DSCRD | DSCRD |\n           | Client         3
      | DSCRD | DSCRD | DSCRD | PROC  | DSCRD |\n           | Server         4 | DSCRD
      | DSCRD | DSCRD | DSCRD | DSCRD |\n           | Broadcast      5 | DSCRD | DSCRD
      | DSCRD | DSCRD | DSCRD |\n           | Bcast Client   6 | DSCRD | DSCRD | DSCRD
      | DSCRD | PROC  |\n           +------------------+-------+-------+-------+-------+-------+\n
      \                     Figure 20: Peer Dispatch Table\n   DSCRD.  This indicates
      a non-fatal violation of protocol as the\n   result of a programming error,
      long-delayed packet, or replayed\n   packet.  The peer process discards the
      packet and exits.\n   ERR.  This indicates a fatal violation of protocol as
      the result of a\n   programming error, long-delayed packet, or replayed packet.
      \ The peer\n   process discards the packet, demobilizes the symmetric passive\n
      \  association, and exits.\n   FXMIT.  This indicates a client (mode 3) packet
      matching no\n   association (mode 0).  If the destination address is not a broadcast\n
      \  address, the server constructs a server (mode 4) packet and returns\n   it
      to the client without retaining state.  The server packet header\n   is constructed.
      \ An example is described by the fast_xmit() routine\n   in Appendix A.5.3.
      \ The packet header is assembled from the receive\n   packet and system variables
      as shown in Figure 21.  If the\n   s.rootdelay and s.rootdisp system variables
      are stored in floating\n   double, they must be converted to NTP short format
      first.\n                   +-----------------------------------+\n                   |
      Packet Variable -->   Variable    |\n                   +-----------------------------------+\n
      \                  | r.leap        -->     p.leap      |\n                   |
      r.mode        -->     p.mode      |\n                   | r.stratum     -->
      \    p.stratum   |\n                   | r.poll        -->     p.ppoll     |\n
      \                  | r.rootdelay   -->     p.rootdelay |\n                   |
      r.rootdisp    -->     p.rootdisp  |\n                   | r.refid       -->
      \    p.refid     |\n                   | r.reftime     -->     p.reftime   |\n
      \                  | r.keyid       -->     p.keyid     |\n                   +-----------------------------------+\n
      \                    Figure 21: Receive Packet Header\n   Note that, if authentication
      fails, the server returns a special\n   message called a crypto-NAK.  This message
      includes the normal NTP\n   header data shown in Figure 8, but with a MAC consisting
      of four\n   octets of zeros.  The client MAY accept or reject the data in the\n
      \  message.  After these actions, the peer process exits.\n   If the destination
      address is a multicast address, the sender is\n   operating in manycast client
      mode.  If the packet is valid and the\n   server stratum is less than the client
      stratum, the server sends an\n   ordinary server (mode 4) packet, but one which
      uses its unicast\n   destination address.  A crypto-NAK is not sent if authentication\n
      \  fails.  After these actions, the peer process exits.\n   MANY: This indicates
      a server (mode 4) packet matching no\n   association.  Ordinarily, this can
      happen only as the result of a\n   manycast server reply to a previously sent
      multicast client packet.\n   If the packet is valid, an ordinary client (mode
      3) association is\n   mobilized and operation continues as if the association
      was mobilized\n   by the configuration file.\n   NEWBC.  This indicates a broadcast
      (mode 5) packet matching no\n   association.  The client mobilizes either a
      client (mode 3) or\n   broadcast client (mode 6) association.  Examples are
      shown in the\n   mobilize() and clear() routines in Appendix A.2.  Then, the
      packet is\n   validated and the peer variables initialized.  An example is provided\n
      \  by the packet() routine in Appendix A.5.1.1.\n   If the implementation supports
      no additional security or calibration\n   functions, the association mode is
      set to broadcast client (mode 6)\n   and the peer process exits.  Implementations
      supporting public key\n   authentication MAY run the Autokey or equivalent security
      protocol.\n   Implementations SHOULD set the association mode to 3 and run a
      short\n   client/server exchange to determine the propagation delay.  Following\n
      \  the exchange, the association mode is set to 6 and the peer process\n   continues
      in listen-only mode.  Note the distinction between a mode-6\n   packet, which
      is reserved for the NTP monitor and control functions,\n   and a mode-6 association.\n
      \  NEWPS.  This indicates a symmetric active (mode 1) packet matching no\n   association.
      \ The client mobilizes a symmetric passive (mode 2)\n   association.  An example
      is shown in the mobilize() and clear()\n   routines in Appendix A.2.  Processing
      continues in the PROC section\n   below.\n   PROC.  This indicates a packet
      matching an existing association.  The\n   packet timestamps are carefully checked
      to avoid invalid, duplicate,\n   or bogus packets.  Additional checks are summarized
      in Figure 22.\n   Note that all packets, including a crypto-NAK, are considered
      valid\n   only if they survive these tests.\n   +--------------------------+----------------------------------------+\n
      \  | Packet Type              | Description                            |\n   +--------------------------+----------------------------------------+\n
      \  | 1 duplicate packet       | The packet is at best an old duplicate |\n   |
      \                         | or at worst a replay by a hacker.      |\n   |                          |
      This can happen in symmetric modes if  |\n   |                          | the
      poll intervals are uneven.         |\n   | 2 bogus packet           |                                        |\n
      \  | 3 invalid                | One or more timestamp fields are       |\n   |
      \                         | invalid. This normally happens in      |\n   |                          |
      symmetric modes when one peer sends    |\n   |                          | the
      first packet to the other and      |\n   |                          | before
      the other has received its      |\n   |                          | first reply.
      \                          |\n   | 4 access denied          | The access controls
      have blacklisted   |\n   |                          | the source.                            |\n
      \  | 5 authentication failure | The cryptographic message digest does  |\n   |
      \                         | not match the MAC.                     |\n   | 6
      unsynchronized         | The server is not synchronized to a    |\n   |                          |
      valid source.                          |\n   | 7 bad header data        | One
      or more header fields are invalid. |\n   +--------------------------+----------------------------------------+\n
      \                     Figure 22: Packet Error Checks\n   Processing continues
      by copying the packet variables to the peer\n   variables as shown in Figure
      21.  An example is described by the\n   packet() routine in Appendix A.5.1.1.
      \ The receive() routine\n   implements tests 1-5 in Figure 22; the packet()
      routine implements\n   tests 6-7.  If errors are found, the packet is discarded
      and the peer\n   process exits.\n   The on-wire protocol calculates the clock
      offset theta and round-trip\n   delay delta from the four most recent timestamps
      as described in\n   Section 8.  While it is, in principle, possible to do all\n
      \  calculations except the first-order timestamp differences in fixed-\n   point
      arithmetic, it is much easier to convert the first-order\n   differences to
      floating doubles and do the remaining calculations in\n   that arithmetic, and
      this will be assumed in the following\n   description.\n   Next, the 8-bit p.reach
      shift register in the poll process described\n   in Section 13 is used to determine
      whether the server is reachable\n   and the data are fresh.  The register is
      shifted left by one bit when\n   a packet is sent and the rightmost bit is set
      to zero.  As valid\n   packets arrive, the rightmost bit is set to one.  If
      the register\n   contains any nonzero bits, the server is considered reachable;\n
      \  otherwise, it is unreachable.  Since the peer poll interval might\n   have
      changed since the last packet, the host poll interval is\n   reviewed.  An example
      is provided by the poll_update() routine in\n   Appendix A.5.7.2.\n   The dispersion
      statistic epsilon(t) represents the maximum error due\n   to the frequency tolerance
      and time since the last packet was sent.\n   It is initialized\n   epsilon(t_0)
      = r.rho + s.rho + PHI * (T4-T1)\n   when the measurement is made at t_0 according
      to the seconds counter.\n   Here, r.rho is the packet precision described in
      Section 7.3 and\n   s.rho is the system precision described in Section 11.1,
      both\n   expressed in seconds.  These terms are necessary to account for the\n
      \  uncertainty in reading the system clock in both the server and the\n   client.\n
      \  The dispersion then grows at constant rate PHI; in other words, at\n   time
      t, epsilon(t) = epsilon(t_0) + PHI * (t-t_0).  With the default\n   value PHI
      = 15 ppm, this amounts to about 1.3 s per day.  With this\n   understanding,
      the argument t will be dropped and the dispersion\n   represented simply as
      epsilon.  The remaining statistics are computed\n   by the clock filter algorithm
      described in the next section.\n"
    title: 9.2.  Peer Process Operations
  title: 9.  Peer Process
- contents:
  - "10.  Clock Filter Algorithm\n   The clock filter algorithm is part of the peer
    process.  It grooms\n   the stream of on-wire data to select the samples most
    likely to\n   represent accurate time.  The algorithm produces the variables shown\n
    \  in Figure 19, including the offset (theta), delay (delta), dispersion\n   (epsilon),
    jitter (psi), and time of arrival (t).  These data are\n   used by the mitigation
    algorithms to determine the best and final\n   offset used to discipline the system
    clock.  They are also used to\n   determine the server health and whether it is
    suitable for\n   synchronization.\n   The clock filter algorithm saves the most
    recent sample tuples\n   (theta, delta, epsilon, t) in the filter structure, which
    functions\n   as an 8-stage shift register.  The tuples are saved in the order
    that\n   packets arrive.  Here, t is the packet time of arrival according to\n
    \  the seconds counter and should not be confused with the peer variable\n   tp.\n
    \  The following scheme is used to ensure sufficient samples are in the\n   filter
    and that old stale data are discarded.  Initially, the tuples\n   of all stages
    are set to the dummy tuple (0, MAXDISP, MAXDISP, 0).\n   As valid packets arrive,
    tuples are shifted into the filter causing\n   old tuples to be discarded, so
    eventually only valid tuples remain.\n   If the three low-order bits of the reach
    register are zero,\n   indicating three poll intervals have expired with no valid
    packets\n   received, the poll process calls the clock filter algorithm with a\n
    \  dummy tuple just as if the tuple had arrived from the network.  If\n   this
    persists for eight poll intervals, the register returns to the\n   initial condition.\n
    \  In the next step, the shift register stages are copied to a temporary\n   list
    and the list sorted by increasing delta.  Let i index the stages\n   starting
    with the lowest delta.  If the first tuple epoch t_0 is not\n   later than the
    last valid sample epoch tp, the routine exits without\n   affecting the current
    peer variables.  Otherwise, let epsilon_i be\n   the dispersion of the ith entry,
    then\n                     i=n-1\n                     ---     epsilon_i\n      epsilon
    =       \\     ----------\n                      /        (i+1)\n                     ---
    \    2\n                     i=0\n   is the peer dispersion p.disp.  Note the
    overload of epsilon, whether\n   input to the clock filter or output, the meaning
    should be clear from\n   context.\n   The observer should note (a) if all stages
    contain the dummy tuple\n   with dispersion MAXDISP, the computed dispersion is
    a little less\n   than 16 s, (b) each time a valid tuple is shifted into the register,\n
    \  the dispersion drops by a little less than half, depending on the\n   valid
    tuples dispersion, and (c) after the fourth valid packet the\n   dispersion is
    usually a little less than 1 s, which is the assumed\n   value of the MAXDIST
    parameter used by the selection algorithm to\n   determine whether or not the
    peer variables are acceptable.\n   Let the first stage offset in the sorted list
    be theta_0; then, for\n   the other stages in any order, the jitter is the RMS
    average\n                          +-----                 -----+^1/2\n                          |
    \ n-1                      |\n                          |  ---                      |\n
    \                 1       |  \\                     2  |\n      psi   =  --------
    * |  /    (theta_0-theta_j)   |\n                (n-1)     |  ---                      |\n
    \                         |  j=1                      |\n                          +-----
    \                -----+\n   where n is the number of valid tuples in the filter
    (n > 1).  In\n   order to ensure consistency and avoid divide exceptions in other\n
    \  computations, the psi is bounded from below by the system precision\n   s.rho
    expressed in seconds.  While not in general considered a major\n   factor in ranking
    server quality, jitter is a valuable indicator of\n   fundamental timekeeping
    performance and network congestion state.  Of\n   particular importance to the
    mitigation algorithms is the peer\n   synchronization distance, which is computed
    from the delay and\n   dispersion.\n   lambda = (delta / 2) + epsilon.\n   Note
    that epsilon and therefore lambda increase at rate PHI.  The\n   lambda is not
    a state variable, since lambda is recalculated at each\n   use.  It is a component
    of the root synchronization distance used by\n   the mitigation algorithms as
    a metric to evaluate the quality of time\n   available from each server.\n   It
    is important to note that, unlike NTPv3, NTPv4 associations do not\n   show a
    timeout condition by setting the stratum to 16 and leap\n   indicator to 3.  The
    association variables retain the values\n   determined upon arrival of the last
    packet.  In NTPv4, lambda\n   increases with time, so eventually the synchronization
    distance\n   exceeds the distance threshold MAXDIST, in which case the association\n
    \  is considered unfit for synchronization.\n   An example implementation of the
    clock filter algorithm is shown in\n   the clock_filter() routine of Appendix
    A.5.2.\n"
  title: 10.  Clock Filter Algorithm
- contents:
  - "11.  System Process\n   As each new sample (theta, delta, epsilon, jitter, t)
    is produced by\n   the clock filter algorithm, all peer processes are scanned
    by the\n   mitigation algorithms consisting of the selection, cluster, combine,\n
    \  and clock discipline algorithms in the system process.  The selection\n   algorithm
    scans all associations and casts off the falsetickers,\n   which have demonstrably
    incorrect time, leaving the truechimers as\n   result.  In a series of rounds,
    the cluster algorithm discards the\n   association statistically furthest from
    the centroid until a\n   specified minimum number of survivors remain.  The combine
    algorithm\n   produces the best and final statistics on a weighted average basis.\n
    \  The final offset is passed to the clock discipline algorithm to steer\n   the
    system clock to the correct time.\n   The cluster algorithm selects one of the
    survivors as the system\n   peer.  The associated statistics (theta, delta, epsilon,
    jitter, t)\n   are used to construct the system variables inherited by dependent\n
    \  servers and clients and made available to other applications running\n   on
    the same machine.\n"
  - contents:
    - "11.1.  System Process Variables\n   Figure 23 summarizes the common names,
      formula names, and a short\n   description of each system variable.  Unless
      noted otherwise, all\n   variables have assumed prefix s.\n                +-----------+------------+------------------------+\n
      \               | Name      | Formula    | Description            |\n                +-----------+------------+------------------------+\n
      \               | t         | t          | update time            |\n                |
      p         | p          | system peer identifier |\n                | leap      |
      leap       | leap indicator         |\n                | stratum   | stratum
      \   | stratum                |\n                | precision | rho        | precision
      \             |\n                | offset    | THETA      | combined offset
      \       |\n                | jitter    | PSI        | combined jitter        |\n
      \               | rootdelay | DELTA      | root delay             |\n                |
      rootdisp  | EPSILON    | root dispersion        |\n                | v         |
      v          | survivor list          |\n                | refid     | refid      |
      reference ID           |\n                | reftime   | reftime    | reference
      time         |\n                | NMIN      | 3          | minimum survivors
      \     |\n                | CMIN      | 1          | minimum candidates     |\n
      \               +-----------+------------+------------------------+\n                    Figure
      23: System Process Variables\n   Except for the t, p, offset, and jitter variables
      and the NMIN and\n   CMIN constants, the variables have the same format and
      interpretation\n   as the peer variables of the same name.  The NMIN and CMIN
      parameters\n   are used by the selection and cluster algorithms described in
      the\n   next section.\n   The t variable is the seconds counter at the time
      of the last update.\n   An example is shown by the clock_update() routine in\n
      \  Appendix A.5.5.4.  The p variable is the system peer identifier\n   determined
      by the cluster() routine in Section 11.2.2.  The precision\n   variable has
      the same format as the packet variable of the same name.\n   The precision is
      defined as the larger of the resolution and time to\n   read the clock, in log2
      units.  For instance, the precision of a\n   mains-frequency clock incrementing
      at 60 Hz is 16 ms, even when the\n   system clock hardware representation is
      to the nanosecond.\n   The offset and jitter variables are determined by the
      combine\n   algorithm in Section 11.2.3.  These values represent the best and\n
      \  final offset and jitter used to discipline the system clock.\n   Initially,
      all variables are cleared to zero, then the leap is set to\n   3 (unsynchronized)
      and stratum is set to MAXSTRAT (16).  Remember\n   that MAXSTRAT is mapped to
      zero in the transmitted packet.\n"
    title: 11.1.  System Process Variables
  - contents:
    - "11.2.  System Process Operations\n   Figure 24 summarizes the system process
      operations performed by the\n   clock select routine.  The selection algorithm
      described in\n   Section 11.2.1 produces a majority clique of presumed correct\n
      \  candidates (truechimers) based on agreement principles.  The cluster\n   algorithm
      described in Section 11.2.2 discards outliers to produce\n   the most accurate
      survivors.  The combine algorithm described in\n   Section 11.2.3 provides the
      best and final offset for the clock\n   discipline algorithm.  An example is
      described in Appendix A.5.5.6.\n   If the selection algorithm cannot produce
      a majority clique, or if it\n   cannot produce at least CMIN survivors, the
      system process exits\n   without disciplining the system clock.  If successful,
      the cluster\n   algorithm selects the statistically best candidate as the system
      peer\n   and its variables are inherited as the system variables.\n                          +-----------------+\n
      \                         | clock_select()  |\n                          +-----------------+\n
      \  ................................|...........\n   .                               V
      \         .\n   .      yes +---------+ +-----------------+ .\n   .       +--|
      accept? | | scan candidates | .\n   .       |  +---------+ |                 |
      .\n   .       V        no |  |                 | .\n   .  +---------+      |
      \ |                 | .\n   .  | add peer|      |  |                 | .\n   .
      \ +----------      |  |                 | .\n   .       |           V  |                 |
      .\n   .       +---------->-->|                 | .\n   .                      |
      \                | .\n   . Selection Algorithm  +-----------------+ .\n   .................................|..........\n
      \                                   V\n                       no +-------------------+\n
      \           +-------------|     survivors?    |\n            |             +-------------------+\n
      \           |                       | yes\n            |                       V\n
      \           |             +-------------------+\n            |             |
      Cluster Algorithm |\n            |             +-------------------+\n            |
      \                      |\n            |                       V\n            V
      \        yes +-------------------+\n            |<------------|     n < CMIN?
      \    |\n            |             +-------------------+\n            V                       |\n
      \    +-----------------+            V no\n     |   s.p = NULL    |  +-------------------+\n
      \    +-----------------+  |   s.p = v_0.p     |\n            |             +-------------------+\n
      \           V                       |\n     +-----------------+            V\n
      \    | return (UNSYNC) |  +-------------------+\n     +-----------------+  |
      \  return (SYNC)   |\n                          +-------------------+\n                      Figure
      24: Clock Select Routine\n"
    - contents:
      - "11.2.1.  Selection Algorithm\n   Note that the selection and cluster algorithms
        are described\n   separately, but combined in the code skeleton.  The selection\n
        \  algorithm operates to find an intersection interval containing a\n   majority
        clique of truechimers using Byzantine agreement principles\n   originally
        proposed by Marzullo [ref6], but modified to improve\n   accuracy.  An overview
        of the algorithm is given below and described\n   in the first half of the
        clock_select() routine in Appendix A.5.5.1.\n   First, those servers that
        are unusable according to the rules of the\n   protocol are detected and discarded
        as shown by the accept() routine\n   in Appendix A.5.5.3.  Next, a set of
        tuples (p, type, edge) is\n   generated for the remaining candidates.  Here,
        p is the association\n   identifier and type identifies the upper (+1), middle
        (0), and lower\n   (-1) endpoints of a correctness interval centered on theta
        for that\n   candidate.  This results in three tuples, lowpoint (p, -1, theta
        -\n   lambda), midpoint (p, 0, theta), and highpoint (p, +1, theta +\n   lambda),
        where lambda is the root synchronization distance.  An\n   example of this
        calculation is shown by the rootdist() routine in\n   Appendix A.5.1.1.  The
        steps of the algorithm are:\n   1.  For each of m associations, place three
        tuples as defined above\n   on the candidate list.\n   2.  Sort the tuples
        on the list by the edge component.  Order the\n   lowpoint, midpoint, and
        highpoint of these intervals from lowest to\n   highest.  Set the number of
        falsetickers f = 0.\n   3.  Set the number of midpoints d = 0.  Set c = 0.
        \ Scan from lowest\n   endpoint to highest.  Add one to c for every lowpoint,
        subtract one\n   for every highpoint, add one to d for every midpoint.  If
        c >= m - f,\n   stop; set l = current lowpoint.\n   4.  Set c = 0.  Scan from
        highest endpoint to lowest.  Add one to c\n   for every highpoint, subtract
        one for every lowpoint, add one to d\n   for every midpoint.  If c >= m -
        f, stop; set u = current highpoint.\n   5.  Is d = f and l < u?  If yes, then
        follow step 5A; else, follow\n   step 5B.\n   5A. Success: the intersection
        interval is [l, u].\n   5B. Add one to f.  Is f < (m / 2)?  If yes, then go
        to step 3 again.\n   If no, then go to step 6.\n   6.  Failure; a majority
        clique could not be found.  There are no\n   suitable candidates to discipline
        the system clock.\n   The algorithm is described in detail in Appendix A.5.5.1.
        \ Note that\n   it starts with the assumption that there are no falsetickers
        (f = 0)\n   and attempts to find a non-empty intersection interval containing
        the\n   midpoints of all correct servers, i.e., truechimers.  If a non-empty\n
        \  interval cannot be found, it increases the number of assumed\n   falsetickers
        by one and tries again.  If a non-empty interval is\n   found and the number
        of falsetickers is less than the number of\n   truechimers, a majority clique
        has been found and the midpoint of\n   each truechimer (theta) represents
        the candidates available to the\n   cluster algorithm.\n   If a majority clique
        is not found, or if the number of truechimers is\n   less than CMIN, there
        are insufficient candidates to discipline the\n   system clock.  CMIN defines
        the minimum number of servers consistent\n   with the correctness requirements.
        \ Suspicious operators would set\n   CMIN to ensure multiple redundant servers
        are available for the\n   algorithms to mitigate properly.  However, for historic
        reasons the\n   default value for CMIN is one.\n"
      title: 11.2.1.  Selection Algorithm
    - contents:
      - "11.2.2.  Cluster Algorithm\n   The candidates of the majority clique are
        placed on the survivor list\n   v in the form of tuples (p, theta_p, psi_p,
        lambda_p), where p is an\n   association identifier, theta_p, psi_p, and stratum_p
        the current\n   offset, jitter and stratum of association p, respectively,
        and\n   lambda_p is a merit factor equal to stratum_p * MAXDIST + lambda,\n
        \  where lambda is the root synchronization distance for association p.\n
        \  The list is processed by the cluster algorithm below.  An example is\n
        \  shown by the second half of the clock_select() algorithm in\n   Appendix
        A.5.5.1.\n   1.  Let (p, theta_p, psi_p, lambda_p) represent a survivor candidate.\n
        \  2.  Sort the candidates by increasing lambda_p.  Let n be the number\n
        \  of candidates and NMIN the minimum required number of survivors.\n   3.
        \ For each candidate, compute the selection jitter psi_s:\n             +-----
        \                      -----+^1/2\n             |        n-1                      |\n
        \            |        ---                      |\n             |   1    \\
        \                    2  |\n     psi_s = | ---- * /  (theta_s - theta_j)   |\n
        \            |  n-1   ---                      |\n             |        j=1
        \                     |\n             +-----                       -----+\n
        \  4.  Select psi_max as the candidate with maximum psi_s.\n   5.  Select
        psi_min as the candidate with minimum psi_p.\n   6.  Is psi_max < psi_min
        or n <= NMIN?  If yes, follow step 6A;\n   otherwise, follow step 6B.\n   6A.
        Done.  The remaining candidates on the survivor list are ranked\n   in the
        order of preference.  The first entry on the list represents\n   the system
        peer; its variables are used later to update the system\n   variables.\n   6B.
        Delete the outlier candidate with psi_max; reduce n by one and go\n   back
        to step 3.\n   The algorithm operates in a series of rounds where each round\n
        \  discards the statistical outlier with maximum selection jitter psi_s.\n
        \  However, if psi_s is less than the minimum peer jitter psi_p, no\n   improvement
        is possible by discarding outliers.  This and the minimum\n   number of survivors
        represent the terminating conditions of the\n   algorithm.  Upon termination,
        the final value of psi_max is saved as\n   the system selection jitter PSI_s
        for use later.\n"
      title: 11.2.2.  Cluster Algorithm
    - contents:
      - "11.2.3.  Combine Algorithm\n   The clock combine route processes the remaining
        survivors to produce\n   the best and final data for the clock discipline
        algorithm.  The\n   routine processes peer offset and jitter statistics to
        produce the\n   combined system offset THETA and system peer jitter PSI_p,
        where each\n   server statistic is weighted by the reciprocal of the root\n
        \  synchronization distance and the result normalized.  An example is\n   shown
        by the clock_combine() routine in Appendix A.5.5.5\n   The combined THETA
        is passed to the clock update routine.  The first\n   candidate on the survivor
        list is nominated as the system peer with\n   identifier p.  The system peer
        jitter PSI_p is a component of the\n   system jitter PSI.  It is used along
        with the selection jitter PSI_s\n   to produce the system jitter:\n   PSI
        = [(PSI_s)^2 + (PSI_p)^2]^1/2\n   Each time an update is received from the
        system peer, the clock\n   update routine is called.  By rule, an update is
        discarded if its\n   time of arrival p.t is not strictly later than the last
        update used\n   s.t.  The labels IGNOR, PANIC, ADJ, and STEP refer to return
        codes\n   from the local clock routine described in the next section.\n   IGNORE
        means the update has been ignored as an outlier.  PANIC means\n   the offset
        is greater than the panic threshold PANICT (1000 s) and\n   SHOULD cause the
        program to exit with a diagnostic message to the\n   system log.  STEP means
        the offset is less than the panic threshold,\n   but greater than the step
        threshold STEPT (125 ms).  In this case,\n   the clock is stepped to the correct
        offset, but since this means all\n   peer data have been invalidated, all
        associations MUST be reset and\n   the client begins as at initial start.\n
        \  ADJ means the offset is less than the step threshold and thus a valid\n
        \  update.  In this case, the system variables are updated from the peer\n
        \  variables as shown in Figure 25.\n                  +-------------------------------------------+\n
        \                 | System Variable <-- System Peer Variable  |        |\n
        \                 +-------------------------------------------+\n                  |
        s.leap      <-- p.leap                    |\n                  | s.stratum
        \  <-- p.stratum + 1             |\n                  | s.offset    <-- THETA
        \                    |\n                  | s.jitter    <-- PSI                       |\n
        \                 | s.rootdelay <-- p.delta_r + delta         |\n                  |
        s.rootdisp  <-- p.epsilon_r + p.epsilon + |\n                  |                 p.psi
        + PHI * (s.t - p.t) |\n                  |                 + |THETA|                 |\n
        \                 | s.refid     <-- p.refid                   |\n                  |
        s.reftime   <-- p.reftime                 |\n                  | s.t         <--
        p.t                       |\n                  +-------------------------------------------+\n
        \                   Figure 25: System Variables Update\n   There is an important
        detail not shown.  The dispersion increment\n   (p.epsilon + p.psi + PHI *
        (s.t - p.t) + |THETA|) is bounded from\n   below by MINDISP.  In subnets with
        very fast processors and networks\n   and very small delay and dispersion
        this forces a monotone-definite\n   increase in s.rootdisp (EPSILON), which
        avoids loops between peers\n   operating at the same stratum.\n   The system
        variables are available to dependent application programs\n   as nominal performance
        statistics.  The system offset THETA is the\n   clock offset relative to the
        available synchronization sources.  The\n   system jitter PSI is an estimate
        of the error in determining this\n   value, elsewhere called the expected
        error.  The root delay DELTA is\n   the total round-trip delay relative to
        the primary server.  The root\n   dispersion EPSILON is the dispersion accumulated
        over the network\n   from the primary server.  Finally, the root synchronization
        distance\n   is defined as:\n   LAMBDA = EPSILON + DELTA / 2,\n   which represents
        the maximum error due all causes and is designated\n   the root synchronization
        distance.\n   An example of the clock update routine is provided in\n   Appendix
        A.5.5.4.\n"
      title: 11.2.3.  Combine Algorithm
    title: 11.2.  System Process Operations
  - contents:
    - "11.3.  Clock Discipline Algorithm\n   The NTPv4 clock discipline algorithm,
      shortened to discipline in the\n   following, functions as a combination of
      two quite philosophically\n   different feedback control systems.  In a phase-locked
      loop (PLL)\n   design, periodic phase updates at update intervals mu seconds
      are\n   used directly to minimize the time error and indirectly the frequency\n
      \  error.  In a frequency-locked loop (FLL) design, periodic frequency\n   updates
      at intervals mu are used directly to minimize the frequency\n   error and indirectly
      the time error.  As shown in [ref7], a PLL\n   usually works better when network
      jitter dominates, while an FLL\n   works better when oscillator wander dominates.
      \ This section contains\n   an outline of how the NTPv4 design works.  An in-depth
      discussion of\n   the design principles is provided in [ref7], which also includes
      a\n   performance analysis.\n   The discipline is implemented as the feedback
      control system shown in\n   Figure 26.  The variable theta_r represents the
      combine algorithm\n   offset (reference phase) and theta_c the VFO offset (control
      phase).\n   Each update produces a signal V_d representing the instantaneous\n
      \  phase difference theta_r - theta_c.  The clock filter for each server\n   functions
      as a tapped delay line, with the output taken at the tap\n   selected by the
      clock filter algorithm.  The selection, cluster, and\n   combine algorithms
      combine the data from multiple filters to produce\n   the signal V_s.  The loop
      filter, with impulse response F(t),\n   produces the signal V_c, which controls
      the VFO frequency omega_c and\n   thus the integral of the phase theta_c which
      closes the loop.  The\n   V_c signal is generated by the clock-adjust process
      in Section 12.\n   The detailed equations that implement these functions are
      best\n   presented in the routines of Appendices A.5.5.6 and A.5.6.1.\n                theta_r
      + +---------\\        +----------------+\n            NTP --------->|  Phase
      \  \\  V_d  |                | V_s\n                theta_c - | Detector  ------>|
      \ Clock Filter  |----+\n                +-------->|          /       |                |
      \   |\n                |         +---------/        +----------------+    |\n
      \               |                                                  |\n              -----
      \                                               |\n             /     \\                                               |\n
      \            | VFO |                                               |\n             \\
      \    /                                               |\n              -----
      \   .......................................     |\n                ^      .
      \           Loop Filter              .     |\n                |      . +---------+
      \  x  +-------------+    .     |\n                | V_c  . |         |<-----|
      \            |    .     |\n                +------.-|  Clock  |   y  | Phase/Freq
      \ |<---------+\n                       . | Adjust  |<-----| Prediction  |    .\n
      \                      . |         |      |             |    .\n                       .
      +---------+      +-------------+    .\n                       .......................................\n
      \                Figure 26: Clock Discipline Feedback Loop\n   Ordinarily, the
      pseudo-linear feedback loop described above operates\n   to discipline the system
      clock.  However, there are cases where a\n   non-linear algorithm offers considerable
      improvement.  One case is\n   when the discipline starts without knowledge of
      the intrinsic clock\n   frequency.  The pseudo-linear loop takes several hours
      to develop an\n   accurate measurement and during most of that time the poll
      interval\n   cannot be increased.  The non-linear loop described below does
      this\n   in 15 minutes.  Another case is when occasional bursts of large\n   jitter
      are present due to congested network links.  The state machine\n   described
      below resists error bursts lasting less than 15 minutes.\n   Figure 27 contains
      a summary of the variables and parameters\n   including the variable (lowercase)
      or parameter (uppercase) name,\n   formula name, and short description.  Unless
      noted otherwise, all\n   variables have assumed prefix c.  The variables t,
      tc, state, hyster,\n   and count are integers; the remaining variables are floating
      doubles.\n   The function of each will be explained in the algorithm descriptions\n
      \  below.\n                +--------+------------+--------------------------+\n
      \               | Name   | Formula    | Description              |\n                +--------+------------+--------------------------+\n
      \               | t      | timer      | seconds counter          |\n                |
      offset | theta      | combined offset          |\n                | resid  |
      theta_r    | residual offset          |\n                | freq   | phi        |
      clock frequency          |\n                | jitter | psi        | clock offset
      jitter      |\n                | wander | omega      | clock frequency wander
      \  |\n                | tc     | tau        | time constant (log2)     |\n                |
      state  | state      | state                    |\n                | adj    |
      adj        | frequency adjustment     |\n                | hyster | hyster     |
      hysteresis counter       |\n                | STEPT  | 125        | step threshold
      (.125 s)  |\n                | WATCH  | 900        | stepout thresh(s)        |\n
      \               | PANICT | 1000       | panic threshold (1000 s) |\n                |
      LIMIT  | 30         | hysteresis limit         |\n                | PGATE  |
      4          | hysteresis gate          |\n                | TC     | 16         |
      time constant scale      |\n                | AVG    | 8          | averaging
      constant       |\n                +--------+------------+--------------------------+\n
      \          Figure 27: Clock Discipline Variables and Parameters\n   The process
      terminates immediately if the offset is greater than the\n   panic threshold
      PANICT (1000 s).  The state transition function is\n   described by the rstclock()
      function in Appendix A.5.5.7.  Figure 28\n   shows the state transition function
      used by this routine.  It has\n   four columns showing, respectively, the state
      name, predicate and\n   action if the offset theta is less than the step threshold,
      the\n   predicate and actions otherwise, and finally some comments.\n      +-------+---------------------+-------------------+--------------+\n
      \     | State | theta < STEP        | theta > STEP      | Comments     |\n      +-------+---------------------+-------------------+--------------+\n
      \     | NSET  | ->FREQ              | ->FREQ            | no frequency |\n      |
      \      | adjust time         | step time         | file         |\n      +-------+---------------------+-------------------+--------------+\n
      \     | FSET  | ->SYNC              | ->SYNC            | frequency    |\n      |
      \      | adjust time         | step time         | file         |\n      +-------+---------------------+-------------------+--------------+\n
      \     | SPIK  | ->SYNC              | if < 900 s ->SPIK | outlier      |\n      |
      \      | adjust freq         | else ->SYNC       | detected     |\n      |       |
      adjust time         | step freq         |              |\n      |       |                     |
      step time         |              |\n      +-------+---------------------+-------------------+--------------+\n
      \     | FREQ  | if < 900 s ->FREQ   | if < 900 s ->FREQ | initial      |\n      |
      \      | else ->SYNC         | else ->SYNC       | frequency    |\n      |       |
      step freq           | step freq         |              |\n      |       | adjust
      time         | adjust time       |              |\n      +-------+---------------------+-------------------+--------------+\n
      \     | SYNC  | ->SYNC              | if < 900 s ->SPIK | normal       |\n      |
      \      | adjust freq         | else ->SYNC       | operation    |\n      |       |
      adjust time         | step freq         |              |\n      |       |                     |
      step time         |              |\n      +-------+---------------------+-------------------+--------------+\n
      \                  Figure 28: State Transition Function\n   In the table entries,
      the next state is identified by the arrow ->\n   with the actions listed below.
      \ Actions such as adjust time and\n   adjust frequency are implemented by the
      PLL/FLL feedback loop in the\n   local_clock() routine.  A step clock action
      is implemented by setting\n   the clock directly, but this is done only after
      the stepout threshold\n   WATCH (900 s) when the offset is more than the step
      threshold STEPT\n   (.125 s).  This resists clock steps under conditions of
      extreme\n   network congestion.\n   The jitter (psi) and wander (omega) statistics
      are computed using an\n   exponential average with weight factor AVG.  The time
      constant\n   exponent (tau) is determined by comparing psi with the magnitude
      of\n   the current offset theta.  If the offset is greater than PGATE (4)\n
      \  times the clock jitter, the hysteresis counter hyster is reduced by\n   two;
      otherwise, it is increased by one.  If hyster increases to the\n   upper limit
      LIMIT (30), tau is increased by one; if it decreases to\n   the lower limit
      -LIMIT (-30), tau is decreased by one.  Normally, tau\n   hovers near MAXPOLL,
      but quickly decreases if a temperature spike\n   causes a frequency surge.\n"
    title: 11.3.  Clock Discipline Algorithm
  title: 11.  System Process
- contents:
  - "12.  Clock-Adjust Process\n   The actual clock-adjust process runs at one-second
    intervals to add\n   the frequency correction and a fixed percentage of the residual\n
    \  offset theta_r.  The theta_r is, in effect, the exponential decay of\n   the
    theta value produced by the loop filter at each update.  The TC\n   parameter
    scales the time constant to match the poll interval for\n   convenience.  Note
    that the dispersion EPSILON increases by PHI at\n   each second.\n   The clock-adjust
    process includes a timer interrupt facility driving\n   the seconds counter c.t.
    \ It begins at zero when the service starts\n   and increments once each second.
    \ At each interrupt, the\n   clock_adjust() routine is called to incorporate the
    clock discipline\n   time and frequency adjustments, then the associations are
    scanned to\n   determine if the seconds counter equals or exceeds the p.next state\n
    \  variable defined in the next section.  If so, the poll process is\n   called
    to send a packet and compute the next p.next value.\n   An example of the clock-adjust
    process is shown by the clock_adjust()\n   routine in Appendix A.5.6.1.\n"
  title: 12.  Clock-Adjust Process
- contents:
  - "13.  Poll Process\n   Each association supports a poll process that runs at regular\n
    \  intervals to construct and send packets in symmetric, client, and\n   broadcast
    server associations.  It runs continuously, whether or not\n   servers are reachable
    in order to manage the clock filter and reach\n   register.\n"
  - contents:
    - "13.1.  Poll Process Variables\n   Figure 29 summarizes the common names, formula
      names, and a short\n   description of the poll process variables (lowercase)
      and parameters\n   (uppercase).  Unless noted otherwise, all variables have
      assumed\n   prefix p.\n                   +---------+---------+--------------------+\n
      \                  | Name    | Formula | Description        |\n                   +---------+---------+--------------------+\n
      \                  | hpoll   | hpoll   | host poll exponent |\n                   |
      last    | last    | last poll time     |\n                   | next    | next
      \   | next poll time     |\n                   | reach   | reach   | reach register
      \    |\n                   | unreach | unreach | unreach counter    |\n                   |
      UNREACH | 24      | unreach limit      |\n                   | BCOUNT  | 8       |
      burst count        |\n                   | BURST   | flag    | burst enable
      \      |\n                   | IBURST  | flag    | iburst enable      |\n                   +---------+---------+--------------------+\n
      \            Figure 29: Poll Process Variables and Parameters\n   The poll process
      variables are allocated in the association data\n   structure along with the
      peer process variables.  The following is a\n   detailed description of the
      variables.  The parameters will be called\n   out in the following text.\n   hpoll:
      signed integer representing the poll exponent, in log2 seconds\n   last: integer
      representing the seconds counter when the most recent\n   packet was sent\n
      \  next: integer representing the seconds counter when the next packet\n   is
      to be sent\n   reach: 8-bit integer shift register shared by the peer and poll\n
      \  processes\n   unreach: integer representing the number of seconds the server
      has\n   been unreachable\n"
    title: 13.1.  Poll Process Variables
  - contents:
    - "13.2.  Poll Process Operations\n   As described previously, once each second
      the clock-adjust process is\n   called.  This routine calls the poll routine
      for each association in\n   turn.  If the time for the next poll message is
      greater than the\n   seconds counter, the routine returns immediately.  Symmetric
      (modes\n   1, 2), client (mode 3), and broadcast server (mode 5) associations\n
      \  routinely send packets.  A broadcast client (mode 6) association runs\n   the
      routine to update the reach and unreach variables, but does not\n   send packets.
      \ The poll process calls the transmit process to send a\n   packet.  If in a
      burst (burst > 0), nothing further is done except\n   call the poll update routine
      to set the next poll interval.\n   If not in a burst, the reach variable is
      shifted left by one bit,\n   with zero replacing the rightmost bit.  If the
      server has not been\n   heard for the last three poll intervals, the clock filter
      routine is\n   called to increase the dispersion.  An example is shown in\n
      \  Appendix A.5.7.3.\n   If the BURST flag is lit and the server is reachable
      and a valid\n   source of synchronization is available, the client sends a burst
      of\n   BCOUNT (8) packets at each poll interval.  The interval between\n   packets
      in the burst is two seconds.  This is useful to accurately\n   measure jitter
      with long poll intervals.  If the IBURST flag is lit\n   and this is the first
      packet sent when the server has been\n   unreachable, the client sends a burst.
      \ This is useful to quickly\n   reduce the synchronization distance below the
      distance threshold and\n   synchronize the clock.\n   If the P_MANY flag is
      lit in the p.flags word of the association,\n   this is a manycast client association.
      \ Manycast client associations\n   send client mode packets to designated multicast
      group addresses at\n   MINPOLL intervals.  The association starts out with a
      TTL of 1.  If\n   by the time of the next poll there are fewer than MINCLOCK
      servers\n   have been mobilized, the ttl is increased by one.  If the ttl reaches\n
      \  the limit TTLMAX, without finding MINCLOCK servers, the poll interval\n   increases
      until reaching BEACON, when it starts over from the\n   beginning.\n   The poll()
      routine includes a feature that backs off the poll\n   interval if the server
      becomes unreachable.  If reach is nonzero, the\n   server is reachable and unreach
      is set to zero; otherwise, unreach is\n   incremented by one for each poll to
      the maximum UNREACH.  Thereafter\n   for each poll hpoll is increased by one,
      which doubles the poll\n   interval up to the maximum MAXPOLL determined by
      the poll_update()\n   routine.  When the server again becomes reachable, unreach
      is set to\n   zero, hpoll is reset to the tc system variable, and operation
      resumes\n   normally.\n   A packet is sent by the transmit process.  Some header
      values are\n   copied from the peer variables left by a previous packet and
      others\n   from the system variables.  Figure 30 shows which values are copied\n
      \  to each header field.  In those implementations, using floating\n   double
      data types for root delay and root dispersion, these must be\n   converted to
      NTP short format.  All other fields are either copied\n   intact from peer and
      system variables or struck as a timestamp from\n   the system clock.\n                   +-----------------------------------+\n
      \                  | Packet Variable <--   Variable    |\n                   +-----------------------------------+\n
      \                  | x.leap        <--     s.leap      |\n                   |
      x.version     <--     s.version   |\n                   | x.mode        <--
      \    s.mode      |\n                   | x.stratum     <--     s.stratum   |\n
      \                  | x.poll        <--     s.poll      |\n                   |
      x.precision   <--     s.precision |\n                   | x.rootdelay   <--
      \    s.rootdelay |\n                   | x.rootdisp    <--     s.rootdisp  |\n
      \                  | x.refid       <--     s.refid     |\n                   |
      x.reftime     <--     s.reftime   |\n                   | x.org         <--
      \    p.xmt       |\n                   | x.rec         <--     p.dst       |\n
      \                  | x.xmt         <--     clock       |\n                   |
      x.keyid       <--     p.keyid     |\n                   | x.digest      <--
      \    md5 digest  |\n                   +-----------------------------------+\n
      \                  Figure 30: xmit_packet Packet Header\n   The poll update
      routine is called when a valid packet is received and\n   immediately after
      a poll message has been sent.  If in a burst, the\n   poll interval is fixed
      at 2 s; otherwise, the host poll exponent\n   hpoll is set to the minimum of
      ppoll from the last packet received\n   and hpoll from the poll routine, but
      not less than MINPOLL or greater\n   than MAXPOLL.  Thus, the clock discipline
      can be oversampled but not\n   undersampled.  This is necessary to preserve
      subnet dynamic behavior\n   and protect against protocol errors.\n   The poll
      exponent is converted to an interval, which, when added to\n   the last poll
      time variable, determines the value of the next poll\n   time variable.  Finally,
      the last poll time variable is set to the\n   current seconds counter.\n"
    title: 13.2.  Poll Process Operations
  title: 13.  Poll Process
- contents:
  - "14.  Simple Network Time Protocol (SNTP)\n   Primary servers and clients complying
    with a subset of NTP, called\n   the Simple Network Time Protocol (SNTPv4) [RFC4330],
    do not need to\n   implement the mitigation algorithms described in Section 9
    and\n   following sections.  SNTP is intended for primary servers equipped\n   with
    a single reference clock, as well as for clients with a single\n   upstream server
    and no dependent clients.  The fully developed NTPv4\n   implementation is intended
    for secondary servers with multiple\n   upstream servers and multiple downstream
    servers or clients.  Other\n   than these considerations, NTP and SNTP servers
    and clients are\n   completely interoperable and can be intermixed in NTP subnets.\n
    \  An SNTP primary server implementing the on-wire protocol described in\n   Section
    8 has no upstream servers except a single reference clock.\n   In principle, it
    is indistinguishable from an NTP primary server that\n   has the mitigation algorithms
    and therefore capable of mitigating\n   between multiple reference clocks.\n   Upon
    receiving a client request, an SNTP primary server constructs\n   and sends the
    reply packet as described in Figure 31.  Note that the\n   dispersion field in
    the packet header must be updated as described in\n   Section 5.\n                   +-----------------------------------+\n
    \                  | Packet Variable <--   Variable    |\n                   +-----------------------------------+\n
    \                  | x.leap        <--     s.leap      |\n                   |
    x.version     <--     r.version   |\n                   | x.mode        <--     4
    \          |\n                   | x.stratum     <--     s.stratum   |\n                   |
    x.poll        <--     r.poll      |\n                   | x.precision   <--     s.precision
    |\n                   | x.rootdelay   <--     s.rootdelay |\n                   |
    x.rootdisp    <--     s.rootdisp  |\n                   | x.refid       <--     s.refid
    \    |\n                   | x.reftime     <--     s.reftime   |\n                   |
    x.org         <--     r.xmt       |\n                   | x.rec         <--     r.dst
    \      |\n                   | x.xmt         <--     clock       |\n                   |
    x.keyid       <--     r.keyid     |\n                   | x.digest      <--     md5
    digest  |\n                   +-----------------------------------+\n                    Figure
    31: fast_xmit Packet Header\n   An SNTP client implementing the on-wire protocol
    has a single server\n   and no dependent clients.  It can operate with any subset
    of the NTP\n   on-wire protocol, the simplest approach using only the transmit\n
    \  timestamp of the server packet and ignoring all other fields.\n   However,
    the additional complexity to implement the full on-wire\n   protocol is minimal
    so that a full implementation is encouraged.\n"
  title: 14.  Simple Network Time Protocol (SNTP)
- contents:
  - "15.  Security Considerations\n   NTP security requirements are even more stringent
    than most other\n   distributed services.  First, the operation of the authentication\n
    \  mechanism and the time synchronization mechanism are inextricably\n   intertwined.
    \ Reliable time synchronization requires cryptographic\n   keys that are valid
    only over a designated time interval; but, time\n   intervals can be enforced
    only when participating servers and clients\n   are reliably synchronized to UTC.
    \ In addition, the NTP subnet is\n   hierarchical by nature, so time and trust
    flow from the primary\n   servers at the root through secondary servers to the
    clients at the\n   leaves.\n   An NTP client can claim to have authentic time
    to dependent\n   applications only if all servers on the path to the primary servers\n
    \  are authenticated.  In NTP each server authenticates the next lower\n   stratum
    servers and authenticates by induction the lowest stratum\n   (primary) servers.
    \ It is important to note that authentication in\n   the context of NTP does not
    necessarily imply the time is correct.\n   An NTP client mobilizes a number of
    concurrent associations with\n   different servers and uses a crafted agreement
    algorithm to pluck\n   truechimers from the population possibly including falsetickers.\n
    \  The NTP specification assumes that the goal of the intruder is to\n   inject
    false time values, disrupt the protocol, or clog the network,\n   servers, or
    clients with spurious packets that exhaust resources and\n   deny service to legitimate
    applications.  There are a number of\n   defense mechanisms already built in the
    NTP architecture, protocol,\n   and algorithms.  The on-wire timestamp exchange
    scheme is inherently\n   resistant to spoofing, packet-loss, and replay attacks.
    \ The\n   engineered clock filter, selection and clustering algorithms are\n   designed
    to defend against evil cliques of Byzantine traitors.  While\n   not necessarily
    designed to defeat determined intruders, these\n   algorithms and accompanying
    sanity checks have functioned well over\n   the years to deflect improperly operating
    but presumably friendly\n   scenarios.  However, these mechanisms do not securely
    identify and\n   authenticate servers to clients.  Without specific further\n
    \  protection, an intruder can inject any or all of the following\n   attacks:\n
    \  1.  An intruder can intercept and archive packets forever, as well as\n       all
    the public values ever generated and transmitted over the\n       net.\n   2.
    \ An intruder can generate packets faster than the server, network\n       or
    client can process them, especially if they require expensive\n       cryptographic
    computations.\n   3.  In a wiretap attack, the intruder can intercept, modify,
    and\n       replay a packet.  However, it cannot permanently prevent onward\n
    \      transmission of the original packet; that is, it cannot break the\n       wire,
    only tell lies and congest it.  Generally, the modified\n       packet cannot
    arrive at the victim before the original packet,\n       nor does it have the
    server private keys or identity parameters.\n   4.  In a middleman or masquerade
    attack, the intruder is positioned\n       between the server and client, so it
    can intercept, modify and\n       replay a packet and prevent onward transmission
    of the original\n       packet.  However, the middleman does not have the server
    private\n       keys.\n   The NTP security model assumes the following possible
    limitations:\n   1.  The running times for public key algorithms are relatively
    long\n       and highly variable.  In general, the performance of the time\n       synchronization
    function is badly degraded if these algorithms\n       must be used for every
    NTP packet.\n   2.  In some modes of operation, it is not feasible for a server
    to\n       retain state variables for every client.  It is however feasible\n
    \      to regenerated them for a client upon arrival of a packet from\n       that
    client.\n   3.  The lifetime of cryptographic values must be enforced, which\n
    \      requires a reliable system clock.  However, the sources that\n       synchronize
    the system clock must be trusted.  This circular\n       interdependence of the
    timekeeping and authentication functions\n       requires special handling.\n
    \  4.  Client security functions must involve only public values\n       transmitted
    over the net.  Private values must never be disclosed\n       beyond the machine
    on which they were created, except in the case\n       of a special trusted agent
    (TA) assigned for this purpose.\n   Unlike the Secure Shell (SSH) security model,
    where the client must\n   be securely authenticated to the server, in NTP the
    server must be\n   securely authenticated to the client.  In SSH, each different\n
    \  interface address can be bound to a different name, as returned by a\n   reverse-DNS
    query.  In this design, separate public/private key pairs\n   may be required
    for each interface address with a distinct name.  A\n   perceived advantage of
    this design is that the security compartment\n   can be different for each interface.
    \ This allows a firewall, for\n   instance, to require some interfaces to authenticate
    the client and\n   others not.\n   In the case of NTP as specified herein, NTP
    broadcast clients are\n   vulnerable to disruption by misbehaving or hostile SNTP
    or NTP\n   broadcast servers elsewhere in the Internet.  Such disruption can be\n
    \  minimized by several approaches.  Filtering can be employed to limit\n   the
    access of NTP clients to known or trusted NTP broadcast servers.\n   Such filtering
    will prevent malicious traffic from reaching the NTP\n   clients.  Cryptographic
    authentication at the client will only allow\n   timing information from properly
    signed NTP messages to be utilized\n   in synchronizing its clock.  Higher levels
    of authentication may be\n   gained by the use of the Autokey mechanism [RFC5906].\n
    \  Section 8 describes a potential security concern with the replay of\n   client
    requests.  Following the recommendations in that section\n   provides protection
    against such attacks.\n   It should be noted that this specification is describing
    an existing\n   implementation.  While the security shortfalls of the MD5 algorithm\n
    \  are well-known, its use in the NTP specification is consistent with\n   widescale
    deployment in the Internet community.\n"
  title: 15.  Security Considerations
- contents:
  - "16.  IANA Considerations\n   UDP/TCP Port 123 was previously assigned by IANA
    for this protocol.\n   The IANA has assigned the IPv4 multicast group address
    224.0.1.1 and\n   the IPv6 multicast address ending :101 for NTP.  This document\n
    \  introduces NTP extension fields allowing for the development of\n   future
    extensions to the protocol, where a particular extension is to\n   be identified
    by the Field Type sub-field within the extension field.\n   IANA has established
    and will maintain a registry for Extension Field\n   Types associated with this
    protocol, populating this registry with no\n   initial entries.  As future needs
    arise, new Extension Field Types\n   may be defined.  Following the policies outlined
    in [RFC5226], new\n   values are to be defined by IETF Review.\n   The IANA has
    created a new registry for NTP Reference Identifier\n   codes.  This includes
    the current codes defined in Section 7.3, and\n   may be extended on a First-Come-First-Serve
    (FCFS) basis.  The format\n   of the registry is:\n     +------+----------------------------------------------------------+\n
    \    | ID   | Clock Source                                             |\n     +------+----------------------------------------------------------+\n
    \    | GOES | Geosynchronous Orbit Environment Satellite               |\n     |
    GPS  | Global Position System                                   |\n     | ...
    \ | ...                                                      |\n     +------+----------------------------------------------------------+\n
    \                  Figure 32: Reference Identifier Codes\n   The IANA has created
    a new registry for NTP Kiss-o'-Death codes.\n   This includes the current codes
    defined in Section 7.4, and may be\n   extended on a FCFS basis.  The format of
    the registry is:\n   +------+------------------------------------------------------------+\n
    \  | Code |                           Meaning                          |\n   +------+------------------------------------------------------------+\n
    \  | ACST | The association belongs to a unicast server.               |\n   |
    AUTH | Server authentication failed.                              |\n   | ...
    \ | ...                                                        |\n   +------+------------------------------------------------------------+\n
    \                          Figure 33: Kiss Codes\n   For both Reference Identifiers
    and Kiss-o'-Death codes, IANA is\n   requested to never assign a code beginning
    with the character \"X\", as\n   this is reserved for experimentation and development.\n"
  title: 16.  IANA Considerations
- contents:
  - "17.  Acknowledgements\n   The editors would like to thank Karen O'Donoghue, Brian
    Haberman,\n   Greg Dowd, Mark Elliot, Harlan Stenn, Yaakov Stein, Stewart Bryant,\n
    \  and Danny Mayer for technical reviews and specific text contributions\n   to
    this document.\n"
  title: 17.  Acknowledgements
- contents:
  - '18.  References

    '
  - contents:
    - "18.1.  Normative References\n   [RFC0768]       Postel, J., \"User Datagram
      Protocol\", STD 6, RFC 768,\n                   August 1980.\n   [RFC0791]       Postel,
      J., \"Internet Protocol\", STD 5, RFC 791,\n                   September 1981.\n
      \  [RFC0793]       Postel, J., \"Transmission Control Protocol\", STD 7,\n                   RFC
      793, September 1981.\n   [RFC1321]       Rivest, R., \"The MD5 Message-Digest
      Algorithm\",\n                   RFC 1321, April 1992.\n   [RFC2119]       Bradner,
      S., \"Key words for use in RFCs to Indicate\n                   Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n"
    title: 18.1.  Normative References
  - contents:
    - "18.2.  Informative References\n   [CGPM]          Bureau International des
      Poids et Mesures, \"Comptes\n                   Rendus de la 15e CGPM\", 1976.\n
      \  [ITU-R_TF.460]  International Telecommunications Union, \"ITU-R TF.460\n
      \                  Standard-frequency and time-signal emissions\",\n                   February
      2002.\n   [RFC1305]       Mills, D., \"Network Time Protocol (Version 3)\n                   Specification,
      Implementation and Analysis\",\n                   RFC 1305, March 1992.\n   [RFC1345]
      \      Simonsen, K., \"Character Mnemonics and Character\n                   Sets\",
      RFC 1345, June 1992.\n   [RFC4330]       Mills, D., \"Simple Network Time Protocol
      (SNTP)\n                   Version 4 for IPv4, IPv6 and OSI\", RFC 4330,\n                   January
      2006.\n   [RFC5226]       Narten, T. and H. Alvestrand, \"Guidelines for Writing\n
      \                  an IANA Considerations Section in RFCs\", BCP 26,\n                   RFC
      5226, May 2008.\n   [RFC5906]       Haberman, B., Ed. and D. Mills, \"Network
      Time\n                   Protocol Version 4: Autokey Specification\", RFC 5906,\n
      \                  June 2010.\n   [ref6]          Marzullo and S. Owicki, \"Maintaining
      the time in a\n                   distributed system\", ACM Operating Systems
      Review 19,\n                   July 1985.\n   [ref7]          Mills, D.L., \"Computer
      Network Time Synchronization -\n                   the Network Time Protocol\",
      CRC Press, 304 pp, 2006.\n   [ref9]          Mills, D.L., Electrical and Computer
      Engineering\n                   Technical Report 06-6-1, NDSS, June 2006, \"Network\n
      \                  Time Protocol Version 4 Reference and Implementation\n                   Guide\",
      2006.\n"
    title: 18.2.  Informative References
  title: 18.  References
- contents:
  - "Appendix A.  Code Skeleton\n   This appendix is intended to describe the protocol
    and algorithms of\n   an implementation in a general way using what is called
    a code\n   skeleton program.  This consists of a set of definitions, structures,\n
    \  and code fragments that illustrate the protocol operations without\n   the
    complexities of an actual implementation of the protocol.  This\n   program is
    not an executable and is not designed to run in the\n   ordinary sense.\n   Most
    of the features of the reference implementation are included\n   here, with the
    following exceptions: there are no provisions for\n   reference clocks or public
    key (Autokey) cryptography.  There is no\n   huff-n'-puff filter, anti-clockhop
    hysteresis, or monitoring\n   provisions.  Many of the values that can be tinkered
    in the reference\n   implementation are assumed constants here.  There are only
    minimal\n   provisions for the kiss-o'-death packet and no responding code.\n
    \  The program is not intended to be fast or compact, just to\n   demonstrate
    the algorithms with sufficient fidelity to understand how\n   they work.  The
    code skeleton consists of eight segments, a header\n   segment included by each
    of the other segments, plus a code segment\n   for the main program, kernel I/O
    and system clock interfaces, and\n   peer, system, clock_adjust, and poll processes.
    \ These are presented\n   in order below along with definitions and variables
    specific to each\n   process.\n"
  - contents:
    - 'A.1.  Global Definitions

      '
    - contents:
      - 'A.1.1.  Definitions, Constants, Parameters

        '
      - '#include <math.h>               /* avoids complaints about sqrt() */

        '
      - '#include <sys/time.h>           /* for gettimeofday() and friends */

        '
      - '#include <stdlib.h>             /* for malloc() and friends */

        '
      - '#include <string.h>             /* for memset() */

        '
      - "/*\n * Data types\n *\n * This program assumes the int data type is 32 bits
        and the long data\n * type is 64 bits.  The native data type used in most
        calculations is\n * floating double.  The data types used in some packet header
        fields\n * require conversion to and from this representation.  Some header\n
        * fields involve partitioning an octet, here represented by individual\n *
        octets.\n *\n * The 64-bit NTP timestamp format used in timestamp calculations
        is\n * unsigned seconds and fraction with the decimal point to the left of\n
        * bit 32.  The only operation permitted with these values is\n * subtraction,
        yielding a signed 31-bit difference.  The 32-bit NTP\n * short format used
        in delay and dispersion calculations is seconds and\n * fraction with the
        decimal point to the left of bit 16.  The only\n * operations permitted with
        these values are addition and\n * multiplication by a constant.\n *\n * The
        IPv4 address is 32 bits, while the IPv6 address is 128 bits.  The\n * message
        digest field is 128 bits as constructed by the MD5 algorithm.\n * The precision
        and poll interval fields are signed log2 seconds.\n */\n"
      - 'typedef unsigned long long tstamp;   /* NTP timestamp format */

        '
      - 'typedef unsigned int tdist;     /* NTP short format */

        '
      - 'typedef unsigned long ipaddr;   /* IPv4 or IPv6 address */

        '
      - 'typedef unsigned long digest;   /* md5 digest */

        '
      - 'typedef signed char s_char;     /* precision and poll interval (log2) */

        '
      - "/*\n * Timestamp conversion macroni\n */\n"
      - '#define FRIC        65536.                  /* 2^16 as a double */

        '
      - '#define D2FP(r)     ((tdist)((r) * FRIC))   /* NTP short */

        '
      - '#define FP2D(r)     ((double)(r) / FRIC)

        '
      - '#define FRAC       4294967296.             /* 2^32 as a double */

        '
      - '#define D2LFP(a)   ((tstamp)((a) * FRAC))  /* NTP timestamp */

        '
      - '#define LFP2D(a)   ((double)(a) / FRAC)

        '
      - "#define U2LFP(a)   (((unsigned long long) \\\n                       ((a).tv_sec
        + JAN_1970) << 32) + \\\n                       (unsigned long long) \\\n
        \                      ((a).tv_usec / 1e6 * FRAC))\n"
      - "/*\n * Arithmetic conversions\n */\n"
      - "#define LOG2D(a)        ((a) < 0 ? 1. / (1L << -(a)) : \\\n                            1L
        << (a))          /* poll, etc. */\n"
      - '#define SQUARE(x)       (x * x)

        '
      - '#define SQRT(x)         (sqrt(x))

        '
      - "/*\n * Global constants.  Some of these might be converted to variables\n
        * that can be tinkered by configuration or computed on-the-fly.  For\n * instance,
        the reference implementation computes PRECISION on-the-fly\n * and provides
        performance tuning for the defines marked with % below.\n */\n"
      - '#define VERSION         4       /* version number */

        '
      - '#define MINDISP         .01     /* % minimum dispersion (s) */

        '
      - '#define MAXDISP         16      /* maximum dispersion (s) */

        '
      - '#define MAXDIST         1       /* % distance threshold (s) */

        '
      - '#define NOSYNC          0x3     /* leap unsync */

        '
      - '#define MAXSTRAT        16      /* maximum stratum (infinity metric) */

        '
      - '#define MINPOLL         6       /* % minimum poll interval (64 s)*/

        '
      - '#define MAXPOLL         17      /* % maximum poll interval (36.4 h) */

        '
      - '#define MINCLOCK        3       /* minimum manycast survivors */

        '
      - '#define MAXCLOCK        10      /* maximum manycast candidates */

        '
      - '#define TTLMAX          8       /* max ttl manycast */

        '
      - '#define BEACON          15      /* max interval between beacons */

        '
      - '#define PHI             15e-6   /* % frequency tolerance (15 ppm) */

        '
      - '#define NSTAGE          8       /* clock register stages */

        '
      - '#define NMAX            50      /* maximum number of peers */

        '
      - '#define NSANE           1       /* % minimum intersection survivors */

        '
      - '#define NMIN            3       /* % minimum cluster survivors */

        '
      - "/*\n * Global return values\n */\n"
      - '#define TRUE            1       /* boolean true */

        '
      - '#define FALSE           0       /* boolean false */

        '
      - "/*\n * Local clock process return codes\n */\n"
      - '#define IGNORE          0       /* ignore */

        '
      - '#define SLEW            1       /* slew adjustment */

        '
      - '#define STEP            2       /* step adjustment */

        '
      - '#define PANIC           3       /* panic - no adjustment */

        '
      - "/*\n * System flags\n */\n"
      - '#define S_FLAGS         0       /* any system flags */

        '
      - '#define S_BCSTENAB      0x1     /* enable broadcast client */

        '
      - "/*\n * Peer flags\n */\n"
      - '#define P_FLAGS         0       /* any peer flags */

        '
      - '#define P_EPHEM         0x01    /* association is ephemeral */

        '
      - '#define P_BURST         0x02    /* burst enable */

        '
      - '#define P_IBURST        0x04    /* intial burst enable */

        '
      - '#define P_NOTRUST       0x08    /* authenticated access */

        '
      - '#define P_NOPEER        0x10    /* authenticated mobilization */

        '
      - '#define P_MANY          0x20    /* manycast client */

        '
      - "/*\n * Authentication codes\n */\n"
      - '#define A_NONE          0       /* no authentication */

        '
      - '#define A_OK            1       /* authentication OK */

        '
      - '#define A_ERROR         2       /* authentication error */

        '
      - '#define A_CRYPTO        3       /* crypto-NAK */

        '
      - "/*\n * Association state codes\n */\n"
      - '#define X_INIT          0       /* initialization */

        '
      - '#define X_STALE         1       /* timeout */

        '
      - '#define X_STEP          2       /* time step */

        '
      - '#define X_ERROR         3       /* authentication error */

        '
      - '#define X_CRYPTO        4       /* crypto-NAK received */

        '
      - '#define X_NKEY          5       /* untrusted key */

        '
      - "/*\n * Protocol mode definitions\n */\n"
      - '#define M_RSVD          0       /* reserved */

        '
      - '#define M_SACT          1       /* symmetric active */

        '
      - '#define M_PASV          2       /* symmetric passive */

        '
      - '#define M_CLNT          3       /* client */

        '
      - '#define M_SERV          4       /* server */

        '
      - '#define M_BCST          5       /* broadcast server */

        '
      - '#define M_BCLN          6       /* broadcast client */

        '
      - "/*\n * Clock state definitions\n */\n"
      - '#define NSET            0       /* clock never set */

        '
      - '#define FSET            1       /* frequency set from file */

        '
      - '#define SPIK            2       /* spike detected */

        '
      - '#define FREQ            3       /* frequency mode */

        '
      - '#define SYNC            4       /* clock synchronized */

        '
      - '#define min(a, b)   ((a) < (b) ? (a) : (b))

        '
      - '#define max(a, b)   ((a) < (b) ? (b) : (a))

        '
      title: A.1.1.  Definitions, Constants, Parameters
    - contents:
      - 'A.1.2.  Packet Data Structures

        '
      - "/*\n * The receive and transmit packets may contain an optional message\n
        * authentication code (MAC) consisting of a key identifier (keyid) and\n *
        message digest (mac in the receive structure and dgst in the transmit\n *
        structure).  NTPv4 supports optional extension fields that\n * are inserted
        after the header and before the MAC, but these are\n * not described here.\n
        *\n * Receive packet\n *\n * Note the dst timestamp is not part of the packet
        itself.  It is\n * captured upon arrival and returned in the receive buffer
        along with\n * the buffer length and data.  Note that some of the char fields
        are\n * packed in the actual header, but the details are omitted here.\n */\n"
      - "struct r {\n        ipaddr  srcaddr;        /* source (remote) address */\n
        \       ipaddr  dstaddr;        /* destination (local) address */\n        char
        \   version;        /* version number */\n        char    leap;           /*
        leap indicator */\n        char    mode;           /* mode */\n        char
        \   stratum;        /* stratum */\n        char    poll;           /* poll
        interval */\n        s_char  precision;      /* precision */\n        tdist
        \  rootdelay;      /* root delay */\n        tdist   rootdisp;       /* root
        dispersion */\n        char    refid;          /* reference ID */\n        tstamp
        \ reftime;        /* reference time */\n        tstamp  org;            /*
        origin timestamp */\n        tstamp  rec;            /* receive timestamp
        */\n        tstamp  xmt;            /* transmit timestamp */\n        int
        \    keyid;          /* key ID */\n        digest  mac;            /* message
        digest */\n        tstamp  dst;            /* destination timestamp */\n"
      - '} r;

        '
      - "/*\n * Transmit packet\n */\n"
      - "struct x {\n        ipaddr  dstaddr;        /* source (local) address */\n
        \       ipaddr  srcaddr;        /* destination (remote) address */\n        char
        \   version;        /* version number */\n        char    leap;           /*
        leap indicator */\n        char    mode;           /* mode */\n        char
        \   stratum;        /* stratum */\n        char    poll;           /* poll
        interval */\n        s_char  precision;      /* precision */\n        tdist
        \  rootdelay;      /* root delay */\n        tdist   rootdisp;       /* root
        dispersion */\n        char    refid;          /* reference ID */\n        tstamp
        \ reftime;        /* reference time */\n        tstamp  org;            /*
        origin timestamp */\n        tstamp  rec;            /* receive timestamp
        */\n        tstamp  xmt;            /* transmit timestamp */\n        int
        \    keyid;          /* key ID */\n        digest  dgst;           /* message
        digest */\n"
      - '} x;

        '
      title: A.1.2.  Packet Data Structures
    - contents:
      - "A.1.3.  Association Data Structures\n   /*\n    * Filter stage structure.
        \ Note the t member in this and other\n    * structures refers to process
        time, not real time.  Process time\n    * increments by one second for every
        elapsed second of real time.\n    */\n   struct f {\n           tstamp  t;
        \             /* update time */\n           double  offset;         /* clock
        ofset */\n           double  delay;          /* roundtrip delay */\n           double
        \ disp;           /* dispersion */\n   } f;\n   /*\n    * Association structure.
        \ This is shared between the peer process\n    * and poll process.\n    */\n
        \  struct p {\n           /*\n            * Variables set by configuration\n
        \           */\n           ipaddr  srcaddr;        /* source (remote) address
        */\n           ipaddr  dstaddr;        /* destination (local) address */\n
        \          char    version;        /* version number */\n           char    hmode;
        \         /* host mode */\n           int     keyid;          /* key identifier
        */\n           int     flags;          /* option flags */\n           /*\n
        \           * Variables set by received packet\n            */\n           char
        \   leap;           /* leap indicator */\n           char    pmode;          /*
        peer mode */\n           char    stratum;        /* stratum */\n           char
        \   ppoll;          /* peer poll interval */\n           double  rootdelay;
        \     /* root delay */\n           double  rootdisp;       /* root dispersion
        */\n           char    refid;          /* reference ID */\n           tstamp
        \ reftime;        /* reference time */\n   #define begin_clear org         /*
        beginning of clear area */\n           tstamp  org;            /* originate
        timestamp */\n           tstamp  rec;            /* receive timestamp */\n
        \          tstamp  xmt;            /* transmit timestamp */\n           /*\n
        \           * Computed data\n            */\n           double  t;              /*
        update time */\n           struct f f[NSTAGE];     /* clock filter */\n           double
        \ offset;         /* peer offset */\n           double  delay;          /*
        peer delay */\n           double  disp;           /* peer dispersion */\n
        \          double  jitter;         /* RMS jitter */\n           /*\n            *
        Poll process variables\n            */\n           char    hpoll;          /*
        host poll interval */\n           int     burst;          /* burst counter
        */\n           int     reach;          /* reach register */\n           int
        \    ttl;            /* ttl (manycast) */\n   #define end_clear unreach       /*
        end of clear area */\n           int     unreach;        /* unreach counter
        */\n           int     outdate;        /* last poll time */\n           int
        \    nextdate;       /* next poll time */\n   } p;\n"
      title: A.1.3.  Association Data Structures
    - contents:
      - "A.1.4.  System Data Structures\n   /*\n    * Chime list.  This is used by
        the intersection algorithm.\n    */\n   struct m {                      /*
        m is for Marzullo */\n           struct p *p;            /* peer structure
        pointer */\n           int     type;           /* high +1, mid 0, low -1 */\n
        \          double  edge;           /* correctness interval edge */\n   } m;\n
        \  /*\n    * Survivor list.  This is used by the clustering algorithm.\n    */\n
        \  struct v {\n           struct p *p;            /* peer structure pointer
        */\n           double  metric;         /* sort metric */\n   } v;\n   /*\n
        \   * System structure\n    */\n   struct s {\n           tstamp  t;              /*
        update time */\n           char    leap;           /* leap indicator */\n
        \          char    stratum;        /* stratum */\n           char    poll;
        \          /* poll interval */\n           char    precision;      /* precision
        */\n           double  rootdelay;      /* root delay */\n           double
        \ rootdisp;       /* root dispersion */\n           char    refid;          /*
        reference ID */\n           tstamp  reftime;        /* reference time */\n
        \          struct m m[NMAX];       /* chime list */\n           struct v v[NMAX];
        \      /* survivor list */\n           struct p *p;            /* association
        ID */\n           double  offset;         /* combined offset */\n           double
        \ jitter;         /* combined jitter */\n           int     flags;          /*
        option flags */\n           int     n;              /* number of survivors
        */\n   } s;\n"
      title: A.1.4.  System Data Structures
    - contents:
      - "A.1.5.  Local Clock Data Structures\n   /*\n    * Local clock structure\n
        \   */\n   struct c {\n           tstamp  t;              /* update time */\n
        \          int     state;          /* current state */\n           double
        \ offset;         /* current offset */\n           double  last;           /*
        previous offset */\n           int     count;          /* jiggle counter */\n
        \          double  freq;           /* frequency */\n           double  jitter;
        \        /* RMS jitter */\n           double  wander;         /* RMS wander
        */\n   } c;\n"
      title: A.1.5.  Local Clock Data Structures
    - contents:
      - "A.1.6.  Function Prototypes\n  /*\n   * Peer process\n   */\n  void    receive(struct
        r *);    /* receive packet */\n  void    packet(struct p *, struct r *); /*
        process packet */\n  void    clock_filter(struct p *, double, double, double);
        /* filter */\n  double  root_dist(struct p *);  /* calculate root distance
        */\n  int     fit(struct p *);        /* determine fitness of server */\n
        \ void    clear(struct p *, int); /* clear association */\n  int     access(struct
        r *);     /* determine access restrictions */\n  /*\n   * System process\n
        \  */\n  int     main();                 /* main program */\n  void    clock_select();
        \        /* find the best clocks */\n  void    clock_update(struct p *); /*
        update the system clock */\n  void    clock_combine();        /* combine the
        offsets */\n  /*\n   * Local clock process\n   */\n  int     local_clock(struct
        p *, double); /* clock discipline */\n  void    rstclock(int, double, double);
        /* clock state transition */\n  /*\n   * Clock adjust process\n   */\n  void
        \   clock_adjust();         /* one-second timer process */\n  /*\n   * Poll
        process\n   */\n  void    poll(struct p *);               /* poll process
        */\n  void    poll_update(struct p *, int); /* update the poll interval */\n
        \ void    peer_xmit(struct p *);  /* transmit a packet */\n  void    fast_xmit(struct
        r *, int, int); /* transmit a reply packet */\n  /*\n   * Utility routines\n
        \  */\n  digest  md5(int);               /* generate a message digest */\n
        \ struct p *mobilize(ipaddr, ipaddr, int, int, int, int); /* mobilize */\n
        \ struct p *find_assoc(struct r *); /* search the association table */\n  /*\n
        \  * Kernel interface\n   */\n  struct r *recv_packet();        /* wait for
        packet */\n  void    xmit_packet(struct x *); /* send packet */\n  void    step_time(double);
        \     /* step time */\n  void    adjust_time(double);    /* adjust (slew)
        time */\n  tstamp  get_time();             /* read time */\n"
      title: A.1.6.  Function Prototypes
    title: A.1.  Global Definitions
  - contents:
    - 'A.2.  Main Program and Utility Routines

      '
    - "/*\n * Definitions\n */\n"
    - '#define PRECISION       -18     /* precision (log2 s)  */

      '
    - '#define IPADDR          0       /* any IP address */

      '
    - '#define MODE            0       /* any NTP mode */

      '
    - '#define KEYID           0       /* any key identifier */

      '
    - "/*\n * main() - main program\n */\n"
    - 'int

      '
    - 'main()

      '
    - "{\n        struct p *p;            /* peer structure pointer */\n        struct
      r *r;            /* receive packet pointer */\n        /*\n         * Read command
      line options and initialize system variables.\n         * The reference implementation
      measures the precision specific\n         * to each machine by measuring the
      clock increments to read the\n         * system clock.\n         */\n        memset(&s,
      sizeof(s), 0);\n        s.leap = NOSYNC;\n        s.stratum = MAXSTRAT;\n        s.poll
      = MINPOLL;\n        s.precision = PRECISION;\n        s.p = NULL;\n        /*\n
      \        * Initialize local clock variables\n         */\n        memset(&c,
      sizeof(c), 0);\n        if (/* frequency file */ 0) {\n                c.freq
      = /* freq */ 0;\n                rstclock(FSET, 0, 0);\n        } else {\n                rstclock(NSET,
      0, 0);\n        }\n        c.jitter = LOG2D(s.precision);\n        /*\n         *
      Read the configuration file and mobilize persistent\n         * associations
      with specified addresses, version, mode, key ID,\n         * and flags.\n         */\n
      \       while (/* mobilize configurated associations */ 0) {\n                p
      = mobilize(IPADDR, IPADDR, VERSION, MODE, KEYID,\n                    P_FLAGS);\n
      \       }\n        /*\n         * Start the system timer, which ticks once per
      second.  Then,\n         * read packets as they arrive, strike receive timestamp,
      and\n         * call the receive() routine.\n         */\n        while (0)
      {\n                r = recv_packet();\n                r->dst = get_time();\n
      \               receive(r);\n        }\n        return(0);\n"
    - '}

      '
    - "/*\n * mobilize() - mobilize and initialize an association\n */\n"
    - 'struct p

      '
    - "*mobilize(\n        ipaddr  srcaddr,        /* IP source address */\n        ipaddr
      \ dstaddr,        /* IP destination address */\n        int     version,        /*
      version */\n        int     mode,           /* host mode */\n        int     keyid,
      \         /* key identifier */\n        int     flags           /* peer flags
      */\n        )\n"
    - "{\n        struct p *p;            /* peer process pointer */\n        /*\n
      \        * Allocate and initialize association memory\n         */\n        p
      = malloc(sizeof(struct p));\n        p->srcaddr = srcaddr;\n        p->dstaddr
      = dstaddr;\n        p->version = version;\n        p->hmode = mode;\n        p->keyid
      = keyid;\n        p->hpoll = MINPOLL;\n        clear(p, X_INIT);\n        p->flags
      = flags;\n        return (p);\n"
    - '}

      '
    - "/*\n * find_assoc() - find a matching association\n */\n"
    - 'struct p                        /* peer structure pointer or NULL */

      '
    - "*find_assoc(\n        struct r *r             /* receive packet pointer */\n
      \       )\n"
    - "{\n        struct p *p;            /* dummy peer structure pointer */\n        /*\n
      \        * Search association table for matching source\n         * address,
      source port and mode.\n         */\n        while (/* all associations */ 0)
      {\n                if (r->srcaddr == p->srcaddr && r->mode == p->hmode)\n                        return(p);\n
      \       }\n        return (NULL);\n"
    - '}

      '
    - "/*\n * md5() - compute message digest\n */\n"
    - 'digest

      '
    - "md5(\n       int     keyid           /* key identifier */\n       )\n"
    - "{\n       /*\n        * Compute a keyed cryptographic message digest.  The
      key\n        * identifier is associated with a key in the local key cache.\n
      \       * The key is prepended to the packet header and extension fields\n        *
      and the result hashed by the MD5 algorithm as described in\n        * RFC 1321.
      \ Return a MAC consisting of the 32-bit key ID\n        * concatenated with
      the 128-bit digest.\n        */\n       return (/* MD5 digest */ 0);\n"
    - '}

      '
    title: A.2.  Main Program and Utility Routines
  - contents:
    - "A.3.  Kernel Input/Output Interface\n   /*\n    * Kernel interface to transmit
      and receive packets.  Details are\n    * deliberately vague and depend on the
      operating system.\n    *\n    * recv_packet - receive packet from network\n
      \   */\n   struct r                        /* receive packet pointer*/\n   *recv_packet()
      {\n           return (/* receive packet r */ 0);\n   }\n   /*\n    * xmit_packet
      - transmit packet to network\n    */\n   void\n   xmit_packet(\n           struct
      x *x             /* transmit packet pointer */\n           )\n   {\n           /*
      send packet x */\n   }\n"
    title: A.3.  Kernel Input/Output Interface
  - contents:
    - 'A.4.  Kernel System Clock Interface

      '
    - "/*\n * System clock utility functions\n *\n * There are three time formats:
      native (Unix), NTP, and floating\n * double.  The get_time() routine returns
      the time in NTP long format.\n * The Unix routines expect arguments as a structure
      of two signed\n * 32-bit words in seconds and microseconds (timeval) or nanoseconds\n
      * (timespec).  The step_time() and adjust_time() routines expect signed\n *
      arguments in floating double.  The simplified code shown here is for\n * illustration
      only and has not been verified.\n */\n"
    - '#define JAN_1970        2208988800UL /* 1970 - 1900 in seconds */

      '
    - "/*\n * get_time - read system time and convert to NTP format\n */\n"
    - 'tstamp

      '
    - 'get_time()

      '
    - "{\n        struct timeval unix_time;\n        /*\n         * There are only
      two calls on this routine in the program.  One\n         * when a packet arrives
      from the network and the other when a\n         * packet is placed on the send
      queue.  Call the kernel time of\n         * day routine (such as gettimeofday())
      and convert to NTP\n         * format.\n         */\n        gettimeofday(&unix_time,
      NULL);\n        return (U2LFP(unix_time));\n"
    - '}

      '
    - "/*\n * step_time() - step system time to given offset value\n */\n"
    - 'void

      '
    - "step_time(\n        double  offset          /* clock offset */\n        )\n"
    - "{\n        struct timeval unix_time;\n        tstamp  ntp_time;\n        /*\n
      \        * Convert from double to native format (signed) and add to the\n         *
      current time.  Note the addition is done in native format to\n         * avoid
      overflow or loss of precision.\n         */\n        gettimeofday(&unix_time,
      NULL);\n        ntp_time = D2LFP(offset) + U2LFP(unix_time);\n        unix_time.tv_sec
      = ntp_time >> 32;\n        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec)
      <<\n            32) / FRAC * 1e6);\n        settimeofday(&unix_time, NULL);\n"
    - '}

      '
    - "/*\n * adjust_time() - slew system clock to given offset value\n */\n"
    - 'void

      '
    - "adjust_time(\n        double  offset          /* clock offset */\n        )\n"
    - "{\n        struct timeval unix_time;\n        tstamp  ntp_time;\n        /*\n
      \        * Convert from double to native format (signed) and add to the\n         *
      current time.\n         */\n        ntp_time = D2LFP(offset);\n        unix_time.tv_sec
      = ntp_time >> 32;\n        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec)
      <<\n            32) / FRAC * 1e6);\n        adjtime(&unix_time, NULL);\n"
    - '}

      '
    title: A.4.  Kernel System Clock Interface
  - contents:
    - "A.5.  Peer Process\n   /*\n    * A crypto-NAK packet includes the NTP header
      followed by a MAC\n    * consisting only of the key identifier with value zero.
      \ It tells\n    * the receiver that a prior request could not be properly\n
      \   * authenticated, but the NTP header fields are correct.\n    *\n    * A
      kiss-o'-death packet is an NTP header with leap 0x3 (NOSYNC) and\n    * stratum
      16 (MAXSTRAT).  It tells the receiver that something\n    * drastic has happened,
      as revealed by the kiss code in the refid\n    * field.  The NTP header fields
      may or may not be correct.\n    */\n   /*\n    * Peer process parameters and
      constants\n    */\n   #define SGATE           3       /* spike gate (clock filter
      */\n   #define BDELAY          .004    /* broadcast delay (s) */\n   /*\n    *
      Dispatch codes\n    */\n   #define ERR             -1      /* error */\n   #define
      DSCRD           0       /* discard packet */\n   #define PROC            1       /*
      process packet */\n   #define BCST            2       /* broadcast packet */\n
      \  #define FXMIT           3       /* client packet */\n   #define MANY            4
      \      /* manycast packet */\n   #define NEWPS           5       /* new symmetric
      passive client */\n   #define NEWBC           6       /* new broadcast client
      */\n   /*\n    * Dispatch matrix\n    *              active  passv  client server
      bcast */\n   int table[7][5] = {\n   /* nopeer  */   { NEWPS, DSCRD, FXMIT,
      MANY, NEWBC },\n   /* active  */   { PROC,  PROC,  DSCRD, DSCRD, DSCRD },\n
      \  /* passv   */   { PROC,  ERR,   DSCRD, DSCRD, DSCRD },\n   /* client  */
      \  { DSCRD, DSCRD, DSCRD, PROC,  DSCRD },\n   /* server  */   { DSCRD, DSCRD,
      DSCRD, DSCRD, DSCRD },\n   /* bcast   */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD
      },\n   /* bclient */   { DSCRD, DSCRD, DSCRD, DSCRD, PROC}\n   };\n   /*\n    *
      Miscellaneous macroni\n    *\n    * This macro defines the authentication state.
      \ If x is 0,\n    * authentication is optional; otherwise, it is required.\n
      \   */\n   #define AUTH(x, y)      ((x) ? (y) == A_OK : (y) == A_OK || \\\n
      \                              (y) == A_NONE)\n   /*\n    * These are used by
      the clear() routine\n    */\n   #define BEGIN_CLEAR(p)  ((char *)&((p)->begin_clear))\n
      \  #define END_CLEAR(p)    ((char *)&((p)->end_clear))\n   #define LEN_CLEAR
      \      (END_CLEAR((struct p *)0) - \\\n                               BEGIN_CLEAR((struct
      p *)0))\n"
    - contents:
      - 'A.5.1.  receive()

        '
      - "/*\n * receive() - receive packet and decode modes\n */\n"
      - 'void

        '
      - "receive(\n        struct r *r             /* receive packet pointer */\n
        \       )\n"
      - "{\n        struct p *p;            /* peer structure pointer */\n        int
        \    auth;           /* authentication code */\n        int     has_mac;        /*
        size of MAC */\n        int     synch;          /* synchronized switch */\n
        \       /*\n         * Check access control lists.  The intent here is to
        implement\n         * a whitelist of those IP addresses specifically accepted\n
        \        * and/or a blacklist of those IP addresses specifically\n         *
        rejected.  There could be different lists for authenticated\n         * clients
        and unauthenticated clients.\n         */\n        if (!access(r))\n                return;
        \                /* access denied */\n        /*\n         * The version must
        not be in the future.  Format checks include\n         * packet length, MAC
        length and extension field lengths, if\n         * present.\n         */\n
        \       if (r->version > VERSION /* or format error */)\n                return;
        \                /* format error */\n        /*\n         * Authentication
        is conditioned by two switches that can be\n         * specified on a per-client
        basis.\n         *\n         * P_NOPEER     do not mobilize an association
        unless\n         *              authenticated.\n         * P_NOTRUST    do
        not allow access unless authenticated\n         *              (implies P_NOPEER).\n
        \        *\n         * There are four outcomes:\n         *\n         * A_NONE
        \      the packet has no MAC.\n         * A_OK         the packet has a MAC
        and authentication\n         *               succeeds.\n         * A_ERROR
        \     the packet has a MAC and authentication fails.\n         * A_CRYPTO
        \    crypto-NAK.  The MAC has four octets only.\n         *\n         * Note:
        The AUTH (x, y) macro is used to filter outcomes.  If x\n         * is zero,
        acceptable outcomes of y are NONE and OK.  If x is\n         * one, the only
        acceptable outcome of y is OK.\n         */\n        has_mac = /* length of
        MAC field */ 0;\n        if (has_mac == 0) {\n                auth = A_NONE;
        \         /* not required */\n        } else if (has_mac == 4) {\n                auth
        = A_CRYPTO;       /* crypto-NAK */\n        } else {\n                if (r->mac
        != md5(r->keyid))\n                        auth = A_ERROR; /* auth error */\n
        \               else\n                        auth = A_OK;    /* auth OK */\n
        \       }\n        /*\n         * Find association and dispatch code.  If
        there is no\n         * association to match, the value of p->hmode is assumed
        NULL.\n         */\n        p = find_assoc(r);\n        switch(table[(unsigned
        int)(p->hmode)][(unsigned int)(r->mode)])\n        {\n        /*\n         *
        Client packet and no association.  Send server reply without\n         * saving
        state.\n         */\n        case FXMIT:\n                /*\n                 *
        If unicast destination address, send server packet.\n                 * If
        authentication fails, send a crypto-NAK packet.\n                 */\n                /*
        not multicast dstaddr */\n                if (0) {\n                        if
        (AUTH(p->flags & P_NOTRUST, auth))\n                                fast_xmit(r,
        M_SERV, auth);\n                        else if (auth == A_ERROR)\n                                fast_xmit(r,
        M_SERV, A_CRYPTO);\n                        return;         /* M_SERV packet
        sent */\n                }\n                /*\n                 * This must
        be manycast.  Do not respond if we are not\n                 * synchronized
        or if our stratum is above the\n                 * manycaster.\n                 */\n
        \               if (s.leap == NOSYNC || s.stratum > r->stratum)\n                        return;\n
        \               /*\n                 * Respond only if authentication is OK.
        \ Note that the\n                 * unicast address is used, not the multicast.\n
        \                */\n                if (AUTH(p->flags & P_NOTRUST, auth))\n
        \                       fast_xmit(r, M_SERV, auth);\n                return;\n
        \       /*\n         * New manycast client ephemeral association.  It is mobilized\n
        \        * in the same version as in the packet.  If authentication\n         *
        fails, ignore the packet.  Verify the server packet by\n         * comparing
        the r->org timestamp in the packet with the p->xmt\n         * timestamp in
        the multicast client association.  If they\n         * match, the server packet
        is authentic.  Details omitted.\n         */\n        case MANY:\n                if
        (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))\n                        return;
        \        /* authentication error */\n                p = mobilize(r->srcaddr,
        r->dstaddr, r->version, M_CLNT,\n                    r->keyid, P_EPHEM);\n
        \               break;\n       /*\n        * New symmetric passive association.
        \ It is mobilized in the\n        * same version as in the packet.  If authentication
        fails,\n        * send a crypto-NAK packet.  If restrict no-moblize, send
        a\n        * symmetric active packet instead.\n        */\n        case NEWPS:\n
        \               if (!AUTH(p->flags & P_NOTRUST, auth)) {\n                        if
        (auth == A_ERROR)\n                                fast_xmit(r, M_SACT, A_CRYPTO);\n
        \                       return;         /* crypto-NAK packet sent */\n                }\n
        \               if (!AUTH(p->flags & P_NOPEER, auth)) {\n                        fast_xmit(r,
        M_SACT, auth);\n                        return;         /* M_SACT packet sent
        */\n                }\n                p = mobilize(r->srcaddr, r->dstaddr,
        r->version, M_PASV,\n                    r->keyid, P_EPHEM);\n                break;\n
        \       /*\n         * New broadcast client association.  It is mobilized
        in the\n         * same version as in the packet.  If authentication fails,\n
        \        * ignore the packet.  Note this code does not support the\n         *
        initial volley feature in the reference implementation.\n         */\n        case
        NEWBC:\n                if (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))\n
        \                       return;         /* authentication error */\n                if
        (!(s.flags & S_BCSTENAB))\n                        return;         /* broadcast
        not enabled */\n                p = mobilize(r->srcaddr, r->dstaddr, r->version,
        M_BCLN,\n                    r->keyid, P_EPHEM);\n                break;                  /*
        processing continues */\n        /*\n         * Process packet.  Placeholdler
        only.\n         */\n        case PROC:\n                break;                  /*
        processing continues */\n        /*\n         * Invalid mode combination.
        \ We get here only in case of\n         * ephemeral associations, so the correct
        action is simply to\n         * toss it.\n         */\n        case ERR:\n
        \               clear(p, X_ERROR);\n                return;                 /*
        invalid mode combination */\n        /*\n         * No match; just discard
        the packet.\n         */\n        case DSCRD:\n                return;                 /*
        orphan abandoned */\n        }\n        /*\n         * Next comes a rigorous
        schedule of timestamp checking.  If the\n         * transmit timestamp is
        zero, the server is horribly broken.\n         */\n        if (r->xmt == 0)\n
        \               return;                 /* invalid timestamp */\n        /*\n
        \        * If the transmit timestamp duplicates a previous one, the\n         *
        packet is a replay.\n         */\n        if (r->xmt == p->xmt)\n                return;
        \                /* duplicate packet */\n        /*\n         * If this is
        a broadcast mode packet, skip further checking.\n         * If the origin
        timestamp is zero, the sender has not yet heard\n         * from us.  Otherwise,
        if the origin timestamp does not match\n         * the transmit timestamp,
        the packet is bogus.\n         */\n        synch = TRUE;\n        if (r->mode
        != M_BCST) {\n                if (r->org == 0)\n                        synch
        = FALSE;  /* unsynchronized */\n                else if (r->org != p->xmt)\n
        \                       synch = FALSE;  /* bogus packet */\n        }\n        /*\n
        \        * Update the origin and destination timestamps.  If\n         * unsynchronized
        or bogus, abandon ship.\n         */\n        p->org = r->xmt;\n        p->rec
        = r->dst;\n        if (!synch)\n                return;                 /*
        unsynch */\n        /*\n         * The timestamps are valid and the receive
        packet matches the\n         * last one sent.  If the packet is a crypto-NAK,
        the server\n         * might have just changed keys.  We demobilize the association\n
        \        * and wait for better times.\n         */\n        if (auth == A_CRYPTO)
        {\n                clear(p, X_CRYPTO);\n                return;                 /*
        crypto-NAK */\n        }\n        /*\n         * If the association is authenticated,
        the key ID is nonzero\n         * and received packets must be authenticated.
        \ This is designed\n         * to avoid a bait-and-switch attack, which was
        possible in past\n         * versions.\n         */\n        if (!AUTH(p->keyid
        || (p->flags & P_NOTRUST), auth))\n                return;                 /*
        bad auth */\n        /*\n         * Everything possible has been done to validate
        the timestamps\n         * and prevent bad guys from disrupting the protocol
        or\n         * injecting bogus data.  Earn some revenue.\n         */\n        packet(p,
        r);\n"
      - '}

        '
      - contents:
        - 'A.5.1.1.  packet()

          '
        - "/*\n * packet() - process packet and compute offset, delay, and\n * dispersion.\n
          */\n"
        - 'void

          '
        - "packet(\n        struct p *p,            /* peer structure pointer */\n
          \       struct r *r             /* receive packet pointer */\n        )\n"
        - "{\n        double  offset;         /* sample offsset */\n        double
          \ delay;          /* sample delay */\n        double  disp;           /*
          sample dispersion */\n        /*\n         * By golly the packet is valid.
          \ Light up the remaining header\n         * fields.  Note that we map stratum
          0 (unspecified) to MAXSTRAT\n         * to make stratum comparisons simpler
          and to provide a natural\n         * interface for radio clock drivers that
          operate for\n         *  convenience at stratum 0.\n         */\n        p->leap
          = r->leap;\n        if (r->stratum == 0)\n                p->stratum = MAXSTRAT;\n
          \       else\n                p->stratum = r->stratum;\n        p->pmode
          = r->mode;\n        p->ppoll = r->poll;\n        p->rootdelay = FP2D(r->rootdelay);\n
          \       p->rootdisp = FP2D(r->rootdisp);\n        p->refid = r->refid;\n
          \       p->reftime = r->reftime;\n        /*\n         * Verify the server
          is synchronized with valid stratum and\n         * reference time not later
          than the transmit time.\n         */\n        if (p->leap == NOSYNC || p->stratum
          >= MAXSTRAT)\n                return;                 /* unsynchronized
          */\n        /*\n         * Verify valid root distance.\n         */\n        if
          (r->rootdelay / 2 + r->rootdisp >= MAXDISP || p->reftime >\n            r->xmt)\n
          \               return;                 /* invalid header values */\n        poll_update(p,
          p->hpoll);\n        p->reach |= 1;\n        /*\n         * Calculate offset,
          delay and dispersion, then pass to the\n         * clock filter.  Note carefully
          the implied processing.  The\n         * first-order difference is done
          directly in 64-bit arithmetic,\n         * then the result is converted
          to floating double.  All further\n         * processing is in floating-double
          arithmetic with rounding\n         * done by the hardware.  This is necessary
          in order to avoid\n         * overflow and preserve precision.\n         *\n
          \        * The delay calculation is a special case.  In cases where the\n
          \        * server and client clocks are running at different rates and\n
          \        * with very fast networks, the delay can appear negative.  In\n
          \        * order to avoid violating the Principle of Least Astonishment,\n
          \        * the delay is clamped not less than the system precision.\n         */\n
          \       if (p->pmode == M_BCST) {\n                offset = LFP2D(r->xmt
          - r->dst);\n                delay = BDELAY;\n                disp = LOG2D(r->precision)
          + LOG2D(s.precision) + PHI *\n                    2 * BDELAY;\n        }
          else {\n                offset = (LFP2D(r->rec - r->org) + LFP2D(r->dst
          -\n                    r->xmt)) / 2;\n                delay = max(LFP2D(r->dst
          - r->org) - LFP2D(r->rec -\n                    r->xmt), LOG2D(s.precision));\n
          \               disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *\n
          \                   LFP2D(r->dst - r->org);\n        }\n        clock_filter(p,
          offset, delay, disp);\n"
        - '}

          '
        title: A.5.1.1.  packet()
      title: A.5.1.  receive()
    - contents:
      - 'A.5.2.  clock_filter()

        '
      - "/*\n * clock_filter(p, offset, delay, dispersion) - select the best from
        the\n * latest eight delay/offset samples.\n */\n"
      - 'void

        '
      - "clock_filter(\n        struct p *p,            /* peer structure pointer
        */\n        double  offset,         /* clock offset */\n        double  delay,
        \         /* roundtrip delay */\n        double  disp            /* dispersion
        */\n        )\n"
      - "{\n        struct f f[NSTAGE];     /* sorted list */\n        double  dtemp;\n
        \       int     i;\n        /*\n         * The clock filter contents consist
        of eight tuples (offset,\n         * delay, dispersion, time).  Shift each
        tuple to the left,\n         * discarding the leftmost one.  As each tuple
        is shifted,\n         * increase the dispersion since the last filter update.
        \ At the\n         * same time, copy each tuple to a temporary list.  After
        this,\n         * place the (offset, delay, disp, time) in the vacated\n         *
        rightmost tuple.\n         */\n        for (i = 1; i < NSTAGE; i++) {\n                p->f[i]
        = p->f[i - 1];\n                p->f[i].disp += PHI * (c.t - p->t);\n                f[i]
        = p->f[i];\n        }\n        p->f[0].t = c.t;\n        p->f[0].offset =
        offset;\n        p->f[0].delay = delay;\n        p->f[0].disp = disp;\n        f[0]
        = p->f[0];\n        /*\n         * Sort the temporary list of tuples by increasing
        f[].delay.\n         * The first entry on the sorted list represents the best\n
        \        * sample, but it might be old.\n         */\n        dtemp = p->offset;\n
        \       p->offset = f[0].offset;\n        p->delay = f[0].delay;\n        for
        (i = 0; i < NSTAGE; i++) {\n                p->disp += f[i].disp / (2 ^ (i
        + 1));\n                p->jitter += SQUARE(f[i].offset - f[0].offset);\n
        \       }\n        p->jitter = max(SQRT(p->jitter), LOG2D(s.precision));\n
        \       /*\n         * Prime directive: use a sample only once and never a
        sample\n         * older than the latest one, but anything goes before first\n
        \        * synchronized.\n         */\n        if (f[0].t - p->t <= 0 && s.leap
        != NOSYNC)\n                return;\n        /*\n         * Popcorn spike
        suppressor.  Compare the difference between the\n         * last and current
        offsets to the current jitter.  If greater\n         * than SGATE (3) and
        if the interval since the last offset is\n         * less than twice the system
        poll interval, dump the spike.\n         * Otherwise, and if not in a burst,
        shake out the truechimers.\n         */\n        if (fabs(p->offset - dtemp)
        > SGATE * p->jitter && (f[0].t -\n            p->t) < 2 * s.poll)\n                return;\n
        \       p->t = f[0].t;\n        if (p->burst == 0)\n                clock_select();\n
        \       return;\n"
      - '}

        '
      - "/*\n * fit() - test if association p is acceptable for synchronization\n
        */\n"
      - 'int

        '
      - "fit(\n        struct p *p             /* peer structure pointer */\n        )\n"
      - "{\n        /*\n         * A stratum error occurs if (1) the server has never
        been\n         * synchronized, (2) the server stratum is invalid.\n         */\n
        \       if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)\n                return
        (FALSE);\n        /*\n         * A distance error occurs if the root distance
        exceeds the\n         * distance threshold plus an increment equal to one
        poll\n         * interval.\n         */\n        if (root_dist(p) > MAXDIST
        + PHI * LOG2D(s.poll))\n                return (FALSE);\n        /*\n         *
        A loop error occurs if the remote peer is synchronized to the\n         *
        local peer or the remote peer is synchronized to the current\n         * system
        peer.  Note this is the behavior for IPv4; for IPv6\n         * the MD5 hash
        is used instead.\n         */\n        if (p->refid == p->dstaddr || p->refid
        == s.refid)\n                return (FALSE);\n        /*\n         * An unreachable
        error occurs if the server is unreachable.\n         */\n        if (p->reach
        == 0)\n                return (FALSE);\n        return (TRUE);\n"
      - '}

        '
      - "/*\n * clear() - reinitialize for persistent association, demobilize\n *
        for ephemeral association.\n */\n"
      - 'void

        '
      - "clear(\n        struct p *p,            /* peer structure pointer */\n        int
        \    kiss            /* kiss code */\n        )\n"
      - "{\n        int i;\n        /*\n         * The first thing to do is return
        all resources to the bank.\n         * Typical resources are not detailed
        here, but they include\n         * dynamically allocated structures for keys,
        certificates, etc.\n         * If an ephemeral association and not initialization,
        return\n         * the association memory as well.\n         */\n        /*
        return resources */\n        if (s.p == p)\n                s.p = NULL;\n
        \       if (kiss != X_INIT && (p->flags & P_EPHEM)) {\n                free(p);\n
        \               return;\n        }\n        /*\n         * Initialize the
        association fields for general reset.\n         */\n        memset(BEGIN_CLEAR(p),
        LEN_CLEAR, 0);\n        p->leap = NOSYNC;\n        p->stratum = MAXSTRAT;\n
        \       p->ppoll = MAXPOLL;\n        p->hpoll = MINPOLL;\n        p->disp
        = MAXDISP;\n        p->jitter = LOG2D(s.precision);\n        p->refid = kiss;\n
        \       for (i = 0; i < NSTAGE; i++)\n                p->f[i].disp = MAXDISP;\n
        \       /*\n         * Randomize the first poll just in case thousands of
        broadcast\n         * clients have just been stirred up after a long absence
        of the\n         * broadcast server.\n         */\n        p->outdate = p->t
        = c.t;\n        p->nextdate = p->outdate + (random() & ((1 << MINPOLL) - 1));\n"
      - '}

        '
      title: A.5.2.  clock_filter()
    - contents:
      - 'A.5.3.  fast_xmit()

        '
      - "/*\n * fast_xmit() - transmit a reply packet for receive packet r\n */\n"
      - 'void

        '
      - "fast_xmit(\n        struct r *r,            /* receive packet pointer */\n
        \       int     mode,           /* association mode */\n        int     auth
        \           /* authentication code */\n        )\n"
      - "{\n        struct x x;\n        /*\n         * Initialize header and transmit
        timestamp.  Note that the\n         * transmit version is copied from the
        receive version.  This is\n         * for backward compatibility.\n         */\n
        \       x.version = r->version;\n        x.srcaddr = r->dstaddr;\n        x.dstaddr
        = r->srcaddr;\n        x.leap = s.leap;\n        x.mode = mode;\n        if
        (s.stratum == MAXSTRAT)\n                x.stratum = 0;\n        else\n                x.stratum
        = s.stratum;\n        x.poll = r->poll;\n        x.precision = s.precision;\n
        \       x.rootdelay = D2FP(s.rootdelay);\n        x.rootdisp = D2FP(s.rootdisp);\n
        \       x.refid = s.refid;\n        x.reftime = s.reftime;\n        x.org
        = r->xmt;\n        x.rec = r->dst;\n        x.xmt = get_time();\n        /*\n
        \        * If the authentication code is A.NONE, include only the\n         *
        header; if A.CRYPTO, send a crypto-NAK; if A.OK, send a valid\n         *
        MAC.  Use the key ID in the received packet and the key in\n         * the
        local key cache.\n         */\n        if (auth != A_NONE) {\n                if
        (auth == A_CRYPTO) {\n                        x.keyid = 0;\n                }
        else {\n                        x.keyid = r->keyid;\n                        x.dgst
        = md5(x.keyid);\n                }\n        }\n        xmit_packet(&x);\n"
      - '}

        '
      title: A.5.3.  fast_xmit()
    - contents:
      - "A.5.4.  access()\n /*\n  * access() - determine access restrictions\n  */\n
        int\n access(\n         struct r *r             /* receive packet pointer
        */\n         )\n {\n         /*\n          * The access control list is an
        ordered set of tuples\n          * consisting of an address, mask, and restrict
        word containing\n          * defined bits.  The list is searched for the first
        match on\n          * the source address (r->srcaddr) and the associated restrict\n
        \         * word is returned.\n          */\n         return (/* access bits
        */ 0);\n }\n"
      title: A.5.4.  access()
    - contents:
      - 'A.5.5.  System Process

        '
      - contents:
        - 'A.5.5.1.  clock_select()

          '
        - "/*\n * clock_select() - find the best clocks\n */\n"
        - 'void

          '
        - "clock_select() {\n       struct p *p, *osys;     /* peer structure pointers
          */\n       double  low, high;      /* correctness interval extents */\n
          \      int     allow, found, chime; /* used by intersection algorithm */\n
          \      int     n, i, j;\n        /*\n         * We first cull the falsetickers
          from the server population,\n         * leaving only the truechimers.  The
          correctness interval for\n         * association p is the interval from
          offset - root_dist() to\n         * offset + root_dist().  The object of
          the game is to find a\n         * majority clique; that is, an intersection
          of correctness\n         * intervals numbering more than half the server
          population.\n         *\n         * First, construct the chime list of tuples
          (p, type, edge) as\n         * shown below, then sort the list by edge from
          lowest to\n         * highest.\n         */\n        osys = s.p;\n        s.p
          = NULL;\n        n = 0;\n        while (fit(p)) {\n                s.m[n].p
          = p;\n                s.m[n].type = +1;\n                s.m[n].edge = p->offset
          + root_dist(p);\n                n++;\n                s.m[n].p = p;\n                s.m[n].type
          = 0;\n                s.m[n].edge = p->offset;\n                n++;\n                s.m[n].p
          = p;\n                s.m[n].type = -1;\n                s.m[n].edge = p->offset
          - root_dist(p);\n                n++;\n        }\n        /*\n         *
          Find the largest contiguous intersection of correctness\n         * intervals.
          \ Allow is the number of allowed falsetickers;\n         * found is the
          number of midpoints.  Note that the edge values\n         * are limited
          to the range +-(2 ^ 30) < +-2e9 by the timestamp\n         * calculations.\n
          \        */\n        low = 2e9; high = -2e9;\n        for (allow = 0; 2
          * allow < n; allow++) {\n                /*\n                 * Scan the
          chime list from lowest to highest to find\n                 * the lower
          endpoint.\n                 */\n                found = 0;\n                chime
          = 0;\n                for (i = 0; i < n; i++) {\n                        chime
          -= s.m[i].type;\n                        if (chime >= n - found) {\n                                low
          = s.m[i].edge;\n                                break;\n                        }\n
          \                       if (s.m[i].type == 0)\n                                found++;\n
          \               }\n                /*\n                 * Scan the chime
          list from highest to lowest to find\n                 * the upper endpoint.\n
          \                */\n                chime = 0;\n                for (i
          = n - 1; i >= 0; i--) {\n                        chime += s.m[i].type;\n
          \                       if (chime >= n - found) {\n                                high
          = s.m[i].edge;\n                                break;\n                        }\n
          \                       if (s.m[i].type == 0)\n                                found++;\n
          \               }\n                /*\n                 * If the number
          of midpoints is greater than the number\n                 * of allowed falsetickers,
          the intersection contains at\n                 * least one truechimer with
          no midpoint.  If so,\n                 * increment the number of allowed
          falsetickers and go\n                 * around again.  If not and the intersection
          is\n                 * non-empty, declare success.\n                 */\n
          \               if (found > allow)\n                        continue;\n
          \               if (high > low)\n                        break;\n        }\n
          \       /*\n         * Clustering algorithm.  Construct a list of survivors
          (p,\n         * metric) from the chime list, where metric is dominated first\n
          \        * by stratum and then by root distance.  All other things being\n
          \        * equal, this is the order of preference.\n         */\n        s.n
          = 0;\n        for (i = 0; i < n; i++) {\n                if (s.m[i].edge
          < low || s.m[i].edge > high)\n                        continue;\n                p
          = s.m[i].p;\n                s.v[n].p = p;\n                s.v[n].metric
          = MAXDIST * p->stratum + root_dist(p);\n                s.n++;\n        }\n
          \       /*\n         * There must be at least NSANE survivors to satisfy
          the\n         * correctness assertions.  Ordinarily, the Byzantine criteria\n
          \        * require four survivors, but for the demonstration here, one\n
          \        * is acceptable.\n         */\n        if (s.n < NSANE)\n                return;\n
          \       /*\n         * For each association p in turn, calculate the selection\n
          \        * jitter p->sjitter as the square root of the sum of squares\n
          \        * (p->offset - q->offset) over all q associations.  The idea is\n
          \        * to repeatedly discard the survivor with maximum selection\n         *
          jitter until a termination condition is met.\n         */\n        while
          (1) {\n                struct p *p, *q, *qmax; /* peer structure pointers
          */\n                double  max, min, dtemp;\n                max = -2e9;
          min = 2e9;\n                for (i = 0; i < s.n; i++) {\n                        p
          = s.v[i].p;\n                        if (p->jitter < min)\n                                min
          = p->jitter;\n                        dtemp = 0;\n                        for
          (j = 0; j < n; j++) {\n                                q = s.v[j].p;\n                                dtemp
          += SQUARE(p->offset - q->offset);\n                        }\n                        dtemp
          = SQRT(dtemp);\n                        if (dtemp > max) {\n                                max
          = dtemp;\n                                qmax = q;\n                        }\n
          \               }\n                /*\n                 * If the maximum
          selection jitter is less than the\n                 * minimum peer jitter,
          then tossing out more survivors\n                 * will not lower the minimum
          peer jitter, so we might\n                 * as well stop.  To make sure
          a few survivors are left\n                 * for the clustering algorithm
          to chew on, we also stop\n                 * if the number of survivors
          is less than or equal to\n                 * NMIN (3).\n                 */\n
          \               if (max < min || n <= NMIN)\n                        break;\n
          \               /*\n                 * Delete survivor qmax from the list
          and go around\n                 * again.\n                 */\n                s.n--;\n
          \       }\n        /*\n         * Pick the best clock.  If the old system
          peer is on the list\n         * and at the same stratum as the first survivor
          on the list,\n         * then don't do a clock hop.  Otherwise, select the
          first\n         * survivor on the list as the new system peer.\n         */\n
          \       if (osys->stratum == s.v[0].p->stratum)\n                s.p = osys;\n
          \       else\n                s.p = s.v[0].p;\n        clock_update(s.p);\n"
        - '}

          '
        title: A.5.5.1.  clock_select()
      - contents:
        - 'A.5.5.2.  root_dist()

          '
        - "/*\n * root_dist() - calculate root distance\n */\n"
        - 'double

          '
        - "root_dist(\n        struct p *p             /* peer structure pointer */\n
          \       )\n"
        - "{\n        /*\n         * The root synchronization distance is the maximum
          error due to\n         * all causes of the local clock relative to the primary
          server.\n         * It is defined as half the total delay plus total dispersion\n
          \        * plus peer jitter.\n         */\n        return (max(MINDISP,
          p->rootdelay + p->delay) / 2 +\n            p->rootdisp + p->disp + PHI
          * (c.t - p->t) + p->jitter);\n"
        - '}

          '
        title: A.5.5.2.  root_dist()
      - contents:
        - 'A.5.5.3.  accept()

          '
        - "/*\n * accept() - test if association p is acceptable for synchronization\n
          */\n"
        - 'int

          '
        - "accept(\n        struct p *p             /* peer structure pointer */\n
          \       )\n"
        - "{\n        /*\n         * A stratum error occurs if (1) the server has
          never been\n         * synchronized, (2) the server stratum is invalid.\n
          \        */\n        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)\n
          \               return (FALSE);\n        /*\n         * A distance error
          occurs if the root distance exceeds the\n         * distance threshold plus
          an increment equal to one poll\n         * interval.\n         */\n        if
          (root_dist(p) > MAXDIST + PHI * LOG2D(s.poll))\n                return (FALSE);\n
          \       /*\n         * A loop error occurs if the remote peer is synchronized
          to the\n         * local peer or the remote peer is synchronized to the
          current\n         * system peer.  Note this is the behavior for IPv4; for
          IPv6\n         * the MD5 hash is used instead.\n         */\n        if
          (p->refid == p->dstaddr || p->refid == s.refid)\n                return
          (FALSE);\n        /*\n         * An unreachable error occurs if the server
          is unreachable.\n         */\n        if (p->reach == 0)\n                return
          (FALSE);\n        return (TRUE);\n"
        - '}

          '
        title: A.5.5.3.  accept()
      - contents:
        - 'A.5.5.4.  clock_update()

          '
        - "/*\n * clock_update() - update the system clock\n */\n"
        - 'void

          '
        - "clock_update(\n        struct p *p             /* peer structure pointer
          */\n        )\n"
        - "{\n        double dtemp;\n        /*\n         * If this is an old update,
          for instance, as the result of a\n         * system peer change, avoid it.
          \ We never use an old sample or\n         * the same sample twice.\n         */\n
          \       if (s.t >= p->t)\n                return;\n        /*\n         *
          Combine the survivor offsets and update the system clock; the\n         *
          local_clock() routine will tell us the good or bad news.\n         */\n
          \       s.t = p->t;\n        clock_combine();\n        switch (local_clock(p,
          s.offset)) {\n        /*\n         * The offset is too large and probably
          bogus.  Complain to the\n         * system log and order the operator to
          set the clock manually\n         * within PANIC range.  The reference implementation
          includes a\n         * command line option to disable this check and to
          change the\n         * panic threshold from the default 1000 s as required.\n
          \        */\n        case PANIC:\n                exit (0);\n        /*\n
          \        * The offset is more than the step threshold (0.125 s by\n         *
          default).  After a step, all associations now have\n         * inconsistent
          time values, so they are reset and started\n         * fresh.  The step
          threshold can be changed in the reference\n         * implementation in
          order to lessen the chance the clock might\n         * be stepped backwards.
          \ However, there may be serious\n         * consequences, as noted in the
          white papers at the NTP project\n         * site.\n         */\n        case
          STEP:\n                while (/* all associations */ 0)\n                        clear(p,
          X_STEP);\n                s.stratum = MAXSTRAT;\n                s.poll
          = MINPOLL;\n                break;\n        /*\n         * The offset was
          less than the step threshold, which is the\n         * normal case.  Update
          the system variables from the peer\n         * variables.  The lower clamp
          on the dispersion increase is to\n         * avoid timing loops and clockhopping
          when highly precise\n         * sources are in play.  The clamp can be changed
          from the\n         * default .01 s in the reference implementation.\n         */\n
          \       case SLEW:\n                s.leap = p->leap;\n                s.stratum
          = p->stratum + 1;\n                s.refid = p->refid;\n                s.reftime
          = p->reftime;\n                s.rootdelay = p->rootdelay + p->delay;\n
          \               dtemp = SQRT(SQUARE(p->jitter) + SQUARE(s.jitter));\n                dtemp
          += max(p->disp + PHI * (c.t - p->t) +\n                    fabs(p->offset),
          MINDISP);\n                s.rootdisp = p->rootdisp + dtemp;\n                break;\n
          \       /*\n         * Some samples are discarded while, for instance, a
          direct\n         * frequency measurement is being made.\n         */\n        case
          IGNORE:\n                break;\n        }\n"
        - '}

          '
        title: A.5.5.4.  clock_update()
      - contents:
        - 'A.5.5.5.  clock_combine()

          '
        - "/*\n * clock_combine() - combine offsets\n */\n"
        - 'void

          '
        - 'clock_combine()

          '
        - "{\n        struct p *p;            /* peer structure pointer */\n        double
          x, y, z, w;\n        int     i;\n        /*\n         * Combine the offsets
          of the clustering algorithm survivors\n         * using a weighted average
          with weight determined by the root\n         * distance.  Compute the selection
          jitter as the weighted RMS\n         * difference between the first survivor
          and the remaining\n         * survivors.  In some cases, the inherent clock
          jitter can be\n         * reduced by not using this algorithm, especially
          when frequent\n         * clockhopping is involved.  The reference implementation
          can\n         * be configured to avoid this algorithm by designating a\n
          \        * preferred peer.\n         */\n        y = z = w = 0;\n        for
          (i = 0; s.v[i].p != NULL; i++) {\n                p = s.v[i].p;\n                x
          = root_dist(p);\n                y += 1 / x;\n                z += p->offset
          / x;\n                w += SQUARE(p->offset - s.v[0].p->offset) / x;\n        }\n
          \       s.offset = z / y;\n        s.jitter = SQRT(w / y);\n"
        - '}

          '
        title: A.5.5.5.  clock_combine()
      - contents:
        - 'A.5.5.6.  local_clock()

          '
        - "/*\n * Clock discipline parameters and constants\n */\n"
        - '#define STEPT           .128    /* step threshold (s) */

          '
        - '#define WATCH           900     /* stepout threshold (s) */

          '
        - '#define PANICT          1000    /* panic threshold (s) */

          '
        - '#define PLL             65536   /* PLL loop gain */

          '
        - '#define FLL             MAXPOLL + 1 /* FLL loop gain */

          '
        - '#define AVG             4       /* parameter averaging constant */

          '
        - '#define ALLAN           1500    /* compromise Allan intercept (s) */

          '
        - '#define LIMIT           30      /* poll-adjust threshold */

          '
        - '#define MAXFREQ         500e-6  /* frequency tolerance (500 ppm) */

          '
        - '#define PGATE           4       /* poll-adjust gate */

          '
        - "/*\n * local_clock() - discipline the local clock\n */\n"
        - 'int                             /* return code */

          '
        - "local_clock(\n        struct p *p,            /* peer structure pointer
          */\n        double  offset          /* clock offset from combine() */\n
          \       )\n"
        - "{\n        int     state;          /* clock discipline state */\n        double
          \ freq;           /* frequency */\n        double  mu;             /* interval
          since last update */\n        int     rval;\n        double  etemp, dtemp;\n
          \       /*\n         * If the offset is too large, give up and go home.\n
          \        */\n        if (fabs(offset) > PANICT)\n                return
          (PANIC);\n        /*\n         * Clock state machine transition function.
          \ This is where the\n         * action is and defines how the system reacts
          to large time\n         * and frequency errors.  There are two main regimes:
          when the\n         * offset exceeds the step threshold and when it does
          not.\n         */\n        rval = SLEW;\n        mu = p->t - s.t;\n        freq
          = 0;\n        if (fabs(offset) > STEPT) {\n                switch (c.state)
          {\n                /*\n                 * In S_SYNC state, we ignore the
          first outlier and\n                 * switch to S_SPIK state.\n                 */\n
          \               case SYNC:\n                        state = SPIK;\n                        return
          (rval);\n                /*\n                 * In S_FREQ state, we ignore
          outliers and inliers.  At\n                 * the first outlier after the
          stepout threshold,\n                 * compute the apparent frequency correction
          and step\n                 * the time.\n                 */\n                case
          FREQ:\n                        if (mu < WATCH)\n                                return
          (IGNORE);\n                        freq = (offset - c.offset) / mu;\n                        /*
          fall through to S_SPIK */\n                /*\n                 * In S_SPIK
          state, we ignore succeeding outliers until\n                 * either an
          inlier is found or the stepout threshold is\n                 * exceeded.\n
          \                */\n                case SPIK:\n                        if
          (mu < WATCH)\n                                return (IGNORE);\n                        /*
          fall through to default */\n                /*\n                 * We get
          here by default in S_NSET and S_FSET states\n                 * and from
          above in S_FREQ state.  Step the time and\n                 * clamp down
          the poll interval.\n                 *\n                 * In S_NSET state,
          an initial frequency correction is\n                 * not available, usually
          because the frequency file has\n                 * not yet been written.
          \ Since the time is outside the\n                 * capture range, the clock
          is stepped.  The frequency\n                 * will be set directly following
          the stepout interval.\n                 *\n                 * In S_FSET
          state, the initial frequency has been set\n                 * from the frequency
          file.  Since the time is outside\n                 * the capture range,
          the clock is stepped immediately,\n                 * rather than after
          the stepout interval.  Guys get\n                 * nervous if it takes
          17 minutes to set the clock for\n                 * the first time.\n                 *\n
          \                * In S_SPIK state, the stepout threshold has expired\n
          \                * and the phase is still above the step threshold.\n                 *
          Note that a single spike greater than the step\n                 * threshold
          is always suppressed, even at the longer\n                 * poll intervals.\n
          \                */\n                default:\n                        /*\n
          \                        * This is the kernel set time function, usually\n
          \                        * implemented by the Unix settimeofday() system\n
          \                        * call.\n                         */\n                        step_time(offset);\n
          \                       c.count = 0;\n                        s.poll = MINPOLL;\n
          \                       rval = STEP;\n                        if (state
          == NSET) {\n                                rstclock(FREQ, p->t, 0);\n                                return
          (rval);\n                        }\n                        break;\n                }\n
          \               rstclock(SYNC, p->t, 0);\n        } else {\n                /*\n
          \                * Compute the clock jitter as the RMS of exponentially\n
          \                * weighted offset differences.  This is used by the\n                 *
          poll-adjust code.\n                 */\n                etemp = SQUARE(c.jitter);\n
          \               dtemp = SQUARE(max(fabs(offset - c.last),\n                    LOG2D(s.precision)));\n
          \               c.jitter = SQRT(etemp + (dtemp - etemp) / AVG);\n                switch
          (c.state) {\n                /*\n                 * In S_NSET state, this
          is the first update received\n                 * and the frequency has not
          been initialized.  The\n                 * first thing to do is directly
          measure the oscillator\n                 * frequency.\n                 */\n
          \               case NSET:\n                        rstclock(FREQ, p->t,
          offset);\n                        return (IGNORE);\n                /*\n
          \                * In S_FSET state, this is the first update and the\n                 *
          frequency has been initialized.  Adjust the phase,\n                 * but
          don't adjust the frequency until the next update.\n                 */\n
          \               case FSET:\n                        rstclock(SYNC, p->t,
          offset);\n                        break;\n                /*\n                 *
          In S_FREQ state, ignore updates until the stepout\n                 * threshold.
          \ After that, correct the phase and\n                 * frequency and switch
          to S_SYNC state.\n                 */\n                case FREQ:\n                        if
          (c.t - s.t < WATCH)\n                                return (IGNORE);\n
          \                       freq = (offset - c.offset) / mu;\n                        break;\n
          \               /*\n                 * We get here by default in S_SYNC
          and S_SPIK states.\n                 * Here we compute the frequency update
          due to PLL and\n                 * FLL contributions.\n                 */\n
          \               default:\n                        /*\n                         *
          The FLL and PLL frequency gain constants\n                         * depending
          on the poll interval and Allan\n                         * intercept.  The
          FLL is not used below one\n                         * half the Allan intercept.
          \ Above that the\n                         * loop gain increases in steps
          to 1 / AVG.\n                         */\n                        if (LOG2D(s.poll)
          > ALLAN / 2) {\n                                etemp = FLL - s.poll;\n
          \                               if (etemp < AVG)\n                                        etemp
          = AVG;\n                                freq += (offset - c.offset) / (max(mu,\n
          \                                   ALLAN) * etemp);\n                        }\n
          \                       /*\n                         * For the PLL the integration
          interval\n                         * (numerator) is the minimum of the update\n
          \                        * interval and poll interval.  This allows\n                         *
          oversampling, but not undersampling.\n                         */\n                        etemp
          = min(mu, LOG2D(s.poll));\n                        dtemp = 4 * PLL * LOG2D(s.poll);\n
          \                       freq += offset * etemp / (dtemp * dtemp);\n                        rstclock(SYNC,
          p->t, offset);\n                        break;\n                }\n        }\n
          \       /*\n         * Calculate the new frequency and frequency stability
          (wander).\n         * Compute the clock wander as the RMS of exponentially
          weighted\n         * frequency differences.  This is not used directly,
          but can,\n         * along with the jitter, be a highly useful monitoring
          and\n         * debugging tool.\n         */\n        freq += c.freq;\n
          \       c.freq = max(min(MAXFREQ, freq), -MAXFREQ);\n        etemp = SQUARE(c.wander);\n
          \       dtemp = SQUARE(freq);\n        c.wander = SQRT(etemp + (dtemp -
          etemp) / AVG);\n        /*\n         * Here we adjust the poll interval
          by comparing the current\n         * offset with the clock jitter.  If the
          offset is less than the\n         * clock jitter times a constant, then
          the averaging interval is\n         * increased; otherwise, it is decreased.
          \ A bit of hysteresis\n         * helps calm the dance.  Works best using
          burst mode.\n         */\n        if (fabs(c.offset) < PGATE * c.jitter)
          {\n                c.count += s.poll;\n                if (c.count > LIMIT)
          {\n                        c.count = LIMIT;\n                        if
          (s.poll < MAXPOLL) {\n                                c.count = 0;\n                                s.poll++;\n
          \                       }\n                }\n        } else {\n                c.count
          -= s.poll << 1;\n                if (c.count < -LIMIT) {\n                        c.count
          = -LIMIT;\n                        if (s.poll > MINPOLL) {\n                                c.count
          = 0;\n                                s.poll--;\n                        }\n
          \               }\n        }\n        return (rval);\n"
        - '}

          '
        title: A.5.5.6.  local_clock()
      - contents:
        - "A.5.5.7.  rstclock()\n  /*\n   * rstclock() - clock state machine\n   */\n
          \ void\n  rstclock(\n          int     state,          /* new state */\n
          \         double  offset,         /* new offset */\n          double  t
          \              /* new update time */\n          )\n  {\n          /*\n           *
          Enter new state and set state variables.  Note, we use the\n           *
          time of the last clock filter sample, which must be earlier\n           *
          than the current time.\n           */\n          c.state = state;\n          c.last
          = c.offset = offset;\n          s.t = t;\n  }\n"
        title: A.5.5.7.  rstclock()
      title: A.5.5.  System Process
    - contents:
      - 'A.5.6.  Clock Adjust Process

        '
      - contents:
        - "A.5.6.1.  clock_adjust()\n /*\n  * clock_adjust() - runs at one-second
          intervals\n  */\n void\n clock_adjust() {\n         double  dtemp;\n         /*\n
          \         * Update the process time c.t.  Also increase the dispersion\n
          \         * since the last update.  In contrast to NTPv3, NTPv4 does not\n
          \         * declare unsynchronized after one day, since the dispersion\n
          \         * threshold serves this function.  When the dispersion exceeds\n
          \         * MAXDIST (1 s), the server is considered unfit for\n          *
          synchronization.\n          */\n         c.t++;\n         s.rootdisp +=
          PHI;\n         /*\n          * Implement the phase and frequency adjustments.
          \ The gain\n          * factor (denominator) is not allowed to increase
          beyond the\n          * Allan intercept.  It doesn't make sense to average
          phase\n          * noise beyond this point and it helps to damp residual
          offset\n          * at the longer poll intervals.\n          */\n         dtemp
          = c.offset / (PLL * min(LOG2D(s.poll), ALLAN));\n         c.offset -= dtemp;\n
          \        /*\n          * This is the kernel adjust time function, usually
          implemented\n          * by the Unix adjtime() system call.\n          */\n
          \        adjust_time(c.freq + dtemp);\n         /*\n          * Peer timer.
          \ Call the poll() routine when the poll timer\n          * expires.\n          */\n
          \        while (/* all associations */ 0) {\n                 struct p *p;
          \   /* dummy peer structure pointer */\n                 if (c.t >= p->nextdate)\n
          \                        poll(p);\n         }\n         /*\n          *
          Once per hour, write the clock frequency to a file.\n          */\n         /*\n
          \         * if (c.t % 3600 == 3599)\n          *   write c.freq to file\n
          \         */\n }\n"
        title: A.5.6.1.  clock_adjust()
      title: A.5.6.  Clock Adjust Process
    - contents:
      - "A.5.7.  Poll Process\n   /*\n    * Poll process parameters and constants\n
        \   */\n   #define UNREACH         12      /* unreach counter threshold */\n
        \  #define BCOUNT          8       /* packets in a burst */\n   #define BTIME
        \          2       /* burst interval (s) */\n"
      - contents:
        - 'A.5.7.1.  poll()

          '
        - "/*\n * poll() - determine when to send a packet for association p->\n */\n"
        - 'void

          '
        - "poll(\n        struct p *p             /* peer structure pointer */\n        )\n"
        - "{\n        int     hpoll;\n        int     oreach;\n        /*\n         *
          This routine is called when the current time c.t catches up\n         *
          to the next poll time p->nextdate.  The value p->outdate is\n         *
          the last time this routine was executed.  The poll_update()\n         *
          routine determines the next execution time p->nextdate.\n         *\n         *
          If broadcasting, just do it, but only if we are synchronized.\n         */\n
          \       hpoll = p->hpoll;\n        if (p->hmode == M_BCST) {\n                p->outdate
          = c.t;\n                if (s.p != NULL)\n                        peer_xmit(p);\n
          \               poll_update(p, hpoll);\n                return;\n        }\n
          \       /*\n         * If manycasting, start with ttl = 1.  The ttl is increased
          by\n         * one for each poll until MAXCLOCK servers have been found
          or\n         * ttl reaches TTLMAX.  If reaching MAXCLOCK, stop polling until\n
          \        * the number of servers falls below MINCLOCK, then start all\n
          \        * over.\n         */\n        if (p->hmode == M_CLNT && p->flags
          & P_MANY) {\n                p->outdate = c.t;\n                if (p->unreach
          > BEACON) {\n                        p->unreach = 0;\n                        p->ttl
          = 1;\n                        peer_xmit(p);\n                } else if (s.n
          < MINCLOCK) {\n                        if (p->ttl < TTLMAX)\n                                p->ttl++;\n
          \                       peer_xmit(p);\n                }\n                p->unreach++;\n
          \               poll_update(p, hpoll);\n                return;\n        }\n
          \       if (p->burst == 0) {\n                /*\n                 * We
          are not in a burst.  Shift the reachability\n                 * register
          to the left.  Hopefully, some time before\n                 * the next poll
          a packet will arrive and set the\n                 * rightmost bit.\n                 */\n
          \               oreach = p->reach;\n                p->outdate = c.t;\n
          \               p->reach = p->reach << 1;\n                if (!(p->reach
          & 0x7))\n                        clock_filter(p, 0, 0, MAXDISP);\n                if
          (!p->reach) {\n                        /*\n                         * The
          server is unreachable, so bump the\n                         * unreach counter.
          \ If the unreach threshold\n                         * has been reached,
          double the poll interval\n                         * to minimize wasted
          network traffic.  Send a\n                         * burst only if enabled
          and the unreach\n                         * threshold has not been reached.\n
          \                        */\n                        if (p->flags & P_IBURST
          && p->unreach == 0) {\n                                p->burst = BCOUNT;\n
          \                       } else if (p->unreach < UNREACH)\n                                p->unreach++;\n
          \                       else\n                                hpoll++;\n
          \                       p->unreach++;\n                } else {\n                        /*\n
          \                        * The server is reachable.  Set the poll\n                         *
          interval to the system poll interval.  Send a\n                         *
          burst only if enabled and the peer is fit.\n                         */\n
          \                       p->unreach = 0;\n                        hpoll =
          s.poll;\n                        if (p->flags & P_BURST && fit(p))\n                                p->burst
          = BCOUNT;\n                }\n        } else {\n                /*\n                 *
          If in a burst, count it down.  When the reply comes\n                 *
          back the clock_filter() routine will call\n                 * clock_select()
          to process the results of the burst.\n                 */\n                p->burst--;\n
          \       }\n        /*\n         * Do not transmit if in broadcast client
          mode.\n         */\n        if (p->hmode != M_BCLN)\n                peer_xmit(p);\n
          \       poll_update(p, hpoll);\n"
        - '}

          '
        title: A.5.7.1.  poll()
      - contents:
        - 'A.5.7.2.  poll_update()

          '
        - "/*\n * poll_update() - update the poll interval for association p\n *\n
          * Note: This routine is called by both the packet() and poll() routine.\n
          * Since the packet() routine is executed when a network packet arrives\n
          * and the poll() routine is executed as the result of timeout, a\n * potential
          race can occur, possibly causing an incorrect interval for\n * the next
          poll.  This is considered so unlikely as to be negligible.\n */\n"
        - 'void

          '
        - "poll_update(\n        struct p *p,            /* peer structure pointer
          */\n        int     poll            /* poll interval (log2 s) */\n        )\n"
        - "{\n        /*\n         * This routine is called by both the poll() and
          packet()\n         * routines to determine the next poll time.  If within
          a burst\n         * the poll interval is two seconds.  Otherwise, it is
          the\n         * minimum of the host poll interval and peer poll interval,
          but\n         * not greater than MAXPOLL and not less than MINPOLL.  The\n
          \        * design ensures that a longer interval can be preempted by a\n
          \        * shorter one if required for rapid response.\n         */\n        p->hpoll
          = max(min(MAXPOLL, poll), MINPOLL);\n        if (p->burst > 0) {\n                if
          (p->nextdate != c.t)\n                        return;\n                else\n
          \                       p->nextdate += BTIME;\n        } else {\n                /*\n
          \                * While not shown here, the reference implementation\n
          \                * randomizes the poll interval by a small factor.\n                 */\n
          \               p->nextdate = p->outdate + (1 << max(min(p->ppoll,\n                    p->hpoll),
          MINPOLL));\n        }\n        /*\n         * It might happen that the due
          time has already passed.  If so,\n         * make it one second in the future.\n
          \        */\n        if (p->nextdate <= c.t)\n                p->nextdate
          = c.t + 1;\n"
        - '}

          '
        title: A.5.7.2.  poll_update()
      - contents:
        - 'A.5.7.3.  peer_xmit()

          '
        - "/*\n * transmit() - transmit a packet for association p\n */\n"
        - 'void

          '
        - "peer_xmit(\n        struct p *p             /* peer structure pointer */\n
          \       )\n"
        - "{\n        struct x x;             /* transmit packet */\n        /*\n
          \        * Initialize header and transmit timestamp\n         */\n        x.srcaddr
          = p->dstaddr;\n        x.dstaddr = p->srcaddr;\n        x.leap = s.leap;\n
          \       x.version = p->version;\n        x.mode = p->hmode;\n        if
          (s.stratum == MAXSTRAT)\n                x.stratum = 0;\n        else\n
          \               x.stratum = s.stratum;\n        x.poll = p->hpoll;\n        x.precision
          = s.precision;\n        x.rootdelay = D2FP(s.rootdelay);\n        x.rootdisp
          = D2FP(s.rootdisp);\n        x.refid = s.refid;\n        x.reftime = s.reftime;\n
          \       x.org = p->org;\n        x.rec = p->rec;\n        x.xmt = get_time();\n
          \       p->xmt = x.xmt;\n        /*\n         * If the key ID is nonzero,
          send a valid MAC using the key ID\n         * of the association and the
          key in the local key cache.  If\n         * something breaks, like a missing
          trusted key, don't send the\n         * packet; just reset the association
          and stop until the problem\n         * is fixed.\n         */\n        if
          (p->keyid)\n                if (/* p->keyid invalid */ 0) {\n                        clear(p,
          X_NKEY);\n                        return;\n                }\n                x.dgst
          = md5(p->keyid);\n        xmit_packet(&x);\n"
        - '}

          '
        title: A.5.7.3.  peer_xmit()
      title: A.5.7.  Poll Process
    title: A.5.  Peer Process
  title: Appendix A.  Code Skeleton
- contents:
  - "Authors' Addresses\n   Dr. David L. Mills\n   University of Delaware\n   Newark,
    DE  19716\n   US\n   Phone: +1 302 831 8247\n   EMail: mills@udel.edu\n   Jim
    Martin (editor)\n   Internet Systems Consortium\n   950 Charter Street\n   Redwood
    City, CA  94063\n   US\n   Phone: +1 650 423 1378\n   EMail: jrmii@isc.org\n   Jack
    Burbank\n   The Johns Hopkins University Applied Physics Laboratory\n   11100
    Johns Hopkins Road\n   Laurel, MD  20723-6099\n   US\n   Phone: +1 443 778 7127\n
    \  EMail: jack.burbank@jhuapl.edu\n   William Kasch\n   The Johns Hopkins University
    Applied Physics Laboratory\n   11100 Johns Hopkins Road\n   Laurel, MD  20723-6099\n
    \  US\n   Phone: +1 443 778 7463\n   EMail: william.kasch@jhuapl.edu\n"
  title: Authors' Addresses
