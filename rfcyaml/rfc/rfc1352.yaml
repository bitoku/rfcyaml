- title: __initial_text__
  contents:
  - '                        SNMP Security Protocols

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an IAB standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements. Please refer to the current edition of the \"IAB\n   Official\
    \ Protocol Standards\" for the standardization state and status\n   of this protocol.\
    \ Distribution of this memo is unlimited.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.    Abstract . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .   2\n   2.    Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   2\n   2.1   Threats  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   3\n   2.2   Goals and Constraints  . . . . . . . . . . . . . . . .\
    \ . . .   5\n   2.3   Security Services  . . . . . . . . . . . . . . . . . . .\
    \ . .   6\n   2.4   Mechanisms . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n   2.4.1   Message Digest Algorithm . . . . . . . . . . . . . . . . .\
    \   7\n   2.4.2   Symmetric Encryption Algorithm . . . . . . . . . . . . . . \
    \  8\n   3.    SNMP Party   . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 9\n   4.    Digest Authentication Protocol . . . . . . . . . . . . . . .  11\n\
    \   4.1   Generating a Message   . . . . . . . . . . . . . . . . . . .  14\n \
    \  4.2   Receiving a Message  . . . . . . . . . . . . . . . . . . . .  15\n  \
    \ 5.    Symmetric Privacy Protocol . . . . . . . . . . . . . . . . .  16\n   5.1\
    \   Generating a Message   . . . . . . . . . . . . . . . . . . .  17\n   5.2 \
    \  Receiving a Message  . . . . . . . . . . . . . . . . . . . .  18\n   6.   \
    \ Clock and Secret Distribution  . . . . . . . . . . . . . . .  19\n   6.1   Initial\
    \ Configuration    . . . . . . . . . . . . . . . . . .  20\n   6.2   Clock Distribution\
    \   . . . . . . . . . . . . . . . . . . . .  22\n   6.3   Clock Synchronization\
    \  . . . . . . . . . . . . . . . . . . .  24\n   6.4   Secret Distribution  .\
    \ . . . . . . . . . . . . . . . . . . .  26\n   6.5   Crash Recovery   . . . .\
    \ . . . . . . . . . . . . . . . . . .  28\n   7.    Security Considerations  .\
    \ . . . . . . . . . . . . . . . . .  30\n   7.1   Recommended Practices  . . .\
    \ . . . . . . . . . . . . . . . .  30\n   7.2   Conformance    . . . . . . . .\
    \ . . . . . . . . . . . . . . .  33\n   7.3   Protocol Correctness . . . . . .\
    \ . . . . . . . . . . . . . .  34\n   7.3.1   Clock Monotonicity Mechanism . .\
    \ . . . . . . . . . . . . .  35\n   7.3.2   Data Integrity Mechanism . . . . .\
    \ . . . . . . . . . . . .  36\n   7.3.3   Data Origin Authentication Mechanism\
    \ . . . . . . . . . . .  36\n   7.3.4   Restricted Administration Mechanism  .\
    \ . . . . . . . . . .  36\n   7.3.5   Ordered Delivery Mechanism   . . . . . .\
    \ . . . . . . . . .  37\n   7.3.6   Message Timeliness Mechanism . . . . . . .\
    \ . . . . . . . .  38\n   7.3.7   Selective Clock Acceleration Mechanism . . .\
    \ . . . . . . .  38\n   7.3.8   Confidentiality Mechanism  . . . . . . . . . .\
    \ . . . . . .  39\n   8.    Acknowledgements . . . . . . . . . . . . . . . . .\
    \ . . . . .  39\n   9.    References . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  40\n   10.   Authors' Addresses . . . . . . . . . . . . . . . . . .\
    \ . . .  41\n"
- title: 1.  Abstract
  contents:
  - "1.  Abstract\n   The Simple Network Management Protocol (SNMP) specification\
    \ [1]\n   allows for the protection of network management operations by a\n  \
    \ variety of security protocols.  The SNMP administrative model\n   described\
    \ in [2] provides a framework for securing SNMP network\n   management. In the\
    \ context of that framework, this memo defines\n   protocols to support the following\
    \ three security services:\n     o data integrity,\n     o data origin authentication,\
    \ and\n     o data confidentiality.\n   Please send comments to the SNMP Security\
    \ Developers mailing list\n   (snmp-sec-dev@tis.com).\n"
- title: 2.  Introduction
  contents:
  - "2.  Introduction\n   In the model described in [2], each SNMP party is, by definition,\n\
    \   associated with a single authentication protocol.  The authentication\n  \
    \ protocol provides a mechanism by which SNMP management communications\n   transmitted\
    \ by the party may be reliably identified as having\n   originated from that party.\
    \ The authentication protocol defined in\n   this memo also reliably determines\
    \ that the message received is the\n   message that was sent.\n   Similarly, each\
    \ SNMP party is, by definition, associated with a\n   single privacy protocol.\
    \ The privacy protocol provides a mechanism by\n   which SNMP management communications\
    \ transmitted to said party are\n   protected from disclosure. The privacy protocol\
    \ in this memo\n   specifies that only authenticated messages may be protected\
    \ from\n   disclosure.\n   These protocols are secure alternatives to the so-called\
    \ \"trivial\"\n   protocol defined in [1].\n      USE OF THE TRIVIAL PROTOCOL\
    \ ALONE DOES NOT CONSTITUTE SECURE\n      NETWORK MANAGEMENT. THEREFORE, A NETWORK\
    \ MANAGEMENT SYSTEM THAT\n      IMPLEMENTS ONLY THE TRIVIAL PROTOCOL IS NOT CONFORMANT\
    \ TO THIS\n      SPECIFICATION.\n   The Digest Authentication Protocol is described\
    \ in Section 4.  It\n   provides a data integrity service by transmitting a message\
    \ digest --\n   computed by the originator and verified by the recipient -- with\
    \ each\n   SNMP message. The data origin authentication service is provided by\n\
    \   prefixing the message with a secret value known only to the\n   originator\
    \ and recipient, prior to computing the digest. Thus, data\n   integrity is supported\
    \ explicitly while data origin authentication is\n   supported implicitly in the\
    \ verification of the digest.\n   The Symmetric Privacy Protocol is described\
    \ in Section 5. It protects\n   messages from disclosure by encrypting their contents\
    \ according to a\n   secret cryptographic key known only to the originator and\
    \ recipient.\n   The additional functionality afforded by this protocol is assumed\
    \ to\n   justify its additional computational cost.\n   The Digest Authentication\
    \ Protocol depends on the existence of\n   loosely synchronized clocks between\
    \ the originator and recipient of a\n   message. The protocol specification makes\
    \ no assumptions about the\n   strategy by which such clocks are synchronized.\
    \ Section 6.3 presents\n   one strategy that is particularly suited to the demands\
    \ of SNMP\n   network management.\n   Both protocols described here require the\
    \ sharing of secret\n   information between the originator of a message and its\
    \ recipient.\n   The protocol specifications assume the existence of the necessary\n\
    \   secrets. The selection of such secrets and their secure distribution\n   to\
    \ appropriate parties may be accomplished by a variety of\n   strategies. Section\
    \ 6.4 presents one such strategy that is\n   particularly suited to the demands\
    \ of SNMP network management.\n"
- title: 2.1   Threats
  contents:
  - "2.1   Threats\n   Several of the classical threats to network protocols are applicable\n\
    \   to the network management problem and therefore would be applicable\n   to\
    \ any SNMP security protocol. Other threats are not applicable to\n   the network\
    \ management problem. This section discusses principal\n   threats, secondary\
    \ threats, and threats which are of lesser\n   importance.\n   The principal threats\
    \ against which any SNMP security protocol should\n   provide protection are:\n\
    \   Modification of Information.\n      The SNMP protocol provides the means for\
    \ management stations to\n      interrogate and to manipulate the value of objects\
    \ in a managed\n      agent.  The modification threat is the danger that some\
    \ party may\n      alter in-transit messages generated by an authorized party\
    \ in such\n      a way as to effect unauthorized management operations, including\n\
    \      falsifying the value of an object.\n   Masquerade.\n      The SNMP administrative\
    \ model includes an access control model.\n      Access control necessarily depends\
    \ on knowledge of the origin of a\n      message.  The masquerade threat is the\
    \ danger that management\n      operations not authorized for some party may be\
    \ attempted by that\n      party by assuming the identity of another party that\
    \ has the\n      appropriate authorizations.\n   Two secondary threats are also\
    \ identified. The security protocols\n   defined in this memo do provide protection\
    \ against:\n   Message Stream Modification.\n      The SNMP protocol is based\
    \ upon connectionless transport services.\n      The message stream modification\
    \ threat is the danger that messages\n      may be arbitrarily re-ordered, delayed\
    \ or replayed to effect\n      unauthorized management operations.  This threat\
    \ may arise either\n      by the work of a malicious attacker or by the natural\
    \ operation of\n      a subnetwork service.\n   Disclosure.\n      The disclosure\
    \ threat is the danger of eavesdropping on the\n      exchanges between managed\
    \ agents and a management station.\n      Protecting against this threat is mandatory\
    \ when the SNMP is used\n      to administer private parameters on which its security\
    \ is based.\n      Protecting against the disclosure threat may also be required\
    \ as a\n      matter of local policy.\n   There are at least two threats that\
    \ a SNMP security protocol need not\n   protect against. The security protocols\
    \ defined in this memo do not\n   provide protection against:\n   Denial of Service.\n\
    \      A SNMP security protocol need not attempt to address the broad\n      range\
    \ of attacks by which service to authorized parties is denied.\n      Indeed,\
    \ such denial-of-service attacks are in many cases\n      indistinguishable from\
    \ the type of network failures with which any\n      viable network management\
    \ protocol must cope as a matter of\n      course.\n   Traffic Analysis.\n   \
    \   In addition, a SNMP security protocol need not attempt to address\n      traffic\
    \ analysis attacks.  Indeed, many traffic patterns are\n      predictable -- agents\
    \ may be managed on a regular basis by a\n      relatively small number of management\
    \ stations -- and therefore\n      there is no significant advantage afforded\
    \ by protecting against\n      traffic analysis.\n"
- title: 2.2   Goals and Constraints
  contents:
  - "2.2   Goals and Constraints\n   Based on the foregoing account of threats in\
    \ the SNMP network\n   management environment, the goals of a SNMP security protocol\
    \ are\n   enumerated below.\n    1. The protocol should provide for verification\
    \ that each\n       received SNMP message has not been modified during\n     \
    \  its transmission through the network in such a way that\n       an unauthorized\
    \ management operation might result.\n    2. The protocol should provide for verification\
    \ of the\n       identity of the originator of each received SNMP\n       message.\n\
    \    3. The protocol should provide that the apparent time of\n       generation\
    \ for each received SNMP message is recent.\n    4. The protocol should provide\
    \ that the apparent time of\n       generation for each received SNMP message\
    \ is\n       subsequent to that for all previously delivered messages\n      \
    \ of similar origin.\n    5. The protocol should provide, when necessary, that\
    \ the\n       contents of each received SNMP message are protected\n       from\
    \ disclosure.\n   In addition to the principal goal of supporting secure network\n\
    \   management, the design of any SNMP security protocol is also\n   influenced\
    \ by the following constraints:\n    1. When the requirements of effective management\
    \ in times\n       of network stress are inconsistent with those of security,\n\
    \       the former are preferred.\n    2. Neither the security protocol nor its\
    \ underlying security\n       mechanisms should depend upon the ready availability\n\
    \       of other network services (e.g., Network Time Protocol\n       (NTP) or\
    \ secret/key management protocols).\n    3. A security mechanism should entail\
    \ no changes to the\n       basic SNMP network management philosophy.\n"
- title: 2.3   Security Services
  contents:
  - "2.3   Security Services\n   The security services necessary to support the goals\
    \ of a SNMP\n   security protocol are as follows.\n   Data Integrity   is the\
    \ provision of the property that data\n       and data sequences have not been\
    \ altered or destroyed\n       in an unauthorized manner.\n   Data Origin Authentication\
    \    is the provision of the\n       property that the claimed origin of received\
    \ data is\n       corroborated.\n   Data Confidentiality   is the provision of\
    \ the property that\n       information is not made available or disclosed to\n\
    \       unauthorized individuals, entities, or processes.\n      The protocols\
    \ specified in this memo require both data\n      integrity and data origin authentication\
    \ to be used at all\n      times. For these protocols, it is not possible to realize\
    \ data\n      integrity without data origin authentication, nor is it possible\n\
    \      to realize data origin authentication without data integrity.\n      Further,\
    \ there is no provision for data confidentiality without\n      both data integrity\
    \ and data origin authentication.\n"
- title: 2.4   Mechanisms
  contents:
  - "2.4   Mechanisms\n      The security protocols defined in this memo employ several\n\
    \      types of mechanisms in order to realize the goals and security\n      services\
    \ described above:\n     o In support of data integrity, a message digest algorithm\n\
    \       is required. A digest is calculated over an appropriate\n       portion\
    \ of a SNMP message and included as part of the\n       message sent to the recipient.\n\
    \     o In support of data origin authentication and data\n       integrity, the\
    \ portion of a SNMP message that is\n       digested is first prefixed with a\
    \ secret value shared by\n       the originator of that message and its intended\
    \ recipient.\n     o To protect against the threat of message reordering, a\n\
    \       timestamp value is included in each message generated.\n       A recipient\
    \ evaluates the timestamp to determine if the\n       message is recent and it\
    \ uses the timestamp to determine\n       if the message is ordered relative to\
    \ other messages it\n       has received. In conjunction with other readily available\n\
    \       information (e.g., the request-id), the timestamp also\n       indicates\
    \ whether or not the message is a replay of a\n       previous message. This protection\
    \ against the threat of\n       message reordering implies no protection against\n\
    \       unauthorized deletion or suppression of messages.\n     o In support of\
    \ data confidentiality, a symmetric\n       encryption algorithm is required.\
    \ An appropriate\n       portion of the message is encrypted prior to being\n\
    \       transmitted to its recipient.\n   The security protocols in this memo\
    \ are defined independently of the\n   particular choice of a message digest and\
    \ encryption algorithm --\n   owing principally to the lack of a suitable metric\
    \ by which to\n   evaluate the security of particular algorithm choices. However,\
    \ in\n   the interests of completeness and in order to guarantee\n   interoperability,\
    \ Sections 2.4.1 and 2.4.2 specify particular\n   choices, which are considered\
    \ acceptably secure as of this writing.\n   In the future, this memo may be updated\
    \ by the publication of a memo\n   specifying substitute or alternate choices\
    \ of algorithms, i.e., a\n   replacement for or addition to the sections below.\n"
- title: 2.4.1   Message Digest Algorithm
  contents:
  - "2.4.1   Message Digest Algorithm\n   In support of data integrity, the use of\
    \ the MD5 [3] message digest\n   algorithm is chosen. A 128-bit digest is calculated\
    \ over the\n   designated portion of a SNMP message and included as part of the\n\
    \   message sent to the recipient.\n   An appendix of [3] contains a C Programming\
    \ Language implementation\n   of the algorithm. This code was written with portability\
    \ being the\n   principal objective. Implementors may wish to optimize the\n \
    \  implementation with respect to the characteristics of their hardware\n   and\
    \ software platforms.\n   The use of this algorithm in conjunction with the Digest\n\
    \   Authentication Protocol (see Section 4) is identified by the ASN.1\n   object\
    \ identifier value md5AuthProtocol, defined in [4].\n   For any SNMP party for\
    \ which the authentication protocol is\n   md5AuthProtocol, the size of its private\
    \ authentication key is 16\n   octets.\n   Within an authenticated management\
    \ communication generated by such a\n   party, the size of the authDigest component\
    \ of that communication\n   (see Section 4) is 16 octets.\n"
- title: 2.4.2   Symmetric Encryption Algorithm
  contents:
  - "2.4.2   Symmetric Encryption Algorithm\n   In support of data confidentiality,\
    \ the use of the Data Encryption\n   Standard (DES) in the Cipher Block Chaining\
    \ mode of operation is\n   chosen. The designated portion of a SNMP message is\
    \ encrypted and\n   included as part of the message sent to the recipient.\n \
    \  Two organizations have published specifications defining the DES: the\n   National\
    \ Institute of Standards and Technology (NIST) [5] and the\n   American National\
    \ Standards Institute [6].  There is a companion\n   Modes of Operation specification\
    \ for each definition (see [7] and\n   [8], respectively).\n   The NIST has published\
    \ three additional documents that implementors\n   may find useful.\n     o There\
    \ is a document with guidelines for implementing\n       and using the DES, including\
    \ functional specifications\n       for the DES and its modes of operation [9].\n\
    \     o There is a specification of a validation test suite for the\n       DES\
    \ [10]. The suite is designed to test all aspects of the\n       DES and is useful\
    \ for pinpointing specific problems.\n     o There is a specification of a maintenance\
    \ test for the\n       DES [11]. The test utilizes a minimal amount of data\n\
    \       and processing to test all components of the DES. It\n       provides\
    \ a simple yes-or-no indication of correct\n       operation and is useful to\
    \ run as part of an initialization\n       step, e.g., when a computer reboots.\n\
    \   The use of this algorithm in conjunction with the Symmetric Privacy\n   Protocol\
    \ (see Section 5) is identified by the ASN.1 object identifier\n   value desPrivProtocol,\
    \ defined in [4].\n   For any SNMP party for which the privacy protocol is desPrivProtocol,\n\
    \   the size of the private privacy key is 16 octets, of which the first\n   8\
    \ octets are a DES key and the second 8 octets are a DES\n   Initialization Vector.\
    \ The 64-bit DES key in the first 8 octets of\n   the private key is a 56 bit\
    \ quantity used directly by the algorithm\n   plus 8 parity bits -- arranged so\
    \ that one parity bit is the least\n   significant bit of each octet. The setting\
    \ of the parity bits is\n   ignored.\n   The length of the octet sequence to be\
    \ encrypted by the DES must be\n   an integral multiple of 8. When encrypting,\
    \ the data should be padded\n   at the end as necessary; the actual pad value\
    \ is insignificant.\n   If the length of the octet sequence to be decrypted is\
    \ not an\n   integral multiple of 8 octets, the processing of the octet sequence\n\
    \   should be halted and an appropriate exception noted. Upon decrypting,\n  \
    \ the padding should be ignored.\n"
- title: 3.  SNMP Party
  contents:
  - "3.  SNMP Party\n   Recall from [2] that a SNMP party is a conceptual, virtual\
    \ execution\n   context whose operation is restricted (for security or other\n\
    \   purposes) to an administratively defined subset of all possible\n   operations\
    \ of a particular SNMP protocol entity. A SNMP protocol\n   entity is an actual\
    \ process which performs network management\n   operations by generating and/or\
    \ responding to SNMP protocol messages\n   in the manner specified in [1]. Architecturally,\
    \ every SNMP protocol\n   entity maintains a local database that represents all\
    \ SNMP parties\n   known to it.\n   A SNMP party may be represented by an ASN.1\
    \ value with the following\n   syntax.\n      SnmpParty ::= SEQUENCE {\n     \
    \   partyIdentity\n           OBJECT IDENTIFIER,\n        partyTDomain\n     \
    \      OBJECT IDENTIFIER,\n        partyTAddr\n           OCTET STRING,\n    \
    \    partyProxyFor\n           OBJECT IDENTIFIER,\n        partyMaxMessageSize\n\
    \           INTEGER,\n        partyAuthProtocol\n           OBJECT IDENTIFIER,\n\
    \        partyAuthClock\n           INTEGER,\n        partyAuthLastMsg\n     \
    \      INTEGER,\n        partyAuthNonce\n           INTEGER,\n        partyAuthPrivate\n\
    \           OCTET STRING,\n        partyAuthPublic\n           OCTET STRING,\n\
    \        partyAuthLifetime\n           INTEGER,\n        partyPrivProtocol\n \
    \          OBJECT IDENTIFIER,\n        partyPrivPrivate\n           OCTET STRING,\n\
    \        partyPrivPublic\n           OCTET STRING\n      }\n   For each SnmpParty\
    \ value that represents a SNMP party, the generic\n   significance of each of\
    \ its components is defined in [2]. For each\n   SNMP party that supports the\
    \ generation of messages using the Digest\n   Authentication Protocol, additional,\
    \ special significance is\n   attributed to certain components of that party's\
    \ representation:\n     o Its partyAuthProtocol component is called the\n    \
    \   authentication protocol and identifies a combination of\n       the Digest\
    \ Authentication Protocol with a particular\n       digest algorithm (such as\
    \ that defined in Section 2.4.1).\n       This combined mechanism is used to authenticate\
    \ the\n       origin and integrity of all messages generated by the\n       party.\n\
    \     o Its partyAuthClock component is called the\n       authentication clock\
    \ and represents a notion of the\n       current time that is specific to the\
    \ party.\n     o Its partyAuthLastMsg component is called the\n       last-timestamp\
    \ and represents a notion of time\n       associated with the most recent, authentic\
    \ protocol\n       message generated by the party.\n     o Its partyAuthNonce\
    \ component is called the nonce\n       and represents a monotonically increasing\
    \ integer\n       associated with the most recent, authentic protocol\n      \
    \ message generated by the party. The nonce associated\n       with a particular\
    \ message distinguishes it among all\n       others transmitted in the same unit\
    \ time interval.\n     o Its partyAuthPrivate component is called the private\n\
    \       authentication key and represents any secret value\n       needed to support\
    \ the Digest Authentication Protocol\n       and associated digest algorithm.\n\
    \     o Its partyAuthPublic component is called the public\n       authentication\
    \ key and represents any public value that\n       may be needed to support the\
    \ authentication protocol.\n       This component is not significant except as\
    \ suggested in\n       Section 6.4.\n     o Its partyAuthLifetime component is\
    \ called the\n       lifetime and represents an administrative upper bound\n \
    \      on acceptable delivery delay for protocol messages\n       generated by\
    \ the party.\n   For each SNMP party that supports the receipt of messages via\
    \ the\n   Symmetric Privacy Protocol, additional, special significance is\n  \
    \ attributed to certain components of that party's representation:\n     o Its\
    \ partyPrivProtocol component is called the privacy\n       protocol and identifies\
    \ a combination of the Symmetric\n       Privacy Protocol with a particular encryption\
    \ algorithm\n       (such as that defined in Section 2.4.2). This combined\n \
    \      mechanism is used to protect from disclosure all protocol\n       messages\
    \ received by the party.\n     o Its partyPrivPrivate component is called the\
    \ private\n       privacy key and represents any secret value needed to\n    \
    \   support the Symmetric Privacy Protocol and associated\n       encryption algorithm.\n\
    \     o Its partyPrivPublic component is called the public\n       privacy key\
    \ and represents any public value that may be\n       needed to support the privacy\
    \ protocol. This component\n       is not significant except as suggested in Section\
    \ 6.4.\n"
- title: 4.  Digest Authentication Protocol
  contents:
  - "4.  Digest Authentication Protocol\n   This section describes the Digest Authentication\
    \ Protocol. It\n   provides both for verifying the integrity of a received message\n\
    \   (i.e., the message received is the message sent) and for verifying\n   the\
    \ origin of a message (i.e., the reliable identification of the\n   originator).\
    \ The integrity of the message is protected by computing a\n   digest over an\
    \ appropriate portion of a message. The digest is\n   computed by the originator\
    \ of the message, transmitted with the\n   message, and verified by the recipient\
    \ of the message.\n   A secret value known only to the originator and recipient\
    \ of the\n   message is prefixed to the message prior to the digest computation.\n\
    \   Thus, the origin of the message is known implicitly with the\n   verification\
    \ of the digest.\n   Recall from [2] that a SNMP management communication is represented\n\
    \   by an ASN.1 value with the following syntax.\n      SnmpMgmtCom ::= [1] IMPLICIT\
    \ SEQUENCE {\n        dstParty\n           OBJECT IDENTIFIER,\n        srcParty\n\
    \           OBJECT IDENTIFIER,\n        pdu   PDUs\n      }\n   For each SnmpMgmtCom\
    \ value that represents a SNMP management\n   communication, the following statements\
    \ are true:\n     o Its dstParty component is called the destination and\n   \
    \    identifies the SNMP party to which the communication\n       is directed.\n\
    \     o Its srcParty component is called the source and\n       identifies the\
    \ SNMP party from which the\n       communication is originated.\n     o Its pdu\
    \ component has the form and significance\n       attributed to it in [1].\n \
    \  Recall from [2] that a SNMP authenticated management communication is\n   represented\
    \ by an ASN.1 value with the following syntax.\n      SnmpAuthMsg ::= [1] IMPLICIT\
    \ SEQUENCE {\n        authInfo\n           ANY, - defined by authentication protocol\n\
    \        authData\n           SnmpMgmtCom\n      }\n   For each SnmpAuthMsg value\
    \ that represents a SNMP authenticated\n   management communication, the following\
    \ statements are true:\n     o Its authInfo component is called the authentication\n\
    \       information and represents information required in\n       support of\
    \ the authentication protocol used by the\n       SNMP party originating the message.\
    \ The detailed\n       significance of the authentication information is specific\n\
    \       to the authentication protocol in use; it has no effect on\n       the\
    \ application semantics of the communication other\n       than its use by the\
    \ authentication protocol in\n       determining whether the communication is\
    \ authentic or\n       not.\n     o Its authData component is called the authentication\n\
    \       data and represents a SNMP management\n       communication.\n   In support\
    \ of the Digest Authentication Protocol, an authInfo\n   component is of type\
    \ AuthInformation:\n      AuthInformation ::= [1] IMPLICIT SEQUENCE {\n      \
    \  authTimestamp\n           INTEGER (0..2147483647),\n        authNonce\n   \
    \        INTEGER (0..2147483647),\n        authDigest\n           OCTET STRING\n\
    \      }\n   For each AuthInformation value that represents authentication\n \
    \  information, the following statements are true:\n     o Its authTimestamp component\
    \ is called the\n       authentication timestamp and represents the time of the\n\
    \       generation of the message according to the\n       partyAuthClock of the\
    \ SNMP party that originated\n       it. Note that the granularity of the authentication\n\
    \       timestamp is 1 second.\n     o Its authNonce component is called the authentication\n\
    \       nonce and represents a non-negative integer value\n       evaluated according\
    \ to the authTimestamp value. In\n       order not to limit transmission frequency\
    \ of management\n       communications to the granularity of the authentication\n\
    \       timestamp, the authentication nonce is provided to\n       differentiate\
    \ between multiple messages sent with the\n       same value of authTimestamp.\
    \ The authentication\n       nonce is a monotonically increasing sequence number,\n\
    \       that is reset for each new authentication timestamp\n       value.\n \
    \    o Its authDigest component is called the authentication\n       digest and\
    \ represents the digest computed over an\n       appropriate portion of the message,\
    \ where the message is\n       temporarily prefixed with a secret value for the\
    \ purposes\n       of computing the digest.\n"
- title: 4.1   Generating a Message
  contents:
  - "4.1   Generating a Message\n   This section describes the behavior of a SNMP\
    \ protocol entity when it\n   acts as a SNMP party for which the authentication\
    \ protocol is\n   administratively specified as the Digest Authentication Protocol.\n\
    \   Insofar as the behavior of a SNMP protocol entity when transmitting\n   protocol\
    \ messages is defined generically in [2], only those aspects\n   of that behavior\
    \ that are specific to the Digest Authentication\n   Protocol are described below.\
    \ In particular, this section describes\n   the encapsulation of a SNMP management\
    \ communication into a SNMP\n   authenticated management communication.\n   According\
    \ to [2], a SnmpAuthMsg value is constructed during Step 3 of\n   generic processing.\
    \ In particular, it states the authInfo component\n   is constructed according\
    \ to the authentication protocol identified\n   for the SNMP party originating\
    \ the message. When the relevant\n   authentication protocol is the Digest Authentication\
    \ Protocol, the\n   procedure performed by a SNMP protocol entity whenever a management\n\
    \   communication is to be transmitted by a SNMP party is as follows.\n    1.\
    \ The local database is consulted to determine the\n       authentication clock,\
    \ last-timestamp, nonce, and private\n       authentication key (extracted, for\
    \ example, according to\n       the conventions defined in Section 2.4.1) of the\
    \ SNMP\n       party originating the message.\n    2. The authTimestamp component\
    \ is set to the retrieved\n       authentication clock value.\n    3. If the last-timestamp\
    \ is equal to the authentication\n       clock, the nonce is incremented. Otherwise\
    \ the nonce is\n       set to zero. The authNonce component is set to the\n  \
    \     nonce value. In the local database, the originating\n       SNMP party's\
    \ nonce and last-timestamp are set to the\n       nonce value and the authentication\
    \ clock, respectively.\n    4. The authentication digest is temporarily set to\
    \ the\n       private authentication key. The SnmpAuthMsg value\n       is serialized\
    \ according to the conventions of [12] and [1].\n       A digest is computed over\
    \ the octet sequence\n       representing that serialized value using, for example,\
    \ the\n       algorithm specified in Section 2.4.1. The authDigest\n       component\
    \ is set to the computed digest value.\n   As set forth in [2], the SnmpAuthMsg\
    \ value is then encapsulated\n   according to the appropriate privacy protocol\
    \ into a SnmpPrivMsg\n   value. This latter value is then serialized and transmitted\
    \ to the\n   receiving SNMP party.\n"
- title: 4.2   Receiving a Message
  contents:
  - "4.2   Receiving a Message\n   This section describes the behavior of a SNMP protocol\
    \ entity upon\n   receipt of a protocol message from a SNMP party for which the\n\
    \   authentication protocol is administratively specified as the Digest\n   Authentication\
    \ Protocol. Insofar as the behavior of a SNMP protocol\n   entity when receiving\
    \ protocol messages is defined generically in\n   [2], only those aspects of that\
    \ behavior that are specific to the\n   Digest Authentication Protocol are described\
    \ below.\n   According to [2], a SnmpAuthMsg value is evaluated during Step 9\
    \ of\n   generic processing. In particular, it states the SnmpAuthMsg value is\n\
    \   evaluated according to the authentication protocol identified for the\n  \
    \ SNMP party that originated the message. When the relevant\n   authentication\
    \ protocol is the Digest Authentication Protocol, the\n   procedure performed\
    \ by a SNMP protocol entity whenever a management\n   communication is received\
    \ by a SNMP party is as follows.\n    1. If the ASN.1 type of the authInfo component\
    \ is not\n       AuthInformation, the message is evaluated as\n       unauthentic.\
    \ Otherwise, the authTimestamp,\n       authNonce, and authDigest components are\n\
    \       extracted from the SnmpAuthMsg value.\n    2. The local database is consulted\
    \ to determine the\n       authentication clock, last-timestamp, nonce, private\n\
    \       authentication key (extracted, for example, according to\n       the conventions\
    \ defined in Section 2.4.1), and lifetime of\n       the SNMP party that originated\
    \ the message.\n    3. If the authTimestamp component plus the lifetime is\n \
    \      less than the authentication clock, the message is\n       evaluated as\
    \ unauthentic.\n    4. If the authTimestamp component is less than the\n     \
    \  last-timestamp recorded for the originating party in the\n       local database,\
    \ the message is evaluated as unauthentic.\n    5. If the authTimestamp component\
    \ is equal to the\n       last-timestamp and if the authNonce component is less\n\
    \       than or equal to the nonce, the message is evaluated as\n       unauthentic.\n\
    \    6. The authDigest component is extracted and\n       temporarily recorded.\n\
    \    7. A new SnmpAuthMsg value is constructed such that\n       its authDigest\
    \ component is set to the private\n       authentication key and its other components\
    \ are set to\n       the value of the corresponding components in the\n      \
    \ received SnmpAuthMsg value. This new\n       SnmpAuthMsg value is serialized\
    \ according to the\n       conventions of [12] and [1]. A digest is computed over\n\
    \       the octet sequence representing that serialized value\n       using, for\
    \ example, the algorithm specified in\n       Section 2.4.1.\n    8. If the computed\
    \ digest value is not equal to the\n       previously recorded digest value, the\
    \ message is\n       evaluated as unauthentic.\n    9. The message is evaluated\
    \ as authentic.\n   10. The last-timestamp and nonce values locally recorded\n\
    \       for the originating SNMP party are set to the\n       authTimestamp value\
    \ and the authNonce value,\n       respectively.\n   11. The authentication clock\
    \ value locally recorded for the\n       originating SNMP party is advanced to\
    \ the\n       authTimestamp value if this latter exceeds the\n       recorded\
    \ value.\n   If the SnmpAuthMsg value is evaluated as unauthentic, an\n   authentication\
    \ failure is noted and the received message is discarded\n   without further processing.\
    \ Otherwise, processing of the received\n   message continues as specified in\
    \ [2].\n"
- title: 5.  Symmetric Privacy Protocol
  contents:
  - "5.  Symmetric Privacy Protocol\n   This section describes the Symmetric Privacy\
    \ Protocol. It provides\n   for protection from disclosure of a received message.\
    \  An appropriate\n   portion of the message is encrypted according to a secret\
    \ key known\n   only to the originator and recipient of the message.\n   This\
    \ protocol assumes the underlying mechanism is a symmetric\n   encryption algorithm.\
    \ In addition, the message to be encrypted must\n   be protected according to\
    \ the conventions of the Digest\n   Authentication Protocol.\n   Recall from [2]\
    \ that a SNMP private management communication is\n   represented by an ASN.1\
    \ value with the following syntax.\n      SnmpPrivMsg ::= [1] IMPLICIT SEQUENCE\
    \ {\n        privDst\n           OBJECT IDENTIFIER,\n        privData\n      \
    \     [1] IMPLICIT OCTET STRING\n      }\n   For each SnmpPrivMsg value that represents\
    \ a SNMP private management\n   communication, the following statements are true:\n\
    \     o Its privDst component is called the privacy destination\n       and identifies\
    \ the SNMP party to which the\n       communication is directed.\n     o Its privData\
    \ component is called the privacy data and\n       represents the (possibly encrypted)\
    \ serialization\n       (according to the conventions of [12] and [1]) of a SNMP\n\
    \       authenticated management communication.\n"
- title: 5.1   Generating a Message
  contents:
  - "5.1   Generating a Message\n   This section describes the behavior of a SNMP\
    \ protocol entity when it\n   communicates with a SNMP party for which the privacy\
    \ protocol is\n   administratively specified as the Symmetric Privacy Protocol.\
    \ Insofar\n   as the behavior of a SNMP protocol entity when transmitting a\n\
    \   protocol message is defined generically in [2], only those aspects of\n  \
    \ that behavior that are specific to the Symmetric Privacy Protocol are\n   described\
    \ below. In particular, this section describes the\n   encapsulation of a SNMP\
    \ authenticated management communication into a\n   SNMP private management communication.\n\
    \   According to [2], a SnmpPrivMsg value is constructed during Step 5 of\n  \
    \ generic processing. In particular, it states the privData component\n   is constructed\
    \ according to the privacy protocol identified for the\n   SNMP party receiving\
    \ the message.  When the relevant privacy protocol\n   is the Symmetric Privacy\
    \ Protocol, the procedure performed by a SNMP\n   protocol entity whenever a management\
    \ communication is to be\n   transmitted by a SNMP party is as follows.\n    1.\
    \ If the SnmpAuthMsg value is not authenticated\n       according to the conventions\
    \ of the Digest\n       Authentication Protocol, the generation of the private\n\
    \       management communication fails according to a local\n       procedure,\
    \ without further processing.\n    2. The local database is consulted to determine\
    \ the private\n       privacy key of the SNMP party receiving the message\n  \
    \     (represented, for example, according to the conventions\n       defined\
    \ in Section 2.4.2).\n    3. The SnmpAuthMsg value is serialized according to\
    \ the\n       conventions of [12] and [1].\n    4. The octet sequence representing\
    \ the serialized\n       SnmpAuthMsg value is encrypted using, for example,\n\
    \       the algorithm specified in Section 2.4.2 and the\n       extracted private\
    \ privacy key.\n    5. The privData component is set to the encrypted value.\n\
    \      As set forth in [2], the SnmpPrivMsg value is then serialized\n      and\
    \ transmitted to the receiving SNMP party.\n"
- title: 5.2   Receiving a Message
  contents:
  - "5.2   Receiving a Message\n   This section describes the behavior of a SNMP protocol\
    \ entity when it\n   acts as a SNMP party for which the privacy protocol is\n\
    \   administratively specified as the Symmetric Privacy Protocol. Insofar\n  \
    \ as the behavior of a SNMP protocol entity when receiving a protocol\n   message\
    \ is defined generically in [2], only those aspects of that\n   behavior that\
    \ are specific to the Symmetric Privacy Protocol are\n   described below.\n  \
    \ According to [2], the privData component of a received SnmpPrivMsg\n   value\
    \ is evaluated during Step 4 of generic processing. In\n   particular, it states\
    \ the privData component is evaluated according\n   to the privacy protocol identified\
    \ for the SNMP party receiving the\n   message. When the relevant privacy protocol\
    \ is the Symmetric Privacy\n   Protocol, the procedure performed by a SNMP protocol\
    \ entity whenever\n   a management communication is received by a SNMP party is\
    \ as follows.\n    1. The local database is consulted to determine the private\n\
    \       privacy key of the SNMP party receiving the message\n       (represented,\
    \ for example, according to the conventions\n       defined in Section 2.4.2).\n\
    \    2. The contents octets of the privData component are\n       decrypted using,\
    \ for example, the algorithm specified in\n       Section 2.4.2 and the extracted\
    \ private privacy key.\n      Processing of the received message continues as\
    \ specified in [2].\n"
- title: 6.  Clock and Secret Distribution
  contents:
  - "6.  Clock and Secret Distribution\n   The protocols described in Sections 4 and\
    \ 5 assume the existence of\n   loosely synchronized clocks and shared secret\
    \ values. Three\n   requirements constrain the strategy by which clock values\
    \ and secrets\n   are distributed.\n     o If the value of an authentication clock\
    \ is decreased, the\n       last-timestamp and private authentication key must\
    \ be\n       changed concurrently.\n       When the value of an authentication\
    \ clock is decreased,\n       messages that have been sent with a timestamp value\n\
    \       between the value of the authentication clock and its\n       new value\
    \ may be replayed. Changing the private\n       authentication key obviates this\
    \ threat. However,\n       changing the authentication clock and the private\n\
    \       authentication key is not sufficient to ensure proper\n       operation.\
    \ If the last-timestamp is not reduced similarly\n       to the authentication\
    \ clock, no message will be\n       considered authentic until the value of the\
    \ authentication\n       clock exceeds the value of the last-timestamp.\n    \
    \ o The private authentication key and private privacy key\n       must be known\
    \ only to the parties requiring knowledge\n       of them.\n       Protecting\
    \ the secrets from disclosure is critical to the\n       security of the protocols.\
    \ In particular, if the secrets are\n       distributed via a network, the secrets\
    \ must be protected\n       with a protocol that supports confidentiality, e.g.,\
    \ the\n       Symmetric Privacy Protocol. Further, knowledge of the\n       secrets\
    \ must be as restricted as possible within an\n       implementation. In particular,\
    \ although the secrets may\n       be known to one or more persons during the\
    \ initial\n       configuration of a device, the secrets should be changed\n \
    \      immediately after configuration such that their actual\n       value is\
    \ known only to the software. A management\n       station has the additional\
    \ responsibility of recovering the\n       state of all parties whenever it boots,\
    \ and it may address\n       this responsibility by recording the secrets on a\n\
    \       long-term storage device. Access to information on this\n       device\
    \ must be as restricted as is practically possible.\n     o There must exist at\
    \ least one SNMP protocol entity that\n       assumes the role of a responsible\
    \ management station.\n       This management station is responsible for ensuring\
    \ that\n       all authentication clocks are synchronized and for\n       changing\
    \ the secret values when necessary. Although\n       more than one management\
    \ station may share this\n       responsibility, their coordination is essential\
    \ to the\n       secure management of the network. The mechanism by\n       which\
    \ multiple management stations ensure that no\n       more than one of them attempts\
    \ to synchronize the\n       clocks or update the secrets at any one time is a\
    \ local\n       implementation issue.\n       A responsible management station\
    \ may either support\n       clock synchronization and secret distribution as\
    \ separate\n       functions, or combine them into a single functional unit.\n\
    \   The first section below specifies the procedures by which a SNMP\n   protocol\
    \ entity is initially configured. The next two sections\n   describe one strategy\
    \ for distributing clock values and one for\n   determining a synchronized clock\
    \ value among SNMP parties supporting\n   the Digest Authentication Protocol.\
    \ For SNMP parties supporting the\n   Symmetric Privacy Protocol, the next section\
    \ describes a strategy for\n   distributing secret values. The last section specifies\
    \ the procedures\n   by which a SNMP protocol entity recovers from a \"crash.\"\
    \n"
- title: 6.1   Initial Configuration
  contents:
  - "6.1   Initial Configuration\n   This section describes the initial configuration\
    \ of a SNMP protocol\n   entity that supports the Digest Authentication Protocol\
    \ or both the\n   Digest Authentication Protocol and the Symmetric Privacy Protocol.\n\
    \   When a network device is first installed, its initial, secure\n   configuration\
    \ must be done manually, i.e., a person must physically\n   visit the device and\
    \ enter the initial secret values for at least its\n   first secure SNMP party.\
    \ This requirement suggests that the person\n   will have knowledge of the initial\
    \ secret values.\n   In general, the security of a system is enhanced as the number\
    \ of\n   entities that know a secret is reduced. Requiring a person to\n   physically\
    \ visit a device every time a SNMP party is configured not\n   only exposes the\
    \ secrets unnecessarily but is administratively\n   prohibitive. In particular,\
    \ when MD5 is used, the initial\n   authentication secret is 128 bits long and\
    \ when DES is used an\n   additional 128 bits are needed -- 64 bits each for the\
    \ key and\n   initialization vector. Clearly, these values will need to be recorded\n\
    \   on a medium in order to be transported between a responsible\n   management\
    \ station and a managed agent. The recommended procedure is\n   to configure a\
    \ small set of initial SNMP parties for each SNMP\n   protocol entity, one pair\
    \ of which may be used initially to configure\n   all other SNMP parties.\n  \
    \ In fact, there is a minimal, useful set of SNMP parties that could be\n   configured\
    \ between each responsible management station and managed\n   agent. This minimal\
    \ set includes one of each of the following for\n   both the responsible management\
    \ station and the managed agent:\n     o a SNMP party for which the authentication\
    \ protocol and\n       privacy protocol are the values noAuth and noPriv,\n  \
    \     respectively,\n     o a SNMP party for which the authentication protocol\n\
    \       identifies the mechanism defined in Section 2.4.1 and its\n       privacy\
    \ protocol is the value noPriv, and\n     o a SNMP party for which the authentication\
    \ protocol and\n       privacy protocol identify the mechanisms defined in\n \
    \      Section 2.4.1 and Section 2.4.2, respectively.\n   The last of these SNMP\
    \ parties in both the responsible management\n   station and the managed agent\
    \ could be used to configure all other\n   SNMP parties. It is the only suitable\
    \ party for this purpose because\n   it is the only party that supports data confidentiality,\
    \ which is\n   necessary in order to protect the distributed secrets from disclosure\n\
    \   to unauthorized entities.\n   Configuring one pair of SNMP parties to be used\
    \ to configure all\n   other parties has the advantage of exposing only one pair\
    \ of secrets\n   -- the secrets used to configure the minimal, useful set identified\n\
    \   above. To limit this exposure, the responsible management station\n   should\
    \ change these values as its first operation upon completion of\n   the initial\
    \ configuration. In this way, secrets are known only to the\n   peers requiring\
    \ knowledge of them in order to communicate.\n   The Management Information Base\
    \ (MIB) document [4] supporting these\n   security protocols specifies 6 initial\
    \ party identities and initial\n   values, which, by convention, are assigned\
    \ to the parties and their\n   associated parameters.\n   All 6 parties should\
    \ be configured in each new managed agent and its\n   responsible management station.\
    \ The responsible management station\n   should be configured first, since the\
    \ management station can be used\n   to generate the initial secrets and provide\
    \ them to a person, on a\n   suitable medium, for distribution to the managed\
    \ agent. The following\n   sequence of steps describes the initial configuration\
    \ of a managed\n   agent and its responsible management station.\n    1. Determine\
    \ the initial values for each of the attributes of\n       the SNMP party to be\
    \ configured. Some of these values\n       may be computed by the responsible\
    \ management\n       station, some may be specified in the MIB document,\n   \
    \    and some may be administratively determined.\n    2. Configure the parties\
    \ in the responsible management\n       station, according to the set of initial\
    \ values. If the\n       management station is computing some initial values to\n\
    \       be entered into the agent, an appropriate medium must\n       be present\
    \ to record the values.\n    3. Configure the parties in the managed agent, according\
    \ to\n       the set of initial values.\n    4. The responsible management station\
    \ must synchronize\n       the authentication clock values for each party it shares\n\
    \       with each managed agent. Section 6.3 specifies one\n       strategy by\
    \ which this could be accomplished.\n    5. The responsible management station\
    \ should change the\n       secret values manually configured to ensure the actual\n\
    \       values are known only to the peers requiring knowledge\n       of them\
    \ in order to communicate. To do this, the\n       management station generates\
    \ new secrets for each party\n       to be reconfigured and distributes those\
    \ secrets with a\n       strategy that uses a protocol that protects them from\n\
    \       disclosure, e.g., Symmetric Privacy Protocol (see\n       Section 6.4).\
    \ Upon receiving positive acknowledgement\n       that the new values have been\
    \ distributed, the\n       management station should update its local database\n\
    \       with the new values.\n   If the managed agent does not support a protocol\
    \ that protects\n   messages from disclosure, then automatic maintenance and\n\
    \   configuration of parties is not possible, i.e., the last step above\n   is\
    \ not possible. The secrets can only be changed by a physical visit\n   to the\
    \ device.\n   If there are other SNMP protocol entities requiring knowledge of\
    \ the\n   secrets, the responsible management station must distribute the\n  \
    \ information upon completion of the initial configuration. The\n   mechanism\
    \ used must protect the secrets from disclosure to\n   unauthorized entities.\
    \ The Symmetric Privacy Protocol, for example,\n   is an acceptable mechanism.\n"
- title: 6.2   Clock Distribution
  contents:
  - "6.2   Clock Distribution\n   A responsible management station must ensure that\
    \ the authentication\n   clock value for each SNMP party for which it is responsible\n\
    \     o is loosely synchronized among all the local databases in\n       which\
    \ it appears,\n     o is reset, as indicated below, upon reaching its maximal\n\
    \       value, and\n     o is non-decreasing, except as indicated below.\n   The\
    \ skew among the clock values must be accounted for in the lifetime\n   value,\
    \ in addition to the expected communication delivery delay.\n   A skewed authentication\
    \ clock may be detected by a number of\n   strategies, including knowledge of\
    \ the accuracy of the system clock,\n   unauthenticated queries of the party database,\
    \ and recognition of\n   authentication failures originated by the party.\n  \
    \ Whenever clock skew is detected, and whenever the SNMP entities at\n   both\
    \ the responsible management station and the relevant managed\n   agent support\
    \ an appropriate privacy protocol (e.g., the Symmetric\n   Privacy Protocol),\
    \ a straightforward strategy for the correction of\n   clock skew is simultaneous\
    \ alteration of authentication clock and\n   private key for the relevant SNMP\
    \ party. If the request to alter the\n   key and clock for a particular party\
    \ originates from that same party,\n   then, prior to transmitting that request,\
    \ the local notion of the\n   authentication clock is artificially advanced to\
    \ assure acceptance of\n   the request as authentic.\n   More generally, however,\
    \ since an authentication clock value need not\n   be protected from disclosure,\
    \ it is not necessary that a managed\n   agent support a privacy protocol in order\
    \ for a responsible\n   management station to correct skewed clock values. The\
    \ procedure for\n   correcting clock skew in the general case is presented in\
    \ Section\n   6.3.\n   In addition to correcting skewed notions of authentication\
    \ clocks,\n   every SNMP entity must react correctly as an authentication clock\n\
    \   approaches its maximal value. If the authentication clock for a\n   particular\
    \ SNMP party ever reaches the maximal time value, the clock\n   must halt at that\
    \ value.  (The value of interest may be the maximum\n   less lifetime.  When authenticating\
    \ a message, its authentication\n   timestamp is added to lifetime and compared\
    \ to the authentication\n   clock.  A SNMP protocol entity must guarantee that\
    \ the sum is never\n   greater than the maximal time value.) In this state, the\
    \ only\n   authenticated request a management station should generate for this\n\
    \   party is one that alters the value of at least its authentication\n   clock\
    \ and private authentication key. In order to reset these values,\n   the responsible\
    \ management station may set the authentication\n   timestamp in the message to\
    \ the maximal time value. In this case, the\n   nonce value may be used to distinguish\
    \ multiple messages.\n   The value of the authentication clock for a particular\
    \ SNMP party\n   must never be altered such that its new value is less than its\
    \ old\n   value, unless its last-timestamp and private authentication key are\n\
    \   also altered at the same time.\n"
- title: 6.3   Clock Synchronization
  contents:
  - "6.3   Clock Synchronization\n   Unless the secrets are changed at the same time,\
    \ the correct way to\n   synchronize clocks is to advance the slower clock to\
    \ be equal to the\n   faster clock. Suppose that party agentParty is realized\
    \ by the SNMP\n   entity in a managed agent; suppose that party mgrParty is realized\
    \ by\n   the SNMP entity in the corresponding responsible management station.\n\
    \   For any pair of parties, there are four possible conditions of the\n   authentication\
    \ clocks that could require correction:\n    1. The management station's notion\
    \ of the value of the\n       authentication clock for agentParty exceeds the\
    \ agent's\n       notion.\n    2. The management station's notion of the value\
    \ of the\n       authentication clock for mgrParty exceeds the agent's\n     \
    \  notion.\n    3. The agent's notion of the value of the authentication\n   \
    \    clock for agentParty exceeds the management station's\n       notion.\n \
    \   4. The agent's notion of the value of the authentication\n       clock for\
    \ mgrParty exceeds the management station's\n       notion.\n   The selective\
    \ clock acceleration mechanism intrinsic to the protocol\n   corrects conditions\
    \ 2 and 3 as part of the normal processing of an\n   authentic message. Therefore,\
    \ the clock adjustment procedure below\n   does not provide for any adjustments\
    \ in those cases. Rather, the\n   following sequence of steps specifies how the\
    \ clocks may be\n   synchronized when condition 1, condition 4, or both of those\n\
    \   conditions are manifest.\n    1. The responsible management station saves\
    \ its existing\n       notions of the authentication clocks for the two parties\n\
    \       agentParty and mgrParty.\n    2. The responsible management station retrieves\
    \ the\n       authentication clock values for both agentParty and\n       mgrParty\
    \ from the agent. This retrieval must be an\n       unauthenticated request, since\
    \ the management station\n       does not know if the clocks are synchronized.\
    \ If the\n       request fails, the clocks cannot be synchronized, and the\n \
    \      clock adjustment procedure is aborted without further\n       processing.\n\
    \    3. If the management station's notion of the authentication\n       clock\
    \ for agentParty exceeds the notion just retrieved\n       from the agent by more\
    \ than the amount of the\n       communications delay between the two protocol\
    \ entities,\n       then condition 1 is manifest. The recommended estimate\n \
    \      of communication delay in this context is one half of the\n       lifetime\
    \ value recorded for agentParty.\n    4. If the notion of the authentication clock\
    \ for mgrParty\n       just retrieved from the agent exceeds the management\n\
    \       station's notion, then condition 4 is manifest, and the\n       responsible\
    \ management station advances its notion of\n       the authentication clock for\
    \ mgrParty to match the\n       agent's notion.\n    5. If condition 1 is manifest,\
    \ then the responsible\n       management station sends an authenticated\n   \
    \    management operation to the agent that advances the\n       agent's notion\
    \ of the authentication clock for\n       agentParty to be equal to the management\
    \ station's\n       notion. If this management operation fails, then the\n   \
    \    management station restores its previously saved notions\n       of the clock\
    \ values, and the clock adjustment procedure\n       is aborted without further\
    \ processing.\n    6. The responsible management station retrieves the\n     \
    \  authentication clock values for both agentParty and\n       mgrParty from the\
    \ agent. This retrieval must be an\n       authenticated request, in order that\
    \ the management\n       station may verify that the clock values are properly\n\
    \       synchronized. If this authenticated query fails, then the\n       management\
    \ station restores its previously saved notions\n       of the clock values, and\
    \ the clock adjustment procedure\n       is aborted without further processing.\
    \ Otherwise, clock\n       synchronization has been successfully realized.\n \
    \  It is important to note step 4 above must be completed before\n   attempting\
    \ step 5. Otherwise, the agent may evaluate the request in\n   step 5 as unauthentic.\
    \ Similarly, step 5 above must be completed\n   before attempting step 6. Otherwise,\
    \ the management station may\n   evaluate the query response in step 6 as unauthentic.\n\
    \   Administrative advancement of a clock as described above does not\n   introduce\
    \ any new vulnerabilities, since the value of the clock is\n   intended to increase\
    \ with the passage of time. A potential\n   operational problem is the rejection\
    \ of management operations that\n   are authenticated using a previous value of\
    \ the relevant party clock.\n   This possibility may be avoided if a management\
    \ station suppresses\n   generation of management traffic between relevant parties\
    \ while this\n   clock adjustment procedure is in progress.\n"
- title: 6.4   Secret Distribution
  contents:
  - "6.4   Secret Distribution\n   This section describes one strategy by which a\
    \ SNMP protocol entity\n   that supports both the Digest Authentication Protocol\
    \ and the\n   Symmetric Privacy Protocol can change the secrets for a particular\n\
    \   SNMP party.\n   The frequency with which the secrets of a SNMP party should\
    \ be\n   changed is a local administrative issue. However, the more frequently\n\
    \   a secret is used, the more frequently it should be changed. At a\n   minimum,\
    \ the secrets must be changed whenever the associated\n   authentication clock\
    \ approaches its maximal value (see Section 7).\n   Note that, owing to both administrative\
    \ and automatic advances of the\n   authentication clock described in this memo,\
    \ the authentication clock\n   for a SNMP party may well approach its maximal\
    \ value sooner than\n   might otherwise be expected.\n   The following sequence\
    \ of steps specifies how a responsible\n   management station alters a secret\
    \ value (i.e., the private\n   authentication key or the private privacy key)\
    \ for a particular SNMP\n   party.\n    1. The responsible management station\
    \ generates a new\n       secret value.\n    2. The responsible management station\
    \ encapsulates a\n       SNMP Set request in a SNMP private management\n     \
    \  communication with at least the following properties.\n        o Its source\
    \ supports the Digest Authentication\n          Protocol and the Symmetric Privacy\
    \ Protocol.\n        o Its destination supports the Symmetric Privacy\n      \
    \    Protocol and the Digest Authentication Protocol.\n    3. The SNMP private\
    \ management communication is\n       transmitted to its destination.\n    4.\
    \ Upon receiving the request, the recipient processes the\n       message according\
    \ to [1] and [2].\n    5. The recipient encapsulates a SNMP Set response in a\n\
    \       SNMP private management communication with at least\n       the following\
    \ properties.\n        o Its source supports the Digest Authentication\n     \
    \     Protocol and the Symmetric Privacy Protocol.\n        o Its destination\
    \ supports the Symmetric Privacy\n          Protocol and the Digest Authentication\
    \ Protocol.\n    6. The SNMP private management communication is\n       transmitted\
    \ to its destination.\n    7. Upon receiving the response, the responsible\n \
    \      management station updates its local database with the\n       new value.\n\
    \   If the responsible management station does not receive a response to\n   its\
    \ request, there are two possible causes.\n     o The request may not have been\
    \ delivered to the\n       destination.\n     o The response may not have been\
    \ delivered to the\n       originator of the request.\n   In order to distinguish\
    \ the two possible error conditions, a\n   responsible management station could\
    \ check the destination to see if\n   the change has occurred. Unfortunately,\
    \ since the secret values are\n   unreadable, this is not directly possible.\n\
    \   The recommended strategy for verifying key changes is to set the\n   public\
    \ value corresponding to the secret being changed to a\n   recognizable, novel\
    \ value: that is, alter the public authentication\n   key value for the relevant\
    \ party when changing its private\n   authentication key, or alter its public\
    \ privacy key value when\n   changing its private privacy key. In this way, the\
    \ responsible\n   management station may retrieve the public value when a response\
    \ is\n   not received, and verify whether or not the change has taken place.\n\
    \   (This strategy is available since the public values are not used by\n   the\
    \ protocols defined in this memo. If this strategy is employed,\n   then the public\
    \ values are significant in this context. Of course,\n   protocols using the public\
    \ values may make use of this strategy\n   directly.)\n   One other scenario worthy\
    \ of mention is using a SNMP party to change\n   its own secrets. In this case,\
    \ the destination will change its local\n   database prior to generating a response.\
    \ Thus, the response will be\n   constructed according to the new value.  However,\
    \ the responsible\n   management station will not update its local database until\
    \ after the\n   response is received. This suggests the responsible management\n\
    \   station may receive a response which will be evaluated as\n   unauthentic,\
    \ unless the correct secret is used. The responsible\n   management station may\
    \ either account for this scenario as a special\n   case, or use an alteration\
    \ of the relevant public values (as\n   described above) to verify the key change.\n\
    \   Note, during the period of time after the request has been sent and\n   before\
    \ the response is received, the management station must keep\n   track of both\
    \ the old and new secret values. Since the delay may be\n   the result of a network\
    \ failure, the management station must be\n   prepared to retain both values for\
    \ an extended period of time,\n   including across reboots.\n"
- title: 6.5   Crash Recovery
  contents:
  - "6.5   Crash Recovery\n   This section describes the requirements for SNMP protocol\
    \ entities in\n   connection with recovery from system crashes or other service\n\
    \   interruptions.\n   For each SNMP party in the local database for a particular\
    \ SNMP\n   protocol entity, its identity, authentication clock, private\n   authentication\
    \ key, and private privacy key must enjoy non-volatile,\n   incorruptible representations.\
    \ If possible, lifetime should also\n   enjoy a non-volatile, incorruptible representation.\
    \  If said protocol\n   entity supports other security protocols or algorithms\
    \ in addition to\n   the two defined in this memo, then the authentication protocol\
    \ and\n   the privacy protocol for each party also require non-volatile,\n   incorruptible\
    \ representation.\n   The authentication clock of a SNMP party is a critical component\
    \ of\n   the overall security of the protocols. The inclusion of a reliable\n\
    \   representation of a clock in a SNMP protocol entity enhances overall\n   security.\
    \ A reliable clock representation continues to increase\n   according to the passage\
    \ of time, even when the local SNMP protocol\n   entity -- due to power loss or\
    \ other system failure -- may not be\n   operating.  An example of a reliable\
    \ clock representation is that\n   provided by battery-powered clock-calendar\
    \ devices incorporated into\n   some contemporary systems. It is assumed that\
    \ management stations\n   always support reliable clock representations, where\
    \ clock adjustment\n   by a human operator during crash recovery may contribute\
    \ to that\n   reliability.\n   If a managed agent crashes and does not reboot\
    \ in time for its\n   responsible management station to prevent its authentication\
    \ clock\n   from reaching its maximal value, upon reboot the clock must be halted\n\
    \   at its maximal value. The procedures specified in Section 6.3 would\n   then\
    \ apply.\n   If a managed network element supports a reliable clock\n   representation,\
    \ recovering from a crash requires few special actions.\n   Upon recovery, those\
    \ attributes of each SNMP party that do not enjoy\n   non-volatile or reliable\
    \ representation are initialized as follows.\n     o If the private authentication\
    \ key is not the OCTET\n       STRING of zero length, the authentication protocol\
    \ is\n       set to identify use of the Digest Authentication Protocol\n     \
    \  in conjunction with the algorithm specified in\n       Section 2.4.1.\n   \
    \  o The last-timestamp is initialized to the value of the\n       authentication\
    \ clock.\n     o The nonce is initialized to zero.\n     o If the lifetime is\
    \ not retained, it should be initialized to\n       zero.\n     o If the private\
    \ privacy key is not the OCTET STRING\n       of zero length, the privacy protocol\
    \ is set to identify use\n       of the Symmetric Privacy Protocol in conjunction\
    \ with\n       the algorithm specified in Section 2.4.2.\n   Upon detecting that\
    \ a managed agent has rebooted, a responsible\n   management station must reset\
    \ all other party attributes, including\n   the lifetime if it was not retained.\
    \ In order to reset the lifetime,\n   the responsible management station should\
    \ set the authentication\n   timestamp in the message to the sum of the authentication\
    \ clock and\n   desired lifetime. This is an artificial advancement of the\n \
    \  authentication timestamp in order to guarantee the message will be\n   authentic\
    \ when received by the recipient.\n   If, alternatively, a managed network element\
    \ does not support a\n   reliable clock representation, then those attributes\
    \ of each SNMP\n   party that do not enjoy non-volatile representation are initialized\n\
    \   as follows.\n     o If the private authentication key is not the OCTET\n \
    \      STRING of zero length, the authentication protocol is\n       set to identify\
    \ use of the Digest Authentication Protocol\n       in conjunction with the algorithm\
    \ specified in\n       Section 2.4.1.\n     o The authentication clock is initialized\
    \ to the maximal\n       time value.\n     o The last-timestamp is initialized\
    \ to the maximal time\n       value.\n     o The nonce is initialized to zero.\n\
    \     o If the lifetime is not retained, it should be initialized to\n       zero.\n\
    \     o If the private privacy key is not the OCTET STRING\n       of zero length,\
    \ the privacy protocol is set to identify use\n       of the Symmetric Privacy\
    \ Protocol in conjunction with\n       the algorithm specified in Section 2.4.2.\n\
    \   The only authenticated request a management station should generate\n   for\
    \ a party in this initial state is one that alters the value of at\n   least its\
    \ authentication clock, private authentication key, and\n   lifetime (if that\
    \ was not retained). In order to reset these values,\n   the responsible management\
    \ station must set the authentication\n   timestamp in the message to the maximal\
    \ time value. The nonce value\n   may be used to distinguish multiple messages.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This section highlights security considerations\
    \ relevant to the\n   protocols and procedures defined in this memo. Practices\
    \ that\n   contribute to secure, effective operation of the mechanisms defined\n\
    \   here are described first. Constraints on implementation behavior that\n  \
    \ are necessary to the security of the system are presented next.\n   Finally,\
    \ an informal account of the contribution of each mechanism of\n   the protocols\
    \ to the required goals is presented.\n"
- title: 7.1   Recommended Practices
  contents:
  - "7.1   Recommended Practices\n   This section describes practices that contribute\
    \ to the secure,\n   effective operation of the mechanisms defined in this memo.\n\
    \     o A management station should discard SNMP responses\n       for which neither\
    \ the request-id component nor the\n       represented management information\
    \ corresponds to any\n       currently outstanding request.\n       Although it\
    \ would be typical for a management station\n       to do this as a matter of\
    \ course, in the context of these\n       security protocols it is significant\
    \ owing to the possibility\n       of message duplication (malicious or otherwise).\n\
    \     o A management station should not interpret an agent's\n       lack of response\
    \ to an authenticated SNMP management\n       communication as a conclusive indication\
    \ of agent or\n       network failure.\n       It is possible for authentication\
    \ failure traps to be lost or\n       suppressed as a result of authentication\
    \ clock skew or\n       inconsistent notions of shared secrets. In order either\
    \ to\n       facilitate administration of such SNMP parties or to\n       provide\
    \ for continued management in times of network\n       stress, a management station\
    \ implementation may\n       provide for arbitrary, artificial advancement of\
    \ the\n       timestamp or selection of shared secrets on locally\n       generated\
    \ messages.\n     o The lifetime value for a SNMP party should be chosen\n   \
    \    (by the local administration) to be as small as possible,\n       given the\
    \ accuracy of clock devices available, relevant\n       round-trip communications\
    \ delays, and the frequency\n       with which a responsible management station\
    \ will be\n       able to verify all clock values.\n       A large lifetime increases\
    \ the vulnerability to malicious\n       delays of SNMP messages. The implementation\
    \ of a\n       management station may, when explicitly authorized,\n       provide\
    \ for dynamic adjustment of the lifetime in order\n       to accommodate changing\
    \ network conditions.\n     o When sending state altering messages to a managed\n\
    \       agent, a management station should delay sending\n       successive messages\
    \ to the managed agent until a\n       positive acknowledgement is received for\
    \ the previous\n       message or until the previous message expires.\n      \
    \ When using the noAuth protocol, no message ordering\n       is imposed by the\
    \ SNMP. Messages may be received in\n       any order relative to their time of\
    \ generation and each\n       will be processed in the ordered received. In contrast,\n\
    \       the security protocols guarantee that received messages\n       are ordered\
    \ insofar as each received message must have\n       been sent subsequent to the\
    \ sending of a previously\n       received message.\n       When an authenticated\
    \ message is sent to a managed\n       agent, it will be valid for a period of\
    \ time that does not\n       exceed lifetime under normal circumstances. During\
    \ the\n       period of time this message is valid, if the management\n      \
    \ station sends another authenticated message to the\n       managed agent that\
    \ is received and processed prior to\n       the first message, the first message\
    \ will be considered\n       unauthentic when it is received by the managed agent.\n\
    \       Indeed, a management station must cope with the loss\n       and re-ordering\
    \ of messages resulting from anomalies in\n       the network as a matter of course.\
    \ A management\n       station implementation may choose to prevent the loss\n\
    \       of messages resulting from re-ordering when using the\n       security\
    \ protocols defined in this memo by delaying\n       sending successive messages.\n\
    \     o The frequency with which the secrets of a SNMP party\n       should be\
    \ changed is indirectly related to the frequency\n       of their use.\n     \
    \  Protecting the secrets from disclosure is critical to the\n       overall security\
    \ of the protocols. Frequent use of a secret\n       provides a continued source\
    \ of data that may be useful\n       to a cryptanalyst in exploiting known or\
    \ perceived\n       weaknesses in an algorithm. Frequent changes to the\n    \
    \   secret avoid this vulnerability.\n       Changing a secret after each use\
    \ is is generally regarded\n       as the most secure practice, but a significant\
    \ amount of\n       overhead may be associated with that approach.\n       Note,\
    \ too, in a local environment the threat of disclosure\n       may be insignificant,\
    \ and as such the changing of secrets\n       may be less frequent. However, when\
    \ public data\n       networks are the communication paths, more caution is\n\
    \       prudent.\n     o In order to foster the greatest degree of security, a\n\
    \       management station implementation must support\n       constrained, pairwise\
    \ sharing of secrets among SNMP\n       entities as its default mode of operation.\n\
    \       Owing to the use of symmetric cryptography in the\n       protocols defined\
    \ here, the secrets associated with a\n       particular SNMP party must be known\
    \ to all other\n       SNMP parties with which that party may wish to\n      \
    \ communicate. As the number of locations at which\n       secrets are known and\
    \ used increases, the likelihood of\n       their disclosure also increases, as\
    \ does the potential\n       impact of that disclosure. Moreover, if the set of\
    \ SNMP\n       protocol entities with knowledge of a particular secret\n     \
    \  numbers more than two, data origin cannot be reliably\n       authenticated\
    \ because it is impossible to determine with\n       any assurance which entity\
    \ of that set may be the\n       originator of a particular SNMP message. Thus,\
    \ the\n       greatest degree of security is afforded by configurations\n    \
    \   in which the secrets for each SNMP party are known to\n       at most two\
    \ protocol entities.\n"
- title: 7.2   Conformance
  contents:
  - "7.2   Conformance\n   A SNMP protocol entity implementation that claims conformance\
    \ to this\n   memo must satisfy the following requirements:\n    1. It must implement\
    \ the noAuth and noPriv protocols\n       whose object identifiers are defined\
    \ in [4].\n       noAuth  This protocol signifies that messages generated\n  \
    \        by a party using it are not protected as to origin or\n          integrity.\
    \ It is required to ensure that a party's\n          authentication clock is always\
    \ accessible.\n       noPriv  This protocol signifies that messages received\n\
    \          by a party using it are not protected from\n          disclosure. It\
    \ is required to ensure that a party's\n          authentication clock is always\
    \ accessible.\n    2. It must implement the Digest Authentication Protocol in\n\
    \       conjunction with the algorithm defined in Section 2.4.1.\n    3. It must\
    \ include in its local database at least one SNMP\n       party with the following\
    \ parameters set as follows:\n        o partyAuthProtocol is set to noAuth and\n\
    \        o partyPrivProtocol is set to noPriv.\n       This party must have a\
    \ MIB view [2] specified that\n       includes at least the authentication clock\
    \ of all other\n       parties. Alternatively, the authentication clocks of the\n\
    \       other parties may be partitioned among several similarly\n       configured\
    \ parties according to a local implementation\n       convention.\n    4. For\
    \ each SNMP party about which it maintains\n       information in a local database,\
    \ an implementation must\n       satisfy the following requirements:\n      (a)\
    \ It must not allow a party's parameters to be set to\n          a value inconsistent\
    \ with its expected syntax. In\n          particular, Section 2.4 specifies constraints\
    \ for the\n          chosen mechanisms.\n      (b) It must, to the maximal extent\
    \ possible, prohibit\n          read-access to the private authentication key\
    \ and\n          private encryption key under all circumstances\n          except\
    \ as required to generate and/or validate\n          SNMP messages with respect\
    \ to that party. This\n          prohibition includes prevention of read-access\
    \ by\n          the entity's human operators.\n      (c) It must allow the party's\
    \ authentication clock to be\n          publicly accessible. The correct operation\
    \ of the\n          Digest Authentication Protocol requires that it be\n     \
    \     possible to determine this value at all times in\n          order to guarantee\
    \ that skewed authentication\n          clocks can be resynchronized.\n      (d)\
    \ It must prohibit alterations to its record of the\n          authentication\
    \ clock for that party independently of\n          alterations to its record of\
    \ the private\n          authentication key (unless the clock alteration is an\n\
    \          advancement).\n      (e) It must never allow its record of the authentication\n\
    \          clock for that party to be incremented beyond the\n          maximal\
    \ time value and so \"roll-over\" to zero.\n      (f) It must never increase its\
    \ record of the lifetime for\n          that party except as may be explicitly\
    \ authorized\n          (via imperative command or securely represented\n    \
    \      configuration information) by the responsible\n          network administrator.\n\
    \      (g) In the event that the non-volatile, incorruptible\n          representations\
    \ of a party's parameters (in\n          particular, either the private authentication\
    \ key or\n          private encryption key) are lost or destroyed, it\n      \
    \    must alter its record of these quantities to random\n          values so\
    \ subsequent interaction with that party\n          requires manual redistribution\
    \ of new secrets and\n          other parameters.\n    5. If it selects new value(s)\
    \ for a party's secret(s), it must\n       avoid bad or obvious choices for said\
    \ secret(s). Choices\n       to be avoided are boundary values (such as all-zeros)\n\
    \       and predictable values (such as the same value as\n       previously or\
    \ selecting from a predetermined set).\n"
- title: 7.3   Protocol Correctness
  contents:
  - "7.3   Protocol Correctness\n   The correctness of these SNMP security protocols\
    \ with respect to the\n   stated goals depends on the following assumptions:\n\
    \    1. The chosen message digest algorithm satisfies its design\n       criteria.\
    \ In particular, it must be computationally\n       infeasible to discover two\
    \ messages that share the same\n       digest value.\n    2. It is computationally\
    \ infeasible to determine the secret\n       used in calculating a digest on the\
    \ concatenation of the\n       secret and a message when both the digest and the\n\
    \       message are known.\n    3. The chosen symmetric encryption algorithm satisfies\
    \ its\n       design criteria. In particular, it must be computationally\n   \
    \    infeasible to determine the cleartext message from the\n       ciphertext\
    \ message without knowledge of the key used in\n       the transformation.\n \
    \   4. Local notions of a party's authentication clock while it is\n       associated\
    \ with a specific private key value are\n       monotonically non-decreasing (i.e.,\
    \ they never run\n       backwards) in the absence of administrative\n       manipulations.\n\
    \    5. The secrets for a particular SNMP party are known only\n       to authorized\
    \ SNMP protocol entities.\n    6. Local notions of the authentication clock for\
    \ a particular\n       SNMP party are never altered such that the\n       authentication\
    \ clock's new value is less than the current\n       value without also altering\
    \ the private authentication\n       key.\n   For each mechanism of the protocol,\
    \ an informal account of its\n   contribution to the required goals is presented\
    \ below.  Pseudocode\n   fragments are provided where appropriate to exemplify\
    \ possible\n   implementations; they are intended to be self-explanatory.\n"
- title: 7.3.1   Clock Monotonicity Mechanism
  contents:
  - "7.3.1   Clock Monotonicity Mechanism\n   By pairing each sequence of a clock's\
    \ values with a unique key, the\n   protocols partially realize goals 3 and 4,\
    \ and the conjunction of\n   this property with assumption 6 above is sufficient\
    \ for the claim\n   that, with respect to a specific private key value, all local\
    \ notions\n   of a party's authentication clock are, in general, non-decreasing\n\
    \   with time.\n"
- title: 7.3.2   Data Integrity Mechanism
  contents:
  - "7.3.2   Data Integrity Mechanism\n   The protocols require computation of a message\
    \ digest computed over\n   the SNMP message prepended by the secret for the relevant\
    \ party. By\n   virtue of this mechanism and assumptions 1 and 2, the protocols\n\
    \   realize goal 1.\n   Normally, the inclusion of the message digest value with\
    \ the digested\n   message would not be sufficient to guarantee data integrity,\
    \ since\n   the digest value can be modified in addition to the message while\
    \ it\n   is enroute. However, since not all of the digested message is\n   included\
    \ in the transmission to the destination, it is not possible\n   to substitute\
    \ both a message and a digest value while enroute to a\n   destination.\n   Strictly\
    \ speaking, the specified strategy for data integrity does not\n   detect a SNMP\
    \ message modification which appends extraneous material\n   to the end of such\
    \ messages. However, owing to the representation of\n   SNMP messages as ASN.1\
    \ values, such modifications cannot --\n   consistent with goal 1 -- result in\
    \ unauthorized management\n   operations.\n   The data integrity mechanism specified\
    \ in this memo protects only\n   against unauthorized modification of individual\
    \ SNMP messages. A more\n   general data integrity service that affords protection\
    \ against the\n   threat of message stream modification is not realized by this\n\
    \   mechanism, although limited protection against reordering, delay, and\n  \
    \ duplication of messages within a message stream are provided by other\n   mechanisms\
    \ of the protocol.\n"
- title: 7.3.3   Data Origin Authentication Mechanism
  contents:
  - "7.3.3   Data Origin Authentication Mechanism\n   The data integrity mechanism\
    \ requires the use of a secret value known\n   only to communicating parties.\
    \ By virtue of this mechanism and\n   assumptions 1 and 2, the protocols explicitly\
    \ prevent unauthorized\n   modification of messages. Data origin authentication\
    \ is implicit if\n   the message digest value can be verified. That is, the protocols\n\
    \   realize goal 2.\n"
- title: 7.3.4   Restricted Administration Mechanism
  contents:
  - "7.3.4   Restricted Administration Mechanism\n   This memo requires that implementations\
    \ preclude administrative\n   alterations of the authentication clock for a particular\
    \ party\n   independently from its private authentication key (unless that clock\n\
    \   alteration is an advancement). An example of an efficient\n   implementation\
    \ of this restriction is provided in a pseudocode\n   fragment below. This pseudocode\
    \ fragment meets the requirements of\n   assumption 6.\n   Pseudocode Fragment.\
    \ Observe that the requirement is not for\n   simultaneous alteration but to preclude\
    \ independent alteration. This\n   latter requirement is fairly easily realized\
    \ in a way that is\n   consistent with the defined semantics of the SNMP Set operation.\n\
    \   Void partySetKey (party, newKeyValue)\n   {\n       if (party->clockAltered)\
    \ {\n          party->clockAltered = FALSE;\n          party->keyAltered = FALSE;\n\
    \          party->keyInUse = newKeyValue;\n          party->clockInUse = party->clockCache;\n\
    \       }\n       else {\n          party->keyAltered = TRUE;\n          party->keyCache\
    \ = newKeyValue;\n       }\n   }\n   Void partySetClock (party, newClockValue)\n\
    \   {\n       if (party->keyAltered) {\n          party->keyAltered = FALSE;\n\
    \          party->clockAltered = FALSE;\n          party->clockInUse = newClockValue;\n\
    \          party->keyInUse = party->keyCache;\n       }\n       else {\n     \
    \     party->clockAltered = TRUE;\n          party->clockCache = newClockValue;\n\
    \       }\n   }\n"
- title: 7.3.5   Ordered Delivery Mechanism
  contents:
  - "7.3.5   Ordered Delivery Mechanism\n   The definition of the Digest Authentication\
    \ Protocol requires that,\n   if the timestamp value on a received message does\
    \ not exceed the\n   timestamp of the most recent validated message locally delivered\
    \ from\n   the originating party, then that message is not delivered. Otherwise,\n\
    \   the record of the timestamp for the most recent locally delivered\n   validated\
    \ message is updated.\n   if (msgIsValidated) {\n       if (timestampOfReceivedMsg\
    \ >\n          party->timestampOfLastDeliveredMsg) {\n          party->timestampOfLastDeliveredMsg\
    \ =\n             timestampOfReceivedMsg;\n       }\n       else {\n         \
    \ msgIsValidated = FALSE;\n       }\n   }\n   Although not explicitly represented\
    \ in the pseudocode above, in the\n   Digest Authentication Protocol, the ordered\
    \ delivery mechanism must\n   ensure that, when the authentication timestamp of\
    \ the received\n   message is equal to the last-timestamp, received messages continue\
    \ to\n   be delivered as long as their nonce values are monotonically\n   increasing.\
    \ By virtue of this mechanism, the protocols realize goal\n   4.\n"
- title: 7.3.6   Message Timeliness Mechanism
  contents:
  - "7.3.6   Message Timeliness Mechanism\n   The definition of the SNMP security\
    \ protocols requires that, if the\n   authentication timestamp value on a received\
    \ message -- augmented by\n   an administratively chosen lifetime value -- is\
    \ less than the local\n   notion of the clock for the originating SNMP party,\
    \ the message is\n   not delivered.\n   if (timestampOfReceivedMsg +\n       \
    \   party->administrativeLifetime <=\n          party->localNotionOfClock) {\n\
    \          msgIsValidated = FALSE;\n   }\n   By virtue of this mechanism, the\
    \ protocols realize goal 3. In cases\n   in which the local notions of a particular\
    \ SNMP party clock are\n   moderately well-synchronized, the timeliness mechanism\
    \ effectively\n   limits the age of validly delivered messages. Thus, if an attacker\n\
    \   diverts all validated messages for replay much later, the delay\n   introduced\
    \ by this attack is limited to a period that is proportional\n   to the skew among\
    \ local notions of the party clock.\n"
- title: 7.3.7   Selective Clock Acceleration Mechanism
  contents:
  - "7.3.7   Selective Clock Acceleration Mechanism\n   The definition of the SNMP\
    \ security protocols requires that, if the\n   timestamp value on a received,\
    \ validated message exceeds the local\n   notion of the clock for the originating\
    \ party, then that notion is\n   adjusted forward to correspond to said timestamp\
    \ value. This\n   mechanism is neither strictly necessary nor sufficient to the\n\
    \   security of the protocol; rather, it fosters the clock\n   synchronization\
    \ on which valid message delivery depends -- thereby\n   enhancing the effectiveness\
    \ of the protocol in a management context.\n   if (msgIsValidated) {\n       \
    \   if (timestampOfReceivedMsg >\n                party->localNotionOfClock) {\n\
    \                party->localNotionOfClock =\n                      timestampOfReceivedMsg;\n\
    \          }\n   }\n   The effect of this mechanism is to synchronize local notions\
    \ of the\n   party clock more closely in the case where a sender's notion is more\n\
    \   advanced than a receiver's. In the opposite case, this mechanism has\n   no\
    \ effect on local notions of the party clock and either the received\n   message\
    \ is validly delivered or not according to other mechanisms of\n   the protocol.\n\
    \   Operation of this mechanism does not, in general, improve the\n   probability\
    \ of validated delivery for messages generated by party\n   participants whose\
    \ local notion of the party clock is relatively less\n   advanced. In this case,\
    \ queries from a management station may not be\n   validly delivered and the management\
    \ station needs to react\n   appropriately (e.g., by administratively resynchronizing\
    \ local\n   notions of the clock in conjunction with a key change). In contrast,\n\
    \   the delivery of SNMP trap messages generated by an agent that suffers\n  \
    \ from a less advanced notion of a party clock is more problematic, for\n   an\
    \ agent may lack the capacity to recognize and react to security\n   failures\
    \ that prevent delivery of its messages. Thus, the inherently\n   unreliable character\
    \ of trap messages is likely to be compounded by\n   attempts to provide for their\
    \ validated delivery.\n"
- title: 7.3.8   Confidentiality Mechanism
  contents:
  - "7.3.8   Confidentiality Mechanism\n   The protocols require the use of a symmetric\
    \ encryption algorithm\n   when the data confidentiality service is required.\
    \ By virtue of this\n   mechanism and assumption 3, the protocols realize goal\
    \ 5.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   The authors would like to thank the members of the SNMP\
    \ Security\n   Working Group of the IETF for their patience and comments. Special\n\
    \   thanks go to Jeff Case who provided the first implementation of the\n   protocols.\
    \ Dave Balenson, John Linn, Dan Nessett, and all the members\n   of the Privacy\
    \ and Security Research Group provided many valuable and\n   detailed comments.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [1] Case, J., M. Fedor, M. Schoffstall, and J. Davin, The\
    \ Simple\n       Network Management Protocol\", RFC 1157, University of Tennessee\n\
    \       at Knoxville, Performance Systems International, Performance\n       Systems\
    \ International, and the MIT Laboratory for Computer\n       Science, May 1990.\
    \  (Obsoletes RFC 1098.)\n   [2] Davin, J., Galvin, J., and K. McCloghrie, \"\
    SNMP Administrative\n       Model\", RFC 1351, MIT Laboratory for Computer Science,\
    \ Trusted\n       Information Systems, Inc., Hughes LAN Systems, Inc., July 1992.\n\
    \   [3] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, MIT\n    \
    \   Laboratory for Computer Science, April 1992.\n   [4] McCloghrie, K., Davin,\
    \ J., and J. Galvin, \"Definitions of Managed\n       Objects for Administration\
    \ of SNMP Parties\", RFC 1353, Hughes LAN\n       Systems, Inc., MIT Laboratory\
    \ for Computer Science, Trusted\n       Information Systems, Inc., July 1992.\n\
    \   [5] FIPS Publication 46-1, \"Data Encryption Standard\", National\n      \
    \ Institute of Standards and Technology, Federal Information\n       Processing\
    \ Standard (FIPS); Supersedes FIPS Publication 46,\n       January 15, 1977; Reaffirmed\
    \ January 22, 1988.\n   [6] ANSI X3.92-1981, \"Data Encryption Algorithm\", American\
    \ National\n       Standards Institute, December 30, 1980.\n   [7] FIPS Publication\
    \ 81, \"DES Modes of Operation\", National Institute\n       of Standards and\
    \ Technology, December 2, 1980, Federal\n       Information Processing Standard\
    \ (FIPS).\n   [8] ANSI X3.106-1983, \"Data Encryption Algorithm - Modes of\n \
    \      Operation\", American National Standards Institute, May 16, 1983.\n   [9]\
    \ FIPS Publication 74, \"Guidelines for Implementing and Using the\n       NBS\
    \ Data Encryption Standard\", National Institute of Standards\n       and Technology,\
    \ April 1, 1981.  Federal Information Processing\n       Standard (FIPS).\n  [10]\
    \ Special Publication 500-20, \"Validating the Correctness of\n       Hardware\
    \ Implementations of the NBS Data Encryption Standard\",\n       National Institute\
    \ of Standards and Technology.\n  [11] Special Publication 500-61, \"Maintenance\
    \ Testing for the Data\n       Encryption Standard\", National Institute of Standards\
    \ and\n       Technology, August 1980.\n  [12] Information Processing -- Open\
    \ Systems Interconnection --\n       Specification of Basic Encoding Rules for\
    \ Abstract Syntax\n       Notation One (ASN.1), International Organization for\n\
    \       Standardization/International Electrotechnical Institute, 1987,\n    \
    \   International Standard 8825.\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n       James M. Galvin\n       Trusted Information Systems,\
    \ Inc.\n       3060 Washington Road, Route 97\n       Glenwood, MD 21738\n   \
    \    Phone:  (301) 854-6889\n       EMail:  galvin@tis.com\n       Keith McCloghrie\n\
    \       Hughes LAN Systems, Inc.\n       1225 Charleston Road\n       Mountain\
    \ View, CA 94043\n       Phone:  (415) 966-7934\n       EMail:  kzm@hls.com\n\
    \       James R. Davin\n       MIT Laboratory for Computer Science\n       545\
    \ Technology Square\n       Cambridge, MA 02139\n       Phone:  (617) 253-6020\n\
    \       EMail:  jrd@ptt.lcs.mit.edu\n"
