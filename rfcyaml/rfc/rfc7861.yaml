- contents:
  - '             Remote Procedure Call (RPC) Security Version 3

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies version 3 of the Remote Procedure Call (RPC)\n
    \  security protocol (RPCSEC_GSS).  This protocol provides support for\n   multi-principal
    authentication of client hosts and user principals to\n   a server (constructed
    by generic composition), security label\n   assertions for multi-level security
    and type enforcement, structured\n   privilege assertions, and channel bindings.
    \ This document updates\n   RFC 5403.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7861.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction and Motivation .....................................2\n
    \     1.1. Requirements Language ......................................3\n      1.2.
    Added Functionality ........................................4\n      1.3. XDR
    Code Extraction ........................................5\n   2. The RPCSEC_GSSv3
    Protocol .......................................6\n      2.1. Compatibility with
    RPCSEC_GSSv2 ............................6\n      2.2. Version Negotiation ........................................6\n
    \     2.3. New Reply Verifier .........................................7\n      2.4.
    XDR Code Preliminaries .....................................8\n      2.5. RPCSEC_GSS_BIND_CHANNEL
    Operation .........................10\n      2.6. New auth_stat Values ......................................10\n
    \     2.7. New Control Procedures ....................................10\n           2.7.1.
    New Control Procedure - RPCSEC_GSS_CREATE ..........12\n           2.7.2. New
    Control Procedure - RPCSEC_GSS_LIST ............20\n      2.8. Extensibility .............................................21\n
    \  3. Operational Recommendation for Deployment ......................21\n   4.
    Security Considerations ........................................21\n   5. IANA
    Considerations ............................................22\n      5.1. New
    RPC Authentication Status Numbers .....................22\n      5.2. Structured
    Privilege Name Definitions .....................23\n           5.2.1. Initial
    Registry ...................................24\n           5.2.2. Updating Registrations
    .............................24\n   6. References .....................................................25\n
    \     6.1. Normative References ......................................25\n      6.2.
    Informative References ....................................26\n   Acknowledgments
    ...................................................26\n   Authors' Addresses ................................................26\n"
  title: Table of Contents
- contents:
  - "1.  Introduction and Motivation\n   The original Remote Procedure Call (RPC)
    security protocol\n   (RPCSEC_GSS) [RFC2203] provided for authentication of RPC
    clients and\n   servers to each other using the Generic Security Service Application\n
    \  Programming Interface (GSS-API) [RFC2743].  The second version of\n   RPCSEC_GSS
    [RFC5403] added support for channel bindings [RFC5056].\n   Existing GSS-API mechanisms
    are insufficient for communicating\n   certain authorization and authentication
    information to a server.\n   The GSS-API and its mechanisms certainly could be
    extended to address\n   this shortcoming.  However, it is addressed here at the
    application\n   layer, i.e., in RPCSEC_GSS.\n   A major motivation for version
    3 of RPCSEC_GSS (RPCSEC_GSSv3) is to\n   add support for multi-level (labeled)
    security and server-side copy\n   for NFSv4.\n   Multi-Level Security (MLS) is
    a traditional model where subjects\n   (processes) are given a security level
    (Unclassified, Secret,\n   Top Secret, etc.) and objects (files) are given security
    labels that\n   mandate the access of the subject to the object (see Section 9.1
    of\n   [RFC7862]).\n   Labeled NFS (see Section 9 of [RFC7862]) uses an MLS policy
    with\n   Mandatory Access Control (MAC) systems as defined in [RFC4949].\n   Labeled
    NFS stores MAC file object labels on the NFS server and\n   enables client Guest
    Mode MAC as described in Section 9.5.3 of\n   [RFC7862].  RPCSEC_GSSv3 label assertions
    assert client MAC process\n   subject labels to enable Full Mode MAC when combined
    with Labeled NFS\n   as described in Section 9.5.1 of [RFC7862].\n   A traditional
    inter-server file copy entails the user gaining access\n   to a file on the source,
    reading it, and writing it to a file on the\n   destination.  In secure NFSv4
    inter-server server-side copy (see\n   Section 4 of [RFC7862]), the user first
    secures access to both source\n   and destination files and then uses NFSv4.2-defined
    RPCSEC_GSSv3\n   structured privileges to authorize the destination to copy the
    file\n   from the source on behalf of the user.\n   Multi-principal authentication
    can be used to address shared cache\n   poisoning attacks (see Section 9 of [AFS-RXGK])
    on the client cache\n   by a user.  As described in Section 7 of [AFS-RXGK], multi-user\n
    \  machines with a single cache manager can fetch and cache data on a\n   user's
    behalf and re-display it for another user from the cache\n   without refetching
    the data from the server.  The initial data\n   acquisition is authenticated by
    the first user's credentials, and if\n   only that user's credentials are used,
    it may be possible for a\n   malicious user or users to \"poison\" the cache for
    other users by\n   introducing bogus data into the cache.\n   Another use of the
    multi-principal assertion is the secure conveyance\n   of privilege information
    for processes running with more (or even\n   with less) privilege than the user
    normally would be accorded.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  - contents:
    - "1.2.  Added Functionality\n   RPCSEC_GSS version 3 (RPCSEC_GSSv3) is the same
      as RPCSEC_GSSv2\n   [RFC5403], except that the following assertions of authority
      have\n   been added:\n   o  Security labels for Full Mode security type enforcement,
      and other\n      labeled security models (see Section 9.5.1 of [RFC7862]).\n
      \  o  Application-specific structured privileges.  These allow an RPC\n      application
      client to pass structured information to the\n      corresponding application
      code in a server to control the use of\n      the privilege and/or the conditions
      in which the privilege may be\n      exercised.  For an example, see server-side
      copy as described in\n      [RFC7862].\n   o  Multi-principal authentication
      of the client host and user to the\n      server, done by binding two RPCSEC_GSS
      handles.\n   o  Simplified channel binding.\n   Assertions of labels and privileges
      are evaluated by the server,\n   which may then map the asserted values to other
      values, all according\n   to server-side policy.  See [RFC7862].\n   An option
      for enumerating server-supported Label Format Specifiers\n   (LFSs) is provided.
      \ See Section 9.1 of [RFC7862].\n   Note that there is no RPCSEC_GSS_CREATE
      payload that is REQUIRED to\n   implement.  RPCSEC_GSSv3 implementations are
      feature driven.  Besides\n   implementing the RPCSEC_GSS_CREATE operation and
      payloads for the\n   desired features, all RPCSEC_GSSv3 implementations MUST
      implement:\n   o  The new RPCSEC_GSS version number (Section 2.2).\n   o  The
      new reply verifier (Section 2.3).\n   o  The new auth_stat values (Section 2.6).\n
      \  RPCSEC_GSSv3 targets implementing a desired feature MUST also\n   implement
      the RPCSEC_GSS_LIST operation, and the RPCSEC_GSS_CREATE\n   operation replies
      for unsupported features as follows:\n   o  For label assertions, the target
      indicates no support by returning\n      the new RPCSEC_GSS_LABEL_PROBLEM auth_stat
      value (see\n      Section 2.7.1.3).\n   o  For structured privilege assertions,
      the target indicates no\n      support by returning the new RPCSEC_GSS_UNKNOWN_MESSAGE
      auth_stat\n      value (see Section 2.7.1.4).\n   o  For multi-principal authentication
      (Section 2.7.1.1), the target\n      indicates no support by not including an
      rgss3_gss_mp_auth value\n      in the rgss3_create_res.\n   o  For channel bindings
      (Section 2.7.1.2), the target indicates no\n      support by not including an
      rgss3_chan_binding value in the\n      rgss3_create_res.\n"
    title: 1.2.  Added Functionality
  - contents:
    - "1.3.  XDR Code Extraction\n   This document contains the External Data Representation
      (XDR)\n   [RFC4506] definitions for the RPCSEC_GSSv3 protocol.  The XDR\n   description
      is provided in this document in a way that makes it\n   simple for the reader
      to extract it into a form that is ready to\n   compile.  The reader can feed
      this document in the following shell\n   script to produce the machine-readable
      XDR description of\n   RPCSEC_GSSv3:\n   <CODE BEGINS>\n   #!/bin/sh\n   grep
      \"^  *///\" | sed 's?^  */// ??' | sed 's?^  *///$??'\n   <CODE ENDS>\n   That
      is, if the above script is stored in a file called \"extract.sh\"\n   and this
      document is in a file called \"spec.txt\", then the reader\n   can do:\n   <CODE
      BEGINS>\n    sh extract.sh < spec.txt > rpcsec_gss_v3.x\n   <CODE ENDS>\n   The
      effect of the script is to remove leading white space from each\n   line, plus
      a sentinel sequence of \"///\".\n"
    title: 1.3.  XDR Code Extraction
  title: 1.  Introduction and Motivation
- contents:
  - "2.  The RPCSEC_GSSv3 Protocol\n   RPCSEC_GSS version 3 (RPCSEC_GSSv3) is very
    similar to RPCSEC_GSS\n   version 2 (RPCSEC_GSSv2) [RFC5403].  The difference
    is that the new\n   support for assertions and channel bindings is implemented
    via a\n   different mechanism.\n   The entire RPCSEC_GSSv3 protocol is not presented
    here.  Only the\n   differences between RPCSEC_GSSv3 and RPCSEC_GSSv2 are shown.\n
    \  RPCSEC_GSSv3 is implemented as follows:\n   o  A client uses an existing RPCSEC_GSSv3
    context handle established\n      in the usual manner (see Section 5.2 of [RFC2203])
    to protect\n      RPCSEC_GSSv3 exchanges; this will be termed the \"parent\" handle.\n
    \  o  The server issues a \"child\" RPCSEC_GSSv3 handle in the\n      RPCSEC_GSS_CREATE
    response, which uses the underlying GSS-API\n      security context of the parent
    handle in all subsequent exchanges\n      that use the child handle.\n   o  An
    RPCSEC_GSSv3 child handle MUST NOT be used as the parent handle\n      in an RPCSEC_GSS3_CREATE
    control message.\n"
  - contents:
    - "2.1.  Compatibility with RPCSEC_GSSv2\n   The functionality of RPCSEC_GSSv2
      [RFC5403] is fully supported by\n   RPCSEC_GSSv3, with the exception of the
      RPCSEC_GSS_BIND_CHANNEL\n   operation, which is not supported when RPCSEC_GSSv3
      is in use (see\n   Section 2.5).\n"
    title: 2.1.  Compatibility with RPCSEC_GSSv2
  - contents:
    - "2.2.  Version Negotiation\n   An initiator that supports version 3 of RPCSEC_GSS
      simply issues an\n   RPCSEC_GSS request with the rgc_version field set to\n
      \  RPCSEC_GSS_VERS_3.  If the target does not recognize\n   RPCSEC_GSS_VERS_3,
      the target will return an RPC error per\n   Section 5.1 of [RFC2203].\n   The
      initiator MUST NOT attempt to use an RPCSEC_GSS handle returned\n   by version
      3 of a target with version 1 or version 2 of the same\n   target.  The initiator
      MUST NOT attempt to use an RPCSEC_GSS handle\n   returned by version 1 or version
      2 of a target with version 3 of the\n   same target.\n"
    title: 2.2.  Version Negotiation
  - contents:
    - "2.3.  New Reply Verifier\n   A new reply verifier is needed for RPCSEC_GSSv3
      because of a\n   situation that arises from the use of the same GSS context
      by child\n   and parent handles.  Because the RPCSEC_GSSv3 child handle uses
      the\n   same GSS context as the parent handle, a child and parent\n   RPCSEC_GSSv3
      handle could have the same RPCSEC_GSS sequence numbers.\n   Since the reply
      verifier of previous versions of RPCSEC_GSS computes\n   a Message Integrity
      Code (MIC) on just the sequence number, this\n   provides opportunities for
      man-in-the-middle attacks.\n   This issue is addressed in RPCSEC_GSS version
      3 by computing the\n   verifier using exactly the same input as the information
      used to\n   compute the request verifier, except that the mtype is changed from\n
      \  CALL to REPLY.  The new reply verifier computes a MIC over the\n   following
      RPC reply header data:\n     unsigned int xid;\n     msg_type mtype;    /* set
      to REPLY */\n     unsigned int rpcvers;\n     unsigned int prog;\n     unsigned
      int vers;\n     unsigned int proc;\n     opaque_auth  cred; /* binds the RPCSEC_GSS
      handle */\n"
    title: 2.3.  New Reply Verifier
  - contents:
    - "2.4.  XDR Code Preliminaries\n   The following code fragment replaces the corresponding
      preliminary\n   code shown in Figure 1 of [RFC5403].  The values in the code
      fragment\n   in Section 2.6 are additions to the auth_stat enumeration.\n   Subsequent
      code fragments are additions to the code for version 2\n   that support the
      new procedures defined in version 3.\n   <CODE BEGINS>\n      ///  /*\n      ///
      \  * Copyright (c) 2016 IETF Trust and the persons\n      ///   * identified
      as the authors.  All rights reserved.\n      ///   *\n      ///   * The authors
      of the code are identified in RFC 2203,\n      ///   * RFC 5403, and RFC 7861.\n
      \     ///   *\n      ///   * Redistribution and use in source and binary forms,\n
      \     ///   * with or without modification, are permitted\n      ///   * provided
      that the following conditions are met:\n      ///   *\n      ///   * o Redistributions
      of source code must retain the above\n      ///   *   copyright notice, this
      list of conditions and the\n      ///   *   following disclaimer.\n      ///
      \  *\n      ///   * o Redistributions in binary form must reproduce the\n      ///
      \  *   above copyright notice, this list of\n      ///   *   conditions and
      the following disclaimer in\n      ///   *   the documentation and/or other
      materials\n      ///   *   provided with the distribution.\n      ///   *\n
      \     ///   * o Neither the name of Internet Society, IETF or IETF\n      ///
      \  *   Trust, nor the names of specific contributors, may be\n      ///   *
      \  used to endorse or promote products derived from this\n      ///   *   software
      without specific prior written permission.\n      ///   *\n      ///   *   THIS
      SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n      ///   *   AND CONTRIBUTORS
      \"AS IS\" AND ANY EXPRESS OR IMPLIED\n      ///   *   WARRANTIES, INCLUDING,
      BUT NOT LIMITED TO, THE\n      ///   *   IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS\n      ///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n
      \     ///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n      ///
      \  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n      ///   *
      \  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n      ///   *   NOT
      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n      ///   *   SERVICES; LOSS
      OF USE, DATA, OR PROFITS; OR BUSINESS\n      ///   *   INTERRUPTION) HOWEVER
      CAUSED AND ON ANY THEORY OF\n      ///   *   LIABILITY, WHETHER IN CONTRACT,
      STRICT LIABILITY,\n      ///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
      ARISING\n      ///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n
      \     ///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n      ///   */\n
      \     ///\n      ///  /*\n      ///   * This code was derived from RFC 2203,
      RFC 5403,\n      ///   * and RFC 7861.  Please reproduce this note if possible.\n
      \     ///   */\n      ///\n      ///  enum rpc_gss_service_t {\n      ///          /*
      Note: The enumerated value for 0 is reserved. */\n      ///          rpc_gss_svc_none
      \        = 1,\n      ///          rpc_gss_svc_integrity    = 2,\n      ///          rpc_gss_svc_privacy
      \     = 3,\n      ///          rpc_gss_svc_channel_prot = 4\n      ///  };\n
      \     ///\n      ///  enum rpc_gss_proc_t {\n      ///           RPCSEC_GSS_DATA
      \         = 0,\n      ///           RPCSEC_GSS_INIT          = 1,\n      ///
      \          RPCSEC_GSS_CONTINUE_INIT = 2,\n      ///           RPCSEC_GSS_DESTROY
      \      = 3,\n      ///           RPCSEC_GSS_BIND_CHANNEL  = 4, /* Not used */\n
      \     ///           RPCSEC_GSS_CREATE        = 5, /* New */\n      ///           RPCSEC_GSS_LIST
      \         = 6  /* New */\n      ///  };\n      ///\n      ///  struct rpc_gss_cred_vers_1_t
      {\n      ///          rpc_gss_proc_t    gss_proc; /* Control procedure */\n
      \     ///          unsigned int      seq_num;  /* Sequence number */\n      ///
      \         rpc_gss_service_t service;  /* Service used */\n      ///          opaque
      \           handle<>; /* Context handle */\n      ///  };\n      ///\n      ///
      \ const RPCSEC_GSS_VERS_1 = 1;\n      ///  const RPCSEC_GSS_VERS_2 = 2;\n      ///
      \ const RPCSEC_GSS_VERS_3 = 3; /* New */\n      ///\n      ///  union rpc_gss_cred_t
      switch (unsigned int rgc_version) {\n      ///  case RPCSEC_GSS_VERS_1:\n      ///
      \ case RPCSEC_GSS_VERS_2:\n      ///  case RPCSEC_GSS_VERS_3: /* New */\n      ///
      \         rpc_gss_cred_vers_1_t rgc_cred_v1;\n      ///  };\n      ///\n   <CODE
      ENDS>\n   As seen above, the RPCSEC_GSSv3 credential has the same format as
      the\n   RPCSEC_GSSv1 [RFC2203] and RPCSEC_GSSv2 [RFC5403] credential.\n   Setting
      the rgc_version field to 3 indicates that the initiator and\n   target support
      the new RPCSEC_GSSv3 control procedures.\n"
    title: 2.4.  XDR Code Preliminaries
  - contents:
    - "2.5.  RPCSEC_GSS_BIND_CHANNEL Operation\n   RPCSEC_GSSv3 provides a channel-binding
      assertion that replaces the\n   RPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL operation.\n
      \  The RPCSEC_GSS_BIND_CHANNEL operation is not supported on RPCSEC_GSS\n   version
      3 handles.  If a server receives an RPCSEC_GSS_BIND_CHANNEL\n   operation on
      an RPCSEC_GSSv3 handle, it MUST return a reply status of\n   MSG_ACCEPTED with
      an accept_stat of PROC_UNAVAIL [RFC5531].\n"
    title: 2.5.  RPCSEC_GSS_BIND_CHANNEL Operation
  - contents:
    - "2.6.  New auth_stat Values\n   RPCSEC_GSSv3 requires the addition of several
      values to the auth_stat\n   enumerated type definition.  The use of these new
      auth_stat values is\n   explained throughout this document.\n              enum
      auth_stat {\n                      ...\n                      /*\n                       *
      RPCSEC_GSSv3 errors\n                       */\n                      RPCSEC_GSS_INNER_CREDPROBLEM
      = 15,\n                      RPCSEC_GSS_LABEL_PROBLEM     = 16,\n                      RPCSEC_GSS_PRIVILEGE_PROBLEM
      = 17,\n                      RPCSEC_GSS_UNKNOWN_MESSAGE   = 18\n              };\n"
    title: 2.6.  New auth_stat Values
  - contents:
    - "2.7.  New Control Procedures\n   There are two new RPCSEC_GSSv3 control procedures:
      RPCSEC_GSS_CREATE\n   and RPCSEC_GSS_LIST.\n   The RPCSEC_GSS_CREATE procedure
      binds any combination of assertions\n   -- multi-principal authentication, labels,
      structured privileges, or\n   channel bindings -- to a new RPCSEC_GSSv3 context
      returned in the\n   rgss3_create_res rcr_handle field.\n   The RPCSEC_GSS_LIST
      procedure queries the target for supported\n   assertions.\n   RPCSEC_GSS version
      3 control messages are similar to the RPCSEC_GSS\n   version 1 and version 2
      RPCSEC_GSS_DESTROY control message (see\n   Section 5.4 of [RFC2203]) in that
      the sequence number in the request\n   must be valid and the header checksum
      in the verifier must be valid.\n   As in RPCSEC_GSS version 1 and version 2,
      the RPCSEC_GSS version 3\n   control messages may contain call data following
      the verifier in the\n   body of the NULLPROC procedure.  In other words, they
      look a lot like\n   an RPCSEC_GSS data message with the header procedure set
      to NULLPROC.\n   The client MUST use one of the following security services
      to protect\n   the RPCSEC_GSS_CREATE or RPCSEC_GSS_LIST control message:\n   o
      \ rpc_gss_svc_integrity\n   o  rpc_gss_svc_privacy\n   Specifically, the client
      MUST NOT use rpc_gss_svc_none.\n   RPCSEC_GSS_LIST can also use rpc_gss_svc_channel_prot
      (see\n   RPCSEC_GSSv2 [RFC5403]) if the request is sent using an RPCSEC_GSSv3\n
      \  child handle with channel bindings enabled as described in\n   Section 2.7.1.2.\n"
    - contents:
      - "2.7.1.  New Control Procedure - RPCSEC_GSS_CREATE\n   <CODE BEGINS>\n      ///
        \ struct rgss3_create_args {\n      ///          rgss3_gss_mp_auth    *rca_mp_auth;\n
        \     ///          rgss3_chan_binding   *rca_chan_bind_mic;\n      ///          rgss3_assertion_u
        \   rca_assertions<>;\n      ///  };\n      ///\n      ///  struct rgss3_create_res
        {\n      ///          opaque               rcr_handle<>;\n      ///          rgss3_gss_mp_auth
        \   *rcr_mp_auth;\n      ///          rgss3_chan_binding   *rcr_chan_bind_mic;\n
        \     ///          rgss3_assertion_u    rcr_assertions<>;\n      ///  };\n
        \     ///\n      ///  enum rgss3_assertion_type {\n      ///          LABEL
        = 0,\n      ///          PRIVS = 1\n      ///  };\n      ///\n      ///  union
        rgss3_assertion_u\n      ///        switch (rgss3_assertion_type atype) {\n
        \     ///  case LABEL:\n      ///          rgss3_label  rau_label;\n      ///
        \ case PRIVS:\n      ///          rgss3_privs  rau_privs;\n      ///  default:\n
        \     ///          opaque       rau_ext<>;\n      ///  };\n      ///\n   <CODE
        ENDS>\n   The call data for an RPCSEC_GSS_CREATE request consists of an\n
        \  rgss3_create_args, which binds one or more items of several kinds to\n
        \  the returned rcr_handle RPCSEC_GSSv3 context handle (the child\n   handle):\n
        \  o  Multi-principal authentication: another RPCSEC_GSS context handle\n
        \  o  A channel binding\n   o  Authorization assertions: labels and/or privileges\n
        \  The reply to this message consists of either an error or an\n   rgss3_create_res
        structure.  As noted in Sections 2.7.1.3 and\n   2.7.1.4, successful rgss3_assertions
        are enumerated in rcr_assertions\n   and are REQUIRED to be enumerated in
        the same order as they appeared\n   in the rca_assertions argument.\n   Upon
        a successful RPCSEC_GSS_CREATE, both the client and the server\n   need to
        associate the resultant child rcr_handle context handle with\n   the parent
        context handle in their GSS context caches so as to be\n   able to reference
        the parent context given the child context handle.\n   RPCSEC_GSSv3 child
        handles MUST be destroyed upon the destruction of\n   the associated parent
        handle.\n   Server implementation and policy MAY result in labels, privileges,\n
        \  and identities being mapped to concepts and values that are local to\n
        \  the server.  Server policies should take into account the identity of\n
        \  the client and/or user as authenticated via the GSS-API.\n"
      - contents:
        - "2.7.1.1.  Multi-Principal Authentication\n   <CODE BEGINS>\n      ///\n
          \     ///  struct rgss3_gss_mp_auth {\n      ///          opaque          rgmp_handle<>;
          /* Inner handle */\n      ///          opaque          rgmp_rpcheader_mic<>;\n
          \     ///  };\n      ///\n   <CODE ENDS>\n   RPCSEC_GSSv3 clients MAY assert
          a multi-principal authentication of\n   the RPC client host principal and
          a user principal.  This feature is\n   needed, for example, when an RPC
          client host wishes to use authority\n   assertions that the server may only
          grant if a user and an RPC client\n   host are authenticated together to
          the server.  Thus, a server may\n   refuse to grant requested authority
          to a user acting alone (e.g., via\n   an unprivileged user-space program)
          or to an RPC client host acting\n   alone (e.g., when an RPC client host
          is acting on behalf of a user)\n   but may grant requested authority to
          an RPC client host acting on\n   behalf of a user if the server identifies
          the user and trusts the RPC\n   client host.\n   It is assumed that an unprivileged
          user-space program would not have\n   access to RPC client host credentials
          needed to establish a GSS-API\n   security context authenticating the RPC
          client host to the server;\n   therefore, an unprivileged user-space program
          could not create an\n   RPCSEC_GSSv3 RPCSEC_GSS_CREATE message that successfully
          binds an RPC\n   client host and a user security context.\n   In addition
          to the parent handle (Section 2), the multi-principal\n   authentication
          call data has an RPCSEC_GSS version 3 handle\n   referenced via the rgmp_handle
          field termed the \"inner\" handle.\n   Clients using RPCSEC_GSSv3 multi-principal
          authentication MUST use an\n   RPCSEC_GSSv3 context handle that corresponds
          to a GSS-API security\n   context that authenticates the RPC client host
          for the parent handle.\n   The inner context handle of the multi-principal
          authentication\n   assertion MUST use an RPCSEC_GSSv3 context handle that
          corresponds to\n   a GSS-API security context that authenticates the user.
          \ The reverse\n   (parent handle authenticates user, inner context handle
          authenticates\n   an RPC client host) MUST NOT be used.  Other multi-principal
          parent\n   and inner context handle uses might eventually make sense, but
          they\n   would need to be introduced in a new revision of the RPCSEC_GSS\n
          \  protocol.\n   The child context handle returned by a successful multi-principal\n
          \  assertion binds the inner RPCSEC_GSSv3 context handle to the parent\n
          \  RPCSEC_GSS context handle and MUST be treated by servers as\n   authenticating
          the GSS-API initiator principal authenticated by the\n   inner context handle's
          GSS-API security context.  This principal may\n   be mapped to a server-side
          notion of user or principal.\n   Multi-principal binding is done by including
          an assertion of type\n   rgss3_gss_mp_auth in the RPCSEC_GSS_CREATE rgss3_create_args
          call\n   data.  The inner context handle is placed in the rgmp_handle field.\n
          \  A MIC of the RPC header, up to and including the credential, is\n   computed
          using the GSS-API security context associated with the inner\n   context
          handle and is placed in the rgmp_rpcheader_mic field.  Note\n   that the
          rgmp_rpcheader_mic only identifies the client host GSS\n   context by its
          context handle (the parent context handle) in the RPC\n   header.\n   An
          RPCSEC_GSS_CREATE control procedure with a multi-principal\n   authentication
          payload MUST use the rpc_gss_svc_privacy security\n   service for protection.
          \ This prevents an attacker from intercepting\n   the RPCSEC_GSS_CREATE
          control procedure, reassigning the (parent)\n   context handle, and stealing
          the user's identity.\n   The target verifies the multi-principal authentication
          by first\n   confirming that the parent context used is an RPC client host\n
          \  context; the target then verifies the rgmp_rpcheader_mic using the\n
          \  GSS-API security context associated with the rgmp_handle field.\n   On
          successful verification, the rgss3_gss_mp_auth field in the\n   rgss3_create_res
          reply MUST be filled in with the inner RPCSEC_GSSv3\n   context handle as
          the rgmp_handle and a MIC computed over the RPC\n   reply header (see Section
          2.3) using the GSS-API security context\n   associated with the inner handle.\n
          \  On failure, the rgss3_gss_mp_auth field is not sent\n   (rgss3_gss_mp_auth
          is an optional field).  A MSG_DENIED reply to the\n   RPCSEC_GSS_CREATE
          call is formulated as usual.\n   As described in Section 5.3.3.3 of [RFC2203],
          the server maintains a\n   list of contexts for the clients that are currently
          in session with\n   it.  When a client request comes in, there may not be
          a context\n   corresponding to its handle.  When this occurs on an\n   RPCSEC_GSS3_CREATE
          request processing of the parent handle, the\n   server rejects the request
          with a reply status of MSG_DENIED with the\n   reject_stat of AUTH_ERROR
          and with an auth_stat value of\n   RPCSEC_GSS_CREDPROBLEM.\n   A new value,
          RPCSEC_GSS_INNER_CREDPROBLEM, has been added to the\n   auth_stat type.
          \ With a multi-principal authorization request, the\n   server must also
          have a context corresponding to the inner context\n   handle.  When the
          server does not have a context handle corresponding\n   to the inner context
          handle of a multi-principal authorization\n   request, the server sends
          a reply status of MSG_DENIED with the\n   reject_stat of AUTH_ERROR and
          with an auth_stat value of\n   RPCSEC_GSS_INNER_CREDPROBLEM.\n   When processing
          the multi-principal authentication request, if the\n   GSS_VerifyMIC() call
          on the rgmp_rpcheader_mic fails to return\n   GSS_S_COMPLETE, the server
          sends a reply status of MSG_DENIED with\n   the reject_stat of AUTH_ERROR
          and with an auth_stat value of\n   RPCSEC_GSS_INNER_CREDPROBLEM.\n"
        title: 2.7.1.1.  Multi-Principal Authentication
      - contents:
        - "2.7.1.2.  Channel Binding\n   <CODE BEGINS>\n      ///\n      ///  typedef
          opaque rgss3_chan_binding<>;\n      ///\n   <CODE ENDS>\n   RPCSEC_GSSv3
          provides a different way to do channel binding than\n   RPCSEC_GSSv2 [RFC5403].
          \ Specifically:\n   a.  RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing,\n
          \      established context handles rather than providing a different RPC\n
          \      security flavor for establishing context handles.\n   b.  Channel-bindings
          data is not hashed because there is now general\n       agreement that it
          is the secure channel's responsibility to\n       produce channel-bindings
          data of manageable size.\n   (a) is useful in keeping RPCSEC_GSSv3 simple
          in general, not just for\n   channel binding.  (b) is useful in keeping
          RPCSEC_GSSv3 simple\n   specifically for channel binding.\n   Channel binding
          is accomplished as follows.  The client prefixes the\n   channel-bindings
          data octet string with the channel type as described\n   in [RFC5056]; then,
          the client calls GSS_GetMIC() to get a MIC of the\n   resulting octet string,
          using the parent RPCSEC_GSSv3 context\n   handle's GSS-API security context.
          \ The MIC is then placed in the\n   rca_chan_bind_mic field of RPCSEC_GSS_CREATE
          arguments\n   (rgss3_create_args).\n   If the rca_chan_bind_mic field of
          the arguments of an\n   RPCSEC_GSS_CREATE control message is set, then the
          server MUST verify\n   the client's channel-binding MIC if the server supports
          this feature.\n   If channel-binding verification succeeds, then the server
          MUST\n   generate a new MIC of the same channel bindings and place it in
          the\n   rcr_chan_bind_mic field of the RPCSEC_GSS_CREATE rgss3_create_res\n
          \  results.  If channel-binding verification fails or the server doesn't\n
          \  support channel binding, then the server MUST indicate this in its\n
          \  reply by not including an rgss3_chan_binding value in\n   rgss3_create_res
          (rgss3_chan_binding is an optional field).\n   The client MUST verify the
          result's rcr_chan_bind_mic value by\n   calling GSS_VerifyMIC() with the
          given MIC and the channel-bindings\n   data (including the channel-type
          prefix).  If client-side channel-\n   binding verification fails, then the
          client MUST call\n   RPCSEC_GSS_DESTROY.  If the client requested channel
          binding but the\n   server did not include an rcr_chan_binding_mic field
          in the results,\n   then the client MAY continue to use the resulting context
          handle as\n   though channel binding had never been requested.  If the client\n
          \  considers channel binding critical, it MUST call RPCSEC_GSS_DESTROY.\n
          \  As per RPCSEC_GSSv2 [RFC5403]:\n      Once a successful [channel-binding]
          procedure has been performed\n      on an [RPCSEC_GSSv3] context handle,
          the initiator's\n      implementation may map application requests for rpc_gss_svc_none\n
          \     and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials.\n
          \     And if the secure channel has privacy enabled, requests for\n      rpc_gss_svc_privacy
          can also be mapped to\n      rpc_gss_svc_channel_prot.\n   Any RPCSEC_GSSv3
          child context handle that has been bound to a secure\n   channel in this
          way SHOULD be used only with the\n   rpc_gss_svc_channel_prot and SHOULD
          NOT be used with rpc_gss_svc_none\n   or rpc_gss_svc_integrity -- if the
          secure channel does not provide\n   privacy protection, then the client
          MAY use rpc_gss_svc_privacy where\n   privacy protection is needed or desired.\n"
        title: 2.7.1.2.  Channel Binding
      - contents:
        - "2.7.1.3.  Label Assertions\n   <CODE BEGINS>\n      ///  struct rgss3_label
          {\n      ///          rgss3_lfs       rl_lfs;\n      ///          opaque
          \         rl_label<>;\n      ///  };\n      ///\n      ///  struct rgss3_lfs
          {\n      ///          unsigned int rlf_lfs_id;\n      ///          unsigned
          int rlf_pi_id;\n      ///  };\n      ///\n   <CODE ENDS>\n   The client
          discovers, via the RPCSEC_GSS_LIST control message, which\n   LFSs the server
          supports.  Full Mode MAC is enabled when an\n   RPCSEC_GSS version 3 process
          subject label assertion is combined with\n   a file object label provided
          by the NFSv4.2 sec_label attribute.\n   Label encoding is specified to mirror
          the NFSv4.2 sec_label attribute\n   described in Section 12.2.4 of [RFC7862].
          \ The LFS is an identifier\n   used by the client to establish the syntactic
          format of the security\n   label and the semantic meaning of its components.
          \ The Policy\n   Identifier (PI) is an optional part of the definition of
          an LFS that\n   allows clients and the server to identify specific security
          policies.\n   The opaque label field (rgss3_label) is dependent on the MAC
          model to\n   interpret and enforce.\n   If a label itself requires privacy
          protection (i.e., requires that\n   the user can assert that the label is
          a secret), then the client MUST\n   use the rpc_gss_svc_privacy protection
          service for the\n   RPCSEC_GSS_CREATE request.\n   RPCSEC_GSSv3 clients
          MAY assert a set of subject security labels in\n   some LFS by binding a
          label assertion to the RPCSEC_GSSv3 child\n   context handle.  This is done
          by including an assertion of type\n   rgss3_label in the RPCSEC_GSS_CREATE
          rgss3_create_args rca_assertions\n   call data.  The label assertion payload
          is the set of subject labels\n   asserted by the calling NFS client process.
          \ The resultant child\n   context is used for NFS requests asserting the
          client process subject\n   labels.  The NFS server process that handles
          such requests then\n   asserts the (client) process subject label(s) as
          it attempts to\n   access a file that has associated Labeled NFS object
          labels.\n   Servers that support labeling in the requested LFS MAY map the\n
          \  requested subject label to a different subject label as a result of\n
          \  server-side policy evaluation.\n   The labels that are accepted by the
          target and bound to the\n   RPCSEC_GSSv3 context MUST be enumerated in the
          rcr_assertions field\n   of the rgss3_create_res RPCSEC_GSS_CREATE reply.\n
          \  Servers that do not support labeling or that do not support the\n   requested
          LFS reject the label assertion with a reply status of\n   MSG_DENIED, a
          reject_status of AUTH_ERROR, and an auth_stat of\n   RPCSEC_GSS_LABEL_PROBLEM.\n"
        title: 2.7.1.3.  Label Assertions
      - contents:
        - "2.7.1.4.  Structured Privilege Assertions\n   <CODE BEGINS>\n      ///\n
          \     ///  typedef opaque utf8string<>;   /* UTF-8 encoding */\n      ///
          \ typedef utf8string utf8str_cs; /* Case-sensitive UTF-8 */\n      ///\n
          \     ///  struct rgss3_privs {\n      ///          utf8str_cs      rp_name<>;\n
          \     ///          opaque          rp_privilege<>;\n      ///  };\n   <CODE
          ENDS>\n   A structured privilege is a capability defined by a specific RPC\n
          \  application.  To support the assertion of this privilege, by a client\n
          \  using the application, in a server that also supports the\n   application,
          the application may define a private data structure that\n   is understood
          by clients and servers implementing the RPC\n   application.\n   RPCSEC_GSSv3
          clients MAY assert a structured privilege by binding the\n   privilege to
          the RPCSEC_GSSv3 context handle.  This is done by\n   including an assertion
          of type rgss3_privs in the RPCSEC_GSS_CREATE\n   rgss3_create_args rca_assertions
          call data.\n   The privilege is identified by the description string that
          is used by\n   RPCSEC_GSSv3 to identify the privilege and communicate the
          private\n   data between the relevant RPC application-specific code without\n
          \  needing to be aware of the details of the structure used.  Thus, as\n
          \  far as RPCSEC_GSSv3 is concerned, the defined structure is passed\n   between
          client and server as opaque data encoded in the\n   rpc_gss3_privs rp_privilege
          field.\n   Encoding, server verification, and any server policies for structured\n
          \  privileges are described by the RPC application definition.  The\n   rp_name
          field of rpc_gss3_privs carries the description string used\n   to identify
          and list the privilege.  The utf8str_cs definition is\n   from [RFC7530].\n
          \  A successful structured privilege assertion MUST be enumerated in the\n
          \  rcr_assertions field of the rgss3_create_res RPCSEC_GSS_CREATE reply.\n
          \  If a server receives a structured privilege assertion that it does\n
          \  not recognize, the assertion is rejected with a reply status of\n   MSG_DENIED,
          a reject_status of AUTH_ERROR, and an auth_stat of\n   RPCSEC_GSS_UNKNOWN_MESSAGE.\n
          \  It is assumed that a client asserting more than one structured\n   privilege
          to be bound to a context handle would not require all the\n   privilege
          assertions to succeed.\n   The server MUST NOT reject RPCSEC_GSS_CREATE
          requests containing\n   supported structured privilege assertions, even
          if some of those\n   assertions are rejected (e.g., for local policy reasons).\n
          \  If a server receives an RPCSEC_GSS_CREATE request containing one or\n
          \  more unsupported structured privilege assertions, the request MUST be\n
          \  rejected with a reply status of MSG_DENIED, a reject_status of\n   AUTH_ERROR,
          and an auth_stat of RPCSEC_GSS_PRIVILEGE_PROBLEM.\n   Section 4.9.1.1 of
          [RFC7862] (\"Inter-Server Copy via ONC RPC with\n   RPCSEC_GSSv3\") shows
          an example of structured privilege definition\n   and use.\n"
        title: 2.7.1.4.  Structured Privilege Assertions
      title: 2.7.1.  New Control Procedure - RPCSEC_GSS_CREATE
    - contents:
      - "2.7.2.  New Control Procedure - RPCSEC_GSS_LIST\n   <CODE BEGINS>\n      ///
        \ enum rgss3_list_item {\n      ///          LABEL = 0,\n      ///          PRIVS
        = 1\n      ///  };\n      ///\n      ///  struct rgss3_list_args {\n      ///
        \         rgss3_list_item      rla_list_what<>;\n      ///  };\n      ///\n
        \     ///  union rgss3_list_item_u\n      ///        switch (rgss3_list_item
        itype) {\n      ///  case LABEL:\n      ///          rgss3_label          rli_labels<>;\n
        \     ///  case PRIVS:\n      ///          rgss3_privs          rli_privs<>;\n
        \     ///  default:\n      ///          opaque               rli_ext<>;\n
        \     ///  };\n      ///\n      ///  typedef rgss3_list_item_u rgss3_list_res<>;\n
        \     ///\n   <CODE ENDS>\n   The call data for an RPCSEC_GSS_LIST request
        consists of a list of\n   integers (rla_list_what) indicating what assertions
        are to be listed,\n   and the reply consists of an error or the requested
        list.\n   The result of requesting a list of rgss3_list_item LABEL objects
        is a\n   list of LFSs supported by the server.  The client can then use the\n
        \  LFS list to assert labels via the RPCSEC_GSS_CREATE label assertions.\n
        \  See Section 2.7.1.3.\n"
      title: 2.7.2.  New Control Procedure - RPCSEC_GSS_LIST
    title: 2.7.  New Control Procedures
  - contents:
    - "2.8.  Extensibility\n   Assertion types may be added in the future by adding
      arms to the\n   \"rgss3_assertion_u\" union (Section 2.7.1) and the \"rgss3_list_item_u\"\n
      \  union (Section 2.7.2).  Examples of other potential assertion types\n   include:\n
      \  o  Client-side assertions of identity:\n      *  Primary client/user identity.\n
      \     *  Supplementary group memberships of the client/user, including\n         support
      for specifying deltas to the membership list as seen on\n         the server.\n"
    title: 2.8.  Extensibility
  title: 2.  The RPCSEC_GSSv3 Protocol
- contents:
  - "3.  Operational Recommendation for Deployment\n   RPCSEC_GSSv3 is a superset
    of RPCSEC_GSSv2 [RFC5403], which in turn\n   is a superset of RPCSEC_GSSv1 [RFC2203],
    and so can be used in all\n   situations where RPCSEC_GSSv2 is used, or where
    RPCSEC_GSSv1 is used\n   and channel-bindings functionality is not needed.  RPCSEC_GSSv3\n
    \  should be used when the new functionality is needed.\n"
  title: 3.  Operational Recommendation for Deployment
- contents:
  - "4.  Security Considerations\n   This entire document deals with security issues.\n
    \  The RPCSEC_GSSv3 protocol allows for client-side assertions of data\n   that
    is relevant to server-side authorization decisions.  These\n   assertions must
    be evaluated by the server in the context of whether\n   the client and/or user
    are authenticated, whether multi-principal\n   authentication was used, whether
    the client is trusted, what ranges\n   of assertions are allowed for the client
    and the user (separately or\n   together), and any relevant server-side policy.\n
    \  The security semantics of assertions carried by RPCSEC_GSSv3 are\n   application
    protocol-specific.\n   Note that RPCSEC_GSSv3 is not a complete solution for labeling:
    it\n   conveys the labels of actors but not the labels of objects.  RPC\n   application
    protocols may require extending in order to carry object\n   label information.\n
    \  There may be interactions with NFSv4's callback security scheme and\n   NFSv4.1's
    [RFC5661] GSS SSV (Secret State Verifier) mechanisms.\n   Specifically, the NFSv4
    callback scheme requires that the server\n   initiate GSS-API security contexts,
    which does not work well in\n   practice; in the context of client-side processes
    running as the same\n   user but with different privileges and security labels,
    the NFSv4\n   callback security scheme seems particularly unlikely to work well.\n
    \  NFSv4.1 has the server use an existing, client-initiated RPCSEC_GSS\n   context
    handle to protect server-initiated callback RPCs.  The\n   NFSv4.1 callback security
    scheme lacks all the problems of the NFSv4\n   scheme; however, it is important
    that the server pick an appropriate\n   RPCSEC_GSS context handle to protect any
    callbacks.  Specifically, it\n   is important that the server use RPCSEC_GSS context
    handles that\n   authenticate the client to protect any callbacks related to server\n
    \  state initiated by RPCs protected by RPCSEC_GSSv3 contexts.\n   As described
    in Section 2.10.10 of [RFC5661], the client is permitted\n   to associate multiple
    RPCSEC_GSS handles with a single SSV GSS\n   context.  RPCSEC_GSSv3 handles will
    work well with SSV in that the\n   man-in-the-middle attacks described in Section
    2.10.10 of [RFC5661]\n   are solved by the new reply verifier (Section 2.3).  Using
    an\n   RPCSEC_GSSv3 handle backed by a GSS-SSV mechanism context as a parent\n
    \  handle in an RPCSEC_GSS_CREATE call, while permitted, is complicated\n   by
    the lifetime rules of SSV contexts and their associated RPCSEC_GSS\n   handles.\n"
  title: 4.  Security Considerations
- contents:
  - "5.  IANA Considerations\n   This section uses terms that are defined in [RFC5226].\n"
  - contents:
    - "5.1.  New RPC Authentication Status Numbers\n   The following new RPC Authentication
      Status Numbers have been added\n   to the IANA registry:\n   o  RPCSEC_GSS_INNER_CREDPROBLEM
      (15)  \"No credentials for\n      multi-principal assertion inner context user\".
      \ See\n      Section 2.7.1.1.\n   o  RPCSEC_GSS_LABEL_PROBLEM (16)  \"Problem
      with label assertion\".\n      See Section 2.7.1.3.\n   o  RPCSEC_GSS_PRIVILEGE_PROBLEM
      (17)  \"Problem with structured\n      privilege assertion\".  See Section 2.7.1.4.\n
      \  o  RPCSEC_GSS_UNKNOWN_MESSAGE (18)  \"Unknown structured privilege\n      assertion\".
      \ See Section 2.7.1.4.\n"
    title: 5.1.  New RPC Authentication Status Numbers
  - contents:
    - "5.2.  Structured Privilege Name Definitions\n   IANA has created a registry
      called the \"RPCSEC_GSS Structured\n   Privilege Names Registry\".\n   Structured
      privilege assertions (Section 2.7.1.4) are defined by a\n   specific RPC application.
      \ The namespace identifiers for these\n   assertions (the rp_name) are defined
      as string names.  The\n   RPCSEC_GSSv3 protocol does not define the specific
      assignment of the\n   namespace for these structured privilege assertion names.
      \ The IANA\n   registry promotes interoperability where common interests exist.\n
      \  While RPC application developers are allowed to define and use\n   structured
      privileges as needed, they are encouraged to register\n   structured privilege
      assertion names with IANA.\n   The registry is to be maintained using the Standards
      Action policy as\n   defined in Section 4.1 of [RFC5226].\n   Under the RPCSEC_GSS
      version 3 specification, the name of a\n   structured privilege can in theory
      be up to 2^32 - 1 bytes in length,\n   but in practice RPC application clients
      and servers will be unable to\n   handle a string that long.  IANA should reject
      any assignment request\n   with a structured privilege name that exceeds 128
      UTF-8 characters.\n   To give the IESG the flexibility to set up bases of assignment
      of\n   Experimental Use, the prefix \"EXPE\" is Reserved.  The structured\n
      \  privilege with a zero-length name is Reserved.\n   The prefix \"PRIV\" is
      allocated for Private Use.  A site that wants to\n   make use of unregistered
      named attributes without risk of conflicting\n   with an assignment in IANA's
      registry should use the prefix \"PRIV\" in\n   all of its structured privilege
      assertion names.\n   Because some RPC application clients and servers have case-\n
      \  insensitive semantics, the fifteen additional lower-case and mixed-\n   case
      permutations of each of \"EXPE\" and \"PRIV\" are Reserved (e.g.,\n   \"expe\",
      \"expE\", and \"exPe\" are Reserved).  Similarly, IANA must not\n   allow two
      assignments that would conflict if both structured\n   privilege names were
      converted to a common case.\n   The registry of structured privilege names is
      a list of assignments,\n   each containing three fields for each assignment.\n
      \  1.  A US-ASCII string name that is the actual name of the structured\n       privilege.
      \ This name must be unique.  This string name can be 1\n       to 128 UTF-8
      characters long.\n   2.  A reference to the specification of the RPC-application-defined\n
      \      structured privilege.  The reference can consume up to 256 bytes\n       (or
      more if IANA permits).\n   3.  The point of contact of the registrant.  The
      point of contact can\n       consume up to 256 bytes (or more if IANA permits).\n"
    - contents:
      - "5.2.1.  Initial Registry\n   The initial registry consists of the three structured
        privileges\n   defined in [RFC7862].\n   1.  NAME: copy_to_auth, REFERENCE:
        RFC 7862, CONTACT: William\n       A.(Andy) Adamson, andros@netapp.com\n   2.
        \ NAME: copy_from_auth, REFERENCE: RFC 7862, CONTACT: William\n       A.(Andy)
        Adamson, andros@netapp.com\n   3.  NAME: copy_confirm_auth, REFERENCE: RFC
        7862, CONTACT: William\n       A.(Andy) Adamson, andros@netapp.com\n"
      title: 5.2.1.  Initial Registry
    - contents:
      - "5.2.2.  Updating Registrations\n   The registrant is always permitted to
        update the point of contact\n   field.  To make any other change will require
        Expert Review or IESG\n   Approval.\n"
      title: 5.2.2.  Updating Registrations
    title: 5.2.  Structured Privilege Name Definitions
  title: 5.  IANA Considerations
- contents:
  - '6.  References

    '
  - contents:
    - "6.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2203]  Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol\n              Specification\",
      RFC 2203, DOI 10.17487/RFC2203,\n              September 1997, <http://www.rfc-editor.org/info/rfc2203>.\n
      \  [RFC2743]  Linn, J., \"Generic Security Service Application Program\n              Interface
      Version 2, Update 1\", RFC 2743,\n              DOI 10.17487/RFC2743, January
      2000,\n              <http://www.rfc-editor.org/info/rfc2743>.\n   [RFC4506]
      \ Eisler, M., Ed., \"XDR: External Data Representation\n              Standard\",
      STD 67, RFC 4506, DOI 10.17487/RFC4506,\n              May 2006, <http://www.rfc-editor.org/info/rfc4506>.\n
      \  [RFC5056]  Williams, N., \"On the Use of Channel Bindings to Secure\n              Channels\",
      RFC 5056, DOI 10.17487/RFC5056, November 2007,\n              <http://www.rfc-editor.org/info/rfc5056>.\n
      \  [RFC5403]  Eisler, M., \"RPCSEC_GSS Version 2\", RFC 5403,\n              DOI
      10.17487/RFC5403, February 2009,\n              <http://www.rfc-editor.org/info/rfc5403>.\n
      \  [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
      File System (NFS) Version 4 Minor Version 1\n              Protocol\", RFC 5661,
      DOI 10.17487/RFC5661, January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n
      \  [RFC7530]  Haynes, T., Ed., and D. Noveck, Ed., \"Network File System\n              (NFS)
      Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530,\n              March 2015,
      <http://www.rfc-editor.org/info/rfc7530>.\n   [RFC7862]  Haynes, T., \"Network
      File System (NFS) Version 4 Minor\n              Version 2 Protocol\", RFC 7862,
      DOI 10.17487/RFC7862,\n              November 2016, <http://www.rfc-editor.org/info/rfc7862>.\n"
    title: 6.1.  Normative References
  - contents:
    - "6.2.  Informative References\n   [AFS-RXGK]\n              Wilkinson, S. and
      B. Kaduk, \"Integrating rxgk with AFS\",\n              Work in Progress, draft-wilkinson-afs3-rxgk-afs-08,\n
      \             May 2015.\n   [RFC4949]  Shirey, R., \"Internet Security Glossary,
      Version 2\",\n              FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,\n
      \             <http://www.rfc-editor.org/info/rfc4949>.\n   [RFC5226]  Narten,
      T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations
      Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226, May
      2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5531]
      \ Thurlow, R., \"RPC: Remote Procedure Call Protocol\n              Specification
      Version 2\", RFC 5531, DOI 10.17487/RFC5531,\n              May 2009, <http://www.rfc-editor.org/info/rfc5531>.\n"
    title: 6.2.  Informative References
  title: 6.  References
- contents:
  - "Acknowledgments\n   Andy Adamson would like to thank NetApp, Inc. for its funding
    of his\n   time on this project.\n   We thank Lars Eggert, Mike Eisler, Ben Kaduk,
    Bruce Fields, Tom\n   Haynes, and Dave Noveck for their most helpful reviews.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   William A. (Andy) Adamson\n   NetApp\n   3629 Wagner Ridge
    Ct.\n   Ann Arbor, MI  48103\n   United States of America\n   Phone: +1 734 665
    1204\n   Email: andros@netapp.com\n   Nico Williams\n   cryptonector.com\n   13115
    Tamayo Dr.\n   Austin, TX  78729\n   United States of America\n   Email: nico@cryptonector.com\n"
  title: Authors' Addresses
