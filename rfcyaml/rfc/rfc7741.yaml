- contents:
  - '                    RTP Payload Format for VP8 Video

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This memo describes an RTP payload format for the VP8 video codec.\n
    \  The payload format has wide applicability, as it supports\n   applications
    from low-bitrate peer-to-peer usage to high-bitrate\n   video conferences.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7741.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions, Definitions, and Abbreviations .....................3\n   3.
    Media Format Description ........................................4\n   4. Payload
    Format ..................................................5\n      4.1. RTP Header
    Usage ...........................................6\n      4.2. VP8 Payload Descriptor
    .....................................7\n      4.3. VP8 Payload Header ........................................11\n
    \     4.4. Aggregated and Fragmented Payloads ........................12\n      4.5.
    Example Algorithms ........................................13\n           4.5.1.
    Frame Reconstruction Algorithm .....................13\n           4.5.2. Partition
    Reconstruction Algorithm .................13\n      4.6. Examples of VP8 RTP Stream
    ................................14\n           4.6.1. Key Frame in a Single RTP
    Packet ...................14\n           4.6.2. Non-discardable VP8 Interframe
    in a Single\n                  RTP Packet; No PictureID ...........................14\n
    \          4.6.3. VP8 Partitions in Separate RTP Packets .............15\n           4.6.4.
    VP8 Frame Fragmented across RTP Packets ............16\n           4.6.5. VP8
    Frame with Long PictureID ......................18\n   5. Using VP8 with RPSI
    and SLI Feedback ...........................18\n      5.1. RPSI ......................................................18\n
    \     5.2. SLI .......................................................19\n      5.3.
    Example ...................................................19\n   6. Payload Format
    Parameters ......................................21\n      6.1. Media Type Definition
    .....................................21\n      6.2. SDP Parameters ............................................23\n
    \          6.2.1. Mapping of Media Subtype Parameters to SDP .........23\n           6.2.2.
    Offer/Answer Considerations ........................23\n   7. Security Considerations
    ........................................24\n   8. Congestion Control .............................................24\n
    \  9. IANA Considerations ............................................24\n   10.
    References ....................................................25\n      10.1.
    Normative References .....................................25\n      10.2. Informative
    References ...................................26\n   Authors' Addresses ................................................28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo describes an RTP payload specification applicable
    to the\n   transmission of video streams encoded using the VP8 video codec\n   [RFC6386].
    \ The format described in this document can be used both in\n   peer-to-peer and
    video-conferencing applications.\n   VP8 is based on the decomposition of frames
    into square sub-blocks of\n   pixels known as \"macroblocks\" (see Section 2 of
    [RFC6386]).\n   Prediction of such sub-blocks using previously constructed blocks,\n
    \  and adjustment of such predictions (as well as synthesis of\n   unpredicted
    blocks) is done using a discrete cosine transform\n   (hereafter abbreviated as
    DCT).  In one special case, however, VP8\n   uses a \"Walsh-Hadamard\" transform
    (hereafter abbreviated as WHT)\n   instead of a DCT.  An encoded VP8 frame is
    divided into two or more\n   partitions, as described in [RFC6386].  The first
    partition\n   (prediction or mode) contains prediction mode parameters and motion\n
    \  vectors for all macroblocks.  The remaining partitions all contain\n   the
    quantized DCT/WHT coefficients for the residuals.  There can be\n   1, 2, 4, or
    8 DCT/WHT partitions per frame, depending on encoder\n   settings.\n   In summary,
    the payload format described in this document enables a\n   number of features
    in VP8, including:\n   o  Taking partition boundaries into consideration, to improve
    loss\n      robustness and facilitate efficient packet-loss concealment at the\n
    \     decoder.\n   o  Temporal scalability.\n   o  Advanced use of reference frames
    to enable efficient error\n      recovery.\n   o  Marking of frames that have
    no impact on the decoding of any other\n      frame, so that these non-reference
    frames can be discarded in a\n      server or media-aware network element if needed.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions, Definitions, and Abbreviations\n   The key words \"MUST\", \"MUST
    NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
    \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
    as described in [RFC2119].\n   This document uses the definitions of [RFC6386].
    \ In particular, the\n   following terms are used.\n   Key frames:  Frames that
    are decoded without reference to any other\n      frame in a sequence (also called
    intraframes and I-frames).\n   Interframes:  Frames that are encoded with reference
    to prior frames,\n      specifically all prior frames up to and including the
    most recent\n      key frame (also called prediction frames and P-frames).\n   Golden
    and altref frames:  alternate prediction frames.  Blocks in an\n      interframe
    may be predicted using blocks in the immediately\n      previous frame as well
    as the most recent golden frame or altref\n      frame.  Every key frame is automatically
    golden and altref, and\n      any interframe may optionally replace the most recent
    golden or\n      altref frame.\n   Macroblock:  a square array of pixels whose
    Y (luminance) dimensions\n      are 16x16 pixels and whose U and V (chrominance)
    dimensions are\n      8x8 pixels.\n   Two definitions from [RFC4585] are also
    used in this document.\n   RPSI:  Reference picture selection indication.  A feedback
    message to\n      let the encoder know that the decoder has correctly decoded
    a\n      certain frame.\n   SLI:  Slice loss indication.  A feedback message to
    let a decoder\n      inform an encoder that it has detected the loss or corruption
    of\n      one or several macroblocks.\n"
  title: 2.  Conventions, Definitions, and Abbreviations
- contents:
  - "3.  Media Format Description\n   The VP8 codec uses three different reference
    frames for interframe\n   prediction: the previous frame, the golden frame, and
    the altref\n   frame.  Blocks in an interframe may be predicted using blocks in
    the\n   immediately previous frame as well as the most recent golden frame or\n
    \  altref frame.  Every key frame is automatically golden and altref,\n   and
    any interframe may optionally replace the most recent golden or\n   altref frame.
    \ Golden frames and altref frames may also be used to\n   increase the tolerance
    to dropped frames.  The payload specification\n   in this memo has elements that
    enable advanced use of the reference\n   frames, e.g., for improved loss robustness.\n
    \  One specific use case of the three reference frame types is temporal\n   scalability.
    \ By setting up the reference hierarchy in the\n   appropriate way, up to five
    temporal layers can be encoded.  (How to\n   set up the reference hierarchy for
    temporal scalability is not within\n   the scope of this memo.)  Support for temporal
    scalability is\n   provided by the optional TL0PICIDX and TID/Y/KEYIDX fields
    described\n   in Section 4.2.  For a general description of temporal scalability\n
    \  for video coding, see [Sch07].\n   Another property of the VP8 codec is that
    it applies data\n   partitioning to the encoded data.  Thus, an encoded VP8 frame
    can be\n   divided into two or more partitions, as described in \"VP8 Data Format\n
    \  and Decoding Guide\" [RFC6386].  The first partition (prediction or\n   mode)
    contains prediction mode parameters and motion vectors for all\n   macroblocks.
    \ The remaining partitions all contain the transform\n   coefficients for the
    residuals.  The first partition is decodable\n   without the remaining residual
    partitions.  The subsequent partitions\n   may be useful even if some part of
    the frame is lost.  Accordingly,\n   this document RECOMMENDS that the frame be
    packetized by the sender\n   with each data partition in a separate packet or
    packets.  This may\n   be beneficial for decoder-side error concealment, and the
    payload\n   format described in Section 4 provides fields that allow the\n   partitions
    to be identified even if the first partition is not\n   available.  The sender
    can, alternatively, aggregate the data\n   partitions into a single data stream
    and, optionally, split it into\n   several packets without consideration of the
    partition boundaries.\n   The receiver can use the length information in the first
    partition to\n   identify the partitions during decoding.\n   The format specification
    is described in Section 4.  In Section 5, a\n   method to acknowledge receipt
    of reference frames using RTCP\n   techniques is described.\n   The payload partitioning
    and the acknowledging method both serve as\n   motivation for three of the fields
    included in the payload format:\n   the \"PID\", \"1st partition size\", and \"PictureID\"
    fields.  The ability\n   to encode a temporally scalable stream motivates the
    \"TL0PICIDX\" and\n   \"TID\" fields.\n"
  title: 3.  Media Format Description
- contents:
  - "4.  Payload Format\n   This section describes how the encoded VP8 bitstream is
    encapsulated\n   in RTP.  To handle network losses, usage of RTP/AVPF [RFC4585]
    is\n   RECOMMENDED.  All integer fields in the specifications are encoded as\n
    \  unsigned integers in network octet order.\n"
  - contents:
    - "4.1.  RTP Header Usage\n   The general RTP payload format for VP8 is depicted
      below.\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |V=2|P|X|  CC   |M|     PT      |       sequence number         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           timestamp                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |           synchronization source (SSRC) identifier            |\n     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n
      \    |            contributing source (CSRC) identifiers             |\n     |
      \                            ....                              |\n     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n
      \    |            VP8 payload descriptor (integer #octets)           |\n     :
      \                                                              :\n     |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                               : VP8 payload header (3 octets) |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | VP8 pyld hdr  :                                               |\n     +-+-+-+-+-+-+-+-+
      \                                              |\n     :                   Octets
      4..N of VP8 payload                  :\n     |                                                               |\n
      \    |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                              :    OPTIONAL RTP padding       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The VP8 payload descriptor and VP8 payload header will be described\n   in
      Sections 4.2 and 4.3.  OPTIONAL RTP padding MUST NOT be included\n   unless
      the P bit is set.  The figure specifically shows the format\n   for the first
      packet in a frame.  Subsequent packets will not contain\n   the VP8 payload
      header and will have later octets in the frame\n   payload.\n                                 Figure
      1\n   Marker bit (M):  MUST be set for the very last packet of each encoded\n
      \     frame in line with the normal use of the M bit in video formats.\n      This
      enables a decoder to finish decoding the picture, where it\n      otherwise
      may need to wait for the next packet to explicitly know\n      that the frame
      is complete.\n   Payload type (PT):  The assignment of an RTP payload type for
      this\n      packet format is outside the scope of this document and will not\n
      \     be specified here.\n   Timestamp:  The RTP timestamp indicates the time
      when the frame was\n      sampled.  The granularity of the clock is 90 kHz,
      so a delta of 1\n      represents 1/90,000 of a second.\n      The remaining
      RTP Fixed Header Fields (V, P, X, CC, sequence\n      number, SSRC, and CSRC
      identifiers) are used as specified in\n      Section 5.1 of [RFC3550].\n"
    title: 4.1.  RTP Header Usage
  - contents:
    - "4.2.  VP8 Payload Descriptor\n   The first octets after the RTP header are
      the VP8 payload descriptor,\n   with the following structure.  The single-octet
      version of the\n   PictureID is illustrated to the left (M bit set to 0), while
      the\n   dual-octet version (M bit set to 1) is shown to the right.\n         0
      1 2 3 4 5 6 7                      0 1 2 3 4 5 6 7\n        +-+-+-+-+-+-+-+-+
      \                  +-+-+-+-+-+-+-+-+\n        |X|R|N|S|R| PID | (REQUIRED)        |X|R|N|S|R|
      PID | (REQUIRED)\n        +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n
      \  X:   |I|L|T|K| RSV   | (OPTIONAL)   X:   |I|L|T|K| RSV   | (OPTIONAL)\n        +-+-+-+-+-+-+-+-+
      \                  +-+-+-+-+-+-+-+-+\n   I:   |M| PictureID   | (OPTIONAL)   I:
      \  |M| PictureID   | (OPTIONAL)\n        +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n
      \  L:   |   TL0PICIDX   | (OPTIONAL)        |   PictureID   |\n        +-+-+-+-+-+-+-+-+
      \                  +-+-+-+-+-+-+-+-+\n   T/K: |TID|Y| KEYIDX  | (OPTIONAL)   L:
      \  |   TL0PICIDX   | (OPTIONAL)\n        +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n
      \                                      T/K: |TID|Y| KEYIDX  | (OPTIONAL)\n                                            +-+-+-+-+-+-+-+-+\n
      \                                Figure 2\n   X: Extended control bits present.
      \ When set to 1, the extension octet\n      MUST be provided immediately after
      the mandatory first octet.  If\n      the bit is zero, all optional fields MUST
      be omitted.  Note: this\n      X bit is not to be confused with the X bit in
      the RTP header.\n   R: Bit reserved for future use.  MUST be set to 0 and MUST
      be ignored\n      by the receiver.\n   N: Non-reference frame.  When set to
      1, the frame can be discarded\n      without affecting any other future or past
      frames.  If the\n      reference status of the frame is unknown, this bit SHOULD
      be set\n      to 0 to avoid discarding frames needed for reference.\n         Informative
      note: This document does not describe how to\n         determine if an encoded
      frame is non-reference.  The reference\n         status of an encoded frame
      is preferably provided from the\n         encoder implementation.\n   S: Start
      of VP8 partition.  SHOULD be set to 1 when the first payload\n      octet of
      the RTP packet is the beginning of a new VP8 partition,\n      and MUST NOT
      be 1 otherwise.  The S bit MUST be set to 1 for the\n      first packet of each
      encoded frame.\n   PID:  Partition index.  Denotes to which VP8 partition the
      first\n      payload octet of the packet belongs.  The first VP8 partition\n
      \     (containing modes and motion vectors) MUST be labeled with PID =\n      0.
      \ PID SHOULD be incremented by 1 for each subsequent partition,\n      but it
      MAY be kept at 0 for all packets.  PID cannot be larger\n      than 7.  If more
      than one packet in an encoded frame contains the\n      same PID, the S bit
      MUST NOT be set for any packet other than the\n      first packet with that
      PID.\n   When the X bit is set to 1 in the first octet, the Extended Control\n
      \  Bits field octet MUST be provided as the second octet.  If the X bit\n   is
      0, the Extended Control Bits field octet MUST NOT be present, and\n   no extensions
      (I, L, T, or K) are permitted.\n   I: PictureID present.  When set to 1, the
      PictureID MUST be present\n      after the extension bit field and specified
      as below.  Otherwise,\n      PictureID MUST NOT be present.\n   L: TL0PICIDX
      present.  When set to 1, the TL0PICIDX MUST be present\n      and specified
      as below, and the T bit MUST be set to 1.\n      Otherwise, TL0PICIDX MUST NOT
      be present.\n   T: TID present.  When set to 1, the TID/Y/KEYIDX octet MUST
      be\n      present.  The TID|Y part of the octet MUST be specified as below.\n
      \     If K (below) is set to 1 but T is set to 0, the TID/Y/KEYIDX octet\n      MUST
      be present, but the TID field MUST be ignored.  If neither T\n      nor K is
      set to 1, the TID/Y/KEYIDX octet MUST NOT be present.\n   K: KEYIDX present.
      \ When set to 1, the TID/Y/KEYIDX octet MUST be\n      present.  The KEYIDX
      part of the octet MUST be specified as below.\n      If T (above) is set to
      1 but K is set to 0, the TID/Y/KEYIDX octet\n      MUST be present, but the
      KEYIDX field MUST be ignored.  If neither\n      T nor K is set to 1, the TID/Y/KEYIDX
      octet MUST NOT be present.\n   RSV:  Bits reserved for future use.  MUST be
      set to 0 and MUST be\n      ignored by the receiver.\n   After the extension
      bit field follow the extension data fields that\n   are enabled.\n   The PictureID
      extension:  If the I bit is set to 1, the PictureID\n      extension field MUST
      be present, and it MUST NOT be present\n      otherwise.  The field consists
      of two parts:\n      M: The most significant bit of the first octet is an extension\n
      \        flag.  If M is set, the remainder of the PictureID field MUST\n         contain
      15 bits, else it MUST contain 7 bits.  Note: this M bit\n         is not to
      be confused with the M bit in the RTP header.\n      PictureID:  7 or 15 bits
      (shown left and right, respectively, in\n         Figure 2) not including the
      M bit.  This is a running index of\n         the frames, which MAY start at
      a random value, MUST increase by\n         1 for each subsequent frame, and
      MUST wrap to 0 after reaching\n         the maximum ID (all bits set).  The
      7 or 15 bits of the\n         PictureID go from most significant to least significant,\n
      \        beginning with the first bit after the M bit.  The sender\n         chooses
      a 7- or 15-bit index and sets the M bit accordingly.\n         The receiver
      MUST NOT assume that the number of bits in\n         PictureID stays the same
      through the session.  Having sent a\n         7-bit PictureID with all bits
      set to 1, the sender may either\n         wrap the PictureID to 0 or extend
      to 15 bits and continue\n         incrementing.\n   The TL0PICIDX extension:
      \ If the L bit is set to 1, the TL0PICIDX\n      extension field MUST be present,
      and it MUST NOT be present\n      otherwise.  The field consists of one part:\n
      \     TL0PICIDX:  8 bits temporal level zero index.  TL0PICIDX is a\n         running
      index for the temporal base layer frames, i.e., the\n         frames with TID
      set to 0.  If TID is larger than 0, TL0PICIDX\n         indicates on which base-layer
      frame the current image depends.\n         TL0PICIDX MUST be incremented when
      TID is 0.  The index MAY\n         start at a random value, and it MUST wrap
      to 0 after reaching\n         the maximum number 255.  Use of TL0PICIDX depends
      on the\n         presence of TID.  Therefore, it is RECOMMENDED that the TID
      be\n         used whenever TL0PICIDX is.\n   The TID/Y/KEYIDX extension:  If
      either of the T or K bits are set to\n      1, the TID/Y/KEYIDX extension field
      MUST be present.  It MUST NOT\n      be present if both T and K are zero.  The
      field consists of three\n      parts:\n      TID:  2 bits temporal-layer index.
      \ The TID field MUST be ignored\n         by the receiver when the T bit is
      set equal to 0.  The TID\n         field indicates which temporal layer the
      packet represents.\n         The lowest layer, i.e., the base layer, MUST have
      the TID set\n         to 0.  Higher layers SHOULD increment the TID according
      to\n         their position in the layer hierarchy.\n      Y: 1 layer sync bit.
      \ The Y bit SHOULD be set to 1 if the current\n         frame depends only on
      the base layer (TID = 0) frame with\n         TL0PICIDX equal to that of the
      current frame.  The Y bit MUST\n         be set to 0 if the current frame depends
      on any other frame\n         than the base layer (TID = 0) frame with TL0PICIDX
      equal to\n         that of the current frame.  Additionally, the Y bit MUST
      be set\n         to 0 if any frame following the current frame depends on a
      non-\n         base-layer frame older than the base-layer frame with TL0PICIDX\n
      \        equal to that of the current frame.  If the Y bit is set when\n         the
      T bit is equal to 0, the current frame MUST only depend on\n         a past
      base-layer (TID=0) key frame as signaled by a change in\n         the KEYIDX
      field.  Additionally, this frame MUST NOT depend on\n         any of the three
      codec buffers (as defined by [RFC6386]) that\n         have been updated since
      the last time the KEYIDX field was\n         changed.\n         Informative
      note: This document does not describe how to\n         determine the dependency
      status for a frame; this information\n         is preferably provided from the
      encoder implementation.  In the\n         case of unknown status, the Y bit
      can safely be set to 0.\n      KEYIDX:  5 bits temporal key frame index.  The
      KEYIDX field MUST\n         be ignored by the receiver when the K bit is set
      equal to 0.\n         The KEYIDX field is a running index for key frames.  KEYIDX
      MAY\n         start at a random value, and it MUST wrap to 0 after reaching\n
      \        the maximum number 31.  When in use, the KEYIDX SHOULD be\n         present
      for both key frames and interframes.  The sender MUST\n         increment KEYIDX
      for key frames that convey parameter updates\n         critical to the interpretation
      of subsequent frames, and it\n         SHOULD leave the KEYIDX unchanged for
      key frames that do not\n         contain these critical updates.  If the KEYIDX
      is present, a\n         receiver SHOULD NOT decode an interframe if it has not
      received\n         and decoded a key frame with the same KEYIDX after the last\n
      \        KEYIDX wraparound.\n         Informative note: This document does not
      describe how to\n         determine if a key frame updates critical parameters;
      this\n         information is preferably provided from the encoder\n         implementation.
      \ A sender that does not have this information\n         may either omit the
      KEYIDX field (set K equal to 0) or\n         increment the KEYIDX on every key
      frame.  The benefit with the\n         latter is that any key-frame loss will
      be detected by the\n         receiver, which can signal for re-transmission
      or request a new\n         key frame.\n   Informative note:  Implementations
      doing splicing of VP8 streams will\n      have to make sure the rules for incrementing
      TL0PICIDX and KEYIDX\n      are obeyed across the splice.  This will likely
      require rewriting\n      values of TL0PICIDX and KEYIDX after the splice.\n"
    title: 4.2.  VP8 Payload Descriptor
  - contents:
    - "4.3.  VP8 Payload Header\n   The beginning of an encoded VP8 frame is referred
      to as an\n   \"uncompressed data chunk\" in Section 9.1 of [RFC6386], and it
      also\n   serves as a payload header in this RTP format.  The codec bitstream\n
      \  format specifies two different variants of the uncompressed data\n   chunk:
      a 3-octet version for interframes and a 10-octet version for\n   key frames.
      \ The first 3 octets are common to both variants.  In the\n   case of a key
      frame, the remaining 7 octets are considered to be part\n   of the remaining
      payload in this RTP format.  Note that the header is\n   present only in packets
      that have the S bit equal to one and the PID\n   equal to zero in the payload
      descriptor.  Subsequent packets for the\n   same frame do not carry the payload
      header.\n   The length of the first partition can always be obtained from the\n
      \  first partition-size parameter in the VP8 payload header.  The VP8\n   bitstream
      format [RFC6386] specifies that if multiple DCT/WHT\n   partitions are produced,
      the location of each partition start is\n   found at the end of the first (prediction
      or mode) partition.  In\n   this RTP payload specification, the location offsets
      are considered\n   to be part of the first partition.\n                             0
      1 2 3 4 5 6 7\n                            +-+-+-+-+-+-+-+-+\n                            |Size0|H|
      VER |P|\n                            +-+-+-+-+-+-+-+-+\n                            |
      \    Size1     |\n                            +-+-+-+-+-+-+-+-+\n                            |
      \    Size2     |\n                            +-+-+-+-+-+-+-+-+\n                            |
      Octets 4..N of|\n                            | VP8 payload   |\n                            :
      \              :\n                            +-+-+-+-+-+-+-+-+\n                            |
      OPTIONAL RTP  |\n                            | padding       |\n                            :
      \              :\n                            +-+-+-+-+-+-+-+-+\n                                 Figure
      3\n   A packetizer needs access to the P bit.  The other fields are defined\n
      \  in [RFC6386], Section 9.1, and their meanings do not influence the\n   packetization
      process.  None of these fields are modified by the\n   packetization process.\n
      \  P: Inverse key frame flag.  When set to 0, the current frame is a key\n      frame.
      \ When set to 1, the current frame is an interframe.\n      Defined in [RFC6386]\n"
    title: 4.3.  VP8 Payload Header
  - contents:
    - "4.4.  Aggregated and Fragmented Payloads\n   An encoded VP8 frame can be divided
      into two or more partitions, as\n   described in Section 1.  It is OPTIONAL
      for a packetizer implementing\n   this RTP specification to pay attention to
      the partition boundaries\n   within an encoded frame.  If packetization of a
      frame is done without\n   considering the partition boundaries, the PID field
      MAY be set to 0\n   for all packets and the S bit MUST NOT be set to 1 for any
      other\n   packet than the first.\n   If the preferred usage suggested in Section
      3 is followed, with each\n   packet carrying data from exactly one partition,
      the S bit and PID\n   fields described in Section 4.2 SHOULD be used to indicate
      what the\n   packet contains.  The PID field should indicate to which partition\n
      \  the first octet of the payload belongs and the S bit indicates that\n   the
      packet starts on a new partition.\n   If the packetizer does not pay attention
      to the partition boundaries,\n   one packet can contain a fragment of a partition,
      a complete\n   partition, or an aggregate of fragments and partitions.  There
      is no\n   explicit signaling of partition boundaries in the payload, and the\n
      \  partition lengths at the end of the first partition have to be used\n   to
      identify the boundaries.  Partitions MUST be aggregated in\n   decoding order.
      \ Two fragments from different partitions MAY be\n   aggregated into the same
      packet along with one or more complete\n   partitions.\n   In all cases, the
      payload of a packet MUST contain data from only one\n   video frame.  Consequently,
      the set of packets carrying the data from\n   a particular frame will contain
      exactly one VP8 Payload Header (see\n   Section 4.3) carried in the first packet
      of the frame.  The last, or\n   only, packet carrying data for the frame MUST
      have the M bit set in\n   the RTP header.\n"
    title: 4.4.  Aggregated and Fragmented Payloads
  - contents:
    - '4.5.  Example Algorithms

      '
    - contents:
      - "4.5.1.  Frame Reconstruction Algorithm\n   Example of frame reconstruction
        algorithm.\n   1: Collect all packets with a given RTP timestamp.\n   2: Go
        through packets in order, sorted by sequence numbers, if\n      packets are
        missing, send NACK as defined in [RFC4585] or decode\n      with missing partitions,
        see Section 4.5.2 below.\n   3: A frame is complete if the frame has no missing
        sequence numbers,\n      the first packet in the frame contains S=1 with partId=0
        and the\n      last packet in the frame has the marker bit set.\n"
      title: 4.5.1.  Frame Reconstruction Algorithm
    - contents:
      - "4.5.2.  Partition Reconstruction Algorithm\n   Example of partition reconstruction
        algorithm.  The algorithm only\n   applies for the RECOMMENDED use case with
        partitions in separate\n   packets.\n   1: Scan for the start of a new partition;
        S=1.\n   2: Continue scan to detect end of partition; hence, a new S=1\n      (previous
        packet was the end of the partition) is found or the\n      marker bit is
        set.  If a loss is detected before the end of the\n      partition, abandon
        all packets in this partition and continue the\n      scan repeating from
        step 1.\n   3: Store the packets in the complete partition, continue the scan\n
        \     repeating from step 1 until end of frame is reached.\n   4: Send all
        complete partitions to the decoder.  If no complete\n      partition is found
        discard the whole frame.\n"
      title: 4.5.2.  Partition Reconstruction Algorithm
    title: 4.5.  Example Algorithms
  - contents:
    - "4.6.  Examples of VP8 RTP Stream\n   A few examples of how the VP8 RTP payload
      can be used are included\n   below.\n"
    - contents:
      - "4.6.1.  Key Frame in a Single RTP Packet\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n
        \    |  RTP header   |\n     |  M = 1        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0
        0 0| X = 1; S = 1; PID = 0\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0|
        I = 1\n     +-+-+-+-+-+-+-+-+\n     |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n
        \    |Size0|1| VER |0| P = 0\n     +-+-+-+-+-+-+-+-+\n     |     Size1     |\n
        \    +-+-+-+-+-+-+-+-+\n     |     Size2     |\n     +-+-+-+-+-+-+-+-+\n     |
        VP8 payload   |\n     +-+-+-+-+-+-+-+-+\n"
      title: 4.6.1.  Key Frame in a Single RTP Packet
    - contents:
      - "4.6.2.  Non-discardable VP8 Interframe in a Single RTP Packet; No\n        PictureID\n
        \     0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |
        \ M = 1        |\n     +-+-+-+-+-+-+-+-+\n     |0|0|0|1|0|0 0 0| X = 0; S
        = 1; PID = 0\n     +-+-+-+-+-+-+-+-+\n     |Size0|1| VER |1| P = 1\n     +-+-+-+-+-+-+-+-+\n
        \    |     Size1     |\n     +-+-+-+-+-+-+-+-+\n     |     Size2     |\n     +-+-+-+-+-+-+-+-+\n
        \    | VP8 payload   |\n     +-+-+-+-+-+-+-+-+\n"
      title: 4.6.2.  Non-discardable VP8 Interframe in a Single RTP Packet; No
    - contents:
      - "4.6.3.  VP8 Partitions in Separate RTP Packets\n   First RTP packet; complete
        first partition.\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP
        header   |\n     |  M = 0        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0
        0 0| X = 1; S = 1; PID = 0\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0|
        I = 1\n     +-+-+-+-+-+-+-+-+\n     |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n
        \    |Size0|1| VER |1| P = 1\n     +-+-+-+-+-+-+-+-+\n     |     Size1     |\n
        \    +-+-+-+-+-+-+-+-+\n     |     Size2     |\n     +-+-+-+-+-+-+-+-+\n     |
        Octets 4..L of|\n     | first VP8     |\n     | partition     |\n     :               :\n
        \    +-+-+-+-+-+-+-+-+\n   Second RTP packet; complete second partition.\n
        \     0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |
        \ M = 1        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0 0 1| X = 1; S
        = 1; PID = 1\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0| I = 1\n     +-+-+-+-+-+-+-+-+\n
        \    |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n     | Remaining
        VP8 |\n     | partitions    |\n     :               :\n     +-+-+-+-+-+-+-+-+\n"
      title: 4.6.3.  VP8 Partitions in Separate RTP Packets
    - contents:
      - "4.6.4.  VP8 Frame Fragmented across RTP Packets\n   First RTP packet; complete
        first partition.\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP
        header   |\n     |  M = 0        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0
        0 0| X = 1; S = 1; PID = 0\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0|
        I = 1\n     +-+-+-+-+-+-+-+-+\n     |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n
        \    |Size0|1| VER |1| P = 1\n     +-+-+-+-+-+-+-+-+\n     |     Size1     |\n
        \    +-+-+-+-+-+-+-+-+\n     |     Size2     |\n     +-+-+-+-+-+-+-+-+\n     |
        Complete      |\n     | first         |\n     | partition     |\n     :               :\n
        \    +-+-+-+-+-+-+-+-+\n   Second RTP packet; first fragment of second partition.\n
        \     0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |
        \ M = 0        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0 0 1| X = 1; S
        = 1; PID = 1\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0| I = 1\n     +-+-+-+-+-+-+-+-+\n
        \    |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n     | First
        fragment|\n     | of second     |\n     | partition     |\n     :               :\n
        \    +-+-+-+-+-+-+-+-+\n   Third RTP packet; second fragment of second partition.\n
        \     0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |
        \ M = 0        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0|0 0 1| X = 1; S
        = 0; PID = 1\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0| I = 1\n     +-+-+-+-+-+-+-+-+\n
        \    |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n     | Mid
        fragment  |\n     | of second     |\n     | partition     |\n     :               :\n
        \    +-+-+-+-+-+-+-+-+\n   Fourth RTP packet; last fragment of second partition.\n
        \     0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |
        \ M = 1        |\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0|0 0 1| X = 1; S
        = 0; PID = 1\n     +-+-+-+-+-+-+-+-+\n     |1|0|0|0|0 0 0 0| I = 1\n     +-+-+-+-+-+-+-+-+\n
        \    |0 0 0 1 0 0 0 1| PictureID = 17\n     +-+-+-+-+-+-+-+-+\n     | Last
        fragment |\n     | of second     |\n     | partition     |\n     :               :\n
        \    +-+-+-+-+-+-+-+-+\n"
      title: 4.6.4.  VP8 Frame Fragmented across RTP Packets
    - contents:
      - "4.6.5.  VP8 Frame with Long PictureID\n   PictureID = 4711 = 001001001100111
        binary (first 7 bits: 0010010,\n   last 8 bits: 01100111).\n      0 1 2 3
        4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  RTP header   |\n     |  M = 1        |\n
        \    +-+-+-+-+-+-+-+-+\n     |1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n     +-+-+-+-+-+-+-+-+\n
        \    |1|0|0|0|0 0 0 0| I = 1;\n     +-+-+-+-+-+-+-+-+\n     |1 0 0 1 0 0 1
        0| Long PictureID flag = 1\n     |0 1 1 0 0 1 1 1| PictureID = 4711\n     +-+-+-+-+-+-+-+-+\n
        \    |Size0|1| VER |1|\n     +-+-+-+-+-+-+-+-+\n     |     Size1     |\n     +-+-+-+-+-+-+-+-+\n
        \    |     Size2     |\n     +-+-+-+-+-+-+-+-+\n     | Octets 4..N of|\n     |
        VP8 payload   |\n     :               :\n     +-+-+-+-+-+-+-+-+\n"
      title: 4.6.5.  VP8 Frame with Long PictureID
    title: 4.6.  Examples of VP8 RTP Stream
  title: 4.  Payload Format
- contents:
  - "5.  Using VP8 with RPSI and SLI Feedback\n   The VP8 payload descriptor defined
    in Section 4.2 contains an\n   optional PictureID parameter.  This parameter is
    included mainly to\n   enable use of reference picture selection indication (RPSI)
    and slice\n   loss indication (SLI), both defined in [RFC4585].\n"
  - contents:
    - "5.1.  RPSI\n   The RPSI is a payload-specific feedback message defined within
      the\n   RTCP-based feedback format.  The RPSI message is generated by a\n   receiver
      and can be used in two ways.  Either it can signal a\n   preferred reference
      picture when a loss has been detected by the\n   decoder -- preferably then
      a reference that the decoder knows is\n   perfect -- or it can be used as positive
      feedback information to\n   acknowledge correct decoding of certain reference
      pictures.  The\n   positive-feedback method is useful for VP8 used for point-to-point\n
      \  (unicast) communication.  The use of RPSI for VP8 is preferably\n   combined
      with a special update pattern of the codec's two special\n   reference frames
      -- the golden frame and the altref frame -- in which\n   they are updated in
      an alternating leapfrog fashion.  When a receiver\n   has received and correctly
      decoded a golden or altref frame, and that\n   frame has a PictureID in the
      payload descriptor, the receiver can\n   acknowledge this simply by sending
      an RPSI message back to the\n   sender.  The message body (i.e., the \"native
      RPSI bit string\" in\n   [RFC4585]) is simply the PictureID of the received
      frame.\n"
    title: 5.1.  RPSI
  - contents:
    - "5.2.  SLI\n   The SLI is another payload-specific feedback message defined
      within\n   the RTCP-based feedback format.  The SLI message is generated by
      the\n   receiver when a loss or corruption is detected in a frame.  The\n   format
      of the SLI message is as follows [RFC4585]:\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         First           |        Number           | PictureID |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                                Figure 4\n   Here, First is the macroblock
      address (in scan order) of the first\n   lost block and Number is the number
      of lost blocks, as defined in\n   [RFC4585].  PictureID is the six least significant
      bits of the codec-\n   specific picture identifier in which the loss or corruption
      has\n   occurred.  For VP8, this codec-specific identifier is naturally the\n
      \  PictureID of the current frame, as read from the payload descriptor.\n   If
      the payload descriptor of the current frame does not have a\n   PictureID, the
      receiver MAY send the last received PictureID+1 in the\n   SLI message.  The
      receiver MAY set the First parameter to 0, and the\n   Number parameter to the
      total number of macroblocks per frame, even\n   though only part of the frame
      is corrupted.  When the sender receives\n   an SLI message, it can make use
      of the knowledge from the latest\n   received RPSI message.  Knowing that the
      last golden or altref frame\n   was successfully received, it can encode the
      next frame with\n   reference to that established reference.\n"
    title: 5.2.  SLI
  - contents:
    - "5.3.  Example\n   The use of RPSI and SLI is best illustrated in an example.
      \ In this\n   example, the encoder may not update the altref frame until the
      last\n   sent golden frame has been acknowledged with an RPSI message.  If an\n
      \  update is not received within some time, a new golden frame update is\n   sent
      instead.  Once the new golden frame is established and\n   acknowledged, the
      same rule applies when updating the altref frame.\n   +-------+-------------------+-------------------------+-------------+\n
      \  | Event | Sender            | Receiver                | Established |\n   |
      \      |                   |                         | reference   |\n   +-------+-------------------+-------------------------+-------------+\n
      \  | 1000  | Send golden frame |                         |             |\n   |
      \      | PictureID = 0     |                         |             |\n   |       |
      \                  |                         |             |\n   |       |                   |
      Receive and decode      |             |\n   |       |                   | golden
      frame            |             |\n   |       |                   |                         |
      \            |\n   | 1001  |                   | Send RPSI(0)            |             |\n
      \  |       |                   |                         |             |\n   |
      1002  | Receive RPSI(0)   |                         | golden      |\n   |       |
      \                  |                         |             |\n   | ...   | (sending
      regular  |                         |             |\n   |       | frames)           |
      \                        |             |\n   |       |                   |                         |
      \            |\n   | 1100  | Send altref frame |                         |             |\n
      \  |       | PictureID = 100   |                         |             |\n   |
      \      |                   |                         |             |\n   |       |
      \                  | Altref corrupted or     | golden      |\n   |       |                   |
      lost                    |             |\n   |       |                   |                         |
      \            |\n   | 1101  |                   | Send SLI(100)           | golden
      \     |\n   |       |                   |                         |             |\n
      \  | 1102  | Receive SLI(100)  |                         |             |\n   |
      \      |                   |                         |             |\n   | 1103
      \ | Send frame with   |                         |             |\n   |       |
      reference to      |                         |             |\n   |       | golden
      \           |                         |             |\n   |       |                   |
      \                        |             |\n   |       |                   | Receive
      and decode      | golden      |\n   |       |                   | frame (decoder
      state    |             |\n   |       |                   | restored)               |
      \            |\n   |       |                   |                         |             |\n
      \  | ...   | (sending regular  |                         |             |\n   |
      \      | frames)           |                         |             |\n   |       |
      \                  |                         |             |\n   | 1200  | Send
      altref frame |                         |             |\n   |       | PictureID
      = 200   |                         |             |\n   |       |                   |
      \                        |             |\n   |       |                   | Receive
      and decode      | golden      |\n   |       |                   | altref frame
      \           |             |\n   |       |                   |                         |
      \            |\n   | 1201  |                   | Send RPSI(200)          |             |\n
      \  |       |                   |                         |             |\n   |
      1202  | Receive RPSI(200) |                         | altref      |\n   |       |
      \                  |                         |             |\n   | ...   | (sending
      regular  |                         |             |\n   |       | frames)           |
      \                        |             |\n   |       |                   |                         |
      \            |\n   | 1300  | Send golden frame |                         |             |\n
      \  |       | PictureID = 300   |                         |             |\n   |
      \      |                   |                         |             |\n   |       |
      \                  | Receive and decode      | altref      |\n   |       |                   |
      golden frame            |             |\n   |       |                   |                         |
      \            |\n   | 1301  |                   | Send RPSI(300)          | altref
      \     |\n   |       |                   |                         |             |\n
      \  | 1302  | RPSI lost         |                         |             |\n   |
      \      |                   |                         |             |\n   | 1400
      \ | Send golden frame |                         |             |\n   |       |
      PictureID = 400   |                         |             |\n   |       |                   |
      \                        |             |\n   |       |                   | Receive
      and decode      | altref      |\n   |       |                   | golden frame
      \           |             |\n   |       |                   |                         |
      \            |\n   | 1401  |                   | Send RPSI(400)          |             |\n
      \  |       |                   |                         |             |\n   |
      1402  | Receive RPSI(400) |                         | golden      |\n   +-------+-------------------+-------------------------+-------------+\n
      \         Table 1: Example Signaling between Sender and Receiver\n   Note that
      the scheme is robust to loss of the feedback messages.  If\n   the RPSI is lost,
      the sender will try to update the golden (or\n   altref) again after a while,
      without releasing the established\n   reference.  Also, if an SLI is lost, the
      receiver can keep sending\n   SLI messages at any interval allowed by the RTCP
      sending timing\n   restrictions as specified in [RFC4585], as long as the picture
      is\n   corrupted.\n"
    title: 5.3.  Example
  title: 5.  Using VP8 with RPSI and SLI Feedback
- contents:
  - "6.  Payload Format Parameters\n   This payload format has two optional parameters.\n"
  - contents:
    - "6.1.  Media Type Definition\n   This registration is done using the template
      defined in [RFC6838] and\n   following [RFC4855].\n   Type name:  video\n   Subtype
      name:  VP8\n   Required parameters:  None.\n   Optional parameters:\n      These
      parameters are used to signal the capabilities of a receiver\n      implementation.
      \ If the implementation is willing to receive\n      media, both parameters
      MUST be provided.  These parameters MUST\n      NOT be used for any other purpose.\n
      \     max-fr:  The value of max-fr is an integer indicating the maximum\n         frame
      rate in units of frames per second that the decoder is\n         capable of
      decoding.\n      max-fs:  The value of max-fs is an integer indicating the maximum\n
      \        frame size in units of macroblocks that the decoder is capable\n         of
      decoding.\n         The decoder is capable of decoding this frame size as long
      as\n         the width and height of the frame in macroblocks are less than\n
      \        int(sqrt(max-fs * 8)).  For instance, a max-fs of 1200 (capable\n         of
      supporting 640x480 resolution) will support widths and\n         heights up
      to 1552 pixels (97 macroblocks).\n   Encoding considerations:\n      This media
      type is framed in RTP and contains binary data; see\n      Section 4.8 of [RFC6838].\n
      \  Security considerations:  See Section 7 of RFC 7741.\n   Interoperability
      considerations:  None.\n   Published specification:  VP8 bitstream format [RFC6386]
      and RFC\n      7741.\n   Applications that use this media type:\n      For example:
      Video over IP, video conferencing.\n   Fragment identifier considerations:  N/A.\n
      \  Additional information:  None.\n   Person & email address to contact for
      further information:\n      Patrik Westin, patrik.westin@gmail.com\n   Intended
      usage:  COMMON\n   Restrictions on usage:\n      This media type depends on
      RTP framing, and hence it is only\n      defined for transfer via RTP [RFC3550].\n
      \  Author:  Patrik Westin, patrik.westin@gmail.com\n   Change controller:\n
      \     IETF Payload Working Group delegated from the IESG.\n"
    title: 6.1.  Media Type Definition
  - contents:
    - "6.2.  SDP Parameters\n   The receiver MUST ignore any fmtp parameter unspecified
      in this memo.\n"
    - contents:
      - "6.2.1.  Mapping of Media Subtype Parameters to SDP\n   The media type video/VP8
        string is mapped to fields in the Session\n   Description Protocol (SDP) [RFC4566]
        as follows:\n   o  The media name in the \"m=\" line of SDP MUST be video.\n
        \  o  The encoding name in the \"a=rtpmap\" line of SDP MUST be VP8 (the\n
        \     media subtype).\n   o  The clock rate in the \"a=rtpmap\" line MUST
        be 90000.\n   o  The parameters \"max-fs\" and \"max-fr\" MUST be included
        in the\n      \"a=fmtp\" line if the SDP is used to declare receiver capabilities.\n
        \     These parameters are expressed as a media subtype string, in the\n      form
        of a semicolon-separated list of parameter=value pairs.\n"
      - contents:
        - "6.2.1.1.  Example\n   An example of media representation in SDP is as follows:\n
          \  m=video 49170 RTP/AVPF 98\n   a=rtpmap:98 VP8/90000\n   a=fmtp:98 max-fr=30;
          max-fs=3600;\n"
        title: 6.2.1.1.  Example
      title: 6.2.1.  Mapping of Media Subtype Parameters to SDP
    - contents:
      - "6.2.2.  Offer/Answer Considerations\n   The VP8 codec offers a decode complexity
        that is roughly linear with\n   the number of pixels encoded.  The parameters
        \"max-fr\" and \"max-fs\"\n   are defined in Section 6.1, where the macroblock
        size is 16x16 pixels\n   as defined in [RFC6386], the max-fs and max-fr parameters
        MUST be\n   used to establish these limits.\n"
      title: 6.2.2.  Offer/Answer Considerations
    title: 6.2.  SDP Parameters
  title: 6.  Payload Format Parameters
- contents:
  - "7.  Security Considerations\n   RTP packets using the payload format defined
    in this specification\n   are subject to the security considerations discussed
    in the RTP\n   specification [RFC3550], and in any applicable RTP profile such
    as\n   RTP/AVP [RFC3551], RTP/AVPF [RFC4585], RTP/SAVP [RFC3711], or RTP/\n   SAVPF
    [RFC5124].  However, as \"Securing the RTP Protocol Framework:\n   Why RTP Does
    Not Mandate a Single Media Security Solution\" [RFC7202]\n   discusses, it is
    not an RTP payload format's responsibility to\n   discuss or mandate what solutions
    are used to meet the basic security\n   goals like confidentiality, integrity,
    and source authenticity for\n   RTP in general.  This responsibility lays on anyone
    using RTP in an\n   application.  They can find guidance on available security
    mechanisms\n   and important considerations in \"Options for Securing RTP Sessions\"\n
    \  [RFC7201].  Applications SHOULD use one or more appropriate strong\n   security
    mechanisms.  The rest of this security consideration section\n   discusses the
    security impacting properties of the payload format\n   itself.\n   This RTP payload
    format and its media decoder do not exhibit any\n   significant difference in
    the receiver-side computational complexity\n   for packet processing and, thus,
    are unlikely to pose a denial-of-\n   service threat due to the receipt of pathological
    data.  Nor does the\n   RTP payload format contain any active content.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Congestion Control\n   Congestion control for RTP SHALL be used in accordance
    with RFC 3550\n   [RFC3550] and with any applicable RTP profile; e.g., RFC 3551\n
    \  [RFC3551].  The congestion control mechanism can, in a real-time\n   encoding
    scenario, adapt the transmission rate by instructing the\n   encoder to encode
    at a certain target rate.  Media-aware network\n   elements MAY use the information
    in the VP8 payload descriptor in\n   Section 4.2 to identify non-reference frames
    and discard them in\n   order to reduce network congestion.  Note that discarding
    of non-\n   reference frames cannot be done if the stream is encrypted (because\n
    \  the non-reference marker is encrypted).\n"
  title: 8.  Congestion Control
- contents:
  - "9.  IANA Considerations\n   The IANA has registered a media type as described
    in Section 6.1.\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.\n              Jacobson,
      \"RTP: A Transport Protocol for Real-Time\n              Applications\", STD
      64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <http://www.rfc-editor.org/info/rfc3550>.\n
      \  [RFC3551]  Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and\n              Video
      Conferences with Minimal Control\", STD 65, RFC 3551,\n              DOI 10.17487/RFC3551,
      July 2003,\n              <http://www.rfc-editor.org/info/rfc3551>.\n   [RFC4566]
      \ Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n              Description
      Protocol\", RFC 4566, DOI 10.17487/RFC4566,\n              July 2006, <http://www.rfc-editor.org/info/rfc4566>.\n
      \  [RFC4585]  Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey,\n              \"Extended
      RTP Profile for Real-time Transport Control\n              Protocol (RTCP)-Based
      Feedback (RTP/AVPF)\", RFC 4585,\n              DOI 10.17487/RFC4585, July 2006,\n
      \             <http://www.rfc-editor.org/info/rfc4585>.\n   [RFC4855]  Casner,
      S., \"Media Type Registration of RTP Payload\n              Formats\", RFC 4855,
      DOI 10.17487/RFC4855, February 2007,\n              <http://www.rfc-editor.org/info/rfc4855>.\n
      \  [RFC6386]  Bankoski, J., Koleszar, J., Quillio, L., Salonen, J.,\n              Wilkins,
      P., and Y. Xu, \"VP8 Data Format and Decoding\n              Guide\", RFC 6386,
      DOI 10.17487/RFC6386, November 2011,\n              <http://www.rfc-editor.org/info/rfc6386>.\n
      \  [RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n              Specifications
      and Registration Procedures\", BCP 13,\n              RFC 6838, DOI 10.17487/RFC6838,
      January 2013,\n              <http://www.rfc-editor.org/info/rfc6838>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC3711]  Baugher, M., McGrew, D., Naslund,
      M., Carrara, E., and K.\n              Norrman, \"The Secure Real-time Transport
      Protocol (SRTP)\",\n              RFC 3711, DOI 10.17487/RFC3711, March 2004,\n
      \             <http://www.rfc-editor.org/info/rfc3711>.\n   [RFC5124]  Ott,
      J. and E. Carrara, \"Extended Secure RTP Profile for\n              Real-time
      Transport Control Protocol (RTCP)-Based Feedback\n              (RTP/SAVPF)\",
      RFC 5124, DOI 10.17487/RFC5124, February\n              2008, <http://www.rfc-editor.org/info/rfc5124>.\n
      \  [RFC7201]  Westerlund, M. and C. Perkins, \"Options for Securing RTP\n              Sessions\",
      RFC 7201, DOI 10.17487/RFC7201, April 2014,\n              <http://www.rfc-editor.org/info/rfc7201>.\n
      \  [RFC7202]  Perkins, C. and M. Westerlund, \"Securing the RTP\n              Framework:
      Why RTP Does Not Mandate a Single Media\n              Security Solution\",
      RFC 7202, DOI 10.17487/RFC7202, April\n              2014, <http://www.rfc-editor.org/info/rfc7202>.\n
      \  [Sch07]    Schwarz, H., Marpe, D., and T. Wiegand, \"Overview of the\n              Scalable
      Video Coding Extension of the H.264/AVC\n              Standard\", IEEE Transactions
      on Circuits and Systems for\n              Video Technology, Volume 17: Issue
      9,\n              DOI 10.1109/TCSVT.2007.905532, September 2007,\n              <http://dx.doi.org/10.1109/TCSVT.2007.905532>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Authors' Addresses\n   Patrik Westin\n   Google, Inc.\n   1600 Amphitheatre Parkway\n
    \  Mountain View, CA  94043\n   United States\n   Email: patrik.westin@gmail.com\n
    \  Henrik F Lundin\n   Google, Inc.\n   Kungsbron 2\n   Stockholm  11122\n   Sweden\n
    \  Email: hlundin@google.com\n   Michael Glover\n   Twitter Boston\n   10 Hemlock
    Way\n   Durham, NH  03824\n   United States\n   Email: michaelglover262@gmail.com\n
    \  Justin Uberti\n   Google, Inc.\n   747 6th Street South\n   Kirkland, WA  98033\n
    \  United States\n   Email: justin@uberti.name\n   Frank Galligan\n   Google,
    Inc.\n   1600 Amphitheatre Parkway\n   Mountain View, CA  94043\n   United States\n
    \  Email: fgalligan@google.com\n"
  title: Authors' Addresses
