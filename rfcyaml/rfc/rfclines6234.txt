Abstract The United States of America has adopted a suite of Secure Hash Algorithms (SHAs), including four beyond SHA 1, as part of a Federal Information Processing Standard (FIPS), namely SHA 224, SHA 256, SHA 384, and SHA 512.
This document makes open source code performing these SHA hash functions conveniently available to the Internet community.
The sample code supports input strings of arbitrary bit length.
Much of the text herein was adapted by the authors from FIPS 180 2.
This document replaces RFC 4634, fixing errata and adding code for an HMAC based extract and expand Key Derivation Function, HKDF (RFC 5869).
As with RFC 4634, code to perform SHA based Hashed Message Authentication Codes (HMACs) is also included.
This document includes specifications for the United States of America (USA) Federal Information Processing Standard (FIPS)
Secure Hash Algorithms (SHAs), code to implement the SHAs, code to implement HMAC (Hashed Message Authentication Code, [RFC2104])
based on the SHAs, and code to implement HKDF (HMAC based Key Derivation Function, [RFC5869]) based on HMAC.
Specifications for HMAC and HKDF are not included as they appear elsewhere in the RFC series [RFC2104]
Much of the text below is taken from [SHS], and the assertions of the security of the hash algorithms described therein are made by the US Government, the author of [SHS], not by the listed authors of this document.
See also [RFC6194] concerning the security of SHA 1.
The text below specifies Secure Hash Algorithms, SHA 224 [RFC3874], SHA 256, SHA 384, and SHA 512, for computing a condensed representation of a message or a data file.
(SHA 1 is specified in [RFC3174].)
When a message of any length < 2^64 bits (for SHA 224 and SHA 256) or < 2^128 bits (for SHA 384 and SHA 512) is input to one of these algorithms, the result is an output called a message digest.
The message digests range in length from 224 to 512 bits, depending on the algorithm.
Secure Hash Algorithms are typically used with other cryptographic algorithms, such as digital signature algorithms and keyed hash authentication codes, the generation of random numbers [RFC4086], or in key derivation functions.
The algorithms specified in this document are called secure because it is computationally infeasible to (1) find a message that corresponds to a given message digest, or (2) find two different messages that produce the same message digest.
Any change to a message in transit will, with very high probability, result in a different message digest.
This will result in a verification failure when the Secure Hash Algorithm is used with a digital signature algorithm or a keyed hash message authentication algorithm.
The code provided herein supports input strings of arbitrary bit length.
SHA 1's sample code from [RFC3174] has also been updated to handle input strings of arbitrary bit length.
Permission is granted for all uses, commercial and non commercial, of this code.
This document obsoletes [RFC4634], and the changes from that RFC are summarized in the Appendix.
ASN.1 OIDs (Object Identifiers) for the SHA algorithms, taken from [RFC4055], are as follows:
3 } Section 2 below defines the terminology and functions used as building blocks to form these algorithms.
Section 3 describes the fundamental operations on words from which these algorithms are built.
Section 4 describes how messages are padded up to an integral multiple of the required block size and then parsed into blocks.
Section 5 defines the constants and the composite functions used to specify the hash algorithms.
Section 6 gives the actual specification for the SHA 224, SHA 256, SHA 384, and SHA 512 functions.
Section 7 provides pointers to the specification of HMAC keyed message authentication codes and to the specification of an extract and expand key derivation function based on HMAC.
Section 8 gives sample code for the SHA algorithms, for SHA based HMACs, and for HMAC based extract and expand key derivation function.
Notation for Bit Strings and Integers
The following terminology related to bit strings and integers will be used:
A hex digit is the representation of a 4 bit string.
A word equals a 32 bit or 64 bit string that may be represented as a sequence of 8 or 16 hex digits, respectively.
To convert a word to hex digits, each 4 bit string is converted to its hex equivalent as described in (a) above.
1111 1110 0010 0011   A103FE23.
Throughout this document, the "big endian" convention is used when expressing both 32 bit and 64 bit words, so that within each word the most significant bit is shown in the leftmost bit position.
An integer may be represented as a word or pair of words.
An integer between 0 and 2^32 1 inclusive may be represented as a 32 bit word.
The least significant four bits of the integer are represented by the rightmost hex digit of the word representation.
32 2 1 is represented by the hex word 00000123.
The same holds true for an integer between 0 and 2^64 1 inclusive, which may be represented as a 64 bit word.
If Z is an integer, 0 <  z < 2^64, then z   (2^32)x
x < 2^32 and 0
and y can be represented as words X and Y, respectively, z can be represented as the pair of words (X,Y).
Again, the "big endian" convention is used and the most significant word is in the leftmost word position for values represented by multiple words.
512 bit or 1024 bit string.
A block (e.g., B) may be represented as a sequence of 32 bit or 64 bit words.
The following logical operators will be applied to words in all four hash operations specified herein.
SHA 224 and SHA 256 operate on 32 bit words while SHA 384 and SHA 512 operate on 64 bit words.
In the operations below, x<<n is obtained as follows: discard the leftmost n bits of
and then pad the result with n zeroed bits on the right
(the result will still be the same number of bits).
Similarly, x>>n is obtained as follows:
discard the rightmost n bits of x and then prepend the result with n zeroed bits on the left
(the result will still be the same number of bits).
bitwise logical "exclusive or" of X and Y. NOT
Y is defined as follows:
words X and Y represent w bit integers
and y, where 0 <  x < 2^w and
0 <  y < 2^w.
For positive integers n and m, let n mod m be the remainder upon dividing n by m.
Then 0 <  z < 2^w.
Convert z to a word, Z, and define Z
The right shift operation SHR^n(x), where x is a w bit word and n is an integer with 0 <  n < w, is defined by SHR^n(x)
The rotate right (circular right shift) operation ROTR^n(x), where x is a w bit word and n is an integer with 0 <  n < w, is defined by ROTR^n(x)
The rotate left (circular left shift) operation ROTL^n(x), where x is a w bit word and n is an integer with 0 <  n < w, is defined by ROTL^n(X)
Note the following equivalence relationships, where w is fixed in each relationship:
The hash functions specified herein are used to compute a message digest for a message or data file that is provided as input.
The message or data file should be considered to be a bit string.
The length of the message is the number of bits in the message (the empty message has length 0).
If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex.
The purpose of message padding is to make the total length of a padded message a multiple of 512 for SHA 224 and SHA 256 or a multiple of 1024 for SHA 384 and SHA 512.
The following specifies how this padding shall be performed.
As a summary, a "1" followed by m "0"s followed by a 64 bit or 128 bit integer are appended to the end of the message to produce a padded message of length 512 n or 1024 n.
The appended integer is the length of the original message.
The padded message is then processed by the hash function as n 512 bit or 1024 bit blocks.
SHA 224 and SHA 256 Suppose a message has length L < 2^64.
Before it is input to the hash function, the message is padded on the right as follows:
Example: if the original message is "01010000", this is padded to "010100001".
b. K "0"s are appended where K is the smallest, non negative solution to the equation
( L   1   K ) mod 512
Then append the 64 bit block that is L in binary representation.
After appending this block, the length of the message will be a multiple of 512 bits.
Example: Suppose the original message is the bit string 01100001 01100010 01100011 01100100 01100101
this gives 01100001 01100010 01100011 01100100 01100101 1
Since L   40, the number of bits in the above is 41 and K   407 "0"s
are appended, making the total now 448.
This gives the following in hex:
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
The 64 bit representation of L   40 is hex 00000000 00000028.
Hence the final padded message is the following hex 61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028 4.2.
SHA 384 and SHA 512 Suppose a message has length L < 2^128.
Before it is input to the hash function, the message is padded on the right as follows:
Example: if the original message is "01010000", this is padded to "010100001".
b. K "0"s are appended where K is the smallest, non negative solution to the equation
( L   1   K ) mod 1024
Then append the 128 bit block that is L in binary representation.
After appending this block, the length of the message will be a multiple of 1024 bits.
Example: Suppose the original message is the bit string 01100001 01100010 01100011 01100100 01100101
this gives 01100001 01100010 01100011 01100100 01100101 1
Since L   40, the number of bits in the above is 41 and K   855 "0"s
are appended, making the total now 896.
This gives the following in hex:
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
The 128 bit representation of L   40 is hex 00000000 00000000 00000000 00000028.
Hence the final padded message is the following hex:
Functions and Constants Used The following subsections give the six logical functions and the table of constants used in each of the hash functions.
SHA 224 and SHA 256 SHA 224 and SHA 256 use six logical functions, where each function operates on 32 bit words, which are represented as x, y, and z.
The result of each function is a new 32 bit word.
(x AND y) XOR ( (NOT x) AND z)
z) XOR (y AND z) BSIG0(x)
These words represent the first 32 bits of the fractional parts of the cube roots of the first sixty  four prime numbers.
In hex, these constant words are as follows (from left to right):
748f82ee 78a5636f 84c87814 8cc70208 90befffa
SHA 384 and SHA 512 SHA 384 and SHA 512
each use six logical functions, where each function operates on 64 bit words, which are represented as x, y, and z.
The result of each function is a new 64 bit word.
(x AND y) XOR ( (NOT x) AND z)
z) XOR (y AND z) BSIG0(x)
These words represent the first 64 bits of the fractional parts of the cube roots of the first eighty prime numbers.
In hex, these constant words are as follows (from left to right):
c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275
27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de
The output of each of the secure hash functions, after being applied to a message of N blocks, is the hash quantity H(N).
For SHA 224 and SHA 256
As described below, the hash words are initialized, modified as each message block is processed, and finally concatenated after processing the last block to yield the output.
For SHA 256 and SHA 512, all of the H(N) variables are concatenated while the SHA 224 and SHA 384 hashes are produced by omitting some from the final concatenation.
SHA 224 and SHA 256 Initialization
For SHA 224, the initial hash value, H(0), consists of the following 32 bit words in hex:
For SHA 256, the initial hash value, H(0), consists of the following eight 32 bit words, in hex.
These words were obtained by taking the first 32 bits of the fractional parts of the square roots of the first eight prime numbers.
SHA 224 and SHA 256 Processing SHA 224 and SHA 256 perform identical processing on message blocks and differ only in how H(0)
is initialized and how they produce their final output.
They may be used to hash a message, M, having a length of L bits, where 0 <  L < 2^64.
a message schedule of sixty four 32 bit words,
(2) eight working variables of 32 bits each, and (3) a hash value of eight 32 bit words.
The eight working variables are labeled a, b, c, d, e, f, g, and h.
They also use two temporary words, T1 and T2.
The following computations are then performed for each of the N message blocks.
All addition is performed modulo 2^32.
For i   1 to N 1.
Prepare the message schedule W:
For t   0 to 15
For t   16 to 63 Wt   SSIG1(W(t 2))
Initialize the working variables: a   H(i 1)0 b   H(i
Perform the main hash computation:
For t   0 to 63 T1
b b   a a   T1   T2 4.
Compute the intermediate hash value H(i)
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated.
For SHA 256, this is the concatenation of all of H(N)0, H(N)1, through H(N)7.
For SHA 224, this is the concatenation of H(N)0, H(N)1, through H(N)6.
SHA 384 and SHA 512 Initialization
For SHA 384, the initial hash value, H(0), consists of the following eight 64 bit words, in hex.
These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the ninth through sixteenth prime numbers.
For SHA 512, the initial hash value, H(0), consists of the following eight 64 bit words, in hex.
These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the first eight prime numbers.
SHA 384 and SHA 512
Processing SHA 384 and SHA 512 perform identical processing on message blocks and differ only in how H(0)
is initialized and how they produce their final output.
They may be used to hash a message, M, having a length of L bits, where 0 <  L < 2^128.
a message schedule of eighty 64 bit words,
(2) eight working variables of 64 bits each, and (3) a hash value of eight 64 bit words.
The eight working variables are labeled a, b, c, d, e, f, g, and h.
The following computations are then performed for each of the N message blocks.
All addition is performed modulo 2^64.
For i   1 to N 1.
Prepare the message schedule W:
For t   0 to 15
For t   16 to 79
Initialize the working variables: a   H(i 1)0 b   H(i
Perform the main hash computation:
For t   0 to 79 T1
b b   a a   T1   T2 4.
Compute the intermediate hash value H(i)
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated.
For SHA 512, this is the concatenation of all of H(N)0, H(N)1, through H(N)7.
For SHA 384, this is the concatenation of H(N)0, H(N)1, through H(N)5.
HKDF  and SHA Based HMACs
Below are brief descriptions and pointers to more complete descriptions and code for (1) SHA based HMACs and (2) an HMAC based extract and expand key derivation function.
Both HKDF and HMAC were devised by Hugo Krawczyk.
SHA Based HMACs HMAC is a method for computing a keyed MAC (Message Authentication Code) using a hash function as described in [RFC2104].
It uses a key to mix in with the input text to produce the final hash.
Sample code is also provided, in Section 8.3 below, to perform HMAC based on any of the SHA algorithms described herein.
The sample code found in [RFC2104] was written in terms of a specified text size.
Since SHA is defined in terms of an arbitrary number of bits, the sample HMAC code has been written to allow the text input to HMAC to have an arbitrary number of octets and bits.
A fixed length interface is also provided.
HKDF HKDF is a specific Key Derivation Function (KDF), that is, a function of initial keying material from which the KDF derives one or more cryptographically strong secret keys.
HKDF, which is described in [RFC5869], is based on HMAC.
Sample code for HKDF is provided in Section 8.4 below.
C Code for SHAs, HMAC, and HKDF Below is a demonstration implementation of these secure hash functions in C.  Section 8.1 contains the header file sha.h that declares all constants, structures, and functions used by the SHA and HMAC functions.
It includes conditionals based on the state of definition of USE 32BIT ONLY that, if that symbol is defined at compile time, avoids 64 bit operations.
It also contains sha  private.h that provides some declarations common to all the SHA functions.
Section 8.2 contains the C code for sha1.c, sha224 256.c, sha384 512.c, and usha.c.
Section 8.3 contains the C code for the HMAC functions, and Section 8.4 contains the C code for HKDF.
Section 8.5 contains a test driver to exercise the code.
when presented with a null pointer parameter shaInputTooLong(2)  when the input data is too long shaStateError(3)
when SHA$$$Input is called after SHA$$$FinalBits or SHA$$$Result
Structure: typedef SHA$$$Context an opaque structure holding the complete state for producing the hash Functions:
; Reset the hash context state.
t  octets, unsigned int bytecount); Incorporate bytecount octets into the hash.
, const uint8 t octet, unsigned int bitcount); Incorporate bitcount bits into the hash.
The bits are in the upper portion of the octet.
SHA$$$Input() cannot be called after this.
SHA$$$Result(SHA$$$Context  , uint8 t Message Digest[SHA$$$HashSize]); Do the final calculations on the hash and copy the value into Message Digest.
They add the following constants, structure, and functions:
typedef USHAContext an opaque structure holding the complete state for producing the hash Functions: int USHAReset(USHAContext
context, SHAversion whichSha); Reset the hash context state.
int USHAInput(USHAContext context , const uint8 t  bytes, unsigned int bytecount); Incorporate bytecount octets into the hash.
context, const uint8 t bits, unsigned int bitcount); Incorporate bitcount bits into the hash.
context, uint8 t Message Digest[USHAMaxHashSize])
; Do the final calculations on the hash and copy the value into Message Digest.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
; The number of octets in the given hash.
; The number of bits in the given hash.
USHABlockSize(enum SHAversion whichSha); The internal block size for the given hash.
; This function will return the name of the given SHA algorithm as a string.
The HMAC functions follow the same pattern to allow any length of text input to be used.
typedef HMACContext an opaque structure holding the complete state for producing the keyed message digest (MAC) Functions: int hmacReset(HMACContext  ctx, enum SHAversion whichSha, const unsigned char
key, int key len); Reset the MAC context state.
hmacInput(HMACContext  ctx, const unsigned char  text, int text len)
; Incorporate text len octets into the MAC.
ctx, const uint8 t bits, unsigned int bitcount); Incorporate bitcount bits into the MAC.
ctx, uint8 t Message Digest[USHAMaxHashSize]); Do the final calculations on the MAC and copy the value into Message Digest.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
In addition, a combined interface is provided, similar to that shown in [RFC2104], that allows a fixed length text input to be used.
int hmac(SHAversion whichSha, const unsigned char
text, int text len, const unsigned char
key, int key len, uint8 t Message Digest[USHAMaxHashSize]); Calculate the given digest for the given text and key, and return the resulting MAC.
Octets in Message Digest beyond USHAHashSize(whichSha) are left untouched.
The HKDF functions follow the same pattern to allow any length of text input to be used.
typedef HKDFContext an opaque structure holding the complete state for producing the keying material Functions: int
, enum SHAversion whichSha, const unsigned char  salt, int salt len) Reset the key derivation state and initialize it with the salt len octets of the optional salt.
hkdfInput(HKDFContext  context, const unsigned char  ikm, int ikm len)
Incorporate ikm len octets into the entropy extractor.
uint8 t ikm bits, unsigned int ikm bit count)
Incorporate ikm bit count bits into the entropy extractor.
Finish the HKDF extraction and perform the final HKDF expansion, storing the okm len octets into output keying material (okm).
Optionally store the pseudo random key (prk) that is generated internally.
In addition, combined interfaces are provided, similar to that shown in [RFC5869], that allows a fixed length text input to be used.
ikm, int ikm len, uint8 t prk[USHAMaxHashSize])
Perform HKDF extraction, combining the salt len octets of the optional salt with the ikm len octets of the input keying material (ikm) to form the pseudo random key prk.
The output prk must be large enough to hold the octets appropriate for the given hash type.
Perform HKDF expansion, combining the prk len octets of the pseudo random key prk with the info len octets of info to form the okm len octets stored in okm.
int hkdf(SHAversion whichSha, const unsigned char  salt, int salt len, const unsigned char
This combined interface performs both HKDF extraction and expansion.
The variables are the same as in hkdfExtract() and hkdfExpand().
The following sha.h file, as stated in the comments within the file, assumes that <stdint.h> is available on your system.
If it is not, you should change to including <stdint example.h>, provided in Section 8.1.2, or the like.
2011 IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
Neither the name of Internet Society, IETF or IETF Trust, nor the names of specific contributors, may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "
AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
USE MODIFIED MACROS use alternate form of the SHA Ch
All SHA functions return one of these values.
/  input data too long
These constants hold size information for each of the SHA    hashing operations  / enum { SHA1 Message Block Size   64,
SHA224 Message Block Size   64, SHA256 Message Block Size   64, SHA384 Message Block Size   128, SHA512 Message Block Size   128, USHA Max Message Block Size   SHA512 Message Block Size,
SHA1HashSize   20, SHA224HashSize   28, SHA256HashSize   32
, SHA384HashSize   48, SHA512HashSize   64, USHAMaxHashSize   SHA512HashSize, SHA1HashSizeBits
/ typedef struct SHA1Context {
/ typedef struct SHA256Context { uint32 t Intermediate Hash[SHA256HashSize/4]; /
/ typedef struct SHA512Context { #ifdef USE 32BIT
/ uint64 t Intermediate Hash[SHA512HashSize/8]; /
It uses the SHA 256 structure for computation.
It uses the SHA 512 structure for computation.
SHA256Context sha256Context; SHA384Context sha384Context; SHA512Context sha512Context; }
/ unsigned char k opad[USHA Max Message Block Size];
/  outer padding key XORd with opad
Is the key material computed?
extern int SHA1Input(SHA1Context  , const uint8 t  bytes, unsigned int bytecount); extern int
SHA1FinalBits(SHA1Context  , uint8 t bits, unsigned int bit count);
, const uint8 t  bytes, unsigned int bytecount); extern int SHA224FinalBits(SHA224Context  , uint8 t bits, unsigned int bit count)
, const uint8 t  bytes, unsigned int bytecount); extern int SHA256FinalBits(SHA256Context  , uint8 t bits, unsigned int bit count); extern int SHA256Result(SHA256Context
/ extern int SHA384Reset(SHA384Context  )
, const uint8 t  bytes, unsigned int bytecount); extern int
, uint8 t bits, unsigned int bit count); extern int SHA384Result(SHA384Context
/ extern int SHA512Reset(SHA512Context  )
, const uint8 t  bytes, unsigned int bytecount);
extern int SHA512FinalBits(SHA512Context  , uint8 t bits, unsigned int bit count)
context, const uint8 t  bytes, unsigned int bytecount); extern int USHAFinalBits(USHAContext
context, uint8 t bits, unsigned int bit count); extern int USHAResult(USHAContext
context, uint8 t Message Digest[USHAMaxHashSize]); extern int USHABlockSize(enum SHAversion whichSha); extern int USHAHashSize(enum SHAversion whichSha); extern int USHAHashSizeBits(enum SHAversion whichSha);
Keyed Hashing for Message Authentication, RFC 2104,   for all SHAs.
This interface allows a fixed length text input to be used.
RFC 2104,   for all SHAs.
This interface allows any length of text input to be used.
/ extern int hmacReset(HMACContext  context, enum SHAversion whichSha, const unsigned char
key, int key len); extern int hmacInput(HMACContext  context
RFC 5869, for all SHAs.
/ extern int hkdf(SHAversion whichSha, const unsigned char  salt, int salt len, const unsigned char
RFC 5869, for all SHAs.
This interface allows any length of text input to be used.
/ extern int hkdfReset(HKDFContext  context, enum SHAversion whichSha, const unsigned char  salt, int salt len); extern int hkdfInput(HKDFContext  context
, const unsigned char  ikm, int ikm len); extern int hkdfFinalBits(HKDFContext  context,
If your system does not have <stdint.h
>, the following should be adequate as a substitute for compiling the other code in this document. /
The sha private.h header file contains definitions that should only be needed internally in the other code in this document.
These definitions should not be needed in application code calling the code provided in this document.
SHA PRIVATE H #define  SHA PRIVATE H /
These definitions are defined in FIPS 180 3, section 4.1.
Ch() and Maj() are defined identically in sections 4.1.1,   4.1.2, and 4.1.3.
The definitions used in FIPS 180 3 are as follows:  /
The following definitions are equivalent and potentially faster.
define SHA Ch(x, y, z)
#define SHA Maj(x, y, z)
endif /  USE MODIFIED MACROS  /
define SHA Parity(x, y, z)
This code is primarily intended as expository reference code and could be optimized further.
, h could be treated as a cycle and the loop unrolled, rather than doing the explicit copying.
Note that there are alternative representations of the Ch() and Maj() functions controlled by an ifdef.
Set Corrupted when overflow has occurred.
/ static uint32 t addTemp; #define SHA1AddLength(context, length)
SHA1Reset(SHA1Context  context) { if (!
return shaNull; context Length High   context
/ int SHA1Input(SHA1Context  context, const uint8
t  message array, unsigned length) { if (!
if (context Computed) return context
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int SHA1FinalBits(SHA1Context  context, uint8 t message bits, unsigned int length) { static uint8 t masks[8]
/ 0x01 }; if (!
return shaSuccess; if (context Corrupted
) return context Corrupted; if (context Computed) return context
Corrupted   shaStateError; if (length >
8) return context Corrupted   shaBadParam; SHA1AddLength(context, length); SHA1Finalize(context, (uint8 t)
Where the digest is returned.
SHA1Result(SHA1Context  context, uint8 t Message Digest[SHA1HashSize])
{ int i; if (!
if (context Corrupted) return context Corrupted; if (!
; for (i   0; i < SHA1HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>2]
Constants defined in FIPS 180 3, section 4.2.1  / const
((uint32 t)context Message Block[t   4])
W[t]   SHA1 ROTL(1, W[t 3]
E   W[t]   K[3]; E   D; D   C; C   SHA1 ROTL(30,B)
context Message Block Index   0
/ static void SHA1Finalize(SHA1Context  context,
uint8 t Pad Byte) { int i; SHA1PadMessage(context, Pad Byte)
/ context Length Low   0; context
The first padding bit must be a '1'.
The last 64 bits represent the length of the original message.
All bits in between should be 0.
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
; } else context Message Block[context Message Block Index ]
(uint8 t) (context Length High >> 24); context Message Block[57]
(uint8 t) (context Length High >> 16)
(uint8 t) (context Length High >> 8);
(context Length Low >> 24); context Message Block[61]
(uint8 t) (context Length Low
> 16); context Message Block[62]
(uint8 t) (context Length Low >> 8);
(uint8 t) (context Length Low);
/  Define the SHA SIGMA and sigma macros  /
\ (SHA256 ROTR( 2,word) ^ SHA256 ROTR(13,word) ^ SHA256 ROTR(22,word))
\ (SHA256 ROTR( 6,word) ^ SHA256 ROTR(11,word) ^ SHA256 ROTR(25,word))
(SHA256 ROTR( 7,word) ^ SHA256 ROTR(18,word) ^
Set Corrupted when overflow has occurred.
/ static uint32 t addTemp;
\ (context) Corrupted ) /
Local Function Prototypes  / static int SHA224
FIPS 180 3 section 5.3.2
FIPS 180 3 section 5.3.3
/ int SHA224Reset(SHA224Context  context) { return SHA224 256Reset(context, SHA224 H0);
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
Where the digest is returned.
t  message array, unsigned int length) { if (!
if (context Computed) return context
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int SHA256FinalBits(SHA256Context  context, uint8 t message bits, unsigned int length)
{ static uint8 t masks[8]
/ 0x01 }; if (!
return shaSuccess; if (context Corrupted
) return context Corrupted; if (context Computed) return context
Corrupted   shaStateError; if (length >
Where the digest is returned.
256Reset(SHA256Context  context, uint32 t  H0) { if (!
return shaNull; context Length High   context
; context Message Block Index    0; context Intermediate Hash[0]   H0[0]
; context Intermediate Hash[1]   H0[1]; context Intermediate Hash[2]
H0[2]; context Intermediate Hash[3]   H0[3]; context Intermediate Hash[4]   H0[4]; context Intermediate Hash[5]   H0[5]; context Intermediate Hash[6]   H0[6]; context Intermediate Hash[7]
H0[7]; context Computed    0; context Corrupted   shaSuccess;
0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624,
A, B, C, D, E, F, G, H;  /
W  / for (t   t4   0
; t < 16; t , t4    4) W[t]
(((uint32 t)context Message Block[t4   1])
(((uint32 t)context Message Block[t4   2])
W[t 16]; A   context Intermediate Hash[0]; B   context Intermediate Hash[1]; C   context Intermediate Hash[2]; D   context Intermediate Hash[3]; E   context Intermediate Hash[4]; F   context Intermediate Hash[5]; G   context Intermediate Hash[6]; H   context Intermediate Hash[7]; for (t   0; t < 64
SHA Ch(E,F,G)   K[t]   W[t]; temp2
SHA Maj(A,B,C); H   G; G   F; F   E;
E   D   temp1; D   C; C   B;
temp2; } context Intermediate Hash[0]
/ static void SHA224 256Finalize(SHA256Context  context, uint8 t Pad Byte) {
The first padding bit must be a '1'.
The last 64 bits represent the length of the original message.
All bits in between should be 0.
/ static void SHA224 256PadMessage(SHA256Context  context,
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
Pad Byte; while (context Message Block Index < SHA256 Message Block Size) context
Length High >> 24); context Message Block[57]
Length High >> 16); context Message Block[58]
Length High >> 8); context Message Block[59]
(uint8 t)(context Length High); context Message Block[60]
(uint8 t)(context Length Low >> 24); context Message Block[61]
Length Low >> 16); context Message Block[62]
Length Low >> 8); context Message Block[63]
Where the digest is returned.
{ int i; if (!
if (context Corrupted) return context Corrupted; if (!context Computed) SHA224 256Finalize(context, 0x80); for (i   0; i < HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>2] >
Each 64 bit number is represented in a 2 word array.
All macros are defined such that the result is the last parameter.
/ #define SHA512 SHR(bits, word, ret)
#define SHA512 SHL(bits, word, ret)
define SHA512 OR(word1, word2, ret)
/ #define SHA512 AND(word1, word2, ret)
define SHA512 ADD(word1, word2, ret)
/ static uint32 t ADDTO4 temp, ADDTO4
/ static uint32 t ADDTO2 temp; #define SHA512 ADDTO2(word1, word2)
/ static uint32 t ROTR temp1[2], ROTR temp2[2]; #define SHA512 ROTR(bits, word, ret)
SHA512 SHL(64 (bits), (word), ROTR temp2),
, SIGMA0 temp2[2], SIGMA0 temp3[2], SIGMA0 temp4[2]; #define SHA512 SIGMA0(word, ret)
SIGMA1 temp1[2], SIGMA1 temp2[2], SIGMA1 temp3[2], SIGMA1 temp4[2]; #define SHA512 SIGMA1(word, ret)
/ static uint32 t sigma0 temp1[2], sigma0 temp2[2], sigma0 temp3[2], sigma0 temp4[2]; #define SHA512 sigma0(word, ret)
/ static uint32 t sigma1 temp1[2], sigma1 temp2[2], sigma1 temp3[2], sigma1 temp4[2]; #define SHA512 sigma1(word, ret)
SHA512 XOR(sigma1 temp1, sigma1 temp4, (ret)) )
#ifndef USE MODIFIED MACROS /
These definitions are the ones used in FIPS 180 3,
/ static uint32 t Ch temp1[2]
, Ch temp2[2], Ch temp3[2]; #define SHA Ch(x, y, z, ret)
SHA512 XOR(Ch temp1, Ch temp3, (ret)) )
, Maj temp2[2], Maj temp3[2], Maj temp4[2]; #define SHA Maj(x, y, z, ret)
temp2, Maj temp3, Maj temp4),
(x & (y ^ z))
define SHA Ch(x, y, z, ret)
define SHA Maj(x, y, z, ret)
Set Corrupted when overflow has occurred.
(length), SHA512 ADDTO4((context) Length, addTemp), \
\ (context) Corrupted ) /
Local Function Prototypes  / static int SHA384
^ SHA512 ROTR(34,word) ^ SHA512 ROTR(39,word))
(SHA512 ROTR(14,word) ^ SHA512 ROTR(18,word) ^ SHA512 ROTR(41,word))
(SHA512 ROTR( 1,word) ^ SHA512 ROTR( 8,word)
(SHA512 ROTR(19,word) ^ SHA512 ROTR(61,word)
Set Corrupted when overflow has occurred.
/ static uint64 t addTemp;
addTemp   context Length Low, context
Local Function Prototypes  / static int SHA384 512Reset(SHA512Context
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
Where the digest is returned.
t  message array, unsigned int length) { if (!
if (context Computed) return context
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
SHA512FinalBits(SHA512Context  context, uint8 t message bits, unsigned int length)
{ static uint8 t masks[8]
/ 0x01 }; if (!
return shaSuccess; if (context Corrupted
) return context Corrupted; if (context Computed) return context
Corrupted   shaStateError; if (length >
Where the digest is returned.
512Reset(SHA512Context  context, uint32 t H0[SHA512HashSize/4])
/ static int SHA384 512Reset(SHA512Context
if (!context) return shaNull; context Message Block Index   0; #ifdef USE 32BIT ONLY context
context Length[3]   0; for (i   0; i < SHA512HashSize/4; i ) context Intermediate Hash[i]
ONLY  / context Length High   context
Length Low   0; for (i   0; i < SHA512HashSize/8; i ) context Intermediate Hash[i]
Constants defined in FIPS 180 3, section 4.2.3
0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8, 0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53, 0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8, 0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3, 0x748F82EE
, 0x5DEFB2FC, 0x78A5636F, 0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC, 0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B, 0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207, 0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6, 0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C
Temporary word values  / temp3[2], temp4[2], temp5[2]; uint32 t
for (t   t2   t8   0; t < 16; t , t8    8) {
; D[1]   context Intermediate Hash[7]
; E[0]   context Intermediate Hash[8]; E[1]   context Intermediate Hash[9]; F[0]
; SHA512 ADD(D, temp1, E); D[0]
Constants defined in FIPS 180 3, section 4.2.3
/ static const uint64 t K[80]
, 0xB5C0FBCFEC4D3B2Fll, 0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll, 0x59F111F1B605D019ll, 0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll, 0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll, 0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll, 0xC19BF174CF692694ll, 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll, 0x0FC19DC68B8CD5B5ll
, 0x240CA1CC77AC9C65ll, 0x2DE92C6F592B0275ll, 0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll, 0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll, 0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll, 0x06CA6351E003826Fll, 0x142929670A0E6E70ll,
, 0x53380D139D95B3DFll, 0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll, 0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll, 0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll, 0xD69906245565A910ll, 0xF40E35855771202All, 0x106AA07032BBD1B8ll, 0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll, 0x2748774CDF8EEB99ll, 0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll, 0x5B9CCA4F7763E373ll,
0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll, 0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll, 0x90BEFFFA23631E28ll, 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll, 0xC67178F2E372532Bll,
0xCA273ECEEA26619Cll, 0xD186B8C721C0C207ll, 0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll, 0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll, 0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll, 0x431D67C49C100D4Cll, 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All, 0x5FCB6FAB3AD6FAECll,
A, B, C, D, E, F, G, H;  /
for (t   t8   0; t < 16; t , t8    8)
((uint64 t)(context Message Block[t8  ])
((uint64 t)(context Message Block[t8   1])
((uint64 t)(context Message Block[t8   2])
((uint64 t)(context Message Block[t8   3])
((uint64 t)(context Message Block[t8   4])
((uint64 t)(context Message Block[t8   5])
((uint64 t)(context Message Block[t8   6])
W[t 16]; A   context Intermediate Hash[0]; B   context Intermediate Hash[1]; C   context Intermediate Hash[2]; D   context Intermediate Hash[3]; E   context Intermediate Hash[4]; F   context Intermediate Hash[5]; G   context Intermediate Hash[6]; H   context Intermediate Hash[7]; for (t   0; t < 80
SHA Ch(E,F,G)   K[t]   W[t]; temp2
SHA Maj(A,B,C); H   G; G   F; F   E;
E   D   temp1; D   C; C   B;
temp2; } context Intermediate Hash[0]
H; #endif /  USE 32BIT ONLY
/ static void SHA384 512Finalize(SHA512Context
context, uint8 t Pad Byte) { int
) context Message Block[i]   0; #ifdef USE 32BIT
context Length[1]   0; context Length[2]
ONLY  / context Length High   context
Length Low   0; #endif /  USE 32BIT ONLY  / context
The first padding bit must be a '1'.
The last 128 bits represent the length of the original message.
All bits in between should be 0.
/ static void SHA384 512PadMessage(SHA512Context  context,
If so, we will pad the   block, process it, and then continue padding into a second   block.
/ if (context Message Block Index
(SHA512 Message Block Size 16))
{ context Message Block[context Message Block Index ]
Pad Byte; while (context Message Block Index < (SHA512 Message Block Size 16))
> 16); context Message Block[114]
(uint8 t)(context Length[1]); context Message Block[120]
> 24); context Message Block[121]
Length High >> 32); context Message Block[116]
Length High >> 8); context Message Block[119]
Length Low >> 24); context Message Block[125]
Length Low >> 16); context Message Block[126]
Length Low >> 8); context Message Block[127]
Where the digest is returned.
/ static int SHA384 512ResultN(SHA512Context
{ int i; #ifdef USE 32BIT ONLY int i2; #endif /  USE 32BIT
/ if (!context) return shaNull; if (!Message Digest) return shaNull; if (context Corrupted) return context Corrupted; if (!context Computed) SHA384 512Finalize(context, 0x80); #ifdef USE 32BIT ONLY for (i
Intermediate Hash[i2]>>24); Message Digest[i ]
Intermediate Hash[i2]>>16); Message Digest[i ]
Intermediate Hash[i2]>>24); Message Digest[i ]
Intermediate Hash[i2]>>16); Message Digest[i ]
ONLY  / for (i   0; i < HashSize;  i)
(uint8 t) (context Intermediate Hash[i>>3]
context, enum SHAversion whichSha) { if (!context) return shaNull; context whichSha   whichSha; switch (whichSha)
return SHA1Reset((SHA1Context )&context ctx); case SHA224: return SHA224Reset((SHA224Context )&context ctx); case SHA256: return SHA256Reset((SHA256Context )&context ctx); case SHA384: return SHA384Reset((SHA384Context )&context ctx); case SHA512: return SHA512Reset((SHA512Context )&context ctx)
context, const uint8 t  bytes, unsigned int bytecount) { if (!context) return shaNull; switch (context whichSha)
This function will add in any final bits of the message.
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
context, uint8 t bits, unsigned int bit count) { if (!context) return shaNull; switch (context whichSha)
Where the digest is returned.
context, uint8 t Message Digest[USHAMaxHashSize])
{ switch (whichSha) { case SHA1:
return SHA1 Message Block Size
; case SHA224: return SHA224 Message Block Size; case SHA256: return SHA256 Message Block Size; case SHA384:
/ int USHAHashSize(enum SHAversion whichSha)
{ switch (whichSha) { case SHA1:
{ switch (whichSha) { case SHA1:
{ switch (whichSha) { case SHA1:
return "SHA1"; case SHA224: return "SHA224";
/ int hmac(SHAversion whichSha, const unsigned char
message array, int length, const unsigned char
hmacReset(HMACContext  context, enum SHAversion whichSha, const unsigned char
Computed   0; context Corrupted   shaSuccess
; context whichSha   whichSha; /
If key is longer than the hash blocksize,   reset it to key   HASH(key).
/ if (key len > blocksize) { USHAContext tcontext;
ipad is the byte 0x36 repeated blocksize times,   opad is the byte 0x5c repeated blocksize times,   and
text is the data being protected.
/  and start with inner pad
/ USHAInput(&context shaContext, k ipad, blocksize); return context
It may be called multiple times.
hmacInput(HMACContext  context, const unsigned char  text, int text len) { if (!context) return shaNull; if (context Corrupted
) return context Corrupted; if (context Computed) return context
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int hmacFinalBits(HMACContext  context, uint8 t bits, unsigned int bit count) { if (!context) return shaNull; if (context Corrupted) return context Corrupted;
if (context Computed) return context Corrupted   shaStateError;
/  then final bits of datagram
Where the digest is returned.
uint8 t  digest) { int ret;
if (!context) return shaNull; if (context Corrupted) return context Corrupted; if (context Computed) return context Corrupted   shaStateError
(Use digest here as a temporary buffer.)
/ ret   USHAResult(&context shaContext, digest)
/ USHAInput(&context shaContext, context k opad, context blockSize)
then results of 1st hash  /
USHAInput(&context shaContext, digest, context hashSize)
pass  / USHAResult(&context shaContext, digest)
; context Computed   1; return context
sha.h" #include <string.h> #include <stdlib.h
If info   NULL or a zero length string, it is ignored.
Where the HKDF is to be stored.
okm len must be <  255
/ int hkdf(SHAversion whichSha, const unsigned char
If info   NULL or a zero length string, it is ignored.
Where the HKDF is to be stored.
okm len must be <  255
) N ; if (N > 255) return shaBadParam;
where, T, (i !  N) ?
okm len where)); where    hash len; Tlen   hash len
/ int hkdfReset(HKDFContext  context, enum SHAversion whichSha, const unsigned char  salt, int salt len) { unsigned char nullSalt[USHAMaxHashSize]; if (!
return shaNull; context whichSha   whichSha; context hashSize   USHAHashSize(whichSha); if (salt   0) { salt   nullSalt
It may be called multiple times.
hkdfInput(HKDFContext  context, const unsigned char  ikm, int ikm len) {
(Use 0b###00000 instead of 0b00000
The number of bits in message bits, between 1 and 7.
/ int hkdfFinalBits(HKDFContext  context, uint8 t ikm bits, unsigned int ikm bit count) { if (!context)
return shaNull; if (context Corrupted) return context Corrupted; if (context Computed) return context Corrupted   shaStateError
If info   NULL or a zero length string, it is ignored.
Where the HKDF is to be stored.
return shaNull; if (context Corrupted) return context Corrupted; if (context Computed) return context Corrupted   shaStateError; if (!
prk   prkbuf; ret   hmacResult(&context hmacContext, prk)
hkdfExpand(context whichSha, prk, context hashSize
, info, info len, okm, okm len); context Computed   1; return context
The following code is a main program test driver to exercise the code in sha1.c, sha224 256.c, sha384 512.c, hmac.c, and hkdf.c.
The test driver can also be used as a standalone program for generating the hashes.
Note that the tests assume that character values are as in [US ASCII] and a run time check warns if the code appears to have been compiled with some other character system.
To run the tests and just see PASSED/FAILED, use the  p option.
> #include <string.h> #include <ctype.h> #include <unistd.h>
/  defines getopt() and optarg  /
#define TEST10 256 \ "
" #define TEST10 384 \
\x8d\x4e\x3c\x0e\x38\x89\x19\x14\x91\x81\x6e\x9d\x98\xbf\xf0\xa0" #define TEST9 512 \ "
#define PRINTHEX 3 #define PRINTBASE64 4
#define PRINTPASSFAIL 1 #define PRINTFAIL
/ struct hash { const char  name; SHAversion whichSha; int hashsize; struct { const char  testarray; int length; long repeatcount; int extrabits; int numberExtrabits;
/ { TEST2 1, length(TEST2 1), 1, 0, 0, "84983E441C3BD26EBAAE4AA1F95129E5E54670F1" },
/ struct hmachash { const char  keyarray[5]; int keylength[5]
/ struct hkdfhash { SHAversion whichSha; int ikmlength;
const char  ikmarray; int saltlength; const char  saltarray; int infolength;
const char  infoarray; int prklength; const char  prkarray; int okmlength;
Test Case 2  / SHA256, 80, "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d" "\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b" "\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29" "\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37" "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45
Test Case 5  / SHA1, 80, "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d" "\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b" "\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29" "\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37" "\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45" "\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f", 80, "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D
hexstr, int hashsize) { int i; for (i   0; i < hashsize;  i) { if (
> 4) & 0xF]) return 0;
/ void printxstr(const char  str, int len)
{ fprintf(stderr, "Usage:\n" "Common options: [ h hash]
"Hash a string:\n" "\t%s [ S expectedresult]  s hashstr
"[ i info  L okm len]\n"
"\t%s [ S expectedresult]  f file
"[ i info  L okm len]\n"
[ l loopcount] [ t test#]
many times to run the test\n" " e\ttest error returns\n" " p\tdo not print results\n" " P\tdo not print PASSED/
FAILED\n" " X\tprint FAILED, but not PASSED\n" " r\tseed for random test\n" "
R\thow many times to run random test\n" " s\tstring to hash\n" " S\texpected result of hashed string, in
hex\n" " w\toutput hash in raw format\n" " x\toutput hash in hex format\n
" " 6\toutput hash in base64 format\n" " B\t# extra bits to add in after string or file input\n" " b\textra bits to add (high order bits of #, 0
# or 0x#)\n" " H\tinput hashstr or randomseed is in
Message Digest, int hashsize, const char  hashname, const char
testtype, const char  testname, const char
resultarray, int printResults, int printPassFail)
{ int i, k; if (printResults   PRINTTEXT)
{ printf("\nhashsize %d\n", hashsize); putchar('\t'); for (i   0; i < hashsize;  i)
{ unsigned char b; char  sm
i    3) { putchar(sm[Message Digest[i] >
) b    Message Digest[i 1] >
; putchar(sm[b]); if (i 1 < hashsize) { b
if (i 2 < hashsize) b    Message Digest[i 2] >
if (i 2 < hashsize)
The input is the testarray,   repeated repeatcount times, followed by the extrabits.
If the   result is known, it is in resultarray in uppercase hex.
/ int hash(int testno, int loopno, int hashno, const char
testarray, int length, long repeatcount, int numberExtrabits, int extrabits, const unsigned char
keyarray, int keylen, const unsigned char  info, int infolen, int okmlen, const char
, int hashsize, int printResults, int printPassFail) { USHAContext sha; HMACContext hmac; HKDFContext hkdf; int err, i;
uint8 t Message Digest Buf[USHAMaxHashSize]; uint8 t
Message Digest Buf; char buf[20]; if (printResults   PRINTTEXT) { printf("\nTest
/ memset(&hmac, '\343', sizeof(hmac)); memset(&hkdf, '\343', sizeof(hkdf)); err   info ?
hmacReset(&hmac, hashes[hashno].whichSha, keyarray, keylen) : USHAReset(&sha, hashes[hashno].whichSha);
hkdfInput(&hkdf, (const uint8 t  )testarray, length)
hmacInput(&hmac, (const uint8 t  ) testarray, length) : USHAInput(&sha,
(const uint8 t  ) testarray, length);
hmacFinalBits(&hmac, (uint8 t) extrabits, numberExtrabits) :
USHAFinalBits(&sha, (uint8 t) extrabits, numberExtrabits); if (err !
hkdfResult(&hkdf, 0, info, infolen, Message Digest, okmlen) : keyarray ?
hmacResult(&hmac, Message Digest) : USHAResult(&sha, Message Digest); if (err !
hashsize, hashes[hashno].name, info ? "
hkdf standard test" : keyarray ? "
The input is the testarray,   repeated repeatcount times, followed by the extrabits.
If the   result is known, it is in resultarray in uppercase hex.
/ int hashHkdf(int testno, int loopno, int hashno, int printResults, int printPassFail)
{ int err; unsigned char prk[USHAMaxHashSize 1];
uint8 t okm[255   USHAMaxHashSize 1]; char buf[20]; if (printResults   PRINTTEXT) { printf("\nTest
) hkdfhashes[testno].ikmarray, hkdfhashes[testno].ikmlength, (const uint8
) hkdfhashes[testno].saltarray, hkdfhashes[testno].saltlength, (const uint8
hkdfExpand(hkdfhashes[testno].whichSha, prk, USHAHashSize(hkdfhashes[testno].whichSha), (const uint8
The input is a filename.
If the result is known, it is in resultarray in uppercase hex.
/ int hashfile(int hashno, const char  hashfilename, int bits, int bitcount, int skipSpaces, const unsigned char
keyarray, int keylen, const unsigned char  info, int infolen, int okmlen, const char
, int hashsize, int printResults, int printPassFail) { USHAContext sha; HMACContext hmac; HKDFContext hkdf; int err, nread, c; unsigned char buf[4096];
uint8 t Message Digest Buf[USHAMaxHashSize]; uint8 t
Message Digest Buf; unsigned char cc;
stdin : fopen(hashfilename, "r"); if (!
{ fprintf(stderr, "cannot open file '%s'\n", hashfilename); return shaStateError; } if (info)
/ memset(&hmac, '\343', sizeof(hmac)); memset(&hkdf, '\343', sizeof(hkdf)); err   info ?
hmacReset(&hmac, hashes[hashno].whichSha, keyarray, keylen) : USHAReset(&sha, hashes[hashno].whichSha);
hmacInput(&hmac, &cc, 1) : USHAInput(&sha, &cc, 1); if (err !  shaSuccess) {
hmacInput(&hmac, buf, nread) : USHAInput(&sha, buf, nread); if (err !
USHAFinalBits(&sha, bits, bitcount); if (err !  shaSuccess) {
", err); if (hashfp !
stdin) fclose(hashfp); return err; } err   info ?
hkdfResult(&hkdf, 0, info, infolen, Message Digest, okmlen) : keyarray ?
hmacResult(&hmac, Message Digest) : USHAResult(&sha, Message Digest); if (err !
hashsize, hashes[hashno].name, "file", hashfilename, resultarray, printResults, printPassFail); if (hashfp !
The input is an initial seed.
That seed is replicated 3 times.
For 1000 rounds, the previous three results are used as the input.
This result is then checked, and used to seed the next cycle.
If the result is known, it is in resultarrays in uppercase hex.
resultarrays, int randomcount, int printResults, int printPassFail)
Seed A random seed n bits long
MDj  / sprintf(buf, "%d", j); printResult(SEED, hashsize, hashes[hashno].name, "random test", buf, resultarrays ?
resultarrays[j] : 0, printResults, (j < RANDOMCOUNT) ?
argv0, const char  opt) { int i;
Run some tests that should invoke errors.
/ void testErrors(int hashnolow, int hashnohigh,
{ USHAContext usha; uint8 t Message Digest[USHAMaxHashSize]; int hashno, err; for (hashno   hashnolow; hashno <  hashnohigh; hashno ) {
printf("%s se: %s\n", hashes[hashno].name, (err
printf ("\nError %d. Should be %d.\n", err, shaStateError); if ((printPassFail   PRINTPASSFAIL)
printf("%s se: %s\n", hashes[hashno].name, (err
printf("\nError %d. Should be %d.\n", err, shaNull); if ((printPassFail   PRINTPASSFAIL)
; break; case SHA384: err   SHA384Reset(0); break; case SHA512: err   SHA512Reset(0); break; } if (printResults   PRINTTEXT)
printf("\nError %d. Should be %d.\n", err, shaNull); if ((printPassFail   PRINTPASSFAIL)
%s\n", hashes[hashno].name, (err   shaNull) ?
( hexstr)) 'a'   10; } else if (isdigit((int)(unsigned char)( hexstr)))
{ printf("\nError: bad hex character '%c'\n",  hexstr); }
( hexstr)) 'a'   10; } else if (isdigit((int)(unsigned char)( hexstr)))
{ int i, err; int loopno, loopnohigh   1; int hashno,
hashnolow   0, hashnohigh   HASHCOUNT 1; int testno, testnolow   0, testnohigh;
int ntestnohigh   0; int printResults   PRINTTEXT; int printPassFail   1;
0; char  hashstr   0; int hashlen   0; const char  resultstr   0; char  randomseedstr   0; int runHmacTests   0; int runHkdfTests   0; char  hmacKey   0; int hmaclen   0; char  info   0;
0; int randomcount   RANDOMCOUNT; const char  hashfilename   0; const char  hashFilename   0; int extrabits   0, numberExtrabits   0;
strtol(optarg, 0, 0); break; case 'B': numberExtrabits
); break; case 'd': runHkdfTests   1; break; case 'e': checkErrors   1; break; case 'f': hashfilename   optarg; break; case 'F': hashFilename   optarg; break;
strIsHex   1; break; case 'i': info   optarg; infolen   strlen(optarg)
hmacKey   optarg; hmaclen   strlen(optarg); break; case 'l':
: okmlen   strtol(optarg, 0, 0); break; case 'm':
runHmacTests   1; break; case 'P': printPassFail   0; break; case 'p': printResults   PRINTNONE;
: randomcount   atoi(optarg); break; case 'r': randomseedstr   optarg; break;
case 's': hashstr   optarg; hashlen   strlen(hashstr); break; case 'S': resultstr   optarg;
printResults   PRINTRAW; break; case 'x': printResults   PRINTHEX; break; case 'X':
(HMACTESTCOUNT 1) : runHkdfTests ?
hash(0, loopno, hashno, hashstr, hashlen, 1, numberExtrabits, extrabits, (const unsigned char  )
hmacKey, hmaclen, (const uint8 t  ) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail); else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail); else if (hashfilename)
hashfile(hashno, hashfilename, extrabits, numberExtrabits, 0,
(const unsigned char  )hmacKey, hmaclen, (const uint8 t  ) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail); else if (hashFilename)
hashfile(hashno, hashFilename, extrabits, numberExtrabits, 1,
hmachashes[testno].dataarray[1] : hmachashes[testno].dataarray[0], hmachashes[testno].datalength[hashno] ?
hmachashes[testno].keyarray[1] : hmachashes[testno].keyarray[0]), hmachashes[testno].keylength[hashno] ?
Equivalent to strcasecmp() found on some systems.
This document is intended to provide convenient open source access by the Internet community to the United States of America Federal Information Processing Standard Secure Hash Algorithms (SHAs)
[FIPS 180 2], HMACs based thereon, and HKDF.
No independent assertion of the security of these functions by the authors for any particular use is intended.
See [RFC6194] for a discussion of SHA 1 Security Considerations.
Appendix: Changes from RFC 4634
The following changes were made to RFC 4634 to produce this document:
Add code for HKDF and brief text about HKDF with pointer to [RFC5869].
Fix numerous errata filed against [RFC4634] as included below.
Note that in no case did the old code return an incorrect hash value.
Correct some of the error return values which has erroneously been "shaNull" to the correct "shaInputTooLong" error.
Update comments and variable names within the code for consistency and clarity and other editorial changes.
The previous code for SHA 384 and SHA 512 would stop after 2^93 bytes (2^96 bits).
The fixed code handles up to 2^125 bytes (2^128 bits).
Add additional error checking including a run time check in the test driver to detect attempts to run the test driver after compilation using some other character set instead of [US ASCII].
Update boilerplate, remove special license in [RFC4634] as new boilerplate mandates simplified BSD license.
Replace MIT version of getopt with new code to satisfy IETF incoming and outgoing license restrictions.
