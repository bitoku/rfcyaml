- contents:
  - "               Addressing an Amplification Vulnerability\n          in Session
    Initiation Protocol (SIP) Forking Proxies\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2008 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    (http://trustee.ietf.org/\n   license-info) in effect on the date of publication
    of this document.\n   Please review these documents carefully, as they describe
    your rights\n   and restrictions with respect to this document.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document normatively updates RFC 3261, the Session Initiation\n
    \  Protocol (SIP), to address a security vulnerability identified in SIP\n   proxy
    behavior.  This vulnerability enables an attack against SIP\n   networks where
    a small number of legitimate, even authorized, SIP\n   requests can stimulate
    massive amounts of proxy-to-proxy traffic.\n   This document strengthens loop-detection
    requirements on SIP proxies\n   when they fork requests (that is, forward a request
    to more than one\n   destination).  It also corrects and clarifies the description
    of the\n   loop-detection algorithm such proxies are required to implement.\n
    \  Additionally, this document defines a Max-Breadth mechanism for\n   limiting
    the number of concurrent branches pursued for any given\n   request.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions and Definitions .....................................3\n   3.
    Vulnerability: Leveraging Forking to Flood a Network ............3\n   4. Updates
    to RFC 3261 .............................................7\n      4.1. Strengthening
    the Requirement to Perform Loop Detection ....7\n      4.2. Correcting and Clarifying
    the RFC 3261\n           Loop-Detection Algorithm ...................................7\n
    \          4.2.1. Update to Section 16.6 ..............................7\n           4.2.2.
    Update to Section 16.3 ..............................8\n           4.2.3. Impact
    of Loop Detection on Overall Network\n                  Performance .........................................9\n
    \          4.2.4. Note to Implementers ................................9\n   5.
    Max-Breadth ....................................................10\n      5.1.
    Overview ..................................................10\n      5.2. Examples
    ..................................................11\n      5.3. Formal Mechanism
    ..........................................12\n           5.3.1. Max-Breadth Header
    Field ...........................12\n           5.3.2. Terminology ........................................13\n
    \          5.3.3. Proxy Behavior .....................................13\n                  5.3.3.1.
    Reusing Max-Breadth .......................14\n           5.3.4. UAC Behavior
    .......................................14\n           5.3.5. UAS Behavior .......................................14\n
    \     5.4. Implementer Notes .........................................14\n           5.4.1.
    Treatment of CANCEL ................................14\n           5.4.2. Reclamation
    of Max-Breadth on 2xx Responses ........14\n           5.4.3. Max-Breadth and
    Automaton UAs ......................14\n      5.5. Parallel and Sequential Forking
    ...........................15\n      5.6. Max-Breadth Split Weight Selection ........................15\n
    \     5.7. Max-Breadth's Effect on Forking-Based\n           Amplification Attacks
    .....................................15\n      5.8. Max-Breadth Header Field ABNF
    Definition ..................16\n   6. IANA Considerations ............................................16\n
    \     6.1. Max-Breadth Header Field ..................................16\n      6.2.
    440 Max-Breadth Exceeded Response .........................16\n   7. Security
    Considerations ........................................16\n      7.1. Alternate
    Solutions That Were Considered and Rejected .....17\n   8. Acknowledgments ................................................19\n
    \  9. References .....................................................19\n      9.1.
    Normative References ......................................19\n      9.2. Informative
    References ....................................19\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Interoperability testing uncovered a vulnerability in the
    behavior of\n   forking SIP proxies as defined in [RFC3261].  This vulnerability
    can\n   be leveraged to cause a small number of valid SIP requests to\n   generate
    an extremely large number of proxy-to-proxy messages.  A\n   version of this attack
    demonstrates fewer than ten messages\n   stimulating potentially 2^71 messages.\n
    \  This document specifies normative changes to the SIP protocol to\n   address
    this vulnerability.  According to this update, when a SIP\n   proxy forks a request
    to more than one destination, it is required to\n   ensure it is not participating
    in a request loop.\n   This normative update alone is insufficient to protect
    against\n   crafted variations of the attack described here involving multiple\n
    \  Addresses of Record (AORs).  To further address the vulnerability,\n   this
    document defines the Max-Breadth mechanism to limit the total\n   number of concurrent
    branches caused by a forked SIP request.  The\n   mechanism only limits concurrency.
    \ It does not limit the total\n   number of branches a request can traverse over
    its lifetime.\n   The mechanisms in this update will protect against variations
    of the\n   attack described here that use a small number of resources, including\n
    \  most unintentional self-inflicted variations that occur through\n   accidental
    misconfiguration.  However, an attacker with access to a\n   sufficient number
    of distinct resources will still be able to\n   stimulate a very large number
    of messages.  The number of concurrent\n   messages will be limited by the Max-Breadth
    mechanism, so the entire\n   set will be spread out over a long period of time,
    giving operators\n   better opportunity to detect the attack and take corrective
    measures\n   outside the protocol.  Future protocol work is needed to prevent
    this\n   form of the attack.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions and Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [RFC2119].\n"
  title: 2.  Conventions and Definitions
- contents:
  - "3.  Vulnerability: Leveraging Forking to Flood a Network\n   This section describes
    setting up an attack with a simplifying\n   assumption: that two accounts on each
    of two different RFC 3261\n   compliant proxy/registrar servers that do not perform
    loop detection\n   are available to an attacker.  This assumption is not necessary
    for\n   the attack but makes representing the scenario simpler.  The same\n   attack
    can be realized with a single account on a single server.\n   Consider two proxy/registrar
    services, P1 and P2, and four Addresses\n   of Record, a@P1, b@P1, a@P2, and b@P2.
    \ Using normal REGISTER\n   requests, establish bindings to these AORs as follows
    (non-essential\n   details elided):\n           REGISTER sip:P1 SIP/2.0\n           To:
    <sip:a@P1>\n           Contact: <sip:a@P2>, <sip:b@P2>\n           REGISTER sip:P1
    SIP/2.0\n           To: <sip:b@P1>\n           Contact: <sip:a@P2>, <sip:b@P2>\n
    \          REGISTER sip:P2 SIP/2.0\n           To: <sip:a@P2>\n           Contact:
    <sip:a@P1>, <sip:b@P1>\n           REGISTER sip:P2 SIP/2.0\n           To: <sip:b@P2>\n
    \          Contact: <sip:a@P1>, <sip:b@P1>\n   With these bindings in place, introduce
    an INVITE request to any of\n   the four AORs, say a@P1.  This request will fork
    to two requests\n   handled by P2, which will fork to four requests handled by
    P1, which\n   will fork to eight messages handled by P2, and so on.  This message\n
    \  flow is represented in Figure 1.\n                                       |\n
    \                                    a@P1\n                                   /
    \      \\\n                                 /           \\\n                               /
    \              \\\n                             /                   \\\n                          a@P2
    \                  b@P2\n                          /  \\                   /  \\\n
    \                       /      \\               /      \\\n                       /
    \       \\             /        \\\n                     a@P1       b@P1        a@P1
    \      b@P1\n                     /  \\       /  \\        /  \\       /  \\\n
    \                 a@P2  b@P2 a@P2  b@P2  a@P2  b@P2 a@P2  b@P2\n                   /\\
    \   /\\   /\\    /\\    /\\    /\\   /\\    /\\\n                                       .\n
    \                                      .\n                                       .\n
    \                  Figure 1: Attack Request Propagation\n   Requests will continue
    to propagate down this tree until Max-Forwards\n   reaches zero.  If the endpoint
    and two proxies involved follow RFC\n   3261 recommendations, the tree will be
    70 rows deep, representing\n   2^71-1 requests.  The actual number of messages
    may be much larger if\n   the time to process the entire tree's worth of requests
    is longer\n   than Timer C at either proxy.  In this case, a storm of 408 responses\n
    \  and/or a storm of CANCEL requests will also be propagating through\n   the
    tree along with the INVITE requests.  Remember that there are\n   only two proxies
    involved in this scenario - each having to hold the\n   state for all the transactions
    it sees (at least 2^70 simultaneously\n   active transactions near the end of
    the scenario).\n   The attack can be simplified to one account at one server if
    the\n   service can be convinced that contacts with varying attributes\n   (parameters,
    schemes, embedded headers) are sufficiently distinct,\n   and these parameters
    are not used as part of AOR comparisons when\n   forwarding a new request.  Since
    RFC 3261 mandates that all URI\n   parameters must be removed from a URI before
    looking it up in a\n   location service and that the URIs from the Contact header
    field are\n   compared using URI equality, the following registration should be\n
    \  sufficient to set up this attack using a single REGISTER request to a\n   single
    account:\n   REGISTER sip:P1 SIP/2.0\n   To: <sip:a@P1>\n   Contact: <sip:a@P1;unknown-param=whack>,<sip:a@P1;unknown-param=thud>\n
    \  This attack was realized in practice during one of the SIP\n   Interoperability
    Test (SIPit) sessions.  The scenario was extended to\n   include more than two
    proxies, and the participating proxies all\n   limited Max-Forwards to be no larger
    than 20.  After a handful of\n   messages to construct the attack, the participating
    proxies began\n   bombarding each other.  Extrapolating from the several hours
    the\n   experiment was allowed to run, the scenario would have completed in\n
    \  just under 10 days.  Had the proxies used the RFC 3261 recommended\n   Max-Forwards
    value of 70, and assuming they performed linearly as the\n   state they held increased,
    it would have taken 3 trillion years to\n   complete the processing of the single
    INVITE request that initiated\n   the attack.  It is interesting to note that
    a few proxies rebooted\n   during the scenario and rejoined in the attack when
    they restarted\n   (as long as they maintained registration state across reboots).
    \ This\n   points out that if this attack were launched on the Internet at\n   large,
    it might require coordination among all the affected elements\n   to stop it.\n
    \  Loop detection, as specified in this document, at any of the proxies\n   in
    the scenarios described so far would have stopped the attack\n   immediately.
    \ (If all the proxies involved implemented this loop\n   detection, the total
    number of stimulated messages in the first\n   scenario described would be reduced
    to 14; in the variation involving\n   one server, the number of stimulated messages
    would be reduced to\n   10.)  However, there is a variant of the attack that uses
    multiple\n   AORs where loop detection alone is insufficient protection.  In this\n
    \  variation, each participating AOR forks to all the other\n   participating
    AORs.  For small numbers of participating AORs (10, for\n   example), paths through
    the resulting tree will not loop until very\n   large numbers of messages have
    been generated.  Acquiring a\n   sufficient number of AORs to launch such an attack
    on networks\n   currently available is quite feasible.\n   In this scenario, requests
    will often take many hops to complete a\n   loop, and there are a very large number
    of different loops that will\n   occur during the attack.  In fact, if N is the
    number of\n   participating AORs, and provided N is less than or equal to Max-\n
    \  Forwards, the amount of traffic generated by the attack is greater\n   than
    N!, even if all proxies involved are performing loop detection.\n   Suppose we
    have a set of N AORs, all of which are set up to fork to\n   the entire set.  For
    clarity, assume AOR 1 is where the attack\n   begins.  Every permutation of the
    remaining N-1 AORs will play out,\n   defining (N-1)! distinct paths, without
    repeating any AOR.  Then,\n   each of these paths will fork N ways one last time,
    and a loop will\n   be detected on each of these branches.  These final branches
    alone\n   total N! requests ((N-1)! paths, with N forks at the end of each\n   path).\n
    \                       ___N____Requests_\n                        |  1 |         1
    |\n                        |  2 |         4 |\n                        |  3 |
    \       15 |\n                        |  4 |        64 |\n                        |
    \ 5 |       325 |\n                        |  6 |      1956 |\n                        |
    \ 7 |     13699 |\n                        |  8 |    109600 |\n                        |
    \ 9 |    986409 |\n                        | 10 |   9864100 |\n            Forwarded
    Requests vs. Number of Participating AORs\n   In a network where all proxies are
    performing loop detection, an\n   attacker is still afforded rapidly increasing
    returns on the number\n   of AORs they are able to leverage.  The Max-Breadth
    mechanism defined\n   in this document is designed to limit the effectiveness
    of this\n   variation of the attack.\n   In all of the scenarios, it is important
    to notice that at each\n   forking proxy, an additional branch could be added
    pointing to a\n   single victim (that might not even be a SIP-aware element),
    resulting\n   in a massive amount of traffic being directed towards the victim
    from\n   potentially as many sources as there are AORs participating in the\n
    \  attack.\n"
  title: '3.  Vulnerability: Leveraging Forking to Flood a Network'
- contents:
  - '4.  Updates to RFC 3261

    '
  - contents:
    - "4.1.  Strengthening the Requirement to Perform Loop Detection\n   The following
      requirements mitigate the risk of a proxy falling\n   victim to the attack described
      in this document.\n   When a SIP proxy forks a particular request to more than
      one\n   location, it MUST ensure that request is not looping through this\n
      \  proxy.  It is RECOMMENDED that proxies meet this requirement by\n   performing
      the loop-detection steps defined in this document.\n   The requirement to use
      this document's refinement of the loop-\n   detection algorithm from RFC 3261
      is set at should-strength to allow\n   for future Standards-Track mechanisms
      that will allow a proxy to\n   determine it is not looping.  For example, a
      proxy forking to\n   destinations established using the sip-outbound mechanism
      [OUTBOUND]\n   would know those branches will not loop.\n   A SIP proxy forwarding
      a request to only one location MAY perform\n   loop detection but is not required
      to.  When forwarding to only one\n   location, the amplification risk being
      exploited is not present, and\n   the Max-Forwards mechanism will protect the
      network to the extent it\n   was designed (always keep in mind the constant
      multiplier due to\n   exhausting Max-Forwards while not forking).  A proxy is
      not required\n   to perform loop detection when forwarding a request to a single\n
      \  location even if it happened to have previously forked that request\n   (and
      performed loop detection) in its progression through the\n   network.\n"
    title: 4.1.  Strengthening the Requirement to Perform Loop Detection
  - contents:
    - '4.2.  Correcting and Clarifying the RFC 3261 Loop-Detection Algorithm

      '
    - contents:
      - "4.2.1.  Update to Section 16.6\n   This section replaces all of item 8 in
        Section 16.6 of RFC 3261 (item\n   8 begins on page 105 and ends on page 106
        of RFC 3261).\n   8.  Add a Via Header Field Value\n   The proxy MUST insert
        a Via header field value into the copy before\n   the existing Via header
        field values.  The construction of this value\n   follows the same guidelines
        of Section 8.1.1.7.  This implies that\n   the proxy will compute its own
        branch parameter, which will be\n   globally unique for that branch, and will
        contain the requisite magic\n   cookie.  Note that following only the guidelines
        in Section 8.1.1.7\n   will result in a branch parameter that will be different
        for\n   different instances of a spiraled or looped request through a proxy.\n
        \  Proxies required to perform loop detection by RFC 5393 have an\n   additional
        constraint on the value they place in the Via header\n   field.  Such proxies
        SHOULD create a branch value separable into two\n   parts in any implementation-dependent
        way.\n   The remainder of this section's description assumes the existence
        of\n   these two parts.  If a proxy chooses to employ some other mechanism,\n
        \  it is the implementer's responsibility to verify that the detection\n   properties
        defined by the requirements placed on these two parts are\n   achieved.\n
        \  The first part of the branch value MUST satisfy the constraints of\n   Section
        8.1.1.7.  The second part is used to perform loop detection\n   and distinguish
        loops from spirals.\n   This second part MUST vary with any field used by
        the location\n   service logic in determining where to retarget or forward
        this\n   request.  This is necessary to distinguish looped requests from\n
        \  spirals by allowing the proxy to recognize if none of the values\n   affecting
        the processing of the request have changed.  Hence, the\n   second part MUST
        depend at least on the received Request-URI and any\n   Route header field
        values used when processing the received request.\n   Implementers need to
        take care to include all fields used by the\n   location service logic in
        that particular implementation.\n   This second part MUST NOT vary with the
        request method.  CANCEL and\n   non-200 ACK requests MUST have the same branch
        parameter value as the\n   corresponding request they cancel or acknowledge.
        \ This branch\n   parameter value is used in correlating those requests at
        the server\n   handling them (see Sections 17.2.3 and 9.2).\n"
      title: 4.2.1.  Update to Section 16.6
    - contents:
      - "4.2.2.  Update to Section 16.3\n   This section replaces all of item 4 in
        Section 16.3 of RFC 3261 (item\n   4 appears on page 95 of RFC 3261).\n   4.
        \ Loop-Detection Check\n   Proxies required to perform loop detection by RFC
        5393 MUST perform\n   the following loop-detection test before forwarding
        a request.  Each\n   Via header field value in the request whose sent-by value
        matches a\n   value placed into previous requests by this proxy MUST be inspected\n
        \  for the \"second part\" defined in Section 4.2.1 of RFC 5393.  This\n   second
        part will not be present if the message was not forked when\n   that Via header
        field value was added.  If the second field is\n   present, the proxy MUST
        perform the second-part calculation described\n   in Section 4.2.1 of RFC
        5393 on this request and compare the result\n   to the value from the Via
        header field.  If these values are equal,\n   the request has looped and the
        proxy MUST reject the request with a\n   482 (Loop Detected) response.  If
        the values differ, the request is\n   spiraling and processing continues to
        the next step.\n"
      title: 4.2.2.  Update to Section 16.3
    - contents:
      - "4.2.3.  Impact of Loop Detection on Overall Network Performance\n   These
        requirements and the recommendation to use the loop-detection\n   mechanisms
        in this document make the favorable trade of exponential\n   message growth
        for work that is, at worst, order n^2 as a message\n   crosses n proxies.
        \ Specifically, this work is order m*n where m is\n   the number of proxies
        in the path that fork the request to more than\n   one location.  In practice,
        m is expected to be small.\n   The loop-detection algorithm expressed in this
        document requires a\n   proxy to inspect each Via element in a received request.
        \ In the\n   worst case, where a message crosses N proxies, each of which
        loop\n   detect, proxy k does k inspections, and the overall number of\n   inspections
        spread across the proxies handling this request is the\n   sum of k from k=1
        to k=N which is N(N+1)/2.\n"
      title: 4.2.3.  Impact of Loop Detection on Overall Network Performance
    - contents:
      - "4.2.4.  Note to Implementers\n   A common way to create the second part of
        the branch parameter value\n   when forking a request is to compute a hash
        over the concatenation of\n   the Request-URI, any Route header field values
        used during processing\n   the request, and any other values used by the location
        service logic\n   while processing this request.  The hash should be chosen
        so that\n   there is a low probability that two distinct sets of these parameters\n
        \  will collide.  Because the maximum number of inputs that need to be\n   compared
        is 70, the chance of a collision is low even with a\n   relatively small hash
        value, such as 32 bits.  CRC-32c as specified\n   in [RFC4960] is a specific
        acceptable function, as is MD5 [RFC1321].\n   Note that MD5 is being chosen
        purely for non-cryptographic\n   properties.  An attacker who can control
        the inputs in order to\n   produce a hash collision can attack the connection
        in a variety of\n   other ways.  When forming the second part using a hash,\n
        \  implementations SHOULD include at least one field in the input to the\n
        \  hash that varies between different transactions attempting to reach\n   the
        same destination to avoid repeated failure should the hash\n   collide.  The
        Call-ID and CSeq fields would be good inputs for this\n   purpose.\n   A common
        point of failure to interoperate at SIPit events has been\n   due to parsers
        objecting to the contents of another element's Via\n   header field values
        when inspecting the Via stack for loops.\n   Implementers need to take care
        to avoid making assumptions about the\n   format of another element's Via
        header field value beyond the basic\n   constraints placed on that format
        by RFC 3261.  In particular,\n   parsing a header field value with unknown
        parameter names, parameters\n   with no values, or parameter values with or
        without quoted strings\n   must not cause an implementation to fail.\n   Removing,
        obfuscating, or in any other way modifying the branch\n   parameter values
        in Via header fields in a received request before\n   forwarding it removes
        the ability for the node that placed that\n   branch parameter into the message
        to perform loop detection.  If two\n   elements in a loop modify branch parameters
        this way, a loop can\n   never be detected.\n"
      title: 4.2.4.  Note to Implementers
    title: 4.2.  Correcting and Clarifying the RFC 3261 Loop-Detection Algorithm
  title: 4.  Updates to RFC 3261
- contents:
  - '5.  Max-Breadth

    '
  - contents:
    - "5.1.  Overview\n   The Max-Breadth mechanism defined here limits the total
      number of\n   concurrent branches caused by a forked SIP request.  With this\n
      \  mechanism, all proxyable requests are assigned a positive integral\n   Max-Breadth
      value, which denotes the maximum number of concurrent\n   branches this request
      may spawn through parallel forking as it is\n   forwarded from its current point.
      \ When a proxy forwards a request,\n   its Max-Breadth value is divided among
      the outgoing requests.  In\n   turn, each of the forwarded requests has a limit
      on how many\n   concurrent branches it may spawn.  As branches complete, their\n
      \  portion of the Max-Breadth value becomes available for subsequent\n   branches,
      if needed.  If there is insufficient Max-Breadth to carry\n   out a desired
      parallel fork, a proxy can return the 440 (Max-Breadth\n   Exceeded) response
      defined in this document.\n   This mechanism operates independently from Max-Forwards.
      \ Max-\n   Forwards limits the depth of the tree a request may traverse as it
      is\n   forwarded from its origination point to each destination it is forked\n
      \  to.  As Section 3 shows, the number of branches in a tree of even\n   limited
      depth can be made large (exponential with depth) by\n   leveraging forking.
      \ Each such branch has a pair of SIP transaction\n   state machines associated
      with it.  The Max-Breadth mechanism limits\n   the number of branches that are
      active (those that have running\n   transaction state machines) at any given
      point in time.\n   Max-Breadth does not prevent forking.  It only limits the
      number of\n   concurrent parallel forked branches.  In particular, a Max-Breadth
      of\n   1 restricts a request to pure serial forking rather than restricting\n
      \  it from being forked at all.\n   A client receiving a 440 (Max-Breadth Exceeded)
      response can infer\n   that its request did not reach all possible destinations.
      \ Recovery\n   options are similar to those when receiving a 483 (Too Many Hops)\n
      \  response, and include affecting the routing decisions through\n   whatever
      mechanisms are appropriate to result in a less broad search,\n   or refining
      the request itself before submission to make the search\n   space smaller.\n"
    title: 5.1.  Overview
  - contents:
    - "5.2.  Examples\n    UAC                 Proxy A              Proxy B             Proxy
      C\n     | INVITE              |                    |                   |\n     |
      Max-Breadth: 60     | INVITE             |                   |\n     | Max-Forwards:
      70    | Max-Breadth: 30    |                   |\n     |-------------------->|
      Max-Forwards: 69   |                   |\n     |                     |------------------->|
      \                  |\n     |                     | INVITE             |                   |\n
      \    |                     | Max-Breadth: 30    |                   |\n     |
      \                    | Max-Forwards: 69   |                   |\n     |                     |--------------------------------------->|\n
      \    |                     |                    |                   |\n                             Parallel
      Forking\n    UAC                 Proxy A              Proxy B             Proxy
      C\n     | INVITE              |                    |                   |\n     |
      Max-Breadth: 60     | INVITE             |                   |\n     | Max-Forwards:
      70    | Max-Breadth: 60    |                   |\n     |-------------------->|
      Max-Forwards: 69   |                   |\n     |                     |------------------->|
      \                  |\n     |                     | some error response|                   |\n
      \    |                     |<-------------------|                   |\n     |
      \                    | INVITE             |                   |\n     |                     |
      Max-Breadth: 60    |                   |\n     |                     | Max-Forwards:
      69   |                   |\n     |                     |--------------------------------------->|\n
      \    |                     |                    |                   |\n                            Sequential
      Forking\n    UAC                 Proxy A              Proxy B             Proxy
      C\n     | INVITE              |                    |                   |\n     |
      Max-Breadth: 60     | INVITE             |                   |\n     | Max-Forwards:
      70    | Max-Breadth: 60    | INVITE            |\n     |-------------------->|
      Max-Forwards: 69   | Max-Breadth: 60   |\n     |                     |------------------->|
      Max-Forwards: 68  |\n     |                     |                    |------------------>|\n
      \    |                     |                    |                   |\n     |
      \                    |                    |                   |\n     |                     |
      \                   |                   |\n                                No
      Forking\n              MB == Max-Breadth               MF == Max-Forwards\n
      \                                   | MB: 4\n                                    |
      MF: 5\n                         MB: 2      P            MB: 2\n                         MF:
      4    /  \\           MF: 4\n                 +---------------+    +------------------+\n
      \        MB: 1   P    MB: 1                     MB: 1    P    MB: 1\n         MF:
      3 /  \\   MF: 3                     MF: 3  /  \\   MF: 3\n          +---+    +-------+
      \                    +----+    +-------+\n          P                P                     P
      \                P\n    MB: 1 |          MB: 1 |               MB: 1 |           MB:
      1 |\n    MF: 2 |          MF: 2 |               MF: 2 |           MF: 2 |\n
      \         P                P                     P                 P\n    MB:
      1 |          MB: 1 |               MB: 1 |           MB: 1 |\n    MF: 1 |          MF:
      1 |               MF: 1 |           MF: 1 |\n          P                P                     P
      \                P\n                                     .\n                                     .\n
      \                                    .\n               Max-Breadth and Max-Forwards
      Working Together\n"
    title: 5.2.  Examples
  - contents:
    - '5.3.  Formal Mechanism

      '
    - contents:
      - "5.3.1.  Max-Breadth Header Field\n   The Max-Breadth header field takes a
        single positive integer as its\n   value.  The Max-Breadth header field value
        takes no parameters.\n"
      title: 5.3.1.  Max-Breadth Header Field
    - contents:
      - "5.3.2.  Terminology\n   For each \"response context\" (see Section 16 of
        [RFC3261]) in a proxy,\n   this mechanism defines two positive integral values:
        Incoming Max-\n   Breadth and Outgoing Max-Breadth.  Incoming Max-Breadth
        is the value\n   in the Max-Breadth header field in the request that formed
        the\n   response context.  Outgoing Max-Breadth is the sum of the Max-Breadth\n
        \  header field values in all forwarded requests in the response context\n
        \  that have not received a final response.\n"
      title: 5.3.2.  Terminology
    - contents:
      - "5.3.3.  Proxy Behavior\n   If a SIP proxy receives a request with no Max-Breadth
        header field\n   value, it MUST add one, with a value that is RECOMMENDED
        to be 60.\n   Proxies MUST have a maximum allowable Incoming Max-Breadth value,\n
        \  which is RECOMMENDED to be 60.  If this maximum is exceeded in a\n   received
        request, the proxy MUST overwrite it with a value that\n   SHOULD be no greater
        than its allowable maximum.\n   All proxied requests MUST contain a single
        Max-Breadth header field\n   value.\n   SIP proxies MUST NOT allow the Outgoing
        Max-Breadth to exceed the\n   Incoming Max-Breadth in a given response context.\n
        \  If a SIP proxy determines a response context has insufficient\n   Incoming
        Max-Breadth to carry out a desired parallel fork, and the\n   proxy is unwilling/unable
        to compensate by forking serially or\n   sending a redirect, that proxy MUST
        return a 440 (Max-Breadth\n   Exceeded) response.\n   Notice that these requirements
        mean a proxy receiving a request with\n   a Max-Breadth of 1 can only fork
        serially, but it is not required to\n   fork at all -- it can return a 440
        instead.  Thus, this mechanism is\n   not a tool a user agent can use to force
        all proxies in the path of a\n   request to fork serially.\n   A SIP proxy
        MAY distribute Max-Breadth in an arbitrary fashion\n   between active branches.
        \ A proxy SHOULD NOT use a smaller amount of\n   Max-Breadth than was present
        in the original request unless the\n   Incoming Max-Breadth exceeded the proxy's
        maximum acceptable value.\n   A proxy MUST NOT decrement Max-Breadth for each
        hop or otherwise use\n   it to restrict the \"depth\" of a request's propagation.\n"
      - contents:
        - "5.3.3.1.  Reusing Max-Breadth\n   Because forwarded requests that have
          received a final response do not\n   count towards the Outgoing Max-Breadth,
          whenever a final response\n   arrives, the Max-Breadth that was used on
          that branch becomes\n   available for reuse.  Proxies SHOULD be prepared
          to reuse this Max-\n   Breadth in cases where there may be elements left
          in the target-set.\n"
        title: 5.3.3.1.  Reusing Max-Breadth
      title: 5.3.3.  Proxy Behavior
    - contents:
      - "5.3.4.  UAC Behavior\n   A User Agent Client (UAC) MAY place a Max-Breadth
        header field value\n   in outgoing requests.  If so, this value is RECOMMENDED
        to be 60.\n"
      title: 5.3.4.  UAC Behavior
    - contents:
      - "5.3.5.  UAS Behavior\n   This mechanism does not affect User Agent Server
        (UAS) behavior.  A\n   UAS receiving a request with a Max-Breadth header field
        will ignore\n   that field while processing the request.\n"
      title: 5.3.5.  UAS Behavior
    title: 5.3.  Formal Mechanism
  - contents:
    - '5.4.  Implementer Notes

      '
    - contents:
      - "5.4.1.  Treatment of CANCEL\n   Since CANCEL requests are never proxied,
        a Max-Breadth header field\n   value is meaningless in a CANCEL request.  Sending
        a CANCEL in no way\n   affects the Outgoing Max-Breadth in the associated
        INVITE response\n   context.  Receiving a CANCEL in no way affects the Incoming
        Max-\n   Breadth of the associated INVITE response context.\n"
      title: 5.4.1.  Treatment of CANCEL
    - contents:
      - "5.4.2.  Reclamation of Max-Breadth on 2xx Responses\n   Whether 2xx responses
        free up Max-Breadth is mostly a moot issue,\n   since proxies are forbidden
        to start new branches in this case.  But,\n   there is one caveat.  A proxy
        may receive multiple 2xx responses for\n   a single forwarded INVITE request.
        \ Also, [RFC2543] implementations\n   may send back a 6xx followed by a 2xx
        on the same branch.\n   Implementations that subtract from the Outgoing Max-Breadth
        when they\n   receive a 2xx response to an INVITE request must be careful
        to avoid\n   bugs caused by subtracting multiple times for a single branch.\n"
      title: 5.4.2.  Reclamation of Max-Breadth on 2xx Responses
    - contents:
      - "5.4.3.  Max-Breadth and Automaton UAs\n   Designers of automaton user agents
        (UAs) (including B2BUAs, gateways,\n   exploders, and any other element that
        programmatically sends requests\n   as a result of incoming SIP traffic) should
        consider whether Max-\n   Breadth limitations should be placed on outgoing
        requests.  For\n   example, it is reasonable to design B2BUAs to carry the
        Max-Breadth\n   value from incoming requests into requests that are sent as
        a result.\n   Also, it is reasonable to place Max-Breadth constraints on sets
        of\n   requests sent by exploders when they may be leveraged in an\n   amplification
        attack.\n"
      title: 5.4.3.  Max-Breadth and Automaton UAs
    title: 5.4.  Implementer Notes
  - contents:
    - "5.5.  Parallel and Sequential Forking\n   Inherent in the definition of this
      mechanism is the ability of a\n   proxy to reclaim apportioned Max-Breadth while
      forking sequentially.\n   The limitation on outgoing Max-Breadth is applied
      to concurrent\n   branches only.\n   For example, if a proxy receives a request
      with a Max-Breadth of 4\n   and has 8 targets to forward it to, that proxy may
      parallel fork to 4\n   of these targets initially (each with a Max-Breadth of
      1, totaling an\n   Outgoing Max-Breadth of 4).  If one of these transactions
      completes\n   with a failure response, the outgoing Max-Breadth drops to 3,\n
      \  allowing the proxy to forward to one of the 4 remaining targets\n   (again,
      with a Max-Breadth of 1).\n"
    title: 5.5.  Parallel and Sequential Forking
  - contents:
    - "5.6.  Max-Breadth Split Weight Selection\n   There are a variety of mechanisms
      for controlling the weight of each\n   fork branch.  Fork branches that are
      given more Max-Breadth are more\n   likely to complete quickly (because it is
      less likely that a proxy\n   down the line will be forced to fork sequentially).
      \ By the same\n   token, if it is known that a given branch will not fork later
      on, a\n   Max-Breadth of 1 may be assigned with no ill effect.  This would be\n
      \  appropriate, for example, if a proxy knows the branch is using the\n   SIP
      outbound extension [OUTBOUND].\n"
    title: 5.6.  Max-Breadth Split Weight Selection
  - contents:
    - "5.7.  Max-Breadth's Effect on Forking-Based Amplification Attacks\n   Max-Breadth
      limits the total number of active branches spawned by a\n   given request at
      any one time, while placing no constraint on the\n   distance (measured in hops)
      that the request can propagate. (i.e.,\n   receiving a request with a Max-Breadth
      of 1 means that any forking\n   must be sequential, not that forking is forbidden)\n
      \  This limits the effectiveness of any amplification attack that\n   leverages
      forking because the amount of state/bandwidth needed to\n   process the traffic
      at any given point in time is capped.\n"
    title: 5.7.  Max-Breadth's Effect on Forking-Based Amplification Attacks
  - contents:
    - "5.8.  Max-Breadth Header Field ABNF Definition\n   This specification extends
      the grammar for the Session Initiation\n   Protocol by adding an extension-header.
      \ The ABNF [RFC5234]\n   definition is as follows.\n   Max-Breadth  =  \"Max-Breadth\"
      HCOLON 1*DIGIT\n"
    title: 5.8.  Max-Breadth Header Field ABNF Definition
  title: 5.  Max-Breadth
- contents:
  - "6.  IANA Considerations\n   This specification registers a new SIP header field
    and a new SIP\n   response according to the processes defined in [RFC3261].\n"
  - contents:
    - "6.1.  Max-Breadth Header Field\n   This information appears in the Header Fields
      sub-registry of the SIP\n   Parameters registry.\n   RFC 5393 (this specification)\n
      \  Header Field Name: Max-Breadth\n   Compact Form: none\n"
    title: 6.1.  Max-Breadth Header Field
  - contents:
    - "6.2.  440 Max-Breadth Exceeded Response\n   This information appears in the
      Response Codes sub-registry of the\n   SIP Parameters registry.\n   Response
      code: 440\n   Default Reason Phrase: Max-Breadth Exceeded\n"
    title: 6.2.  440 Max-Breadth Exceeded Response
  title: 6.  IANA Considerations
- contents:
  - "7.  Security Considerations\n   This document is entirely about documenting and
    addressing a\n   vulnerability in SIP proxies as defined by RFC 3261 that can
    lead to\n   an exponentially growing message exchange attack.\n   The Max-Breadth
    mechanism defined here does not decrease the\n   aggregate traffic caused by the
    forking-loop attack.  It only serves\n   to spread the traffic caused by the attack
    over a longer period by\n   limiting the number of concurrent branches that are
    being processed\n   at the same time.  An attacker could pump multiple requests
    into a\n   network that uses the Max-Breadth mechanism and gradually build\n   traffic
    to unreasonable levels.  Deployments should monitor carefully\n   and react to
    gradual increases in the number of concurrent\n   outstanding transactions related
    to a given resource to protect\n   against this possibility.  Operators should
    anticipate being able to\n   temporarily disable any resources identified as being
    used in such an\n   attack.  A rapid increase in outstanding concurrent transactions\n
    \  system-wide may be an indication of the presence of this kind of\n   attack
    across many resources.  Deployments in which it is feasible\n   for an attacker
    to obtain a very large number of resources are\n   particularly at risk.  If detecting
    and intervening in each instance\n   of the attack is insufficient to reduce the
    load, overload may occur.\n   Implementers and operators are encouraged to follow
    the\n   recommendations being developed for handling overload conditions (see\n
    \  [REQS] and [DESIGN]).\n   Designers of protocol gateways should consider the
    implications of\n   this kind of attack carefully.  As an example, if a message
    transits\n   from a SIP network into the Public Switched Telephone Network (PSTN)\n
    \  and subsequently back into a SIP network, and information about the\n   history
    of the request on either side of the protocol translation is\n   lost, it becomes
    possible to construct loops that neither Max-\n   Forwards nor loop detection
    can protect against.  This, combined with\n   forking amplification on the SIP
    side of the loop, will result in an\n   attack as described in this document that
    the mechanisms here will\n   not abate, not even to the point of limiting the
    number of concurrent\n   messages in the attack.  These considerations are particularly\n
    \  important for designers of gateways from SIP to SIP (as found in\n   B2BUAs,
    for example).  Many existing B2BUA implementations are under\n   some pressure
    to hide as much information about the two sides\n   communicating with them as
    possible.  Implementers of such\n   implementations may be tempted to remove the
    data that might be used\n   by the loop-detection, Max-Forwards, or Max-Breadth
    mechanisms at\n   other points in the network, taking on the responsibility for\n
    \  detecting loops (or forms of this attack).  However, if two such\n   implementations
    are involved in the attack, neither will be able to\n   detect it.\n"
  - contents:
    - "7.1.  Alternate Solutions That Were Considered and Rejected\n   Alternative
      solutions that were discussed include:\n   Doing nothing - rely on suing the
      offender:   While systems that have\n      accounts have logs that can be mined
      to locate abusers, it isn't\n      clear that this provides a credible deterrent
      or defense against\n      the attack described in this document.  Systems that
      don't\n      recognize the situation and take corrective/preventative action\n
      \     are likely to experience failure of a magnitude that precludes\n      retrieval
      of the records documenting the setup of the attack.  (In\n      one scenario,
      the registrations can occur in a radically different\n      time period than
      the INVITE transaction.  The INVITE request\n      itself may have come from
      an innocent).  It's even possible that\n      the scenario may be set up unintentionally.
      \ Furthermore, for some\n      existing deployments, the cost and audit ability
      of an account is\n      simply an email address.  Finding someone to punish
      may be\n      impossible.  Finally, there are individuals who will not respond\n
      \     to any threat of legal action, and the effect of even a single\n      successful
      instance of this kind of attack would be devastating to\n      a service provider.\n
      \  Putting a smaller cap on Max-Forwards:   The effect of the attack is\n      exponential
      with respect to the initial Max-Forwards value.\n      Turning this value down
      limits the effect of the attack.  This\n      comes at the expense of severely
      limiting the reach of requests in\n      the network, possibly to the point
      that existing architectures\n      will begin to fail.\n   Disallowing registration
      bindings to arbitrary contacts:   The way\n      registration binding is currently
      defined is a key part of the\n      success of the kind of attack documented
      here.  The alternative of\n      limiting registration bindings to allow only
      binding to the\n      network element performing the registration, perhaps to
      the\n      extreme of ignoring bits provided in the Contact in favor of\n      transport
      artifacts observed in the registration request, has been\n      discussed (particularly
      in the context of the mechanisms being\n      defined in [OUTBOUND]).  Mechanisms
      like this may be considered\n      again in the future, but are currently insufficiently
      developed to\n      address the present threat.\n   Deprecate forking:   This
      attack does not exist in a system that\n      relies entirely on redirection
      and initiation of new requests by\n      the original endpoint.  Removing such
      a large architectural\n      component from the system at this time was deemed
      too extreme a\n      solution.\n   Don't reclaim breadth:  An alternative design
      of the Max-Breadth\n      mechanism that was considered and rejected was to
      not allow the\n      breadth from completed branches to be reused (see\n      Section
      5.3.3.1).  Under this alternative, an introduced request\n      would cause,
      at most, the initial value of Max-Breadth\n      transactions to be generated
      in the network.  While that approach\n      limits any variant of the amplification
      vulnerability described\n      here to a constant multiplier, it would dramatically
      change the\n      potential reach of requests, and there is belief that it would\n
      \     break existing deployments.\n"
    title: 7.1.  Alternate Solutions That Were Considered and Rejected
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgments\n   Thanks go to the implementers that subjected their code
    to this\n   scenario and helped analyze the results at SIPit 17.  Eric Rescorla\n
    \  provided guidance and text for the hash recommendation note.\n"
  title: 8.  Acknowledgments
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \              A., Peterson, J., Sparks, R., Handley, M., and E.\n               Schooler,
      \"SIP: Session Initiation Protocol\", RFC 3261,\n               June 2002.\n
      \  [RFC5234]   Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n               Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [DESIGN]    Hilt, V., \"Design Considerations
      for Session Initiation\n               Protocol (SIP) Overload Control\", Work
      in Progress,\n               July 2008.\n   [OUTBOUND]  Jennings, C. and R.
      Mahy, \"Managing Client Initiated\n               Connections in the Session
      Initiation Protocol (SIP)\",\n               Work in Progress, October 2008.\n
      \  [REQS]      Rosenberg, J., \"Requirements for Management of Overload\n               in
      the Session Initiation Protocol\", Work in Progress,\n               July 2008.\n
      \  [RFC1321]   Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n
      \              April 1992.\n   [RFC2543]   Handley, M., Schulzrinne, H., Schooler,
      E., and J.\n               Rosenberg, \"SIP: Session Initiation Protocol\",
      RFC 2543,\n               March 1999.\n   [RFC4960]   Stewart, R., \"Stream
      Control Transmission Protocol\",\n               RFC 4960, September 2007.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Authors' Addresses\n   Robert Sparks (editor)\n   Tekelec\n   17210 Campbell
    Road\n   Suite 250\n   Dallas, Texas  75254-4203\n   USA\n   EMail: RjS@nostrum.com\n
    \  Scott Lawrence\n   Nortel Networks, Inc.\n   600 Technology Park\n   Billerica,
    MA  01821\n   USA\n   Phone: +1 978 288 5508\n   EMail: scott.lawrence@nortel.com\n
    \  Alan Hawrylyshen\n   Ditech Networks Inc.\n   823 E. Middlefield Rd\n   Mountain
    View, CA  94043\n   USA\n   Phone: +1 650 623 1300\n   EMail: alan.ietf@polyphase.ca\n
    \  Byron Campen\n   Tekelec\n   17210 Campbell Road\n   Suite 250\n   Dallas,
    Texas  75254-4203\n   USA\n   EMail: bcampen@estacado.net\n"
  title: Authors' Addresses
