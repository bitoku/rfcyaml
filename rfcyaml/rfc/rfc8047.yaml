- contents:
  - '            Host Multihoming with the Host Identity Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines host multihoming extensions to the Host\n
    \  Identity Protocol (HIP), by leveraging protocol components defined\n   for
    host mobility.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8047.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction and Scope  . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Terminology and Conventions . . . . . . . . . . . . . .
    . . .   4\n   3.  Protocol Model  . . . . . . . . . . . . . . . . . . . . . .
    .   4\n   4.  Protocol Overview . . . . . . . . . . . . . . . . . . . . . .   4\n
    \    4.1.  Background  . . . . . . . . . . . . . . . . . . . . . . .   5\n     4.2.
    \ Usage Scenarios . . . . . . . . . . . . . . . . . . . . .   6\n       4.2.1.
    \ Multiple Addresses  . . . . . . . . . . . . . . . . .   6\n       4.2.2.  Multiple
    Security Associations  . . . . . . . . . . .   6\n       4.2.3.  Host Multihoming
    for Fault Tolerance  . . . . . . . .   7\n       4.2.4.  Host Multihoming for
    Load Balancing . . . . . . . . .   9\n       4.2.5.  Site Multihoming  . . . .
    . . . . . . . . . . . . . .  10\n       4.2.6.  Dual-Host Multihoming . . . .
    . . . . . . . . . . . .  10\n       4.2.7.  Combined Mobility and Multihoming
    . . . . . . . . . .  11\n       4.2.8.  Initiating the Protocol in R1, I2, or
    R2  . . . . . .  11\n       4.2.9.  Using LOCATOR_SETs across Addressing Realms
    . . . . .  13\n     4.3.  Interaction with Security Associations  . . . . . .
    . . .  13\n   5.  Processing Rules  . . . . . . . . . . . . . . . . . . . . .
    .  14\n     5.1.  Sending LOCATOR_SETs  . . . . . . . . . . . . . . . . . .  14\n
    \    5.2.  Handling Received LOCATOR_SETs  . . . . . . . . . . . . .  16\n     5.3.
    \ Verifying Address Reachability  . . . . . . . . . . . . .  18\n     5.4.  Changing
    the Preferred Locator  . . . . . . . . . . . . .  18\n   6.  Security Considerations
    . . . . . . . . . . . . . . . . . . .  19\n   7.  References  . . . . . . . .
    . . . . . . . . . . . . . . . . .  21\n     7.1.  Normative References  . . .
    . . . . . . . . . . . . . . .  21\n     7.2.  Informative References  . . . .
    . . . . . . . . . . . . .  21\n   Acknowledgments . . . . . . . . . . . . . .
    . . . . . . . . . . .  22\n   Authors' Addresses  . . . . . . . . . . . . . .
    . . . . . . . . .  22\n"
  title: Table of Contents
- contents:
  - "1.  Introduction and Scope\n   The Host Identity Protocol (HIP) [RFC7401] supports
    an architecture\n   that decouples the transport layer (TCP, UDP, etc.) from the\n
    \  internetworking layer (IPv4 and IPv6) by using public/private key\n   pairs,
    instead of IP addresses, as host identities.  When a host uses\n   HIP, the overlying
    protocol sublayers (e.g., transport-layer sockets\n   and Encapsulating Security
    Payload (ESP) Security Associations (SAs))\n   are instead bound to representations
    of these host identities, and\n   the IP addresses are only used for packet forwarding.
    \ However, each\n   host must also know at least one IP address at which its peers
    are\n   reachable.  Initially, these IP addresses are the ones used during\n   the
    HIP base exchange.\n   One consequence of such a decoupling is that new solutions
    to\n   network-layer mobility and host multihoming are possible.  Basic host\n
    \  mobility is defined in [RFC8046] and covers the case in which a host\n   has
    a single address and changes its network point of attachment\n   while desiring
    to preserve the HIP-enabled security association.\n   Host multihoming is somewhat
    of a dual case to host mobility, in\n   that, a host may simultaneously have more
    than one network point of\n   attachment.  There are potentially many variations
    of host\n   multihoming possible.  [RFC8046] specifies the format of the HIP\n
    \  parameter (LOCATOR_SET parameter) used to convey IP addressing\n   information
    between peers, the procedures for sending and processing\n   this parameter to
    enable basic host mobility, and procedures for an\n   address verification mechanism.
    \ The scope of this document\n   encompasses messaging and elements of procedure
    for some basic host\n   multihoming scenarios of interest.\n   Another variation
    of multihoming that has been heavily studied is\n   site multihoming.  Solutions
    for host multihoming in multihomed IPv6\n   networks have been specified by the
    IETF shim6 working group.  The\n   Shim6 protocol [RFC5533] bears many architectural
    similarities to\n   HIP, but there are differences in the security model and in
    the\n   protocol.\n   While HIP can potentially be used with transports other
    than the ESP\n   transport format [RFC7402], this document largely assumes the
    use of\n   ESP and leaves other transport formats for further study.\n   Finally,
    making underlying IP multihoming transparent to the\n   transport layer has implications
    on the proper response of transport\n   congestion control, path MTU selection,
    and Quality of Service (QoS).\n   Transport-layer mobility triggers, and the proper
    transport response\n   to a HIP multihoming address change, are outside the scope
    of this\n   document.\n   This specification relies on implementing Sections 4
    (\"LOCATOR_SET\n   Parameter Format\") and 5 (\"Processing Rules\") of [RFC8046]
    as a\n   starting point for this implementation.\n"
  title: 1.  Introduction and Scope
- contents:
  - "2.  Terminology and Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [RFC2119].\n   The following terms used in this document are defined in [RFC8046]:\n
    \  LOCATOR_SET, Locator, locator, Address, preferred locator, and\n   Credit-Based
    Authorization.\n"
  title: 2.  Terminology and Conventions
- contents:
  - "3.  Protocol Model\n   The protocol model for HIP support of host multihoming
    extends the\n   model for host mobility described in Section 3 of [RFC8046].  This\n
    \  section only highlights the differences.\n   In host multihoming, a host has
    multiple locators simultaneously\n   rather than sequentially, as in the case
    of mobility.  By using the\n   LOCATOR_SET parameter defined in [RFC8046], a host
    can inform its\n   peers of additional (multiple) locators at which it can be
    reached.\n   When multiple locators are available and announced to the peer, a\n
    \  host can designate a particular locator as a \"preferred\" locator,\n   meaning
    that the host prefers that its peer send packets to the\n   designated address
    before trying an alternative address.  Although\n   this document defines a basic
    mechanism for multihoming, it does not\n   define all possible policies and procedures,
    such as which locators\n   to choose when more than one is available, the operation
    of\n   simultaneous mobility and multihoming, source address selection\n   policies
    (beyond those specified in [RFC6724]), and the implications\n   of multihoming
    on transport protocols.\n"
  title: 3.  Protocol Model
- contents:
  - "4.  Protocol Overview\n   In this section, we briefly introduce a number of usage
    scenarios for\n   HIP multihoming.  These scenarios assume that HIP is being used
    with\n   the ESP transport [RFC7402], although other scenarios may be defined\n
    \  in the future.  To understand these usage scenarios, the reader\n   should
    be at least minimally familiar with the HIP protocol\n   specification [RFC7401],
    the use of the ESP transport format\n   [RFC7402], and the HIP mobility specification
    [RFC8046].  However,\n   for the (relatively) uninitiated reader, it is most important
    to keep\n   in mind that in HIP, the actual payload traffic is protected with\n
    \  ESP, and that the ESP Security Parameter Index (SPI) acts as an index\n   to
    the right host-to-host context.\n"
  - contents:
    - "4.1.  Background\n   The multihoming scenarios can be explained in contrast
      to the\n   non-multihoming case described in the base protocol specification\n
      \  [RFC7401].  We review the pertinent details here.  In the base\n   specification,
      when used with the ESP transport format, the HIP base\n   exchange will set
      up a single SA in each direction.  The IP addresses\n   associated with the
      SAs are the same as those used to convey the HIP\n   packets.  For data traffic,
      a security policy database (SPD) and\n   security association database (SAD)
      will likely exist, following the\n   IPsec architecture.  One distinction between
      HIP and IPsec, however,\n   is that the host IDs, and not the IP addresses,
      are conceptually used\n   as selectors in the SPD.  In the outbound direction,
      as a result of\n   SPD processing, when an outbound SA is selected, the correct
      IP\n   destination address for the peer must also be assigned.  Therefore,\n
      \  outbound SAs are conceptually associated with the peer IP address\n   that
      must be used as the destination IP address below the HIP layer.\n   In the inbound
      direction, the IP addresses may be used as selectors\n   in the SAD to look
      up the SA, but they are not strictly required; the\n   ESP SPI may be used alone.
      \ To summarize, in the non-multihoming\n   case, there is only one source IP
      address, one destination IP\n   address, one inbound SA, and one outbound SA.\n
      \  The HIP readdressing protocol [RFC8046] is an asymmetric protocol in\n   which
      a mobile or multihomed host informs a peer host about changes\n   of IP addresses
      on affected SPIs.  IP address and ESP SPI information\n   is carried in Locator
      fields in a HIP parameter called a LOCATOR_SET.\n   The HIP mobility specification
      [RFC8046] describes how the\n   LOCATOR_SET is carried in a HIP UPDATE packet.\n
      \  To summarize the mobility elements of procedure, as background for\n   multihoming,
      the basic idea of host mobility is to communicate a\n   local IP address change
      to the peer when active HIP-maintained SAs\n   are in use.  To do so, the IP
      address must be conveyed, any\n   association between the IP address and an
      inbound SA (via the SPI\n   index) may be conveyed, and protection against flooding
      attacks must\n   be ensured.  The association of an IP address with an SPI is\n
      \  performed by a Locator Type of \"1\", which is a concatenation of an\n   ESP
      SPI with an IP address.\n   An address verification method is specified in [RFC8046].
      \ It is\n   expected that addresses learned in multihoming scenarios also are\n
      \  subject to the same verification rules.  At times, the scenarios\n   describe
      addresses as being in either an ACTIVE, VERIFIED, or\n   DEPRECATED state.  From
      the perspective of a host, newly learned\n   addresses of the peer must be verified
      before put into active\n   service, and addresses removed by the peer are put
      into a deprecated\n   state.  Under limited conditions described in [RFC8046],
      an\n   UNVERIFIED address may be used.\n   With this background, we next describe
      an additional protocol to\n   facilitate scenarios in which one or both hosts
      have multiple IP\n   addresses available.  Increasingly, this is the common
      case with\n   network-connected hosts on the Internet.\n"
    title: 4.1.  Background
  - contents:
    - '4.2.  Usage Scenarios

      '
    - contents:
      - "4.2.1.  Multiple Addresses\n   Hosts may have multiple IP addresses within
        different address\n   families (IPv4 and IPv6) and scopes available to support
        HIP\n   messaging and HIP-enabled SAs.  The multiple addresses may be on a\n
        \  single network interface or multiple network interfaces.  It is\n   outside
        of the scope of this document to specify how a host decides\n   which of possibly
        multiple addresses may be used to support a HIP\n   association.  Some IP
        addresses may be held back from usage due to\n   privacy, security, or cost
        considerations.\n   When multiple IP addresses are shared with a peer, the
        procedures\n   described in the HIP mobility specification [RFC8046] allow
        for a\n   host to set a preferred locator (\"P\") bit, requesting that one
        of the\n   multiple addresses be preferred for control- or data-plane traffic.\n
        \  It is also permitted to leave the preferred bit unset for all\n   addresses,
        allowing the peer to make address selection decisions.\n   Hosts that use
        link-local addresses as source addresses in their HIP\n   handshakes may not
        be reachable by a mobile peer.  Such hosts SHOULD\n   provide a globally routable
        address either in the initial handshake\n   or via the LOCATOR_SET parameter.\n
        \  To support mobility, as described in the HIP mobility specification\n   [RFC8046],
        the LOCATOR_SET may be sent in a HIP UPDATE packet.  To\n   support multihoming,
        the LOCATOR_SET may also be sent in R1, I2, or\n   R2 packets defined in the
        HIP protocol specification [RFC7401].  The\n   reason to consider sending
        LOCATOR_SET parameters in base exchange\n   packets is to convey all usable
        addresses for fault-tolerance or\n   load-balancing considerations.\n"
      title: 4.2.1.  Multiple Addresses
    - contents:
      - "4.2.2.  Multiple Security Associations\n   When multiple addresses are available
        between peer hosts, a question\n   that arises is whether to use one or multiple
        SAs.  The intent of\n   this specification is to support different use cases
        but to leave the\n   policy decision to the hosts.\n   When one host has n
        addresses and the other host has m addresses, it\n   is possible to set up
        as many as (n * m) SAs in each direction.  In\n   such a case, every combination
        of source and destination IP addresses\n   would have a unique SA, and the
        possibility of the reordering of\n   datagrams on each SA will be lessened
        (ESP SAs may have an anti-\n   replay window [RFC4303] sensitive to reordering).
        \ However, the\n   downside to creating a mesh of SAs is the signaling overhead
        required\n   (for exchanging UPDATE messages conveying ESP_INFO parameters)
        and\n   the state maintenance required in the SPD/SAD.\n   For load balancing,
        when multiple paths are to be used in parallel,\n   it may make sense to create
        different SAs for different paths.  In\n   this use case, while a full mesh
        of 2 * (n * m) SAs may not be\n   required, it may be beneficial to create
        one SA pair per load-\n   balanced path to avoid anti-replay window issues.\n
        \  For fault tolerance, it is more likely that a single SA and multiple\n
        \  IP addresses associated with that SA can be used, and the alternative\n
        \  addresses can be used only upon failure detection of the addresses in\n
        \  use.  Techniques for path failure detection are outside the scope of\n
        \  this specification.  An implementation may use ICMP interactions,\n   reachability
        checks, or other means to detect the failure of a\n   locator.\n   In summary,
        whether and how a host decides to leverage additional\n   addresses in a load-balancing
        or fault-tolerant manner is outside the\n   scope of the specification (although
        the academic literature on\n   multipath TCP schedulers may provide guidance
        on how to design such a\n   policy).  However, in general, this document recommends
        that for\n   fault tolerance, it is likely sufficient to use a single SA pair
        for\n   all addresses, and for load balancing, to support a different SA pair\n
        \  for all active paths being balanced across.\n"
      title: 4.2.2.  Multiple Security Associations
    - contents:
      - "4.2.3.  Host Multihoming for Fault Tolerance\n   A (mobile or stationary)
        host may have more than one interface or\n   global address.  The host may
        choose to notify the peer host of the\n   additional interface or address
        by using the LOCATOR_SET parameter.\n   The LOCATOR_SET parameter may be included
        in an I2, R1, or R2 packet,\n   or it may be conveyed, after the base exchange
        completes in an UPDATE\n   packet.\n   When more than one locator is provided
        to the peer host, the host MAY\n   indicate which locator is preferred (the
        locator on which the host\n   prefers to receive traffic).  By default, the
        address that a host\n   uses in the base exchange is its preferred locator
        (for the address\n   family and address scope in use during the base exchange)
        until\n   indicated otherwise.  It may be the case that the host does not\n
        \  express any preferred locators.\n   In the multihoming case, the sender
        may also have multiple valid\n   locators from which to source traffic.  In
        practice, a HIP\n   association in a multihoming configuration may have both
        a preferred\n   peer locator and a preferred local locator.  The host should
        try to\n   use the peer's preferred locator unless policy or other circumstances\n
        \  prevent such usage.  A preferred local locator may be overridden if\n   source
        address selection rules on the destination address (peer's\n   preferred locator)
        suggest the use of a different source address.\n   Although the protocol may
        allow for configurations in which there is\n   an asymmetric number of SAs
        between the hosts (e.g., one host has two\n   interfaces and two inbound SAs,
        while the peer has one interface and\n   one inbound SA), it is suggested
        that inbound and outbound SAs be\n   created pairwise between hosts.  When
        an ESP_INFO arrives to rekey a\n   particular outbound SA, the corresponding
        inbound SA should also be\n   rekeyed at that time.  Section 4.3 discusses
        the interaction between\n   addresses and security associations in more detail.\n
        \  Consider the case of two hosts, one single-homed and one multihomed.\n
        \  The multihomed host may decide to inform the single-homed host about\n
        \  its other address(es).  It may choose to do so as follows.\n   If the multihomed
        host wishes to convey the additional address(es)\n   for fault tolerance,
        it should include all of its addresses in\n   Locator fields, indicating the
        Traffic Type, Locator Type, and\n   whether the locator is a preferred locator.
        \ If it wishes to bind any\n   particular address to an existing SPI, it may
        do so by using a\n   Locator Type of \"1\" as specified in the HIP mobility
        specification\n   [RFC8046].  It does not need to rekey the existing SA or
        request\n   additional SAs at this time.\n   Figure 1 illustrates this scenario.
        \ Note that the conventions for\n   message parameter notations in figures
        (use of parentheses and\n   brackets) is defined in Section 2.2 of [RFC7401].\n
        \    Multihomed Host                     Peer Host\n              UPDATE(LOCATOR_SET,
        SEQ)\n        ----------------------------------->\n              UPDATE(ACK)\n
        \       <-----------------------------------\n                   Figure 1:
        Basic Multihoming Scenario\n   In this scenario, the peer host associates
        the multiple addresses\n   with the SA pair between it and the multihomed
        host.  It may also\n   undergo address verification procedures to transition
        the addresses\n   to ACTIVE state.  For inbound data traffic, it may choose
        to use the\n   addresses along with the SPI as selectors.  For outbound data\n
        \  traffic, it must choose among the available addresses of the\n   multihomed
        host, considering the state of address verification\n   [RFC8046] of each
        address, and also considering available information\n   about whether an address
        is in a working state.\n"
      title: 4.2.3.  Host Multihoming for Fault Tolerance
    - contents:
      - "4.2.4.  Host Multihoming for Load Balancing\n   A multihomed host may decide
        to set up new SA pairs corresponding to\n   new addresses, for the purpose
        of load balancing.  The decision to\n   load balance and the mechanism for
        splitting load across multiple SAs\n   is out of scope of this document.  The
        scenario can be supported by\n   sending the LOCATOR_SET parameter with one
        or more ESP_INFO\n   parameters to initiate new ESP SAs.  To do this, the
        multihomed host\n   sends a LOCATOR_SET with an ESP_INFO, indicating the request
        for a\n   new SA by setting the OLD SPI value to zero and the NEW SPI value
        to\n   the newly created incoming SPI.  A Locator Type of \"1\" is used to\n
        \  associate the new address with the new SPI.  The LOCATOR_SET\n   parameter
        also contains a second Type \"1\" Locator, that of the\n   original address
        and SPI.  To simplify parameter processing and avoid\n   explicit protocol
        extensions to remove locators, each LOCATOR_SET\n   parameter MUST list all
        locators in use on a connection (a complete\n   listing of inbound locators
        and SPIs for the host).  The multihomed\n   host waits for a corresponding
        ESP_INFO (new outbound SA) from the\n   peer and an ACK of its own UPDATE.
        \ As in the mobility case, the peer\n   host must perform an address verification
        before actively using the\n   new address.\n   Figure 2 illustrates this scenario.\n
        \    Multihomed Host                     Peer Host\n              UPDATE(ESP_INFO,
        LOCATOR_SET, SEQ, [DIFFIE_HELLMAN])\n        ----------------------------------->\n
        \             UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)\n
        \       <-----------------------------------\n              UPDATE(ACK, ECHO_RESPONSE)\n
        \       ----------------------------------->\n               Figure 2: Host
        Multihoming for Load Balancing\n   In multihoming scenarios, it is important
        that hosts receiving\n   UPDATEs associate them correctly with the destination
        address used in\n   the packet carrying the UPDATE.  When processing inbound
        LOCATOR_SETs\n   that establish new security associations on an interface
        with\n   multiple addresses, a host uses the destination address of the UPDATE\n
        \  containing the LOCATOR_SET as the local address to which the\n   LOCATOR_SET
        plus ESP_INFO is targeted.  This is because hosts may\n   send UPDATEs with
        the same (locator) IP address to different peer\n   addresses -- this has
        the effect of creating multiple inbound SAs\n   implicitly affiliated with
        different peer source addresses.\n"
      title: 4.2.4.  Host Multihoming for Load Balancing
    - contents:
      - "4.2.5.  Site Multihoming\n   A host may have an interface that has multiple
        globally routable IP\n   addresses.  Such a situation may be a result of the
        site having\n   multiple upper Internet Service Providers, or just because
        the site\n   provides all hosts with both IPv4 and IPv6 addresses.  The host\n
        \  should stay reachable at all or any subset of the currently available\n
        \  global routable addresses, independent of how they are provided.\n   This
        case is handled the same as if there were different IP\n   addresses, described
        above in Sections 4.2.3 and 4.2.4.  Note that a\n   single interface may have
        addresses corresponding to site multihoming\n   while the host itself may
        also have multiple network interfaces.\n   Note that a host may be multihomed
        and mobile simultaneously, and\n   that a multihomed host may want to protect
        the location of some of\n   its interfaces while revealing the real IP address
        of some others.\n   This document does not present additional site multihoming
        extensions\n   to HIP; such extensions are for further study.\n"
      title: 4.2.5.  Site Multihoming
    - contents:
      - "4.2.6.  Dual-Host Multihoming\n   Consider the case in which both hosts are
        multihomed and would like\n   to notify the peer of an additional address
        after the base exchange\n   completes.  It may be the case that both hosts
        choose to simply\n   announce the second address in a LOCATOR_SET parameter
        using an\n   UPDATE message exchange.  It may also be the case that one or
        both\n   hosts decide to ask for new SA pairs to be created using the newly\n
        \  announced address.  In the case that both hosts request this, the\n   result
        will be a full mesh of SAs as depicted in Figure 3.  In such a\n   scenario,
        consider that host1, which used address addr1a in the base\n   exchange to
        set up SPI1a and SPI2a, wants to add address addr1b.  It\n   would send an
        UPDATE with LOCATOR_SET (containing the address addr1b)\n   to host2, using
        destination address addr2a, and a new ESP_INFO, and a\n   new set of SPIs
        would be added between hosts 1 and 2 (call them SPI1b\n   and SPI2b; not shown
        in the figure).  Next, consider host2 deciding\n   to add addr2b to the relationship.
        \ Host2 must select one of host1's\n   addresses towards which to initiate
        an UPDATE.  It may choose to\n   initiate an UPDATE to addr1a, addr1b, or
        both.  If it chooses to send\n   to both, then a full mesh (four SA pairs)
        of SAs would exist between\n   the two hosts.  This is the most general case;
        the protocol is\n   flexible enough to accommodate this choice.\n              -<-
        SPI1a --                         -- SPI2a ->-\n      host1 <              >
        addr1a <---> addr2a <              > host2\n              ->- SPI2a --                         --
        SPI1a -<-\n                             addr1b <---> addr2a  (second SA pair)\n
        \                            addr1a <---> addr2b  (third SA pair)\n                             addr1b
        <---> addr2b  (fourth SA pair)\n    Figure 3: Dual-Multihoming Case in which
        Each Host Uses LOCATOR_SET\n                          to Add a Second Address\n"
      title: 4.2.6.  Dual-Host Multihoming
    - contents:
      - "4.2.7.  Combined Mobility and Multihoming\n   Mobile hosts may be simultaneously
        mobile and multihomed, i.e., have\n   multiple mobile interfaces.  Furthermore,
        if the interfaces use\n   different access technologies, it is fairly likely
        that one of the\n   interfaces may appear stable (retain its current IP address)
        while\n   some others may experience mobility (undergo IP address change).\n
        \  The use of LOCATOR_SET plus ESP_INFO should be flexible enough to\n   handle
        most such scenarios, although more complicated scenarios have\n   not been
        studied so far.\n"
      title: 4.2.7.  Combined Mobility and Multihoming
    - contents:
      - "4.2.8.  Initiating the Protocol in R1, I2, or R2\n   A Responder host MAY
        include a LOCATOR_SET parameter in the R1 packet\n   that it sends to the
        Initiator.  This parameter MUST be protected by\n   the R1 signature.  If
        the R1 packet contains LOCATOR_SET parameters\n   with a new preferred locator,
        the Initiator SHOULD directly set the\n   new preferred locator to status
        ACTIVE without performing address\n   verification first, and it MUST send
        the I2 packet to the new\n   preferred locator.  The I1 destination address
        and the new preferred\n   locator may be identical.  All new non-preferred
        locators must still\n   undergo address verification once the base exchange
        completes.  It is\n   also possible for the host to send the LOCATOR_SET without
        any\n   preferred bits set, in which case the exchange will continue as\n
        \  normal and the newly learned addresses will be in an UNVERIFIED state\n
        \  at the initiator.\n            Initiator                                Responder\n
        \                             R1 with LOCATOR_SET\n                  <-----------------------------------\n
        \  record additional addresses\n   change Responder address\n                     I2
        sent to newly indicated preferred address\n                  ----------------------------------->\n
        \                                                    (process normally)\n
        \                                 R2\n                  <-----------------------------------\n
        \  (process normally, later verification of non-preferred locators)\n                   Figure
        4: LOCATOR_SET Inclusion in R1\n   An Initiator MAY include one or more LOCATOR_SET
        parameters in the I2\n   packet, independent of whether or not there was a
        LOCATOR_SET\n   parameter in the R1.  These parameters MUST be protected by
        the I2\n   signature.  Even if the I2 packet contains LOCATOR_SET parameters,\n
        \  the Responder MUST still send the R2 packet to the source address of\n
        \  the I2.  The new preferred locator, if set, SHOULD be identical to\n   the
        I2 source address.  If the I2 packet contains LOCATOR_SET\n   parameters,
        all new locators must undergo address verification as\n   usual, and the ESP
        traffic that subsequently follows should use the\n   preferred locator.\n
        \           Initiator                                Responder\n                             I2
        with LOCATOR_SET\n                  ----------------------------------->\n
        \                                                    (process normally)\n
        \                                            record additional addresses\n
        \                      R2 sent to source address of I2\n                  <-----------------------------------\n
        \  (process normally)\n                   Figure 5: LOCATOR_SET Inclusion
        in I2\n   The I1 and I2 may be arriving from different source addresses if
        the\n   LOCATOR_SET parameter is present in R1.  In this case,\n   implementations
        simultaneously using multiple pre-created R1s,\n   indexed by Initiator IP
        addresses, may inadvertently fail the puzzle\n   solution of I2 packets due
        to a perceived puzzle mismatch.  See, for\n   instance, the example in Appendix
        A of [RFC7401].  As a solution, the\n   Responder's puzzle indexing mechanism
        must be flexible enough to\n   accommodate the situation when R1 includes
        a LOCATOR_SET parameter.\n   Finally, the R2 may be used to carry the LOCATOR_SET
        parameter.  In\n   this case, the LOCATOR_SET is covered by the HIP_MAC_2
        and\n   HIP_SIGNATURE.  Including LOCATOR_SET in R2 as opposed to R1 may have\n
        \  some advantages when a host prefers not to divulge additional\n   locators
        until after the I2 is successfully processed.\n   When the LOCATOR_SET parameter
        is sent in an UPDATE packet, the\n   receiver will respond with an UPDATE
        acknowledgment.  When the\n   LOCATOR_SET parameter is sent in an R1, I2,
        or R2 packet, the base\n   exchange retransmission mechanism will confirm
        its successful\n   delivery.\n"
      title: 4.2.8.  Initiating the Protocol in R1, I2, or R2
    - contents:
      - "4.2.9.  Using LOCATOR_SETs across Addressing Realms\n   It is possible for
        HIP associations to use these mechanisms to\n   migrate their HIP associations
        and security associations from\n   addresses in the IPv4 addressing realm
        to IPv6, or vice versa.  It\n   may be possible for a state to arise in which
        both hosts are only\n   using locators in different addressing realms, but
        in such a case,\n   some type of mechanism for interworking between the different
        realms\n   must be employed; such techniques are outside the scope of the\n
        \  present text.\n"
      title: 4.2.9.  Using LOCATOR_SETs across Addressing Realms
    title: 4.2.  Usage Scenarios
  - contents:
    - "4.3.  Interaction with Security Associations\n   A host may establish any number
      of security associations (or SPIs)\n   with a peer.  The main purpose of having
      multiple SPIs with a peer is\n   to group the addresses into collections that
      are likely to experience\n   fate sharing, or to perform load balancing.\n   A
      basic property of HIP SAs is that the inbound IP address is not\n   used to
      look up the incoming SA.  However, the use of different\n   source and destination
      addresses typically leads to different paths,\n   with different latencies in
      the network, and if packets were to\n   arrive via an arbitrary destination
      IP address (or path) for a given\n   SPI, the reordering due to different latencies
      may cause some packets\n   to fall outside of the ESP anti-replay window.  For
      this reason, HIP\n   provides a mechanism to affiliate destination addresses
      with inbound\n   SPIs, when there is a concern that anti-replay windows might
      be\n   violated.  In this sense, we can say that a given inbound SPI has an\n
      \  \"affinity\" for certain inbound IP addresses, and this affinity is\n   communicated
      to the peer host.  Each physical interface SHOULD have a\n   separate SA, unless
      the ESP anti-replay window is extended or\n   disabled.\n   Moreover, even when
      the destination addresses used for a particular\n   SPI are held constant, the
      use of different source interfaces may\n   also cause packets to fall outside
      of the ESP anti-replay window,\n   since the path traversed is often affected
      by the source address or\n   interface used.  A host has no way to influence
      the source interface\n   on which a peer sends its packets on a given SPI.  A
      host SHOULD\n   consistently use the same source interface and address when
      sending\n   to a particular destination IP address and SPI.  For this reason,
      a\n   host may find it useful to change its SPI or at least reset its ESP\n
      \  anti-replay window when the peer host readdresses.\n"
    title: 4.3.  Interaction with Security Associations
  title: 4.  Protocol Overview
- contents:
  - "5.  Processing Rules\n   Basic processing rules for the LOCATOR_SET parameter
    are specified in\n   [RFC8046].  This document focuses on multihoming-specific
    rules.\n"
  - contents:
    - "5.1.  Sending LOCATOR_SETs\n   The decision of when to send a LOCATOR_SET,
      and which addresses to\n   include, is a local policy issue.  [RFC8046] recommends
      that a host\n   \"send a LOCATOR_SET whenever it recognizes a change of its
      IP\n   addresses in use on an active HIP association and [when it] assumes\n
      \  that the change is going to last at least for a few seconds.\"  It is\n   possible
      to delay the exposure of additional locators to the peer,\n   and to send data
      from previously unannounced locators, as might arise\n   in certain mobility
      or multihoming situations.\n   When a host decides to inform its peers about
      changes in its IP\n   addresses, it has to decide how to group the various addresses
      with\n   SPIs.  If hosts are deployed in an operational environment in which\n
      \  HIP-aware NATs and firewalls (that may perform parameter inspection)\n   exist,
      and different such devices may exist on different paths, hosts\n   may take
      that knowledge into consideration about how addresses are\n   grouped, and may
      send the same LOCATOR_SET in separate UPDATEs on the\n   different paths.  However,
      more detailed guidelines about how to\n   operate in the presence of such HIP-aware
      NATs and firewalls are a\n   topic for further study.  Since each SPI is associated
      with a\n   different security association, the grouping policy may also be based\n
      \  on ESP anti-replay protection considerations.  In the typical case,\n   simply
      basing the grouping on actual kernel-level physical and\n   logical interfaces
      may be the best policy.  The grouping policy is\n   outside of the scope of
      this document.\n   Locators corresponding to tunnel interfaces (e.g., IPsec
      tunnel\n   interfaces or Mobile IP home addresses) or other virtual interfaces\n
      \  MAY be announced in a LOCATOR_SET, but implementations SHOULD avoid\n   announcing
      such locators as preferred locators if more direct paths\n   may be obtained
      by instead preferring locators from non-tunneling\n   interfaces if such locators
      provide a more direct path to the HIP\n   peer.\n   [RFC8046] specifies that
      hosts MUST NOT announce broadcast or\n   multicast addresses in LOCATOR_SETs.
      \ Link-local addresses MAY be\n   announced to peers that are known to be neighbors
      on the same link,\n   such as when the IP destination address of a peer is also
      link local.\n   The announcement of link-local addresses in this case is a policy\n
      \  decision; link-local addresses used as preferred locators will create\n   reachability
      problems when the host moves to another link.  In any\n   case, link-local addresses
      MUST NOT be announced to a peer unless\n   that peer is known to be on the same
      link.\n   Once the host has decided on the groups and assignment of addresses\n
      \  to the SPIs, it creates a LOCATOR_SET parameter that serves as a\n   complete
      representation of the addresses and associated SPIs intended\n   for active
      use.  We now describe a few cases introduced in Section 4.\n   We assume that
      the Traffic Type for each locator is set to \"0\" (other\n   values for Traffic
      Type may be specified in documents that separate\n   the HIP control plane from
      data-plane traffic).  Other mobility and\n   multihoming cases are possible
      but are left for further\n   experimentation.\n   1.  Host multihoming (addition
      of an address).  We only describe the\n       simple case of adding an additional
      address to a (previously)\n       single-homed, non-mobile host.  The host MAY
      choose to simply\n       announce this address to the peer, for fault tolerance.
      \ To do\n       this, the multihomed host creates a LOCATOR_SET parameter\n
      \      including the existing address and SPI as a Type \"1\" Locator, and\n
      \      the new address as a Type \"0\" Locator.  The host sends this in an\n
      \      UPDATE message with the SEQ parameter, which is acknowledged by\n       the
      peer.\n   2.  The host MAY set up a new SA pair between this new address and
      an\n       address of the peer host.  To do this, the multihomed host\n       creates
      a new inbound SA and creates a new SPI.  For the outgoing\n       UPDATE message,
      it inserts an ESP_INFO parameter with an OLD SPI\n       field of \"0\", a NEW
      SPI field corresponding to the new SPI, and a\n       KEYMAT Index as selected
      by local policy.  The host adds to the\n       UPDATE message a LOCATOR_SET
      with two Type \"1\" Locators: the\n       original address and SPI active on
      the association, and the new\n       address and new SPI being added (with the
      SPI matching the NEW\n       SPI contained in the ESP_INFO).  The preferred
      bit SHOULD be set\n       depending on the policy to tell the peer host which
      of the two\n       locators is preferred.  The UPDATE also contains a SEQ parameter\n
      \      and optionally a DIFFIE_HELLMAN parameter and follows rekeying\n       procedures
      with respect to this new address.  The UPDATE message\n       SHOULD be sent
      to the peer's preferred address with a source\n       address corresponding
      to the new locator.\n   The sending of multiple LOCATOR_SETs is unsupported.
      \ Note that the\n   inclusion of LOCATOR_SET in an R1 packet requires the use
      of Type \"0\"\n   Locators since no SAs are set up at that point.\n"
    title: 5.1.  Sending LOCATOR_SETs
  - contents:
    - "5.2.  Handling Received LOCATOR_SETs\n   A host SHOULD be prepared to receive
      a LOCATOR_SET parameter in the\n   following HIP packets: R1, I2, R2, and UPDATE.\n
      \  This document describes sending both ESP_INFO and LOCATOR_SET\n   parameters
      in an UPDATE.  The ESP_INFO parameter is included when\n   there is a need to
      rekey or key a new SPI and can otherwise be\n   included for the possible benefit
      of HIP-aware middleboxes.  The\n   LOCATOR_SET parameter contains a complete
      map of the locators that\n   the host wishes to make or keep active for the
      HIP association.\n   In general, the processing of a LOCATOR_SET depends upon
      the packet\n   type in which it is included.  Here, we describe only the case
      in\n   which ESP_INFO is present and a single LOCATOR_SET and ESP_INFO are\n
      \  sent in an UPDATE message; other cases are for further study.  The\n   steps
      below cover each of the cases described in Section 5.1.\n   The processing of
      ESP_INFO and LOCATOR_SET parameters is intended to\n   be modular and support
      future generalization to the inclusion of\n   multiple ESP_INFO and/or multiple
      LOCATOR_SET parameters.  A host\n   SHOULD first process the ESP_INFO before
      the LOCATOR_SET, since the\n   ESP_INFO may contain a new SPI value mapped to
      an existing SPI, while\n   a Type \"1\" Locator will only contain a reference
      to the new SPI.\n   When a host receives a validated HIP UPDATE with a LOCATOR_SET
      and\n   ESP_INFO parameter, it processes the ESP_INFO as follows.  The\n   ESP_INFO
      parameter indicates whether an SA is being rekeyed, created,\n   deprecated,
      or just identified for the benefit of middleboxes.  The\n   host examines the
      OLD SPI and NEW SPI values in the ESP_INFO\n   parameter:\n   1.  (no rekeying)
      If the OLD SPI is equal to the NEW SPI and both\n       correspond to an existing
      SPI, the ESP_INFO is gratuitous\n       (provided for middleboxes), and no rekeying
      is necessary.\n   2.  (rekeying) If the OLD SPI indicates an existing SPI and
      the NEW\n       SPI is a different non-zero value, the existing SA is being\n
      \      rekeyed and the host follows HIP ESP rekeying procedures by\n       creating
      a new outbound SA with an SPI corresponding to the NEW\n       SPI, with no
      addresses bound to this SPI.  Note that locators in\n       the LOCATOR_SET
      parameter will reference this new SPI instead of\n       the old SPI.\n   3.
      \ (new SA) If the OLD SPI value is zero and the NEW SPI is a new\n       non-zero
      value, then a new SA is being requested by the peer.\n       This case is also
      treated like a rekeying event; the receiving\n       host must create a new
      SA and respond with an UPDATE ACK.\n   4.  (deprecating the SA) If the OLD SPI
      indicates an existing SPI and\n       the NEW SPI is zero, the SA is being deprecated
      and all locators\n       uniquely bound to the SPI are put into the DEPRECATED
      state.\n   If none of the above cases apply, a protocol error has occurred and\n
      \  the processing of the UPDATE is stopped.\n   Next, the locators in the LOCATOR_SET
      parameter are processed.  For\n   each locator listed in the LOCATOR_SET parameter,
      check that the\n   address therein is a legal unicast or anycast address.  That
      is, the\n   address MUST NOT be a broadcast or multicast address.  Note that
      some\n   implementations MAY accept addresses that indicate the local host,\n
      \  since it may be allowed that the host runs HIP with itself.\n   For each
      Type \"1\" address listed in the LOCATOR_SET parameter, the\n   host checks
      whether the address is already bound to the SPI\n   indicated.  If the address
      is already bound, its lifetime is updated.\n   If the status of the address
      is DEPRECATED, the status is changed to\n   UNVERIFIED.  If the address is not
      already bound, the address is\n   added, and its status is set to UNVERIFIED.
      \ If there exist remaining\n   addresses corresponding to the SPI that were
      NOT listed in the\n   LOCATOR_SET parameter, the host sets the status of such
      addresses to\n   DEPRECATED.\n   For each Type \"0\" address listed in the LOCATOR_SET
      parameter, if the\n   status of the address is DEPRECATED, or the address was
      not\n   previously known, the status is changed to UNVERIFIED.  The host MAY\n
      \  choose to associate this address with one or more SAs.  The\n   association
      with different SAs is a local policy decision, unless the\n   peer has indicated
      that the address is preferred, in which case the\n   address should be put into
      use on an SA that is prioritized in the\n   security policy database.\n   As
      a result, at the end of processing, the addresses listed in the\n   LOCATOR_SET
      parameter have a state of either UNVERIFIED or ACTIVE,\n   and any old addresses
      on the old SA not listed in the LOCATOR_SET\n   parameter have a state of DEPRECATED.\n
      \  Once the host has processed the locators, if the LOCATOR_SET\n   parameter
      contains a new preferred locator, the host SHOULD initiate\n   a change of the
      preferred locator.  This requires that the host first\n   verifies reachability
      of the associated address and only then changes\n   the preferred locator; see
      Section 5.4.\n   If a host receives a locator with an unsupported Locator Type,
      and\n   when such a locator is also declared to be the preferred locator for\n
      \  the peer, the host SHOULD send a NOTIFY error with a Notify Message\n   Type
      of LOCATOR_TYPE_UNSUPPORTED, with the Notification Data field\n   containing
      the locator(s) that the receiver failed to process.\n   Otherwise, a host MAY
      send a NOTIFY error if a (non-preferred)\n   locator with an unsupported Locator
      Type is received in a LOCATOR_SET\n   parameter.\n"
    title: 5.2.  Handling Received LOCATOR_SETs
  - contents:
    - "5.3.  Verifying Address Reachability\n   Address verification is defined in
      [RFC8046].\n   When address verification is in progress for a new preferred
      locator,\n   the host SHOULD select a different locator listed as ACTIVE, if
      one\n   such locator is available, to continue communications until address\n
      \  verification completes.  Alternatively, the host MAY use the new\n   preferred
      locator while in UNVERIFIED status to the extent Credit-\n   Based Authorization
      permits.  Credit-Based Authorization is explained\n   in [RFC8046].  Once address
      verification succeeds, the status of the\n   new preferred locator changes to
      ACTIVE.\n"
    title: 5.3.  Verifying Address Reachability
  - contents:
    - "5.4.  Changing the Preferred Locator\n   A host MAY want to change the preferred
      outgoing locator for\n   different reasons, e.g., because traffic information
      or ICMP error\n   messages indicate that the currently used preferred address
      may have\n   become unreachable.  Another reason may be due to receiving a\n
      \  LOCATOR_SET parameter that has the preferred bit set.\n   To change the preferred
      locator, the host initiates the following\n   procedure:\n   1.  If the new
      preferred locator has ACTIVE status, the preferred\n       locator is changed
      and the procedure succeeds.\n   2.  If the new preferred locator has UNVERIFIED
      status, the host\n       starts to verify its reachability.  The host SHOULD
      use a\n       different locator listed as ACTIVE until address verification\n
      \      completes if one such locator is available.  Alternatively, the\n       host
      MAY use the new preferred locator, even though in UNVERIFIED\n       status,
      to the extent Credit-Based Authorization permits.  Once\n       address verification
      succeeds, the status of the new preferred\n       locator changes to ACTIVE,
      and its use is no longer governed by\n       Credit-Based Authorization.\n   3.
      \ If the peer host has not indicated a preference for any address,\n       then
      the host picks one of the peer's ACTIVE addresses randomly\n       or according
      to policy.  This case may arise if, for example,\n       ICMP error messages
      that deprecate the preferred locator arrive,\n       but the peer has not yet
      indicated a new preferred locator.\n   4.  If the new preferred locator has
      DEPRECATED status and there is\n       at least one non-deprecated address,
      the host selects one of the\n       non-deprecated addresses as a new preferred
      locator and\n       continues.  If the selected address is UNVERIFIED, the address\n
      \      verification procedure described above will apply.\n"
    title: 5.4.  Changing the Preferred Locator
  title: 5.  Processing Rules
- contents:
  - "6.  Security Considerations\n   This document extends the scope of host mobility
    solutions defined in\n   [RFC8046] to also include host multihoming, and as a
    result, many of\n   the same security considerations for mobility also pertain
    to\n   multihoming.  In particular, [RFC8046] describes how HIP host\n   mobility
    is resistant to different types of impersonation attacks and\n   denial-of-service
    (DoS) attacks.\n   The security considerations for this document are similar to
    those of\n   [RFC8046] because the strong authentication capabilities for mobility\n
    \  also carry over to end-host multihoming.  [RFC4218] provides a threat\n   analysis
    for IPv6 multihoming, and the remainder of this section\n   first describes how
    HIP host multihoming addresses those previously\n   described threats, and then
    it discusses some additional security\n   considerations.\n   The high-level threats
    discussed in [RFC4218] involve redirection\n   attacks for the purposes of packet
    recording, data manipulation, and\n   availability.  There are a few types of
    attackers to consider:\n   on-path attackers, off-path attackers, and malicious
    hosts.\n   [RFC4218] also makes the comment that in identifier/locator split\n
    \  solutions such as HIP, application security mechanisms should be tied\n   to
    the identifier, not the locator, and attacks on the identifier\n   mechanism and
    on the mechanism binding locators to the identifier are\n   of concern.  This
    document does not consider the former issue\n   (application-layer security bindings)
    to be within scope.  The latter\n   issue (locator bindings to identifier) is
    directly addressed by the\n   cryptographic protections of the HIP protocol, in
    that locators\n   associated to an identifier are listed in HIP packets that are
    signed\n   using the identifier key.\n   Section 3.1 of [RFC4218] lists several
    classes of security\n   configurations in use in the Internet.  HIP maps to the
    fourth\n   (strong identifier) and fifth (\"leap-of-faith\") categories, the\n
    \  latter being associated with the optional opportunistic mode of HIP\n   operation.
    \ The remainder of Section 3 describes existing security\n   problems in the Internet
    and comments that the goal of a multihoming\n   solution is not to solve them
    specifically but rather not to make any\n   of them worse.  HIP multihoming should
    not increase the severity of\n   the identified risks.  One concern for both HIP
    mobility and\n   multihoming is the susceptibility of the mechanisms to misuse\n
    \  flooding-based redirections due to a malicious host.  The mechanisms\n   described
    in [RFC8046] for address verification are important in this\n   regard.\n   Regarding
    the new types of threats introduced by multihoming\n   (Section 4 of [RFC4218]),
    HIP multihoming should not introduce new\n   concerns.  Classic and premeditated
    redirection are prevented by the\n   strong authentication in HIP messages.  Third-party
    DoS attacks are\n   prevented by the address verification mechanism.  Replay attacks
    can\n   be avoided via use of replay protection in ESP SAs.  In addition,\n   accepting
    packets from unknown locators is protected by either the\n   strong authentication
    in the HIP control packets or by the ESP-based\n   encryption in use for data
    packets.\n   The HIP mechanisms are designed to limit the ability to introduce
    DoS\n   on the mechanisms themselves (Section 7 of [RFC4218]).  Care is taken\n
    \  in the HIP base exchange to avoid creating state or performing much\n   work
    before hosts can authenticate one another.  A malicious host\n   involved in HIP
    multihoming with another host might attempt to misuse\n   the mechanisms for multihoming
    by, for instance, increasing the state\n   required or inducing a resource limitation
    attack by sending too many\n   candidate locators to the peer host.  Therefore,
    implementations\n   supporting the multihoming extensions should consider avoiding\n
    \  accepting large numbers of peer locators and rate limiting any UPDATE\n   messages
    being exchanged.\n   The exposure of a host's IP addresses through HIP mobility
    and\n   multihoming extensions may raise the following privacy concern.  The\n
    \  administrator of a host may be trying to hide its location in some\n   context
    through the use of a VPN or other virtual interfaces.\n   Similar privacy issues
    also arise in other frameworks such as WebRTC\n   and are not specific to HIP.
    \ Implementations SHOULD provide a\n   mechanism to allow the host administrator
    to block the exposure of\n   selected addresses or address ranges.\n   Finally,
    some implementations of VPN tunneling have experienced\n   instances of 'leakage'
    of flows that were intended to have been\n   protected by a security tunnel but
    are instead sent in the clear,\n   perhaps because some of the addresses used
    fall outside of the range\n   of addresses configured for the tunnel in the security
    policy or\n   association database.  Implementors are advised to take steps to\n
    \  ensure that the usage of multiple addresses between hosts does not\n   cause
    accidental leakage of some data session traffic outside of the\n   ESP-protected
    envelope.\n"
  title: 6.  Security Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,\n              \"Default
      Address Selection for Internet Protocol Version 6\n              (IPv6)\", RFC
      6724, DOI 10.17487/RFC6724, September 2012,\n              <http://www.rfc-editor.org/info/rfc6724>.\n
      \  [RFC7401]  Moskowitz, R., Ed., Heer, T., Jokela, P., and T.\n              Henderson,
      \"Host Identity Protocol Version 2 (HIPv2)\",\n              RFC 7401, DOI 10.17487/RFC7401,
      April 2015,\n              <http://www.rfc-editor.org/info/rfc7401>.\n   [RFC7402]
      \ Jokela, P., Moskowitz, R., and J. Melen, \"Using the\n              Encapsulating
      Security Payload (ESP) Transport Format with\n              the Host Identity
      Protocol (HIP)\", RFC 7402,\n              DOI 10.17487/RFC7402, April 2015,\n
      \             <http://www.rfc-editor.org/info/rfc7402>.\n   [RFC8046]  Henderson,
      T., Ed., Vogt, C., and J. Arkko, \"Host Mobility\n              with the Host
      Identity Protocol\", RFC 8046,\n              DOI 10.17487/RFC8046, February
      2017,\n              <http://www.rfc-editor.org/info/rfc8046>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [RFC4218]  Nordmark, E. and T. Li, \"Threats
      Relating to IPv6\n              Multihoming Solutions\", RFC 4218, DOI 10.17487/RFC4218,\n
      \             October 2005, <http://www.rfc-editor.org/info/rfc4218>.\n   [RFC4303]
      \ Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n              RFC
      4303, DOI 10.17487/RFC4303, December 2005,\n              <http://www.rfc-editor.org/info/rfc4303>.\n
      \  [RFC5533]  Nordmark, E. and M. Bagnulo, \"Shim6: Level 3 Multihoming\n              Shim
      Protocol for IPv6\", RFC 5533, DOI 10.17487/RFC5533,\n              June 2009,
      <http://www.rfc-editor.org/info/rfc5533>.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Acknowledgments\n   This document contains content that was originally included
    in RFC\n   5206.  Pekka Nikander and Jari Arkko originated RFC 5206, and\n   Christian
    Vogt and Thomas Henderson (editor) later joined as\n   coauthors.  Also in RFC
    5206, Greg Perkins contributed the initial\n   draft of the security section,
    and Petri Jokela was a coauthor of the\n   initial individual submission.\n   The
    authors thank Miika Komu, Mika Kousa, Jeff Ahrenholz, and Jan\n   Melen for many
    improvements to the document.  Concepts from a paper\n   on host multihoming across
    address families, by Samu Varjonen, Miika\n   Komu, and Andrei Gurtov, contributed
    to this revised specification.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Thomas R. Henderson (editor)\n   University of Washington\n
    \  Campus Box 352500\n   Seattle, WA\n   United States of America\n   Email: tomhend@u.washington.edu\n
    \  Christian Vogt\n   Independent\n   3473 North First Street\n   San Jose, CA
    \ 95134\n   United States of America\n   Email: mail@christianvogt.net\n   Jari
    Arkko\n   Ericsson\n   Jorvas,  FIN-02420\n   Finland\n   Phone: +358 40 5079256\n
    \  Email: jari.arkko@piuha.net\n"
  title: Authors' Addresses
