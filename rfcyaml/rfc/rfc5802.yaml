- contents:
  - "       Salted Challenge Response Authentication Mechanism (SCRAM)\n                      SASL
    and GSS-API Mechanisms\n"
  title: __initial_text__
- contents:
  - "Abstract\n   The secure authentication mechanism most widely deployed and used
    by\n   Internet application protocols is the transmission of clear-text\n   passwords
    over a channel protected by Transport Layer Security (TLS).\n   There are some
    significant security concerns with that mechanism,\n   which could be addressed
    by the use of a challenge response\n   authentication mechanism protected by TLS.
    \ Unfortunately, the\n   challenge response mechanisms presently on the standards
    track all\n   fail to meet requirements necessary for widespread deployment, and\n
    \  have had success only in limited use.\n   This specification describes a family
    of Simple Authentication and\n   Security Layer (SASL; RFC 4422) authentication
    mechanisms called the\n   Salted Challenge Response Authentication Mechanism (SCRAM),
    which\n   addresses the security concerns and meets the deployability\n   requirements.
    \ When used in combination with TLS or an equivalent\n   security layer, a mechanism
    from this family could improve the status\n   quo for application protocol authentication
    and provide a suitable\n   choice for a mandatory-to-implement mechanism for future
    application\n   protocol standards.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5802.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Conventions Used in This Document ...............................5\n      2.1.
    Terminology ................................................5\n      2.2. Notation
    ...................................................6\n   3. SCRAM Algorithm Overview
    ........................................7\n   4. SCRAM Mechanism Names ...........................................8\n
    \  5. SCRAM Authentication Exchange ...................................9\n      5.1.
    SCRAM Attributes ..........................................10\n      5.2. Compliance
    with SASL Mechanism Requirements ...............13\n   6. Channel Binding ................................................14\n
    \     6.1. Default Channel Binding ...................................15\n   7.
    Formal Syntax ..................................................15\n   8. SCRAM
    as a GSS-API Mechanism ...................................19\n      8.1. GSS-API
    Principal Name Types for SCRAM ....................19\n      8.2. GSS-API Per-Message
    Tokens for SCRAM ......................20\n      8.3. GSS_Pseudo_random() for
    SCRAM .............................20\n   9. Security Considerations ........................................20\n
    \  10. IANA Considerations ...........................................22\n   11.
    Acknowledgements ..............................................23\n   12. References
    ....................................................24\n      12.1. Normative
    References .....................................24\n      12.2. Normative References
    for GSS-API Implementors ............24\n      12.3. Informative References ...................................25\n
    \  Appendix A. Other Authentication Mechanisms .......................27\n   Appendix
    B. Design Motivations ....................................27\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This specification describes a family of authentication
    mechanisms\n   called the Salted Challenge Response Authentication Mechanism (SCRAM)\n
    \  which addresses the requirements necessary to deploy a challenge-\n   response
    mechanism more widely than past attempts (see Appendix A and\n   Appendix B).
    \ When used in combination with Transport Layer Security\n   (TLS; see [RFC5246])
    or an equivalent security layer, a mechanism\n   from this family could improve
    the status quo for application\n   protocol authentication and provide a suitable
    choice for a\n   mandatory-to-implement mechanism for future application protocol\n
    \  standards.\n   For simplicity, this family of mechanisms does not presently
    include\n   negotiation of a security layer [RFC4422].  It is intended to be used\n
    \  with an external security layer such as that provided by TLS or SSH,\n   with
    optional channel binding [RFC5056] to the external security\n   layer.\n   SCRAM
    is specified herein as a pure Simple Authentication and\n   Security Layer (SASL)
    [RFC4422] mechanism, but it conforms to the new\n   bridge between SASL and the
    Generic Security Service Application\n   Program Interface (GSS-API) called \"GS2\"
    [RFC5801].  This means that\n   this document defines both, a SASL mechanism and
    a GSS-API mechanism.\n   SCRAM provides the following protocol features:\n   o
    \ The authentication information stored in the authentication\n      database
    is not sufficient by itself to impersonate the client.\n      The information
    is salted to prevent a pre-stored dictionary\n      attack if the database is
    stolen.\n   o  The server does not gain the ability to impersonate the client
    to\n      other servers (with an exception for server-authorized proxies).\n   o
    \ The mechanism permits the use of a server-authorized proxy without\n      requiring
    that proxy to have super-user rights with the back-end\n      server.\n   o  Mutual
    authentication is supported, but only the client is named\n      (i.e., the server
    has no name).\n   o  When used as a SASL mechanism, SCRAM is capable of transporting\n
    \     authorization identities (see [RFC4422], Section 2) from the\n      client
    to the server.\n   A separate document defines a standard LDAPv3 [RFC4510] attribute\n
    \  that enables storage of the SCRAM authentication information in LDAP.\n   See
    [RFC5803].\n   For an in-depth discussion of why other challenge response mechanisms\n
    \  are not considered sufficient, see Appendix A.  For more information\n   about
    the motivations behind the design of this mechanism, see\n   Appendix B.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n   Formal syntax is defined by [RFC5234] including the core rules\n
    \  defined in Appendix B of [RFC5234].\n   Example lines prefaced by \"C:\" are
    sent by the client and ones\n   prefaced by \"S:\" by the server.  If a single
    \"C:\" or \"S:\" label\n   applies to multiple lines, then the line breaks between
    those lines\n   are for editorial clarity only, and are not part of the actual\n
    \  protocol exchange.\n"
  - contents:
    - "2.1.  Terminology\n   This document uses several terms defined in [RFC4949]
      (\"Internet\n   Security Glossary\") including the following: authentication,\n
      \  authentication exchange, authentication information, brute force,\n   challenge-response,
      cryptographic hash function, dictionary attack,\n   eavesdropping, hash result,
      keyed hash, man-in-the-middle, nonce,\n   one-way encryption function, password,
      replay attack, and salt.\n   Readers not familiar with these terms should use
      that glossary as a\n   reference.\n   Some clarifications and additional definitions
      follow:\n   o  Authentication information: Information used to verify an identity\n
      \     claimed by a SCRAM client.  The authentication information for a\n      SCRAM
      identity consists of salt, iteration count, \"StoredKey\" and\n      \"ServerKey\"
      (as defined in the algorithm overview) for each\n      supported cryptographic
      hash function.\n   o  Authentication database: The database used to look up
      the\n      authentication information associated with a particular identity.\n
      \     For application protocols, LDAPv3 (see [RFC4510]) is frequently\n      used
      as the authentication database.  For network-level protocols\n      such as
      PPP or 802.11x, the use of RADIUS [RFC2865] is more\n      common.\n   o  Base64:
      An encoding mechanism defined in [RFC4648] that converts\n      an octet string
      input to a textual output string that can be\n      easily displayed to a human.
      \ The use of base64 in SCRAM is\n      restricted to the canonical form with
      no whitespace.\n   o  Octet: An 8-bit byte.\n   o  Octet string: A sequence
      of 8-bit bytes.\n   o  Salt: A random octet string that is combined with a password\n
      \     before applying a one-way encryption function.  This value is used\n      to
      protect passwords that are stored in an authentication\n      database.\n"
    title: 2.1.  Terminology
  - contents:
    - "2.2.  Notation\n   The pseudocode description of the algorithm uses the following\n
      \  notations:\n   o  \":=\": The variable on the left-hand side represents the
      octet\n      string resulting from the expression on the right-hand side.\n
      \  o  \"+\": Octet string concatenation.\n   o  \"[ ]\": A portion of an expression
      enclosed in \"[\" and \"]\" may not\n      be included in the result under some
      circumstances.  See the\n      associated text for a description of those circumstances.\n
      \  o  Normalize(str): Apply the SASLprep profile [RFC4013] of the\n      \"stringprep\"
      algorithm [RFC3454] as the normalization algorithm to\n      a UTF-8 [RFC3629]
      encoded \"str\".  The resulting string is also in\n      UTF-8.  When applying
      SASLprep, \"str\" is treated as a \"stored\n      strings\", which means that
      unassigned Unicode codepoints are\n      prohibited (see Section 7 of [RFC3454]).
      \ Note that\n      implementations MUST either implement SASLprep or disallow
      use of\n      non US-ASCII Unicode codepoints in \"str\".\n   o  HMAC(key, str):
      Apply the HMAC keyed hash algorithm (defined in\n      [RFC2104]) using the
      octet string represented by \"key\" as the key\n      and the octet string \"str\"
      as the input string.  The size of the\n      result is the hash result size
      for the hash function in use.  For\n      example, it is 20 octets for SHA-1
      (see [RFC3174]).\n   o  H(str): Apply the cryptographic hash function to the
      octet string\n      \"str\", producing an octet string as a result.  The size
      of the\n      result depends on the hash result size for the hash function in\n
      \     use.\n   o  XOR: Apply the exclusive-or operation to combine the octet
      string\n      on the left of this operator with the octet string on the right
      of\n      this operator.  The length of the output and each of the two\n      inputs
      will be the same for this use.\n   o  Hi(str, salt, i):\n     U1   := HMAC(str,
      salt + INT(1))\n     U2   := HMAC(str, U1)\n     ...\n     Ui-1 := HMAC(str,
      Ui-2)\n     Ui   := HMAC(str, Ui-1)\n     Hi := U1 XOR U2 XOR ... XOR Ui\n      where
      \"i\" is the iteration count, \"+\" is the string concatenation\n      operator,
      and INT(g) is a 4-octet encoding of the integer g, most\n      significant octet
      first.\n      Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n      pseudorandom
      function (PRF) and with dkLen == output length of\n      HMAC() == output length
      of H().\n"
    title: 2.2.  Notation
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  SCRAM Algorithm Overview\n   The following is a description of a full, uncompressed
    SASL SCRAM\n   authentication exchange.  Nothing in SCRAM prevents either sending\n
    \  the client-first message with the SASL authentication request defined\n   by
    an application protocol (\"initial client response\"), or sending\n   the server-final
    message as additional data of the SASL outcome of\n   authentication exchange
    defined by an application protocol.  See\n   [RFC4422] for more details.\n   Note
    that this section omits some details, such as client and server\n   nonces.  See
    Section 5 for more details.\n   To begin with, the SCRAM client is in possession
    of a username and\n   password (*) (or a ClientKey/ServerKey, or SaltedPassword).
    \ It sends\n   the username to the server, which retrieves the corresponding\n
    \  authentication information, i.e., a salt, StoredKey, ServerKey, and\n   the
    iteration count i.  (Note that a server implementation may choose\n   to use the
    same iteration count for all accounts.)  The server sends\n   the salt and the
    iteration count to the client, which then computes\n   the following values and
    sends a ClientProof to the server:\n   (*) Note that both the username and the
    password MUST be encoded in\n   UTF-8 [RFC3629].\n   Informative Note: Implementors
    are encouraged to create test cases\n   that use both usernames and passwords
    with non-ASCII codepoints.  In\n   particular, it's useful to test codepoints
    whose \"Unicode\n   Normalization Form C\" and \"Unicode Normalization Form KC\"
    are\n   different.  Some examples of such codepoints include Vulgar Fraction\n
    \  One Half (U+00BD) and Acute Accent (U+00B4).\n     SaltedPassword  := Hi(Normalize(password),
    salt, i)\n     ClientKey       := HMAC(SaltedPassword, \"Client Key\")\n     StoredKey
    \      := H(ClientKey)\n     AuthMessage     := client-first-message-bare + \",\"
    +\n                        server-first-message + \",\" +\n                        client-final-message-without-proof\n
    \    ClientSignature := HMAC(StoredKey, AuthMessage)\n     ClientProof     :=
    ClientKey XOR ClientSignature\n     ServerKey       := HMAC(SaltedPassword, \"Server
    Key\")\n     ServerSignature := HMAC(ServerKey, AuthMessage)\n   The server authenticates
    the client by computing the ClientSignature,\n   exclusive-ORing that with the
    ClientProof to recover the ClientKey\n   and verifying the correctness of the
    ClientKey by applying the hash\n   function and comparing the result to the StoredKey.
    \ If the ClientKey\n   is correct, this proves that the client has access to the
    user's\n   password.\n   Similarly, the client authenticates the server by computing
    the\n   ServerSignature and comparing it to the value sent by the server.  If\n
    \  the two are equal, it proves that the server had access to the user's\n   ServerKey.\n
    \  The AuthMessage is computed by concatenating messages from the\n   authentication
    exchange.  The format of these messages is defined in\n   Section 7.\n"
  title: 3.  SCRAM Algorithm Overview
- contents:
  - "4.  SCRAM Mechanism Names\n   A SCRAM mechanism name is a string \"SCRAM-\" followed
    by the\n   uppercased name of the underlying hash function taken from the IANA\n
    \  \"Hash Function Textual Names\" registry (see http://www.iana.org),\n   optionally
    followed by the suffix \"-PLUS\" (see below).  Note that\n   SASL mechanism names
    are limited to 20 octets, which means that only\n   hash function names with lengths
    shorter or equal to 9 octets\n   (20-length(\"SCRAM-\")-length(\"-PLUS\") can
    be used.  For cases when the\n   underlying hash function name is longer than
    9 octets, an alternative\n   9-octet (or shorter) name can be used to construct
    the corresponding\n   SCRAM mechanism name, as long as this alternative name doesn't\n
    \  conflict with any other hash function name from the IANA \"Hash\n   Function
    Textual Names\" registry.  In order to prevent future\n   conflict, such alternative
    names SHOULD be registered in the IANA\n   \"Hash Function Textual Names\" registry.\n
    \  For interoperability, all SCRAM clients and servers MUST implement\n   the
    SCRAM-SHA-1 authentication mechanism, i.e., an authentication\n   mechanism from
    the SCRAM family that uses the SHA-1 hash function as\n   defined in [RFC3174].\n
    \  The \"-PLUS\" suffix is used only when the server supports channel\n   binding
    to the external channel.  If the server supports channel\n   binding, it will
    advertise both the \"bare\" and \"plus\" versions of\n   whatever mechanisms it
    supports (e.g., if the server supports only\n   SCRAM with SHA-1, then it will
    advertise support for both SCRAM-SHA-1\n   and SCRAM-SHA-1-PLUS).  If the server
    does not support channel\n   binding, then it will advertise only the \"bare\"
    version of the\n   mechanism (e.g., only SCRAM-SHA-1).  The \"-PLUS\" exists to
    allow\n   negotiation of the use of channel binding.  See Section 6.\n"
  title: 4.  SCRAM Mechanism Names
- contents:
  - "5.  SCRAM Authentication Exchange\n   SCRAM is a SASL mechanism whose client
    response and server challenge\n   messages are text-based messages containing
    one or more attribute-\n   value pairs separated by commas.  Each attribute has
    a one-letter\n   name.  The messages and their attributes are described in\n   Section
    5.1, and defined in Section 7.\n   SCRAM is a client-first SASL mechanism (see
    [RFC4422], Section 5,\n   item 2a), and returns additional data together with
    a server's\n   indication of a successful outcome.\n   This is a simple example
    of a SCRAM-SHA-1 authentication exchange\n   when the client doesn't support channel
    bindings (username 'user' and\n   password 'pencil' are used):\n   C: n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL\n
    \  S: r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,\n      i=4096\n
    \  C: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,\n      p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=\n
    \  S: v=rmF9pqV8S7suAoZWja4dJRkFsKQ=\n   First, the client sends the \"client-first-message\"
    containing:\n   o  a GS2 header consisting of a flag indicating whether channel\n
    \     binding is supported-but-not-used, not supported, or used, and an\n      optional
    SASL authorization identity;\n   o  SCRAM username and a random, unique nonce
    attributes.\n   Note that the client's first message will always start with \"n\",
    \"y\",\n   or \"p\"; otherwise, the message is invalid and authentication MUST\n
    \  fail.  This is important, as it allows for GS2 extensibility (e.g.,\n   to
    add support for security layers).\n   In response, the server sends a \"server-first-message\"
    containing the\n   user's iteration count i and the user's salt, and appends its
    own\n   nonce to the client-specified one.\n   The client then responds by sending
    a \"client-final-message\" with the\n   same nonce and a ClientProof computed
    using the selected hash\n   function as explained earlier.\n   The server verifies
    the nonce and the proof, verifies that the\n   authorization identity (if supplied
    by the client in the first\n   message) is authorized to act as the authentication
    identity, and,\n   finally, it responds with a \"server-final-message\", concluding
    the\n   authentication exchange.\n   The client then authenticates the server
    by computing the\n   ServerSignature and comparing it to the value sent by the
    server.  If\n   the two are different, the client MUST consider the authentication\n
    \  exchange to be unsuccessful, and it might have to drop the\n   connection.\n"
  - contents:
    - "5.1.  SCRAM Attributes\n   This section describes the permissible attributes,
      their use, and the\n   format of their values.  All attribute names are single
      US-ASCII\n   letters and are case-sensitive.\n   Note that the order of attributes
      in client or server messages is\n   fixed, with the exception of extension attributes
      (described by the\n   \"extensions\" ABNF production), which can appear in any
      order in the\n   designated positions.  See Section 7 for authoritative reference.\n
      \  o  a: This is an optional attribute, and is part of the GS2 [RFC5801]\n      bridge
      between the GSS-API and SASL.  This attribute specifies an\n      authorization
      identity.  A client may include it in its first\n      message to the server
      if it wants to authenticate as one user, but\n      subsequently act as a different
      user.  This is typically used by\n      an administrator to perform some management
      task on behalf of\n      another user, or by a proxy in some situations.\n         Upon
      the receipt of this value the server verifies its\n         correctness according
      to the used SASL protocol profile.\n         Failed verification results in
      failed authentication exchange.\n         If this attribute is omitted (as it
      normally would be), the\n         authorization identity is assumed to be derived
      from the\n         username specified with the (required) \"n\" attribute.\n
      \        The server always authenticates the user specified by the \"n\"\n         attribute.
      \ If the \"a\" attribute specifies a different user,\n         the server associates
      that identity with the connection after\n         successful authentication
      and authorization checks.\n         The syntax of this field is the same as
      that of the \"n\" field\n         with respect to quoting of '=' and ','.\n
      \  o  n: This attribute specifies the name of the user whose password is\n      used
      for authentication (a.k.a. \"authentication identity\"\n      [RFC4422]).  A
      client MUST include it in its first message to the\n      server.  If the \"a\"
      attribute is not specified (which would\n      normally be the case), this username
      is also the identity that\n      will be associated with the connection subsequent
      to\n      authentication and authorization.\n         Before sending the username
      to the server, the client SHOULD\n         prepare the username using the \"SASLprep\"
      profile [RFC4013] of\n         the \"stringprep\" algorithm [RFC3454] treating
      it as a query\n         string (i.e., unassigned Unicode code points are allowed).
      \ If\n         the preparation of the username fails or results in an empty\n
      \        string, the client SHOULD abort the authentication exchange\n         (*).\n
      \        (*) An interactive client can request a repeated entry of the\n         username
      value.\n         Upon receipt of the username by the server, the server MUST\n
      \        either prepare it using the \"SASLprep\" profile [RFC4013] of the\n
      \        \"stringprep\" algorithm [RFC3454] treating it as a query string\n
      \        (i.e., unassigned Unicode codepoints are allowed) or otherwise\n         be
      prepared to do SASLprep-aware string comparisons and/or\n         index lookups.
      \ If the preparation of the username fails or\n         results in an empty
      string, the server SHOULD abort the\n         authentication exchange.  Whether
      or not the server prepares\n         the username using \"SASLprep\", it MUST
      use it as received in\n         hash calculations.\n         The characters
      ',' or '=' in usernames are sent as '=2C' and\n         '=3D' respectively.
      \ If the server receives a username that\n         contains '=' not followed
      by either '2C' or '3D', then the\n         server MUST fail the authentication.\n
      \  o  m: This attribute is reserved for future extensibility.  In this\n      version
      of SCRAM, its presence in a client or a server message\n      MUST cause authentication
      failure when the attribute is parsed by\n      the other end.\n   o  r: This
      attribute specifies a sequence of random printable ASCII\n      characters excluding
      ',' (which forms the nonce used as input to\n      the hash function).  No quoting
      is applied to this string.  As\n      described earlier, the client supplies
      an initial value in its\n      first message, and the server augments that value
      with its own\n      nonce in its first response.  It is important that this
      value be\n      different for each authentication (see [RFC4086] for more details\n
      \     on how to achieve this).  The client MUST verify that the initial\n      part
      of the nonce used in subsequent messages is the same as the\n      nonce it
      initially specified.  The server MUST verify that the\n      nonce sent by the
      client in the second message is the same as the\n      one sent by the server
      in its first message.\n   o  c: This REQUIRED attribute specifies the base64-encoded
      GS2 header\n      and channel binding data.  It is sent by the client in its
      second\n      authentication message.  The attribute data consist of:\n      *
      \ the GS2 header from the client's first message (recall that the\n         GS2
      header contains a channel binding flag and an optional\n         authzid).  This
      header is going to include channel binding type\n         prefix (see [RFC5056]),
      if and only if the client is using\n         channel binding;\n      *  followed
      by the external channel's channel binding data, if and\n         only if the
      client is using channel binding.\n   o  s: This attribute specifies the base64-encoded
      salt used by the\n      server for this user.  It is sent by the server in its
      first\n      message to the client.\n   o  i: This attribute specifies an iteration
      count for the selected\n      hash function and user, and MUST be sent by the
      server along with\n      the user's salt.\n         For the SCRAM-SHA-1/SCRAM-SHA-1-PLUS
      SASL mechanism, servers\n         SHOULD announce a hash iteration-count of
      at least 4096.  Note\n         that a client implementation MAY cache ClientKey&ServerKey
      (or\n         just SaltedPassword) for later reauthentication to the same\n
      \        service, as it is likely that the server is going to advertise\n         the
      same salt value upon reauthentication.  This might be\n         useful for mobile
      clients where CPU usage is a concern.\n   o  p: This attribute specifies a base64-encoded
      ClientProof.  The\n      client computes this value as described in the overview
      and sends\n      it to the server.\n   o  v: This attribute specifies a base64-encoded
      ServerSignature.  It\n      is sent by the server in its final message, and
      is used by the\n      client to verify that the server has access to the user's\n
      \     authentication information.  This value is computed as explained\n      in
      the overview.\n   o  e: This attribute specifies an error that occurred during\n
      \     authentication exchange.  It is sent by the server in its final\n      message
      and can help diagnose the reason for the authentication\n      exchange failure.
      \ On failed authentication, the entire server-\n      final-message is OPTIONAL;
      specifically, a server implementation\n      MAY conclude the SASL exchange
      with a failure without sending the\n      server-final-message.  This results
      in an application-level error\n      response without an extra round-trip.  If
      the server-final-message\n      is sent on authentication failure, then the
      \"e\" attribute MUST be\n      included.\n   o  As-yet unspecified mandatory
      and optional extensions.  Mandatory\n      extensions are encoded as values
      of the 'm' attribute (see ABNF\n      for reserved-mext in section 7).  Optional
      extensions use as-yet\n      unassigned attribute names.\n      Mandatory extensions
      sent by one peer but not understood by the\n      other MUST cause authentication
      failure (the server SHOULD send\n      the \"extensions-not-supported\" server-error-value).\n
      \     Unknown optional extensions MUST be ignored upon receipt.\n"
    title: 5.1.  SCRAM Attributes
  - contents:
    - "5.2.  Compliance with SASL Mechanism Requirements\n   This section describes
      compliance with SASL mechanism requirements\n   specified in Section 5 of [RFC4422].\n
      \  1)  \"SCRAM-SHA-1\" and \"SCRAM-SHA-1-PLUS\".\n   2a) SCRAM is a client-first
      mechanism.\n   2b) SCRAM sends additional data with success.\n   3)  SCRAM is
      capable of transferring authorization identities from\n       the client to
      the server.\n   4)  SCRAM does not offer any security layers (SCRAM offers channel\n
      \      binding instead).\n   5)  SCRAM has a hash protecting the authorization
      identity.\n"
    title: 5.2.  Compliance with SASL Mechanism Requirements
  title: 5.  SCRAM Authentication Exchange
- contents:
  - "6.  Channel Binding\n   SCRAM supports channel binding to external secure channels,
    such as\n   TLS.  Clients and servers may or may not support channel binding,\n
    \  therefore the use of channel binding is negotiable.  SCRAM does not\n   provide
    security layers, however, therefore it is imperative that\n   SCRAM provide integrity
    protection for the negotiation of channel\n   binding.\n   Use of channel binding
    is negotiated as follows:\n   o  Servers that support the use of channel binding
    SHOULD advertise\n      both the non-PLUS (SCRAM-<hash-function>) and PLUS-variant
    (SCRAM-\n      <hash-function>-PLUS) mechanism name.  If the server cannot\n      support
    channel binding, it SHOULD advertise only the non-PLUS-\n      variant.  If the
    server would never succeed in the authentication\n      of the non-PLUS-variant
    due to policy reasons, it MUST advertise\n      only the PLUS-variant.\n   o  If
    the client supports channel binding and the server does not\n      appear to (i.e.,
    the client did not see the -PLUS name advertised\n      by the server), then the
    client MUST NOT use an \"n\" gs2-cbind-\n      flag.\n   o  Clients that support
    mechanism negotiation and channel binding\n      MUST use a \"p\" gs2-cbind-flag
    when the server offers the PLUS-\n      variant of the desired GS2 mechanism.\n
    \  o  If the client does not support channel binding, then it MUST use\n      an
    \"n\" gs2-cbind-flag.  Conversely, if the client requires the use\n      of channel
    binding then it MUST use a \"p\" gs2-cbind-flag.  Clients\n      that do not support
    mechanism negotiation never use a \"y\" gs2-\n      cbind-flag, they use either
    \"p\" or \"n\" according to whether they\n      require and support the use of
    channel binding or whether they do\n      not, respectively.\n   o  Upon receipt
    of the client-first message, the server checks the\n      channel binding flag
    (gs2-cbind-flag).\n      *  If the flag is set to \"y\" and the server supports
    channel\n         binding, the server MUST fail authentication.  This is because\n
    \        if the client sets the channel binding flag to \"y\", then the\n         client
    must have believed that the server did not support\n         channel binding --
    if the server did in fact support channel\n         binding, then this is an indication
    that there has been a\n         downgrade attack (e.g., an attacker changed the
    server's\n         mechanism list to exclude the -PLUS suffixed SCRAM mechanism\n
    \        name(s)).\n      *  If the channel binding flag was \"p\" and the server
    does not\n         support the indicated channel binding type, then the server\n
    \        MUST fail authentication.\n   The server MUST always validate the client's
    \"c=\" field.  The server\n   does this by constructing the value of the \"c=\"
    attribute and then\n   checking that it matches the client's c= attribute value.\n
    \  For more discussions of channel bindings, and the syntax of channel\n   binding
    data for various security protocols, see [RFC5056].\n"
  - contents:
    - "6.1.  Default Channel Binding\n   A default channel binding type agreement
      process for all SASL\n   application protocols that do not provide their own
      channel binding\n   type agreement is provided as follows.\n   'tls-unique'
      is the default channel binding type for any application\n   that doesn't specify
      one.\n   Servers MUST implement the \"tls-unique\" [RFC5929] channel binding\n
      \  type, if they implement any channel binding.  Clients SHOULD\n   implement
      the \"tls-unique\" [RFC5929] channel binding type, if they\n   implement any
      channel binding.  Clients and servers SHOULD choose the\n   highest-layer/innermost
      end-to-end TLS channel as the channel to\n   which to bind.\n   Servers MUST
      choose the channel binding type indicated by the client,\n   or fail authentication
      if they don't support it.\n"
    title: 6.1.  Default Channel Binding
  title: 6.  Channel Binding
- contents:
  - "7.  Formal Syntax\n   The following syntax specification uses the Augmented Backus-Naur\n
    \  form (ABNF) notation as specified in [RFC5234].  \"UTF8-2\", \"UTF8-3\",\n
    \  and \"UTF8-4\" non-terminal are defined in [RFC3629].\n   ALPHA = <as defined
    in RFC 5234 appendix B.1>\n   DIGIT = <as defined in RFC 5234 appendix B.1>\n
    \  UTF8-2 = <as defined in RFC 3629 (STD 63)>\n   UTF8-3 = <as defined in RFC
    3629 (STD 63)>\n   UTF8-4 = <as defined in RFC 3629 (STD 63)>\n   attr-val        =
    ALPHA \"=\" value\n                     ;; Generic syntax of any attribute sent\n
    \                    ;; by server or client\n   value           = 1*value-char\n
    \  value-safe-char = %x01-2B / %x2D-3C / %x3E-7F /\n                     UTF8-2
    / UTF8-3 / UTF8-4\n                     ;; UTF8-char except NUL, \"=\", and \",\".\n
    \  value-char      = value-safe-char / \"=\"\n   printable       = %x21-2B / %x2D-7E\n
    \                    ;; Printable ASCII except \",\".\n                     ;;
    Note that any \"printable\" is also\n                     ;; a valid \"value\".\n
    \  base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n   base64-4        = 4base64-char\n
    \  base64-3        = 3base64-char \"=\"\n   base64-2        = 2base64-char \"==\"\n
    \  base64          = *base64-4 [base64-3 / base64-2]\n   posit-number = %x31-39
    *DIGIT\n                     ;; A positive number.\n   saslname        = 1*(value-safe-char
    / \"=2C\" / \"=3D\")\n                     ;; Conforms to <value>.\n   authzid
    \        = \"a=\" saslname\n                     ;; Protocol specific.\n   cb-name
    \        = 1*(ALPHA / DIGIT / \".\" / \"-\")\n                      ;; See RFC
    5056, Section 7.\n                      ;; E.g., \"tls-server-end-point\" or\n
    \                     ;; \"tls-unique\".\n   gs2-cbind-flag  = (\"p=\" cb-name)
    / \"n\" / \"y\"\n                     ;; \"n\" -> client doesn't support channel
    binding.\n                     ;; \"y\" -> client does support channel binding\n
    \                    ;;        but thinks the server does not.\n                     ;;
    \"p\" -> client requires channel binding.\n                     ;; The selected
    channel binding follows \"p=\".\n   gs2-header      = gs2-cbind-flag \",\" [ authzid
    ] \",\"\n                     ;; GS2 header for SCRAM\n                     ;;
    (the actual GS2 header includes an optional\n                     ;; flag to indicate
    that the GSS mechanism is not\n                     ;; \"standard\", but since
    SCRAM is \"standard\", we\n                     ;; don't include that flag).\n
    \  username        = \"n=\" saslname\n                     ;; Usernames are prepared
    using SASLprep.\n   reserved-mext  = \"m=\" 1*(value-char)\n                     ;;
    Reserved for signaling mandatory extensions.\n                     ;; The exact
    syntax will be defined in\n                     ;; the future.\n   channel-binding
    = \"c=\" base64\n                     ;; base64 encoding of cbind-input.\n   proof
    \          = \"p=\" base64\n   nonce           = \"r=\" c-nonce [s-nonce]\n                     ;;
    Second part provided by server.\n   c-nonce         = printable\n   s-nonce         =
    printable\n   salt            = \"s=\" base64\n   verifier        = \"v=\" base64\n
    \                    ;; base-64 encoded ServerSignature.\n   iteration-count =
    \"i=\" posit-number\n                     ;; A positive number.\n   client-first-message-bare
    =\n                     [reserved-mext \",\"]\n                     username \",\"
    nonce [\",\" extensions]\n   client-first-message =\n                     gs2-header
    client-first-message-bare\n   server-first-message =\n                     [reserved-mext
    \",\"] nonce \",\" salt \",\"\n                     iteration-count [\",\" extensions]\n
    \  client-final-message-without-proof =\n                     channel-binding
    \",\" nonce [\",\"\n                     extensions]\n   client-final-message
    =\n                     client-final-message-without-proof \",\" proof\n   server-error
    = \"e=\" server-error-value\n   server-error-value = \"invalid-encoding\" /\n
    \                 \"extensions-not-supported\" /  ; unrecognized 'm' value\n                  \"invalid-proof\"
    /\n                  \"channel-bindings-dont-match\" /\n                  \"server-does-support-channel-binding\"
    /\n                    ; server does not support channel binding\n                  \"channel-binding-not-supported\"
    /\n                  \"unsupported-channel-binding-type\" /\n                  \"unknown-user\"
    /\n                  \"invalid-username-encoding\" /\n                    ; invalid
    username encoding (invalid UTF-8 or\n                    ; SASLprep failed)\n
    \                 \"no-resources\" /\n                  \"other-error\" /\n                  server-error-value-ext\n
    \          ; Unrecognized errors should be treated as \"other-error\".\n           ;
    In order to prevent information disclosure, the server\n           ; may substitute
    the real reason with \"other-error\".\n   server-error-value-ext = value\n           ;
    Additional error reasons added by extensions\n           ; to this document.\n
    \  server-final-message = (server-error / verifier)\n                     [\",\"
    extensions]\n   extensions = attr-val *(\",\" attr-val)\n                     ;;
    All extensions are optional,\n                     ;; i.e., unrecognized attributes\n
    \                    ;; not defined in this document\n                     ;;
    MUST be ignored.\n   cbind-data    = 1*OCTET\n   cbind-input   = gs2-header [
    cbind-data ]\n                     ;; cbind-data MUST be present for\n                     ;;
    gs2-cbind-flag of \"p\" and MUST be absent\n                     ;; for \"y\"
    or \"n\".\n"
  title: 7.  Formal Syntax
- contents:
  - "8.  SCRAM as a GSS-API Mechanism\n   This section and its sub-sections and all
    normative references of it\n   not referenced elsewhere in this document are INFORMATIONAL
    for SASL\n   implementors, but they are NORMATIVE for GSS-API implementors.\n
    \  SCRAM is actually also a GSS-API mechanism.  The messages are the\n   same,
    but a) the GS2 header on the client's first message and channel\n   binding data
    is excluded when SCRAM is used as a GSS-API mechanism,\n   and b) the RFC2743
    section 3.1 initial context token header is\n   prefixed to the client's first
    authentication message (context\n   token).\n   The GSS-API mechanism OID for
    SCRAM-SHA-1 is 1.3.6.1.5.5.14 (see\n   Section 10).\n   SCRAM security contexts
    always have the mutual_state flag\n   (GSS_C_MUTUAL_FLAG) set to TRUE.  SCRAM
    does not support credential\n   delegation, therefore SCRAM security contexts
    alway have the\n   deleg_state flag (GSS_C_DELEG_FLAG) set to FALSE.\n"
  - contents:
    - "8.1.  GSS-API Principal Name Types for SCRAM\n   SCRAM does not explicitly
      name acceptor principals.  However, the use\n   of acceptor principal names
      to find or prompt for passwords is\n   useful.  Therefore, SCRAM supports standard
      generic name syntaxes for\n   acceptors such as GSS_C_NT_HOSTBASED_SERVICE (see
      [RFC2743], Section\n   4.1).  Implementations should use the target name passed
      to\n   GSS_Init_sec_context(), if any, to help retrieve or prompt for SCRAM\n
      \  passwords.\n   SCRAM supports only a single name type for initiators:\n   GSS_C_NT_USER_NAME.
      \ GSS_C_NT_USER_NAME is the default name type for\n   SCRAM.\n   There is no
      name canonicalization procedure for SCRAM beyond applying\n   SASLprep as described
      in Section 5.1.\n   The query, display, and exported name syntaxes for SCRAM
      principal\n   names are all the same.  There are no SCRAM-specific name syntaxes\n
      \  (SCRAM initiator principal names are free-form); -- applications\n   should
      use generic GSS-API name types such as GSS_C_NT_USER_NAME and\n   GSS_C_NT_HOSTBASED_SERVICE
      (see [RFC2743], Section 4).  The exported\n   name token does, of course, conform
      to [RFC2743], Section 3.2, but\n   the \"NAME\" part of the token is just a
      SCRAM user name.\n"
    title: 8.1.  GSS-API Principal Name Types for SCRAM
  - contents:
    - "8.2.  GSS-API Per-Message Tokens for SCRAM\n   The per-message tokens for SCRAM
      as a GSS-API mechanism SHALL be the\n   same as those for the Kerberos V GSS-API
      mechanism [RFC4121] (see\n   Section 4.2 and sub-sections), using the Kerberos
      V \"aes128-cts-hmac-\n   sha1-96\" enctype [RFC3962].\n   The replay_det_state
      (GSS_C_REPLAY_FLAG), sequence_state\n   (GSS_C_SEQUENCE_FLAG), conf_avail (GSS_C_CONF_FLAG)
      and integ_avail\n   (GSS_C_CONF_FLAG) security context flags are always set
      to TRUE.\n   The 128-bit session \"protocol key\" SHALL be derived by using
      the\n   least significant (right-most) 128 bits of HMAC(StoredKey, \"GSS-API\n
      \  session key\" || ClientKey || AuthMessage).  \"Specific keys\" are then\n
      \  derived as usual as described in Section 2 of [RFC4121], [RFC3961],\n   and
      [RFC3962].\n   The terms \"protocol key\" and \"specific key\" are Kerberos
      V5 terms\n   [RFC3961].\n   SCRAM does support PROT_READY, and is PROT_READY
      on the initiator\n   side first upon receipt of the server's reply to the initial
      security\n   context token.\n"
    title: 8.2.  GSS-API Per-Message Tokens for SCRAM
  - contents:
    - "8.3.  GSS_Pseudo_random() for SCRAM\n   The GSS_Pseudo_random() [RFC4401] for
      SCRAM SHALL be the same as for\n   the Kerberos V GSS-API mechanism [RFC4402].
      \ There is no acceptor-\n   asserted sub-session key for SCRAM, thus GSS_C_PRF_KEY_FULL
      and\n   GSS_C_PRF_KEY_PARTIAL are equivalent for SCRAM's GSS_Pseudo_random().\n
      \  The protocol key to be used for the GSS_Pseudo_random() SHALL be the\n   same
      as the key defined in Section 8.2.\n"
    title: 8.3.  GSS_Pseudo_random() for SCRAM
  title: 8.  SCRAM as a GSS-API Mechanism
- contents:
  - "9.  Security Considerations\n   If the authentication exchange is performed without
    a strong security\n   layer (such as TLS with data confidentiality), then a passive\n
    \  eavesdropper can gain sufficient information to mount an offline\n   dictionary
    or brute-force attack that can be used to recover the\n   user's password.  The
    amount of time necessary for this attack\n   depends on the cryptographic hash
    function selected, the strength of\n   the password, and the iteration count supplied
    by the server.  An\n   external security layer with strong encryption will prevent
    this\n   attack.\n   If the external security layer used to protect the SCRAM
    exchange\n   uses an anonymous key exchange, then the SCRAM channel binding\n
    \  mechanism can be used to detect a man-in-the-middle attack on the\n   security
    layer and cause the authentication to fail as a result.\n   However, the man-in-the-middle
    attacker will have gained sufficient\n   information to mount an offline dictionary
    or brute-force attack.\n   For this reason, SCRAM allows to increase the iteration
    count over\n   time.  (Note that a server that is only in possession of \"StoredKey\"\n
    \  and \"ServerKey\" can't automatically increase the iteration count upon\n   successful
    authentication.  Such an increase would require resetting\n   the user's password.)\n
    \  If the authentication information is stolen from the authentication\n   database,
    then an offline dictionary or brute-force attack can be\n   used to recover the
    user's password.  The use of salt mitigates this\n   attack somewhat by requiring
    a separate attack on each password.\n   Authentication mechanisms that protect
    against this attack are\n   available (e.g., the EKE class of mechanisms).  RFC
    2945 [RFC2945] is\n   an example of such technology.  The WG elected not to use
    EKE like\n   mechanisms as a basis for SCRAM.\n   If an attacker obtains the authentication
    information from the\n   authentication repository and either eavesdrops on one
    authentication\n   exchange or impersonates a server, the attacker gains the ability
    to\n   impersonate that user to all servers providing SCRAM access using the\n
    \  same hash function, password, iteration count, and salt.  For this\n   reason,
    it is important to use randomly generated salt values.\n   SCRAM does not negotiate
    a hash function to use.  Hash function\n   negotiation is left to the SASL mechanism
    negotiation.  It is\n   important that clients be able to sort a locally available
    list of\n   mechanisms by preference so that the client may pick the appropriate\n
    \  mechanism to use from a server's advertised mechanism list.  This\n   preference
    order is not specified here as it is a local matter.  The\n   preference order
    should include objective and subjective notions of\n   mechanism cryptographic
    strength (e.g., SCRAM with a successor to\n   SHA-1 may be preferred over SCRAM
    with SHA-1).\n   Note that to protect the SASL mechanism negotiation applications\n
    \  normally must list the server mechanisms twice: once before and once\n   after
    authentication, the latter using security layers.  Since SCRAM\n   does not provide
    security layers, the only ways to protect the\n   mechanism negotiation are a)
    use channel binding to an external\n   channel, or b) use an external channel
    that authenticates a user-\n   provided server name.\n   SCRAM does not protect
    against downgrade attacks of channel binding\n   types.  The complexities of negotiating
    a channel binding type, and\n   handling down-grade attacks in that negotiation,
    were intentionally\n   left out of scope for this document.\n   A hostile server
    can perform a computational denial-of-service attack\n   on clients by sending
    a big iteration count value.\n   See [RFC4086] for more information about generating
    randomness.\n"
  title: 9.  Security Considerations
- contents:
  - "10.  IANA Considerations\n   IANA has added the following family of SASL mechanisms
    to the SASL\n   Mechanism registry established by [RFC4422]:\n   To: iana@iana.org\n
    \  Subject: Registration of a new SASL family SCRAM\n   SASL mechanism name (or
    prefix for the family): SCRAM-*\n   Security considerations: Section 7 of [RFC5802]\n
    \  Published specification (optional, recommended): [RFC5802]\n   Person & email
    address to contact for further information:\n   IETF SASL WG <sasl@ietf.org>\n
    \  Intended usage: COMMON\n   Owner/Change controller: IESG <iesg@ietf.org>\n
    \  Note: Members of this family MUST be explicitly registered\n   using the \"IETF
    Review\" [RFC5226] registration procedure.\n   Reviews MUST be requested on the
    SASL mailing list\n   <sasl@ietf.org> (or a successor designated by the responsible\n
    \  Security AD).\n   Note to future SCRAM-mechanism designers: each new SCRAM-SASL\n
    \  mechanism MUST be explicitly registered with IANA and MUST comply\n   with
    SCRAM-mechanism naming convention defined in Section 4 of this\n   document.\n
    \  IANA has added the following entries to the SASL Mechanism registry\n   established
    by [RFC4422]:\n   To: iana@iana.org\n   Subject: Registration of a new SASL mechanism
    SCRAM-SHA-1\n   SASL mechanism name (or prefix for the family): SCRAM-SHA-1\n
    \  Security considerations: Section 7 of [RFC5802]\n   Published specification
    (optional, recommended): [RFC5802]\n   Person & email address to contact for further
    information:\n   IETF SASL WG <sasl@ietf.org>\n   Intended usage: COMMON\n   Owner/Change
    controller: IESG <iesg@ietf.org>\n   Note:\n   To: iana@iana.org\n   Subject:
    Registration of a new SASL mechanism SCRAM-SHA-1-PLUS\n   SASL mechanism name
    (or prefix for the family): SCRAM-SHA-1-PLUS\n   Security considerations: Section
    7 of [RFC5802]\n   Published specification (optional, recommended): [RFC5802]\n
    \  Person & email address to contact for further information:\n   IETF SASL WG
    <sasl@ietf.org>\n   Intended usage: COMMON\n   Owner/Change controller: IESG <iesg@ietf.org>\n
    \  Note:\n   Per this document, IANA has assigned a GSS-API mechanism OID for\n
    \  SCRAM-SHA-1 from the iso.org.dod.internet.security.mechanisms prefix\n   (see
    \"SMI Security for Mechanism Codes\" registry).\n"
  title: 10.  IANA Considerations
- contents:
  - "11.  Acknowledgements\n   This document benefited from discussions on the SASL
    WG mailing list.\n   The authors would like to specially thank Dave Cridland,
    Simon\n   Josefsson, Jeffrey Hutzelman, Kurt Zeilenga, Pasi Eronen, Ben\n   Campbell,
    Peter Saint-Andre, and Tobias Markmann for their\n   contributions to this document.
    \ A special thank you to Simon\n   Josefsson for shepherding this document and
    for doing one of the\n   first implementations of this specification.\n"
  title: 11.  Acknowledgements
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.
      Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\",
      RFC 2104,\n              February 1997.\n   [RFC2119]  Bradner, S., \"Key words
      for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC3174]  Eastlake, D. and P. Jones, \"US Secure Hash
      Algorithm 1\n              (SHA1)\", RFC 3174, September 2001.\n   [RFC3454]
      \ Hoffman, P. and M. Blanchet, \"Preparation of\n              Internationalized
      Strings (\"stringprep\")\", RFC 3454,\n              December 2002.\n   [RFC3629]
      \ Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\",
      STD 63, RFC 3629, November 2003.\n   [RFC4013]  Zeilenga, K., \"SASLprep: Stringprep
      Profile for User Names\n              and Passwords\", RFC 4013, February 2005.\n
      \  [RFC4422]  Melnikov, A. and K. Zeilenga, \"Simple Authentication and\n              Security
      Layer (SASL)\", RFC 4422, June 2006.\n   [RFC4648]  Josefsson, S., \"The Base16,
      Base32, and Base64 Data\n              Encodings\", RFC 4648, October 2006.\n
      \  [RFC5056]  Williams, N., \"On the Use of Channel Bindings to Secure\n              Channels\",
      RFC 5056, November 2007.\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented
      BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January
      2008.\n   [RFC5929]  Altman, J., Williams, N., and L. Zhu, \"Channel Bindings\n
      \             for TLS\", RFC 5929, July 2010.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Normative References for GSS-API Implementors\n   [RFC2743]  Linn, J.,
      \"Generic Security Service Application Program\n              Interface Version
      2, Update 1\", RFC 2743, January 2000.\n   [RFC3961]  Raeburn, K., \"Encryption
      and Checksum Specifications for\n              Kerberos 5\", RFC 3961, February
      2005.\n   [RFC3962]  Raeburn, K., \"Advanced Encryption Standard (AES)\n              Encryption
      for Kerberos 5\", RFC 3962, February 2005.\n   [RFC4121]  Zhu, L., Jaganathan,
      K., and S. Hartman, \"The Kerberos\n              Version 5 Generic Security
      Service Application Program\n              Interface (GSS-API) Mechanism: Version
      2\", RFC 4121,\n              July 2005.\n   [RFC4401]  Williams, N., \"A Pseudo-Random
      Function (PRF) API\n              Extension for the Generic Security Service
      Application\n              Program Interface (GSS-API)\", RFC 4401, February
      2006.\n   [RFC4402]  Williams, N., \"A Pseudo-Random Function (PRF) for the\n
      \             Kerberos V Generic Security Service Application Program\n              Interface
      (GSS-API) Mechanism\", RFC 4402, February 2006.\n   [RFC5801]  Josefsson, S.
      and N. Williams, \"Using Generic Security\n              Service Application
      Program Interface (GSS-API) Mechanisms\n              in Simple Authentication
      and Security Layer (SASL): The\n              GS2 Mechanism Family\", RFC 5801,
      July 2010.\n"
    title: 12.2.  Normative References for GSS-API Implementors
  - contents:
    - "12.3.  Informative References\n   [CRAMHISTORIC]\n              Zeilenga, K.,
      \"CRAM-MD5 to Historic\", Work in Progress,\n              November 2008.\n
      \  [DIGESTHISTORIC]\n              Melnikov, A., \"Moving DIGEST-MD5 to Historic\",
      Work\n              in Progress, July 2008.\n   [RFC2865]  Rigney, C., Willens,
      S., Rubens, A., and W. Simpson,\n              \"Remote Authentication Dial
      In User Service (RADIUS)\",\n              RFC 2865, June 2000.\n   [RFC2898]
      \ Kaliski, B., \"PKCS #5: Password-Based Cryptography\n              Specification
      Version 2.0\", RFC 2898, September 2000.\n   [RFC2945]  Wu, T., \"The SRP Authentication
      and Key Exchange System\",\n              RFC 2945, September 2000.\n   [RFC4086]
      \ Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n              Requirements
      for Security\", BCP 106, RFC 4086, June 2005.\n   [RFC4510]  Zeilenga, K., \"Lightweight
      Directory Access Protocol\n              (LDAP): Technical Specification Road
      Map\", RFC 4510,\n              June 2006.\n   [RFC4616]  Zeilenga, K., \"The
      PLAIN Simple Authentication and\n              Security Layer (SASL) Mechanism\",
      RFC 4616, August 2006.\n   [RFC4949]  Shirey, R., \"Internet Security Glossary,
      Version 2\",\n              RFC 4949, August 2007.\n   [RFC5226]  Narten, T.
      and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations
      Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n   [RFC5246]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC5803]  Melnikov, A.,
      \"Lightweight Directory Access Protocol\n              (LDAP) Schema for Storing
      Salted Challenge Response\n              Authentication Mechanism (SCRAM) Secrets\",
      RFC 5803,\n              July 2010.\n   [tls-server-end-point]\n              IANA,
      \"Registration of TLS server end-point channel\n              bindings\", available
      from http://www.iana.org, June 2008.\n"
    title: 12.3.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  Other Authentication Mechanisms\n   The DIGEST-MD5 [DIGESTHISTORIC]
    mechanism has proved to be too\n   complex to implement and test, and thus has
    poor interoperability.\n   The security layer is often not implemented, and almost
    never used;\n   everyone uses TLS instead.  For a more complete list of problems
    with\n   DIGEST-MD5 that led to the creation of SCRAM, see [DIGESTHISTORIC].\n
    \  The CRAM-MD5 SASL mechanism, while widely deployed, also has some\n   problems.
    \ In particular, it is missing some modern SASL features\n   such as support for
    internationalized usernames and passwords,\n   support for passing of authorization
    identity, and support for\n   channel bindings.  It also doesn't support server
    authentication.\n   For a more complete list of problems with CRAM-MD5, see\n
    \  [CRAMHISTORIC].\n   The PLAIN [RFC4616] SASL mechanism allows a malicious server
    or\n   eavesdropper to impersonate the authenticating user to any other\n   server
    for which the user has the same password.  It also sends the\n   password in the
    clear over the network, unless TLS is used.  Server\n   authentication is not
    supported.\n"
  title: Appendix A.  Other Authentication Mechanisms
- contents:
  - "Appendix B.  Design Motivations\n   The following design goals shaped this document.
    \ Note that some of\n   the goals have changed since the initial version of the
    document.\n   o  The SASL mechanism has all modern SASL features: support for\n
    \     internationalized usernames and passwords, support for passing of\n      authorization
    identity, and support for channel bindings.\n   o  The protocol supports mutual
    authentication.\n   o  The authentication information stored in the authentication\n
    \     database is not sufficient by itself to impersonate the client.\n   o  The
    server does not gain the ability to impersonate the client to\n      other servers
    (with an exception for server-authorized proxies),\n      unless such other servers
    allow SCRAM authentication and use the\n      same salt and iteration count for
    the user.\n   o  The mechanism is extensible, but (hopefully) not over-engineered\n
    \     in this respect.\n   o  The mechanism is easier to implement than DIGEST-MD5
    in both\n      clients and servers.\n"
  title: Appendix B.  Design Motivations
- contents:
  - "Authors' Addresses\n   Chris Newman\n   Oracle\n   800 Royal Oaks\n   Monrovia,
    CA  91016\n   USA\n   EMail: chris.newman@oracle.com\n   Abhijit Menon-Sen\n   Oryx
    Mail Systems GmbH\n   EMail: ams@toroid.org\n   Alexey Melnikov\n   Isode, Ltd.\n
    \  EMail: Alexey.Melnikov@isode.com\n   Nicolas Williams\n   Oracle\n   5300 Riata
    Trace Ct\n   Austin, TX  78727\n   USA\n   EMail: Nicolas.Williams@oracle.com\n"
  title: Authors' Addresses
