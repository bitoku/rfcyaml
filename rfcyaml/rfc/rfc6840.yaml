- contents:
  - '   Clarifications and Implementation Notes for DNS Security (DNSSEC)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document is a collection of technical clarifications to the
    DNS\n   Security (DNSSEC) document set.  It is meant to serve as a resource\n
    \  to implementors as well as a collection of DNSSEC errata that existed\n   at
    the time of writing.\n   This document updates the core DNSSEC documents (RFC
    4033, RFC 4034,\n   and RFC 4035) as well as the NSEC3 specification (RFC 5155).
    \ It also\n   defines NSEC3 and SHA-2 (RFC 4509 and RFC 5702) as core parts of
    the\n   DNSSEC specification.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6840.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction and Terminology ....................................4\n
    \     1.1. Structure of This Document .................................4\n      1.2.
    Terminology ................................................4\n   2. Important
    Additions to DNSSEC ...................................4\n      2.1. NSEC3 Support
    ..............................................4\n      2.2. SHA-2 Support ..............................................5\n
    \  3. Scaling Concerns ................................................5\n      3.1.
    Implement a BAD Cache ......................................5\n   4. Security
    Concerns ...............................................5\n      4.1. Clarifications
    on Nonexistence Proofs ......................5\n      4.2. Validating Responses
    to an ANY Query .......................6\n      4.3. Check for CNAME ............................................6\n
    \     4.4. Insecure Delegation Proofs .................................7\n   5.
    Interoperability Concerns .......................................7\n      5.1.
    Errors in Canonical Form Type Code List ....................7\n      5.2. Unknown
    DS Message Digest Algorithms .......................7\n      5.3. Private Algorithms
    .........................................8\n      5.4. Caution about Local Policy
    and Multiple RRSIGs .............9\n      5.5. Key Tag Calculation ........................................9\n
    \     5.6. Setting the DO Bit on Replies ..............................9\n      5.7.
    Setting the AD Bit on Queries .............................10\n      5.8. Setting
    the AD Bit on Replies .............................10\n      5.9. Always Set the
    CD Bit on Queries ..........................10\n      5.10. Nested Trust Anchors
    .....................................11\n      5.11. Mandatory Algorithm Rules
    ................................11\n      5.12. Ignore Extra Signatures from Unknown
    Keys ................12\n   6. Minor Corrections and Clarifications ...........................12\n
    \     6.1. Finding Zone Cuts .........................................12\n      6.2.
    Clarifications on DNSKEY Usage ............................12\n      6.3. Errors
    in Examples ........................................13\n      6.4. Errors in RFC
    5155 ........................................13\n   7. Security Considerations
    ........................................13\n   8. References .....................................................14\n
    \     8.1. Normative References ......................................14\n      8.2.
    Informative References ....................................15\n   Appendix A.
    Acknowledgments .......................................16\n   Appendix B. Discussion
    of Setting the CD Bit ......................16\n   Appendix C. Discussion of Trust
    Anchor Preference Options .........19\n      C.1. Closest Encloser ..........................................19\n
    \     C.2. Accept Any Success ........................................20\n      C.3.
    Preference Based on Source ................................20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction and Terminology\n   This document lists some additions, clarifications,
    and corrections\n   to the core DNSSEC specification, as originally described
    in\n   [RFC4033], [RFC4034], and [RFC4035], and later amended by [RFC5155].\n
    \  (See Section 2 for more recent additions to that core document set.)\n   It
    is intended to serve as a resource for implementors and as a\n   repository of
    items existing at the time of writing that need to be\n   addressed when advancing
    the DNSSEC documents along the Standards\n   Track.\n"
  - contents:
    - "1.1.  Structure of This Document\n   The clarifications and changes to DNSSEC
      are sorted according to\n   their importance, starting with ones which could,
      if ignored, lead to\n   security problems and progressing down to clarifications
      that are\n   expected to have little operational impact.\n"
    title: 1.1.  Structure of This Document
  - contents:
    - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in\n   [RFC2119].\n"
    title: 1.2.  Terminology
  title: 1.  Introduction and Terminology
- contents:
  - "2.  Important Additions to DNSSEC\n   This section lists some documents that
    are now considered core DNSSEC\n   protocol documents in addition to those originally
    specified in\n   Section 10 of [RFC4033].\n"
  - contents:
    - "2.1.  NSEC3 Support\n   [RFC5155] describes the use and behavior of the NSEC3
      and NSEC3PARAM\n   records for hashed denial of existence.  Validator implementations\n
      \  are strongly encouraged to include support for NSEC3 because a number\n   of
      highly visible zones use it.  Validators that do not support\n   validation
      of responses using NSEC3 will be hampered in validating\n   large portions of
      the DNS space.\n   [RFC5155] is now considered part of the DNS Security Document
      Family\n   as described by Section 10 of [RFC4033].\n   Note that the algorithm
      identifiers defined in [RFC5155] (DSA-NSEC3-\n   SHA1 and RSASHA1-NSEC3-SHA1)
      and [RFC5702] (RSASHA256 and RSASHA512)\n   signal that a zone might be using
      NSEC3, rather than NSEC.  The zone\n   may be using either, and validators supporting
      these algorithms MUST\n   support both NSEC3 and NSEC responses.\n"
    title: 2.1.  NSEC3 Support
  - contents:
    - "2.2.  SHA-2 Support\n   [RFC4509] describes the use of SHA-256 as a digest
      algorithm in\n   Delegation Signer (DS) RRs.  [RFC5702] describes the use of
      the\n   RSASHA256 and RSASHA512 algorithms in DNSKEY and RRSIG RRs.\n   Validator
      implementations are strongly encouraged to include support\n   for these algorithms
      for DS, DNSKEY, and RRSIG records.\n   Both [RFC4509] and [RFC5702] are now
      considered part of the DNS\n   Security Document Family as described by Section
      10 of [RFC4033].\n"
    title: 2.2.  SHA-2 Support
  title: 2.  Important Additions to DNSSEC
- contents:
  - '3.  Scaling Concerns

    '
  - contents:
    - "3.1.  Implement a BAD Cache\n   Section 4.7 of [RFC4035] permits security-aware
      resolvers to\n   implement a BAD cache.  That guidance has changed: security-aware\n
      \  resolvers SHOULD implement a BAD cache as described in [RFC4035].\n   This
      change in guidance is based on operational experience with\n   DNSSEC administrative
      errors leading to significant increases in DNS\n   traffic, with an accompanying
      realization that such events are more\n   likely and more damaging than originally
      supposed.  An example of one\n   such event is documented in \"Rolling Over
      DNSSEC Keys\" [Huston].\n"
    title: 3.1.  Implement a BAD Cache
  title: 3.  Scaling Concerns
- contents:
  - "4.  Security Concerns\n   This section provides clarifications that, if overlooked,
    could lead\n   to security issues.\n"
  - contents:
    - "4.1.  Clarifications on Nonexistence Proofs\n   Section 5.4 of [RFC4035] under-specifies
      the algorithm for checking\n   nonexistence proofs.  In particular, the algorithm
      as presented would\n   allow a validator to interpret an NSEC or NSEC3 RR from
      an ancestor\n   zone as proving the nonexistence of an RR in a child zone.\n
      \  An \"ancestor delegation\" NSEC RR (or NSEC3 RR) is one with:\n   o  the
      NS bit set,\n   o  the Start of Authority (SOA) bit clear, and\n   o  a signer
      field that is shorter than the owner name of the NSEC RR,\n      or the original
      owner name for the NSEC3 RR.\n   Ancestor delegation NSEC or NSEC3 RRs MUST
      NOT be used to assume\n   nonexistence of any RRs below that zone cut, which
      include all RRs at\n   that (original) owner name other than DS RRs, and all
      RRs below that\n   owner name regardless of type.\n   Similarly, the algorithm
      would also allow an NSEC RR at the same\n   owner name as a DNAME RR, or an
      NSEC3 RR at the same original owner\n   name as a DNAME, to prove the nonexistence
      of names beneath that\n   DNAME.  An NSEC or NSEC3 RR with the DNAME bit set
      MUST NOT be used\n   to assume the nonexistence of any subdomain of that NSEC/NSEC3
      RR's\n   (original) owner name.\n"
    title: 4.1.  Clarifications on Nonexistence Proofs
  - contents:
    - "4.2.  Validating Responses to an ANY Query\n   [RFC4035] does not address how
      to validate responses when QTYPE=*.\n   As described in Section 6.2.2 of [RFC1034],
      a proper response to\n   QTYPE=* may include a subset of the RRsets at a given
      name.  That is,\n   it is not necessary to include all RRsets at the QNAME in
      the\n   response.\n   When validating a response to QTYPE=*, all received RRsets
      that match\n   QNAME and QCLASS MUST be validated.  If any of those RRsets fail\n
      \  validation, the answer is considered Bogus.  If there are no RRsets\n   matching
      QNAME and QCLASS, that fact MUST be validated according to\n   the rules in
      Section 5.4 of [RFC4035] (as clarified in this\n   document).  To be clear,
      a validator must not expect to receive all\n   records at the QNAME in response
      to QTYPE=*.\n"
    title: 4.2.  Validating Responses to an ANY Query
  - contents:
    - "4.3.  Check for CNAME\n   Section 5 of [RFC4035] says nothing explicit about
      validating\n   responses based on (or that should be based on) CNAMEs.  When\n
      \  validating a NOERROR/NODATA response, validators MUST check the CNAME\n   bit
      in the matching NSEC or NSEC3 RR's type bitmap in addition to the\n   bit for
      the query type.\n   Without this check, an attacker could successfully transform
      a\n   positive CNAME response into a NOERROR/NODATA response by (for\n   example)
      simply stripping the CNAME RRset from the response.  A naive\n   validator would
      then note that the QTYPE was not present in the\n   matching NSEC/NSEC3 RR,
      but fail to notice that the CNAME bit was\n   set; thus, the response should
      have been a positive CNAME response.\n"
    title: 4.3.  Check for CNAME
  - contents:
    - "4.4.  Insecure Delegation Proofs\n   Section 5.2 of [RFC4035] specifies that
      a validator, when proving a\n   delegation is not secure, needs to check for
      the absence of the DS\n   and SOA bits in the NSEC (or NSEC3) type bitmap.  The
      validator also\n   MUST check for the presence of the NS bit in the matching
      NSEC (or\n   NSEC3) RR (proving that there is, indeed, a delegation), or\n   alternately
      make sure that the delegation is covered by an NSEC3 RR\n   with the Opt-Out
      flag set.\n   Without this check, an attacker could reuse an NSEC or NSEC3 RR\n
      \  matching a non-delegation name to spoof an unsigned delegation at\n   that
      name.  This would claim that an existing signed RRset (or set of\n   signed
      RRsets) is below an unsigned delegation, thus not signed and\n   vulnerable
      to further attack.\n"
    title: 4.4.  Insecure Delegation Proofs
  title: 4.  Security Concerns
- contents:
  - '5.  Interoperability Concerns

    '
  - contents:
    - "5.1.  Errors in Canonical Form Type Code List\n   When canonicalizing DNS names
      (for both ordering and signing), DNS\n   names in the RDATA section of NSEC
      resource records are not converted\n   to lowercase.  DNS names in the RDATA
      section of RRSIG resource\n   records are converted to lowercase.\n   The guidance
      in the above paragraph differs from what has been\n   published before but is
      consistent with current common practice.\n   Item 3 of Section 6.2 of [RFC4034]
      says that names in both of these\n   RR types should be converted to lowercase.
      \ The earlier [RFC3755]\n   says that they should not.  Current practice follows
      neither document\n   fully.\n   Section 6.2 of [RFC4034] also erroneously lists
      HINFO as a record\n   that needs conversion to lowercase, and twice at that.
      \ Since HINFO\n   records contain no domain names, they are not subject to case\n
      \  conversion.\n"
    title: 5.1.  Errors in Canonical Form Type Code List
  - contents:
    - "5.2.  Unknown DS Message Digest Algorithms\n   Section 5.2 of [RFC4035] includes
      rules for how to handle delegations\n   to zones that are signed with entirely
      unsupported public key\n   algorithms, as indicated by the key algorithms shown
      in those zones'\n   DS RRsets.  It does not explicitly address how to handle
      DS records\n   that use unsupported message digest algorithms.  In brief, DS
      records\n   using unknown or unsupported message digest algorithms MUST be\n
      \  treated the same way as DS records referring to DNSKEY RRs of unknown\n   or
      unsupported public key algorithms.\n   The existing text says:\n      If the
      validator does not support any of the algorithms listed in\n      an authenticated
      DS RRset, then the resolver has no supported\n      authentication path leading
      from the parent to the child.  The\n      resolver should treat this case as
      it would the case of an\n      authenticated NSEC RRset proving that no DS RRset
      exists, as\n      described above.\n   In other words, when determining the
      security status of a zone, a\n   validator disregards any authenticated DS records
      that specify\n   unknown or unsupported DNSKEY algorithms.  If none are left,
      the zone\n   is treated as if it were unsigned.\n   This document modifies the
      above text to additionally disregard\n   authenticated DS records using unknown
      or unsupported message digest\n   algorithms.\n"
    title: 5.2.  Unknown DS Message Digest Algorithms
  - contents:
    - "5.3.  Private Algorithms\n   As discussed above, Section 5.2 of [RFC4035] requires
      that validators\n   make decisions about the security status of zones based
      on the public\n   key algorithms shown in the DS records for those zones.  In
      the case\n   of private algorithms, as described in Appendix A.1.1 of [RFC4034],\n
      \  the eight-bit algorithm field in the DS RR is not conclusive about\n   what
      algorithm(s) is actually in use.\n   If no private algorithms appear in the
      DS RRset, or if any supported\n   algorithm appears in the DS RRset, no special
      processing is needed.\n   Furthermore, if the validator implementation does
      not support any\n   private algorithms, or only supports private algorithms
      using an\n   algorithm number not present in the DS RRset, no special processing\n
      \  is needed.\n   In the remaining cases, the security status of the zone depends
      on\n   whether or not the resolver supports any of the private algorithms in\n
      \  use (provided that these DS records use supported message digest\n   algorithms,
      as discussed in Section 5.2 of this document).  In these\n   cases, the resolver
      MUST retrieve the corresponding DNSKEY for each\n   private algorithm DS record
      and examine the public key field to\n   determine the algorithm in use.  The
      security-aware resolver MUST\n   ensure that the hash of the DNSKEY RR's owner
      name and RDATA matches\n   the digest in the DS RR as described in Section 5.2
      of [RFC4035],\n   authenticating the DNSKEY.  If all of the retrieved and authenticated\n
      \  DNSKEY RRs use unknown or unsupported private algorithms, then the\n   zone
      is treated as if it were unsigned.\n   Note that if none of the private algorithm
      DS RRs can be securely\n   matched to DNSKEY RRs and no other DS establishes
      that the zone is\n   secure, the referral should be considered Bogus data as
      discussed in\n   [RFC4035].\n   This clarification facilitates the broader use
      of private algorithms,\n   as suggested by [RFC4955].\n"
    title: 5.3.  Private Algorithms
  - contents:
    - "5.4.  Caution about Local Policy and Multiple RRSIGs\n   When multiple RRSIGs
      cover a given RRset, Section 5.3.3 of [RFC4035]\n   suggests that \"the local
      resolver security policy determines whether\n   the resolver also has to test
      these RRSIG RRs and how to resolve\n   conflicts if these RRSIG RRs lead to
      differing results\".\n   This document specifies that a resolver SHOULD accept
      any valid RRSIG\n   as sufficient, and only determine that an RRset is Bogus
      if all\n   RRSIGs fail validation.\n   If a resolver adopts a more restrictive
      policy, there's a danger that\n   properly signed data might unnecessarily fail
      validation due to cache\n   timing issues.  Furthermore, certain zone management
      techniques, like\n   the Double Signature Zone Signing Key Rollover method described
      in\n   Section 4.2.1.2 of [RFC6781], will not work reliably.  Such a\n   resolver
      is also vulnerable to malicious insertion of gibberish\n   signatures.\n"
    title: 5.4.  Caution about Local Policy and Multiple RRSIGs
  - contents:
    - "5.5.  Key Tag Calculation\n   Appendix B.1 of [RFC4034] incorrectly defines
      the Key Tag field\n   calculation for algorithm 1.  It correctly says that the
      Key Tag is\n   the most significant 16 of the least significant 24 bits of the\n
      \  public key modulus.  However, [RFC4034] then goes on to incorrectly\n   say
      that this is fourth-to-last and third-to-last octets of the\n   public key modulus.
      \ It is, in fact, the third-to-last and second-to-\n   last octets.\n"
    title: 5.5.  Key Tag Calculation
  - contents:
    - "5.6.  Setting the DO Bit on Replies\n   As stated in Section 3 of [RFC3225],
      the DNSSEC OK (DO) bit of the\n   query MUST be copied in the response.  However,
      in order to\n   interoperate with implementations that ignore this rule on sending,\n
      \  resolvers MUST ignore the DO bit in responses.\n"
    title: 5.6.  Setting the DO Bit on Replies
  - contents:
    - "5.7.  Setting the AD Bit on Queries\n   The semantics of the Authentic Data
      (AD) bit in the query were\n   previously undefined.  Section 4.6 of [RFC4035]
      instructed resolvers\n   to always clear the AD bit when composing queries.\n
      \  This document defines setting the AD bit in a query as a signal\n   indicating
      that the requester understands and is interested in the\n   value of the AD
      bit in the response.  This allows a requester to\n   indicate that it understands
      the AD bit without also requesting\n   DNSSEC data via the DO bit.\n"
    title: 5.7.  Setting the AD Bit on Queries
  - contents:
    - "5.8.  Setting the AD Bit on Replies\n   Section 3.2.3 of [RFC4035] describes
      under which conditions a\n   validating resolver should set or clear the AD
      bit in a response.  In\n   order to interoperate with legacy stub resolvers
      and middleboxes that\n   neither understand nor ignore the AD bit, validating
      resolvers SHOULD\n   only set the AD bit when a response both meets the conditions
      listed\n   in Section 3.2.3 of [RFC4035], and the request contained either a
      set\n   DO bit or a set AD bit.\n"
    title: 5.8.  Setting the AD Bit on Replies
  - contents:
    - "5.9.  Always Set the CD Bit on Queries\n   When processing a request with the
      Checking Disabled (CD) bit set, a\n   resolver SHOULD attempt to return all
      response data, even data that\n   has failed DNSSEC validation.  Section 3.2.2
      of [RFC4035] requires a\n   resolver processing a request with the CD bit set
      to set the CD bit\n   on its upstream queries.\n   This document further specifies
      that validating resolvers SHOULD set\n   the CD bit on every upstream query.
      \ This is regardless of whether\n   the CD bit was set on the incoming query
      or whether it has a trust\n   anchor at or above the QNAME.\n   [RFC4035] is
      ambiguous about what to do when a cached response was\n   obtained with the
      CD bit unset, a case that only arises when the\n   resolver chooses not to set
      the CD bit on all upstream queries, as\n   specified above.  In the typical
      case, no new query is required, nor\n   does the cache need to track the state
      of the CD bit used to make a\n   given query.  The problem arises when the cached
      response is a server\n   failure (RCODE 2), which may indicate that the requested
      data failed\n   DNSSEC validation at an upstream validating resolver.  ([RFC2308]\n
      \  permits caching of server failures for up to five minutes.)  In these\n   cases,
      a new query with the CD bit set is required.\n   Appendix B discusses more of
      the logic behind the recommendation\n   presented in this section.\n"
    title: 5.9.  Always Set the CD Bit on Queries
  - contents:
    - "5.10.  Nested Trust Anchors\n   A DNSSEC validator may be configured such that,
      for a given response,\n   more than one trust anchor could be used to validate
      the chain of\n   trust to the response zone.  For example, imagine a validator\n
      \  configured with trust anchors for \"example.\" and \"zone.example.\"\n   When
      the validator is asked to validate a response to\n   \"www.sub.zone.example.\",
      either trust anchor could apply.\n   When presented with this situation, DNSSEC
      validators have a choice\n   of which trust anchor(s) to use.  Which to use
      is a matter of\n   implementation choice.  Appendix C discusses several possible\n
      \  algorithms.\n   It is possible and advisable to expose the choice of policy
      as a\n   configuration option.  As a default, it is suggested that validators\n
      \  implement the \"Accept Any Success\" policy described in Appendix C.2\n   while
      exposing other policies as configuration options.\n   The \"Accept Any Success\"
      policy is to try all applicable trust\n   anchors until one gives a validation
      result of Secure, in which case\n   the final validation result is Secure.  If
      and only if all applicable\n   trust anchors give a result of Insecure, the
      final validation result\n   is Insecure.  If one or more trust anchors lead
      to a Bogus result and\n   there is no Secure result, then the final validation
      result is Bogus.\n"
    title: 5.10.  Nested Trust Anchors
  - contents:
    - "5.11.  Mandatory Algorithm Rules\n   The last paragraph of Section 2.2 of [RFC4035]
      includes rules\n   describing which algorithms must be used to sign a zone.
      \ Since these\n   rules have been confusing, they are restated using different
      language\n   here:\n      The DS RRset and DNSKEY RRset are used to signal which
      algorithms\n      are used to sign a zone.  The presence of an algorithm in
      either a\n      zone's DS or DNSKEY RRset signals that that algorithm is used
      to\n      sign the entire zone.\n      A signed zone MUST include a DNSKEY for
      each algorithm present in\n      the zone's DS RRset and expected trust anchors
      for the zone.  The\n      zone MUST also be signed with each algorithm (though
      not each key)\n      present in the DNSKEY RRset.  It is possible to add algorithms
      at\n      the DNSKEY that aren't in the DS record, but not vice versa.  If\n
      \     more than one key of the same algorithm is in the DNSKEY RRset, it\n      is
      sufficient to sign each RRset with any subset of these DNSKEYs.\n      It is
      acceptable to sign some RRsets with one subset of keys (or\n      key) and other
      RRsets with a different subset, so long as at least\n      one DNSKEY of each
      algorithm is used to sign each RRset.\n      Likewise, if there are DS records
      for multiple keys of the same\n      algorithm, any subset of those may appear
      in the DNSKEY RRset.\n   This requirement applies to servers, not validators.
      \ Validators\n   SHOULD accept any single valid path.  They SHOULD NOT insist
      that all\n   algorithms signaled in the DS RRset work, and they MUST NOT insist\n
      \  that all algorithms signaled in the DNSKEY RRset work.  A validator\n   MAY
      have a configuration option to perform a signature completeness\n   test to
      support troubleshooting.\n"
    title: 5.11.  Mandatory Algorithm Rules
  - contents:
    - "5.12.  Ignore Extra Signatures from Unknown Keys\n   Validating resolvers MUST
      disregard RRSIGs in a zone that do not\n   (currently) have a corresponding
      DNSKEY in the zone.  Similarly, a\n   validating resolver MUST disregard RRSIGs
      with algorithm types that\n   don't exist in the DNSKEY RRset.\n   Good key
      rollover and algorithm rollover practices, as discussed in\n   RFC 6781 and
      its successor documents and as suggested by the rules in\n   the previous section,
      may require that such RRSIGs be present in a\n   zone.\n"
    title: 5.12.  Ignore Extra Signatures from Unknown Keys
  title: 5.  Interoperability Concerns
- contents:
  - '6.  Minor Corrections and Clarifications

    '
  - contents:
    - "6.1.  Finding Zone Cuts\n   Appendix C.8 of [RFC4035] discusses sending DS
      queries to the servers\n   for a parent zone but does not state how to find
      those servers.\n   Specific instructions can be found in Section 4.2 of [RFC4035].\n"
    title: 6.1.  Finding Zone Cuts
  - contents:
    - "6.2.  Clarifications on DNSKEY Usage\n   It is possible to use different DNSKEYs
      to sign different subsets of\n   a zone, constrained only by the rules in Section
      5.11.  It is even\n   possible to use a different DNSKEY for each RRset in a
      zone, subject\n   only to practical limits on the size of the DNSKEY RRset and
      the\n   above rules.  However, be aware that there is no way to tell\n   resolvers
      what a particular DNSKEY is supposed to be used for -- any\n   DNSKEY in the
      zone's signed DNSKEY RRset may be used to authenticate\n   any RRset in the
      zone.  For example, if a weaker or less trusted\n   DNSKEY is being used to
      authenticate NSEC RRsets or all dynamically\n   updated records, that same DNSKEY
      can also be used to sign any other\n   RRsets from the zone.\n   Furthermore,
      note that the SEP bit setting has no effect on how a\n   DNSKEY may be used
      -- the validation process is specifically\n   prohibited from using that bit
      by Section 2.1.2 of [RFC4034].  It is\n   possible to use a DNSKEY without the
      SEP bit set as the sole secure\n   entry point to the zone, yet use a DNSKEY
      with the SEP bit set to\n   sign all RRsets in the zone (other than the DNSKEY
      RRset).  It is\n   also possible to use a single DNSKEY, with or without the
      SEP bit\n   set, to sign the entire zone, including the DNSKEY RRset itself.\n"
    title: 6.2.  Clarifications on DNSKEY Usage
  - contents:
    - "6.3.  Errors in Examples\n   The text in Appendix C.1 of [RFC4035] refers to
      the examples in\n   Appendix B.1 as \"x.w.example.com\" while B.1 uses \"x.w.example\".
      \ This\n   is painfully obvious in the second paragraph where it states that
      the\n   RRSIG labels field value of 3 indicates that the answer was not the\n
      \  result of wildcard expansion.  This is true for \"x.w.example\" but not\n
      \  for \"x.w.example.com\", which of course has a label count of 4\n   (antithetically,
      a label count of 3 would imply the answer was the\n   result of a wildcard expansion).\n
      \  The first paragraph of Appendix C.6 of [RFC4035] also has a minor\n   error:
      the reference to \"a.z.w.w.example\" should instead be\n   \"a.z.w.example\",
      as in the previous line.\n"
    title: 6.3.  Errors in Examples
  - contents:
    - "6.4.  Errors in RFC 5155\n   An NSEC3 record that matches an Empty Non-Terminal
      effectively has no\n   type associated with it.  This NSEC3 record has an empty
      type bit\n   map.  Section 3.2.1 of [RFC5155] contains the statement:\n      Blocks
      with no types present MUST NOT be included.\n   However, the same section contains
      a regular expression:\n      Type Bit Maps Field = ( Window Block # | Bitmap
      Length | Bitmap )+\n   The plus sign in the regular expression indicates that
      there is one\n   or more of the preceding element.  This means that there must
      be at\n   least one window block.  If this window block has no types, it\n   contradicts
      with the first statement.  Therefore, the correct text in\n   Section 3.2.1
      of [RFC5155] should be:\n      Type Bit Maps Field = ( Window Block # | Bitmap
      Length | Bitmap )*\n"
    title: 6.4.  Errors in RFC 5155
  title: 6.  Minor Corrections and Clarifications
- contents:
  - "7.  Security Considerations\n   This document adds SHA-2 and NSEC3 support to
    the core DNSSEC\n   protocol.  Security considerations for those features are
    discussed\n   in the documents defining them.  Additionally, this document\n   addresses
    some ambiguities and omissions in the core DNSSEC documents\n   that, if not recognized
    and addressed in implementations, could lead\n   to security failures.  In particular,
    the validation algorithm\n   clarifications in Section 4 are critical for preserving
    the security\n   properties DNSSEC offers.  Furthermore, failure to address some
    of\n   the interoperability concerns in Section 5 could limit the ability to\n
    \  later change or expand DNSSEC, including adding new algorithms.\n   The recommendation
    in Section 5.9 to always set the CD bit has\n   security implications.  By setting
    the CD bit, a resolver will not\n   benefit from more stringent validation rules
    or a more complete set\n   of trust anchors at an upstream validator.\n"
  title: 7.  Security Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names -
      concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3225]  Conrad, D., \"Indicating
      Resolver Support of DNSSEC\",\n              RFC 3225, December 2001.\n   [RFC4033]
      \ Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"DNS Security Introduction and Requirements\",\n              RFC 4033, March
      2005.\n   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n
      \             Rose, \"Resource Records for the DNS Security Extensions\",\n
      \             RFC 4034, March 2005.\n   [RFC4035]  Arends, R., Austein, R.,
      Larson, M., Massey, D., and S.\n              Rose, \"Protocol Modifications
      for the DNS Security\n              Extensions\", RFC 4035, March 2005.\n   [RFC4509]
      \ Hardaker, W., \"Use of SHA-256 in DNSSEC Delegation Signer\n              (DS)
      Resource Records (RRs)\", RFC 4509, May 2006.\n   [RFC5155]  Laurie, B., Sisson,
      G., Arends, R., and D. Blacka, \"DNS\n              Security (DNSSEC) Hashed
      Authenticated Denial of\n              Existence\", RFC 5155, March 2008.\n
      \  [RFC5702]  Jansen, J., \"Use of SHA-2 Algorithms with RSA in DNSKEY\n              and
      RRSIG Resource Records for DNSSEC\", RFC 5702,\n              October 2009.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [Huston]   Michaelson, G., Wallstrom, P.,
      Arends, R., and G. Huston,\n              \"Rolling Over DNSSEC Keys\", Internet
      Protocol\n              Journal, Vol. 13, No.1, pp. 2-16, March 2010.\n   [RFC2308]
      \ Andrews, M., \"Negative Caching of DNS Queries (DNS\n              NCACHE)\",
      RFC 2308, March 1998.\n   [RFC3755]  Weiler, S., \"Legacy Resolver Compatibility
      for Delegation\n              Signer (DS)\", RFC 3755, May 2004.\n   [RFC4955]
      \ Blacka, D., \"DNS Security (DNSSEC) Experiments\", RFC 4955,\n              July
      2007.\n   [RFC5011]  StJohns, M., \"Automated Updates of DNS Security (DNSSEC)\n
      \             Trust Anchors\", STD 74, RFC 5011, September 2007.\n   [RFC5074]
      \ Weiler, S., \"DNSSEC Lookaside Validation (DLV)\", RFC 5074,\n              November
      2007.\n   [RFC6781]  Kolkman, O., Mekking, W., and R. Gieben, \"DNSSEC\n              Operational
      Practices, Version 2\", RFC 6781,\n              December 2012.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Appendix A.  Acknowledgments\n   The editors would like the thank Rob Austein
    for his previous work as\n   an editor of this document.\n   The editors are extremely
    grateful to those who, in addition to\n   finding errors and omissions in the
    DNSSEC document set, have\n   provided text suitable for inclusion in this document.\n
    \  The lack of specificity about handling private algorithms, as\n   described
    in Section 5.3, and the lack of specificity in handling ANY\n   queries, as described
    in Section 4.2, were discovered by David\n   Blacka.\n   The error in algorithm
    1 key tag calculation, as described in\n   Section 5.5, was found by Abhijit Hayatnagarkar.
    \ Donald Eastlake\n   contributed text for Section 5.5.\n   The bug relating to
    delegation NSEC RR's in Section 4.1 was found by\n   Roy Badami.  Roy Arends found
    the related problem with DNAME.\n   The errors in the [RFC4035] examples were
    found by Roy Arends, who\n   also contributed text for Section 6.3 of this document.\n
    \  Text on the mandatory algorithm rules was derived from suggestions by\n   Matthijs
    Mekking and Ed Lewis.\n   The CD bit logic was analyzed in depth by David Blacka,
    Olafur\n   Gudmundsson, Mike St. Johns, and Andrew Sullivan.\n   The editors would
    like to thank Alfred Hoenes, Ed Lewis, Danny Mayer,\n   Olafur Gudmundsson, Suzanne
    Woolf, Rickard Bellgrim, Mike St. Johns,\n   Mark Andrews, Wouter Wijngaards,
    Matthijs Mekking, Andrew Sullivan,\n   Jeremy Reed, Paul Hoffman, Mohan Parthasarathy,
    Florian Weimer,\n   Warren Kumari and Scott Rose for their contributions to this\n
    \  document.\n"
  title: Appendix A.  Acknowledgments
- contents:
  - "Appendix B.  Discussion of Setting the CD Bit\n   [RFC4035] may be read as relying
    on the implicit assumption that\n   there is at most one validating system between
    the stub resolver and\n   the authoritative server for a given zone.  It is entirely
    possible,\n   however, for more than one validator to exist between a stub resolver\n
    \  and an authoritative server.  If these different validators have\n   disjoint
    trust anchors configured, then it is possible that each\n   would be able to validate
    some portion of the DNS tree, but neither\n   is able to validate all of it.  Accordingly,
    it might be argued that\n   it is desirable not to set the CD bit on upstream
    queries, because\n   that allows for maximal validation.\n   In Section 5.9 of
    this document, it is recommended to set the CD bit\n   on an upstream query even
    when the incoming query arrives with CD=0.\n   This is for two reasons: it encourages
    a more predictable validation\n   experience as only one validator is always doing
    the validation, and\n   it ensures that all DNSSEC data that exists may be available
    from the\n   local cache should a query with CD=1 arrive.\n   As a matter of policy,
    it is possible to set the CD bit differently\n   than suggested in Section 5.9.
    \ A different choice will, of course,\n   not always yield the benefits listed
    above.  It is beyond the scope\n   of this document to outline all of the considerations
    and counter\n   considerations for all possible policies.  Nevertheless, it is\n
    \  possible to describe three approaches and their underlying philosophy\n   of
    operation.  These are laid out in the tables below.\n   The table that describes
    each model has five columns.  The first\n   column indicates the value of the
    CD bit that the resolver receives\n   (for instance, on the name server side in
    an iterative resolver, or\n   as local policy or from the API in the case of a
    stub).  The second\n   column indicates whether the query needs to be forwarded
    for\n   resolution (F) or can be satisfied from a local cache (C).  The third\n
    \  column is a line number, so that it can be referred to later in the\n   table.
    \ The fourth column indicates any relevant conditions at the\n   resolver, for
    example, whether the resolver has a covering trust\n   anchor, and so on.  If
    there are no parameters here, the column is\n   empty.  The fifth and final column
    indicates what action the resolver\n   takes.\n   The tables differentiate between
    \"cached data\" and \"cached RCODE=2\".\n   This is a shorthand; the point is
    that one has to treat RCODE=2\n   (server failure) as special, because it might
    indicate a validation\n   failure somewhere upstream.  The distinction is really
    between\n   \"cached RCODE=2\" and \"cached everything else\".\n   The tables
    are probably easiest to think of in terms of describing\n   what happens when
    a stub resolver sends a query to an intermediate\n   resolver, but they are perfectly
    general and can be applied to any\n   validating resolver.\n   Model 1: \"always
    set\"\n   This model is so named because the validating resolver sets the CD\n
    \  bit on queries it makes regardless of whether it has a covering trust\n   anchor
    for the query.  The general philosophy represented by this\n   table is that only
    one resolver should be responsible for validation\n   irrespective of the possibility
    that an upstream resolver may be\n   present with trust anchors that cover different
    or additional QNAMEs.\n   It is the model recommended in Section 5.9 of this document.\n
    \   CD F/C    line      conditions            action\n    ====================================================================\n
    \   1   F      A1                             Set CD=1 on upstream query\n    0
    \  F      A2                             Set CD=1 on upstream query\n    1   C
    \     A3                             Return the cache contents\n                                               (data
    or RCODE=2)\n    0   C      A4       no covering TA        Return cache contents\n
    \                                              (data or RCODE=2)\n    0   C      A5
    \      covering TA           Validate cached result and\n                                               return
    it\n   Model 2: \"never set when receiving CD=0\"\n   This model is so named because
    it sets CD=0 on upstream queries for\n   all received CD=0 queries, even if it
    has a covering trust anchor.\n   The general philosophy represented by this table
    is that more than\n   one resolver may take responsibility for validating a QNAME
    and that\n   a validation failure for a QNAME by any resolver in the chain is
    a\n   validation failure for the query.  Using this model is NOT\n   RECOMMENDED.\n
    \   CD F/C    line       conditions           action\n    ====================================================================\n
    \   1  F      N1                              Set CD=1 on upstream query\n    0
    \ F      N2                              Set CD=0 on upstream query\n    1  C
    \     N3         cached data          Return cached data\n    1  C      N4         cached
    RCODE=2       Treat as line N1\n    0  C      N5         no covering TA       Return
    cache contents\n                                               (data or RCODE=2)\n
    \   0  C      N6         covering TA &        Treat as line N2\n                          cached
    data was\n                          generated with CD=1\n    0  C      N7         covering
    TA &        Validate and return\n                          cached data was\n                          generated
    with CD=0\n   Model 3: \"sometimes set\"\n   This model is so named because it
    sets the CD bit on upstream queries\n   triggered by received CD=0 queries, based
    on whether the validator\n   has a trust anchor configured that covers the query.
    \ If there is no\n   covering trust anchor, the resolver clears the CD bit in
    the upstream\n   query.  If there is a covering trust anchor, the resolver sets
    CD=1\n   and performs validation itself.  The general philosophy represented\n
    \  by this table is that a resolver should try and validate QNAMEs for\n   which
    it has trust anchors and should not preclude validation by\n   other resolvers
    for QNAMEs for which it does not have covering trust\n   anchors.  Using this
    model is NOT RECOMMENDED.\n    CD F/C    line       conditions         action\n
    \   ====================================================================\n    1
    \ F      S1                            Set CD=1 on upstream query\n    0  F      S2
    \        covering TA        Set CD=1 on upstream query\n    0  F      S3         no
    covering TA     Set CD=0 on upstream query\n    1  C      S4         cached data
    \       Return cached data\n    1  C      S5         cached RCODE=2     Treat
    as line S1\n    0  C      S6         cached data was    Return cache contents\n
    \                         generated with\n                          CD=0\n    0
    \ C      S7         cached data was    Validate & return cache\n                          generated
    with     contents\n                          CD=1 &\n                          covering
    TA\n    0  C      S8         cached RCODE=2     Return cache contents\n    0  C
    \     S9         cached data        Treat as line S3\n                          was
    generated\n                          with CD=1 &\n                          no
    covering\n                          TA\n"
  title: Appendix B.  Discussion of Setting the CD Bit
- contents:
  - "Appendix C.  Discussion of Trust Anchor Preference Options\n   This section presents
    several different policies for validating\n   resolvers to use when they have
    a choice of trust anchors available\n   for validating a given answer.\n"
  - contents:
    - "C.1.  Closest Encloser\n   One policy is to choose the trust anchor closest
      to the QNAME of the\n   response.  For example, consider a validator configured
      with trust\n   anchors for \"example.\" and \"zone.example.\"  When asked to
      validate a\n   response for \"www.sub.zone.example.\", a validator using the
      \"Closest\n   Encloser\" policy would choose the \"zone.example.\" trust anchor.\n
      \  This policy has the advantage of allowing the operator to trivially\n   override
      a parent zone's trust anchor with one that the operator can\n   validate in
      a stronger way, perhaps because the resolver operator is\n   affiliated with
      the zone in question.  This policy also minimizes the\n   number of public key
      operations needed, which is of benefit in\n   resource-constrained environments.\n
      \  This policy has the disadvantage of giving the user some unexpected\n   and
      unnecessary validation failures when sub-zone trust anchors are\n   neglected.
      \ As a concrete example, consider a validator that\n   configured a trust anchor
      for \"zone.example.\" in 2009 and one for\n   \"example.\" in 2011.  In 2012,
      \"zone.example.\" rolls its Key Signing\n   Key (KSK) and updates its DS records,
      but the validator operator\n   doesn't update its trust anchor.  With the \"Closest
      Encloser\" policy,\n   the validator gets validation failures.\n"
    title: C.1.  Closest Encloser
  - contents:
    - "C.2.  Accept Any Success\n   Another policy is to try all applicable trust
      anchors until one gives\n   a validation result of Secure, in which case the
      final validation\n   result is Secure.  If and only if all applicable trust
      anchors give a\n   result of Insecure, the final validation result is Insecure.
      \ If one\n   or more trust anchors lead to a Bogus result and there is no Secure\n
      \  result, then the final validation result is Bogus.\n   This has the advantage
      of causing the fewest validation failures,\n   which may deliver a better user
      experience.  If one trust anchor is\n   out of date (as in our above example),
      the user may still be able to\n   get a Secure validation result (and see DNS
      responses).\n   This policy has the disadvantage of making the validator subject
      to\n   the compromise of the weakest of these trust anchors, while making it\n
      \  relatively painless to keep old trust anchors configured in\n   perpetuity.\n"
    title: C.2.  Accept Any Success
  - contents:
    - "C.3.  Preference Based on Source\n   When the trust anchors have come from
      different sources (e.g.,\n   automated updates ([RFC5011]), one or more DNSSEC
      Lookaside\n   Validation (DLV) registries ([RFC5074]), and manual configuration),
      a\n   validator may wish to choose between them based on the perceived\n   reliability
      of those sources.  The order of precedence might be\n   exposed as a configuration
      option.\n   For example, a validator might choose to prefer trust anchors found\n
      \  in a DLV registry over those manually configured on the theory that\n   the
      manually configured ones will not be as aggressively maintained.\n   Conversely,
      a validator might choose to prefer manually configured\n   trust anchors over
      those obtained from a DLV registry on the theory\n   that the manually configured
      ones have been more carefully\n   authenticated.\n   Or the validator might
      do something more complex: prefer a sub-set of\n   manually configured trust
      anchors (based on a configuration option),\n   then trust anchors that have
      been updated using the mechanism in\n   [RFC5011], then trust anchors from one
      DLV registry, then trust\n   anchors from a different DLV registry, then the
      rest of the manually\n   configured trust anchors.\n"
    title: C.3.  Preference Based on Source
  title: Appendix C.  Discussion of Trust Anchor Preference Options
- contents:
  - "Authors' Addresses\n   Samuel Weiler (editor)\n   SPARTA, Inc.\n   7110 Samuel
    Morse Drive\n   Columbia, MD  21046\n   US\n   EMail: weiler@tislabs.com\n   David
    Blacka (editor)\n   Verisign, Inc.\n   12061 Bluemont Way\n   Reston, VA  20190\n
    \  US\n   EMail: davidb@verisign.com\n"
  title: Authors' Addresses
