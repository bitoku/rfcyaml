- title: __initial_text__
  contents:
  - '                         TCP/IP Field Behavior

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes TCP/IP field behavior in the context of header\n\
    \   compression.  Header compression is possible because most header\n   fields\
    \ do not vary randomly from packet to packet.  Many of the\n   fields exhibit\
    \ static behavior or change in a more or less\n   predictable way.  When a header\
    \ compression scheme is designed, it is\n   of fundamental importance to understand\
    \ the behavior of the fields in\n   detail.  An example of this analysis can be\
    \ seen in RFC 3095.  This\n   memo performs a similar role for the compression\
    \ of TCP/IP headers.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. General classification ..........................................4\n  \
    \    2.1. IP Header Fields ...........................................5\n    \
    \     2.1.1. IPv6 Header Fields ....................................5\n      \
    \   2.1.2. IPv4 Header Fields ....................................7\n      2.2.\
    \ TCP Header Fields .........................................10\n      2.3. Summary\
    \ for IP/TCP ........................................11\n   3. Classification\
    \ of Replicable Header Fields .....................11\n      3.1. IPv4 Header\
    \ (Inner and/or Outer) ..........................12\n      3.2. IPv6 Header (inner\
    \ and/or outer) ..........................14\n      3.3. TCP Header ................................................14\n\
    \      3.4. TCP Options ...............................................15\n  \
    \    3.5. Summary of Replication ....................................16\n   4.\
    \ Analysis of Change Patterns of Header Fields ...................16\n      4.1.\
    \ IP Header .................................................19\n         4.1.1.\
    \ IP Traffic-Class / Type-Of-Service (TOS) .............19\n         4.1.2. ECN\
    \ Flags ............................................19\n         4.1.3. IP Identification\
    \ ....................................20\n         4.1.4. Don't Fragment (DF)\
    \ flag .............................22\n         4.1.5. IP Hop-Limit / Time-To-Live\
    \ (TTL) ....................22\n      4.2. TCP Header ................................................23\n\
    \         4.2.1. Sequence Number ......................................23\n  \
    \       4.2.2. Acknowledgement Number ...............................24\n    \
    \     4.2.3. Reserved .............................................25\n      \
    \   4.2.4. Flags ................................................25\n        \
    \ 4.2.5. Checksum .............................................26\n         4.2.6.\
    \ Window ...............................................26\n         4.2.7. Urgent\
    \ Pointer .......................................27\n      4.3. Options ...................................................27\n\
    \         4.3.1. Options Overview .....................................28\n  \
    \       4.3.2. Option Field Behavior ................................29\n   5.\
    \ Other Observations .............................................36\n      5.1.\
    \ Implicit Acknowledgements .................................36\n      5.2. Shared\
    \ Data ...............................................36\n      5.3. TCP Header\
    \ Overhead .......................................37\n      5.4. Field Independence\
    \ and Packet Behavior ....................37\n      5.5. Short-Lived Flows .........................................37\n\
    \      5.6. Master Sequence Number ....................................38\n  \
    \    5.7. Size Constraint for TCP Options ...........................38\n   6.\
    \ Security Considerations ........................................39\n   7. Acknowledgements\
    \ ...............................................39\n   8. References .....................................................40\n\
    \      8.1. Normative References ......................................40\n  \
    \    8.2. Informative References ....................................41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the format of the TCP/IP header\
    \ and the\n   header field behavior, i.e., how fields vary within a TCP flow.\
    \  The\n   description is presented in the context of header compression.\n  \
    \ Since the IP header does exhibit slightly different behavior from\n   that previously\
    \ presented in RFC 3095 [31] for UDP and RTP, it is\n   also included in this\
    \ document.\n   This document borrows much of the classification text from RFC\
    \ 3095\n   [31], rather than inserting many references to that document.\n   According\
    \ to the format presented in RFC 3095 [31], TCP/IP header\n   fields are classified\
    \ and analyzed in two steps.  First, we have a\n   general classification in Section\
    \ 2, where the fields are classified\n   on the basis of stable knowledge and\
    \ assumptions.  This general\n   classification does not take into account the\
    \ change characteristics\n   of changing fields, as those will vary more or less\
    \ depending on the\n   implementation and on the application used.  Section 3\
    \ considers how\n   field values can be used to optimize short-lived flows.  A\
    \ more\n   detailed analysis of the change characteristics is then done in\n \
    \  Section 4.  Finally, Section 5 summarizes with conclusions about how\n   the\
    \ various header fields should be handled by the header compression\n   scheme\
    \ to optimize compression.\n   A general question raised by this analysis is:\
    \ what 'baseline'\n   definition of all possible TCP/IP implementations is to\
    \ be\n   considered?  This review is based on an analysis of currently\n   deployed\
    \ TCP implementations supporting mechanisms standardised by\n   the IETF.\n  \
    \ The general requirement for transparency is also interesting.  A\n   number\
    \ of recent proposals for extensions to TCP use some of the\n   previously 'reserved'\
    \ bits in the TCP packet header.  Therefore, a\n   'reserved' bit cannot be taken\
    \ to have a guaranteed zero value; it\n   may change.  Ideally, this should be\
    \ accommodated by the compression\n   profile.\n   A number of reserved bits are\
    \ available for future expansion.  A\n   treatment of field behavior cannot predict\
    \ the future use of such\n   bits, but we expect that they will be used at some\
    \ point.  Given\n   this, a compression scheme can optimise for the current situation\
    \ but\n   should be capable of supporting any arbitrary usage of the reserved\n\
    \   bits.  However, it is impossible to optimise for usage patterns that\n   have\
    \ yet to be defined.\n"
- title: 2.  General classification
  contents:
  - "2.  General classification\n   The following definitions (and some text) are\
    \ copied from RFC 3095\n   [31], Appendix A.  Differences of IP field behavior\
    \ between RFC 3095\n   [31] (i.e., IP/UDP/RTP behavior for audio and video applications)\
    \ and\n   this document have been identified.\n   For the following, we define\
    \ \"session\" as a TCP packet stream, being\n   a series of packets with the same\
    \ IP addresses and port numbers.  A\n   packet flow is defined by certain fields\
    \ (see STATIC-DEF, below) and\n   may be considered a subset of a session.  See\
    \ [31] for a fuller\n   discussion of separation of sessions into streams of packets\
    \ for\n   header compression.\n   At a general level, the header fields are separated\
    \ into 5 classes:\n   o  INFERRED\n         These fields contain values that can\
    \ be inferred from other\n         values (for example, the size of the frame\
    \ carrying the packet)\n         and thus do not have to be handled at all by\
    \ the compression\n         scheme.\n   o  STATIC\n         These fields are expected\
    \ to be constant throughout the\n         lifetime of the packet stream.  Static\
    \ information must in some\n         way be communicated once.\n   o  STATIC-DEF\n\
    \         STATIC fields whose values define a packet stream.  They are in\n  \
    \       general handled as STATIC.\n   o  STATIC-KNOWN\n         These STATIC\
    \ fields are expected to have well-known values and\n         therefore do not\
    \ need to be communicated at all.\n   o  CHANGING\n         These fields are expected\
    \ to vary randomly within a limited\n         value set or range or in some other\
    \ manner.\n   In this section, each of the IP and TCP header fields is assigned\
    \ to\n   one of these classes.  For all fields except those classified as\n  \
    \ CHANGING, the motives for the classification are also stated.  In\n   section\
    \ 4, CHANGING fields are further examined and classified on the\n   basis of their\
    \ expected change behavior.\n"
- title: 2.1.  IP Header Fields
  contents:
  - '2.1.  IP Header Fields

    '
- title: 2.1.1.  IPv6 Header Fields
  contents:
  - "2.1.1.  IPv6 Header Fields\n          +---------------------+-------------+----------------+\n\
    \          |        Field        | Size (bits) |      Class     |\n          +---------------------+-------------+----------------+\n\
    \          | Version             |      4      |     STATIC     |\n          |\
    \ DSCP*               |      6      |   ALTERNATING  |\n          | ECT flag*\
    \           |      1      |    CHANGING    |\n          | CE  flag*          \
    \ |      1      |    CHANGING    |\n          | Flow Label          |     20 \
    \     |   STATIC-DEF   |\n          | Payload Length      |     16      |    INFERRED\
    \    |\n          | Next Header         |      8      |     STATIC     |\n   \
    \       | Hop Limit           |      8      |    CHANGING    |\n          | Source\
    \ Address      |    128      |   STATIC-DEF   |\n          | Destination Address\
    \ |    128      |   STATIC-DEF   |\n          +---------------------+-------------+----------------+\n\
    \               * Differs from RFC 3095 [31].  (The DSCP, ECT,\n             \
    \    and CE flags were amalgamated into the Traffic\n                 Class octet\
    \ in RFC 3095).\n                          Figure 1.  IPv6 Header Fields\n   o\
    \  Version\n         The version field states which IP version is used.  Packets\n\
    \         with different values in this field must be handled by\n         different\
    \ IP stacks.  All packets of a packet stream must\n         therefore be of the\
    \ same IP version.  Accordingly, the field is\n         classified as STATIC.\n\
    \   o  Flow Label\n         This field may be used to identify packets belonging\
    \ to a\n         specific packet stream.  If the field is not used, its value\n\
    \         should be zero.  Otherwise, all packets belonging to the same\n    \
    \     stream must have the same value in this field, it being one of\n       \
    \  the fields that define the stream.  The field is therefore\n         classified\
    \ as STATIC-DEF.\n   o  Payload Length\n         Information about packet length\
    \ (and, consequently, payload\n         length) is expected to be provided by\
    \ the link layer.  The\n         field is therefore classified as INFERRED.\n\
    \   o  Next Header\n         This field will usually have the same value in all\
    \ packets of a\n         packet stream.  It encodes the type of the subsequent\
    \ header.\n         Only when extension headers are sometimes absent will the\
    \ field\n         change its value during the lifetime of the stream.  The field\n\
    \         is therefore classified as STATIC.  The classification of\n        \
    \ STATIC is inherited from RFC 3095 [31].  However, note that the\n         next\
    \ header field is actually determined by the type of the\n         following header.\
    \  Thus, it might be more appropriate to view\n         this as an inference,\
    \ although this depends upon the specific\n         implementation of the compression\
    \ scheme.\n   o  Source and Destination Addresses\n         These fields are part\
    \ of the definition of a stream and\n         therefore must be constant for all\
    \ packets in the stream.  The\n         fields are therefore classified as STATIC-DEF.\n\
    \         This might be considered as a slightly simplistic view.  In\n      \
    \   this document, the IP addresses are associated with the\n         transport\
    \ layer connection and assumed to be part of the\n         definition of a flow.\
    \  More complex flow-separation could, of\n         course, be considered (see\
    \ also RFC 3095 [31] for more\n         discussion of this issue).  Where tunneling\
    \ is being performed,\n         the use of the IP addresses in outer tunnel headers\
    \ is also\n         assumed to be STATIC-DEF.\n   The total size of the fields\
    \ in each class is as follows:\n                      +--------------+--------------+\n\
    \                      | Class        | Size (octets)|\n                     \
    \ +--------------+--------------+\n                      | INFERRED     |    \
    \  2       |\n                      | STATIC       |      1.5     |\n        \
    \              | STATIC-DEF   |     34.5     |\n                      | STATIC-KNOWN\
    \ |      0       |\n                      | CHANGING     |      2       |\n  \
    \                    +--------------+--------------+\n                       \
    \    Figure 2: Field sizes\n"
- title: 2.1.2.  IPv4 Header Fields
  contents:
  - "2.1.2.  IPv4 Header Fields\n           +---------------------+-------------+----------------+\n\
    \           | Field               | Size (bits) |      Class     |\n         \
    \  +---------------------+-------------+----------------+\n           | Version\
    \             |      4      |      STATIC    |\n           | Header Length   \
    \    |      4      |   STATIC-KNOWN |\n           | DSCP*               |    \
    \  6      |   ALTERNATING  |\n           | ECT flag*           |      1      |\
    \     CHANGING   |\n           | CE  flag*           |      1      |     CHANGING\
    \   |\n           | Packet Length       |     16      |     INFERRED   |\n   \
    \        | Identification      |     16      |     CHANGING   |\n           |\
    \ Reserved flag*      |      1      |     CHANGING   |\n           | Don't Fragment\
    \ flag*|      1      |     CHANGING   |\n           | More Fragments flag |  \
    \    1      |   STATIC-KNOWN |\n           | Fragment Offset     |     13    \
    \  |   STATIC-KNOWN |\n           | Time To Live        |      8      |     CHANGING\
    \   |\n           | Protocol            |      8      |      STATIC    |\n   \
    \        | Header Checksum     |     16      |     INFERRED   |\n           |\
    \ Source Address      |     32      |    STATIC-DEF  |\n           | Destination\
    \ Address |     32      |    STATIC-DEF  |\n           +---------------------+-------------+----------------+\n\
    \                 * Differs from RFC 3095 [31].  (The DSCP, ECT\n            \
    \       and CE flags were amalgamated into the TOS\n                   octet in\
    \ RFC 3095; the DF flag behavior is\n                   considered later; the\
    \ reserved field is\n                   discussed below).\n                  \
    \     Figure 3.  IPv4 Header Fields\n   o  Version\n         The version field\
    \ states which IP version is used.  Packets\n         with different values in\
    \ this field must be handled by\n         different IP stacks.  All packets of\
    \ a packet stream must\n         therefore be of the same IP version.  Accordingly,\
    \ the field is\n         classified as STATIC.\n   o  Header Length\n        \
    \ As long as no options are present in the IP header, the header\n         length\
    \ is constant and well known.  If there are options, the\n         fields would\
    \ be STATIC, but it is assumed here that there are\n         no options.  The\
    \ field is therefore classified as STATIC-KNOWN.\n   o  Packet Length\n      \
    \   Information about packet length is expected to be provided by\n         the\
    \ link layer.  The field is therefore classified as INFERRED.\n   o  Flags\n \
    \        The Reserved flag must be set to zero, as defined in RFC 791\n      \
    \   [1].  In RFC 3095 [31] the field is therefore classified as\n         STATIC-KNOWN.\
    \  However, it is expected that reserved fields may\n         be used at some\
    \ future point.  It is undesirable to select an\n         encoding that would\
    \ preclude the use of a compression profile\n         for a future change in the\
    \ use of reserved fields.  For this\n         reason, the alternative encoding\
    \ of CHANGING is used.  (A\n         compression profile can, of course, still\
    \ optimise for the\n         current situation, where the field value is known\
    \ to be 0).\n         The More Fragments (MF) flag is expected to be zero because\n\
    \         fragmentation is, ideally, not expected.  However, it is also\n    \
    \     understood that some scenarios (for example, some tunnelling\n         architectures)\
    \ do cause fragmentation.  In general, though,\n         fragmentation is not\
    \ expected to be common in the Internet due\n         to a combination of initial\
    \ MSS negotiation and subsequent use\n         of path-MTU discovery.  RFC 3095\
    \ [31] points out that, for RTP,\n         only the first fragment will contain\
    \ the transport layer\n         protocol header; subsequent fragments would have\
    \ to be\n         compressed with a different profile.  This is also obviously\n\
    \         the case for TCP.  If fragmentation were to occur, the first\n     \
    \    fragment, by definition, would be relatively large, minimizing\n        \
    \ the header overhead.  Subsequent fragments would be compressed\n         with\
    \ another profile.  It is therefore considered undesirable\n         to optimise\
    \ for fragmentation in performing header compression.\n         The More Fragments\
    \ flag is therefore classified as STATIC-\n         KNOWN.\n   o  Fragment Offset\n\
    \         Under the assumption that no fragmentation occurs, the fragment\n  \
    \       offset is always zero.  The field is therefore classified as\n       \
    \  STATIC-KNOWN.  Even if fragmentation were to be further\n         considered,\
    \ only the first fragment would contain the TCP\n         header, and the fragment\
    \ offset of this packet would still be\n         zero.\n   o  Protocol\n     \
    \    This field will usually have the same value in all packets of a\n       \
    \  packet stream.  It encodes the type of the subsequent header.\n         Only\
    \ where the sequence of headers changes (e.g., an extension\n         header is\
    \ inserted or deleted or a tunnel header is added or\n         removed) will the\
    \ field change its value.  The field is\n         therefore classified as STATIC.\
    \  Whether such a change would\n         cause the sequence of packets to be treated\
    \ as a new flow (for\n         header compression) is an issue for profile design.\
    \  ROHC\n         profiles must be able to cope with extension headers and\n \
    \        tunnelling, but the choice of strategy is outside the scope of\n    \
    \     this document.\n   o  Header Checksum\n         The header checksum protects\
    \ individual hops from processing a\n         corrupted header.  When almost all\
    \ IP header information is\n         compressed away, there is no point in having\
    \ this additional\n         checksum.  Instead, it can be regenerated at the decompressor\n\
    \         side.  The field is therefore classified as INFERRED.\n         Note\
    \ that the TCP checksum does not protect the whole TCP/IP\n         header, but\
    \ only the TCP pseudo-header (and the payload).\n         Compare this with ROHC\
    \ [31], which uses a CRC to verify the\n         uncompressed header.  Given the\
    \ need to validate the complete\n         TCP/IP header, the cost of computing\
    \ the TCP checksum over the\n         entire payload, and known weaknesses in\
    \ the TCP checksum [37],\n         an additional check is necessary.  Therefore,\
    \ it is highly\n         desirable that some additional checksum (such as a CRC)\
    \ will be\n         used to validate correct decompression.\n   o  Source and\
    \ Destination Addresses\n         These fields are part of the definition of a\
    \ stream and must\n         thus be constant for all packets in the stream.  The\
    \ fields are\n         therefore classified as STATIC-DEF.\n   The total size\
    \ of the fields in each class is as follows:\n                      +--------------+--------------+\n\
    \                      | Class        | Size (octets)|\n                     \
    \ +--------------+--------------+\n                      | INFERRED     |    \
    \  4       |\n                      | STATIC*      |      1.5     |\n        \
    \              | STATIC-DEF   |      8       |\n                      | STATIC-KNOWN*|\
    \      2.25    |\n                      | CHANGING*    |      4.25    |\n    \
    \                  +--------------+--------------+\n                         *\
    \ Differs from RFC 3095 [31]\n                          Figure 4.  Field sizes\n"
- title: 2.2.  TCP Header Fields
  contents:
  - "2.2.  TCP Header Fields\n          +---------------------+-------------+----------------+\n\
    \          | Field               | Size (bits) |      Class     |\n          +---------------------+-------------+----------------+\n\
    \          | Source Port         |     16      |    STATIC-DEF  |\n          |\
    \ Destination Port    |     16      |    STATIC-DEF  |\n          | Sequence Number\
    \     |     32      |     CHANGING   |\n          | Acknowledgement Num |    \
    \ 32      |     CHANGING   |\n          | Data Offset         |      4      |\
    \     INFERRED   |\n          | Reserved            |      4      |     CHANGING\
    \   |\n          | CWR flag            |      1      |     CHANGING   |\n    \
    \      | ECE flag            |      1      |     CHANGING   |\n          | URG\
    \ flag            |      1      |     CHANGING   |\n          | ACK flag     \
    \       |      1      |     CHANGING   |\n          | PSH flag            |  \
    \    1      |     CHANGING   |\n          | RST flag            |      1     \
    \ |     CHANGING   |\n          | SYN flag            |      1      |     CHANGING\
    \   |\n          | FIN flag            |      1      |     CHANGING   |\n    \
    \      | Window              |     16      |     CHANGING   |\n          | Checksum\
    \            |     16      |     CHANGING   |\n          | Urgent Pointer    \
    \  |     16      |     CHANGING   |\n          | Options             |   0(-352)\
    \   |     CHANGING   |\n          +---------------------+-------------+----------------+\n\
    \                        Figure 5: TCP header fields\n   o  Source and Destination\
    \ ports\n      These fields are part of the definition of a stream and must thus\n\
    \      be constant for all packets in the stream.  The fields are\n      therefore\
    \ classified as STATIC-DEF.\n   o  Data Offset\n      The number of 4 octet words\
    \ in the TCP header, indicating the\n      start of the data.  It is always a\
    \ multiple of 4 octets.  It can\n      be re-constructed from the length of any\
    \ options, and thus it is\n      not necessary to carry this explicitly.  The\
    \ field is therefore\n      classified as INFERRED.\n"
- title: 2.3.  Summary for IP/TCP
  contents:
  - "2.3.  Summary for IP/TCP\n   Summarizing this for IP/TCP, one obtains the following:\n\
    \          +----------------+----------------+----------------+\n          | Class\
    \ \\ IP ver | IPv6 (octets)  | IPv4 (octets)  |\n          +----------------+----------------+----------------+\n\
    \          | INFERRED       |   2 + 4 bits   |   4 + 4 bits   |\n          | STATIC\
    \         |   1 + 4 bits   |   1 + 4 bits   |\n          | STATIC-DEF     |  38\
    \ + 4 bits   |      12        |\n          | STATIC-KNOWN   |       -        |\
    \   2 + 2 bits   |\n          | CHANGING       |  17 + 4 bits   |  19 + 6 bits\
    \   |\n          +----------------+----------------+----------------+\n      \
    \    | Totals         |     60         |     40         |\n          +----------------+----------------+----------------+\n\
    \          (Excludes options, which are all classified as CHANGING).\n       \
    \               Figure 6.  Overall field sizes\n"
- title: 3.  Classification of Replicable Header Fields
  contents:
  - "3.  Classification of Replicable Header Fields\n   Where multiple flows either\
    \ overlap in time or occur sequentially\n   within a short space of time, there\
    \ can be a great deal of similarity\n   in header field values.  Such commonality\
    \ of field values is\n   reflected in the compression context.  Thus, it should\
    \ be possible to\n   utilise commonality between fields across different flows\
    \ to improve\n   the compression ratio.  In order to do this, it is important\
    \ to\n   understand the 'replicable' characteristics of the various header\n \
    \  fields.\n   The key concept is that of 'replication': an existing context is\
    \ used\n   as a baseline and replicated to initialise a new context.  Those\n\
    \   fields that are the same are then automatically initialised in the\n   new\
    \ context.  Those that have changed will be updated or overwritten\n   with values\
    \ from the initialisation packet that triggered the\n   replication.  This section\
    \ considers the commonality between fields\n   in different flows.\n   Note, however,\
    \ that replication is based on contexts (rather than on\n   just field values),\
    \ so compressor-created fields that are part of the\n   context may also be included.\
    \  These, of course, are dependent upon\n   the nature of the compression protocol\
    \ (ROHC profile) being applied.\n   A brief analysis of the relationship of TCP/IP\
    \ fields among\n   'replicable' packet streams follows.\n      'N/A': The field\
    \ need not be considered in the replication\n            process, as it is inferred\
    \ or known 'a priori' (and,\n            therefore, does not appear in the context).\n\
    \      'No': The field cannot be replicated since its change pattern\n       \
    \     between two packet flows is uncorrelated.\n      'Yes': The field may be\
    \ replicated.  This does not guarantee that\n            the field value will\
    \ be the same across two candidate\n            streams, only that it might be\
    \ possible to exploit\n            replication to increase the compression ratio.\
    \  Specific\n            encoding methods can be used to improve the compression\n\
    \            efficiency.\n"
- title: 3.1.  IPv4 Header (Inner and/or Outer)
  contents:
  - "3.1.  IPv4 Header (Inner and/or Outer)\n          +-----------------------+---------------+------------+\n\
    \          | Field                 | Class         | Replicable |\n          +-----------------------+---------------+------------+\n\
    \          | Version               | STATIC        | N/A        |\n          |\
    \ Header Length         | STATIC-KNOWN  | N/A        |\n          | DSCP     \
    \             | ALTERNATING   | No  (1)    |\n          | ECT flag           \
    \   | CHANGING      | No  (2)    |\n          | CE flag               | CHANGING\
    \      | No  (2)    |\n          | Packet Length         | INFERRED      | N/A\
    \        |\n          | Identification        | CHANGING      | Yes (3)    |\n\
    \          | Reserved flag         | CHANGING      | No  (4)    |\n          |\
    \ Don't Fragment flag   | CHANGING      | Yes (5)    |\n          | More Fragments\
    \ flag   | STATIC-KNOWN  | N/A        |\n          | Fragment Offset       | STATIC-KNOWN\
    \  | N/A        |\n          | Time To Live          | CHANGING      | Yes   \
    \     |\n          | Protocol              | STATIC        | N/A        |\n  \
    \        | Header Checksum       | INFERRED      | N/A        |\n          | Source\
    \ Address        | STATIC-DEF    | Yes        |\n          | Destination Address\
    \   | STATIC-DEF    | Yes        |\n          +-----------------------+---------------+------------+\n\
    \                           Figure 7: IPv4 header\n   (1) The DSCP is marked according\
    \ to the application's requirements.\n       If it can be assumed that replicable\
    \ connections belong to the\n       same diffserv class, then it is likely that\
    \ the DSCP will be\n       replicable.  The DSCP can be set not only by the sender\
    \ but by\n       any packet marker.  Thus, a flow may have a number of DSCP values\n\
    \       at different points in the network.  However, header compression\n   \
    \    operates on a point-to-point link and so would expect to see a\n       relatively\
    \ stable value.  If re-marking is being done based on\n       the state of a meter,\
    \ then the value may change mid-flow.\n       Overall, though, we expect supporting\
    \ replication of the DSCP to\n       be useful for header compression.\n   (2)\
    \ It is not possible for the ECN bits to be replicated (note that\n       use\
    \ of the ECN nonce scheme [19] is anticipated).  However, it\n       seems likely\
    \ that all TCP flows between ECN-capable hosts will\n       use ECN, the use (or\
    \ not) of ECN for flows between the same end-\n       points might be considered\
    \ replicable.  See also note (4).\n   (3) The replicable context for this field\
    \ includes the IP-ID, NBO,\n       and RND flags (as described in ROHC RTP). \
    \ This highlights that\n       the replication is of the context, rather than\
    \ just the header\n       field values and, as such, needs to be considered based\
    \ on the\n       exact nature of compression applied to each field.\n   (4) Since\
    \ the possible future behavior of the 'Reserved Flag' cannot\n       be predicted,\
    \ it is not considered as replicable.  However, it\n       might be expected that\
    \ the behavior of the reserved flag between\n       the same end-points will be\
    \ similar.  In this case, any selection\n       of packet formats (for example)\
    \ based on this behavior might\n       carry across to the new flow.  In the case\
    \ of packet formats,\n       this can probably be considered as a compressor-local\
    \ decision.\n   (5) In theory, the DF bit may be replicable.  However, this is\
    \ not\n       guaranteed and, in practice, it is unlikely to be useful to do\n\
    \       this.  From the perspective of header compression, having to\n       indicate\
    \ whether or not a 1-bit flag should be replicated or\n       specified explicitly\
    \ is likely to require more bits than simply\n       conveying the value of the\
    \ flag.  We do not rule out DF\n       replication.\n"
- title: 3.2.  IPv6 Header (inner and/or outer)
  contents:
  - "3.2.  IPv6 Header (inner and/or outer)\n          +-----------------------+---------------+------------+\n\
    \          | Field                 | Class         | Replicable |\n          +-----------------------+---------------+------------+\n\
    \          | Version               | STATIC        | N/A        |\n          |\
    \ Traffic Class         | CHANGING      | Yes (1)    |\n          | ECT flag \
    \             | CHANGING      | No  (2)    |\n          | CE flag            \
    \   | CHANGING      | No  (2)    |\n          | Flow Label            | STATIC-DEF\
    \    | N/A        |\n          | Payload Length        | INFERRED      | N/A \
    \       |\n          | Next Header           | STATIC        | N/A        |\n\
    \          | Hop Limit             | CHANGING      | Yes        |\n          |\
    \ Source Address        | STATIC-DEF    | Yes        |\n          | Destination\
    \ Address   | STATIC-DEF    | Yes        |\n          +-----------------------+---------------+------------+\n\
    \            (1) See comment about DSCP field for IPv4, above.\n            (2)\
    \ See comment about ECT and CE flags for IPv4, above.\n                      \
    \    Figure 8.  IPv6 Header\n"
- title: 3.3.  TCP Header
  contents:
  - "3.3.  TCP Header\n          +-----------------------+---------------+------------+\n\
    \          | Field                 | Class         | Replicable |\n          +-----------------------+---------------+------------+\n\
    \          | Source Port           | STATIC-DEF    |  Yes (1)   |\n          |\
    \ Destination Port      | STATIC-DEF    |  Yes (1)   |\n          | Sequence Number\
    \       | CHANGING      |  No  (2)   |\n          | Acknowledgement Number| CHANGING\
    \      |  No        |\n          | Data Offset           | INFERRED      |  N/A\
    \       |\n          | Reserved Bits         | CHANGING      |  No  (3)   |\n\
    \          | Flags                 |               |            |\n          |\
    \         CWR           | CHANGING      |  No  (4)   |\n          |         ECE\
    \           | CHANGING      |  No  (4)   |\n          |         URG          \
    \ | CHANGING      |  No        |\n          |         ACK           | CHANGING\
    \      |  No        |\n          |         PSH           | CHANGING      |  No\
    \        |\n          |         RST           | CHANGING      |  No        |\n\
    \          |         SYN           | CHANGING      |  No        |\n          |\
    \         FIN           | CHANGING      |  No        |\n          | Window   \
    \             | CHANGING      |  Yes       |\n          | Checksum           \
    \   | CHANGING      |  No        |\n          | Urgent Pointer        | CHANGING\
    \      |  Yes (5)   |\n          +-----------------------+---------------+------------+\n\
    \                           Figure 9: TCP Header\n   (1) On the server side, the\
    \ port number is likely to be a well-known\n       value.  On the client side,\
    \ the port number is generally selected\n       by the stack automatically.  Whether\
    \ the port number is\n       replicable depends upon how the stack chooses the\
    \ port number.\n       Whilst most implementations use a simple scheme that sequentially\n\
    \       picks the next available port number, it may not be desirable to\n   \
    \    rely on this behavior.\n   (2) With the recommendation (and expected deployment)\
    \ of TCP Initial\n       Sequence Number randomization, defined in RFC 1948 [10],\
    \ it will\n       be impossible to share the sequence number.  Thus, this field\n\
    \       will not be regarded as replicable.\n   (3) See comment (4) for the IPv4\
    \ header, above.\n   (4) See comment (2) on ECN flags for the IPv4 header, above.\n\
    \   (5) The urgent pointer is very rarely used.  This means that, in\n       practice,\
    \ the field may be considered replicable.\n"
- title: 3.4.  TCP Options
  contents:
  - "3.4.  TCP Options\n          +---------------------------+--------------+------------+\n\
    \          | Option                    | SYN-only (1) | Replicable |\n       \
    \   +---------------------------+--------------+------------+\n          | End\
    \ of Option List        | No           | No   (2)   |\n          | No-Operation\
    \              | No           | No   (2)   |\n          | Maximum Segment Size\
    \      | Yes          | Yes        |\n          | Window Scale              |\
    \ Yes          | Yes        |\n          | SACK-Permitted            | Yes   \
    \       | Yes        |\n          | SACK                      | No           |\
    \ No         |\n          | Timestamp                 | No           | No    \
    \     |\n          +---------------------------+--------------+------------+\n\
    \                             Figure 10.  TCP Options\n   (1) This indicates whether\
    \ the option only appears in SYN packets.\n       Options that are not 'SYN-only'\
    \ may appear in any packet.  Many\n       TCP options are used only in SYN packets.\
    \  Some options, such as\n       MSS, Window Scale, and SACK-Permitted, will tend\
    \ to have the same\n       value among replicable packet streams.\n       Thus,\
    \ to support context sharing, the compressor should maintain\n       such TCP\
    \ options in the context (even though they only appear in\n       the SYN segment).\n\
    \   (2) Since these options have fixed values, they could be regarded as\n   \
    \    replicable.  However, the only interesting thing to convey about\n      \
    \ these options is their presence.  If it is known that such an\n       option\
    \ exists, its value is defined.\n"
- title: 3.5.  Summary of Replication
  contents:
  - "3.5.  Summary of Replication\n   From the above analysis, it can be seen that\
    \ there are reasonable\n   grounds for exploiting redundancy between flows as\
    \ well as between\n   packets within a flow.  Simply consider the advantage of\
    \ being able\n   to elide the source and destination addresses for a repeated\n\
    \   connection between two IPv6 endpoints.  There will also be a cost (in\n  \
    \ terms of complexity and robustness) for replicating contexts, and\n   this must\
    \ be considered when one decides what constitutes an\n   appropriate solution.\n\
    \   Finally, note that the use of replication requires that the\n   compressor\
    \ have a suitable degree of confidence that the source data\n   is present and\
    \ correct at the decompressor.  This may place some\n   restrictions on which\
    \ of the 'changing' fields, in particular, can be\n   utilised during replication.\n"
- title: 4.  Analysis of Change Patterns of Header Fields
  contents:
  - "4.  Analysis of Change Patterns of Header Fields\n   To design suitable mechanisms\
    \ for efficient compression of all header\n   fields, their change patterns must\
    \ be analyzed.  For this reason, an\n   extended classification is done based\
    \ on the general classification\n   in 2, considering the fields that were labeled\
    \ CHANGING in that\n   classification.\n   The CHANGING fields are separated into\
    \ five different subclasses:\n   o  STATIC\n      These are fields that were classified\
    \ as CHANGING on a general\n      basis, but that are classified as STATIC here\
    \ due to certain\n      additional assumptions.\n   o  SEMISTATIC\n      These\
    \ fields are STATIC most of the time.  However, occasionally\n      the value\
    \ changes but reverts to its original value after a known\n      number of packets.\n\
    \   o  RARELY-CHANGING (RC)\n      These are fields that change their values occasionally\
    \ and then\n      keep their new values.\n   o  ALTERNATING\n      These fields\
    \ alternate between a small number of different values.\n   o  IRREGULAR\n   \
    \   These, finally, are the fields for which no useful change pattern\n      can\
    \ be identified.\n   To further expand the classification possibilities without\
    \ increasing\n   complexity, the classification can be done either according to\
    \ the\n   values of the field and/or according to the values of the deltas for\n\
    \   the field.\n   When the classification is done, other details are also stated\n\
    \   regarding possible additional knowledge about the field values and/or\n  \
    \ field deltas, according to the classification.  For fields classified\n   as\
    \ STATIC or SEMISTATIC, the value of the field could be not only\n   STATIC but\
    \ also well-KNOWN a priori (two states for SEMISTATIC\n   fields).  For fields\
    \ with non-irregular change behavior, it could be\n   known that changes are usually\
    \ within a LIMITED range compared to the\n   maximal change for the field.  For\
    \ other fields, the values are\n   completely UNKNOWN.\n   Figure 11 classifies\
    \ all the CHANGING fields on the basis of their\n   expected change patterns.\
    \ (4) refers to IPv4 fields and (6) refers to\n   IPv6.\n   +------------------------+-------------+-------------+-------------+\n\
    \   | Field                  | Value/Delta |    Class    |  Knowledge  |\n   +========================+=============+=============+=============+\n\
    \   | DSCP(4) / Tr.Class(6)  | Value       | ALTERNATING |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP ECT flag(4)         | Value       |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP CE flag(4)          | Value       |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   |             Sequential | Delta       |    STATIC   |    KNOWN    |\n   |\
    \             -----------+-------------+-------------+-------------+\n   | IP\
    \ Id(4)     Seq. jump | Delta       |      RC     |   LIMITED   |\n   |      \
    \       -----------+-------------+-------------+-------------+\n   |         \
    \        Random | Value       |  IRREGULAR  |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP DF flag(4)          | Value       |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP TTL(4) / Hop Lim(6) | Value       | ALTERNATING |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Sequence Number    | Delta       |  IRREGULAR  |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Acknowledgement Num| Delta       |  IRREGULAR  |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Reserved           | Value       |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP flags              |             |             |             |\n   |\
    \     ECN flags          | Value       |  IRREGULAR  |   UNKNOWN   |\n   |   \
    \  CWR flag           | Value       |  IRREGULAR  |   UNKNOWN   |\n   |     ECE\
    \ flag           | Value       |  IRREGULAR  |   UNKNOWN   |\n   |     URG flag\
    \           | Value       |  IRREGULAR  |   UNKNOWN   |\n   |     ACK flag   \
    \        | Value       |  SEMISTATIC |    KNOWN    |\n   |     PSH flag      \
    \     | Value       |  IRREGULAR  |   UNKNOWN   |\n   |     RST flag         \
    \  | Value       |  IRREGULAR  |   UNKNOWN   |\n   |     SYN flag           |\
    \ Value       |  SEMISTATIC |    KNOWN    |\n   |     FIN flag           | Value\
    \       |  SEMISTATIC |    KNOWN    |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Window             | Value       | ALTERNATING |    KNOWN    |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Checksum           | Value       |  IRREGULAR  |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Urgent Pointer     | Value       |  IRREGULAR  |    KNOWN    |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | TCP Options            | Value       |  IRREGULAR  |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \               Figure 11.  Classification of CHANGING Fields\n   The following\
    \ subsections discuss the various header fields in\n   detail.  Note that Table\
    \ 1 and the discussion below do not consider\n   changes caused by loss or reordering\
    \ before the compression point.\n"
- title: 4.1.  IP Header
  contents:
  - '4.1.  IP Header

    '
- title: 4.1.1.  IP Traffic-Class / Type-Of-Service (TOS)
  contents:
  - "4.1.1.  IP Traffic-Class / Type-Of-Service (TOS)\n   The Traffic-Class (IPv6)\
    \ or Type-Of-Service/DSCP (IPv4) field might\n   be expected to change during\
    \ the lifetime of a packet stream.  This\n   analysis considers several RFCs that\
    \ describe modifications to the\n   original RFC 791 [1].\n   The TOS byte was\
    \ initially described in RFC 791 [1] as 3 bits of\n   precedence followed by 3\
    \ bits of TOS and 2 reserved bits (defined to\n   be zero).  RFC 1122 [21] extended\
    \ this to specify 5 bits of TOS,\n   although the meanings of the additional 2\
    \ bits were not defined.  RFC\n   1349 [23] defined the 4th bit of TOS as 'minimize\
    \ monetary cost'.\n   The next significant change was in RFC 2474 [14] (obsoleting\
    \ RFC 1349\n   [23]).  RFC 2474 reworked the TOS octet as 6 bits of DSCP (DiffServ\n\
    \   Code Point) plus 2 unused bits.  Most recently, RFC 2780 [30]\n   identified\
    \ the 2 reserved bits in the TOS or traffic class octet for\n   experimental use\
    \ with ECN.\n   It is therefore proposed that the TOS (or traffic class) octet\
    \ be\n   classified as 6 bits for the DSCP and 2 additional bits.  These 2\n \
    \  bits may be expected to be zero or to contain ECN data.  From a\n   future-proofing\
    \ perspective, it is preferable to assume the use of\n   ECN, especially with\
    \ respect to TCP.\n   It is also considered important that the profile work with\
    \ legacy\n   stacks, since these will be in existence for some considerable time\n\
    \   to come.  For simplicity, this will be considered as 6 bits of TOS\n   information\
    \ and 2 bits of ECN data, so the fields are always\n   considered to be structured\
    \ the same way.\n   The DSCP (as for TOS in ROHC RTP) is not expected to change\n\
    \   frequently (although it could change mid-flow, for example, as a\n   result\
    \ of a route change).\n"
- title: 4.1.2.  ECN Flags
  contents:
  - "4.1.2.  ECN Flags\n   Initially, we describe the ECN flags as specified in RFC\
    \ 2481 [15]\n   and RFC 3168 [18].  Subsequently, a suggested update is described\n\
    \   that would alter the behavior of the flags.\n   In RFC 2481 [15] there are\
    \ 2 separate flags, the ECT (ECN Capable\n   Transport) flag and the CE (Congestion\
    \ Experienced) flag.  The ECT\n   flag, if negotiated by the TCP stack, will be\
    \ '1' for all data\n   packets and '0' for all 'pure acknowledgement' packets.\
    \  This means\n   that the behavior of the ECT flag is linked to behavior in the\
    \ TCP\n   stack.  Whether this can be exploited for compression is not clear.\n\
    \   The CE flag is only used if ECT is set to '1'.  It is set to '0' by\n   the\
    \ sender and can be set to '1' by an ECN-capable router in the\n   network to\
    \ indicate congestion.  Thus the CE flag is expected to be\n   randomly set to\
    \ '1' with a probability dependent on the congestion\n   state of the network\
    \ and the position of the compressor in the path.\n   Therefore, a compressor\
    \ located close to the receiver in a congested\n   network will see the CE bit\
    \ set frequently, but a compressor located\n   close to a sender will rarely,\
    \ if ever, see the CE bit set to '1'.\n   A recent experimental proposal [19]\
    \ suggests an alternative view of\n   these 2 bits.  This considers the two bits\
    \ together to have 4\n   possible codepoints.  Meanings are then assigned to the\
    \ codepoints:\n      00 Not ECN capable\n      01 ECN capable, no congestion (known\
    \ as ECT(0))\n      10 ECN capable, no congestion (known as ECT(1))\n      11\
    \ Congestion experienced\n   The use of 2 codepoints for signaling ECT allows\
    \ the sender to detect\n   when a receiver is not reliably echoing congestion\
    \ information.\n   For the purposes of compression, this update means that ECT(0)\
    \ and\n   ECT(1) are equally likely (for an ECN capable flow) and that '11'\n\
    \   will be seen relatively rarely.  The probability of seeing a\n   congestion\
    \ indication is discussed above in the description of the CE\n   flag.\n   It\
    \ is suggested that, for the purposes of compression, ECN with\n   nonces be assumed\
    \ as the baseline, although the compression scheme\n   must be able to compress\
    \ the original ECN scheme transparently.\n"
- title: 4.1.3.  IP Identification
  contents:
  - "4.1.3.  IP Identification\n   The Identification field (IP ID) of the IPv4 header\
    \ identifies which\n   fragments constitute a datagram, when fragmented datagrams\
    \ are\n   reassembled.  The IPv4 specification does not specify exactly how\n\
    \   this field is to be assigned values, only that each packet should get\n  \
    \ an IP ID that is unique for the source-destination pair and protocol\n   for\
    \ the time during which the datagram (or any of its fragments)\n   could be alive\
    \ in the network.  This means that assignment of IP ID\n   values can be done\
    \ in various ways, which we have separated into\n   three classes:\n   o  Sequential\
    \ jump\n      This is the most common assignment policy in today's IP stacks.\
    \  A\n      single IP ID counter is used for all packet streams.  When the\n \
    \     sender is running more than one packet stream simultaneously, the\n    \
    \  IP ID can increase by more than one between packets in a stream.\n      The\
    \ IP ID values will be much more predictable and will require\n      fewer bits\
    \ to transfer than random values, and the packet-to-\n      packet increment (determined\
    \ by the number of active outgoing\n      packet streams and sending frequencies)\
    \ will usually be limited.\n   o  Random\n      Some IP stacks assign IP ID values\
    \ by using a pseudo-random number\n      generator.  There is thus no correlation\
    \ between the ID values of\n      subsequent datagrams.  Therefore, there is no\
    \ way to predict the\n      IP ID value for the next datagram.  For header compression\n\
    \      purposes, this means that the IP ID field needs to be sent\n      uncompressed\
    \ with each datagram, resulting in two extra octets of\n      header.  IP stacks\
    \ in cellular terminals that need optimum header\n      compression efficiency\
    \ should not use this IP ID assignment\n      policy.\n   o  Sequential\n    \
    \  This assignment policy keeps a separate counter for each outgoing\n      packet\
    \ stream, and thus the IP ID value will increment by one for\n      each packet\
    \ in the stream, except at wrap around.  Therefore, the\n      delta value of\
    \ the field is constant and well known a priori.\n      This assignment policy\
    \ is the most desirable for header\n      compression purposes.  However, its\
    \ usage is not as common as it\n      perhaps should be.\n      In order to avoid\
    \ violating RFC 791 [1], packets sharing the same\n      IP address pair and IP\
    \ protocol number cannot use the same IP ID\n      values.  Therefore, implementations\
    \ of sequential policies must\n      make the ID number spaces disjoint for packet\
    \ streams of the same\n      IP protocol going between the same pair of nodes.\
    \  This can be\n      done in a number of ways, all of which introduce occasional\
    \ jumps\n      and thus make the policy less than perfectly sequential.  For\n\
    \      header compression purposes, less frequent jumps are preferred.\n   Note\
    \ that the ID is an IPv4 mechanism and is therefore not a problem\n   for IPv6.\
    \  For IPv4, the ID could be handled in three different ways.\n   First, we have\
    \ the inefficient but reliable solution where the ID\n   field is sent as-is in\
    \ all packets, increasing the compressed headers\n   by two octets.  This is the\
    \ best way to handle the ID field if the\n   sender uses random assignment of\
    \ the ID field.  Second, there can be\n   solutions with more flexible mechanisms\
    \ that require fewer bits for\n   the ID handling as long as sequential jump assignment\
    \ is used.  Such\n   solutions will probably require even more bits if random\
    \ assignment\n   is used by the sender.  Knowledge about the sender's assignment\n\
    \   policy could therefore be useful when choosing between the two\n   solutions\
    \ above.  Finally, even for IPv4, header compression could be\n   designed without\
    \ any additional information for the ID field included\n   in compressed headers.\
    \  To use such schemes, it must be known which\n   assignment policy for the ID\
    \ field is being used by the sender.  That\n   might not be possible to know,\
    \ which implies that the applicability\n   of such solutions is very uncertain.\
    \  However, designers of IPv4\n   stacks for cellular terminals should use an\
    \ assignment policy close\n   to sequential.\n   With regard to TCP compression,\
    \ the behavior of the IP ID field is\n   essentially the same.  However, in RFC\
    \ 3095 [31], the IP ID is\n   generally inferred from the RTP Sequence Number.\
    \  There is no obvious\n   candidate in the TCP case for a field to offer this\
    \ 'master sequence\n   number' role.\n   Clearly, from a busy server, the observed\
    \ behavior may well be quite\n   erratic.  This is a case where the ability to\
    \ share the IP\n   compression context between a number of flows (between the\
    \ same end-\n   points) could offer potential benefits.  However, this would only\n\
    \   have any real impact where there is a large number of flows between\n   one\
    \ machine and the server.  If context sharing is being considered,\n   then it\
    \ is preferable to share the IP part of the context.\n"
- title: 4.1.4.  Don't Fragment (DF) flag
  contents:
  - "4.1.4.  Don't Fragment (DF) flag\n   Path-MTU discovery (RFC 1191 for IPv4 [6]\
    \ and RFC 1981 for IPv6 [11])\n   is widely deployed for TCP, in contrast to little\
    \ current use for UDP\n   packet streams.  This employs the DF flag value of '1'\
    \ to detect the\n   need for fragmentation in the end-to-end path and to probe\
    \ the\n   minimum MTU along the network path.  End hosts using this technique\n\
    \   may be expected to send all packets with DF set to '1', although a\n   host\
    \ may end PMTU discovery by clearing the DF bit to '0'.  Thus, for\n   compression,\
    \ we expect the field value to be stable.\n"
- title: 4.1.5.  IP Hop-Limit / Time-To-Live (TTL)
  contents:
  - "4.1.5.  IP Hop-Limit / Time-To-Live (TTL)\n   The Hop-Limit (IPv6) or Time-To-Live\
    \ (IPv4) field is expected to be\n   constant during the lifetime of a packet\
    \ stream or to alternate\n   between a limited number of values due to route changes.\n"
- title: 4.2.  TCP Header
  contents:
  - "4.2.  TCP Header\n   Any discussion of compressability of TCP fields borrows\
    \ heavily from\n   RFC 1144 [22].  However, the premise of how the compression\
    \ is\n   performed is slightly different, and the protocol has evolved\n   slightly\
    \ in the intervening time.\n"
- title: 4.2.1.  Sequence Number
  contents:
  - "4.2.1.  Sequence Number\n   Understanding the sequence and acknowledgement number\
    \ behavior is\n   essential for a TCP compression scheme.\n   At the simplest\
    \ level, the behavior of the sequence number can be\n   described relatively easily.\
    \  However, there are a number of\n   complicating factors that also need to be\
    \ considered.\n   For transferring in-sequence data packets, the sequence number\
    \ will\n   increment for each packet by between 0 and an upper limit defined by\n\
    \   the MSS (Maximum Segment Size) and, if it is being used, by Path-MTU\n   discovery.\n\
    \   There are common MSS values, but these can be quite variable and\n   unpredictable\
    \ for any given flow.  Given this variability and the\n   range of window sizes,\
    \ it is hard (compared with the RTP case, for\n   example) to select a 'one size\
    \ fits all' encoding for the sequence\n   number.  (The same argument applies\
    \ equally to the acknowledgement\n   number).\n   Note that the increment of the\
    \ sequence number in a packet is the\n   size of the data payload of that packet\
    \ (including the SYN and FIN\n   flags).  This is, of course, exactly the relationship\
    \ that RFC 1144\n   [22] exploits to compress the sequence number in the most\
    \ efficient\n   case.  This technique may not be directly applicable to a robust\n\
    \   solution, but it may be a useful relationship to consider.\n   However, at\
    \ any point on the path (i.e., wherever a compressor might\n   be deployed), the\
    \ sequence number can be anywhere within a range\n   defined by the TCP window.\
    \  This is a combination of a number of\n   values (buffer space at the sender;\
    \ advertised buffer size at the\n   receiver; and TCP congestion control algorithms).\
    \  Missing packets or\n   retransmissions can cause the TCP sequence number to\
    \ fluctuate within\n   the limits of this window.\n   It is desirable to be able\
    \ to predict the sequence number with some\n   regularity.  However, this also\
    \ appears to be difficult to do.  For\n   example, during bulk data transfer,\
    \ the sequence number will tend to\n   go up by 1 MSS per packet (assuming no\
    \ packet loss).  Higher layer\n   values have been seen to have an impact as well,\
    \ where sequence\n   number behavior has been observed with an 8 kbyte repeating\
    \ pattern\n   -- 5 segments of 1460 bytes followed by 1 segment of 892 bytes.\
    \  The\n   implementation of TCP and the management of buffers within a protocol\n\
    \   stack can affect the behavior of the sequence number.\n   It may be possible\
    \ to track the TCP window by the compressor,\n   allowing it to bound the size\
    \ of these jumps.\n   For interactive flows (for example, telnet), the sequence\
    \ number will\n   change by small, irregular amounts.  In this case, the Nagle\n\
    \   algorithm [3] commonly applies, coalescing small packets where\n   possible\
    \ in order to reduce the basic header overhead.  This may also\n   mean that predictable\
    \ changes in the sequence number are less likely\n   to occur.  The Nagle algorithm\
    \ is an optimisation and is not required\n   to be used (applications can disable\
    \ its use).  However, it is turned\n   on by default in all common TCP implementations.\n\
    \   Note also that the SYN and FIN flags (which have to be acknowledged)\n   each\
    \ consume 1 byte of sequence space.\n"
- title: 4.2.2.  Acknowledgement Number
  contents:
  - "4.2.2.  Acknowledgement Number\n   Much of the information about the sequence\
    \ number applies equally to\n   the acknowledgement number.  However, there are\
    \ some important\n   differences.\n   For bulk data transfers, there will tend\
    \ to be 1 acknowledgement for\n   every 2 data segments.  The algorithm is specified\
    \ in RFC 2581 [16].\n   An ACK need not always be sent immediately on receipt\
    \ of a data\n   segment, but it must be sent within 500ms and should be generated\
    \ for\n   at least every second full-size segment (MSS) of received data.  It\n\
    \   may be seen from this that the delta for the acknowledgement number\n   is\
    \ roughly twice that of the sequence number.  This is not always the\n   case,\
    \ and the discussion about sequence number irregularity should be\n   applied.\n\
    \   As an aside, a common implementation bug is 'stretch ACKs' [33]\n   (acknowledgements\
    \ may be generated less frequently than every two\n   full-size data segments).\
    \  This pattern can also occur following loss\n   on the return path.\n   Since\
    \ the acknowledgement number is cumulative, dropped packets in\n   the forward\
    \ path will result in the acknowledgement number remaining\n   constant for a\
    \ time in the reverse direction.  Retransmission of a\n   dropped segment can\
    \ then cause a substantial jump in the\n   acknowledgement number.  These jumps\
    \ in acknowledgement number are\n   bounded by the TCP window, just as for the\
    \ jumps in sequence number.\n   In the acknowledgement case, information about\
    \ the advertised\n   received window gives a bound to the size of any ACK jump.\n"
- title: 4.2.3.  Reserved
  contents:
  - "4.2.3.  Reserved\n   This field is reserved, and it therefore might be expected\
    \ to be\n   zero.  This can no longer be assumed, due to future-proofing.  It\
    \ is\n   only a matter of time before a suggestion for using the flag is made.\n"
- title: 4.2.4.  Flags
  contents:
  - "4.2.4.  Flags\n   o  ECN-E (Explicit Congestion Notification)\n      '1' to echo\
    \ CE bit in IP header.  It will be set in several\n      consecutive headers (until\
    \ 'acknowledged' by CWR).  If ECN nonces\n      are used, then there will be a\
    \ 'nonce-sum' (NS) bit in the flags,\n      as well.  Again, transparency of the\
    \ reserved bits is crucial for\n      future-proofing this compression scheme.\
    \  From an\n      efficiency/compression standpoint, the NS bit will either be\n\
    \      unused (always '0') or randomly changing.  The nonce sum is the\n     \
    \ 1-bit sum of the ECT codepoints, as described in [19].\n   o  CWR (Congestion\
    \ Window Reduced)\n      '1' to signal congestion window reduced on ECN.  It will\
    \ generally\n      be set in individual packets.  The flag will be set once per\
    \ loss\n      event.  Thus, the probability of its being set is proportional to\n\
    \      the degree of congestion in the network, but it is less likely to\n   \
    \   be set than the CE flag.\n   o  ECE (Echo Congestion Experience)\n      If\
    \ 'congestion experienced' is signaled in a received IP header,\n      this is\
    \ echoed through the ECE bit in segments sent by the\n      receiver until acknowledged\
    \ by seeing the CWR bit set.  Clearly,\n      in periods of high congestion and/or\
    \ long RTT, this flag will\n      frequently be set to '1'.\n      During connection\
    \ open (SYN and SYN/ACK packets), the ECN bits\n      have special meaning:\n\
    \      * CWR and ECN-E are both set with SYN to indicate desire to use\n     \
    \   ECN.\n      * CWR only is set in SYN-ACK, to agree to ECN.\n        (The difference\
    \ in bit-patterns for the negotiation is such that\n        it will work with\
    \ broken stacks that reflect the value of\n        reserved bits).\n   o  URG\
    \ (Urgent Flag)\n      '1' to indicate urgent data (which is unlikely with any\
    \ flag other\n      than ACK).\n   o  ACK (Acknowledgement)\n      '1' for all\
    \ except the initial 'SYN' packet.\n   o  PSH (Push Function Field)\n      Generally\
    \ accepted to be randomly '0' or '1'.  However, it may be\n      biased more to\
    \ one value than the other (this is largely caused by\n      the implementation\
    \ of the stack).\n   o  RST (Reset Connection)\n      '1' to reset a connection\
    \ (unlikely with any flag other than ACK).\n   o  SYN (Synchronize Sequence Number)\n\
    \      '1' for the SYN/SYN-ACK, only at the start of a connection.\n   o  FIN\
    \ (End of Data: FINished)\n      '1' to indicate 'no more data' (unlikely with\
    \ any flag other than\n      ACK).\n"
- title: 4.2.5.  Checksum
  contents:
  - "4.2.5.  Checksum\n   Carried as the end-to-end check for the TCP data.  See RFC\
    \ 1144 [22]\n   for a discussion of why this should be carried.  A header compression\n\
    \   scheme should not rely upon the TCP checksum for robustness, though,\n   and\
    \ should apply appropriate error-detection mechanisms of its own.\n   The TCP\
    \ checksum has to be considered to be randomly changing.\n"
- title: 4.2.6.  Window
  contents:
  - "4.2.6.  Window\n   This may oscillate randomly between 0 and the receiver's window\
    \ limit\n   (for the connection).\n   In practice, the window will either not\
    \ change or alternate between a\n   relatively small number of values.  Particularly\
    \ when the window is\n   closing (its value is getting smaller), the change in\
    \ window is\n   likely to be related to the segment size, but it is not clear\
    \ that\n   this necessarily offers any compression advantage.  When the window\n\
    \   is opening, the effect of 'Silly-Window Syndrome' avoidance should be\n  \
    \ remembered.  This prevents the window from opening by small amounts\n   that\
    \ would encourage the sender to clock out small segments.\n   When thinking about\
    \ what fields might change in a sequence of TCP\n   segments, one should note\
    \ that the receiver can generate 'window\n   update' segments in which only the\
    \ window advertisement changes.\n"
- title: 4.2.7.  Urgent Pointer
  contents:
  - "4.2.7.  Urgent Pointer\n   From a compression point of view, the Urgent Pointer\
    \ is interesting\n   because it offers an example where 'semantically identical'\n\
    \   compression is not the same as 'bitwise identical'.  This is because\n   the\
    \ value of the Urgent Pointer is only valid if the URG flag is set.\n   However,\
    \ the TCP checksum must be passed transparently, in order to\n   maintain its\
    \ end-to-end integrity checking property.  Since the TCP\n   checksum includes\
    \ the Urgent Pointer in its coverage, this enforces\n   bitwise transparency of\
    \ the Urgent Pointer.  Thus, the issue of\n   'semantic' vs. 'bitwise' identity\
    \ is presented as a note: the Urgent\n   Pointer must be compressed in a way that\
    \ preserves its value.\n   If the URG flag is set, then the Urgent Pointer indicates\
    \ the end of\n   the urgent data and thus can point anywhere in the window.  It\
    \ may be\n   set (and changing) over several segments.  Note that urgent data\
    \ is\n   rarely used, since it is not a particularly clean way of managing\n \
    \  out-of-band data.\n"
- title: 4.3.  Options
  contents:
  - "4.3.  Options\n   Options occupy space at the end of the TCP header.  All options\
    \ are\n   included in the checksum.  An option may begin on any byte boundary.\n\
    \   The TCP header must be padded with zeros to make the header length a\n   multiple\
    \ of 32 bits.\n   Optional header fields are identified by an option kind field.\n\
    \   Options 0 and 1 are exactly one octet, which is their kind field.\n   All\
    \ other options have their one-octet kind field, followed by a\n   one-octet length\
    \ field, followed by length-2 octets of option data.\n"
- title: 4.3.1.  Options Overview
  contents:
  - "4.3.1.  Options Overview\n   The IANA provides the authoritative list of TCP\
    \ options.  Figure 12\n   describes the current allocations at the time of publication.\
    \  Any\n   new option would have a 'kind' value assigned by IANA.  The list is\n\
    \   available at [20].  Where applicable, the associated RFC is also\n   cited.\n\
    \   +----+-------+------------------------------------+----------+-----+\n   |Kind|Length\
    \ |               Meaning              |    RFC   | Use |\n   |    |octets | \
    \                                   |          |     |\n   +----+-------+------------------------------------+----------+-----+\n\
    \   |  0 |   -   | End of Option List                 | RFC 793  |  *  |\n   |\
    \  1 |   -   | No-Operation                       | RFC 793  |  *  |\n   |  2\
    \ |   4   | Maximum Segment Size               | RFC 793  |  *  |\n   |  3 | \
    \  3   | WSopt - Window Scale               | RFC 1323 |  *  |\n   |  4 |   2\
    \   | SACK Permitted                     | RFC 2018 |  *  |\n   |  5 |   N   |\
    \ SACK                               | RFC 2018 |  *  |\n   |  6 |   6   | Echo\
    \ (obsoleted by option 8)       | RFC 1072 |     |\n   |  7 |   6   | Echo Reply\
    \ (obsoleted by option 8) | RFC 1072 |     |\n   |  8 |  10   | TSopt - Time Stamp\
    \ Option          | RFC 1323 |  *  |\n   |  9 |   2   | Partial Order Connection\
    \ Permitted | RFC 1693 |     |\n   | 10 |   3   | Partial Order Service Profile\
    \      | RFC 1693 |     |\n   | 11 |   6   | CC                              \
    \   | RFC 1644 |     |\n   | 12 |   6   | CC.NEW                             |\
    \ RFC 1644 |     |\n   | 13 |   6   | CC.ECHO                            | RFC\
    \ 1644 |     |\n   | 14 |   3   | Alternate Checksum Request         | RFC 1146\
    \ |     |\n   | 15 |   N   | Alternate Checksum Data            | RFC 1146 | \
    \    |\n   | 16 |       | Skeeter                            |          |    \
    \ |\n   | 17 |       | Bubba                              |          |     |\n\
    \   | 18 |   3   | Trailer Checksum Option            |          |     |\n   |\
    \ 19 |  18   | MD5 Signature Option               | RFC 2385 |     |\n   | 20\
    \ |       | SCPS Capabilities                  |          |     |\n   | 21 | \
    \      | Selective Negative Acks            |          |     |\n   | 22 |    \
    \   | Record Boundaries                  |          |     |\n   | 23 |       |\
    \ Corruption experienced             |          |     |\n   | 24 |       | SNAP\
    \                               |          |     |\n   | 25 |       | Unassigned\
    \ (released 12/18/00)     |          |     |\n   | 26 |       | TCP Compression\
    \ Filter             |          |     |\n   +----+-------+------------------------------------+----------+-----+\n\
    \                      Figure 12.  Common TCP Options\n   The 'use' column is\
    \ marked with '*' to indicate options that are most\n   likely to be seen in TCP\
    \ flows.  Also note that RFC 1072 [4] has been\n   obsoleted by RFC 1323 [7],\
    \ although the original bit usage is defined\n   only in RFC 1072.\n"
- title: 4.3.2.  Option Field Behavior
  contents:
  - "4.3.2.  Option Field Behavior\n   Generally speaking, all option fields have\
    \ been classified as\n   changing.  This section describes the behavior of each\
    \ option\n   referenced within an RFC, listed by 'kind' indicator.\n      0: End\
    \ of Option List\n         This option code indicates the end of the option list.\
    \  This\n         might not coincide with the end of the TCP header according\
    \ to\n         the Data Offset field.  This is used at the end of all options,\n\
    \         not at the end of each option, and it need only be used if the\n   \
    \      end of the options would not otherwise coincide with the end of\n     \
    \    the TCP header.  Defined in RFC 793 [2].\n         There is no data associated\
    \ with this option, so a compression\n         scheme must simply be able to encode\
    \ its presence.  However,\n         note that since this option marks the end\
    \ of the list and the\n         TCP options are 4-octet aligned, there may be\
    \ octets of padding\n         (defined to be '0' in [2]) after this option.\n\
    \      1: No-Operation\n         This option code may be used between options,\
    \ for example, to\n         align the beginning of a subsequent option on a word\
    \ boundary.\n         There is no guarantee that senders will use this option,\
    \ so\n         receivers must be prepared to process options even if they do\n\
    \         not begin on a word boundary RFC 793 [2].  There is no data\n      \
    \   associated with this option, so a compression scheme must\n         simply\
    \ be able to encode its presence.  This may be done by\n         noting that the\
    \ option simply maintains a certain alignment and\n         that compression need\
    \ only convey this alignment.  In this way,\n         padding can just be removed.\n\
    \      2: Maximum Segment Size\n         If this option is present, then it communicates\
    \ the maximum\n         segment size that may be used to send a packet to this\
    \ end-\n         host.  This field must only be sent in the initial connection\n\
    \         request (i.e., in segments with the SYN control bit set).  If\n    \
    \     this option is not used, any segment size is allowed RFC 793\n         [2].\n\
    \         This option is very common.  The segment size is a 16-bit\n        \
    \ quantity.  Theoretically, this could take any value; however\n         there\
    \ are a number of values that are common.  For example,\n         1460 bytes is\
    \ very common for TCP/IPv4 over Ethernet (though\n         with the increased\
    \ prevalence of tunnels, for example, smaller\n         values such as 1400 have\
    \ become more popular). 536 bytes is the\n         default MSS value.  This may\
    \ allow for common values to be\n         encoded more efficiently.\n      3:\
    \ Window Scale Option (WSopt)\n         This option may be sent in a SYN segment\
    \ by the TCP end-host\n         (1) to indicate that the sending TCP end-host\
    \ is prepared to\n             perform both send and receive window scaling, and\n\
    \         (2) to communicate a scale factor to be applied to its receive\n   \
    \          window.\n         The scale factor is encoded logarithmically as a\
    \ power of 2\n         (presumably to be implemented by binary shifts).  Note\
    \ that the\n         window in the SYN segment itself is never scaled (RFC 1072\n\
    \         [4]).  This option may be sent in an initial segment (i.e., in\n   \
    \      a segment with the SYN bit on and the ACK bit off).  It may\n         also\
    \ be sent in later segments, but only if a Window Scale\n         option was received\
    \ in the initial segment.  A Window Scale\n         option in a segment without\
    \ a SYN bit should be ignored.  The\n         Window field in a SYN segment itself\
    \ is never scaled (RFC 1323\n         [7]).\n         The use of window scaling\
    \ does not affect the encoding of any\n         other field during the lifetime\
    \ of the flow.  Only the encoding\n         of the window scaling option itself\
    \ is important.  The window\n         scale must be between 0 and 14 (inclusive).\
    \  Generally, smaller\n         values would be expected (a window scale of 14\
    \ allows for a\n         1Gbyte window, which is extremely large).\n      4: SACK-Permitted\n\
    \         This option may be sent in a SYN by a TCP that has been\n         extended\
    \ to receive (and presumably to process) the SACK option\n         once the connection\
    \ has opened RFC 2018 [12].  There is no data\n         in this option all that\
    \ is required is for the presence of the\n         option to be encoded.\n   \
    \   5: SACK\n         This option is to be used to convey extended acknowledgment\n\
    \         information over an established connection.  Specifically, it\n    \
    \     is to be sent by a data receiver to inform the data transmitter\n      \
    \   of non-contiguous blocks of data that have been received and\n         queued.\
    \  The data receiver awaits the receipt of data in later\n         retransmissions\
    \ to fill the gaps in sequence space between\n         these blocks.  At that\
    \ time, the data receiver acknowledges the\n         data, normally by advancing\
    \ the left window edge in the\n         Acknowledgment Number field of the TCP\
    \ header.  It is important\n         to understand that the SACK option will not\
    \ change the meaning\n         of the Acknowledgment Number field, whose value\
    \ will still\n         specify the left window edge, i.e., one byte beyond the\
    \ last\n         sequence number of fully received data (RFC 2018 [12]).\n   \
    \      If SACK has been negotiated (through an exchange of SACK-\n         Permitted\
    \ options), then this option may occur when dropped\n         segments are noticed\
    \ by the receiver.  Because this identifies\n         ranges of blocks within\
    \ the receiver's window, it can be viewed\n         as a base value with a number\
    \ of offsets.  The base value (left\n         edge of the first block) can be\
    \ viewed as offset from the TCP\n         acknowledgement number.  There can be\
    \ up to 4 SACK blocks in a\n         single option.  SACK blocks may occur in\
    \ a number of segments\n         (if there is more out-of-order data 'on the wire'),\
    \ and this\n         will typically extend the size of or add to the existing\n\
    \         blocks.\n         Alternative proposals such as DSACK RFC 2883 [17]\
    \ do not\n         fundamentally change the behavior of the SACK block, from the\n\
    \         point of view of the information contained within it.\n      6: Echo\n\
    \         This option carries information that the receiving TCP may send\n  \
    \       back in a subsequent TCP Echo Reply option (see below).  A TCP\n     \
    \    may send the TCP Echo option in any segment, but only if a TCP\n        \
    \ Echo option was received in a SYN segment for the connection.\n         When\
    \ the TCP echo option is used for RTT measurement, it will\n         be included\
    \ in data segments, and the four information bytes\n         will define the time\
    \ at which the data segment was transmitted\n         in any format convenient\
    \ to the sender (see RFC 1072 [4]).\n         The Echo option is generally not\
    \ used in practice -- it is\n         obsoleted by the Timestamp option.  However,\
    \ for transparency\n         it is desirable that a compression scheme be able\
    \ to transport\n         it.  (However, there is no benefit in attempting any\
    \ treatment\n         more sophisticated than viewing it as a generic 'option').\n\
    \      7: Echo Reply\n         A TCP that receives a TCP Echo option containing\
    \ four\n         information bytes will return these same bytes in a TCP Echo\n\
    \         Reply option.  This TCP Echo Reply option must be returned in\n    \
    \     the next segment (e.g., an ACK segment) that is sent.  If more\n       \
    \  than one Echo option is received before a reply segment is\n         sent,\
    \ the TCP must choose only one of the options to echo,\n         ignoring the\
    \ others; specifically, it must choose the newest\n         segment with the oldest\
    \ sequence number (see RFC 1072 [4]).\n         The Echo Reply option is generally\
    \ not used in practice -- it\n         is obsoleted by the Timestamp option. \
    \ However, for\n         transparency it is desirable that a compression scheme\
    \ be able\n         to transport it.  (However, there is no benefit in attempting\n\
    \         any more sophisticated treatment than viewing it as a generic\n    \
    \     'option').\n      8: Timestamps\n         This option carries two four-byte\
    \ timestamp fields.  The\n         Timestamp Value field (TSval) contains the\
    \ current value of the\n         timestamp clock of the TCP sending the option.\
    \  The Timestamp\n         Echo Reply field (TSecr) is only valid if the ACK bit\
    \ is set in\n         the TCP header; if it is valid, it echoes a timestamp value\n\
    \         that was sent by the remote TCP in the TSval field of a\n         Timestamps\
    \ option.  When TSecr is not valid, its value must be\n         zero.  The TSecr\
    \ value will generally be from the most recent\n         Timestamp option that\
    \ was received; however, there are\n         exceptions that are explained below.\
    \  A TCP may send the\n         Timestamps option (TSopt) in an initial segment\
    \ (i.e., a\n         segment containing a SYN bit and no ACK bit), and it may\
    \ send a\n         TSopt in other segments only if it received a TSopt in the\n\
    \         initial segment for the connection (see RFC 1323 [7]).\n         Timestamps\
    \ are quite commonly used.  If timestamp options are\n         exchanged in the\
    \ connection set-up phase, then they are\n         expected to appear on all subsequent\
    \ segments.  If this\n         exchange does not happen, then they will not appear\
    \ for the\n         remainder of the flow.\n         Because the value being carried\
    \ is a timestamp, it is logical\n         to expect that the entire value need\
    \ not be carried.  There is\n         no obvious pattern of increments that might\
    \ be expected,\n         however.\n         An important reason for using the\
    \ timestamp option is to allow\n         detection of sequence space wrap-around\
    \ (Protection Against\n         Wrapped Sequence-number, or PAWS, see RFC 1323\
    \ [7]).  It is not\n         expected that this is a serious concern on the links\
    \ on which\n         TCP header compression would be deployed, but it is important\n\
    \         that the integrity of this option be maintained.  This issue is\n  \
    \       discussed in, for example, RFC 3150 [32].  However, the\n         proposed\
    \ Eifel algorithm [35] makes use of timestamps, so it is\n         currently recommended\
    \ that timestamps be used for cellular-type\n         links [34].\n         With\
    \ regard to compression, note that the range of resolutions\n         for the\
    \ timestamp suggested in RFC 1323 [7] is quite wide (1ms\n         to 1s per 'tick').\
    \  This (along with the perhaps wide variation\n         in RTT) makes it hard\
    \ to select a set of encodings that will be\n         optimal in all cases.\n\
    \      9: Partial Order Connection (POC) permitted\n         This option represents\
    \ a simple indicator communicated between\n         the two peer transport entities\
    \ to establish the operation of\n         the POC protocol.  See RFC 1693 [9].\n\
    \         The Partial Order Connection option sees little (or no) use in\n   \
    \      the current Internet, so the only requirement is that the\n         header\
    \ compression scheme be able to encode it.\n      10: POC service profile\n  \
    \       This option serves to communicate the information necessary to\n     \
    \    carry out the job of the protocol -- the type of information\n         that\
    \ is typically found in the header of a TCP segment.  The\n         Partial Order\
    \ Connection option sees little (or no) use in the\n         current Internet,\
    \ so the only requirement is that the header\n         compression scheme be able\
    \ to encode it.\n      11: Connection Count (CC)\n         This option is part\
    \ of the implementation of TCP Accelerated\n         Open (TAO) that effectively\
    \ bypasses the TCP Three-Way\n         Handshake (3WHS).  TAO introduces a 32-bit\
    \ incarnation number,\n         called a \"connection count\" (CC), that is carried\
    \ in a TCP\n         option in each segment.  A distinct CC value is assigned\
    \ to\n         each direction of an open connection.  The implementation\n   \
    \      assigns monotonically increasing CC values to successive\n         connections\
    \ that it opens actively or passively (see RFC 1644\n         [8]).  This option\
    \ sees little (or no) use in the current\n         Internet, so the only requirement\
    \ is that the header\n         compression scheme be able to encode it.\n    \
    \  12: CC.NEW\n         Correctness of the TAO mechanism requires that clients\
    \ generate\n         monotonically increasing CC values for successive connection\n\
    \         initiations.  Receiving a CC.NEW causes the server to\n         invalidate\
    \ its cache entry and to do a 3WHS.  See RFC 1644 [8].\n         This option sees\
    \ little (or no) use in the current Internet, so\n         the only requirement\
    \ is that the header compression scheme be\n         able to encode it.\n    \
    \  13: CC.ECHO\n         When a server host sends a segment, it echoes the connection\n\
    \         count from the initial in a CC.ECHO option, which is used by\n     \
    \    the client host to validate the segment (see RFC 1644 [8]).\n         This\
    \ option sees little (or no) use in the current Internet, so\n         the only\
    \ requirement is that the header compression scheme be\n         able to encode\
    \ it.\n      14: Alternate Checksum Request\n         This option may be sent\
    \ in a SYN segment by a TCP to indicate\n         that the TCP is prepared to\
    \ both generate and receive checksums\n         based on an alternate algorithm.\
    \  During communication, the\n         alternate checksum replaces the regular\
    \ TCP checksum in the\n         checksum field of the TCP header.  Should the\
    \ alternate\n         checksum require more than 2 octets to transmit, either\
    \ the\n         checksum may be moved into a TCP Alternate Checksum Data Option\n\
    \         and the checksum field of the TCP header be sent as zero, or\n     \
    \    the data may be split between the header field and the option.\n        \
    \ Alternate checksums are computed over the same data as the\n         regular\
    \ TCP checksum; see RFC 1146 [5].\n         This option sees little (or no) use\
    \ in the current Internet, so\n         the only requirement is that the header\
    \ compression scheme be\n         able to encode it.  It would only occur in connection\
    \ set-up\n         (SYN) packets.  Even if this option were used, it would not\n\
    \         affect the handling of the checksum, since this should be\n        \
    \ carried transparently in any case.\n      15: Alternate Checksum Data\n    \
    \     This field is used only when the alternate checksum that is\n         negotiated\
    \ is longer than 16 bits.  These checksums will not\n         fit in the checksum\
    \ field of the TCP header and thus at least\n         part of them must be put\
    \ in an option.  Whether the checksum is\n         split between the checksum\
    \ field in the TCP header and the\n         option or the entire checksum is placed\
    \ in the option is\n         determined on a checksum-by-checksum basis.  The\
    \ length of this\n         option will depend on the choice of alternate checksum\n\
    \         algorithm for this connection; see RFC 1146 [5].\n         If an alternative\
    \ checksum was negotiated in the connection\n         set-up, then this option\
    \ may appear on all subsequent packets\n         (if needed to carry the checksum\
    \ data).  However, this option\n         is in practice never seen, so the only\
    \ requirement is that the\n         header compression scheme be able to encode\
    \ it.\n      16 - 18:\n         These non-RFC option types are not considered\
    \ in this document.\n      19: MD5 Digest\n         Every segment sent on a TCP\
    \ connection to be protected against\n         spoofing will contain the 16-byte\
    \ MD5 digest produced by\n         applying the MD5 algorithm to a concatenated\
    \ block of data\n         [13].\n         Upon receiving a signed segment, the\
    \ receiver must validate it\n         by calculating its own digest from the same\
    \ data (using its own\n         key) and comparing the two digests.  A failing\
    \ comparison must\n         result in the segment's being dropped and must not\
    \ produce any\n         response back to the sender.  Logging the failure is probably\n\
    \         advisable.\n         Unlike other TCP extensions (e.g., the Window Scale\
    \ option\n         [7]), the absence of the option in the SYN-ACK segment must\
    \ not\n         cause the sender to disable its sending of signatures.  This\n\
    \         negotiation is typically done to prevent some TCP\n         implementations\
    \ from misbehaving upon receiving options in non-\n         SYN segments.  This\
    \ is not a problem for this option, since the\n         SYN-ACK sent during connection\
    \ negotiation will not be signed\n         and will thus be ignored.  The connection\
    \ will never be made,\n         and non-SYN segments with options will never be\
    \ sent.  More\n         importantly, the sending of signatures must be under the\n\
    \         complete control of the application, not at the mercy of a\n       \
    \  remote host not understanding the option.  MD5 digest\n         information\
    \ should, like any cryptographically secure data, be\n         incompressible.\
    \  Therefore the compression scheme must simply\n         transparently carry\
    \ this option, if it occurs.\n      20 - 26;\n         Thse non-RFC option types\
    \ are not considered in this document.\n         This only means that their behavior\
    \ is not described in detail,\n         as a compression scheme is not expected\
    \ to be optimised for\n         these options.  However, any unrecognised option\
    \ must be\n         carried by a TCP compression scheme transparently, in order\
    \ to\n         work efficiently in the presence of new or rare options.\n   The\
    \ above list covers options known at the time of writing.  Other\n   options are\
    \ expected to be defined.  It is important that any future\n   options can be\
    \ handled by a header compression scheme.  The\n   processing of as-yet undefined\
    \ options cannot be optimised but, at\n   the very least, unknown options should\
    \ be carried transparently.\n   The current model for TCP options is that an option\
    \ is negotiated in\n   the SYN exchange and used thereafter, if the negotiation\
    \ succeeds.\n   This leads to some assumptions about the presence of options (being\n\
    \   only on packets with the SYN flag set, or appearing on every packet,\n   for\
    \ example).  Where such assumptions hold true, it may be possible\n   to optimise\
    \ compression of options slightly.  However, it is seen as\n   undesirable to\
    \ be so constrained, as there is no guarantee that\n   option handling and negotiation\
    \ will remain the same in the future.\n   Also note that a compressor may not\
    \ process the SYN packets of a flow\n   and cannot, therefore, be assumed to know\
    \ which options have been\n   negotiated.\n"
- title: 5.  Other Observations
  contents:
  - '5.  Other Observations

    '
- title: 5.1.  Implicit Acknowledgements
  contents:
  - "5.1.  Implicit Acknowledgements\n   There may be a small number of cues for 'implicit\
    \ acknowledgements'\n   in a TCP flow.  Even if the compressor only sees the data\
    \ transfer\n   direction, for example, seeing a packet without the SYN flag set\n\
    \   implies that the SYN packet has been received.\n   There is a clear requirement\
    \ for the deployment of compression to be\n   topologically independent.  This\
    \ means that it is not actually\n   possible to be sure that seeing a data packet\
    \ at the compressor\n   guarantees that the SYN packet has been correctly received\
    \ by the\n   decompressor (as the SYN packet may have taken an alternative path).\n\
    \   However, there may be other such cues, which may be used in certain\n   circumstances\
    \ to improve compression efficiency.\n"
- title: 5.2.  Shared Data
  contents:
  - "5.2.  Shared Data\n   It can be seen that there are two distinct deployments\
    \ (i) where the\n   forward (data) and reverse (ACK) path are both carried over\
    \ a common\n   link, and (ii) where the forward (data) and reverse (ACK) path\
    \ are\n   carried over different paths, with a specific link carrying packets\n\
    \   corresponding to only one direction of communication.\n   In the former case,\
    \ a compressor and decompressor could be colocated.\n   It may then be possible\
    \ for the compressor and decompressor at each\n   end of the link to exchange\
    \ information.  This could lead to possible\n   optimizations.\n   For example,\
    \ acknowledgement numbers are generally taken from the\n   sequence numbers in\
    \ the opposite direction.  Since an acknowledgement\n   cannot be generated for\
    \ a packet that has not passed across the link,\n   this offers an efficient way\
    \ of encoding acknowledgements.\n"
- title: 5.3.  TCP Header Overhead
  contents:
  - "5.3.  TCP Header Overhead\n   For a TCP bulk data-transfer, the overhead of the\
    \ TCP header does not\n   form a large proportion of the data packet (e.g., <\
    \ 3% for a 1460\n   octet packet), particularly compared to the typical RTP voice\
    \ case.\n   Spectral efficiency is clearly an important goal.  However,\n   extracting\
    \ every last bit of compression gain offers only marginal\n   benefit at a considerable\
    \ cost in complexity.  This trade-off, of\n   efficiency and complexity, must\
    \ be addressed in the design of a TCP\n   compression profile.\n   However, in\
    \ the acknowledgement direction (i.e., for 'pure'\n   acknowledgement headers),\
    \ the overhead could be said to be infinite\n   (since there is no data being\
    \ carried).  This is why optimizations\n   for the acknowledgement path may be\
    \ considered useful.\n   There are a number of schemes for manipulating TCP acknowledgements\n\
    \   to reduce the ACK bandwidth.  Many of these are documented in [33]\n   and\
    \ [32].  Most of these schemes are entirely compatible with header\n   compression,\
    \ without requiring any particular support.  While it is\n   not expected that\
    \ a compression scheme will be optimised for\n   experimental options, it is useful\
    \ to consider these when developing\n   header compression schemes, and vice versa.\
    \  A header compression\n   scheme must be able to support any option (including\
    \ ones as yet\n   undefined).\n"
- title: 5.4.  Field Independence and Packet Behavior
  contents:
  - "5.4.  Field Independence and Packet Behavior\n   It should be apparent that direct\
    \ comparisons with the highly\n   'packet'-based view of RTP compression are hard.\
    \  RTP header fields\n   tend to change regularly per-packet, and many fields\
    \ (IPv4 IP ID, RTP\n   sequence number, and RTP timestamp, for example) typically\
    \ change in\n   a dependent manner.  However, TCP fields, such as sequence number\n\
    \   tend to change more unpredictably, partly because of the influence of\n  \
    \ external factors (size of TCP windows, application behavior, etc.).\n   Also,\
    \ the field values tend to change independently.  Overall, this\n   makes compression\
    \ more challenging and makes it harder to select a\n   set of encodings that can\
    \ successfully trade off efficiency and\n   robustness.\n"
- title: 5.5.  Short-Lived Flows
  contents:
  - "5.5.  Short-Lived Flows\n   It is hard to see what can be done to improve performance\
    \ for a\n   single, unpredictable, short-lived connection.  However, there are\n\
    \   commonly cases where there will be multiple TCP connections between\n   the\
    \ same pair of hosts.  As a particular example, consider web\n   browsing (this\
    \ is more the case with HTTP/1.0 [25] than with HTTP/1.1\n   [26]).\n   When a\
    \ connection closes, either it is the last connection between\n   that pair of\
    \ hosts or it is likely that another connection will open\n   within a relatively\
    \ short space of time.  In this case, the IP header\n   part of the context (i.e.,\
    \ those fields characterised in Section 2.1)\n   will probably be almost identical.\
    \  Certain aspects of the TCP\n   context may also be similar.\n   Support for\
    \ context replication is discussed in more detail in\n   Section 3.  Overall,\
    \ support for sub-context sharing or initializing\n   one context from another\
    \ offers useful optimizations for a sequence\n   of short-lived connections.\n\
    \   Note that, although TCP is connection oriented, it is hard for a\n   compressor\
    \ to tell whether a TCP flow has finished.  For example,\n   even in the 'bi-directional'\
    \ link case, seeing a FIN and the ACK of\n   the FIN at the compressor/decompressor\
    \ does not mean that the FIN\n   cannot be retransmitted.  Thus, it may be more\
    \ useful to think about\n   initializing a new context from an existing one, rather\
    \ than re-using\n   an existing one.\n   As mentioned previously in Section 4.1.3,\
    \ the IP header can clearly\n   be shared between any transport-layer flows between\
    \ the same two\n   end-points.  There may be limited scope for initialisation\
    \ of a new\n   TCP header from an existing one.  The port numbers are the most\n\
    \   obvious starting point.\n"
- title: 5.6.  Master Sequence Number
  contents:
  - "5.6.  Master Sequence Number\n   As pointed out earlier, in Section 4.1.3, there\
    \ is no obvious\n   candidate for a 'master sequence number' in TCP.  Moreover,\
    \ it is\n   noted that such a master sequence number is only required to allow\
    \ a\n   decompressor to acknowledge packets in bi-directional mode.  It can\n\
    \   also be seen that such a sequence number would not be required for\n   every\
    \ packet.\n   While the sequence number only needs to be 'sparse', it is clear\
    \ that\n   there is a requirement for an explicitly added sequence number.\n \
    \  There are no obvious ways to guarantee the unique identity of a\n   packet\
    \ other than by adding such a sequence number (sequence and\n   acknowledgement\
    \ numbers can both remain the same, for example).\n"
- title: 5.7.  Size Constraint for TCP Options
  contents:
  - "5.7.  Size Constraint for TCP Options\n   As can be seen from the above analysis,\
    \ most TCP options, such as\n   MSS, WSopt, or SACK-Permitted, may appear only\
    \ on a SYN segment.\n   Every implementation should (and we expect that most will)\
    \ ignore\n   unknown options on SYN segments.  TCP options will be sent on non-SYN\n\
    \   segments only when an exchange of options on the SYN segments has\n   indicated\
    \ that both sides understand the extension.  Other TCP\n   options, such as MD5\
    \ Digest or Timestamp, also tend to be sent when\n   the connection is initiated\
    \ (i.e., in the SYN packet).\n   The total header size is also an issue.  The\
    \ TCP header specifies\n   where segment data starts with a 4-bit field that gives\
    \ the total\n   size of the header (including options) in 32-bit words.  This\
    \ means\n   that the total size of the header plus option must be less than or\n\
    \   equal to 60 bytes.  This leaves 40 bytes for options.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Since this document only describes TCP field\
    \ behavior, it raises no\n   direct security concerns.\n   This memo is intended\
    \ to be used to aid the compression of TCP/IP\n   headers.  Where authentication\
    \ mechanisms such as IPsec AH [24] are\n   used, it is important that compression\
    \ be transparent.  Where\n   encryption methods such as IPsec ESP [27] are used,\
    \ the TCP fields\n   may not be visible, preventing compression.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Many IP and TCP RFCs (hopefully all of which have been\
    \ collated\n   below), together with header compression schemes from RFC 1144\
    \ [22],\n   RFC 3544 [36], and RFC 3095 [31], and of course the detailed analysis\n\
    \   of RTP/UDP/IP in RFC 3095, have been sources of ideas and knowledge.\n   Further\
    \ background information can also be found in [28] and [29].\n   This document\
    \ also benefited from discussion on the ROHC mailing list\n   and in various corridors\
    \ (virtual or otherwise) about many key\n   issues; special thanks go to Qian\
    \ Zhang, Carsten Bormann, and Gorry\n   Fairhurst.\n   Qian Zhang and Hongbin\
    \ Liao contributed the extensive analysis of\n   shareable header fields.\n  \
    \ Any remaining misrepresentation or misinterpretation of information\n   is entirely\
    \ the fault of the authors.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [1]   Postel, J., \"Internet Protocol\", STD 5,\
    \ RFC 791, September\n         1981.\n   [2]   Postel, J., \"Transmission Control\
    \ Protocol\", STD 7, RFC 793,\n         September 1981.\n   [3]   Nagle, J., \"\
    Congestion control in IP/TCP internetworks\", RFC\n         896, January 1984.\n\
    \   [4]   Jacobson, V. and R. Braden, \"TCP extensions for long-delay\n      \
    \   paths\", RFC 1072, October 1988.\n   [5]   Zweig, J. and C. Partridge, \"\
    TCP alternate checksum options\",\n         RFC 1146, March 1990.\n   [6]   Mogul,\
    \ J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n         November 1990.\n\
    \   [7]   Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions for\n    \
    \     High Performance\", RFC 1323, May 1992.\n   [8]   Braden, B., \"T/TCP --\
    \ TCP Extensions for Transactions\n         Functional Specification\", RFC 1644,\
    \ July 1994.\n   [9]   Connolly, T., Amer, P., and P. Conrad, \"An Extension to\
    \ TCP:\n         Partial Order Service\", RFC 1693, November 1994.\n   [10]  Bellovin,\
    \ S., \"Defending Against Sequence Number Attacks\", RFC\n         1948, May 1996.\n\
    \   [11]  McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for\n  \
    \       IP version 6\", RFC 1981, August 1996.\n   [12]  Mathis, M., Mahdavi,\
    \ J., Floyd, S., and A. Romanow, \"TCP\n         Selective Acknowledgment Options\"\
    , RFC 2018, October 1996.\n   [13]  Heffernan, A., \"Protection of BGP Sessions\
    \ via the TCP MD5\n         Signature Option\", RFC 2385, August 1998.\n   [14]\
    \  Nichols, K., Blake, S., Baker, F., and D. Black, \"Definition of\n        \
    \ the Differentiated Services Field (DS Field) in the IPv4 and\n         IPv6\
    \ Headers\", RFC 2474, December 1998.\n   [15]  Ramakrishnan, K. and S. Floyd,\
    \ \"A Proposal to add Explicit\n         Congestion Notification (ECN) to IP\"\
    , RFC 2481, January 1999.\n   [16]  Allman, M., Paxson, V., and W. Stevens, \"\
    TCP Congestion\n         Control\", RFC 2581, April 1999.\n   [17]  Floyd, S.,\
    \ Mahdavi, J., Mathis, M., and M. Podolsky, \"An\n         Extension to the Selective\
    \ Acknowledgement (SACK) Option for\n         TCP\", RFC 2883, July 2000.\n  \
    \ [18]  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of\n       \
    \  Explicit Congestion Notification (ECN) to IP\", RFC 3168,\n         September\
    \ 2001.\n   [19]  Spring, N., Wetherall, D., and D. Ely, \"Robust Explicit\n \
    \        Congestion Notification (ECN)  Signaling with Nonces\", RFC\n       \
    \  3540, June 2003.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [20]  IANA, \"IANA\", IANA TCP options, February\
    \ 1998,\n         <http://www.iana.org/assignments/tcp-parameters>.\n   [21] \
    \ Braden, R., \"Requirements for Internet Hosts - Communication\n         Layers\"\
    , STD 3, RFC 1122, October 1989.\n   [22]  Jacobson, V., \"Compressing TCP/IP\
    \ headers for low-speed serial\n         links\", RFC 1144, February 1990.\n \
    \  [23]  Almquist, P., \"Type of Service in the Internet Protocol Suite\",\n \
    \        RFC 1349, July 1992.\n   [24]  Kent, S. and R. Atkinson, \"IP Authentication\
    \ Header\", RFC 2402,\n         November 1998.\n   [25]  Berners-Lee, T., Fielding,\
    \ R., and H. Nielsen, \"Hypertext\n         Transfer Protocol -- HTTP/1.0\", RFC\
    \ 1945, May 1996.\n   [27]  Kent, S. and R. Atkinson, \"IP Encapsulating Security\
    \ Payload\n         (ESP)\", RFC 2406, November 1998.\n   [26]  Fielding, R.,\
    \ Gettys, J., Mogul, J., Nielsen, H., and T.\n         Berners-Lee, \"Hypertext\
    \ Transfer Protocol -- HTTP/1.1\", RFC\n         2068, January 1997.\n   [28]\
    \  Degermark, M., Nordgren, B., and S. Pink, \"IP Header\n         Compression\"\
    , RFC 2507, February 1999.\n   [29]  Casner, S. and V. Jacobson, \"Compressing\
    \ IP/UDP/RTP Headers for\n         Low-Speed Serial Links\", RFC 2508, February\
    \ 1999.\n   [30]  Bradner, S. and V. Paxson, \"IANA Allocation Guidelines For\n\
    \         Values In the Internet Protocol and Related Headers\", BCP 37,\n   \
    \      RFC 2780, March 2000.\n   [31]  Bormann, C., Burmeister, C., Degermark,\
    \ M., Fukushima, H.,\n         Hannu, H., Jonsson, L-E., Hakenberg, R., Koren,\
    \ T., Le, K.,\n         Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke,\
    \ T.,\n         Yoshimura, T., and H. Zheng, \"RObust Header Compression (ROHC):\n\
    \         Framework and four profiles: RTP, UDP, ESP, and uncompressed\",\n  \
    \       RFC 3095, July 2001.\n   [32]  Dawkins, S., Montenegro, G., Kojo, M.,\
    \ and V. Magret, \"End-to-\n         end Performance Implications of Slow Links\"\
    , BCP 48, RFC 3150,\n         July 2001.\n   [33]  Balakrishnan, Padmanabhan,\
    \ V., Fairhurst, G., and M.\n         Sooriyabandara, \"TCP Performance Implications\
    \ of Network Path\n         Asymmetry\", RFC 3449, December 2002.\n   [34]  Inamura,\
    \ H., Montenegro, G., Ludwig, R., Gurtov, A., and F.\n         Khafizov, \"TCP\
    \ over Second (2.5G) and Third (3G) Generation\n         Wireless Networks\",\
    \ RFC 3481, February 2003.\n   [35]  Ludwig, R. and M. Meyer, \"The Eifel Detection\
    \ Algorithm for\n         TCP\", RFC 3522, April 2003.\n   [36]  Engan, M., Casner,\
    \ S., Bormann, C., and T. Koren, \"IP Header\n         Compression over PPP\"\
    , RFC 3544, July 2003.\n   [37]  Karn, P., Bormann, C., Fairhurst, G., Grossman,\
    \ D., Ludwig, R.,\n         Mahdavi, J., Montenegro, G., Touch, J., and L. Wood,\
    \ \"Advice\n         for Internet Subnetwork Designers\", BCP 89, RFC 3819, July\n\
    \         2004.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mark A. West\n   Siemens/Roke Manor Research\n   Roke\
    \ Manor Research Ltd.\n   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794\
    \ 833311\n   EMail: mark.a.west@roke.co.uk\n   URI:   http://www.roke.co.uk\n\
    \   Stephen McCann\n   Siemens/Roke Manor Research\n   Roke Manor Research Ltd.\n\
    \   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794 833341\n   EMail: stephen.mccann@roke.co.uk\n\
    \   URI:   http://www.roke.co.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
