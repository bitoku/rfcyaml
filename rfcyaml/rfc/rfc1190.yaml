- title: __initial_text__
  contents:
  - '        Experimental Internet Stream Protocol, Version 2 (ST-II)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines a revised version of the Internet Stream\
    \ Protocol,\n   originally defined in IEN-119 [8], based on results from experiments\n\
    \   with the original version, and subsequent requests, discussion, and\n   suggestions\
    \ for improvements.  This is a Limited-Use Experimental\n   Protocol.  Please\
    \ refer to the current edition of the \"IAB Official\n   Protocol Standards\"\
    \ for the standardization state and status of this\n   protocol.  Distribution\
    \ of this memo is unlimited.\n"
- title: 1.         Abstract
  contents:
  - "1.         Abstract\n   This memo defines the Internet Stream Protocol, Version\
    \ 2 (ST-II), an\n   IP-layer protocol that provides end-to-end guaranteed service\
    \ across\n   an internet.  This specification obsoletes IEN 119 \"ST - A Proposed\n\
    \   Internet Stream Protocol\" written by Jim Forgie in 1979, the previous\n \
    \  specification of ST.  ST-II is not compatible with Version 1 of the\n   protocol,\
    \ but maintains much of the architecture and philosophy of\n   that version. \
    \ It is intended to fill in some of the areas left\n   unaddressed, to make it\
    \ easier to implement, and to support a wider\n   range of applications.\n   1.1.\
    \       Table of Contents\n                 Status of this Memo .  .  .  .  .\
    \  .  .  .  .  .  .  .   1\n         1.      Abstract   .  .  .  .  .  .  .  .\
    \  .  .  .  .  .  .  .   1\n         1.1.       Table of Contents   .  .  .  .\
    \  .  .  .  .  .  .  .   2\n         1.2.       List of Figures  .  .  .  .  .\
    \  .  .  .  .  .  .  .   4\n         2.      Introduction  .  .  .  .  .  .  .\
    \  .  .  .  .  .  .  .   7\n         2.1.       Major Differences Between ST and\
    \ ST-II   .  .  .  .   8\n         2.2.       Concepts and Terminology  .  . \
    \ .  .  .  .  .  .  .   9\n         2.3.       Relationship Between Applications\
    \ and ST .  .  .  .  11\n         2.4.       ST Control Message Protocol  .  .\
    \  .  .  .  .  .  .  12\n         2.5.       Flow Specifications .  .  .  .  .\
    \  .  .  .  .  .  .  14\n         3.      ST Control Message Protocol Functional\
    \ Description   .  17\n         3.1.       Stream Setup  .  .  .  .  .  .  . \
    \ .  .  .  .  .  .  18\n         3.1.1.        Initial Setup at the Origin  .\
    \  .  .  .  .  .  .  18\n         3.1.2.        Invoking the Routing Function\
    \   .  .  .  .  .  .  19\n         3.1.3.        Reserving Resources .  .  . \
    \ .  .  .  .  .  .  .  19\n         3.1.4.        Sending CONNECT Messages  .\
    \  .  .  .  .  .  .  .  20\n         3.1.5.        CONNECT Processing by an Intermediate\
    \ Agent .  .  22\n         3.1.6.        Setup at the Targets   .  .  .  .  .\
    \  .  .  .  .  23\n         3.1.7.        ACCEPT Processing by an Intermediate\
    \ Agent  .  .  24\n         3.1.8.        ACCEPT Processing by the Origin .  .\
    \  .  .  .  .  26\n         3.1.9.        Processing a REFUSE Message  .  .  .\
    \  .  .  .  .  27\n         3.2.       Data Transfer .  .  .  .  .  .  .  .  .\
    \  .  .  .  .  30\n         3.3.       Modifying an Existing Stream .  .  .  .\
    \  .  .  .  .  31\n         3.3.1.        Adding a Target  .  .  .  .  .  .  .\
    \  .  .  .  .  31\n         3.3.2.        The Origin Removing a Target .  .  .\
    \  .  .  .  .  33\n         3.3.3.        A Target Deleting Itself  .  .  .  .\
    \  .  .  .  .  35\n         3.3.4.        Changing the FlowSpec  .  .  .  .  .\
    \  .  .  .  .  36\n         3.4.       Stream Tear Down .  .  .  .  .  .  .  .\
    \  .  .  .  .  36\n         3.5.       Exceptional Cases   .  .  .  .  .  .  .\
    \  .  .  .  .  37\n         3.5.1.        Setup Failure due to CONNECT Timeout\
    \  .  .  .  .  37\n         3.5.2.        Problems due to Routing Inconsistency\
    \ .  .  .  .  38\n         3.5.3.        Setup Failure due to a Routing Failure\
    \   .  .  .  39\n         3.5.4.        Problems in Reserving Resources .  . \
    \ .  .  .  .  41\n         3.5.5.        Setup Failure due to ACCEPT Timeout \
    \  .  .  .  .  41\n         3.5.6.        Problems Caused by CHANGE Messages .\
    \  .  .  .  .  42\n         3.5.7.        Notification of Changes Forced by Failures\
    \  .  .  42\n         3.6.       Options .  .  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  44\n         3.6.1.        HID Field Option .  .  .  .  .  .  .  .  .\
    \  .  .  44\n         3.6.2.        PTP Option .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  44\n         3.6.3.        FDx Option .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  45\n         3.6.4.        NoRecovery Option   .  .  .  .  .  .  .  .\
    \  .  .  46\n         3.6.5.        RevChrg Option   .  .  .  .  .  .  .  .  .\
    \  .  .  46\n         3.6.6.        Source Route Option .  .  .  .  .  .  .  .\
    \  .  .  46\n         3.7.       Ancillary Functions .  .  .  .  .  .  .  .  .\
    \  .  .  48\n         3.7.1.        Failure Detection   .  .  .  .  .  .  .  .\
    \  .  .  48\n         3.7.1.1.         Network Failures .  .  .  .  .  .  .  .\
    \  .  .  48\n         3.7.1.2.         Detecting ST Stream Failures .  .  .  .\
    \  .  .  49\n         3.7.1.3.         Subset  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  51\n         3.7.2.        Failure Recovery .  .  .  .  .  .  .  .  .\
    \  .  .  51\n         3.7.2.1.         Subset  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  55\n         3.7.3.        A Group of Streams  .  .  .  .  .  .  .  .\
    \  .  .  56\n         3.7.3.1.         Group Name Generator   .  .  .  .  .  .\
    \  .  .  57\n         3.7.3.2.         Subset  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  57\n         3.7.4.        HID Negotiation  .  .  .  .  .  .  .  .  .\
    \  .  .  58\n         3.7.4.1.         Subset  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  64\n         3.7.5.        IP Encapsulation of ST .  .  .  .  .  .  .\
    \  .  .  64\n         3.7.5.1.         IP Multicasting  .  .  .  .  .  .  .  .\
    \  .  .  65\n         3.7.6.        Retransmission   .  .  .  .  .  .  .  .  .\
    \  .  .  66\n         3.7.7.        Routing .  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  67\n         3.7.8.        Security   .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  67\n         3.8.       ST Service Interfaces  .  .  .  .  .  .  .  .\
    \  .  .  68\n         3.8.1.        Access to Routing Information   .  .  .  .\
    \  .  .  69\n         3.8.2.        Access to Network Layer Resource Reservation\
    \   .  70\n         3.8.3.        Network Layer Services Utilized .  .  .  . \
    \ .  .  71\n         3.8.4.        IP Services Utilized   .  .  .  .  .  .  .\
    \  .  .  71\n         3.8.5.        ST Layer Services Provided   .  .  .  .  .\
    \  .  .  72\n         4.      ST Protocol Data Unit Descriptions .  .  .  .  .\
    \  .  .  75\n         4.1.       Data Packets  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  76\n         4.2.       ST Control Message Protocol Descriptions .  .\
    \  .  .  77\n         4.2.1.        ST Control Messages .  .  .  .  .  .  .  .\
    \  .  .  79\n         4.2.2.        Common SCMP Elements   .  .  .  .  .  .  .\
    \  .  .  80\n         4.2.2.1.         DetectorIPAddress   .  .  .  .  .  .  .\
    \  .  .  80\n         4.2.2.2.         ErroredPDU .  .  .  .  .  .  .  .  .  .\
    \  .  .  80\n         4.2.2.3.         FlowSpec & RFlowSpec   .  .  .  .  .  .\
    \  .  .  81\n         4.2.2.4.         FreeHIDs   .  .  .  .  .  .  .  .  .  .\
    \  .  .  84\n         4.2.2.5.         Group & RGroup   .  .  .  .  .  .  .  .\
    \  .  .  85\n         4.2.2.6.         HID & RHID .  .  .  .  .  .  .  .  .  .\
    \  .  .  86\n         4.2.2.7.         MulticastAddress .  .  .  .  .  .  .  .\
    \  .  .  86\n         4.2.2.8.         Name & RName  .  .  .  .  .  .  .  .  .\
    \  .  .  87\n         4.2.2.9.         NextHopIPAddress .  .  .  .  .  .  .  .\
    \  .  .  88\n         4.2.2.10.        Origin  .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  88\n         4.2.2.11.        OriginTimestamp  .  .  .  .  .  .  .  .\
    \  .  .  89\n         4.2.2.12.        ReasonCode .  .  .  .  .  .  .  .  .  .\
    \  .  .  89\n         4.2.2.13.        RecordRoute   .  .  .  .  .  .  .  .  .\
    \  .  .  94\n         4.2.2.14.        SrcRoute   .  .  .  .  .  .  .  .  .  .\
    \  .  .  95\n         4.2.2.15.        Target and TargetList  .  .  .  .  .  .\
    \  .  .  96\n         4.2.2.16.        UserData   .  .  .  .  .  .  .  .  .  .\
    \  .  .  98\n         4.2.3.        ST Control Message PDUs   .  .  .  .  .  .\
    \  .  .  99\n         4.2.3.1.         ACCEPT  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 100\n         4.2.3.2.         ACK  .  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 102\n         4.2.3.3.         CHANGE-REQUEST   .  .  .  .  .  .  .  .\
    \  .  . 103\n         4.2.3.4.         CHANGE  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 104\n         4.2.3.5.         CONNECT .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 105\n         4.2.3.6.         DISCONNECT .  .  .  .  .  .  .  .  .  .\
    \  .  . 110\n         4.2.3.7.         ERROR-IN-REQUEST .  .  .  .  .  .  .  .\
    \  .  . 111\n         4.2.3.8.         ERROR-IN-RESPONSE   .  .  .  .  .  .  .\
    \  .  . 112\n         4.2.3.9.         HELLO   .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 113\n         4.2.3.10.        HID-APPROVE   .  .  .  .  .  .  .  .  .\
    \  .  . 114\n         4.2.3.11.        HID-CHANGE-REQUEST  .  .  .  .  .  .  .\
    \  .  . 115\n         4.2.3.12.        HID-CHANGE .  .  .  .  .  .  .  .  .  .\
    \  .  . 116\n         4.2.3.13.        HID-REJECT .  .  .  .  .  .  .  .  .  .\
    \  .  . 118\n         4.2.3.14.        NOTIFY  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 120\n         4.2.3.15.        REFUSE  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 122\n         4.2.3.16.        STATUS  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 124\n         4.2.3.17.        STATUS-RESPONSE  .  .  .  .  .  .  .  .\
    \  .  . 126\n         4.3.       Suggested Protocol Constants .  .  .  .  .  .\
    \  .  . 127\n         5.      Areas Not Addressed .  .  .  .  .  .  .  .  .  .\
    \  .  . 131\n         6.      Glossary   .  .  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 135\n         7.      References .  .  .  .  .  .  .  .  .  .  .  .  .\
    \  .  . 143\n         8.      Security Considerations.  .  .  .  .  .  .  .  .\
    \  .  . 144\n         9.      Authors' Addresses  .  .  .  .  .  .  .  .  .  .\
    \  .  . 145\n         Appendix 1.      Data Notations   .  .  .  .  .  .  .  .\
    \  .  . 147\n   1.2.       List of Figures\n         Figure 1.    Protocol Relationships\
    \  .  .  .  .  .  .  .  .  .   6\n         Figure 2.    Topology Used in Protocol\
    \ Exchange Diagrams  .  .  16\n         Figure 3.    Virtual Link Identifiers\
    \ for SCMP Messages   .  .  16\n         Figure 4.    HIDs Assigned for ST User\
    \ Packets   .  .  .  .  .  18\n         Figure 5.    Origin Sending CONNECT Message\
    \   .  .  .  .  .  .  21\n         Figure 6.    CONNECT Processing by an Intermediate\
    \ Agent  .  .  22\n         Figure 7.    CONNECT Processing by the Target .  .\
    \  .  .  .  .  24\n         Figure 8.    ACCEPT Processing by an Intermediate\
    \ Agent   .  .  25\n         Figure 9.    ACCEPT Processing by the Origin  . \
    \ .  .  .  .  .  26\n         Figure 10.   Sending REFUSE Message  .  .  .  .\
    \  .  .  .  .  .  28\n         Figure 11.   Routing Around a Failure   .  .  .\
    \  .  .  .  .  .  29\n         Figure 12.   Addition of Another Target .  .  .\
    \  .  .  .  .  .  32\n         Figure 13.   Origin Removing a Target   .  .  .\
    \  .  .  .  .  .  34\n         Figure 14.   Target Deleting Itself  .  .  .  .\
    \  .  .  .  .  .  35\n         Figure 15.   CONNECT Retransmission after a Timeout\
    \ .  .  .  .  38\n         Figure 16.   Processing NOTIFY Messages .  .  .  .\
    \  .  .  .  .  43\n         Figure 17.   Source Routing Option   .  .  .  .  .\
    \  .  .  .  .  47\n         Figure 18.   Typical HID Negotiation (No Multicasting)\
    \ .  .  .  60\n         Figure 19.   Multicast HID Negotiation  .  .  .  .  .\
    \  .  .  .  61\n         Figure 20.   Multicast HID Re-Negotiation           .\
    \  .  .  .  62\n         Figure 21.   ST Header   .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  75\n         Figure 22.   ST Control Message Format  .  .  .  .  .\
    \  .  .  .  77\n         Figure 23.   ErroredPDU  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  80\n         Figure 24.   FlowSpec & RFlowSpec .  .  .  .  .  .  .\
    \  .  .  .  81\n         Figure 25.   FreeHIDs .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  85\n         Figure 26.   Group & RGroup .  .  .  .  .  .  .  .  .\
    \  .  .  .  85\n         Figure 27.   HID & RHID  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  86\n         Figure 28.   MulticastAddress  .  .  .  .  .  .  .  .\
    \  .  .  .  86\n         Figure 29.   Name & RName   .  .  .  .  .  .  .  .  .\
    \  .  .  .  87\n         Figure 30.   NextHopIPAddress  .  .  .  .  .  .  .  .\
    \  .  .  .  88\n         Figure 31.   Origin   .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  88\n         Figure 32.   OriginTimestamp   .  .  .  .  .  .  .  .\
    \  .  .  .  89\n         Figure 33.   ReasonCode  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  89\n         Figure 34.   RecordRoute .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  94\n         Figure 35.   SrcRoute .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  95\n         Figure 36.   Target   .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  97\n         Figure 37.   TargetList  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  97\n         Figure 38.   UserData .  .  .  .  .  .  .  .  .  .  .\
    \  .  .  .  98\n         Figure 39.   ACCEPT Control Message  .  .  .  .  .  .\
    \  .  .  . 101\n         Figure 40.   ACK Control Message  .  .  .  .  .  .  .\
    \  .  .  . 102\n         Figure 41.   CHANGE-REQUEST Control Message   .  .  .\
    \  .  .  . 103\n         Figure 42.   CHANGE Control Message  .  .  .  .  .  .\
    \  .  .  . 105\n         Figure 43.   CONNECT Control Message .  .  .  .  .  .\
    \  .  .  . 109\n         Figure 44.   DISCONNECT Control Message .  .  .  .  .\
    \  .  .  . 110\n         Figure 45.   ERROR-IN-REQUEST Control Message .  .  .\
    \  .  .  . 111\n         Figure 46.   ERROR-IN-RESPONSE Control Message   .  .\
    \  .  .  . 112\n         Figure 47.   HELLO Control Message   .  .  .  .  .  .\
    \  .  .  . 113\n         Figure 48.   HID-APPROVE Control Message   .  .  .  .\
    \  .  .  . 114\n         Figure 49.   HID-CHANGE-REQUEST Control Message  .  .\
    \  .  .  . 115\n         Figure 50.   HID-CHANGE Control Message .  .  .  .  .\
    \  .  .  . 117\n         Figure 51.   HID-REJECT Control Message .  .  .  .  .\
    \  .  .  . 119\n         Figure 52.   NOTIFY Control Message  .  .  .  .  .  .\
    \  .  .  . 121\n         Figure 53.   REFUSE Control Message  .  .  .  .  .  .\
    \  .  .  . 123\n         Figure 54.   STATUS Control Message  .  .  .  .  .  .\
    \  .  .  . 125\n         Figure 55.   STATUS-RESPONSE Control Message  .  .  .\
    \  .  .  . 126\n         Figure 56.   Transmission Order of Bytes   .  .  .  .\
    \  .  .  . 147\n         Figure 57.   Significance of Bits .  .  .  .  .  .  .\
    \  .  .  . 147\n +--------------------+\n | Conference Control |\n +--------------------+\n\
    \                    |\n"
- title: +-------+ +-------+ |
  contents:
  - '+-------+ +-------+ |

    '
- title: '| Video | | Voice | | +-----+ +------+ +-----+     +-----+ Application'
  contents:
  - '| Video | | Voice | | +-----+ +------+ +-----+     +-----+ Application

    '
- title: '| Appl  | | Appl  | | | SNMP| |Telnet| | FTP | ... |     |    Layer'
  contents:
  - '| Appl  | | Appl  | | | SNMP| |Telnet| | FTP | ... |     |    Layer

    '
- title: +-------+ +-------+ | +-----+ +------+ +-----+     +-----+
  contents:
  - "+-------+ +-------+ | +-----+ +------+ +-----+     +-----+\n    |        |  \
    \    |     |        |     |            |\n    V        V      |     |        |\
    \     |            |   ------------\n +-----+  +-----+   |     |        |    \
    \ |            |\n | PVP |  | NVP |   |     |        |     |            |\n +-----+\
    \  +-----+   +     |        |     |            |\n  |   \\      | \\     \\  \
    \  |        |     |            |\n  |    +-----|--+-----+   |        |     | \
    \           |\n  |     Appl.|control  V  V        V     V            V\n  | ST\
    \  data |         +-----+    +-------+        +-----+\n  | & control|        \
    \ | UDP |    |  TCP  |    ... |     | Transport\n  |          |         +-----+\
    \    +-------+        +-----+   Layer\n  |         /|          / | \\       /\
    \ / |          / /|\n  |\\       / |  +------+--|--\\-----+-/--|--- ... -+ / |\n\
    \  | \\     /  |  |         |   \\     /   |          /  |\n  |  \\   /   |  |\
    \         |    \\   +----|--- ... -+   |   -----------\n  |   \\ /    |  |   \
    \      |     \\ /     |             |\n  |    V     |  |         |      V    \
    \  |             |\n  | +------+ |  |         |   +------+  |   +------+  |\n\
    \  | | SCMP | |  |         |   | ICMP |  |   | IGMP |  |    Internet\n  | +------+\
    \ |  |         |   +------+  |   +------+  |     Layer\n  |    |     |  |    \
    \     |      |      |      |      |\n  V    V     V  V         V      V      V\
    \      V      V\n"
- title: +-----------------+  +-----------------------------------+
  contents:
  - '+-----------------+  +-----------------------------------+

    '
- title: '| STream protocol |->|      Internet     Protocol        |'
  contents:
  - '| STream protocol |->|      Internet     Protocol        |

    '
- title: +-----------------+  +-----------------------------------+
  contents:
  - "+-----------------+  +-----------------------------------+\n               |\
    \ \\   / |\n               |  \\ /  |\n               |   X   |              \
    \                    ------------\n               |  / \\  |\n               |\
    \ /   \\ |\n               VV     VV\n"
- title: +----------------+   +----------------+
  contents:
  - '+----------------+   +----------------+

    '
- title: '| (Sub-) Network |...| (Sub-) Network |                  (Sub-)Network'
  contents:
  - '| (Sub-) Network |...| (Sub-) Network |                  (Sub-)Network

    '
- title: '|    Protocol    |   |    Protocol    |                     Layer'
  contents:
  - '|    Protocol    |   |    Protocol    |                     Layer

    '
- title: +----------------+   +----------------+
  contents:
  - "+----------------+   +----------------+\n                    Figure 1.  Protocol\
    \ Relationships\n"
- title: 2.      Introduction
  contents:
  - "2.      Introduction\n   ST has been developed to support efficient delivery\
    \ of streams of\n   packets to either single or multiple destinations in applications\n\
    \   requiring guaranteed data rates and controlled delay characteristics.\n  \
    \ The motivation for the original protocol was that IP [2] [15] did not\n   provide\
    \ the delay and data rate characteristics necessary to support\n   voice applications.\n\
    \   ST is an internet protocol at the same layer as IP, see Figure 1.  ST\n  \
    \ differs from IP in that IP, as originally envisioned, did not require\n   routers\
    \ (or intermediate systems) to maintain state information\n   describing the streams\
    \ of packets flowing through them.  ST\n   incorporates the concept of streams\
    \ across an internet.  Every\n   intervening ST entity maintains state information\
    \ for each stream\n   that passes through it.  The stream state includes forwarding\n\
    \   information, including multicast support for efficiency, and resource\n  \
    \ information, which allows network or link bandwidth and queues to be\n   assigned\
    \ to a specific stream.  This pre-allocation of resources\n   allows data packets\
    \ to be forwarded with low delay, low overhead, and\n   a low probability of loss\
    \ due to congestion.  The characteristics of\n   a stream, such as the number\
    \ and location of the endpoints, and the\n   bandwidth required, may be modified\
    \ during the lifetime of the\n   stream.  This allows ST to give a real time application\
    \ the\n   guaranteed and predictable communication characteristics it requires,\n\
    \   and is a good vehicle to support an application whose communications\n   requirements\
    \ are relatively predictable.\n   ST proved quite useful in several early experiments\
    \ that involved\n   voice conferences in the Internet.  Since that time, ST has\
    \ also been\n   used to support point-to-point streams that include both video\
    \ and\n   voice.  Recently, multimedia conferencing applications have been\n \
    \  developed that need to exchange real-time voice, video, and pointer\n   data\
    \ in a multi-site conferencing environment.  Multimedia\n   conferencing across\
    \ an internet is an application for which ST\n   provides ideal support.  Simulation\
    \ and wargaming applications [14]\n   also place similar requirements on the communication\
    \ system.  Other\n   applications may include scientific visualization between\
    \ a number of\n   workstations and one or more remote supercomputers, and the\n\
    \   collection and distribution of real-time sensor data from remote\n   sensor\
    \ platforms.  ST may also be useful to support activities that\n   are currently\
    \ supported by IP, such as bulk file transfer using TCP.\n   Transport protocols\
    \ above ST include the Packet Video Protocol (PVP)\n   [5] and the Network Voice\
    \ Protocol (NVP) [4], which are end-to-end\n   protocols used directly by applications.\
    \  Other transport layer\n   protocols that may be used over ST include TCP [16],\
    \ VMTP [3], etc.\n   They provide the user interface, flow control, and packet\
    \ ordering.\n   This specification does not describe these higher layer protocols.\n\
    \   2.1.       Major Differences Between ST and ST-II\n      ST-II supports a\
    \ wider variety of applications than did the\n      original ST.  The differences\
    \ between ST and ST-II are fairly\n      straight forward yet provide great improvements.\
    \  Four of the more\n      notable differences are:\n         1  ST-II is decoupled\
    \ from the Access Controller (AC).  The\n            AC, as well as providing\
    \ a rudimentary access control\n            function, also served as a centralized\
    \ repository and\n            distributor of the conference information.  If an\
    \ AC is\n            necessary, it should be an entity in a higher layer\n   \
    \         protocol.  A large variety of applications such as\n            conferencing,\
    \ distributed simulations, and wargaming can\n            be run without an explicit\
    \ AC.\n         2  The basic stream construct of ST-II is a directed tree\n  \
    \          carrying traffic away from a source to all the\n            destinations,\
    \ rather than the original ST's omniplex\n            structure.  For example,\
    \ a conference is composed of a\n            number of such trees, one for traffic\
    \ from each\n            participant.  Although there are more (simplex) streams\
    \ in\n            ST-II, each is much simpler to manage, so the aggregate is\n\
    \            much simpler.  This change has a minimal impact on the\n        \
    \    application.\n         3  ST-II defines a number of the robustness and recovery\n\
    \            mechanisms that were left undefined in the original ST\n        \
    \    specification.  In case of a network or ST Agent failure,\n            a\
    \ stream may optionally be repaired automatically (i.e.,\n            without\
    \ intervention from the user or the application)\n            using a pruned depth\
    \ first search starting at the ST Agent\n            immediately preceding the\
    \ failure.\n         4  ST-II does not make an inherent distinction between\n\
    \            streams connecting only two communicants and streams among\n    \
    \        an arbitrary number of communicants.\n      This memo is the specification\
    \ for the ST-II Protocol.  Since\n      there should be no ambiguity between the\
    \ original ST specification\n      and the specification herein, the protocol\
    \ is simply called ST\n      hereafter.\n      ST is the protocol used by ST entities\
    \ to exchange information.\n      The same protocol is used for communication\
    \ among all ST entities,\n      whether they communicate with a higher layer protocol\
    \ or forward\n      ST packets between attached networks.\n      The remainder\
    \ of this section gives a brief overview of the ST\n      Protocol.  Section 3\
    \ (page 17) provides a detailed description of\n      the operations required\
    \ by the protocol.  Section 4 (page 75)\n      provides descriptions of the ST\
    \ Protocol Data Units exchanged\n      between ST entities.  Issues that have\
    \ not yet been fully\n      addressed are presented in Section 5 (page 131). \
    \ A glossary and\n      list of references are in Sections 6 (page 135) and 7\
    \ (page 143),\n      respectively.\n      This memo also defines \"subsets\" of\
    \ ST that can be implemented.  A\n      subsetted implementation does not have\
    \ full ST functionality, but\n      it can interoperate with other similarly subsetted\n\
    \      implementations, or with a full implementation, in a predictable\n    \
    \  and consistent manner.  This approach allows an implementation to\n      be\
    \ built and provide service with minimum effort, and gives it an\n      immediate\
    \ and well defined growth path.\n   2.2.       Concepts and Terminology\n    \
    \  The ST packet header is not constrained to be compatible with the\n      IP\
    \ packet header, except for the IP Version Number (the first four\n      bits)\
    \ that is used to distinguish ST packets (IP Version 5) from\n      IP packets\
    \ (IP Version 4).  The ST packets, or protocol data units\n      (PDUs), can be\
    \ encapsulated in IP either to provide connectivity\n      (possibly with degraded\
    \ service) across portions of an internet\n      that do not provide support for\
    \ ST, or to allow access to services\n      such as security that are not provided\
    \ directly by ST.\n      An internet entity that implements the ST Protocol is\
    \ called an\n      \"ST Agent\".  We refer to two kinds of ST agents:  \"host\
    \ ST\n      agents\", also called \"host agents\" and \"intermediate ST agents\"\
    ,\n      also called \"intermediate agents\".  The ST agents functioning as\n\
    \      hosts are sourcing or sinking data to a higher layer protocol or\n    \
    \  application, while ST agents functioning as intermediate agents\n      are\
    \ forwarding data between directly attached networks.  This\n      distinction\
    \ is not part of the protocol, but is used for\n      conceptual purposes only.\
    \  Indeed, a given ST agent may be\n      simultaneously performing both host\
    \ and intermediate roles.  Every\n      ST agent should be capable of delivering\
    \ packets to a higher layer\n      protocol.  Every ST agent can replicate ST\
    \ data packets as\n      necessary for multi-destination delivery, and is able\
    \ to send\n      packets whether received from a network interface or a higher\n\
    \      layer protocol.  There are no other kinds of ST agents.\n      ST provides\
    \ applications with an end-to-end flow oriented service\n      across an internet.\
    \  This service is implemented using objects\n      called \"streams\".  ST data\
    \ packets are not considered to be\n      totally independent as are IP data packets.\
    \  They are transmitted\n      only as part of a point-to-point or point-to-multi-\
    \ point stream.\n      ST creates a stream during a setup phase before data is\n\
    \      transmitted.  During the setup phase, routes are selected and\n      internetwork\
    \ resources are reserved.  Except for explicit changes\n      to the stream, the\
    \ routes remain in effect until the stream is\n      explicitly torn down.\n \
    \     An ST stream is:\n         o  the set of paths that data generated by an\
    \ application\n            entity traverses on its way to its peer application\n\
    \            entity(s) that receive it,\n         o  the resources allocated to\
    \ support that transmission of\n            data, and\n         o  the state information\
    \ that is maintained describing that\n            transmission of data.\n    \
    \  Each stream is identified by a globally unique \"Name\";  see\n      Section\
    \ 4.2.2.8 (page 87).  The Name is specified in ST control\n      operations, but\
    \ is not used in ST data packets.  A set of streams\n      may be related as members\
    \ of a larger aggregate called a \"group\".\n      A group is identified by a\
    \ \"Group Name\";  see Section 3.7.3 (page\n      56).\n      The end-users of\
    \ a stream are called the \"participants\" in the\n      stream.  Data travels\
    \ in a single direction through any given\n      stream.  The host agent that\
    \ transmits the data into the stream is\n      called the \"origin\", and the\
    \ host agents that receive the data are\n      called the \"targets\".  Thus,\
    \ for any stream one participant is the\n      origin and the others are the targets.\n\
    \      A stream is \"multi-destination simplex\" since data travels across\n \
    \     it in only one direction:  from the origin to the targets.  A\n      stream\
    \ can be viewed as a directed tree in which the origin is the\n      root, all\
    \ the branches are directed away from the root toward the\n      targets, which\
    \ are the leaves.  A \"hop\" is an edge of that tree.\n      The ST agent that\
    \ is on the end of an edge in the direction toward\n      the origin is called\
    \ the \"previous-hop ST agent\", or the\n      \"previous-hop\".  The ST agents\
    \ that are one hop away from a\n      previous-hop ST agent in the direction toward\
    \ the targets are\n      called the \"next-hop ST agents\", or the \"next-hops\"\
    .  It is\n      possible that multiple edges between a previous-hop and several\n\
    \      next-hops are actually implemented by a network level multicast\n     \
    \ group.\n      Packets travel across a hop for one of two purposes:  data or\n\
    \      control.  For ST data packet handling, hops are marked by \"Hop\n     \
    \ IDentifiers\" (HIDs) used for efficient forwarding instead of the\n      stream's\
    \ Name.  A HID is negotiated among several agents so that\n      data forwarding\
    \ can be done efficiently on both a point-to-point\n      and multicast basis.\
    \  All control message exchange is done on a\n      point-to-point basis between\
    \ a pair of agents.  For control\n      message handling, Virtual Link Identifiers\
    \ are used to quickly\n      dispatch the control messages to the proper stream's\
    \ state\n      machine.\n      ST requires routing decisions to be made at several\
    \ points in the\n      stream setup and management process.  ST assumes that an\n\
    \      appropriate routing algorithm exists to which ST has access; see\n    \
    \  Section 3.8.1 (page 69).  However, routing is considered to be a\n      separate\
    \ issue.  Thus neither the routing algorithm nor its\n      implementation is\
    \ specified here.  A routing algorithm may attempt\n      to minimize the number\
    \ of hops to the target(s), or it may be more\n      intelligent and attempt to\
    \ minimize the total internet resources\n      consumed.  ST operates equally\
    \ well with any reasonable routing\n      algorithm.  The availability of a source\
    \ routing option does not\n      eliminate the need for an appropriate routing\
    \ algorithm in ST\n      agents.\n   2.3.       Relationship Between Applications\
    \ and ST\n      It is the responsibility of an ST application entity to exchange\n\
    \      information among its peers, usually via IP, as necessary to\n      determine\
    \ the structure of the communication before establishing\n      the ST stream.\
    \  This includes:\n         o  identifying the participants,\n         o  determining\
    \ which are targets for which origins,\n         o  selecting the characteristics\
    \ of the data flow between any\n            origin and its target(s),\n      \
    \   o  specifying the protocol that resides above ST,\n         o  identifying\
    \ the Service Access Point (SAP), port, or\n            socket relevant to that\
    \ protocol at every participant, and\n         o  ensuring security, if necessary.\n\
    \      The protocol layer above ST must pass such information down to the\n  \
    \    ST protocol layer when creating a stream.\n      ST uses a flow specification,\
    \ abbreviated herein as \"FlowSpec\", to\n      describe the required characteristics\
    \ of a stream.  Included are\n      bandwidth, delay, and reliability parameters.\
    \  Additional\n      parameters may be included in the future in an extensible\
    \ manner.\n      The FlowSpec describes both the desired values and their minimal\n\
    \      allowable values.  The ST agents thus have some freedom in\n      allocating\
    \ their resources.  The ST agents accumulate information\n      that describes\
    \ the characteristics of the chosen path and pass\n      that information to the\
    \ origin and the targets of the stream.\n      ST stream setup control messages\
    \ carry some information that is\n      not specifically relevant to ST, but is\
    \ passed through the\n      interface to the protocol that resides above ST. \
    \ The \"next\n      protocol identifier\" (\"NextPcol\") allows ST to demultiplex\
    \ streams\n      to a number of possible higher layer protocols.  The SAP\n  \
    \    associated with each participant allows the higher layer protocol\n     \
    \ to further demultiplex to a specific application entity.  A\n      UserData\
    \ parameter is provided;  see Section 4.2.2.16 (page 98).\n   2.4.       ST Control\
    \ Message Protocol\n      ST agents create and manage a stream using the ST Control\
    \ Message\n      Protocol (SCMP).  Conceptually, SCMP resides immediately above\
    \ ST\n      (as does ICMP above IP) but is an integral part of ST.  Control\n\
    \      messages are used to:\n         o  create streams,\n         o  refuse\
    \ creation of a stream,\n         o  delete a stream in whole or in part,\n  \
    \       o  negotiate or change a stream's parameters,\n         o  tear down parts\
    \ of streams as a result of router or\n            network failures, or transient\
    \ routing inconsistencies,\n            and\n         o  reroute around network\
    \ or component failures.\n      SCMP follows a request-response model.  SCMP reliability\
    \ is\n      ensured through use of retransmission after timeout;  see Section\n\
    \      3.7.6 (page 66).\n      An ST application that will transmit data requests\
    \ its local ST\n      agent, the origin, to create a stream.  While only the origin\n\
    \      requests creation of a stream, all the ST agents from the origin\n    \
    \  to the targets participate in its creation and management.  Since\n      a\
    \ stream is simplex, each participant that wishes to transmit data\n      must\
    \ request that a stream be created.\n      An ST agent that receives an indication\
    \ that a stream is being\n      created must:\n         1  negotiate a HID with\
    \ the previous-hop identifying the\n            stream,\n         2  map the list\
    \ of targets onto a set of next-hop ST agents\n            through the routing\
    \ function,\n         3  reserve the local and network resources required to\n\
    \            support the stream,\n         4  update the FlowSpec, and\n     \
    \    5  propagate the setup information and partitioned target\n            list\
    \ to the next-hop ST agents.\n      When a target receives the setup message,\
    \ it must inquire from the\n      specified application process whether or not\
    \ it is willing to\n      accept the stream, and inform the origin accordingly.\n\
    \      Once a stream is established, the origin can safely send data.  ST\n  \
    \    and its implementations are optimized to allow fast and efficient\n     \
    \ forwarding of data packets by the ST agents using the HIDs, even\n      at the\
    \ cost of adding overhead to stream creation and management.\n      Specifically,\
    \ the forwarding decisions, that is, determining the\n      set of next-hop ST\
    \ agents to which a data packet belonging to a\n      particular stream will be\
    \ sent, are made during the stream setup\n      phase.  The shorthand HIDs are\
    \ negotiated at that time, not only\n      to reduce the data packet header size,\
    \ but to access efficiently\n      the stream's forwarding information.  When\
    \ possible, network-layer\n      multicast is used to forward a data packet to\
    \ multiple next-hop ST\n      agents across a network.  Note that when network-layer\
    \ multicast\n      is used, all members of the multicast group must participate\
    \ in\n      the negotiation of a common HID.\n      An established stream can\
    \ be modified by adding or deleting\n      targets, or by changing the network\
    \ resources allocated to it.  A\n      stream may be torn down by either the origin\
    \ or the targets.  A\n      target can remove itself from a stream leaving the\
    \ others\n      unaffected.  The origin can similarly remove any subset of the\n\
    \      targets from its stream leaving the remainder unaffected.  An\n      origin\
    \ can also remove all the targets from the stream and\n      eliminate the stream\
    \ in its entirety.\n      A stream is monitored by the involved ST agents.  If\
    \ they detect a\n      failure, they can attempt recovery.  In general, this involves\n\
    \      tearing down part of the stream and rebuilding it to bypass the\n     \
    \ failed component(s).  The rebuilding always occurs from the origin\n      side\
    \ of the failure.  The origin can optionally specify whether\n      recovery is\
    \ to be attempted automatically by intermediate ST\n      agents or whether a\
    \ failure should immediately be reported to the\n      origin.  If automatic recovery\
    \ is selected but an intermediate\n      agent determines it cannot effect the\
    \ repair, it propagates the\n      failure information backward until it reaches\
    \ an agent that can\n      effect repair.  If the failure information propagates\
    \ back to the\n      origin, then the application can decide if it should abort\
    \ or\n      reattempt the recovery operation.\n      Although ST supports an arbitrary\
    \ connection structure, we\n      recognize that certain stream topologies will\
    \ be common and\n      justify special features, or options, which allow for optimized\n\
    \      support.  These include:\n         o  streams with only a single target\
    \ (see Section 3.6.2 (page\n            44)), and\n         o  pairs of streams\
    \ to support full duplex communication\n            between two points (see Section\
    \ 3.6.3 (page 45)).\n      These features allow the most frequently occurring\
    \ topologies to\n      be supported with less setup delay, with fewer control\
    \ messages,\n      and with less overhead than the more general situations.\n\
    \   2.5.       Flow Specifications\n      Real time data, such as voice and video,\
    \ have predictable\n      characteristics and make specific demands of the networks\
    \ that\n      must transfer it.  Specifically, the data may be transmitted in\n\
    \      packets of a constant size that are produced at a constant rate.\n    \
    \  Alternatively, the bandwidth may vary, due either to variable\n      packet\
    \ size or rate, with a predefined maximum, and perhaps a\n      non-zero minimum.\
    \  The variation may also be predictable based on\n      some model of how the\
    \ data is generated.  Depending on the\n      equipment used to generate the data,\
    \ the packet size and rate may\n      be negotiable.  Certain applications, such\
    \ as voice, produce\n      packets at the given rate only some of the time.  The\
    \ networks\n      that support real time data must add minimal delay and delay\n\
    \      variance, but it is expected that they will be non-zero.\n      The FlowSpec\
    \ is used for three purposes.  First, it is used in the\n      setup message to\
    \ specify the desired and minimal packet size and\n      rate required by the\
    \ origin.  This information is used by ST\n      agents when they attempt to reserve\
    \ the resources in the\n      intervening networks.  Second, when the setup message\
    \ reaches the\n      target, the FlowSpec contains the packet size and rate that\
    \ was\n      actually obtained along the path from the origin, and the accrued\n\
    \      mean delay and delay variance expected for data packets along that\n  \
    \    path.  This information is used by the target to determine if it\n      wishes\
    \ to accept the connection.  The target may reduce reserved\n      resources if\
    \ it wishes to do so and if the possibility is still\n      available.  Third,\
    \ if the target accepts the connection, it\n      returns the updated FlowSpec\
    \ to the origin, so that the origin can\n      decide if it still wishes to participate\
    \ in the stream with the\n      characteristics that were actually obtained.\n\
    \      When the data transmitted by stream users is generated at varying\n   \
    \   rates, including bursts of varying rate and duration, there is an\n      opportunity\
    \ to provide service to more subscribers by providing\n      guaranteed service\
    \ for the average data rate of each stream, and\n      reserving additional network\
    \ capacity, shared among all streams,\n      to service the bursts.  This concept\
    \ has been recognized by analog\n      voice network providers leading to the\
    \ principle of time assigned\n      speech interpolation (TASI) in which only\
    \ the talkspurts of a\n      speech conversation are transmitted, and, during\
    \ silence periods,\n      the circuit can be used to send the talkspurts of other\n\
    \      conversations.  The FlowSpec is intended to assist algorithms that\n  \
    \    perform similar kinds of functions.  We do not propose such\n      algorithms\
    \ here, but rather expect that this will be an area for\n      experimentation.\
    \  To allow for experiments, and a range of ways\n      that application traffic\
    \ might be characterized, a \"DutyFactor\" is\n      included in the FlowSpec\
    \ and we expect that a \"burst descriptor\"\n      will also be needed.\n    \
    \  The FlowSpec will need to be revised as experience is gained with\n      connections\
    \ involving numerous participants using multiple media\n      across heterogeneous\
    \ internetworks.  We feel a change of the\n      FlowSpec does not necessarily\
    \ require a new version of ST, it only\n      requires the FlowSpec version number\
    \ be updated and software to\n      manage the new FlowSpec to be distributed.\
    \  We further suggest\n      that if the change to the FlowSpec involves additional\
    \ information\n      for improved operation, such as a burst descriptor, that\
    \ it be\n      added to the end of the FlowSpec and that the current parameters\n\
    \      be maintained so that obsolete software can be used to process the\n  \
    \    current parameters with minimum modifications.\n                      ****\
    \                      ****\n                     *    *     ST Agent 1     *\
    \    *       +---+\n                    *      *------- o ---------*    *-------+\
    \ B |\n                    *      *                   *    *       +---+\n   \
    \                 *      *                    ****\n      +---+         *    \
    \  *                     |\n      |   |         *      *                     |\n\
    \      | A +---------*      *                     o ST Agent 3\n      |   |  \
    \       *      *                     |\n      +---+         *      *         \
    \            |\n                    *      *                    ***\n        \
    \            *      *                   *   *        +---+\n                 \
    \   *      *    ST Agent 2    *     *-------+ C |\n                    *     \
    \ *------- o --------*     *       +---+\n                     *    *        \
    \           *     *\n                      ****                    *     *\n \
    \                                             *     *\n                      \
    \           +---+        *     *       +---+\n                               \
    \  | E +--------*     *-------+ D |\n                                 +---+  \
    \       *   *        +---+\n                                                ***\n\
    \         Figure 2.  Topology Used in Protocol Exchange Diagrams\n           \
    \           ****     ST Agent 1       ****\n                     * +--+---14---\
    \ o -----15--+----+--44---+---+\n                    *  | +-+--11---   -----16--+-+\
    \  *       | B |\n                    *  | | *                   * |+-+--45---+---+\n\
    \                    *  | | *                    *++*\n      +---+         * \
    \ | | *                  34 ||32\n      |   +----4----+--+ | *               \
    \      ||\n      | A +----6----+----+ *                     o ST Agent 3\n   \
    \   |   +----5----+---+  *                     |\n      +---+         *   |  *\
    \                     | 33\n                    *   |  *       ST           *+*\n\
    \                    *   |  *      Agent        * | *\n                    * \
    \  |  *        2 -----24-+--+  *       +---+\n                    *   +--+--23---\
    \ o -----25-+-----+--54---+ C |\n                     *    *           -----26-+---+\
    \ *       +---+\n                      ****            -----27-+-+ | *\n     \
    \                                         * | | *\n                          \
    \       +---+        * | | *       +---+\n                                 | E\
    \ +---74---+-+ +-+--64---+ D |\n                                 +---+       \
    \  *   *        +---+\n                                                ***\n \
    \        Figure 3.  Virtual Link Identifiers for SCMP Messages\n"
- title: 3.      ST Control Message Protocol Functional Description
  contents:
  - "3.      ST Control Message Protocol Functional Description\n   This section contains\
    \ a functional description of the ST Control\n   Message Protocol (SCMP); Section\
    \ 4 (page 75) specifies the formats of\n   the control message PDUs.  We begin\
    \ with a description of stream\n   setup.  Mechanisms used to deal with the exceptional\
    \ cases are then\n   presented.  Complications due to options that an application\
    \ or a ST\n   agent may select are then detailed.  Once a stream has been\n  \
    \ established, the data transfer phase is entered; it is described.\n   Once the\
    \ data transfer phase has been completed, the stream must be\n   torn down and\
    \ resources released; the control messages used to\n   perform this function are\
    \ presented.  The resources or participants\n   of a stream may be changed during\
    \ the lifetime of the stream; the\n   procedures to make changes are described.\
    \  Finally, the section\n   concludes with a description of some ancillary functions,\
    \ such as\n   failure detection and recovery, HID negotiation, routing, security,\n\
    \   etc.\n   To help clarify the SCMP exchanges used to setup and maintain ST\n\
    \   streams, we have included a series of figures in this section.  The\n   protocol\
    \ interactions in the figures assume the topology shown in\n   Figure 2.  The\
    \ figures, taken together,\n    o  Create a stream from an application at A to\
    \ three peers at B,\n       C and D,\n    o  Add a peer at E,\n    o  Disconnect\
    \ peers B and C, and\n    o  D drops out of the stream.\n   Other figures illustrate\
    \ exchanges related to failure recovery.\n   In order to make the dispatch function\
    \ within SCMP more uniform and\n   efficient, each end of a hop is assigned, by\
    \ the agent at that end, a\n   Virtual Link Identifier that uniquely (within that\
    \ agent) identifies\n   the hop and associates it with a particular stream's state\n\
    \   machine(s).  The identifier at the end of a link that is sending a\n   message\
    \ is called the Sender Virtual Link Identifier (SVLId);  that\n   at the receiving\
    \ end is called the Receiver Virtual Link Identifier\n   (RVLId).  Whenever one\
    \ agent sends a control message for the other to\n   receive, the sender will\
    \ place the receiver's identifier into the\n   RVLId field of the message and\
    \ its own identifier in the SVLId field.\n   When a reply to the message is sent,\
    \ the values in SVLId and RVLId\n   fields will be reversed, reflecting the fact\
    \ the sender and receiver\n   roles are reversed.  VLIds with values zero through\
    \ three are\n   received and should not be assigned in response to CONNECT messages.\n\
    \   Figure 3 shows the hops that will be used in the examples and\n   summarizes\
    \ the VLIds that will be assigned to them.\n   Similarly, Figure 4 summarizes\
    \ the HIDs that will eventually be\n   negotiated as the stream is created.\n\
    \                      ****     ST Agent 1       ****\n                     *\
    \  +>+--1200-> o -------->+--->+-3600->+---+\n                    *   ^  *   \
    \                *    *       | B |\n                    *   |  *            \
    \       * +->+-6000->+---+\n                    *   |  *                    *+**\n\
    \      +---+         *   |  *                     ^\n      |   +-------->+-->+\
    \  *                     |\n      | A |         *      *                     o\
    \ St Agent 3\n      |   +-------->+-->+  *                     ^\n      +---+\
    \         *   |  *                     | 4801\n                    *   |  *  \
    \                  *+*\n                    *   V  *   ST Agent 2      * ^ * \
    \       +---+\n                     *  +>+--2400-> o ------->+->+->+-4800->+ C\
    \ |\n                      ****                    *  |  * 4801  +---+\n     \
    \                                         *  |  *\n                          \
    \       +---+        *  V  *       +---+\n                                 | E\
    \ +<-4800--+<-+->+-4800->+ D |\n                                 +---+       \
    \  *   *  4801  +---+\n                                                ***\n \
    \            Figure 4.  HIDs Assigned for ST User Packets\n   Some of the diagrams\
    \ that follow form a progression.  For example,\n   the steps required initially\
    \ to establish a connection are spread\n   across five figures.  Within a progression,\
    \ the actions on the first\n   diagram are numbered 1.1, 1.2, etc.;  within the\
    \ second diagram they\n   are numbered 2.1, 2.2, etc.  Points where control leaves\
    \ one diagram\n   to enter another are identified with a continuation arrow \"\
    -->>\", and\n   are continued with \"[a.b] >>-->\" in the other diagram.  The\
    \ number in\n   brackets shows the label where control left the earlier diagram.\
    \  The\n   reception of simple acknowledgments, e.g., ACKs, in one figure from\n\
    \   another is omitted for clarity.\n   3.1.       Stream Setup\n      This section\
    \ presents a description of stream setup assuming that\n      everything succeeds\
    \ -- HIDs are approved, any required resources\n      are available, and the routing\
    \ is correct.\n      3.1.1.        Initial Setup at the Origin\n         As described\
    \ in Section 2.3 (page 11), the application has\n         collected the information\
    \ necessary to determine the\n         participants in the communication before\
    \ passing it to the host\n         ST agent at the origin.  The host ST agent\
    \ will take this\n         information, allocate a Name for the stream (see Section\n\
    \         4.2.2.8 (page 87)), and create a stream.\n      3.1.2.        Invoking\
    \ the Routing Function\n         An ST agent that is setting up a stream invokes\
    \ a routing\n         function to find a path to reach each of the targets specified\n\
    \         in the TargetList.  This is similar to the routing decision in\n   \
    \      IP.  However, in this case the route is to a multitude of\n         targets\
    \ rather than to a single destination.\n         The set of next-hops that an\
    \ ST agent would select is not\n         necessarily the same as the set of next\
    \ hops that IP would\n         select given a number of independent IP datagrams\
    \ to the same\n         destinations.  The routing algorithm may attempt to optimize\n\
    \         parameters other than the number of hops that the packets will\n   \
    \      take, such as delay, local network bandwidth consumption, or\n        \
    \ total internet bandwidth consumption.\n         The result of the routing function\
    \ is a set of next-hop ST\n         agents and the parameters of the intervening\
    \ network(s).  The\n         latter permit the ST agent to determine whether the\
    \ selected\n         network has the resources necessary to support the level\
    \ of\n         service requested in the FlowSpec.\n      3.1.3.        Reserving\
    \ Resources\n         The intent of ST is to provide a guaranteed level of service\
    \ by\n         reserving internet resources for a stream during a setup phase\n\
    \         rather than on a per packet basis.  The relevant resources are\n   \
    \      not only the forwarding information maintained by the ST\n         agents,\
    \ but also packet switch processor bandwidth and buffer\n         space, and network\
    \ bandwidth and multicast group identifiers.\n         Reservation of these resources\
    \ can help to increase the\n         reliability and decrease the delay and delay\
    \ variance with\n         which data packets are delivered.  The FlowSpec contains\
    \ all\n         the information needed by the ST agent to allocate the\n     \
    \    necessary resources.  When and how these resources are\n         allocated\
    \ depends on the details of the networks involved, and\n         is not specified\
    \ here.\n         If an ST agent must send data across a network to a single\n\
    \         next-hop ST agent, then only the point-to-point bandwidth needs\n  \
    \       to be reserved.  If the agent must send data to multiple next-\n     \
    \    hop agents across one network and network layer multicasting is\n       \
    \  not available, then bandwidth must be reserved for all of them.\n         This\
    \ will allow the ST agent to\n         use replication to send a copy of the data\
    \ packets to each\n         next-hop agent.\n         If multicast is supported,\
    \ its use will decrease the effort\n         that the ST agent must expend when\
    \ forwarding packets and also\n         reduces the bandwidth required since one\
    \ copy can be received\n         by all next-hop agents.  However, the setup phase\
    \ is more\n         complicated.  A network multicast address must be allocated\n\
    \         that contains all those next-hop agents, the sender must have\n    \
    \     access to that address, the next-hop agents must be informed of\n      \
    \   the address so they can join the multicast group identified by\n         it\
    \ (see Section 4.2.2.7 (page 86)), and a common HID must be\n         negotiated.\n\
    \         The network should consider the bandwidth and multicast\n         requirements\
    \ to determine the amount of packet switch\n         processing bandwidth and\
    \ buffer space to reserve for the\n         stream.  In addition, the membership\
    \ of a stream in a Group may\n         affect the resources that have to be allocated;\
    \  see Section\n         3.7.3 (page 56).\n         Few networks in the Internet\
    \ currently offer resource\n         reservation, and none that we know of offer\
    \ reservation of all\n         the resources specified here.  Only the Terrestrial\
    \ Wideband\n         Network (TWBNet) [7] and the Atlantic Satellite Network\n\
    \         (SATNET) [9] offer(ed) bandwidth reservation.  Multicasting is\n   \
    \      more widely supported.  No network provides for the reservation\n     \
    \    of packet switch processing bandwidth or buffer space.  We hope\n       \
    \  that future networks will be designed to better support\n         protocols\
    \ like ST.\n         Effects similar to reservation of the necessary resources\
    \ may\n         be obtained even when the network cannot provide direct support\n\
    \         for the reservation.  Certainly if total reservations are a\n      \
    \   small fraction of the overall resources, such as packet switch\n         processing\
    \ bandwidth, buffer space, or network bandwidth, then\n         the desired performance\
    \ can be honored if the degree of\n         confidence is consistent with the\
    \ requirements as stated in the\n         FlowSpec.  Other solutions can be designed\
    \ for specific\n         networks.\n      3.1.4.        Sending CONNECT Messages\n\
    \         A VLId and a proposed HID must be selected for each next-hop\n     \
    \    agent.  The control packets for the next-hop must carry the\n         VLId\
    \ in the SVLId field.  The data packets transmitted in the\n         stream to\
    \ the next-hop must carry the HID in the ST Header.\n         The ST agent sends\
    \ a CONNECT message to each of the ST agents\n         identified by the routing\
    \ function.  Each CONNECT message\n         contains the VLId, the proposed HID\
    \ (the HID Field option bit\n         must be set, see Section 3.6.1 (page 44)),\
    \ an updated FlowSpec,\n         and a TargetList.  In general, the HID, FlowSpec,\
    \ and\n         TargetList will depend on both the next-hop and the intervening\n\
    \         network.  Each TargetList is a subset of the received (or\n        \
    \ original) TargetList, identifying the targets that are to be\n         reached\
    \ through the next-hop to which the CONNECT message is\n         being sent. \
    \ Note that a CONNECT message to a single next-hop\n         might have to be\
    \ fragmented into multiple CONNECTs if the\n         single CONNECT is too large\
    \ for the intervening network's MTU;\n         fragmentation is performed by further\
    \ dividing the TargetList.\n         If multiple next-hops are to be reached through\
    \ a network that\n         supports network level multicast, a different CONNECT\
    \ message\n         must nevertheless be sent to each next-hop since each will\
    \ have\n         a different TargetList;  see Section 4.2.3.5 (page 105).\n  \
    \       However, since an identical copy of each ensuing data packet\n       \
    \  will reach each member of the multicast group, all the CONNECT\n         messages\
    \ must propose the same HID.  See Section 3.7.4 (page\n         58) for a detailed\
    \ discussion on HID selection.\n         In the example of Figure 2, the routing\
    \ function might return\n         that B is reachable via Agent 1 and C and D\
    \ are reachable via\n         Agent 2.  Thus A would create two CONNECT messages,\
    \ one each\n         for Agents 1 and 2, as illustrated in Figure 5.  Assuming\
    \ that\n         the proposed HIDs are available in the receiving agents, they\n\
    \         would each send a responding HID-APPROVE back to Agent A.\n        \
    \ Application  Agent A                    Agent 1    Agent 2\n    1.1. (open B,C,D)\n\
    \               V\n    1.2.       +-> (routing to B,C,D)\n                   \
    \      V\n    1.3.                 +->(reserve resources from A to Agent 1)\n\
    \                         |  V\n    1.4.                 |  +-> CONNECT B --------->>\n\
    \                         |      <RVLId=0><SVLId=4>\n                        \
    \ |      <Ref=10><HID=1200>\n                         V\n    1.5.            \
    \     +->(reserve resources from A to Agent 2)\n                            V\n\
    \    1.6.                    +-> CONNECT C,D ------------------>>\n          \
    \                      <RVLId=0><SVLId=5>\n                                <Ref=15><HID=2400>\n\
    \               Figure 5.  Origin Sending CONNECT Message\n      3.1.5.      \
    \  CONNECT Processing by an Intermediate Agent\n         An ST agent receiving\
    \ a CONNECT message should, assuming no\n         errors, quickly select a VLId\
    \ and respond to the previous-hop\n         with either an ACK, a HID-REJECT,\
    \ or a HID-APPROVE message, as\n         is appropriate.  This message must identify\
    \ the CONNECT to\n         which it corresponds by including the CONNECT's Reference\n\
    \         number in its Reference field.  Note that the VLId that this\n     \
    \    agent selects is placed in the SVLId of the response, and the\n         previous-hop's\
    \ VLId (which is contained in the SVLId of the\n         CONNECT) is copied into\
    \ the RVLId of the response.  If the\n         agent is not a target, it must\
    \ then invoke the routing\n         function, reserve resources, and send a CONNECT\
    \ message(s) to\n         its next-hop(s), as described in Sections 3.1.2-4 (pages\
    \ 19-\n         20).\n       Agent A                   Agent 1               \
    \       Agent B\n    [1.4] >>-> CONNECT B -------->+--+\n               <RVLId=0><SVLId=4>\
    \ |  V\n"
- title: 2.1.           <Ref=10><HID=1200> |  (routing to B)
  contents:
  - "2.1.           <Ref=10><HID=1200> |  (routing to B)\n                       \
    \           |  V\n"
- title: 2.2.                              V  +->(reserve resources from 1 to B)
  contents:
  - '2.2.                              V  +->(reserve resources from 1 to B)

    '
- title: 2.3.       +<- HID-APPROVE <------+     V
  contents:
  - '2.3.       +<- HID-APPROVE <------+     V

    '
- title: 2.4.           <RVLId=4><SVLId=14>      +-> CONNECT B ---------->>
  contents:
  - "2.4.           <RVLId=4><SVLId=14>      +-> CONNECT B ---------->>\n        \
    \       <Ref=10><HID=1200>           <RVLId=0><SVLId=15>\n                   \
    \                         <Ref=110><HID=3600>\n       Agent A                \
    \   Agent 2                      Agent C\n    [1.6] >>-> CONNECT C,D ------>+-+\n\
    \               <RVLId=0><SVLId=5> | V\n"
- title: 2.5.           <Ref=15><HID=2400> | (routing to C,D)
  contents:
  - "2.5.           <Ref=15><HID=2400> | (routing to C,D)\n                      \
    \            | V\n"
- title: 2.6.                              V +-->(reserve resources from 2 to C)
  contents:
  - '2.6.                              V +-->(reserve resources from 2 to C)

    '
- title: 2.7.       +<- HID-APPROVE <------+ |   V
  contents:
  - '2.7.       +<- HID-APPROVE <------+ |   V

    '
- title: 2.8.           <RVLId=5><SVLId=23>  |   +-> CONNECT C ---------->>
  contents:
  - "2.8.           <RVLId=5><SVLId=23>  |   +-> CONNECT C ---------->>\n        \
    \       <Ref=15><HID=2400>   |       <RVLId=0><SVLId=25>\n                   \
    \                 |       <Ref=210><HID=4800>\n                              \
    \      |\n                                    |                         Agent\
    \ D\n                                    V\n"
- title: 2.9.                                +->(reserve resources from 2 to D)
  contents:
  - "2.9.                                +->(reserve resources from 2 to D)\n    \
    \                                    V\n"
- title: 2.10.                                   +-> CONNECT D ---------->>
  contents:
  - "2.10.                                   +-> CONNECT D ---------->>\n        \
    \                                    <RVLId=0><SVLId=26>\n                   \
    \                         <Ref=215><HID=4800>\n         Figure 6.  CONNECT Processing\
    \ by an Intermediate Agent\n         The resources listed as Desired in a received\
    \ FlowSpec may not\n         correspond to those actually reserved in either the\
    \ ST agent\n         itself or in the network(s) used to reach the next-hop\n\
    \         agent(s).  As long as the reserved resources are sufficient to\n   \
    \      meet the specified Limits, the copy of the FlowSpec sent to a\n       \
    \  next-hop must have the Desired resources updated to reflect the\n         resources\
    \ that were actually obtained.  For example, the\n         Desired bandwidth might\
    \ be reduced because the network to the\n         next-hop could not provide all\
    \ of the desired bandwidth.  Also,\n         the delay and delay variance are\
    \ appropriately increased, and\n         the link MTU may require that the DesPDUBytes\
    \ field be reduced.\n         (The minimum requirements that the origin had entered\
    \ into the\n         FlowSpec Limits fields cannot be altered by the intermediate\
    \ or\n         target agents.)\n      3.1.6.        Setup at the Targets\n   \
    \      An ST agent that is the target of a CONNECT, whether from an\n        \
    \ intermediate ST agent, or directly from the origin host ST\n         agent,\
    \ must respond first (assuming no errors) with either a\n         HID-REJECT or\
    \ HID-APPROVE.  After inquiring from the specified\n         application process\
    \ whether or not it is willing to accept the\n         connection, the agent must\
    \ also respond with either an ACCEPT\n         or a REFUSE.\n         In particular,\
    \ the application must be presented with\n         parameters from the CONNECT,\
    \ such as the Name, FlowSpec,\n         Options, and Group, to be used as a basis\
    \ for its decision.\n         The application is identified by a combination of\
    \ the NextPcol\n         field and the SAP field in the (usually) single remaining\n\
    \         Target of the TargetList.  The contents of the SAP field may\n     \
    \    specify the \"port\" or other local identifier for use by the\n         protocol\
    \ layer above the host ST layer.  Subsequently received\n         data packets\
    \ will carry a short hand identifier (the HID) that\n         can be mapped into\
    \ this information and be used for their\n         delivery.\n         The responses\
    \ to the CONNECT message are sent to the previous-\n         hop from which the\
    \ CONNECT was received.  An ACCEPT contains\n         the Name of the stream and\
    \ the updated FlowSpec.  Note that the\n         application might have reduced\
    \ the desired level of service in\n         the received FlowSpec before accepting\
    \ it.  The target must not\n         send the ACCEPT until HID negotiation has\
    \ been successfully\n         completed.\n         Since the ACCEPT or REFUSE\
    \ message must be acknowledged by the\n         previous-hop, it is assigned a\
    \ new Reference number that will\n         be returned in the ACK.  The CONNECT\
    \ to which the ACCEPT or\n         REFUSE is a reply is identified by placing\
    \ the CONNECT's\n         Reference number in the LnkReference field of the ACCEPT\
    \ or\n         REFUSE.\n           Agent 1                    Agent B       Application\
    \ B\n 3.1.                                             (proc B listening)\n  \
    \       [2.4] >>-> CONNECT B ---------->+------------------+\n               \
    \     <RVLId=0><SVLId=15>  |                  |\n 3.2.               <Ref=110><HID=3600>\
    \  V          (proc B accepts)\n 3.3.           +<- HID-APPROVE <--------+   \
    \               |\n                    <RVLId=15><SVLId=44>                  \
    \  |\n                    <Ref=110><HID=3600>                     V\n 3.4.   \
    \                    (wait until HID negotiated) <---+\n                     \
    \                    V\n 3.5.       <<--+<- ACCEPT B <-----------+\n         \
    \           <RVLId=15><SVLId=44>\n                    <Ref=410><LnkRef=110>\n\
    \           Agent 2                    Agent C       Application C\n 3.6.    \
    \                                         (proc C listening)\n         [2.8] >>->\
    \ CONNECT C ---------->+------------------+\n                    <RVLId=0><SVLId=25>\
    \  |                  |\n 3.7.               <Ref=210><HID=4800>  V          (proc\
    \ C accepts)\n 3.8.           +<- HID-APPROVE <--------+                  |\n\
    \                    <RVLId=25><SVLId=54>                    |\n             \
    \       <Ref=210><HID=4800>                     V\n 3.9.                     \
    \  (wait until HID negotiated) <---+\n                                       \
    \  V\n 3.10.      <<--+<- ACCEPT C <-----------+\n                    <RVLId=25><SVLId=54>\n\
    \                    <Ref=510><LnkRef=210>\n           Agent 2               \
    \     Agent D       Application D\n 3.11.                                    \
    \        (proc D listening)\n        [2.10] >>-> CONNECT D ---------->+------------------+\n\
    \                    <RVLId=0><SVLId=26>  |                  |\n 3.12.       \
    \       <Ref=215><HID=4800>  V          (proc D accepts)\n 3.13.          +<-\
    \ HID-APPROVE <--------+                  |\n                    <RVLId=26><SVLId=64>\
    \                    |\n                    <Ref=215><HID=4800>              \
    \       V\n 3.14.                      (wait until HID negotiated) <---+\n   \
    \                                      V\n 3.15.      <<--+<- ACCEPT D <-----------+\n\
    \                    <RVLId=26><SVLId=64>\n                    <Ref=610><LnkRef=215>\n\
    \              Figure 7.  CONNECT Processing by the Target\n      3.1.7.     \
    \   ACCEPT Processing by an Intermediate Agent\n         When an intermediate\
    \ ST agent receives an ACCEPT, it first\n         verifies that the message is\
    \ a response to an earlier CONNECT.\n         If not, it responds to the next-hop\
    \ ST agent with an ERROR-IN-\n         REPLY (LnkRefUnknown) message.  Otherwise,\
    \ it responds to the\n         next-hop ST agent with an ACK, and propagates\n\
    \         the ACCEPT message to the previous-hop along the same path\n       \
    \  traced by the CONNECT but in the reverse direction toward the\n         origin.\
    \  The ACCEPT should not be propagated until all HID\n         negotiations with\
    \ the next-hop agent(s) have been successfully\n         completed.\n        \
    \ The FlowSpec is included in the ACCEPT message so that the\n         origin\
    \ and intermediate ST agents can gain access to the\n         information that\
    \ was accumulated as the CONNECT traversed the\n         internet.  Note that\
    \ the resources, as specified in the\n         FlowSpec in the ACCEPT message,\
    \ may differ from the resources\n         that were reserved by the agent when\
    \ the CONNECT was\n      Agent A                     Agent 1                 \
    \   Agent B\n                                     +<-+<- ACCEPT B <-------<< [3.5]\n\
    \                                     V  |   <RVLId=15><SVLId=44>\n"
- title: 4.1.                 (wait for ACCEPTS) V   <Ref=410><LnkRef=110>
  contents:
  - '4.1.                 (wait for ACCEPTS) V   <Ref=410><LnkRef=110>

    '
- title: 4.2.                                 V  +-> ACK --------------->+
  contents:
  - '4.2.                                 V  +-> ACK --------------->+

    '
- title: 4.3.    (wait until HID negotiated)<-+      <RVLId=44><SVLId=15>
  contents:
  - "4.3.    (wait until HID negotiated)<-+      <RVLId=44><SVLId=15>\n          \
    \                        V         <Ref=410>\n"
- title: 4.4.  <<--+<-- ACCEPT B <---------+
  contents:
  - "4.4.  <<--+<-- ACCEPT B <---------+\n               <RVLId=4><SVLId=14>\n   \
    \            <Ref=115><LnkRef=10>\n       Agent A                    Agent 2 \
    \                   Agent C\n                                     +<-+<- ACCEPT\
    \ C <------<< [3.10]\n                                     |  |   <RVLId=25><SVLId=54>\n\
    \                                     |  V   <Ref=510><LnkRef=210>\n"
- title: 4.5.                                 |  +-> ACK --------------->+
  contents:
  - "4.5.                                 |  +-> ACK --------------->+\n         \
    \                            |      <Ref=510>\n                              \
    \       |      <RVLId=54><SVLId=25>\n                                     |\n\
    \                                     |                       Agent D\n      \
    \                               V\n                                     +<-+<-\
    \ ACCEPT D <------<< [3.15]\n                                     V  |   <RVLId=26><SVLId=64>\n"
- title: 4.6.                 (wait for ACCEPTS) V   <Ref=610><LnkRef=215>
  contents:
  - '4.6.                 (wait for ACCEPTS) V   <Ref=610><LnkRef=215>

    '
- title: 4.7.                                 V  +-> ACK --------------->+
  contents:
  - '4.7.                                 V  +-> ACK --------------->+

    '
- title: 4.8.    (wait until HID negotiated)<-+      <RVLId=64><SVLId=26>
  contents:
  - "4.8.    (wait until HID negotiated)<-+      <RVLId=64><SVLId=26>\n          \
    \                        V         <Ref=610>\n"
- title: 4.9.  <<--+<- ACCEPT C <----------+
  contents:
  - "4.9.  <<--+<- ACCEPT C <----------+\n              <RVLId=5><SVLId=23> |\n  \
    \            <Ref=220><LnkRef=15>|\n                                  V\n"
- title: 4.10. <<--+<- ACCEPT D <----------+
  contents:
  - "4.10. <<--+<- ACCEPT D <----------+\n              <RVLId=5><SVLId=23>\n    \
    \          <Ref=225><LnkRef=15>\n         Figure 8.  ACCEPT Processing by an Intermediate\
    \ Agent\n         originally processed.  However, the agent does not adjust the\n\
    \         reservation in response to the ACCEPT.  It is expected that any\n  \
    \       excess resource allocation will be released for use by other\n       \
    \  stream or datagram traffic through an explicit CHANGE message\n         initiated\
    \ by the application at the origin if it does not wish\n         to be charged\
    \ for any excess resource allocations.\n      3.1.8.        ACCEPT Processing\
    \ by the Origin\n         The origin will eventually receive an ACCEPT (or REFUSE\
    \ or\n         ERROR-IN-REQUEST) message from each of the targets.  As each\n\
    \         ACCEPT is received, the application should be notified of the\n    \
    \     target and the resources that were successfully allocated along\n      \
    \   the path to it, as specified in the FlowSpec contained in the\n         ACCEPT\
    \ message.  The application may then use the information\n         to either adopt\
    \ or terminate the portion of the stream to each\n         target.  When ACCEPTs\
    \ (or failures) from all targets have been\n         received at the origin, the\
    \ application is notified that stream\n         setup is complete, and that data\
    \ may be sent.\n         Application A   Agent A                  Agent 1   Agent\
    \ 2\n                            +<-- ACCEPT B <--------<< [4.4]\n           \
    \                 |    <RVLId=4><SVLId=14>\n                            V    <Ref=115><LnkRef=10>\n\
    \   5.1.                     +--> ACK ----------------->+\n                  \
    \          |    <RVLId=14><SVLId=4>\n                            V    <Ref=115>\n\
    \   5.2.        +<-- (inform A of B's FlowSpec)\n               |            +<--\
    \ ACCEPT C <----------------<< [4.9]\n               |            |    <RVLId=5><SVLId=23>\n\
    \               |            V    <Ref=220><LnkRef=15>\n   5.3.        |     \
    \       +--> ACK ------------------------->+\n               |            |  \
    \  <RVLId=23><SVLId=5>\n               |            V    <Ref=220>\n   5.4.  \
    \      +<-- (inform A of C's FlowSpec)\n               |            +<-- ACCEPT\
    \ D <----------------<< [4.10]\n               |            |    <RVLId=5><SVLId=23>\n\
    \               |            V    <Ref=225><LnkRef=15>\n   5.5.        |     \
    \       +--> ACK ------------------------->+\n               |            |  \
    \  <RVLId=23><SVLId=5>\n               |            V    <Ref=225>\n   5.6.  \
    \      +<-- (inform A of D's FlowSpec)\n               V\n   5.7.    (wait until\
    \ HIDs negotiated)\n               V\n   5.8.    (inform A open to B,C,D)\n  \
    \             Figure 9.  ACCEPT Processing by the Origin\n         There are several\
    \ pieces of information contained in the\n         FlowSpec that the application\
    \ must combine before sending data\n         through the stream.  The PDU size\
    \ should be computed from the\n         minimum value of the DesPDUBytes field\
    \ from all ACCEPTs and the\n         protocol layers above ST should be informed\
    \ of the limit.  It\n         is expected that the next higher protocol layer\
    \ above ST will\n         segment its PDUs accordingly.  Note, however, that the\
    \ MTU may\n         decrease over the life of the stream if new targets are\n\
    \         subsequently added.  Whether the MTU should be increased as\n      \
    \   targets are dropped from a stream is left for further study.\n         The\
    \ available bandwidth and packet rate limits must also be\n         combined.\
    \  In this case, however, it may not be possible to\n         select a pair of\
    \ values that may be used for all paths, e.g.,\n         one path may have selected\
    \ a low rate of large packets while\n         another selected a high rate of\
    \ small packets.  The application\n         may remedy the situation by either\
    \ tearing down the stream,\n         dropping some participants, or creating a\
    \ second stream.\n         After any differences have been resolved (or some targets\
    \ have\n         been deleted by the application to permit resolution), the\n\
    \         application at the origin should send a CHANGE message to\n        \
    \ release any excess resources along paths to those targets that\n         exceed\
    \ the resolved parameters for the stream, thereby reducing\n         the costs\
    \ that will be incurred by the stream.\n      3.1.9.        Processing a REFUSE\
    \ Message\n         REFUSE messages are used to indicate a failure to reach an\n\
    \         application at a target;  they are propagated toward the origin\n  \
    \       of a stream.  They are used in three situations:\n          1  during\
    \ stream setup or expansion to indicate that there\n             is no satisfactory\
    \ path from an ST agent to a target,\n          2  when the application at the\
    \ target either does not\n             exist does not wish to be a participant,\
    \ or wants to\n             cease being a participant, and\n          3  when\
    \ a failure has been detected and the agents are\n             trying to find\
    \ a suitable path around the failure.\n         The cases are distinguished by\
    \ the ReasonCode field and an\n         agent receiving a REFUSE message must\
    \ examine that field in\n         order to determine the proper action to be taken.\
    \  In\n         particular, if the ReasonCode indicates that the CONNECT\n   \
    \      message reached the target then the REFUSE should be propagated\n     \
    \    back to the origin, releasing resources as appropriate along\n         the\
    \ way.  If the ReasonCode indicates that\n         the CONNECT message did not\
    \ reach the target then the\n         intermediate (origin) ST agent(s) should\
    \ check for alternate\n         routes to the target before propagating the REFUSE\
    \ back another\n         hop toward the origin.  This implies that an agent must\
    \ keep\n         track of the next-hops that it has tried, on a target by target\n\
    \         basis, in order not to get caught in a loop.\n         An ST agent that\
    \ receives a REFUSE message must acknowledge it\n         by sending an ACK to\
    \ the next-hop.  The REFUSE must also be\n         propagated back to the previous-hop\
    \ ST agent.  Note that the ST\n         agent may not have any information about\
    \ the target in\n   Appl.  Agent A                   Agent 2                 Agent\
    \ E\n                                               (proc E NOT listening)\n"
- title: 1. (add E)
  contents:
  - '1. (add E)

    '
- title: 2.    +----->+-> CONNECT E ---------->+->+
  contents:
  - "2.    +----->+-> CONNECT E ---------->+->+\n                 <RVLId=23><SVLId=5>\
    \  |  |\n                 <Ref=65>             V  |\n"
- title: 3.           +<-- ACK <---------------+  |
  contents:
  - "3.           +<-- ACK <---------------+  |\n                  <RVLId=5><SVLId=23>\
    \    V\n"
- title: 4.                <Ref=65>         (routing to E)
  contents:
  - "4.                <Ref=65>         (routing to E)\n                         \
    \                V\n"
- title: 5.                           (reserve resources 2 to E)
  contents:
  - "5.                           (reserve resources 2 to E)\n                   \
    \                      V\n"
- title: 6.                                       +--> CONNECT E --------->+
  contents:
  - "6.                                       +--> CONNECT E --------->+\n       \
    \                                       <RVLId=0><SVLId=27> |\n              \
    \                                <Ref=115><HID=4600> |\n                     \
    \                                             V\n"
- title: 7.                                    +<-+<- REFUSE B <-----------+
  contents:
  - "7.                                    +<-+<- REFUSE B <-----------+\n       \
    \                               |  |   <RVLId=27><SVLId=74>\n                \
    \                      |  |   <Ref=705><LnkRef=115>\n                        \
    \              |  V   <RC=SAPUnknown>\n"
- title: 8.                                    |  +-> ACK ---------------->+
  contents:
  - "8.                                    |  +-> ACK ---------------->+\n       \
    \                               |  |   <RVLId=74><SVLId=27> |\n              \
    \                        |  V   <Ref=705>            |\n"
- title: 9.                                    |  (free link 27)           V
  contents:
  - '9.                                    |  (free link 27)           V

    '
- title: 10.                                   V              (free link 74)
  contents:
  - '10.                                   V              (free link 74)

    '
- title: 11.          +<- REFUSE B <-----------+
  contents:
  - "11.          +<- REFUSE B <-----------+\n             |   <RVLId=5><SVLId=23>\
    \  |\n             |   <Ref=550><LnkRef=65> V\n"
- title: 12.          |   <RC=SAPUnknown>  (free resources 2 to E)
  contents:
  - "12.          |   <RC=SAPUnknown>  (free resources 2 to E)\n             V\n"
- title: 13.          +-> ACK  --------------->+
  contents:
  - "13.          +-> ACK  --------------->+\n             |   <RVLId=23><SVLId=5>\
    \  |\n             |   <Ref=550>            V\n"
- title: 14.          V             (keep link 23 for C,D)
  contents:
  - '14.          V             (keep link 23 for C,D)

    '
- title: 15.  (keep link 5 for C,D)
  contents:
  - "15.  (keep link 5 for C,D)\n      V\n"
- title: 16.  (inform application failed SAPUnknown)
  contents:
  - "16.  (inform application failed SAPUnknown)\n                   Figure 10.  Sending\
    \ REFUSE Message\n         the TargetList.  This may result from interacting DISCONNECT\n\
    \         and REFUSE messages and should be logged and silently ignored.\n   \
    \      If, after deleting the specified target, the next-hop has no\n        \
    \ remaining targets, then those resources associated with that\n         next-hop\
    \ agent may be released.  Note that network resources\n         may not actually\
    \ be released if network multicasting is being\n   Appl.   Agent A       Agent\
    \ 2  Agent 1 Agent 3              Agent B\n"
- title: 1.                                      (network from 1 to B fails)
  contents:
  - '1.                                      (network from 1 to B fails)

    '
- title: 2. (add B)
  contents:
  - '2. (add B)

    '
- title: 3.   +-> CONNECT B ----------------->+
  contents:
  - "3.   +-> CONNECT B ----------------->+\n         <RVLId=0><SVLId=6>         \
    \ |\n         <Ref=35><HID=100>           |\n"
- title: 3.   +<- HID-APPROVE <---------------+
  contents:
  - "3.   +<- HID-APPROVE <---------------+\n         <RVLId=6><SVLId=11>        \
    \ |\n         <Ref=35><HID=100>           V\n"
- title: '4.                       (routing to B: no route)'
  contents:
  - "4.                       (routing to B: no route)\n                         \
    \            V\n"
- title: 5.   +<-+-- REFUSE B ----------------+
  contents:
  - "5.   +<-+-- REFUSE B ----------------+\n     |  |   <RVLId=6><SVLId=11>\n   \
    \  |  |   <Ref=155><LnkRef=35>\n     |  V   <RC=NoRouteToDest>\n"
- title: 6.   |  +-> ACK -------------------->+
  contents:
  - "6.   |  +-> ACK -------------------->+\n     |  |   <RVLId=11><SVLId=6>     \
    \ V\n"
- title: 7.   |  V   <Ref=155>           (drop link 6)
  contents:
  - '7.   |  V   <Ref=155>           (drop link 6)

    '
- title: 8.   V  (drop link 11)
  contents:
  - '8.   V  (drop link 11)

    '
- title: '9.   (find alternative route: via agent 2)'
  contents:
  - '9.   (find alternative route: via agent 2)

    '
- title: '10.  (resources from A to 2 already allocated:'
  contents:
  - "10.  (resources from A to 2 already allocated:\n     V   reuse control link &\
    \ HID, no additional resources required)\n"
- title: 11.  +-> CONNECT B -------->+->+
  contents:
  - "11.  +-> CONNECT B -------->+->+\n         <RVLId=23><SVLId=5>|  |\n        \
    \ <Ref=40>           V  |\n"
- title: 12.  +<- ACK <--------------+  |
  contents:
  - "12.  +<- ACK <--------------+  |\n         <RVLId=5><SVLId=23>   V\n"
- title: '13.      <Ref=40>    (routing to B: via agent 3)'
  contents:
  - "13.      <Ref=40>    (routing to B: via agent 3)\n                          \
    \  V\n"
- title: 14.                         +-> CONNECT B -->+
  contents:
  - '14.                         +-> CONNECT B -->+

    '
- title: 15.                      <RVLId=0><SVLId=24> +-> CONNECT B --------->+
  contents:
  - "15.                      <RVLId=0><SVLId=24> +-> CONNECT B --------->+\n    \
    \                     <Ref=245><HID=4801> V   <RVLId=0><SVLId=32> |\n"
- title: 16.                         +<- HID-APPROVE -+   <Ref=310><HID=6000> |
  contents:
  - "16.                         +<- HID-APPROVE -+   <Ref=310><HID=6000> |\n    \
    \                            <RVLId=24><SVLId=33>                 |\n        \
    \                        <Ref=245><HID=4801>                  V\n"
- title: 17.                                          +<- HID-APPROVE --------+
  contents:
  - "17.                                          +<- HID-APPROVE --------+\n    \
    \                                             <RVLId=32><SVLId=45>|\n        \
    \                                         <Ref=310><HID=6000> V\n"
- title: 18.        (ACCEPT handling follows normally to complete stream setup)
  contents:
  - "18.        (ACCEPT handling follows normally to complete stream setup)\n    \
    \       Figure 11.  Routing Around a Failure\n         used since they may still\
    \ be required for traffic to other\n         next-hops in the multicast group.\n\
    \         When the REFUSE reaches a origin, the origin sends an ACK and\n    \
    \     notifies the application via the next higher layer protocol\n         that\
    \ the target listed in the TargetList is no longer part of\n         the stream\
    \ and also if the stream has no remaining targets.  If\n         there are no\
    \ remaining targets, the application may wish to\n         terminate the stream.\n\
    \         Figure 10 illustrates the protocol exchanges for processing a\n    \
    \     REFUSE generated at the target, either because the target\n         application\
    \ is not running or that the target application\n         rejects membership in\
    \ the stream.  Figure 11 illustrates the\n         case of rerouting around a\
    \ failure by an intermediate agent\n         that detects a failure or receives\
    \ a refuse.  The protocol\n         exchanges used by an application at the target\
    \ to delete itself\n         from the stream is discussed in Section 3.3.3 (page\
    \ 35).\n   3.2.       Data Transfer\n      At the end of the connection setup\
    \ phase, the origin, each target,\n      and each intermediate ST agent has a\
    \ database entry that allows it\n      to forward the data packets from the origin\
    \ to the targets and to\n      recover from failures of the intermediate agents\
    \ or networks.  The\n      database should be optimized to make the packet forwarding\
    \ task\n      most efficient.  The time critical operation is an intermediate\n\
    \      agent receiving a packet from the previous-hop agent and\n      forwarding\
    \ it to the next-hop agent(s).  The database entry must\n      also contain the\
    \ FlowSpec, utilization information, the address of\n      the origin and previous-hop,\
    \ and the addresses of the targets and\n      next-hops, so it can perform enforcement\
    \ and recover from\n      failures.\n      An ST agent receives data packets encapsulated\
    \ by an ST header.  A\n      data packet received by an ST agent contains the\
    \ non-zero HID\n      assigned to the stream for the branch from the previous-hop\
    \ to\n      itself.  This HID was selected so that it is unique at the\n     \
    \ receiving ST agent and thus can be used, e.g., as an index into\n      the database,\
    \ to obtain quickly the necessary replication and\n      forwarding information.\n\
    \      The forwarding information will be network and implementation\n      specific,\
    \ but must identify the next-hop agent or agents and their\n      respective HIDs.\
    \  It is suggested that the cached information for\n      a next-hop agent include\
    \ the local network address of the next-\n      hop.  If the data packet must\
    \ be forwarded to multiple next-hops\n      across a single network that supports\
    \ multicast, the database may\n      specify a single HID and may identify the\
    \ next-hops by a (local\n      network) multicast address.\n      If the network\
    \ does not support multicast, or the next-hops are on\n      different networks,\
    \ then the database must indicate multiple\n      (next-hop, HID) tuples.  When\
    \ multiple copies of the data packet\n      must be sent, it may be necessary\
    \ to invoke a packet replicator.\n      Data packets should not require fragmentation\
    \ as the next higher\n      protocol layer at the origin was informed of the minimum\
    \ MTU over\n      all paths in the stream and is expected to segment its PDUs\n\
    \      accordingly.  However, it may be the case that a data packet that\n   \
    \   is being rerouted around a failed network component may be too\n      large\
    \ for the MTU of an intervening network.  This should be a\n      transient condition\
    \ that will be corrected as soon as the new\n      minimum MTU has been propagated\
    \ back to the origin.  Disposition\n      by a mechanism other than dropping of\
    \ the too large PDUs is left\n      for further study.\n   3.3.       Modifying\
    \ an Existing Stream\n      Some applications may wish to change the parameters\
    \ of a stream\n      after it has been created.  Possible changes include adding\
    \ or\n      deleting targets and changing the FlowSpec.  These are described\n\
    \      below.\n      3.3.1.        Adding a Target\n         It is possible for\
    \ an application to add a new target to an\n         existing stream any time\
    \ after ST has incorporated information\n         about the stream into its database.\
    \  At a high level, the\n         application entities exchanges whatever information\
    \ is\n         necessary.  Although the mechanism or protocol used to\n      \
    \   accomplish this is not specified here, it is necessary for the\n         higher\
    \ layer protocol to inform the host ST agent at the origin\n         of this event.\
    \  The host ST agent at the target must also be\n         informed unless this\
    \ had previously been done.  Generally, the\n         transfer of a target list\
    \ from an ST agent to another, or from\n         a higher layer protocol to a\
    \ host ST agent, will occur\n         atomically when the CONNECT is received.\
    \  Any information\n         concerning a new target received after this point\
    \ can be viewed\n         as a stream expansion by the receiving ST agent.  However,\
    \ it\n         may be possible that an ST agent can utilize such information\n\
    \         if it is received before it makes the relevant routing\n         decisions.\
    \  These implementation details are not specified\n         here, but implementations\
    \ must be prepared to receive CONNECT\n         messages that represent expansions\
    \ of streams that are still in\n         the process of being setup.\n       \
    \  To expand an existing stream, the origin issues one or more\n         CONNECT\
    \ messages that contain the Name, the VLId, the FlowSpec,\n         and the TargetList\
    \ specifying the new target or targets.  The\n         origin issues multiple\
    \ CONNECT messages if\n         either the targets are to be reached through different\
    \ next-hop\n         agents, or a single CONNECT message is too large for the\n\
    \         network MTU.  The HID Field option is not set since the HID has\n  \
    \       already been (or is being) negotiated for the hop;\n         consequently,\
    \ the CONNECT is acknowledged with an ACK instead\n         of a HID-REJECT or\
    \ HID-APPROVE.\n"
- title: Application  Agent A               Agent 2                    Agent E
  contents:
  - 'Application  Agent A               Agent 2                    Agent E

    '
- title: 1.   (open E)
  contents:
  - '1.   (open E)

    '
- title: 2.      V                                            (proc E listening)
  contents:
  - '2.      V                                            (proc E listening)

    '
- title: 3.      +->(routing to E)
  contents:
  - "3.      +->(routing to E)\n           V\n"
- title: '4.         +-> (check resources from A to Agent 2: already allocated,'
  contents:
  - "4.         +-> (check resources from A to Agent 2: already allocated,\n     \
    \      V  reuse control link & HID, no additional resources needed)\n"
- title: 5.         +-> CONNECT E --------->+->+
  contents:
  - "5.         +-> CONNECT E --------->+->+\n               <RVLId=23><SVLId=5> |\
    \  V\n"
- title: 6.             <Ref=20>            V  (routing to E)
  contents:
  - '6.             <Ref=20>            V  (routing to E)

    '
- title: 7.         +<- ACK <---------------+  V
  contents:
  - "7.         +<- ACK <---------------+  V\n               <RVLId=5><SVLId=23> \
    \   +->(reserve resources 2 to E)\n               <Ref=20>                  V\n"
- title: 8.                                       +-> CONNECT E --------->+
  contents:
  - "8.                                       +-> CONNECT E --------->+\n        \
    \                                     <RVLId=0><SVLId=27> |\n                \
    \                             <Ref=230><HID=4800> |\n"
- title: 9.                                       +<- HID-APPROVE <-------+
  contents:
  - "9.                                       +<- HID-APPROVE <-------+\n        \
    \                                     <RVLId=27><SVLId=74>|\n                \
    \                             <Ref=230><HID=4800> V\n"
- title: 10.                                               (proc E accepts)
  contents:
  - '10.                                               (proc E accepts)

    '
- title: 11.                                    (wait until HID negotiated)
  contents:
  - "11.                                    (wait until HID negotiated)\n        \
    \                                                         V\n"
- title: 12.                                   +<-+<- ACCEPT E <----------+
  contents:
  - "12.                                   +<-+<- ACCEPT E <----------+\n        \
    \                              V  |   <RVLId=27><SVLId=74>\n"
- title: 13.                  (wait for ACCEPTS)  V   <Ref=710><LnkRef=230>
  contents:
  - '13.                  (wait for ACCEPTS)  V   <Ref=710><LnkRef=230>

    '
- title: 14.                                   V  +-> ACK --------------->+
  contents:
  - '14.                                   V  +-> ACK --------------->+

    '
- title: 15.      (wait until HID negotiated)<-+      <RVLId=74><SVLId=27>
  contents:
  - "15.      (wait until HID negotiated)<-+      <RVLId=74><SVLId=27>\n         \
    \                          V         <Ref=710>\n"
- title: 16.           +<- ACCEPT E <-------+
  contents:
  - "16.           +<- ACCEPT E <-------+\n              |   <RVLId=5><SVLId=23>\n\
    \              V   <Ref=235><LnkRef=20>\n"
- title: 17.           +-> ACK ------------>+
  contents:
  - "17.           +-> ACK ------------>+\n              |   <RVLId=23><SVLId=5>\n\
    \              V   <Ref=235>\n"
- title: 18.        +<-(inform A of E's FlowSpec)
  contents:
  - "18.        +<-(inform A of E's FlowSpec)\n           V\n"
- title: 19.     +<-(wait for ACCEPTS)
  contents:
  - "19.     +<-(wait for ACCEPTS)\n        V\n"
- title: 20.  +<-(wait until HID negotiated)
  contents:
  - "20.  +<-(wait until HID negotiated)\n     V\n"
- title: 21.  (inform A open to E)
  contents:
  - "21.  (inform A open to E)\n                 Figure 12.  Addition of Another Target\n\
    \         An ST agent that is already a node in the stream recognizes the\n  \
    \       RVLId and verifies that the Name of the stream is the same.  It\n    \
    \     then checks if the intersection of the TargetList and the\n         targets\
    \ of the established stream is empty.  If this is not the\n         case, then\
    \ the receiver responds with an ERROR-IN-REQUEST with\n         the appropriate\
    \ reason code (RouteLoop) that contains a\n         TargetList of those targets\
    \ that were duplicates;  see Section\n         4.2.3.5 (page 106).\n         For\
    \ each new target in the TargetList, processing is much the\n         same as\
    \ for the original CONNECT;  see Sections 3.1.2-4 (pages\n         19-20).  The\
    \ CONNECT must be acknowledged, propagated, and\n         network resources must\
    \ be reserved.  However, it may be\n         possible to route to the new targets\
    \ using previously allocated\n         paths or an existing multicast group. \
    \ In that case, additional\n         resources do not need to be reserved but\
    \ more next-hop(s) might\n         have to be added to an existing multicast group.\n\
    \         Nevertheless, the origin, or any intermediate ST agent that\n      \
    \   receives a CONNECT for an existing stream, can make a routing\n         decision\
    \ that is independent of any it may have made\n         previously.  Depending\
    \ on the routing algorithm that is used,\n         the ST agent may decide to\
    \ reach the new target by way of an\n         established branch, or it may decide\
    \ to create a new branch.\n         The fact that a new target is being added\
    \ to an existing stream\n         may result in a suboptimal overall routing for\
    \ certain routing\n         algorithms.  We take this problem to be unavoidable\
    \ since it is\n         unlikely that the stream routing can be made optimal in\n\
    \         general, and the only way to avoid this loss of optimality is\n    \
    \     to redefine the routing of potentially the entire stream, which\n      \
    \   would be too expensive and time consuming.\n      3.3.2.        The Origin\
    \ Removing a Target\n         The application at the origin specifies a set of\
    \ targets that\n         are to be removed from the stream and an appropriate\
    \ reason\n         code (ApplDisconnect).  The targets are partitioned into\n\
    \         multiple DISCONNECT messages based on the next-hop to the\n        \
    \ individual targets.  As with CONNECT messages, an ST agent that\n         is\
    \ sending a DISCONNECT must make sure that the message fits\n         into the\
    \ MTU for the intervening network.  If the message is\n         too large, the\
    \ TargetList must be further partitioned into\n         multiple DISCONNECT messages.\n\
    \         An ST agent that receives a DISCONNECT message must acknowledge\n  \
    \       it by sending an ACK back to the previous-hop.  The DISCONNECT\n     \
    \    must also be propagated to the relevant next-hop ST agents.\n         Before\
    \ propagating the message, however, the TargetList should\n         be partitioned\
    \ based on next-hop ST\n         agent and MTU, as described above.  Note that\
    \ there may be\n         targets in the TargetList for which the ST agent has\
    \ no\n         information.  This may result from interacting DISCONNECT and\n\
    \         REFUSE messages and should be logged and silently ignored.\n       \
    \  If, after deleting the specified targets, any next-hop has no\n         remaining\
    \ targets, then those resources associated with that\n         next-hop agent\
    \ may be released.  Note that network resources\n         may not actually be\
    \ released if network multicasting is being\n         used since they may still\
    \ be required for traffic to other\n         next-hops in the multicast group.\n\
    \      Application                                         Application\n     \
    \       Agent A             Agent 1  Agent 2          Agent B    C\n  1.  (close\
    \ B,C ApplDisconnect)\n          V\n  2.      +->+-+-> DISCONNECT B ----->+\n\
    \  3.         | |   <RVLId=14><SVLId=4>+-+-> DISCONNECT B ------>+\n         \
    \    | |   <Ref=25>           | |   <RVLId=44><SVLId=15>|\n             | V  \
    \ <RC=ApplDisconnect>| |   <Ref=120>           |\n  4.         | (free A to 1\
    \ resrc.)   | V   <RC=ApplDisconnect> |\n  5.         |                      \
    \  V (free 1 to B resrc.)    |\n  6.         | +<- ACK <--------------+      \
    \                   V\n  7.         | |   <RVLId=4><SVLId=14>| +<- ACK <---------------+\n\
    \             | V   <Ref=25>           | |   <RVLId=15><SVLId=44>|\n  8.     \
    \    | (free link 4)          V |   <Ref=120>           |\n  9.         |    \
    \       (free link 14) V                       |\n  10.        |             \
    \             (free link 15)          V\n  11.        |        (inform B that\
    \ stream closed ApplDisconnect)\n  12.        |                              \
    \       (free link 44)\n             V\n  13.     +<-+-+-> DISCONNECT C ---------->+\n\
    \  14.     |    |   <RVLId=23><SVLId=5>     +-+-> DISCONNECT C ------>+\n    \
    \      |    |   <Ref=30>                | |   <RVLId=54><SVLId=25>|\n        \
    \  |    V   <RC=ApplDisconnect>     | |   <Ref=240>           |\n  15.     | \
    \   (keep A to 2 resrc for      | V   <RC=ApplDisconnect> |\n  16.     |     \
    \    data going to D,E)     | (free 2 to C resrc.)    |\n          |         \
    \                       V                         |\n  17.     |    +<- ACK <-------------------+\
    \                         V\n  18.     |    |   <RVLId=5><SVLId=23>     | +<-\
    \ ACK <---------------+\n          |    V   <Ref=30>                | |   <RVLId=25><SVLId=54>|\n\
    \  19.     |    (keep link 5 for D,E)       V |   <Ref=240>           |\n  20.\
    \     |           (keep link 23 for D,E) V                       |\n  21.    \
    \ |                           (free link 25)                 V\n  22.     |  \
    \            (inform C that stream closed ApplDisconnect>)\n  23.     V      \
    \                                       (free link 54)\n  24.     (inform A closed\
    \ to B,C ApplDisconnect)\n                  Figure 13.  Origin Removing a Target\n\
    \         When the DISCONNECT reaches a target, the target sends an ACK\n    \
    \     and notifies the application that it is no longer part of the\n        \
    \ stream and the reason.  The application should then inform ST\n         to terminate\
    \ the stream, and ST should delete the stream from\n         its database after\
    \ performing any necessary management and\n         accounting functions.\n  \
    \    3.3.3.        A Target Deleting Itself\n         The application at the target\
    \ may inform ST that it wants to be\n         removed from the stream and the\
    \ appropriate reason code\n         (ApplDisconnect).  The agent then forms a\
    \ REFUSE message with\n         itself as the only entry in the TargetList.  The\
    \ REFUSE is sent\n         back to the origin via the previous-hop.  If a stream\
    \ has\n         multiple targets and one target leaves the stream using this\n\
    \         REFUSE mechanism, the stream to the other targets is not\n         affected;\
    \  the stream continues to exist.\n         An ST agent that receives such a REFUSE\
    \ message must\n         acknowledge it by sending an ACK to the next-hop.  The\
    \ target\n         is deleted and, if the next-hop has no remaining targets, then\n\
    \         the those resources associated with that next-hop agent may be\n   \
    \      released.  Note that network resources may not actually be\n         released\
    \ if network multicasting is being used since they may\n         still be required\
    \ for traffic to other next-hops in the\n         multicast group.  The REFUSE\
    \ must also be propagated back to\n         the previous-hop ST agent.\n     \
    \            Agent A          Agent 2          Agent E\n            1.       \
    \                      (close E ApplDisconnect)\n                            \
    \                          V\n            2.                         +<- REFUSE\
    \ E --+\n                                       |   <RVLId=27><SVLId=74>\n   \
    \                                    |   <Ref=720>\n                         \
    \              V   <RC=ApplDisconnect>\n            3.                      +<-+->\
    \ ACK ------>+\n                                    |  |   <RVLId=74><SVLId=27>\n\
    \            4.                      V  V   <Ref=720>\n            5.    +<-+<-\
    \ REFUSE E --+  (prune allocations)\n                  |  |   <RVLId=5><SVLId=23>\n\
    \                  |  |   <Ref=245>\n                  |  V   <RC=ApplDisconnect>\n\
    \            6.    |  +-> ACK ------>+\n                  |  |   <RVLId=23><SVLId=5>\n\
    \                  |  V   <Ref=245>\n            7.    V  (prune allocations)\n\
    \            8.    (inform application closed E ApplDisconnect)\n            \
    \       Figure 14.  Target Deleting Itself\n         When the REFUSE reaches the\
    \ origin, the origin sends an ACK and\n         notifies the application that\
    \ the target listed in the\n         TargetList is no longer part of the stream.\
    \  If the stream has\n         no remaining targets, the application may choose\
    \ to terminate\n         the stream.\n      3.3.4.        Changing the FlowSpec\n\
    \         An application may wish to change the FlowSpec of an\n         established\
    \ stream.  To do so, it informs ST of the new\n         FlowSpec and the list\
    \ of targets that are to be changed.  The\n         origin ST agent then issues\
    \ one or more CHANGE messages with\n         the new FlowSpec and sends them to\
    \ the relevant next-hop\n         agents.  CHANGE messages are structured and\
    \ processed similarly\n         to CONNECT messages.  A next-hop agent that is\
    \ an intermediate\n         agent and receives a CHANGE message similarly determines\
    \ if it\n         can implement the new FlowSpec along the hop to each of its\n\
    \         next-hop agents, and if so, it propagates the CHANGE messages\n    \
    \     along the established paths.  If this process succeeds, the\n         CHANGE\
    \ messages will eventually reach the targets, which will\n         each respond\
    \ with an ACCEPT message that is propagated back to\n         the origin.\n  \
    \       Note that since a CHANGE may be sent containing a FlowSpec with\n    \
    \     a range of permissible values for bandwidth, delay, and/or\n         error\
    \ rate, and the actual values returned in the ACCEPTs may\n         differ, then\
    \ another CHANGE may be required to release excess\n         resources along some\
    \ of the paths.\n   3.4.       Stream Tear Down\n      A stream is usually terminated\
    \ by the origin when it has no\n      further data to send, but may also be partially\
    \ torn down by the\n      individual targets.  These cases will not be further\
    \ discussed\n      since they have already been described in Sections 3.3.2-3\
    \ (pages\n      33-35).\n      A stream is also torn down if the application should\
    \ terminate\n      abnormally.  Processing in this case is identical to the previous\n\
    \      descriptions except that the appropriate reason code is different\n   \
    \   (ApplAbort).\n      When all targets have left a stream, the origin notifies\
    \ the\n      application of that fact, and the application then is responsible\n\
    \      for terminating the stream.  Note, however, that the application\n    \
    \  may decide to add a target(s) to the stream instead of terminating\n      it.\n\
    \   3.5.       Exceptional Cases\n      The previous descriptions covered the\
    \ simple cases where\n      everything worked.  We now discuss what happens when\
    \ things do not\n      succeed.  Included are situations where messages are lost,\
    \ the\n      requested resources are not available, the routing fails or is\n\
    \      inconsistent.\n      In order for the ST Control Message Protocol to be\
    \ reliable over\n      an unreliable internetwork, the problems of corruption,\n\
    \      duplication, loss, and ordering must be addressed.  Corruption is\n   \
    \   handled through use of checksumming, as described in Section 4\n      (page\
    \ 76).  Duplication of control messages is detected by\n      assigning a transaction\
    \ number (Reference) to each control\n      message;  duplicates are discarded.\
    \  Loss is detected using a\n      timeout at the sender;  messages that are not\
    \ acknowledged before\n      the timeout expires are retransmitted;  see Section\
    \ 3.7.6 (page\n      66).  If a message is not acknowledged after a few retransmissions\n\
    \      a fault is reported.  The protocol does not have significant\n      ordering\
    \ constraints.  However, minor sequencing of control\n      messages for a stream\
    \ is facilitated by the requirement that the\n      Reference numbers be monotonically\
    \ increasing;  see Section 4.2\n      (page 78).\n      3.5.1.        Setup Failure\
    \ due to CONNECT Timeout\n         If a response (an ERROR-IN-REQUEST, an ACK,\
    \ a HID-REJECT, or a\n         HID-APPROVE) has not been received within time\
    \ ToConnect, the\n         ST agent should retransmit the CONNECT message.  If\
    \ no response\n         has been received within NConnect retransmissions, then\
    \ a fault\n         occurs and a REFUSE message with the appropriate reason code\n\
    \         (RetransTimeout) is sent back in the direction of the origin,\n    \
    \     and, in place of the CONNECT, a DISCONNECT is sent to the\n         next-hop\
    \ (in case the response to the CONNECT is the message\n         that was lost).\
    \  The agent will expect an ACK for both the\n         REFUSE and the DISCONNECT\
    \ messages.  If it does not receive an\n         ACK after retransmission time\
    \ ToRefuse and ToDisconnect\n         respectively, it will resend the REFUSE/DISCONNECT\
    \ message.  If\n         it does not receive ACKs after sending NRefuse/ NDisconnect\n\
    \         consecutive REFUSE/DISCONNECT messages, then it simply gives up\n  \
    \       trying.\n          Sending Agent              Receiving Agent\n    1.\
    \   ->+----> CONNECT X ------>//// (message lost or garbled)\n           |   \
    \   <RVLId=0><SVLId=99>\n           V      <Ref=1278><HID=1234>\n    2. (timeout)\n\
    \           V\n    3.     +----> CONNECT X ------------>+\n    4.     |      <RVLId=0><SVLId=99>\
    \    +----> CONNECT X ----------->+\n           |      <Ref=1278><HID=1234>  \
    \ V      <RVLId=0><SVLId=1010> |\n    5.     | //<- HID-APPROVE <----------+ \
    \     <Ref=6666><HID=6666>  V\n    6.     |      <RVLId=99><SVLId=88>      +<-\
    \ HID-APPROVE <---------+\n           V      <Ref=1278><HID=1234>          <RVLId=1010><SVLId=1111>\n\
    \    7. (timeout)                                <Ref=6666><HID=6666>\n      \
    \     V\n    8.     +----> CONNECT X ------------>+\n                  <RVLId=0><SVLId=99>\
    \    |\n                  <Ref=1278><HID=1234>   V\n    9.     +<-+<- HID-APPROVE\
    \ <----------+\n           |      <RVLId=99><SVLId=88>\n           V      <Ref=1278><HID=1234>\n\
    \     (cancel timer)\n           Figure 15.  CONNECT Retransmission after a Timeout\n\
    \      3.5.2.        Problems due to Routing Inconsistency\n         When an intermediate\
    \ agent receives a CONNECT, it selects the\n         next-hop agents based on\
    \ the TargetList and the networks to\n         which it is connected.  If the\
    \ resulting next-hop to any of the\n         targets is across the same network\
    \ from which it received the\n         CONNECT (but not the previous-hop itself),\
    \ there may be a\n         routing problem.  However, the routing algorithm at\
    \ the\n         previous-hop may be optimizing differently than the local\n  \
    \       algorithm would in the same situation.  Since the local ST\n         agent\
    \ cannot distinguish the two cases, it should permit the\n         setup but send\
    \ back to the previous-hop agent an informative\n         NOTIFY message with\
    \ the appropriate reason code (RouteBack),\n         pertinent TargetList, and\
    \ in the NextHopIPAddress element the\n         address of the next-hop ST agent\
    \ returned by its routing\n         algorithm.\n         The agent that receives\
    \ such a NOTIFY should ACK it.  If the\n         agent is using an algorithm that\
    \ would produce such behavior,\n         no further action is taken;  if not,\
    \ the agent should send a\n         DISCONNECT to the next-hop agent to correct\
    \ the problem.\n         Alternatively, if the next-hop returned by the routing\
    \ function\n         is in fact the previous-hop, a routing inconsistency has\
    \ been\n         detected.  In this case, a REFUSE is sent back to\n         the\
    \ previous-hop agent containing an appropriate reason code\n         (RouteInconsist),\
    \ pertinent TargetList, and in the\n         NextHopIPAddress element the address\
    \ of the previous-hop.  When\n         the previous-hop receives the REFUSE, it\
    \ will recompute the\n         next-hop for the affected targets.  If there is\
    \ a difference in\n         the routing databases in the two agents, they may\
    \ exchange\n         CONNECT and REFUSE messages again.  Since such routing errors\n\
    \         in the internet are assumed to be temporary, the situation\n       \
    \  should eventually stabilize.\n      3.5.3.        Setup Failure due to a Routing\
    \ Failure\n         It is possible for an agent to receive a CONNECT message that\n\
    \         contains a known Name, but from an agent other than the\n         previous-hop\
    \ agent of the stream with that Name.  This may be:\n          1  that two branches\
    \ of the tree forming the stream have\n             joined back together,\n  \
    \        2  a deliberate source routing loop,\n          3  the result of an attempted\
    \ recovery of a partially\n             failed stream, or\n          4  an erroneous\
    \ routing loop.\n         The TargetList is used to distinguish the cases 1 and\
    \ 2 (see\n         also Section 4.2.3.5 (page 107)) by comparing each newly\n\
    \         received target with those of the previously existing stream:\n    \
    \      o  if the IP address of the targets differ, it is case 1;\n          o\
    \  if the IP address of the targets match but the source\n             route(s)\
    \ are different, it is case 2;\n          o  if the target (including any source\
    \ route) matches a\n             target (including any source route) in the existing\n\
    \             stream, it may be case 3 or 4.\n         It is expected that the\
    \ joining of branches will become more\n         common as routing decisions are\
    \ based on policy issues and not\n         just simple connectivity.  Unfortunately,\
    \ there is no good way\n         to merge the two parts of the stream back into\
    \ a single stream.\n         They must be treated independently with respect to\
    \ processing\n         in the agent.  In particular, a separate state machine\
    \ is\n         required, the Virtual Link Identifiers and HIDs from the\n    \
    \     previous-hops and to the next-hops must be different, and\n         duplicate\
    \ resources must be reserved in both the agent and in\n         any next-hop networks.\
    \  Processing is the same for a deliberate\n         source routing loop.\n  \
    \       The remaining cases requiring recovery, a partially failed\n         stream\
    \ and an erroneous routing loop, are not easily\n         distinguishable.  In\
    \ attempting recovery of a failed stream, an\n         agent may issue new CONNECT\
    \ messages to the affected targets;\n         for a full explanation see also\
    \ Section 3.7.2 (page 51),\n         Failure Recovery.  Such a CONNECT may reach\
    \ an agent downstream\n         of the failure before that agent has received\
    \ a DISCONNECT from\n         the neighborhood of the failure.  Until that agent\
    \ receives the\n         DISCONNECT, it cannot distinguish between a failure recovery\n\
    \         and an erroneous routing loop.  That agent must therefore\n        \
    \ respond to the CONNECT with a REFUSE message with the affected\n         targets\
    \ specified in the TargetList and an appropriate reason\n         code (StreamExists).\n\
    \         The agent immediately preceding that point, i.e., the latest\n     \
    \    agent to send the CONNECT message, will receive the REFUSE\n         message.\
    \  It must release any resources reserved exclusively\n         for traffic to\
    \ the listed targets.  If this agent was not the\n         one attempting the\
    \ stream recovery, then it cannot distinguish\n         between a failure recovery\
    \ and an erroneous routing loop.  It\n         should repeat the CONNECT after\
    \ a ToConnect timeout.  If after\n         NConnect retransmissions it continues\
    \ to receive REFUSE\n         messages, it should propagate the REFUSE message\
    \ toward the\n         origin, with the TargetList that specifies the affected\n\
    \         targets, but with a different error code (RouteLoop).\n         The\
    \ REFUSE message with this error code (RouteLoop) is\n         propagated by each\
    \ ST agent without retransmitting any CONNECT\n         messages.  At each agent,\
    \ it causes any resources reserved\n         exclusively for the listed targets\
    \ to be released.  The REFUSE\n         will be propagated to the origin in the\
    \ case of an erroneous\n         routing loop.  In the case of stream recovery,\
    \ it will be\n         propagated to the ST agent that is attempting the recovery,\n\
    \         which may be an intermediate agent or the origin itself.  In\n     \
    \    the case of a stream recovery, the agent attempting the\n         recovery\
    \ may issue new CONNECT messages to the same or to\n         different next-hops.\n\
    \         If an agent receives both a REFUSE message and a DISCONNECT\n      \
    \   message with a target in common then it can release the\n         relevant\
    \ resources and propagate neither the REFUSE nor the\n         DISCONNECT (however,\
    \ we feel that it is unlikely that most\n         implementations will be able\
    \ to detect this situation).\n         If the origin receives such a REFUSE message,\
    \ it should attempt\n         to send a new CONNECT to all the affected targets.\
    \  Since\n         routing errors in an internet are assumed to be temporary,\
    \ the\n         new CONNECTs will eventually find acceptable routes to the\n \
    \        targets, if one exists.  If no further routes exist after\n         NRetryRoute\
    \ tries, the application should be\n         informed so that it may take whatever\
    \ action it deems\n         necessary.\n      3.5.4.        Problems in Reserving\
    \ Resources\n         If the network or ST agent resources are not available,\
    \ an ST\n         agent may preempt one or more streams that have lower\n    \
    \     precedence than the one being created.  When it breaks a lower\n       \
    \  precedence stream, it must issue REFUSE and DISCONNECT messages\n         as\
    \ described in Sections 4.2.3.15 (page 122) and 4.2.3.6 (page\n         110).\
    \  If there are no streams of lower precedence, or if\n         preempting them\
    \ would not provide sufficient resources, then\n         the stream cannot be\
    \ accepted by the ST agent.\n         If an intermediate agent detects that it\
    \ cannot allocate the\n         necessary resources, then it sends a REFUSE that\
    \ contains an\n         appropriate reason code (CantGetResrc) and the pertinent\n\
    \         TargetList to the previous-hop ST agent.  For further study are\n  \
    \       issues of reporting what resources are available, whether the\n      \
    \   resource shortage is permanent or transitory, and in the latter\n        \
    \ case, an estimate of how long before the requested resources\n         might\
    \ be available.\n      3.5.5.        Setup Failure due to ACCEPT Timeout\n   \
    \      An ST agent that propagates an ACCEPT message backward toward\n       \
    \  the origin expects an ACK from the previous-hop.  If it does\n         not\
    \ receive an ACK within a timeout, called ToAccept, it will\n         retransmit\
    \ the ACCEPT.  If it does not receive an ACK after\n         sending a number,\
    \ called NAccept, of ACCEPT messages, then it\n         will replace the ACCEPT\
    \ with a REFUSE, and will send a\n         DISCONNECT in the direction toward\
    \ the target.  Both the REFUSE\n         and DISCONNECT will identify the affected\
    \ target(s) and specify\n         an appropriate reason code (AcceptTimeout).\
    \  Both are also\n         retransmitted until ACKed with timeout ToRefuse/ ToDisconnect\n\
    \         and retransmit count NRefuse/NDisconnect.  If they are not\n       \
    \  ACKed, the agent simply gives up, letting the failure detection\n         mechanism\
    \ described in Section 3.7.1 (page 48) take care of any\n         cleanup.\n \
    \     3.5.6.        Problems Caused by CHANGE Messages\n         An application\
    \ must exercise care when changing a FlowSpec to\n         prevent a failure.\
    \  A CHANGE might fail for two reasons.  The\n         request may be for a larger\
    \ amount of network resources when\n         those resources are not available;\
    \  this failure may be\n         prevented by requiring that the current level\
    \ of service be\n         contained within the ranges of the FlowSpec in the CHANGE.\n\
    \         Alternatively, the local network might require all the former\n    \
    \     resources to be released before the new ones are requested and,\n      \
    \   due to unlucky timing, an unrelated request for network\n         resources\
    \ might be processed between the time the resources are\n         released and\
    \ the time the new resources are requested, so that\n         the former resources\
    \ are no longer available.  There is not\n         much that an application or\
    \ ST can do to prevent such failures.\n         If the attempt to change the FlowSpec\
    \ fails then the ST agent\n         where the failure occurs must intentionally\
    \ break the stream\n         and invoke the stream recovery mechanism using REFUSE\
    \ and\n         DISCONNECT messages;  see Section 3.7.2 (page 51).  Note that\n\
    \         the reserved resources after the failure of a CHANGE may not be\n  \
    \       the same as before, i.e., the CHANGE may have been partially\n       \
    \  completed.  The application is responsible for any cleanup\n         (another\
    \ CHANGE).\n      3.5.7.        Notification of Changes Forced by Failures\n \
    \        NOTIFY is issued by a an ST Agent to inform upsteam agents and\n    \
    \     the origin that resource allocation changes have occurred after\n      \
    \   a stream was established.  These changes occur when network\n         components\
    \ fail and when competing streams preempt resources\n         previously reserved\
    \ by a lower precedence stream.  We also\n         anticipate that NOTIFY can\
    \ be used in the future when\n         additional resources become available,\
    \ as is the case when\n         network components recover or when higher precedence\
    \ streams\n         are deleted.\n         NOTIFY is also used to inform upstream\
    \ agents that a routing\n         anomaly has occurred.  Such an example was cited\
    \ in Section\n         3.5.2 (page 38), where an agent notices that the next-hop\
    \ agent\n         is on the same network as the previous-hop agent;  the anomaly\n\
    \         is that the previous-hop should have connected directly to the\n   \
    \      next-hop without using an intermediate agent.  Delays in\n         propagating\
    \ host status and routing information can cause such\n         anomalies to occur.\
    \  NOTIFY allows ST to correct automatically\n         such mistakes.\n      \
    \   NOTIFY reports a FlowSpec that reflects that revised guarantee\n         that\
    \ can be promised to the stream.  NOTIFY also\n         identifies those targets\
    \ affected by the change.  In this way,\n         NOTIFY is similar to ACCEPT.\
    \  NOTIFY includes a ReasonCode to\n         identify the event that triggered\
    \ the notification.  It also\n         includes a TargetList, rather than a single\
    \ Target, since a\n         single event can affect a branch leading to several\
    \ targets.\n         NOTIFY is relayed by the ST agents back toward the origin,\n\
    \         along the path established by the CONNECT but in the reverse\n     \
    \    direction.  NOTIFY must be acknowledged with an ACK at each\n         hop.\
    \  If intermediate agent corrects the situation without\n         causing any\
    \ disruption to the data flow or guarantees, it can\n         choose to drop the\
    \ notification message before it reaches the\n         origin.  If the originating\
    \ agent receives a NOTIFY, it is then\n         expected to adjust its own processing\
    \ and data rates, and to\n         submit any required CHANGE requests.  As with\
    \ ACCEPT, the\n         FlowSpec is not modified on this trip from the target\
    \ back to\n         the origin.  It is up to the origin to decide whether a CHANGE\n\
    \         should be submitted.  (However, even though the FlowSpec has\n     \
    \    not been modified, the situation reported in the\n   Application  Agent A\
    \            Agent 1                    Agent B\n 1.                      (high\
    \ precedence request preempts 10K of\n                             the stream's\
    \ original 30Kb bandwidth\n                              allocated to the hop\
    \ from 1 to B)\n                                      |\n                    \
    \                  V\n 2.   +<------+-- NOTIFY -------------+\n      |       |\
    \   <RVLId=4><SVLId=14>\n      |       |   <Ref=150>\n      |       V   <FlowSpec=20Kb,...><TargList=B>\n\
    \ 3.   |       +-> ACK --------------->+\n      |           <RVLId=14><SVLId=4>\n\
    \      V           <Ref=150>\n 4. (inform application)\n      ....\n 5. change(FlowSpec=20Kb,...)\n\
    \      V\n 6.   +---------> CHANGE B ---------->+\n 7.               <RVLId=14><SVLId=4>\
    \ +--> CHANGE B ------------>+->+\n                  <Ref=60>            |   \
    \ <RVLId=44><SVLId=15>  |  |\n                  <FlowSpec=20Kb,...> V    <Ref=160>\
    \             |  |\n 8.           +<- ACK ----------------+    <FlowSpec=20Kb,...>\
    \   |  |\n                  <RVLId=4><SVLId=14>                            V \
    \ |\n 9.               <Ref=60>            +--- ACK ------------------+  |\n \
    \                                            <RVLId=15><SVLId=44>   |\n      \
    \                                       <Ref=160>              V\n           \
    \   ... perform normal ACCEPT processing ...        <-----+\n                \
    \ Figure 16.  Processing NOTIFY Messages\n         notify may have prevented the\
    \ ST agents from meeting the\n         original guarantees.)\n   3.6.       Options\n\
    \      Several options are defined in the CONNECT message.  The special\n    \
    \  processing required to support each will be described in the\n      following\
    \ sections.  The options are independent, i.e., can be set\n      to one (1, TRUE)\
    \ or zero (0, FALSE) in any combination.  However,\n      the effect and implementation\
    \ of the options is NOT necessarily\n      independent, and not all combinations\
    \ are supported.\n      3.6.1.        HID Field Option\n         The sender of\
    \ a CONNECT message may or not specify an HID in\n         the HID field.  If\
    \ the HID Field option of the CONNECT message\n         is not set (the H bit\
    \ is 0), then the HID field does not\n         contain relevant information and\
    \ should be ignored.\n         If this option is set (the H bit is 1), then the\
    \ HID field\n         contains a relevant value.  If this option is set and the\
    \ HID\n         field of the CONNECT contains a non-zero value, that value\n \
    \        represents a proposed HID that initiates the HID negotiation.\n     \
    \    If the HID Field option is set but the HID field of the CONNECT\n       \
    \  message contains a zero, this means that the sender of that\n         CONNECT\
    \ message has chosen to defer selection of the HID to the\n         next-hop agent\
    \ (the receiver of a CONNECT message).  This\n         choice can allow a more\
    \ efficient mechanism for selecting HIDs\n         and possibly a more efficient\
    \ mechanism for forwarding data\n         packets in the case when the previous-hop\
    \ does not need to\n         select the HID;  see also Section 4.2.3.5 (page 105).\n\
    \         Upon receipt of a CONNECT message with the HID Field option set\n  \
    \       and the HID field set to zero, a next-hop agent selects the HID\n    \
    \     for the hop, enters it into its appropriate data structure, and\n      \
    \   returns it in the HID field of the HID-APPROVE message.  The\n         previous-hop\
    \ takes the HID from the HID-APPROVE message and\n         enters it into its\
    \ appropriate data structure.\n      3.6.2.        PTP Option\n         The PTP\
    \ option (Point-to-Point) is used to indicate that the\n         stream will never\
    \ have more than a single target.  It\n         consequently implies that the\
    \ stream will never need to support\n         any form of multicasting.  Use of\
    \ the PTP option may thus allow\n         efficiencies in the way the stream is\
    \ built or is\n         managed.  Specifically, the ST agents do not need to request\n\
    \         that the intervening networks allocate multicast groups to\n       \
    \  support this stream.\n         The PTP option can only be set to one (1) by\
    \ the origin, and\n         must be the same for the entire stream (i.e., propagated\
    \ by ST\n         agents).  The details of what this option does are\n       \
    \  implementation specific, and do not affect the protocol very\n         much.\n\
    \         If the application attempts to add a new target to an existing\n   \
    \      stream that was created with the PTP option set to one (1), the\n     \
    \    application should be informed of the error with an ERROR-IN-\n         REQUEST\
    \ message with the appropriate reason code.  If a CONNECT\n         is received\
    \ whose TargetList contains more than a single entry,\n         an ERROR-IN-REQUEST\
    \ message with the appropriate reason code\n         (PTPError) should be returned\
    \ to the previous-hop agent (note\n         that such a CONNECT should never be\
    \ received if the origin both\n         implements the PTP option and is functioning\
    \ properly).\n         As implied in the last paragraph, a subsetted implementation\n\
    \         might choose not to implement the PTP option.\n      3.6.3.        FDx\
    \ Option\n         The FDx option is used to indicate that a second stream in\
    \ the\n         reverse direction, from the target to the origin, should\n   \
    \      automatically be created.  This option is most likely to be\n         used\
    \ when the TargetList has only a single entry.  If used when\n         the TargetList\
    \ has multiple entries, the resulting streams\n         would allow bi-directional\
    \ communication between the origin and\n         the various targets, but not\
    \ among the targets.  The FDx option\n         can only be invoked by the origin,\
    \ and must be propagated by\n         intermediate agents.\n         This option\
    \ is specified by inclusion of both an RFlowSpec and\n         an RHID parameter\
    \ in the CONNECT message (possibly with an\n         optional RGroup parameter).\n\
    \         Any ST agent that receives a CONNECT message with both an\n        \
    \ RFlowSpec and an RHID parameter will create database entries\n         for streams\
    \ in both directions and will allocate resources in\n         both directions\
    \ for them.  By this we mean that an ST agent\n         will reserve resources\
    \ to the next-hop agent for the normal\n         stream and resources back to\
    \ the previous-hop agent for the\n         reverse stream.  This is necessary\
    \ since it is expected that\n         network reservation interfaces will require\
    \ the destination\n         address(es) in order to make reservations, and because\
    \ all ST\n         agents must use the same reservation model.\n         The target\
    \ agent will select a Name for the reverse stream and\n         return it (in\
    \ the RName parameter) and the resulting FlowSpec\n         (in the RFlowSpec\
    \ parameter) of the ACCEPT message.  Each agent\n         that processes the ACCEPT\
    \ will update its partial stream\n         database entry for the reverse stream\
    \ with the Name contained\n         in the RName parameter.  We assume that the\
    \ next higher\n         protocol layer will use the same SAP for both streams.\n\
    \      3.6.4.        NoRecovery Option\n         The NoRecovery option is used\
    \ to indicate that ST agents should\n         not attempt recovery in case of\
    \ network or component failure.\n         If a failure occurs, the origin will\
    \ be notified via a REFUSE\n         message and the target(s) via a DISCONNECT,\
    \ with an appropriate\n         reason code of \"failure\" (i.e., one of DropFailAgt,\n\
    \         DropFailHst, DropFailIfc, DropFailNet, IntfcFailure,\n         NetworkFailure,\
    \ STAgentFailure, FailureRecovery).  They can\n         then decide whether to\
    \ wait for the failed component to be\n         fixed, or drop the target via\
    \ DISCONNECT/REFUSE messages.  The\n         NoRecovery option can only be set\
    \ to one (1) by the origin, and\n         must be the same for the entire stream.\n\
    \      3.6.5.        RevChrg Option\n         The RevChrg option bit in the FlowSpec\
    \ is set to one (1) by the\n         origin to request that the target(s) pay\
    \ any charges associated\n         with the stream (to the target(s));  see Section\
    \ 4.2.2.3 (page\n         83).  If the target is not willing to accept charges,\
    \ the bit\n         should be set to zero (0) by the target before returning the\n\
    \         FlowSpec to the origin in an ACCEPT message.\n         If the FDx option\
    \ is also specified, the target pays charges\n         for both streams.\n   \
    \   3.6.6.        Source Route Option\n         The Source Route Option may be\
    \ used both for diagnostic\n         purposes, and, in those hopefully infrequent\
    \ cases where the\n         standard routing mechanisms do not produce paths that\
    \ satisfy\n         some policy constraint, to allow the origin to prespecify\
    \ the\n         ST agents along the path to the target(s).  The idea is that\n\
    \         the origin can explicitly specify the path to a target, either\n   \
    \      strictly hop-by-hop or more loosely by specification of one or\n      \
    \   more agents through which the path must pass.\n         The option is specified\
    \ by including source routing information\n         in the Target structure. \
    \ A target may contain zero or more\n         SrcRoute options;  when multiple\
    \ options are present, they are\n         processed in the order in which they\
    \ occur.  The parameter code\n         indicates whether the portion of the path\
    \ contained in the\n         parameter is of the strict or loose variety.\n  \
    \       Since portions of a path may pass through portions of an\n         internet\
    \ that does not support ST agents, there are also forms\n         of the SrcRoute\
    \ option that are converted into the\n"
- title: Application  Agent A        Agent 2        Agent 3              Agent B
  contents:
  - 'Application  Agent A        Agent 2        Agent 3              Agent B

    '
- title: 1.  (open B<SR=2,3>)
  contents:
  - '1.  (open B<SR=2,3>)

    '
- title: 2.    V                                              (proc B listening)
  contents:
  - '2.    V                                              (proc B listening)

    '
- title: 3.   (source routed to 2)
  contents:
  - "3.   (source routed to 2)\n      V\n"
- title: '4.   (check resources from A to Agent 2: already allocated,'
  contents:
  - "4.   (check resources from A to Agent 2: already allocated,\n      V   reuse\
    \ control link & HID, no additional resources needed)\n"
- title: 5.    +-> CONNECT B<SR=2,3>->-+-+
  contents:
  - "5.    +-> CONNECT B<SR=2,3>->-+-+\n          <RVLId=23><SVLId=5> | |\n"
- title: 6.        <Ref=50>            V |
  contents:
  - '6.        <Ref=50>            V |

    '
- title: 7.    +<- ACK ----------------+ |
  contents:
  - "7.    +<- ACK ----------------+ |\n          <RVLId=5><SVLId=23>   |\n      \
    \    <Ref=50>              V\n"
- title: 8.                 (source routed to 3)
  contents:
  - "8.                 (source routed to 3)\n                             V\n"
- title: 9.            (reserve resources 2 to 3)
  contents:
  - "9.            (reserve resources 2 to 3)\n                          V\n"
- title: 10.                       +-> CONNECT B<SR=3> ---->+
  contents:
  - "10.                       +-> CONNECT B<SR=3> ---->+\n                      \
    \        <RVLId=0><SVLId=24>  |\n                              <Ref=280><HID=4801>\
    \  V\n"
- title: 11.                       +<- HID-APPROVE <--------+
  contents:
  - "11.                       +<- HID-APPROVE <--------+\n                      \
    \        <RVLId=24><SVLId=33> |\n                              <Ref=280><HID=4801>\
    \  |\n                                                   V\n                 \
    \                          (routing to B)\n                                  \
    \              V\n                                 (reserve resources from 3 to\
    \ B)\n                                             V\n"
- title: 12.                                          +-> CONNECT B ---------->+
  contents:
  - "12.                                          +-> CONNECT B ---------->+\n   \
    \                                              <RVLId=0><SVLId=32>  |\n      \
    \                                           <Ref=330><HID=6000>  V\n"
- title: 13.                                          +<- HID-APPROVE <--------+
  contents:
  - "13.                                          +<- HID-APPROVE <--------+\n   \
    \                                              <RVLId=32><SVLId=45> |\n      \
    \                                           <Ref=330><HID=6000>  V\n"
- title: 14.                                                    (proc B accepts)
  contents:
  - "14.                                                    (proc B accepts)\n   \
    \                                                                   V\n      \
    \          ... perform normal ACCEPT processing ...        <-----+\n         \
    \           Figure 17.  Source Routing Option\n         corresponding IP Source\
    \ Routing options by the ST agent that\n         performs the encapsulation.\n\
    \         The SrcRoute option is usually selected by the origin, but may\n   \
    \      be used by intermediate agents if specified as a result of the\n      \
    \   routing function.\n         For example, in the topology of Figure 2, if A\
    \ wants to add B\n         back into the stream, its routing function might decide\
    \ that\n         the best path is via Agent 3.  Since the data is already being\n\
    \         multicast across the network connected to C, D, and E, the\n       \
    \  route via Agent 3 might cost less than having A replicate the\n         data\
    \ packets and send them across A's network a second time.\n   3.7.       Ancillary\
    \ Functions\n      There are several functions and procedures that are required\
    \ by\n      the ST Protocol.  They are described in subsequent sections.\n   \
    \   3.7.1.        Failure Detection\n         The ST failure detection mechanism\
    \ is based on two assumptions:\n          1  If a neighbor of an ST agent is up,\
    \ and has been up\n             without a disruption, and has not notified the\
    \ ST agent\n             of a problem with streams that pass through both, then\n\
    \             the ST agent can assume that there has not been any\n          \
    \   problem with those streams.\n          2  A network through which an ST agent\
    \ has routed a stream\n             will notify the ST agent if there is a problem\
    \ that\n             affects the stream data packets but does not affect the\n\
    \             control packets.\n         The purpose of the robustness protocol\
    \ defined here is for ST\n         agents to determine that the streams through\
    \ a neighbor have\n         been broken by the failure of the neighbor or the\
    \ intervening\n         network.  This protocol should detect the overwhelming\
    \ majority\n         of failures that can occur.  Once a failure is detected,\n\
    \         recovery procedures are initiated.\n         3.7.1.1.         Network\
    \ Failures\n            In this memo, a network is defined to be the protocol\n\
    \            layer(s) below ST.  This function can be implemented in a\n     \
    \       hardware module separate from the ST agent, or as software\n         \
    \   modules within the ST agent itself, or as a combination of\n            both.\
    \  This specification and the robustness protocol do not\n            differentiate\
    \ between these alternatives.\n            An ST agent can detect network failures\
    \ by two mechanisms;\n            the network can report a failure, or the ST\
    \ agent can\n            discover a failure by itself.  They differ in the amount\
    \ of\n            information that ST agent has available to it in order to\n\
    \            make a recovery decision.  For example, a network may be\n      \
    \      able to report that reserved bandwidth has been lost and the\n        \
    \    reason for the loss and may also report that connectivity to\n          \
    \  the neighboring ST agent remains intact.  In this case, the\n            ST\
    \ agent may request the network to allocate bandwidth anew.\n            On the\
    \ other hand, an ST agent may discover that\n            communication with a\
    \ neighboring ST agent has ceased because\n            it has not received any\
    \ traffic from that neighbor in some\n            time period.  If an ST agent\
    \ detects a failure, it may not\n            be able to determine if the failure\
    \ was in the network while\n            the neighbor remains available, or the\
    \ neighbor has failed\n            while the network remains intact.\n       \
    \  3.7.1.2.         Detecting ST Stream Failures\n            Each ST agent periodically\
    \ sends each neighbor with which it\n            shares a stream a HELLO message.\
    \  A HELLO message is ACKed\n            if the Reference field is non-zero. \
    \ This message exchange\n            is between ST agents, not entities representing\
    \ streams or\n            applications (there is no Name field in a HELLO message).\n\
    \            That is, an ST agent need only send a single HELLO message\n    \
    \        to a neighbor regardless of the number of streams that flow\n       \
    \     between them.  All ST agents (host as well as intermediate)\n          \
    \  must participate in this exchange.  However, only agents\n            that\
    \ share active streams need to participate in this\n            exchange.\n  \
    \          To facilitate processing of HELLO messages, an\n            implementation\
    \ may either create a separate Virtual Link\n            Identifier for each neighbor\
    \ having an active stream, or may\n            use the reserved identifier of\
    \ one (1) for the SVLId field\n            in all its HELLO messages.\n      \
    \      An implementation that wishes to send its HELLO messages via\n        \
    \    a data path instead of the control path may setup a separate\n          \
    \  stream to its neighbor agent for that purpose.  The HELLO\n            message\
    \ would contain a HID of zero, indicating a control\n            message, but\
    \ would be identified to the next lower protocol\n            layer as being part\
    \ of the separate stream.\n            As well as identifying the sender, the\
    \ HELLO message has two\n            fields;  a HelloTimer field that is in units\
    \ of milliseconds\n            modulo the maximum for the field size, and a\n\
    \            Restarted bit specifying that the ST agent has been\n           \
    \ restarted recently.  The HelloTimer must appear to be\n            incremented\
    \ every millisecond whether a HELLO message is\n            sent or not, but it\
    \ is allowable for an ST agent to create a\n            new HelloTimer only when\
    \ it sends a HELLO message.  The\n            HelloTimer wraps around to zero\
    \ after reaching the maximum\n            value.  Whenever an ST agent suffers\
    \ a catastrophic event\n            that may result in it losing ST state information,\
    \ it must\n            reset its HelloTimer to zero and must set the Restarted\
    \ bit\n            for the following HelloTimerHoldDown seconds.\n           \
    \ An ST agent must send HELLO messages to its neighbor with a\n            period\
    \ shorter than the smallest RecoveryTimeout parameter\n            of the FlowSpecs\
    \ of all the active streams that pass between\n            the two agents, regardless\
    \ of direction.  This period must\n            be smaller by a factor, called\
    \ HelloLossFactor, which is at\n            least as large as the greatest number\
    \ of consecutive HELLO\n            messages that could credibly be lost while\
    \ the communication\n            between the two ST agents is still viable.\n\
    \            An ST agent may send simultaneous HELLO messages to all its\n   \
    \         neighbors at the rate necessary to support the smallest\n          \
    \  RecoveryTimeout of any active stream.  Alternately, it may\n            send\
    \ HELLO messages to different neighbors independently at\n            different\
    \ rates corresponding to RecoveryTimeouts of\n            individual streams.\n\
    \            The agent that receives a HELLO message expects to receive\n    \
    \        at least one new HELLO message from a neighbor during the\n         \
    \   RecoveryTimeout of every active stream through that\n            neighbor.\
    \  It can detect duplicate or delayed HELLO messages\n            by saving the\
    \ HelloTimer field of the most recent valid\n            HELLO message from that\
    \ neighbor and comparing it with the\n            HelloTimer field of incoming\
    \ HELLO messages.  It will only\n            accept an incoming HELLO message\
    \ from that neighbor if it\n            has a HelloTimer field that is greater\
    \ than the most recent\n            valid HELLO message by the time elapsed since\
    \ that message\n            was received plus twice the maximum likely delay variance\n\
    \            from that neighbor.  If the ST agent does not receive a\n       \
    \     valid HELLO message within the RecoveryTimeout of a stream,\n          \
    \  it must assume that the neighboring ST agent or the\n            communication\
    \ link between the two has failed and it must\n            initiate stream recovery\
    \ activity.\n            Furthermore, if an ST agent receives a HELLO message\
    \ that\n            contains the Restarted bit set, it must assume that the\n\
    \            sending ST agent has lost its ST state.  If it shares\n         \
    \   streams with that neighbor, it must initiate stream recovery\n           \
    \ activity.  If it does not share streams with that neighbor,\n            it\
    \ should not attempt to create one until that\n            bit is no longer set.\
    \  If an ST agent receives a CONNECT\n            message from a neighbor whose\
    \ Restarted bit is still set, it\n            must respond with ERROR-IN-REQUEST\
    \ with the appropriate\n            reason code (RemoteRestart).  If it receives\
    \ a CONNECT\n            message while its own Restarted bit is set, it must respond\n\
    \            with ERROR-IN-REQUEST with the appropriate reason code\n        \
    \    (RestartLocal).\n         3.7.1.3.         Subset\n            This failure\
    \ detection mechanism subsets by reducing the\n            complexity of the timing\
    \ and decisions.  A subsetted ST\n            agent sends HELLO messages to all\
    \ its ST neighbors\n            regardless of whether there is an active ST stream\
    \ between\n            them or not.  The RecoveryTimeout parameter of the FlowSpec\n\
    \            is ignored and is assumed to be the DefaultRecoveryTimeout.\n   \
    \         Note that this implies that a REFUSE should be sent for all\n      \
    \      CONNECT or CHANGE messages whose RecoveryTimeout is less\n            than\
    \ DefaultRecoveryTimeout.  An ST agent will accept an\n            incoming HELLO\
    \ message if it has a HelloTimer field that is\n            greater than the most\
    \ recent valid HELLO message by\n            DefaultHelloFactor times the time\
    \ elapsed since that message\n            was received.\n      3.7.2.        Failure\
    \ Recovery\n         Streams can fail from various causes;  an ST agent can break,\
    \ a\n         network can break, or an ST agent can intentionally break a\n  \
    \       stream in order to give the stream's resources to a higher\n         precedence\
    \ stream.  We can envision several approaches to\n         recovery of broken\
    \ streams, and we consider the one described\n         here the simplest and therefore\
    \ the most likely to be\n         implemented and work.\n         If an intermediate\
    \ agent fails or a network or part of a\n         network fails, the previous-hop\
    \ agent and the various next-hop\n         agents will discover the fact by the\
    \ failure detection\n         mechanism described in Section 3.7.1 (page 48).\
    \  An ST agent\n         that intentionally breaks a stream obviously knows of\
    \ the\n         event.\n         The recovery of an ST stream is a relatively\
    \ complex and time\n         consuming effort because it is designed in a general\
    \ manner to\n         operate across a large number of networks with diverse\n\
    \         characteristics.  Therefore, it may require information to be\n    \
    \     distributed widely, and may require relatively long timers.  On\n      \
    \   the other hand, since a network is a homogeneous system,\n         failure\
    \ recovery in the network may be a relatively faster and\n         simpler operation.\
    \  Therefore an ST agent that detects a\n         failure should attempt to fix\
    \ the network failure before\n         attempting recovery of the ST stream. \
    \ If the stream that\n         existed between two ST agents before the failure\
    \ cannot be\n         reconstructed by network recovery mechanisms alone, then\
    \ the ST\n         stream recovery mechanism must be invoked.\n         If stream\
    \ recovery is necessary, the different ST agents may\n         need to perform\
    \ different functions, depending on their\n         relation to the failure.\n\
    \         An intermediate agent that breaks the stream intentionally\n       \
    \  sends DISCONNECT messages with the appropriate reason code\n         (StreamPreempted)\
    \ toward the affected targets.  If the\n         NoRecovery option is selected,\
    \ it sends a REFUSE message with\n         the appropriate reason code(StreamPreempted)\
    \ toward the origin.\n         If the NoRecovery option is not selected, then\
    \ this agent\n         attempts recovery of the stream, as described below.\n\
    \         A host agent that is a target of the broken stream or is itself\n  \
    \       the next-hop of the failed component should release resources\n      \
    \   that are allocated to the stream, but should maintain the\n         internal\
    \ state information describing the stream.  It should\n         inform any next\
    \ higher protocol of the failure.  It is\n         appropriate for that protocol\
    \ to expect that the stream will be\n         fixed shortly by some alternate\
    \ path and so maintain, for some\n         time period, whatever information in\
    \ the ST layer, the next\n         higher layer, and the application is necessary\
    \ to reactivate\n         quickly entries for the stream as the alternate path\
    \ develops.\n         The agent should use a timeout to delete all the stream\n\
    \         information in case the stream cannot be fixed in a reasonable\n   \
    \      time.\n         An intermediate agent that is a next-hop of a failure that\
    \ was\n         not due to a preemption should first verify that there was a\n\
    \         failure.  It can do this using STATUS messages to query its\n      \
    \   upstream neighbor.  If it cannot communicate with that\n         neighbor,\
    \ then it should first send a REFUSE message with the\n         appropriate reason\
    \ code of \"failure\" to the neighbor to speed\n         up the failure recovery\
    \ in case the hop is unidirectional,\n         i.e., the neighbor can hear the\
    \ agent but the agent cannot hear\n         the neighbor.  The ST agent detecting\
    \ the failure must then\n         send DISCONNECT messages with the same reason\
    \ code toward the\n         targets.  The intermediate agents process this DISCONNECT\n\
    \         message just like the DISCONNECT that tears down the stream.\n     \
    \    However, a target ST agent that receives a DISCONNECT message\n         with\
    \ the appropriate reason code (StreamPreempted, or\n         \"failure\") will\
    \ maintain the stream state and notify the next\n         higher protocol of the\
    \ failure.  In effect, these DISCONNECT\n         messages tear down the stream\
    \ from the point of the failure to\n         the targets, but inform the targets\
    \ that the stream may be\n         fixed shortly.\n         An ST agent that is\
    \ the previous-hop before the failed\n         component first verifies that there\
    \ was a failure by querying\n         the downstream neighbor using STATUS messages.\
    \  If the neighbor\n         has lost its state but is available, then the ST\
    \ agent may\n         reconstruct the stream if the NoRecovery option is not\n\
    \         selected, as described below.  If it cannot communicate with\n     \
    \    the next-hop, then the agent detecting the failure releases any\n       \
    \  resources that are dedicated exclusively to sending data on the\n         broken\
    \ branch and sends a DISCONNECT message with the\n         appropriate reason\
    \ code (\"failure\") toward the affected\n         targets.  It does so to speed\
    \ up failure recovery in case the\n         communication may be unidirectional\
    \ and this message might be\n         delivered successfully.\n         If the\
    \ NoRecovery option is selected, then the ST agent that\n         detects the\
    \ failure sends a REFUSE message with the appropriate\n         reason code (\"\
    failure\") to the previous-hop.  If it is breaking\n         the stream intentionally,\
    \ it sends a REFUSE message with the\n         appropriate reason code (StreamPreempted)\
    \ to the previous-hop.\n         The TargetList in these messages contains all\
    \ the targets that\n         were reached through the broken branch.  Multiple\
    \ REFUSE\n         messages may be required if the PDU is too long for the MTU\
    \ of\n         the intervening network.  The REFUSE message is propagated all\n\
    \         the way to the origin, which can attempt recovery of the stream\n  \
    \       by sending a new CONNECT to the affected targets.  The new\n         CONNECT\
    \ will be treated by intermediate ST agents as an\n         addition of new targets\
    \ into the established stream.\n         If the NoRecovery option is not selected,\
    \ the ST agent that\n         breaks the stream intentionally or is the previous-hop\
    \ before\n         the failed component can attempt recovery of the stream.  It\n\
    \         does so by issuing a new CONNECT message to the affected\n         targets.\
    \  If the ST agent cannot find new routes to some\n         targets, or if the\
    \ only route to some targets is through the\n         previous-hop, then it sends\
    \ one or more REFUSE messages to the\n         previous-hop with the appropriate\
    \ reason code (\"failure\" or\n         StreamPreempted) specifying the affected\
    \ targets in the\n         TargetList.  The previous-hop can then attempt recovery\
    \ of the\n         stream by issuing a CONNECT to those targets.  If it cannot\n\
    \         find an appropriate route, it will propagate the REFUSE message\n  \
    \       toward the origin.\n         Regardless of which agent attempts recovery\
    \ of a damaged\n         stream, it will issue one or more CONNECT messages to\
    \ the\n         affected targets.  These CONNECT messages are treated by\n   \
    \      intermediate ST agents as additions of new targets into the\n         established\
    \ stream.  The FlowSpecs of the new CONNECT messages\n         should be the same\
    \ as the ones contained in the most recent\n         CONNECT or CHANGE messages\
    \ that the ST agent had sent toward\n         the affected targets when the stream\
    \ was operational.\n         The reconstruction of a broken stream may not proceed\
    \ smoothly.\n         Since there may be some delay while the information concerning\n\
    \         the failure is propagated throughout an internet, routing\n        \
    \ errors may occur for some time after a failure.  As a result,\n         the\
    \ ST agent attempting the recovery may receive REFUSE or\n         ERROR-IN-REQUEST\
    \ messages for the new CONNECTs that are caused\n         by internet routing\
    \ errors.  The ST agent attempting the\n         recovery should be prepared to\
    \ resend CONNECTs before it\n         succeeds in reconstructing the stream. \
    \ If the failure\n         partitions the internet and a new set of routes cannot\
    \ be found\n         to the targets, the REFUSE messages will eventually be\n\
    \         propagated to the origin, which can then inform the application\n  \
    \       so it can decide whether to terminate or to continue to attempt\n    \
    \     recovery of the stream.\n         The new CONNECT may at some point reach\
    \ an ST agent downstream\n         of the failure before the DISCONNECT does.\
    \  In this case, the\n         agent that receives the CONNECT is not yet aware\
    \ that the\n         stream has suffered a failure, and will interpret the new\n\
    \         CONNECT as resulting from a routing failure.  It will respond\n    \
    \     with an ERROR-IN-REQUEST message with the appropriate reason\n         code\
    \ (StreamExists).  Since the timeout that the ST agents\n         immediately\
    \ preceding the failure and immediately following the\n         failure are approximately\
    \ the same, it is very likely that the\n         remnants of the broken stream\
    \ will soon be torn down by a\n         DISCONNECT message with the appropriate\
    \ reason code\n         (\"failure\").  Therefore, the ST agent that receives\
    \ the ERROR-\n         IN-REQUEST message with reason code (StreamExists) should\n\
    \         retransmit the CONNECT message after the ToConnect timeout\n       \
    \  expires.  If this fails again, the request will be retried for\n         NConnect\
    \ times.  Only if it still fails will the ST agent send\n         a REFUSE message\
    \ with the appropriate reason code (RouteLoop)\n         to its previous-hop.\
    \  This message will be propagated back to\n         the ST agent that is attempting\
    \ recovery of the damaged stream.\n         That ST agent can issue a new CONNECT\
    \ message if it so chooses.\n         The REFUSE is matched to a CONNECT message\
    \ created by a\n         recovery operation through the LnkReference field in\
    \ the\n         CONNECT.\n         ST agents that have propagated a CONNECT message\
    \ and have\n         received a REFUSE message should maintain this information\
    \ for\n         some period of time.  If an agent receives a second CONNECT\n\
    \         message for a target that recently resulted in a REFUSE, that\n    \
    \     agent may respond with a REFUSE immediately rather than\n         attempting\
    \ to propagate the CONNECT.  This has the effect of\n         pruning the tree\
    \ that is formed by the propagation of CONNECT\n         messages to a target\
    \ that is not reachable by the routes that\n         are selected first.  The\
    \ tree will pass through any given ST\n         agent only once, and the stream\
    \ setup phase will be completed\n         faster.\n         The time period for\
    \ which the failure information is maintained\n         must be consistent with\
    \ the expected lifetime of that\n         information.  Failures due to lack of\
    \ reachability will remain\n         relevant for time periods large enough to\
    \ allow for network\n         reconfigurations or repairs.  Failures due to routing\
    \ loops\n         will be valid only until the relevant routing information has\n\
    \         propagated, which can be a short time period.  Lack of\n         bandwidth\
    \ resulting from over-allocation will remain valid\n         until streams are\
    \ terminated, which is an unpredictable time,\n         so the time that such\
    \ information is maintained should also be\n         short.\n         If a CONNECT\
    \ message reaches a target, the target should as\n         efficiently as possible\
    \ use the state that it has saved from\n         before the stream failed during\
    \ recovery of the stream.  It\n         will then issue an ACCEPT message toward\
    \ the origin.  The\n         ACCEPT message will be intercepted by the ST agent\
    \ that is\n         attempting recovery of the damaged stream, if not the origin.\n\
    \         If the FlowSpec contained in the ACCEPT specifies the same\n       \
    \  selection of parameters as were in effect before the failure,\n         then\
    \ the ST agent that is attempting recovery will not\n         propagate the ACCEPT.\
    \  If the selections of the parameters are\n         different, then the agent\
    \ that is attempting recovery will send\n         the origin a NOTIFY message\
    \ with the appropriate reason code\n         (FailureRecovery) that contains a\
    \ FlowSpec that specifies the\n         new parameter values.  The origin may\
    \ then have to change its\n         data generation characteristics and the stream's\
    \ parameters\n         with a CHANGE message to use the newly recovered subtree.\n\
    \         3.7.2.1.         Subset\n            Subsets of this mechanism may reduce\
    \ the functionality in\n            the following ways.  A host agent might not\
    \ retain state\n            describing a stream that fails with a DISCONNECT message\n\
    \            with the appropriate reason code (\"failure\" or\n            StreamPreempted).\n\
    \            An agent might force the NoRecovery option always to be set.\n  \
    \          In this case, it will allow the option to be propagated in\n      \
    \      the CONNECT message, but will propagate the REFUSE message\n          \
    \  with the appropriate reason code (\"failure\" or\n            StreamPreempted)\
    \ without attempting recovery of the damaged\n            stream.\n          \
    \  If an ST agent allows stream recovery and attempts recovery\n            of\
    \ a stream, it might choose a FlowSpec to specify exactly\n            the current\
    \ values of the parameters, with no ranges or\n            options.\n      3.7.3.\
    \        A Group of Streams\n         There may be a need to associate related\
    \ streams.  The Group\n         mechanism is simply an association technique that\
    \ allows ST\n         agents to identify the different streams that are to be\n\
    \         associated.  Streams are in the same Group if they have the\n      \
    \   same Group Name in the GroupName field of the (R)Group\n         parameter.\
    \  At this time there are no ST control messages that\n         modify Groups.\
    \  Group Names have the same format as stream\n         Names, and can share the\
    \ same name space.  A stream that is a\n         member of a Group can specify\
    \ one or more (Subgroup Identifier,\n         Relation) tuples.  The Relation\
    \ specifies how the members of\n         the Subgroup of the Group are related.\
    \  The Subgroups\n         Identifiers need only be unique within the Group.\n\
    \         Streams can be associated into Groups to support activities\n      \
    \   that deal with a number of streams simultaneously.  The\n         operation\
    \ of Groups of streams is a matter for further study,\n         and this mechanism\
    \ is provided to support that study.  This\n         mechanism allows streams\
    \ to be identified as belonging to a\n         given Group and Subgroup, but in\
    \ order to have any effect, the\n         behavior that is expected of the Relation\
    \ must be implemented\n         in the ST agents.  Possible applications for this\
    \ mechanism\n         include the following:\n          o  Associating streams\
    \ that are part of a floor-controlled\n             conference.  In this case,\
    \ only one origin can send data\n             through its stream at any given\
    \ time.  Therefore, at any\n             point where more than one stream passes\
    \ through a branch\n             or network, only enough bandwidth for one stream\
    \ needs\n             to be allocated.\n          o  Associating streams that\
    \ cannot exist independently.  An\n             example of this may be the various\
    \ streams that carry\n             the audio, video, and data components of a\
    \ conference,\n             or the various streams that carry data from the\n\
    \             different participants in a conference.  In this case,\n       \
    \      if some ST agent must preempt more than a single stream,\n            \
    \ and it has selected any one of the streams so\n             associated, then\
    \ it should also preempt the rest of the\n             members of that Subgroup\
    \ rather than preempting any\n             other streams.\n          o  Associating\
    \ streams that must not be completed\n             independently.  This example\
    \ is similar to the preceding\n             one, but relates to the stream setup\
    \ phase.  In this\n             example, any single member of a Subgroup of streams\
    \ need\n             not be completed unless the rest are also completed.\n  \
    \           Therefore, if one stream becomes blocked, all the others\n       \
    \      will also be blocked.  In this case, if there are not\n             enough\
    \ resources to support all the conferences that are\n             attempted, some\
    \ number of the conferences will complete\n             and other will be blocked,\
    \ rather than all conferences\n             be partially completed and partially\
    \ blocked.\n         This document assumes that the creation and membership of\
    \ the\n         Group will be managed by the next protocol above ST, with the\n\
    \         assistance of ST.  For example, the next higher protocol\n         would\
    \ request ST to create a unique Group Name and a set of\n         Subgroups with\
    \ specified characteristics.  The next higher\n         protocol would distribute\
    \ this information to the other\n         participants that were to be members\
    \ of the Group.  Each\n         would transfer the Group Name, Subgroups, and\
    \ Relations to\n         the ST layer, which would simply include them in the\
    \ stream\n         state.\n         3.7.3.1.         Group Name Generator\n  \
    \          This facility is provided so that an application or higher\n      \
    \      layer protocol can obtain a unique Group Name from the ST\n           \
    \ layer.  This is a mechanism for the application to request\n            the\
    \ allocation of a Group Name that is independent of the\n            request to\
    \ create a stream.  The Group Name is used by the\n            application or\
    \ higher layer protocol when creating the\n            streams that are to be\
    \ part of a group.  All that is\n            required is a function of the form:\n\
    \               AllocateGroupName()\n                  -> result, GroupName\n\
    \            A corresponding function to release a Group Name is also\n      \
    \      desirable;  its form is:\n               ReleaseGroupName( GroupName )\n\
    \                  -> result\n         3.7.3.2.         Subset\n            Since\
    \ Groups are currently intended to support\n            experimentation, and it\
    \ is not clear how best to use them,\n            it is appropriate for an implementation\
    \ not to support\n            Groups.  At this time, a subsetted ST agent may\
    \ ignore the\n            Group parameter.  It is expected that in the future,\
    \ when\n            Groups transition from being an experimental concept to an\n\
    \            operational one, it may be the case that such subsetting\n      \
    \      will no longer be acceptable.  At that time, a new\n            subsetting\
    \ option may be defined.\n      3.7.4.        HID Negotiation\n         Each data\
    \ packet must carry a value to identify the stream to\n         which it belongs,\
    \ so that forwarding can be performed.\n         Conceptually, this value could\
    \ be the Name of the stream.  A\n         shorthand identifier is desirable for\
    \ two reasons.  First,\n         since each data packet must carry this identifier,\
    \ network\n         bandwidth efficiency suggests that it be as small as\n   \
    \      possible.  This is particularly important for applications\n         that\
    \ use small data packets, and that use low bandwidth\n         networks, such\
    \ as voice across packet radio networks.\n         Second, the operation of mapping\
    \ this identifier into a data\n         object that contains the forwarding information\
    \ must be\n         performed at each intermediate ST agent in the stream.  To\n\
    \         minimize delay and processing overhead, this operation should\n    \
    \     be as efficient as possible.  Most likely, this identifier\n         will\
    \ be used to index into an internal table.  To meet these\n         goals, ST\
    \ has chosen to use a 16-bit hop-by-hop identifier\n         (HID).  It is large\
    \ enough to handle the foreseen number of\n         streams during the expected\
    \ life of the protocol while small\n         enough not to preclude its use as\
    \ a forwarding table index.\n         Note, however, that HID 0 is reserved for\
    \ control messages,\n         and that HIDs 1-3 are also reserved for future use.\n\
    \         When ST makes use of multicast ability in networks that\n         provide\
    \ it, a data packet multicast by an ST agent will be\n         received identically\
    \ by several next-hop ST agents.  In a\n         multicast environment, the HID\
    \ must be selected either by\n         some network-wide mechanism that selects\
    \ unique identifiers,\n         or it must be selected by the sender of the CONNECT\
    \ message.\n         Since we feel any network-wide mechanism is outside the scope\n\
    \         of this protocol, we propose that the previous-hop agent\n         select\
    \ the HID and send it in the CONNECT message (with the\n         HID Field option\
    \ set, see Section 3.6.1 (page 44)) subject to\n         the approval of the next-hop\
    \ agents.  We call this \"HID\n         negotiation\".\n         As an origin\
    \ ST agent is creating a stream or as an\n         intermediate agent is propagating\
    \ a CONNECT message, it must\n         make a routing decision to determine which\
    \ targets will be\n         reached through which next-hop ST agents.  In some\
    \ cases,\n         several next-hops can be reached through a network that\n \
    \        supports multicast delivery.  If so, those next-hops will be\n      \
    \   made members of a multicast group and data packets will be\n         sent\
    \ to the group.  Different CONNECT messages are sent to\n         the several\
    \ next-hops even if the data packets will be sent\n         to the multicast group,\
    \ because the CONNECT messages contain\n         different TargetLists and are\
    \ acknowledged and accepted\n         separately.  However, the HID contained\
    \ by the different\n         CONNECT message must be identical.  The ST agent\
    \ selects a\n         16-bit quantity to be the HID and inserts it into each\n\
    \         CONNECT message that is then sent to the appropriate\n         next-hop.\n\
    \         The next-hop agents that receive the CONNECT messages must\n       \
    \  propagate the CONNECT messages toward the targets, but must\n         also\
    \ look at the HID and decide whether they can approve it.\n         An ST agent\
    \ can only receive data packets with a given HID if\n         they belong to a\
    \ single stream.  If the ST agent already has\n         an established stream\
    \ that uses the proposed HID, this is a\n         HID collision, and the agent\
    \ cannot approve the HID for the\n         new stream.  Otherwise the agent can\
    \ approve the HID.  If it\n         can approve the HID, then it must make note\
    \ of that HID and\n         it must respond with a HID-APPROVE message (unless\
    \ it can\n         immediately respond with an ERROR-IN-REQUEST or a REFUSE).\n\
    \         If it cannot approve the HID then it must respond with a\n         HID-REJECT\
    \ message.\n         An agent that sends a CONNECT message with the H bit set\n\
    \         awaits its acknowledgment message (which could be a\n         HID-ACCEPT,\
    \ HID-REJECT, or an ERROR-IN-REQUEST) from the\n         next-hops independently\
    \ of receiving ACCEPT messages.  If it\n         does not receive an acknowledgment\
    \ within timeout ToConnect,\n         it will resend the CONNECT.  If each next-hop\
    \ agent responds\n         with a HID-ACCEPT, this implies that they have each\
    \ approved\n         of the HID, so it can be used for all subsequent data\n \
    \        packets.  If one or more next-hops respond with an\n         HID-REJECT,\
    \ then the agent that selected the HID must select\n         another HID and send\
    \ it to each next-hop in a set of\n         HID-CHANGE messages.  The next-hop\
    \ agents must respond to\n         (and thus acknowledge) these HID-CHANGE messages\
    \ with either\n         a HID-ACCEPT or a HID-REJECT (or, in the case of an error,\
    \ an\n         ERROR-IN-REQUEST, or a REFUSE if the next-hop agent wants to\n\
    \         abort the HID negotiation process after rejecting NHIDAbort\n      \
    \   proposed HIDs).  If the agent does not receive such a\n         response within\
    \ timeout ToHIDChange, it will resend the\n         HID-CHANGE up to NHIDChange\
    \ times.  If any next-hop agents\n         respond with a REFUSE message that\
    \ specifies all the targets\n         that were included in the corresponding\
    \ CONNECT, then that\n         next-hop is removed from the negotiation.  The\
    \ overall\n         negotiation is complete only when the agent receives a\n \
    \        HID-ACCEPT to the same proposed HID from all the next-hops\n        \
    \ that do not respond with an ERROR-IN-REQUEST or a REFUSE.\n         This negotiation\
    \ may continue an indeterminate length of\n         time.  In fact, the CONNECT\
    \ messages could propagate to the\n         targets and their ACCEPT messages\
    \ may potentially propagate\n         back to the origin before the negotiation\
    \ is complete.  If\n         this were permitted, the origin would not be aware\
    \ of the\n         incomplete negotiation and could begin to send data packets.\n\
    \         Then the agent that is attempting to select a HID would have\n     \
    \    to discard any data rather than sending it to the next-hops\n         since\
    \ it might not have a valid HID to send with the data.\n         To prevent this\
    \ situation, an ACCEPT should not be propagated\n         back to the previous-hop\
    \ until the HID negotiation with the\n         next-hops has been completed.\n\
    \         Although it is possible that the negotiation extends for an\n      \
    \   arbitrary length of time, we consider this to be very\n         unlikely.\
    \  Since the HID is only relevant across a single\n         hop, we can estimate\
    \ the probability that a randomly selected\n         HID will conflict with the\
    \ HID of an established stream.\n         Consider a stream in which the hop from\
    \ an ST agent to ten\n         next-hop agents is through the multicast facility\
    \ of a given\n         network.  Assume also that each of the next-hop agents\n\
    \         participates in 1000 other streams, and that each has been\n       \
    \  created with a different HID.  A randomly selected 16-bit HID\n         will\
    \ have a probability of greater than 85.9% of succeeding\n         on the first\
    \ try, 98.1% of succeeding on the second, and\n         99.8% of succeeding on\
    \ the third.  We therefore suggest that\n         a 16-bit HID space is sufficiently\
    \ large to support ST until\n         better multicast HID selection procedures,\
    \ e.g., HID servers,\n         can be deployed.\n         An obvious way to select\
    \ the HID is for the ST agents to use\n         a random number generator as suggested\
    \ above.  An alternate\n         mechanism is for the intermediate agents to use\
    \ the HID\n         contained in the incoming CONNECT message for all the\n  \
    \       outgoing CONNECT messages, and generate a random number only\n       \
    \  as a second choice.  In this case, the origin ST agent would\n          Agent\
    \ 3                      Agent B\n      1.     +-> CONNECT B -------------->+\n\
    \                 <RVLId=0><SVLId=32>      |\n                 <Ref=315><HID=5990>\
    \      V\n      2.             (Check HID Table, 5990 busy, 6000-11 unused)\n\
    \                                          V\n      3.     +<- HID-REJECT --------------+\n\
    \             |   <RVLId=32><SVLId=45>\n             |   <Ref=315><HID=5990>\n\
    \             V   <FreeHIDs=5990:0000FFF0>\n      4.     +-> HID-CHANGE  ------------>+\n\
    \                 <RVLId=45><SVLId=32>     |\n                 <Ref=320><HID=6000>\
    \      V\n      5.             (Check HID Table, 6000 (still) available)\n   \
    \                                       V\n      6.     +<- HID-APPROVE -------------+\n\
    \                 <RVLId=32><SVLId=45>\n                 <Ref=320><HID=6000>\n\
    \      7.     (Both parties have now agreed to use HID 6000)\n         Figure\
    \ 18.  Typical HID Negotiation (No Multicasting)\n         be responsible for\
    \ generating the HID, and the same HID could\n         be propagated for the entire\
    \ stream.  This approach has the\n         marginal advantage that the HID could\
    \ be created by a higher\n         layer protocol that might have global knowledge\
    \ and could\n         select small, globally unique HIDs for all the streams.\
    \  While\n         this is possible, we leave it for further study.\n       Agent\
    \ 2                           Agent C        Agent D\n   1.    +->+-> CONNECT\
    \ ---------------------------------->+\n            |   <RVLId=0><SVLId=26>  \
    \                      |\n            |   <Ref=250><HID=4824>                \
    \        |\n            V   <Mcast=224.1.18.216,01:00:5E:01:12:d8>     |\n   2.\
    \       +-> CONNECT --------------------+              |\n                <RVLId=0><SVLId=25>\
    \         |              |\n                <Ref=252><HID=4824>         |    \
    \          V\n   3.           <Mcast=224.1.18.216,        V      (Check HID Table)\n\
    \   4.            01:00:5E:01:12:d8> (Check HID Table)  (4824 ok)\n          \
    \                              (4824 busy)  (4800-4809 ok)\n                 \
    \                     (4800-4820 ok)       |\n                               \
    \             V              |\n   5.       +<- HID-REJECT -----------------+\
    \              |\n            |   <RVLId=25><SVLId=54>                       |\n\
    \            |   <Ref=252><HID=4824>                        |\n            V \
    \  <FreeHIDs=4824:FFFFF800>                   V\n   6.    +<-+<- HID-APPROVE -------------------------------+\n\
    \         |      <RVLId=26><SVLId=64>\n         |      <Ref=250><HID=4824>\n \
    \        V      <FreeHIDs=4824:FFC00080>\n         (find common HID 4800)\n  \
    \       V\n   7.    +->+-> HID-CHANGE ------------------------------->+\n    \
    \        |   <RVLId=64><SVLId=26>                       |\n            V   <Ref=253><HID=4800>\
    \                        |\n   8.       +-> HID-CHANGE ---------------->+    \
    \          |\n                <RVLId=54><SVLId=25>        |              V\n \
    \  9.           <Ref=254><HID=4800>         V      (Check HID Table)\n   10. \
    \                             (Check HID Table)   (4800 ok)\n                \
    \                      (4800-4820 ok) (4800-4809 ok)\n                       \
    \                     V              |\n   11.      +<- HID-APPROVE ----------------+\
    \              |\n            |   <RVLId=25><SVLId=54>                       |\n\
    \            |   <Ref=254><HID=4800>                        |\n            V \
    \  <FreeHIDs=4800:7FFFF800>                   V\n   12.   +<-+<- HID-APPROVE -------------------------------+\n\
    \         |      <RVLId=26><SVLId=64>\n         |      <Ref=253><HID=4800>\n \
    \        V      <FreeHIDs=4800:7FC00080>\n   13.   (all parties have now agreed\
    \ to use HID 4800)\n                 Figure 19.  Multicast HID Negotiation\n \
    \     Agent 2                  Agent C        Agent D     Agent 3\n  1.   +---->\
    \ CONNECT B ------------------------------------>+\n              <RVLId=0><SVLId=24>\
    \                            V\n  2.          <Ref=260><HID=4800>            \
    \        (Check HID Table)\n              <Mcast=224.1.18.216,             (4800\
    \ busy, 4801-4810 ok)\n               01:00:5E:01:12:d8>                     \
    \       V\n  3.   +<---- HID-REJECT <-----------------------------------+\n  \
    \     |      <RVLId=24><SVLId=33>\n       |      <Ref=260><HID=4824>\n       V\
    \      <FreeHIDs=4824:7FE00000>\n  4.   (find common HID 4810)\n       V\n  5.\
    \   +->+-> HID-CHANGE ----------------------------------->+\n          |   <RVLId=33><SVLId=24>\
    \                           |\n          V   <Ref=262><HID=4810>             \
    \               |\n  6.      +-> HID-CHANGE-ADD ------------------->+        \
    \   |\n          |   <RVLId=64><SVLId=26>               |           V\n  7.  \
    \    V   <Ref=263><HID=4810>                |   (Check HID Table)\n  8.      +->\
    \ HID-CHANGE-ADD ---->+              |     (4801-4815 ok)\n              <RVLId=54><SVLId=25>|\
    \              V           |\n  9.          <Ref=265><HID=4810> V      (Check\
    \ HID Table)   |\n  10.                     (Check HID Table) (4810 busy)    \
    \  |\n                            (4801-4812 ok) (4801-4807 ok)    |\n       \
    \                           V              |           |\n  11.     +<- HID-APPROVE\
    \ <-------+              |           |\n          |   <RVLId=25><SVLId=54>   \
    \            |           |\n          |   <Ref=265><HID=4810>                |\
    \           |\n          V   <FreeHIDs=4810:7FD8000>            V           |\n\
    \  12.     +<- HID-REJECT <-----------------------+           |\n          | \
    \  <RVLId=26><SVLId=64>                           |\n          |   <Ref=263><HID=4810>\
    \                            |\n          V   <FreeHIDs=4810:7F000000>       \
    \                V\n  13.  +<-+<- HID-APPROVE <----------------------------------+\n\
    \       |      <RVLId=24><SVLId=33>\n       |      <Ref=262><HID=4810>\n     \
    \  V      <FreeHIDs=4810:7FDF0000>\n  14.  +->+-> HID-CHANGE-DELETE ---------------------------->+\n\
    \       |  |   <RVLId=33><SVLId=24>                           |\n       |  V \
    \  <Ref=266><HID=4810>                            |\n  15.  |  +-> HID-CHANGE-DELETE\
    \ ->+                          |\n       |      <RVLId=54><SVLId=25>|        \
    \                  |\n       |      <Ref=268><HID=4810> V                    \
    \      |\n  16.  |  +<- HID-APPROVE --------+                          |\n   \
    \    |      <RVLId=25><SVLId=54>                           |\n       |      <Ref=268><HID=0>\
    \                               V\n  17.  |  +<- HID-APPROVE -----------------------------------+\n\
    \       |      <RVLId=24><SVLId=33>\n       V      <Ref=266><HID=0>\n  18.  (find\
    \ common HID 4801)\n                Figure 20.  Multicast HID Re-Negotiation (part\
    \ 1)\n      Agent 2                  Agent C        Agent D     Agent 3\n  18.\
    \  (find common HID 4801)\n       V\n  19.  +->+-> HID-CHANGE ----------------------------------->+\n\
    \          |   <RVLId=33><SVLId=24>                           |\n          V \
    \  <Ref=270><HID=4801>                            |\n  20.     +-> HID-CHANGE-ADD\
    \ ------------------->+           |\n          |   <RVLId=64><SVLId=26>      \
    \         |           V\n  21.     V   <Ref=273><HID=4801>                |  \
    \ (Check HID Table)\n  22.     +-> HID-CHANGE-ADD ---->+              |     (4801-4815\
    \ ok)\n              <RVLId=54><SVLId=25>|              V           |\n  23. \
    \        <Ref=274><HID=4801> V      (Check HID Table)   |\n  24.             \
    \        (Check HID Table)(4801-4807 ok)    |\n                            (4801-4812\
    \ ok)       |           |\n                                  V              |\
    \           |\n  25.     +<- HID-APPROVE <-------+              |           |\n\
    \          |   <RVLId=25><SVLId=54>               |           |\n          | \
    \  <Ref=274><HID=4801>                |           |\n          V   <FreeHIDs=4801:3FF80000>\
    \           V           |\n  26.     +<- HID-APPROVE <----------------------+\
    \           |\n          |   <RVLId=26><SVLId=64>                           |\n\
    \          |   <Ref=273><HID=4801>                            |\n          V \
    \  <FreeHIDs=4801:3F000000>                       V\n  27.  +<-+<- HID-APPROVE\
    \ <----------------------------------+\n       |      <RVLId=24><SVLId=33>\n \
    \      |      <Ref=270><HID=4801>\n       V      <FreeHIDs=4801:3FFF0000>\n  28.\
    \  (switch data stream to HID 4801, drop 4800)\n       V\n  29.  +->+-> HID-CHANGE-DELETE\
    \ ---------------->+\n          |   <RVLId=64><SVLId=26>               |\n   \
    \       V   <Ref=275><HID=4800>                |\n  30.     +-> HID-CHANGE-DELETE\
    \ ->+              |\n              <RVLId=54><SVLId=25>|              |\n   \
    \           <Ref=277><HID=4800> V              |\n  31.  +<-+<- HID-APPROVE --------+\
    \              |\n       |      <RVLId=25><SVLId=54>               |\n       V\
    \      <Ref=277><HID=0>                   V\n  32.  +<-+<- HID-APPROVE -----------------------+\n\
    \       |      <RVLId=26><SVLId=64>\n       V      <Ref=275><HID=0>\n       (all\
    \ parties have now agreed to use HID 4801)\n                Figure 20.  Multicast\
    \ HID Re-Negotiation (part 2)\n         3.7.4.1.         Subset\n            The\
    \ above mechanism can operate exactly as described even if\n            the ST\
    \ agents do not all use the entire 16 bits of the HID.\n            A low capacity\
    \ ST agent that cannot support a large number\n            of simultaneous streams\
    \ may use only some of the bits in the\n            HID, say for example the low\
    \ order byte.  This may allow\n            this disadvantaged agent to use smaller\
    \ internal data\n            structures at the expense of causing HID collisions\
    \ to occur\n            more often.  However, neither the disadvantaged agent's\n\
    \            previous-hop nor its next-hops need be aware of its\n           \
    \ limitations.  In the HID negotiation, the negotiators still\n            exchange\
    \ a 16-bit quantity.\n      3.7.5.        IP Encapsulation of ST\n         ST\
    \ packets may be encapsulated in IP to allow them to pass\n         through routers\
    \ that don't support the ST Protocol.  Of course,\n         ST resource management\
    \ is precluded over such a path, and\n         packet overhead is increased by\
    \ encapsulation, but if the\n         performance is reasonably predictable this\
    \ may be better than\n         not communicating at all.  IP encapsulation may\
    \ also be\n         required either for enhanced security (see Section 3.7.8 (page\n\
    \         67)) or for user-space implementations of ST in hosts that\n       \
    \  don't allow demultiplexing on the IP Version Number field (see\n         Section\
    \ 4 (page 75)), but do allow access to raw IP packets.\n         IP-encapsulated\
    \ ST packets begin with a normal IP header.  Most\n         fields of the IP header\
    \ should be filled in according to the\n         same rules that apply to any\
    \ other IP packet.  Three fields of\n         special interest are:\n        \
    \  o  Protocol is 5 to indicate an ST packet is enclosed, as\n             opposed\
    \ to TCP or UDP, for example.  The assignment of\n             protocol 5 to ST\
    \ is an arranged coincidence with the\n             assignment of IP Version 5\
    \ to ST [18].\n          o  Destination Address is that of the next-hop ST agent.\n\
    \             This may or may not be the target of the ST stream.\n          \
    \   There may be an intermediate ST agent to which the\n             packet should\
    \ be routed to take advantage of service\n             guarantees on the path\
    \ past that agent.  Such an\n             intermediate agent would not be on a\
    \ directly-connected\n             network (or else IP encapsulation wouldn't\
    \ be needed),\n             so it would probably not be listed in the normal routing\n\
    \             table.  Additional routing mechanisms, not defined here,\n     \
    \        will be required to learn about such agents.\n          o  Type-of-Service\
    \ may be set to an appropriate value for\n             the service being requested\
    \ (usually low delay, high\n         throughput, normal reliability).  This feature\
    \ is not\n         implemented uniformly in the Internet, so its use can't be\n\
    \         precisely defined here.\n         Since there can be no guarantees made\
    \ about performance across\n         a normal IP network, the ST agent that will\
    \ encapsulate should\n         modify the Desired FlowSpec parameters when the\
    \ stream is being\n         established to indicate that performance is not guaranteed.\
    \  In\n         particular, Reliability should be set to the minimum value\n \
    \        (1/256), and suitably large values should be added to the\n         Accumulated\
    \ Mean Delay and Accumulated Delay Variance to\n         reflect the possibility\
    \ that packets may be delayed up to the\n         point of discard when there\
    \ is network congestion.  A suitably\n         large value is 255 seconds, the\
    \ maximum packet lifetime as\n         defined by the IP Time-to-Live field.\n\
    \         IP encapsulation adds little difficulty for the ST agent that\n    \
    \     receives the packet.  The IP header is simply removed, then the\n      \
    \   ST header is processed as usual.\n         The more difficult part is during\
    \ setup, when the ST agent must\n         decide whether or not to encapsulate.\
    \  If the next-hop ST agent\n         is on a remote network and the route to\
    \ that network is through\n         a router that supports IP but not ST, then\
    \ encapsulation is\n         required.  As mentioned in Section 3.8.1 (page 69),\
    \ routing\n         table entries must be expanded to indicate whether the router\n\
    \         supports ST.\n         On forwarding, the (mostly constant) IP Header\
    \ must be inserted\n         and the IP checksum appropriately updated.\n    \
    \     On a directly connected network, though, one might want to\n         encapsulate\
    \ only when sending to a particular destination host\n         that does not allow\
    \ demultiplexing on the IP Version Number\n         field.  This requires the\
    \ routing table to include host-route\n         as well as network-route entries.\
    \  Host-route entries might\n         require static definition if the hosts do\
    \ not participate in\n         the routing protocols.  If packet size is not a\
    \ critical\n         performance factor, one solution is always to encapsulate\
    \ on\n         the directly connected network whenever some hosts require\n  \
    \       encapsulation.  Those that don't require the encapsulation\n         should\
    \ be able to remove it upon reception.\n         3.7.5.1.         IP Multicasting\n\
    \            If an ST agent must use IP encapsulation to reach multiple\n    \
    \        next-hops toward different targets, then either the packet\n        \
    \    must be replicated for transmission to each next-hop, or IP\n           \
    \ multicasting [6] may be used if it is implemented in the\n            next-hop\
    \ ST agents and in the intervening IP routers.\n            This is analogous\
    \ to using network-level service to\n            multicast to several next-hop\
    \ agents on a directly connected\n            network.\n            When the stream\
    \ is established, the collection of next-hop\n            ST agents must be set\
    \ up as an IP multicast group.  It may\n            be necessary for the ST agent\
    \ that wishes to send the IP\n            multicast to allocate a transient multicast\
    \ group address\n            and then tell the next-hop agents to join the group.\
    \  Use of\n            the MulticastAddress parameter (see Section 4.2.2.7 (page\n\
    \            86)) provides one way that the information may be\n            communicated,\
    \ but other techniques are possible.  The\n            multicast group address\
    \ in inserted in the Destination\n            Address field of the IP encapsulation\
    \ when data packets are\n            transmitted.\n            A block of transient\
    \ IP multicast addresses, 224.1.0.0 -\n            224.1.255.255, has been allocated\
    \ for this purpose.  There\n            are 2^16 addresses in this block, allowing\
    \ a direct mapping\n            with 16-bit HIDs, if appropriate.  The mechanisms\
    \ for\n            allocating these addresses are not defined here.\n        \
    \    In addition, two permanent IP multicast addresses have been\n           \
    \ assigned to facilitate experimentation with exchange of\n            routing\
    \ or other information among ST agents.  Those\n            addresses are:\n \
    \              224.0.0.7    All ST routers\n               224.0.0.8    All ST\
    \ hosts\n            An ST router is an ST agent that can pass traffic between\n\
    \            attached networks;  an ST host is an ST agent that is\n         \
    \   connected to a single network or is not permitted to pass\n            traffic\
    \ between attached networks.  Note that the range of\n            these multicasts\
    \ is normally just the attached local\n            network, limited by setting\
    \ the IP time-to-live field to 1\n            (see [6]).\n      3.7.6.       \
    \ Retransmission\n         The ST Control Message Protocol is made reliable through\
    \ use of\n         retransmission when an expected acknowledgment is not received\n\
    \         in a timely manner.  The problem of when to send a\n         retransmission\
    \ has been studied for protocols such as TCP [2]\n         [10] [11].  The problem\
    \ should be simpler for ST since control\n         messages usually only have\
    \ to travel a single hop and they do\n         not contain very much data.  However,\
    \ the algorithms developed\n         for TCP are sufficiently simple that their\
    \ use is recommended\n         for ST as well;  see [2].  An implementor might,\
    \ for example,\n         choose to keep statistics separately for each\n     \
    \    neighboring ST agent, or combined into a single statistic for\n         an\
    \ attached network.\n         Estimating the packet round-trip time (RTT) is a\
    \ key function\n         in reliable transport protocols such as TCP.  Estimation\
    \ must\n         be dynamic, since congestion and resource contention result in\n\
    \         varying delays.  If RTT estimates are too low, packets will be\n   \
    \      retransmitted too frequently, wasting network capacity.  If RTT\n     \
    \    estimates are too high, retransmissions will be delayed\n         reducing\
    \ network throughput when transmission errors occur.\n         Article [11] identifies\
    \ problems that arise when RTT estimates\n         are poor, outlines how RTT\
    \ is used and how retransmission\n         timeouts (RTO) are estimated, and surveys\
    \ several ways that RTT\n         and RTO estimates can be improved.\n       \
    \  Note the HELLO/ACK mechanism described in Section 3.7.1.2 (page\n         49)\
    \ can give an estimate of the RTT and its variance.  These\n         estimates\
    \ are also important for use with the delay and delay\n         variance entries\
    \ in the FlowSpec.\n      3.7.7.        Routing\n         ST requires access to\
    \ routing information in order to select a\n         path from an origin to the\
    \ destination(s).  However, routing is\n         considered to be a separate issue\
    \ and neither the routing\n         algorithm nor its implementation is specified\
    \ here.  ST should\n         operate equally well with any reasonable routing\
    \ algorithm.\n         While ST may be capable of using several types of information\n\
    \         that are not currently available, the minimal information\n        \
    \ required is that provided by IP, namely the ability to find an\n         interface\
    \ and next hop router for a specified IP destination\n         address and Type\
    \ of Service.  Methods to make more information\n         available and to use\
    \ it are left for further study.  For\n         initial ST implementations, any\
    \ routing information that is\n         required but not automatically provided\
    \ will be assumed to be\n         manually configured into the ST agents.\n  \
    \    3.7.8.        Security\n         The ST Protocol by itself does not provide\
    \ security services.\n         It is more vulnerable to misdelivery and denial\
    \ of service than\n         IP since the ST Header only carries a 16-bit HID for\n\
    \         identification purposes.  Any information, such as source and\n    \
    \     destination addresses, which a higher-layer protocol might use\n       \
    \  to detect misdelivery are the responsibility of either the\n         application\
    \ or higher-layer protocol.\n         ST is less prone to traffic analysis than\
    \ IP since the only\n         identifying information contained in the ST Header\
    \ is a hop-\n         by-hop identifier (HID).  However, the use of a HID is also\n\
    \         what makes ST more vulnerable to denial of service since an ST\n   \
    \      agent has no reliable way to detect when bogus traffic is\n         injected\
    \ into, and thus consumes bandwidth from, a user's\n         stream.  Detection\
    \ can be enhanced through use of per-interface\n         forwarding tables and\
    \ verification of local network source and\n         destination addresses.\n\
    \         We envision that applications that require security services\n     \
    \    will use facilities, such as the Secure Digital Networking\n         System\
    \ (SDNS) layer 3 Security Protocol (SP3/D) [19] [20].  In\n         such an environment,\
    \ ST PDUs would first be encapsulated in an\n         IP Header, using IP Protocol\
    \ 5 (ST) as described in Section\n         3.7.5 (page 64).  These IP datagrams\
    \ would then be secured\n         using SP3/D, which results in another IP Protocol\
    \ 5 PDU that\n         can be passed between ST agents.\n         This memo does\
    \ not specify how an application invokes security\n         services.\n   3.8.\
    \       ST Service Interfaces\n      ST has several interfaces to other modules\
    \ in a communication\n      system.  ST provides its services to applications\
    \ or transport-\n      level protocols through its \"upper\" interface (or SAP).\
    \  ST in\n      turn uses the services provided by network layers, management\n\
    \      functions (e.g., address translation and routing), and IP.  The\n     \
    \ interfaces to these modules are described in this section in the\n      form\
    \ of subroutine calls.  Note that this does not mean that an\n      implementation\
    \ must actually be implemented as subroutines, but is\n      instead intended\
    \ to identify the information to be passed between\n      the modules.\n     \
    \ In this style of outlining the module interfaces, the information\n      passed\
    \ into a module is shown as arguments to the subroutine call.\n      Return information\
    \ and/or success/failure indications are listed\n      after the arrow (\"->\"\
    ) that follows the subroutine call.  In\n      several cases, a list of values\
    \ must either be passed to or\n      returned from a module interface.  Examples\
    \ include a set of\n      target addresses, or the mappings from a target list\
    \ to a set of\n      next hop addresses that span the route to the originally\
    \ listed\n      targets.  When such a list is appropriate, the values repeated\
    \ for\n      each list element are bracketed and an asterisk is added to\n   \
    \   indicate that zero, one, or many list elements can be passed\n      across\
    \ the interface (e.g., \"<target>*\" means zero, one, or more\n      targets).\n\
    \      3.8.1.        Access to Routing Information\n         The design of routing\
    \ functions that can support a variety of\n         resource management algorithms\
    \ is difficult.  In this section\n         we suggest a set of preliminary interfaces\
    \ suitable for use in\n         initial experiments.  We expect that these interfaces\
    \ will\n         change as we gain more insight into how routing, resource\n \
    \        allocation, and decision making elements are best divided.\n        \
    \ Routing functions are required to identify the set of potential\n         routes\
    \ to each destination site.  The routing functions should\n         make some\
    \ effort to identify routes that are currently\n         available and that meet\
    \ the resource requirements. However,\n         these properties need not be confirmed\
    \ until the actual\n         resource allocation and connection setup propagation\
    \ are\n         performed.\n         The minimum capability required of the interface\
    \ to routing is\n         to identify the network interface and next hop toward\
    \ a given\n         target.  We expect that the traditional routing table will\
    \ need\n         to be extended to include information that ST requires such as\n\
    \         whether or not a next hop supports ST, and, if so, whether or\n    \
    \     not IP encapsulation (see Section 3.7.5 (page 64)) is required\n       \
    \  to communicate with it.  In particular, host entries will be\n         required\
    \ for hosts that can only support ST through\n         encapsulation because the\
    \ IP software either is not capable of\n         demultiplexing datagrams based\
    \ on the IP Version Number field,\n         or the application interface only\
    \ supports access to raw IP\n         datagrams.  This interface is illustrated\
    \ by the function:\n            FindNextHop( destination, TOS )\n            \
    \   -> result, < interface, next hop, ST-capable,\n                  MustEncapsulate\
    \ >*\n         However, the resource management functions can best tradeoff\n\
    \         among alternative routes when presented with a matrix of all\n     \
    \    potential routes.  The matrix entry corresponding to a\n         destination\
    \ and a next hop would contain the estimated\n         characteristics of the\
    \ corresponding pathway.  Using this\n         representation, the resource management\
    \ functions can quickly\n         determine the next hop sets that cover the entire\
    \ destination\n         list, and compare the various parameters of the tradeoff\n\
    \         between the guarantees that can be promised by each set.  An\n     \
    \    interface that returns a compressed matrix, listing the\n         suitable\
    \ routes by next hop and the destinations reachable\n         through each, is\
    \ illustrated by the function:\n            FindNextHops( < destination >*, TOS\
    \ )\n               -> result, < destination, < interface, next hop,\n       \
    \           ST-capable, MustEncapsulate >* >*\n         We hope that routing protocols\
    \ will be available that propagate\n         additional metrics of bandwidth,\
    \ delay, bit/burst error rate,\n         and whether a router has ST capability.\
    \  However, propagating\n         this information in a timely fashion is still\
    \ a key research\n         issue.\n      3.8.2.        Access to Network Layer\
    \ Resource Reservation\n         The resources required to reach the next-hops\
    \ associated with\n         the chosen routes must be allocated.  These allocations\
    \ will\n         generally be requested and released incrementally.  As the\n\
    \         next-hop elements for the routes are chosen, the network\n         resources\
    \ between the current node and the next-hops must be\n         allocated.  Since\
    \ the resources are not guaranteed to be\n         available -- a network or node\
    \ further down the path might have\n         failed or needed resources might\
    \ have been allocated since the\n         routing decisions where made -- some\
    \ of these allocations may\n         have to be released, another route selected,\
    \ and a new\n         allocation requested.\n         There are four basic interface\
    \ functions needed for the network\n         resource allocator.  The first checks\
    \ to see if the required\n         resources are available, returning the likelihood\
    \ that an\n         ensuing resource allocation will succeed.  A probability of\
    \ 0%\n         indicates the resources are not available or cannot promise to\n\
    \         meet the required guarantees.  Low probabilities indicate that\n   \
    \      most of the resource has been allocated or that there is a lot\n      \
    \   of contention for using the resource.  This call does not\n         actually\
    \ reserve the resources:\n            ResourceProbe( requirements )\n        \
    \       -> likelihood\n         Another call reserves the resources:\n       \
    \     ResourceReserve( requirements )\n               -> result, reservation_id\n\
    \         The third call adjusts the resource guarantees:\n            ResourceAdjust(\
    \ reservation_id, new requirements )\n               -> result\n         The final\
    \ call allows the resources to be released:\n            ResourceRelease( reservation_id\
    \ )\n               -> result\n      3.8.3.        Network Layer Services Utilized\n\
    \         ST requires access to the usual network layer functions to send\n  \
    \       and receive packets and to be informed of network status\n         information.\
    \  In addition, it requires functions to enable and\n         disable reception\
    \ of multicast packets.  Such functions might\n         be defined as:\n     \
    \       JoinLocalGroup( network level group-address )\n               -> result,\
    \ multicast_id\n            LeaveLocalGroup( network level group-address )\n \
    \              -> result\n            RecvNet( SAP )\n               -> result,\
    \ src, dst, len, BufPTR )\n            SendNet( src, dst, SAP, len, BufPTR )\n\
    \               -> result\n            GetNotification( SAP )\n              \
    \ -> result, infop\n      3.8.4.        IP Services Utilized\n         Since ST\
    \ packets might be sent or received using IP\n         encapsulation, IP level\
    \ routines to join and leave multicast\n         groups are required in addition\
    \ to the usual services defined\n         in the IP specification (see the IP\
    \ specification [2] [15] and\n         the IP multicast specification [6] for\
    \ details).\n            JoinHostGroup( IP level group-address, interface )\n\
    \               -> result, multicast_id\n            LeaveHostGroup( IP level\
    \ group-address, interface )\n               -> result\n            GET_SRCADDR(\
    \ remote IP addr, TOS )\n               -> local IP address\n            SEND(\
    \ src, dst, prot, TOS, TTL, BufPTR, len, Id, DF,\n                  opt )\n  \
    \             -> result\n            RECV( BufPTR, prot )\n               -> result,\
    \ src, dst, SpecDest, TOS, len, opt\n            GET_MAXSIZES( local, remote,\
    \ TOS )\n               -> MMS_R, MMS_S\n            ADVISE_DELIVPROB( problem,\
    \ local, remote, TOS )\n               -> result\n            SEND_ICMP( src,\
    \ dst, TOS, TTL, BufPTR, len, Id, DF, opt )\n               -> result\n      \
    \      RECV_ICMP( BufPTR )\n               -> result, src, dst, len, opt\n   \
    \   3.8.5.        ST Layer Services Provided\n         Interface to the ST layer\
    \ services may be modeled using a set\n         of subroutine calls (but need\
    \ not be implemented as such).\n         When the protocol is implemented as part\
    \ of an operating\n         system, these subroutines may be used directly by\
    \ a higher\n         level protocol processing layer.\n         These subroutines\
    \ might also be provided through system service\n         calls to provide a raw\
    \ interface for use by an application.\n         Often, this will require further\
    \ adaptation to conform with the\n         idiom of the particular operating system.\
    \  For example, 4.3 BSD\n         UNIX (TM) provides sockets, ioctls and signals\
    \ for network\n         programming.\n         open( connect/listen, SAPBytes,\
    \ local SAP, local host,\n               account, authentication info, < foreign\
    \ host,\n               SAPBytes, foreign SAP, options >*, flow spec,\n      \
    \         precedence, group name, optional parameters )\n             -> result,\
    \ id, stream name, < foreign host,\n               foreign SAPBytes, foreign SAP,\
    \ result, flow spec,\n               rname, optional parameters >*\n         Note\
    \ that an open by a target in \"listen mode\" may cause ST to\n         create\
    \ a state block for the stream to facilitate rendezvous.\n         add( id, SAPBytes,\
    \ local SAP, local host, < foreign host,\n              SAPBytes, foreign SAP,\
    \ options >*, flow spec,\n              precedence, group name, optional parameters\
    \ )\n            -> result, < foreign host, foreign SAPBytes,\n              \
    \ foreign SAP, result,\n               flow spec, rname, optional parameters >*\n\
    \         send( id, buffer address, byte count, priority )\n            -> result,\
    \ next send time, burst send time\n         recv( id, buffer address, max byte\
    \ count )\n            -> result, byte count\n         recvsignal( id )\n    \
    \        -> result, signal, info\n         receivecontrol( id )\n            ->\
    \ result, id, stream name, < foreign host,\n               foreign SAPBytes, foreign\
    \ SAP, result, flow spec,\n               rname, optional parameters >*\n    \
    \     sendcontrol( id, flow spec, precedence, options,\n               < foreign\
    \ host, SAPBytes, foreign SAP, options >*)\n            -> result, < foreign host,\
    \ foreign SAPBytes,\n               foreign SAP, result, flow spec, rname,\n \
    \              optional parameters >*\n         change( id, flow spec, precedence,\
    \ options,\n               < foreign host, SAPBytes, foreign SAP, options >*)\n\
    \            -> result, < foreign host, foreign SAPBytes,\n               foreign\
    \ SAP, result, flow spec, rname,\n               optional parameters >*\n    \
    \     close( id, < foreign host, SAPBytes, foreign SAP >*,\n               optional\
    \ parameters )\n            -> result\n         status( id/stream name/group name\
    \ )\n            -> result, account, group name, protocol,\n               < stream\
    \ name, < foreign host, SAPbytes,\n               foreign SAP, state, options,\
    \ flow spec,\n               routing info, rname >*, precedence, options >*\n\
    \         creategroup( members* )\n            -> result, group name\n       \
    \  deletegroup( group name, members* )\n            -> result\n              \
    \        [This page intentionally left blank.]\n"
- title: 4.      ST Protocol Data Unit Descriptions
  contents:
  - "4.      ST Protocol Data Unit Descriptions\n   The ST PDUs sent between ST agents\
    \ consist of an ST Header\n   ncapsulating either a higher layer PDU or an ST\
    \ Control Message.\n   Since ST operates as an extension of IP, the packet arrives\
    \ at the\n   same network service access point that IP uses to receive IP\n  \
    \ datagrams, e.g., ST would use the same ethertype (0x800) as does IP.\n   The\
    \ two types of packets are distinguished by the IP Version Number\n   field (the\
    \ first four bits of the packet);  IP currently uses a value\n   of 4, while ST\
    \ has been assigned the value 5 [18].  There is no\n   requirement for compatibility\
    \ between IP and ST packet headers beyond\n   the first four bits.\n   The ST\
    \ Header also includes an ST Version Number, a total length\n   field, a header\
    \ checksum, and a HID, as shown in Figure 21.  See\n   Appendix 1 (page 147) for\
    \ an explanation of the notation.\n      ST is the IP Version Number assigned\
    \ to identify ST packets.  The\n      value for ST is 5.\n      Ver is the ST\
    \ Version Number.  This document defines ST Version 2.\n      Pri is the priority\
    \ of the packet.  It is used in data packets to\n      indicate those packets\
    \ to drop if a stream is exceeding its\n      allocation.  Zero is the lowest\
    \ priority and 7 the highest.\n      T (bit 11) is used to indicate that a Timestamp\
    \ is present\n      following the ST Header but before any next higher layer protocol\n\
    \      data.  The Timestamp is not permitted on ST Control Messages\n      (which\
    \ may use the OriginTimestamp option).\n      Bits 12 through 15 are spares and\
    \ should be set to 0.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  ST=5 | Ver=2 | Pri |T| Bits  |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              HID              |        HeaderChecksum         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \                                                             |\n   +-       \
    \                   Timestamp                          -+\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 21.  ST Header\n      TotalBytes is the length,\
    \ in bytes, of the entire ST packet, it\n      includes the ST Header and optional\
    \ Timestamp but does not include\n      any local network headers or trailers.\
    \  In general, all length\n      fields in the ST Protocol are in units of bytes.\n\
    \      HID is the 16-bit hop-by-hop stream identifier.  It is an\n      abbreviation\
    \ for the Name of the stream and is used both to reduce\n      the packet header\
    \ length and, by the receiver of the data packet,\n      to make the forwarding\
    \ function more efficient.  Control Messages\n      have a HID value of zero.\
    \  HIDs are negotiated by the next-hop and\n      previous-hop agents to make\
    \ the abbreviation unique.  It is used\n      here in the ST Header and in various\
    \ Control Messages.  HID values\n      1-3 are reserved for future use.\n    \
    \  HeaderChecksum covers only the ST Header and Timestamp, if\n      present.\
    \  The ST Protocol uses 16-bit checksums here in the ST\n      Header and in each\
    \ Control Message.  The standard Internet\n      checksum algorithm is used: \
    \ \"The checksum field is the 16-bit\n      one's complement of the one's complement\
    \ sum of all 16-bit words\n      in the header.  For purposes of computing the\
    \ checksum, the value\n      of the checksum field is zero.\"  See [1] [12] [15]\
    \ for suggestions\n      for efficient checksum algorithms.\n      Timestamp is\
    \ an optional timestamp inserted into data packets by\n      the origin.  It is\
    \ only present when the T bit, described above,\n      is set (1).  Its use is\
    \ negotiated at connection setup time;  see\n      Sections 4.2.3.5 (page 108)\
    \ and 4.2.3.1 (page 100).  The Timestamp\n      has the NTP format;  see [13].\n\
    \   4.1.       Data Packets\n      ST packets whose HID is not zero to three are\
    \ user data packets.\n      Their interpretation is a matter for the higher layer\
    \ protocols\n      and consequently is not specified here.  The data packets are\
    \ not\n      protected by an ST checksum and will be delivered to the higher\n\
    \      layer protocol even with errors.\n      ST agents will not pass data packets\
    \ over a new hop whose setup is\n      not complete, i.e., a HID must have been\
    \ negotiated and either an\n      ACCEPT or REFUSE has been received for all targets\
    \ specified in\n      the CONNECT.\n   4.2.       ST Control Message Protocol\
    \ Descriptions\n      ST Control Messages are between a previous-hop agent and\
    \ its\n      next-hop agent(s) using a HID of zero.  The control protocol\n  \
    \    follows a request-response model with all requests expecting\n      responses.\
    \  Retransmission after timeout (see Section 3.7.6 (page\n      66)) is used to\
    \ allow for lost or ignored messages.  Control\n      messages do not extend across\
    \ packet boundaries; if a control\n      message is too large for the MTU of a\
    \ hop, its information\n      (usually a TargetList) is partitioned and a control\
    \ message per\n      partition is sent.  All control messages have the following\n\
    \      format:\n         OpCode identifies the type of control message.  Each\
    \ is\n         described in detail in following sections.\n         Options is\
    \ used to convey OpCode-specific variations for a\n         control message.\n\
    \         TotalBytes is the length of the control message, in bytes,\n       \
    \  including all OpCode specific fields and optional parameters.\n         The\
    \ value is always divisible by four.\n         RVLId is used to convey the Virtual\
    \ Link Identifier of the\n         receiver of the control message, when known,\
    \ or zero in the\n         case of an initial CONNECT or diagnostic message. \
    \ The RVLId is\n         intended to permit efficient dispatch to the portion\
    \ of a\n         stream's state machine containing information about a specific\n\
    \         operation in progress over the link.  RVLId values 1-3 are\n       \
    \  reserved; see Sections 3 (page 17) and 3.7.1.2 (page 49).\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     OpCode    |    Options    |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \                             -+\n   :                      OpCode Specific Data\
    \                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 22.  ST Control Message Format\n         SVLId is used\
    \ to convey the Virtual Link Identifier of the\n         sender of the control\
    \ message.  Except for ERROR-IN-REQUEST and\n         diagnostic messages, it\
    \ must never be zero.  SVLId values 1-3\n         are reserved; see Sections 3\
    \ (page 17) and 3.7.1.2 (page 49).\n         Reference is a transaction number.\
    \  Each sender of a request\n         control message assigns a Reference number\
    \ to the message that\n         is unique with respect to the stream.  The Reference\
    \ number is\n         used by the receiver to detect and discard duplicates. \
    \ Each\n         acknowledgment carries the Reference number of the request\n\
    \         being acknowledged.  Reference zero is never used, and\n         Reference\
    \ numbers are assumed to be monotonically increasing\n         with wraparound\
    \ so that the older-than and more-recent-than\n         relations are well defined.\n\
    \         LnkReference contains the Reference field of the request\n         control\
    \ message that caused this request control message to be\n         created.  It\
    \ is used in situations where a single request leads\n         to multiple \"\
    responses\".  Examples are CONNECT and CHANGE\n         messages that must be\
    \ acknowledged hop-by-hop and will also\n         lead to an ACCEPT or REFUSE\
    \ from each target in the TargetList.\n         SenderIPAddress is the 32-bit\
    \ IP address of the network\n         interface that the ST agent used to send\
    \ the control message.\n         This value changes each time the packet is forwarded\
    \ by an ST\n         agent (hop-by-hop).\n         Checksum is the checksum of\
    \ the control message.  Because the\n         control messages are sent in packets\
    \ that may be delivered with\n         bits in error, each control message must\
    \ be checked before it\n         is acted upon;  see Section 4 (page 76).\n  \
    \       OpCode Specific Data contains any additional information that\n      \
    \   is associated with the control message.  It depends on the\n         specific\
    \ control message and is explained further below.  In\n         some response\
    \ control messages, fields of zero are included to\n         allow the format\
    \ to match that of the corresponding request\n         message.  The OpCode Specific\
    \ Data may also contain any of the\n         optional Parameters defined in Section\
    \ 4.2.2 (page 80).\n      4.2.1.        ST Control Messages\n         The CONNECT\
    \ and CHANGE messages are used to establish or modify\n         branches in the\
    \ stream.  They propagate in the direction from\n         the origin toward the\
    \ targets.  They are end-to-end messages\n         created by the origin.  They\
    \ propagate all the way to the\n         targets, and require ERROR-IN-REQUEST,\
    \ ACK, HID-REJECT, HID-\n         APPROVE, ACCEPT, or REFUSE messages in response.\
    \  The CONNECT\n         message is the stream setup message.  The CHANGE message\
    \ is\n         used to change the characteristics of an established stream.\n\
    \         The CONNECT message is also used to add one or more targets to\n   \
    \      an existing stream and during recovery of a broken stream.\n         Both\
    \ messages have a TargetList parameter and are processed\n         similarly.\n\
    \         The DISCONNECT message is used to tear down streams or parts of\n  \
    \       streams.  It propagates in the direction from the origin toward\n    \
    \     the targets.  It is either used as an end-to-end message\n         generated\
    \ by the origin that is used to completely tear down a\n         stream, or is\
    \ generated by an intermediate ST agent that\n         preempts a stream or detects\
    \ the failure of its previous-hop\n         agent or network in the stream.  In\
    \ the latter case, it is used\n         to tear down the part of the stream from\
    \ the failure to the\n         targets, thus the message propagates all the way\
    \ to the\n         targets.\n         The REFUSE message is sent by a target to\
    \ refuse to join or\n         remove itself from a stream;  in these cases, it\
    \ is an end-to-\n         end message.  An intermediate ST agent issues a REFUSE\
    \ if it\n         cannot find a route to a target, can only find a route to a\n\
    \         target through the previous-hop, preempts a stream, or detects\n   \
    \      a failure in a next-hop ST agent or network.  In all cases a\n        \
    \ REFUSE propagates in the direction toward the origin.\n         The ACCEPT message\
    \ is an end-to-end message generated by a\n         target and is used to signify\
    \ the successful completion of the\n         setup of a stream or part of a stream,\
    \ or the change of the\n         FlowSpec.  There are no other messages that are\
    \ similar to it.\n         The following sections contain descriptions of common\
    \ fields\n         and parameters, followed by descriptions of the individual\n\
    \         control messages, both listed in alphabetical order.  A brief\n    \
    \     description of the use of the control message is given.  The\n         packet\
    \ format is shown graphically.\n      4.2.2.        Common SCMP Elements\n   \
    \      Several fields and parameters (referred to generically as\n         \"\
    elements\") are common to two or more PDUs.  They are described\n         in detail\
    \ here instead of repeating their description several\n         times.  In many\
    \ cases, the presence of a parameter is optional.\n         To permit the parameters\
    \ to be easily defined and parsed, each\n         is identified with a PCode byte\
    \ that is followed by a PBytes\n         byte indicating the length of the parameter\
    \ in bytes (including\n         the PCode, PByte, and any padding bytes).  If\
    \ the length of the\n         information is not a multiple of 4 bytes, the parameter\
    \ is\n         padded with one to three zero (0) bytes.  PBytes is thus always\n\
    \         a multiple of four.  Parameters can be present in any order.\n     \
    \    4.2.2.1.         DetectorIPAddress\n            Several control messages\
    \ contain the DetectorIPAddress\n            field.  It is used to identify the\
    \ agent that caused the\n            first instance of the message to be generated,\
    \ i.e., before\n            it was propagated.  It is copied from the received\
    \ message\n            into the copy of the message that is to be propagated to\
    \ a\n            previous-hop or next-hop.  It use is primarily diagnostic.\n\
    \         4.2.2.2.         ErroredPDU\n            The ErroredPDU parameter (PCode\
    \ = 1) is used for diagnostic\n            purposes to encapsulate a received\
    \ ST PDU that contained an\n            error.  It may be included in the ERROR-IN-REQUEST,\
    \ ERROR-\n            IN-RESPONSE, or REFUSE messages.  It use is primarily\n\
    \            diagnostic.\n               PDUBytes indicates how many bytes of\
    \ the PDUInError are\n               actually present.\n               ErrorOffset\
    \ contains the number of bytes into the errored\n               PDU to the field\
    \ containing the error.  At least as much\n               of the PDU in error\
    \ must be included to\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 1   |     PBytes    |   PDUBytes    |  ErrorOffset  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                          PDUInError           :    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                          Figure 23.  ErroredPDU\n               include the\
    \ field or parameter identified by ErrorOffset;\n               an ErrorOffset\
    \ of zero would imply a problem with the IP\n               Version Number or\
    \ ST Version Number fields.\n               PDUInError is the PDU in error, beginning\
    \ with the ST\n               Header.\n         4.2.2.3.         FlowSpec & RFlowSpec\n\
    \            The FlowSpec is used to convey stream service requirements\n    \
    \        end-to-end.  We expect that other versions of FlowSpec will\n       \
    \     be needed in the future, which may or may not be subsets or\n          \
    \  supersets of the version described here.  PBytes will allow\n            new\
    \ constraints to be added to the end without having to\n            simultaneously\
    \ update all implementations in the field.\n            Implementations are expected\
    \ to be able to process in a\n            graceful manner a Version 4 (or higher)\
    \ structure that has\n            more elements than shown here.\n           \
    \ The FlowSpec parameter (PCode = 2) is used in several\n            messages\
    \ to convey the FlowSpec.\n    0                   1                   2     \
    \              3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     PCode     |     PBytes    |  Version = 3  |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   DutyFactor  |   ErrorRate   |   Precedence  |  Reliability  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Tradeoffs           |        RecoveryTimeout        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          LimitOnCost          |         LimitOnDelay          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        LimitOnPDUBytes        |        LimitOnPDURate         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         MinBytesXRate                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         AccdMeanDelay                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       AccdDelayVariance                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          DesPDUBytes          |          DesPDURate           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 24.  FlowSpec & RFlowSpec\n            The RFlowSpec\
    \ parameter (PCode = 12) is used in conjunction\n            with the FDx option\
    \ to convey the FlowSpec that is to be\n            used in the reverse direction.\n\
    \               Version identifies the version of the FlowSpec.  Version\n   \
    \            3 is defined here.\n               DutyFactor is the estimated proportion\
    \ of the time that\n               the requested bandwidth will actually be in\
    \ use.  Zero is\n               taken to represent 256 and signify a duty factor\
    \ of 1.\n               Other values are to be divided by 256 to yield the duty\n\
    \               factor.\n               ErrorRate expresses the error rate as\
    \ the negative\n               exponent of 10 in the error rate.  One (1) represents\
    \ a\n               bit error rate of 0.1 and 10 represents 0.0000000001.\n  \
    \             Precedence is the precedence of the connection being\n         \
    \      established.  Zero represents the lowest precedence.\n               Note\
    \ that non-zero values of this parameter should be\n               subject to\
    \ authentication and authorization checks, which\n               are not specified\
    \ here.  In general, the distinction\n               between precedence and priority\
    \ is that precedence\n               specifies streams that are permitted to take\
    \ previously\n               committed resources from another stream, while priority\n\
    \               identifies those PDUs that a stream is most willing to\n     \
    \          have dropped when the stream exceeds its guaranteed\n             \
    \  limits.\n               Reliability is modified by each intervening ST agent\
    \ as a\n               measure of the probability that a given offered data\n\
    \               packet will be forwarded and not dropped.  Zero is taken\n   \
    \            to represent 256 and signify a probability of 1.  Other\n       \
    \        values are to be divided by 256 to yield the probability.\n         \
    \      Tradeoffs is incompletely defined at this time.  Bits\n               currently\
    \ specified are as follows:\n                  The most significant bit in the\
    \ field, bit 0 in the\n                  Figure 24, when one (1) means that each\
    \ ST agent must\n                  \"implement\" all constraints in the FlowSpec\
    \ even if\n                  they are not shown in the figure, e.g., when the\n\
    \                  FlowSpec has been extended.  When zero (0), unknown\n     \
    \             constraints may be ignored.\n                  The second most significant\
    \ bit in the field, bit 1,\n                  when one (1) means that one or more\
    \ constraints are\n                  unknown and have been ignored.  When zero\
    \ (0), all\n                  constraints are known and have been processed.\n\
    \                  The third most significant bit in the field, bit 2, is\n  \
    \                used for RevChrg;  see Section 3.6.5 (page 46).\n           \
    \       Other bits are currently unspecified, and should be\n                \
    \  set to zero (0) by the origin ST agent and not changed\n                  by\
    \ other agents unless those agents know their\n                  meaning.\n  \
    \             RecoveryTimeout specifies the nominal number of\n              \
    \ milliseconds that the application is willing to wait for\n               a failed\
    \ system component to be detected and any\n               corrective action to\
    \ be taken.\n               LimitOnCost specifies the maximum cost that the origin\
    \ is\n               willing to expend.  A value of zero indicates that the\n\
    \               application is not willing to incur any direct charges\n     \
    \          for the resources used by the stream.  The meaning of\n           \
    \    non-zero values is left for further study.\n               LimitOnDelay specifies\
    \ the maximum end-to-end delay, in\n               milliseconds, that can be tolerated\
    \ by the origin.\n               LimitOnPDUBytes is the smallest packet size,\
    \ in terms of\n               ST-user data bytes, that can be tolerated by the\
    \ origin.\n               LimitOnPDURate is the lowest packet rate that can be\n\
    \               tolerated by the origin, expressed as tenths of a packet\n   \
    \            per second.\n               MinBytesXRate is the minimum bandwidth\
    \ that can be\n               tolerated by the origin, expressed as a product\
    \ of bytes\n               and tenths of a packet per second.\n              \
    \ AccdMeanDelay is modified by each intervening ST agent.\n               This\
    \ provides a means of reporting the total expected\n               delay, in milliseconds,\
    \ for a data packet.  Note that it\n               is implicitly assumed that\
    \ the requested mean delay is\n               zero and there is no limit on the\
    \ mean delay, so there\n               are no parameters to specify these explicitly.\n\
    \               AccdDelayVariance is also modified by each intervening ST\n  \
    \             agent as a measure, in milliseconds squared, of the\n          \
    \     packet dispersion.  This quantity can be used by the\n               target\
    \ or origin in determining whether the resulting\n               stream has an\
    \ adequate quality of service to support the\n               application.  Note\
    \ that it is implicitly assumed that the\n               requested delay variance\
    \ is zero and there is no limit on\n               the delay variance, so there\
    \ are no parameters to specify\n               these explicitly.\n           \
    \    DesPDUBytes is the desired PDU size in bytes.  This is\n               not\
    \ necessarily the same as the minimum necessary PDU\n               size.  This\
    \ value may be made smaller by intervening ST\n               agents so long as\
    \ it is not made smaller than\n               LimitOnPDUBytes.  The *PDUBytes\
    \ limits measure the size\n               of the PDUs of next-higher protocol\
    \ layer, i.e., the user\n               information contained in a data packet.\
    \  An ST agent must\n               account for both the ST Header (including\
    \ possible IP\n               encapsulation) and any local network headers and\
    \ trailers\n               when comparing a network's MTU with *PDUBytes.  In\
    \ an\n               ACCEPT message, the value of this field will be no larger\n\
    \               than the MTU of the path to the specified target.\n          \
    \     DesPDURate is the requested PDU rate, expressed as tenths\n            \
    \   of a packet per second.  This value may be made smaller\n               by\
    \ intervening ST agents so long as it is not made\n               smaller than\
    \ LimitOnPDURate.\n               It is expected that the next parameter to be\
    \ added to the\n               FlowSpec will be a Burst Descriptor.  This parameter\
    \ will\n               describe the burstiness of the offered traffic.  For\n\
    \               example, this may include the simple average rate, peak\n    \
    \           rate and variance values, or more complete descriptions\n        \
    \       that characterize the distribution of expected burst\n               rates\
    \ and their expected duration.  The nature of the\n               algorithms that\
    \ deal with the traffic's burstiness and\n               the information that\
    \ needs to be described by this\n               parameter will be subjects of\
    \ further experimentation.\n               It is expected that a new FlowSpec\
    \ with Version = 4 will\n               be defined that looks like Version 3 but\
    \ has a Burst\n               Descriptor parameter appended to the end.\n    \
    \     4.2.2.4.         FreeHIDs\n            The FreeHIDs parameter (PCode = 3)\
    \ is used to communicate to\n            the previous-hop suggestions for a HID.\
    \  It consists of\n            BaseHID and FreeHIDBitMask fields.  Experiments\
    \ will\n            determine how long the mask should be for practical use of\n\
    \            this parameter.  The parameter (if implemented) should be\n     \
    \       included in all HID-REJECTs, and in HID-APPROVEs that are\n          \
    \  linked to a multicast CONNECT, e.g., one containing the\n            MulticastAddress\
    \ parameter.\n               BaseHID was the suggested value in a HID-CHANGE or\n\
    \               CONNECT.  BaseHID is chosen to be the suggested HID value\n  \
    \             to insure that the masks from multiple FreeHIDs\n              \
    \ parameters will overlap.\n               FreeHIDBitMask identifies available\
    \ HID values as\n               follows.  Bit 0 in the FreeHIDBitMask corresponds\
    \ to a\n               HID with a value equal to BaseHID with the 5 least\n  \
    \             significant bits set to zero, bit 1 corresponds to that\n      \
    \         value + 1, etc.  This alignment of the mask on a 32-bit\n          \
    \     boundary is used so that masks from several FreeHIDs\n               parameters\
    \ might more easily be combined using a bit-wise\n               AND function\
    \ to find a free HID.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 3   |     4+4*N     |            BaseHID            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                        FreeHIDBitMask                         :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                          Figure 25.  FreeHIDs\n         4.2.2.5.         Group\
    \ & RGroup\n            The Group parameter (PCode = 4) is an optional argument\n\
    \            used only for the creation of a stream.  This parameter\n       \
    \     contains a GroupName; the GroupName may be the same as the\n           \
    \ Name of one of the group's streams.  In addition, there\n            may be\
    \ some number of <SubGroupId, Relation> tuples that\n            describe the\
    \ meaning of the grouping and the relation\n            between the members of\
    \ the group.  The forms of grouping\n            are for further study.\n    \
    \        The RGroup parameter (PCode = 13) is an optional argument\n         \
    \   used only for the creation of a stream in the reverse\n            direction\
    \ that is a member of a Group;  see the FDx\n            option, Section 3.6.3\
    \ (page 45).  This parameter has the\n            same format as the Group parameter.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     PCode     |    12+4*N     |                               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \                             -+\n   !                           GroupName   \
    \                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           SubGroupId          |            Relation           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :              ...              :              ...              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           SubGroupId          |            Relation           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 26.  Group & RGroup\n            A GroupName has\
    \ the same format as a Name;  see Figure 29.\n         4.2.2.6.         HID &\
    \ RHID\n            The HID parameter (PCode = 5) is used in the NOTIFY message\n\
    \            when the notification is related to a HID, and possibly in\n    \
    \        the STATUS-RESPONSE message to convey additional HIDs that\n        \
    \    are valid for a stream when there are more than one.  It\n            consists\
    \ of the PCode and PBytes bytes prepended to a HID;\n            HIDs were described\
    \ in Section 4 (page 76).\n            The RHID parameter (PCode = 14) is used\
    \ in conjunction with\n            the FDx option to convey the HID that is to\
    \ be used in the\n            reverse direction.  It consists of the PCode and\
    \ PBytes\n            bytes prepended to a HID.\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     PCode     |       4       |              HID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 27.  HID & RHID\n         4.2.2.7.         MulticastAddress\n\
    \            The MulticastAddress parameter (PCode = 6) is an optional\n     \
    \       parameter that is used, when setting up a network level\n            multicast\
    \ group, to communicate an IP and/or local network\n            multicast address\
    \ to the next-hop agents that should become\n            members of the group.\n\
    \               LocalNetBytes is the length of the Local Net Multicast\n     \
    \          Address.\n    0                   1                   2           \
    \        3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |   PCode = 6   |    PBytes     | LocalNetBytes |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     IP Multicast Address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                  Local Net Multicast Address  :    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 28.  MulticastAddress\n               IP Multicast\
    \ Address is described in [6].  This field is\n               zero (0) if no IP\
    \ multicast address is known or is\n               applicable.  The block of addresses\
    \ 224.1.0.0 -\n               224.1.255.255 has been allocated for use by ST.\n\
    \               Local Net Multicast Address is the multicast address to\n    \
    \           be used on the local network.  It corresponds to the IP\n        \
    \       Multicast Address when the latter is non-zero.\n         4.2.2.8.    \
    \     Name & RName\n            Each stream is uniquely (i.e., globally) identified\
    \ by a\n            Name.  A Name is created by the origin host ST agent and is\n\
    \            composed of 1) a 16-bit number chosen to make the Name\n        \
    \    unique within the agent, 2) the IP address of the origin ST\n           \
    \ agent, and 3) a 32-bit timestamp.  If the origin has\n            multiple IP\
    \ addresses, then any that can be used to reach\n            target may be used\
    \ in the Name.  The intent is that the\n            <Unique ID, IP Address> tuple\
    \ be unique for the lifetime of\n            the stream.  It is suggested that\
    \ to increase robustness a\n            Unique ID value not be reused for a period\
    \ of time on the\n            order of 5 minutes.\n            The Timestamp is\
    \ included both to make the Name unique over\n            long intervals (e.g.,\
    \ forever) for purposes of network\n            management and accounting/billing,\
    \ and to protect against\n            failure of an ST agent that causes knowledge\
    \ of active\n            Unique IDs to be lost.  The assumption is that all ST\
    \ agents\n            have access to some \"clock\".  If this is not the case,\
    \ the\n            agent should have access to some form of non-volatile memory\n\
    \            in which it can store some number that at least gets\n          \
    \  incremented per restart.\n            The Name parameter (PCode = 7) is used\
    \ in most control\n            messages to identify a stream.\n            The\
    \ RName parameter (PCode = 15) is used in conjunction with\n            the FDx\
    \ option to convey the Name of the reverse stream in\n            an ACCEPT message.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     PCode     |       12      |            Unique ID          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          IP Address                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Figure 29.  Name & RName\n         4.2.2.9.         NextHopIPAddress\n\
    \            The NextHopIPAddress parameter (PCode = 8) is an optional\n     \
    \       parameter of NOTIFY (RouteBack) or REFUSE (RouteInconsist or\n       \
    \     RouteLoop) and contains the IP address of a suggested next-\n          \
    \  hop ST agent.\n    0                   1                   2              \
    \     3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \ PCode = 8   |       8       |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       next-hop IP address                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 30.  NextHopIPAddress\n         4.2.2.10.      \
    \  Origin\n            The Origin parameter (PCode = 9) is used to identify the\n\
    \            origin of the stream, the next higher protocol, and the SAP\n   \
    \         being used in conjunction with that protocol.\n               NextPcol\
    \ is an 8-bit field used in demultiplexing\n               operations to identify\
    \ the protocol to be used above ST.\n               The values of NextPcol are\
    \ in the same number space as\n               the IP Header's Protocol field and\
    \ are consequently\n               defined in the Assigned Numbers RFC [18].\n\
    \               OriginSAPBytes specifies the length of the OriginSAP,\n      \
    \         exclusive of any padding required to maintain 32-bit\n             \
    \  alignment.\n               OriginIPAddress is (one of) the IP address of the\
    \ origin.\n               OriginSAP identifies the origin's SAP associated with\
    \ the\n               NextPcol protocol.\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 9   |    PBytes     |    NextPcol   |OriginSAPBytes |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         OriginIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                           OriginSAP           :    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 31.  Origin\n         4.2.2.11.        OriginTimestamp\n\
    \            The OriginTimestamp parameter (PCode = 10) is used to\n         \
    \   indicate the time at which the control message was sent.\n            The\
    \ units and format of the timestamp is that defined in the\n            NTP protocol\
    \ specification [13].  Note that discontinuities\n            over leap seconds\
    \ are expected.\n            Note that the time synchronization implied by the\
    \ use of\n            such a parameter is the subject of systems management\n\
    \            functions not described in this memo, e.g., NTP.\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 10  |      12       |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +- \
    \                         Timestamp                          -+\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 32.  OriginTimestamp\n         4.2.2.12.  \
    \      ReasonCode\n            Several errors may occur during protocol processing.\
    \  All ST\n            error codes are taken from a single number space.  The\n\
    \            currently defined values and their meaning is presented in\n    \
    \        the list below.  Note that new error codes may be defined\n         \
    \   from time to time.  All implementations are expected to\n            handle\
    \ new codes in a graceful manner.  If an unknown\n            ReasonCode is encountered,\
    \ it should be assumed to be fatal.\n                    0                   1\n\
    \                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   |          ReasonCode           |\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 33.  ReasonCode\n                  Name     \
    \  Value                 Meaning\n            ---------------- ----- ---------------------------------------\n\
    \            AcceptTimeout      2   An Accept has not been\n                 \
    \                  acknowledged.\n            AccessDenied       3   Access denied.\n\
    \            AckUnexpected      4   An unexpected ACK was received.\n        \
    \    ApplAbort          5   The application aborted the stream\n             \
    \                      abnormally.\n            ApplDisconnect     6   The application\
    \ closed the stream\n                                   normally.\n          \
    \  AuthentFailed      7   The authentication function\n                      \
    \             failed.\n            CantGetResrc       8   Unable to acquire (additional)\n\
    \                                   resources.\n            CantRelResrc     \
    \  9   Unable to release excess\n                                   resources.\n\
    \            CksumBadCtl       10   A received control PDU has a bad\n       \
    \                            message checksum.\n            CksumBadST       \
    \ 11   A received PDU has a bad ST Header\n                                  \
    \ checksum.\n            DropExcdDly       12   A received PDU was dropped because\n\
    \                                   it could not be processed within\n       \
    \                            the delay specification.\n            DropExcdMTU\
    \       13   A received PDU was dropped because\n                            \
    \       its size exceeds the MTU.\n            DropFailAgt       14   A received\
    \ PDU was dropped because\n                                   of a failed ST agent.\n\
    \            DropFailHst       15   A received PDU was dropped because\n     \
    \                              of a host failure.\n            DropFailIfc   \
    \    16   A received PDU was dropped because\n                               \
    \    of a broken interface.\n            DropFailNet       17   A received PDU\
    \ was dropped because\n                                   of a network failure.\n\
    \                  Name       Value                 Meaning\n            ----------------\
    \ ----- ---------------------------------------\n            DropLimits      \
    \  18   A received PDU was dropped because\n                                 \
    \  it exceeds the resource limits for\n                                   its\
    \ stream.\n            DropNoResrc       19   A received PDU was dropped due to\n\
    \                                   no available resources (including\n      \
    \                             precedence).\n            DropNoRoute       20 \
    \  A received PDU was dropped because\n                                   of no\
    \ available route.\n            DropPriLow        21   A received PDU was dropped\
    \ because\n                                   it has a priority too low to be\n\
    \                                   processed.\n            DuplicateIgn     \
    \ 22   A received control PDU is a\n                                   duplicate\
    \ and is being\n                                   acknowledged.\n           \
    \ DuplicateTarget   23   A received control PDU contains a\n                 \
    \                  duplicate target, or an attempt to\n                      \
    \             add an existing target.\n            ErrorUnknown       1   An error\
    \ not contained in this\n                                   list has been detected.\n\
    \            failure          N/A   An abbreviation used in the text\n       \
    \                            for any of the more specific\n                  \
    \                 errors:  DropFailAgt, DropFailHst,\n                       \
    \            DropFailIfc, DropFailNet,\n                                   IntfcFailure,\
    \ NetworkFailure,\n                                   STAgentFailure, FailureRecovery.\n\
    \            FailureRecovery   24   A notification that recovery is\n        \
    \                           being attempted.\n            FlowVerBad        25\
    \   A received control PDU has a\n                                   FlowSpec\
    \ Version Number that is\n                                   not supported.\n\
    \            GroupUnknown      26   A received control PDU contains an\n     \
    \                              unknown Group Name.\n            HIDNegFails  \
    \     28   HID negotiation failed.\n            HIDUnknown        29   A received\
    \ control PDU contains an\n                                   unknown HID.\n \
    \                 Name       Value                 Meaning\n            ----------------\
    \ ----- ---------------------------------------\n            InconsistHID    \
    \  30   An inconsistency has been detected\n                                 \
    \  with a stream Name and\n                                   corresponding HID.\n\
    \            InconsistGroup    31   An inconsistency has been detected\n     \
    \                              with the streams forming a group.\n           \
    \ IntfcFailure      32   A network interface failure has\n                   \
    \                been detected.\n            InvalidHID        33   A received\
    \ ST PDU contains an\n                                   invalid HID.\n      \
    \      InvalidSender     34   A received control PDU has an\n                \
    \                   invalid SenderIPAddress field.\n            InvalidTotByt\
    \     35   A received control PDU has an\n                                   invalid\
    \ TotalBytes field.\n            LnkRefUnknown     36   A received control PDU\
    \ contains an\n                                   unknown LnkReference.\n    \
    \        NameUnknown       37   A received control PDU contains an\n         \
    \                          unknown stream Name.\n            NetworkFailure  \
    \  38   A network failure has been\n                                   detected.\n\
    \            NoError            0   No error has occurred.\n            NoRouteToAgent\
    \    39   Cannot find a route to an ST\n                                   agent.\n\
    \            NoRouteToDest     40   Cannot find a route to the\n             \
    \                      destination.\n            NoRouteToHost     41   Cannot\
    \ find a route to a host.\n            NoRouteToNet      42   Cannot find a route\
    \ to a network.\n            OpCodeUnknown     43   A received control PDU has\
    \ an\n                                   invalid OpCode field.\n            PCodeUnknown\
    \      44   A received control PDU has a\n                                   parameter\
    \ with an invalid PCode.\n            ParmValueBad      45   A received control\
    \ PDU contains an\n                                   invalid parameter value.\n\
    \                  Name       Value                 Meaning\n            ----------------\
    \ ----- ---------------------------------------\n            PcolIdUnknown   \
    \  46   A received control PDU contains an\n                                 \
    \  unknown next-higher layer protocol\n                                   identifier.\n\
    \            ProtocolError     47   A protocol error was detected.\n         \
    \   PTPError          48   Multiple targets were specified\n                 \
    \                  for a stream created with the PTP\n                       \
    \            option.\n            RefUnknown        49   A received control PDU\
    \ contains an\n                                   unknown Reference.\n       \
    \     RestartLocal      50   The local ST agent has recently\n               \
    \                    restarted.\n            RemoteRestart     51   The remote\
    \ ST agent has recently\n                                   restarted.\n     \
    \       RetransTimeout    52   An acknowledgment to a control\n              \
    \                     message has not been received\n                        \
    \           after several retransmissions.\n            RouteBack         53 \
    \  The routing function indicates\n                                   that the\
    \ route to the next-hop is\n                                   through the same\
    \ interface as the\n                                   previous-hop and is not\
    \ the\n                                   previous-hop.\n            RouteInconsist\
    \    54   A routing inconsistency has been\n                                 \
    \  detected, e.g., a route loop.\n            RouteLoop         55   A CONNECT\
    \ was received that\n                                   specified an existing\
    \ target.\n            SAPUnknown        56   A received control PDU contains\
    \ an\n                                   unknown next-higher layer SAP\n     \
    \                              (port).\n            STAgentFailure    57   An\
    \ ST agent failure has been\n                                   detected.\n  \
    \          StreamExists      58   A stream with the given Name or\n          \
    \                         HID already exists.\n            StreamPreempted   59\
    \   The stream has been preempted by\n                                   one with\
    \ a higher precedence.\n                  Name       Value                 Meaning\n\
    \            ---------------- ----- ---------------------------------------\n\
    \            STVerBad          60   A received PDU is not ST Version\n       \
    \                            2.\n            TooManyHIDs       61   Attempt to\
    \ add more HIDs to a\n                                   stream than the implementation\n\
    \                                   supports.\n            TruncatedCtl      62\
    \   A received control PDU is shorter\n                                   than\
    \ expected.\n            TruncatedPDU      63   A received ST PDU is shorter than\n\
    \                                   the ST Header indicates.\n            UserDataSize\
    \      64   The UserData parameter is too\n                                  \
    \ large to permit a control message\n                                   to fit\
    \ into a network's MTU.\n         4.2.2.13.        RecordRoute\n            The\
    \ RecordRoute parameter (PCode = 11) may be used to\n            request that\
    \ the route between the origin and a target be\n            recorded and returned\
    \ to the agent specified in the\n            DetectorIPAddress field.\n      \
    \      FreeOffset is the offset to the position where the next\n            next-hop\
    \ IP address should be inserted.  It is initialized\n            to four (4) and\
    \ incremented by four each time an agent\n            inserts its IP address.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 11  |     PBytes    |       0       |  FreeOffset   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       next-hop IP address                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                              ...                              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       next-hop IP address                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                          Figure 34.  RecordRoute\n         4.2.2.14.       \
    \ SrcRoute\n            The SrcRoute parameter is used, in the Target structure\n\
    \            shown in Figure 36, to specify the IP addresses of the ST\n     \
    \       agents through which the stream to the target should pass.\n         \
    \   There are two forms of the option, distinguished by the\n            PCode.\n\
    \            With loose source route (PCode = 18) each ST agent first\n      \
    \      examines the first next-hop IP address in the option.  If\n           \
    \ the address is (one of) the address of the current ST agent,\n            that\
    \ entry is removed, and the PBytes field reduced by four\n            (4).  If\
    \ the resulting PBytes field contains 4 (i.e., there\n            are no more\
    \ next-hop IP addresses) the parameter is removed\n            from the Target.\
    \  In either case, the Target's TargetBytes\n            field and the TargetList's\
    \ PBytes field must be reduced\n            accordingly.  The ST agent then routes\
    \ toward the first\n            next-hop IP address in the option, if one exists,\
    \ or toward\n            the target otherwise.  Note that the target's IP address\
    \ is\n            not included as the last entry in the list.\n            With\
    \ a strict source route (PCode = 19) each ST agent first\n            examines\
    \ the first next-hop IP address in the option.  If\n            the address is\
    \ not (one of) the address of the current ST\n            agent, a routing error\
    \ has occurred and should be reported\n            with the appropriate reason\
    \ code.  Otherwise that entry is\n            removed, and the PBytes field reduced\
    \ by four (4).  If the\n            resulting PBytes field contains 4 (i.e., there\
    \ are no more\n            next-hop IP addresses) the parameter is removed from\
    \ the\n            Target.  In either case, the Target's TargetBytes field and\n\
    \            the TargetList's PBytes field must be reduced accordingly.\n    \
    \        The ST agent then routes toward the first next-hop IP\n            address\
    \ in the option, if one exists, or toward the target\n            otherwise. \
    \ Note that the target's IP address is not\n            included as the last entry\
    \ in the list.\n    0                   1                   2                \
    \   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   \
    \   PCode    |     4+4*N     |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      next-hop IP address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                              ...                              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      next-hop IP address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                          Figure 35.  SrcRoute\n            Since it is possible\
    \ that a single hop between ST agents is\n            actually composed of multiple\
    \ IP hops using IP\n            encapsulation, it might be necessary to also specify\
    \ an IP\n            source routing option.  Two additional PCodes are used in\n\
    \            this case.  See [15] for a description of IP routing\n          \
    \  options.\n            An IP Loose Source Route (PCode = 16) indicates that\
    \ PDUs\n            for the next-hop ST agent should be encapsulated in IP and\n\
    \            that the IP datagram should contain an IP Loose Source Route\n  \
    \          constructed from the list of IP router addresses contained\n      \
    \      in this option.\n            An IP Strict Source Route (PCode = 17) is\
    \ similarly used\n            when the corresponding IP Strict Source Route option\
    \ should\n            be constructed.\n            Consequently, the \"routing\
    \ parameter\" may consist of a\n            sequence of one or more separate parameters\
    \ with PCodes 16,\n            17, 18, or 19.\n         4.2.2.15.        Target\
    \ and TargetList\n            Several control messages use a parameter called\
    \ TargetList\n            (PCode = 20), which contains information about the targets\n\
    \            to which the message pertains.  For each Target in the\n        \
    \    TargetList, the information includes the IP addresses of the\n          \
    \  target, the SAP applicable to the next higher layer\n            protocol,\
    \ the length of the SAP (SAPBytes), and zero or more\n            optional SrcRoute\
    \ parameters;  see Section 4.2.2.14 (page\n            95).  Consequently, a Target\
    \ structure can be of variable\n            length.  Each entry has the format\
    \ shown in Figure 36.\n            The optional SrcRoute parameter is only meaningful\
    \ in a\n            CONNECT messages;  if present in other messages, they are\n\
    \            ignored.  Note that the presence of SrcRoute parameter(s)\n     \
    \       reduces the number of Targets that can be contained in a\n           \
    \ TargetList since the maximum size of a TargetList is 256\n            bytes.\
    \  Consequently an implementation should be prepared to\n            accept multiple\
    \ TargetLists in a single message.\n               TargetIPAddress is the IP Address\
    \ of the Target.\n               TargetBytes is the length of the Target structure,\n\
    \               beginning with the TargetIPAddress and including any\n       \
    \        SrcRoute Parameter(s).\n               SAPBytes is the length of the\
    \ SAP, excluding any padding\n               required to maintain 32-bit alignment.\
    \  I.e.,\n               there would be no padding required for SAPs with lengths\n\
    \               of 2, 6, etc., bytes.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        TargetIPAddress                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  TargetBytes  |   SAPBytes    |                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \             -+-+-+-+-+-+-+-+-+\n   :                              SAP      \
    \        :    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   SrcRoute Parameter(s)                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 36.  Target\n            We assume that the\
    \ ST agents must know the maximum packet\n            size of the networks to\
    \ which they are connected (the MTU),\n            and those maximum sizes will\
    \ restrict the number of targets\n            that can be specified in control\
    \ messages.  We feel that\n            this is not a serious drawback.  High bandwidth\
    \ networks\n            such as the Ethernet or the Terrestrial Wideband network\n\
    \            support packet sizes large enough to allow well over one\n      \
    \      hundred targets to be specified, and we feel that\n            conferences\
    \ with a larger number of participants will not\n            occur for quite some\
    \ time.  Furthermore, we expect that\n            future higher bandwidth networks\
    \ will allow even larger\n            packet sizes.  It may be desirable to send\
    \ ST voice data\n            packets in individual B-ISDN ATM cells, which are\
    \ small, but\n            network services on ATM will provide \"adaptation layers\"\
    \ to\n            implement network-level fragmentation that may be used to\n\
    \            carry larger ST control messages.\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 20  |    PBytes     |        TargetCount = N        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                            Target 1                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                              ...                              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                            Target N                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 37.  TargetList\n            If a message must\
    \ pass across a network whose maximum packet\n            size is too small, the\
    \ message must be broken up into\n            multiple messages, each of which\
    \ carries part of the\n            TargetList.  The function of the message can\
    \ still be\n            performed even if the message is so partitioned.  The\
    \ effect\n            in this partitioning is to compromise the performance, but\n\
    \            still allows proper operation.  For example, if a CONNECT\n     \
    \       message were partitioned, the first CONNECT would establish\n        \
    \    the stream, and the rest of the CONNECTs would be processed\n           \
    \ as additions to the first.  The routing decisions might\n            suffer,\
    \ however, since they would be made on partial\n            information.  Nevertheless,\
    \ the stream would be created.\n         4.2.2.16.        UserData\n         \
    \   The UserData parameter (PCode = 21) is an optional parameter\n           \
    \ that may be used by the next higher protocol or an\n            application\
    \ to convey arbitrary information to its peers.\n            Note that since the\
    \ size of control messages is limited by\n            the smallest MTU in the\
    \ path to the target(s), the maximum\n            size of this parameter cannot\
    \ be specified a priori.  If the\n            parameter is too large for some\
    \ network's MTU, a\n            UserDataSize error will occur.  The parameter\
    \ must be padded\n            to a multiple of 32 bits.\n               UserBytes\
    \ specifies the number of valid UserInformation\n               bytes.\n     \
    \          UserInformation is arbitrary data meaningful to the next\n        \
    \       higher protocol layer or application.\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PCode = 21  |    PBytes     |           UserBytes           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                        UserInformation        :    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 38.  UserData\n"
- title: 4.2.3.        ST Control Message PDUs
  contents:
  - "4.2.3.        ST Control Message PDUs\n         Each control message is described\
    \ in a following section.  See\n         Appendix 1 (page 147) for an explanation\
    \ of the notation.\n         4.2.3.1.         ACCEPT\n            ACCEPT (OpCode\
    \ = 1) is issued by a target as a positive\n            response to a CONNECT\
    \ message.  It implies that the target\n            is prepared to accept data\
    \ from the origin along the stream\n            that was established by the CONNECT.\
    \  The ACCEPT includes\n            the FlowSpec that contains the cumulative\
    \ information that\n            was calculated by the intervening ST agents as\
    \ the CONNECT\n            made its way from the origin to the target, as well\
    \ as any\n            modifications made by the application at the target.  The\n\
    \            ACCEPT is relayed by the ST agents from the target to the\n     \
    \       origin along the path established by the CONNECT but in the\n        \
    \    reverse direction.  The ACCEPT must be acknowledged with an\n           \
    \ ACK at each hop.\n            The FlowSpec is not modified on this trip from\
    \ the target\n            back to the origin.  Since the cumulative FlowSpec\n\
    \            information can be different for different targets, no\n        \
    \    attempt is made to combine the ACCEPTs from the various\n            targets.\
    \  The TargetList included in each ACCEPT contains\n            the IP address\
    \ of only the target that issued the ACCEPT.\n            Any SrcRoute parameters\
    \ in the TargetList are ignored.\n            Since an ACCEPT might be the first\
    \ response from a next-hop\n            on a control link (due to network reordering),\
    \ the SVLId\n            field may be the first source of the Virtual Link Identifier\n\
    \            to be used in the RVLId field of subsequent control messages\n  \
    \          sent to that next-hop.\n            When the FDx option has been selected\
    \ to setup a second\n            stream in the reverse direction, the ACCEPT will\
    \ contain\n            both RFlowSpec and RName parameters.  Each agent should\n\
    \            update the state tables for the reverse stream with this\n      \
    \      information.\n               TSR (bits 14 and 15) specifies the target's\
    \ response for\n               the use of data packet timestamps; see Section\
    \ 4 (page\n               76).  Its values and semantics are:\n              \
    \    00  Not implemented.\n                  01  No timestamps are permitted.\n\
    \                  10  Timestamps must always be present.\n                  11\
    \  Timestamps may optionally be present.\n               Reference contains a\
    \ number assigned by the agent sending\n               the ACCEPT for use in the\
    \ acknowledging ACK.\n               LnkReference is the Reference number from\
    \ the\n               corresponding CONNECT or CHANGE.\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 1   |     0     |TSR|           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                      FlowSpec Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                     TargetList Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   RecordRoute Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    RFlowSpec Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       RName Parameter                       !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 39.  ACCEPT Control Message\n         4.2.3.2.    \
    \     ACK\n            ACK (OpCode = 2) is used to acknowledge a request.  The\n\
    \            Reference in the header is the Reference number of the\n        \
    \    control message being acknowledged.\n            Since a ACK might be the\
    \ first response from a next-hop on a\n            control link, the SVLId field\
    \ may be the first source of the\n            Virtual Link Identifier to be used\
    \ in the RVLId field of\n            subsequent control messages sent to that\
    \ next-hop.\n               ReasonCode is usually NoError, but other possibilities\n\
    \               exist, e.g., DuplicateIgn.\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 2   |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 40.  ACK Control Message\n         4.2.3.3.      \
    \   CHANGE-REQUEST\n            CHANGE-REQUEST (OpCode = 4) is used by an intermediate\
    \ or\n            target agent to request that the origin change the FlowSpec\n\
    \            of an established stream.  The CHANGE-REQUEST message is\n      \
    \      propagated hop-by-hop to the origin, with an ACK at each\n            hop.\n\
    \            Any SrcRoute parameters in the targets of the TargetList are\n  \
    \          ignored.\n               G (bit 8) is used to request a global, stream-wide\n\
    \               change;  the TargetList parameter may be omitted when the\n  \
    \             G bit is specified.\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 4   |G|      0      |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                       FlowSpec Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   TargetList Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 41.  CHANGE-REQUEST Control Message\n         4.2.3.4.\
    \         CHANGE\n            CHANGE (OpCode = 3) is used to change the FlowSpec\
    \ of an\n            established stream.  Parameters are the same as for CONNECT\n\
    \            but the TargetList is not required.  The CHANGE message is\n    \
    \        processed similarly to the CONNECT message, except that it\n        \
    \    travels along the path of an established stream.\n            If the change\
    \ to the FlowSpec is in a direction that makes\n            fewer demands of the\
    \ involved networks, then the change has\n            a high probability of success\
    \ along the path of the\n            established stream.  Each ST agent receiving\
    \ the CHANGE\n            message makes the necessary requested changes to the\
    \ network\n            resource allocations, and if successful, propagates the\n\
    \            CHANGE message along the established paths.  If the change\n    \
    \        cannot be made then the ST agent must recover using\n            DISCONNECT\
    \ and REFUSE messages as in the case of a network\n            failure.  Note\
    \ that a failure to change the resources\n            requested for a specific\
    \ target(s) should not cause other\n            targets in the stream to be deleted.\
    \  The CHANGE must be\n            ACKed.\n            If the CHANGE is a result\
    \ of a CHANGE-REQUEST the\n            LnkReference field of the CHANGE will contain\
    \ the value from\n            the Reference field of the CHANGE-REQUEST.\n   \
    \         It is recommended that the origin only have one outstanding\n      \
    \      CHANGE per target;  if the application requests more that\n           \
    \ one to be outstanding at a time, it is the application's\n            responsibility\
    \ to deal with any sequencing problems that may\n            arise.\n        \
    \    Any SrcRoute parameters in the targets of the\n            TargetListParameter\
    \ are ignored.\n               G (bit 8) is used to request a global, stream-wide\n\
    \               change;  the TargetList parameter may be omitted when the\n  \
    \             G bit is specified.\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 3   |G|      0      |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                       FlowSpec Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   TargetList Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 42.  CHANGE Control Message\n         4.2.3.5.    \
    \     CONNECT\n            CONNECT (OpCode = 5) requests the setup of a new stream\
    \ or\n            an addition to or recovery of an existing stream.  Only the\n\
    \            origin can issue the initial set of CONNECTs to setup a\n       \
    \     stream, and the first CONNECT to each next-hop is used to\n            convey\
    \ the initial suggestion for a HID.  If the stream's\n            data packets\
    \ will be sent to some set of next-hop ST agents\n            by multicast then\
    \ the CONNECTs to that set must suggest the\n            same HID.  Otherwise,\
    \ the HIDs in the various CONNECTs can\n            be different.\n          \
    \  The CONNECT message must fit within the maximum allowable\n            packet\
    \ size (MTU) for the intervening network.  If a CONNECT\n            message is\
    \ too large, it must be fragmented into multiple\n            CONNECT messages\
    \ by partitioning the TargetList; see Section\n            4.2 (page 77).  Any\
    \ UserData parameter will be replicated in\n            each fragment for delivery\
    \ to all targets.\n            The next-hop can initially respond with any of\
    \ the following\n            five responses:\n             1  ERROR-IN-REQUEST,\
    \ which implies that the CONNECT was\n                not valid and has been ignored,\n\
    \             2  ACK, which implies that the CONNECT with the H bit not\n    \
    \            set was valid and is being processed,\n             3  HID-APPROVE,\
    \ which implies that the CONNECT with the\n                H bit set was valid,\
    \ and the suggested HID can be\n                used or was deferred,\n      \
    \       4  HID-REJECT, which implies that the CONNECT with the H\n           \
    \     bit set was valid but the suggested HID cannot be\n                used\
    \ and another must be suggested in a subsequent\n                HID-CHANGE message,\
    \ or\n             5  REFUSE, which implies that the CONNECT was valid but\n \
    \               the included list of targets in the REFUSE cannot be\n       \
    \         processed for the stated reason.\n            The next-hop will later\
    \ relay back either an ACCEPT or\n            REFUSE from each target not already\
    \ specified in the REFUSE\n            of case 5 above (note multiple targets\
    \ may be included in a\n            single REFUSE message).\n            An intermediate\
    \ ST agent that receives a CONNECT selects the\n            next-hop ST agents,\
    \ partitions the TargetList accordingly,\n            reserves network resources\
    \ in the direction toward the\n            next-hop, updating the FlowSpec accordingly\
    \ (see Section\n            4.2.2.3 (page 81)), selects a proposed HID for each\
    \ next-\n            hop, and sends the resulting CONNECTs.\n            If the\
    \ intermediate ST agent that is processing a CONNECT\n            fails to find\
    \ a route to a target, then it responds with a\n            REFUSE with the appropriate\
    \ reason code.  If the next-hop to\n            a target is by way of the network\
    \ from which it received the\n            CONNECT, then it sends a NOTIFY with\
    \ the appropriate reason\n            code (RouteBack).  In either case, the TargetList\
    \ specifies\n            the affected targets.  The intermediate ST agent will\
    \ only\n            route to and propagate a CONNECT to the targets for which\
    \ it\n            does not issue either an ERROR-IN-REQUEST or a REFUSE.\n   \
    \         The processing of a received CONNECT message requires care\n       \
    \     to avoid routing loops that could result from delays in\n            propagating\
    \ routing information among ST agents.  If a\n            received CONNECT contains\
    \ a new Name, a new stream should be\n            created (unless the Virtual\
    \ Link Identifier matches a known\n            link in which case an ERROR-IN-REQUEST\
    \ should be sent).  If\n            the Name is known, there are four cases:\n\
    \             1  the Virtual Link Identifier matches and the Target\n        \
    \        matches a current Target -- the duplicate target\n                should\
    \ be ignored.\n             2  the Virtual Link Identifier matches but the Target\
    \ is\n                new -- the stream should be expanded to include the\n  \
    \              new target.\n             3  the Virtual Link Identifier differs\
    \ and the Target\n                matches a current Target -- an ERROR-IN-REQUEST\n\
    \                message should be sent specifying that the target is\n      \
    \          involved in a routing loop.  If a reroute, the old\n              \
    \  path will eventually timeout and send a DISCONNECT;\n                a subsequent\
    \ retransmission of the rerouted CONNECT\n                will then be processed\
    \ under case 2 above.\n             4  the Virtual Link Identifier differs but\
    \ the Target is\n                new -- a new (instance of the) stream should\
    \ be\n                created for the target that is deliberately part of\n  \
    \              a loop using a SrcRoute parameter.\n            Note that the test\
    \ for a known or matching Target includes\n            comparing any SrcRoute\
    \ parameter that might be present.\n            Option bits are specified by either\
    \ the origin's service\n            user or by an intermediate agent, depending\
    \ on the specific\n            option.  Bits not specified below are currently\
    \ unspecified,\n            and should be set to zero (0) by the origin agent\
    \ and not\n            changed by other agents unless those agents know their\n\
    \            meaning.\n               H (bit 8) is used for the HID Field option;\
    \ see Section\n               3.6.1 (page 44).  It is set to one (1) only if the\
    \ HID\n               field contains either zero (when the HID selection is\n\
    \               being deferred), or the proposed HID.  This bit is zero\n    \
    \           (0) if the HID field does not contain valid data and\n           \
    \    should be ignored.\n               P (bit 9) is used for the PTP option;\
    \ see Section 3.6.2\n               (page 44).\n               S (bit 10) is used\
    \ for the NoRecovery option; see Section\n               3.6.4 (page 46).\n  \
    \             TSP (bits 14 and 15) specifies the origin's proposal for\n     \
    \          the use of data packet timestamps; see Section 4 (page\n          \
    \     76).  Its values and semantics are:\n                  00  No proposal.\n\
    \                  01  Cannot insert timestamps.\n                  10  Must always\
    \ insert timestamps.\n                  11  Can insert timestamps if requested.\n\
    \               RVLId, the receiver's Virtual Link Identifier, is set to\n   \
    \            zero in all CONNECT messages until its value arrives in\n       \
    \        the SVLId field of an acknowledgment to the CONNECT.\n              \
    \ SVLId, the sender's Virtual Link Identifier, is set to a\n               value\
    \ chosen by each hop to facilitate efficient\n               dispatching of subsequent\
    \ control messages.\n               HID is the identifier that will be used with\
    \ data packets\n               moving through the stream in the direction from\
    \ the\n               origin to the targets.  It is a hop-by-hop shorthand\n \
    \              identifier for the stream's Name, and is chosen by each\n     \
    \          agent for the branch to the next-hop agents.  The\n               contents\
    \ of the HID field are only valid, and a HID-\n               REJECT or HID-APPROVE\
    \ reply may only be sent, when the\n               HID Field option (H bit) is\
    \ set (1).  If the HID Field\n               option is specified and the proposed\
    \ HID is zero, the\n               selection of the HID is deferred to the receiving\
    \ next-\n               hop agent.  If the HID Field option is not set (H bit\
    \ is\n               0), then the HID field does not contain valid data and\n\
    \               should be ignored;  see Section 3.6.1 (page 44).\n           \
    \    TargetList is the list of IP addresses of the target\n               processes.\
    \  It is of arbitrary size up to the maximum\n               allowed for packets\
    \ traveling across the specific\n               network.\n    0              \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 5   |H|P|S|  0  |TSP|           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            RVLId/0            |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |             HID/0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                       Origin Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                      FlowSpec Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                      TargetList Parameter(s)                  :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                      Group Parameter                        :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                 MulticastAddress Parameter                  :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   RecordRoute Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    RFlowSpec Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                      RGroup Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                      RHID Parameter                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         4.2.3.6.         DISCONNECT\n            DISCONNECT (OpCode = 6) is\
    \ used by an origin to tear down an\n            established stream or part of\
    \ a stream, or by an\n            intermediate agent that detects a failure between\
    \ itself and\n            its previous-hop, as distinguished by the ReasonCode.\
    \  The\n            DISCONNECT message specifies the list of targets that are\
    \ to\n            be disconnected.  An ACK is required in response to a\n    \
    \        DISCONNECT message.  The DISCONNECT message is propagated\n         \
    \   all the way to the specified targets.  The targets are\n            expected\
    \ to terminate their participation in the stream.\n            Note that in the\
    \ case of a failure it may be advantageous to\n            retain state information\
    \ as the stream should be repaired\n            shortly;  see Section 3.7.2 (page\
    \ 52).\n               G (bit 8) is used to request a DISCONNECT of all the\n\
    \               stream's targets; the TargetList parameter may be omitted\n  \
    \             when the G bit is set (1).\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 6   |G|      0      |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   TargetList Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 44.  DISCONNECT Control Message\n         4.2.3.7.  \
    \       ERROR-IN-REQUEST\n            ERROR-IN-REQUEST (OpCode = 7) is sent in\
    \ acknowledgment to a\n            request in which an error is detected.  No\
    \ action is taken\n            on the erroneous request and no state information\
    \ for the\n            stream is retained.  Consequently it is appropriate for\
    \ the\n            SVLId to be zero (0).  No ACK is expected.\n            An\
    \ ERROR-IN-REQUEST is never sent in response to either an\n            ERROR-IN-REQUEST\
    \ or an ERROR-IN-RESPONSE;  however, the\n            event should be logged for\
    \ diagnostic purposes.  The\n            receiver of an ERROR-IN-REQUEST is encouraged\
    \ to try again\n            without waiting for a retransmission timeout.\n  \
    \             Reference is the Reference number of the erroneous\n           \
    \    request.\n    0                   1                   2                 \
    \  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  OpCode\
    \ = 7   |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |            SVLId/0            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                        ErroredPDU                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    TargetList Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 45.  ERROR-IN-REQUEST Control Message\n         4.2.3.8.\
    \         ERROR-IN-RESPONSE\n            ERROR-IN-RESPONSE (OpCode = 8) is sent\
    \ in acknowledgment to\n            a response in which an error is detected.\
    \  No ACK is\n            expected.  Action taken by the requester and responder\
    \ will\n            vary with the nature of the request.\n            An ERROR-IN-REQUEST\
    \ is never sent in response to either an\n            ERROR-IN-REQUEST or an ERROR-IN-RESPONSE;\
    \  however, the\n            event should be logged for diagnostic purposes. \
    \ The\n            receiver of an ERROR-IN-RESPONSE is encouraged to try again\n\
    \            without waiting for a retransmission timeout.\n            Reference\
    \ identifies the erroneous response.\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 8   |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                        ErroredPDU                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    TargetList Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 46.  ERROR-IN-RESPONSE Control Message\n         4.2.3.9.\
    \         HELLO\n            HELLO (OpCode = 9) is used as part of the ST failure\n\
    \            detection mechanism; see Section 3.7.1.2 (page 49).\n           \
    \    R (bit 8) is used for the Restarted bit.\n               Reference is non-zero\
    \ to inform the receiver that an ACK\n               should be promptly sent so\
    \ that the sender can update its\n               round-trip time estimates.  If\
    \ the Reference is zero, no\n               ACK should be sent.\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 9   |R|      0      |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            RVLId/0            |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Reference/0          |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          HelloTimer                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                      OriginTimestamp                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 47.  HELLO Control Message\n         4.2.3.10.    \
    \    HID-APPROVE\n            HID-APPROVE (OpCode = 10) is used by the agent that\
    \ is\n            responding to either a CONNECT or HID-CHANGE to agree to\n \
    \           either use the proposed HID or to the addition or deletion\n     \
    \       of the specified HID.  In all cases but deletion, the newly\n        \
    \    approved HID is returned in the HID field;  for deletion,\n            the\
    \ HID field must be set to zero.  The HID-APPROVE is the\n            acknowledgment\
    \ of a CONNECT or HID-CHANGE.\n            The optional FreeHIDs parameter provides\
    \ the previous-hop\n            agent with hints about what other HIDs are acceptable\
    \ in\n            case a multicast HID is being negotiated;  see Section\n   \
    \         4.2.2.4 (page 84).\n            Since a HID-APPROVE might be the first\
    \ response from a\n            next-hop on a control link, the SVLId field may\
    \ be the first\n            source of the Virtual Link Identifier to be used in\
    \ the\n            RVLId field of subsequent control messages sent to that\n \
    \           next-hop.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 10  |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |              HID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    FreeHIDs Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 48.  HID-APPROVE Control Message\n         4.2.3.11. \
    \       HID-CHANGE-REQUEST\n            HID-CHANGE-REQUEST (OpCode = 12) is used\
    \ by a next-hop agent\n            that would like, for administrative reasons,\
    \ to change the\n            HID that is in use.  The receiving previous-hop agent\n\
    \            acknowledges the request by either an ERROR-IN-REQUEST if it\n  \
    \          is unwilling to make the requested change, or with a HID-\n       \
    \     CHANGE if it can accommodate the request.\n               A (bit 8) is used\
    \ to indicate that the specified HID\n               should be included in the\
    \ set of HIDs for the specified\n               Name.  When a HID is added, the\
    \ acknowledging HID-APPROVE\n               should contain a HID field whose contents\
    \ is the HID just\n               added.\n               D (bit 9) is used to\
    \ indicate that the specified HID\n               should be removed in the set\
    \ of HIDs for the specified\n               Name.  When a HID is deleted, the\
    \ acknowledging HID-\n               APPROVE should contain a HID field whose\
    \ contents is\n               zero.  Note that the Reference field may be used\
    \ to\n               determine the HID that has been deleted.\n              \
    \ If neither bit is set, the specified HID should replace\n               that\
    \ currently in use with the specified Name.\n    0                   1       \
    \            2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 12  |A|D|     0     |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |              HID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 49.  HID-CHANGE-REQUEST Control Message\n         4.2.3.12.\
    \        HID-CHANGE\n            HID-CHANGE (OpCode = 11) is used by the agent\
    \ that issued a\n            CONNECT and received a HID-REJECT to attempt to negotiate\
    \ a\n            suitable HID.  The HID in the HID-CHANGE message must be\n  \
    \          different from that in the CONNECT, or any previous HID-\n        \
    \    CHANGE messages for the given Name.  The agent receiving the\n          \
    \  HID-CHANGE must respond with a HID-APPROVE if the new HID is\n            suitable,\
    \ or a HID-REJECT if it is not.  In case of an\n            error, either an ERROR-IN-REQUEST\
    \ or a REFUSE may be\n            returned as an acknowledgment.\n           \
    \ Since an agent may send CONNECT messages with the same HID\n            to several\
    \ next-hops in order to use multicast data\n            transfer, any HID-CHANGE\
    \ must also be sent to the same set\n            of next-hops.  Therefore, a next-hop\
    \ agent must be prepared\n            to receive a HID-CHANGE before or after\
    \ it has sent a HID-\n            APPROVE response to the CONNECT or a previous\
    \ HID-CHANGE.\n            Only the last HID-CHANGE is relevant.  The previous-hop\n\
    \            agent will ignore HID-APPROVE or HID-REJECT messages to\n       \
    \     previous CONNECT or HID-CHANGE messages.\n            A DISCONNECT can be\
    \ sent instead of a HID-CHANGE, or a\n            REFUSE can be sent instead of\
    \ a HID-APPROVE or HID-REJECT,\n            to terminate fatally the HID negotiation\
    \ and the agent's\n            knowledge of the stream.\n            The A and\
    \ D bits are used to change a HID, e.g., when adding\n            a new next-hop\
    \ to a multicast group, in such a way that data\n            packets that are\
    \ flowing through the network will not be\n            mishandled due to a race\
    \ condition in processing the HID-\n            CHANGE messages between the previous-hop\
    \ and its next-hops.\n            An implementation may choose to limit the number\
    \ of\n            simultaneous HIDs associated with a stream, but must allow\n\
    \            at least two.\n               A (bit 8) is used to indicate that\
    \ the specified HID\n               should be included in the set of HIDs for\
    \ the specified\n               Name.  When a HID is added, the acknowledging\
    \ HID-APPROVE\n               should contain a HID field whose contents is the\
    \ HID just\n               added.\n               D (bit 9) is used to indicate\
    \ that the specified HID\n               should be removed from the set of HIDs\
    \ for the specified\n               Name.  When a HID is deleted, the acknowledging\
    \ HID-\n               APPROVE should contain a HID field whose contents is\n\
    \               zero.  Note that the Reference field may be used to\n        \
    \       determine the HID that has been deleted.\n               If neither bit\
    \ is set, the specified HID should replace\n               that currently in use\
    \ for the specified Name.\n    0                   1                   2     \
    \              3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 11  |A|D|     0     |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |              HID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 50.  HID-CHANGE Control Message\n         4.2.3.13. \
    \       HID-REJECT\n            HID-REJECT (OpCode = 13) is used as an acknowledgment\
    \ that a\n            CONNECT or HID-CHANGE was received and is being processed,\n\
    \            but means that the HID contained in the CONNECT or HID-\n       \
    \     CHANGE is not acceptable.  Upon receipt of this message the\n          \
    \  agent that issued the CONNECT or HID-CHANGE must now issue a\n            HID-CHANGE\
    \ to attempt to find a suitable HID.  The HID-\n            CHANGE can cause another\
    \ HID-REJECT but eventually the HID-\n            CHANGE must be acknowledged\
    \ with a HID-APPROVE to end\n            successfully the HID negotiation.  The\
    \ agent that issued the\n            HID-REJECT may not issue an ACCEPT before\
    \ it has found an\n            acceptable HID.\n            Since a HID-REJECT\
    \ might be the first response from a next-\n            hop on a control link,\
    \ the SVLId field may be the first\n            source of the Virtual Link Identifier\
    \ to be used in the\n            RVLId field of subsequent control messages sent\
    \ to that\n            next-hop.\n            Either agent may terminate the negotiation\
    \ by issuing either\n            a DISCONNECT or a REROUTE.  The agent that issued\
    \ the HID-\n            REJECT may issue a REFUSE, or REROUTE at any time after\
    \ the\n            HID-REJECT.  In this case, the stream cannot be created, the\n\
    \            HID negotiation need not proceed, and the previous-hop need\n   \
    \         not transmit any further messages;  any further messages\n         \
    \   that are received should be ignored.\n            The optional FreeHIDs parameter\
    \ provides the previous-hop\n            agent with hints about what HIDs would\
    \ have been acceptable;\n            see Section 4.2.2.4 (page 84).\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 13  |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          RejectedHID          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    FreeHIDs Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 51.  HID-REJECT Control Message\n         4.2.3.14. \
    \       NOTIFY\n            NOTIFY (OpCode = 14) is issued by a an agent to inform\
    \ other\n            agents, the origin, or target(s) of events that may be\n\
    \            significant.  The action taken by the receiver of a NOTIFY\n    \
    \        depends on the ReasonCode.  Possible events are suspected\n         \
    \   routing problems or resource allocation changes that occur\n            after\
    \ a stream has been established.  These changes occur\n            when network\
    \ components fail and when competing streams\n            preempt resources previously\
    \ reserved by a lower precedence\n            stream.  We also anticipate that\
    \ NOTIFY can be used in the\n            future when additional resources become\
    \ available, as is the\n            case when network components recover or when\
    \ higher\n            precedence streams are deleted.\n            NOTIFY may\
    \ contain a FlowSpec that reflects that revised\n            guarantee that can\
    \ be promised to the stream.  NOTIFY may\n            also identify those targets\
    \ that are affected by the change.\n            In this way, NOTIFY is similar\
    \ to ACCEPT.\n            NOTIFY may be relayed by the ST agents back to the origin,\n\
    \            along the path established by the CONNECT but in the reverse\n  \
    \          direction.  It is up to the origin to decide whether a\n          \
    \  CHANGE should be submitted.\n            When NOTIFY is received at the origin,\
    \ the application\n            should be notified of the target and the change\
    \ in resources\n            allocated along the path to it, as specified in the\
    \ FlowSpec\n            contained in the NOTIFY message.  The application may\
    \ then\n            use the information to either adjust or terminate the\n  \
    \          portion of the stream to each affected target.\n            The NOTIFY\
    \ may be propagated beyond the previous-hop or\n            next-hop agent; it\
    \ must be acknowledged with an ACK.\n               Reference contains a number\
    \ assigned by the agent sending\n               the NOTIFY for use in the acknowledging\
    \ ACK.\n               ReasonCode identifies the reason for the notification.\n\
    \               LnkReference, when non-zero, is the Reference number from\n  \
    \             a command that is the subject of the notification.\n           \
    \    HID is present when the notification is related to a HID.\n             \
    \  Name is present when the notification is related to a\n               stream.\n\
    \               NextHopIPAddress is an optional parameter and contains\n     \
    \          the IP address of a suggested next-hop ST agent.\n               TargetList\
    \ is present when the notification is related to\n               one or more targets.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 14  |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                        ErroredPDU                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    FlowSpec Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       HID Parameter                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                NextHopIPAddress Parameter                   !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   RecordRoute Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    TargetList Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 52.  NOTIFY Control Message\n         4.2.3.15.      \
    \  REFUSE\n            REFUSE (OpCode = 15) is issued by a target that either\
    \ does\n            not wish to accept a CONNECT message or wishes to remove\n\
    \            itself from an established stream.  It might also be issued\n   \
    \         by an intermediate agent in response to a CONNECT or CHANGE\n      \
    \      either to terminate fatally a failing HID negotiation, to\n           \
    \ terminate a routing loop, or when a satisfactory next-hop to\n            a\
    \ target cannot be found.  It may also be a separate command\n            when\
    \ an existing stream has been preempted by a higher\n            precedence stream\
    \ or an agent detects the failure of a\n            previous-hop, next-hop, or\
    \ the network between them.  In all\n            cases, the TargetList specifies\
    \ the targets that are\n            affected by the condition.  Each REFUSE must\
    \ be acknowledged\n            by an ACK.\n            The REFUSE is relayed by\
    \ the agents from the originating\n            agent to the origin (or intermediate\
    \ agent that created the\n            CONNECT or CHANGE) along the path traced\
    \ by the CONNECT.\n            The agent receiving the REFUSE will process it\
    \ differently\n            depending on the condition that caused it, as specified\
    \ in\n            the ReasonCode field.  In some cases, such as if a next-hop\n\
    \            cannot obtain resources, the agent can release any resources\n  \
    \          reserved exclusively for transmissions in the stream in\n         \
    \   question to the target specified in the TargetList, and the\n            previous-hop\
    \ can attempt to find an alternate route.  In\n            some cases, such as\
    \ a routing failure, the previous-hop\n            cannot determine where the\
    \ failure occurred, and must\n            propagate the REFUSE back to the origin,\
    \ which can attempt\n            recovery of the stream by issuing a new CONNECT.\n\
    \            No special effort is made to combine multiple REFUSE\n          \
    \  messages since it is considered most unlikely that separate\n            REFUSEs\
    \ will happen to both pass through an agent at the\n            same time and\
    \ be easily combined, e.g., have identical\n            ReasonCodes and parameters.\n\
    \            Since a REFUSE might be the first response from a next-hop\n    \
    \        on a control link, the SVLId field may be the first source\n        \
    \    of the Virtual Link Identifier to be used in the RVLId field\n          \
    \  of subsequent control messages sent to that next-hop.\n               Reference\
    \ contains a number assigned by the agent sending\n               the REFUSE for\
    \ use in the acknowledging ACK.\n               LnkReference is either the Reference\
    \ number from the\n               corresponding CONNECT or CHANGE, if it is the\
    \ result of\n               such a message, or zero when the REFUSE was originated\
    \ as\n               a separate command.\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 15  |       0       |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             RVLId             |             SVLId             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |          ReasonCode           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       DetectorIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                        Name Parameter                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                     TargetList Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                        ErroredPDU                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                   RecordRoute Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    UserData Parameter                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 53.  REFUSE Control Message\n         4.2.3.16.   \
    \     STATUS\n            STATUS (OpCode = 16) is used to inquire about the existence\n\
    \            of a particular stream identified by either a HID (H bit\n      \
    \      set) or Name (Name Parameter present).\n            When a stream has been\
    \ identified, a STATUS-RESPONSE is\n            returned that will contain the\
    \ specified HID and/or Name but\n            no other parameters if the specified\
    \ stream is unknown, or\n            will otherwise contain the current HID(s),\
    \ Name, FlowSpec,\n            TargetList, and possibly Group(s) of the stream.\
    \  Note that\n            if a stream has no current HID, the HID field in the\n\
    \            STATUS-RESPONSE will contain zero;  it will contain the\n       \
    \     first, or only, HID if a valid HID exists; additional valid\n          \
    \  HIDs will be returned in HID parameters.\n            Use of STATUS is intended\
    \ for diagnostic purposes and to\n            assist in stream cleanup operations.\
    \  Note that if both a\n            HID and Name are specified, but they do not\
    \ correspond to\n            the same stream, an ERROR-IN-REQUEST with the appropriate\n\
    \            reason code (InconsistHID) would be returned.\n            It is\
    \ possible in cases of multiple failures or network\n            partitioning\
    \ for an ST agent to have information about a\n            stream after the stream\
    \ has either ceased to exist or has\n            been rerouted around the agent.\
    \  When an agent concludes\n            that a stream has not been used for a\
    \ period of time and\n            might no longer be valid, it can probe the stream's\n\
    \            previous-hop or next-hop(s) to see if they believe that the\n   \
    \         stream still exists through the interrogating agent.  If\n         \
    \   not, those hops would reply with a STATUS-RESPONSE that\n            contains\
    \ the HID and/or Name but no other parameters;\n            otherwise, if the\
    \ stream is still valid, the hops would\n            reply with the parameters\
    \ of the stream.\n               H (bit 8) is used to indicate whether (when 1)\
    \ or not\n               (when 0) a HID is present in the HID field.\n       \
    \        Q (bit 9) is set to one (1) for remote diagnostic\n               purposes\
    \ when the receiving agent should return a\n               stream's parameters,\
    \ whether or not the source of the\n               message is believed to be a\
    \ previous-hop or next-hop in\n               the specified stream.  Note that\
    \ this use has potential\n               for disclosure of sensitive information.\n\
    \               RVLId and SVLId may either or both be zero when STATUS is\n  \
    \             used for diagnostic purposes.\n    0                   1       \
    \            2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 16  |H|Q|     0     |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            RVLId/0            |            SVLId/0            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |             HID/0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 54.  STATUS Control Message\n         4.2.3.17.   \
    \     STATUS-RESPONSE\n            STATUS-RESPONSE (OpCode = 17) is the reply\
    \ to a STATUS\n            message.  If the stream specified in the STATUS message\
    \ is\n            not known, the STATUS-RESPONSE will contain the specified\n\
    \            HID and/or Name but no other parameters.  It will otherwise\n   \
    \         contain the current HID(s), Name, FlowSpec, TargetList, and\n      \
    \      possibly Group of the stream.  Note that if a stream has no\n         \
    \   current HID, the H bit in the STATUS-RESPONSE will be zero.\n            The\
    \ HID field will contain the first, or only, HID if a\n            valid HID exists;\
    \ additional valid HIDs will be returned in\n            HID parameters.\n   \
    \            H (bit 8) is used to indicate whether (when 1) or not\n         \
    \      (when 0) a HID is present in the HID field.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  OpCode = 17  |H|Q|     0     |           TotalBytes          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            RVLId/0            |            SVLId/0            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reference           |         LnkReference          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         SenderIPAddress                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Checksum           |             HID/0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               0                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                         Name Parameter                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                     FlowSpec Parameter                      :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                      Group Parameter                        :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !  \
    \                       HID Parameter                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :  \
    \                    TargetList Parameter                     :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 55.  STATUS-RESPONSE Control Message\n   4.3.     \
    \  Suggested Protocol Constants\n      The ST Protocol uses several fields that\
    \ must have specific values\n      for the protocol to work, and also several\
    \ values that an\n      implementation must select.  This section specifies the\
    \ required\n      values and suggests initial values for others.  It is recommended\n\
    \      that the latter be implemented as variables so that they may be\n     \
    \ easily changed when experience indicates better values.\n      Eventually, they\
    \ should be managed via the normal network\n      management facilities.\n   \
    \   ST uses IP Version Number 5.\n      When encapsulated in IP, ST uses IP Protocol\
    \ Number 5.\n       Value  ST Command Message Name       Value     ST Element\
    \ Name\n      ------- -----------------------      ------- ---------------------\n\
    \         1    ACCEPT                          1    ErroredPDU\n         2   \
    \ ACK                             2    FlowSpec\n         3    CHANGE        \
    \                  3    FreeHIDs\n         4    CHANGE-REQUEST               \
    \   4    Group\n         5    CONNECT                         5    HID\n     \
    \    6    DISCONNECT                      6    MulticastAddress\n         7  \
    \  ERROR-IN-REQUEST                7    Name\n         8    ERROR-IN-RESPONSE\
    \               8    NextHopIPAddress\n         9    HELLO                   \
    \        9    Origin\n        10    HID-APPROVE                    10    OriginTimestamp\n\
    \        11    HID-CHANGE                     11    RecordRoute\n        12  \
    \  HID-CHANGE-REQUEST             12    RFlowSpec\n        13    HID-REJECT  \
    \                   13    RGroup\n        14    NOTIFY                       \
    \  14    RHID\n        15    REFUSE                         15    RName\n    \
    \    16    STATUS                         16    SrcRoute, IP Loose\n        17\
    \    STATUS-RESPONSE                17    SrcRoute, IP Strict\n              \
    \                               18    SrcRoute, ST Loose\n                   \
    \                          19    SrcRoute, ST Strict\n                       \
    \                      20    TargetList\n                                    \
    \         21    UserData\n      A good choice for the minimum number of bits in\
    \ the FreeHIDBitMask\n      element of the FreeHIDs parameter is not yet known.\
    \  We suggest a\n      minimum of 64 bits, i.e., N in Figure 25 has a value of\
    \ two (2).\n      HID value zero (0) is reserved for ST Control Messages.  HID\n\
    \      values 1-3 are reserved for future use.\n      VLId value zero (0) may\
    \ only be used in the RVLId field of an ST\n      Control Message when the appropriate\
    \ value has not yet been\n      received from the other end of the virtual link;'\
    \ except for an\n      ERROR-IN-REQUEST or diagnostic message, the SVLId field\
    \ may never\n      contain a value of zero except in a diagnostic message.  VLId\n\
    \      value 1 is reserved for use with HELLO messages by those agents\n     \
    \ whose implementation wishes to have all HELLOs so identified.\n      VLId values\
    \ 2-3 are reserved for future use.\n      The following permanent IP multicast\
    \ addresses have been assigned\n      to ST:\n         224.0.0.7    All ST routers\n\
    \         224.0.0.8    All ST hosts\n      In addition, a block of transient IP\
    \ multicast addresses,\n      224.1.0.0 - 224.1.255.255, has been allocated for\
    \ ST multicast\n      groups.  Note that in the case of Ethernet, an ST Multicast\n\
    \      address of 224.1.cc.dd maps to an Ethernet Multicast address of\n     \
    \ 01:00:5E:01:cc:dd (see [6]).\n      SCMP uses retransmission to effect reliability\
    \ and thus has\n      several \"retransmission timers\".  Each \"timer\" is modeled\
    \ by an\n      initial time interval (ToXxx), which gets updated dynamically\n\
    \      through measurement of control traffic, and a number of times\n      (NXxx)\
    \ to retransmit a message before declaring a failure.  All\n      time intervals\
    \ are in units of milliseconds.\n       Value   Timeout  Name                \
    \      Meaning\n      ------- ---------------------- ----------------------------------\n\
    \        1000  ToAccept               Initial hop-by-hop timeout for\n       \
    \                              acknowledgment of ACCEPT\n           3  NAccept\
    \                ACCEPT retries before failure\n        1000  ToConnect      \
    \        Initial hop-by-hop timeout for\n                                    \
    \ acknowledgment of CONNECT\n           5  NConnect               CONNECT retries\
    \ before failure\n        1000  ToDisconnect           Initial hop-by-hop timeout\
    \ for\n                                     acknowledgment of DISCONNECT\n   \
    \       3   NDisconnect            DISCONNECT retries before\n               \
    \                      failure\n       Value   Timeout  Name                 \
    \     Meaning\n      ------- ---------------------- ----------------------------------\n\
    \        1000  ToHIDAck               Initial hop-by-hop timeout for\n       \
    \                              acknowledgment of\n                           \
    \          HID-CHANGE-REQUEST\n           3  NHIDAck                HID-CHANGE-REQUEST\
    \ retries\n                                     before failure\n        1000 \
    \ ToHIDChange            Initial hop-by-hop timeout for\n                    \
    \                 acknowledgment of HID-CHANGE\n           3  NHIDChange     \
    \        HID-CHANGE retries before\n                                     failure\n\
    \        1000  ToNotify               Initial hop-by-hop timeout for\n       \
    \                              acknowledgment of NOTIFY\n           3  NNotify\
    \                NOTIFY retries before failure\n        1000  ToRefuse       \
    \        Initial hop-by-hop timeout for\n                                    \
    \ acknowledgment of REFUSE\n           3  NRefuse                REFUSE retries\
    \ before failure\n        1000  ToReroute              Timeout for receipt of\
    \ ACCEPT or\n                                     REFUSE from targets during\n\
    \                                     failure recovery\n           5  NReroute\
    \               CONNECT retries before failure\n        5000  ToEnd2End      \
    \        End-to-End timeout for receipt\n                                    \
    \ of ACCEPT or REFUSE from targets\n                                     by origin\n\
    \           0  NEnd2End               CONNECT retries before failure\n       Value\
    \   Parameter  Name                    Meaning\n      ------- ----------------------\
    \ ----------------------------------\n          10  NHIDAbort              Number\
    \ of rejected HID proposals\n                                     before aborting\
    \ the HID\n                                     negotiation process\n       10000\
    \  HelloTimerHoldDown     Interval that Restarted bit must\n                 \
    \                    be set after ST restart\n           5  HelloLossFactor  \
    \      Number of consecutively missed\n                                     HELLO\
    \ messages before declaring\n                                     link failure\n\
    \        2000  DefaultRecoveryTimeout Interval between successive\n          \
    \                           HELLOs to/from active neighbors\n           2  DefaultHelloFactor\
    \     HELLO filtering function factor\n"
- title: 5.      Areas Not Addressed
  contents:
  - "5.      Areas Not Addressed\n   There are a number of issues that will need to\
    \ be addressed in the\n   long run but are not addressed here.  Some issues are\
    \ network or\n   implementation specific.  For example, the management of multicast\n\
    \   groups depends on the interface that a network provides to the ST\n   agent,\
    \ and an UP/DOWN protocol based on ST HELLO messages depends on\n   the details\
    \ of the ST agents.  Both these examples may impact the ST\n   implementations,\
    \ but we feel it is inappropriate to specify them\n   here.\n   In other cases\
    \ we feel that appropriate solutions are not clear at\n   this time.  The following\
    \ are examples of such issues:\n   This document does not include a routing mechanism.\
    \  We do not feel\n   that a routing strategy based on minimizing the number of\
    \ hops from\n   the source to the destination is necessarily appropriate.  An\n\
    \   alternative strategy is to minimize the consumption of internet\n   resources\
    \ within some delay constraints.  Furthermore, it would be\n   preferable if the\
    \ routing function were to provide routes that\n   incorporated bandwidth, delay,\
    \ reliability, and perhaps other\n   characteristics, not just connectivity. \
    \ This would increase the\n   likelihood that a selected route would succeed.\
    \  This requirement\n   would probably cause the ST agents to exchange more routing\n\
    \   information than currently implemented.  We feel that further\n   research\
    \ and experimentation will be required before an appropriate\n   routing strategy\
    \ is well enough defined to be incorporated into the\n   ST specification.\n \
    \  Once the bandwidth for a stream has been agreed upon, it is not\n   sufficient\
    \ to rely on the origin to transmit traffic at that rate.\n   The internet should\
    \ not rely on the origin to operate properly.\n   Furthermore, even if the origin\
    \ sources traffic at the agreed rate,\n   the packets may become aggregated unintentionally\
    \ and cause local\n   congestion.  There are several approaches to addressing\
    \ this problem,\n   such as metering the traffic in each stream as it passes through\
    \ each\n   agent.  Experimentation is necessary before such a mechanism is\n \
    \  selected.\n   The interface between the agent and the network is very limited.\
    \  A\n   mechanism is provided by which the ST layer can query the network to\n\
    \   determine the likelihood that a stream can be supported.  However,\n   this\
    \ facility will require practical experience before its\n   appropriate use is\
    \ defined.\n   The simplex tree model of a stream does not easily allow for using\n\
    \   multiple paths to support a greater bandwidth.  That is, at any given\n  \
    \ point in a stream, the entire incoming bandwidth must be transmitted\n   to\
    \ the same next-hop in order to get to some target.  If the\n   bandwidth isn't\
    \ available along any single path, the stream cannot be\n   built to that target.\
    \  It may be the case that the bandwidth is not\n   available along a single path,\
    \ but if the data\n   flow is split along multiple paths, and so multiple next-hops,\n\
    \   sufficient bandwidth would be available.  As currently specified, the\n  \
    \ ST agent at the point where the multiple flows converge will refuse\n   the\
    \ second connection because it can only be interpreted as a routing\n   failure.\
    \  A mechanism that allows multiple paths in a stream and can\n   protect against\
    \ routing failures has not been defined.\n   If sufficient bandwidth is not available,\
    \ both preemption and\n   rerouting are possible.  However, it is not clear when\
    \ to use one or\n   the other.  As currently specified, an ST agent that cannot\
    \ obtain\n   sufficient bandwidth will attempt to preempt lower precedence streams\n\
    \   before attempting to reroute around the bottleneck.  This may lead to\n  \
    \ an undesirably high number of preemptions.  It may be that a higher\n   precedence\
    \ stream can be rerouted around lower precedence streams and\n   still meet its\
    \ performance requirements, whereas the preempted lower\n   precedence streams\
    \ cannot be reconstructed and still meet their\n   performance requirements. \
    \ A simple and effective algorithm to allow\n   a better decision has not been\
    \ identified.\n   In case a stream cannot be completed, ST does not report to\
    \ the\n   application the nature of the trouble in any great detail.\n   Specifically,\
    \ the application cannot determine where the bottleneck\n   is, whether the problem\
    \ is permanent or transitory, or the likely\n   time before the trouble may be\
    \ resolved.  The application can only\n   attempt to build the stream at some\
    \ later time hoping that the\n   trouble has been resolved.  Schemes can be envisioned\
    \ by which\n   information is relayed back to the application.  However, only\n\
    \   practical experience can evaluate the kind of trouble that is most\n   likely\
    \ encountered and the nature of information that would be most\n   useful to the\
    \ application.\n   A mechanism is also not defined for cases where a stream cannot\
    \ be\n   completed not because of lack of resources but because of an\n   unexpected\
    \ failure that results in an ERROR-IN-REQUEST message.  An\n   ERROR-IN-REQUEST\
    \ message is returned in cases when an ST agent issues\n   a malformed control\
    \ message to a neighbor.  Such an occurrence is\n   unexpected and may be caused\
    \ by a bad or incomplete ST\n   implementation.  In some cases a message, such\
    \ as a NOTIFY should be\n   sent to the origin.  Such a mechanism is not defined\
    \ because it is\n   not clear what information can be extracted and what the origin\n\
    \   should do.\n   No special action is taken when a target is removed from a\
    \ stream.\n   Removing a target may also remove a bottleneck either in bandwidth,\n\
    \   packet rate or packet size, but advantage of this opportunity is not\n   taken\
    \ automatically.  The application may initiate a change to the\n   stream's characteristics,\
    \ but it is not in the best position to do\n   this because the application may\
    \ not know the nature of the\n   bottleneck.  The ST layer may have the best information,\
    \ but a\n   mechanism to do this may be very complex.  As a result, this concept\n\
    \   requires further thought.\n   An agent simply discards a stream's data packets\
    \ if it cannot forward\n   them.  The reason may be that the packets are too large\
    \ or are\n   arriving at too high a rate.  Alternative actions may include an\n\
    \   attempt to do something with the packets, such as fragmenting them,\n   or\
    \ to notify the origin of the trouble.  Corrective measures may be\n   too complex,\
    \ so it may be preferable simply to notify the origin with\n   a NOTIFY message.\
    \  However, if the incoming packet rate is causing\n   congestion, then the NOTIFY\
    \ messages themselves may cause more\n   trouble.  The nature of the communication\
    \ has yet to be defined.\n   The FlowSpec includes a cost field, but its implementation\
    \ has not\n   been identified.  The units of cost can probably be defined\n  \
    \ relatively easily.  Cost of bandwidth can probably also be assigned.\n   It\
    \ is not clear how cost is assigned to other functions, such as high\n   precedence\
    \ or low delay, or how cost of the components of the stream\n   are combined together.\
    \  It is clear that the cost to provide services\n   will become more important\
    \ in the near future, but it is not clear at\n   this time how that cost is determined.\n\
    \   A number of parameters of the FlowSpec are intended to be used as\n   ranges,\
    \ but some may be useful as discrete values.  For example, the\n   FlowSpec may\
    \ specify that bandwidth for a stream carrying voice\n   should be reserved in\
    \ a range from 16Kbps to 64Kbps because the voice\n   codec has a variable coding\
    \ rate.  However, the voice codec may be\n   varied only among certain discrete\
    \ values, such as 16Kbps, 32Kbps and\n   64Kbps.  A stream that has 48Kbps of\
    \ bandwidth is no better than one\n   with 32Kbps.  The parameters of the FlowSpec\
    \ where this may be\n   relevant should optionally specify discrete values.  This\
    \ is being\n   considered.\n   Groups are defined as a way to associate different\
    \ streams, but the\n   nature of the association is left for further study.  An\
    \ example of\n   such an association is to allow streams whose traffic is inherently\n\
    \   not simultaneous to share the same allocated resources.  This may\n   happen\
    \ for example in a conference that has an explicit floor, such\n   that only one\
    \ site can generate video or audio traffic at any given\n   time.  The grouping\
    \ facility can be implemented based on this\n   specification, but the implementation\
    \ of the possible uses of groups\n   will require new functionality to be added\
    \ to the ST agents.  The\n   uses for groups and the implementation to support\
    \ them will be\n   carried out as experience is gained and the need arises.\n\
    \   We hope that the ST we here propose will act as a vehicle to study\n   the\
    \ use and performance of stream oriented services across packet\n   switched networks.\n\
    \                   [This page intentionally left blank.]\n"
- title: 6.      Glossary
  contents:
  - "6.      Glossary\n   appropriate reason code\n      This phrase refers to one\
    \ or perhaps a set of reason codes that\n      indicate why a particular action\
    \ is being taken.  Typically,\n      these result from detection of errors or\
    \ anomalous conditions.\n      It can also indicate that an application component\
    \ or agent has\n      presented invalid parameters.\n   DefaultRecoveryTimeout\n\
    \      The DefaultRecoveryTimeout is maintained by each ST agent.  It\n      indicates\
    \ the default time interval to use for sending HELLO\n      messages.\n   downstream\n\
    \      The direction in a stream from an origin toward its targets.\n   element\n\
    \      The fields and parameters of the ST control messages are\n      collectively\
    \ called elements.\n   FlowSpec\n      The Flow Specification, abbreviated \"\
    FlowSpec\" is used by an\n      application to specify required and desired characteristics\
    \ of\n      the stream.  The FlowSpec specifies bandwidth, delay, and\n      reliability\
    \ parameters.  Both minimal requirements and desired\n      characteristics are\
    \ included.  This information is then used to\n      guide route selection and\
    \ resource allocation decisions.  The\n      desired vs. required characteristics\
    \ are used to guide tradeoff\n      decisions among competing stream requests.\n\
    \   group\n      A set of related streams can be associated as a group.  This\
    \ is\n      done by generating a Group Name and assigning it to each of the\n\
    \      related streams.  The grouping information can then be used by\n      the\
    \ ST agents in making resource management and other control\n      decisions.\
    \  For example, when preemption is necessary to\n      establish a high precedence\
    \ stream, we can exploit the group\n      information to minimize the number of\
    \ stream groups that are\n      preempted.\n   Group Name\n      The Group Name\
    \ is used to indicate that a collection of streams\n      are related.  A Group\
    \ Name is structured to ensure that it is\n      unique across all hosts:  it\
    \ includes the address of the host\n      where it was generated combined with\
    \ a unique number generated\n      by that host.  A timestamp is added to ensure\
    \ that the overall\n      name is unique over all time.  (A Group Name has the\
    \ same format\n      as a stream Name.)\n   HelloLossFactor\n      The HelloLossFactor\
    \ is a parameter maintained by each ST agent.\n      It identifies the expected\
    \ number of consecutive HELLO messages\n      typically lost due to transient\
    \ factors.  Thus, an agent will be\n      assumed to be down after we miss more\
    \ than HelloLossFactor\n      messages.\n   HelloTimer\n      The HelloTimer is\
    \ a millisecond timer maintained by each ST\n      agent.  It is included in each\
    \ HELLO message.  It represents the\n      time since the agent was restarted,\
    \ modulo the precision of the\n      field.  It is used to detect variations in\
    \ the delay between the\n      two agents, by comparing the arrival interval of\
    \ two HELLO\n      messages to the difference between their HelloTimer fields.\n\
    \   HelloTimerHoldDown\n      The HelloTimerHoldDown value is maintained by each\
    \ ST agent.\n      When an ST agent is restarted, it will set the \"Restarted\"\
    \ bit\n      in all HELLO messages it sends for HelloTimerHoldDown seconds.\n\
    \   HID\n      The Hop IDentifier, abbreviated as HID, is a numeric key stored\n\
    \      in the header of each ST packet.  It is used by an ST agent to\n      associate\
    \ the packet with one of the incoming hops managed by\n      the agent.  It can\
    \ be used by receiving agent to map to\n      the set of outgoing next-hops to\
    \ which the message should be\n      forwarded.  The HID field of an ST packet\
    \ will generally need to\n      be changed as it passes through each ST agent\
    \ since there may be\n      many HIDs associated with a single stream.\n   hop\n\
    \      A \"hop\" refers to the portion of a stream's path between two\n      neighbor\
    \ ST agents.  It is usually represented by a physical\n      network.  However,\
    \ a multicast hop can connect a single ST agent\n      to several next-hop ST\
    \ agents.\n   host agents\n      Synonym for host ST agents.\n   host ST agents\n\
    \      Host ST agents are ST agents that provide services to higher\n      layer\
    \ protocols and applications.  The services include methods\n      for sourcing\
    \ data from and sinking data to the higher layer or\n      application, and methods\
    \ for requesting and modifying streams.\n   intermediate agents\n      Synonym\
    \ for intermediate ST agents.\n   intermediate ST agents\n      Intermediate ST\
    \ agents are ST agents that can forward ST\n      packets between the networks\
    \ to which they are attached.\n   MTU\n      The abbreviation for Maximum Transmission\
    \ Unit, which is the\n      maximum packet size in bytes that can be accepted\
    \ by a given\n      network for transmission.  ST agents determine the maximum\n\
    \      packet size for a stream so that data written to the stream can\n     \
    \ be forwarded through the networks without fragmentation.\n   multi-destination\
    \ simplex\n      The topology and data flow of ST streams are described as being\n\
    \      multi-destination simplex:  all data flowing on the stream\n      originates\
    \ from a single origin and is passed to one or more\n      destination targets.\
    \  Only control information, invisible to the\n      application program, ever\
    \ passes in the upstream direction.\n   NAccept\n      NAccept is an integer parameter\
    \ maintained by each ST agent.  It\n      is used to control retransmission of\
    \ an ACCEPT message.  Since\n      an ACCEPT request is relayed by agents back\
    \ toward the origin,\n      it must be acknowledged by each previous-hop agent.\
    \  If this ACK\n      is not received within the appropriate timeout interval,\
    \ the\n      request will be resent up to NAccept times before giving up.\n  \
    \ Name\n      Generally refers to the name of a stream.  A stream Name is\n  \
    \    structured to ensure that it is unique across all hosts: it\n      includes\
    \ the address of the host where it was generated combined\n      with a unique\
    \ number generated at that host.  A timestamp is\n      added to ensure that the\
    \ overall Name is unique over all time.\n      (A stream Name has the same format\
    \ as a Group Name.)\n   NConnect\n      NConnect is an integer parameter maintained\
    \ by each ST agent.\n      It is used to control retransmission of a CONNECT message.\
    \  A\n      CONNECT request must be acknowledged by each next-hop agent as\n \
    \     it is propagated toward the targets.  If a HID-ACCEPT,\n      HID-REJECT,\
    \ or ACK is not received for the CONNECT between any\n      two agents within\
    \ the appropriate timeout interval, the request\n      will be resent up to NConnect\
    \ times before giving up.\n   NDisconnect\n      NDisconnect is an integer parameter\
    \ maintained by each ST\n      agent.  It is used to control retransmission of\
    \ a DISCONNECT\n      message.  A DISCONNECT request must be acknowledged by each\n\
    \      next-hop agent as it is propagated toward the targets.  If this\n     \
    \ ACK is not received for the DISCONNECT between any two agents\n      within\
    \ the appropriate timeout interval, the request will be\n      resent up to NDisconnect\
    \ times before giving up.\n   next protocol identifier\n      The next protocol\
    \ identifier is used by a target ST agent to\n      identify to which of several\
    \ higher layer protocols it should\n      pass data packets it receives the network.\
    \  Examples of higher\n      layer protocols include the Network Voice Protocol\
    \ and the\n      Packet Video Protocol.  These higher layer protocols will\n \
    \     typically perform further demultiplexing among multiple\n      application\
    \ processes as part of their protocol processing\n      activities.\n   next-hop\n\
    \      Synonym for next-hop ST agent.\n   next-hop ST agent\n      For each origin\
    \ or intermediate ST agent managing a stream\n      there are a set of next-hop\
    \ ST agents.  The intermediate agent\n      forwards each data packet it receives\
    \ to all the next-hop ST\n      agents, which in turn forward the data toward\
    \ the target host\n      agent (if the particular next-hop agent is another intermediate\n\
    \      agent) or to the next higher protocol layer at the target (if\n      the\
    \ particular next-hop agent is a host agent).\n   NextPcol\n      NextPcol is\
    \ a field in each Target of the CONNECT message used\n      to convey the next\
    \ protocol identifier.  See definition of next\n      protocol identifier above\
    \ for more details.\n   NHIDAbort\n      NHIDAbort is an integer parameter maintained\
    \ by each ST agent.\n      It is the number of unacceptable HID proposals before\
    \ an ST\n      agent aborts the HID negotiation process.\n   NHIDAck\n      NHIDAck\
    \ is an integer parameter maintained by each ST agent.\n      It is used to control\
    \ retransmission of HID-CHANGE-REQUEST\n      messages.  HID-CHANGE-REQUEST is\
    \ sent by an ST agent to the\n      previous-hop ST agent to request that the\
    \ HID in use between\n      those agents be changed.  The previous-hop acknowledges\
    \ the\n      HID-CHANGE-REQUEST message by sending a HID-CHANGE message.  If\n\
    \      the HID-CHANGE is not received within the appropriate timeout\n      interval,\
    \ the request will be resent up to NHIDAck times before\n      giving up.\n  \
    \ NHIDChange\n      NHIDChange is an integer parameter maintained by each ST agent.\n\
    \      It is used to control retransmission of the HID-CHANGE message.\n     \
    \ A HID-CHANGE message must be acknowledged by the next-hop agent.\n      If this\
    \ ACK is not received within the appropriate timeout\n      interval, the request\
    \ will be resent up to NHIDChange times\n      before giving up.\n   NRefuse\n\
    \      NRefuse is an integer parameter maintained by each ST agent.\n      It\
    \ is used to control retransmission of a REFUSE message.  As a\n      REFUSE request\
    \ is relayed by agents back toward the origin, it\n      must be acknowledged\
    \ by each previous-hop agent.  If this ACK is\n      not received within the appropriate\
    \ timeout interval, the\n      request will be resent up to NRefuse times before\
    \ giving up.\n   NRetryRoute\n      NRetryRoute is an integer parameter maintained\
    \ by each ST\n      agent.  It is used to control route exploration.  When an\
    \ agent\n      receives a REFUSE message whose ReasonCode indicates that the\n\
    \      originally selected route is not acceptable, the agent should\n      attempt\
    \ to find an alternate route to the target.  If the agent\n      has not found\
    \ a viable route after a maximum of NRetryRoute\n      choices, it should give\
    \ up and notify the previous-hop or\n      application that it cannot find an\
    \ acceptable path to the\n      target.\n   origin\n      The origin of a stream\
    \ is the host agent where an application\n      or higher level protocol originally\
    \ requested that the stream be\n      created.  The origin specifies the data\
    \ to be sent through the\n      stream.\n   parameter\n      Parameters are additional\
    \ values that may be included in\n      control messages.  Parameters are often\
    \ optional.  They are\n      distinguished from fields, which are always present.\n\
    \   participants\n      Participants are the end-users of a stream.\n   PDU\n\
    \      Abbreviation for Protocol Data Unit, defined below.\n   peer\n      The\
    \ term peer is used to refer to entities at the same protocol\n      layer.  It\
    \ is used here to identify instances of an application\n      or protocol layer\
    \ above ST.  For example, data is passed through\n      a stream from an originating\
    \ peer process to its target peers.\n   previous-hop\n      Synonym for previous-hop\
    \ ST agent.\n   previous-hop ST agent\n      The origin or intermediate agent\
    \ from which an ST agent receives\n      its data.\n   protocol data unit\n  \
    \    A protocol data unit (PDU) is the unit of data passed to a\n      protocol\
    \ layer by the next higher layer protocol or user.  It\n      consists of control\
    \ information and possibly user data.\n   RecoveryTimeout\n      RecoveryTimeout\
    \ is specified in the FlowSpec of each stream.\n      The minimum of these values\
    \ over all streams between a pair of\n      adjacent agents determines how often\
    \ those agents must send\n      HELLO messages to each other in order to ensure\
    \ that failure of\n      one of the agents will be detected quickly enough to\
    \ meet the\n      guarantee implied by the FlowSpec.\n   Restarted bit\n     \
    \ The Restarted bit is part of the HELLO message.  When set, it\n      indicates\
    \ that the sending agent was restarted recently (within\n      the last HelloTimerHoldDown\
    \ seconds).\n   round-trip time\n      The round-trip-time is the time it takes\
    \ a message to be sent,\n      delivered, processed, and the acknowledgment received.\
    \  It\n      includes both network and processing delays.\n   RTT\n      Abbreviation\
    \ for round-trip-time.\n   RVLId\n      Abbreviation for Receiver's Virtual Link\
    \ Identifier.  It\n      uniquely identifies to the receiver the virtual link,\
    \ and this\n      stream, used to send it a message.  See definition for Virtual\n\
    \      Link Identifier below.\n   SAP\n      Abbreviation for Service Access Point.\n\
    \   SCMP\n      Abbreviation for ST Control Message Protocol, defined below.\n\
    \   Service Access Point\n      A point where a protocol service provider makes\
    \ available the\n      services it offers to a next higher layer protocol or user.\n\
    \   setup phase\n      Before data can be transmitted through a stream, the ST\
    \ agents\n      must distribute state information about the stream to all agents\n\
    \      along the path(s) to the target(s).  This is the setup phase.\n      The\
    \ setup phase ends when all the ACCEPT and REFUSE messages\n      sent by the\
    \ targets have been delivered to the origin.  At this\n      point, the data transfer\
    \ phase begins and data can be sent.\n      Requests to modify the stream can\
    \ be issued after the setup\n      phase has ended, i.e., during the data transfer\
    \ phase without\n      disrupting the flow of data.\n   ST agent\n      An ST\
    \ agent is an entity that implements the ST Protocol.\n   ST Control Message Protocol\n\
    \      The ST Control Message Protocol is the subset of the overall ST\n     \
    \ Protocol responsible for creation, modification, maintenance,\n      and tear\
    \ down of a stream.  It also includes support for event\n      notification and\
    \ status monitoring.\n   stream\n      A stream is the basic object managed by\
    \ the ST Protocol for\n      transmission of data.  A stream has one origin where\
    \ data are\n      generated and one or more targets where the data are received\n\
    \      for processing.  A flow specification, provided by the origin\n      and\
    \ negotiated among the origin, intermediate, and target ST\n      agents, identifies\
    \ the requirements of the application and the\n      guarantees that can be assured\
    \ by the ST agents.\n   subsets\n      Subsets of the ST Protocol are permitted,\
    \ as defined in various\n      sections of this specification.  Subsets are defined\
    \ to allow\n      simplified implementations that can still effectively\n    \
    \  interoperate with more complete implementations without causing\n      disruption.\n\
    \   SVLId\n      Abbreviation for Sender's Virtual Link Identifier.  It uniquely\n\
    \      identifies to the receiver the virtual link identifier that\n      should\
    \ be placed into the RVLId field of all replies sent over\n      the virtual link\
    \ for a given stream.  See definition for Virtual\n      Link Identifier below.\n\
    \   target\n      An ST target is the destination where data supplied by the\n\
    \      origin will be delivered for higher layer protocol or\n      application\
    \ processing.\n   tear down\n      The tear down phase of a stream begins when\
    \ the origin indicates\n      that it has no further data to send and the ST agents\
    \ through\n      which the stream passes should dismantle the stream and release\n\
    \      its resources.\n   ToAccept\n      ToAccept is a timeout in seconds maintained\
    \ by each ST agent.\n      It sets the retransmission interval for ACCEPT messages.\n\
    \   ToConnect\n      ToConnect is a timeout in seconds maintained by each ST agent.\n\
    \      It sets the retransmission interval a CONNECT messages.\n   ToDisconnect\n\
    \      ToDisconnect is a timeout in seconds maintained by each ST\n      agent.\
    \  It sets the retransmission interval for DISCONNECT\n      messages.\n   ToHIDAck\n\
    \      ToHIDAck is a timeout in seconds maintained by each ST agent.\n      It\
    \ sets the retransmission interval for HID-CHANGE-REQUEST\n      messages.\n \
    \  ToHIDChange\n      ToHIDChange is a timeout in seconds maintained by each ST\
    \ agent.\n      It sets the retransmission interval for HID-CHANGE messages.\n\
    \   ToRefuse\n      ToRefuse is a timeout in seconds maintained by each ST agent.\n\
    \      It sets the retransmission interval for REFUSE messages.\n   upstream\n\
    \      The direction in a stream from a target toward the origin.\n   Virtual\
    \ Link\n      A virtual link is one edge of the tree describing the path of\n\
    \      data flow through a stream.  A separate virtual link is assigned\n    \
    \  to each pair of neighbor ST agents, even when multiple next-hops\n      are\
    \ be reached through a single network level multicast group.\n      The virtual\
    \ link allows efficient demultiplexing of ST Control\n      Message PDUs received\
    \ from a single physical link or network.\n   Virtual Link Identifier\n      For\
    \ each ST Control Message sent, the sender provides its own\n      virtual link\
    \ identifier and that of the receiver (if known).\n      Either of these identifiers,\
    \ combined with the address of the\n      corresponding host, can be used to identify\
    \ uniquely the virtual\n      control link to the agent.  However, virtual link\
    \ identifiers\n      are chosen by the associated agent so that the agent may\n\
    \      precisely identify the stream, state machine, and other protocol\n    \
    \  processing data elements managed by that agent, without regard\n      to the\
    \ source of the control message.  Virtual link identifiers\n      are not negotiated,\
    \ and do not change during the lifetime of a\n      stream.  They are discarded\
    \ when the stream is torn down.\n"
- title: 7.      References
  contents:
  - "7.      References\n   [1] Braden, B., Borman, D., and C. Partridge, \"Computing\
    \ the\n       Internet Checksum\", RFC 1071, USC/Information Sciences\n      \
    \ Institute, Cray Research, BBN Laboratories, September\n       1988.\n   [2]\
    \ Braden, R. (ed.), \"Requirements for Internet Hosts --\n       Communication\
    \ Layers\", RFC 1122, USC/Information Sciences\n       Institute, October 1989.\n\
    \   [3] Cheriton, D., \"VMTP: Versatile Message Transaction Protocol\n       Specification\"\
    , RFC 1045, Stanford University, February 1988.\n   [4] Cohen, D., \"A Network\
    \ Voice Protocol NVP-II\", USC/Information\n       Sciences Institute, April 1981.\n\
    \   [5] Cole, E., \"PVP - A Packet Video Protocol\", W-Note 28,\n       USC/Information\
    \ Sciences Institute, August 1981.\n   [6] Deering, S., \"Host Extensions for\
    \ IP Multicasting\", RFC 1112,\n       Stanford University, August 1989.\n   [7]\
    \ Edmond W., Seo K., Leib M., and C. Topolcic, \"The DARPA\n       Wideband Network\
    \ Dual Bus Protocol\", accepted for presentation\n       at ACM SIGCOMM '90, September\
    \ 24-27, 1990.\n   [8] Forgie, J., \"ST - A Proposed Internet Stream Protocol\"\
    ,\n       IEN 119, M. I. T. Lincoln Laboratory, 7 September 1979.\n   [9] Jacobs\
    \ I., Binder R., and E. Hoversten E., \"General Purpose\n       Packet Satellite\
    \ Network\", Proc. IEEE, vol 66, pp 1448-1467,\n       November 1978.\n   [10]\
    \ Jacobson, V., \"Congestion Avoidance and Control\", ACM\n        SIGCOMM-88,\
    \ August 1988.\n   [11] Karn, P. and C. Partridge, \"Round Trip Time Estimation\"\
    ,\n        ACM SIGCOMM-87, August 1987.\n   [12] Mallory, T., and A. Kullberg,\
    \ \"Incremental Updating of the\n        Internet Checksum\", RFC 1141, BBN Communications\n\
    \        Corporation, January 1990.\n   [13] Mills, D., \"Network Time Protocol\
    \ (Version 2) Specification\n        and Implementation\", RFC 1119, University\
    \ of Delaware,\n        September 1989 (Revised February 1990).\n   [14] Pope,\
    \ A., \"The SIMNET Network and Protocols\", BBN\n        Report No. 7102, BBN\
    \ Systems and Technologies, July 1989.\n   [15] Postel, J., ed., \"Internet Protocol\
    \ - DARPA Internet Program\n        Protocol Specification\", RFC 791, DARPA,\
    \ September 1981.\n   [16] Postel, J., ed., \"Transmission Control Protocol -\
    \ DARPA\n        Internet Program Protocol Specification\", RFC 793, DARPA,\n\
    \        September 1981.\n   [17] Postel, J., \"User Datagram Protocol\", RFC\
    \ 768,\n        USC/Information Sciences Institute, August 1980.\n   [18] Reynolds,\
    \ J., Postel, J., \"Assigned Numbers\", RFC 1060,\n        USC/Information Sciences\
    \ Institute, March 1990.\n   [19] SDNS Protocol and Signaling Working Group, SP3\
    \ Sub-Group,\n        SDNS Secure Data Network System, Security Protocol 3 (SP3),\n\
    \        SDN.301, Rev. 1.5, 1989-05-15.\n   [20] SDNS Protocol and Signaling Working\
    \ Group, SP3 Sub-Group,\n        SDNS Secure Data Network System, Security Protocol\
    \ 3 (SP3)\n        Addendum 1, Cooperating Families, SDN.301.1, Rev. 1.2,\n  \
    \      1988-07-12.\n"
- title: 8.      Security Considerations
  contents:
  - "8.      Security Considerations\n   See section 3.7.8.\n"
- title: 9.      Authors' Addresses
  contents:
  - "9.      Authors' Addresses\n      Stephen Casner\n      USC/Information Sciences\
    \ Institute\n      4676 Admiralty Way\n      Marina del Rey, CA 90292-6695\n \
    \     Phone: (213) 822-1511 x153\n      EMail: Casner@ISI.Edu\n      Charles Lynn,\
    \ Jr.\n      BBN Systems and Technologies,\n      a division of Bolt Beranek and\
    \ Newman Inc.\n      10 Moulton Street\n      Cambridge, MA  02138\n      Phone:\
    \ (617) 873-3367\n      EMail: CLynn@BBN.Com\n      Philippe Park\n      BBN Systems\
    \ and Technologies,\n      a division of Bolt Beranek and Newman Inc.\n      10\
    \ Moulton Street\n      Cambridge, MA  02138\n      Phone: (617) 873-2892\n  \
    \    EMail: ppark@BBN.COM\n      Kenneth Schroder\n      BBN Systems and Technologies,\n\
    \      a division of Bolt Beranek and Newman Inc.\n      10 Moulton Street\n \
    \     Cambridge, MA  02138\n      Phone: (617) 873-3167\n      EMail: Schroder@BBN.Com\n\
    \      Claudio Topolcic\n      BBN Systems and Technologies,\n      a division\
    \ of Bolt Beranek and Newman Inc.\n      10 Moulton Street\n      Cambridge, MA\
    \  02138\n      Phone: (617) 873-3874\n      EMail: Topolcic@BBN.Com\n       \
    \            [This page intentionally left blank.]\n"
- title: Appendix 1.      Data Notations
  contents:
  - "Appendix 1.      Data Notations\n   The convention in the documentation of Internet\
    \ Protocols is to\n   express numbers in decimal and to picture data with the\
    \ most\n   significant octet on the left and the least significant octet on the\n\
    \   right.\n   The order of transmission of the header and data described in this\n\
    \   document is resolved to the octet level.  Whenever a diagram shows a\n   group\
    \ of octets, the order of transmission of those octets is the\n   normal order\
    \ in which they are read in English.  For example, in the\n   following diagram\
    \ the octets are transmitted in the order they are\n   numbered.\n    0      \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       1       |       2       |       3       |       4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       5       |       6       |       7       |       8       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       9       |      10       |      11       |      12       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 56.  Transmission Order of Bytes\n   Whenever an octet\
    \ represents a numeric quantity the left most bit in\n   the diagram is the high\
    \ order or most significant bit.  That is, the\n   bit labeled 0 is the most significant\
    \ bit.  For example, the\n   following diagram represents the value 170 (decimal).\n\
    \                            0 1 2 3 4 5 6 7\n                           +-+-+-+-+-+-+-+-+\n\
    \                           |1 0 1 0 1 0 1 0|\n                           +-+-+-+-+-+-+-+-+\n\
    \                    Figure 57.  Significance of Bits\n   Similarly, whenever\
    \ a multi-octet field represents a numeric quantity\n   the left most bit of the\
    \ whole field is the most significant bit.\n   When a multi-octet quantity is\
    \ transmitted the most significant octet\n   is transmitted first.\n   Fields\
    \ whose length is fixed and fully illustrated are shown with a\n   vertical bar\
    \ (|) at the end;  fixed fields whose contents are\n   abbreviated are shown with\
    \ an exclamation point (!);  variable fields\n   are shown with colons (:).\n\
    \   Optional parameters are separated from control messages with a blank\n   line.\
    \  The order of any optional parameters is not meaningful.\n"
