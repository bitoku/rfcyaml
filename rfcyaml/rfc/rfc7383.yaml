- contents:
  - ' Internet Key Exchange Protocol Version 2 (IKEv2) Message Fragmentation

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a way to avoid IP fragmentation of large\n
    \  Internet Key Exchange Protocol version 2 (IKEv2) messages.  This\n   allows
    IKEv2 messages to traverse network devices that do not allow\n   IP fragments
    to pass through.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7383.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \     1.1. Problem Description ........................................2\n      1.2.
    Proposed Solution ..........................................3\n      1.3. Conventions
    Used in This Document ..........................4\n   2. Protocol Details ................................................4\n
    \     2.1. Overview ...................................................4\n      2.2.
    Limitations ................................................4\n      2.3. Negotiation
    ................................................5\n      2.4. Using IKE Fragmentation
    ....................................5\n      2.5. Fragmenting Message ........................................6\n
    \          2.5.1. Selecting Fragment Size .............................8\n           2.5.2.
    PMTU Discovery ......................................9\n           2.5.3. Fragmenting
    Messages Containing Unprotected\n                  Payloads ...........................................11\n
    \     2.6. Receiving IKE Fragment Message ............................11\n           2.6.1.
    Replay Detection and Retransmissions ...............13\n   3. Interaction with
    Other IKE Extensions ..........................14\n   4. Transport Considerations
    .......................................14\n   5. Security Considerations ........................................15\n
    \  6. IANA Considerations ............................................16\n   7.
    References .....................................................16\n      7.1.
    Normative References ......................................16\n      7.2. Informative
    References ....................................16\n   Appendix A. Design Rationale
    ......................................19\n   Appendix B. Correlation between IP
    Datagram Size and Encrypted\n               Payload Content Size ..................................19\n
    \  Acknowledgements ..................................................20\n   Author's
    Address ..................................................20\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Problem Description\n   The Internet Key Exchange Protocol version 2
      (IKEv2), specified in\n   [RFC7296], uses UDP as a transport for its messages.
      \ Most IKEv2\n   messages are relatively small, usually below several hundred
      bytes.\n   A notable exception is the IKE_AUTH exchange, which requires fairly\n
      \  large messages, up to several KB, especially when certificates are\n   transferred.
      \ When the IKE message size exceeds the path MTU, it gets\n   fragmented at
      the IP level.  The problem is that some network\n   devices, specifically some
      NAT boxes, do not allow IP fragments to\n   pass through.  This apparently blocks
      IKE communication and,\n   therefore, prevents peers from establishing an IPsec
      Security\n   Association (SA).  Section 2 of [RFC7296] discusses the impact
      of IP\n   fragmentation on IKEv2 and acknowledges this problem.\n   Widespread
      deployment of Carrier-Grade NATs (CGNs) introduces new\n   challenges.  [RFC6888]
      describes requirements for CGNs.  It states\n   that CGNs must comply with Section
      11 of [RFC4787], which requires\n   NATs to support receiving IP fragments (REQ-14).
      \ In real life,\n   fulfillment of this requirement creates an additional burden
      in terms\n   of memory, especially for high-capacity devices used in CGNs.  It
      was\n   found by people deploying IKE that more and more ISPs use equipment\n
      \  that drops IP fragments, thereby violating this requirement.\n   Security
      researchers have found, and continue to find, attack vectors\n   that rely on
      IP fragmentation.  For these reasons, and also as\n   articulated in [FRAGDROP],
      many network operators filter all IPv6\n   fragments.  Also, the default behavior
      of many currently deployed\n   firewalls is to discard IPv6 fragments.\n   In
      one recent study [BLACKHOLES], two researchers utilized a\n   measurement network
      to measure fragment filtering.  They sent\n   packets, fragmented to the minimum
      MTU of 1280, to 502 IPv6-enabled\n   and reachable probes.  They found that
      during any given trial period,\n   ten percent of the probes did not receive
      fragmented packets.\n   Thus, this problem is valid for both IPv4 and IPv6 and
      may be caused\n   by either deficiency of network devices or operational choice.\n"
    title: 1.1.  Problem Description
  - contents:
    - "1.2.  Proposed Solution\n   The solution to the problem described in this document
      is to perform\n   fragmentation of large messages by IKEv2 itself and replace
      them with\n   a series of smaller messages.  In this case, the resulting IP\n
      \  datagrams will be small enough so that no fragmentation at the IP\n   level
      will take place.\n   The primary goal of this solution is to allow IKEv2 to
      operate in\n   environments that might block IP fragments.  This goal does not\n
      \  assume that IP fragmentation should be avoided completely, but only\n   in
      those cases when it interferes with IKE operations.  However, this\n   solution
      could be used to avoid IP fragmentation in all situations\n   where fragmentation
      within IKE is applicable, as recommended in\n   Section 3.2 of [RFC5405].  Avoiding
      IP fragmentation would be\n   beneficial for IKEv2 in general.  The Security
      Considerations section\n   of [RFC7296] mentions exhaustion of the IP reassembly
      buffers as one\n   of the possible attacks on the protocol.  In [DOSUDPPROT],
      several\n   aspects of attacks on IKE using IP fragmentation are discussed,
      and\n   one of the defenses it proposes is to perform fragmentation within\n
      \  IKE, similar to the solution described in this document.\n"
    title: 1.2.  Proposed Solution
  - contents:
    - "1.3.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [RFC2119].\n"
    title: 1.3.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - '2.  Protocol Details

    '
  - contents:
    - "2.1.  Overview\n   The idea of the protocol described in this document is to
      split large\n   IKEv2 messages into a set of smaller ones, called IKE Fragment\n
      \  messages.  Fragmentation takes place before the original message is\n   encrypted
      and authenticated, so that each IKE Fragment message\n   receives individual
      protection.  On the receiving side, IKE Fragment\n   messages are collected,
      verified, decrypted, and merged together to\n   get the original message before
      encryption.  See Appendix A for\n   details on design rationale.\n"
    title: 2.1.  Overview
  - contents:
    - "2.2.  Limitations\n   Since IKE Fragment messages are cryptographically protected,
      SK_a and\n   SK_e must already be calculated.  In general, it means that the\n
      \  original message can be fragmented if and only if it contains an\n   Encrypted
      payload.\n   This implies that messages of the IKE_SA_INIT exchange cannot be\n
      \  fragmented.  In most cases, this is not a problem because IKE_SA_INIT\n   messages
      are usually small enough to avoid IP fragmentation.  But in\n   some cases (advertising
      a badly structured long list of algorithms,\n   using large Modular Exponentiation
      (MODP) groups, etc.), these\n   messages may become fairly large and get fragmented
      at the IP level.\n   In this case, the solution described in this document will
      not help.\n   Among existing IKEv2 extensions, messages of an IKE_SESSION_RESUME\n
      \  exchange, as defined in [RFC5723], cannot be fragmented either.  See\n   Section
      3 for details.\n   Another limitation is that the minimum size of an IP datagram
      bearing\n   an IKE Fragment message is about 100 bytes, depending on the\n   algorithms
      employed.  According to [RFC0791], the minimum IPv4\n   datagram size that is
      guaranteed not to be further fragmented is\n   68 bytes.  So, even the smallest
      IKE Fragment messages could be\n   fragmented at the IP level in some circumstances.
      \ But such extremely\n   small Path MTU (PMTU) sizes are very rare in real life.\n"
    title: 2.2.  Limitations
  - contents:
    - "2.3.  Negotiation\n   The initiator indicates its support for IKE fragmentation
      and\n   willingness to use it by including a Notification payload of type\n
      \  IKEV2_FRAGMENTATION_SUPPORTED in the IKE_SA_INIT request message.  If\n   the
      responder also supports this extension and is willing to use it,\n   it includes
      this notification in the response message.\n   Initiator                   Responder\n
      \  -----------                 -----------\n   HDR, SAi1, KEi, Ni,\n      [N(IKEV2_FRAGMENTATION_SUPPORTED)]
      \ -->\n                       <--   HDR, SAr1, KEr, Nr, [CERTREQ],\n                                  [N(IKEV2_FRAGMENTATION_SUPPORTED)]\n
      \  The Notify payload is formatted as follows:\n                        1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  o  Protocol ID (1 octet) - MUST be 0.\n   o  SPI Size (1 octet) - MUST be
      0, meaning no Security Parameter\n      Index (SPI) is present.\n   o  Notify
      Message Type (2 octets) - MUST be 16430, the value assigned\n      for the IKEV2_FRAGMENTATION_SUPPORTED
      notification.\n   This notification contains no data.\n"
    title: 2.3.  Negotiation
  - contents:
    - "2.4.  Using IKE Fragmentation\n   IKE fragmentation MUST NOT be used unless
      both peers have indicated\n   their support for it.  After that, it is up to
      the initiator of each\n   exchange to decide whether or not to use it.  The
      responder usually\n   replies in the same form as the request message, but other\n
      \  considerations might override this.\n   The initiator can employ various
      policies regarding the use of IKE\n   fragmentation.  It might first try to
      send an unfragmented message\n   and resend it as fragmented only if no complete
      response is received\n   even after several retransmissions.  Alternatively,
      it might choose\n   to always send fragmented messages (however, see Section
      3), or it\n   might fragment only large messages and messages that are expected
      to\n   result in large responses.\n   The following general guidelines apply:\n
      \  o  If either peer has information that a part of the transaction is\n      likely
      to be fragmented at the IP layer, causing interference with\n      the IKE exchange,
      that peer SHOULD use IKE fragmentation.  This\n      information might be passed
      from a lower layer, provided by\n      configuration, or derived through heuristics.
      \ Examples of\n      heuristics are the lack of a complete response after several\n
      \     retransmissions for the initiator, and receiving repeated\n      retransmissions
      of the request for the responder.\n   o  If either peer knows that IKE fragmentation
      has been used in a\n      previous exchange in the context of the current IKE
      SA, that peer\n      SHOULD continue to use IKE fragmentation for the messages
      that are\n      larger than the current fragmentation threshold (see\n      Section
      2.5.1).\n   o  IKE fragmentation SHOULD NOT be used in cases where IP-layer\n
      \     fragmentation of both the request and response messages is\n      unlikely.
      \ For example, there is no point in fragmenting liveness\n      check messages.\n
      \  o  If none of the above apply, the responder SHOULD respond in the\n      same
      form (fragmented or not) as the request message to which it\n      is responding.
      \ Note that the other guidelines might override this\n      because of information
      or heuristics available to the responder.\n   In most cases, IKE fragmentation
      will be used in the IKE_AUTH\n   exchange, especially if certificates are employed.\n"
    title: 2.4.  Using IKE Fragmentation
  - contents:
    - "2.5.  Fragmenting Message\n   Only messages that contain an Encrypted payload
      are subject to IKE\n   fragmentation.  For the purpose of construction of IKE
      Fragment\n   messages, the original (unencrypted) content of the Encrypted payload\n
      \  is split into chunks.  The content is treated as a binary blob and is\n   split
      regardless of the boundaries of inner payloads.  Each of the\n   resulting chunks
      is treated as an original content of the Encrypted\n   Fragment payload and
      is then encrypted and authenticated.  Thus, the\n   Encrypted Fragment payload
      contains a chunk of the original content\n   of the Encrypted payload in encrypted
      form.  The cryptographic\n   processing of the Encrypted Fragment payload is
      identical to that\n   described in Section 3.14 of [RFC7296], as well as documents
      updating\n   such processing for particular algorithms or modes, such as\n   [RFC5282].\n
      \  As is the case for the Encrypted payload, the Encrypted Fragment\n   payload,
      if present in a message, MUST be the last payload in the\n   message.\n   The
      Encrypted Fragment payload is denoted SKF{...}, and its payload\n   type is
      53.  This payload is also called the \"Encrypted and\n   Authenticated Fragment\"
      payload.\n                        1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |        Fragment Number        |        Total Fragments        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                     Initialization Vector                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ~                      Encrypted content                        ~\n   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |               |             Padding (0-255 octets)            |\n   +-+-+-+-+-+-+-+-+
      \                              +-+-+-+-+-+-+-+-+\n   |                                               |
      \ Pad Length   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ~                    Integrity Checksum Data                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                       Encrypted Fragment Payload\n   o  Next Payload (1 octet)
      - in the very first fragment (with Fragment\n      Number equal to 1), this
      field MUST be set to the payload type of\n      the first inner payload (the
      same as for the Encrypted payload).\n      In the rest of the Fragment messages
      (with Fragment Number greater\n      than 1), this field MUST be set to zero.\n
      \  o  Fragment Number (2 octets, unsigned integer) - current Fragment\n      message
      number, starting from 1.  This field MUST be less than or\n      equal to the
      next field (Total Fragments).  This field MUST NOT be\n      zero.\n   o  Total
      Fragments (2 octets, unsigned integer) - number of Fragment\n      messages
      into which the original message was divided.  This field\n      MUST NOT be
      zero.  With PMTU discovery, this field plays an\n      additional role.  See
      Section 2.5.2 for details.\n   The other fields are identical to those specified
      in Section 3.14 of\n   [RFC7296].\n   When prepending the IKE header to the
      IKE Fragment messages, it MUST\n   be taken intact from the original message,
      except for the Length and\n   Next Payload fields.  The Length field is adjusted
      to reflect the\n   length of the IKE Fragment message being constructed, and
      the Next\n   Payload field is set to the payload type of the first payload in
      that\n   message (in most cases, it will be the Encrypted Fragment payload).\n
      \  After prepending the IKE header and all payloads that possibly\n   precede
      the Encrypted payload in the original message (if any; see\n   Section 2.5.3),
      the resulting messages are sent to the peer.\n   Below is an example of fragmenting
      a message.\n   HDR(MID=n), SK(NextPld=PLD1) {PLD1 ... PLDN}\n                             Original
      Message\n   HDR(MID=n), SKF(NextPld=PLD1, Frag#=1, TotalFrags=m) {...},\n   HDR(MID=n),
      SKF(NextPld=0, Frag#=2, TotalFrags=m) {...},\n   ...\n   HDR(MID=n), SKF(NextPld=0,
      Frag#=m, TotalFrags=m) {...}\n                           IKE Fragment Messages\n"
    - contents:
      - "2.5.1.  Selecting Fragment Size\n   When splitting the content of an Encrypted
        payload into chunks, the\n   sender SHOULD choose their size so that the resulting
        IP datagrams\n   will be smaller than some fragmentation threshold.  Implementations\n
        \  may calculate the fragmentation threshold using various sources of\n   information.\n
        \  If the sender has information about the PMTU size, it SHOULD use it.\n
        \  The responder in the exchange may use the maximum size of the\n   received
        IKE Fragment message IP datagrams as a threshold when\n   constructing a fragmented
        response.  Successful completion of\n   previous exchanges (including those
        exchanges that cannot employ IKE\n   fragmentation, e.g., IKE_SA_INIT) may
        be an indication that the\n   fragmentation threshold can be set to the size
        of the largest message\n   of those messages already sent.\n   Otherwise,
        for messages to be sent over IPv6, it is RECOMMENDED that\n   a value of 1280
        bytes as a maximum IP datagram size be used\n   ([RFC2460]).  For messages
        to be sent over IPv4, it is RECOMMENDED\n   that a value of 576 bytes as a
        maximum IP datagram size be used.  The\n   presence of tunnels on the path
        may reduce these values.\n   Implementations may use other values if they
        are appropriate in the\n   current environment.\n   According to [RFC0791],
        the minimum IPv4 datagram size that is\n   guaranteed not to be further fragmented
        is 68 bytes, but it is\n   generally impossible to use such a small value
        for the solution\n   described in this document.  Using 576 bytes is a compromise
        -- the\n   value is large enough for the presented solution and small enough
        to\n   avoid IP fragmentation in most situations.  Several other UDP-based\n
        \  protocols (Syslog, DNS, etc.) use 576 bytes as a safe low limit for\n   IP
        datagram size.\n   See Appendix B for correlation between IP datagram size
        and Encrypted\n   payload content size.\n"
      title: 2.5.1.  Selecting Fragment Size
    - contents:
      - "2.5.2.  PMTU Discovery\n   The amount of traffic that the IKE endpoint produces
        during the\n   lifetime of an IKE SA is fairly modest -- it is usually below
        100 KB\n   within a period of several hours.  Most of this traffic consists
        of\n   relatively short messages -- usually below several hundred bytes.  In\n
        \  most cases, the only time when IKE endpoints exchange messages of\n   several
        KB in size is IKE SA establishment, and often each endpoint\n   sends exactly
        one such message.\n   For the reasons articulated above, implementing PMTU
        discovery in IKE\n   is OPTIONAL.  It is believed that using the values recommended
        in\n   Section 2.5.1 as a fragmentation threshold will be sufficient in most\n
        \  cases.  Using these values could lead to suboptimal fragmentation,\n   but
        it is acceptable given the amount of traffic IKE produces.\n   Implementations
        may support PMTU discovery if there are good reasons\n   to do it (for example,
        if they are intended to be used in\n   environments where the MTU size might
        be less than the values listed\n   in Section 2.5.1).\n   PMTU discovery in
        IKE follows recommendations given in Section 10.4\n   of [RFC4821] with some
        modifications, induced by the distinctive\n   features of IKE listed above.
        \ The difference is that the PMTU search\n   is performed downward, while
        in [RFC4821] it is performed upward.\n   The reason for this change is that
        IKE usually sends large messages\n   only when the IKE SA is being established,
        and in many cases there is\n   only one such message.  If the probing were
        performed upward, this\n   message would be fragmented using the smallest
        allowable threshold,\n   and usually all other messages are small enough to
        avoid IP\n   fragmentation, so continued probing would be of little value.\n
        \  It is the initiator of the exchange who performs PMTU discovery.\n   This
        is done by probing several values of fragmentation threshold.\n   Implementations
        MUST be prepared to probe in every exchange that\n   utilizes IKE fragmentation
        to deal with possible changes in path MTU\n   over time.  While doing probes,
        it MUST start from larger values and\n   refragment the original message,
        using the next smaller value of the\n   threshold if it did not receive a
        response in a reasonable time after\n   several retransmissions.  The exact
        number of retransmissions and\n   length of timeouts are not covered in this
        specification because they\n   do not affect interoperability.  However, the
        timeout interval is\n   supposed to be relatively short, so that unsuccessful
        probes would\n   not delay IKE operations too much.  Performing a few retries
        within\n   several seconds for each probe seems appropriate, but different\n
        \  environments may require different rules.  When starting a new probe,\n
        \  the node MUST reset its retransmission timers so that if it employs\n   exponential
        back-off the timers will start over.  After reaching the\n   smallest allowed
        value for the fragmentation threshold, an\n   implementation MUST continue
        retransmitting until the exchange either\n   completes or times out using
        some timeout interval as discussed in\n   Section 2.4 of [RFC7296].\n   PMTU
        discovery in IKE is supposed to be coarse-grained, i.e., it is\n   expected
        that a node will try only a few fragmentation thresholds in\n   order to minimize
        delays caused by unsuccessful probes.  If path MTU\n   information is not
        yet available, the endpoint may use the link MTU\n   size when it starts probing.
        \ In subsequent exchanges, the node\n   should start with the current value
        of the fragmentation threshold.\n   If an implementation is capable of receiving
        ICMP error messages, it\n   can additionally utilize classic PMTU discovery
        methods, as described\n   in [RFC1191] and [RFC1981].  In particular, if the
        initiator receives\n   a Packet Too Big error in response to the probe, and
        it contains a\n   smaller value than the current fragmentation threshold,
        then the\n   initiator SHOULD stop retransmitting the probe and SHOULD select
        a\n   new value for the fragmentation threshold that is less than or equal\n
        \  to the value from the ICMP message and meets the requirements listed\n
        \  below.\n   In the case of PMTU discovery, the Total Fragments field is
        used to\n   distinguish between different sets of fragments, i.e., the sets
        that\n   were created by fragmenting the original message using different\n
        \  fragmentation thresholds.  Since the sender starts from larger\n   fragments
        and then makes them smaller, the value in the Total\n   Fragments field increases
        with each new probe.  When selecting the\n   next smaller value for the fragmentation
        threshold, the sender MUST\n   ensure that the value in the Total Fragments
        field is really\n   increased.  This requirement should not be a problem for
        the sender,\n   because PMTU discovery in IKE is supposed to be coarse-grained,
        so\n   the difference between previous and next fragmentation thresholds\n
        \  should be significant anyway.  The need to distinguish between the\n   sets
        is vital for the receiver, since receiving a valid fragment from\n   a newer
        set means that it has to start the reassembly process over\n   and not mix
        fragments from different sets.\n"
      title: 2.5.2.  PMTU Discovery
    - contents:
      - "2.5.3.  Fragmenting Messages Containing Unprotected Payloads\n   Currently,
        there are no IKEv2 exchanges that define messages,\n   containing both unprotected
        payloads and payloads, that are protected\n   by the Encrypted payload.  However,
        IKEv2 does not prohibit such\n   construction.  If some future IKEv2 extension
        defines such a message\n   and it needs to be fragmented, all unprotected
        payloads MUST be\n   placed in the first fragment (with the Fragment Number
        field equal to\n   1), along with the Encrypted Fragment payload, which MUST
        be present\n   in every IKE Fragment message and be the last payload in it.\n
        \  Below is an example of a fragmenting message that contains both\n   protected
        and unprotected payloads.\n   HDR(MID=n), PLD0, SK(NextPld=PLD1) {PLD1 ...
        PLDN}\n                             Original Message\n   HDR(MID=n), PLD0,
        SKF(NextPld=PLD1, Frag#=1, TotalFrags=m) {...},\n   HDR(MID=n), SKF(NextPld=0,
        Frag#=2, TotalFrags=m) {...},\n   ...\n   HDR(MID=n), SKF(NextPld=0, Frag#=m,
        TotalFrags=m) {...}\n                           IKE Fragment Messages\n   Note
        that the size of each IP datagram bearing IKE Fragment messages\n   should
        not exceed the fragmentation threshold, including the first\n   one, that
        contains unprotected payloads.  This will reduce the size\n   of the Encrypted
        Fragment payload content in the first IKE Fragment\n   message to accommodate
        all unprotected payloads.  In an extreme case,\n   the Encrypted Fragment
        payload will contain no data, but it still\n   must be present in the message,
        because only its presence allows the\n   receiver to determine that the sender
        has used IKE fragmentation.\n"
      title: 2.5.3.  Fragmenting Messages Containing Unprotected Payloads
    title: 2.5.  Fragmenting Message
  - contents:
    - "2.6.  Receiving IKE Fragment Message\n   The receiver identifies the IKE Fragment
      message by the presence of\n   an Encrypted Fragment payload in it.  In most
      cases, it will be the\n   first and only payload in the message; however, this
      may not be true\n   for some hypothetical IKE exchanges (see Section 2.5.3).\n
      \  Upon receiving the IKE Fragment message, the following actions are\n   performed:\n
      \  o  Check message validity - in particular, check whether the values\n      in
      the Fragment Number and the Total Fragments fields in the\n      Encrypted Fragment
      payload are valid.  The following tests need to\n      be performed.\n      *
      \ check that the Fragment Number and the Total Fragments fields\n         contain
      non-zero values\n      *  check that the value in the Fragment Number field
      is less than\n         or equal to the value in the Total Fragments field\n
      \     *  if reassembling has already started, check that the value in\n         the
      Total Fragments field is equal to or greater than the Total\n         Fragments
      field in the fragments that have already been stored\n         in the reassembling
      queue\n      If any of these tests fail, the message MUST be silently\n      discarded.\n
      \  o  Check that this IKE Fragment message is new for the receiver and\n      not
      a replay.  If an IKE Fragment message with the same Message\n      ID, Fragment
      Number, and Total Fragments fields is already present\n      in the reassembling
      queue, this message is considered a replay and\n      MUST be silently discarded.\n
      \  o  Verify IKE Fragment message authenticity by checking the Integrity\n      Check
      Value (ICV) in the Encrypted Fragment payload.  If the ICV\n      check fails,
      the message MUST be silently discarded.\n   o  If reassembling is not finished
      yet and the Total Fragments field\n      in the received fragment is greater
      than the Total Fragments field\n      in those fragments that are in the reassembling
      queue, the\n      receiver MUST discard all received fragments and start the\n
      \     reassembly process over with just the received IKE Fragment\n      message.\n
      \  o  Store the message in the reassembling queue waiting for the rest\n      of
      the fragments to arrive.\n   When all IKE Fragment messages (as indicated in
      the Total Fragments\n   field) are received, the decrypted content of all Encrypted
      Fragment\n   payloads is merged together to form the content of the original\n
      \  Encrypted payload and, therefore, along with the IKE header and\n   unprotected
      payloads (if any), the original message.  Then, it is\n   processed as if it
      was received, verified, and decrypted as a regular\n   IKE message.\n   If the
      receiver does not get all IKE fragments needed to reassemble\n   the original
      message within a timeout interval, it MUST discard all\n   IKE Fragment messages
      received so far for the exchange.  The next\n   actions depend on the role of
      the receiver in the exchange.\n   o  The initiator acts as described in Section
      2.1 of [RFC7296].  It\n      either retransmits the fragmented request message
      or deems the IKE\n      SA to have failed and deletes it.  The number of retransmits
      and\n      length of timeouts for the initiator are not covered in this\n      specification,
      since they are assumed to be the same as in a\n      regular IKEv2 exchange
      and are discussed in Section 2.4 of\n      [RFC7296].\n   o  The responder in
      this case acts as if no request message was\n      received.  It would delete
      any memory of the incomplete request\n      message and not treat it as an IKE
      SA failure.  It is RECOMMENDED\n      that the reassembling timeout for the
      responder be equal to the\n      time interval that the implementation waits
      before completely\n      giving up when acting as the initiator of an exchange.\n
      \     Section 2.4 of [RFC7296] gives recommendations for selecting this\n      interval.
      \ Implementations can use a shorter timeout to conserve\n      memory.\n"
    - contents:
      - "2.6.1.  Replay Detection and Retransmissions\n   According to Section 2.2
        of [RFC7296], the Message ID is used, in\n   particular, to identify retransmissions
        of IKE messages.  Each\n   request or response message, sent by either side,
        must have a unique\n   Message ID, or be considered a retransmission otherwise.
        \ This logic\n   has already been updated by [RFC6311], which deliberately
        allows any\n   number of messages with zero Message ID.  This document also
        updates\n   this logic for those situations where IKE fragmentation is in
        use.\n   If an incoming message contains an Encrypted Fragment payload, the\n
        \  values of the Fragment Number and Total Fragments fields MUST be used\n
        \  along with the Message ID to detect retransmissions and replays.\n   If
        the responder receives a retransmitted fragment of a request when\n   it has
        already processed that request and has sent back a response,\n   that event
        MUST only trigger a retransmission of the response message\n   (fragmented
        or not) if the Fragment Number field in the received\n   fragment is set to
        1; otherwise, it MUST be ignored.\n"
      title: 2.6.1.  Replay Detection and Retransmissions
    title: 2.6.  Receiving IKE Fragment Message
  title: 2.  Protocol Details
- contents:
  - "3.  Interaction with Other IKE Extensions\n   IKE fragmentation is compatible
    with most IKE extensions, such as IKE\n   Session Resumption ([RFC5723]), the
    Quick Crash Detection Method\n   ([RFC6290]), and so on.  It neither affects their
    operation nor is\n   affected by them.  It is believed that IKE fragmentation
    will also be\n   compatible with future IKE extensions, if they follow general\n
    \  principles of formatting, sending, and receiving IKE messages, as\n   described
    in [RFC7296].\n   When IKE fragmentation is used with IKE Session Resumption\n
    \  ([RFC5723]), messages of an IKE_SESSION_RESUME exchange cannot be\n   fragmented,
    since they do not contain an Encrypted payload.  These\n   messages may be large
    due to the ticket size.  To avoid IP\n   fragmentation in this situation, it is
    recommended that smaller\n   tickets be used, e.g., by utilizing a \"ticket by
    reference\" approach\n   instead of \"ticket by value\".\n   Protocol Support
    for High Availability of IKEv2/IPsec, described in\n   [RFC6311], requires special
    care when deciding whether to fragment an\n   IKE message or not.  Since it deliberately
    allows any number of\n   synchronization exchanges to have the same Message ID,
    namely zero,\n   standard IKEv2 replay detection logic, based on checking the
    Message\n   ID, is not applicable for such messages, and the receiver has to\n
    \  check message content to detect replays.  When implementing IKE\n   fragmentation
    along with [RFC6311], IKE Message ID Synchronization\n   messages MUST NOT be
    sent fragmented, to simplify the receiver's task\n   of detecting replays.  Fortunately,
    these messages are small, and\n   there is no point in fragmenting them anyway.\n"
  title: 3.  Interaction with Other IKE Extensions
- contents:
  - "4.  Transport Considerations\n   With IKE fragmentation, if any single IKE Fragment
    message gets lost,\n   the receiver becomes unable to reassemble the original
    message.  So,\n   in general, using IKE fragmentation implies a higher probability
    that\n   the message will not be delivered to the peer.  Although in most\n   network
    environments the difference will be insignificant, on some\n   lossy networks
    it may become noticeable.  When using IKE\n   fragmentation, implementations MAY
    use longer timeouts and do more\n   retransmits than usual before considering
    the peer dead.\n   Note that Fragment messages are not individually acknowledged.
    \ The\n   response Fragment messages are all sent back together only when all\n
    \  fragments of the request are received, and the original request\n   message
    is reassembled and successfully processed.\n"
  title: 4.  Transport Considerations
- contents:
  - "5.  Security Considerations\n   Most of the security considerations for IKE fragmentation
    are the\n   same as those for the base IKEv2 protocol described in [RFC7296].\n
    \  This extension introduces the Encrypted Fragment payload to protect\n   the
    content of an IKE Message Fragment.  This allows the receiver to\n   individually
    check the authenticity of fragments, thus protecting\n   peers from a DoS attack.\n
    \  The Security Considerations section of [RFC7296] mentions a possible\n   attack
    on IKE where an attacker could prevent an exchange from\n   completing by exhausting
    the IP reassembly buffers.  The mechanism\n   described in this document allows
    IKE to avoid IP fragmentation and\n   therefore increases its robustness to DoS
    attacks.\n   The following attack is possible with IKE fragmentation.  An attacker\n
    \  can initiate an IKE_SA_INIT exchange, complete it, compute SK_a and\n   SK_e,
    and then send a large but still incomplete set of IKE_AUTH\n   fragments.  These
    fragments will pass the ICV check and will be\n   stored in reassembly buffers,
    but since the set is incomplete, the\n   reassembling will never succeed and eventually
    will time out.  If the\n   set is large, this attack could potentially exhaust
    the receiver's\n   memory resources.\n   To mitigate the impact of this attack,
    it is RECOMMENDED that the\n   receiver limit the number of fragments it stores
    in the reassembling\n   queue so that the sum of the sizes of Encrypted Fragment
    payload\n   contents (after decryption) for fragments that are already placed\n
    \  into the reassembling queue is less than some value that is\n   reasonable
    for the implementation.  If the peer sends so many\n   fragments that the above
    condition is not met, the receiver can\n   consider this situation to be either
    an attack or a broken sender\n   implementation.  In either case, the receiver
    SHOULD drop the\n   connection and discard all the received fragments.\n   This
    value can be predefined, can be a configurable option, or can be\n   calculated
    dynamically, depending on the receiver's memory load.\n   Some care should be
    taken when selecting this value because if it is\n   too small it might prevent
    a legitimate peer from establishing an IKE\n   SA if the size of messages it sends
    exceeds this value.  It is NOT\n   RECOMMENDED for this value to exceed 64 KB
    because any IKE message\n   before fragmentation would likely be shorter than
    that.\n   If IKE fragments arrive in order, it is possible, but not advised,\n
    \  for the receiver to parse the beginning of the message that is being\n   reassembled
    and extract the already-available payloads before the\n   reassembly is complete.
    \ It can be dangerous to take any action based\n   on the content of these payloads,
    because the fragments that have not\n   yet been received might contain payloads
    that could change the\n   meaning of them (or could even make the whole message
    invalid), and\n   this can potentially be exploited by an attacker.  It is important
    to\n   address this threat by ensuring that all the fragments are received\n   prior
    to parsing the reassembled message, as described in\n   Section 2.6.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  IANA Considerations\n   This document defines a new payload in the \"IKEv2
    Payload Types\"\n   registry:\n     53       Encrypted and Authenticated Fragment
    \     SKF\n   This document also defines a new Notify Message Type in the \"IKEv2\n
    \  Notify Message Types - Status Types\" registry:\n     16430       IKEV2_FRAGMENTATION_SUPPORTED\n"
  title: 6.  IANA Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC7296]
      \ Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n              Kivinen,
      \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\", STD 79,
      RFC 7296, October 2014,\n              <http://www.rfc-editor.org/info/rfc7296>.\n
      \  [RFC6311]  Singh, R., Kalyani, G., Nir, Y., Sheffer, Y., and D.\n              Zhang,
      \"Protocol Support for High Availability of IKEv2/\n              IPsec\", RFC
      6311, July 2011,\n              <http://www.rfc-editor.org/info/rfc6311>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [RFC0791]  Postel, J., \"Internet Protocol\",
      STD 5, RFC 791,\n              September 1981, <http://www.rfc-editor.org/info/rfc791>.\n
      \  [RFC1191]  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n
      \             November 1990, <http://www.rfc-editor.org/info/rfc1191>.\n   [RFC1981]
      \ McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery\n              for
      IP version 6\", RFC 1981, August 1996,\n              <http://www.rfc-editor.org/info/rfc1981>.\n
      \  [RFC2460]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)
      Specification\", RFC 2460, December 1998,\n              <http://www.rfc-editor.org/info/rfc2460>.\n
      \  [RFC4787]  Audet, F. and C. Jennings, \"Network Address Translation\n              (NAT)
      Behavioral Requirements for Unicast UDP\", BCP 127,\n              RFC 4787,
      January 2007,\n              <http://www.rfc-editor.org/info/rfc4787>.\n   [RFC4821]
      \ Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n              Discovery\",
      RFC 4821, March 2007,\n              <http://www.rfc-editor.org/info/rfc4821>.\n
      \  [RFC5282]  Black, D. and D. McGrew, \"Using Authenticated Encryption\n              Algorithms
      with the Encrypted Payload of the Internet Key\n              Exchange version
      2 (IKEv2) Protocol\", RFC 5282,\n              August 2008, <http://www.rfc-editor.org/info/rfc5282>.\n
      \  [RFC5405]  Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines\n
      \             for Application Designers\", BCP 145, RFC 5405,\n              November
      2008, <http://www.rfc-editor.org/info/rfc5405>.\n   [RFC5723]  Sheffer, Y. and
      H. Tschofenig, \"Internet Key Exchange\n              Protocol Version 2 (IKEv2)
      Session Resumption\", RFC 5723,\n              January 2010, <http://www.rfc-editor.org/info/rfc5723>.\n
      \  [RFC6290]  Nir, Y., Wierbowski, D., Detienne, F., and P. Sethi, \"A\n              Quick
      Crash Detection Method for the Internet Key Exchange\n              Protocol
      (IKE)\", RFC 6290, June 2011,\n              <http://www.rfc-editor.org/info/rfc6290>.\n
      \  [RFC6888]  Perreault, S., Yamagata, I., Miyakawa, S., Nakagawa, A.,\n              and
      H. Ashida, \"Common Requirements for Carrier-Grade NATs\n              (CGNs)\",
      BCP 127, RFC 6888, April 2013,\n              <http://www.rfc-editor.org/info/rfc6888>.\n
      \  [FRAGDROP] Jaeggli, J., Colitti, L., Kumari, W., Vyncke, E., Kaeo,\n              M.,
      and T. Taylor, \"Why Operators Filter Fragments and\n              What It Implies\",
      Work in Progress, draft-taylor-v6ops-\n              fragdrop-02, December 2013.\n
      \  [BLACKHOLES]\n              De Boer, M. and J. Bosma, \"Discovering Path
      MTU black\n              holes on the Internet using RIPE Atlas\", July 2012,\n
      \             <http://www.nlnetlabs.nl/downloads/publications/\n              pmtu-black-holes-msc-thesis.pdf>.\n
      \  [DOSUDPPROT]\n              Kaufman, C., Perlman, R., and B. Sommerfeld,
      \"DoS\n              protection for UDP-based protocols\", ACM Conference on\n
      \             Computer and Communications Security, October 2003.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Appendix A.  Design Rationale\n   The simplest approach to IKE fragmentation
    would have been to\n   fragment a message that is fully formed and ready to be
    sent.\n   However, if a message got fragmented after being encrypted and\n   authenticated,
    this could make a simple DoS attack possible.  The\n   attacker could infrequently
    emit forged but valid-looking fragments\n   into the network, and some of these
    fragments would be fetched by the\n   receiver into the reassembling queue.  The
    receiver would not be able\n   to distinguish forged fragments from valid ones
    and would only be\n   able to determine that some of the received fragments were
    forged\n   after the whole message was reassembled and its authenticity check\n
    \  failed.\n   To prevent this kind of attack and also reduce vulnerability to
    some\n   other kinds of DoS attacks, it was decided to perform fragmentation\n
    \  before applying cryptographic protection to the message.  In this\n   case,
    each Fragment message becomes individually encrypted and\n   authenticated; this
    allows the receiver to determine forged fragments\n   and not store them in the
    reassembling queue.\n"
  title: Appendix A.  Design Rationale
- contents:
  - "Appendix B.  Correlation between IP Datagram Size and Encrypted Payload\n             Content
    Size\n   In the case of IPv4, the content size of the Encrypted Payload is\n   less
    than the IP datagram size by the sum of the following values:\n   o  IPv4 header
    size (typically 20 bytes, up to 60 if IP options are\n      present)\n   o  UDP
    header size (8 bytes)\n   o  non-ESP (Encapsulating Security Payload) marker size
    (4 bytes if\n      present)\n   o  IKE header size (28 bytes)\n   o  Encrypted
    payload header size (4 bytes)\n   o  initialization vector (IV) size (variable)\n
    \  o  padding and its size (at least 1 byte)\n   o  ICV size (variable)\n   The
    sum may be estimated as 61..105 bytes + IV + ICV + padding.\n   In the case of
    IPv6, the content size of the Encrypted Payload is\n   less than the IP datagram
    size by the sum of the following values:\n   o  IPv6 header size (40 bytes)\n
    \  o  IPv6 extension headers (optional; size varies)\n   o  UDP header size (8
    bytes)\n   o  non-ESP marker size (4 bytes if present)\n   o  IKE header size
    (28 bytes)\n   o  Encrypted payload header size (4 bytes)\n   o  IV size (variable)\n
    \  o  padding and its size (at least 1 byte)\n   o  ICV size (variable)\n   If
    no extension header is present, the sum may be estimated as\n   81..85 bytes +
    IV + ICV + padding.  If extension headers are present,\n   the payload content
    size is further reduced by the sum of the size of\n   the extension headers.  The
    length of each extension header can be\n   calculated as 8 * (Hdr Ext Len) bytes,
    except for the fragment\n   header, which is always 8 bytes in length.\n"
  title: Appendix B.  Correlation between IP Datagram Size and Encrypted Payload
- contents:
  - "Acknowledgements\n   The author would like to thank Tero Kivinen, Yoav Nir, Paul
    Wouters,\n   Yaron Sheffer, Joe Touch, Derek Atkins, Ole Troan, and others for\n
    \  their reviews and valuable comments.  Thanks to Ron Bonica for\n   contributing
    text to the Introduction section.  Thanks to Paul\n   Hoffman and Barry Leiba
    for improving text clarity.\n"
  title: Acknowledgements
- contents:
  - "Author's Address\n   Valery Smyslov\n   ELVIS-PLUS\n   PO Box 81\n   Moscow (Zelenograd)
    \ 124460\n   Russian Federation\n   Phone: +7 495 276 0211\n   EMail: svan@elvis.ru\n"
  title: Author's Address
