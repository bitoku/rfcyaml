- title: __initial_text__
  contents:
  - '          The Secure Sockets Layer (SSL) Protocol Version 3.0

    '
- title: Abstract
  contents:
  - "Abstract\n   This document is published as a historical record of the SSL 3.0\n\
    \   protocol.  The original Abstract follows.\n   This document specifies version\
    \ 3.0 of the Secure Sockets Layer (SSL\n   3.0) protocol, a security protocol\
    \ that provides communications\n   privacy over the Internet.  The protocol allows\
    \ client/server\n   applications to communicate in a way that is designed to prevent\n\
    \   eavesdropping, tampering, or message forgery.\n"
- title: Foreword
  contents:
  - "Foreword\n   Although the SSL 3.0 protocol is a widely implemented protocol,\
    \ a\n   pioneer in secure communications protocols, and the basis for\n   Transport\
    \ Layer Security (TLS), it was never formally published by\n   the IETF, except\
    \ in several expired Internet-Drafts.  This allowed no\n   easy referencing to\
    \ the protocol.  We believe a stable reference to\n   the original document should\
    \ exist and for that reason, this document\n   describes what is known as the\
    \ last published version of the SSL 3.0\n   protocol, that is, the November 18,\
    \ 1996, version of the protocol.\n   There were no changes to the original document\
    \ other than trivial\n   editorial changes and the addition of a \"Security Considerations\"\
    \n   section.  However, portions of the original document that no longer\n   apply\
    \ were not included.  Such as the \"Patent Statement\" section, the\n   \"Reserved\
    \ Ports Assignment\" section, and the cipher-suite registrator\n   note in the\
    \ \"The CipherSuite\" section.  The \"US export rules\"\n   discussed in the document\
    \ do not apply today but are kept intact to\n   provide context for decisions\
    \ taken in protocol design.  The \"Goals\n   of This Document\" section indicates\
    \ the goals for adopters of SSL\n   3.0, not goals of the IETF.\n   The authors\
    \ and editors were retained as in the original document.\n   The editor of this\
    \ document is Nikos Mavrogiannopoulos\n   (nikos.mavrogiannopoulos@esat.kuleuven.be).\
    \  The editor would like to\n   thank Dan Harkins, Linda Dunbar, Sean Turner,\
    \ and Geoffrey Keating\n   for reviewing this document and providing helpful comments.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for the historical record.\n   This document defines a Historic\
    \ Document for the Internet community.\n   This document is a product of the Internet\
    \ Engineering Task Force\n   (IETF).  It represents the consensus of the IETF\
    \ community.  It has\n   received public review and has been approved for publication\
    \ by the\n   Internet Engineering Steering Group (IESG).  Not all documents\n\
    \   approved by the IESG are a candidate for any level of Internet\n   Standard;\
    \ see Section 2 of RFC 5741.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6101.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Goals ...........................................................5\n  \
    \ 3. Goals of This Document ..........................................6\n   4.\
    \ Presentation Language ...........................................6\n      4.1.\
    \ Basic Block Size ...........................................7\n      4.2. Miscellaneous\
    \ ..............................................7\n      4.3. Vectors ....................................................7\n\
    \      4.4. Numbers ....................................................8\n  \
    \    4.5. Enumerateds ................................................8\n    \
    \  4.6. Constructed Types ..........................................9\n      \
    \     4.6.1. Variants ...........................................10\n      4.7.\
    \ Cryptographic Attributes ..................................11\n      4.8. Constants\
    \ .................................................12\n   5. SSL Protocol ...................................................12\n\
    \      5.1. Session and Connection States .............................12\n  \
    \    5.2. Record Layer ..............................................14\n    \
    \       5.2.1. Fragmentation ......................................14\n      \
    \     5.2.2. Record Compression and Decompression ...............15\n        \
    \   5.2.3. Record Payload Protection and the CipherSpec .......16\n      5.3.\
    \ Change Cipher Spec Protocol ...............................18\n      5.4. Alert\
    \ Protocol ............................................18\n           5.4.1. Closure\
    \ Alerts .....................................19\n           5.4.2. Error Alerts\
    \ .......................................20\n      5.5. Handshake Protocol Overview\
    \ ...............................21\n      5.6. Handshake Protocol ........................................23\n\
    \           5.6.1. Hello messages .....................................24\n  \
    \         5.6.2. Server Certificate .................................28\n    \
    \       5.6.3. Server Key Exchange Message ........................28\n      \
    \     5.6.4. Certificate Request ................................30\n        \
    \   5.6.5. Server Hello Done ..................................31\n          \
    \ 5.6.6. Client Certificate .................................31\n           5.6.7.\
    \ Client Key Exchange Message ........................31\n           5.6.8. Certificate\
    \ Verify .................................34\n           5.6.9. Finished ...........................................35\n\
    \      5.7. Application Data Protocol .................................36\n  \
    \ 6. Cryptographic Computations .....................................36\n    \
    \  6.1. Asymmetric Cryptographic Computations .....................36\n      \
    \     6.1.1. RSA ................................................36\n        \
    \   6.1.2. Diffie-Hellman .....................................37\n          \
    \ 6.1.3. FORTEZZA ...........................................37\n      6.2. Symmetric\
    \ Cryptographic Calculations and the CipherSpec ...37\n           6.2.1. The Master\
    \ Secret ..................................37\n           6.2.2. Converting the\
    \ Master Secret into Keys and\n                  MAC Secrets ........................................37\n\
    \   7. Security Considerations ........................................39\n  \
    \ 8. Informative References .........................................40\n   Appendix\
    \ A. Protocol Constant Values ..............................42\n     A.1. Record\
    \ Layer ...............................................42\n     A.2. Change Cipher\
    \ Specs Message ................................43\n     A.3. Alert Messages .............................................43\n\
    \     A.4. Handshake Protocol .........................................44\n  \
    \     A.4.1. Hello Messages .........................................44\n    \
    \   A.4.2. Server Authentication and Key Exchange Messages ........45\n     A.5.\
    \ Client Authentication and Key Exchange Messages ............46\n       A.5.1.\
    \ Handshake Finalization Message .........................47\n     A.6. The CipherSuite\
    \ ............................................47\n     A.7. The CipherSpec .............................................49\n\
    \   Appendix B. Glossary ..............................................50\n  \
    \ Appendix C. CipherSuite Definitions ...............................53\n   Appendix\
    \ D. Implementation Notes ..................................56\n     D.1. Temporary\
    \ RSA Keys .........................................56\n     D.2. Random Number\
    \ Generation and Seeding .......................56\n     D.3. Certificates and\
    \ Authentication ............................57\n     D.4. CipherSuites ...............................................57\n\
    \     D.5. FORTEZZA ...................................................57\n  \
    \     D.5.1. Notes on Use of FORTEZZA Hardware ......................57\n    \
    \   D.5.2. FORTEZZA Cipher Suites .................................58\n      \
    \ D.5.3. FORTEZZA Session Resumption ............................58\n   Appendix\
    \ E. Version 2.0 Backward Compatibility ....................59\n     E.1. Version\
    \ 2 Client Hello .....................................59\n     E.2. Avoiding Man-in-the-Middle\
    \ Version Rollback ..............61\n   Appendix F. Security Analysis .....................................61\n\
    \     F.1. Handshake Protocol .........................................61\n  \
    \     F.1.1. Authentication and Key Exchange ........................61\n    \
    \   F.1.2. Version Rollback Attacks ...............................64\n      \
    \ F.1.3. Detecting Attacks against the Handshake Protocol .......64\n       F.1.4.\
    \ Resuming Sessions ......................................65\n       F.1.5. MD5\
    \ and SHA ............................................65\n     F.2. Protecting\
    \ Application Data ................................65\n     F.3. Final Notes ................................................66\n\
    \   Appendix G. Acknowledgements ......................................66\n  \
    \   G.1. Other Contributors .........................................66\n    \
    \ G.2. Early Reviewers ............................................67\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The primary goal of the SSL protocol is to provide privacy\
    \ and\n   reliability between two communicating applications.  The protocol is\n\
    \   composed of two layers.  At the lowest level, layered on top of some\n   reliable\
    \ transport protocol (e.g., TCP [RFC0793]), is the SSL record\n   protocol.  The\
    \ SSL record protocol is used for encapsulation of\n   various higher level protocols.\
    \  One such encapsulated protocol, the\n   SSL handshake protocol, allows the\
    \ server and client to authenticate\n   each other and to negotiate an encryption\
    \ algorithm and cryptographic\n   keys before the application protocol transmits\
    \ or receives its first\n   byte of data.  One advantage of SSL is that it is\
    \ application\n   protocol independent.  A higher level protocol can layer on\
    \ top of\n   the SSL protocol transparently.  The SSL protocol provides connection\n\
    \   security that has three basic properties:\n   o  The connection is private.\
    \  Encryption is used after an initial\n      handshake to define a secret key.\
    \  Symmetric cryptography is used\n      for data encryption (e.g., DES [DES],\
    \ 3DES [3DES], RC4 [SCH]).\n   o  The peer's identity can be authenticated using\
    \ asymmetric, or\n      public key, cryptography (e.g., RSA [RSA], DSS [DSS]).\n\
    \   o  The connection is reliable.  Message transport includes a message\n   \
    \   integrity check using a keyed Message Authentication Code (MAC)\n      [RFC2104].\
    \  Secure hash functions (e.g., SHA, MD5) are used for\n      MAC computations.\n"
- title: 2.  Goals
  contents:
  - "2.  Goals\n   The goals of SSL protocol version 3.0, in order of their priority,\n\
    \   are:\n   1.  Cryptographic security\n          SSL should be used to establish\
    \ a secure connection between\n          two parties.\n   2.  Interoperability\n\
    \          Independent programmers should be able to develop applications\n  \
    \        utilizing SSL 3.0 that will then be able to successfully\n          exchange\
    \ cryptographic parameters without knowledge of one\n          another's code.\n\
    \          Note: It is not the case that all instances of SSL (even in\n     \
    \     the same application domain) will be able to successfully\n          connect.\
    \  For instance, if the server supports a particular\n          hardware token,\
    \ and the client does not have access to such a\n          token, then the connection\
    \ will not succeed.\n   3.  Extensibility\n          SSL seeks to provide a framework\
    \ into which new public key and\n          bulk encryption methods can be incorporated\
    \ as necessary.\n          This will also accomplish two sub-goals: to prevent\
    \ the need\n          to create a new protocol (and risking the introduction of\n\
    \          possible new weaknesses) and to avoid the need to implement an\n  \
    \        entire new security library.\n   4.  Relative efficiency\n          Cryptographic\
    \ operations tend to be highly CPU intensive,\n          particularly public key\
    \ operations.  For this reason, the SSL\n          protocol has incorporated an\
    \ optional session caching scheme\n          to reduce the number of connections\
    \ that need to be\n          established from scratch.  Additionally, care has\
    \ been taken\n          to reduce network activity.\n"
- title: 3.  Goals of This Document
  contents:
  - "3.  Goals of This Document\n   The SSL protocol version 3.0 specification is\
    \ intended primarily for\n   readers who will be implementing the protocol and\
    \ those doing\n   cryptographic analysis of it.  The spec has been written with\
    \ this in\n   mind, and it is intended to reflect the needs of those two groups.\n\
    \   For that reason, many of the algorithm-dependent data structures and\n   rules\
    \ are included in the body of the text (as opposed to in an\n   appendix), providing\
    \ easier access to them.\n   This document is not intended to supply any details\
    \ of service\n   definition or interface definition, although it does cover select\n\
    \   areas of policy as they are required for the maintenance of solid\n   security.\n"
- title: 4.  Presentation Language
  contents:
  - "4.  Presentation Language\n   This document deals with the formatting of data\
    \ in an external\n   representation.  The following very basic and somewhat casually\n\
    \   defined presentation syntax will be used.  The syntax draws from\n   several\
    \ sources in its structure.  Although it resembles the\n   programming language\
    \ \"C\" in its syntax and External Data\n   Representation (XDR) [RFC1832] in\
    \ both its syntax and intent, it\n   would be risky to draw too many parallels.\
    \  The purpose of this\n   presentation language is to document SSL only, not\
    \ to have general\n   application beyond that particular goal.\n"
- title: 4.1.  Basic Block Size
  contents:
  - "4.1.  Basic Block Size\n   The representation of all data items is explicitly\
    \ specified.  The\n   basic data block size is one byte (i.e., 8 bits).  Multiple\
    \ byte data\n   items are concatenations of bytes, from left to right, from top\
    \ to\n   bottom.  From the byte stream, a multi-byte item (a numeric in the\n\
    \   example) is formed (using C notation) by:\n        value = (byte[0] << 8*(n-1))\
    \ | (byte[1] << 8*(n-2)) | ...\n        | byte[n-1];\n   This byte ordering for\
    \ multi-byte values is the commonplace network\n   byte order or big-endian format.\n"
- title: 4.2.  Miscellaneous
  contents:
  - "4.2.  Miscellaneous\n   Comments begin with \"/*\" and end with \"*/\".  Optional\
    \ components are\n   denoted by enclosing them in \"[[ ]]\" double brackets. \
    \ Single-byte\n   entities containing uninterpreted data are of type opaque.\n"
- title: 4.3.  Vectors
  contents:
  - "4.3.  Vectors\n   A vector (single dimensioned array) is a stream of homogeneous\
    \ data\n   elements.  The size of the vector may be specified at documentation\n\
    \   time or left unspecified until runtime.  In either case, the length\n   declares\
    \ the number of bytes, not the number of elements, in the\n   vector.  The syntax\
    \ for specifying a new type T' that is a fixed-\n   length vector of type T is\n\
    \        T T'[n];\n   Here, T' occupies n bytes in the data stream, where n is\
    \ a multiple\n   of the size of T.  The length of the vector is not included in\
    \ the\n   encoded stream.\n   In the following example, Datum is defined to be\
    \ three consecutive\n   bytes that the protocol does not interpret, while Data\
    \ is three\n   consecutive Datum, consuming a total of nine bytes.\n        opaque\
    \ Datum[3];      /* three uninterpreted bytes */\n        Datum Data[9];     \
    \   /* 3 consecutive 3 byte vectors */\n   Variable-length vectors are defined\
    \ by specifying a subrange of legal\n   lengths, inclusively, using the notation\
    \ <floor..ceiling>.  When\n   encoded, the actual length precedes the vector's\
    \ contents in the byte\n   stream.  The length will be in the form of a number\
    \ consuming as many\n   bytes as required to hold the vector's specified maximum\
    \ (ceiling)\n   length.  A variable-length vector with an actual length field\
    \ of zero\n   is referred to as an empty vector.\n        T T'<floor..ceiling>;\n\
    \   In the following example, mandatory is a vector that must contain\n   between\
    \ 300 and 400 bytes of type opaque.  It can never be empty.\n   The actual length\
    \ field consumes two bytes, a uint16, sufficient to\n   represent the value 400\
    \ (see Section 4.4).  On the other hand, longer\n   can represent up to 800 bytes\
    \ of data, or 400 uint16 elements, and it\n   may be empty.  Its encoding will\
    \ include a two-byte actual length\n   field prepended to the vector.\n      \
    \  opaque mandatory<300..400>;\n              /* length field is 2 bytes, cannot\
    \ be empty */\n        uint16 longer<0..800>;\n              /* zero to 400 16-bit\
    \ unsigned integers */\n"
- title: 4.4.  Numbers
  contents:
  - "4.4.  Numbers\n   The basic numeric data type is an unsigned byte (uint8).  All\
    \ larger\n   numeric data types are formed from fixed-length series of bytes\n\
    \   concatenated as described in Section 4.1 and are also unsigned.  The\n   following\
    \ numeric types are predefined.\n        uint8 uint16[2];\n        uint8 uint24[3];\n\
    \        uint8 uint32[4];\n        uint8 uint64[8];\n"
- title: 4.5.  Enumerateds
  contents:
  - "4.5.  Enumerateds\n   An additional sparse data type is available called enum.\
    \  A field of\n   type enum can only assume the values declared in the definition.\n\
    \   Each definition is a different type.  Only enumerateds of the same\n   type\
    \ may be assigned or compared.  Every element of an enumerated\n   must be assigned\
    \ a value, as demonstrated in the following example.\n   Since the elements of\
    \ the enumerated are not ordered, they can be\n   assigned any unique value, in\
    \ any order.\n        enum { e1(v1), e2(v2), ... , en(vn), [[(n)]] } Te;\n   Enumerateds\
    \ occupy as much space in the byte stream as would its\n   maximal defined ordinal\
    \ value.  The following definition would cause\n   one byte to be used to carry\
    \ fields of type Color.\n        enum { red(3), blue(5), white(7) } Color;\n \
    \  Optionally, one may specify a value without its associated tag to\n   force\
    \ the width definition without defining a superfluous element.\n   In the following\
    \ example, Taste will consume two bytes in the data\n   stream but can only assume\
    \ the values 1, 2, or 4.\n        enum { sweet(1), sour(2), bitter(4), (32000)\
    \ } Taste;\n   The names of the elements of an enumeration are scoped within the\n\
    \   defined type.  In the first example, a fully qualified reference to\n   the\
    \ second element of the enumeration would be Color.blue.  Such\n   qualification\
    \ is not required if the target of the assignment is well\n   specified.\n   \
    \     Color color = Color.blue;     /* overspecified, legal */\n        Color\
    \ color = blue;           /* correct, type implicit */\n   For enumerateds that\
    \ are never converted to external representation,\n   the numerical information\
    \ may be omitted.\n        enum { low, medium, high } Amount;\n"
- title: 4.6.  Constructed Types
  contents:
  - "4.6.  Constructed Types\n   Structure types may be constructed from primitive\
    \ types for\n   convenience.  Each specification declares a new, unique type.\
    \  The\n   syntax for definition is much like that of C.\n      struct {\n   \
    \       T1 f1;\n          T2 f2;\n          ...\n          Tn fn;\n      } [[T]];\n\
    \   The fields within a structure may be qualified using the type's name\n   using\
    \ a syntax much like that available for enumerateds.  For\n   example, T.f2 refers\
    \ to the second field of the previous declaration.\n   Structure definitions may\
    \ be embedded.\n"
- title: 4.6.1.  Variants
  contents:
  - "4.6.1.  Variants\n   Defined structures may have variants based on some knowledge\
    \ that is\n   available within the environment.  The selector must be an enumerated\n\
    \   type that defines the possible variants the structure defines.  There\n  \
    \ must be a case arm for every element of the enumeration declared in\n   the\
    \ select.  The body of the variant structure may be given a label\n   for reference.\
    \  The mechanism by which the variant is selected at\n   runtime is not prescribed\
    \ by the presentation language.\n        struct {\n            T1 f1;\n      \
    \      T2 f2;\n             ....\n            Tn fn;\n            select (E) {\n\
    \                case e1: Te1;\n                case e2: Te2;\n              \
    \      ....\n                case en: Ten;\n            } [[fv]];\n        } [[Tv]];\n\
    \      For example,\n        enum { apple, orange } VariantTag;\n        struct\
    \ {\n            uint16 number;\n            opaque string<0..10>; /* variable\
    \ length */\n        } V1;\n        struct {\n            uint32 number;\n   \
    \         opaque string[10];    /* fixed length */\n        } V2;\n        struct\
    \ {\n            select (VariantTag) { /* value of selector is implicit */\n \
    \               case apple: V1;   /* VariantBody, tag = apple */\n           \
    \     case orange: V2;  /* VariantBody, tag = orange */\n            } variant_body;\
    \       /* optional label on variant */\n        } VariantRecord;\n   Variant\
    \ structures may be qualified (narrowed) by specifying a value\n   for the selector\
    \ prior to the type.  For example, an\n        orange VariantRecord\n   is a narrowed\
    \ type of a VariantRecord containing a variant_body of\n   type V2.\n"
- title: 4.7.  Cryptographic Attributes
  contents:
  - "4.7.  Cryptographic Attributes\n   The four cryptographic operations digital\
    \ signing, stream cipher\n   encryption, block cipher encryption, and public key\
    \ encryption are\n   designated digitally-signed, stream-ciphered, block-ciphered,\
    \ and\n   public-key-encrypted, respectively.  A field's cryptographic\n   processing\
    \ is specified by prepending an appropriate key word\n   designation before the\
    \ field's type specification.  Cryptographic\n   keys are implied by the current\
    \ session state (see Section 5.1).\n   In digital signing, one-way hash functions\
    \ are used as input for a\n   signing algorithm.  In RSA signing, a 36-byte structure\
    \ of two hashes\n   (one SHA and one MD5) is signed (encrypted with the private\
    \ key).  In\n   DSS, the 20 bytes of the SHA hash are run directly through the\n\
    \   Digital Signature Algorithm with no additional hashing.\n   In stream cipher\
    \ encryption, the plaintext is exclusive-ORed with an\n   identical amount of\
    \ output generated from a cryptographically secure\n   keyed pseudorandom number\
    \ generator.\n   In block cipher encryption, every block of plaintext encrypts\
    \ to a\n   block of ciphertext.  Because it is unlikely that the plaintext\n \
    \  (whatever data is to be sent) will break neatly into the necessary\n   block\
    \ size (usually 64 bits), it is necessary to pad out the end of\n   short blocks\
    \ with some regular pattern, usually all zeroes.\n   In public key encryption,\
    \ one-way functions with secret \"trapdoors\"\n   are used to encrypt the outgoing\
    \ data.  Data encrypted with the\n   public key of a given key pair can only be\
    \ decrypted with the private\n   key, and vice versa.  In the following example:\n\
    \        stream-ciphered struct {\n            uint8 field1;\n            uint8\
    \ field2;\n            digitally-signed opaque hash[20];\n        } UserType;\n\
    \   The contents of hash are used as input for the signing algorithm,\n   then\
    \ the entire structure is encrypted with a stream cipher.\n"
- title: 4.8.  Constants
  contents:
  - "4.8.  Constants\n   Typed constants can be defined for purposes of specification\
    \ by\n   declaring a symbol of the desired type and assigning values to it.\n\
    \   Under-specified types (opaque, variable-length vectors, and\n   structures\
    \ that contain opaque) cannot be assigned values.  No fields\n   of a multi-element\
    \ structure or vector may be elided.\n      For example,\n        struct {\n \
    \           uint8 f1;\n            uint8 f2;\n        } Example1;\n        Example1\
    \ ex1 = {1, 4};/* assigns f1 = 1, f2 = 4 */\n"
- title: 5.  SSL Protocol
  contents:
  - "5.  SSL Protocol\n   SSL is a layered protocol.  At each layer, messages may\
    \ include\n   fields for length, description, and content.  SSL takes messages\
    \ to\n   be transmitted, fragments the data into manageable blocks, optionally\n\
    \   compresses the data, applies a MAC, encrypts, and transmits the\n   result.\
    \  Received data is decrypted, verified, decompressed, and\n   reassembled, then\
    \ delivered to higher level clients.\n"
- title: 5.1.  Session and Connection States
  contents:
  - "5.1.  Session and Connection States\n   An SSL session is stateful.  It is the\
    \ responsibility of the SSL\n   handshake protocol to coordinate the states of\
    \ the client and server,\n   thereby allowing the protocol state machines of each\
    \ to operate\n   consistently, despite the fact that the state is not exactly\n\
    \   parallel.  Logically, the state is represented twice, once as the\n   current\
    \ operating state and (during the handshake protocol) again as\n   the pending\
    \ state.  Additionally, separate read and write states are\n   maintained.  When\
    \ the client or server receives a change cipher spec\n   message, it copies the\
    \ pending read state into the current read\n   state.  When the client or server\
    \ sends a change cipher spec message,\n   it copies the pending write state into\
    \ the current write state.  When\n   the handshake negotiation is complete, the\
    \ client and server exchange\n   change cipher spec messages (see Section 5.3),\
    \ and they then\n   communicate using the newly agreed-upon cipher spec.\n   An\
    \ SSL session may include multiple secure connections; in addition,\n   parties\
    \ may have multiple simultaneous sessions.\n   The session state includes the\
    \ following elements:\n   session identifier:  An arbitrary byte sequence chosen\
    \ by the server\n      to identify an active or resumable session state.\n   peer\
    \ certificate:  X509.v3 [X509] certificate of the peer.  This\n      element of\
    \ the state may be null.\n   compression method:  The algorithm used to compress\
    \ data prior to\n      encryption.\n   cipher spec:  Specifies the bulk data encryption\
    \ algorithm (such as\n      null, DES, etc.) and a MAC algorithm (such as MD5\
    \ or SHA).  It\n      also defines cryptographic attributes such as the hash_size.\
    \  (See\n      Appendix A.7 for formal definition.)\n   master secret:  48-byte\
    \ secret shared between the client and server.\n   is resumable:  A flag indicating\
    \ whether the session can be used to\n      initiate new connections.\n   The\
    \ connection state includes the following elements:\n   server and client random:\
    \  Byte sequences that are chosen by the\n      server and client for each connection.\n\
    \   server write MAC secret:  The secret used in MAC operations on data\n    \
    \  written by the server.\n   client write MAC secret:  The secret used in MAC\
    \ operations on data\n      written by the client.\n   server write key:  The\
    \ bulk cipher key for data encrypted by the\n      server and decrypted by the\
    \ client.\n   client write key:  The bulk cipher key for data encrypted by the\n\
    \      client and decrypted by the server.\n   initialization vectors:  When a\
    \ block cipher in Cipher Block Chaining\n      (CBC) mode is used, an initialization\
    \ vector (IV) is maintained\n      for each key.  This field is first initialized\
    \ by the SSL\n      handshake protocol.  Thereafter, the final ciphertext block\
    \ from\n      each record is preserved for use with the following record.\n  \
    \ sequence numbers:  Each party maintains separate sequence numbers for\n    \
    \  transmitted and received messages for each connection.  When a\n      party\
    \ sends or receives a change cipher spec message, the\n      appropriate sequence\
    \ number is set to zero.  Sequence numbers are\n      of type uint64 and may not\
    \ exceed 2^64-1.\n"
- title: 5.2.  Record Layer
  contents:
  - "5.2.  Record Layer\n   The SSL record layer receives uninterpreted data from\
    \ higher layers\n   in non-empty blocks of arbitrary size.\n"
- title: 5.2.1.  Fragmentation
  contents:
  - "5.2.1.  Fragmentation\n   The record layer fragments information blocks into\
    \ SSLPlaintext\n   records of 2^14 bytes or less.  Client message boundaries are\
    \ not\n   preserved in the record layer (i.e., multiple client messages of the\n\
    \   same ContentType may be coalesced into a single SSLPlaintext record).\n  \
    \      struct {\n            uint8 major, minor;\n        } ProtocolVersion;\n\
    \        enum {\n            change_cipher_spec(20), alert(21), handshake(22),\n\
    \            application_data(23), (255)\n        } ContentType;\n        struct\
    \ {\n            ContentType type;\n            ProtocolVersion version;\n   \
    \         uint16 length;\n            opaque fragment[SSLPlaintext.length];\n\
    \        } SSLPlaintext;\n   type:  The higher level protocol used to process\
    \ the enclosed\n      fragment.\n   version:  The version of protocol being employed.\
    \  This document\n      describes SSL version 3.0 (see Appendix A.1).\n   length:\
    \  The length (in bytes) of the following\n      SSLPlaintext.fragment.  The length\
    \ should not exceed 2^14.\n   fragment:  The application data.  This data is transparent\
    \ and\n      treated as an independent block to be dealt with by the higher\n\
    \      level protocol specified by the type field.\n   Note: Data of different\
    \ SSL record layer content types may be\n   interleaved.  Application data is\
    \ generally of lower precedence for\n   transmission than other content types.\n"
- title: 5.2.2.  Record Compression and Decompression
  contents:
  - "5.2.2.  Record Compression and Decompression\n   All records are compressed using\
    \ the compression algorithm defined in\n   the current session state.  There is\
    \ always an active compression\n   algorithm; however, initially it is defined\
    \ as\n   CompressionMethod.null.  The compression algorithm translates an\n  \
    \ SSLPlaintext structure into an SSLCompressed structure.  Compression\n   functions\
    \ erase their state information whenever the CipherSpec is\n   replaced.\n   Note:\
    \ The CipherSpec is part of the session state described in\n   Section 5.1.  References\
    \ to fields of the CipherSpec are made\n   throughout this document using presentation\
    \ syntax.  A more complete\n   description of the CipherSpec is shown in Appendix\
    \ A.7.\n   Compression must be lossless and may not increase the content length\n\
    \   by more than 1024 bytes.  If the decompression function encounters an\n  \
    \ SSLCompressed.fragment that would decompress to a length in excess of\n   2^14\
    \ bytes, it should issue a fatal decompression_failure alert\n   (Section 5.4.2).\n\
    \        struct {\n            ContentType type;       /* same as SSLPlaintext.type\
    \ */\n            ProtocolVersion version;/* same as SSLPlaintext.version */\n\
    \            uint16 length;\n            opaque fragment[SSLCompressed.length];\n\
    \        } SSLCompressed;\n   length:  The length (in bytes) of the following\n\
    \      SSLCompressed.fragment.  The length should not exceed 2^14 + 1024.\n  \
    \ fragment:  The compressed form of SSLPlaintext.fragment.\n   Note: A CompressionMethod.null\
    \ operation is an identity operation; no\n   fields are altered (see Appendix\
    \ A.4.1.)\n   Implementation note: Decompression functions are responsible for\n\
    \   ensuring that messages cannot cause internal buffer overflows.\n"
- title: 5.2.3.  Record Payload Protection and the CipherSpec
  contents:
  - "5.2.3.  Record Payload Protection and the CipherSpec\n   All records are protected\
    \ using the encryption and MAC algorithms\n   defined in the current CipherSpec.\
    \  There is always an active\n   CipherSpec; however, initially it is SSL_NULL_WITH_NULL_NULL,\
    \ which\n   does not provide any security.\n   Once the handshake is complete,\
    \ the two parties have shared secrets\n   that are used to encrypt records and\
    \ compute keyed Message\n   Authentication Codes (MACs) on their contents.  The\
    \ techniques used\n   to perform the encryption and MAC operations are defined\
    \ by the\n   CipherSpec and constrained by CipherSpec.cipher_type.  The encryption\n\
    \   and MAC functions translate an SSLCompressed structure into an\n   SSLCiphertext.\
    \  The decryption functions reverse the process.\n   Transmissions also include\
    \ a sequence number so that missing,\n   altered, or extra messages are detectable.\n\
    \        struct {\n            ContentType type;\n            ProtocolVersion\
    \ version;\n            uint16 length;\n            select (CipherSpec.cipher_type)\
    \ {\n                case stream: GenericStreamCipher;\n                case block:\
    \ GenericBlockCipher;\n            } fragment;\n        } SSLCiphertext;\n   type:\
    \  The type field is identical to SSLCompressed.type.\n   version:  The version\
    \ field is identical to SSLCompressed.version.\n   length:  The length (in bytes)\
    \ of the following\n      SSLCiphertext.fragment.  The length may not exceed 2^14\
    \ + 2048.\n   fragment:  The encrypted form of SSLCompressed.fragment, including\n\
    \      the MAC.\n"
- title: 5.2.3.1.  Null or Standard Stream Cipher
  contents:
  - "5.2.3.1.  Null or Standard Stream Cipher\n   Stream ciphers (including BulkCipherAlgorithm.null;\
    \ see Appendix A.7)\n   convert SSLCompressed.fragment structures to and from\
    \ stream\n   SSLCiphertext.fragment structures.\n        stream-ciphered struct\
    \ {\n            opaque content[SSLCompressed.length];\n            opaque MAC[CipherSpec.hash_size];\n\
    \        } GenericStreamCipher;\n   The MAC is generated as:\n        hash(MAC_write_secret\
    \ + pad_2 +\n             hash(MAC_write_secret + pad_1 + seq_num +\n        \
    \          SSLCompressed.type + SSLCompressed.length +\n                  SSLCompressed.fragment));\n\
    \   where \"+\" denotes concatenation.\n   pad_1:  The character 0x36 repeated\
    \ 48 times for MD5 or 40 times for\n      SHA.\n   pad_2:  The character 0x5c\
    \ repeated 48 times for MD5 or 40 times for\n      SHA.\n   seq_num:  The sequence\
    \ number for this message.\n   hash:  Hashing algorithm derived from the cipher\
    \ suite.\n   Note that the MAC is computed before encryption.  The stream cipher\n\
    \   encrypts the entire block, including the MAC.  For stream ciphers\n   that\
    \ do not use a synchronization vector (such as RC4), the stream\n   cipher state\
    \ from the end of one record is simply used on the\n   subsequent packet.  If\
    \ the CipherSuite is SSL_NULL_WITH_NULL_NULL,\n   encryption consists of the identity\
    \ operation (i.e., the data is not\n   encrypted and the MAC size is zero implying\
    \ that no MAC is used).\n   SSLCiphertext.length is SSLCompressed.length plus\n\
    \   CipherSpec.hash_size.\n"
- title: 5.2.3.2.  CBC Block Cipher
  contents:
  - "5.2.3.2.  CBC Block Cipher\n   For block ciphers (such as RC2 or DES), the encryption\
    \ and MAC\n   functions convert SSLCompressed.fragment structures to and from\
    \ block\n   SSLCiphertext.fragment structures.\n        block-ciphered struct\
    \ {\n            opaque content[SSLCompressed.length];\n            opaque MAC[CipherSpec.hash_size];\n\
    \            uint8 padding[GenericBlockCipher.padding_length];\n            uint8\
    \ padding_length;\n        } GenericBlockCipher;\n   The MAC is generated as described\
    \ in Section 5.2.3.1.\n   padding:  Padding that is added to force the length\
    \ of the plaintext\n      to be a multiple of the block cipher's block length.\n\
    \   padding_length:  The length of the padding must be less than the\n      cipher's\
    \ block length and may be zero.  The padding length should\n      be such that\
    \ the total size of the GenericBlockCipher structure is\n      a multiple of the\
    \ cipher's block length.\n   The encrypted data length (SSLCiphertext.length)\
    \ is one more than the\n   sum of SSLCompressed.length, CipherSpec.hash_size,\
    \ and\n   padding_length.\n   Note: With CBC, the initialization vector (IV) for\
    \ the first record\n   is provided by the handshake protocol.  The IV for subsequent\
    \ records\n   is the last ciphertext block from the previous record.\n"
- title: 5.3.  Change Cipher Spec Protocol
  contents:
  - "5.3.  Change Cipher Spec Protocol\n   The change cipher spec protocol exists\
    \ to signal transitions in\n   ciphering strategies.  The protocol consists of\
    \ a single message,\n   which is encrypted and compressed under the current (not\
    \ the pending)\n   CipherSpec.  The message consists of a single byte of value\
    \ 1.\n        struct {\n            enum { change_cipher_spec(1), (255) } type;\n\
    \        } ChangeCipherSpec;\n   The change cipher spec message is sent by both\
    \ the client and server\n   to notify the receiving party that subsequent records\
    \ will be\n   protected under the just-negotiated CipherSpec and keys.  Reception\n\
    \   of this message causes the receiver to copy the read pending state\n   into\
    \ the read current state.  The client sends a change cipher spec\n   message following\
    \ handshake key exchange and certificate verify\n   messages (if any), and the\
    \ server sends one after successfully\n   processing the key exchange message\
    \ it received from the client.  An\n   unexpected change cipher spec message should\
    \ generate an\n   unexpected_message alert (Section 5.4.2).  When resuming a previous\n\
    \   session, the change cipher spec message is sent after the hello\n   messages.\n"
- title: 5.4.  Alert Protocol
  contents:
  - "5.4.  Alert Protocol\n   One of the content types supported by the SSL record\
    \ layer is the\n   alert type.  Alert messages convey the severity of the message\
    \ and a\n   description of the alert.  Alert messages with a level of fatal\n\
    \   result in the immediate termination of the connection.  In this case,\n  \
    \ other connections corresponding to the session may continue, but the\n   session\
    \ identifier must be invalidated, preventing the failed session\n   from being\
    \ used to establish new connections.  Like other messages,\n   alert messages\
    \ are encrypted and compressed, as specified by the\n   current connection state.\n\
    \        enum { warning(1), fatal(2), (255) } AlertLevel;\n        enum {\n  \
    \          close_notify(0),\n            unexpected_message(10),\n           \
    \ bad_record_mac(20),\n            decompression_failure(30),\n            handshake_failure(40),\n\
    \            no_certificate(41),\n            bad_certificate(42),\n         \
    \   unsupported_certificate(43),\n            certificate_revoked(44),\n     \
    \       certificate_expired(45),\n            certificate_unknown(46),\n     \
    \       illegal_parameter (47)\n            (255)\n        } AlertDescription;\n\
    \        struct {\n            AlertLevel level;\n            AlertDescription\
    \ description;\n        } Alert;\n"
- title: 5.4.1.  Closure Alerts
  contents:
  - "5.4.1.  Closure Alerts\n   The client and the server must share knowledge that\
    \ the connection is\n   ending in order to avoid a truncation attack.  Either\
    \ party may\n   initiate the exchange of closing messages.\n   close_notify: \
    \ This message notifies the recipient that the sender\n      will not send any\
    \ more messages on this connection.  The session\n      becomes unresumable if\
    \ any connection is terminated without proper\n      close_notify messages with\
    \ level equal to warning.\n   Either party may initiate a close by sending a close_notify\
    \ alert.\n   Any data received after a closure alert is ignored.\n   Each party\
    \ is required to send a close_notify alert before closing\n   the write side of\
    \ the connection.  It is required that the other\n   party respond with a close_notify\
    \ alert of its own and close down the\n   connection immediately, discarding any\
    \ pending writes.  It is not\n   required for the initiator of the close to wait\
    \ for the responding\n   close_notify alert before closing the read side of the\
    \ connection.\n   NB: It is assumed that closing a connection reliably delivers\
    \ pending\n   data before destroying the transport.\n"
- title: 5.4.2.  Error Alerts
  contents:
  - "5.4.2.  Error Alerts\n   Error handling in the SSL handshake protocol is very\
    \ simple.  When an\n   error is detected, the detecting party sends a message\
    \ to the other\n   party.  Upon transmission or receipt of a fatal alert message,\
    \ both\n   parties immediately close the connection.  Servers and clients are\n\
    \   required to forget any session identifiers, keys, and secrets\n   associated\
    \ with a failed connection.  The following error alerts are\n   defined:\n   unexpected_message:\
    \  An inappropriate message was received.  This\n      alert is always fatal and\
    \ should never be observed in\n      communication between proper implementations.\n\
    \   bad_record_mac:  This alert is returned if a record is received with\n   \
    \   an incorrect MAC.  This message is always fatal.\n   decompression_failure:\
    \  The decompression function received improper\n      input (e.g., data that\
    \ would expand to excessive length).  This\n      message is always fatal.\n \
    \  handshake_failure:  Reception of a handshake_failure alert message\n      indicates\
    \ that the sender was unable to negotiate an acceptable\n      set of security\
    \ parameters given the options available.  This is a\n      fatal error.\n   no_certificate:\
    \  A no_certificate alert message may be sent in\n      response to a certification\
    \ request if no appropriate certificate\n      is available.\n   bad_certificate:\
    \  A certificate was corrupt, contained signatures\n      that did not verify\
    \ correctly, etc.\n   unsupported_certificate:  A certificate was of an unsupported\
    \ type.\n   certificate_revoked:  A certificate was revoked by its signer.\n \
    \  certificate_expired:  A certificate has expired or is not currently\n     \
    \ valid.\n   certificate_unknown:  Some other (unspecified) issue arose in\n \
    \     processing the certificate, rendering it unacceptable.\n   illegal_parameter:\
    \  A field in the handshake was out of range or\n      inconsistent with other\
    \ fields.  This is always fatal.\n"
- title: 5.5.  Handshake Protocol Overview
  contents:
  - "5.5.  Handshake Protocol Overview\n   The cryptographic parameters of the session\
    \ state are produced by the\n   SSL handshake protocol, which operates on top\
    \ of the SSL record\n   layer.  When an SSL client and server first start communicating,\
    \ they\n   agree on a protocol version, select cryptographic algorithms,\n   optionally\
    \ authenticate each other, and use public key encryption\n   techniques to generate\
    \ shared secrets.  These processes are performed\n   in the handshake protocol,\
    \ which can be summarized as follows: the\n   client sends a client hello message\
    \ to which the server must respond\n   with a server hello message, or else a\
    \ fatal error will occur and the\n   connection will fail.  The client hello and\
    \ server hello are used to\n   establish security enhancement capabilities between\
    \ client and\n   server.  The client hello and server hello establish the following\n\
    \   attributes: Protocol Version, Session ID, Cipher Suite, and\n   Compression\
    \ Method.  Additionally, two random values are generated\n   and exchanged: ClientHello.random\
    \ and ServerHello.random.\n   Following the hello messages, the server will send\
    \ its certificate,\n   if it is to be authenticated.  Additionally, a server key\
    \ exchange\n   message may be sent, if it is required (e.g., if their server has\
    \ no\n   certificate, or if its certificate is for signing only).  If the\n  \
    \ server is authenticated, it may request a certificate from the\n   client, if\
    \ that is appropriate to the cipher suite selected.  Now the\n   server will send\
    \ the server hello done message, indicating that the\n   hello-message phase of\
    \ the handshake is complete.  The server will\n   then wait for a client response.\
    \  If the server has sent a\n   certificate request message, the client must send\
    \ either the\n   certificate message or a no_certificate alert.  The client key\n\
    \   exchange message is now sent, and the content of that message will\n   depend\
    \ on the public key algorithm selected between the client hello\n   and the server\
    \ hello.  If the client has sent a certificate with\n   signing ability, a digitally-signed\
    \ certificate verify message is\n   sent to explicitly verify the certificate.\n\
    \   At this point, a change cipher spec message is sent by the client,\n   and\
    \ the client copies the pending CipherSpec into the current\n   CipherSpec.  The\
    \ client then immediately sends the finished message\n   under the new algorithms,\
    \ keys, and secrets.  In response, the server\n   will send its own change cipher\
    \ spec message, transfer the pending to\n   the current CipherSpec, and send its\
    \ finished message under the new\n   CipherSpec.  At this point, the handshake\
    \ is complete and the client\n   and server may begin to exchange application\
    \ layer data.  (See flow\n   chart below.)\n      Client                     \
    \                           Server\n      ClientHello                   -------->\n\
    \                                                       ServerHello\n        \
    \                                              Certificate*\n                \
    \                                ServerKeyExchange*\n                        \
    \                       CertificateRequest*\n                                \
    \    <--------      ServerHelloDone\n      Certificate*\n      ClientKeyExchange\n\
    \      CertificateVerify*\n      [ChangeCipherSpec]\n      Finished          \
    \            -------->\n                                                [ChangeCipherSpec]\n\
    \                                    <--------             Finished\n      Application\
    \ Data              <------->     Application Data\n      * Indicates optional\
    \ or situation-dependent messages that are not\n        always sent.\n   Note:\
    \ To help avoid pipeline stalls, ChangeCipherSpec is an\n   independent SSL protocol\
    \ content type, and is not actually an SSL\n   handshake message.\n   When the\
    \ client and server decide to resume a previous session or\n   duplicate an existing\
    \ session (instead of negotiating new security\n   parameters) the message flow\
    \ is as follows:\n   The client sends a ClientHello using the session ID of the\
    \ session to\n   be resumed.  The server then checks its session cache for a match.\n\
    \   If a match is found, and the server is willing to re-establish the\n   connection\
    \ under the specified session state, it will send a\n   ServerHello with the same\
    \ session ID value.  At this point, both\n   client and server must send change\
    \ cipher spec messages and proceed\n   directly to finished messages.  Once the\
    \ re-establishment is\n   complete, the client and server may begin to exchange\
    \ application\n   layer data.  (See flow chart below.)  If a session ID match\
    \ is not\n   found, the server generates a new session ID and the SSL client and\n\
    \   server perform a full handshake.\n      Client                           \
    \                     Server\n      ClientHello                   -------->\n\
    \                                                       ServerHello\n        \
    \                                      [change cipher spec]\n                \
    \                    <--------             Finished\n      change cipher spec\n\
    \      Finished                      -------->\n      Application Data       \
    \       <------->     Application Data\n   The contents and significance of each\
    \ message will be presented in\n   detail in the following sections.\n"
- title: 5.6.  Handshake Protocol
  contents:
  - "5.6.  Handshake Protocol\n   The SSL handshake protocol is one of the defined\
    \ higher level clients\n   of the SSL record protocol.  This protocol is used\
    \ to negotiate the\n   secure attributes of a session.  Handshake messages are\
    \ supplied to\n   the SSL record layer, where they are encapsulated within one\
    \ or more\n   SSLPlaintext structures, which are processed and transmitted as\n\
    \   specified by the current active session state.\n        enum {\n         \
    \   hello_request(0), client_hello(1), server_hello(2),\n            certificate(11),\
    \ server_key_exchange (12),\n            certificate_request(13), server_hello_done(14),\n\
    \            certificate_verify(15), client_key_exchange(16),\n            finished(20),\
    \ (255)\n        } HandshakeType;\n        struct {\n            HandshakeType\
    \ msg_type;    /* handshake type */\n            uint24 length;             /*\
    \ bytes in message */\n            select (HandshakeType) {\n                case\
    \ hello_request: HelloRequest;\n                case client_hello: ClientHello;\n\
    \                case server_hello: ServerHello;\n                case certificate:\
    \ Certificate;\n                case server_key_exchange: ServerKeyExchange;\n\
    \                case certificate_request: CertificateRequest;\n             \
    \   case server_hello_done: ServerHelloDone;\n                case certificate_verify:\
    \ CertificateVerify;\n                case client_key_exchange: ClientKeyExchange;\n\
    \                case finished: Finished;\n            } body;\n        } Handshake;\n\
    \   The handshake protocol messages are presented in the order they must\n   be\
    \ sent; sending handshake messages in an unexpected order results in\n   a fatal\
    \ error.\n"
- title: 5.6.1.  Hello messages
  contents:
  - "5.6.1.  Hello messages\n   The hello phase messages are used to exchange security\
    \ enhancement\n   capabilities between the client and server.  When a new session\n\
    \   begins, the CipherSpec encryption, hash, and compression algorithms\n   are\
    \ initialized to null.  The current CipherSpec is used for\n   renegotiation messages.\n"
- title: 5.6.1.1.  Hello Request
  contents:
  - "5.6.1.1.  Hello Request\n   The hello request message may be sent by the server\
    \ at any time, but\n   will be ignored by the client if the handshake protocol\
    \ is already\n   underway.  It is a simple notification that the client should\
    \ begin\n   the negotiation process anew by sending a client hello message when\n\
    \   convenient.\n   Note: Since handshake messages are intended to have transmission\n\
    \   precedence over application data, it is expected that the negotiation\n  \
    \ begin in no more than one or two times the transmission time of a\n   maximum-length\
    \ application data message.\n   After sending a hello request, servers should\
    \ not repeat the request\n   until the subsequent handshake negotiation is complete.\
    \  A client\n   that receives a hello request while in a handshake negotiation\
    \ state\n   should simply ignore the message.\n   The structure of a hello request\
    \ message is as follows:\n        struct { } HelloRequest;\n"
- title: 5.6.1.2.  Client Hello
  contents:
  - "5.6.1.2.  Client Hello\n   When a client first connects to a server it is required\
    \ to send the\n   client hello as its first message.  The client can also send\
    \ a client\n   hello in response to a hello request or on its own initiative in\n\
    \   order to renegotiate the security parameters in an existing\n   connection.\
    \  The client hello message includes a random structure,\n   which is used later\
    \ in the protocol.\n      struct {\n          uint32 gmt_unix_time;\n        \
    \  opaque random_bytes[28];\n      } Random;\n   gmt_unix_time:  The current time\
    \ and date in standard UNIX 32-bit\n      format according to the sender's internal\
    \ clock.  Clocks are not\n      required to be set correctly by the basic SSL\
    \ protocol; higher\n      level or application protocols may define additional\
    \ requirements.\n   random_bytes:  28 bytes generated by a secure random number\n\
    \      generator.\n   The client hello message includes a variable-length session\n\
    \   identifier.  If not empty, the value identifies a session between the\n  \
    \ same client and server whose security parameters the client wishes to\n   reuse.\
    \  The session identifier may be from an earlier connection,\n   this connection,\
    \ or another currently active connection.  The second\n   option is useful if\
    \ the client only wishes to update the random\n   structures and derived values\
    \ of a connection, while the third option\n   makes it possible to establish several\
    \ simultaneous independent\n   secure connections without repeating the full handshake\
    \ protocol.\n   The actual contents of the SessionID are defined by the server.\n\
    \        opaque SessionID<0..32>;\n   Warning: Servers must not place confidential\
    \ information in session\n   identifiers or let the contents of fake session identifiers\
    \ cause any\n   breach of security.\n   The CipherSuite list, passed from the\
    \ client to the server in the\n   client hello message, contains the combinations\
    \ of cryptographic\n   algorithms supported by the client in order of the client's\n\
    \   preference (first choice first).  Each CipherSuite defines both a key\n  \
    \ exchange algorithm and a CipherSpec.  The server will select a cipher\n   suite\
    \ or, if no acceptable choices are presented, return a handshake\n   failure alert\
    \ and close the connection.\n        uint8 CipherSuite[2];  /* Cryptographic suite\
    \ selector */\n   The client hello includes a list of compression algorithms supported\n\
    \   by the client, ordered according to the client's preference.  If the\n   server\
    \ supports none of those specified by the client, the session\n   must fail.\n\
    \        enum { null(0), (255) } CompressionMethod;\n   Issue: Which compression\
    \ methods to support is under investigation.\n   The structure of the client hello\
    \ is as follows.\n        struct {\n            ProtocolVersion client_version;\n\
    \            Random random;\n            SessionID session_id;\n            CipherSuite\
    \ cipher_suites<2..2^16-1>;\n            CompressionMethod compression_methods<1..2^8-1>;\n\
    \        } ClientHello;\n   client_version:  The version of the SSL protocol by\
    \ which the client\n      wishes to communicate during this session.  This should\
    \ be the\n      most recent (highest valued) version supported by the client.\
    \  For\n      this version of the specification, the version will be 3.0 (see\n\
    \      Appendix E for details about backward compatibility).\n   random:  A client-generated\
    \ random structure.\n   session_id:  The ID of a session the client wishes to\
    \ use for this\n      connection.  This field should be empty if no session_id\
    \ is\n      available or the client wishes to generate new security\n      parameters.\n\
    \   cipher_suites:  This is a list of the cryptographic options supported\n  \
    \    by the client, sorted with the client's first preference first.\n      If\
    \ the session_id field is not empty (implying a session\n      resumption request),\
    \ this vector must include at least the\n      cipher_suite from that session.\
    \  Values are defined in\n      Appendix A.6.\n   compression_methods:  This is\
    \ a list of the compression methods\n      supported by the client, sorted by\
    \ client preference.  If the\n      session_id field is not empty (implying a\
    \ session resumption\n      request), this vector must include at least the compression_method\n\
    \      from that session.  All implementations must support\n      CompressionMethod.null.\n\
    \   After sending the client hello message, the client waits for a server\n  \
    \ hello message.  Any other handshake message returned by the server\n   except\
    \ for a hello request is treated as a fatal error.\n   Implementation note: Application\
    \ data may not be sent before a\n   finished message has been sent.  Transmitted\
    \ application data is\n   known to be insecure until a valid finished message\
    \ has been\n   received.  This absolute restriction is relaxed if there is a\n\
    \   current, non-null encryption on this connection.\n   Forward compatibility\
    \ note: In the interests of forward\n   compatibility, it is permitted for a client\
    \ hello message to include\n   extra data after the compression methods.  This\
    \ data must be included\n   in the handshake hashes, but must otherwise be ignored.\n"
- title: 5.6.1.3.  Server Hello
  contents:
  - "5.6.1.3.  Server Hello\n   The server processes the client hello message and\
    \ responds with\n   either a handshake_failure alert or server hello message.\n\
    \        struct {\n            ProtocolVersion server_version;\n            Random\
    \ random;\n            SessionID session_id;\n            CipherSuite cipher_suite;\n\
    \            CompressionMethod compression_method;\n        } ServerHello;\n \
    \  server_version:  This field will contain the lower of that suggested\n    \
    \  by the client in the client hello and the highest supported by the\n      server.\
    \  For this version of the specification, the version will\n      be 3.0 (see\
    \ Appendix E for details about backward compatibility).\n   random:  This structure\
    \ is generated by the server and must be\n      different from (and independent\
    \ of) ClientHello.random.\n   session_id:  This is the identity of the session\
    \ corresponding to\n      this connection.  If the ClientHello.session_id was\
    \ non-empty, the\n      server will look in its session cache for a match.  If\
    \ a match is\n      found and the server is willing to establish the new connection\n\
    \      using the specified session state, the server will respond with\n     \
    \ the same value as was supplied by the client.  This indicates a\n      resumed\
    \ session and dictates that the parties must proceed\n      directly to the finished\
    \ messages.  Otherwise, this field will\n      contain a different value identifying\
    \ the new session.  The server\n      may return an empty session_id to indicate\
    \ that the session will\n      not be cached and therefore cannot be resumed.\n\
    \   cipher_suite:  The single cipher suite selected by the server from\n     \
    \ the list in ClientHello.cipher_suites.  For resumed sessions, this\n      field\
    \ is the value from the state of the session being resumed.\n   compression_method:\
    \  The single compression algorithm selected by the\n      server from the list\
    \ in ClientHello.compression_methods.  For\n      resumed sessions, this field\
    \ is the value from the resumed session\n      state.\n"
- title: 5.6.2.  Server Certificate
  contents:
  - "5.6.2.  Server Certificate\n   If the server is to be authenticated (which is\
    \ generally the case),\n   the server sends its certificate immediately following\
    \ the server\n   hello message.  The certificate type must be appropriate for\
    \ the\n   selected cipher suite's key exchange algorithm, and is generally an\n\
    \   X.509.v3 certificate (or a modified X.509 certificate in the case of\n   FORTEZZA(tm)\
    \ [FOR]).  The same message type will be used for the\n   client's response to\
    \ a certificate request message.\n        opaque ASN.1Cert<1..2^24-1>;\n     \
    \   struct {\n            ASN.1Cert certificate_list<1..2^24-1>;\n        } Certificate;\n\
    \   certificate_list:  This is a sequence (chain) of X.509.v3\n      certificates,\
    \ ordered with the sender's certificate first followed\n      by any certificate\
    \ authority certificates proceeding sequentially\n      upward.\n   Note: PKCS\
    \ #7 [PKCS7] is not used as the format for the certificate\n   vector because\
    \ PKCS #6 [PKCS6] extended certificates are not used.\n   Also, PKCS #7 defines\
    \ a Set rather than a Sequence, making the task\n   of parsing the list more difficult.\n"
- title: 5.6.3.  Server Key Exchange Message
  contents:
  - "5.6.3.  Server Key Exchange Message\n   The server key exchange message is sent\
    \ by the server if it has no\n   certificate, has a certificate only used for\
    \ signing (e.g., DSS [DSS]\n   certificates, signing-only RSA [RSA] certificates),\
    \ or FORTEZZA KEA\n   key exchange is used.  This message is not used if the server\n\
    \   certificate contains Diffie-Hellman [DH1] parameters.\n   Note: According\
    \ to current US export law, RSA moduli larger than 512\n   bits may not be used\
    \ for key exchange in software exported from the\n   US.  With this message, larger\
    \ RSA keys may be used as signature-only\n   certificates to sign temporary shorter\
    \ RSA keys for key exchange.\n        enum { rsa, diffie_hellman, fortezza_kea\
    \ }\n               KeyExchangeAlgorithm;\n        struct {\n            opaque\
    \ rsa_modulus<1..2^16-1>;\n            opaque rsa_exponent<1..2^16-1>;\n     \
    \   } ServerRSAParams;\n   rsa_modulus:  The modulus of the server's temporary\
    \ RSA key.\n   rsa_exponent:  The public exponent of the server's temporary RSA\
    \ key.\n        struct {\n            opaque dh_p<1..2^16-1>;\n            opaque\
    \ dh_g<1..2^16-1>;\n            opaque dh_Ys<1..2^16-1>;\n        } ServerDHParams;\
    \     /* Ephemeral DH parameters */\n   dh_p:  The prime modulus used for the\
    \ Diffie-Hellman operation.\n   dh_g:  The generator used for the Diffie-Hellman\
    \ operation.\n   dh_Ys:  The server's Diffie-Hellman public value (gX mod p).\n\
    \        struct {\n            opaque r_s [128];\n        } ServerFortezzaParams;\n\
    \   r_s:  Server random number for FORTEZZA KEA (Key Exchange Algorithm).\n  \
    \      struct {\n            select (KeyExchangeAlgorithm) {\n               \
    \ case diffie_hellman:\n                    ServerDHParams params;\n         \
    \           Signature signed_params;\n                case rsa:\n            \
    \        ServerRSAParams params;\n                    Signature signed_params;\n\
    \                case fortezza_kea:\n                    ServerFortezzaParams\
    \ params;\n            };\n        } ServerKeyExchange;\n   params:  The server's\
    \ key exchange parameters.\n   signed_params:  A hash of the corresponding params\
    \ value, with the\n      signature appropriate to that hash applied.\n   md5_hash:\
    \  MD5(ClientHello.random + ServerHello.random +\n      ServerParams);\n   sha_hash:\
    \  SHA(ClientHello.random + ServerHello.random +\n      ServerParams);\n     \
    \   enum { anonymous, rsa, dsa } SignatureAlgorithm;\n        digitally-signed\
    \ struct {\n            select(SignatureAlgorithm) {\n                case anonymous:\
    \ struct { };\n                case rsa:\n                    opaque md5_hash[16];\n\
    \                    opaque sha_hash[20];\n                case dsa:\n       \
    \             opaque sha_hash[20];\n            };\n        } Signature;\n"
- title: 5.6.4.  Certificate Request
  contents:
  - "5.6.4.  Certificate Request\n   A non-anonymous server can optionally request\
    \ a certificate from the\n   client, if appropriate for the selected cipher suite.\n\
    \        enum {\n            rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n\
    \            rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_kea(20),\n   \
    \         (255)\n        } ClientCertificateType;\n        opaque DistinguishedName<1..2^16-1>;\n\
    \        struct {\n            ClientCertificateType certificate_types<1..2^8-1>;\n\
    \            DistinguishedName certificate_authorities<3..2^16-1>;\n        }\
    \ CertificateRequest;\n   certificate_types:  This field is a list of the types\
    \ of certificates\n      requested, sorted in order of the server's preference.\n\
    \   certificate_authorities:  A list of the distinguished names of\n      acceptable\
    \ certificate authorities.\n   Note: DistinguishedName is derived from [X509].\n\
    \   Note: It is a fatal handshake_failure alert for an anonymous server\n   to\
    \ request client identification.\n"
- title: 5.6.5.  Server Hello Done
  contents:
  - "5.6.5.  Server Hello Done\n   The server hello done message is sent by the server\
    \ to indicate the\n   end of the server hello and associated messages.  After\
    \ sending this\n   message, the server will wait for a client response.\n    \
    \    struct { } ServerHelloDone;\n   Upon receipt of the server hello done message\
    \ the client should\n   verify that the server provided a valid certificate if\
    \ required and\n   check that the server hello parameters are acceptable.\n"
- title: 5.6.6.  Client Certificate
  contents:
  - "5.6.6.  Client Certificate\n   This is the first message the client can send\
    \ after receiving a\n   server hello done message.  This message is only sent\
    \ if the server\n   requests a certificate.  If no suitable certificate is available,\
    \ the\n   client should send a no_certificate alert instead.  This alert is\n\
    \   only a warning; however, the server may respond with a fatal\n   handshake\
    \ failure alert if client authentication is required.  Client\n   certificates\
    \ are sent using the certificate defined in Section 5.6.2.\n   Note: Client Diffie-Hellman\
    \ certificates must match the server\n   specified Diffie-Hellman parameters.\n"
- title: 5.6.7.  Client Key Exchange Message
  contents:
  - "5.6.7.  Client Key Exchange Message\n   The choice of messages depends on which\
    \ public key algorithm(s) has\n   (have) been selected.  See Section 5.6.3 for\
    \ the KeyExchangeAlgorithm\n   definition.\n        struct {\n            select\
    \ (KeyExchangeAlgorithm) {\n                case rsa: EncryptedPreMasterSecret;\n\
    \                case diffie_hellman: ClientDiffieHellmanPublic;\n           \
    \     case fortezza_kea: FortezzaKeys;\n            } exchange_keys;\n       \
    \ } ClientKeyExchange;\n   The information to select the appropriate record structure\
    \ is in the\n   pending session state (see Section 5.1).\n"
- title: 5.6.7.1.  RSA Encrypted Premaster Secret Message
  contents:
  - "5.6.7.1.  RSA Encrypted Premaster Secret Message\n   If RSA is being used for\
    \ key agreement and authentication, the client\n   generates a 48-byte premaster\
    \ secret, encrypts it under the public\n   key from the server's certificate or\
    \ temporary RSA key from a server\n   key exchange message, and sends the result\
    \ in an encrypted premaster\n   secret message.\n        struct {\n          \
    \  ProtocolVersion client_version;\n            opaque random[46];\n        }\
    \ PreMasterSecret;\n   client_version:  The latest (newest) version supported\
    \ by the client.\n      This is used to detect version roll-back attacks.\n  \
    \ random:  46 securely-generated random bytes.\n        struct {\n           \
    \ public-key-encrypted PreMasterSecret pre_master_secret;\n        } EncryptedPreMasterSecret;\n\
    \   pre_master_secret:  This random value is generated by the client and\n   \
    \   is used to generate the master secret, as specified in\n      Section 6.1.\n"
- title: 5.6.7.2.  FORTEZZA Key Exchange Message
  contents:
  - "5.6.7.2.  FORTEZZA Key Exchange Message\n   Under FORTEZZA, the client derives\
    \ a token encryption key (TEK) using\n   the FORTEZZA Key Exchange Algorithm (KEA).\
    \  The client's KEA\n   calculation uses the public key in the server's certificate\
    \ along\n   with private parameters in the client's token.  The client sends\n\
    \   public parameters needed for the server to generate the TEK, using\n   its\
    \ own private parameters.  The client generates session keys, wraps\n   them using\
    \ the TEK, and sends the results to the server.  The client\n   generates IVs\
    \ for the session keys and TEK and sends them also.  The\n   client generates\
    \ a random 48-byte premaster secret, encrypts it using\n   the TEK, and sends\
    \ the result:\n        struct {\n            opaque y_c<0..128>;\n           \
    \ opaque r_c[128];\n            opaque y_signature[40];\n            opaque wrapped_client_write_key[12];\n\
    \            opaque wrapped_server_write_key[12];\n            opaque client_write_iv[24];\n\
    \            opaque server_write_iv[24];\n            opaque master_secret_iv[24];\n\
    \            block-ciphered opaque encrypted_pre_master_secret[48];\n        }\
    \ FortezzaKeys;\n   y_signature:  y_signature is the signature of the KEA public\
    \ key,\n      signed with the client's DSS private key.\n   y_c:  The client's\
    \ Yc value (public key) for the KEA calculation.  If\n      the client has sent\
    \ a certificate, and its KEA public key is\n      suitable, this value must be\
    \ empty since the certificate already\n      contains this value.  If the client\
    \ sent a certificate without a\n      suitable public key, y_c is used and y_signature\
    \ is the KEA public\n      key signed with the client's DSS private key.  For\
    \ this value to\n      be used, it must be between 64 and 128 bytes.\n   r_c:\
    \  The client's Rc value for the KEA calculation.\n   wrapped_client_write_key:\
    \  This is the client's write key, wrapped by\n      the TEK.\n   wrapped_server_write_key:\
    \  This is the server's write key, wrapped by\n      the TEK.\n   client_write_iv:\
    \  The IV for the client write key.\n   server_write_iv:  The IV for the server\
    \ write key.\n   master_secret_iv:  This is the IV for the TEK used to encrypt\
    \ the\n      premaster secret.\n   pre_master_secret:  A random value, generated\
    \ by the client and used\n      to generate the master secret, as specified in\
    \ Section 6.1.  In\n      the above structure, it is encrypted using the TEK.\n"
- title: 5.6.7.3.  Client Diffie-Hellman Public Value
  contents:
  - "5.6.7.3.  Client Diffie-Hellman Public Value\n   This structure conveys the client's\
    \ Diffie-Hellman public value (Yc)\n   if it was not already included in the client's\
    \ certificate.  The\n   encoding used for Yc is determined by the enumerated\n\
    \   PublicValueEncoding.\n        enum { implicit, explicit } PublicValueEncoding;\n\
    \   implicit:  If the client certificate already contains the public\n      value,\
    \ then it is implicit and Yc does not need to be sent again.\n   explicit:  Yc\
    \ needs to be sent.\n        struct {\n            select (PublicValueEncoding)\
    \ {\n                case implicit: struct { };\n                case explicit:\
    \ opaque dh_Yc<1..2^16-1>;\n            } dh_public;\n        } ClientDiffieHellmanPublic;\n\
    \   dh_Yc:  The client's Diffie-Hellman public value (Yc).\n"
- title: 5.6.8.  Certificate Verify
  contents:
  - "5.6.8.  Certificate Verify\n   This message is used to provide explicit verification\
    \ of a client\n   certificate.  This message is only sent following any client\n\
    \   certificate that has signing capability (i.e., all certificates\n   except\
    \ those containing fixed Diffie-Hellman parameters).\n          struct {\n   \
    \            Signature signature;\n          } CertificateVerify;\n        CertificateVerify.signature.md5_hash\n\
    \                   MD5(master_secret + pad_2 +\n                       MD5(handshake_messages\
    \ + master_secret + pad_1));\n        Certificate.signature.sha_hash\n       \
    \            SHA(master_secret + pad_2 +\n                       SHA(handshake_messages\
    \ + master_secret + pad_1));\n   pad_1:  This is identical to the pad_1 defined\
    \ in Section 5.2.3.1.\n   pad_2:  This is identical to the pad_2 defined in Section\
    \ 5.2.3.1.\n   Here, handshake_messages refers to all handshake messages starting\
    \ at\n   client hello up to but not including this message.\n"
- title: 5.6.9.  Finished
  contents:
  - "5.6.9.  Finished\n   A finished message is always sent immediately after a change\
    \ cipher\n   spec message to verify that the key exchange and authentication\n\
    \   processes were successful.  The finished message is the first\n   protected\
    \ with the just-negotiated algorithms, keys, and secrets.  No\n   acknowledgment\
    \ of the finished message is required; parties may begin\n   sending encrypted\
    \ data immediately after sending the finished\n   message.  Recipients of finished\
    \ messages must verify that the\n   contents are correct.\n        enum { client(0x434C4E54),\
    \ server(0x53525652) } Sender;\n        struct {\n            opaque md5_hash[16];\n\
    \            opaque sha_hash[20];\n        } Finished;\n   md5_hash:  MD5(master_secret\
    \ + pad2 + MD5(handshake_messages + Sender\n      + master_secret + pad1));\n\
    \   sha_hash:  SHA(master_secret + pad2 + SHA(handshake_messages + Sender\n  \
    \    + master_secret + pad1));\n   handshake_messages:  All of the data from all\
    \ handshake messages up\n      to but not including this message.  This is only\
    \ data visible at\n      the handshake layer and does not include record layer\
    \ headers.\n   It is a fatal error if a finished message is not preceeded by a\n\
    \   change cipher spec message at the appropriate point in the handshake.\n  \
    \ The hash contained in finished messages sent by the server\n   incorporate Sender.server;\
    \ those sent by the client incorporate\n   Sender.client.  The value handshake_messages\
    \ includes all handshake\n   messages starting at client hello up to but not including\
    \ this\n   finished message.  This may be different from handshake_messages in\n\
    \   Section 5.6.8 because it would include the certificate verify message\n  \
    \ (if sent).\n   Note: Change cipher spec messages are not handshake messages\
    \ and are\n   not included in the hash computations.\n"
- title: 5.7.  Application Data Protocol
  contents:
  - "5.7.  Application Data Protocol\n   Application data messages are carried by\
    \ the record layer and are\n   fragmented, compressed, and encrypted based on\
    \ the current connection\n   state.  The messages are treated as transparent data\
    \ to the record\n   layer.\n"
- title: 6.  Cryptographic Computations
  contents:
  - "6.  Cryptographic Computations\n   The key exchange, authentication, encryption,\
    \ and MAC algorithms are\n   determined by the cipher_suite selected by the server\
    \ and revealed in\n   the server hello message.\n"
- title: 6.1.  Asymmetric Cryptographic Computations
  contents:
  - "6.1.  Asymmetric Cryptographic Computations\n   The asymmetric algorithms are\
    \ used in the handshake protocol to\n   authenticate parties and to generate shared\
    \ keys and secrets.\n   For Diffie-Hellman, RSA, and FORTEZZA, the same algorithm\
    \ is used to\n   convert the pre_master_secret into the master_secret.  The\n\
    \   pre_master_secret should be deleted from memory once the\n   master_secret\
    \ has been computed.\n        master_secret =\n          MD5(pre_master_secret\
    \ + SHA('A' + pre_master_secret +\n              ClientHello.random + ServerHello.random))\
    \ +\n          MD5(pre_master_secret + SHA('BB' + pre_master_secret +\n      \
    \        ClientHello.random + ServerHello.random)) +\n          MD5(pre_master_secret\
    \ + SHA('CCC' + pre_master_secret +\n              ClientHello.random + ServerHello.random));\n"
- title: 6.1.1.  RSA
  contents:
  - "6.1.1.  RSA\n   When RSA is used for server authentication and key exchange,\
    \ a 48-\n   byte pre_master_secret is generated by the client, encrypted under\n\
    \   the server's public key, and sent to the server.  The server uses its\n  \
    \ private key to decrypt the pre_master_secret.  Both parties then\n   convert\
    \ the pre_master_secret into the master_secret, as specified\n   above.\n   RSA\
    \ digital signatures are performed using PKCS #1 [PKCS1] block\n   type 1.  RSA\
    \ public key encryption is performed using PKCS #1 block\n   type 2.\n"
- title: 6.1.2.  Diffie-Hellman
  contents:
  - "6.1.2.  Diffie-Hellman\n   A conventional Diffie-Hellman computation is performed.\
    \  The\n   negotiated key (Z) is used as the pre_master_secret, and is converted\n\
    \   into the master_secret, as specified above.\n   Note: Diffie-Hellman parameters\
    \ are specified by the server, and may\n   be either ephemeral or contained within\
    \ the server's certificate.\n"
- title: 6.1.3.  FORTEZZA
  contents:
  - "6.1.3.  FORTEZZA\n   A random 48-byte pre_master_secret is sent encrypted under\
    \ the TEK\n   and its IV.  The server decrypts the pre_master_secret and converts\n\
    \   it into a master_secret, as specified above.  Bulk cipher keys and\n   IVs\
    \ for encryption are generated by the client's token and exchanged\n   in the\
    \ key exchange message; the master_secret is only used for MAC\n   computations.\n"
- title: 6.2.  Symmetric Cryptographic Calculations and the CipherSpec
  contents:
  - "6.2.  Symmetric Cryptographic Calculations and the CipherSpec\n   The technique\
    \ used to encrypt and verify the integrity of SSL records\n   is specified by\
    \ the currently active CipherSpec.  A typical example\n   would be to encrypt\
    \ data using DES and generate authentication codes\n   using MD5.  The encryption\
    \ and MAC algorithms are set to\n   SSL_NULL_WITH_NULL_NULL at the beginning of\
    \ the SSL handshake\n   protocol, indicating that no message authentication or\
    \ encryption is\n   performed.  The handshake protocol is used to negotiate a\
    \ more secure\n   CipherSpec and to generate cryptographic keys.\n"
- title: 6.2.1.  The Master Secret
  contents:
  - "6.2.1.  The Master Secret\n   Before secure encryption or integrity verification\
    \ can be performed\n   on records, the client and server need to generate shared\
    \ secret\n   information known only to themselves.  This value is a 48-byte\n\
    \   quantity called the master secret.  The master secret is used to\n   generate\
    \ keys and secrets for encryption and MAC computations.  Some\n   algorithms,\
    \ such as FORTEZZA, may have their own procedure for\n   generating encryption\
    \ keys (the master secret is used only for MAC\n   computations in FORTEZZA).\n"
- title: 6.2.2.  Converting the Master Secret into Keys and MAC Secrets
  contents:
  - "6.2.2.  Converting the Master Secret into Keys and MAC Secrets\n   The master\
    \ secret is hashed into a sequence of secure bytes, which\n   are assigned to\
    \ the MAC secrets, keys, and non-export IVs required by\n   the current CipherSpec\
    \ (see Appendix A.7).  CipherSpecs require a\n   client write MAC secret, a server\
    \ write MAC secret, a client write\n   key, a server write key, a client write\
    \ IV, and a server write IV,\n   which are generated from the master secret in\
    \ that order.  Unused\n   values, such as FORTEZZA keys communicated in the KeyExchange\n\
    \   message, are empty.  The following inputs are available to the key\n   definition\
    \ process:\n          opaque MasterSecret[48]\n          ClientHello.random\n\
    \          ServerHello.random\n   When generating keys and MAC secrets, the master\
    \ secret is used as an\n   entropy source, and the random values provide unencrypted\
    \ salt\n   material and IVs for exportable ciphers.\n   To generate the key material,\
    \ compute\n        key_block =\n          MD5(master_secret + SHA(`A' + master_secret\
    \ +\n                                  ServerHello.random +\n                \
    \                  ClientHello.random)) +\n          MD5(master_secret + SHA(`BB'\
    \ + master_secret +\n                                  ServerHello.random +\n\
    \                                  ClientHello.random)) +\n          MD5(master_secret\
    \ + SHA(`CCC' + master_secret +\n                                  ServerHello.random\
    \ +\n                                  ClientHello.random)) + [...];\n   until\
    \ enough output has been generated.  Then, the key_block is\n   partitioned as\
    \ follows.\n        client_write_MAC_secret[CipherSpec.hash_size]\n        server_write_MAC_secret[CipherSpec.hash_size]\n\
    \        client_write_key[CipherSpec.key_material]\n        server_write_key[CipherSpec.key_material]\n\
    \        client_write_IV[CipherSpec.IV_size] /* non-export ciphers */\n      \
    \  server_write_IV[CipherSpec.IV_size] /* non-export ciphers */\n   Any extra\
    \ key_block material is discarded.\n   Exportable encryption algorithms (for which\
    \ CipherSpec.is_exportable\n   is true) require additional processing as follows\
    \ to derive their\n   final write keys:\n        final_client_write_key = MD5(client_write_key\
    \ +\n                                     ClientHello.random +\n             \
    \                        ServerHello.random);\n        final_server_write_key\
    \ = MD5(server_write_key +\n                                     ServerHello.random\
    \ +\n                                     ClientHello.random);\n   Exportable\
    \ encryption algorithms derive their IVs from the random\n   messages:\n     \
    \   client_write_IV = MD5(ClientHello.random + ServerHello.random);\n        server_write_IV\
    \ = MD5(ServerHello.random + ClientHello.random);\n   MD5 outputs are trimmed\
    \ to the appropriate size by discarding the\n   least-significant bytes.\n"
- title: 6.2.2.1.  Export Key Generation Example
  contents:
  - "6.2.2.1.  Export Key Generation Example\n   SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5\
    \ requires five random bytes for\n   each of the two encryption keys and 16 bytes\
    \ for each of the MAC\n   keys, for a total of 42 bytes of key material.  MD5\
    \ produces 16 bytes\n   of output per call, so three calls to MD5 are required.\
    \  The MD5\n   outputs are concatenated into a 48-byte key_block with the first\
    \ MD5\n   call providing bytes zero through 15, the second providing bytes 16\n\
    \   through 31, etc.  The key_block is partitioned, and the write keys\n   are\
    \ salted because this is an exportable encryption algorithm.\n        client_write_MAC_secret\
    \ = key_block[0..15]\n        server_write_MAC_secret = key_block[16..31]\n  \
    \      client_write_key      = key_block[32..36]\n        server_write_key   \
    \   = key_block[37..41]\n        final_client_write_key = MD5(client_write_key\
    \ +\n                                     ClientHello.random +\n             \
    \                        ServerHello.random)[0..15];\n        final_server_write_key\
    \ = MD5(server_write_key +\n                                     ServerHello.random\
    \ +\n                                     ClientHello.random)[0..15];\n      \
    \  client_write_IV = MD5(ClientHello.random +\n                              ServerHello.random)[0..7];\n\
    \        server_write_IV = MD5(ServerHello.random +\n                        \
    \      ClientHello.random)[0..7];\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   See Appendix F.\n"
- title: 8.  Informative References
  contents:
  - "8.  Informative References\n   [DH1]      Diffie, W. and M. Hellman, \"New Directions\
    \ in\n              Cryptography\", IEEE Transactions on Information Theory V.\n\
    \              IT-22, n. 6, pp. 74-84, June 1977.\n   [SSL-2]    Hickman, K.,\
    \ \"The SSL Protocol\", February 1995.\n   [3DES]     Tuchman, W., \"Hellman Presents\
    \ No Shortcut Solutions To\n              DES\", IEEE Spectrum, v. 16, n. 7, pp\
    \ 40-41, July 1979.\n   [DES]      ANSI X3.106, \"American National Standard for\
    \ Information\n              Systems-Data Link Encryption\", American National\n\
    \              Standards Institute, 1983.\n   [DSS]      NIST FIPS PUB 186, \"\
    Digital Signature Standard\", National\n              Institute of Standards and\
    \ Technology U.S. Department of\n              Commerce, May 1994.\n   [FOR] \
    \     NSA X22, \"FORTEZZA: Application Implementers Guide\",\n              Document\
    \ # PD4002103-1.01, April 1995.\n   [RFC0959]  Postel, J. and J. Reynolds, \"\
    File Transfer Protocol\",\n              STD 9, RFC 959, October 1985.\n   [RFC0791]\
    \  Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n              September\
    \ 1981.\n   [RFC1945]  Berners-Lee, T., Fielding, R., and H. Nielsen, \"Hypertext\n\
    \              Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n   [RFC1321]\
    \  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n             \
    \ April 1992.\n   [RFC0793]  Postel, J., \"Transmission Control Protocol\", STD\
    \ 7,\n              RFC 793, September 1981.\n   [RFC0854]  Postel, J. and J.\
    \ Reynolds, \"Telnet Protocol\n              Specification\", STD 8, RFC 854,\
    \ May 1983.\n   [RFC1832]  Srinivasan, R., \"XDR: External Data Representation\n\
    \              Standard\", RFC 1832, August 1995.\n   [RFC2104]  Krawczyk, H.,\
    \ Bellare, M., and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message\
    \ Authentication\", RFC 2104,\n              February 1997.\n   [IDEA]     Lai,\
    \ X., \"On the Design and Security of Block Ciphers\",\n              ETH Series\
    \ in Information Processing, v. 1, Konstanz:\n              Hartung-Gorre Verlag,\
    \ 1992.\n   [PKCS1]    RSA Laboratories, \"PKCS #1: RSA Encryption Standard\n\
    \              version 1.5\", November 1993.\n   [PKCS6]    RSA Laboratories,\
    \ \"PKCS #6: RSA Extended Certificate\n              Syntax Standard version 1.5\"\
    , November 1993.\n   [PKCS7]    RSA Laboratories, \"PKCS #7: RSA Cryptographic\
    \ Message\n              Syntax Standard version 1.5\", November 1993.\n   [RSA]\
    \      Rivest, R., Shamir, A., and L. Adleman, \"A Method for\n              Obtaining\
    \ Digital Signatures and Public-Key\n              Cryptosystems\", Communications\
    \ of the ACM v. 21, n. 2 pp.\n              120-126., February 1978.\n   [SCH]\
    \      Schneier, B., \"Applied Cryptography: Protocols,\n              Algorithms,\
    \ and Source Code in C\", John Wiley & Sons,\n              1994.\n   [SHA]  \
    \    NIST FIPS PUB 180-1, \"Secure Hash Standard\", May 1994.\n              National\
    \ Institute of Standards and Technology, U.S.\n              Department of Commerce,\
    \ DRAFT\n   [X509]     CCITT, \"The Directory - Authentication Framework\",\n\
    \              Recommendation X.509 , 1988.\n   [RSADSI]   RSA Data Security,\
    \ Inc., \"Unpublished works\".\n"
- title: Appendix A.  Protocol Constant Values
  contents:
  - "Appendix A.  Protocol Constant Values\n   This section describes protocol types\
    \ and constants.\n"
- title: A.1.  Record Layer
  contents:
  - "A.1.  Record Layer\n        struct {\n            uint8 major, minor;\n     \
    \   } ProtocolVersion;\n        ProtocolVersion version = { 3,0 };\n        enum\
    \ {\n            change_cipher_spec(20), alert(21), handshake(22),\n         \
    \   application_data(23), (255)\n        } ContentType;\n        struct {\n  \
    \          ContentType type;\n            ProtocolVersion version;\n         \
    \   uint16 length;\n            opaque fragment[SSLPlaintext.length];\n      \
    \  } SSLPlaintext;\n        struct {\n            ContentType type;\n        \
    \    ProtocolVersion version;\n            uint16 length;\n            opaque\
    \ fragment[SSLCompressed.length];\n        } SSLCompressed;\n        struct {\n\
    \            ContentType type;\n            ProtocolVersion version;\n       \
    \     uint16 length;\n            select (CipherSpec.cipher_type) {\n        \
    \        case stream: GenericStreamCipher;\n                case block:  GenericBlockCipher;\n\
    \            } fragment;\n        } SSLCiphertext;\n        stream-ciphered struct\
    \ {\n            opaque content[SSLCompressed.length];\n            opaque MAC[CipherSpec.hash_size];\n\
    \        } GenericStreamCipher;\n        block-ciphered struct {\n           \
    \ opaque content[SSLCompressed.length];\n            opaque MAC[CipherSpec.hash_size];\n\
    \            uint8 padding[GenericBlockCipher.padding_length];\n            uint8\
    \ padding_length;\n        } GenericBlockCipher;\n"
- title: A.2.  Change Cipher Specs Message
  contents:
  - "A.2.  Change Cipher Specs Message\n        struct {\n            enum { change_cipher_spec(1),\
    \ (255) } type;\n        } ChangeCipherSpec;\n"
- title: A.3.  Alert Messages
  contents:
  - "A.3.  Alert Messages\n        enum { warning(1), fatal(2), (255) } AlertLevel;\n\
    \        enum {\n            close_notify(0),\n            unexpected_message(10),\n\
    \            bad_record_mac(20),\n            decompression_failure(30),\n   \
    \         handshake_failure(40),\n            no_certificate(41),\n          \
    \  bad_certificate(42),\n            unsupported_certificate(43),\n          \
    \  certificate_revoked(44),\n            certificate_expired(45),\n          \
    \  certificate_unknown(46),\n            illegal_parameter (47),\n           \
    \ (255)\n        } AlertDescription;\n        struct {\n            AlertLevel\
    \ level;\n            AlertDescription description;\n        } Alert;\n"
- title: A.4.  Handshake Protocol
  contents:
  - "A.4.  Handshake Protocol\n      enum {\n          hello_request(0), client_hello(1),\
    \ server_hello(2),\n          certificate(11), server_key_exchange (12),\n   \
    \       certificate_request(13), server_done(14),\n          certificate_verify(15),\
    \ client_key_exchange(16),\n          finished(20), (255)\n      } HandshakeType;\n\
    \        struct {\n            HandshakeType msg_type;\n            uint24 length;\n\
    \            select (HandshakeType) {\n                case hello_request: HelloRequest;\n\
    \                case client_hello: ClientHello;\n                case server_hello:\
    \ ServerHello;\n                case certificate: Certificate;\n             \
    \   case server_key_exchange: ServerKeyExchange;\n                case certificate_request:\
    \ CertificateRequest;\n                case server_done: ServerHelloDone;\n  \
    \              case certificate_verify: CertificateVerify;\n                case\
    \ client_key_exchange: ClientKeyExchange;\n                case finished: Finished;\n\
    \            } body;\n        } Handshake;\n"
- title: A.4.1.  Hello Messages
  contents:
  - "A.4.1.  Hello Messages\n        struct { } HelloRequest;\n        struct {\n\
    \            uint32 gmt_unix_time;\n            opaque random_bytes[28];\n   \
    \     } Random;\n        opaque SessionID<0..32>;\n        uint8 CipherSuite[2];\n\
    \        enum { null(0), (255) } CompressionMethod;\n        struct {\n      \
    \      ProtocolVersion client_version;\n            Random random;\n         \
    \   SessionID session_id;\n            CipherSuite cipher_suites<0..2^16-1>;\n\
    \            CompressionMethod compression_methods<0..2^8-1>;\n        } ClientHello;\n\
    \        struct {\n            ProtocolVersion server_version;\n            Random\
    \ random;\n            SessionID session_id;\n            CipherSuite cipher_suite;\n\
    \            CompressionMethod compression_method;\n        } ServerHello;\n"
- title: A.4.2.  Server Authentication and Key Exchange Messages
  contents:
  - "A.4.2.  Server Authentication and Key Exchange Messages\n        opaque ASN.1Cert<2^24-1>;\n\
    \        struct {\n            ASN.1Cert certificate_list<1..2^24-1>;\n      \
    \  } Certificate;\n        enum { rsa, diffie_hellman, fortezza_kea } KeyExchangeAlgorithm;\n\
    \        struct {\n            opaque RSA_modulus<1..2^16-1>;\n            opaque\
    \ RSA_exponent<1..2^16-1>;\n        } ServerRSAParams;\n        struct {\n   \
    \         opaque DH_p<1..2^16-1>;\n            opaque DH_g<1..2^16-1>;\n     \
    \       opaque DH_Ys<1..2^16-1>;\n        } ServerDHParams;\n        struct {\n\
    \            opaque r_s [128]\n        } ServerFortezzaParams\n        struct\
    \ {\n            select (KeyExchangeAlgorithm) {\n                case diffie_hellman:\n\
    \                    ServerDHParams params;\n                    Signature signed_params;\n\
    \                case rsa:\n                    ServerRSAParams params;\n    \
    \                Signature signed_params;\n                case fortezza_kea:\n\
    \                    ServerFortezzaParams params;\n            };\n        } ServerKeyExchange;\n\
    \        enum { anonymous, rsa, dsa } SignatureAlgorithm;\n        digitally-signed\
    \ struct {\n            select(SignatureAlgorithm) {\n                case anonymous:\
    \ struct { };\n                case rsa:\n                    opaque md5_hash[16];\n\
    \                    opaque sha_hash[20];\n                case dsa:\n       \
    \             opaque sha_hash[20];\n            };\n        } Signature;\n   \
    \     enum {\n            RSA_sign(1), DSS_sign(2), RSA_fixed_DH(3),\n       \
    \     DSS_fixed_DH(4), RSA_ephemeral_DH(5), DSS_ephemeral_DH(6),\n           \
    \ FORTEZZA_MISSI(20), (255)\n        } CertificateType;\n        opaque DistinguishedName<1..2^16-1>;\n\
    \        struct {\n            CertificateType certificate_types<1..2^8-1>;\n\
    \            DistinguishedName certificate_authorities<3..2^16-1>;\n        }\
    \ CertificateRequest;\n        struct { } ServerHelloDone;\n"
- title: A.5.  Client Authentication and Key Exchange Messages
  contents:
  - "A.5.  Client Authentication and Key Exchange Messages\n        struct {\n   \
    \         select (KeyExchangeAlgorithm) {\n                case rsa: EncryptedPreMasterSecret;\n\
    \                case diffie_hellman: DiffieHellmanClientPublicValue;\n      \
    \          case fortezza_kea: FortezzaKeys;\n            } exchange_keys;\n  \
    \      } ClientKeyExchange;\n        struct {\n            ProtocolVersion client_version;\n\
    \            opaque random[46];\n        } PreMasterSecret;\n        struct {\n\
    \            public-key-encrypted PreMasterSecret pre_master_secret;\n       \
    \ } EncryptedPreMasterSecret;\n        struct {\n            opaque y_c<0..128>;\n\
    \            opaque r_c[128];\n            opaque y_signature[40];\n         \
    \   opaque wrapped_client_write_key[12];\n            opaque wrapped_server_write_key[12];\n\
    \            opaque client_write_iv[24];\n            opaque server_write_iv[24];\n\
    \            opaque master_secret_iv[24];\n            opaque encrypted_preMasterSecret[48];\n\
    \        } FortezzaKeys;\n        enum { implicit, explicit } PublicValueEncoding;\n\
    \        struct {\n            select (PublicValueEncoding) {\n              \
    \  case implicit: struct {};\n                case explicit: opaque DH_Yc<1..2^16-1>;\n\
    \            } dh_public;\n        } ClientDiffieHellmanPublic;\n        struct\
    \ {\n            Signature signature;\n        } CertificateVerify;\n"
- title: A.5.1.  Handshake Finalization Message
  contents:
  - "A.5.1.  Handshake Finalization Message\n        struct {\n            opaque\
    \ md5_hash[16];\n            opaque sha_hash[20];\n        } Finished;\n"
- title: A.6.  The CipherSuite
  contents:
  - "A.6.  The CipherSuite\n   The following values define the CipherSuite codes used\
    \ in the client\n   hello and server hello messages.\n   A CipherSuite defines\
    \ a cipher specifications supported in SSL\n   version 3.0.\n     CipherSuite\
    \ SSL_NULL_WITH_NULL_NULL                = { 0x00,0x00 };\n   The following CipherSuite\
    \ definitions require that the server provide\n   an RSA certificate that can\
    \ be used for key exchange.  The server may\n   request either an RSA or a DSS\
    \ signature-capable certificate in the\n   certificate request message.\n    \
    \ CipherSuite SSL_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };\n     CipherSuite\
    \ SSL_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };\n     CipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5\
    \         = { 0x00,0x03 };\n     CipherSuite SSL_RSA_WITH_RC4_128_MD5        \
    \       = { 0x00,0x04 };\n     CipherSuite SSL_RSA_WITH_RC4_128_SHA          \
    \     = { 0x00,0x05 };\n     CipherSuite SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5  \
    \   = { 0x00,0x06 };\n     CipherSuite SSL_RSA_WITH_IDEA_CBC_SHA             \
    \ = { 0x00,0x07 };\n     CipherSuite SSL_RSA_EXPORT_WITH_DES40_CBC_SHA      =\
    \ { 0x00,0x08 };\n     CipherSuite SSL_RSA_WITH_DES_CBC_SHA               = {\
    \ 0x00,0x09 };\n     CipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A\
    \ };\n   The following CipherSuite definitions are used for server-\n   authenticated\
    \ (and optionally client-authenticated) Diffie-Hellman.\n   DH denotes cipher\
    \ suites in which the server's certificate contains\n   the Diffie-Hellman parameters\
    \ signed by the certificate authority\n   (CA).  DHE denotes ephemeral Diffie-Hellman,\
    \ where the Diffie-Hellman\n   parameters are signed by a DSS or RSA certificate,\
    \ which has been\n   signed by the CA.  The signing algorithm used is specified\
    \ after the\n   DH or DHE parameter.  In all cases, the client must have the same\n\
    \   type of certificate, and must use the Diffie-Hellman parameters\n   chosen\
    \ by the server.\n     CipherSuite SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = {\
    \ 0x00,0x0B };\n     CipherSuite SSL_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C\
    \ };\n     CipherSuite SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };\n\
    \     CipherSuite SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };\n  \
    \   CipherSuite SSL_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };\n    \
    \ CipherSuite SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };\n     CipherSuite\
    \ SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };\n     CipherSuite SSL_DHE_DSS_WITH_DES_CBC_SHA\
    \           = { 0x00,0x12 };\n     CipherSuite SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\
    \      = { 0x00,0x13 };\n     CipherSuite SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\
    \  = { 0x00,0x14 };\n     CipherSuite SSL_DHE_RSA_WITH_DES_CBC_SHA           =\
    \ { 0x00,0x15 };\n     CipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = {\
    \ 0x00,0x16 };\n   The following cipher suites are used for completely anonymous\
    \ Diffie-\n   Hellman communications in which neither party is authenticated.\
    \  Note\n   that this mode is vulnerable to man-in-the-middle attacks and is\n\
    \   therefore strongly discouraged.\n     CipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5\
    \     = { 0x00,0x17 };\n     CipherSuite SSL_DH_anon_WITH_RC4_128_MD5        \
    \   = { 0x00,0x18 };\n     CipherSuite SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA \
    \ = { 0x00,0x19 };\n     CipherSuite SSL_DH_anon_WITH_DES_CBC_SHA           =\
    \ { 0x00,0x1A };\n     CipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA      = {\
    \ 0x00,0x1B };\n   The final cipher suites are for the FORTEZZA token.\n     CipherSuite\
    \ SSL_FORTEZZA_KEA_WITH_NULL_SHA         = { 0X00,0X1C };\n     CipherSuite SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA\
    \ = { 0x00,0x1D };\n     CipherSuite SSL_FORTEZZA_KEA_WITH_RC4_128_SHA      =\
    \ { 0x00,0x1E };\n   Note: All cipher suites whose first byte is 0xFF are considered\n\
    \   private and can be used for defining local/experimental algorithms.\n   Interoperability\
    \ of such types is a local matter.\n"
- title: A.7.  The CipherSpec
  contents:
  - "A.7.  The CipherSpec\n   A cipher suite identifies a CipherSpec.  These structures\
    \ are part of\n   the SSL session state.  The CipherSpec includes:\n        enum\
    \ { stream, block } CipherType;\n        enum { true, false } IsExportable;\n\
    \        enum { null, rc4, rc2, des, 3des, des40, fortezza }\n            BulkCipherAlgorithm;\n\
    \        enum { null, md5, sha } MACAlgorithm;\n        struct {\n           \
    \ BulkCipherAlgorithm bulk_cipher_algorithm;\n            MACAlgorithm mac_algorithm;\n\
    \            CipherType cipher_type;\n            IsExportable is_exportable\n\
    \            uint8 hash_size;\n            uint8 key_material;\n            uint8\
    \ IV_size;\n        } CipherSpec;\n"
- title: Appendix B.  Glossary
  contents:
  - "Appendix B.  Glossary\n   application protocol:  An application protocol is a\
    \ protocol that\n      normally layers directly on top of the transport layer\
    \ (e.g.,\n      TCP/IP [RFC0793]/[RFC0791]).  Examples include HTTP [RFC1945],\n\
    \      TELNET [RFC0959], FTP [RFC0854], and SMTP.\n   asymmetric cipher:  See\
    \ public key cryptography.\n   authentication:  Authentication is the ability\
    \ of one entity to\n      determine the identity of another entity.\n   block\
    \ cipher:  A block cipher is an algorithm that operates on\n      plaintext in\
    \ groups of bits, called blocks. 64 bits is a typical\n      block size.\n   bulk\
    \ cipher:  A symmetric encryption algorithm used to encrypt large\n      quantities\
    \ of data.\n   cipher block chaining (CBC) mode:  CBC is a mode in which every\n\
    \      plaintext block encrypted with the block cipher is first\n      exclusive-ORed\
    \ with the previous ciphertext block (or, in the case\n      of the first block,\
    \ with the initialization vector).\n   certificate:  As part of the X.509 protocol\
    \ (a.k.a.  ISO\n      Authentication framework), certificates are assigned by\
    \ a trusted\n      certificate authority and provide verification of a party's\n\
    \      identity and may also supply its public key.\n   client:  The application\
    \ entity that initiates a connection to a\n      server.\n   client write key:\
    \  The key used to encrypt data written by the\n      client.\n   client write\
    \ MAC secret:  The secret data used to authenticate data\n      written by the\
    \ client.\n   connection:  A connection is a transport (in the OSI layering model\n\
    \      definition) that provides a suitable type of service.  For SSL,\n     \
    \ such connections are peer-to-peer relationships.  The connections\n      are\
    \ transient.  Every connection is associated with one session.\n   Data Encryption\
    \ Standard (DES):  DES is a very widely used symmetric\n      encryption algorithm.\
    \  DES is a block cipher [DES] [3DES].\n   Digital Signature Standard:  (DSS)\
    \ A standard for digital signing,\n      including the Digital Signature Algorithm,\
    \ approved by the\n      National Institute of Standards and Technology, defined\
    \ in NIST\n      FIPS PUB 186, \"Digital Signature Standard,\" published May,\
    \ 1994 by\n      the U.S. Dept. of Commerce.\n   digital signatures:  Digital\
    \ signatures utilize public key\n      cryptography and one-way hash functions\
    \ to produce a signature of\n      the data that can be authenticated, and is\
    \ difficult to forge or\n      repudiate.\n   FORTEZZA:  A PCMCIA card that provides\
    \ both encryption and digital\n      signing.\n   handshake:  An initial negotiation\
    \ between client and server that\n      establishes the parameters of their transactions.\n\
    \   Initialization Vector (IV):  When a block cipher is used in CBC mode,\n  \
    \    the initialization vector is exclusive-ORed with the first\n      plaintext\
    \ block prior to encryption.\n   IDEA:  A 64-bit block cipher designed by Xuejia\
    \ Lai and James Massey\n      [IDEA].\n   Message Authentication Code (MAC): \
    \ A Message Authentication Code is\n      a one-way hash computed from a message\
    \ and some secret data.  Its\n      purpose is to detect if the message has been\
    \ altered.\n   master secret:  Secure secret data used for generating encryption\n\
    \      keys, MAC secrets, and IVs.\n   MD5:  MD5 [RFC1321] is a secure hashing\
    \ function that converts an\n      arbitrarily long data stream into a digest\
    \ of fixed size.\n   public key cryptography:  A class of cryptographic techniques\n\
    \      employing two-key ciphers.  Messages encrypted with the public key\n  \
    \    can only be decrypted with the associated private key.\n      Conversely,\
    \ messages signed with the private key can be verified\n      with the public\
    \ key.\n   one-way hash function:  A one-way transformation that converts an\n\
    \      arbitrary amount of data into a fixed-length hash.  It is\n      computationally\
    \ hard to reverse the transformation or to find\n      collisions.  MD5 and SHA\
    \ are examples of one-way hash functions.\n   RC2, RC4:  Proprietary bulk ciphers\
    \ from RSA Data Security, Inc.\n      (There is no good reference to these as\
    \ they are unpublished\n      works; however, see [RSADSI]).  RC2 is a block cipher\
    \ and RC4 is a\n      stream cipher.\n   RSA:  A very widely used public key algorithm\
    \ that can be used for\n      either encryption or digital signing.\n   salt:\
    \  Non-secret random data used to make export encryption keys\n      resist precomputation\
    \ attacks.\n   server:  The server is the application entity that responds to\n\
    \      requests for connections from clients.  The server is passive,\n      waiting\
    \ for requests from clients.\n   session:  An SSL session is an association between\
    \ a client and a\n      server.  Sessions are created by the handshake protocol.\
    \  Sessions\n      define a set of cryptographic security parameters, which can\
    \ be\n      shared among multiple connections.  Sessions are used to avoid the\n\
    \      expensive negotiation of new security parameters for each\n      connection.\n\
    \   session identifier:  A session identifier is a value generated by a\n    \
    \  server that identifies a particular session.\n   server write key:  The key\
    \ used to encrypt data written by the\n      server.\n   server write MAC secret:\
    \  The secret data used to authenticate data\n      written by the server.\n \
    \  SHA:  The Secure Hash Algorithm is defined in FIPS PUB 180-1.  It\n      produces\
    \ a 20-byte output [SHA].\n   stream cipher:  An encryption algorithm that converts\
    \ a key into a\n      cryptographically strong keystream, which is then exclusive-ORed\n\
    \      with the plaintext.\n   symmetric cipher:  See bulk cipher.\n"
- title: Appendix C.  CipherSuite Definitions
  contents:
  - 'Appendix C.  CipherSuite Definitions

    '
- title: CipherSuite                  Is         Key            Cipher       Hash
  contents:
  - "CipherSuite                  Is         Key            Cipher       Hash\n  \
    \                           Exportable Exchange\n"
- title: SSL_NULL_WITH_NULL_NULL               * NULL           NULL         NULL
  contents:
  - 'SSL_NULL_WITH_NULL_NULL               * NULL           NULL         NULL

    '
- title: SSL_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5
  contents:
  - 'SSL_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5

    '
- title: SSL_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA
  contents:
  - 'SSL_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA

    '
- title: SSL_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5
  contents:
  - 'SSL_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5

    '
- title: SSL_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5
  contents:
  - 'SSL_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5

    '
- title: SSL_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA
  contents:
  - 'SSL_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA

    '
- title: SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5
  contents:
  - 'SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5

    '
- title: SSL_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA
  contents:
  - 'SSL_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA

    '
- title: SSL_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA
  contents:
  - 'SSL_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA

    '
- title: SSL_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA
  contents:
  - 'SSL_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA

    '
- title: SSL_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA
  contents:
  - 'SSL_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA

    '
- title: SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA
  contents:
  - 'SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA

    '
- title: SSL_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA
  contents:
  - 'SSL_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA

    '
- title: SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA
  contents:
  - 'SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA

    '
- title: SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA
  contents:
  - 'SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA

    '
- title: SSL_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA
  contents:
  - 'SSL_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA

    '
- title: SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA
  contents:
  - 'SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA

    '
- title: SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA
  contents:
  - 'SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA

    '
- title: SSL_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA
  contents:
  - 'SSL_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA

    '
- title: SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA
  contents:
  - 'SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA

    '
- title: SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA
  contents:
  - 'SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA

    '
- title: SSL_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA
  contents:
  - 'SSL_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA

    '
- title: SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA
  contents:
  - 'SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA

    '
- title: SSL_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5
  contents:
  - 'SSL_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5

    '
- title: SSL_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5
  contents:
  - 'SSL_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5

    '
- title: SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA
  contents:
  - 'SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA

    '
- title: SSL_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA
  contents:
  - 'SSL_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA

    '
- title: SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA
  contents:
  - 'SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA

    '
- title: SSL_FORTEZZA_KEA_WITH_NULL_SHA          FORTEZZA_KEA   NULL         SHA
  contents:
  - 'SSL_FORTEZZA_KEA_WITH_NULL_SHA          FORTEZZA_KEA   NULL         SHA

    '
- title: SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA  FORTEZZA_KEA   FORTEZZA_CBC SHA
  contents:
  - 'SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA  FORTEZZA_KEA   FORTEZZA_CBC SHA

    '
- title: SSL_FORTEZZA_KEA_WITH_RC4_128_SHA       FORTEZZA_KEA   RC4_128      SHA
  contents:
  - "SSL_FORTEZZA_KEA_WITH_RC4_128_SHA       FORTEZZA_KEA   RC4_128      SHA\n   +----------------+------------------------------+-------------------+\n\
    \   |  Key Exchange  |          Description         |   Key Size Limit  |\n  \
    \ |    Algorithm   |                              |                   |\n   +----------------+------------------------------+-------------------+\n\
    \   |     DHE_DSS    |     Ephemeral DH with DSS    |        None       |\n  \
    \ |                |          signatures          |                   |\n   |\
    \ DHE_DSS_EXPORT |     Ephemeral DH with DSS    |   DH = 512 bits   |\n   |  \
    \              |          signatures          |                   |\n   |    \
    \ DHE_RSA    |     Ephemeral DH with RSA    |        None       |\n   |      \
    \          |          signatures          |                   |\n   | DHE_RSA_EXPORT\
    \ |     Ephemeral DH with RSA    |   DH = 512 bits,  |\n   |                |\
    \          signatures          |     RSA = none    |\n   |     DH_anon    |  Anonymous\
    \ DH, no signatures |        None       |\n   | DH_anon_EXPORT |  Anonymous DH,\
    \ no signatures |   DH = 512 bits   |\n   |     DH_DSS     |       DH with DSS-based\
    \      |        None       |\n   |                |         certificates     \
    \    |                   |\n   |  DH_DSS_EXPORT |       DH with DSS-based    \
    \  |   DH = 512 bits   |\n   |                |         certificates         |\
    \                   |\n   |     DH_RSA     |       DH with RSA-based      |  \
    \      None       |\n   |                |         certificates         |    \
    \               |\n   |  DH_RSA_EXPORT |       DH with RSA-based      |   DH =\
    \ 512 bits,  |\n   |                |         certificates         |     RSA =\
    \ none    |\n   |  FORTEZZA_KEA  |     FORTEZZA KEA. Details    |        N/A \
    \       |\n   |                |          unpublished         |              \
    \     |\n   |      NULL      |        No key exchange       |        N/A     \
    \   |\n   |       RSA      |       RSA key exchange       |        None      \
    \ |\n   |   RSA_EXPORT   |       RSA key exchange       |   RSA = 512 bits  |\n\
    \   +----------------+------------------------------+-------------------+\n  \
    \                                Table 1\n   Key size limit:  The key size limit\
    \ gives the size of the largest\n      public key that can be legally used for\
    \ encryption in cipher\n      suites that are exportable.\n   +--------------+--------+-----+-------+-------+-------+------+------+\n\
    \   | Cipher       | Cipher | IsE |  Key  |  Exp. | Effec |  IV  | Bloc |\n  \
    \ |              |  Type  | xpo | Mater |  Key  |  tive | Size |   k  |\n   |\
    \              |        | rta |  ial  | Mater |  Key  |      | Size |\n   |  \
    \            |        | ble |       |  ial  |  Bits |      |      |\n   +--------------+--------+-----+-------+-------+-------+------+------+\n\
    \   | NULL         | Stream |  *  |   0   |   0   |   0   |   0  |  N/A |\n  \
    \ | FORTEZZA_CBC |  Block |     |   NA  |   12  |   96  |  20  |   8  |\n   |\
    \              |        |     |  (**) |  (**) |  (**) | (**) |      |\n   | IDEA_CBC\
    \     |  Block |     |   16  |   16  |  128  |   8  |   8  |\n   | RC2_CBC_40\
    \   |  Block |  *  |   5   |   16  |   40  |   8  |   8  |\n   | RC4_40      \
    \ | Stream |  *  |   5   |   16  |   40  |   0  |  N/A |\n   | RC4_128      |\
    \ Stream |     |   16  |   16  |  128  |   0  |  N/A |\n   | DES40_CBC    |  Block\
    \ |  *  |   5   |   8   |   40  |   8  |   8  |\n   | DES_CBC      |  Block |\
    \     |   8   |   8   |   56  |   8  |   8  |\n   | 3DES_EDE_CBC |  Block |  \
    \   |   24  |   24  |  168  |   8  |   8  |\n   +--------------+--------+-----+-------+-------+-------+------+------+\n\
    \                     * Indicates IsExportable is true.\n        ** FORTEZZA uses\
    \ its own key and IV generation algorithms.\n                                \
    \  Table 2\n   Key Material:  The number of bytes from the key_block that are\
    \ used\n      for generating the write keys.\n   Expanded Key Material:  The number\
    \ of bytes actually fed into the\n      encryption algorithm.\n   Effective Key\
    \ Bits:  How much entropy material is in the key material\n      being fed into\
    \ the encryption routines.\n               +---------------+-----------+--------------+\n\
    \               | Hash Function | Hash Size | Padding Size |\n               +---------------+-----------+--------------+\n\
    \               |      NULL     |     0     |       0      |\n               |\
    \      MD5      |     16    |      48      |\n               |      SHA      |\
    \     20    |      40      |\n               +---------------+-----------+--------------+\n\
    \                                  Table 3\n"
- title: Appendix D.  Implementation Notes
  contents:
  - "Appendix D.  Implementation Notes\n   The SSL protocol cannot prevent many common\
    \ security mistakes.  This\n   section provides several recommendations to assist\
    \ implementers.\n"
- title: D.1.  Temporary RSA Keys
  contents:
  - "D.1.  Temporary RSA Keys\n   US export restrictions limit RSA keys used for encryption\
    \ to 512\n   bits, but do not place any limit on lengths of RSA keys used for\n\
    \   signing operations.  Certificates often need to be larger than 512\n   bits,\
    \ since 512-bit RSA keys are not secure enough for high-value\n   transactions\
    \ or for applications requiring long-term security.  Some\n   certificates are\
    \ also designated signing-only, in which case they\n   cannot be used for key\
    \ exchange.\n   When the public key in the certificate cannot be used for encryption,\n\
    \   the server signs a temporary RSA key, which is then exchanged.  In\n   exportable\
    \ applications, the temporary RSA key should be the maximum\n   allowable length\
    \ (i.e., 512 bits).  Because 512-bit RSA keys are\n   relatively insecure, they\
    \ should be changed often.  For typical\n   electronic commerce applications,\
    \ it is suggested that keys be\n   changed daily or every 500 transactions, and\
    \ more often if possible.\n   Note that while it is acceptable to use the same\
    \ temporary key for\n   multiple transactions, it must be signed each time it\
    \ is used.\n   RSA key generation is a time-consuming process.  In many cases,\
    \ a\n   low-priority process can be assigned the task of key generation.\n   Whenever\
    \ a new key is completed, the existing temporary key can be\n   replaced with\
    \ the new one.\n"
- title: D.2.  Random Number Generation and Seeding
  contents:
  - "D.2.  Random Number Generation and Seeding\n   SSL requires a cryptographically\
    \ secure pseudorandom number generator\n   (PRNG).  Care must be taken in designing\
    \ and seeding PRNGs.  PRNGs\n   based on secure hash operations, most notably\
    \ MD5 and/or SHA, are\n   acceptable, but cannot provide more security than the\
    \ size of the\n   random number generator state.  (For example, MD5-based PRNGs\
    \ usually\n   provide 128 bits of state.)\n   To estimate the amount of seed material\
    \ being produced, add the\n   number of bits of unpredictable information in each\
    \ seed byte.  For\n   example, keystroke timing values taken from a PC-compatible's\
    \ 18.2 Hz\n   timer provide 1 or 2 secure bits each, even though the total size\
    \ of\n   the counter value is 16 bits or more.  To seed a 128-bit PRNG, one\n\
    \   would thus require approximately 100 such timer values.\n   Note: The seeding\
    \ functions in RSAREF and versions of BSAFE prior to\n   3.0 are order independent.\
    \  For example, if 1000 seed bits are\n   supplied, one at a time, in 1000 separate\
    \ calls to the seed function,\n   the PRNG will end up in a state that depends\
    \ only on the number of 0\n   or 1 seed bits in the seed data (i.e., there are\
    \ 1001 possible final\n   states).  Applications using BSAFE or RSAREF must take\
    \ extra care to\n   ensure proper seeding.\n"
- title: D.3.  Certificates and Authentication
  contents:
  - "D.3.  Certificates and Authentication\n   Implementations are responsible for\
    \ verifying the integrity of\n   certificates and should generally support certificate\
    \ revocation\n   messages.  Certificates should always be verified to ensure proper\n\
    \   signing by a trusted certificate authority (CA).  The selection and\n   addition\
    \ of trusted CAs should be done very carefully.  Users should\n   be able to view\
    \ information about the certificate and root CA.\n"
- title: D.4.  CipherSuites
  contents:
  - "D.4.  CipherSuites\n   SSL supports a range of key sizes and security levels,\
    \ including some\n   that provide no or minimal security.  A proper implementation\
    \ will\n   probably not support many cipher suites.  For example, 40-bit\n   encryption\
    \ is easily broken, so implementations requiring strong\n   security should not\
    \ allow 40-bit keys.  Similarly, anonymous Diffie-\n   Hellman is strongly discouraged\
    \ because it cannot prevent man-in-the-\n   middle attacks.  Applications should\
    \ also enforce minimum and maximum\n   key sizes.  For example, certificate chains\
    \ containing 512-bit RSA\n   keys or signatures are not appropriate for high-security\n\
    \   applications.\n"
- title: D.5.  FORTEZZA
  contents:
  - "D.5.  FORTEZZA\n   This section describes implementation details for cipher suites\
    \ that\n   make use of the FORTEZZA hardware encryption system.\n"
- title: D.5.1.  Notes on Use of FORTEZZA Hardware
  contents:
  - "D.5.1.  Notes on Use of FORTEZZA Hardware\n   A complete explanation of all issues\
    \ regarding the use of FORTEZZA\n   hardware is outside the scope of this document.\
    \  However, there are a\n   few special requirements of SSL that deserve mention.\n\
    \   Because SSL is a full duplex protocol, two crypto states must be\n   maintained,\
    \ one for reading and one for writing.  There are also a\n   number of circumstances\
    \ that can result in the crypto state in the\n   FORTEZZA card being lost.  For\
    \ these reasons, it's recommended that\n   the current crypto state be saved after\
    \ processing a record, and\n   loaded before processing the next.\n   After the\
    \ client generates the TEK, it also generates two message\n   encryption keys\
    \ (MEKs), one for reading and one for writing.  After\n   generating each of these\
    \ keys, the client must generate a\n   corresponding IV and then save the crypto\
    \ state.  The client also\n   uses the TEK to generate an IV and encrypt the premaster\
    \ secret.  All\n   three IVs are sent to the server, along with the wrapped keys\
    \ and the\n   encrypted premaster secret in the client key exchange message. \
    \ At\n   this point, the TEK is no longer needed, and may be discarded.\n   On\
    \ the server side, the server uses the master IV and the TEK to\n   decrypt the\
    \ premaster secret.  It also loads the wrapped MEKs into\n   the card.  The server\
    \ loads both IVs to verify that the IVs match the\n   keys.  However, since the\
    \ card is unable to encrypt after loading an\n   IV, the server must generate\
    \ a new IV for the server write key.  This\n   IV is discarded.\n   When encrypting\
    \ the first encrypted record (and only that record),\n   the server adds 8 bytes\
    \ of random data to the beginning of the\n   fragment.  These 8 bytes are discarded\
    \ by the client after\n   decryption.  The purpose of this is to synchronize the\
    \ state on the\n   client and server resulting from the different IVs.\n"
- title: D.5.2.  FORTEZZA Cipher Suites
  contents:
  - "D.5.2.  FORTEZZA Cipher Suites\n   5) FORTEZZA_NULL_WITH_NULL_SHA: Uses the full\
    \ FORTEZZA key exchange,\n   including sending server and client write keys and\
    \ IVs.\n"
- title: D.5.3.  FORTEZZA Session Resumption
  contents:
  - "D.5.3.  FORTEZZA Session Resumption\n   There are two possibilities for FORTEZZA\
    \ session restart: 1) Never\n   restart a FORTEZZA session. 2) Restart a session\
    \ with the previously\n   negotiated keys and IVs.\n   Never restarting a FORTEZZA\
    \ session:\n   Clients who never restart FORTEZZA sessions should never send session\n\
    \   IDs that were previously used in a FORTEZZA session as part of the\n   ClientHello.\
    \  Servers who never restart FORTEZZA sessions should\n   never send a previous\
    \ session id on the ServerHello if the negotiated\n   session is FORTEZZA.\n \
    \  Restart a session:\n   You cannot restart FORTEZZA on a session that has never\
    \ done a\n   complete FORTEZZA key exchange (that is, you cannot restart FORTEZZA\n\
    \   if the session was an RSA/RC4 session renegotiated for FORTEZZA).  If\n  \
    \ you wish to restart a FORTEZZA session, you must save the MEKs and\n   IVs from\
    \ the initial key exchange for this session and reuse them for\n   any new connections\
    \ on that session.  This is not recommended, but it\n   is possible.\n"
- title: Appendix E.  Version 2.0 Backward Compatibility
  contents:
  - "Appendix E.  Version 2.0 Backward Compatibility\n   Version 3.0 clients that\
    \ support version 2.0 servers must send\n   version 2.0 client hello messages\
    \ [SSL-2].  Version 3.0 servers\n   should accept either client hello format.\
    \  The only deviations from\n   the version 2.0 specification are the ability\
    \ to specify a version\n   with a value of three and the support for more ciphering\
    \ types in the\n   CipherSpec.\n   Warning: The ability to send version 2.0 client\
    \ hello messages will\n   be phased out with all due haste.  Implementers should\
    \ make every\n   effort to move forward as quickly as possible.  Version 3.0 provides\n\
    \   better mechanisms for transitioning to newer versions.\n   The following cipher\
    \ specifications are carryovers from SSL version\n   2.0.  These are assumed to\
    \ use RSA for key exchange and\n   authentication.\n        V2CipherSpec SSL_RC4_128_WITH_MD5\
    \          = { 0x01,0x00,0x80 };\n        V2CipherSpec SSL_RC4_128_EXPORT40_WITH_MD5\
    \ = { 0x02,0x00,0x80 };\n        V2CipherSpec SSL_RC2_CBC_128_CBC_WITH_MD5  =\
    \ { 0x03,0x00,0x80 };\n        V2CipherSpec SSL_RC2_CBC_128_CBC_EXPORT40_WITH_MD5\n\
    \                                                   = { 0x04,0x00,0x80 };\n  \
    \      V2CipherSpec SSL_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };\n    \
    \    V2CipherSpec SSL_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };\n      \
    \  V2CipherSpec SSL_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };\n   Cipher\
    \ specifications introduced in version 3.0 can be included in\n   version 2.0\
    \ client hello messages using the syntax below.  Any\n   V2CipherSpec element\
    \ with its first byte equal to zero will be\n   ignored by version 2.0 servers.\
    \  Clients sending any of the above\n   V2CipherSpecs should also include the\
    \ version 3.0 equivalent (see\n   Appendix A.6):\n        V2CipherSpec (see Version\
    \ 3.0 name) = { 0x00, CipherSuite };\n"
- title: E.1.  Version 2 Client Hello
  contents:
  - "E.1.  Version 2 Client Hello\n   The version 2.0 client hello message is presented\
    \ below using this\n   document's presentation model.  The true definition is\
    \ still assumed\n   to be the SSL version 2.0 specification.\n        uint8 V2CipherSpec[3];\n\
    \        struct {\n            unit8 msg_type;\n            Version version;\n\
    \            uint16 cipher_spec_length;\n            uint16 session_id_length;\n\
    \            uint16 challenge_length;\n            V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n\
    \            opaque session_id[V2ClientHello.session_id_length];\n           \
    \ Random challenge;\n        } V2ClientHello;\n   session msg_type:  This field,\
    \ in conjunction with the version field,\n      identifies a version 2 client\
    \ hello message.  The value should\n      equal one (1).\n   version:  The highest\
    \ version of the protocol supported by the client\n      (equals ProtocolVersion.version;\
    \ see Appendix A.1).\n   cipher_spec_length:  This field is the total length of\
    \ the field\n      cipher_specs.  It cannot be zero and must be a multiple of\
    \ the\n      V2CipherSpec length (3).\n   session_id_length:  This field must\
    \ have a value of either zero or\n      16.  If zero, the client is creating a\
    \ new session.  If 16, the\n      session_id field will contain the 16 bytes of\
    \ session\n      identification.\n   challenge_length:  The length in bytes of\
    \ the client's challenge to\n      the server to authenticate itself.  This value\
    \ must be 32.\n   cipher_specs:  This is a list of all CipherSpecs the client\
    \ is\n      willing and able to use.  There must be at least one CipherSpec\n\
    \      acceptable to the server.\n   session_id:  If this field's length is not\
    \ zero, it will contain the\n      identification for a session that the client\
    \ wishes to resume.\n   challenge:  The client's challenge to the server for the\
    \ server to\n      identify itself is a (nearly) arbitrary length random.  The\n\
    \      version 3.0 server will right justify the challenge data to become\n  \
    \    the ClientHello.random data (padded with leading zeroes, if\n      necessary),\
    \ as specified in this version 3.0 protocol.  If the\n      length of the challenge\
    \ is greater than 32 bytes, then only the\n      last 32 bytes are used.  It is\
    \ legitimate (but not necessary) for\n      a V3 server to reject a V2 ClientHello\
    \ that has fewer than 16\n      bytes of challenge data.\n   Note: Requests to\
    \ resume an SSL 3.0 session should use an SSL 3.0\n   client hello.\n"
- title: E.2.  Avoiding Man-in-the-Middle Version Rollback
  contents:
  - "E.2.  Avoiding Man-in-the-Middle Version Rollback\n   When SSL version 3.0 clients\
    \ fall back to version 2.0 compatibility\n   mode, they use special PKCS #1 block\
    \ formatting.  This is done so\n   that version 3.0 servers will reject version\
    \ 2.0 sessions with\n   version 3.0-capable clients.\n   When version 3.0 clients\
    \ are in version 2.0 compatibility mode, they\n   set the right-hand (least-significant)\
    \ 8 random bytes of the PKCS\n   padding (not including the terminal null of the\
    \ padding) for the RSA\n   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY\n\
    \   to 0x03 (the other padding bytes are random).  After decrypting the\n   ENCRYPTED-KEY-DATA\
    \ field, servers that support SSL 3.0 should issue\n   an error if these eight\
    \ padding bytes are 0x03.  Version 2.0 servers\n   receiving blocks padded in\
    \ this manner will proceed normally.\n"
- title: Appendix F.  Security Analysis
  contents:
  - "Appendix F.  Security Analysis\n   The SSL protocol is designed to establish\
    \ a secure connection between\n   a client and a server communicating over an\
    \ insecure channel.  This\n   document makes several traditional assumptions,\
    \ including that\n   attackers have substantial computational resources and cannot\
    \ obtain\n   secret information from sources outside the protocol.  Attackers\
    \ are\n   assumed to have the ability to capture, modify, delete, replay, and\n\
    \   otherwise tamper with messages sent over the communication channel.\n   This\
    \ appendix outlines how SSL has been designed to resist a variety\n   of attacks.\n"
- title: F.1.  Handshake Protocol
  contents:
  - "F.1.  Handshake Protocol\n   The handshake protocol is responsible for selecting\
    \ a CipherSpec and\n   generating a MasterSecret, which together comprise the\
    \ primary\n   cryptographic parameters associated with a secure session.  The\n\
    \   handshake protocol can also optionally authenticate parties who have\n   certificates\
    \ signed by a trusted certificate authority.\n"
- title: F.1.1.  Authentication and Key Exchange
  contents:
  - "F.1.1.  Authentication and Key Exchange\n   SSL supports three authentication\
    \ modes: authentication of both\n   parties, server authentication with an unauthenticated\
    \ client, and\n   total anonymity.  Whenever the server is authenticated, the\
    \ channel\n   should be secure against man-in-the-middle attacks, but completely\n\
    \   anonymous sessions are inherently vulnerable to such attacks.\n   Anonymous\
    \ servers cannot authenticate clients, since the client\n   signature in the certificate\
    \ verify message may require a server\n   certificate to bind the signature to\
    \ a particular server.  If the\n   server is authenticated, its certificate message\
    \ must provide a valid\n   certificate chain leading to an acceptable certificate\
    \ authority.\n   Similarly, authenticated clients must supply an acceptable\n\
    \   certificate to the server.  Each party is responsible for verifying\n   that\
    \ the other's certificate is valid and has not expired or been\n   revoked.\n\
    \   The general goal of the key exchange process is to create a\n   pre_master_secret\
    \ known to the communicating parties and not to\n   attackers.  The pre_master_secret\
    \ will be used to generate the\n   master_secret (see Section 6.1).  The master_secret\
    \ is required to\n   generate the finished messages, encryption keys, and MAC\
    \ secrets (see\n   Sections 5.6.9 and 6.2.2).  By sending a correct finished message,\n\
    \   parties thus prove that they know the correct pre_master_secret.\n"
- title: F.1.1.1.  Anonymous Key Exchange
  contents:
  - "F.1.1.1.  Anonymous Key Exchange\n   Completely anonymous sessions can be established\
    \ using RSA, Diffie-\n   Hellman, or FORTEZZA for key exchange.  With anonymous\
    \ RSA, the\n   client encrypts a pre_master_secret with the server's uncertified\n\
    \   public key extracted from the server key exchange message.  The\n   result\
    \ is sent in a client key exchange message.  Since eavesdroppers\n   do not know\
    \ the server's private key, it will be infeasible for them\n   to decode the pre_master_secret.\n\
    \   With Diffie-Hellman or FORTEZZA, the server's public parameters are\n   contained\
    \ in the server key exchange message and the client's are\n   sent in the client\
    \ key exchange message.  Eavesdroppers who do not\n   know the private values\
    \ should not be able to find the Diffie-Hellman\n   result (i.e., the pre_master_secret)\
    \ or the FORTEZZA token encryption\n   key (TEK).\n   Warning: Completely anonymous\
    \ connections only provide protection\n   against passive eavesdropping.  Unless\
    \ an independent tamper-proof\n   channel is used to verify that the finished\
    \ messages were not\n   replaced by an attacker, server authentication is required\
    \ in\n   environments where active man-in-the-middle attacks are a concern.\n"
- title: F.1.1.2.  RSA Key Exchange and Authentication
  contents:
  - "F.1.1.2.  RSA Key Exchange and Authentication\n   With RSA, key exchange and\
    \ server authentication are combined.  The\n   public key either may be contained\
    \ in the server's certificate or may\n   be a temporary RSA key sent in a server\
    \ key exchange message.  When\n   temporary RSA keys are used, they are signed\
    \ by the server's RSA or\n   DSS certificate.  The signature includes the current\n\
    \   ClientHello.random, so old signatures and temporary keys cannot be\n   replayed.\
    \  Servers may use a single temporary RSA key for multiple\n   negotiation sessions.\n\
    \   Note: The temporary RSA key option is useful if servers need large\n   certificates\
    \ but must comply with government-imposed size limits on\n   keys used for key\
    \ exchange.\n   After verifying the server's certificate, the client encrypts\
    \ a\n   pre_master_secret with the server's public key.  By successfully\n   decoding\
    \ the pre_master_secret and producing a correct finished\n   message, the server\
    \ demonstrates that it knows the private key\n   corresponding to the server certificate.\n\
    \   When RSA is used for key exchange, clients are authenticated using\n   the\
    \ certificate verify message (see Section 5.6.8).  The client signs\n   a value\
    \ derived from the master_secret and all preceding handshake\n   messages.  These\
    \ handshake messages include the server certificate,\n   which binds the signature\
    \ to the server, and ServerHello.random,\n   which binds the signature to the\
    \ current handshake process.\n"
- title: F.1.1.3.  Diffie-Hellman Key Exchange with Authentication
  contents:
  - "F.1.1.3.  Diffie-Hellman Key Exchange with Authentication\n   When Diffie-Hellman\
    \ key exchange is used, the server either can\n   supply a certificate containing\
    \ fixed Diffie-Hellman parameters or\n   can use the server key exchange message\
    \ to send a set of temporary\n   Diffie-Hellman parameters signed with a DSS or\
    \ RSA certificate.\n   Temporary parameters are hashed with the hello.random values\
    \ before\n   signing to ensure that attackers do not replay old parameters.  In\n\
    \   either case, the client can verify the certificate or signature to\n   ensure\
    \ that the parameters belong to the server.\n   If the client has a certificate\
    \ containing fixed Diffie-Hellman\n   parameters, its certificate contains the\
    \ information required to\n   complete the key exchange.  Note that in this case,\
    \ the client and\n   server will generate the same Diffie-Hellman result (i.e.,\n\
    \   pre_master_secret) every time they communicate.  To prevent the\n   pre_master_secret\
    \ from staying in memory any longer than necessary,\n   it should be converted\
    \ into the master_secret as soon as possible.\n   Client Diffie-Hellman parameters\
    \ must be compatible with those\n   supplied by the server for the key exchange\
    \ to work.\n   If the client has a standard DSS or RSA certificate or is\n   unauthenticated,\
    \ it sends a set of temporary parameters to the server\n   in the client key exchange\
    \ message, then optionally uses a\n   certificate verify message to authenticate\
    \ itself.\n"
- title: F.1.1.4.  FORTEZZA
  contents:
  - "F.1.1.4.  FORTEZZA\n   FORTEZZA's design is classified, but at the protocol level\
    \ it is\n   similar to Diffie-Hellman with fixed public values contained in\n\
    \   certificates.  The result of the key exchange process is the token\n   encryption\
    \ key (TEK), which is used to wrap data encryption keys,\n   client write key,\
    \ server write key, and master secret encryption key.\n   The data encryption\
    \ keys are not derived from the pre_master_secret\n   because unwrapped keys are\
    \ not accessible outside the token.  The\n   encrypted pre_master_secret is sent\
    \ to the server in a client key\n   exchange message.\n"
- title: F.1.2.  Version Rollback Attacks
  contents:
  - "F.1.2.  Version Rollback Attacks\n   Because SSL version 3.0 includes substantial\
    \ improvements over SSL\n   version 2.0, attackers may try to make version 3.0-capable\
    \ clients\n   and servers fall back to version 2.0.  This attack is occurring\
    \ if\n   (and only if) two version 3.0-capable parties use an SSL 2.0\n   handshake.\n\
    \   Although the solution using non-random PKCS #1 block type 2 message\n   padding\
    \ is inelegant, it provides a reasonably secure way for version\n   3.0 servers\
    \ to detect the attack.  This solution is not secure\n   against attackers who\
    \ can brute force the key and substitute a new\n   ENCRYPTED-KEY-DATA message\
    \ containing the same key (but with normal\n   padding) before the application\
    \ specified wait threshold has expired.\n   Parties concerned about attacks of\
    \ this scale should not be using 40-\n   bit encryption keys anyway.  Altering\
    \ the padding of the least\n   significant 8 bytes of the PKCS padding does not\
    \ impact security,\n   since this is essentially equivalent to increasing the\
    \ input block\n   size by 8 bytes.\n"
- title: F.1.3.  Detecting Attacks against the Handshake Protocol
  contents:
  - "F.1.3.  Detecting Attacks against the Handshake Protocol\n   An attacker might\
    \ try to influence the handshake exchange to make the\n   parties select different\
    \ encryption algorithms than they would\n   normally choose.  Because many implementations\
    \ will support 40-bit\n   exportable encryption and some may even support null\
    \ encryption or\n   MAC algorithms, this attack is of particular concern.\n  \
    \ For this attack, an attacker must actively change one or more\n   handshake\
    \ messages.  If this occurs, the client and server will\n   compute different\
    \ values for the handshake message hashes.  As a\n   result, the parties will\
    \ not accept each other's finished messages.\n   Without the master_secret, the\
    \ attacker cannot repair the finished\n   messages, so the attack will be discovered.\n"
- title: F.1.4.  Resuming Sessions
  contents:
  - "F.1.4.  Resuming Sessions\n   When a connection is established by resuming a\
    \ session, new\n   ClientHello.random and ServerHello.random values are hashed\
    \ with the\n   session's master_secret.  Provided that the master_secret has not\n\
    \   been compromised and that the secure hash operations used to produce\n   the\
    \ encryption keys and MAC secrets are secure, the connection should\n   be secure\
    \ and effectively independent from previous connections.\n   Attackers cannot\
    \ use known encryption keys or MAC secrets to\n   compromise the master_secret\
    \ without breaking the secure hash\n   operations (which use both SHA and MD5).\n\
    \   Sessions cannot be resumed unless both the client and server agree.\n   If\
    \ either party suspects that the session may have been compromised,\n   or that\
    \ certificates may have expired or been revoked, it should\n   force a full handshake.\
    \  An upper limit of 24 hours is suggested for\n   session ID lifetimes, since\
    \ an attacker who obtains a master_secret\n   may be able to impersonate the compromised\
    \ party until the\n   corresponding session ID is retired.  Applications that\
    \ may be run in\n   relatively insecure environments should not write session\
    \ IDs to\n   stable storage.\n"
- title: F.1.5.  MD5 and SHA
  contents:
  - "F.1.5.  MD5 and SHA\n   SSL uses hash functions very conservatively.  Where possible,\
    \ both\n   MD5 and SHA are used in tandem to ensure that non-catastrophic flaws\n\
    \   in one algorithm will not break the overall protocol.\n"
- title: F.2.  Protecting Application Data
  contents:
  - "F.2.  Protecting Application Data\n   The master_secret is hashed with the ClientHello.random\
    \ and\n   ServerHello.random to produce unique data encryption keys and MAC\n\
    \   secrets for each connection.  FORTEZZA encryption keys are generated\n   by\
    \ the token, and are not derived from the master_secret.\n   Outgoing data is\
    \ protected with a MAC before transmission.  To\n   prevent message replay or\
    \ modification attacks, the MAC is computed\n   from the MAC secret, the sequence\
    \ number, the message length, the\n   message contents, and two fixed-character\
    \ strings.  The message type\n   field is necessary to ensure that messages intended\
    \ for one SSL\n   record layer client are not redirected to another.  The sequence\n\
    \   number ensures that attempts to delete or reorder messages will be\n   detected.\
    \  Since sequence numbers are 64 bits long, they should never\n   overflow.  Messages\
    \ from one party cannot be inserted into the\n   other's output, since they use\
    \ independent MAC secrets.  Similarly,\n   the server-write and client-write keys\
    \ are independent so stream\n   cipher keys are used only once.\n   If an attacker\
    \ does break an encryption key, all messages encrypted\n   with it can be read.\
    \  Similarly, compromise of a MAC key can make\n   message modification attacks\
    \ possible.  Because MACs are also\n   encrypted, message-alteration attacks generally\
    \ require breaking the\n   encryption algorithm as well as the MAC.\n   Note:\
    \ MAC secrets may be larger than encryption keys, so messages can\n   remain tamper\
    \ resistant even if encryption keys are broken.\n"
- title: F.3.  Final Notes
  contents:
  - "F.3.  Final Notes\n   For SSL to be able to provide a secure connection, both\
    \ the client\n   and server systems, keys, and applications must be secure.  In\n\
    \   addition, the implementation must be free of security errors.\n   The system\
    \ is only as strong as the weakest key exchange and\n   authentication algorithm\
    \ supported, and only trustworthy\n   cryptographic functions should be used.\
    \  Short public keys, 40-bit\n   bulk encryption keys, and anonymous servers should\
    \ be used with great\n   caution.  Implementations and users must be careful when\
    \ deciding\n   which certificates and certificate authorities are acceptable;\
    \ a\n   dishonest certificate authority can do tremendous damage.\n"
- title: Appendix G.  Acknowledgements
  contents:
  - 'Appendix G.  Acknowledgements

    '
- title: G.1.  Other Contributors
  contents:
  - "G.1.  Other Contributors\n   Martin Abadi                  Robert Relyea\n  \
    \ Digital Equipment Corporation Netscape Communications\n   ma@pa.dec.com    \
    \             relyea@netscape.com\n   Taher Elgamal                 Jim Roskind\n\
    \   Netscape Communications       Netscape Communications\n   elgamal@netscape.com\
    \          jar@netscape.com\n   Anil Gangolli                 Micheal J. Sabin,\
    \ Ph.D.\n   Netscape Communications       Consulting Engineer\n   gangolli@netscape.com\
    \         msabin@netcom.com\n   Kipp E.B. Hickman             Tom Weinstein\n\
    \   Netscape Communications       Netscape Communications\n   kipp@netscape.com\
    \             tomw@netscape.com\n"
- title: G.2.  Early Reviewers
  contents:
  - "G.2.  Early Reviewers\n   Robert Baldwin                Clyde Monma\n   RSA Data\
    \ Security, Inc.       Bellcore\n   baldwin@rsa.com               clyde@bellcore.com\n\
    \   George Cox                    Eric Murray\n   Intel Corporation          \
    \   ericm@lne.com\n   cox@ibeam.jf.intel.com\n   Cheri Dowell                \
    \  Avi Rubin\n   Sun Microsystems              Bellcore\n   cheri@eng.sun.com\
    \             rubin@bellcore.com\n   Stuart Haber                  Don Stephenson\n\
    \   Bellcore                      Sun Microsystems\n   stuart@bellcore.com   \
    \        don.stephenson@eng.sun.com\n   Burt Kaliski                  Joe Tardo\n\
    \   RSA Data Security, Inc.       General Magic\n   burt@rsa.com             \
    \     tardo@genmagic.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alan O. Freier\n   Netscape Communications\n   Philip\
    \ Karlton\n   Netscape Communications\n   Paul C. Kocher\n   Independent Consultant\n"
