- title: __initial_text__
  contents:
  - '       An RTP Payload Format for Generic Forward Error Correction

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a payload format for generic forward error\n\
    \   correction of media encapsulated in RTP. It is engineered for FEC\n   algorithms\
    \ based on the exclusive-or (parity) operation. The payload\n   format allows\
    \ end systems to transmit using arbitrary block lengths\n   and parity schemes.\
    \ It also allows for the recovery of both the\n   payload and critical RTP header\
    \ fields. Since FEC is sent as a\n   separate stream, it is backwards compatible\
    \ with non-FEC capable\n   hosts, so that receivers which do not wish to implement\
    \ FEC can just\n   ignore the extensions.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1     Introduction ...........................................\
    \    2\n   2     Terminology ............................................    2\n\
    \   3     Basic Operation ........................................    3\n   4\
    \     Parity Codes ...........................................    5\n   5    \
    \ RTP Media Packet Structure .............................    6\n   6     FEC\
    \ Packet Structure ...................................    7\n   6.1   RTP Header\
    \ of FEC Packets ..............................    7\n   6.2   FEC Header .............................................\
    \    7\n   7     Protection Operation ...................................    9\n\
    \   8     Recovery Procedures ....................................   10\n   8.1\
    \   Reconstruction .........................................   10\n   8.2   Determination\
    \ of When to Recover .......................   12\n   9     Example ................................................\
    \   16\n   10    Use with Redundant Encodings ...........................   17\n\
    \   11    Indicating FEC Usage in SDP ............................   20\n   11.1\
    \  FEC as a Separate Stream ...............................   20\n   11.2  Use\
    \ with Redundant Encodings ...........................   21\n   11.3  Usage with\
    \ RTSP ........................................   22\n   12    Security Considerations\
    \ ................................   23\n   13    Acknowledgments ........................................\
    \   24\n   14    Authors' Addresses .....................................   24\n\
    \   15    Bibliography ...........................................   25\n   16\
    \    Full Copyright Statement ...............................   26\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   The quality of packet voice on the Internet has been mediocre\
    \ due, in\n   part, to high packet loss rates. This is especially true on wide-area\n\
    \   connections. Unfortunately, the strict delay requirements of real-\n   time\
    \ multimedia usually eliminate the possibility of retransmissions.\n   It is for\
    \ this reason that forward error correction (FEC) has been\n   proposed to compensate\
    \ for packet loss in the Internet [1] [2]. In\n   particular, the use of traditional\
    \ error correcting codes, such as\n   parity, Reed-Solomon, and Hamming codes,\
    \ has attracted attention. To\n   support these mechanisms, protocol support is\
    \ required.\n   This document defines a payload format for RTP [3] which allows\
    \ for\n   generic forward error correction of real time media. In this context,\n\
    \   generic means that the FEC protocol is (1) independent of the nature\n   of\
    \ the media being protected, be it audio, video, or otherwise, (2)\n   flexible\
    \ enough to support a wide variety of FEC mechanisms, (3)\n   designed for adaptivity\
    \ so that the FEC technique can be modified\n   easily without out of band signaling,\
    \ and (4) supportive of a number\n   of different mechanisms for transporting\
    \ the FEC packets.\n"
- title: 2 Terminology
  contents:
  - "2 Terminology\n   The following terms are used throughout this document:\n  \
    \     Media Payload: is a piece of raw, un-protected user data which\n       \
    \     is to be transmitted from the sender. The media payload is\n           \
    \ placed inside of an RTP packet.\n       Media Header: is the RTP header for\
    \ the packet containing the\n            media payload.\n       Media Packet:\
    \ The combination of a media payload and media\n            header is called a\
    \ media packet.\n       FEC Packet: The forward error correction algorithms at\
    \ the\n            transmitter take the media packets as an input. They output\n\
    \            both the media packets that they are passed, and new\n          \
    \  packets called FEC packets. The FEC packets are formatted\n            according\
    \ to the rules specified in this document.\n       FEC Header: The FEC header\
    \ is the header information contained\n            in an FEC packet.\n       FEC\
    \ Payload: The FEC payload is the payload in an FEC packet.\n       Associated:\
    \ An FEC packet is said to be \"associated\" with one or\n            more media\
    \ packets when those media packets are used to\n            generate the FEC packet\
    \ (by use of the exclusive or\n            operation).\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in RFC 2119 [4].\n"
- title: 3 Basic Operation
  contents:
  - "3 Basic Operation\n   The payload format described here is used whenever a participant\
    \ in\n   an RTP session would like to protect a media stream it is sending\n \
    \  with forward error correction (FEC). The FEC supported by the format\n   are\
    \ those codes based on simple exclusive or (xor) parities. The\n   sender takes\
    \ some set of packets from the media stream, and applies\n   an xor operation\
    \ across the payloads. The sender also applies the xor\n   operation over components\
    \ of the RTP headers. Based on the procedures\n   defined here, the result is\
    \ an RTP packet containing FEC information.\n   This packet can be used at the\
    \ receiver to recover any one of the\n   packets used to generate the FEC packet.\
    \ This document does not\n   mandate the particular set of media packets combined\
    \ to generate an\n   FEC packet (such a set [is] referred to as a code). Use of\
    \ differing\n   sets results in a tradeoff between overhead, delay, and\n   recoverability.\
    \  Section 4 outlines some possible combinations.\n   The payload format contains\
    \ information that allows the sender to\n   tell the receiver exactly which media\
    \ packets have been used to\n   generate the FEC. Specifically, each FEC packet\
    \ contains a bitmask,\n   called the offset mask, containing 24 bits. If bit i\
    \ in the mask is\n   set to 1, the media packet with sequence number N + i was\
    \ used to\n   generate this FEC packet. N is called the sequence number base,\
    \ and\n   is sent in the FEC packet as well. The offset mask and payload type\n\
    \   are sufficient to signal arbitrary parity based forward error\n   correction\
    \ schemes with little overhead.\n   This document also describes procedures that\
    \ allow the receiver to\n   make use of the FEC without having to know the details\
    \ of specific\n   codes. This allows the sender much flexibility; it can adapt\
    \ the code\n   in use based on network conditions, and be certain the receivers\
    \ can\n   still make use of the FEC for recovery.\n   As the sender generates\
    \ FEC packets, they are sent to the receivers.\n   The sender still usually sends\
    \ the original media stream, as if there\n   were no FEC. This allows the media\
    \ stream to still be used by\n   receivers who are not FEC capable. However, some\
    \ FEC codes do not\n   require the original media to be sent; the FEC stream is\
    \ sufficient\n   for recovery. These codes have the drawback that all receivers\
    \ must\n   be FEC capable. However, they are supported by this format.\n   The\
    \ FEC packets are not sent in the same RTP stream as the media\n   packets. They\
    \ can be sent as a separate stream, or as a secondary\n   codec in the redundant\
    \ codec payload format [5]. When sent as a\n   separate stream, the FEC packets\
    \ have their own sequence number\n   space. Although the timestamps for the FEC\
    \ packets are derived from\n   the media packets, they increment monotonically.\
    \ FEC packet streams\n   thus work well with any header compression mechanism\
    \ which requires\n   fixed deltas between fields in the packet header.\n   This\
    \ document does not prescribe the definition of \"separate\n   streams\", but\
    \ leaves this to applications and higher level protocols\n   to define. For multicast,\
    \ the separate stream may be implemented by\n   separate multicast groups, different\
    \ ports in the same group, or by a\n   different SSRC within the same group/port.\
    \ For unicast, different\n   ports or different SSRC may be used. Each of these\
    \ approaches has\n   drawbacks and benefits which depend on the application.\n\
    \   At the receiver, the FEC and original media are received. If no media\n  \
    \ packets are lost, the FEC can be ignored. In the event of loss, the\n   FEC\
    \ packets can be combined with other media and FEC packets that\n   have been\
    \ received, resulting in recovery of missing media packets.\n   The recovery is\
    \ exact; the payload is perfectly reconstructed, along\n   with most components\
    \ of the header.\n   RTP packets which contain data formatted according to this\n\
    \   specification (i.e., FEC packets) are signaled using dynamic RTP\n   payload\
    \ types.\n"
- title: 4 Parity Codes
  contents:
  - "4 Parity Codes\n   For brevity, we define the function f(x,y,..) to be the XOR\
    \ (parity)\n   operator applied to the packets x,y,... The output of this function\n\
    \   is another packet, called the parity packet. For simplicity, we\n   assume\
    \ here that the parity packet is computed as the bitwise XOR of\n   the input\
    \ packets. The exact procedure is specified in section 6.\n   Recovery of data\
    \ packets using parity codes is accomplished by\n   generating one or more parity\
    \ packets over a group of data packets.\n   To be effective, the parity packets\
    \ must be generated by linearly\n   independent combinations of data packets.\
    \ The particular combination\n   is called a parity code. One class of codes takes\
    \ a group of k data\n   packets, and generates n-k parity packets. There are a\
    \ large number\n   of possible parity codes for a given n,k. The payload format\
    \ does not\n   mandate a particular code.\n   For example, consider a parity code\
    \ which generates a single parity\n   packet over two data packets. If the original\
    \ media packets are\n   a,b,c,d, the packets generated by the sender are:\n  \
    \ a        b        c        d               <-- media stream\n              f(a,b)\
    \            f(c,d)        <-- FEC stream\n   where time increases to the right.\
    \ In this example, the error\n   correction scheme (we use the terms scheme and\
    \ code interchangeably)\n   introduces a 50% overhead. But if b is lost, a and\
    \ f(a,b) can be used\n   to recover b.\n   Some additional codes are listed below.\
    \ In each, the original media\n   stream consists of packets a,b,c,d and so on.\n\
    \   Scheme 1\n   --------\n   This scheme is the similar to the one in the example\
    \ above. However,\n   instead of sending b, followed by f(a,b), f(a,b) is sent\
    \ before b.\n   Doing this clearly requires additional delay at the sender. However,\n\
    \   if allows some bursts of two consecutive packet losses to be\n   recovered.\
    \ The packets generated by the sender look like:\n   a        b        c     \
    \   d        e        <-- media stream\n     f(a,b)   f(b,c)   f(c,d)   f(d,e)\
    \          <-- FEC stream\n   Scheme 2\n   --------\n   It is not strictly necessary\
    \ for the original media stream to be\n   transmitted. In this scheme, only FEC\
    \ packets are transmitted.  This\n   scheme allows for recovery of all single\
    \ packet losses and some\n   consecutive packet losses, but with slightly less\
    \ overhead than\n   scheme 1. The packets generated by the sender look like:\n\
    \   f(a,b)  f(a,c)  f(a,b,c)  f(c,d)  f(c,e)  f(c,d,e)  <-- FEC stream\n   Scheme\
    \ 3\n   --------\n   This scheme requires the receiver to wait an additional four\
    \ packet\n   intervals to recover the original media packets. However, it can\n\
    \   recover from one, two or three consecutive packet losses. The packets\n  \
    \ generated by the sender look like:\n   a         b          c              \
    \      d     <-- media stream\n               f(a,b,c)    f(a,c,d) f(a,b,d)  \
    \     <-- FEC stream\n"
- title: 5 RTP Media Packet Structure
  contents:
  - "5 RTP Media Packet Structure\n   The formatting of the media packets is unaffected\
    \ by FEC. If the FEC\n   is sent as a separate stream, the media packets are sent\
    \ as if there\n   was no FEC. If the FEC is being sent as a redundant codec, the\
    \ media\n   packets are sent as the main codec as defined in RFC 2198 [5].\n \
    \  This lends to a very efficient encoding. When little (or no) FEC is\n   used,\
    \ there are mostly media packets being sent. This means that the\n   overhead\
    \ (present in FEC packets only) tracks the amount of FEC in\n   use.\n"
- title: 6 FEC Packet Structure
  contents:
  - "6 FEC Packet Structure\n   An FEC packet is constructed by placing an FEC header\
    \ and FEC payload\n   in the RTP payload, as shown in Figure 1:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         RTP Header                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         FEC Header                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         FEC Payload                           |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 1: FEC Packet Structure\n"
- title: 6.1 RTP Header of FEC Packets
  contents:
  - "6.1 RTP Header of FEC Packets\n   The version field is set to 2. The padding\
    \ bit is computed via the\n   protection operation, defined below. The extension\
    \ bit is also\n   computed via the protection operation. The SSRC value will generally\n\
    \   be the same as the SSRC value of the media stream it protects. It MAY\n  \
    \ be different if the FEC stream is being demultiplexed via the SSRC\n   value.\
    \ The CC value is computed via the protection operation. The\n   CSRC list is\
    \ never present, independent of the value of the CC field.\n   The extension is\
    \ never present, independent of the value of the X\n   bit. The marker bit is\
    \ computed via the protection operation.\n   The sequence number has the standard\
    \ definition: it MUST be one\n   higher than the sequence number in the previously\
    \ transmitted FEC\n   packet. The timestamp MUST be set to the value of the media\
    \ RTP clock\n   at the instant the FEC packet is transmitted. This results in\
    \ the TS\n   value in FEC packets to be monotonically increasing, independent\
    \ of\n   the FEC scheme.\n   The payload type for the FEC packet is determined\
    \ through dynamic,\n   out of band means. According to RFC 1889 [3], RTP participants\
    \ which\n   cannot recognize a payload type must discard it. This provides\n \
    \  backwards compatibility. The FEC mechanisms can then be used in a\n   multicast\
    \ group with mixed FEC-capable and FEC-incapable receivers.\n"
- title: 6.2 FEC Header
  contents:
  - "6.2 FEC Header\n   This header is 12 bytes. The format of the header is shown\
    \ in Figure\n   2, and consists of an SN base field, length recovery field, E\
    \ field,\n   PT recovery field, mask field and TS recovery field.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      SN base                  |        length recovery        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E| PT recovery |                 mask                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          TS recovery                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 2: Parity Header Format\n   The length recovery field is used to determine\
    \ the length of any\n   recovered packets. It is computed via the protection operation\n\
    \   applied to the unsigned network-ordered 16 bit representation of the\n   sums\
    \ of the lengths (in bytes) of the media payload, CSRC list,\n   extension and\
    \ padding of media packets associated with this FEC\n   packet (in other words,\
    \ the CSRC list, extension, and padding, if\n   present, are \"counted\" as part\
    \ of the payload). This allows the FEC\n   procedure to be applied even when the\
    \ lengths of the media packets\n   are not identical. For example, assume an FEC\
    \ packet is being\n   generated by xor'ing two media packets together. The length\
    \ of the\n   two media packets are 3 (0b011) and 5 (0b101) bytes, respectively.\n\
    \   The length recovery field is then encoded as 0b011 xor 0b101 = 0b110.\n  \
    \ The E bit indicates a header extension. Implementations conforming to\n   this\
    \ version of the specification MUST set this bit to zero.\n   The PT recovery\
    \ field is obtained via the protection operation\n   applied to the payload type\
    \ values of the media packets associated\n   with the FEC packet.\n   The mask\
    \ field is 24 bits. If bit i in the mask is set to 1, then the\n   media packet\
    \ with sequence number N + i is associated with this FEC\n   packet, where N is\
    \ the SN Base field in the FEC packet header. The\n   least significant bit corresponds\
    \ to i=0, and the most significant to\n   i=23.\n   The SN base field MUST be\
    \ set to the minimum sequence number of those\n   media packets protected by FEC.\
    \ This allows for the FEC operation to\n   extend over any string of at most 24\
    \ packets.\n   The TS recovery field is computed via the protection operation\n\
    \   applied to the timestamps of the media packets associated with this\n   FEC\
    \ packet. This allows the timestamp to be completely recovered.\n   The payload\
    \ of the FEC packet is the protection operation applied to\n   the concatenation\
    \ of the CSRC list, RTP extension, media payload, and\n   padding of the media\
    \ packets associated with the FEC packet.\n   Note that it's possible for the\
    \ FEC packet to be slightly larger than\n   the media packets it protects (due\
    \ to the presence of the FEC\n   header). This could cause difficulties if this\
    \ results in the FEC\n   packet exceeding the Maximum Transmission Unit size for\
    \ the path\n   along which it is sent.\n"
- title: 7 Protection Operation
  contents:
  - "7 Protection Operation\n   The protection operation involves concatenating specific\
    \ fields from\n   the RTP header of the media packet, appending the payload, padding\n\
    \   with zeroes, and then computing the xor across the resulting bit\n   strings.\
    \ The resulting bit string is used to generate the FEC packet.\n   The following\
    \ procedure MAY be followed for the protection operation.\n   Other procedures\
    \ MAY be followed, but the end result MUST be\n   identical to the one described\
    \ here. For each media packet to be\n   protected, a bit string is generated by\
    \ concatenating the following\n   fields together in the order specifed:\n   \
    \   o Padding Bit (1 bit)\n      o Extension Bit (1 bit)\n      o CC bits (4 bits)\n\
    \      o Marker bit (1 bit)\n      o Payload Type (7 bits)\n      o Timestamp\
    \ (32 bits)\n      o Unsigned network-ordered 16 bit representation of the sum\
    \ of\n        the lengths (in bytes) of the CSRC List, length of the padding,\n\
    \        length of the extension, and length of the media payload (16\n      \
    \  bits)\n      o if CC is nonzero, the CSRC List (variable length)\n      o if\
    \ X is 1, the Header Extension (variable length)\n      o the payload (variable\
    \ length)\n      o Padding, if present (variable length)\n   Note that the Padding\
    \ Bit (first entry above) forms the most\n   significant bit of the bit string.\n\
    \   If the lengths of the bit strings are not equal, each bit string that\n  \
    \ is shorter than the length of the longest, MUST be padded to the\n   length\
    \ of the longest. Any value for the pad may be used. The pad\n   MUST be added\
    \ at the end of the bit string.\n   The parity operation is then applied across\
    \ the bit strings. The\n   result is the bit string used to build the FEC packet.\
    \ Call this the\n   FEC bit string.\n   The first (most significant) bit in the\
    \ FEC bit string is written\n   into the Padding Bit of the FEC packet. The second\
    \ bit in the FEC bit\n   string is written into the Extension bit of the FEC packet.\
    \ The next\n   four bits of the FEC bit string are written into the CC field of\
    \ the\n   FEC packet. The next bit of the FEC bit string is written into the\n\
    \   marker bit of the FEC packet. The next 7 bits of the FEC bit string\n   are\
    \ written into the PT recovery field in the FEC packet header. The\n   next 32\
    \ bits of the FEC bit string are written into the TS recovery\n   field in the\
    \ packet header. The next 16 bits are written into the\n   length recovery field\
    \ in the FEC packet header. The remaining bits\n   are set to be the payload of\
    \ the FEC packet.\n"
- title: 8 Recovery Procedures
  contents:
  - "8 Recovery Procedures\n   The FEC packets allow end systems to recover from the\
    \ loss of media\n   packets. All of the header fields of the missing packets,\
    \ including\n   CSRC lists, extensions, padding bits, marker and payload type,\
    \ are\n   recoverable.  This section describes the procedure for performing\n\
    \   this recovery.\n   Recovery requires two distinct operations. The first determines\
    \ which\n   packets (media and FEC) must be combined in order to recover a\n \
    \  missing packet. Once this is done, the second step is to actually\n   reconstruct\
    \ the data. The second step MUST be performed as described\n   below. The first\
    \ step MAY be based on any algorithm chosen by the\n   implementer. Different\
    \ algorithms result in a tradeoff between\n   complexity and the ability to recover\
    \ missing packets if at all\n   possible.\n"
- title: 8.1 Reconstruction
  contents:
  - "8.1 Reconstruction\n   Let T be the list of packets (FEC and media) which can\
    \ be combined to\n   recover some media packet xi. The procedure is as follows:\n\
    \       1.   For the media packets in T, compute the bit string as\n         \
    \   described in the protection operation of the previous\n            section.\n\
    \       2.   For the FEC packet in T, compute the bit string in the same\n   \
    \         fashion, except use the PT Recovery instead of Payload Type,\n     \
    \       TS Recovery instead of Timestamp,  and always set the CSRC\n         \
    \   list, extension, and padding to null.\n       3.   If any of the bit strings\
    \ generated from the media packets\n            are shorter than the bit string\
    \ generated from the FEC\n            packet, pad them to be the same length as\
    \ the bit string\n            generated from the FEC. The padding MUST be added\
    \ at the\n            end of the bit string, and MAY be of any value.\n      \
    \ 4.   Perform the exclusive or (parity) operation across the bit\n          \
    \  strings, resulting in a recovery bit string.\n       5.   Create a new packet\
    \ with the standard 12 byte RTP header\n            and no payload.\n       6.\
    \   Set the version of the new packet to 2.\n       7.   Set the Padding bit in\
    \ the new packet to the first bit in\n            the recovery bit string.\n \
    \      8.   Set the Extension bit in the new packet to the second bit\n      \
    \      in the recovery bit string.\n       9.   Set the CC field to the next four\
    \ bits in the recovery bit\n            string.\n       10.  Set the marker bit\
    \ in the new packet to the next bit in the\n            recovery bit string.\n\
    \       11.  Set the payload type in the new packet to the next 7 bits\n     \
    \       in the recovery bit string.\n       12.  Set the SN field in the new packet\
    \ to xi.\n       13.  Set the TS field in the new packet to the next 32 bits in\n\
    \            the recovery bit string.\n       14.  Take the next 16 bits of the\
    \ recovery bit string. Whatever\n            unsigned integer this represents\
    \ (assuming network-order),\n            take that many bytes from the recovery\
    \ bit string and\n            append them to the new packet. This represents the\
    \ CSRC\n            list, extension, payload, and padding.\n       15.  Set the\
    \ SSRC of the new packet to the SSRC of the media\n            stream it's protecting.\n\
    \   This procedure will completely recover both the header and payload of\n  \
    \ an RTP packet.\n"
- title: 8.2 Determination of When to Recover
  contents:
  - "8.2 Determination of When to Recover\n   The previous section discussed how to\
    \ recover a media packet with\n   sequence number xi when all of the packets needed\
    \ to recover it were\n   available. The decision about whether to attempt recovery\
    \ of some\n   media packet xi, and how to determine if sufficient data is available\n\
    \   to recover it, is left to the implementer. However, this section\n   provides\
    \ a simple algorithm which MAY be used for this purpose.\n   The algorithm is\
    \ described below in C code. The code assumes that\n   several functions exist.\
    \ recover_packet() takes the sequence number\n   of a packet, and an FEC packet.\
    \ Using the FEC packet and data packets\n   received previously, the data packet\
    \ with the given sequence number\n   is recovered. add_fec_to_pending_list() adds\
    \ the given FEC packet to\n   a linked list of FEC packets which have not yet\
    \ been used for\n   recovery. wait_for_packet() waits for a packet, FEC or data,\
    \ from the\n   network. remove_from_pending_list() removes the FEC packet from\
    \ the\n   pending list. The structure packet contains a boolean variable fec\n\
    \   which is true when the packet is FEC, false if it's media. When its\n   an\
    \ FEC packet, the mask and snbase field contain those values from\n   the FEC\
    \ packet header. When it's a media packet, the sn variable\n   contains the sequence\
    \ number of the packet. The global array A\n   indicates which media packets have\
    \ been received, and which have not.\n   It is indexed by the sequence number\
    \ of the packet.\n   The function fec_recovery implements the algorithm. It waits\
    \ for\n   packets, and when it receives an FEC packet, calls recover_with_fec()\n\
    \   to attempt to use it to recover. If no recovery is possible, the FEC\n   packet\
    \ is stored for later attempts. If the received packet was a\n   media packet,\
    \ its presence is noted, and any old FEC packets are\n   checked to see if recovery\
    \ is now possible. Recovered packets are\n   treated as if they were received,\
    \ triggering further attempts at\n   recovery.\n   A real implementation will\
    \ need to use a circular buffer instead of\n   the simple array (A in the code)\
    \ in order to avoid running off the\n   end of the buffer. In addition, the code\
    \ below does not attempt to\n   free up FEC packets that are old and were never\
    \ used. Normally, such\n   discarding is done based on time constraints introduced\
    \ by the\n   playout buffer. If an FEC data protects packets whose play time has\n\
    \   elapsed, the FEC is no longer needed.\n"
- title: typedef struct packet_s {
  contents:
  - "typedef struct packet_s {\n  BOOLEAN fec;               /* FEC or media */\n\
    \  int sn;                    /* SN of the packet, for media only */\n  BOOLEAN\
    \ mask[24];          /* Mask, FEC only */\n  int snbase;                /* SN\
    \ Base, FEC only */\n  struct packet_s *next;\n"
- title: '} packet;'
  contents:
  - '} packet;

    '
- title: BOOLEAN A[65535];
  contents:
  - 'BOOLEAN A[65535];

    '
- title: packet *pending_list;
  contents:
  - 'packet *pending_list;

    '
- title: packet *recover_with_fec(packet *fec_pkt) {
  contents:
  - "packet *recover_with_fec(packet *fec_pkt) {\n  packet *data_pkt;\n  int pkts_present,\
    \  /* number of packets from the mask that are\n                        present\
    \ */\n    pkts_needed,    /* number of packets needed is the number of ones\n\
    \                        in the mask minus 1 */\n    pkt_to_recover, /* sn of\
    \ the packet we are recovering */\n    i;\n  pkts_present = 0;\n  /* The number\
    \ of packets needed is the number of ones in the mask\n     minus 1.  The code\
    \ below increments pkts_needed by the number\n     of ones in the mask, so we\
    \ initialize this to -1 so that the\n     final count is correct */\n  pkts_needed\
    \ = -1;\n  /* Go through all 24 bits in the mask, and check if we have\n     all\
    \ but one of the media packets */\n  for(i = 0; i < 24; i++) {\n     /* If the\
    \ packet is here and in the mask, increment counter */\n     if(A[i+fec_pkt->snbase]\
    \ && fec_pkt->mask[i]) pkts_present++;\n     /* Count the number of packets needed\
    \ as well */\n     if(fec_pkt->mask[i]) pkts_needed++;\n     /* The packet to\
    \ recover is the one with a bit in the\n        mask that's not here yet */\n\
    \     if(!A[i+fec_pkt->snbase] && fec_pkt->mask[i])\n       pkt_to_recover = i+fec_pkt->snbase;\n\
    \   }\n   /* If we can recover, do so. Otherwise, return NULL */\n   if(pkts_present\
    \ == pkts_needed) {\n     data_pkt = recover_packet(pkt_to_recover, fec_pkt);\n\
    \   }  else {\n     data_pkt = NULL;\n   }\n   return(data_pkt);\n }\n void fec_recovery()\
    \ {\n   packet *p,    /* packet received or regenerated */\n       *fecp,    /*\
    \ fec packet from pending list */\n       *pnew;    /* new packets recovered */\n\
    \   while(1) {\n     p = wait_for_packet();    /* get packet from network */\n\
    \     while(p) {\n       /* if it's an FEC packet, try to recover with it. If\
    \ we can't,\n          store it for later potential use. If we can recover, act\
    \ as\n          if the recovered packet is received and try to recover some\n\
    \          more.  Otherwise, if it's a data packet, mark it as received,\n   \
    \       and check if we can now recover a data packet with the list\n        \
    \  of pending FEC packets */\n       if(p->fec == TRUE) {\n          pnew = recover_with_fec(p);\n\
    \          if(pnew)\n            A[pnew->sn] = TRUE;\n          else\n       \
    \     add_fec_to_pending_list(p);\n          /* We assign pnew to p since the\
    \ while loop will continue\n             to recover based on p not being NULL\
    \ */\n          p = pnew;\n       } else {\n         /* Mark this data packet\
    \ as here */\n         A[p->sn] = TRUE;\n         free(p);\n         p = NULL;\n\
    \         /* Go through pending list. Try and recover a packet using\n       \
    \     each FEC. If we are successful, add the data packet to\n            the\
    \ list of received packets, remove the FEC packet from\n            the pending\
    \ list, since we've used it, and then try to\n            recover some more */\n\
    \         for(fecp = pending_list; fecp != NULL; fecp = fecp->next) {\n      \
    \     pnew = recover_with_fec(fecp);\n           if(pnew) {\n             /* The\
    \ packet is now here, as we've recovered it */\n             A[pnew->sn] = TRUE;\n\
    \             /* One FEC packet can only be used once to recover,\n          \
    \      so remove it from the pending list */\n             remove_fec_from_pending_list(fecp);\n\
    \             p = pnew;\n             break;\n           }\n         } /*for*/\n\
    \       } /*p->fec was false */\n     } /* while p*/\n   } /* while 1 */\n }\n"
- title: 9 Example
  contents:
  - "9 Example\n   Consider 2 media packets to be sent, x and y, from SSRC 2. Their\n\
    \   sequence numbers are 8 and 9, respectively, with timestamps of 3 and\n   5,\
    \ respectively. Packet x uses payload type 11, and packet y uses\n   payload type\
    \ 18. Packet x is has 10 bytes of payload, and packet y\n   11. Packet y has its\
    \ marker bit set. The RTP headers for packets x\n   and y are shown in Figures\
    \ 3 and 4 respectively.\n"
- title: Media Packet x
  contents:
  - "Media Packet x\n   0                   1                   2                \
    \   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |1 0|0|0|0\
    \ 0 0 0|0|0 0 0 1 0 1 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 0\n      PTI:       11\n      SN:        8\n      TS:        3\n      SSRC:\
    \      2\n   Figure 3: RTP Header for Media Packet X\n   An FEC packet is generated\
    \ from these two. We assume that payload\n   type 127 is used to indicate an FEC\
    \ packet. The resulting RTP header\n   is shown in Figure 5.\n   The FEC header\
    \ in the FEC packet is shown in Figure 6.\n"
- title: 11 Use with Redundant Encodings
  contents:
  - "11 Use with Redundant Encodings\n   One can consider an FEC packet as a \"redundant\
    \ coding\" of the media.\n"
- title: Media Packet y
  contents:
  - "Media Packet y\n   0                   1                   2                \
    \   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |1 0|0|0|0\
    \ 0 0 0|1|0 0 1 0 0 1 0|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 1\n      PTI:       18\n      SN:        9\n      TS:        5\n      SSRC:\
    \      2\n   Figure 4: RTP Header for Media Packet Y\n   Because of this, the\
    \ payload format for encoding of redundant audio\n   data [5] can be used to carry\
    \ the FEC data along with the media. The\n   procedure for this is as follows.\n\
    \   The FEC operation defined above acts on a stream of RTP media\n   packets.\
    \ The stream which is operated on is the stream before the\n   encapsulation defined\
    \ in RFC 2198 [5]. In other words, the media\n   stream to be protected is encapsulated\
    \ in standard RTP media packets.\n   The FEC operation above is performed (with\
    \ one minor change),\n   generating a stream of FEC packets. The change to the\
    \ procedure above\n   is that if the RTP packets being protected contain an RTP\
    \ extension,\n   padding, or a CSRC list, these MUST be removed from the packets,\
    \ and\n   the CC field, Padding Bit, and Extension but MUST be set to zero,\n\
    \   before the FEC operation is applied. These modified packets are used\n   in\
    \ the procedure above. Note that the sender MUST still send the\n   original packets\
    \ (with the CSRC list, padding, and extension in tact)\n   as the primary encoding\
    \ in RFC 2198. The removal of these fields only\n   applies to the protection\
    \ operation.\n   Once the FEC packets have been generated, the media payload is\n\
    \   extracted from the media packets. This payload is used as the primary\n  \
    \ encoding as defined in RFC 2198. Then, the FEC header and payload of\n   the\
    \ FEC packets is extracted, and treated as a redundant encoding.\n   Additional\
    \ redundant encodings, besides FEC, MAY be added to the\n   packet as well. These\
    \ encodings will not be protected by FEC,\n   however.\n   0                 \
    \  1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Version:   2\n      Padding:   0\n      Extension: 0\n      Marker:   \
    \ 1\n      PTI:       127\n      SN:        1\n      TS:        5\n      SSRC:\
    \      2\n   Figure 5: RTP Header of FEC for Packets X and Y\n   The redundant\
    \ encodings header for the primary codec is set as\n   defined in RFC 2198. The\
    \ redundant encodings header for the FEC data\n   is set as follows. The block\
    \ PT is set to the dynamic PT associated\n   with the FEC format. The block length\
    \ is set to the sum of the\n   lengths of the FEC header and payload. The timestamp\
    \ offset SHOULD be\n   set to zero. The secondary coder payload includes the FEC\
    \ header and\n   FEC payload.\n   At the receiver, the primary codec and all secondary\
    \ codecs are\n   extracted as separate RTP packets. This is done by copying the\n\
    \   sequence number, SSRC, marker bit, CC field, RTP version, and\n   extension\
    \ bit from the RTP header of the redundant encodings packet\n   to the RTP header\
    \ of each extracted packet. If the secondary codec\n   contains FEC, the CC field,\
    \ Extension Bit, and Padding Bit in the RTP\n   header of the FEC packet MUST\
    \ be set to zero instead. The payload\n   type identifier in the extracted packet\
    \ is copied from the block PT\n   of the redundant encodings header. The timestamp\
    \ of the extracted\n   packet is the difference between the timestamp in the RTP\
    \ header and\n   the offset in the block header. The payload of the extracted\
    \ packet\n   is the data block. This will result in the FEC stream and media\n\
    \   stream being extracted.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      SN base:   8    [min(8,9)]\n      len. rec.: 1    [8 xor 9]\n      E: \
    \        0\n      PTI rec.:  25   [11 xor 18]\n      mask:      3\n      TS rec.:\
    \   6    [3 xor 5]\n      The payload length is 11 bytes.\n   Figure 6: FEC Header\
    \ of Result\n   To use the FEC and media packets for recovery, the CSRC list,\n\
    \   extension, and padding MUST be removed from the media packets, if\n   present,\
    \ and the CC field, Extension Bit, and Padding Bit MUST be set\n   to zero. These\
    \ modified media packets, along with the FEC packets,\n   are then used to recover\
    \ based on the procedures in section 8. The\n   recovered media packets will always\
    \ have no extension, padding, or\n   CSRC list. An implementation MAY copy these\
    \ fields into the recovered\n   packet from another media packet, if available.\n\
    \   Using the redundant encodings payload format also implies that the\n   marker\
    \ bit may not be recovered correctly. Applications MUST set the\n   marker bit\
    \ to zero in media packets reconstructed using FEC\n   encapsulated in RFC 2198\
    \ redundancy.\n   An advantage of this approach is a reduction in the overhead\
    \ for\n   sending FEC packets.\n"
- title: 11 Indicating FEC Usage in SDP
  contents:
  - "11 Indicating FEC Usage in SDP\n   FEC packets contain RTP packets with dynamic\
    \ payload type values. In\n   addition, the FEC packets can be sent on separate\
    \ multicast groups or\n   separate ports from the media. The FEC can even be carried\
    \ in packets\n   containing media, using the redundant encodings payload format\
    \ [5].\n   These configuration options must be indicated out of band. This\n \
    \  section describes how this can be accomplished using the Session\n   Description\
    \ Protocol (SDP), specified in RFC 2327 [6].\n"
- title: 11.1 FEC as a Separate Stream
  contents:
  - "11.1 FEC as a Separate Stream\n   In the first case, the FEC packets are sent\
    \ as a separate stream.\n   This can mean they are sent on a different port and/or\
    \ multicast\n   group from the media. When this is done, several pieces of\n \
    \  information must be conveyed:\n        o The address and port where the FEC\
    \ is being sent to\n        o The payload type number for the FEC\n        o Which\
    \ media stream the FEC is protecting\n   The payload type number for the FEC is\
    \ conveyed in the m line of the\n   media it is protecting, listed as if it were\
    \ another valid encoding\n   for the stream. There is no static payload type assignment\
    \ for FEC,\n   so dynamic payload type numbers MUST be used. The binding to the\n\
    \   number is indicated by an rtpmap attribute. The name used in this\n   binding\
    \ is \"parityfec\".\n   The presence of the payload type number in the m line\
    \ of the media it\n   is protecting does not mean the FEC is sent to the same\
    \ address and\n   port as the media. Instead, this information is conveyed through\
    \ an\n   fmtp attribute line. The presence of the FEC payload type on the m\n\
    \   line of the media serves only to indicate which stream the FEC is\n   protecting.\n\
    \   The format for the fmtp line for FEC is:\n   a=fmtp:<number> <port> <network\
    \ type> <addresss type> <connection\n   address>\n   where 'number' is the payload\
    \ type number present in the m line. Port\n   is the port number where the FEC\
    \ is sent to. The remaining three\n   items - network type, address type, and\
    \ connection address - have the\n   same syntax and semantics as the c line from\
    \ SDP. This allows the\n   fmtp line to be partially parsed by the same parser\
    \ used on the c\n   lines. Note that since FEC cannot be hierarchically encoded,\
    \ the\n   <number of addresses> parameter MUST NOT appear in the connection\n\
    \   address.\n   The following is an example SDP for FEC:\n   v=0\n   o=hamming\
    \ 2890844526 2890842807 IN IP4 126.16.64.4\n   s=FEC Seminar\n   c=IN IP4 224.2.17.12/127\n\
    \   t=0 0\n   m=audio 49170 RTP/AVP 0 78\n   a=rtpmap:78 parityfec/8000\n   a=fmtp:78\
    \ 49172 IN IP4 224.2.17.12/127\n   m=video 51372 RTP/AVP 31 79\n   a=rtpmap:79\
    \ parityfec/8000\n   a=fmtp:79 51372 IN IP4 224.2.17.13/127\n   The presence of\
    \ two m lines in this SDP indicates that there are two\n   media streams - one\
    \ audio and one video. The media format of 0\n   indicates that the audio uses\
    \ PCM, and is protected by FEC with\n   payload type number 78. The FEC is sent\
    \ to the same multicast group\n   and TTL as the audio, but on a port number two\
    \ higher (49172). The\n   video is protected by FEC with payload type number 79.\
    \ The FEC\n   appears on the same port as the video (51372), but on a different\n\
    \   multicast address.\n"
- title: 11.2 Use with Redundant Encodings
  contents:
  - "11.2 Use with Redundant Encodings\n   When the FEC stream is being sent as a\
    \ secondary codec in the\n   redundant encodings format, this must be signaled\
    \ through SDP. To do\n   this, the procedures defined in RFC 2198 are used to\
    \ signal the use\n   of redundant encodings. The FEC payload type is indicated\
    \ in the same\n   fashion as any other secondary codec. An rtpmap attribute MUST\
    \ be\n   used to indicate a dynamic payload type number for the FEC packets.\n\
    \   The FEC MUST protect only the main codec. In this case, the fmtp\n   attribute\
    \ for the FEC MUST NOT be present.\n   For example:\n   m=audio 12345 RTP/AVP\
    \ 121 0 5 100\n   a=rtpmap:121 red/8000/1\n   a=rtpmap:100 parityfec/8000\n  \
    \ a=fmtp:121 0/5/100\n   This SDP indicates that there is a single audio stream,\
    \ which can\n   consist of PCM (media format 0) , DVI (media format 5), the redundant\n\
    \   encodings (indicated by media format 121, which is bound to red\n   through\
    \ the rtpmap attribute), or FEC (media format 100, which is\n   bound to parityfec\
    \ through the rtpmap attribute). Although the FEC\n   format is specified as a\
    \ possible coding for this stream, the FEC\n   MUST NOT be sent by itself for\
    \ this stream. Its presence in the m\n   line is required only because non-primary\
    \ codecs must be listed here\n   according to RFC 2198. The fmtp attribute indicates\
    \ that the\n   redundant encodings format can be used, with DVI as a secondary\n\
    \   coding and FEC as a tertiary encoding.\n"
- title: 11.3 Usage with RTSP
  contents:
  - "11.3 Usage with RTSP\n   RTSP [7] can be used to request FEC packets to be sent\
    \ as a separate\n   stream. When SDP is used with RTSP, the Session Description\
    \ does not\n   include a connection address and port number for each stream.\n\
    \   Instead, RTSP uses the concept of a \"Control URL\". Control URLs are\n  \
    \ used in SDP in two distinct ways.\n        1.   There is a single control URL\
    \ for all streams. This is\n             referred to as \"aggregate control\"\
    . In this case, the fmtp\n             line for the FEC stream is omitted.\n \
    \       2.   There is a Control URL assigned to each stream. This is\n       \
    \      referred to as \"non-aggregate control\". In this case, the\n         \
    \    fmtp line specifies the Control URL for the stream of FEC\n             packets.\
    \ The URL may be used in a SETUP command by an RTSP\n             client.\n  \
    \ The format for the fmtp line for FEC with RTSP and non-aggregate\n   control\
    \ is:\n   a=fmtp:<number> <control URL>\n   where 'number' is the payload type\
    \ number present in the m line.\n   Control URL is the URL used to control the\
    \ stream of FEC packets.\n   Note that the Control URL does not need to be an\
    \ absolute URL. The\n   rules for converting a relative Control URL to an absolute\
    \ URL are\n   given in RFC 2326, Section C.1.1.\n"
- title: 12 Security Considerations
  contents:
  - "12 Security Considerations\n   The use of FEC has implications on the usage and\
    \ changing of keys for\n   encryption. As the FEC packets do consist of a separate\
    \ stream, there\n   are a number of permutations on the usage of encryption. In\n\
    \   particular:\n     o The FEC stream may be encrypted, while the media stream\
    \ is\n       not.\n     o The media stream may be encrypted, while the FEC stream\
    \ is\n       not.\n     o The media stream and FEC stream are both encrypted,\
    \ but using\n       different keys.\n     o The media stream and FEC stream are\
    \ both encrypted, but using\n       the same key.\n   The first three of these\
    \ would require any application level\n   signaling protocols to be aware of the\
    \ usage of FEC, and to thus\n   exchange keys for it and negotiate its usage on\
    \ the media and FEC\n   streams separately. In the final case, no such additional\
    \ mechanisms\n   are needed. The first two cases present a layering violation,\
    \ as FEC\n   packets should really be treated no differently than other RTP\n\
    \   packets. Encrypting just one may also make certain known-plaintext\n   attacks\
    \ possible. For these reasons, applications utilizing\n   encryption SHOULD encrypt\
    \ both streams.\n   However, the changing of keys becomes problematic. For example,\
    \ if\n   two packets a and b are sent, and FEC packet f(a,b) is sent, and the\n\
    \   keys used for a and b are different, which key should be used to\n   decode\
    \ f(a,b)? In general, old keys will likely need to be cached, so\n   that when\
    \ the keys change for the media stream, the old key is kept,\n   and used, until\
    \ it is determined that the key has changed on the FEC\n   packets as well.\n\
    \   Another issue with the use of FEC is its impact on network\n   congestion.\
    \ Adding FEC in the face of increasing network losses is a\n   bad idea, as it\
    \ can lead to increased congestion and eventual\n   congestion collapse if done\
    \ on a widespread basis. As a result,\n   implementers MUST NOT substantially\
    \ increase the amount of FEC in use\n   as network losses increase.\n"
- title: 13 Acknowledgments
  contents:
  - "13 Acknowledgments\n   This work is based on an earlier draft on FEC, submitted\
    \ by Budge and\n   Mackenzie in 1997. We would also like to thank Steve Casner,\
    \ Mark\n   Handley, Orion Hodson and Colin Perkins for their comments. Thanks\
    \ to\n   Anders Klemets who wrote the section on usage with RTSP.\n"
- title: 14 Authors' Addresses
  contents:
  - "14 Authors' Addresses\n   Jonathan Rosenberg\n   dynamicsoft\n   200 Executive\
    \ Drive\n   Suite 120\n   West Orange, NJ 07046\n   Email: jdrosen@dynamicsoft.com\n\
    \   Henning Schulzrinne\n   Columbia University\n   M/S 0401, 1214 Amsterdam Ave.\n\
    \   New York, NY 10027-7003\n   EMail: schulzrinne@cs.columbia.edu\n"
- title: 15 Bibliography
  contents:
  - "15 Bibliography\n   [1] J.C. Bolot and A. V. Garcia, \"Control mechanisms for\
    \ packet audio\n       in the internet,\" in Proceedings of the Conference on\
    \ Computer\n       Communications (IEEE Infocom) , (San Francisco, California),\
    \ Mar.\n       1996.\n   [2] Perkins, C. and O. Hodson, \"Options for Repair of\
    \ Streaming\n       media\", RFC 2354, June 1998.\n   [3] Schulzrinne, H., Casner,\
    \ S., Frederick, R. and V. Jacobson, \"RTP:\n       A Transport Protocol for Real-Time\
    \ Applications\", RFC 1889,\n       January 1996.\n   [4] Bradner, S., \"Key words\
    \ for use in RFCs to indicate requirement\n       levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [5] Perkins, C., Kouvelas, I., Hodson, O., Hardman, V., Handley,\
    \ M.,\n       Bolot, J.C., Vega-Garcia, A. and S. Fosse-Parisis, \"RTP Payload\n\
    \       for Redundant Audio Data\", RFC 2198, September 1997.\n   [6] Handley,\
    \ M. and V. Jacobson, \"SDP: Session Description Protocol\",\n       RFC 2327,\
    \ April 1998.\n   [7] Schulzrinne, H., Rao, A. and R. Lanphier, \"Real Time Streaming\n\
    \       Protocol (RTSP)\", RFC 2326, April 1998.\n"
- title: 16.  Full Copyright Statement
  contents:
  - "16.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
