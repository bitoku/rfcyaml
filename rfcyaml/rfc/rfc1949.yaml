- title: __initial_text__
  contents:
  - '                  Scalable Multicast Key Distribution

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The benefits of multicasting are becoming ever-more apparent, and\
    \ its\n   use much more widespread. This is evident from the growth of the\n \
    \  MBONE [1]. Providing security services for multicast, such as traffic\n   integrity,\
    \ authentication, and confidentiality, is particularly\n   problematic since it\
    \ requires securely distributing a group (session)\n   key to each of a group's\
    \ receivers.  Traditionally, the key\n   distribution function has been assigned\
    \ to a central network entity,\n   or Key Distribution Centre (KDC), but this\
    \ method does not scale for\n   wide-area multicasting, where group members may\
    \ be widely-distributed\n   across the internetwork, and a wide-area group may\
    \ be densely\n   populated.\n   Even more problematic is the scalable distribution\
    \ of sender-specific\n   keys. Sender-specific keys are required if data traffic\
    \ is to be\n   authenticated on a per-sender basis.\n   This memo provides a scalable\
    \ solution to the multicast key\n   distribution problem.\n   NOTE: this proposal\
    \ requires some simple support mechanisms, which,\n   it is recommended here,\
    \ be integrated into version 3 of IGMP. This\n   support is described in Appendix\
    \ B.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Growing concern about the integrity of Internet communication\
    \ [13]\n   (routing information and data traffic) has led to the development of\n\
    \   an Internet Security Architecture, proposed by the IPSEC working\n   group\
    \ of the IETF [2]. The proposed security mechanisms are\n   implemented at the\
    \ network layer - the layer of the protocol stack at\n   which networking resources\
    \ are best protected [3].\n   Unlike many network layer protocols, the Core Based\
    \ Tree (CBT)\n   multicast protocol [4] makes explicit provision for security;\
    \ it has\n   its own protocol header, unlike existing IP multicast schemes\n \
    \  [10,11], and other recently proposed schemes [12].\n   In this document we\
    \ describe how the CBT multicast protocol can\n   provide for the secure joining\
    \ of a CBT group tree, and how this same\n   process can provide a scalable solution\
    \ to the multicast key\n   distribution problem.  These security services are\
    \ an integral part\n   of the CBT protocol [4]. Their use is optional, and is\
    \ dependent on\n   each individual group's requirements for security. Furthermore,\
    \ the\n   use of the CBT multicast protocol for multicast key distribution does\n\
    \   not preclude the use of other multicast protocols for the actual\n   multicast\
    \ communication itself, that is, CBT need only be the vehicle\n   with which to\
    \ distribute keys.\n   Secure joining implies the provision for authentication,\
    \ integrity,\n   and optionally, confidentiality, of CBT join messages. The scheme\
    \ we\n   describe provides for the authentication of tree nodes (routers) and\n\
    \    receivers (end-systems) as part of the tree joining process. Key\n   distribution\
    \ (optional) is an integral part of secure joining.\n   Network layer multicast\
    \ protocols, such as DVMRP [7] and M-OSPF [9],\n   do not have their own protocol\
    \ header(s), and so cannot provision for\n   security in themselves; they must\
    \ rely on whatever security is\n   provided by IP itself. Multicast key distribution\
    \ is not addressed to\n   any significant degree by the new IP security architecture\
    \ [2].\n   The CBT security architecture is independent of any particular\n  \
    \ cryptotechniques, although many security services, such as\n   authentication,\
    \ are easier if public-key cryptotechniques are\n   employed.\n   What follows\
    \ is an overview of the CBT multicasting. The description\n   of our proposal\
    \ in section 6.1 assumes the reader is reasonably\n   familiar with the CBT protocol.\
    \ Details of the CBT architecture and\n   protocol can be found in [7] and [4],\
    \ respectively.\n"
- title: 2.  Overview of BCT Multicasting
  contents:
  - "2.  Overview of BCT Multicasting\n   CBT is a new architecture for local and\
    \ wide-area IP multicasting,\n   being unique in its utilization of just one shared\
    \ delivery tree per\n   group, as opposed to the source-based delivery tree approach\
    \ of\n   existing IP multicast schemes, such as DVMRP and MOSPF.\n   A shared\
    \ multicast delivery tree is built around several so-called\n   core routers.\
    \ A group receiver's local multicast router is required\n   to explicitly join\
    \ the corresponding delivery tree after receiving an\n   IGMP [8] group membership\
    \ report over a directly connected interface.\n   A CBT join message is targeted\
    \ at one of the group's core routers.\n   The resulting acknowledgement traverses\
    \ the reverse-path of the join,\n   resulting in the creation of a tree branch.\
    \ Routers along these\n   branches are called non-core routers for the group,\
    \ and there exists\n   a parent-child relationship between adjacent routers along\
    \ a branch\n   of the same tree (group).\n"
- title: 3.  How the CBT Architecture Complements Security
  contents:
  - "3.  How the CBT Architecture Complements Security\n   The CBT architecture requires\
    \ \"leaf\" routers to explicitly join a CBT\n   tree. Hence, CBT is not data driven;\
    \ the ack associated with a join\n   \"fixes\" tree state in the routers that\
    \ make up the tree. This so-\n   called \"hard state\" remains until the tree\
    \ re-configures, for\n   example, due to receivers leaving the group, or because\
    \ an upstream\n   failure has occurred. The CBT protocol incorporates mechanisms\n\
    \   enabling a CBT tree to repair itself in the event of the latter.\n   As far\
    \ as the establishment of an authenticated multicast\n   distribution tree is\
    \ concerned, DVMRP, M-OSPF, and PIM, are at a\n   disadvan- tage; the nature of\
    \ their \"soft state\" means a delivery\n   tree only exists as long as there\
    \ is data flow.  Also, routers\n   implementing a multicast protocol that builds\
    \ its delivery tree based\n   on a reverse-path check (like DVMRP and PIM dense\
    \ mode) cannot be\n   sure of the previous-hop router, but only the interface\
    \ a multicast\n   packet arrived on.\n   These problems do not occur in the CBT\
    \ architecture. CBT's hard state\n   approach means that all routers that make\
    \ up a delivery tree know who\n   their on-tree neighbours are; these neighbours\
    \ can be authenticated\n   as part of delivery tree set-up. As part of secure\
    \ tree set-up,\n   neighbours could exchange a secret packet handle for inclusion\
    \ in the\n   CBT header of data packets exchanged between those neighbours,\n\
    \   allowing for the simple and efficient hop-by-hop authentication of\n   data\
    \ packets (on-tree).\n   The presence of tree focal points (i.e. cores) provides\
    \ CBT trees\n   with natural authorization points (from a security viewpoint)\
    \ -- the\n   formation of a CBT tree requires a core to acknowledge at least one\n\
    \   join in order for a tree branch to be formed. Thereafter,\n   authorization\
    \ and key distribution capability can be passed on to\n   joining nodes that are\
    \ authenticated.\n   In terms of security, CBT's hard state approach offers several\n\
    \   additional advantages: once a multicast tree is established, tree\n   state\
    \ maintained in the routers that make up the tree does not time\n   out or change\
    \ necessarily to reflect underlying unicast topology.\n   The security implications\
    \ of this are that nodes need not be subject\n   to repeated authentication subsequent\
    \ to a period of inactivity, and\n   tree nodes do not need to re-authenticate\
    \ themselves as a result of\n   an underlying unicast topology change, unless\
    \ of course, an network\n   (node) failure has occurred.\n   Hard-state protocol\
    \ mechanisms are often thought of as being less\n   fault tolerant than soft-state\
    \ schemes, but there are pros and cons\n   to both approaches; we see here that\
    \ security is one of the pros.\n"
- title: 4.  The Multicast Key Distribution Problem
  contents:
  - "4.  The Multicast Key Distribution Problem\n   We believe that multicast key\
    \ distribution needs to be combined with\n   group access control. Without group\
    \ access control, there is no point\n   in employing multicast key distribution,\
    \ since, if there are no group\n   restrictions, then it should not matter to\
    \ whom multicast information\n   is divulged.\n   There are different ways of\
    \ addressing group access control. The\n   group access control we describe requires\
    \ identifying one group\n   member (we suggest in [14] that this should be the\
    \ group initiator)\n   who has the ability to create, modify and delete all or\
    \ part of a\n   group access control list. The enforcement of group access control\n\
    \   may be done by a network entity external to the group, or by a group\n   member.\n\
    \   The essential problem of distributing a session (or group) key to a\n   group\
    \ of multicast receivers lies in the fact that some central key\n   management\
    \ entity, such as a key distribution centre (KDC) (A Key\n   Distribution Centre\
    \ (KDC) is a network entity, usually residing at a\n   well-known address. It\
    \ is a third party entity whose responsibility\n   it to generate and distribute\
    \ symmetric key(s) to peers, or group\n   receivers in the case of multicast,\
    \ wishing to engage in a \"secure\"\n   communication. It must therefore be able\
    \ to identify and reliably\n   authenticate requestors of symmetric keys.), must\
    \ authenticate each\n   of a group's receivers, as well as securely distribute\
    \ a session key\n   to each of them.  This involves encrypting the relevant message\
    \ n\n   times, once with each secret key shared between the KDC and\n   corresponding\
    \ receiver (or alternatively, with the public key of the\n   receiver), before\
    \ multicasting it to the group. (Alternatively, the\n   KDC could send an encrypted\
    \ message to each of the receivers\n   individually, but this does not scale either.)\
    \  Potentially, n may be\n   very large.  Encrypting the group key with the secret\
    \ key (of a\n   secret-public key pair) of the KDC is not an option, since the\
    \ group\n   key would be accessible to anyone holding the KDC's public key, and\n\
    \   public keys are either well-known or readily available.  In short,\n   existing\
    \ multicast key distribution methods do not scale.\n   The scaling problem of\
    \ secure multicast key distribution is\n   compounded for the case where sender-specific\
    \ keys need to be\n   distributed to a group. This is required for sender-specific\n\
    \   authentication of data traffic. It is not possible to achieve per-\n   sender\
    \ authentication, given only a group session key.\n   Recently a proposal has\
    \ emerged, called the Group Key Management\n   Protocol (GKMP) [15]. This was\
    \ designed for military networks, but\n   the authors have demonstrated how the\
    \ architecture could be applied\n   to a network like the Internet, running receiver-oriented\
    \ multicast\n   applications.\n   GKMP goes a considerable way to addressing the\
    \ problems of multicast\n   key distribution: it does not rely on a centralised\
    \ KDC, but rather\n   places the burden of key management on a group member(s).\
    \ This is the\n   approach adopted by the CBT solution, but our solution can take\
    \ this\n   distributed approach further, which makes our scheme that much more\n\
    \   scalable. Furthermore, our scheme is relatively simple.\n   The CBT model\
    \ for multicast key distribution is unique in that it is\n   integrated into the\
    \ CBT multicast protocol itself. It offers a\n   simple, low-cost, scalable solution\
    \ to multicast key distribution. We\n   describe the CBT multicast key distribution\
    \ approach below.\n"
- title: 5.  Multicast Security Associations
  contents:
  - "5.  Multicast Security Associations\n   The IP security architecture [2] introduces\
    \ the concept of \"Security\n   Associations\" (SAs), which must be negotiated\
    \ in advance during the\n   key management phase, using a protocol such as Photuris\
    \ [20], or\n   ISAKMP [21].  A Security Association is normally one-way, so if\
    \ two-\n   way communication is to take place (e.g. a typical TCP connection),\n\
    \   then two Security Associations need to be negotiated.  During the\n   negotiation\
    \ phase, the destination system normally assigns a Security\n   Parameter Index\
    \ to the association, which is used, together with the\n   destination address\
    \ (or, for the sender, the sender's user-id) to\n   index into a Security Association\
    \ table, maintained by the\n   communicating parties.  This table enables those\
    \ parties to index the\n   correct security parameters pertinent to an association.\
    \  The\n   security association parameters include authentication algorithm,\n\
    \   algorithm mode, cryptographic keys, key lifetime, sensitivity level,\n   etc.\n\
    \   The establishment of Security Associations (SA) for multicast\n   communication\
    \ does not scale using protocols like Photuris, or\n   ISAKMP.  This is why it\
    \ is often assumed that a multicast group will\n   be part of a single Security\
    \ Association, and hence share a single\n   SPI. It is assumed that one entity\
    \ (or a pair of entities) creates\n   the SPI \"by some means\" (which may be\
    \ an SA negotiation protocol,\n   like [20] and [21]), which is then simply multicast,\
    \ together with\n   the SA parameters, to the group for subsequent use. However,\
    \ this\n   precludes multicast receivers from performing sender-specific origin\n\
    \   authentication; all a receiver can be sure of is that the sender is\n   part\
    \ of the multicast Security Association.\n   We advocate that the primary core,\
    \ either alone, or in conjunction\n   with the group initiator, establish the\
    \ security parameters to be\n   used in the group communication. These are distributed\
    \ as part of the\n   secure join process. Thereafter, individual senders can distribute\n\
    \   their own key and security parameters to the group.  In the case of\n   the\
    \ latter, there are two cases to consider:\n   +    the sender is already a group\
    \ member. In this case, the sender\n        can decide upon/generate its own security\
    \ parameters, and multi-\n        cast them to the group using the current group\
    \ session key.\n   +    the sender is not a group member. In this case, before\
    \ the\n        sender begins sending, it must first negotiate the security\n \
    \       parameters with the primary core, using a protocol such as Pho-\n    \
    \    turis [20] or ISAKMP [21].  Once completed, the primary core\n        multicasts\
    \ (securely) the new sender's session key and security\n        parameters to\
    \ the group.\n   Given that we assume the use of asymmetric cryptotechniques\n\
    \   throughout, this scheme provides a scalable solution to multicast\n   origin\
    \ authentication.\n   Sender-specific keys are also discussed in section 8.\n"
- title: 6.  The CBT Multicast Key Distribution Model
  contents:
  - "6.  The CBT Multicast Key Distribution Model\n   The security architecture we\
    \ propose allows not only for the secure\n   joining of a CBT multicast tree,\
    \ but also provides a solution to the\n   multicast key distribution problem [16].\
    \ Multicast key distribution\n   is an optional, but integral, part of the secure\
    \ tree joining\n   process; if a group session key is not required, its distribution\
    \ may\n   be omitted.\n   The use of CBT for scalable multicast key distribution\
    \ does not\n   preclude the use of other multicast protocols for the actual\n\
    \   multicast communication.  CBT could be used solely for multicast key\n   distribution\
    \ -- any multicast protocol could be used for the actual\n   multicast communication\
    \ itself.\n   The model that we propose does not rely on the presence of a\n \
    \  centralised KDC -- indeed, the KDC we propose need not be dedicated\n   to\
    \ key distribution. We are proposing that each group have its own\n   group key\
    \ distribution centre (GKDC), and that the functions it\n   provides should be\
    \ able to be \"passed on\" to other nodes as they join\n   the tree.  Hence, our\
    \ scheme involves truly distributed key\n   distribution capability, and is therefore\
    \ scalable. It does not\n   require dedicated KDCs.  We are proposing that a CBT\
    \ primary core\n   initially take on the role of a GKDC.\n"
- title: 6.1  Operational Overview
  contents:
  - "6.1  Operational Overview\n   When a CBT group is created, it is the group initiator's\n\
    \   responsibility to create a multicast group access control list (ACL)\n   [14].\
    \ It is recommended that this list is a digitally signed\n   \"document\", the\
    \ same as (or along the lines of) an X.509 certificate\n   [9], such that it can\
    \ be authenticated.  The group initiator\n   subsequently unicasts the ACL to\
    \ the primary core for the group. This\n   communication is not part of the CBT\
    \ protocol. The ACL's digital\n   signature ensures that it cannot be modified\
    \ in transit without\n   detection. If the group membership itself is sensitive\
    \ information,\n   the ACL can be additionally encrypted with the public key of\
    \ the\n   primary core before being sent.  The ACL can be an \"inclusion\" list\n\
    \   or an \"exclusion\" list, depending on whether group membership\n   includes\
    \ relatively few, or excludes relatively few.\n   The ACL described above consists\
    \ of group membership (inclusion or\n   exclusion) information, which can be at\
    \ the granularity of hosts or\n   users. How these granularities are specified\
    \ is outside the scope of\n   this document.  Additionally, it may be desirable\
    \ to restrict key\n   distribution capability to certain \"trusted\" nodes (routers)\
    \ in the\n   network, such that only those trusted nodes will be given key\n \
    \  distribution capability should they become part of a CBT delivery\n   tree.\
    \ For this case, an additional ACL is required comprising\n   \"trusted\" network\
    \ nodes.\n   The primary core creates a session key subsequent to receiving and\n\
    \   authenticating the message containing the access control list.  The\n   primary\
    \ core also creates a key encrypting key (KEK) which is used\n   for re-keying\
    \ the group just prior to an old key exceeding its life-\n   time.  This re-keying\
    \ strategy means that an active key is less\n   likely to become compromised during\
    \ its lifetime.\n   The ACL(s), group key, and KEK are distributed to secondary\
    \ cores as\n   they become part of the distribution tree.\n   Any tree node with\
    \ this information can authenticate a joining\n   member, and hence, secure tree\
    \ joining and multicast session key\n   distribution are truly distributed across\
    \ already authenticated tree\n   nodes.\n"
- title: 6.2  Integrated Join Authentication and Multicast Key Distribution
  contents:
  - "6.2  Integrated Join Authentication and Multicast Key Distribution\n   For simplicity,\
    \ in our example we assume the presence of an\n   internetwork-wide asymmetric\
    \ key management scheme, such as that\n   proposed in [17].  However, we are not\
    \ precluding the use of\n   symmetric cryptographic techniques -- all of the security\
    \ services we\n   are proposing, i.e. integrity, authentication, and confidentiality,\n\
    \   can all be achieved using symmetric cryptography, albeit a greater\n   expense,\
    \ e.g. negotiation with a third party to establish pairwise\n   secret keys. For\
    \ these reasons, we assume that a public (asymmetric)\n   key management scheme\
    \ is globally available, for example, through the\n   Domain Name System (DNS)\
    \ [17] or World Wide Web [18].\n   NOTE: given the presence of asymmetric keys,\
    \ we can assume digital\n   signatures provide integrity and origin authentication\
    \ services\n   combined.\n   The terminology we use here is described in Appendix\
    \ A. We formally\n   define some additional terms here:\n   +    grpKey: group\
    \ key used for encrypting group data traffic.\n   +    ACL: group access control\
    \ list.\n   +    KEK: key encrypting key, used for re-keying a group with a new\n\
    \        group key.\n   +    SAparams: Security Association parameters, including\
    \ SPI.\n   +    group access package (grpAP): sent from an already verified tree\n\
    \        node to a joining node.\n        [token_sender, [ACL]^SK_core, {[grpKey,\
    \ KEK,\n        SAparams]^SK_core}^PK_origin-host,\n        {[grpKey, KEK, SAparams]^SK_core}^PK_next-hop]^SK_sender\n\
    \        NOTE: SK_core is the secret key of the PRIMARY core.\n   As we have already\
    \ stated, the elected primary core of a CBT tree\n   takes on the initial role\
    \ of GKDC. In our example, we assume that a\n   group access control list has\
    \ already been securely communicated to\n   the primary core. Also, it is assumed\
    \ the primary core has already\n   participated in a Security Association estabishment\
    \ protocol [20,21],\n   and thus, holds a group key, a key-encrypting key, and\
    \ an SPI.\n      NOTE, there is a minor modification required to the CBT protocol\n\
    \      [4], which is as follows: when a secondary core receives a join,\n    \
    \  instead of sending an ack followed by a re-join to the primary,\n      the\
    \ secondary forwards the join to the primary; the ack travels\n      from the\
    \ primary (or intermediate on-tree router) back to the join\n      origin. All\
    \ routers (or only specific routers) become GKDCs after\n      they receive the\
    \ ack.\n   We now demonstrate, by means of an example, how CBT routers join a\n\
    \   tree securely, and become GKDCs. For clarity, in the example, it is\n   assumed\
    \ all routers are authorised to become GKDCs, i.e. there is no\n   trusted-router\
    \ ACL.\n   In the diagram below, only one core (the primary) is shown. The\n \
    \  process of a secondary joining the primary follows exactly what we\n   describe\
    \ here.\n   In the diagram, host h wishes to join multicast group G.  Its local\n\
    \   multicast router (router A) has not yet joined the CBT tree for the\n   group\
    \ G.\n    b      b     b-----b\n     \\     |     |\n      \\    |     |\n   \
    \    b---b     b------b\n      /     \\  /              KEY....\n     /      \
    \ \\/\n    b         C               C = Core (Initial Group Key Dist'n Centre)\n\
    \             / \\             A, B, b = non-core routers\n            /   \\\n\
    \           /     \\           ======= LAN where host h is located\n         \
    \  B      b------b\n            \\\n             \\              NOTE: Only one\
    \ core is shown, but typically\n"
- title: host h        A              a CBT tree is likely to comprise several.
  contents:
  - "host h        A              a CBT tree is likely to comprise several.\n    o\
    \         |\n"
- title: =====================
  contents:
  - "=====================\n       Figure 1: Example of Multicast Key Distribution\
    \ using CBT\n   A branch is created as part of the CBT secure tree joining process,\n\
    \   as follows:\n   +    Immediately subsequent to a multicast application starting\
    \ up on\n        host h, host h immediately sends an IGMP group membership\n \
    \       report, addressed to the group. This report is not suppressible\n    \
    \    (see Appendix B), like other IGMP report types, and it also\n        includes\
    \ the reporting host's token, which is digitally signed\n        h --> DR (A):\
    \ [[token_h]^SK_h, IGMP group membership report]\n        (A host's token differs\
    \ in two respects compared with tokens\n        defined in [9]. To refresh, a\
    \ token assists a recipient in the\n        verification process, and typically\
    \ contains: recipient's\n        unique identity, a timestamp, and a pseudo-random\
    \ number. A\n        token is also usually digitally signed by its originator.\n\
    \        Firstly, A host's token does not contain the intended\n        recipient's\
    \ identity, since this token may need to traverse\n        several CBT routers\
    \ before reaching a GKDC.  A host does not\n        actually know which router,\
    \ i.e. GKDC, will actually\n        acknowledge the join that it invoked.  Secondly,\
    \ the host's\n        token is digitally signed -- this is usual for a token.\n\
    \        However, tokens generated by routers need not be explicitly\n       \
    \ digitally signed because the JOIN-REQUESTs and JOIN-ACKs that\n        carry\
    \ them are themselves digitally signed.)\n   +    In response to receiving the\
    \ IGMP report, the local designated\n        router (router A) authenticates the\
    \ host's enclosed token. If\n        successful, router A formulates a CBT join-request,\
    \ whose target\n        is core C (the primary core). Router A includes its own\
    \ token in\n        the join, as well as the signed token received from host h.\
    \ The\n        join is digitally signed by router A.\n        NOTE 1: router A,\
    \ like all CBT routers, is configured with the\n        unicast addresses of a\
    \ prioritized list of cores, for different\n        group sets, so that joins\
    \ can be targeted accordingly.\n        NOTE 2: the host token is authenticated\
    \ at most twice, once by\n        the host's local CBT router, and once by a GKDC.\
    \ If the local\n        router is already a GKDC, then authentication only happens\
    \ once.\n        If the local router is not already a GKDC, a failed authentica-\n\
    \        tion check removes the overhead of generating and sending a CBT\n   \
    \     join-request.\n        Router A unicasts the join to the best next-hop router\
    \ on the\n        path to core C (router B).\n            A --> B: [[token_A],\
    \ [token_h]^SK_h, JOIN-REQUEST]^SK_A\n   +    B authenticates A's join-request.\
    \ If successful, B repeats the\n        previous step, but now the join is sent\
    \ from B to C (the pri-\n        mary, and target), and the join includes B's\
    \ token. Host h's\n        token is copied to this new join.\n            B -->\
    \ C: [[token_B], [token_h]^SK_h, JOIN-REQUEST]^SK_B\n   +    C authenticates B's\
    \ join. As the tree's primary authorization\n        point (and GKDC), C also\
    \ authenticates host h, which triggered\n        the join process. For this to\
    \ be successful, host h must be\n        included in the GKDC's access control\
    \ list for the group.  If h\n        is not in the corresponding access control\
    \ list, authentication\n        is redundant, and a join-nack is returned from\
    \ C to B, which\n        eventually reaches host h's local DR, A.\n        Assuming\
    \ successful authentication of B and h, C forms a group\n        access package\
    \ (grpAP), encapsulates it in a join-ack, and digi-\n        tally signs the complete\
    \ message. C's token, host h's signed\n        token, a signed ACL, and two (group\
    \ key, KEK) pairs are included\n        in the group access package; one for the\
    \ originating host, and\n        one for the next-hop CBT router to which the\
    \ join-ack is des-\n        tined. Each key pair is digitally signed by the issuer,\
    \ i.e. the\n        primary core for the group. The host key pair is encrypted\
    \ using\n        the public key of the originating host, so as to be only deci-\n\
    \        pherable by the originating host, and the other key pair is\n       \
    \ encrypted using the public key of the next-hop router to which\n        the\
    \ ack is destined -- in this case, B.  Host h's token is used\n        by the\
    \ router connected to the subnet where h resides so as to\n        be able to\
    \ identify the new member.\n              C --> B: [[token^h]^SK_h, grpAP, JOIN-ACK]^SK_C\n\
    \   +    B authenticates the join-ack from C. B extracts its encrypted\n     \
    \   key pair from the group access package, decrypts it, authenti-\n        cates\
    \ the primary core, and stores the key pair in encrypted\n        form, using\
    \ a local key.  B also verifies the digital signature\n        included with the\
    \ access control list. It subsequently stores\n        the ACL in an appropriate\
    \ table.  The originating host key pair\n        remains enciphered.\n       \
    \ The other copy of router B's key pair is taken and deciphered\n        using\
    \ its secret key, and immediately enciphered with the public\n        key of next-hop\
    \ to which a join-ack must be passed, i.e. router\n        A. A group access package\
    \ is formulated by B for A. It contains\n        B's token, the group ACL (which\
    \ is digitally signed by the pri-\n        mary core), a (group key, KEK) pair\
    \ encrypted using the public\n        key of A, and the originating host's key\
    \ pair, already\n        encrypted.  The group access package is encapsulated\
    \ in a join-\n        ack, the complete message is digitally signed by B, then\
    \ for-\n        warded to A.\n                B --> A: [[token^h]^SK_h, grpAP,\
    \ JOIN-ACK]^SK_B\n   +    A authenticates the join-ack received from B.  A copy\
    \ of the\n        encrypted key pair that is for itself is extracted from the\n\
    \        group access package and deciphered, and the key issuer (primary\n  \
    \      core) is authenticated.  If successful, the enciphered key pair\n     \
    \   is stored by A.  The digital signature of the included access\n        control\
    \ list is also verified, and stored in an appropriate\n        table.  The key\
    \ pair encrypted for host h is extracted from the\n        group access package,\
    \ and is forwarded directly to host h, which\n        is identified from the presence\
    \ of its signed token.  On\n        receipt, host h decrypts the key pair for\
    \ subsequent use, and\n        stores the SA parameters in its SA table.\n   \
    \       A --> h: [[token^h]^SK_h, {grpKey, KEK, SAparams}^PK_h]\n   Going back\
    \ to the initial step of the tree-joining procedure, if the\n   DR for the group\
    \ being joined by host h were already established as\n   part of the corresponding\
    \ tree, it would already be a GKDC. It would\n   therefore be able to directly\
    \ pass the group key and KEK to host h\n   after receiving an IGMP group membership\
    \ report from h:\n          A --> h: [[token^h]^SK_h, {grpKey, KEK, SAparams}^PK_h]\n\
    \   If paths, or nodes fail, a new route to a core is gleaned as normal\n   from\
    \ the underlying unicast routing table, and the re-joining process\n   (see [4])\
    \ occurs in the same secure fashion.\n"
- title: 7.  A Question of Trust
  contents:
  - "7.  A Question of Trust\n   The security architecture we have described, involving\
    \ multicast key\n   distribution, assumes that all routers on a delivery tree\
    \ are trusted\n   and do not misbehave. A pertinent question is: is it reasonable\
    \ to\n   assume that network routers do not misbehave and are adequately\n   protected\
    \ from malicious attacks?\n   Many would argue that this is not a reasonable assumption,\
    \ and\n   therefore the level of security should be increased to discount the\n\
    \   threat of misbehaving routers. As we described above, routers\n   periodically\
    \ decrypt key pairs in order to verify them, and/or re-\n   encrypt them to pass\
    \ them on to joining neighbour routers.\n   In view of the above, we suggest that\
    \ if more stringent security is\n   required, the model we presented earlier should\
    \ be slightly amended\n   to accommodate this requirement.  However, depending\
    \ on the security\n   requirement and perceived threat, the model we presented\
    \ may be\n   acceptable.\n   We recommend the following change to the model already\
    \ presented\n   above, to provide a higher level of security:\n   All join-requests\
    \ must be authenticated by a core router, i.e. a join\n   arriving at an on-tree\
    \ router must be forwarded upstream to a core if\n   the join is identified as\
    \ being a \"secure\" join (as indicated by the\n   presence of a signed host token).\n\
    \   The implication of this is that key distribution capability remains\n   with\
    \ the core routers and is not distributed to non-core routers\n   whose joins\
    \ have been authenticated. Whilst this makes our model\n   somewhat less distributed\
    \ than it was before, the concept of key\n   distribution being delegated to the\
    \ responsibility of individual\n   groups remains.  Our scheme therefore retains\
    \ its attractiveness over\n   centralized schemes.\n"
- title: 8.  The Multicast Distribution of Sender-Specific Keys
  contents:
  - "8.  The Multicast Distribution of Sender-Specific Keys\n   Section 5, in part,\
    \ discussed the scalable distribution of sender-\n   specific keys and sender-specific\
    \ security parameters to a multicast\n   group, for both member-senders, and non-member\
    \ senders. If asymmetric\n   cryptotechniques are employed, this allows for sender-specific\
    \ origin\n   authentication.\n   For member-senders, the following message is\
    \ multicast to the group,\n   encrypted using the current group session key, prior\
    \ to the new\n   sender transmitting data:\n            {[sender_key, senderSAparams]^SK_sender}^group_key\n\
    \   Non-member senders must first negotiate (e.g. using Photuris or\n   ISAKMP)\
    \ with the primary core, to establish the security association\n   parameters,\
    \ and the session key, for the sender.  The sender, of\n   course, is subject\
    \ to access control at the primary.  Thereafter, the\n   primary multicasts the\
    \ sender-specific session key, together with\n   sender's security parameters\
    \ to the group, using the group's current\n   session key.  Receivers are thus\
    \ able to perform origin\n   authentication.\n                           Photuris\
    \ or ISAKMP\n             1. sender <----------------------> primary core\n  \
    \        2. {[sender_key, senderSAparams]^SK_primary}^group_key\n   For numerous\
    \ reasons, it may be desirable to exclude certain group\n   members from all or\
    \ part of a group's communication.  We cannot offer\n   any solution to providing\
    \ this capability, other than requiring new\n   keys to be distributed via the\
    \ establishment of a newly-formed group\n   (CBT tree).\n"
- title: 9.  Summary
  contents:
  - "9.  Summary\n   This memo has offered a scalable solution to the multicast key\n\
    \   distribution problem. Our solution is based on the CBT architecture\n   and\
    \ protocol, but this should not preclude the use of other multicast\n   protocols\
    \ for secure multicast communication subsequent to key\n   distribution. Furthermore,\
    \ virtually all of the functionality present\n   in our solution is in-built in\
    \ the secure version of the CBT\n   protocol, making multicast key distribution\
    \ an optional, but integral\n   part, of the CBT protocol.\n"
- title: Appendix A
  contents:
  - "Appendix A\n   The following terminology is used throughout this document:\n\
    \   +    PK_A indicates the public key of entity A.\n   +    SK_A indicates the\
    \ secret key of entity A. The secret key can be\n        used by a sender to digitally\
    \ sign a digest of the message,\n        which is computed using a strong, one-way\
    \ hash function, such as\n        MD5 [19].\n   +    Unencrypted messages will\
    \ appear enclosed within square brack-\n        ets, e.g. [X, Y, Z]. If a message\
    \ is digitally signed, a super-\n        script will appear outside the right\
    \ hand bracket, indicating\n        the message signer.  Encrypted messages appear\
    \ enclosed within\n        curly braces, with a superscript on the top right hand\
    \ side out-\n        side the closing curly brace indicating the encryption key,\
    \ e.g.\n        {X, Y, Z}^{PK_A}.\n   +    a token is information sent as part\
    \ of a strong authentication\n        exchange, which aids a receiver in the message\
    \ verification pro-\n        cess. It consists of a timestamp, t (to demonstrate\
    \ message\n        freshness), a random, non-repeating number, r (to demonstrate\n\
    \        message originality), and the unique name of the message\n        recipient\
    \ (to demonstrate that the message is indeed intended\n        for the recipient).\
    \  A digital signature is appended to the\n        token by the sender (which\
    \ allows the recipient to authenticate\n        the sender). The token is as follows:\n\
    \             [t_A, r_A, B]^{SK_A} --  token sent from A to B.\n   +    A -->\
    \ B:  -- denotes a message sent from A to B.\n"
- title: Appendix B
  contents:
  - "Appendix B\n   The group access controls described in this document require a\
    \ few\n   simple support mechanisms, which, we recommend, be integrated into\n\
    \   version 3 of IGMP. This would be a logical inclusion to IGMP, given\n   that\
    \ version 3 is expected to accommodate a variety of multicast\n   requirements,\
    \ including security. Furthermore, this would remove the\n   need for the integration\
    \ of a separate support protocol in hosts.\n   To refresh, IGMP [8] is a query/response\
    \ multicast support protocol\n   that operates between a multicast router and\
    \ attached hosts.\n   Whenever an multicast application starts on a host, that\
    \ host\n   generates a small number of IGMP group membership reports in quick\n\
    \   succession (to overcome potential loss). Thereafter, a host only\n   issues\
    \ a report in response to an IGMP query (issued by the local\n   multicast router),\
    \ but only if the host has not received a report for\n   the same group (issued\
    \ by some other host on the same subnet) before\n   the host's IGMP random response\
    \ timer expires. Hence, IGMP,\n   incorporates a report \"suppression\" mechanism\
    \ to help avoid \"IGMP\n   storms\" on a subnet, and generally conserve bandwidth.\n\
    \   We propose that IGMP accommodate \"secure joins\" - IGMP reports that\n  \
    \ indicate the presence of a digitally signed host (or user) token.\n   These\
    \ report types must not be suppressible, as is typically the case\n   with IGMP\
    \ reports; it must be possible for each host to independently\n   report its group\
    \ presence to the local router, since a GKDC bases its\n   group access control\
    \ decision on this information.\n   This functionality should not adversely affect\
    \ backwards\n   compatibility with earlier versions of IGMP that may be present\
    \ on\n   the same subnet; the new reports will simply be ignored by older IGMP\n\
    \   versions, which thus continue to operate normally.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Tony Ballardie,\n   Department of Computer Science,\n  \
    \ University College London,\n   Gower Street,\n   London, WC1E 6BT,\n   ENGLAND,\
    \ U.K.\n   Phone: ++44 (0)71 419 3462\n   EMail: A.Ballardie@cs.ucl.ac.uk\n"
- title: References
  contents:
  - "References\n   [1] MBONE, The Multicast BackbONE; M. Macedonia and D. Brutzman;\n\
    \   available from http://www.cs.ucl.ac.uk/mice/mbone_review.html.\n   [2] R.\
    \ Atkinson. Security Architecture for the Internet Protocol; RFC\n   1825, SRI\
    \ Network Information Center, August 1995.\n   [3] D. Estrin and G. Tsudik. An\
    \ End-to-End Argument for Network Layer,\n   Inter-Domain Access Controls; Journal\
    \ of Internetworking & Experience,\n   Vol 2, 71-85, 1991.\n   [4] A. Ballardie,\
    \ S. Reeve, N. Jain. Core Based Tree (CBT) Multicast -\n   Protocol Specification;\
    \ Work in Progress, 1996. Available from:\n   ftp://cs.ucl.ac.uk/darpa/IDMR/draft-ietf-idmr-cbt-spec-XX.txt.\n\
    \   [5] R. Atkinson. IP Authentication Header; RFC 1826, SRI Network\n   Information\
    \ Center, August 1995.\n   [6] R. Atkinson. IP Encapsulating Security Payload;\
    \ RFC 1827, SRI Net-\n   work Information Center, August 1995.\n   [7] A. Ballardie.\
    \ Core Based Tree (CBT) Multicast Architecture; Work\n   in progress, 1996. Available\
    \ from:\n   ftp://cs.ucl.ac.uk/darpa/IDMR/draft-ietf-idmr-cbt-arch-XX.txt\n  \
    \ [8] W. Fenner. Internet Group Management Protocol, version 2 (IGMPv2),\n   Work\
    \ in progress, 1996.\n   [9] CCITT Data Communication Networks Directory (Blue\
    \ Book). Recommen-\n   dation X.509, Authentication Framework.\n   [10] T. Pusateri.\
    \ Distance-Vector Multicast Routing Protocol (DVMRP)\n   version 3. Working draft,\
    \ February 1996.\n   [11] J. Moy. Multicast Extensions to OSPF; RFC 1584, SRI\
    \ Network\n   Information Center, March 1994.\n   [12] D. Estrin et al. Protocol\
    \ Independent Multicast, protocol specif-\n   ication; Work in progress, January\
    \ 1996.\n   [13] R. Braden, D. Clark, S. Crocker and C. Huitema. Security in the\n\
    \   Internet Architecture. RFC 1636, June 1994.\n   [14] A. Ballardie and J. Crowcroft.\
    \ Multicast-Specific Security\n   Threats and Counter-Measures. In ISOC Symposium\
    \ on Network and Distri-\n   buted System Security, February 1995.\n   [15] H.\
    \ Harney, C. Muckenhirn, and T. Rivers. Group Key Management\n   Protocol (GKMP)\
    \ Architecture. Working draft, 1994.\n   [16] N. Haller and R. Atkinson. RFC 1704,\
    \ On Internet Authentication.\n   SRI Network Information Center, October 1994.\n\
    \   [17] C. Kaufman and D. Eastlake. DNS Security Protocol Extensions.\n   Working\
    \ draft, January 1996.\n   [18] T. Berners-Lee, R. Cailliau, A. Luotonen, H. Frystyk\
    \ Nielsen, A.\n   Secret.  The World Wide Web. Communications of the ACM, 37(8):76-82,\n\
    \   August 1994.\n   [19] R. Rivest. RFC 1321, The MD-5 Message Digest Algorithm,\
    \ SRI Net-\n   work Information Center, 1992.\n   [20] P. Karn, W. Simpson. The\
    \ Photuris Session Key Management Proto-\n   col; Working draft, January 1996.\n\
    \   [21] D. Maughan, M. Schertler. Internet Security Association and Key\n   Management\
    \ Protocol; Working draft, November 1995.\n"
