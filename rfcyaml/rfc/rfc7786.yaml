- title: __initial_text__
  contents:
  - '           TCP Modifications for Congestion Exposure (ConEx)

    '
- title: Abstract
  contents:
  - "Abstract\n   Congestion Exposure (ConEx) is a mechanism by which senders inform\n\
    \   the network about expected congestion based on congestion feedback\n   from\
    \ previous packets in the same flow.  This document describes the\n   necessary\
    \ modifications to use ConEx with the Transmission Control\n   Protocol (TCP).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7786.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   4\n   2.  Sender-Side Modifications . . . . . . . . . . . . . . .\
    \ . . .   4\n   3.  Counting Congestion . . . . . . . . . . . . . . . . . . .\
    \ . .   5\n     3.1.  Loss Detection  . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n       3.1.1.  Without SACK Support  . . . . . . . . . . . . . . . .\
    \   7\n     3.2.  Explicit Congestion Notification (ECN)  . . . . . . . . .  \
    \ 8\n       3.2.1.  Accurate ECN Feedback . . . . . . . . . . . . . . . .  10\n\
    \       3.2.2.  Classic ECN Support . . . . . . . . . . . . . . . . .  10\n  \
    \ 4.  Setting the ConEx Flags . . . . . . . . . . . . . . . . . . .  11\n    \
    \ 4.1.  Setting the E or the L Flag . . . . . . . . . . . . . . .  11\n     4.2.\
    \  Setting the Credit Flag . . . . . . . . . . . . . . . . .  11\n   5.  Loss\
    \ of ConEx Information . . . . . . . . . . . . . . . . . .  14\n   6.  Timeliness\
    \ of the ConEx Signals . . . . . . . . . . . . . . .  14\n   7.  Open Areas for\
    \ Experimentation  . . . . . . . . . . . . . . .  15\n   8.  Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  17\n   9.  References  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  18\n     9.1.  Normative References  .\
    \ . . . . . . . . . . . . . . . . .  18\n     9.2.  Informative References  .\
    \ . . . . . . . . . . . . . . . .  19\n   Acknowledgements  . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  20\n   Authors' Addresses  . . . . . . . . .\
    \ . . . . . . . . . . . . . .  20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Congestion Exposure (ConEx) is a mechanism by which senders\
    \ inform\n   the network about expected congestion based on congestion feedback\n\
    \   from previous packets in the same flow.  ConEx concepts and use cases\n  \
    \ are further explained in [RFC6789].  The abstract ConEx mechanism is\n   explained\
    \ in [RFC7713].  This document describes the necessary\n   modifications to use\
    \ ConEx with the Transmission Control Protocol\n   (TCP).\n   The markings for\
    \ ConEx signaling are defined in the ConEx Destination\n   Option (CDO) for IPv6\
    \ [RFC7837].  Specifically, the use of four flags\n   is defined: X (ConEx-capable),\
    \ L (loss experienced), E (ECN\n   experienced), and C (credit).\n   ConEx signaling\
    \ is based on the use of either loss or Explicit\n   Congestion Notification (ECN)\
    \ marks [RFC3168] as congestion\n   indication.  The sender collects this congestion\
    \ information based on\n   existing TCP feedback mechanisms from the receiver\
    \ to the sender.  No\n   changes are needed at the receiver side to implement\
    \ ConEx signaling.\n   Therefore, no additional negotiation is needed to implement\
    \ and use\n   ConEx at the sender side.  This document specifies the sender's\n\
    \   actions that are needed to provide meaningful ConEx information to\n   the\
    \ network.\n   Section 2 provides an overview of the modifications needed for\
    \ TCP\n   senders to implement ConEx.  First, congestion information has to be\n\
    \   extracted from TCP's loss or ECN feedback as described in Section 3.\n   Section\
    \ 4 details how to set the CDO marking based on this congestion\n   information.\
    \  Section 5 discusses the loss of packets carrying ConEx\n   information.  Section\
    \ 6 discusses the timeliness of the ConEx\n   feedback signal, given that congestion\
    \ is a temporary state.\n   This document describes congestion accounting for\
    \ TCP with and\n   without the Selective Acknowledgement (SACK) extension [RFC2018]\
    \ (in\n   Section 3.1).  However, ConEx benefits from the more accurate\n   information\
    \ that SACK provides about the number of bytes dropped in\n   the network, and\
    \ it is therefore preferable to use the SACK extension\n   when using TCP with\
    \ ConEx.  The detailed mechanism to set the L flag\n   in response to the loss-based\
    \ congestion feedback signal is given in\n   Section 4.1.\n   While loss has to\
    \ be minimized, ECN can provide more fine-grained\n   feedback information.  ConEx-based\
    \ traffic measurement or management\n   mechanisms could benefit from this.  Unfortunately,\
    \ the current ECN\n   feedback mechanism does not reflect multiple congestion\
    \ markings if\n   they occur within the same Round-Trip Time (RTT).  A more accurate\n\
    \   feedback extension to ECN (AccECN) is proposed in a separate document\n  \
    \ [ACCURATE], as this is also useful for other mechanisms.\n   Congestion accounting\
    \ for both classic ECN feedback and AccECN\n   feedback is explained in detail\
    \ in Section 3.2.  Setting the E flag\n   in response to ECN-based congestion\
    \ feedback is again detailed in\n   Section 4.1.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Sender-Side Modifications
  contents:
  - "2.  Sender-Side Modifications\n   This section gives an overview of actions that\
    \ need to be taken by a\n   TCP sender modified to use ConEx signaling.\n   In\
    \ the TCP handshake, a ConEx sender MUST negotiate for SACK and ECN\n   preferably\
    \ with AccECN feedback.  Therefore, a ConEx sender MUST also\n   implement SACK\
    \ and ECN.  Depending on the capability of the receiver,\n   the following operation\
    \ modes exist:\n   o  SACK-accECN-ConEx (SACK and accurate ECN feedback)\n   o\
    \  SACK-ECN-ConEx (SACK and classic instead of accurate ECN)\n   o  accECN-ConEx\
    \ (no SACK but accurate ECN feedback)\n   o  ECN-ConEx (no SACK and no accurate\
    \ ECN feedback, but classic ECN)\n   o  SACK-ConEx (SACK but no ECN at all)\n\
    \   o  Basic-ConEx (neither SACK nor ECN)\n   A ConEx sender MUST expose all congestion\
    \ information to the network\n   according to the congestion information received\
    \ by ECN or based on\n   loss information provided by the TCP feedback loop. \
    \ A TCP sender\n   SHOULD count congestion byte-wise (rather than packet-wise;\
    \ see next\n   paragraph).  After any congestion notification, a sender MUST mark\n\
    \   subsequent packets with the appropriate ConEx flag in the IP header.\n   Furthermore,\
    \ a ConEx sender must send enough credit to cover all\n   experienced congestion\
    \ for the connection so far, as well as the risk\n   of congestion for the current\
    \ transmission (see Section 4.2).\n   With SACK the number of lost payload bytes\
    \ is known, but not the\n   number of packets carrying these bytes.  With classic\
    \ ECN only an\n   indication is given that a marking occurred, but not the exact\
    \ number\n   of payload bytes nor packets.  As network congestion is usually byte-\n\
    \   congestion [RFC7141], the byte-size of a packet marked with a CDO\n   flag\
    \ is defined to represent that number of bytes of congestion\n   signaling [RFC7837].\
    \  Therefore, the exact number of bytes should be\n   taken into account, if available,\
    \ to make the ConEx Signal as exact\n   as possible.\n   Detailed mechanisms for\
    \ congestion counting in each operation mode\n   are described in the next section.\n"
- title: 3.  Counting Congestion
  contents:
  - "3.  Counting Congestion\n   A ConEx TCP sender maintains two counters: one that\
    \ counts congestion\n   based on the information retrieved by loss detection,\
    \ and a second\n   that accounts for ECN-based congestion feedback.  These counters\
    \ hold\n   the number of outstanding bytes that should be ConEx-Marked with,\n\
    \   respectively, the E flag or the L flag in subsequent packets.\n   The outstanding\
    \ bytes for congestion indications based on loss are\n   maintained in the Loss\
    \ Exposure Gauge (LEG), as explained in\n   Section 3.1.\n   The outstanding bytes\
    \ counted based on ECN feedback information are\n   maintained in the Congestion\
    \ Exposure Gauge (CEG), as explained in\n   Section 3.2.\n   When the sender sends\
    \ a ConEx-capable packet with the E or L flag\n   set, it reduces the respective\
    \ counter by the byte-size of the\n   packet.  This is explained for both counters\
    \ in Section 4.1.\n   Note that all bytes of an IP packet must be counted in the\
    \ LEG or CEG\n   to capture the right number of bytes that should be marked.\n\
    \   Therefore, the sender SHOULD take the payload and headers into\n   account,\
    \ up to and including the IP header.  However, in TCP the\n   information regarding\
    \ how large the headers of a lost or marked\n   packet were is usually not available,\
    \ as only payload data will be\n   acknowledged.\n   If equal-sized packets, or\
    \ at least equally distributed packet sizes,\n   can be assumed, the sender MAY\
    \ only add and subtract TCP payload\n   bytes.  In this case, there should be\
    \ about the same number of ConEx-\n   Marked packets as the original packets that\
    \ were causing the\n   congestion.  Thus, both contain about the same number of\
    \ header bytes\n   so they will cancel out.  This case is assumed for simplicity\
    \ in the\n   following sections.\n   Otherwise, if a sender sends different sized\
    \ packets (with unequally\n   distributed packet sizes), the sender needs to memorize\
    \ or estimate\n   the number of lost or ECN-marked packets.  If the sender has\n\
    \   sufficient memory available, the most accurate way to reconstruct the\n  \
    \ number of lost or marked packets is to remember the sequence number\n   of all\
    \ sent but not acknowledged packets.  In this case, a sender is\n   able to reconstruct\
    \ the number of packets, and thus the header bytes\n   that were sent during the\
    \ last RTT.  Otherwise (e.g., if not enough\n   memory is available), the sender\
    \ would need to estimate the packet\n   size.  The average packet size can be\
    \ estimated if the distribution\n   pattern of packet sizes in the last RTT is\
    \ known; alternatively, the\n   minimum packet size seen in the last RTT can be\
    \ used as the most\n   conservative estimate.\n   If the number of newly sent-out\
    \ packets with the ConEx L or E flag\n   set is smaller (or larger) than this\
    \ estimated number of lost/ECN-\n   marked packets, the additional header bytes\
    \ should be added to (or\n   can be subtracted from) the respective gauge.\n"
- title: 3.1.  Loss Detection
  contents:
  - "3.1.  Loss Detection\n   This section applies whether or not SACK support is\
    \ available.  The\n   following subsection (Section 3.1.1) handles the case when\
    \ SACK is\n   not available.\n   A TCP sender detects losses and subsequently\
    \ retransmits the lost\n   data.  Therefore, the ConEx sender can simply set the\
    \ ConEx L flag on\n   all retransmissions in order to at least cover the amount\
    \ of bytes\n   lost.  If this approach is taken, no LEG is needed.\n   However,\
    \ any retransmission may be spurious.  In this case, more\n   bytes have been\
    \ marked than necessary.  To compensate for this\n   effect, a ConEx sender can\
    \ maintain a local signed counter (the LEG)\n   that indicates the number of outstanding\
    \ bytes to be sent with the\n   ConEx L flag and also can become negative.\n \
    \  Using the LEG, when a TCP sender decides that a data segment needs to\n   be\
    \ retransmitted, it will increase the LEG by the size of the TCP\n   payload bytes\
    \ in the retransmission (assuming equal sized segments\n   such that the retransmitted\
    \ packet will have the same number of\n   header bytes as the original ones):\n\
    \   For each retransmission:\n   LEG += payload\n   Note how the LEG is reduced\
    \ when the ConEx L marking is set as\n   described in Section 4.\n   Further,\
    \ to accommodate spurious retransmissions, a ConEx sender\n   SHOULD make use\
    \ of heuristics to detect such spurious retransmissions\n   (e.g., F-RTO [RFC5682],\
    \ DSACK [RFC3708], and Eifel [RFC3522],\n   [RFC4015]), if already available in\
    \ a given implementation.  If no\n   mechanism for detecting spurious retransmissions\
    \ is available, the\n   ConEx sender MAY chose to implement one of the mechanisms\
    \ stated\n   above.  However, given the inaccuracy that ConEx may have anyway\
    \ and\n   the timeliness of ConEx information, a ConEx MAY also chose not to\n\
    \   compensate for spurious retransmission.  In this case, if spurious\n   retransmissions\
    \ occur, the ConEx sender has simply sent too many\n   ConEx Signals which, e.g.,\
    \ would decrease the congestion allowance in\n   a ConEx policer unnecessarily.\n\
    \   If a heuristic method is used to detect spurious retransmission and\n   has\
    \ determined that a certain number of packets were retransmitted\n   erroneously,\
    \ the ConEx sender subtracts the payload size of these TCP\n   packets from LEG.\n\
    \   If a spurious retransmission is detected:\n   LEG -= payload\n   Note that\
    \ LEG can become negative if too many L markings have already\n   been sent. \
    \ This case is further discussed in Section 6.\n"
- title: 3.1.1.  Without SACK Support
  contents:
  - "3.1.1.  Without SACK Support\n   If multiple losses occur within one RTT and\
    \ SACK is not used, it may\n   take several RTTs until all lost data is retransmitted.\
    \  With the\n   scheme described above, the ConEx information will be delayed\n\
    \   considerably, but timeliness is important for ConEx.  For ConEx, it\n   is\
    \ important to know how much data was lost; it is not important to\n   know what\
    \ data is lost.  During the first RTT after the initial loss\n   detection, the\
    \ amount of received data, and thus also the amount of\n   lost data, can be estimated\
    \ based on the number of received ACKs.\n   Therefore, a ConEx sender can use\
    \ the following algorithm to\n   estimated the number of lost bytes with an additional\
    \ delay of one\n   RTT using an additional Loss Estimation Counter (LEC):\n  \
    \    flight_bytes:      current flight size in bytes\n      retransmit_bytes:\
    \  payload size of the retransmission\n      At the first retransmission in a\
    \ congestion event, LEC is set:\n         LEC = flight_bytes - 3*SMSS\n      \
    \   (At this point in the transmission, in the worst case,\n         all packets\
    \ in flight minus three that triggered the dupACks\n         could have been lost.)\n\
    \      Then, during the first RTT of the congestion event:\n         For each\
    \ retransmission:\n            LEG += retransmit_bytes\n            LEC -= retransmit_bytes\n\
    \         For each ACK:\n            LEC -= SMSS\n      After one RTT:\n     \
    \    LEG += LEC\n         (The LEC now estimates the number of outstanding bytes\n\
    \         that should be ConEx L-marked.)\n      After the first RTT for each\
    \ following retransmissions:\n         if (LEC > 0): LEC -= retransmit_bytes\n\
    \         else if (LEC==0): LEG += retransmit_bytes\n         if (LEC < 0): LEG\
    \ += -LEC\n         (The LEG is not increased for those bytes that were\n    \
    \     already counted.)\n"
- title: 3.2.  Explicit Congestion Notification (ECN)
  contents:
  - "3.2.  Explicit Congestion Notification (ECN)\n   ECN [RFC3168] is an IP/TCP mechanism\
    \ that allows network nodes to\n   mark packets with the Congestion Experienced\
    \ (CE) mark instead of\n   dropping them when congestion occurs.\n   A receiver\
    \ might support classic ECN, the more accurate ECN feedback\n   scheme (AccECN),\
    \ or neither.  In the case that ECN is not supported\n   for a connection, of\
    \ course no ECN marks will occur; thus, the sender\n   will never set the E flag.\
    \  Otherwise, a ConEx sender needs to\n   maintain a signed counter, the Congestion\
    \ Exposure Gauge (CEG), for\n   the number of outstanding bytes that have to be\
    \ ConEx-Marked with the\n   E flag.\n   The CEG is increased when ECN information\
    \ is received from an ECN-\n   capable receiver supporting the classic ECN scheme\
    \ or the accurate\n   ECN feedback scheme.  When the ConEx sender receives an\
    \ ACK\n   indicating one or more segments were received with a CE mark, CEG is\n\
    \   increased by the appropriate number of bytes as described further\n   below.\n\
    \   Unfortunately, in case of duplicate acknowledgements, the number of\n   newly\
    \ acknowledged bytes will be zero even though (CE-marked) data\n   has been received.\
    \  Therefore, we increase the CEG by DeliveredData,\n   as defined below:\n  \
    \ DeliveredData = acked_bytes + SACK_diff + (is_dup)*1SMSS -\n   (is_after_dup)*num_dup*1SMSS\n\
    \   DeliveredData covers the number of bytes that has been newly\n   delivered\
    \ to the receiver.  Therefore, on each arrival of an ACK,\n   DeliveredData will\
    \ be increased by the newly acknowledged bytes\n   (acked_bytes) as indicated\
    \ by the current ACK, relative to all past\n   ACKs.  The formula depends on whether\
    \ SACK is available: if SACK is\n   not available, SACK_diff is always zero, whereas\
    \ if ACK information\n   is available, is_dup and is_after_dup are always zero.\n\
    \   With SACK, DeliveredData is increased by the number of bytes provided\n  \
    \ by (new) SACK information (SACK_diff).  Note that if less\n   unacknowledged\
    \ bytes are announced in the new SACK information than\n   in the previous ACK,\
    \ SACK_diff can be negative.  In this case, data\n   is newly acknowledged (in\
    \ acked_bytes) that was previously\n   accumulated into DeliveredData, based on\
    \ SACK information.\n   Otherwise without SACK, DeliveredData is increased by\
    \ 1 Sender\n   Maximum Segment Size (SMSS) on duplicate acknowledgements because\n\
    \   duplicate acknowledgements do not acknowledge any new data (and\n   acked_bytes\
    \ will be zero).  For the subsequent partial or full ACK,\n   acked_bytes cover\
    \ all newly acknowledged bytes including those\n   already accounted for with\
    \ the receipt of any duplicate\n   acknowledgement.  Therefore, DeliveredData\
    \ is reduced by one SMSS for\n   each preceding duplicate ACK.  Consequently,\
    \ is_dup is one if the\n   current ACK is a duplicated ACK without SACK, and zero\
    \ otherwise.\n   is_after_dup is only one for the next full or partial ACK after\
    \ a\n   number of duplicated ACKs without SACK and num_dup counts the number\n\
    \   of duplicated ACKs in a row (which usually is 3 or more).\n   With classic\
    \ ECN, one congestion-marked packet causes continuous\n   congestion feedback\
    \ for a whole round trip, thus hiding the arrival\n   of any further congestion-marked\
    \ packets during that round trip.  A\n   more accurate ECN feedback scheme (AccECN)\
    \ is needed to ensure that\n   feedback properly reflects the extent of congestion\
    \ marking.  The two\n   cases, with and without a receiver capable of AccECN,\
    \ are discussed\n   in the following sections.\n"
- title: 3.2.1.  Accurate ECN Feedback
  contents:
  - "3.2.1.  Accurate ECN Feedback\n   With a more accurate ECN feedback scheme (AccECN)\
    \ that is supported\n   by the receiver, either the number of marked packets or\
    \ the number of\n   marked bytes will be fed back from the receiver to the sender\
    \ and,\n   therefore is known at the sender side.  In the latter case, the CEG\n\
    \   can be increased directly by the number of marked bytes.  Otherwise\n   if\
    \ D is assumed to be the number of marks, the gauge (CEG) will be\n   conservatively\
    \ increased by one SMSS for each marking or, at the\n   maximum, the number of\
    \ newly acknowledged bytes:\n   CEG += min(SMSS*D, DeliveredData)\n"
- title: 3.2.2.  Classic ECN Support
  contents:
  - "3.2.2.  Classic ECN Support\n   With classic ECN, as soon as a CE mark is seen\
    \ at the receiver side,\n   it will feed this information back to the sender by\
    \ setting the Echo\n   Congestion Experienced (ECE) flag in the TCP header of\
    \ subsequent\n   ACKs.  Once the sender receives the first ECE of a congestion\n\
    \   notification, it sets the Congestion Window Reduced (CWR) flag in the\n  \
    \ TCP header once.  When this packet with the CWR flag in the TCP\n   header arrives\
    \ at the receiver side acknowledging its first ECE\n   feedback, the receiver\
    \ stops setting the ECE flag.\n   If the ConEx sender fully conforms to the semantics\
    \ of ECN signaling\n   as defined by [RFC3168], it will receive one full RTT of\
    \ ACKs with\n   the ECE flag set whenever at least one CE mark was received by\
    \ the\n   receiver.  As the sender cannot estimate how many packets have\n   actually\
    \ been CE-marked during this RTT, the most conservative\n   assumption MAY be\
    \ taken, namely assuming that all packets were\n   marked.  This can be achieved\
    \ by increasing the CEG by DeliveredData\n   for each ACK with the ECE flag:\n\
    \   CEG += DeliveredData\n   Optionally, a ConEx sender could implement the following\
    \ technique\n   (that does not conform to [RFC3168]), called \"advanced compatibility\n\
    \   mode\", to considerably improve its estimate of the number of ECN-\n   marked\
    \ packets:\n   To extract more than one ECE indication per RTT, a ConEx sender\
    \ could\n   set the CWR flag continuously to force the receiver to signal only\n\
    \   one ECE per CE mark.  Unfortunately, the use of delayed ACKs\n   [RFC5681]\
    \ (which is common) will prevent feedback of every CE mark;\n   if a CWR confirmation\
    \ is received before the ECE can be sent out on\n   the next ACK, ECN feedback\
    \ information could get lost (depending on\n   the actual receiver implementation).\
    \  Thus, a sender SHOULD set CWR\n   only on those data segments that will presumably\
    \ trigger a (delayed)\n   ACK.  The sender would need an additional control loop\
    \ to estimate\n   which data segments will trigger an ACK in order to extract\
    \ more\n   timely congestion notifications.  Still, the CEG SHOULD be increased\n\
    \   by DeliveredData, as one or more CE-marked packets could be\n   acknowledged\
    \ by one delayed ACK.\n"
- title: 4.  Setting the ConEx Flags
  contents:
  - "4.  Setting the ConEx Flags\n   By setting the X flag, a packet is marked as\
    \ ConEx-capable.  All\n   packets carrying payload MUST be marked with the X flag\
    \ set,\n   including retransmissions.  Only if no congestion feedback\n   information\
    \ is (currently) available, SHOULD the X flag be zero\n   (e.g., for control packets\
    \ on a connection that has not sent any user\n   data for some time and, therefore\
    \ is sending only pure ACKs that are\n   not carrying any payload).\n"
- title: 4.1.  Setting the E or the L Flag
  contents:
  - "4.1.  Setting the E or the L Flag\n   As described in Section 3.1, the sender\
    \ needs to maintain a CEG\n   counter and might also maintain a LEG counter. \
    \ If no LEG is used,\n   all retransmission will be marked with the L flag.\n\
    \   Further, as long as the LEG or CEG counter is positive, the sender\n   marks\
    \ each ConEx-capable packet with L or E respectively, and\n   decreases the LEG\
    \ or CEG counter by the TCP payload bytes carried in\n   the marked packet (assuming\
    \ headers are not being counted because\n   packet sizes are regular).  No matter\
    \ how small the value of LEG or\n   CEG, if the value is positive the sender MUST\
    \ NOT defer packet\n   marking; this ensures that ConEx Signals are timely.  Therefore,\
    \ the\n   value of LEG and CEG will commonly be negative.\n   If both the LEG\
    \ and CEG are positive, the sender MUST mark each\n   ConEx-capable packet with\
    \ both L and E.  If a credit signal is also\n   pending (see the next section),\
    \ the C flag can be set as well.\n"
- title: 4.2.  Setting the Credit Flag
  contents:
  - "4.2.  Setting the Credit Flag\n   The ConEx abstract mechanism [RFC7713] requires\
    \ that sufficient\n   credit MUST be signaled in advance to cover the expected\
    \ congestion\n   during the feedback delay of one RTT.\n   To monitor the credit\
    \ state at the audit, a ConEx sender needs to\n   maintain a Credit State Counter\
    \ (CSC) in bytes.  If congestion\n   occurs, credits will be consumed and the\
    \ CSC is reduced by the number\n   of bytes that were lost or estimated to be\
    \ ECN-marked.  If the risk\n   of congestion was estimated wrongly, and thus too\
    \ few credits were\n   sent, the CSC becomes zero but cannot go negative.\n  \
    \ To be sure that the credit state in the audit never reaches zero, the\n   number\
    \ of credits should always equal the number of bytes in flight\n   as all packets\
    \ could potentially get lost or congestion-marked.  In\n   this case, a ConEx\
    \ sender also monitors the number of bytes in flight\n   F.  If F ever becomes\
    \ larger than the CSC, the ConEx sender sets the\n   C flag on each ConEx-capable\
    \ packet and increases the CSC by the\n   payload size of each marked packet until\
    \ the CSC is no less than F\n   again.  However, a ConEx sender might also be\
    \ less conservative and\n   send fewer credits if it, e.g., assumes that the congestion\
    \ will be\n   low on a certain path based on previous experience.\n   Recall that\
    \ the CSC will be decreased whenever congestion occurs;\n   therefore the CSC\
    \ will need to be replenished as soon as the CSC\n   drops below F.  Also recall\
    \ that the sender can set the C flag on a\n   ConEx-capable packet whether or\
    \ not the E or L flags are also set.\n   In TCP Slow Start, the congestion window\
    \ might grow much larger than\n   during the rest of the transmission.  Likely,\
    \ a sender could consider\n   sending fewer than F credits but risking being penalized\
    \ by an audit\n   function.  However, the credits should at least cover the increase\
    \ in\n   sending rate.  Given the exponential increase as implemented in the\n\
    \   TCP Slow Start algorithm, which means that the sending rate doubles\n   every\
    \ RTT, a ConEx sender should at least cover half the number of\n   packets in\
    \ flight by credits.\n   Note that the number of losses or markings within one\
    \ RTT does not\n   depend solely on the sender's actions.  In general, the behavior\
    \ of\n   the cross traffic, whether Active Queue Management (AQM) is used and\n\
    \   how it is parameterized influence how many packets might be dropped\n   or\
    \ marked.  As long as any AQM encountered is not overly aggressive\n   with ECN\
    \ marking, sending half the flight size as credits should be\n   sufficient whether\
    \ congestion is signaled by loss or ECN.\n   To maintain half of the packets in\
    \ flight as credits, half of the\n   packet of the initial window must also be\
    \ C-marked.  In Slow Start\n   marking, every fourth packet introduces the correct\
    \ amount of credit\n   as can be seen in Figure 1.\n                         \
    \               in_flight  credits\n                RTT1  |------XC------>|  \
    \   1         1\n                      |------X------->|     2         1\n   \
    \                   |------XC------>|     3         2\n                      |\
    \               |\n                RTT2  |------X------->|     3         2\n \
    \                     |------X------->|     4         2\n                    \
    \  |------X------->|     4         2\n                      |------XC------>|\
    \     5         3\n                      |------X------->|     5         3\n \
    \                     |------X------->|     6         3\n                    \
    \  |               |\n                RTT3  |------X------->|     6         3\n\
    \                      |------XC------>|     7         4\n                   \
    \   |------X------->|     7         4\n                      |------X------->|\
    \     8         4\n                      |------X------->|     8         4\n \
    \                     |------XC------>|     9         5\n                    \
    \  |------X------->|     9         5\n                      |------X------->|\
    \    10         5\n                      |------X------->|    10         5\n \
    \                     |------XC------>|    11         6\n                    \
    \  |------X------->|    11         6\n                      |------X------->|\
    \    12         6\n                      |      .        |\n                 \
    \     |      :        |\n       Figure 1: Credits in Slow Start (with an initial\
    \ window of 3)\n   It is possible that a TCP flow will encounter an audit function\n\
    \   without relevant flow state due to, e.g., rerouting or memory\n   limitations.\
    \  Therefore, the sender needs to detect this case and\n   resend credits.  A\
    \ ConEx sender might reset the credit counter CSC to\n   zero if losses occur\
    \ in subsequent RTTs (assuming that the sending\n   rate was correctly reduced\
    \ based on the received congestion signal\n   and using a conservatively large\
    \ RTT estimation).\n   This section proposes a concrete algorithm for determining\
    \ how much\n   credit to signal (with a separate approach used for Slow Start).\n\
    \   However, experimentation in credit setting algorithms is expected and\n  \
    \ encouraged.  The wider goal of ConEx is to reflect the \"cost\" of the\n   risk\
    \ of causing congestion on those that contribute most to it.\n   Thus, experimentation\
    \ is encouraged to improve or maintain\n   performance while reducing the risk\
    \ of causing congestion and,\n   therefore potentially reducing the need to signal\
    \ so much credit.\n"
- title: 5.  Loss of ConEx Information
  contents:
  - "5.  Loss of ConEx Information\n   Packets carrying ConEx Signals could be discarded\
    \ themselves.  This\n   will be a second order problem (e.g., if the loss probability\
    \ is\n   0.1%, the probability of losing a ConEx L signal will be 0.1% of 0.1%\n\
    \   = 0.01%).  Further, the penalty an audit induces should be\n   proportional\
    \ to the mismatch of expected ConEx marks and observed\n   congestion, therefore\
    \ the audit might only slightly increase the loss\n   level of this flow.  Therefore,\
    \ an implementer MAY choose to ignore\n   this problem, accepting instead the\
    \ risk that an audit function might\n   wrongly penalize a flow.\n   Nonetheless,\
    \ a ConEx sender is responsible for always signaling\n   sufficient congestion\
    \ feedback, and therefore SHOULD remember which\n   packet was marked with either\
    \ the L, the E, or the C flag.  If one of\n   these packets is detected as lost,\
    \ the sender SHOULD increase the\n   respective gauge(s), LEG or CEG, by the number\
    \ of lost payload bytes\n   in addition to increasing LEG for the loss.\n"
- title: 6.  Timeliness of the ConEx Signals
  contents:
  - "6.  Timeliness of the ConEx Signals\n   ConEx Signals will only be useful to\
    \ a network node within a time\n   delay of about one RTT after the congestion\
    \ occurred.  To avoid\n   further delays, a ConEx sender SHOULD send the ConEx\
    \ signaling on the\n   next available packet.\n   Any or all of the ConEx flags\
    \ can be used in the same packet, which\n   allows delays to be minimized when\
    \ multiple signals are pending.  The\n   need to set multiple ConEx flags at the\
    \ same time can occur if, e.g,\n   an ACK is received by the sender that simultaneously\
    \ indicates that\n   at least one ECN mark was received, and that one or more\
    \ segments\n   were lost.  This may happen during excessive congestion, if the\n\
    \   queues overflow even though ECN was used and currently all forwarded\n   packets\
    \ are marked, while others have to be dropped.  Another case\n   when this might\
    \ happen is when ACKs are lost, so that a subsequent\n   ACK carries summary information\
    \ not previously available to the\n   sender.\n   If a flow becomes application-limited,\
    \ there could be insufficient\n   bytes to send to reduce the gauges to zero or\
    \ below.  In such cases,\n   the sender cannot help but delay ConEx Signals. \
    \ Nonetheless, as long\n   as the sender is marking all outgoing packets, an audit\
    \ function is\n   unlikely to penalize ConEx-Marked packets.  Therefore, no matter\
    \ how\n   long a gauge has been positive, a sender MUST NOT reduce the gauge by\n\
    \   more than the ConEx-Marked bytes it has sent.\n   If the CEG or LEG counter\
    \ is negative, the respective counter MAY be\n   reset to zero within one RTT\
    \ after it was decreased the last time, or\n   one RTT after recovery if no further\
    \ congestion occurred.\n"
- title: 7.  Open Areas for Experimentation
  contents:
  - "7.  Open Areas for Experimentation\n   All proposed mechanisms in this document\
    \ are experimental, and\n   therefore further large-scale experimentation on the\
    \ Internet is\n   required to evaluate if the signaling provided by these mechanisms\
    \ is\n   accurate and timely enough to produce value for ConEx-based (traffic\n\
    \   management or other) mechanisms.\n   The current ConEx specifications assume\
    \ that congestion is counted in\n   the number of bytes (including the IP header\
    \ that directly\n   encapsulates the CDO and everything that the IP header encapsulates)\n\
    \   [RFC7837].  This decision was taken because most network devices\n   today\
    \ experience byte-congestion where the memory is filled exactly\n   with the number\
    \ of bytes a packet carries [RFC7141].  However, there\n   are also devices that\
    \ may allocate a certain amount of memory per\n   packet, no matter how large\
    \ a packet is.  These devices get congested\n   based on the number of packets\
    \ in their memory and therefore, in this\n   case, congestion is determined by\
    \ the number of packets that have\n   been lost or marked.  Furthermore, a transport-layer\
    \ endpoint such as\n   a TCP sender or receiver, might not know the exact number\
    \ of bytes\n   that a lower layer was carrying.  Therefore, a TCP endpoint may\
    \ only\n   be able to estimate the exact number of congested bytes (assuming\n\
    \   that all lower-layer headers have the same length).  If this\n   estimation\
    \ is sufficient to work with, the ConEx Signal needs to be\n   further evaluated\
    \ in tests on the Internet together with different\n   auditor implementations.\n\
    \   Further, the proposed marking schemes in this document are designed\n   under\
    \ the assumption that all TCP packets of a ConEx-capable flow are\n   of equal\
    \ size or that flows have a constant mean packet size over a\n   rather small\
    \ time frame, like one RTT or less.  In most\n   implementations, this assumption\
    \ might be taken as well and is\n   probably true for most of the traffic flows.\
    \  If this proposed scheme\n   is used, it is necessary to evaluate how much accuracy\
    \ degrades if\n   this precondition is not met.  Evaluating with real traffic\
    \ from\n   different applications is especially important in making the decision\n\
    \   regarding whether the proposed schemes are sufficient or whether a\n   more\
    \ complex scheme is needed.\n   In this context, the proposed scheme to set credit\
    \ markings in Slow\n   Start runs the risk of providing an insufficient number\
    \ of markings,\n   which can cause an audit function to penalize this flow.  Both\
    \ the\n   proposed credit scheme for Slow Start as well as the scheme in\n   Congestion\
    \ Avoidance must be evaluated together with one or more\n   specific implementations\
    \ of a ConEx auditor to ensure that both\n   algorithms, in the sender and in\
    \ the auditor, work properly together\n   with a low risk of false positives (which\
    \ would lead to penalization\n   of an honest sender).  However, if a sender is\
    \ wrongly assumed to\n   cheat, the penalization of the audit should be adequate\
    \ and should\n   allow an honest sender using a congestion control scheme that\
    \ is\n   commonly used today to recover quickly.\n   Another open issue is the\
    \ accuracy of the ECN feedback signal.  At\n   the time of this document's publication,\
    \ there is no AccECN mechanism\n   specified yet, and further AccECN will also\
    \ take some time to be\n   widely deployed.  This document proposes an advanced\
    \ compatibility\n   mode for classic ECN.  The proposed mechanism can provide\
    \ more\n   accurate feedback by utilizing the way classic ECN is specified but\n\
    \   has a higher risk of losing information.  To figure out how high this\n  \
    \ risk is in a real deployment scenario, further experimental\n   evaluation is\
    \ needed.  The following argument is intended to prove\n   that suppressing repetitions\
    \ of ECE, however, is still safe against\n   possible congestion collapse due\
    \ to lost congestion feedback and\n   should be further proven in experimentation:\n\
    \   Repetition of ECE in classic ECN is intended to ensure reliable\n   delivery\
    \ of congestion feedback.  However, with advanced\n   compatibility mode, it is\
    \ possible to miss congestion notifications.\n   This can happen in some implementations\
    \ if delayed acknowledgements\n   are used.  Further, an ACK containing ECE can\
    \ simply get lost.  If\n   only a few CE marks are received within one congestion\
    \ event (e.g.,\n   only one), the loss of one acknowledgement due to (heavy) congestion\n\
    \   on the reverse path can prevent that any congestion notification is\n   received\
    \ by the sender.\n   However, if loss of feedback exacerbates congestion on the\
    \ forward\n   path, more forward packets will be CE-marked, increasing the\n \
    \  likelihood that feedback from at least one CE will get through per\n   RTT.\
    \  As long as one ECE reaches the sender per RTT, the sender's\n   congestion\
    \ response will be the same as if CWR were not continuous.\n   The only way that\
    \ heavy congestion on the forward path could be\n   completely hidden would be\
    \ if all ACKs on the reverse path were lost.\n   If total ACK loss persisted,\
    \ the sender would time out and do a\n   congestion response anyway.  Therefore,\
    \ the problem seems confined to\n   potential suppression of a congestion response\
    \ during light\n   congestion.\n   Furthermore, even if loss of all ECN feedback\
    \ leads to no congestion\n   response, the worst that could happen would be loss\
    \ instead of ECN-\n   signaled congestion on the forward path.  Given that compatibility\n\
    \   mode does not affect loss feedback, there would be no risk of\n   congestion\
    \ collapse.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   General ConEx security considerations are covered\
    \ extensively in the\n   ConEx abstract mechanism [RFC7713].  This section covers\
    \ TCP-specific\n   concerns that may occur with the addition of ConEx to TCP (while\
    \ not\n   discussing generally well-known attacks against TCP).  It is assumed\n\
    \   that any altering of ConEx information can be detected by protection\n   mechanisms\
    \ in the IP layer and is, therefore, not discussed here but\n   in [RFC7837].\
    \  Further, [RFC7837] describes how to use ConEx to\n   mitigate flooding attacks\
    \ by using preferential drop where the use of\n   ConEx can even increase security.\n\
    \   The ConEx modifications to TCP provide no mechanism for a receiver to\n  \
    \ force a sender not to use ConEx.  A receiver can degrade the accuracy\n   of\
    \ ConEx by claiming that it does not support SACK, AccECN, or ECN,\n   but the\
    \ sender will never have to turn ConEx off.  Further, the\n   receiver cannot\
    \ force the sender to have to mark ConEx more\n   conservatively, in order to\
    \ cover the risk of any inaccuracy.\n   Instead, it is always the sender's choice\
    \ to either mark very\n   conservatively, which ensures that the audit always\
    \ sees enough\n   markings to not penalize the flow, or estimate the needed number\
    \ of\n   markings more tightly.  This second case can lead to inaccurate\n   marking,\
    \ and therefore increases the likelihood of loss at an audit\n   function that\
    \ will only harm the receiver itself.\n   Assuming the sender is limited in some\
    \ way by a congestion allowance\n   or quota, a receiver could spoof more loss\
    \ or ECN congestion feedback\n   than it actually experiences, in an attempt to\
    \ make the sender draw\n   down its allowance faster than necessary.  However,\
    \ over-declaring\n   congestion simply makes the sender slow down.  If the receiver\
    \ is\n   interested in the content, it will not want to harm its own\n   performance.\n\
    \   However, if the receiver is solely interested in making the sender\n   draw\
    \ down its allowance, the net effect will depend on the sender's\n   congestion\
    \ control algorithm as permanently adding more and more\n   additional congestion\
    \ would cause the sender to more and more reduce\n   its sending rate.  Therefore,\
    \ a receiver can only maintain a certain\n   congestion level that is corresponding\
    \ to a certain sending rate.\n   With NewReno [RFC6582], doubling congestion feedback\
    \ causes the\n   sender to reduce its sending rate such that it would only consume\n\
    \   sqrt(2) = 1.4 times more congestion allowance.  However, to improve\n   scaling,\
    \ congestion control algorithms are tending towards less\n   responsive algorithms\
    \ like Cubic or Compound TCP, and ultimately to\n   linear algorithms like Data\
    \ Center TCP (DCTCP) [DCTCP] that aim to\n   maintain the same congestion level\
    \ independent of the current sending\n   rate and always reduce its sending window\
    \ if the signaled congestion\n   feedback is higher.  In each case, if the receiver\
    \ doubles congestion\n   feedback, it causes the sender to respectively consume\
    \ more allowance\n   by a factor of 1.2, 1.15, or 1, where 1 implies the attack\
    \ has become\n   completely ineffective as no further congestion allowance is\
    \ consumed\n   but the flow will decrease its sending rate to a minimum instead.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S.,\
    \ and A. Romanow, \"TCP\n              Selective Acknowledgment Options\", RFC\
    \ 2018,\n              DOI 10.17487/RFC2018, October 1996,\n              <http://www.rfc-editor.org/info/rfc2018>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3168]\
    \  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n              of\
    \ Explicit Congestion Notification (ECN) to IP\",\n              RFC 3168, DOI\
    \ 10.17487/RFC3168, September 2001,\n              <http://www.rfc-editor.org/info/rfc3168>.\n\
    \   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n    \
    \          Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009,\n      \
    \        <http://www.rfc-editor.org/info/rfc5681>.\n   [RFC7713]  Mathis, M. and\
    \ B. Briscoe, \"Congestion Exposure (ConEx)\n              Concepts, Abstract\
    \ Mechanism, and Requirements\", RFC 7713,\n              DOI 10.17487/RFC7713,\
    \ December 2015,\n              <http://www.rfc-editor.org/info/rfc7713>.\n  \
    \ [RFC7837]  Krishnan, S., Kuehlewind, M., Briscoe, B., and C. Ralli,\n      \
    \        \"IPv6 Destination Option for Congestion Exposure (ConEx)\",\n      \
    \        RFC 7837, DOI 10.17487/RFC7837, May 2016,\n              <http://www.rfc-editor.org/info/rfc7837>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [ACCURATE] Briscoe, B., Kuehlewind, M., and\
    \ R. Scheffenegger, \"More\n              Accurate ECN Feedback in TCP\", Work\
    \ in Progress,\n              draft-ietf-tcpm-accurate-ecn-00, December 2015.\n\
    \   [DCTCP]    Alizadeh, M., Greenberg, A., Maltz, D., Padhye, J., Patel,\n  \
    \            P., Prabhakar, B., Sengupta, S., and M. Sridharan, \"Data\n     \
    \         Center TCP (DCTCP)\", ACM SIGCOMM Computer Communication\n         \
    \     Review, Volume 40, Issue 4, pages 63-74,\n              DOI 10.1145/1851182.1851192,\
    \ October 2010,\n              <http://portal.acm.org/citation.cfm?id=1851192>.\n\
    \   [ECNTCP]   Briscoe, B., Jacquet, A., Moncaster, T., and A. Smith,\n      \
    \        \"Re-ECN: Adding Accountability for Causing Congestion to\n         \
    \     TCP/IP\", Work in Progress, draft-briscoe-conex-re-ecn-\n              tcp-04,\
    \ July 2014.\n   [RFC3522]  Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm\n\
    \              for TCP\", RFC 3522, DOI 10.17487/RFC3522, April 2003,\n      \
    \        <http://www.rfc-editor.org/info/rfc3522>.\n   [RFC3708]  Blanton, E.\
    \ and M. Allman, \"Using TCP Duplicate Selective\n              Acknowledgement\
    \ (DSACKs) and Stream Control Transmission\n              Protocol (SCTP) Duplicate\
    \ Transmission Sequence Numbers\n              (TSNs) to Detect Spurious Retransmissions\"\
    , RFC 3708,\n              DOI 10.17487/RFC3708, February 2004,\n            \
    \  <http://www.rfc-editor.org/info/rfc3708>.\n   [RFC4015]  Ludwig, R. and A.\
    \ Gurtov, \"The Eifel Response Algorithm\n              for TCP\", RFC 4015, DOI\
    \ 10.17487/RFC4015, February 2005,\n              <http://www.rfc-editor.org/info/rfc4015>.\n\
    \   [RFC5682]  Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata,\n         \
    \     \"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting\n           \
    \   Spurious Retransmission Timeouts with TCP\", RFC 5682,\n              DOI\
    \ 10.17487/RFC5682, September 2009,\n              <http://www.rfc-editor.org/info/rfc5682>.\n\
    \   [RFC6582]  Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, \"The\n \
    \             NewReno Modification to TCP's Fast Recovery Algorithm\",\n     \
    \         RFC 6582, DOI 10.17487/RFC6582, April 2012,\n              <http://www.rfc-editor.org/info/rfc6582>.\n\
    \   [RFC6789]  Briscoe, B., Ed., Woundy, R., Ed., and A. Cooper, Ed.,\n      \
    \        \"Congestion Exposure (ConEx) Concepts and Use Cases\",\n           \
    \   RFC 6789, DOI 10.17487/RFC6789, December 2012,\n              <http://www.rfc-editor.org/info/rfc6789>.\n\
    \   [RFC7141]  Briscoe, B. and J. Manner, \"Byte and Packet Congestion\n     \
    \         Notification\", BCP 41, RFC 7141, DOI 10.17487/RFC7141,\n          \
    \    February 2014, <http://www.rfc-editor.org/info/rfc7141>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Bob Briscoe who contributed\
    \ with\n   these initial ideas [ECNTCP] and valuable feedback.  Moreover, thanks\n\
    \   to Jana Iyengar who also provided valuable feedback.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mirja Kuehlewind (editor)\n   ETH Zurich\n   Switzerland\n\
    \   Email: mirja.kuehlewind@tik.ee.ethz.ch\n   Richard Scheffenegger\n   NetApp,\
    \ Inc.\n   Am Euro Platz 2\n   Vienna  1120\n   Austria\n   Email: rs.ietf@gmx.at\n"
