- contents:
  - '     A Session Initiation Protocol (SIP) Load-Control Event Package

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This specification defines a load-control event package for the\n
    \  Session Initiation Protocol (SIP).  It allows SIP entities to\n   distribute
    load-filtering policies to other SIP entities in the\n   network.  The load-filtering
    policies contain rules to throttle calls\n   from a specific user or based on
    their source or destination domain,\n   telephone number prefix.  The mechanism
    helps to prevent signaling\n   overload and complements feedback-based SIP overload
    control efforts.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7200.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions .....................................................3\n   3.
    SIP Load-Filtering Overview .....................................4\n      3.1.
    Load-Filtering Policy Format ...............................4\n      3.2. Load-Filtering
    Policy Computation ..........................4\n      3.3. Load-Filtering Policy
    Distribution .........................4\n      3.4. Applicable Network Domains
    .................................8\n   4. Load-Control Event Package ......................................9\n
    \     4.1. Event Package Name .........................................9\n      4.2.
    Event Package Parameters ...................................9\n      4.3. SUBSCRIBE
    Bodies ...........................................9\n      4.4. SUBSCRIBE Duration
    .........................................9\n      4.5. NOTIFY Bodies .............................................10\n
    \     4.6. Notifier Processing of SUBSCRIBE Requests .................10\n      4.7.
    Notifier Generation of NOTIFY Requests ....................10\n      4.8. Subscriber
    Processing of NOTIFY Requests ..................10\n      4.9. Handling of Forked
    Requests ...............................12\n      4.10. Rate of Notifications
    ....................................12\n      4.11. State Delta ..............................................12\n
    \  5. Load-Control Document ..........................................13\n      5.1.
    Format ....................................................13\n      5.2. Namespace
    .................................................13\n      5.3. Conditions ................................................14\n
    \          5.3.1. Call Identity ......................................14\n           5.3.2.
    Method .............................................16\n           5.3.3. Target
    SIP Entity ..................................17\n           5.3.4. Validity ...........................................18\n
    \     5.4. Actions ...................................................18\n   6.
    XML Schema Definition for Load Control .........................20\n   7. Security
    Considerations ........................................23\n   8. IANA Considerations
    ............................................24\n      8.1. Load-Control Event
    Package Registration ...................24\n      8.2. application/load-control+xml
    Media Type Registration ......24\n      8.3. URN Sub-Namespace Registration ............................25\n
    \     8.4. Load-Control Schema Registration ..........................26\n   9.
    Acknowledgements ...............................................27\n   10. References
    ....................................................27\n      10.1. Normative
    References .....................................27\n      10.2. Informative References
    ...................................28\n   Appendix A. Definitions ...........................................30\n
    \  Appendix B. Design Requirements ...................................30\n   Appendix
    C. Discussion of How This Specification Meets the\n               Requirements
    of RFC 5390 ..............................31\n   Appendix D. Complete Examples
    .....................................36\n      D.1. Load-Control Document Examples
    ............................36\n      D.2. Message Flow Examples .....................................40\n
    \  Appendix E.  Related Work .........................................41\n      E.1.
    Relationship to Load Filtering in PSTN ....................41\n      E.2. Relationship
    with Other IETF SIP Overload Control Efforts .42\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   SIP load-control mechanisms are needed to prevent congestion
    collapse\n   [RFC6357] in cases of SIP server overload [RFC5390].  There are two\n
    \  types of load-control approaches.  In the first approach, feedback\n   control,
    SIP servers provide load limits to upstream servers, to\n   reduce the incoming
    rate of all SIP requests [SIP-OVERLOAD].  These\n   upstream servers then drop
    or delay incoming SIP requests.  Feedback\n   control is reactive and affects
    signaling messages that have already\n   been issued by user agent clients.  This
    approach works well when SIP\n   proxy servers in the core networks (core proxy
    servers) or\n   destination-specific SIP proxy servers in the edge networks (edge\n
    \  proxy servers) are overloaded.  By their nature, they need to\n   distribute
    rate, drop, or window information to all upstream SIP\n   proxy servers and normally
    affect all calls equally, regardless of\n   destination.\n   This specification
    proposes an additional, complementary load-control\n   mechanism, called \"load
    filtering\".  It is most applicable for\n   situations where a traffic surge and
    its source/destination\n   distribution can be predicted in advance.  In those
    cases, network\n   operators create load-filtering policies that indicate calls
    to\n   specific destinations or from specific sources should be rate-limited\n
    \  or randomly dropped.  These load-filtering policies are then\n   distributed
    to SIP servers and possibly SIP user agents that are\n   likely to generate calls
    to the affected destinations or from the\n   affected sources.  Load filtering
    works best if it prevents calls as\n   close to the originating user agent clients
    as possible.  The\n   applicability of SIP load filtering can also be extended
    beyond\n   overload control, e.g., to implement service level agreement\n   commitments.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n"
  title: 2.  Conventions
- contents:
  - '3.  SIP Load-Filtering Overview

    '
  - contents:
    - "3.1.  Load-Filtering Policy Format\n   Load-filtering policies are specified
      by sets of rules.  Each rule\n   contains both load-filtering conditions and
      actions.  The load-\n   filtering conditions define identities of the targets
      to be filtered\n   (Section 5.3.1).  For example, there are two typical resource
      limits\n   in a possible overload situation, i.e., human destination limits\n
      \  (number of call takers) and node capacity limits.  The load-filtering\n   targets
      in these two cases can be the specific callee numbers or the\n   destination
      domain corresponding to the overload.  Load-filtering\n   conditions also indicate
      the specific message type to be matched\n   (Section 5.3.2), with which target
      SIP entity the filtering policy is\n   associated (Section 5.3.3), and the period
      of time when the filtering\n   policy should be activated and deactivated (Section
      5.3.4).  Load-\n   filtering actions describe the desired control functions
      such as\n   keeping the request rate below a specified level (Section 5.4).\n"
    title: 3.1.  Load-Filtering Policy Format
  - contents:
    - "3.2.  Load-Filtering Policy Computation\n   When computing the load-filtering
      policies, one needs to take into\n   consideration information such as overload
      time, scope and network\n   topology, as well as service policies.  It is also
      important to make\n   sure that there is no resource allocation loop and that
      server\n   capacity is allocated in a way that both prevents overload and\n
      \  maximizes effective throughput (commonly called goodput).  In some\n   cases,
      in order to better utilize system resources, it may be\n   preferable to employ
      an algorithm that dynamically computes the load-\n   filtering policies based
      on currently observed server load status,\n   rather than using a purely static
      filtering policy assignment.  The\n   computation algorithm for load-filtering
      policies is beyond the scope\n   of this specification.\n"
    title: 3.2.  Load-Filtering Policy Computation
  - contents:
    - "3.3.  Load-Filtering Policy Distribution\n   For distributing load-filtering
      policies, this specification defines\n   the SIP event package for load control,
      which is an \"instantiation\"\n   of the generic SIP event notification framework
      [RFC6665].  This\n   specification also defines the XML schema of a load-control
      document\n   (Section 5), which is used to encode load-filtering policies.\n
      \  In order for load-filtering policies to be properly distributed, each\n   capable
      SIP entity in the network subscribes to the SIP load-control\n   event package
      of each SIP entity to which it sends signaling\n   requests.  A SIP entity that
      accepts subscription requests is called\n   a \"notifier\" (Section 4.6).  Subscription
      is initiated and maintained\n   during normal server operation.  The subscription
      of neighboring SIP\n   entities needs to be persistent, as described in Sections
      4.1 and 4.2\n   of [RFC6665].  The refresh procedure is described in Section
      4.7\n   below.  Subscribers may terminate the subscription if they have not\n
      \  received notifications for an extended time period, and can\n   resubscribe
      if they determine that signaling with the notifier\n   becomes active again.\n
      \  An example architecture is shown in Figure 1 to illustrate SIP load-\n   filtering
      policy distribution.  This scenario consists of two\n   networks belonging to
      Service Provider A and Service Provider B,\n   respectively.  Each provider's
      network is made up of two SIP core\n   proxy servers and four SIP edge proxy
      servers.  The core proxy\n   servers and edge proxy servers of Service Provider
      A are denoted as\n   CPa1 to CPa2 and EPa1 to EPa4; the core proxy servers and
      edge proxy\n   servers of Service Provider B are denoted as CPb1 to CPb2 and
      EPb1 to\n   EPb4.\n      +-----------+   +-----------+   +-----------+   +-----------+\n
      \     |           |   |           |   |           |   |           |\n      |
      \  EPa1    |   |   EPa2    |   |   EPa3    |   |   EPa4    |\n      |           |
      \  |           |   |           |   |           |\n      +-----------+   +-----------+
      \  +-----------+   +-----------+\n              \\         /                    \\
      \         /\n               \\       /                      \\        /\n                \\
      \    /                        \\      /\n              +-----------+                  +-----------+\n
      \             |           |                  |           |\n              |
      \  CPa1    |------------------|   CPa2    |\n              |           |                  |
      \          |\n              +-----------+                  +-----------+\n                    |
      \                             |\n      Service       |                              |\n
      \     Provider A    |                              |\n                    |
      \                             |\n     =================================================================\n
      \                   |                              |\n      Service       |
      \                             |\n      Provider B    |                              |\n
      \                   |                              |\n              +-----------+
      \                 +-----------+\n              |           |                  |
      \          |\n              |   CPb1    |------------------|   CPb2    |\n              |
      \          |                  |           |\n              +-----------+                  +-----------+\n
      \               /      \\                        /     \\\n               /
      \       \\                      /       \\\n              /          \\                    /
      \        \\\n      +-----------+   +-----------+   +-----------+   +-----------+\n
      \     |           |   |           |   |           |   |           |\n      |
      \  EPb1    |   |   EPb2    |   |   EPb3    |   |   EPb4    |\n      |           |
      \  |           |   |           |   |           |\n      +-----------+   +-----------+
      \  +-----------+   +-----------+\n      Figure 1: Example Network Scenario Using
      SIP Load-Control Event\n                             Package Mechanism\n   During
      the initialization stage, the proxy servers first identify all\n   their outgoing
      signaling neighbors and subscribe to them.  Service\n   providers can provision
      neighbors, or the proxy servers can\n   incrementally learn who their neighbors
      are by inspecting signaling\n   messages that they send and receive.  Assuming
      all signaling\n   relationships in Figure 1 are bidirectional, after this\n
      \  initialization stage, each proxy server will be subscribed to all its\n   neighbors.\n
      \  Case I: EPa1 serves a TV program hotline and decides to limit the\n   total
      number of incoming calls to the hotline to prevent an overload.\n   To do so,
      EPa1 sends a notification to CPa1 with the specific hotline\n   number, time
      of activation, and total acceptable call rate.\n   Depending on the load-filtering
      policy computation algorithm, CPa1\n   may allocate the received total acceptable
      call rate among its\n   neighbors, namely, EPa2, CPa2, and CPb1, and notify
      them about the\n   resulting allocation along with the hotline number and the
      activation\n   time.  CPa2 and CPb1 may perform further allocation among their
      own\n   neighbors and notify the corresponding proxy servers.  This process\n
      \  continues until all edge proxy servers in the network have been\n   informed
      about the event and have proper load-filtering policies\n   configured.\n   In
      the above case, the network entity where load-filtering policy is\n   first
      introduced is the SIP server providing access to the resource\n   that creates
      the overload situation.  In other cases, the network\n   entry point of introducing
      load-filtering policy could also be an\n   entity that hosts this resource.
      \ For example, an operator may host\n   an application server that performs
      toll-free-number (\"800 number\")\n   translation services.  The application
      server itself may be a SIP\n   proxy server or a SIP Back-to-Back User Agent
      (B2BUA).  If one of the\n   toll-free numbers hosted at the application server
      creates the\n   overload condition, the load-filtering policies can be introduced\n
      \  from the application server and then propagated to other SIP proxy\n   servers
      in the network.\n   Case II: A hurricane affects the region covered by CPb2,
      EPb3, and\n   EPb4.  All three of these SIP proxy servers are overloaded.  The\n
      \  rescue team determines that outbound calls are more valuable than\n   inbound
      calls in this specific situation.  Therefore, EPb3 and EPb4\n   are configured
      with load-filtering policies to accept more outbound\n   calls than inbound
      calls.  CPb2 may be configured the same way or\n   receive dynamically computed
      load-filtering policies from EPb3 and\n   EPb4.  Depending on the load-filtering
      policy computation algorithm,\n   CPb2 may also send out notifications to its
      outside neighbors, namely\n   CPb1 and CPa2, specifying a limit on the acceptable
      rate of inbound\n   calls to CPb2's responsible domain.  CPb1 and CPa2 may subsequently\n
      \  notify their neighbors about limiting the calls to CPb2's area.  The\n   same
      process could continue until all edge proxy servers are notified\n   and have
      load-filtering policies configured.\n   Note that this specification does not
      define the provisioning\n   interface between the party who determines the load-filtering
      policy\n   and the network entry point where the policy is introduced.  One
      of\n   the options for the provisioning interface is the Extensible Markup\n
      \  Language (XML) Configuration Access Protocol (XCAP) [RFC4825].\n"
    title: 3.3.  Load-Filtering Policy Distribution
  - contents:
    - "3.4.  Applicable Network Domains\n   This specification MUST be applied inside
      a \"Trust Domain\".  The\n   concept of a Trust Domain is similar to that defined
      in [RFC3324] and\n   [RFC3325].  A Trust Domain, for the purpose of SIP load
      filtering, is\n   a set of SIP entities such as SIP proxy servers that are trusted
      to\n   exchange load-filtering policies defined in this specification.  In\n
      \  the simplest case, a Trust Domain is a network of SIP entities\n   belonging
      to a single service provider who deploys it and accurately\n   knows the behavior
      of those SIP entities.  Such simple Trust Domains\n   may be joined to form
      larger Trust Domains by bilateral agreements\n   between the service providers
      of the SIP entities.\n   The key requirement of a Trust Domain for the purpose
      of SIP load\n   filtering is that the behavior of all SIP entities within a
      given\n   Trust Domain is known to comply to the following set of\n   specifications.\n
      \  o  SIP entities in the Trust Domain agree on the mechanisms used to\n      secure
      the communication among SIP entities within the Trust\n      Domain.\n   o  SIP
      entities in the Trust Domain agree on the manner used to\n      determine which
      SIP entities are part of the Trust Domain.\n   o  SIP entities in the Trust
      Domain are compliant to SIP [RFC3261].\n   o  SIP entities in the Trust Domain
      are compliant to SIP-Specific\n      Event Notification[RFC6665].\n   o  SIP
      entities in the Trust Domain are compliant to this\n      specification.\n   o
      \ SIP entities in the Trust Domain agree on what types of calls can\n      be
      affected by this SIP load-filtering mechanism.  For example,\n      <call-identity>
      condition elements (Section 5.3.1) <one> and\n      <many> might be limited
      to describe within certain prefixes.\n   o  SIP entities in the Trust Domain
      agree on the destinations to\n      which calls may be redirected when the \"redirect\"
      action\n      (Section 5.4) is used.  For example, the URI might have to match
      a\n      given set of domains.\n   SIP load filtering is only effective if all
      neighbors that are\n   possible signaling sources participate and enforce the
      designated\n   load-filtering policies.  Otherwise, a single non-conforming
      neighbor\n   could make all filtering efforts useless by pumping in excessive\n
      \  traffic to overload the server.  Therefore, the SIP server that\n   distributes
      load-filtering policies needs to take countermeasures\n   towards any non-conforming
      neighbors.  A simple method is to reject\n   excessive requests with 503 \"Service
      Unavailable\" response messages\n   as if they were obeying the rate.  Considering
      the rejection costs, a\n   more complicated but fairer method would be to allocate
      at the\n   overloaded server the same amount of processing to the combination
      of\n   both normal processing and rejection as the overloaded server would\n
      \  devote to processing requests for a conforming upstream SIP server.\n   These
      approaches work as long as the total rejection cost does not\n   overwhelm the
      entire server resources.  In addition, SIP servers need\n   to handle message
      prioritization properly while performing load\n   filtering, which is described
      in Section 4.8.\n"
    title: 3.4.  Applicable Network Domains
  title: 3.  SIP Load-Filtering Overview
- contents:
  - "4.  Load-Control Event Package\n   The SIP load-filtering mechanism defines a
    load-control event package\n   for SIP based on [RFC6665].\n"
  - contents:
    - "4.1.  Event Package Name\n   The name of this event package is \"load-control\".
      \ This name is\n   carried in the Event and Allow-Events header, as specified
      in\n   [RFC6665].\n"
    title: 4.1.  Event Package Name
  - contents:
    - "4.2.  Event Package Parameters\n   No package-specific event header field parameters
      are defined for\n   this event package.\n"
    title: 4.2.  Event Package Parameters
  - contents:
    - "4.3.  SUBSCRIBE Bodies\n   This specification does not define the content of
      SUBSCRIBE bodies.\n   Future specifications could define bodies for SUBSCRIBE
      messages, for\n   example, to request specific types of load-control event\n
      \  notifications.\n   A SUBSCRIBE request sent without a body implies the default\n
      \  subscription behavior as specified in Section 4.7.\n"
    title: 4.3.  SUBSCRIBE Bodies
  - contents:
    - "4.4.  SUBSCRIBE Duration\n   The default expiration time for a subscription
      to load-filtering\n   policy is one hour.  Since the desired expiration time
      may vary\n   significantly for subscriptions among SIP entities with different\n
      \  signaling relationships, the subscribers and notifiers are\n   RECOMMENDED
      to explicitly negotiate appropriate subscription duration\n   when knowledge
      about the mutual signaling relationship is available.\n"
    title: 4.4.  SUBSCRIBE Duration
  - contents:
    - "4.5.  NOTIFY Bodies\n   The body of a NOTIFY request in this event package
      contains load-\n   filtering policies.  The format of the NOTIFY request body
      MUST be in\n   one of the formats defined in the Accept header field of the\n
      \  SUBSCRIBE request or be the default format, as specified in\n   [RFC6665].
      \ The default data format for the NOTIFY request body of\n   this event package
      is \"application/load-control+xml\" (defined in\n   Section 5).  This means
      that when a NOTIFY request body exists but no\n   Accept header field is specified
      in a SUBSCRIBE request, the NOTIFY\n   request body MUST contain content conforming
      to the \"application/\n   load-control+xml\" format.\n"
    title: 4.5.  NOTIFY Bodies
  - contents:
    - "4.6.  Notifier Processing of SUBSCRIBE Requests\n   The notifier accepts a
      new subscription or updates an existing\n   subscription upon receiving a valid
      SUBSCRIBE request.\n   If the identity of the subscriber sending the SUBSCRIBE
      request is\n   not allowed to receive load-filtering policies, the notifier
      MUST\n   return a 403 \"Forbidden\" response.\n   If none of the media types
      specified in the Accept header of the\n   SUBSCRIBE request are supported, the
      notifier SHOULD return a 406\n   \"Not Acceptable\" response.\n"
    title: 4.6.  Notifier Processing of SUBSCRIBE Requests
  - contents:
    - "4.7.  Notifier Generation of NOTIFY Requests\n   A notifier MUST send a NOTIFY
      request with its current load-filtering\n   policy to the subscriber upon successfully
      accepting or refreshing a\n   subscription.  If no load-filtering policy needs
      to be distributed\n   when the subscription is received, the notifier SHOULD
      sent a NOTIFY\n   request without a body to the subscriber.  The content-type
      header\n   field of this NOTIFY request MUST indicate the correct body format
      as\n   if the body were present (e.g., \"application/load-control+xml\").\n
      \  Notifiers are likely to send NOTIFY requests without a body when a\n   subscription
      is initiated for the first time, e.g., when a SIP entity\n   is just introduced,
      because there may be no planned events that\n   require load filtering at that
      time.  A notifier SHOULD generate\n   NOTIFY requests each time the load-filtering
      policy changes, with the\n   maximum notification rate not exceeding values
      defined in\n   Section 4.10.\n"
    title: 4.7.  Notifier Generation of NOTIFY Requests
  - contents:
    - "4.8.  Subscriber Processing of NOTIFY Requests\n   The subscriber is the load-filtering
      server that enforces load-\n   filtering policies received from the notifier.
      \ The way subscribers\n   process NOTIFY requests depends on the load-filtering
      policies\n   conveyed in the notifications.  Typically, load-filtering policies\n
      \  consist of rules specifying actions to be applied to requests\n   matching
      certain conditions.  A subscriber receiving a notification\n   first installs
      these rules and then enforces corresponding actions on\n   requests matching
      those conditions, for example, limiting the sending\n   rate of call requests
      destined for a specific callee.\n   In the case when load-filtering policies
      specify a future validity,\n   it is possible that when the validity time arrives,
      the subscription\n   to the specific notifier that conveyed the rules has expired.
      \ In\n   this case, it is RECOMMENDED that the subscriber re-activate its\n
      \  subscription with the corresponding notifier.  Regardless of whether\n   or
      not this re-activation of subscription is successful, when the\n   validity
      time is reached, the subscriber SHOULD enforce the\n   corresponding rules.\n
      \  Upon receipt of a NOTIFY request with a Subscription-State header\n   field
      containing the value \"terminated\", the subscription status with\n   the particular
      notifier will be terminated.  Meanwhile, subscribers\n   MUST also terminate
      previously received load-filtering policies from\n   that notifier.\n   The
      subscriber MUST discard unknown bodies.  If the NOTIFY request\n   contains
      several bodies, none of them being supported, it SHOULD\n   unsubscribe unless
      it has knowledge that it will possibly receive\n   NOTIFY requests with supported
      bodies from that notifier.  A NOTIFY\n   request without a body indicates that
      no load-filtering policies need\n   to be updated.\n   When the subscriber enforces
      load-filtering policies, it needs to\n   prioritize requests and select those
      requests that need to be\n   rejected or redirected.  This selection is largely
      a matter of local\n   policy.  It is expected that the subscriber will follow
      local policy\n   as long as the result in reduction of traffic is consistent
      with the\n   overload algorithm in effect at that node.  Accordingly, the\n
      \  normative behavior described in the next three paragraphs should be\n   interpreted
      with the understanding that the subscriber will aim to\n   preserve local policy
      to the fullest extent possible.\n   o  The subscriber SHOULD honor the local
      policy for prioritizing SIP\n      requests such as policies based on message
      type, e.g., INVITEs\n      versus requests associated with existing sessions.\n
      \  o  The subscriber SHOULD honor the local policy for prioritizing SIP\n      requests
      based on the content of the Resource-Priority header\n      (RPH, [RFC4412]).
      \ Specific (namespace.value) RPH contents may\n      indicate high-priority
      requests that should be preserved as much\n      as possible during overload.
      \ The RPH contents can also indicate a\n      low-priority request that is eligible
      to be dropped during times\n      of overload.\n   o  The subscriber SHOULD
      honor the local policy for prioritizing SIP\n      requests relating to emergency
      calls as identified by the sos URN\n      [RFC5031] indicating an emergency
      request.\n   A local policy can be expected to combine both the SIP request
      type\n   and the prioritization markings and SHOULD be honored when overload\n
      \  conditions prevail.\n"
    title: 4.8.  Subscriber Processing of NOTIFY Requests
  - contents:
    - "4.9.  Handling of Forked Requests\n   Forking is not applicable when this load-control
      event package\n   mechanism is used within a single-hop distance between neighboring\n
      \  SIP entities.  If communication scope of the load-control event\n   package
      mechanism is among multiple hops, forking is also not\n   expected to happen
      because the subscription request is addressed to a\n   clearly defined SIP entity.
      \ However, in the unlikely case when\n   forking does happen, the load-control
      event package only allows the\n   first potential dialog-establishing message
      to create a dialog, as\n   specified in Section 5.4.9 of [RFC6665].\n"
    title: 4.9.  Handling of Forked Requests
  - contents:
    - "4.10.  Rate of Notifications\n   The rate of notifications is unlikely to be
      of concern for this local\n   control event package mechanism when it is used
      in a non-real-time\n   mode for relatively static load-filtering policies.  Nevertheless,
      if\n   a situation does arise in which a rather frequently used load\n   filtering
      policy update is needed, it is RECOMMENDED that the\n   notifier not generate
      notifications at a rate higher than once per\n   second in all cases, in order
      to avoid the NOTIFY request itself\n   overloading the system.\n"
    title: 4.10.  Rate of Notifications
  - contents:
    - "4.11.  State Delta\n   It is likely that updates to specific load-filtering
      policies are\n   made by changing only part of the policy parameters (e.g.,
      acceptable\n   request rate or percentage, but not matching identities).  This
      will\n   typically be because the utilization of a resource subject to\n   overload
      depends upon dynamic unknowns such as holding time and the\n   relative distribution
      of offered loads over subscribing SIP entities.\n   The updates could originate
      manually or be determined automatically\n   by an algorithm that dynamically
      computes the load-filtering policies\n   (Section 3.2).  Another factor that
      is usually not known precisely or\n   needs to be computed automatically is
      the duration of the event\n   requiring load filtering.  Therefore, it would
      also be common for the\n   validity to change frequently.\n   This event package
      allows the use of state delta as in [RFC6665] to\n   accommodate frequent updates
      of partial policy parameters.  For each\n   NOTIFY transaction in a subscription,
      a version number that increases\n   by exactly one MUST be included in the NOTIFY
      request body when the\n   body is present.  When the subscriber receives a state
      delta, it\n   associates the partial updates to the particular policy by matching\n
      \  the appropriate rule id (Appendix D).  If the subscriber receives a\n   NOTIFY
      request with a version number that is increased by more than\n   one, it knows
      that it has missed a state delta and needs to ask for a\n   full state snapshot.
      \ Therefore, the subscriber ignores that NOTIFY\n   request containing the state
      delta, and resends a SUBSCRIBE request\n   to force a NOTIFY request containing
      a complete state snapshot.\n"
    title: 4.11.  State Delta
  title: 4.  Load-Control Event Package
- contents:
  - '5.  Load-Control Document

    '
  - contents:
    - "5.1.  Format\n   A load-control document is an XML document that describes
      the load-\n   filtering policies.  It inherits and enhances the common policy\n
      \  document defined in [RFC4745].  A common policy document contains a\n   set
      of rules.  Each rule consists of three parts: conditions,\n   actions, and transformations.
      \ The conditions part is a set of\n   expressions containing attributes such
      as identity, domain, and\n   validity time information.  Each expression evaluates
      to TRUE or\n   FALSE.  Conditions are matched on \"equality\" or \"greater than\"
      style\n   comparison.  There is no regular expression matching.  Conditions
      are\n   evaluated on receipt of an initial SIP request for a dialog or\n   standalone
      transaction.  If a request matches all conditions in a\n   rule set, the action
      part and the transformation part are consulted\n   to determine the \"permission\"
      on how to handle the request.  Each\n   action or transformation specifies a
      positive grant to the policy\n   server to perform the resulting actions.  Well-defined
      mechanism are\n   available for combining actions and transformations obtained
      from\n   more than one sources.\n"
    title: 5.1.  Format
  - contents:
    - "5.2.  Namespace\n   The namespace URI for elements defined by this specification
      is a\n   Uniform Resource Namespace (URN) ([RFC2141]), using the namespace\n
      \  identifier \"ietf\" defined by [RFC2648] and extended by [RFC3688].\n   The
      URN is as follows:\n   urn:ietf:params:xml:ns:load-control\n"
    title: 5.2.  Namespace
  - contents:
    - "5.3.  Conditions\n   [RFC4745] defines three condition elements: <identity>,
      <sphere>, and\n   <validity>.  This specification defines new condition elements
      and\n   reuses the <validity> element.  The <sphere> element is not used.\n"
    - contents:
      - "5.3.1.  Call Identity\n   Since the problem space of this specification is
        different from that\n   of [RFC4745], the [RFC4745] <identity> element is
        not sufficient for\n   use with load filtering.  First, load filtering may
        be applied to\n   different identities contained in a request, including identities
        of\n   both the receiving entity and the sending entity.  Second, the\n   importance
        of authentication varies when different identities of a\n   request are concerned.
        \ This specification defines new identity\n   conditions that can accommodate
        the granularity of specific SIP\n   identity header fields.  The requirement
        for authentication depends\n   on which field is to be matched.\n   The identity
        condition for load filtering is specified by the\n   <call-identity> element
        and its sub-element <sip>.  The <sip> element\n   itself contains sub-elements
        representing SIP sending and receiving\n   identity header fields: <from>,
        <to>, <request-uri>, and\n   <p-asserted-identity>.  All those sub-elements
        are of an extended\n   form of the [RFC4745] <identity> element.  In addition
        to the sub-\n   elements including <one>, <except>, and <many> in the <identity>\n
        \  element from [RFC4745], the extended form adds two new sub-elements,\n
        \  namely, <many-tel> and <except-tel>, which will be explained later in\n
        \  this section.\n   The [RFC4745] <one> and <except> elements may contain
        an \"id\"\n   attribute, which is the URI of a single entity to be included
        or\n   excluded in the condition.  When used in the <from>, <to>,\n   <request-uri>,
        and <p-asserted-identity> elements, this \"id\" value is\n   the URI contained
        in the corresponding SIP header field, i.e., From,\n   To, Request-URI, and
        P-Asserted-Identity.\n   When the <call-identity> element contains multiple
        <sip> sub-\n   elements, the result is combined using logical OR.  When the
        <from>,\n   <to>, <request-uri>, and <p-asserted-identity> elements contain\n
        \  multiple <one>, <many>, or <many-tel> sub-elements, the result is\n   also
        combined using logical OR.  When the <many> sub-element further\n   contains
        one or more <except> sub-elements, or when the <many-tel>\n   sub-element
        further contains one or more <except-tel> sub-elements,\n   the result of
        each <except> or <except-tel> sub-element is combined\n   using a logical
        OR, similar to that of the [RFC4745] <identity>\n   element.  However, when
        the <sip> element contains multiple <from>,\n   <to>, <request-uri>, and <p-asserted-identity>
        sub-elements, the\n   result is combined using logical AND.  This allows the
        call identity\n   to be specified by multiple fields of a SIP request simultaneously,\n
        \  e.g., both the From and the To header fields.\n   The following shows an
        example of the <call-identity> element, which\n   matches call requests whose
        To header field contains the SIP URI\n   \"sip:alice@hotline.example.com\"
        or the 'tel' URI\n   \"tel:+1-212-555-1234\".\n               <call-identity>\n
        \                  <sip>\n                       <to>\n                           <one
        id=\"sip:alice@hotline.example.com\"/>\n                           <one id=\"tel:+1-212-555-1234\"/>\n
        \                      </to>\n                   </sip>\n               </call-identity>\n
        \  Before evaluating <call-identity> conditions, the subscriber shall\n   convert
        URIs received in SIP header fields in canonical form as per\n   [RFC3261],
        except that the \"phone-context\" parameter shall not be\n   removed, if present.\n
        \  The [RFC4745] <many> and <except> elements may take a \"domain\"\n   attribute.
        \ The \"domain\" attribute specifies a domain name to be\n   matched by the
        domain part of the candidate identity.  Thus, it\n   allows matching a large
        and possibly unknown number of entities\n   within a domain.  The \"domain\"
        attribute works well for SIP URIs.\n   A URI identifying a SIP user, however,
        can also be a 'tel' URI.\n   Therefore, a similar way to match a group of
        'tel' URIs is needed.\n   There are two forms of 'tel' URIs: for global numbers
        and local\n   numbers.  According to [RFC3966], \"All phone numbers MUST use
        the\n   global form unless they cannot be represented as such...Local numbers\n
        \  MUST be tagged with a 'phone-context'\".  The global number 'tel' URIs\n
        \  start with a \"+\".  The \"phone-context\" parameter of local numbers may\n
        \  be labeled as a global number or any number of its leading digits or\n
        \  a domain name.  Both forms of the 'tel' URI make the resulting URI\n   globally
        unique.\n   'tel' URIs of global numbers can be grouped by prefixes consisting
        of\n   any number of common leading digits.  For example, a prefix formed
        by\n   a country code or both the country and area code identifies telephone\n
        \  numbers within a country or an area.  Since the length of the country\n
        \  and area code for different regions are different, the length of the\n
        \  number prefix also varies.  This allows further flexibility such as\n   grouping
        the numbers into sub-areas within the same area code. 'tel'\n   URIs of local
        numbers can be grouped by the value of the\n   \"phone-context\" parameter.\n
        \  The <many> and <except> sub-elements in the <identity> element of\n   [RFC4745]
        do not allow additional attributes to be added directly.\n   Redefining behavior
        of their existing \"domain\" attribute creates\n   backward-compatibility
        issues.  Therefore, this specification defines\n   the <many-tel> and <except-tel>
        sub-elements that extend the\n   [RFC4745] <identity> element.  Both of them
        have a \"prefix\" attribute\n   for grouping 'tel' URIs, similar to the \"domain\"
        attribute for\n   grouping SIP URIs in existing <many> and <except> sub-elements.
        \ For\n   global numbers, the \"prefix\" attribute value holds any number
        of\n   common leading digits, for example, \"+1-212\" for US phone numbers\n
        \  within area code \"212\" or \"+1-212-854\" for the organization with US\n
        \  area code \"212\" and local prefix \"854\".  For local numbers, the\n   \"prefix\"
        attribute value contains the \"phone-context\" parameter\n   value.  It should
        be noted that visual separators (such as the \"-\"\n   sign) in 'tel' URIs
        are not used for URI comparison as per [RFC3966].\n   The following example
        shows the use of the \"prefix\" attribute along\n   with the \"domain\" attribute.
        \ It matches those requests calling to\n   the number \"+1-202-999-1234\"
        but are not calling from a \"+1-212\"\n   prefix or a SIP From URI domain
        of \"manhattan.example.com\".\n               <call-identity>\n                   <sip>\n
        \                      <from>\n                           <many>\n                               <except
        domain=\"manhattan.example.com\"/>\n                           </many>\n                           <many-tel>\n
        \                              <except-tel prefix=\"+1-212\"/>\n                           </many-tel>\n
        \                      </from>\n                       <to>\n                           <one
        id=\"tel:+1-202-999-1234\"/>\n                       </to>\n                   </sip>\n
        \              </call-identity>\n"
      title: 5.3.1.  Call Identity
    - contents:
      - "5.3.2.  Method\n   The load created on a SIP server depends on the type of
        initial SIP\n   requests for dialogs or standalone transactions.  The <method>\n
        \  element specifies the SIP method to which the load-filtering action\n   applies.
        \ When this element is not included, the load-filtering\n   actions are applicable
        to all applicable initial requests.  These\n   requests include INVITE, MESSAGE,
        REGISTER, SUBSCRIBE, OPTIONS, and\n   PUBLISH.  Non-initial requests, such
        as ACK, BYE, and CANCEL MUST NOT\n   be subjected to load filtering.  In addition,
        SUBSCRIBE requests are\n   not filtered if the event-type header field indicates
        the event\n   package defined in this specification.\n   The following example
        shows the use of the <method> element in the\n   case the filtering actions
        should be applied to INVITE requests.\n           <method>INVITE</method>\n"
      title: 5.3.2.  Method
    - contents:
      - "5.3.3.  Target SIP Entity\n   A SIP server that performs load-filtering may
        have multiple paths to\n   route call requests matching the same set of call
        identity elements.\n   In those situations, the SIP load-filtering server
        may desire to take\n   advantage of alternative paths and only apply load-filtering
        actions\n   to matching requests for the next-hop SIP entity that originated
        the\n   corresponding load-filtering policy.  To achieve that, the SIP load-\n
        \  filtering server needs to associate every load-filtering policy with\n
        \  its originating SIP entity.  The <target-sip-entity> element is\n   defined
        for that purpose, and it contains the URI of the entity that\n   initiated
        the load-filtering policy, which is generally the\n   corresponding notifier.
        \ A notifier MAY include this element as part\n   of the condition of its
        filtering policy being sent to the\n   subscriber, as below.\n   <target-sip-entity>sip:biloxi.example.com</target-sip-entity>\n
        \  When a SIP load-filtering server receives a policy with a\n   <target-sip-entity>
        element, it SHOULD record it and take it into\n   consideration when making
        load-filtering decisions.  If the load-\n   filtering server receives a load-filtering
        policy that does not\n   contain a <target-sip-entity> element, it MAY still
        record the URI of\n   the load-filtering policy's originator as the <target-sip-entity>\n
        \  information and consider it when making load-filtering decisions.\n      The
        following are two examples of using the <target-sip-entity>\n      element.\n
        \     Use case I: The network has user A connected to SIP Proxy 1 (SP1),\n
        \     user B connected to SIP Proxy 3 (SP3), SP1 and SP3 connected via\n      SIP
        Proxy 2 (SP2), and SP2 connected to an Application Server\n      (AS).  Under
        normal load conditions, a call from A to B is routed\n      along the following
        path: A-SP1-SP2-AS-SP3-B.  The AS provides a\n      nonessential service and
        can be bypassed in case of overload.  Now\n      let's assume that AS is overloaded
        and sends to SP2 a load-\n      filtering policy requesting that 50% of all
        INVITE requests be\n      dropped.  SP2 can maintain AS as the <target-sip-entity>
        for that\n      policy so that it knows the 50% drop action is only applicable
        to\n      call requests that must go through AS, without affecting those\n
        \     calls directly routed through SP3 to B.\n      Use case II: A translation
        service for toll-free numbers is\n      installed on two Application Servers,
        AS1 and AS2.  User A is\n      connected to SP1 and calls 800-1234-4529, which
        is translated by\n      AS1 and AS2 into a regular E.164 number depending
        on, e.g., the\n      caller's location.  SP1 forwards INVITE requests with
        Request-URI\n      = \"800 number\" to AS1 or AS2 based on a load-balancing
        strategy.\n      As calls to 800-1234-4529 create a pre-overload condition
        in AS1,\n      AS1 sends to SP1 a load-filtering policy requesting that 50%
        of\n      calls towards 800-1234-4529 be rejected.  In this case, SP1 can\n
        \     maintain AS1 as the <target-sip-entity> for the rule, and only\n      apply
        the load-filtering policy on incoming requests that are\n      intended to
        be sent to AS1.  Those requests that are sent to AS2,\n      although matching
        the <call-identity> of the filter, will not be\n      affected.\n"
      title: 5.3.3.  Target SIP Entity
    - contents:
      - "5.3.4.  Validity\n   A filtering policy is usually associated with a validity
        period\n   condition.  This specification reuses the <validity> element of\n
        \  [RFC4745], which specifies a period of validity time by pairs of\n   <from>
        and <until> sub-elements.  When multiple time periods are\n   defined, the
        validity condition is evaluated to TRUE if the current\n   time falls into
        any of the specified time periods.  That is, it\n   represents a logical OR
        operation across all validity time periods.\n   The following example shows
        a <validity> element specifying a valid\n   period from 12:00 to 15:00 US
        Eastern Standard Time on 2008-05-31.\n               <validity>\n                   <from>2008-05-31T12:00:00-05:00</from>\n
        \                  <until>2008-05-31T15:00:00-05:00</until>\n               </validity>\n"
      title: 5.3.4.  Validity
    title: 5.3.  Conditions
  - contents:
    - "5.4.  Actions\n   The actions a load-filtering server takes on loads matching
      the load-\n   filtering conditions are defined by the <accept> element in the
      load-\n   filtering policy, which includes any one of the three sub-elements\n
      \  <rate>, <percent>, and <win>.  The <rate> element denotes an absolute\n   value
      of the maximum acceptable request rate in requests per second;\n   the <percent>
      element specifies the relative percentage of incoming\n   requests that should
      be accepted; the <win> element describes the\n   acceptable window size supplied
      by the receiver, which is applicable\n   in window-based load-filtering.  In
      static load-filtering policy\n   configuration scenarios, using the <rate> sub-element
      is RECOMMENDED\n   because it is hard to enforce the percentage rate or window-based\n
      \  load filtering when incoming load from upstream or reactions from\n   downstream
      are uncertain.  (See [SIP-OVERLOAD] and [RFC6357] for more\n   details on rate-based,
      loss-based, and window-based load control.)\n   In addition, the <accept> element
      takes an optional \"alt-action\"\n   attribute that can be used to explicitly
      specify the desired action\n   in case a request cannot be processed.  The \"alt-action\"
      can take one\n   of the following three values: \"reject\", \"redirect\", or
      \"drop\".\n   o  The \"reject\" action is the default value for \"alt-action\".
      \ It\n      means that the load-filtering server will reject the request with\n
      \     a 503 \"Service Unavailable\" response message.\n   o  The \"redirect\"
      action means redirecting the request to another\n      target.  When it is used,
      an \"alt-target\" attribute MUST be\n      defined.  The \"alt-target\" specifies
      one URI or a list of URIs\n      where the request should be redirected.  The
      server sends out the\n      redirect URIs in a 300-class response message.\n
      \  o  The \"drop\" action means simply ignoring the request without doing\n
      \     anything, which can, in certain cases, help save processing\n      capability
      during overload.  For example, when SIP is running over\n      a reliable transport
      such as TCP, the \"drop\" action does not send\n      out the rejection response,
      neither does it close the transport\n      connection.  However, when running
      SIP over an unreliable\n      transport such as UDP, using the \"drop\" action
      will create message\n      retransmissions that further worsen the possible
      overload\n      situation.  Therefore, any \"drop\" action applied to an unreliable\n
      \     transport MUST be treated as if it were \"reject\".\n   The above \"alt-action\"
      processing can also be illustrated through the\n   following pseudocode.\n           SWITCH
      \"alt-action\"\n             \"redirect\": \"redirect\"\n             \"drop\":\n
      \              IF unreliable-transport\n                 THEN treat as \"reject\"\n
      \              ELSE\n                 \"drop\"\n             \"reject\": \"reject\"\n
      \            default: \"reject\"\n           END\n   In the following <actions>
      element example, the server accepts\n   maximum of 100 call requests per second.
      \ The remaining calls are\n   redirected to an answering machine.\n           <actions>\n
      \              <accept alt-action=\"redirect\" alt-target=\n                       \"sip:answer-machine@example.com\">\n
      \                  <rate>100</rate>\n               </accept>\n           </actions>\n"
    title: 5.4.  Actions
  title: 5.  Load-Control Document
- contents:
  - "6.  XML Schema Definition for Load Control\n   This section defines the XML schema
    for the load-control document.\n   It extends the Common Policy schema in [RFC4745]
    in two ways.\n   Firstly, it defines two mandatory attributes for the <ruleset>\n
    \  element: \"version\" and \"state\".  The \"version\" attribute allows the\n
    \  recipient of the notification to properly order them.  Versions start\n   at
    zero and increase by one for each new document sent to a\n   subscriber within
    the same subscription.  Versions MUST be\n   representable using a non-negative
    32-bit integer.  The \"state\"\n   attribute indicates whether the document contains
    a full load-\n   filtering policy update or only state delta as partial update.\n
    \  Secondly, it defines new members of the <conditions> and <actions>\n   elements.\n
    \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xs:schema targetNamespace=\"urn:ietf:params:xml:ns:load-control\"\n
    \      xmlns:lc=\"urn:ietf:params:xml:ns:load-control\"\n       xmlns:cp=\"urn:ietf:params:xml:ns:common-policy\"\n
    \      xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n       elementFormDefault=\"qualified\"\n
    \      attributedFormDefault=\"unqualified\">\n   <xs:import namespace=\"urn:ietf:params:xml:ns:common-policy\"/>\n
    \  <!-- RULESET -->\n   <xs:element name=\"ruleset\">\n     <xs:complexType>\n
    \      <xs:complexContent>\n         <xs:restriction base=\"xs:anyType\">\n           <xs:sequence>\n
    \            <xs:element name=\"rule\" type=\"cp:ruleType\"\n             minOccurs=\"0\"
    maxOccurs=\"unbounded\"/>\n           </xs:sequence>\n         </xs:restriction>\n
    \      </xs:complexContent>\n       <xs:attribute name=\"version\" type=\"xs:integer\"
    use=\"required\"/>\n       <xs:attribute name=\"state\" use=\"required\">\n         <xs:simpleType>\n
    \          <xs:restriction base=\"xs:string\">\n             <xs:enumeration value=\"full\"/>\n
    \            <xs:enumeration value=\"partial\"/>\n           </xs:restriction>\n
    \        </xs:simpleType>\n       </xs:attribute>\n     </xs:complexType>\n   </xs:element>\n
    \  <!-- CONDITIONS -->\n   <!-- CALL IDENTITY -->\n   <xs:element name=\"call-identity\"
    type=\"lc:call-identity-type\"/>\n   <!-- CALL IDENTITY TYPE -->\n   <xs:complexType
    name=\"call-identity-type\">\n     <xs:choice>\n       <xs:element name=\"sip\"
    type=\"lc:sip-id-type\"/>\n       <any namespace=\"##other\" processContents=\"lax\"
    minOccurs=\"0\"\n       maxOccurs=\"unbounded\"/>\n     </xs:choice>\n     <anyAtrribute
    namespace=\"##other\" processContents=\"lax\"/>\n   </xs:complexType>\n   <!--
    SIP ID TYPE -->\n   <xs:complexType name=\"sip-id-type\">\n     <xs:sequence>\n
    \      <element name=\"from\" type=\"lc:identityType\" minOccurs=\"0\"/>\n       <element
    name=\"to\" type=\"lc:identityType\" minOccurs=\"0\"/>\n       <element name=\"request-uri\"
    type=\"lc:identityType\"\n       minOccurs=\"0\"/>\n       <element name=\"p-asserted-identity\"
    type=\"lc:identityType\"\n       minOccurs=\"0\"/>\n       <any namespace=\"##other\"
    processContents=\"lax\" minOccurs=\"0\"\n       maxOccurs=\"unbounded\"/>\n     </xs:sequence>\n
    \    <anyAtrribute namespace=\"##other\" processContents=\"lax\"/>\n   </xs:complexType>\n
    \  <!-- IDENTITY TYPE -->\n   <xs:complexType name=\"identityType\">\n     <xs:complexContent>\n
    \      <xs:restriction base=\"xs:anyType\">\n         <xs:choice minOccurs=\"1\"
    maxOccurs=\"unbounded\">\n           <xs:element name=\"one\" type=\"cp:oneType\"/>\n
    \          <xs:element name=\"many\" type=\"lc:manyType\"/>\n           <xs:element
    name=\"many-tel\" type=\"lc:manyTelType\"/>\n           <xs:any namespace=\"##other\"
    processContents=\"lax\"/>\n         </xs:choice>\n       </xs:restriction>\n     </xs:complexContent>\n
    \  </xs:complexType>\n   <!-- MANY-TEL TYPE -->\n   <xs:complexType name=\"manyTelType\">\n
    \    <xs:complexContent>\n       <xs:restriction base=\"xs:anyType\">\n         <xs:choice
    minOccurs=\"0\" maxOccurs=\"unbounded\">\n           <xs:element name=\"except-tel\"
    type=\"lc:exceptTelType\"/>\n           <xs:any namespace=\"##other\"\n           minOccurs=\"0\"
    processContents=\"lax\"/>\n         </xs:choice>\n         <xs:attribute name=\"prefix\"\n
    \        use=\"optional\" type=\"xs:string\"/>\n       </xs:restriction>\n     </xs:complexContent>\n
    \  </xs:complexType>\n   <!-- EXCEPT-TEL TYPE -->\n   <xs:complexType name=\"exceptTelType\">\n
    \    <xs:attribute name=\"prefix\" type=\"xs:string\" use=\"optional\"/>\n     <xs:attribute
    name=\"id\" type=\"xs:anyURI\" use=\"optional\"/>\n   </xs:complexType>\n   <!--
    METHOD -->\n   <xs:element name=\"method\" type=\"lc:method-type\"/>\n   <!--
    METHOD TYPE -->\n   <xs:simpleType name=\"method-type\">\n     <xs:restriction
    base=\"xs:string\">\n       <xs:enumeration value=\"INVITE\"/>\n       <xs:enumeration
    value=\"MESSAGE\"/>\n       <xs:enumeration value=\"REGISTER\"/>\n       <xs:enumeration
    value=\"SUBSCRIBE\"/>\n       <xs:enumeration value=\"OPTIONS\"/>\n       <xs:enumeration
    value=\"PUBLISH\"/>\n     </xs:restriction>\n   </xs:simpleType>\n   <!-- TARGET
    SIP ENTITY -->\n   <xs:element name=\"target-sip-entity\" type=\"xs:anyURI\" minOccurs=\"0\"/>\n
    \  <!-- ACTIONS -->\n   <xs:element name=\"accept\">\n     <xs:choice>\n       <element
    name=\"rate\" type=\"xs:decimal\" minOccurs=\"0\"/>\n       <element name=\"win\"
    type=\"xs:integer\" minOccurs=\"0\"/>\n       <element name=\"percent\" type=\"xs:decimal\"
    minOccurs=\"0\"/>\n       <any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\"\n
    \      maxOccurs=\"unbounded\"/>\n     </xs:choice>\n     <xs:attribute name=\"alt-action\"
    type=\"xs:string\" default=\"reject\"/>\n     <xs:attribute name=\"alt-target\"
    type=\"lc:alt-target-type\"\n     use=\"optional\"/>\n     <anyAtrribute namespace=\"##other\"
    processContents=\"lax\"/>\n   </xs:element>\n   <!-- ALT TARGET TYPE -->\n   <xs:simpleType
    name=\"alt-target-type\">\n     <xs:list itemType=\"xs:anyURI\"/>\n   </xs:simpleType>\n
    \  </xs:schema>\n"
  title: 6.  XML Schema Definition for Load Control
- contents:
  - "7.  Security Considerations\n   Two primary security considerations arise from
    this specification.\n   One is the distribution mechanism for the load filtering
    policy that\n   is based on the SIP event notification framework, and the other
    is\n   the enforcement mechanism for the load-filtering policy.\n   Security considerations
    for SIP event package mechanisms are covered\n   in Section 6 of [RFC6665].  A
    particularly relevant security concern\n   for this event package is that if the
    notifiers can be spoofed,\n   attackers can send fake notifications asking subscribers
    to throttle\n   all traffic, leading to denial-of-service (DoS) attacks.  Therefore,\n
    \  this SIP load-filtering mechanism MUST be used in a Trust Domain\n   (Section
    3.4).  But if a legitimate notifier in the Trust Domain is\n   itself compromised,
    additional mechanisms will be needed to detect\n   the attack.\n   Security considerations
    for load-filtering policy enforcement depends\n   very much on the contents of
    the policy.  This specification defines\n   a possible match of the following
    SIP header fields in a load-\n   filtering policy: <from>, <to>, <request-uri>,
    and\n   <p-asserted-identity>.  The exact requirement to authenticate and\n   authorize
    these fields is up to the service provider.  In general, if\n   the identity field
    represents the source of the request, it SHOULD be\n   authenticated and authorized;
    if the identity field represents the\n   destination of the request, the authentication
    and authorization is\n   optional.\n   In addition, the \"redirect\" action (Section
    5.4) could facilitate a\n   reflection denial-of-service attack.  If a number
    of SIP proxy\n   servers in a Trust Domain are using UDP and configured to get
    their\n   policies from a central server.  An attacker spoofs the central\n   server's
    address to send a number of NOTIFY bodies telling the proxy\n   servers to redirect
    all calls to victim@outside-of-trust-domain.com.\n   The proxy servers then redirect
    all calls to the victim, who then\n   becomes a victim of Denial of Service attack
    and becomes\n   inaccessiable from the Internet.  To address this type of threat,\n
    \  this specification requires that a Trust Domain agrees on what types\n   of
    calls can be affected as well as on the destinations to which\n   calls may be
    redirected, as in Section 3.4.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   This specification registers a SIP event package,
    a new media type, a\n   new XML namespace, and a new XML schema.\n"
  - contents:
    - "8.1.  Load-Control Event Package Registration\n   This section registers an
      event package based on the registration\n   procedures defined in [RFC6665].\n
      \  Package name: load-control\n   Type: package\n   Published specification:
      This specification\n   Person to contact: Charles Shen, charles@cs.columbia.edu\n"
    title: 8.1.  Load-Control Event Package Registration
  - contents:
    - "8.2.  application/load-control+xml Media Type Registration\n   This section
      registers a new media type based on the procedures\n   defined in [RFC6838]
      and guidelines in [RFC3023].\n   Type name: application\n   Subtype name: load-control+xml\n
      \  Required parameters: none\n   Optional parameters: Same as charset parameter
      of application/xml as\n   specified in [RFC3023].\n   Encoding considerations:
      Same as encoding considerations of\n   application/xml as specified in [RFC3023].\n
      \  Security considerations: See Section 10 of [RFC3023] and Section 7 of\n   this
      specification.\n   Interoperability considerations: none\n   Published specification:
      This specification\n   Applications that use this media type: Applications that
      perform load\n   control of SIP entities.\n   Fragment identifier considerations:
      Same as fragment identifier\n   considerations of application/xml as specified
      in [RFC3023].\n   Additional Information:\n      Deprecated alias names for
      this type: none\n      Magic Number(s): none\n      File Extension(s): .xml\n
      \     Macintosh file type code(s): \"TEXT\"\n   Person and email address for
      further information: Charles Shen,\n   charles@cs.columbia.edu\n   Intended
      usage: COMMON\n   Restrictions on usage: none\n   Author: Charles Shen, Henning
      Schulzrinne, Arata Koike\n   Change controller: IESG\n   Provisional registration?
      (standards tree only): no\n"
    title: 8.2.  application/load-control+xml Media Type Registration
  - contents:
    - "8.3.  URN Sub-Namespace Registration\n   This section registers a new XML namespace,
      as per the guidelines in\n   [RFC3688]\n   URI: The URI for this namespace is\n
      \     urn:ietf:params:xml:ns:load-control\n   Registrant Contact: IETF SOC Working
      Group <sip-overload@ietf.org>,\n   as designated by the IESG <iesg@ietf.org>\n
      \  XML:\n   BEGIN\n   <?xml version=\"1.0\"?>\n   <!DOCTYPE html PUBLIC \"-//W3C//DTD
      XHTML Basic 1.0//EN\"\n                \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
      \  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n   <head>\n     <meta http-equiv=\"content-type\"\n
      \      content=\"text/html;charset=iso-8859-1\"/>\n     <title>SIP Load-Control
      Namespace</title>\n   </head>\n   <body>\n     <h1>Namespace for SIP Load Control</h1>\n
      \    <h2>urn:ietf:params:xml:ns:load-control</h2>\n     <p>See <a href=\"http://www.rfc-editor.org/rfc/rfc7200.txt\">\n
      \        RFC 7200</a>.</p>\n   </body>\n   </html>\n   END\n"
    title: 8.3.  URN Sub-Namespace Registration
  - contents:
    - "8.4.  Load-Control Schema Registration\n   URI: urn:ietf:params:xml:schema:load-control\n
      \  Registrant Contact: IETF SOC working group, Charles Shen\n   (charles@cs.columbia.edu).\n
      \  XML: the XML schema contained in Section 6 has been registered.\n   Its first
      line is\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   and its last line
      is\n   </xs:schema>\n"
    title: 8.4.  Load-Control Schema Registration
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgements\n   The authors would like to thank Jari Arkko, Richard
    Barnes, Stewart\n   Bryant, Gonzalo Camarillo, Bruno Chatras, Benoit Claise, Spencer\n
    \  Dawkins, Martin Dolly, Keith Drage, Ashutosh Dutta, Donald Eastlake,\n   Adrian
    Farrel, Stephen Farrell, Janet Gunn, Vijay Gurbani, Brian\n   Haberman, Volker
    Hilt, Geoff Hunt, Carolyn Johnson, Hadriel Kaplan,\n   Paul Kyzivat, Barry Leiba,
    Pearl Liang, Salvatore Loreto, Timothy\n   Moran, Eric Noel, Parthasarathi R,
    Pete Resnick, Adam Roach, Dan\n   Romascanu, Shida Schubert, Robert Sparks, Martin
    Stiemerling, Sean\n   Turner, Phil Williams, and other members of the SOC and
    SIPPING\n   working groups for many helpful comments.  In particular, Bruno\n
    \  Chatras proposed the <method> and <target-sip-entity> condition\n   elements
    along with many other text improvements.  Janet Gunn\n   provided detailed text
    suggestions including Appendix C. Eric Noel\n   suggested clarification on load-filtering
    policy distribution\n   initialization process.  Shida Schubert made many suggestions
    such as\n   terminology usage.  Phil Williams suggested adding support for delta\n
    \  updates.  Ashutosh Dutta gave pointers to Public Switched Telephone\n   Network
    (PSTN) references.  Adam Roach suggested improvements related\n   to RFC 6665
    and offered other helpful clarifications.  Richard Barnes\n   made many suggestions
    such as referencing the Trust Domain concept of\n   RFCs 3324 and 3325, the use
    of a separate element for 'tel' URI\n   grouping, and addressing the \"redirect\"
    action security threat.\n"
  title: 9.  Acknowledgements
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2141]  Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [RFC3023]
      \ Murata, M., St. Laurent, S., and D. Kohn, \"XML Media\n              Types\",
      RFC 3023, January 2001.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo,
      G., Johnston,\n              A., Peterson, J., Sparks, R., Handley, M., and
      E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n
      \             June 2002.\n   [RFC3688]  Mealling, M., \"The IETF XML Registry\",
      BCP 81, RFC 3688,\n              January 2004.\n   [RFC3966]  Schulzrinne, H.,
      \"The tel URI for Telephone Numbers\", RFC\n              3966, December 2004.\n
      \  [RFC4745]  Schulzrinne, H., Tschofenig, H., Morris, J., Cuellar, J.,\n              Polk,
      J., and J. Rosenberg, \"Common Policy: A Document\n              Format for
      Expressing Privacy Preferences\", RFC 4745,\n              February 2007.\n
      \  [RFC6665]  Roach, A., \"SIP-Specific Event Notification\", RFC 6665,\n              July
      2012.\n   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n              Specifications
      and Registration Procedures\", BCP 13, RFC\n              6838, January 2013.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [E.300SerSup3]\n              ITU-T, \"North
      American Precise Audible Tone Plan\",\n              Recommendation E.300 Series
      Supplement 3, November 1988.\n   [E.412]    ITU-T, \"Network Management Controls\",
      Recommendation\n              E.412-2003, January 2003.\n   [Q.1248.2] ITU-T,
      \"Interface Recommendation for Intelligent Network\n              Capability
      Set4:SCF-SSF interface\", Recommendation\n              Q.1248.2, July 2001.\n
      \  [RFC2648]  Moats, R., \"A URN Namespace for IETF Documents\", RFC 2648,\n
      \             August 1999.\n   [RFC3324]  Watson, M., \"Short Term Requirements
      for Network Asserted\n              Identity\", RFC 3324, November 2002.\n   [RFC3325]
      \ Jennings, C., Peterson, J., and M. Watson, \"Private\n              Extensions
      to the Session Initiation Protocol (SIP) for\n              Asserted Identity
      within Trusted Networks\", RFC 3325,\n              November 2002.\n   [RFC4412]
      \ Schulzrinne, H. and J. Polk, \"Communications Resource\n              Priority
      for the Session Initiation Protocol (SIP)\", RFC\n              4412, February
      2006.\n   [RFC4825]  Rosenberg, J., \"The Extensible Markup Language (XML)\n
      \             Configuration Access Protocol (XCAP)\", RFC 4825, May 2007.\n
      \  [RFC5031]  Schulzrinne, H., \"A Uniform Resource Name (URN) for\n              Emergency
      and Other Well-Known Services\", RFC 5031,\n              January 2008.\n   [RFC5390]
      \ Rosenberg, J., \"Requirements for Management of Overload in\n              the
      Session Initiation Protocol\", RFC 5390, December 2008.\n   [RFC6357]  Hilt,
      V., Noel, E., Shen, C., and A. Abdelal, \"Design\n              Considerations
      for Session Initiation Protocol (SIP)\n              Overload Control\", RFC
      6357, August 2011.\n   [SIP-OVERLOAD]\n              Gurbani, V., Ed., Hilt,
      V., and H. Schulzrinne, \"Session\n              Initiation Protocol (SIP) Overload
      Control\", Work in\n              Progress, March 2014.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Definitions\n   This specification reuses the definitions for \"Event
    Package\",\n   \"Notification\", \"Notifier\", \"Subscriber\", and \"Subscription\"
    as in\n   [RFC6665].  The following additional definitions are also used.\n   Load
    Filtering:  A load-control mechanism that applies specific\n      actions to selected
    loads (e.g., SIP requests) matching specific\n      conditions.\n   Load-Filtering
    Policy:  A set of zero or more load-filtering rules,\n      also known as load-filtering
    rule set.\n   Load-Filtering Rule:  Conditions and actions to be applied for load\n
    \     filtering.\n   Load-Filtering Condition:  Elements that describe how to
    select loads\n      to apply load-filtering actions.  This specification defines
    the\n      <call-identity>, <method>, <target-sip-identity>, and <validity>\n
    \     condition elements (Section 5.3).\n   Load-Filtering Action:  An operation
    to be taken by a load-filtering\n      server on loads that match the load-filtering
    conditions.  This\n      specification allows actions such as accept, reject,
    and redirect\n      of loads (Section 5.4).\n   Load-Filtering Server:  A server
    that performs load filtering.  In\n      the context of this specification, the
    load-filtering server is\n      the subscriber, which receives load-filtering
    policies from the\n      notifier and enforces those policies during load filtering.\n
    \  Load-Control Document:  An XML document that describes the load-\n      filtering
    policies (Section 5).  It inherits and enhances the\n      common policy document
    defined in [RFC4745].\n"
  title: Appendix A.  Definitions
- contents:
  - "Appendix B.  Design Requirements\n   The SIP load-filtering mechanism needs to
    satisfy the following\n   requirements:\n   o  For simplicity, the solution should
    focus on a method for\n      controlling SIP load, rather than a generic application-layer\n
    \     mechanism.\n   o  The load-filtering policy needs to be distributed efficiently
    to\n      possibly a large subset of all SIP elements.\n   o  The solution should
    reuse existing SIP protocol mechanisms to\n      reduce implementation and deployment
    complexity.\n   o  For predictable overload situations, such as holidays and mass\n
    \     calling events, the load-filtering policy should specify during\n      what
    time it is to be applied, so that the information can be\n      distributed ahead
    of time.\n   o  For destination-specific overload situations, the load-filtering\n
    \     policy should be able to describe the destination domain or the\n      callee.\n
    \  o  To address accidental and intentional high-volume call generators,\n      the
    load-filtering policy should be able to specify the caller.\n   o  Caller and
    callee need to be specified as both SIP URIs and 'tel'\n      URIs [RFC3966] in
    load-filtering policies.\n   o  It should be possible to specify particular information
    in the SIP\n      headers (e.g., prefixes in telephone numbers) that allow load\n
    \     filtering over limited regionally focused overloads.\n   o  The solution
    should draw upon experiences from related PSTN\n      mechanisms [Q.1248.2] [E.412]
    [E.300SerSup3] where applicable.\n   o  The solution should be extensible to meet
    future needs.\n"
  title: Appendix B.  Design Requirements
- contents:
  - "Appendix C.  Discussion of How This Specification Meets the Requirements\n             of
    RFC 5390\n   This section evaluates whether the load-control event package\n   mechanism
    defined in this specification satisfies various SIP\n   overload control requirements
    set forth by [RFC5390].  As mentioned\n   in Section 1, this specification complements
    other efforts in the\n   overall SIP load-control solution space.  Therefore,
    not all RFC 5390\n   requirements are found applicable to this specification.
    \ This\n   specification categorizes the assessment results into Yes (the\n   requirement
    is met), P/A (Partially Applicable), No (must be used in\n   conjunction with
    another mechanism to meet the requirement), and N/A\n   (Not Applicable).\n      REQ
    1: The overload mechanism shall strive to maintain the overall\n      useful throughput
    (taking into consideration the quality-of-\n      service needs of the using applications)
    of a SIP server at\n      reasonable levels, even when the incoming load on the
    network is\n      far in excess of its capacity.  The overall throughput under
    load\n      is the ultimate measure of the value of an overload control\n      mechanism.\n
    \  P/A.  The goal of load filtering is to prevent overload or maintain\n   overall
    goodput during the time of overload, but it is dependent on\n   the predictions
    of the load and the computations as well as\n   distribution of the filtering
    policies.  If the load predictions or\n   filtering policy computations are incorrect,
    or the filtering policy\n   is not properly distributed, the mechanism will be
    less effective.\n   On the other hand, if the load can be accurately predicted
    and\n   filtering policies be computed and distributed appropriately, this\n   requirement
    can be met.\n      REQ 2: When a single network element fails, goes into overload,
    or\n      suffers from reduced processing capacity, the mechanism should\n      strive
    to limit the impact of this on other elements in the\n      network.  This helps
    to prevent a small-scale failure from\n      becoming a widespread outage.\n   N/A
    if load-filtering policies are installed in advance and do not\n   change during
    the potential overload period, P/A if load-filtering\n   policies are dynamically
    adjusted.  The algorithm to dynamically\n   compute load-filtering policies is
    outside the scope of this\n   specification, while the distribution of the updated
    filtering\n   policies uses the event package mechanism of this specification.\n
    \     REQ 3: The mechanism should seek to minimize the amount of\n      configuration
    required in order to work.  For example, it is\n      better to avoid needing
    to configure a server with its SIP message\n      throughput, as these kinds of
    quantities are hard to determine.\n   No.  This mechanism is entirely dependent
    on advance configuration,\n   based on advance knowledge.  In order to satisfy
    REQ 3, it should be\n   used in conjunction with other mechanisms that are not
    based on\n   advance configuration.\n      REQ 4: The mechanism must be capable
    of dealing with elements that\n      do not support it, so that a network can
    consist of a mix of\n      elements that do and don't support it.  In other words,
    the\n      mechanism should not work only in environments where all elements\n
    \     support it.  It is reasonable to assume that it works better in\n      such
    environments, of course.  Ideally, there should be\n      incremental improvements
    in overall network throughput as\n      increasing numbers of elements in the
    network support the\n      mechanism.\n   No.  This mechanism is entirely dependent
    on the participation of all\n   possible neighbors.  In order to satisfy REQ 4,
    it should be used in\n   conjunction with other mechanisms, some of which are
    described in\n   Section 3.4.\n      REQ 5: The mechanism should not assume that
    it will only be\n      deployed in environments with completely trusted elements.
    \ It\n      should seek to operate as effectively as possible in environments\n
    \     where other elements are malicious; this includes preventing\n      malicious
    elements from obtaining more than a fair share of\n      service.\n   No.  This
    mechanism is entirely dependent on the non-malicious\n   participation of all
    possible neighbors.  In order to satisfy REQ 5,\n   it should be used in conjunction
    with other mechanisms, some of which\n   are described in Section 3.4.\n      REQ
    6: When overload is signaled by means of a specific message,\n      the message
    must clearly indicate that it is being sent because of\n      overload, as opposed
    to other, non overload-based failure\n      conditions.  This requirement is meant
    to avoid some of the\n      problems that have arisen from the reuse of the 503
    response code\n      for multiple purposes.  Of course, overload is also signaled
    by\n      lack of response to requests.  This requirement applies only to\n      explicit
    overload signals.\n   N/A.  This mechanism signals anticipated overload, not actual\n
    \  overload.  However, the signals in this mechanism are not used for\n   any
    other purpose.\n      REQ 7: The mechanism shall provide a way for an element
    to\n      throttle the amount of traffic it receives from an upstream\n      element.
    \ This throttling shall be graded so that it is not all-\n      or-nothing as
    with the current 503 mechanism.  This recognizes the\n      fact that \"overload\"
    is not a binary state and that there are\n      degrees of overload.\n   Yes.
    \ This event package allows rate-/loss-/window-based overload\n   control options
    as discussed in Section 5.4.\n      REQ 8: The mechanism shall ensure that, when
    a request was not\n      processed successfully due to overload (or failure) of
    a\n      downstream element, the request will not be retried on another\n      element
    that is also overloaded or whose status is unknown.  This\n      requirement derives
    from REQ 1.\n   N/A to the load-control event package mechanism itself.\n      REQ
    9: That a request has been rejected from an overloaded element\n      shall not
    unduly restrict the ability of that request to be\n      submitted to and processed
    by an element that is not overloaded.\n      This requirement derives from REQ
    1.\n   Yes.  For example, load-filtering policy (Section 3.1) can include\n   alternative
    forwarding destinations for rejected requests.\n      REQ 10: The mechanism should
    support servers that receive requests\n      from a large number of different
    upstream elements, where the set\n      of upstream elements is not enumerable.\n
    \  No.  Because this mechanism requires advance configuration of\n   specifically
    identified neighbors, it does not support environments\n   where the number and
    identity of the upstream neighbors are not known\n   in advance.  In order to
    satisfy REQ 10, it should be used in\n   conjunction with other mechanisms.\n
    \     REQ 11: The mechanism should support servers that receive requests\n      from
    a finite set of upstream elements, where the set of upstream\n      elements is
    enumerable.\n   Yes.  See also answer to REQ 10.\n      REQ 12: The mechanism
    should work between servers in different\n      domains.\n   Yes.  The load-control
    event package mechanism is not limited by\n   domain boundaries.  However, it
    is likely more applicable in intra-\n   domain scenarios than in inter-domain
    scenarios due to security and\n   other concerns (see also Section 3.4).\n      REQ
    13: The mechanism must not dictate a specific algorithm for\n      prioritizing
    the processing of work within a proxy during times of\n      overload.  It must
    permit a proxy to prioritize requests based on\n      any local policy, so that
    certain ones (such as a call for\n      emergency services or a call with a specific
    value of the\n      Resource-Priority header field [RFC4412]) are given preferential\n
    \     treatment, such as not being dropped, being given additional\n      retransmission,
    or being processed ahead of others.\n   P/A.  This mechanism does not specifically
    address the prioritizing\n   of work during times of overload.  But it does not
    preclude any\n   particular local policy.\n      REQ 14: The mechanism should
    provide unambiguous directions to\n      clients on when they should retry a request
    and when they should\n      not.  This especially applies to TCP connection establishment
    and\n      SIP registrations, in order to mitigate against avalanche restart.\n
    \  N/A to the load-control event package mechanism itself.\n      REQ 15: In cases
    where a network element fails, is so overloaded\n      that it cannot process
    messages, or cannot communicate due to a\n      network failure or network partition,
    it will not be able to\n      provide explicit indications of the nature of the
    failure or its\n      levels of congestion.  The mechanism must properly function
    in\n      these cases.\n   P/A.  Because the load-filtering policies are provisioned
    in advance,\n   they are not affected by the overload or failure of other network\n
    \  elements.  On the other hand, they may not, in those cases, be able\n   to
    protect the overloaded network elements (see REQ 1).\n      REQ 16: The mechanism
    should attempt to minimize the overhead of\n      the overload control messaging.\n
    \  Yes.  The standardized SIP event package mechanism [RFC6665] is used.\n      REQ
    17: The overload mechanism must not provide an avenue for\n      malicious attack,
    including DoS and DDoS attacks.\n   P/A.  This mechanism does provide a potential
    avenue for malicious\n   attacks.  Therefore, the security mechanisms for SIP
    event packages,\n   in general, [RFC6665] and Section 7 of this specification
    should be\n   used.\n      REQ 18: The overload mechanism should be unambiguous
    about whether\n      a load indication applies to a specific IP address, host,
    or URI,\n      so that an upstream element can determine the load of the entity\n
    \     to which a request is to be sent.\n   Yes.  The identity of load indication
    is covered in the load-\n   filtering policy format definition in Section 3.1.\n
    \     REQ 19: The specification for the overload mechanism should give\n      guidance
    on which message types might be desirable to process over\n      others during
    times of overload, based on SIP-specific\n      considerations.  For example,
    it may be more beneficial to process\n      a SUBSCRIBE refresh with Expires of
    zero than a SUBSCRIBE refresh\n      with a non-zero expiration (since the former
    reduces the overall\n      amount of load on the element), or to process re-INVITEs
    over new\n      INVITEs.\n   N/A to the load-control event package mechanism itself.\n
    \     REQ 20: In a mixed environment of elements that do and do not\n      implement
    the overload mechanism, no disproportionate benefit\n      shall accrue to the
    users or operators of the elements that do not\n      implement the mechanism.\n
    \  No.  This mechanism is entirely dependent on the participation of all\n   possible
    neighbors.  In order to satisfy REQ 20, it should be used in\n   conjunction with
    other mechanisms, some of which are described in\n   Section 3.4.\n      REQ 21:
    The overload mechanism should ensure that the system\n      remains stable.  When
    the offered load drops from above the\n      overall capacity of the network to
    below the overall capacity, the\n      throughput should stabilize and become
    equal to the offered load.\n   N/A to the load-control event package mechanism
    itself.\n      REQ 22: It must be possible to disable the reporting of load\n
    \     information towards upstream targets based on the identity of\n      those
    targets.  This allows a domain administrator who considers\n      the load of
    their elements to be sensitive information, to\n      restrict access to that
    information.  Of course, in such cases,\n      there is no expectation that the
    overload mechanism itself will\n      help prevent overload from that upstream
    target.\n   N/A to the load-control event package mechanism itself.\n      REQ
    23: It must be possible for the overload mechanism to work in\n      cases where
    there is a load balancer in front of a farm of\n      proxies.\n   Yes.  The load-control
    event package mechanism does not preclude its\n   use in a scenario with server
    farms.\n"
  title: Appendix C.  Discussion of How This Specification Meets the Requirements
- contents:
  - 'Appendix D.  Complete Examples

    '
  - contents:
    - "D.1.  Load-Control Document Examples\n   This section presents two complete
      examples of load-control documents\n   valid with respect to the XML schema
      defined in Section 6.\n   The first example assumes that a set of hotlines are
      set up at\n   \"sip:alice@hotline.example.com\" and \"tel:+1-212-555-1234\".
      \ The\n   hotlines are activated from 12:00 to 15:00 US Eastern Standard Time\n
      \  on 2008-05-31.  The goal is to limit the incoming calls to the\n   hotlines
      to 100 requests per second.  Calls that exceed the rate\n   limit are explicitly
      rejected.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\"\n
      \              xmlns:lc=\"urn:ietf:params:xml:ns:load-control\"\n               version=\"0\"
      state=\"full\">\n       <rule id=\"f3g44k1\">\n           <conditions>\n               <lc:call-identity>\n
      \                  <lc:sip>\n                       <lc:to>\n                           <one
      id=\"sip:alice@hotline.example.com\"/>\n                           <one id=\"tel:+1-212-555-1234\"/>\n
      \                      </lc:to>\n                   </lc:sip>\n               </lc:call-identity>\n
      \              <method>INVITE</method>\n               <validity>\n                   <from>2008-05-31T12:00:00-05:00</from>\n
      \                  <until>2008-05-31T15:00:00-05:00</until>\n               </validity>\n
      \          </conditions>\n           <actions>\n               <lc:accept alt-action=\"reject\">\n
      \                  <lc:rate>100</lc:rate>\n               </lc:accept>\n           </actions>\n
      \      </rule>\n   </ruleset>\n   The second example optimizes the usage of
      server resources during the\n   three-day period following a hurricane.  Incoming
      calls to the domain\n   \"sandy.example.com\" or to call destinations with prefix
      \"+1-212\" will\n   be limited to a rate of 100 requests per second, except
      for those\n   calls originating from a particular rescue team domain\n   \"rescue.example.com\".
      \ Outgoing calls from the hurricane domain or\n   calls within the local domain
      are never limited.  All calls that are\n   throttled due to the rate limit will
      be forwarded to an answering\n   machine with updated hurricane rescue information.\n
      \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\"\n
      \      xmlns:lc=\"urn:ietf:params:xml:ns:load-control\"\n       version=\"1\"
      state=\"full\">\n       <rule id=\"f3g44k2\">\n           <conditions>\n               <lc:call-identity>\n
      \                  <lc:sip>\n                       <lc:to>\n                           <many
      domain=\"sandy.example.com\"/>\n                           <many-tel prefix=\"+1-212\"/>\n
      \                      </lc:to>\n                       <lc:from>\n                           <many>\n
      \                              <except domain=\"sandy.example.com\"/>\n                               <except
      domain=\"rescue.example.com\"/>\n                           </many>\n                       </lc:from>\n
      \                  </lc:sip>\n               </lc:call-identity>\n               <method>INVITE</method>\n
      \              <validity>\n                   <from>2012-10-25T09:00:00+01:00</from>\n
      \                  <until>2012-10-28T09:00:00+01:00</until>\n               </validity>\n
      \          </conditions>\n           <actions>\n               <lc:accept alt-action=\"redirect\"
      alt-target=\n                       \"sip:sandy@update.example.com\">\n                   <lc:rate>100</lc:rate>\n
      \              </lc:accept>\n           </actions>\n       </rule>\n   </ruleset>\n
      \  Sometimes it may occur that multiple rules in a ruleset define\n   actions
      that match the same methods, call identity and validity.  In\n   those cases,
      the \"first-match-wins\" principle is used.  For example,\n   in the following
      ruleset, the first rule requires all calls from the\n   \"example.com\" domain
      to be rejected.  Even though the rule following\n   that one specifies that
      calls from \"sip:alice@example.com\" be\n   redirected to a specific target
      \"sip:eve@example.com\", the calls from\n   \"sip:alice@example.com\" will still
      be rejected because they have\n   already been matched by the earlier rule.\n
      \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\"\n
      \      xmlns:lc=\"urn:ietf:params:xml:ns:load-control\"\n       version=\"1\"
      state=\"full\">\n       <rule id=\"f3g44k3\">\n           <conditions>\n               <lc:call-identity>\n
      \                  <lc:sip>\n                       <lc:from>\n                           <many
      domain=\"example.com\"/>\n                       </lc:from>\n                   </lc:sip>\n
      \              </lc:call-identity>\n               <method>INVITE</method>\n
      \              <validity>\n                   <from>2013-7-2T09:00:00+01:00</from>\n
      \                  <until>2013-7-3T09:00:00+01:00</until>\n               </validity>\n
      \          </conditions>\n           <actions>\n               <lc:accept alt-action=\"reject\">\n
      \                  <lc:rate>0</lc:rate>\n               </lc:accept>\n           </actions>\n
      \      </rule>\n       <rule id=\"f3g44k4\">\n           <conditions>\n               <lc:call-identity>\n
      \                  <lc:sip>\n                       <lc:from>\n                           <one
      id=\"sip:alice@example.com\"/>\n                       </lc:from>\n                   </lc:sip>\n
      \              </lc:call-identity>\n               <method>INVITE</method>\n
      \              <validity>\n                   <from>2013-7-2T09:00:00+01:00</from>\n
      \                  <until>2013-7-3T09:00:00+01:00</until>\n               </validity>\n
      \          </conditions>\n           <actions>\n               <lc:accept alt-action=\"redirect\"
      alt-target=\n                       \"sip:eve@example.com\">\n                   <lc:rate>0</lc:rate>\n
      \              </lc:accept>\n           </actions>\n       </rule>\n   </ruleset>\n"
    title: D.1.  Load-Control Document Examples
  - contents:
    - "D.2.  Message Flow Examples\n   This section presents an example message flow
      of using the load-\n   control event package mechanism defined in this specification.\n
      \     atlanta             biloxi\n         | F1 SUBSCRIBE      |\n         |------------------>|\n
      \        | F2 200 OK         |\n         |<------------------|\n         | F3
      NOTIFY         |\n         |<------------------|\n         | F4 200 OK         |\n
      \        |------------------>|\n      F1 SUBSCRIBE atlanta.example.com -> biloxi.example.com\n
      \        SUBSCRIBE sip:biloxi.example.com SIP/2.0\n         Via: SIP/2.0/TCP
      atlanta.example.com;branch=z9hG4bKy7cjbu3\n         From: sip:atlanta.example.com;tag=162ab5\n
      \        To: sip:biloxi.example.com\n         Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com\n
      \        CSeq: 2012 SUBSCRIBE\n         Contact: sip:atlanta.example.com\n         Event:
      load-control\n         Max-Forwards: 70\n         Accept: application/load-control+xml\n
      \        Expires: 3600\n         Content-Length: 0\n      F2 200 OK   biloxi.example.com
      -> atlanta.example.com\n         SIP/2.0 200 OK\n         Via: SIP/2.0/TCP biloxi.example.com;branch=z9hG4bKy7cjbu3\n
      \          ;received=192.0.2.1\n         To: <sip:biloxi.example.com>;tag=331dc8\n
      \        From: <sip:atlanta.example.com>;tag=162ab5\n         Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com\n
      \        CSeq: 2012 SUBSCRIBE\n         Expires: 3600\n         Contact: sip:biloxi.example.com\n
      \        Content-Length: 0\n      F3 NOTIFY  biloxi.example.com -> atlanta.example.com\n
      \        NOTIFY sip:atlanta.example.com SIP/2.0\n         Via: SIP/2.0/TCP biloxi.example.com;branch=z9hG4bKy71g2ks\n
      \        From: <sip:biloxi.example.com>;tag=331dc8\n         To: <sip:atlanta.example.com>;tag=162ab5\n
      \        Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com\n         Event: load-control\n
      \        Subscription-State: active;expires=3599\n         Max-Forwards: 70\n
      \        CSeq: 1775 NOTIFY\n         Contact: sip:biloxi.example.com\n         Content-Type:
      application/load-control+xml\n         Content-Length: ...\n         [Load-Control
      Document]\n      F4 200 OK atlanta.example.com -> biloxi.example.com\n         SIP/2.0
      200 OK\n         Via: SIP/2.0/TCP atlanta.example.com;branch=z9hG4bKy71g2ks\n
      \          ;received=192.0.2.2\n         From: <sip:biloxi.example.com>;tag=331dc8\n
      \        To: <sip:atlanta.example.com>;tag=162ab5\n         Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com\n
      \        CSeq: 1775 NOTIFY\n         Content-Length: 0\n"
    title: D.2.  Message Flow Examples
  title: Appendix D.  Complete Examples
- contents:
  - 'Appendix E.  Related Work

    '
  - contents:
    - "E.1.  Relationship to Load Filtering in PSTN\n   It is known that an existing
      PSTN network also uses a load-filtering\n   mechanism to prevent overload and
      the filtering policy configuration\n   is done manually except in specific cases
      when the Intelligent\n   Network architecture is used [Q.1248.2][E.412].  This
      specification\n   defines a load-filtering mechanism based on the SIP event\n
      \  notification framework that allows automated filtering policy\n   distribution
      in suitable environments.\n   PSTN overload control uses messages that specify
      an outgoing control\n   list, call gap duration, and control duration [Q.1248.2][E.412].\n
      \  These items correspond roughly to the identity, action, and time\n   fields
      of the SIP load-filtering policy defined in this\n   specification.  However,
      the load-filtering policy defined in this\n   specification is much more generic
      and flexible as opposed to its\n   PSTN counterpart.\n   Firstly, PSTN load
      filtering only applies to telephone numbers.  The\n   identity element of SIP
      load-filtering policy allows both SIP URI and\n   telephone numbers (through
      'tel' URI) to be specified.  These\n   identities can be arbitrarily grouped
      by SIP domains or any number of\n   leading prefixes of the telephone numbers.\n
      \  Secondly, the PSTN load-filtering action is usually limited to call\n   gapping.
      \ The action field in SIP load-filtering policy allows more\n   flexible possibilities
      such as rate throttle and others.\n   Thirdly, the duration field in PSTN load
      filtering specifies a value\n   in seconds for the load-filtering duration only,
      and the allowed\n   values are mapped into a value set.  The time field in SIP
      load-\n   filtering policy may specify not only a duration, but also a future\n
      \  activation time that could be especially useful for automating load\n   filtering
      for predictable overloads.\n   PSTN load filtering can be performed in both
      edge switches and\n   transit switches; the SIP load filtering can also be applied
      in both\n   edge proxy servers and core proxy servers, and even in capable user\n
      \  agents.\n   PSTN load filtering also has special accommodation for High\n
      \  Probability of Completion (HPC) calls, which would be similar to\n   calls
      designated by the SIP Resource Priority Headers [RFC4412].  The\n   SIP load-filtering
      mechanism also allows prioritizing the treatment\n   of these calls by specifying
      favorable actions for them.\n   PSTN load filtering also provides an administrative
      option for\n   routing failed call attempts to either a reorder tone [E.300SerSup3]\n
      \  indicating overload conditions or a special recorded announcement.  A\n   similar
      capability can be provided in the SIP load-filtering\n   mechanism by specifying
      appropriate \"alt-action\" attribute in the SIP\n   load-filtering action field.\n"
    title: E.1.  Relationship to Load Filtering in PSTN
  - contents:
    - "E.2.  Relationship with Other IETF SIP Overload Control Efforts\n   The load-filtering
      policies in this specification consist of\n   identity, action, and time.  The
      identity can range from a single\n   specific user to an arbitrary user aggregate,
      domains, or areas.  The\n   user can be identified by either the source or the
      destination.  When\n   the user is identified by the source and a favorable
      action is\n   specified, the result is, to some extent, similar to identifying
      a\n   priority user based on authorized Resource Priority Headers [RFC4412]\n
      \  in the requests.  Specifying a source user identity with an\n   unfavorable
      action would cause an effect to some extent similar to an\n   inverse SIP resource
      priority mechanism.\n   The load-filtering policy defined in this specification
      is generic\n   and expected to be applicable not only to the load-filtering\n
      \  mechanism but also to the feedback overload control mechanism in\n   [SIP-OVERLOAD].
      \ In particular, both mechanisms could use specific or\n   wildcard identities
      for load control and could share well-known load-\n   control actions.  The
      time duration field in the load-filtering\n   policy could also be used in both
      mechanisms.  As mentioned in\n   Section 1, the load-filtering policy distribution
      mechanism and the\n   feedback overload control mechanism address complementary
      areas in\n   the overload control problem space.  Load filtering is more proactive\n
      \  and focuses on distributing filtering policies towards the source of\n   the
      traffic; the hop-by-hop feedback-based approach is reactive and\n   reduces
      traffic already accepted by the network.  Therefore, they\n   could also make
      different use of the generic load-filtering policy\n   components.  For example,
      the load-filtering mechanism may use the\n   time field in the filtering policy
      to specify not only a control\n   duration but also a future activation time
      to accommodate a\n   predicable overload such as the one caused by Mother's
      Day greetings\n   or a viewer-voting program; the feedback-based control might
      not need\n   to use the time field or might use the time field to specify an\n
      \  immediate load-control duration.\n"
    title: E.2.  Relationship with Other IETF SIP Overload Control Efforts
  title: Appendix E.  Related Work
- contents:
  - "Authors' Addresses\n   Charles Shen\n   Columbia University\n   Department of
    Computer Science\n   1214 Amsterdam Avenue, MC 0401\n   New York, NY   10027\n
    \  USA\n   Phone: +1 212 854 3109\n   EMail: charles@cs.columbia.edu\n   Henning
    Schulzrinne\n   Columbia University\n   Department of Computer Science\n   1214
    Amsterdam Avenue, MC 0401\n   New York, NY   10027\n   USA\n   Phone: +1 212 939
    7004\n   EMail: schulzrinne@cs.columbia.edu\n   Arata Koike\n   NTT Network Technology
    Labs\n   3-9-11 Midori-cho Musashino-shi\n   Tokyo  180-8585\n   Japan\n   Phone:
    +81 422 59 6099\n   EMail: koike.arata@lab.ntt.co.jp\n"
  title: Authors' Addresses
