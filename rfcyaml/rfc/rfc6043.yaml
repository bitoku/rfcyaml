- title: __initial_text__
  contents:
  - "          MIKEY-TICKET: Ticket-Based Modes of Key Distribution\n            \
    \     in Multimedia Internet KEYing (MIKEY)\n"
- title: Abstract
  contents:
  - "Abstract\n   The Multimedia Internet KEYing (MIKEY) specification describes a\
    \ key\n   management scheme for real-time applications.  In this document, we\n\
    \   note that the currently defined MIKEY modes are insufficient to\n   address\
    \ deployment scenarios built around a centralized key\n   management service.\
    \  Interest in such deployments is increasing.\n   Therefore, a set of new MIKEY\
    \ modes that work well in such scenarios\n   are defined.  The new modes use a\
    \ trusted key management service and\n   a ticket concept, similar to that in\
    \ Kerberos.  The new modes also\n   support features used by many existing applications,\
    \ where the exact\n   identity of the other endpoint may not be known at the start\
    \ of the\n   communication session.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6043.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Terminology .....................................................4\n  \
    \    2.1. Definitions and Notation ...................................5\n    \
    \  2.2. Abbreviations ..............................................6\n      2.3.\
    \ Payloads ...................................................6\n   3. Design\
    \ Considerations ...........................................7\n   4. MIKEY-TICKET\
    \ ....................................................9\n      4.1. Overview ...................................................9\n\
    \           4.1.1. Modes ..............................................12\n  \
    \    4.2. Exchanges .................................................13\n    \
    \       4.2.1. Ticket Request .....................................13\n      \
    \     4.2.2. Ticket Transfer ....................................16\n        \
    \   4.2.3. Ticket Resolve .....................................19\n   5. Key Management\
    \ Functions .......................................23\n      5.1. Key Derivation\
    \ ............................................23\n           5.1.1. Deriving Forked\
    \ Keys ...............................25\n           5.1.2. Deriving Keys from\
    \ an Envelope Key/PSK/MPK .........26\n           5.1.3. Deriving Keys from a\
    \ TGK/GTGK ......................27\n      5.2. CSB Updating ..............................................28\n\
    \      5.3. Ticket Reuse ..............................................29\n  \
    \    5.4. Error Handling ............................................29\n    \
    \  5.5. MAC/Signature Coverage ....................................30\n   6. Payload\
    \ Encoding ...............................................31\n      6.1. Common\
    \ Header Payload (HDR) ...............................31\n           6.1.1. The\
    \ GENERIC-ID Map Type ............................33\n      6.2. Key Data Transport\
    \ Payload (KEMAC) ........................34\n           6.2.1. Key Data Sub-Payload\
    \ ...............................35\n      6.3. Timestamp Payload (T) .....................................36\n\
    \      6.4. Timestamp Payload with Role Indicator (TR) ................36\n  \
    \    6.5. ID Payload (ID) ...........................................37\n    \
    \  6.6. ID Payload with Role Indicator (IDR) ......................37\n      6.7.\
    \ Cert Hash Payload (CHASH) .................................38\n      6.8. RAND\
    \ Payload with Role Indicator (RANDR) ..................38\n      6.9. Error Payload\
    \ (ERR) .......................................39\n      6.10. Ticket Policy Payload\
    \ (TP) / Ticket Payload (TICKET) .....39\n   7. Transport Protocols ............................................43\n\
    \   8. Pre-Encrypted Content ..........................................43\n  \
    \ 9. Group Communication ............................................44\n    \
    \  9.1. Key Forking ...............................................45\n   10.\
    \ Signaling between Different KMSs ..............................45\n   11. Adding\
    \ New Ticket Types to MIKEY-TICKET .......................46\n   12. Security\
    \ Considerations .......................................47\n      12.1. General\
    \ ..................................................47\n      12.2. Key Forking\
    \ ..............................................48\n      12.3. Denial of Service\
    \ ........................................49\n      12.4. Replay ...................................................49\n\
    \      12.5. Group Key Management .....................................50\n  \
    \ 13. Acknowledgements ..............................................50\n   14.\
    \ IANA Considerations ...........................................50\n   15. References\
    \ ....................................................53\n      15.1. Normative\
    \ References .....................................53\n      15.2. Informative\
    \ References ...................................53\n   Appendix A.  MIKEY Base\
    \ Ticket ....................................55\n     A.1.  Components of the\
    \ Ticket Data .............................55\n     A.2.  Key Derivation ............................................56\n\
    \       A.2.1.  Deriving Keys from a TPK ..............................56\n  \
    \     A.2.2.  Deriving MPKi and MPKr ................................57\n    \
    \ A.3.  Ticket Header Payload (THDR) ..............................57\n   Appendix\
    \ B.  Alternative Use Cases ................................58\n     B.1.  Compatibility\
    \ Mode ........................................58\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Key management systems are either based on negotiation and\
    \ exchange\n   directly between peers (e.g., Diffie-Hellman-based schemes), pre-\n\
    \   distribution of user credentials (shared secrets/certificates), or\n   availability\
    \ of a trusted Key Management Service (KMS).  The modes\n   described in the Multimedia\
    \ Internet KEYing (MIKEY) specification\n   [RFC3830] and its extensions [RFC4650]\
    \ [RFC4738] are all variants of\n   the first two alternatives.\n   In security\
    \ systems serving a large number of users, a solution based\n   on a key management\
    \ service is often preferred.  With such a service\n   in place, there is no need\
    \ to pre-distribute credentials that\n   directly can be used to establish security\
    \ associations between peers\n   for protected communication, as users can request\
    \ such credentials\n   when needed.  Solutions based on a trusted key management\
    \ service\n   also scale well when the number of users grows.\n   This document\
    \ introduces a set of new MIKEY modes that go under the\n   common name MIKEY-TICKET.\
    \  The new modes support a ticket concept,\n   similar to that in Kerberos [RFC4120],\
    \ which is used to identify and\n   deliver keys.  A high-level outline of MIKEY-TICKET\
    \ as defined herein\n   is that the Initiator requests keys and a ticket from\
    \ the KMS and\n   sends the ticket to the Responder.  The ticket contains a reference\n\
    \   to the keys, or the enveloped keys.  The Responder then sends the\n   ticket\
    \ to the KMS, which returns the appropriate keys.\n   MIKEY-TICKET is primarily\
    \ designed to be used for media plane\n   security in the 3rd Generation Partnership\
    \ Project (3GPP) IP\n   Multimedia Subsystem (IMS) [3GPP.33.328].  This implies\
    \ that some\n   extensions to the basic Kerberos concept are needed.  For instance,\n\
    \   the Initiator may not always know the exact identity of the Responder\n  \
    \ when the communication with the key management server is initiated.\n   This\
    \ document defines a signaling framework enabling peers to\n   request, transfer,\
    \ and resolve various Ticket Types using a key\n   management service.  A default\
    \ Ticket Type is also defined.  To allow\n   the use of 256-bit keys for users\
    \ with high security requirements,\n   additional encryption, authentication,\
    \ and pseudorandom functions are\n   defined.  And to eliminate the limitations\
    \ with the existing SRTP-ID\n   map type, a new CS ID map type called GENERIC-ID\
    \ is defined.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   Definitions of terms and notation will, unless otherwise stated, be\n   as\
    \ defined in [RFC3830].\n"
- title: 2.1.  Definitions and Notation
  contents:
  - "2.1.  Definitions and Notation\n   Forking: The delivery of a request to multiple\
    \ endpoints (multiple\n   devices owned by a single user or multiple users).\n\
    \   Key forking: When used in conjunction with forking, key forking\n   refers\
    \ to the process of modifying keys, making them\n   cryptographically unique for\
    \ each responder targeted by the forking.\n   (Media) session: The communication\
    \ session intended to be secured by\n   the MIKEY-TICKET provided key(s).\n  \
    \ Session information: Information related to the security protocols\n   used\
    \ to protect the media session: keys, salts, algorithms, etc.\n   Ticket: A Kerberos-like\
    \ object used to identify and deliver keys over\n   an untrusted network.\n  \
    \ Ticket Data: Ticket part with information intended only for the party\n   that\
    \ resolves the ticket (e.g., keys).\n   Ticket Request: Exchange used by the Initiator\
    \ to request keys and a\n   ticket from a trusted KMS.\n   Ticket Transfer: Exchange\
    \ used to transfer the ticket as well as\n   session information from the Initiator\
    \ to the Responder.\n   Ticket Resolve: Exchange used by the Responder to request\
    \ the KMS to\n   return the keys encoded in a ticket.\n   Ticket Policy: Policy\
    \ for ticket generation and resolution,\n   authorized applications, key derivation,\
    \ etc.\n   Ticket Type: Defines ticket format and processing.  May further have\n\
    \   subtype and version.\n   Solid arrows  (----->) indicate mandatory messages.\n\
    \   Dashed arrows (- - ->) indicate optional messages.\n   E(k, p)   Encryption\
    \ of p with the key k\n   PKx       Public Key of entity x\n   k'        The forked\
    \ key k\n   [p]       p is optional\n   {p}       Zero or more occurrences of\
    \ p\n   (p)       One or more occurrences of p\n   ||        Concatenation\n \
    \  |         OR (selection operator)\n"
- title: 2.2.  Abbreviations
  contents:
  - "2.2.  Abbreviations\n   3GPP:     3rd Generation Partnership Project\n   AAA:\
    \      Authentication, Authorization, and Accounting\n   ACL:      Access Control\
    \ List\n   AES:      Advanced Encryption Standard\n   CA:       Certification\
    \ Authority\n   CS:       Crypto Session\n   CSB:      Crypto Session Bundle\n\
    \   IMS:      IP Multimedia Subsystem\n   GTGK:     Group TGK\n   HMAC:     Hash-based\
    \ Message Authentication Code\n   KMS:      Key Management Service\n   MAC:  \
    \    Message Authentication Code\n   MIKEY:    Multimedia Internet KEYing\n  \
    \ NSPS:     National Security and Public Safety\n   MKI:      Master Key Identifier\n\
    \   MPK:      MIKEY Protection Key\n   NTP:      Network Time Protocol\n   PET:\
    \      Privacy Enhancing Technologies\n   PK:       Public Key\n   PRF:      Pseudorandom\
    \ Function\n   PRNG:     Pseudorandom Number Generator\n   PSK:      Pre-Shared\
    \ Key\n   RTSP:     Real Time Streaming Protocol\n   SDP:      Session Description\
    \ Protocol\n   SHA:      Secure Hash Algorithm\n   SIP:      Session Initiation\
    \ Protocol\n   SPI:      Security Parameters Index\n   SRTP:     Secure Realtime\
    \ Transport Protocol\n   TEK:      Traffic Encryption Key\n   TGK:      TEK Generation\
    \ Key\n   TPK:      Ticket Protection Key\n   UTC:      Coordinated Universal\
    \ Time\n"
- title: 2.3.  Payloads
  contents:
  - "2.3.  Payloads\n   CERTx:    Certificate of entity x\n   CHASH:    Hash of the\
    \ certificate used\n   HDR:      Common Header payload\n   ID:       Identity\
    \ payload\n   IDRx:     Identifier for entity x\n   IDRpsk:   Identifier for pre-shared\
    \ key\n   IDRapp:   Identifier for application/service\n   KEMAC:    Key data\
    \ transport payload\n   PKE:      Encrypted envelope key\n   RAND:     RAND payload\n\
    \   RANDRx:   Random value generated by entity x\n   SIGNx:    Signature created\
    \ using entity x's private key\n   SP:       Security Policy payload\n   T:  \
    \      Timestamp payload\n   TRy:      Timestamp payload with role indicator y\n\
    \   THDR:     Ticket Header payload\n   TICKET:   Ticket payload\n   TP:     \
    \  Ticket Policy payload\n   V:        Verification payload\n   where\n      x\
    \ is in the set {i, r, kms} (Initiator, Responder, KMS) and\n      y is in the\
    \ set {i, s, e, r} (time of Issue, Start time, End time,\n         Rekeying interval).\n\
    \   The IDR, RANDR, TR, TICKET, and TP payloads are defined in Section 6.\n  \
    \ Note that in [RFC3830], there is defined both a V payload (carrying\n   the\
    \ authentication tag) and a V flag in the HDR payload (indicating\n   whether\
    \ or not a response message is expected).\n"
- title: 3.  Design Considerations
  contents:
  - "3.  Design Considerations\n   As mentioned in the introduction, none of the previously\
    \ defined\n   MIKEY modes are based on a KMS.  The pre-shared key method and the\n\
    \   public-key encryption method defined in [RFC3830] are examples of\n   systems\
    \ based on pre-distribution of user credentials.  The Diffie-\n   Hellman method\
    \ [RFC3830] is an example of a system based on\n   negotiation and exchange directly\
    \ between peers.\n   In some situations, a request may be delivered to multiple\
    \ endpoints.\n   The endpoints may be multiple devices owned by a single user\
    \ (e.g.,\n   mobile phone, fixed phone, and computer), or multiple users (e.g.,\n\
    \   IT-support@example.com, a group of users where only one is supposed\n   to\
    \ answer).  In the following, the term \"forking\" will be used to\n   describe\
    \ all such cases.  One example of delivery to multiple\n   endpoints is forking\
    \ and retargeting in SIP [RFC3261].  To prevent\n   any form of eavesdropping,\
    \ only the endpoint that answers should get\n   access to the session keys.  The\
    \ naive application of [RFC3830] where\n   all endpoints share the same pre-shared/private\
    \ key is not secure\n   when it comes to forking, as all endpoints get access\
    \ to the session\n   keys.  Conversely, having per-user unique pre-shared keys/\n\
    \   certificates creates more fundamental problems with forking, as the\n   initiator\
    \ does not know which pre-shared key/certificate to use at\n   session initiation.\
    \  SIP-signaled media protection is described in\n   [RFC5479] and the applicability\
    \ of different MIKEY modes is discussed\n   in [RFC5197].\n   In security systems\
    \ serving a large number of users, a solution based\n   on a key management service\
    \ is often preferred.  With such a service\n   in place, there is no need to pre-distribute\
    \ credentials that\n   directly can be used to establish security associations\
    \ between peers\n   for protected communication, as users can request such credentials\n\
    \   when needed.  In many applications, e.g., National Security and\n   Public\
    \ Safety (NSPS), the controlling organization wants to enforce\n   policies on\
    \ the use of keys.  A trusted KMS fits these applications\n   well, as it makes\
    \ it easier to enforce policies centrally.  Solutions\n   based on a trusted KMS\
    \ also scale well when the number of users\n   grows.  A KMS based on symmetric\
    \ keys has particular advantages, as\n   symmetric key algorithms are generally\
    \ much less computationally\n   intensive than asymmetric key algorithms.\n  \
    \ Systems based on a KMS require a signaling mechanism that allows\n   peers to\
    \ retrieve other peers' credentials.  A convenient way to\n   implement such a\
    \ signaling scheme is to use a ticket concept, similar\n   to that in Kerberos\
    \ [RFC4120] to identify and deliver keys.  The\n   ticket can be forwarded in\
    \ the signaling associated with the session\n   setup.  The initiator requests\
    \ a ticket from the KMS and sends the\n   ticket to the responder.  The responder\
    \ forwards the ticket to the\n   KMS, which returns the corresponding keys.\n\
    \   It should be noted that Kerberos does not require that the responder\n   also\
    \ contact the KMS.  However, in order to support also the\n   aforementioned forking\
    \ scenarios, it becomes necessary that the\n   ticket is not bound to the exact\
    \ identity (or credentials) of the\n   responder until the final responder becomes\
    \ fully determined.  Group\n   and forking communication scenarios can also be\
    \ improved from access\n   control point of view if authorization to access the\
    \ keys can be\n   enforced with higher granularity at the responder side.  The\n\
    \   mechanism specified in this document is useful for any system where\n   the\
    \ initial message may be transferred to arbitrarily many potential\n   responders\
    \ and where the set of responders may change at any time.\n   In addition to being\
    \ able to meet the requirements just described,\n   the mechanism specified in\
    \ this document also supports group key\n   management.\n   The ticket can contain\
    \ a reference to keys held by the key management\n   system or it can hold the\
    \ keys itself.  In the latter case, the\n   ticket needs to be confidentiality\
    \ and integrity protected\n   (enveloped).  In the following, the term \"encoded\
    \ keys\" will be used\n   to describe both cases as well as keys derived from\
    \ such keys.\n   By using different Ticket Types and ticket policies, some allowing\n\
    \   the initiator or responder to create or resolve the tickets without\n   assistance\
    \ from the KMS, a wide range of different security levels\n   and use cases can\
    \ be supported.  This has a number of advantages, as\n   it offers a framework\
    \ that is flexible enough to satisfy users with a\n   broad range of security\
    \ and functional needs.\n   The use of a ticket-based system may also help in\
    \ the handling of\n   keys for deferred delivery of end-to-end protected content\
    \ to\n   currently offline users.  Such scenarios exclude all key management\n\
    \   schemes that are based on some type of direct online negotiation\n   between\
    \ peers (e.g., Diffie-Hellman-based schemes) as the responder\n   cannot rely\
    \ on contacting the initiator to get access to keys.\n   At the same time, it\
    \ is also important to be aware that (centralized)\n   key management services\
    \ may introduce a single point of (security)\n   failure.  The security requirements\
    \ on the implementation and\n   protection of the KMS may therefore, in high-security\
    \ applications,\n   be more or less equivalent to the requirements of an AAA\n\
    \   (Authentication, Authorization, and Accounting) server or a\n   Certification\
    \ Authority (CA).\n"
- title: 4.  MIKEY-TICKET
  contents:
  - '4.  MIKEY-TICKET

    '
- title: 4.1.  Overview
  contents:
  - "4.1.  Overview\n   All previously defined MIKEY modes consist of a single (or\
    \ half)\n   round trip between two peers.  MIKEY-TICKET differs from these modes\n\
    \   as it consists of up to three different round trips (Ticket Request,\n   Ticket\
    \ Transfer, and Ticket Resolve) involving three parties\n   (Initiator, Responder,\
    \ and KMS).  Since the number of round trips and\n   order of messages may vary,\
    \ MIKEY-TICKET is actually the common name\n   for a set of modes, all revolving\
    \ around a ticket concept.  The third\n   party, the KMS, is only involved in\
    \ some of the MIKEY exchanges and\n   not at all in the resulting secure media\
    \ session.  The Ticket Request\n   and Ticket Resolve exchanges are meant to be\
    \ used in combination with\n   the Ticket Transfer exchange and not on their own.\
    \  In Figure 1, the\n   signaling for the full three round-trip MIKEY-TICKET mode\
    \ is\n   depicted.\n   +---+                          +-----+                \
    \          +---+\n   | I |                          | KMS |                  \
    \        | R |\n   +---+                          +-----+                    \
    \      +---+\n               REQUEST_INIT\n     -------------------------------->\n\
    \               REQUEST_RESP\n     <--------------------------------\n       \
    \                        TRANSFER_INIT\n     ---------------------------------------------------------------->\n\
    \                                                RESOLVE_INIT\n              \
    \                       <--------------------------------\n                  \
    \                              RESOLVE_RESP\n                                \
    \     -------------------------------->\n                               TRANSFER_RESP\n\
    \     <----------------------------------------------------------------\n    \
    \             Figure 1: Full three round-trip signaling\n   The Initiator (I)\
    \ wants to establish a secure media session with the\n   Responder (R).  The Initiator\
    \ and the Responder do not share any\n   credentials; instead, they trust a third\
    \ party, the KMS, with which\n   they both have or can establish shared credentials.\
    \  These pre-\n   established trust relations are used to establish a security\n\
    \   association between I and R.  The assumed trust model is illustrated\n   in\
    \ Figure 2.\n      Pre-established trust relation   Pre-established trust relation\n\
    \     <------------------------------> <------------------------------>\n   +---+\
    \                          +-----+                          +---+\n   | I |  \
    \                        | KMS |                          | R |\n   +---+    \
    \                      +-----+                          +---+\n     <--------------------------------------------------------------->\n\
    \                   Security association based on ticket\n                   \
    \        Figure 2: Trust model\n   Note that rather than a single KMS, multiple\
    \ KMSs may be involved,\n   e.g., one for the Initiator and one for the Responder;\
    \ this is\n   discussed in Section 10.\n   The Initiator requests keys and a ticket\
    \ (encoding the same keys)\n   from the KMS by sending a REQUEST_INIT message.\
    \  The REQUEST_INIT\n   message includes session information (e.g., identities\
    \ of the\n   authorized responders) and is integrity protected by a MAC based\
    \ on a\n   pre-shared key or by a signature (similar to the pre-shared key and\n\
    \   public-key encryption modes in [RFC3830]).  If the request is\n   authorized,\
    \ the KMS generates the requested keys, encodes them in a\n   ticket, and returns\
    \ the keys and the ticket in a REQUEST_RESP\n   message.  The Ticket Request exchange\
    \ is OPTIONAL (depending on the\n   Ticket Type), and MAY be omitted if the Initiator\
    \ can create the\n   ticket without assistance from the KMS (see mode 3 of Section\
    \ 4.1.1).\n   The Initiator next includes the ticket in a TRANSFER_INIT message,\n\
    \   which is sent to the Responder.  The TRANSFER_INIT message is\n   protected\
    \ by a MAC based on an MPK (MIKEY Protection Key) encoded in\n   the ticket. \
    \ If the Responder finds the Ticket Policy and session\n   security policies acceptable,\
    \ the Responder forwards the ticket to\n   the KMS.  This is done with a RESOLVE_INIT\
    \ message, which asks the\n   KMS to return the keys encoded in the ticket.  The\
    \ RESOLVE_INIT\n   message is protected by a MAC based on a pre-shared key (between\n\
    \   Responder and KMS) or by a signature.  The Ticket Resolve exchange is\n  \
    \ OPTIONAL (depending on the Ticket Policy), and SHOULD only be used\n   when\
    \ the Responder is unable to resolve the ticket without assistance\n   from the\
    \ KMS (see mode 2 of Section 4.1.1).\n   The KMS resolves the ticket.  If the\
    \ Responder is authorized to\n   receive the keys encoded in the ticket, the KMS\
    \ retrieves the keys\n   and other information.  If key forking is used, the keys\
    \ are modified\n   (bound to the Responder) by the KMS, see Section 5.1.1.  The\
    \ keys and\n   additional information are then sent in a RESOLVE_RESP message\
    \ to the\n   Responder.  The Responder then sends a TRANSFER_RESP message to the\n\
    \   Initiator as verification.  The TRANSFER_RESP message might include\n   information\
    \ used for further key derivation.\n   The use case and signaling described above\
    \ is the full three round-\n   trip mode, but other modes are allowed, see Section\
    \ 4.1.1.  Pre-\n   encrypted content is discussed in Section 8, group communication\
    \ is\n   discussed in Section 9, and signaling between different KMSs is\n   discussed\
    \ in Section 10.  An alternative use case is discussed in\n   Appendix B.\n  \
    \ The session keys are normally generated/supplied by the KMS (encoded\n   in\
    \ the ticket), but in certain use cases (see Section 8) the session\n   key may\
    \ be supplied by the Initiator or Responder (sent in a separate\n   KEMAC protected\
    \ with keys derived from the MPK).\n   MIKEY-TICKET offers a framework that is\
    \ flexible enough to satisfy\n   users with a broad range of security and functional\
    \ needs.  The\n   framework consists of the three exchanges for which different\
    \ Ticket\n   Types can be defined.  The ticket consists of a Ticket Policy as\
    \ well\n   as Ticket Data.  The Ticket Policy contains information intended for\n\
    \   all parties involved, whereas the Ticket Data is only intended for\n   the\
    \ party that resolves the ticket.  The Ticket Data could be a\n   reference to\
    \ information (keys, etc.) stored by the key management\n   service, it could\
    \ contain all the information itself, or it could be\n   a combination of the\
    \ two alternatives.  The format of the Ticket Data\n   depends on the Ticket Type\
    \ signaled in the Ticket Policy.  The Ticket\n   Data corresponding to the default\
    \ Ticket Type, called MIKEY base\n   ticket, is defined in Appendix A and requirements\
    \ regarding new\n   Ticket Types are given in Section 11.\n   As MIKEY-TICKET\
    \ is based on [RFC3830], the same terminology,\n   processing, and considerations\
    \ still apply unless otherwise stated.\n   Just like in [RFC3830], the messages\
    \ are integrity protected and\n   encryption is only applied to the keys and not\
    \ to the entire\n   messages.\n"
- title: 4.1.1.  Modes
  contents:
  - "4.1.1.  Modes\n   Depending on the Ticket Type and the Ticket Policy, some of\
    \ the\n   exchanges might be optional or not used at all, see Figure 3.  If the\n\
    \   ticket protection is based on a key known only by the KMS, both the\n   Initiator\
    \ and the Responder have to contact the KMS to request/\n   resolve tickets (mode\
    \ 1).  If the key used to protect the ticket is\n   shared between the KMS and\
    \ the Responder, the Ticket Resolve exchange\n   can be omitted (similar to Kerberos),\
    \ as the Responder can resolve\n   the ticket without assistance from the KMS\
    \ (mode 2).\n     +---+                         +-----+                      \
    \   +---+\n     | I |                         | KMS |                        \
    \ | R |\n     +---+                         +-----+                         +---+\n\
    \                Ticket Request\n   (1) <------------------------------>     \
    \   Ticket Transfer\n       <------------------------------------------------------------->\n\
    \                                      <------------------------------>\n    \
    \                                           Ticket Resolve\n                Ticket\
    \ Request\n   (2) <------------------------------>        Ticket Transfer\n  \
    \     <------------------------------------------------------------->\n      \
    \                         Ticket Transfer\n   (3) <------------------------------------------------------------->\n\
    \                                      <------------------------------>\n    \
    \                                           Ticket Resolve\n                 \
    \              Ticket Transfer\n   (4) <------------------------------------------------------------->\n\
    \                              Figure 3: Modes\n   If the key protecting the ticket\
    \ is shared between the Initiator and\n   the KMS, the Ticket Request exchange\
    \ can be omitted (similar to the\n   Otway-Rees protocol [Otway-Rees]), as the\
    \ Initiator can create the\n   ticket without assistance from the KMS (mode 3).\
    \  If the key\n   protecting the ticket is shared between the Initiator and the\n\
    \   Responder, both the Ticket Request and Ticket Resolve exchanges can\n   be\
    \ omitted (mode 4).  This can be seen as a variation of the pre-\n   shared key\
    \ method of [RFC3830] with a mutual key-freshness guarantee.\n   In modes 1 and\
    \ 2, the Ticket Request exchange can be omitted if the\n   tickets and the corresponding\
    \ keys are distributed from the KMS to\n   the Initiator in some other way.  In\
    \ addition, as tickets may be\n   reused (see Section 5.3), a single Ticket Request\
    \ exchange may be\n   followed by several Ticket Transfer exchanges.\n"
- title: 4.2.  Exchanges
  contents:
  - '4.2.  Exchanges

    '
- title: 4.2.1.  Ticket Request
  contents:
  - "4.2.1.  Ticket Request\n   This exchange is used by the Initiator to request\
    \ keys and a ticket\n   from a trusted KMS with which the Initiator has pre-shared\n\
    \   credentials.  The request contains information (e.g., participant\n   identities,\
    \ etc.) describing the session the ticket is intended to\n   protect.  A full\
    \ round trip is required for the Initiator to receive\n   the ticket.  The initial\
    \ message REQUEST_INIT comes in two variants.\n   The first variant corresponds\
    \ to the pre-shared key (PSK) method of\n   [RFC3830].\n   Initiator         \
    \                      KMS\n   REQUEST_INIT_PSK =              ---->\n   HDR,\
    \ T, RANDRi, [IDRi],\n      [IDRkms], TP,                 <----  REQUEST_RESP\
    \ =\n      [IDRpsk], V                          HDR, T, [IDRkms],\n          \
    \                                    TICKET, KEMAC, V\n   The second variant corresponds\
    \ to the public-key (PK) method of\n   [RFC3830].\n   Initiator              \
    \                 KMS\n   REQUEST_INIT_PK =               ---->\n   HDR, T, RANDRi,\
    \ [IDRi],\n      {CERTi}, [IDRkms], TP,        <----  REQUEST_RESP =\n      [CHASH],\
    \ PKE, SIGNi                  HDR, T, [IDRkms],\n                            \
    \                  TICKET, KEMAC, V\n   As the REQUEST_INIT message MUST ensure\
    \ the identity of the Initiator\n   to the KMS, it SHALL be integrity protected\
    \ by a MAC based on a pre-\n   shared key or by a signature.  The response message\
    \ REQUEST_RESP is\n   the same for the two variants and SHALL be protected using\
    \ the pre-\n   shared/envelope key indicated in the REQUEST_INIT message.\n  \
    \ In addition to the ticket, the Initiator receives keys, which it does\n   not\
    \ already know.  The ticket contains both session information and\n   information\
    \ needed to resolve the ticket later, see Section 6.10.\n"
- title: 4.2.1.1.  Common Components of the REQUEST_INIT Messages
  contents:
  - "4.2.1.1.  Common Components of the REQUEST_INIT Messages\n   The REQUEST_INIT\
    \ message MUST always include the Header (HDR),\n   Timestamp (T), and RANDRi\
    \ payloads.\n   In HDR, the CSB ID (Crypto Session Bundle ID) SHALL be assigned\
    \ as in\n   [RFC3830].  The V flag MUST be set to '1' but SHALL be ignored by\
    \ the\n   KMS as a response is MANDATORY.  As Crypto Sessions (CSs) SHALL NOT\n\
    \   be handled, the #CS MUST be set to '0' and the CS ID map type SHALL\n   be\
    \ the \"Empty map\" as defined in [RFC4563].\n   IDRi contains the identity of\
    \ the Initiator.  This identity SHOULD be\n   included in the granted Ticket Policy.\n\
    \   IDRkms contains the identity of the KMS.  It SHOULD be included, but\n   it\
    \ MAY be left out when it can be expected that the KMS has a single\n   identity.\n\
    \   The Ticket Policy payload (TP) contains the desired Ticket Policy.\n   It\
    \ includes for instance, the ticket's validity period, the number of\n   requested\
    \ keys, and the identities of authorized responders (see\n   Section 6.10).\n"
- title: 4.2.1.2.  Components of the REQUEST_INIT_PSK Message
  contents:
  - "4.2.1.2.  Components of the REQUEST_INIT_PSK Message\n   The IDRi payload SHOULD\
    \ be included but MAY be left out when it can\n   be expected that the KMS can\
    \ identify the Initiator by other means.\n   The IDRpsk payload is used to indicate\
    \ the pre-shared key used.  It\n   MAY be omitted if the KMS can find the pre-shared\
    \ key by other means.\n   The last payload SHALL be a Verification payload (V)\
    \ where the\n   authentication key (auth_key) is derived from the pre-shared key\n\
    \   shared by the Initiator and the KMS (see Section 5.1.2 for key\n   derivation\
    \ specification).  The MAC SHALL cover the entire\n   REQUEST_INIT_PSK message\
    \ as well as the identities of the involved\n   parties (see Section 5.5 for the\
    \ exact definition).\n"
- title: 4.2.1.3.  Components of the REQUEST_INIT_PK Message
  contents:
  - "4.2.1.3.  Components of the REQUEST_INIT_PK Message\n   The identity IDRi and\
    \ certificate CERTi SHOULD be included, but they\n   MAY be left out when it can\
    \ be expected that the KMS can obtain the\n   certificate in some other manner.\
    \  If a certificate chain is to be\n   provided, each certificate in the chain\
    \ SHOULD be included in a\n   separate CERT payload.  The Initiator's certificate\
    \ MUST come first.\n   Each following certificate MUST directly certify the one\
    \ preceding\n   it.\n   PKE contains the encrypted envelope key: PKE = E(PKkms,\
    \ env_key).  It\n   is encrypted using the KMS's public key (PKkms).  If the KMS\n\
    \   possesses several public keys, the Initiator can indicate the key\n   used\
    \ in the CHASH payload.\n   SIGNi is a signature covering the entire REQUEST_INIT_PK\
    \ message,\n   using the Initiator's signature key (see Section 5.5 for the exact\n\
    \   definition).\n"
- title: 4.2.1.4.  Processing the REQUEST_INIT Message
  contents:
  - "4.2.1.4.  Processing the REQUEST_INIT Message\n   If the KMS can verify the integrity\
    \ of the received message and the\n   message can be correctly parsed, the KMS\
    \ MUST check the Initiator's\n   authorization.  If the Initiator is authorized\
    \ to receive the\n   requested ticket, possibly with a modified Ticket Policy,\
    \ the KMS\n   MUST send a REQUEST_RESP message.  Unexpected payloads in the\n\
    \   REQUEST_INIT message SHOULD be ignored.  Errors are handled as\n   described\
    \ in Section 5.4.\n"
- title: 4.2.1.5.  Components of the REQUEST_RESP Message
  contents:
  - "4.2.1.5.  Components of the REQUEST_RESP Message\n   The version, PRF func and\
    \ CSB ID, #CS, and CS ID map type fields in\n   the HDR payload SHALL be identical\
    \ to the corresponding fields in the\n   REQUEST_INIT message.  The V flag has\
    \ no meaning in this context.  It\n   SHALL be set to '0' by the KMS and ignored\
    \ by the Initiator.\n   If one of the NTP timestamp types is used, the KMS SHALL\
    \ generate a\n   fresh timestamp value (unlike [RFC3830]), which may be used for\
    \ clock\n   synchronization.  If the COUNTER timestamp type (see Section 6.6 of\n\
    \   [RFC3830]) is used, the timestamp value MAY be equal to the one in\n   the\
    \ REQUEST_INIT message.\n   The TICKET payload carries the granted Ticket Policy\
    \ and the Ticket\n   Data (see Section 6.10).  As the KMS decides which Ticket\
    \ Policy to\n   use, this may not be the same Ticket Policy as the Initiator\n\
    \   requested.  The Ticket Type and the Ticket Data depend on the granted\n  \
    \ Ticket Policy.\n   The KEMAC payload SHALL use the NULL authentication algorithm,\
    \ as a\n   MAC is included in the V payload.  Depending on the type of\n   REQUEST_INIT\
    \ message, either the pre-shared key or the envelope key\n   SHALL be used to\
    \ derive the encr_key (and salt_key).  Depending on\n   the encryption algorithm,\
    \ the salting key may go into the IV (see\n   [RFC3830]).  If the TP payload in\
    \ the REQUEST_INIT message does not\n   contain a KEMAC, it is RECOMMENDED that\
    \ the KMS's default KEMAC\n   include a single TGK.  The KEMAC SHALL include an\
    \ MPK (MIKEY\n   Protection Key), MPKi, used as a pre-shared key to protect the\n\
    \   messages in the Ticket Transfer exchange.  If key forking (see\n   Section\
    \ 5.1.1) is used (determined by the Ticket Policy) a second\n   MPK, MPKr, SHALL\
    \ be included in the KEMAC.  Then, MPKi SHALL be used\n   to protect the TRANSFER_INIT\
    \ message and MPKr SHALL be used to verify\n   the TRANSFER_RESP message.  The\
    \ KEMAC is hence constructed as\n   follows:\n           KEMAC = E(encr_key, MPKi\
    \ || [MPKr] || {TEK|TGK|GTGK})\n   The last payload SHALL be a Verification payload\
    \ (V).  Depending on\n   the type of REQUEST_INIT message, either the pre-shared\
    \ key or the\n   envelope key SHALL be used to derive the auth_key.  The MAC SHALL\n\
    \   cover the entire REQUEST_RESP message as well as the REQUEST_INIT\n   message\
    \ (see Section 5.5 for the exact definition).\n"
- title: 4.2.1.6.  Processing the REQUEST_RESP Message
  contents:
  - "4.2.1.6.  Processing the REQUEST_RESP Message\n   If the Initiator can verify\
    \ the integrity of the received message and\n   the message can be correctly parsed,\
    \ the ticket and the associated\n   session information SHALL be stored.  Unexpected\
    \ payloads in the\n   REQUEST_RESP message SHOULD be ignored.  Errors are handled\
    \ as\n   described in Section 5.4.\n   Before using the received ticket, the Initiator\
    \ MUST check that the\n   granted Ticket Policy is acceptable.  If not, the Initiator\
    \ SHALL\n   discard and MAY send a new REQUEST_INIT message suggesting a\n   different\
    \ Ticket Policy than before.\n"
- title: 4.2.2.  Ticket Transfer
  contents:
  - "4.2.2.  Ticket Transfer\n   This exchange is used to transfer a ticket as well\
    \ as session\n   information from the Initiator to a Responder.  The exchange\
    \ is\n   modeled after the pre-shared key mode [RFC3830], but instead of a\n \
    \  pre-shared key, an MPK encoded in the ticket is used.  The session\n   keys\
    \ are also encoded in the TICKET payload, but in some use cases\n   (see Section\
    \ 8) they need to be sent in a separate KEMAC payload.\n   The session information\
    \ may be sent from the Initiator to the\n   Responder (similar to [RFC3830]) or\
    \ from the Responder to the\n   Initiator (similar to [RFC4738]).  As the motive\
    \ for this exchange is\n   to setup a shared secret key between Initiator and\
    \ Responder, the\n   Responder cannot check the authenticity of the message before\
    \ the\n   ticket is resolved (by KMS or Responder).  A full round trip is\n  \
    \ required if Responder key confirmation and freshness guarantee are\n   needed.\n\
    \   Initiator                               Responder\n   TRANSFER_INIT =    \
    \             ---->\n   HDR, T, RANDRi, [IDRi],\n      [IDRr], {SP}, TICKET, \
    \        < - -  TRANSFER_RESP =\n      [KEMAC], V                           HDR,\
    \ T, [RANDRr],\n                                              [IDRr], [RANDRkms],\n\
    \                                              {SP}, [KEMAC], V\n"
- title: 4.2.2.1.  Components of the TRANSFER_INIT Message
  contents:
  - "4.2.2.1.  Components of the TRANSFER_INIT Message\n   The TRANSFER_INIT message\
    \ MUST always include the Header (HDR),\n   Timestamp (T), and RANDRi payloads.\n\
    \   In HDR, the CSB ID (Crypto Session Bundle ID) SHALL be assigned as in\n  \
    \ [RFC3830].  The value of the V flag SHALL agree with the F flag in\n   the Ticket\
    \ Policy and it SHALL be ignored by the Responder.\n   The IDRi and IDRr payloads\
    \ SHOULD be included, but IDRi MAY be left\n   out if the Responder can identify\
    \ the Initiator by other means, and\n   IDRr MAY be left out when it can be expected\
    \ that the Responder has a\n   single identity.\n   Multiple SP payloads MAY be\
    \ used both to indicate supported security\n   policies for a specific crypto\
    \ session (similar to [RFC4738]) and to\n   specify security policies for different\
    \ crypto sessions (similar to\n   [RFC3830]).\n   The ticket payload (see Section\
    \ 6.10) contains the Ticket Policy (see\n   Section 6.10), Ticket Data (the default\
    \ ticket type is defined in\n   Appendix A), and Initiator Data.  The Ticket Policy\
    \ contains\n   information intended for all parties involved, whereas the Ticket\n\
    \   Data is only intended for the party that resolves the ticket.  The\n   Ticket\
    \ Type provided in the Ticket Data is indicated in the Ticket\n   Policy.  The\
    \ Initiator Data authenticates the Initiator when key\n   forking (I flag) is\
    \ used.\n   The KEMAC payload is handled in the same way as if it were sent in\
    \ a\n   later CSB update (see Section 5.2), with the only difference that the\n\
    \   encr_key is always derived from MPKi and therefore accessible by all\n   responders\
    \ authorized to resolve the ticket.  Initiator-specified\n   keys MAY be used\
    \ if the Initiator has pre-encrypted content and\n   specific TEKs (Traffic Encryption\
    \ Keys) need to be used (see\n   Section 8).  If indicated by the Ticket Policy\
    \ (L flag), a KEMAC\n   payload SHALL NOT be included.\n   The last payload SHALL\
    \ be a Verification payload (V) where the\n   authentication key (auth_key) is\
    \ derived from the MPKi (see\n   Section 5.1.2 for key derivation specification).\
    \  The MAC SHALL cover\n   the entire TRANSFER_INIT message as well as the identities\
    \ of the\n   involved parties (see Section 5.5 for the exact definition).\n"
- title: 4.2.2.2.  Processing the TRANSFER_INIT Message
  contents:
  - "4.2.2.2.  Processing the TRANSFER_INIT Message\n   As the Initiator and Responder\
    \ do not have any pre-shared keys, the\n   Responder cannot check the authenticity\
    \ of the message before the\n   ticket is resolved.  The Responder SHALL however\
    \ check that both the\n   Ticket Policy and the security policies are acceptable.\
    \  If they are\n   not, the Responder SHALL reject without contacting the KMS.\
    \  This is\n   an early reject mechanism to avoid unnecessary KMS signaling when\
    \ the\n   Responder can conclude from the information at hand that it will not\n\
    \   accept the connection.  After the ticket has been resolved, the\n   parsing\
    \ of the TRANSFER_INIT message continues.  Unexpected payloads\n   in the TRANSFER_INIT\
    \ message SHOULD be ignored.  Errors are handled\n   as described in Section 5.4.\
    \  If the F flag in the Ticket Policy is\n   set, the Responder MUST send a TRANSFER_RESP\
    \ message.\n"
- title: 4.2.2.3.  Components of the TRANSFER_RESP Message
  contents:
  - "4.2.2.3.  Components of the TRANSFER_RESP Message\n   The version, PRF func and\
    \ CSB ID fields in the HDR payload SHALL be\n   identical to the corresponding\
    \ fields in the TRANSFER_INIT message.\n   The V flag has no meaning in this context.\
    \  It SHALL be set to '0' by\n   the Responder and ignored by the Initiator. \
    \ The Responder SHALL\n   update the CS ID map info so that each crypto session\
    \ has exactly one\n   security policy indicated.  The Responder MUST provide Session\
    \ Data\n   (at least for SRTP) and SPI for each crypto session for which the\n\
    \   Initiator has not supplied Session Data and SPI.  If needed, the\n   Responder\
    \ MAY update Session Data and SPI provided by the Initiator.\n   If the Responder\
    \ adds crypto sessions, the #CS SHALL be updated.\n   If one of the NTP timestamp\
    \ types is used, the Responder SHALL\n   generate a fresh timestamp value (unlike\
    \ [RFC3830]).  If the COUNTER\n   timestamp type (see Section 6.6 of [RFC3830])\
    \ is used, the timestamp\n   value MAY be equal to the one in the TRANSFER_INIT\
    \ message.\n   If indicated by the Ticket Policy (G flag), the Responder SHALL\n\
    \   generate a fresh (pseudo-)random byte string RANDRr.  RANDRr is used\n   to\
    \ produce Responder freshness guarantee in key derivations.\n   If the Responder\
    \ receives an IDRr payload in the RESOLVE_RESP\n   message, the same identity\
    \ MUST be sent in an IDRr payload in the\n   TRANSFER_RESP message.  The identity\
    \ sent in the IDRr payload in the\n   TRANSFER_RESP message (e.g., user1@example.com)\
    \ MAY differ from the\n   one sent in the IDRr payload in the TRANSFER_INIT message\
    \ (e.g.,\n   IT-support@example.com).\n   If the Responder receives a RANDRkms\
    \ payload in the RESOLVE_RESP\n   message, the same RAND MUST be sent in a RANDRkms\
    \ payload in the\n   TRANSFER_RESP message.\n   The Responder MAY provide additional\
    \ Security Policy payloads.  The\n   Responder SHOULD NOT resend SP payloads,\
    \ which the Initiator\n   supplied.\n   The KEMAC payload SHALL be handled exactly\
    \ as if it was sent in a\n   later CSB update, see Section 5.2.  Responder-specified\
    \ keys MAY be\n   used if Responder has pre-encrypted content and specific TEKs\n\
    \   (Traffic Encryption Keys) need to be used (see Section 8).  If\n   indicated\
    \ by the Ticket Policy (M flag), a KEMAC payload SHALL NOT be\n   included.\n\
    \   The last payload SHALL be a Verification payload (V) where the\n   authentication\
    \ key (auth_key) is derived from MPKi or MPKr'\n   (depending on if key forking\
    \ is used).  The MAC SHALL cover the\n   entire TRANSFER_RESP message as well\
    \ as the TRANSFER_INIT message\n   (see Section 5.5 for the exact definition).\n"
- title: 4.2.2.4.  Processing the TRANSFER_RESP Message
  contents:
  - "4.2.2.4.  Processing the TRANSFER_RESP Message\n   If the Initiator can verify\
    \ the integrity of the received message and\n   the message can be correctly parsed,\
    \ the Initiator MUST check that\n   any Responder-generated security policies\
    \ are acceptable.  If not,\n   the Initiator SHALL discard and MAY send a new\
    \ TRANSFER_INIT message\n   to indicate supported security policies.  Unexpected\
    \ payloads in the\n   TRANSFER_RESP message SHOULD be ignored.  Errors are handled\
    \ as\n   described in Section 5.4.\n"
- title: 4.2.3.  Ticket Resolve
  contents:
  - "4.2.3.  Ticket Resolve\n   This exchange is used by the Responder to request\
    \ that the KMS return\n   the keys encoded in a ticket.  The KMS does not need\
    \ to be the same\n   KMS that originally issued the ticket, see Section 10.  A\
    \ full round\n   trip is required for the Responder to receive the keys.  The\
    \ Ticket\n   Resolve exchange is OPTIONAL (depending on the Ticket Policy), and\n\
    \   SHOULD only be used when the Responder is unable to resolve the\n   ticket\
    \ without assistance from the KMS.  The initial message\n   RESOLVE_INIT comes\
    \ in two variants (independent from the used\n   REQUEST_INIT variant).  The first\
    \ variant corresponds to the pre-\n   shared key (PSK) method of [RFC3830].\n\
    \   Responder                               KMS\n   RESOLVE_INIT_PSK =       \
    \       ---->\n   HDR, T, RANDRr, [IDRr],\n      [IDRkms], TICKET,           \
    \  <----  RESOLVE_RESP\n      [IDRpsk], V                          HDR, T, [IDRkms],\
    \ KEMAC,\n                                              [IDRr], [RANDRkms], V\n\
    \   The second variant corresponds to the public-key (PK) method of\n   [RFC3830].\n\
    \   Responder                               KMS\n   RESOLVE_INIT_PK =        \
    \       ---->\n   HDR, T, RANDRr, [IDRr],\n      {CERTr}, [IDRkms], TICKET,  \
    \  <----  RESOLVE_RESP\n      [CHASH], PKE, SIGNr                  HDR, T, [IDRkms],\
    \ KEMAC,\n                                              [IDRr], [RANDRkms], V\n\
    \   As the RESOLVE_INIT message MUST ensure the identity of the Responder\n  \
    \ to the KMS, it SHALL be protected by a MAC based on a pre-shared key\n   or\
    \ by a signature.  The response message RESOLVE_RESP is the same for\n   the two\
    \ variants and SHALL be protected by using the pre-shared/\n   envelope key indicated\
    \ in the RESOLVE_INIT message.\n   Upon receiving the RESOLVE_INIT message, the\
    \ KMS verifies that the\n   Responder is authorized to resolve the ticket based\
    \ on ticket and KMS\n   policies.  The KMS extracts the session information from\
    \ the ticket\n   and returns this to the Responder.  Since the KMS resolved the\n\
    \   ticket, the Responder is assured of the integrity of the Ticket\n   Policy,\
    \ which contains the identity of the peer that requested or\n   created the ticket.\
    \  If key forking is used (I flag), the Responder\n   is also assured that the\
    \ peer that requested or created the ticket\n   also sent the TRANSFER_INIT message.\
    \  The Responder can complete the\n   session information it got from the Initiator\
    \ with the additional\n   session information received from the KMS.\n"
- title: 4.2.3.1.  Common Components of the RESOLVE_INIT Messages
  contents:
  - "4.2.3.1.  Common Components of the RESOLVE_INIT Messages\n   The RESOLVE_INIT\
    \ message MUST always include the Header (HDR),\n   Timestamp (T), and RANDRr\
    \ payloads.\n   The CSB ID (Crypto Session Bundle ID) SHALL be assigned as in\n\
    \   [RFC3830].  The V flag MUST be set to '1' but SHALL be ignored by the\n  \
    \ KMS as a response is MANDATORY.  As crypto sessions SHALL NOT be\n   handled,\
    \ the #CS MUST be set to '0' and the CS ID map type SHALL be\n   the \"Empty map\"\
    \ as defined in [RFC4563].\n   IDRkms SHOULD be included, but it MAY be left out\
    \ when it can be\n   expected that the KMS has a single identity.\n   The TICKET\
    \ payload contains the Ticket Policy and Ticket Data that\n   the Responder wants\
    \ to have resolved.\n"
- title: 4.2.3.2.  Components of the RESOLVE_INIT_PSK Message
  contents:
  - "4.2.3.2.  Components of the RESOLVE_INIT_PSK Message\n   IDRr contains the identity\
    \ of the Responder.  IDRr SHOULD be\n   included, but it MAY be left out when\
    \ it can be expected that the KMS\n   can identify the Responder in some other\
    \ manner.\n   The IDRpsk payload is used to indicate the pre-shared key used.\
    \  It\n   MAY be omitted if the KMS can find the pre-shared key by other means.\n\
    \   The last payload SHALL be a Verification payload (V) where the\n   authentication\
    \ key (auth_key) is derived from the pre-shared key\n   shared by the Responder\
    \ and the KMS.  The MAC SHALL cover the entire\n   RESOLVE_INIT_PSK message as\
    \ well as the identities of the involved\n   parties (see Section 5.5 for the\
    \ exact definition).\n"
- title: 4.2.3.3.  Components of the RESOLVE_INIT_PK Message
  contents:
  - "4.2.3.3.  Components of the RESOLVE_INIT_PK Message\n   The identity IDRr and\
    \ certificate CERTr SHOULD be included, but they\n   MAY be left out when it can\
    \ be expected that the KMS can obtain the\n   certificate in some other manner.\
    \  If a certificate chain is to be\n   provided, each certificate in the chain\
    \ SHOULD be included in a\n   separate CERT payload.  The Responder's certificate\
    \ MUST come first.\n   Each following certificate MUST directly certify the one\
    \ preceding\n   it.\n   PKE contains the encrypted envelope key: PKE = E(PKkms,\
    \ env_key).  It\n   is encrypted using PKkms.  If the KMS possesses several public\
    \ keys,\n   the Responder can indicate the key used in the CHASH payload.\n  \
    \ SIGNr is a signature covering the entire RESOLVE_INIT_PK message,\n   using\
    \ the Responder's signature key (see Section 5.5 for the exact\n   definition).\n"
- title: 4.2.3.4.  Processing the RESOLVE_INIT Message
  contents:
  - "4.2.3.4.  Processing the RESOLVE_INIT Message\n   If the KMS can verify the integrity\
    \ of the received message, the\n   message can be correctly parsed, and the Responder\
    \ is authorized to\n   resolve the ticket, the KMS MUST send a RESOLVE_RESP message.\
    \  If key\n   forking is used (I flag), the KMS SHALL also verify the integrity\
    \ of\n   the Initiator Data field in the TICKET payload.  Unexpected payloads\n\
    \   in the RESOLVE_INIT message SHOULD be ignored.  Errors are handled as\n  \
    \ described in Section 5.4.\n"
- title: 4.2.3.5.  Components of the RESOLVE_RESP Message
  contents:
  - "4.2.3.5.  Components of the RESOLVE_RESP Message\n   The version, PRF func and\
    \ CSB ID, #CS, and CS ID map type fields in\n   the HDR payload SHALL be identical\
    \ to the corresponding fields in the\n   RESOLVE_INIT message.  The V flag has\
    \ no meaning in this context.  It\n   SHALL be set to '0' by the KMS and ignored\
    \ by the Responder.\n   If one of the NTP timestamp types is used, the KMS SHALL\
    \ generate a\n   fresh timestamp value (unlike [RFC3830]), which may be used for\
    \ clock\n   synchronization.  If the COUNTER timestamp type (see Section 6.6 of\n\
    \   [RFC3830]) is used, the timestamp value MAY be equal to the one in\n   the\
    \ RESOLVE_INIT message.\n   The KEMAC payload SHALL use the NULL authentication\
    \ algorithm, as a\n   MAC is included in the V payload.  Depending on the type\
    \ of\n   RESOLVE_INIT message, either the pre-shared key or the envelope key\n\
    \   SHALL be used to derive the encr_key (and salt_key).  Depending on\n   the\
    \ encryption algorithm, the salting key may go into the IV (see\n   [RFC3830]).\
    \  The KEMAC SHALL include an MPK (MPKi), used as a pre-\n   shared key to protect\
    \ the messages in the Ticket Transfer exchange.\n   The KEMAC is hence constructed\
    \ as follows:\n           KEMAC = E(encr_key, MPKi || [MPKr'] || {TEK|TGK|GTGK})\n\
    \   If key forking (see Section 5.1.1) is used (determined by the I flag\n   in\
    \ the Ticket Policy), a second MPK (MPKr') SHALL be included in the\n   KEMAC.\
    \  Then, MPKi SHALL be used to verify the TRANSFER_INIT message\n   and MPKr'\
    \ SHALL be used to protect the TRANSFER_RESP message.  The\n   KMS SHALL also\
    \ fork the MPKr and the TGKs.  The modifier used to\n   derive the forked keys\
    \ SHALL be included in the IDRr and RANDRkms\n   payloads, where IDRr is the identity\
    \ of the endpoint that answered\n   and RANDRkms is a fresh (pseudo-)random byte\
    \ string generated by the\n   KMS.  The reason that the KMS MAY adjust the Responder's\
    \ identity is\n   so that it matches an identity encoded in the ticket.\n   The\
    \ last payload SHALL be a Verification payload (V).  Depending on\n   the type\
    \ of RESOLVE_INIT message, either the pre-shared key or the\n   envelope key SHALL\
    \ be used to derive the auth_key.  The MAC SHALL\n   cover the entire RESOLVE_RESP\
    \ message as well as the RESOLVE_INIT\n   message (see Section 5.5 for the exact\
    \ definition).\n"
- title: 4.2.3.6.  Processing the RESOLVE_RESP Message
  contents:
  - "4.2.3.6.  Processing the RESOLVE_RESP Message\n   If the Responder can verify\
    \ the integrity of the received message and\n   the message can be correctly parsed,\
    \ the Responder MUST verify the\n   TRANSFER_INIT message with the MPKi received\
    \ from the KMS.  If key\n   forking is used, the Responder SHALL also verify that\
    \ the MAC field\n   in the V payload in the TRANSFER_INIT message is identical\
    \ to the MAC\n   field in the Vi payload in the Initiator Data field in the TICKET\n\
    \   payload.  Unexpected payloads in the RESOLVE_RESP message SHOULD be\n   ignored.\
    \  Errors are handled as described in Section 5.4.\n"
- title: 5.  Key Management Functions
  contents:
  - '5.  Key Management Functions

    '
- title: 5.1.  Key Derivation
  contents:
  - "5.1.  Key Derivation\n   For all messages in the Ticket Request and Ticket Resolve\
    \ exchanges,\n   the keys used to protect the MIKEY messages are derived from\
    \ a pre-\n   shared key or an envelope key.  As crypto sessions SHALL NOT be\n\
    \   handled, further keying material (i.e., TEKs) does not have to be\n   derived.\n\
    \   In the Ticket Transfer exchange, the keys used to protect the MIKEY\n   messages\
    \ are derived from an MPK.  If key forking is used, the KMS\n   and the Initiator\
    \ SHALL fork the MPKr and the TGKs (encoded in the\n   ticket) based on a modifier,\
    \ and different MPKs (MPKi and MPKr')\n   SHALL be used to protect the TRANSFER_INIT\
    \ and TRANSFER_RESP\n   messages.  In addition, the Responder MAY generate a RAND\
    \ used to\n   give Responder key freshness guarantee.\n   The key hierarchy and\
    \ its dependencies on TRANSFER_INIT message\n   contents for the case without\
    \ key forking and RANDRr are illustrated\n   in Figure 4.  The KEMAC shown is\
    \ the KEMAC sent from the KMS to the\n   Initiator and the Responder.  The illustrated\
    \ key derivations are\n   done by the Initiator and the Responder.\n         \
    \                       +------+------------------+-----+------+\n   KEMAC   \
    \                     | MPKi |..................| TGK | SALT |\n             \
    \                   +--+---+------------------+--+--+--+---+\n               \
    \                    | MPKi                    |     |\n                     \
    \              v                         |     |\n                       CSB ID\
    \    -----   auth_key    ------  |     |\n                    +---------->| PRF\
    \ |------------>| AUTH | |     |\n                    |            -----     \
    \          ------  |     |\n                    |              ^             \
    \   MAC |    |     |\n                    |              | RAND              \
    \ v    |     |\n                 +--+--+------+----+---+--+--------+--+---+  |\
    \     |\n   TRANSFER_INIT | HDR |......| RANDRi |..| TICKET |..| V |  |     |\n\
    \                 +--+--+------+----+---+--+--------+--+---+  |     |\n      \
    \              |              | RAND                    |     |\n            \
    \        |              v                         |     |\n                  \
    \  |   CS ID    -----           TGK         |     |\n                    +---------->|\
    \ PRF |<---------------------+     |\n                                 ----- \
    \                            |\n                                   | TEK     \
    \                 SALT |\n                                   v               \
    \                v\n                                ---------------------------------------\n\
    \                               |      Security Protocol, e.g., SRTP    |\n  \
    \                              ---------------------------------------\n     \
    \     Figure 4: Key hierarchy without key forking and RANDRr\n   The key hierarchy\
    \ and its dependencies on TRANSFER_RESP message\n   contents for the case with\
    \ key forking and RANDRr are illustrated in\n   Figure 5.  The KEMAC shown is\
    \ the KEMAC sent from the KMS to the\n   Initiator.  MOD is the modifier (IDRr,\
    \ RANDRkms).  The two key\n   derivations that produce forked keys are done by\
    \ the Initiator and\n   the KMS, and the remaining two key derivations are done\
    \ by the\n   Initiator and the Responder.  The random value RANDRi from the\n\
    \   TRANSFER_INIT message is used as input to the derivation of the\n   auth_key\
    \ and may be used as input to the derivation of the TEK, but\n   this is omitted\
    \ from the figure.  The protection of the TRANSFER_INIT\n   message is done as\
    \ in Figure 4.\n                        +------+--------------------------+-----+------+\n"
- title: KEMAC                   | MPKr |..........................| TGK | SALT |
  contents:
  - "KEMAC                   | MPKr |..........................| TGK | SALT |\n  \
    \                      +--+---+--------------------------+--+--+--+---+\n    \
    \                       | MPKr                            |     |\n          \
    \                 v                                 |     |\n                \
    \         -----   MPKr'                       |     |\n                      \
    \  | PRF |-------+                  TGK |     |\n                         -----\
    \        |                      |     |\n                           ^        \
    \  v                      |     |\n                   CSB ID  |        ----- \
    \ auth_key  ------  |     |\n                 +---------)------>| PRF |--------->|\
    \ AUTH | |     |\n                 |         |        -----            ------\
    \  |     |\n                 |         | ID Data  ^             MAC |    |   \
    \  |\n                 |         | RAND     | RAND            v    |     |\n \
    \             +--+--+---+--+--+---+---+----+----------+---+  |     |\n"
- title: TRANSFER_RESP | HDR |...| MOD |...| RANDRr |..........| V |  |     |
  contents:
  - "TRANSFER_RESP | HDR |...| MOD |...| RANDRr |..........| V |  |     |\n      \
    \        +--+--+---+--+--+---+---+----+----------+---+  |     |\n            \
    \     |         |          | RAND                 v     |\n                 |\
    \         |          |          ID Data   -----   |\n                 |      \
    \   +----------)------------------>| PRF |  |\n                 |            \
    \        |            RAND    -----   |\n                 |                  \
    \  v                      |     |\n                 |       CS ID      ----- \
    \        TGK'       |     |\n                 +---------------->| PRF |<------------------+\
    \     |\n                                    -----                          |\n\
    \                                      | TEK                   SALT |\n      \
    \                                v                            v\n            \
    \                    ---------------------------------------\n               \
    \                |      Security Protocol, e.g., SRTP    |\n                 \
    \               ---------------------------------------\n            Figure 5:\
    \ Key hierarchy with key forking and RANDRr\n   The labels in the key derivations\
    \ SHALL NOT include entire RANDR\n   payloads, only the fields RAND length and\
    \ RAND from the corresponding\n   payload.\n"
- title: 5.1.1.  Deriving Forked Keys
  contents:
  - "5.1.1.  Deriving Forked Keys\n   When key forking is used (determined by the\
    \ I flag in the Ticket\n   Policy), the MPKr and TGKs (encoded in the ticket)\
    \ SHALL be forked.\n   The TEKs and GTGKs (Group TGKs), however, SHALL NOT be\
    \ forked.  This\n   key forking is done by the KMS and the Initiator using the\
    \ PRF\n   (Pseudorandom Function) indicated in the Ticket Policy.  The\n   parameters\
    \ for the PRF are:\n   inkey:     : MPKr or TGK\n   inkey_len  : bit length of\
    \ the inkey\n   label      : constant || 0xFF || 0xFFFFFFFF || 0x00 ||\n     \
    \           length ID Data || ID Data || length RANDRkms || RANDRkms\n   outkey_len\
    \ : desired bit length of the outkey (MPKr', TGK')\n                SHALL be equal\
    \ to inkey_len\n   where the ID Data field is taken from the IDRr payload sent\
    \ in the\n   RESOLVE_RESP and TRANSFER_RESP messages.  Length ID Data is the\n\
    \   length of the ID Data field in bytes as a 16-bit unsigned integer.\n   Length\
    \ RANDRkms is the length of RANDRkms in bytes as an 8-bit\n   unsigned integer.\
    \  The constant depends on the derived key type as\n   summarized below.\n   \
    \                       Derived key | Constant\n                          ------------+-----------\n\
    \                          MPKr'       | 0x2B288856\n                        \
    \  TGK'        | 0x1512B54A\n              Table 5.1: Constants for forking key\
    \ derivation\n   The constants are taken from the decimal digits of e as described\
    \ in\n   [RFC3830].\n"
- title: 5.1.2.  Deriving Keys from an Envelope Key/PSK/MPK
  contents:
  - "5.1.2.  Deriving Keys from an Envelope Key/PSK/MPK\n   This derivation is used\
    \ to form the keys used to protect the MIKEY\n   messages.  For the Ticket Request\
    \ and Ticket Resolve exchanges, the\n   keys used to protect the MIKEY messages\
    \ are derived from a pre-shared\n   key or an envelope key.  For the Ticket Transfer\
    \ exchange, the keys\n   are derived from an MPK.  If key forking is used, different\
    \ MPKs\n   (MPKi and MPKr') SHALL be used to protect the TRANSFER_INIT and\n \
    \  TRANSFER_RESP messages.  The initial messages SHALL be protected with\n   keys\
    \ derived using the following parameters:\n   inkey:     : pre-shared key, envelope\
    \ key, or MPKi\n   inkey_len  : bit length of the inkey\n   label      : constant\
    \ || 0xFF || CSB ID || 0x01 ||\n                length RANDRi || [RANDRi] || length\
    \ RANDRr || [RANDRr]\n   outkey_len : desired bit length of the outkey (encr_key,\n\
    \                auth_key, salt_key)\n   The response messages SHALL be protected\
    \ with keys derived using the\n   following parameters:\n   inkey:     : pre-shared\
    \ key, envelope key, MPKi, or MPKr'\n   inkey_len  : bit length of the inkey\n\
    \   label      : constant || 0xFF || CSB ID || 0x02 ||\n                length\
    \ RANDRi || [RANDRi] || length RANDRr || [RANDRr]\n   outkey_len : desired bit\
    \ length of the outkey (encr_key,\n                auth_key, salt_key)\n   The\
    \ constant depends on the derived key type as defined in Section\n   4.1.4 of\
    \ [RFC3830].  The 32-bit CSB ID field is taken from the HDR\n   payload.  RANDRi\
    \ SHALL be included in the derivation of keys used to\n   protect the Ticket Request\
    \ and Ticket Transfer exchanges.  RANDRr\n   SHALL be included in the derivation\
    \ of keys used to protect the\n   Ticket Resolve exchange and in the derivation\
    \ of keys used to protect\n   TRANSFER_RESP if the Ticket Policy determines that\
    \ it shall be\n   present in the TRANSFER_RESP message (G flag).  Length RANDRi\
    \ is the\n   length of RANDRi in bytes as an 8-bit unsigned integer, and Length\n\
    \   RANDRr is the length of RANDRr in bytes as an 8-bit unsigned integer.\n  \
    \ If RANDRi is omitted, length RANDRi SHALL be 0 and if RANDRr is\n   omitted,\
    \ length RANDRr SHALL be 0.  Note that at least one of RANDRi\n   and RANDRr is\
    \ always used.\n"
- title: 5.1.3.  Deriving Keys from a TGK/GTGK
  contents:
  - "5.1.3.  Deriving Keys from a TGK/GTGK\n   This only affects the Ticket Transfer\
    \ exchange.  In the following, we\n   describe how keying material is derived\
    \ from a TGK/GTGK.  If key\n   forking is used, any TGK encoded in the ticket\
    \ SHALL be forked, and\n   the forked key TGK' SHALL be used.  The key derivation\
    \ method SHALL\n   be executed using the PRF indicated in the HDR payload.  The\n\
    \   parameters for the PRF are:\n   inkey:     : TGK, TGK', or GTGK\n   inkey_len\
    \  : bit length of the inkey\n   label      : constant || CS ID || 0xFFFFFFFF\
    \ || 0x03 ||\n                length RANDRi || [RANDRi] || length RANDRr || [RANDRr]\n\
    \   outkey_len : desired bit length of the outkey (TEK, encr_key,\n          \
    \      auth_key, salt_key)\n   The constant depends on the derived key type as\
    \ defined in Section\n   4.1.3 of [RFC3830].  If a salting key is present in the\
    \ key data sub-\n   payload, a security protocol in need of a salting key SHALL\
    \ use this\n   salting key and a new salting key SHALL NOT be derived.  The 8-bit\
    \ CS\n   ID field is given by the CS ID map info field in the HDR payload.\n \
    \  RANDRi SHALL be included if the Ticket Policy determines that it\n   shall\
    \ be used (H flag).  RANDRr SHALL be included if the Ticket\n   Policy determines\
    \ that it shall be present in the TRANSFER_RESP\n   message (G flag).  Length\
    \ RANDRi is the length of RANDRi in bytes as\n   an 8-bit unsigned integer, and\
    \ Length RANDRr is the length of RANDRr\n   in bytes as an 8-bit unsigned integer.\
    \  If RANDRi or RANDRr is\n   omitted the corresponding length SHALL be 0.  Note\
    \ that at least one\n   of RANDRi and RANDRr MUST be used.\n"
- title: 5.2.  CSB Updating
  contents:
  - "5.2.  CSB Updating\n   Similar to [RFC3830], MIKEY-TICKET provides a means of\
    \ updating the\n   CSB (Crypto Session Bundle), e.g., transporting a new TEK/TGK/GTGK\
    \ or\n   adding new crypto sessions.  The CSB updating is done by executing\n\
    \   the Ticket Transfer exchange again, e.g., before a TEK expires or\n   when\
    \ a new crypto session is needed.  The CSB updating can be started\n   by the\
    \ Initiator:\n   Initiator                               Responder\n   TRANSFER_INIT\
    \ =                 ---->\n   HDR, T, [IDRi], [IDRr],\n      {SP}, [KEMAC], V\
    \              < - -  TRANSFER_RESP =\n                                      \
    \     HDR, T, [IDRr],\n                                           {SP}, [KEMAC],\
    \ V\n   The CSB updating can also be started by the Responder:\n   Responder \
    \                              Initiator\n   TRANSFER_INIT =                 ---->\n\
    \   HDR, T, [IDRr], [IDRi],\n      {SP}, [KEMAC], V              < - -  TRANSFER_RESP\
    \ =\n                                           HDR, T, [IDRi],\n            \
    \                               {SP}, [KEMAC], V\n   The new message exchange\
    \ MUST use the same CSB ID as the initial\n   exchange but MUST use new timestamps.\
    \  The crypto sessions\n   negotiation (#CS field, CS ID map info field, and SP\
    \ payloads) are\n   handled as in the initial exchange.  In the TRANSFER_INIT\
    \ message the\n   V flag SHALL be used to indicate whether or not a response message\
    \ is\n   expected.  Static payloads such as RANDRi, RANDRr, RANDRkms, and\n  \
    \ TICKET that were provided in the initial exchange SHOULD NOT be\n   included\
    \ unless they are needed by a specific use case.  New RANDs or\n   TICKETs MUST\
    \ NOT be included.  The reason that new RANDs SHALL NOT be\n   used is that if\
    \ several TGKs are used, the peers would need to keep\n   track of which RANDs\
    \ to use for each TGK.  This adds unnecessary\n   complexity.  Both messages SHALL\
    \ be protected with the same keys\n   (derived from MPKi or MPKr') that protected\
    \ the last message\n   (TRANSFER_INIT or TRANSFER_RESP) in the initial exchange.\n\
    \   New keying material MAY be sent in a KEMAC payload.  If indicated by\n   the\
    \ Ticket Policy (L and M flags), KEMAC payloads SHALL NOT be\n   included.  In\
    \ the TRANSFER_RESP message, a session key MUST be\n   provided for each crypto\
    \ session.  The KEMAC SHALL use the NULL\n   authentication algorithm, as a MAC\
    \ is included in the V payload.  The\n   encr_key (and salt_key) SHALL be derived\
    \ from the MPK (MPKi or\n   MPKr').  Depending on the encryption algorithm, the\
    \ salting key may\n   go into the IV (see [RFC3830]).  If a new TGK is exchanged,\
    \ it SHALL\n   NOT be forked.  The KEMAC is hence constructed as follows:\n  \
    \                  KEMAC = E(encr_key, (TEK|TGK|GTGK))\n"
- title: 5.3.  Ticket Reuse
  contents:
  - "5.3.  Ticket Reuse\n   MIKEY-TICKET includes features aiming to offload the KMS\
    \ from\n   receiving ticket requests.  One such feature is that tickets may be\n\
    \   reused.  This means that a user may request a ticket for media\n   sessions\
    \ with another user and then under the ticket's validity\n   period use this ticket\
    \ to protect several media sessions with that\n   user.\n   When reusing a ticket\
    \ that has been used in a previous Ticket\n   Transfer exchange, a new Ticket\
    \ Transfer exchange is executed.  The\n   new exchange MUST use a new CSB ID,\
    \ a new timestamp, and new RANDs\n   (RANDRi, RANDRr).  If the Responder has resolved\
    \ the ticket before,\n   the Responder does not need to resolve the ticket again.\
    \  In that\n   case, the same modifier (IDRr, RANDRkms) SHALL be used.  If the\n\
    \   Ticket Policy forbids reuse (J flag), the ticket MUST NOT be reused.\n   Note\
    \ that such reuse cannot be detected by a stateless KMS.  When\n   group keys\
    \ are used, ticket reuse leaves the Initiator responsible to\n   ensure that group\
    \ membership has not changed since the ticket was\n   last used.  (Otherwise,\
    \ unauthorized responders may gain access to\n   the group communication.)  Thus,\
    \ if group dynamics are difficult to\n   verify, the Initiator SHOULD NOT initiate\
    \ ticket reuse.\n   When key forking is used, only the user that requested the\
    \ ticket has\n   access to the encoded master keys (MPKr, TGKs).  Because of this,\
    \ no\n   one else can initiate a Ticket Transfer exchange using the ticket.\n"
- title: 5.4.  Error Handling
  contents:
  - "5.4.  Error Handling\n   If a fatal error occurs during the parsing of a message,\
    \ the message\n   SHOULD be discarded, and an Error message SHOULD be sent to\
    \ the other\n   party (Initiator, Responder, KMS).  If a failure is due to the\n\
    \   inability to authenticate the peer, the message SHALL be discarded,\n   the\
    \ Error message is OPTIONAL, and the caveats in Section 5.1.2 of\n   [RFC3830]\
    \ apply.  Error messages may be used to report errors in both\n   initial and\
    \ response messages, but not in Error messages.\n   In the Ticket Request and\
    \ Ticket Resolve exchanges, the Error message\n   MAY be authenticated with a\
    \ MAC or a signature.  The Error message is\n   hence constructed as follows:\n\
    \                  Error message = HDR, T, (ERR), [V|SIGNx]\n   where x is in\
    \ the set {i, r, kms} (Initiator, Responder, KMS).\n   Unexpected payloads in\
    \ the Error message SHOULD be ignored.\n   In the Ticket Transfer exchange, the\
    \ Error message MAY be\n   authenticated with a MAC.  If the suggested security\
    \ policies are not\n   supported, the Error message SHOULD include the supported\
    \ parameters.\n   The Error message is hence constructed as follows:\n       \
    \           Error message = HDR, T, (ERR), {SP}, [V]\n   In Error messages, the\
    \ version, PRF func, and CSB ID fields in the\n   HDR payload SHALL be identical\
    \ to the corresponding fields in the\n   message where the error occurred.  The\
    \ V field SHALL be set to '0'\n   and be ignored.\n   If one of the NTP timestamp\
    \ types is used, a fresh timestamp value\n   SHALL be used.  If the COUNTER timestamp\
    \ type (see Section 6.6 of\n   [RFC3830]) is used, the timestamp value MAY be\
    \ equal to the one in\n   the message where the error occurred.\n   The MAC/Signature\
    \ in the V/SIGN payloads covers the entire Error\n   message, except the MAC/Signature\
    \ field itself.  The auth_key SHALL\n   be the same as in the message where the\
    \ error occurred.\n"
- title: 5.5.  MAC/Signature Coverage
  contents:
  - "5.5.  MAC/Signature Coverage\n   The MAC/Signature in the V/SIGN payloads covers\
    \ the entire MIKEY\n   message, except the MAC/Signature field itself.  For initial\n\
    \   messages, the identities (not whole payloads) of the parties involved\n  \
    \ MUST directly follow the MIKEY message in the Verification MAC/\n   Signature\
    \ calculation.  In the TRANSFER_INIT message, the MAC SHALL\n   NOT cover the\
    \ Initiator Data length and Initiator Data fields in the\n   TICKET payload. \
    \ Note that in the Transfer Exchange, Identity_r in\n   TRANSFER_RESP (e.g., user1@example.com)\
    \ MAY differ from that\n   appearing in TRANSFER_INIT (e.g., IT-support@example.com).\
    \  For\n   response messages, the entire initial message (including the MAC/\n\
    \   Signature field) MUST directly follow the MIKEY message in the\n   Verification\
    \ MAC/Signature calculation (the identities are implicitly\n   covered as they\
    \ are covered by the initial message's MAC/Signature).\n        Message type \
    \ | MAC/Signature coverage\n        --------------+--------------------------------------------\n\
    \        REQUEST_INIT  | REQUEST_INIT  || Identity_i || Identity_kms\n       \
    \ REQUEST_RESP  | REQUEST_RESP  || REQUEST_INIT\n        TRANSFER_INIT | TRANSFER_INIT\
    \ || Identity_i || Identity_r\n        TRANSFER_RESP | TRANSFER_RESP || TRANSFER_INIT\n\
    \        RESOLVE_INIT  | RESOLVE_INIT  || Identity_r || Identity_kms\n       \
    \ RESOLVE_RESP  | RESOLVE_RESP  || RESOLVE_INIT\n        Error message | Error\
    \ message\n                     Table 5.2: MAC/Signature coverage\n"
- title: 6.  Payload Encoding
  contents:
  - "6.  Payload Encoding\n   This section does not describe all the payloads that\
    \ are used in the\n   new message types.  It describes in detail the new TR, IDR,\
    \ RANDR,\n   TP, and TICKET payloads.  For the other payloads, only the additions\n\
    \   and changes compared to [RFC3830] are described.  For a detailed\n   description\
    \ of the other MIKEY payloads, see [RFC3830].  Note that\n   the fields with variable\
    \ length are byte aligned and not 32-bit\n   aligned.\n"
- title: 6.1.  Common Header Payload (HDR)
  contents:
  - "6.1.  Common Header Payload (HDR)\n   For the Common Header Payload, new values\
    \ are added to the Data Type,\n   Next Payload, PRF func, and CS ID map type name\
    \ spaces.\n   *  Data Type (8 bits): describes the type of message.\n      Data\
    \ Type        | Value | Comment\n      -----------------+-------+-------------------------------------\n\
    \      REQUEST_INIT_PSK |    11 | Ticket request initial message (PSK)\n     \
    \ REQUEST_INIT_PK  |    12 | Ticket request initial message (PK)\n      REQUEST_RESP\
    \     |    13 | Ticket request response message\n                       |    \
    \   |\n      TRANSFER_INIT    |    14 | Ticket transfer initial message\n    \
    \  TRANSFER_RESP    |    15 | Ticket transfer response message\n             \
    \          |       |\n      RESOLVE_INIT_PSK |    16 | Ticket resolve initial\
    \ message (PSK)\n      RESOLVE_INIT_PK  |    17 | Ticket resolve initial message\
    \ (PK)\n      RESOLVE_RESP     |    18 | Ticket resolve response message\n   \
    \                  Table 6.1: Data Type (Additions)\n   *  Next Payload (8 bits):\
    \ identifies the payload that is added after\n      this payload.\n          \
    \             Next Payload | Value | Section\n                       -------------+-------+--------\n\
    \                       TR           |    13 | 6.4\n                       IDR\
    \          |    14 | 6.6\n                       RANDR        |    15 | 6.8\n\
    \                       TP           |    16 | 6.10\n                       TICKET\
    \       |    17 | 6.10\n                    Table 6.2: Next Payload (Additions)\n\
    \   *  V (1 bit): flag to indicate whether a response message is expected\n  \
    \    ('1') or not ('0').  It MUST be set to '0' and ignored in all\n      messages\
    \ except TRANSFER_INIT messages used for CSB updating (see\n      Section 5.2).\n\
    \   *  PRF func (7 bits): indicates the PRF function that has been/will\n    \
    \  be used for key derivation.  Besides the PRFs already defined in\n      [RFC3830]\
    \ the following additional PRF may be used.\n                         PRF func\
    \         | Value\n                         -----------------+------\n       \
    \                  PRF-HMAC-SHA-256 |     1\n                      Table 6.3:\
    \ PRF func (Additions)\n   The new PRF SHALL be constructed as described in Section\
    \ 4.1.2 of\n   [RFC3830] with the differences that HMAC-SHA-256 (see Section 6.2)\n\
    \   SHALL be used instead of HMAC-SHA-1 and the value 256 SHALL be used\n   instead\
    \ of 160.  This corresponds to the full output length of\n   SHA-256.\n   *  #CS\
    \ (8 bits): indicates the number of crypto sessions in the CS ID\n      map info.\n\
    \   *  CS ID map type (8 bits): specifies the method of uniquely mapping\n   \
    \   crypto sessions to the security protocol sessions.  In the Ticket\n      Transfer\
    \ exchange the new GENERIC-ID map type, which is intended\n      to eliminate\
    \ the limitations with the existing SRTP-ID map type,\n      SHOULD be used. \
    \ The map type SRTP-ID SHALL NOT be used.\n                          CS ID map\
    \ type | Value\n                          ----------------------\n           \
    \               GENERIC-ID     |     2\n                   Table 6.4: CS ID map\
    \ type (Additions)\n   *  CS ID map info (variable length): identifies and maps\
    \ the crypto\n      sessions to the security protocol sessions for which security\n\
    \      associations should be created.\n"
- title: 6.1.1.  The GENERIC-ID Map Type
  contents:
  - "6.1.1.  The GENERIC-ID Map Type\n   For the GENERIC-ID map type, the CS ID map\
    \ info consists of #CS\n   number of blocks, each mapping policies, session data\
    \ (e.g., SSRC),\n   and key to a specific crypto session.\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !     CS ID     !   Prot type   !S!     #P      ! Ps (OPTIONAL) ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !      Session Data Length      !    Session Data (OPTIONAL)    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !  SPI Length   !                SPI (OPTIONAL)                 ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  CS ID (8 bits): defines the CS ID to be used for the crypto\n      session.\n\
    \   *  Prot type (8 bits): defines the security protocol to be used for\n    \
    \  the crypto session.  Allowed values are the ones defined for the\n      Prot\
    \ type field in the SP payload (see Section 6.10 of [RFC3830]).\n   *  S (1 bit):\
    \ flag that MAY be used by the Session Data.\n   *  #P (7 bits): indicates the\
    \ number of security policies provided\n      for the crypto session.  In response\
    \ messages, #P SHALL always be\n      exactly 1.  So if #P = 0 in an initial message,\
    \ a security profile\n      MUST be provided in the response message.  If #P >\
    \ 0, one of the\n      suggested policies SHOULD be chosen in the response message.\
    \  If\n      needed (e.g., in group communication, see Section 9), the\n     \
    \ suggested policies MAY be changed.\n   *  Ps (variable length): lists the policies\
    \ for the crypto session.\n      It SHALL contain exactly #P policies, each having\
    \ the specified\n      Prot type.\n       0                   1              \
    \     2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !  Policy_no_1  !  Policy_no_2  !      ...      ! Policy_no_#P  !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      *\
    \  Policy_no_i (8 bits): a policy_no that corresponds to the\n         policy_no\
    \ of a SP payload.  In response messages, the policy_no\n         may refer to\
    \ a SP payload in the initial message.\n   *  Session Data Length (16 bits): the\
    \ length of Session Data (in\n      bytes).  For the Prot type SRTP, Session Data\
    \ MAY be omitted in\n      the initial message (length = 0), but it MUST be provided\
    \ in the\n      response message.\n   *  Session Data (variable length): contains\
    \ session data for the\n      crypto session.  The type of Session Data depends\
    \ on the specified\n      Prot type.  The Session Data for the Prot type SRTP\
    \ is defined\n      below.  The S flag is used to indicate whether the ROC and\
    \ SEQ\n      fields are provided ('1') or if they are omitted ('0').\n       0\
    \                   1                   2                   3\n       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                              SSRC                             !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                        ROC (OPTIONAL)                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !         SEQ (OPTIONAL)          !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      *  SSRC (32 bits): specifies the SSRC that MUST be used for the\n     \
    \    crypto session.  Note that unlike [RFC3830], an SSRC field set\n        \
    \ to '0' has no special meaning.\n      *  ROC (32 bits): current/initial rollover\
    \ counter.  If the\n         session has not started, this field is set to '0'.\n\
    \      *  SEQ (16 bits): current/initial sequence number.\n   *  SPI Length (8\
    \ bits): the length of SPI (in bytes).  SPI MAY be\n      omitted in the initial\
    \ message (length = 0), but it MUST be\n      provided in the response message.\n\
    \   *  SPI (variable length): the SPI (or MKI) corresponding to the\n      session\
    \ key to (initially) be used for the crypto session.  This\n      does not exclude\
    \ other keys to be used.  All keys MUST belong to\n      the crypto session bundle.\n"
- title: 6.2.  Key Data Transport Payload (KEMAC)
  contents:
  - "6.2.  Key Data Transport Payload (KEMAC)\n   For the KEMAC payload, new encryption\
    \ and authentication algorithms\n   are defined.\n   *  Encr alg (8 bits): the\
    \ encryption algorithm used to encrypt the\n      Encr data field.  Besides the\
    \ algorithms already defined in\n      [RFC3830], the following additional encryption\
    \ algorithm may be\n      used.\n              Encr alg   | Value | Comment\n\
    \              -----------+-------+---------------------------\n             \
    \ AES-CM-256 |     3 | AES-CM using a 256-bit key\n                      Table\
    \ 6.5: Encr alg (Additions)\n   The new encryption algorithm is defined as described\
    \ in Section 4.2.3\n   of [RFC3830] with the only difference being that a 256-bit\
    \ key SHALL\n   be used.\n   *  MAC alg (8 bits): specifies the authentication\
    \ algorithm used.\n      Besides the algorithms already defined in [RFC3830],\
    \ the following\n      additional authentication algorithm may be used.\n    \
    \                MAC alg          | Value | Length\n                    -----------------+-------+---------\n\
    \                    HMAC-SHA-256-256 |     2 | 256 bits\n                   \
    \    Table 6.6: MAC alg (Additions)\n   The new authentication algorithm is Hash-based\
    \ Message Authentication\n   Code (HMAC) [RFC2104] in conjunction with SHA-256\
    \ [FIPS.180-3].  It\n   SHALL be used with a 256-bit authentication key.\n"
- title: 6.2.1.  Key Data Sub-Payload
  contents:
  - "6.2.1.  Key Data Sub-Payload\n   For the key data sub-payload, new types of keys\
    \ are defined.  The\n   Group TGK (GTGK) is used as a regular TGK, with the difference\
    \ that\n   it SHALL NOT be forked.  It is intended to enable the establishment\n\
    \   of a group TGK when key forking is used.  The MIKEY Protection Key\n   (MPK)\
    \ is used to protect the MIKEY messages in the Ticket Transfer\n   exchange. \
    \ The MPK is used as the pre-shared key in the pre-shared\n   key method of [RFC3830];\
    \ however, it is not known by the Responder\n   before the ticket has been resolved.\n\
    \   An SPI (or MKI) MUST be specified for each key (see Section 6.13 of\n   [RFC3830]).\n\
    \   *  Type (4 bits): indicates the type of key included in the payload.\n   \
    \               Type      | Value | Comments\n                  ----------+-------+---------------------\n\
    \                  GTGK      |     4 | Group TGK\n                  GTGK+SALT\
    \ |     5 | Group TGK + SALT\n                  MPK       |     6 | MIKEY Protection\
    \ Key\n                    Table 6.7: Key Data Type (Additions)\n"
- title: 6.3.  Timestamp Payload (T)
  contents:
  - "6.3.  Timestamp Payload (T)\n   For the timestamp payload, a new type of timestamp\
    \ is defined.  The\n   new type is intended to be used when defining validity\
    \ periods, where\n   fractions of seconds seldom matter.  The NTP-UTC-32 string\
    \ contains\n   four bytes, in the same format as the first four bytes in the NTP\n\
    \   timestamp format, defined in [RFC4330].  This represents the number\n   of\
    \ seconds since 0h on 1 January 1900 with respect to the Coordinated\n   Universal\
    \ Time (UTC).  On 7 February 2036, the time value will\n   overflow.  [RFC4330]\
    \ describes a procedure to extend the time to 2104\n   and this procedure is MANDATORY\
    \ to support.\n   *  TS Type (8 bits): specifies the timestamp type used.\n  \
    \                      TS Type    | Value | Length\n                        -----------+-------+--------\n\
    \                        NTP-UTC-32 |     3 | 32 bits\n                      \
    \ Table 6.8: TS Type (Additions)\n   NTP-UTC-32 SHALL be padded to a 64-bit NTP-UTC\
    \ timestamp (with zeroes\n   in the fractional second part) when a 64-bit timestamp\
    \ is required\n   (e.g.  IV creation in AES-CM-128 and AES-CM-256).\n"
- title: 6.4.  Timestamp Payload with Role Indicator (TR)
  contents:
  - "6.4.  Timestamp Payload with Role Indicator (TR)\n   The TR payload uses all\
    \ the fields from the standard timestamp\n   payload (T) but expands it with a\
    \ new field describing the role of\n   the timestamp.  Whereas the TS Type describes\
    \ the type of the TS\n   Value, the TS Role describes the meaning of the timestamp\
    \ itself.\n   The TR payload is intended to eliminate ambiguity when a MIKEY\n\
    \   message contains several timestamp payloads (e.g., in the Ticket\n   Policy).\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !    TS Role    !    TS Type    !    TS Value   ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  TS Role (8 bits): specifies the sort of timestamp.\n                  \
    \ TS Role                        | Value\n                   -------------------------------+------\n\
    \                   Time of issue (TRi)            |     1\n                 \
    \  Start of validity period (TRs) |     2\n                   End of validity\
    \ period (TRe)   |     3\n                   Rekeying interval (TRr)        |\
    \     4\n                             Table 6.9: TS Role\n"
- title: 6.5.  ID Payload (ID)
  contents:
  - "6.5.  ID Payload (ID)\n   For the ID payload, a new ID Type byte string is defined.\
    \  The byte\n   string type is intended to be used when the ID payload is used\
    \ to\n   identify a pre-shared key.  Contrary to the previously defined ID\n \
    \  Types (URI, Network Access Identifier), the byte string does not have\n   any\
    \ encoding rules.\n   *  ID Type (8 bits): specifies the identifier type used.\n\
    \                            ID Type     | Value\n                           \
    \ ------------+------\n                            Byte string |     2\n     \
    \                 Table 6.10: ID Type (Additions)\n"
- title: 6.6.  ID Payload with Role Indicator (IDR)
  contents:
  - "6.6.  ID Payload with Role Indicator (IDR)\n   The IDR payload uses all the fields\
    \ from the standard identity\n   payload (ID) but expands it with a new field\
    \ describing the role of\n   the ID payload.  Whereas the ID Type describes the\
    \ type of the ID\n   Data, the ID Role describes the meaning of the identity itself.\
    \  The\n   IDR payload is intended to eliminate ambiguity when a MIKEY message\n\
    \   contains several identity payloads.  The IDR payload MUST be used\n   instead\
    \ of the ID payload in all MIKEY-TICKET messages.\n    0                   1 \
    \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !    ID Role    !    ID Type    !     ID len\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     ID len (cont) !                    ID Data                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  ID Role (8 bits): specifies the sort of identity.\n                   \
    \   ID Role                 | Value\n                      ------------------------+------\n\
    \                      Initiator (IDRi)        |     1\n                     \
    \ Responder (IDRr)        |     2\n                      KMS (IDRkms)        \
    \    |     3\n                      Pre-Shared Key (IDRpsk) |     4\n        \
    \              Application (IDRapp)    |     5\n                            Table\
    \ 6.11: ID Role\n   IDRapp is intended to specify the authorized Application IDs\
    \ (see\n   Sections 5.1.3 and 6.10)\n"
- title: 6.7.  Cert Hash Payload (CHASH)
  contents:
  - "6.7.  Cert Hash Payload (CHASH)\n   *  Hash func (8 bits): indicates the hash\
    \ function that is used.\n      Besides the hash functions already defined in\
    \ [RFC3830], the\n      following hash function may be used.\n               \
    \       Hash func | Value | Hash Length\n                      ----------+-------+------------\n\
    \                      SHA-256   |     2 |    256 bits\n                     Table\
    \ 6.12: Hash func (Additions)\n   The SHA-256 hash function is defined in [FIPS.180-3].\n"
- title: 6.8.  RAND Payload with Role Indicator (RANDR)
  contents:
  - "6.8.  RAND Payload with Role Indicator (RANDR)\n   The RANDR payload uses all\
    \ the fields from the standard RAND payload\n   (RAND) but expands it with a new\
    \ field describing the role (the\n   generating entity) of the RAND.  The RANDR\
    \ payload is intended to\n   eliminate ambiguity when a MIKEY message contains\
    \ several RAND\n   payloads.\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !    RAND Role  !  RAND length  !     RAND      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  RAND Role (8 bits): specifies the entity that generated the RAND.\n   \
    \                      RAND Role          | Value\n                         -------------------+------\n\
    \                         Initiator (RANDRi) |     1\n                       \
    \  Responder (RANDRr) |     2\n                         KMS (RANDRkms)     | \
    \    3\n                           Table 6.13: RAND Role\n"
- title: 6.9.  Error Payload (ERR)
  contents:
  - "6.9.  Error Payload (ERR)\n   For the key data sub-payload, new types of errors\
    \ are defined.\n   *  Error no (8 bits): indicates the type of error that was\n\
    \      encountered.\n            Error no       | Value | Comments\n         \
    \   ---------------+-------+----------------------------\n            Invalid\
    \ TICKET |    14 | Ticket Type not supported\n            Invalid TPpar  |   \
    \ 15 | TP parameters not supported\n                      Table 6.14: Error no\
    \ (Additions)\n"
- title: 6.10.  Ticket Policy Payload (TP) / Ticket Payload (TICKET)
  contents:
  - "6.10.  Ticket Policy Payload (TP) / Ticket Payload (TICKET)\n   Note that the\
    \ Ticket Policy payload (TP) and the Ticket Payload\n   (TICKET) are two different\
    \ payloads (having different payload\n   identifiers).  However, as they share\
    \ much of the payload structure,\n   they are described in the same section.\n\
    \   The Ticket Policy payload contains a desired Ticket Policy and does\n   not\
    \ include the Ticket Data length, Ticket Data, Initiator Data\n   length, or Initiator\
    \ Data fields.  The ticket payload contains the\n   granted Ticket Policy as well\
    \ as Ticket Data (the default ticket type\n   is defined in Appendix A).  The\
    \ Ticket Policy contains information\n   intended for all parties involved whereas\
    \ the Ticket Data is only\n   intended for the party that resolves the ticket.\
    \  The Ticket Type\n   provided in the Ticket Data is indicated in the Ticket\
    \ Policy.  When\n   key forking is used (I flag), the Initiator Data authenticates\
    \ the\n   Initiator.\n   Note that the flags are not independent: NOT D implies\
    \ L, G implies\n   F, NOT G implies H, NOT H implies G, I implies E, K implies\
    \ D, and M\n   implies F.  The F flag SHALL be set to '1' when the I flag (key\n\
    \   forking) is set to '1' and a TGK is encoded in the ticket.\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !          Ticket Type          !    Subtype    !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !    Version    !   PRF Func  !D!E!F!G!H!I!J!K!L!M!N!O!   Res   !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !        TP Data length         !            TP Data            ~\n   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \   !      Ticket Data length       !          Ticket Data          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !     Initiator Data length     !   Initiator Data (OPTIONAL)   ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  Next Payload (8 bits): identifies the payload that is added after\n   \
    \   this payload.\n   *  Ticket Type (16 bits): specifies the Ticket Type used.\n\
    \           Ticket Type       | Value | Comments\n           ------------------+-------+---------------------------\n\
    \           MIKEY Base Ticket |     1 | Defined in Appendix A\n           3GPP\
    \ Base Ticket  |     2 | Used and specified by 3GPP\n                        \
    \  Table 6.15: Ticket Type\n   Subtype = 0x01 and Version = 0x01 refers to MIKEY\
    \ Base Ticket as\n   defined in this document.\n   *  Subtype (8 bits): specifies\
    \ the ticket subtype used.\n   *  Version (8 bits): specifies the ticket subtype\
    \ version used.\n   *  PRF Func (7 bits): specifies the PRF that SHALL be used\
    \ for key\n      forking.\n   *  D (1 bit): flag to indicate whether the ticket\
    \ was generated by\n      the KMS ('1') or by the Initiator ('0').\n   *  E (1\
    \ bit): flag to indicate whether the Ticket Resolve exchange is\n      MANDATORY\
    \ ('1') or if the Responder MAY resolve the ticket ('0').\n   *  F (1 bit): flag\
    \ to indicate whether the TRANSFER_RESP message\n      SHALL be sent ('1') or\
    \ if it SHALL NOT be sent ('0').\n   *  G (1 bit): flag to indicate whether the\
    \ Responder SHALL generate\n      RANDRr ('1') or if the Responder SHALL NOT generate\
    \ RANDRr ('0').\n   *  H (1 bit): flag to indicate whether RANDRi SHALL be used\
    \ when\n      deriving keys from a TGK/GTGK ('1') or if RANDRi SHALL NOT be used\n\
    \      ('0').\n   *  I (1 bit): flag to indicate whether key forking SHALL be\
    \ used\n      ('1') or if key forking SHALL NOT be used ('0').\n   *  J (1 bit):\
    \ flag to indicate whether the ticket MAY be reused ('1')\n      and therefore\
    \ MAY be cached or if it SHALL NOT be reused ('0').\n   *  K (1 bit): flag to\
    \ indicate whether the KMS changed the desired\n      Ticket Policy or the desired\
    \ KEMAC ('1') or if it did not ('0').\n      In the TP payload, it SHALL be set\
    \ to '0' by the Initiator and\n      ignored by the KMS.\n   *  L (1 bit): flag\
    \ to indicate whether the Initiator MAY supply\n      session keys ('1') or if\
    \ the Initiator SHALL NOT supply session\n      keys ('0').\n   *  M (1 bit):\
    \ flag to indicate whether the Responder MAY supply\n      session keys ('1')\
    \ or if the Responder SHALL NOT supply session\n      keys ('0').\n   *  N (1\
    \ bit): flag to indicate whether an Initiator following this\n      specification\
    \ can initiate a TRANSFER_INIT message using the\n      ticket ('1') or if additional\
    \ processing is required ('0').  If\n      the flag is set to '0', the Initiator\
    \ SHOULD follow the processing\n      in the specification of the received Ticket\
    \ Type.\n   *  O (1 bit): flag to indicate whether a Responder following this\n\
    \      specification can process a TRANSFER_INIT message containing the\n    \
    \  ticket ('1') or if additional processing is required ('0').  If\n      the\
    \ flag is set to '0', the Responder SHOULD follow the processing\n      in the\
    \ specification of the received Ticket Type.\n   *  Res (5 bits): reserved for\
    \ future use.\n   *  TP Data length (16 bits): length of TP Data (in bytes).\n\
    \   *  TP Data (variable length): The first 8 bits identify the first\n      payload.\
    \  The rest of TP Data SHALL be constructed of MIKEY\n      payloads.  Unexpected\
    \ payloads in the TP Data SHOULD be ignored.\n             TP Data = First Payload,\
    \ [IDRkms], [IDRi], [TRs],\n                       [TRe], [TRr], [KEMAC], {IDRapp},\
    \ (IDRr)\n      IDRkms contains the identity of a KMS that can resolve the ticket.\n\
    \      IDRi contains the identity of the peer that requested or created\n    \
    \  the ticket.\n      TRs is the start of the validity period.  TRs SHALL be interpreted\n\
    \      as being in the range 1968-2104 as described in [RFC4330].  An\n      omitted\
    \ TRs means that the validity period has no defined\n      beginning.\n      TRe\
    \ is the end of the validity period.  TRe SHALL be interpreted\n      as being\
    \ in the range 1968-2104 as described in [RFC4330].  An\n      omitted TRe means\
    \ that the validity period has no defined end.\n      TRr indicates how often\
    \ rekeying MUST be done.  TS Type SHALL be\n      NTP-UTC-32 and the time between\
    \ two rekeyings SHALL NOT be longer\n      than the number of seconds in the integer\
    \ part of the timestamp.\n      How the rekeying is done is implementation specific.\n\
    \      The KEMAC payload may be used to indicate the number of requested\n   \
    \   keys and specify other key information (key type, key length, and\n      KV\
    \ (key validity) data).  The KEMAC payload SHALL use the NULL\n      encryption\
    \ algorithm and the NULL authentication algorithm, as a\n      MAC is included\
    \ in the V payload.  The KEMAC is hence constructed\n      as follows:\n     \
    \                      KEMAC = {TEK|TGK|GTGK}\n   The Key Data fields SHALL be\
    \ set to '0' by the Initiator and ignored\n   by the KMS.  The KEMAC SHALL NOT\
    \ be present in the granted Ticket\n   Policy.\n      IDRapp is an identifier\
    \ for an authorized application ID.  The\n      application IDs are implementation\
    \ specific.  If no IDRapp\n      payloads are supplied, all application IDs are\
    \ authorized.\n      IDRr is the identity of a responder or a group of responders\
    \ that\n      are authorized to resolve the ticket.  If there is more than one\n\
    \      responder identity, each responder identity SHALL be included in a\n  \
    \    separate IDR payload.\n   *  Ticket Data length (16 bits): the length of\
    \ the Ticket Data field\n      (in bytes).  Not present in the TP payload.\n \
    \  *  Ticket Data (variable length): contains the Ticket Data.  Not\n      present\
    \ in the TP payload.\n   *  Initiator Data length (16 bits): the length of the\
    \ Initiator Data\n      field (in bytes).  Not present in the TP payload.\n  \
    \ *  Initiator Data (variable length): Not present in the TP payload.\n      SHALL\
    \ be inserted by the Initiator if and only if key forking is\n      used (I flag).\
    \  The first 8 bits identifies the first payload.\n      The rest of Initiator\
    \ Data SHALL be constructed of MIKEY payloads.\n      Unexpected payloads in the\
    \ Initiator Data SHOULD be ignored.\n                   Initiator Data = First\
    \ Payload, Vi, Vr\n      The Vi payload SHALL be identical to the V payload in\
    \ the\n      TRANSFER_INIT message.\n      The last payload (Vr) SHALL be a Verification\
    \ payload where the\n      MAC SHALL cover the entire Initiator Data field except\
    \ the MAC\n      field itself.  The authentication algorithm SHALL be the same\
    \ as\n      used for the Vi payload.  The authentication key (auth_key) SHALL\n\
    \      be derived from MPKr (not forked) using the following parameters:\n   \
    \   inkey:     : MPKr\n      inkey_len  : bit length of the inkey\n      label\
    \      : constant || 0xFF || 0xFFFFFFFF || 0x04\n      outkey_len : desired bit\
    \ length of the outkey (encr_key,\n                   auth_key, salt_key)\n  \
    \    The constant depends on the derived key type as defined in Section\n    \
    \  4.1.4 of [RFC3830].\n"
- title: 7.  Transport Protocols
  contents:
  - "7.  Transport Protocols\n   MIKEY messages are not tied to any specific transport\
    \ protocols.  In\n   [RFC4567], extensions for SDP and RTSP to carry MIKEY messages\
    \ (and\n   therefore MIKEY-TICKET messages) are defined.  The messages in the\n\
    \   Ticket Transfer exchange (TRANSFER_INIT, TRANSFER_RESP) are\n   preferably\
    \ included in the session setup signaling (e.g., SIP INVITE\n   and 200 OK). \
    \ However, it may not be suitable for the MIKEY-TICKET\n   exchanges that do not\
    \ establish keying material for media sessions\n   (Ticket Request and Ticket\
    \ Resolve) to be carried in SDP or RTSP.  If\n   SDP or RTSP is not used, the\
    \ transport protocol needs to be defined.\n   In [3GPP.33.328], it is defined\
    \ how the Ticket Request and Ticket\n   Resolve exchanges are carried over HTTP.\n"
- title: 8.  Pre-Encrypted Content
  contents:
  - "8.  Pre-Encrypted Content\n   The default setting is that the KMS supplies the\
    \ session keys\n   (encoded in the ticket).  This is not possible if the content\
    \ is pre-\n   encrypted (e.g., Video on Demand).  In such use cases, the key\n\
    \   exchange is typically reversed and MAY be carried out as follows.\n   The\
    \ Initiator sends a ticket without encoded session keys to the\n   Responder in\
    \ a TRANSFER_INIT message.  The Responder has access to\n   the TEKs used to protect\
    \ the requested content, but may not be\n   streaming the content.  The Responder\
    \ includes the TEK in the\n   TRANSFER_RESP message, which is sent to the Initiator.\n\
    \   +---+                                                           +---+\n  \
    \ | I |                                                           | R |\n   +---+\
    \                                                           +---+\n          \
    \                     TRANSFER_INIT\n     ---------------------------------------------------------------->\n\
    \                               TRANSFER_RESP {KEMAC}\n     <----------------------------------------------------------------\n\
    \              Figure 6: Distribution of pre-encrypted content\n"
- title: 9.  Group Communication
  contents:
  - "9.  Group Communication\n   What has been discussed up to now can also be used\
    \ for group\n   communication.  The MIKEY signaling for multi-party sessions can\
    \ be\n   centralized as illustrated in Figure 7.\n   +---+                   \
    \        +---+                           +---+\n   | A |                     \
    \      | B |                           | C |\n   +---+                       \
    \    +---+                           +---+\n              Ticket Transfer\n  \
    \   <------------------------------->        Ticket Transfer\n     <--------------------------------------------------------------->\n\
    \              Figure 7: Centralized signaling around party A\n   or decentralized\
    \ as illustrated in Figure 8.\n   +---+                           +---+      \
    \                     +---+\n   | A |                           | B |        \
    \                   | C |\n   +---+                           +---+          \
    \                 +---+\n              Ticket Transfer\n     <------------------------------->\
    \        Ticket Transfer\n                                     <------------------------------->\n\
    \                     Figure 8: Decentralized signaling\n   In the decentralized\
    \ scenario, the identities of B and C SHALL be\n   used in the second Ticket Transfer\
    \ exchange.  Independent of the how\n   the MIKEY signaling is done, a group key\
    \ may be used as session key.\n   If a group key is used, the group key and session\
    \ information may be\n   pushed to all group members (similar to [RFC3830]), or\
    \ distributed\n   when requested (similar to [RFC4738]).  If a TGK/GTGK is used\
    \ as a\n   group key, the same RANDs MUST be used to derive the session keys in\n\
    \   all Ticket Transfer exchanges.  Also note caveats with ticket reuse\n   in\
    \ group communication settings as discussed in Section 5.3.\n"
- title: 9.1.  Key Forking
  contents:
  - "9.1.  Key Forking\n   When key forking is used, only the user that requested\
    \ the ticket can\n   initiate a Ticket Transfer exchange using that ticket, see\n\
    \   Section 5.3.  So if a group key is to be distributed, the MIKEY\n   signaling\
    \ MUST be centralized to the party that initially requested\n   the ticket, or\
    \ different tickets needs to be used in each Ticket\n   Transfer exchange and\
    \ the group key needs to be sent in a KEMAC.\n   Another consideration is that\
    \ different users get different session\n   keys if TGKs (encoded in the ticket)\
    \ are used.\n"
- title: 10.  Signaling between Different KMSs
  contents:
  - "10.  Signaling between Different KMSs\n   A user can in general only be expected\
    \ to have a trust relation with\n   a single KMS.  Different users might therefore\
    \ use tickets issued by\n   different KMSs using only locally known keys.  Thus,\
    \ if users with\n   trust relations to different KMSs are to be able to establish\
    \ a\n   secure session with each other, the KMSs involved have to cooperate\n\
    \   and there has to be a trust relation between them.  The KMSs SHALL be\n  \
    \ mutually authenticated and signaling between them SHALL be integrity\n   and\
    \ confidentiality protected.  The technical means for the inter-KMS\n   security\
    \ is however outside the scope of this specification.  Under\n   these assumptions,\
    \ the following approach MAY be used.\n   +---+               +---+          \
    \    +-------+            +-------+\n   | I |               | R |            \
    \  | KMS R |            | KMS I |\n   +---+               +---+              +-------+\
    \            +-------+\n         TRANSFER_INIT\n     -------------------->   \
    \ RESOLVE_INIT\n                         - - - - - - - - - - ->    RESOLVE_INIT\n\
    \                                              - - - - - - - - - - ->\n      \
    \                                             RESOLVE_RESP\n                 \
    \             RESOLVE_RESP    <- - - - - - - - - - -\n         TRANSFER_RESP \
    \  < - - - - - - -  - - -\n     <--------------------\n                   Figure\
    \ 9: Routing of resolve messages\n   If the Responder cannot directly resolve\
    \ a ticket, the ticket SHOULD\n   be included in a RESOLVE_INIT message sent to\
    \ a KMS.  If the\n   Responder does not have a shared credential with the KMS\
    \ that issued\n   the ticket (KMS I) or if the Responder does not know which KMS\
    \ issued\n   the ticket, the Responder SHOULD send the RESOLVE_INIT message to\
    \ one\n   of the Responder's trusted KMSs (KMS R).  If KMS R did not issue the\n\
    \   ticket, KMS R would normally be unable to directly resolve the ticket\n  \
    \ and must hence ask another KMS to resolve it (typically the issuing\n   KMS).\n\
    \   The signaling between different KMSs MAY be done with a Ticket\n   Resolve\
    \ exchange as illustrated in Figure 9.  The IDRr and TICKET\n   payloads from\
    \ the previous RESOLVE_INIT message SHOULD be reused.\n   Note that IDRr cannot\
    \ be used to look up the pre-shared key/\n   certificate.\n"
- title: 11.  Adding New Ticket Types to MIKEY-TICKET
  contents:
  - "11.  Adding New Ticket Types to MIKEY-TICKET\n   The Ticket Data (in the TICKET\
    \ payload) could be a reference to\n   information (keys, etc.) stored by the\
    \ key management service, it\n   could contain all the information itself, or\
    \ it could be a\n   combination of the two alternatives.  For systems serving\
    \ many users,\n   it is not ideal to use the reference-only ticket approach as\
    \ this\n   would force the key management service to keep state of all issued\n\
    \   tickets that are still valid.  Tickets may carry many different types\n  \
    \ of information helping to enforce usage policies.  The policies may\n   be group\
    \ policies or per-user policies.\n   Tickets may either be transparent, meaning\
    \ they can be resolved\n   without contacting the KMS that generated them, or\
    \ opaque, meaning\n   that the original KMS must be contacted.  The ticket information\n\
    \   SHOULD typically be integrity protected and certain fields need\n   confidentiality\
    \ protection, in particular, the keys if explicitly\n   included.  Other types\
    \ of information may also require\n   confidentiality protection due to privacy\
    \ reasons.  In mode 2 (see\n   Section 4.1.1), it may be preferable to include\
    \ several encrypted\n   ticket protection keys (similar to Secure/Multipurpose\
    \ Internet Mail\n   Extensions (S/MIME)) as this may allow multiple peers to resolve\
    \ the\n   ticket.\n   The Ticket Data MUST include information so that the resolving\
    \ party\n   can retrieve an encoded KEMAC.  It MUST also be possible to verify\n\
    \   the integrity of the TICKET payload.  It is RECOMMENDED that future\n   specifications\
    \ use the recommended payload order and do not add any\n   additional payloads\
    \ or processing.  New Ticket Types SHOULD NOT\n   change the processing for the\
    \ Responder.  If a new Ticket Type\n   requires additional processing, it MUST\
    \ be indicated in the Ticket\n   Policy (N and O flags).  New specifications MUST\
    \ specify which modes\n   are supported and if any additional security considerations\
    \ apply.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   Unless otherwise stated, the security considerations\
    \ in [RFC3830]\n   still apply and contain notes on the security properties of\
    \ the MIKEY\n   protocol, key derivation functions, and other components.  As\
    \ some\n   security properties depend on the specific Ticket Type, only generic\n\
    \   security considerations concerning the MIKEY-TICKET framework are\n   discussed.\n\
    \   This specification includes a large number of optional features,\n   which\
    \ adds complexity to the general case.  Protocol designers are\n   strongly encouraged\
    \ to establish strict profiles defining MIKEY-\n   TICKET options (e.g., exchanges\
    \ or message fields) that SHOULD or\n   MUST be supported.  Such profiles should\
    \ preclude unexpected\n   consequences from compliant implementations with wildly\
    \ differing\n   option sets.\n"
- title: 12.1.  General
  contents:
  - "12.1.  General\n   In addition to the Ticket Policy, the KMS MAY have its own\
    \ set of\n   policies (authorized key lengths, algorithms, etc.) that in some\
    \ way\n   are shared with the peers.  The KMS MAY also provide keying material\n\
    \   to authorized intermediate nodes performing various network functions\n  \
    \ (e.g., transcoding services, recording services, conference bridges).\n   The\
    \ key management service can enforce end-to-end security by only\n   distributing\
    \ the keys to authorized end-users.  As in [RFC3830], the\n   user identities\
    \ are not confidentiality protected.  If user privacy\n   is needed, some kind\
    \ of Privacy Enhancing Technologies (PET) like\n   anonymous or temporary credentials\
    \ MAY be used.\n   In the standard MIKEY modes [RFC3830], the keys are generated\
    \ by the\n   Initiator (or by both peers in the Diffie-Hellman scheme).  If a\
    \ bad\n   PRNG (Pseudorandom Number Generator) is used, this is likely to make\n\
    \   any key management protocol sensitive to different kinds of attacks,\n   and\
    \ MIKEY is no exception.  As the choice of the PRNG is\n   implementation specific,\
    \ the easiest (and often bad) choice is to use\n   the PRNG supplied by the operating\
    \ system.  In MIKEY-TICKET's default\n   mode of operation, the key generation\
    \ is mostly done by the KMS,\n   which can be assumed to be less likely to use\
    \ a bad random number\n   generator.  All keys (including keys used to protect\
    \ the ticket) MUST\n   have adequate strength/length, i.e., 128 bits or more.\n\
    \   The use of random nonces (RANDs) in the key derivation is of utmost\n   importance\
    \ to counter offline pre-computation attacks and other\n   generic attacks.  A\
    \ key of length n, using RANDs of length r, has\n   effective key entropy of (n\
    \ + r) / 2 against a birthday attack.\n   Therefore, the sum of the lengths of\
    \ RANDRi and RANDRr MUST at least\n   be equal to the size of the longest pre-shared\
    \ key/envelope key/MPK/\n   TGK/GTGK, RANDRkms MUST at least be as long as the\
    \ longest MPKr/TGK,\n   and the RAND in the MIKEY base ticket MUST at least be\
    \ as long as the\n   longest of TPK and MPK.\n   Note that the CSB Updating messages\
    \ reuse the old RANDs.  This means\n   that the total effective key entropy (relative\
    \ to pre-computation\n   attacks) for k consecutive key updates, assuming the\
    \ TGKs are each n\n   bits long, is still no more than n bits.  In other words,\
    \ the time\n   and memory needed by an attacker to get all k n-bit keys are\n\
    \   proportional to 2^n.  While this might seem like a defect, this is in\n  \
    \ practice (for all reasonable values of k) not better than brute\n   force, which\
    \ on average requires k * 2^(n-1) work (even if different\n   RANDs would be used).\
    \  A birthday attack would only require 2^(n/2)\n   work, but would need access\
    \ to 2^(n/2) sessions protected with\n   equally many different keys using a single\
    \ pair of RANDs.  This is,\n   for typical values of n, clearly totally infeasible.\
    \  The success\n   probability of such an attack can be controlled by limiting\
    \ the\n   number of updates correspondingly.  As stated in [RFC3830], the fact\n\
    \   that more than one key can be compromised in a single attack is\n   inherent\
    \ to any solution using secret- or public-key algorithms.  An\n   attacker always\
    \ gets access to all the exchanged keys by doing an\n   exhaustive search on the\
    \ pre-shared key/envelope key/MPK.  This\n   requires 2^m work, where m is the\
    \ effective size of the key.\n   As the Responder MAY generate a RAND, the Ticket\
    \ Transfer exchange\n   can provide mutual freshness guarantee for all derived\
    \ keys.\n   The new algorithms PRF-HMAC-SHA-256, AES-CM-256, and HMAC-SHA-256-256\n\
    \   use 256-bit keys and offer a higher security level than the\n   previously\
    \ defined algorithms.  If one of the 256-bit algorithms are\n   supported, the\
    \ other two algorithms SHALL also be supported.  The\n   256-bit algorithms SHOULD\
    \ be used together, and they SHALL NOT be\n   mixed with algorithms using key\
    \ sizes less than 256 bits.  If session\n   keys (TEK/TGK/GTGK) longer than 128\
    \ bits are used, 128-bit algorithms\n   SHALL NOT be used.\n"
- title: 12.2.  Key Forking
  contents:
  - "12.2.  Key Forking\n   In some situations, the TRANSFER_INIT message may be delivered\
    \ to\n   multiple endpoints.  For example, when a Responder is registered on\n\
    \   several devices (e.g., mobile phone, fixed phone, and computer) or\n   when\
    \ an invite is being made to addresses of the type\n   IT-support@example.com,\
    \ a group of users where only one is supposed\n   to answer.  The Initiator may\
    \ not even always know exactly who the\n   authorized group members are.  To prevent\
    \ all forms of eavesdropping,\n   entities other than the endpoint that answers\
    \ MUST NOT get access to\n   the session keys.\n   When key forking is not used,\
    \ keys are accessible by everyone that\n   can resolve the ticket.  When key forking\
    \ is used, some keys (MPKr\n   and TGKs encoded in the ticket) are modified, making\
    \ them\n   cryptographically unique for each responder targeted by the forking.\n\
    \   As only the Initiator and the KMS have access to the master TGKs, it\n   is\
    \ infeasible for anyone else to derive the session keys.\n   When key forking\
    \ is used, some keys (MPKi and TEKs and GTGK encoded\n   in the ticket) are still\
    \ accessible by everyone that can resolve the\n   ticket and should be used with\
    \ this in mind.  This also concerns\n   session keys transferred in a KEMAC in\
    \ the first TRANSFER_INIT (as\n   they are protected with MPKi).\n"
- title: 12.3.  Denial of Service
  contents:
  - "12.3.  Denial of Service\n   This protocol is resistant to denial-of-service\
    \ attacks against the\n   KMS in the sense that it does not construct any state\
    \ (at the key\n   management protocol level) before it has authenticated the Initiator\n\
    \   or Responder.  Since the Responder, in general, cannot verify the\n   validity\
    \ of a TRANSFER_INIT message without first contacting the KMS,\n   denial of service\
    \ may be launched against the Responder and/or the\n   KMS via the Responder.\
    \  Typical prevention methods such as rate-\n   limiting and ACL (Access Control\
    \ List) capability SHOULD therefore be\n   implemented in the KMS as well as the\
    \ clients.  If something in the\n   signaling is suspicious, the Responder SHOULD\
    \ abort before attempting\n   a RESOLVE_INIT with the KMS.  The types and amount\
    \ of prevention\n   needed depends on how critical the system is and may vary\
    \ depending\n   on the Ticket Type.\n"
- title: 12.4.  Replay
  contents:
  - "12.4.  Replay\n   In a replay attack, an attacker may intercept and later retransmit\n\
    \   the whole or part of a MIKEY message, attempting to trick the\n   receiver\
    \ (Responder or KMS) into undesired operations, e.g., leading\n   to a lack of\
    \ key freshness.  MIKEY-TICKET implements several\n   mechanisms to prevent and\
    \ detect such attacks.  Timestamps together\n   with a replay cache efficiently\
    \ stop the replay of entire MIKEY\n   messages.  Parts of the received messages\
    \ (or their hashes) can be\n   saved in the replay cache until their timestamp\
    \ is outdated.  To\n   prevent replay attacks, the sender's (Initiator or Responder)\
    \ and the\n   receiver's (Responder or KMS) identity is always (explicitly or\n\
    \   implicitly) included in the MAC/Signature calculation.\n   An attacker may\
    \ also attempt to replay a ticket by inserting it into\n   a new MIKEY message.\
    \  A possible scenario is that Alice and Bob first\n   communicate based on a\
    \ ticket, which an attacker Mallory intercepts.\n   Later, Mallory (acting as\
    \ herself) invites Bob by inserting the\n   ticket into her own TRANSFER_INIT\
    \ message.  If key forking is used,\n   such replays will always be detected when\
    \ Bob has resolved the\n   ticket.  If key forking is not used, such replays will\
    \ be detected\n   unless Mallory has knowledge of the MPKi.  And if Mallory has\n\
    \   knowledge of the MPKi (i.e., she is authorized to resolve the ticket)\n  \
    \ and key forking is not used, there is no attack.  For the reasons\n   explained\
    \ above, it is RECOMMENDED to use key forking.\n"
- title: 12.5.  Group Key Management
  contents:
  - "12.5.  Group Key Management\n   In a group scenario, only authorized group members\
    \ must have access\n   to the keys.  In some situation, the communication may\
    \ be initiated\n   by the Initiator using a group identity and the Initiator may\
    \ not\n   even know exactly who the authorized group members are.  Moreover,\n\
    \   group membership may change over time due to leaves/joins.  In such a\n  \
    \ situation, it is foremost the responsibility of the KMS to reject\n   ticket\
    \ resolution requests from unauthorized responders, implying\n   that the KMS\
    \ needs to be able to map an individual's identity\n   (carried in the RESOLVE_INIT\
    \ message) to group membership (where the\n   group identity is carried in the\
    \ ticket).\n   As noted, reuse of tickets, which bypasses the KMS, is NOT\n  \
    \ RECOMMENDED when the Initiator is not fully ensured about group\n   membership\
    \ status.\n"
- title: 13.  Acknowledgements
  contents:
  - "13.  Acknowledgements\n   The authors would like to thank Fredrik Ahlqvist, Rolf\
    \ Blom, Yi\n   Cheng, Lakshminath Dondeti, Vesa Lehtovirta, Fredrik Lindholm,\
    \ Mats\n   Naslund, Karl Norrman, Oscar Ohlsson, Brian Rosenberg, Bengt Sahlin,\n\
    \   Wei Yinxing, and Zhu Yunwen for their support and valuable comments.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   This document defines several new values for the\
    \ namespaces Data\n   Type, Next Payload, PRF func, CS ID map type, Encr alg,\
    \ MAC alg, TS\n   Type, ID Type, Hash func, Error no, and Key Data Type defined\
    \ in\n   [RFC3830].  The following IANA assignments were added to the MIKEY\n\
    \   Payload registry (in parentheses is a reference to the table\n   containing\
    \ the registered values):\n   o  Data Type (see Table 6.1)\n   o  Next Payload\
    \ (see Table 6.2)\n   o  PRF func (see Table 6.3)\n   o  CS ID map type (see Table\
    \ 6.4)\n   o  Encr alg (see Table 6.5)\n   o  MAC alg (see Table 6.6)\n   o  TS\
    \ Type (see Table 6.7)\n   o  ID Type (see Table 6.9)\n   o  Hash func (see Table\
    \ 6.11)\n   o  Error no (see Table 6.13)\n   o  Key Data Type (see Table 6.14)\n\
    \   The TR payload defines an 8-bit TS Role field for which IANA has\n   created\
    \ and will maintain a new namespace in the MIKEY Payload\n   registry.  Assignments\
    \ consist of a TS Role name and its associated\n   value.  Values in the range\
    \ 1-239 SHOULD be approved by the process\n   of Specification Required, values\
    \ in the range 240-254 are Reserved\n   for Private Use, and the values 0 and\
    \ 255 are Reserved according to\n   [RFC5226].  The initial contents of the registry\
    \ are as follows:\n                  Value    TS Role\n                  -------\
    \  ------------------------------\n                  0        Reserved\n     \
    \             1        Time of issue (TRi)\n                  2        Start of\
    \ validity period (TRs)\n                  3        End of validity period (TRe)\n\
    \                  4        Rekeying interval (TRr)\n                  5-239 \
    \   Unassigned\n                  240-254  Reserved for Private Use\n        \
    \          255      Reserved\n   The IDR payload defines an 8-bit ID Role field\
    \ for which IANA has\n   created and will maintain a new namespace in the MIKEY\
    \ Payload\n   registry.  Assignments consist of an ID Role name and its associated\n\
    \   value.  Values in the range 1-239 SHOULD be approved by the process\n   of\
    \ Specification Required, values in the range 240-254 are Reserved\n   for Private\
    \ Use, and the values 0 and 255 are Reserved according to\n   [RFC5226].  The\
    \ initial contents of the registry are as follows:\n                     Value\
    \    ID Role\n                     -------  -----------------------\n        \
    \             0        Reserved\n                     1        Initiator (IDRi)\n\
    \                     2        Responder (IDRr)\n                     3      \
    \  KMS (IDRkms)\n                     4        Pre-Shared Key (IDRpsk)\n     \
    \                5        Application (IDRapp)\n                     6-239   \
    \ Unassigned\n                     240-254  Reserved for Private Use\n       \
    \              255      Reserved\n   The RANDR payload defines an 8-bit RAND Role\
    \ field for which IANA has\n   created and will maintain a new namespace in the\
    \ MIKEY Payload\n   registry.  Assignments consist of a RAND Role name and its\
    \ associated\n   value.  Values in the range 1-239 SHOULD be approved by the process\n\
    \   of Specification Required, values in the range 240-254 are Reserved\n   for\
    \ Private Use, and the values 0 and 255 are Reserved according to\n   [RFC5226].\
    \  The initial contents of the registry are as follows:\n                    \
    \ Value    RAND Role\n                     -------  ------------------\n     \
    \                0        Reserved\n                     1        Initiator (RANDRi)\n\
    \                     2        Responder (RANDRr)\n                     3    \
    \    KMS (RANDRkms)\n                     4-239    Unassigned\n              \
    \       240-254  Reserved for Private Use\n                     255      Reserved\n\
    \   The TP/TICKET payload defines a 16-bit Ticket Type field for which\n   IANA\
    \ has created and will maintain a new namespace in the MIKEY\n   Payload registry.\
    \  Assignments consist of a Ticket Type name and its\n   associated value.  Values\
    \ in the range 1-61439 SHOULD be approved by\n   the process of Specification\
    \ Required, values in the range 61440-\n   65534 are Reserved for Private Use,\
    \ and the values 0 and 65535 are\n   Reserved according to [RFC5226].  The initial\
    \ contents of the\n   registry are as follows:\n                   Value     \
    \   Ticket Type\n                   -----------  -----------------\n         \
    \          0            Reserved\n                   1            MIKEY base ticket\n\
    \                   2            3GPP base ticket\n                   3-61439\
    \      Unassigned\n                   61440-65534  Reserved for Private Use\n\
    \                   65535        Reserved\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [FIPS.180-3]   National Institute of Standards\
    \ and Technology,\n                  \"Secure Hash Standard (SHS)\", FIPS PUB\
    \ 180-3,\n                  October 2008, <http://csrc.nist.gov/publications/fips/\n\
    \                  fips180-3/fips180-3_final.pdf>.\n   [RFC2104]      Krawczyk,\
    \ H., Bellare, M., and R. Canetti, \"HMAC:\n                  Keyed-Hashing for\
    \ Message Authentication\", RFC 2104,\n                  February 1997.\n   [RFC2119]\
    \      Bradner, S., \"Key words for use in RFCs to Indicate\n                \
    \  Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3830]      Arkko,\
    \ J., Carrara, E., Lindholm, F., Naslund, M., and\n                  K. Norrman,\
    \ \"MIKEY: Multimedia Internet KEYing\",\n                  RFC 3830, August 2004.\n\
    \   [RFC4330]      Mills, D., \"Simple Network Time Protocol (SNTP)\n        \
    \          Version 4 for IPv4, IPv6 and OSI\", RFC 4330,\n                  January\
    \ 2006.\n   [RFC4563]      Carrara, E., Lehtovirta, V., and K. Norrman, \"The\
    \ Key\n                  ID Information Type for the General Extension Payload\n\
    \                  in Multimedia Internet KEYing (MIKEY)\", RFC 4563,\n      \
    \            June 2006.\n   [RFC4567]      Arkko, J., Lindholm, F., Naslund, M.,\
    \ Norrman, K., and\n                  E. Carrara, \"Key Management Extensions\
    \ for Session\n                  Description Protocol (SDP) and Real Time Streaming\n\
    \                  Protocol (RTSP)\", RFC 4567, July 2006.\n   [RFC4738]     \
    \ Ignjatic, D., Dondeti, L., Audet, F., and P. Lin,\n                  \"MIKEY-RSA-R:\
    \ An Additional Mode of Key Distribution\n                  in Multimedia Internet\
    \ KEYing (MIKEY)\", RFC 4738,\n                  November 2006.\n   [RFC5226]\
    \      Narten, T. and H. Alvestrand, \"Guidelines for Writing\n              \
    \    an IANA Considerations Section in RFCs\", BCP 26,\n                  RFC\
    \ 5226, May 2008.\n"
- title: 15.2.   Informative References
  contents:
  - "15.2.   Informative References\n   [3GPP.33.328]  3GPP, \"IP Multimedia Subsystem\
    \ (IMS) media plane\n                  security\", 3GPP TS 33.328 9.3.0, December\
    \ 2010.\n   [Otway-Rees]   Otway, D., and O. Rees, \"Efficient and Timely Mutual\n\
    \                  Authentication\", ACM SIGOPS Operating Systems\n          \
    \        Review v.21 n.1, p.8-10, January 1987.\n   [RFC3261]      Rosenberg,\
    \ J., Schulzrinne, H., Camarillo, G.,\n                  Johnston, A., Peterson,\
    \ J., Sparks, R., Handley, M.,\n                  and E. Schooler, \"SIP: Session\
    \ Initiation Protocol\",\n                  RFC 3261, June 2002.\n   [RFC4120]\
    \      Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n              \
    \    Kerberos Network Authentication Service (V5)\",\n                  RFC 4120,\
    \ July 2005.\n   [RFC4650]      Euchner, M., \"HMAC-Authenticated Diffie-Hellman\
    \ for\n                  Multimedia Internet KEYing (MIKEY)\", RFC 4650,\n   \
    \               September 2006.\n   [RFC5197]      Fries, S. and D. Ignjatic,\
    \ \"On the Applicability of\n                  Various Multimedia Internet KEYing\
    \ (MIKEY) Modes and\n                  Extensions\", RFC 5197, June 2008.\n  \
    \ [RFC5479]      Wing, D., Fries, S., Tschofenig, H., and F. Audet,\n        \
    \          \"Requirements and Analysis of Media Security\n                  Management\
    \ Protocols\", RFC 5479, April 2009.\n"
- title: Appendix A.  MIKEY Base Ticket
  contents:
  - "Appendix A.  MIKEY Base Ticket\n   The MIKEY base ticket MAY be used in any of\
    \ the modes described in\n   Section 4.1.1.  The Ticket Data SHALL be constructed\
    \ of MIKEY\n   payloads and SHALL be protected by a MAC based on a pre-shared\
    \ Ticket\n   Protection Key (TPK).  The parties that shares the TPK depends on\
    \ the\n   mode.  Unexpected payloads in the Ticket Data SHOULD be ignored.\n \
    \             Ticket Data = THDR, T, RAND, KEMAC, [IDRpsk], V\n"
- title: A.1.  Components of the Ticket Data
  contents:
  - "A.1.  Components of the Ticket Data\n   The Ticket Data MUST always begin with\
    \ a Ticket Header payload\n   (THDR).  The ticket header is a new payload type;\
    \ for the definition,\n   see Appendix A.3.\n   T is a timestamp containing the\
    \ time of issue or a counter.  It MAY\n   be used in the IV (Initialization Vector)\
    \ formation (e.g., Section\n   4.2.3 of [RFC3830]).\n   RAND is used as input\
    \ to the key derivation function when keys are\n   derived from the TPK and the\
    \ MPK (see Appendices A.2.1 and A.2.2).\n   The KEMAC payload SHALL use the NULL\
    \ authentication algorithm, as a\n   MAC is included in the V payload.  The encryption\
    \ key (encr_key) and\n   salting key (salt_key) SHALL be derived from the TPK\
    \ (see\n   Appendix A.2.1).  Depending on the encryption algorithm, the salting\n\
    \   key be used in the IV creation (see Section 4.2.3 of [RFC3830]).  If\n   CSB\
    \ ID is needed in the IV creation it SHALL be set to '0xFFFFFFFF'.\n   The KEMAC\
    \ is hence constructed as follows:\n                 KEMAC = E(encr_key, MPK ||\
    \ {TEK|TGK|GTGK})\n   MPKi and MPKr are derived from the MPK as defined in Appendix\
    \ A.2.2.\n   IDRpsk contains an identifier that enables the KMS/Responder to\n\
    \   retrieve the TPK.  It MAY be omitted when the TPK can be retrieved\n   anyhow.\n\
    \   The last payload SHALL be a Verification payload (V) where the\n   authentication\
    \ key (auth_key) is derived from the TPK.  The MAC SHALL\n   be calculated over\
    \ the entire TICKET payload except the Next Payload\n   field (in the TICKET payload),\
    \ the Initiator Data length field, the\n   Initiator Data field, and the MAC field\
    \ itself.\n"
- title: A.2.  Key Derivation
  contents:
  - "A.2.  Key Derivation\n   The labels in the key derivations SHALL NOT include\
    \ entire RAND\n   payloads, only the fields RAND length and RAND from the corresponding\n\
    \   payload.\n"
- title: A.2.1.  Deriving Keys from a TPK
  contents:
  - "A.2.1.  Deriving Keys from a TPK\n   In the following, we describe how keying\
    \ material is derived from a\n   TPK.  The key derivation method SHALL be executed\
    \ using the PRF\n   indicated in the Ticket Policy.  The parameters for the PRF\
    \ are:\n   inkey:     : TPK\n   inkey_len  : bit length of the inkey\n   label\
    \      : constant || 0xFF || 0xFFFFFFFF || 0x05 ||\n                length RAND\
    \ || RAND\n   outkey_len : desired bit length of the outkey (encr_key,\n     \
    \           auth_key, salt_key)\n   Length RAND is the length of RAND in bytes\
    \ as an 8-bit unsigned\n   integer.  The constants are as defined in Section 4.1.4\
    \ of [RFC3830].\n   The key derivation and its dependencies on Ticket Data contents\
    \ when\n   AES-CM is used are illustrated in Figure 10.  The key derivation is\n\
    \   done by the party that creates the ticket (KMS or Initiator) and by\n   the\
    \ party that resolves the ticket (KMS or Responder).  The\n   encryption key and\
    \ the IV are used to encrypt the KEMAC.\n                                 -----\
    \          auth_key        ------\n              -----     TPK     |     |----------------------->|\
    \ AUTH |\n             | TPK |----------->|     |       encr_key          ------\n\
    \              -----             | PRF |--------------------+       |\n      \
    \          ^           +-->|     |     salt_key       |       |\n            \
    \    :           |   |     |----------------+   |       |\n                : \
    \          |    -----                 |   |       |\n                :       \
    \    |                          v   |       |\n       identify :      RAND | \
    \           TS value    ----  |       | MAC\n                :           |   \
    \      +------------>| IV | |       |\n                :           |         |\
    \              ----  |       |\n                :           |         |      \
    \       IV |   |       |\n                :           |         |            \
    \    v   v       v\n   Ticket   +---+----+---+--+---+---+-+-+------------+-------+---+---+\n\
    \    Data    | IDRpsk |...| RAND |...| T |............| KEMAC |...| V |\n    \
    \        +--------+---+------+---+---+------------+-------+---+---+\n        \
    \            Figure 10: Deriving keys from a TPK\n"
- title: A.2.2.  Deriving MPKi and MPKr
  contents:
  - "A.2.2.  Deriving MPKi and MPKr\n   In the following, we describe how MPKi and\
    \ MPKr are derived from the\n   MPK in the KEMAC payload.  The key derivation\
    \ method SHALL be\n   executed using the PRF indicated in the Ticket Policy. \
    \ The\n   parameters for the PRF are:\n   inkey:     : MPK\n   inkey_len  : bit\
    \ length of the inkey\n   label      : constant || 0xFF || 0xFFFFFFFF || 0x06\
    \ ||\n                length RAND || RAND\n   outkey_len : desired bit length\
    \ of the outkey (MPKi, MPKr)\n                SHALL be equal to inkey_len\n  \
    \ Length RAND is the length of RAND in bytes as an 8-bit unsigned\n   integer.\
    \  The constant depends on the derived key type as summarized\n   below.\n   \
    \                       Derived key | Constant\n                          ------------+-----------\n\
    \                          MPKi        | 0x220E99A2\n                        \
    \  MPKr        | 0x1F4D675B\n                Table A.1: Constants for MPK key\
    \ derivation\n   The constants are taken from the decimal digits of e as described\
    \ in\n   [RFC3830].\n"
- title: A.3.  Ticket Header Payload (THDR)
  contents:
  - "A.3.  Ticket Header Payload (THDR)\n   The ticket header payload contains an\
    \ indicator of the next payload\n   as well as implementation-specific data.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !        THDR Data length       !   THDR Data   ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   *  Next Payload (8 bits): identifies the payload that is added after\n   \
    \   this payload.\n   *  THDR Data length (16 bits): the length of the THDR Data\
    \ field (in\n      bytes).\n   *  THDR Data (variable length): implementation\
    \ specific data that\n      SHOULD be ignored if it is not expected.\n"
- title: Appendix B.  Alternative Use Cases
  contents:
  - 'Appendix B.  Alternative Use Cases

    '
- title: B.1.  Compatibility Mode
  contents:
  - "B.1.  Compatibility Mode\n   MIKEY-TICKET can be used to define a Ticket Type\
    \ compatible with\n   [RFC3830] or any other half-round-trip key management protocol.\
    \  The\n   Initiator requests and gets a ticket from the KMS where the Ticket\n\
    \   Data is a [RFC3830] message protected with a pre-shared key\n   (KMS-Responder)\
    \ or with the Responder's certificate.  The Ticket Data\n   is then sent to the\
    \ Responder according to [RFC3830].  In this way,\n   the Initiator can communicate\
    \ with a Responder that only supports\n   [RFC3830] and with whom the Initiator\
    \ do not have any shared\n   credentials.\n   +---+                          +-----+\
    \                          +---+\n   | I |                          | KMS |  \
    \                        | R |\n   +---+                          +-----+    \
    \                      +---+\n               REQUEST_INIT\n     -------------------------------->\n\
    \               REQUEST_RESP\n     <--------------------------------\n       \
    \                         3830 MIKEY\n     ---------------------------------------------------------------->\n\
    \                       Figure 11: Compatibility mode\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Mattsson\n   Ericsson AB\n   SE-164 80 Stockholm\n\
    \   Sweden\n   Phone: +46 10 71 43 501\n   EMail: john.mattsson@ericsson.com\n\
    \   Tian Tian\n   ZTE Corporation\n   4F, RD Building 2, Zijinghua Road\n   Yuhuatai\
    \ District, Nanjing 210012\n   P.R. China\n   Phone: +86-025-5287-7867\n   EMail:\
    \ tian.tian1@zte.com.cn\n"
