- title: __initial_text__
  contents:
  - '   An SNMP Application Level Gateway for Payload Address Translation

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This document describes an SNMP application layer gateway (ALG),\n\
    \   which may be useful in certain environments.  The document does also\n   list\
    \ the issues and problems that can arise when used as a generic\n   SNMP ALG.\
    \  Specifically, when using SNMPv3's authentication and\n   privacy mechanisms\
    \ this approach may be very problematic and\n   jeopardize the SNMP security.\
    \  The reader is urged to carefully\n   consider these issues before deciding\
    \ to deploy this type of SNMP\n   ALG.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the ALG (Application Level Gateway) for\
    \ the\n   SNMP (Simple Network Management Protocol) by which IP (Internet\n  \
    \ Protocol) addresses in the payload of SNMP packets are statically\n   mapped\
    \ from one group to another.  The SNMP ALG is a specific case of\n   an Application\
    \ Level Gateway as described in [15].\n   An SNMP ALG allows network management\
    \ stations to manage multiple\n   networks that use conflicting IP addresses.\
    \  This can be important in\n   environments where there is a need to use SNMP\
    \ with NAT (Network\n   Address Translator) in order to manage several potentially\n\
    \   overlapping addressing realms.\n   This document includes a detailed description\
    \ of the requirements and\n   limitations for an implementation of an SNMP Application\
    \ Level\n   Gateway.  It also discusses other approaches to exchange SNMP packets\n\
    \   across conflicting addressing realms.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction ..................................................2\n\
    \   2.  Terminology and Concepts Used  ................................5\n   3.\
    \  Problem Scope and Requirements ................................5\n   3.1 IP\
    \ Addresses in SNMP Messages  ................................6\n   3.2 Requirements\
    \ ..................................................7\n   4.  Translating IP Addresses\
    \ in SNMP Packets ......................7\n   4.1 Basic SNMP Application Level\
    \ Gateway ..........................8\n   4.2 Advanced SNMP Application Level\
    \ Gateway  ......................8\n   4.3 Packet Size and UDP Checksum ..................................9\n\
    \   5.  Limitations and Alternate Solutions  .........................10\n   6.\
    \  Security Considerations  .....................................12\n   7.  Summary\
    \ and Recommendations  .................................13\n   8.  Current Implementations\
    \  .....................................14\n   9.  Acknowledgments  .............................................14\n\
    \   10. References ...................................................14\n   11.\
    \ Authors' Addresses ...........................................16\n   12. Description\
    \ of the Encoding of SNMP Packets  .................17\n   13. Full Copyright\
    \ Statement .....................................20\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The need for IP address translation arises when a network's\
    \ internal\n   IP addresses cannot be used outside the network.  Using basic network\n\
    \   address translation allows local hosts on such private networks\n   (addressing\
    \ realms) to transparently access the external global\n   Internet and enables\
    \ access to selective local hosts from the\n   outside.  In particular it is not\
    \ unlikely to have several addressing\n   realms that are using the same private\
    \ IPv4 address space within the\n   same organization.\n   In many of these cases,\
    \ there is a need to manage the local\n   addressing realm from a manager site\
    \ outside the domain. However,\n   managing such a network presents unique problems\
    \ and challenges.\n   Most available management applications use SNMP (Simple\
    \ Network\n   Management Protocol) to retrieve information from the network\n\
    \   elements.  For example, a router may be queried by the management\n   application\
    \ about the addresses of its neighboring elements.  This\n   information is then\
    \ sent by the router back to the management\n   station as part of the payload\
    \ of an SNMP packet. In order to retain\n   consistency in the view as seen by\
    \ the management station we need to\n   be able to locate and translate IP address\
    \ related information in the\n   payload of such packets.\n   The SNMP Application\
    \ Level Gateway for Payload Address Translation,\n   or SNMP ALG, is a technique\
    \ in which the payload of SNMP packets\n   (PDUs) is scanned and IP address related\
    \ information is translated if\n   needed.  In this context, an SNMP ALG can be\
    \ an additional component\n   in a NAT implementation, or it can be a separate\
    \ entity, that may\n   reside in the same gateway or even on a separate node.\
    \  Note that in\n   our context of management application all devices in the network\
    \ are\n   assumed to have a fixed IP address.  Thus, SNMP ALG should only be\n\
    \   combined with NAT that uses static address assignment for all the\n   devices\
    \ in the network.\n   A typical scenario where SNMP ALG is deployed as part of\
    \ NAT is\n   presented in figure Figure 1.  A manager device is managing a remote\n\
    \   stub, with translated IP addresses.\n         \\ | /              .\n   +---------------+\
    \  WAN   .        +------------------------------+\n   |Regional Router|-----------------|Stub\
    \ Router w/NAT and SNMP ALG|\n   +---------------+        .        +------------------------------+\n\
    \           |                .                   |\n           |             \
    \   .                   |  LAN\n      +----------+          .            ---------------\n\
    \      | Manager  |    Stub border         Managed network\n      +----------+\n\
    \               Figure 1: SNMP ALG in a NAT configuration\n   A similar scenario\
    \ occurs when several subnetworks with private (and\n   possibly conflicting)\
    \ IP addresses are to be managed by the same\n   management station.  This scenario\
    \ is presented in Figure 2.\n                         +---------------+     +-----------------+\n\
    \                         | SNMP ALG      |-----|Management device|\n        \
    \                 +---------------+     +-----------------+\n                \
    \       T1  |           | T1\n                           |           |\n     \
    \  Stub A .............|....   ....|............ Stub B\n                    \
    \       |           |\n                 +---------------+   +----------------+\n\
    \                 |Bi-directional |   |Bi-directional |\n                 |NAT\
    \ Router w/  |   |NAT Router w/  |\n                 |static address |   |static\
    \ address |\n                 |mapping        |   |mapping        |\n        \
    \         +---------------+   +---------------+\n                   |        \
    \                 |\n                   |  LAN               LAN  |\n        \
    \   -------------             -------------\n        192.10.x.y   |          \
    \       |  192.10.x.y\n                   /____\\           /____\\\n     Figure\
    \ 2: Using external SNMP ALG to manage two private networks\n   Since the devices\
    \ in the managed network are monitored by the manager\n   device they must obtain\
    \ a fixed IP address.  Therefore, the NAT used\n   in this case must be a basic\
    \ NAT with a static one to one mapping.\n   An SNMP ALG is required to scan all\
    \ the payload of SNMP packets, to\n   detect IP address related data, and to translate\
    \ this data if needed.\n   This is a much more computationally involved process\
    \ than the bi-\n   directional NAT, however they both use the same translation\
    \ tables.\n   In many cases the router may be unable to handle SNMP ALG and retain\n\
    \   acceptable performance. In these cases it may be better to locate the\n  \
    \ SNMP ALG outside the router, as described in Figure 2.\n"
- title: 2. Terminology and Concepts Used
  contents:
  - "2. Terminology and Concepts Used\n   In general we adapt the terminology defined\
    \ in [15].  Our main\n   concern are SNMP messages exchanged between SNMP engines.\
    \  This\n   document only discusses SNMP messages that are send over UDP, which\n\
    \   is the preferred transport mapping for SNMP messages [5].  SNMP\n   messages\
    \ send over other transports can be handled in a similar way.\n   Thus, the term\
    \ SNMP packet is used throughout this document to refer\n   to an SNMP message\
    \ contained in an UDP packet.\n   SNMP messages contain SNMP PDUs (Protocol Data\
    \ Units).  An SNMP PDU\n   defines the parameters for a specific SNMP protocol\
    \ operation.  The\n   notion of flow is less relevant in this case, and hence\
    \ we will focus\n   on the information contained in a single SNMP packet.\n  \
    \ There are currently three versions of SNMP. SNMP version 1 (SNMPv1)\n   protocol\
    \ is defined in STD 15, RFC 1157 [2]. The SNMP version 2c\n   (SNMPv2c) protocol\
    \ is defined in RFC 1901 [3], RFC 1905 [4] and RFC\n   1906 [5].  Finally, the\
    \ SNMP version 3 (SNMPv3) protocol is defined\n   in RFC 1905 [4], 1906 [5], RFC\
    \ 2572 [10] and RFC 2574 [12].  See RFC\n   2570 [9] for a more detailed overview\
    \ over the SNMP standards.  In\n   the following, unless otherwise mentioned,\
    \ we use the term SNMP in\n   statements that are applicable to all three SNMP\
    \ versions.\n   SNMP uses ASN.1 [13] to define the abstract syntax of the messages.\n\
    \   The actual encoding of the messages is done by using the Basic\n   Encoding\
    \ Rules (BER) [14], which provide the transfer syntax.\n   We refer to packets\
    \ that go from a management station to the network\n   elements as \"outgoing\"\
    , and packets that go from the network elements\n   to the management station\
    \ as \"incoming\".\n   A basic SNMP ALG is an SNMP ALG implementation in which\
    \ only IP\n   address values encoded in the IpAddress type are translated. A basic\n\
    \   SNMP ALG therefore does not need to be MIB aware.\n   An advanced SNMP ALG\
    \ is an SNMP ALG implementation which is capable\n   of handling and replacing\
    \ IP address values encoded in well known IP\n   address data types and instance\
    \ identifiers derived from those data\n   types. This implies that an advanced\
    \ SNMP ALG is MIB aware.\n"
- title: 3. Problem Scope and Requirements
  contents:
  - "3. Problem Scope and Requirements\n   As mentioned before, in many cases, there\
    \ is a need to manage a local\n   addressing realm that is using NAT, from a manager\
    \ site outside the\n   realm.  A particular important example is the case of network\n\
    \   management service providers who provide network management services\n   from\
    \ a remote site.  Such providers may have many customers, each\n   using the same\
    \ private address space. When all these addressing\n   realms are to be managed\
    \ from a single management station address\n   collision occurs.  There are two\
    \ straight forward ways to overcome\n   the address collision. One can\n   1.\
    \  reassign IP addresses to the different addressing realms, or\n   2.  use static\
    \ address NAT to hide the address collisions from the\n       network management\
    \ application.\n   The first solution is problematic as it requires both a potentially\n\
    \   large set of IP addresses, and the reconfiguration of a large portion\n  \
    \ of the network.  The problem with the second solution is that many\n   network\
    \ management applications are currently unaware of NAT, and\n   because of the\
    \ large investment needed in order to make them NAT\n   aware are likely to remain\
    \ so in the near future.\n   Hence, there is a need for a solution that is transparent\
    \ to the\n   network management application (but not to the user), and that does\n\
    \   not require a general reconfiguration of a large portion of the\n   network\
    \ (i.e. the addressing realm).  The SNMP ALG described in this\n   memo is such\
    \ a solution.\n"
- title: 3.1 IP Addresses in SNMP Messages
  contents:
  - "3.1 IP Addresses in SNMP Messages\n   SNMP messages can contain IP addresses\
    \ in various places and formats.\n   The following four categories have been identified:\n\
    \   1.  IP version 4 addresses and masks stored in the IpAddress tagged\n    \
    \   ASN.1 data type which are not part of an instance identifier. An\n       example\
    \ is the ipAdEntNetMask object defined in the IP-MIB [6].\n   2.  IP version 4\
    \ addresses contained in instance identifiers derived\n       from index objects\
    \ using the IpAddress data type.  An example is\n       the ipAdEntAddr index\
    \ object of the IP-MIB [6].\n   3.  IP addresses (any version) contained in OCTET\
    \ STRINGS.  Examples\n       include addressMapNetworkAddress object of the RMON2-MIB\
    \ [7], and\n       IP addresses contained in OCTET STRINGS derived from well-known\n\
    \       textual conventions (e.g. TAddress [5] or Ipv6Address [8] or\n       InetAddress\
    \ [19]).\n   4.  IP addresses (any version) contained in instance identifiers\n\
    \       derived from OCTET STRINGS.  This may derived from well-known\n      \
    \ textual conventions (e.g. TAddress [5] or Ipv6Address [8] or\n       InetAddress\
    \ [19]) like the ipv6AddrAddress index object of the\n       IPV6-MIB [8].\n \
    \  Textual conventions that can contain IP addresses can be further\n   divided\
    \ in NAT friendly and NAT unfriendly ones.  A NAT friendly\n   textual convention\
    \ ensures that the encoding on the wire contains\n   sufficient information that\
    \ an advanced SNMP ALG which understands\n   the textual convention and which\
    \ has the necessary MIB knowledge can\n   do a proper translation.  An example\
    \ of this type is the Ipv6Address\n   textual convention.\n   A NAT unfriendly\
    \ textual convention requires that an SNMP ALG, which\n   understands the textual\
    \ convention and which has the necessary MIB\n   knowledge, has access to additional\
    \ information in order to do a\n   proper translation.  Examples of this type\
    \ are the TAddress and the\n   InetAddress textual conventions which require that\
    \ an additional\n   varbind is present in an SNMP packet to determine what type\
    \ of IP\n   address a given value represents.  Such a varbind may or may not be\n\
    \   present depending on the way a management applications retrieves\n   data.\n"
- title: 3.2 Requirements
  contents:
  - "3.2 Requirements\n   An SNMP ALG should provide transparent IP address translation\
    \ to\n   management applications.  An SNMP ALG must be compatible with the\n \
    \  behavior of the SNMP protocol operations as defined by RFC 1157 [2]\n   and\
    \ RFC 1905 [4] and must not have negative impact on the security\n   provided\
    \ by the SNMP protocol.  A fully transparent SNMP ALG must be\n   able to translate\
    \ all categories of IP addresses as described above,\n   when provided with the\
    \ specified OID's and the encoding details.\n   The SNMP ALG requires bi-directional\
    \ NAT devices enroute, that\n   support static address mapping for all nodes in\
    \ the respective\n   private realms.  When there are multiple private realms supported\
    \ by\n   a single SNMP ALG, the external addresses assumed by each of the NAT\n\
    \   devices must not collide with each other.\n"
- title: 4. Translating IP Addresses in SNMP Packets
  contents:
  - "4. Translating IP Addresses in SNMP Packets\n   This section describes several\
    \ ways to translate IP addresses in SNMP\n   packets.\n   A general SNMP ALG must\
    \ be capable to translate IP addresses in\n   outgoing and incoming SNMP packets.\n\
    \   SNMP messages send over UDP may experience fragmentation at the IP\n   layer.\
    \ In an extreme case, fragmentation may cause an IP address type\n   to be partitioned\
    \ into two different fragments.  In order to\n   translate IP addresses in SNMP\
    \ messages, the complete SNMP message\n   must be available. As described in [18],\
    \ fragments of UDP packets do\n   not carry the destination/source port number\
    \ with them.  Hence, an\n   SNMP ALG must reassemble IP packets which contain\
    \ SNMP messages.  The\n   good news is, however, that usually SNMP agents are\
    \ aware of the MTU,\n   and that SNMP packets are usually relatively small.  Some\
    \ SNMP\n   implementations also set the don't fragment (DF) bit in the IP header\n\
    \   [1] to avoid fragmentation.\n"
- title: 4.1 Basic SNMP Application Level Gateway
  contents:
  - "4.1 Basic SNMP Application Level Gateway\n   A basic SNMP ALG is an SNMP ALG\
    \ implementation in which only IP\n   address values encoded in the IpAddress\
    \ base type are translated.  A\n   basic SNMP ALG implementation parses an ASN.1/BER\
    \ encoded SNMP packet\n   looking for elements that are encoded using the IpAddress\
    \ base type.\n   Appendix A contains a more detailed description of the structure\
    \ and\n   encoding used by SNMP.\n   An IpAddress value can be identified easily\
    \ by its tag value (0x40).\n   Once an IpAddress has been detected, the SNMP ALG\
    \ checks the\n   translation table and decides whether the address should be\n\
    \   translated. If the address needs translation, the 4 bytes\n   representing\
    \ the IPv4 address are replaced with the translated IPv4\n   address and the UDP\
    \ checksum is adjusted.  Section 4.3 describes an\n   efficient algorithm to adjust\
    \ the UDP checksum without recalculating\n   it.\n   The basic SNMP ALG does not\
    \ require knowledge of any MIBs since it\n   relies on the ASN.1/BER encoding\
    \ of SNMP packets.  It is therefore\n   easy to implement.  A basic SNMP ALG does\
    \ not change the overall\n   messages size and hence it does not cause translated\
    \ messages to be\n   lost due to message size constraints.\n   However, a basic\
    \ SNMP ALG is only able to translate IPv4 addresses in\n   objects that use the\
    \ IpAddress base type. Furthermore, a basic SNMP\n   ALG is not capable to translate\
    \ IP addresses in objects that are\n   index components of conceptual tables.\
    \  This is especially\n   problematic on index components that are not accessible.\
    \  Hence, the\n   basic SNMP ALG is restricted to the first out of the four possible\n\
    \   ways to represent IP addresses in SNMP messages (see Section 3.1).\n"
- title: 4.2 Advanced SNMP Application Level Gateway
  contents:
  - "4.2 Advanced SNMP Application Level Gateway\n   An advanced SNMP ALG is an SNMP\
    \ ALG implementation which is capable\n   of handling and replacing IP address\
    \ values encoded in well known IP\n   address data types and instance identifiers\
    \ derived from those data\n   types.  Hence, an advanced SNMP ALG may be able\
    \ to transparently map\n   IP addresses that are in the format 1-4 as described\
    \ in Section 3.1.\n   This implies that an advanced SNMP ALG must be MIB aware.\n\
    \   An advanced SNMP ALG must maintain an OBJECT IDENTIFIER (OID)\n   translation\
    \ table in order to identify IP addresses that are not\n   encoded in an IpAddress\
    \ base type.  The OID translation table needs\n   to maintain information about\
    \ the OIDs where translation may be\n   needed.  Furthermore, the translation\
    \ table needs to keep information\n   about instance identifiers for conceptual\
    \ tables that contain IP\n   addresses.  Such an OID translation table may be\
    \ populated offline by\n   using a MIB compiler which loads the MIBs used within\
    \ an addressing\n   realm and searches for types, textual conventions and table\
    \ indexes\n   that may contain IP addresses.\n   The translation function scans\
    \ the packet for these specific OIDs,\n   checks the translation table and replaces\
    \ the data if needed.  Note\n   that since OIDs do not have a fixed size this\
    \ search is much more\n   computationally consuming, and the lookup operation\
    \ may be expensive.\n   The ability to translate IP addresses that are part of\
    \ the index of a\n   conceptual table is a required feature of an advanced SNMP\
    \ ALG.  IP\n   addresses embedded in an instance identifier are ASN.1/BER encoded\n\
    \   according to the OID encoding rules. For example, the OID for the\n   10.1.2.3\
    \ instance of the ipAdEntIfIndex object of the IP-MIB [6] is\n   encoded as 06\
    \ 0D 2B 06 01 02 01 04 14 01 02 0A 01 02 03.  Replacing\n   the embedded private\
    \ IPv4 address with 135.180.140.202 leads to the\n   OID 06 11 2B 06 01 02 01\
    \ 04 14 01 02 81 07 81 34 81 0C 81 4A.  This\n   example shows that an advanced\
    \ SNMP ALG may change the overall packet\n   size since IP addresses embedded\
    \ in an OID can change the size of the\n   ASN.1/BER encoded OID.\n   Another\
    \ effect of an advanced SNMP ALG is that it changes the\n   lexicographic ordering\
    \ of rows in conceptual tables as seen by the\n   SNMP manager.  This may have\
    \ severe side-effects for management\n   applications that use lexicographic ordering\
    \ to retrieve only parts\n   of a conceptual table.  Many SNMP managers check\
    \ lexicographic\n   ordering to detect loops caused by broken agents. Such a manager\
    \ will\n   incorrectly report agents behind an advanced SNMP ALG as broken SNMP\n\
    \   agents.\n"
- title: 4.3 Packet Size and UDP Checksum
  contents:
  - "4.3 Packet Size and UDP Checksum\n   Changing an IpAddress value in an SNMP packet\
    \ does not change the\n   size of the SNMP packet.  A basic SNMP ALG does therefore\
    \ never\n   change the size of the underlying UDP packet.\n   An advanced SNMP\
    \ ALG may change the size of an SNMP packet since a\n   different number of bytes\
    \ may be needed to encode a different IP\n   address.  This is highly undesirable\
    \ but unavoidable in the general\n   case.  A change of the SNMP packet size requires\
    \ additional changes\n   in the UDP and IP headers.  Increasing packet sizes are\
    \ especially\n   problematic with SNMPv3.  The SNMPv3 message header contains\
    \ the\n   msgMaxSize field so that agents can generate Response PDUs for\n   GetBulkRequest\
    \ PDUs that are close to the maximum message size the\n   receiver can handle.\
    \  An SNMP ALG which increases the size of an SNMP\n   packet may have the effect\
    \ that the Response PDU can not be processed\n   anymore.  Thus, an advanced SNMP\
    \ ALG may cause some SNMPv3\n   interactions to fail.\n   In both cases, the UDP\
    \ checksum must be adjusted when making an IP\n   address translation.  We can\
    \ use the algorithm from [18], but a small\n   modification must be introduced\
    \ as the modified bytes may start on an\n   odd position.  The C code shown in\
    \ Figure 3 adjusts the checksum to a\n   replacement of one byte in an odd or\
    \ even position.\n        void checksumbyte(unsigned char *chksum, unsigned char\
    \ *optr,\n        unsigned char *nptr, int odd)\n        /* assuming: unsigned\
    \ char is 8 bits, long is 32 bits,\n           we replace one byte by one byte\
    \ in an odd position.\n          - chksum points to the chksum in the packet\n\
    \          - optr points to the old byte in the packet\n          - nptr points\
    \ to the new byte in the packet\n          - odd is 1 if the byte is in an odd\
    \ position 0 otherwise\n        */\n        {  long x, old, new;\n           x=chksum[0]*256+chksum[1];\n\
    \           x=~x & 0xFFFF;\n           if (odd) old=optr[0]*256; else old=optr[0];\n\
    \           x-=old & 0xFFFF;\n           if (x<=0) { x--; x&=0xFFFF; }\n     \
    \      if (odd) new=nptr[0]*256; else new=nptr[0];\n           x+=new & 0xFFFF;\n\
    \           if (x & 0x10000) { x++; x&=0xFFFF; }\n           x=~x & 0xFFFF;\n\
    \           chksum[0]=x/256; chksum[1]=x & 0xFF;\n        }\n"
- title: 5. Limitations and Alternate Solutions
  contents:
  - "5. Limitations and Alternate Solutions\n   Making SNMP ALGs completely transparent\
    \ to all management\n   applications is not an achievable task.  The basic SNMP\
    \ ALG described\n   in Section 4.1 only translates IP addresses encoded in the\
    \ IpAddress\n   base type.  Such an SNMP ALG achieves only very limited transparency\n\
    \   since IP addresses are frequently used as part of an index into a\n   conceptual\
    \ table.  A management application will therefore see both\n   the translated\
    \ as well as the original address, which can lead to\n   confusion and erroneous\
    \ behavior of management applications.\n   However, a certain class of management\
    \ applications like e.g.\n   network discovery tools may work pretty well across\
    \ NATs with a basic\n   SNMP ALG in place.\n   An advanced SNMP ALG described\
    \ in Section 4.2 achieves better\n   transparency.  However, an advanced SNMP\
    \ ALG can only claim to be\n   transparent for the set of data types (textual\
    \ conventions)\n   understood by the advanced SNMP ALG implementation and for\
    \ a given\n   set of MIB modules.  The price paid for better transparency is\n\
    \   additional complexity, potentially increased SNMP packet sizes and\n   mixed\
    \ up lexicographic ordering.  Especially with SNMPv3, there is an\n   opportunity\
    \ that communication fails due to increased packet sizes.\n   Management applications\
    \ that rely on lexicographic ordering will show\n   erroneous behavior.\n   Both,\
    \ basic and advanced SNMP ALGs, introduce problems when using\n   SNMPv3 security\
    \ features.  The SNMPv3 authentication mechanism\n   protects the whole SNMP message\
    \ against modifications while the\n   SNMPv3 privacy mechanism protects the payload\
    \ of SNMPv3 messages\n   against unauthorized access.  Thus, an SNMP ALG must\
    \ have access to\n   all localized keys in use in order to modify SNMPv3 messages\
    \ without\n   invalidating them.  Furthermore, the SNMP ALG must track any key\n\
    \   changes in order to function.  More details on the security\n   implications\
    \ of using SNMP ALGs can be found in Section 6.\n   Finally, an SNMP ALG only\
    \ deals with SNMP traffic and does not modify\n   the payload of any other protocol.\
    \  However, management systems\n   usually use a set of protocols to manage a\
    \ network.  In particular\n   the telnet protocol is often used to configure or\
    \ troubleshoot\n   managed devices.  Hence, a management system and the human\
    \ network\n   operator must generally be aware that a network address translation\n\
    \   is occurring, even in the presence of an SNMP ALG.\n   A possible alternative\
    \ to SNMP ALGs are SNMP proxies, as defined in\n   RFC 2573 [11].  An SNMP proxy\
    \ forwarder application forwards SNMP\n   messages to other SNMP engines according\
    \ to the context, and\n   irrespective of the specific managed object types being\
    \ accessed.\n   The proxy forwarder also forwards the response to such previously\n\
    \   forwarded messages back to the SNMP engine from which the original\n   message\
    \ was received.  Such a proxy forwarder can be used in a NAT\n   environment to\
    \ address SNMP engines with conflicting IP addresses.\n   (Just replace the box\
    \ SNMP ALG with a box labeled SNMP PROXY in\n   Figure 2.)  The deployment of\
    \ SNMP proxys has the advantage that\n   different security levels can be used\
    \ inside and outside of the\n   conflicting addressing realms.\n   The proxy solution,\
    \ which is structurally preferable, requires that\n   the management application\
    \ is aware of the proxy situation.\n   Furthermore, management applications have\
    \ to use internal data\n   structures for network elements that allow for conflicting\
    \ IP\n   addresses since conflicting IP addresses are not translated by the\n\
    \   SNMP proxy.  Deployment of proxies may also involve the need to\n   reconfigure\
    \ network elements and management stations to direct their\n   traffic (notifications\
    \ and requests) to the proxy forwarder.\n"
- title: 6. Security Considerations
  contents:
  - "6. Security Considerations\n   SNMPv1 and SNMPv2c have very week security services\
    \ based on\n   community strings. All management information is sent in cleartext\n\
    \   without encryption and/or authentication. In such an environment,\n   SNMP\
    \ messages can be modified by any intermediate node and management\n   application\
    \ are not able to verify the integrity of SNMP messages.\n   Furthermore, an SNMP\
    \ ALG does not need to have knowledge of the\n   community strings in order to\
    \ translate embedded IP addresses.  Thus,\n   deployment of SNMP ALGs in an SNMPv1/SNMPv2c\
    \ environment introduces\n   no additional security problems.\n   SNMPv3 supports\
    \ three security levels: no authentication and no\n   encryption (noAuth/noPriv),\
    \ authentication and no encryption\n   (auth/noPriv), and authentication and encryption\
    \ (auth/priv).  SNMPv3\n   messages without authentication and encryption (noAuth/noPriv)\
    \ are\n   send in cleartext.  In such a case the usage of SNMP ALGs introduces\n\
    \   no additional security problems.\n   However, the usage of SNMP ALG introduces\
    \ new problems when SNMPv3\n   authentication and optionally encryption is used.\
    \  First, SNMPv3\n   messages with authentication and optionally encryption (auth/noPriv\n\
    \   and auth/priv) can only be processed by an SNMP ALG which supports\n   the\
    \ corresponding cryptographic algorithms and which has access to\n   the keys\
    \ in use.  Furthermore, as keys may be updated, the SNMP ALG\n   must have a mechanism\
    \ that tracks key changes (either by analyzing\n   the key change interactions\
    \ or by propagating key changes by other\n   mechanisms).  Second, the computational\
    \ complexity of processing SNMP\n   messages may increase dramatically.  The message\
    \ has to be decrypted\n   before the translation takes place.  If any translation\
    \ is done the\n   hash signature used to authenticate the message and to protect\
    \ its\n   integrity must be recomputed.\n   In general, key exchange protocols\
    \ are complicated and designing an\n   SNMP ALG which maintains the keys for a\
    \ set of SNMP engines is a\n   non-trivial task. The User-based Security Model\
    \ for SNMPv3 [12]\n   defines a mechanism which takes a password and generates\
    \ localized\n   keys for every SNMP engine.  The localized keys have the property\n\
    \   that a compromised single localized key does not automatically give\n   an\
    \ attacker access to other SNMP engines, even if the key for other\n   SNMP engines\
    \ is derived from the same password.\n   An SNMP ALG implementation which maintains\
    \ lists of (localized) keys\n   is a potential target to attack the security of\
    \ all the systems which\n   use these keys.  An SNMP ALG implementation which\
    \ maintains passwords\n   in order to generate localized keys is a potential target\
    \ to attack\n   the security of all systems that use the same password.  Hence,\
    \ an\n   SNMP ALG implementation must be properly secured so that people who\n\
    \   are not authorized to access keys or passwords can not access them.\n   Finally,\
    \ SNMP ALGs do not allow a network operator to use different\n   security levels\
    \ on both sides of the NAT.  Using a secure SNMP\n   version outside of a private\
    \ addressing realm while the private\n   addressing realm runs an unsecured version\
    \ of SNMP may be highly\n   desirable in many scenarios, e.g. management outsourcing\
    \ scenarios.\n   The deployment of SNMPv3 proxies instead of SNMP ALGs should\
    \ be\n   considered in these cases since SNMP proxies can be configured to use\n\
    \   different security levels and parameters on both sides of the\n   proxies.\n"
- title: 7. Summary and Recommendations
  contents:
  - "7. Summary and Recommendations\n   Several approaches to address SNMP agents\
    \ across NAT devices have\n   been discussed in this memo.\n   1.  Basic SNMP\
    \ ALGs as described in Section 4.1 provide very limited\n       transparency since\
    \ they only translate IPv4 addresses encoded in\n       the IpAddress base type.\
    \  They are fast and efficient and may be\n       sufficient to execute simple\
    \ management applications (e.g.\n       topology discovery applications) in a\
    \ NAT environment. However,\n       other management applications are likely to\
    \ fail due to the\n       limited transparency provided by a basic SNMP ALG. \
    \ Basic SNMP\n       ALGs are problematic in a secure SNMP environment since they\
    \ need\n       to maintain lists of keys or passwords in order to function.\n\
    \   2.  Advanced SNMP ALGs as described in Section 4.2 provide better\n      \
    \ transparency.  They can be transparent for the set of data types\n       they\
    \ understand and for a given set of MIB modules.  However, an\n       advanced\
    \ SNMP ALG is much more complex and less efficiency than a\n       basic SNMP\
    \ ALG. An advanced SNMP ALG may break the lexicographic\n       ordering when\
    \ IP addresses are used to index conceptual tables\n       and it may change the\
    \ SNMP packet sizes.  Especially with SNMPv3,\n       there is an opportunity\
    \ that communication fails due to increased\n       message sizes.  Advanced SNMP\
    \ ALGs are problematic in a secure\n       SNMP environment, since they need to\
    \ maintain lists of keys or\n       passwords in order to function.\n   3.  SNMP\
    \ proxies as described in RFC 2573 [11] allow management\n       applications\
    \ to access SNMP agents with conflicting IP addresses.\n       No address translation\
    \ is performed on the SNMP payload by an\n       SNMP proxy forwarder.  Hence,\
    \ management applications must be\n       able to deal with network elements that\
    \ have conflicting IP\n       addresses.  This solution requires that management\
    \ applications\n       are aware of the proxy situation.  Deployment of proxies\
    \ may also\n       involve the need to reconfigure network elements and management\n\
    \       stations to direct their traffic (notifications and requests) to\n   \
    \    the proxy forwarder.  SNMP proxies have the advantage that they\n       allow\
    \ to use different security levels inside and outside of a\n       given addressing\
    \ realm.\n   It is recommended that network operators who need to manage networks\n\
    \   in a NAT environment make a careful analysis before deploying a\n   solution.\
    \  In particular, it must be analyzed whether the management\n   applications\
    \ will work with the transparency and the side-effects\n   provided by SNMP ALGs.\
    \  Furthermore, it should be researched whether\n   the management applications\
    \ are able to deal with conflicting IP\n   addresses for network devices.  Finally,\
    \ the additional complexity\n   introduced to the over all management system by\
    \ using SNMP ALGs must\n   be compared to the complexity introduced by the structurally\n\
    \   preferable SNMP proxy forwarders.\n"
- title: 8. Current Implementations
  contents:
  - "8. Current Implementations\n   A basic SNMP ALG as described in Section 4.1 was\
    \ implemented for\n   SNMPv1 at Bell-Labs, running on a Solaris Machine.  The\
    \ solution\n   described in Figure 2, where SNMP ALG was combined with the NAT\n\
    \   implementation of Lucent's PortMaster3, was deployed successfully in\n   a\
    \ large network management service organization.\n"
- title: 9. Acknowledgments
  contents:
  - "9. Acknowledgments\n   We thank Pyda Srisuresh, for the support, encouragement,\
    \ and advice\n   throughout the work on this document.  We also thank Brett A.\
    \ Denison\n   for his contribution to the work that led to this document.\n  \
    \ Additional useful comments have been made by members of the NAT\n   working\
    \ group.\n"
- title: 10. References
  contents:
  - "10. References\n   [1]  Postel, J., \"Internet Protocol\", STD 5, RFC 791, September\
    \ 1981.\n   [2]  Case, J., Fedor, M., Schoffstall, M. and J. Davin, \"A Simple\n\
    \        Network Management Protocol (SNMP)\", STD 15, RFC 1157, May 1990.\n \
    \  [3]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n        \"Introduction\
    \ to Community-based SNMPv2\", RFC 1901, January\n        1996.\n   [4]  Case,\
    \ J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol\n        Operations\
    \ for Version 2 of the Simple Network Management\n        Protocol (SNMPv2)\"\
    , RFC 1905, January 1996.\n   [5]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\
    \ \"Transport\n        Mappings for Version 2 of the Simple Network Management\
    \ Protocol\n        (SNMPv2)\", RFC 1906, January 1996.\n   [6]  McCloghrie, K.,\
    \ \"SNMPv2 Management Information Base for the\n        Internet Protocol using\
    \ SMIv2\", RFC 2011, November 1996.\n   [7]  Waldbusser, S., \"Remote Network\
    \ Monitoring Management\n        Information Base Version 2 using SMIv2\", RFC\
    \ 2021, January 1997.\n   [8]  Haskin, D. and S. Onishi, \"Management Information\
    \ Base for IP\n        Version 6: Textual Conventions and General Group\", RFC\
    \ 2465,\n        December 1998.\n   [9]  Case, J., Mundy, R., Partain, D. and\
    \ B. Stewart, \"Introduction\n        to Version 3 of the Internet-standard Network\
    \ Management\n        Framework\", RFC 2570, April 1999.\n   [10] Case, J., Harrington,\
    \ D., Presuhn, R. and B. Wijnen, \"Message\n        Processing and Dispatching\
    \ for the Simple Network Management\n        Protocol (SNMP)\", RFC 2572, April\
    \ 1999.\n   [11] Levi, D., Meyer, P. and B. Stewart, \"SNMP Applications\", RFC\n\
    \        2573, April 1999.\n   [12] Blumenthal, U. and B. Wijnen, \"User-based\
    \ Security Model (USM)\n        for version 3 of the Simple Network Management\
    \ Protocol\n        (SNMPv3)\", RFC 2574, April 1999.\n   [13] ISO, \"Information\
    \ processing systems - Open Systems\n        Interconnection - Specification of\
    \ Abstract Syntax Notation One\n        (ASN.1)\", International Standard 8824,\
    \ December 1987.\n   [14] ISO, \"Information processing systems - Open Systems\n\
    \        Interconnection - Specification of Basic Encoding Rules for\n       \
    \ Abstract Syntax Notation One (ASN.1)\", International Standard\n        8825,\
    \ December 1987.\n   [15] Srisuresh, P. and M. Holdrege, \"IP Network Address\
    \ Translator\n        (NAT) Terminology and Considerations\", RFC 2663, August\
    \ 1999.\n   [16] Miller, M., \"Managing Internetworks with SNMP\", MT Books, 1997.\n\
    \   [17] Perkins, D. and E. McGinnis, \"Understanding SNMP MIBs\", Prentice\n\
    \        Hall, ISBN 0-13-437708-7, 1997.\n   [18] Srisuresh, P. and K. Egevang,\
    \ \"Traditional IP Network Address\n        Translator (Traditional NAT)\", Work\
    \ in Progress.\n   [19] Daniele, M., Haberman, B., Routhier, S. and J. Schoenwaelder,\n\
    \        \"Textual Conventions for Internet Network Addresses\", RFC 2851,\n \
    \       June 2000.\n"
- title: 11. Authors' Addresses
  contents:
  - "11. Authors' Addresses\n   Danny Raz\n   Lucent Technologies\n   101 Crawfords\
    \ Corner Rd\n   Holmdel, NJ  07733-3030\n   USA\n   Phone: +1 732 949-6712\n \
    \  Fax:   +1 732 949-0399\n   EMail: raz@lucent.com\n   URI:   http://www.bell-labs.com/\n\
    \   Juergen Schoenwaelder\n   TU Braunschweig\n   Bueltenweg 74/75\n   38106 Braunschweig\n\
    \   Germany\n   Phone: +49 531 391-3266\n   Fax:   +49 531 391-5936\n   EMail:\
    \ schoenw@ibr.cs.tu-bs.de\n   URI:   http://www.ibr.cs.tu-bs.de/\n   Binay Sugla\n\
    \   ISPSoft Inc.\n   106 Apple Street\n   Tinton Falls, NJ  07724\n   USA\n  \
    \ Phone: +1 732 936-1763\n   EMail: sugla@ispsoft.com\n   URI:   http://www.ispsoft.com/\n"
- title: 12. Appendix A. Description of the Encoding of SNMP Packets
  contents:
  - "12. Appendix A. Description of the Encoding of SNMP Packets\n   SNMP packets\
    \ use the ASN.1/BER encoding.  We will not cover the full\n   details of this\
    \ encoding in this document.  These details can be\n   found in the International\
    \ Standards ISO-8824 [13] and ISO-8825 [14].\n   A good description of ASN.1/BER\
    \ can be found in the book \"Managing\n   Internetworks with SNMP\", by M. A.\
    \ Miller [16], or in Appendix A of\n   the book \"Understanding SNMP MIBs\", by\
    \ D. Perkins, and E. McGinnis\n   [17].\n   Each variable that is referred to\
    \ in an SNMP packet is uniquely\n   identified by an OID (Object Identifier),\
    \ usually written as a\n   sequence of numbers separated by dots (e.g. 1.3.6.1.2.1.1.3.0).\
    \  Each\n   variable also has an associated base type (this is not very accurate\n\
    \   but good enough for this level of description).  One possible base\n   type\
    \ is the IpAddress type. The base type of each variable and its\n   OID are conveyed\
    \ by the ASN.1/BER encoding.  Note that it is possible\n   to associate additional\
    \ type information with a variable by using\n   textual conventions.  The additional\
    \ type semantics provided by\n   textual conventions are not conveyed by the ASN.1/BER\
    \ encoding.\n   When a value of a variable is needed by a manager it sends a get-\n\
    \   request PDU with the OID of that variable, and a NULL value.  The\n   managed\
    \ element then responds by sending a get-response PDU that\n   contains the same\
    \ OID, the base type of the variable, and the current\n   value. Figure 4 shows\
    \ an example of real data contained in an SNMPv1\n   GetResponse PDU.\n   The\
    \ first 20 bytes contain the IPv4 4 header. The next 8 bytes\n   contain the UDP\
    \ header.  The last two bytes of the UDP header contain\n   the UDP checksum (D3\
    \ 65).  The next four bytes 30 82 00 3E are the\n   beginning of the SNMP message:\
    \ 30 is SEQUENCE, and 82 00 3E is the\n   length of the data in the SEQUENCE in\
    \ bytes (62).  The data in the\n   SEQUENCE is the version (02 01 00) and the\
    \ community string (04 06 70\n   75 62 6C 69 63).  The last element in the SEQUENCE\
    \ of the SNMPv1\n   message is the SNMP PDU.\n      +-----------------------------------------+\n\
    \      |       IP Header                         |     45 00 00 5E\n      |  \
    \                                       |     47 40 00 00\n      |           \
    \                              |     3F 11 39 00\n      |                    \
    \                     |     87 B4 8C CA\n      |                             \
    \            |     87 B4 8C 16\n      +-----------------------------------------+\n\
    \      |       UDP Header                        |     00 A1 05 F5\n      |  \
    \                                       |     00 4A D3 65\n      +-----------------------------------------+\n\
    \      |       SNMP Message                      |     30 82 00 3E\n      |  Version\
    \                     |          |     02 01 00 04\n      |  Community       \
    \                       |     06 70 75 62\n      |                           \
    \   |          |     6C 69 63 A2\n      |   PDU Type                   |     \
    \     |     82 00 2F 02\n      |             Request ID                  |   \
    \  04 6C F2 0C\n      |           |       Error Status          |     5C 02 01\
    \ 00\n      |       Error Index            | SEQUENCE |     02 01 00 30\n    \
    \  |  OF                          | SEQUENCE |     82 00 1F 30\n      |      \
    \                        |   OID    |     82 00 1B 06\n      |           |   \
    \                          |     13 2B 06 01\n      |                        \
    \                 |     02 01 07 05\n      |                                 \
    \        |     01 01 81 40\n      |                                         |\
    \     81 34 81 0C\n      |                                         |     81 4A\
    \ 84 08\n      |  IpAddress          | 135    | 180      |     40 04 87 B4\n \
    \     |  140      | 202     +-------------------+     8C CA\n      +---------------------+\n\
    \   The SNMP PDU itself is a tagged SEQUENCE: A2 indicates a GetResponse\n   PDU\
    \ and 82 00 2F is the length of the data in the GetResponse PDU in\n   bytes (47).\
    \  The data in the GetResponse PDU is the request-id (02 04\n   6C F2 0C 5C),\
    \ the error-status (02 01 00), and the error-index (02 01\n   00).  Now follow\
    \ the variables which contain the real payload: A\n   SEQUENCE OF of length 31\
    \ (30 82 00 1F) containing a SEQUENCE of\n   length 27 (30 82 00 1B).  In it,\
    \ the first object is an OID of length\n   19 (06 13) with the value 1.3.6.1.2.1.7.5.1.1.192.180.140.202.520.\n\
    \   The last 6 bytes 40 04 87 B4 8C CA represent an IpAddress: 40 is the\n   identification\
    \ of the base type IpAddress, 04 is the length, and the\n   next four bytes are\
    \ the IP address value (135.180.140.202).\n   The example also shows an IP address\
    \ embedded in an OID.  The OID\n   prefix resolves to the udpLocalAddress of the\
    \ UDP-MIB, which is\n   indexed by the udpLocalAddress 192.180.140.202 (81 40\
    \ 81 34 81 0C 81\n   4A) and the udpLocalPort 520 (84 08). The SNMP packet actually\
    \ shows\n   an internal contradiction caused by a basic SNMP ALG since the\n \
    \  udpLocalAddress encoded in the OID (192.180.140.202) is not equal to\n   the\
    \ value of the udpLocalAddress object instance (135.180.140.202).\n"
- title: 13.  Full Copyright Statement
  contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
