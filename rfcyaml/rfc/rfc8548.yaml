- title: __initial_text__
  contents:
  - '           Cryptographic Protection of TCP Streams (tcpcrypt)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies \"tcpcrypt\", a TCP encryption protocol\n\
    \   designed for use in conjunction with the TCP Encryption Negotiation\n   Option\
    \ (TCP-ENO).  Tcpcrypt coexists with middleboxes by tolerating\n   resegmentation,\
    \ NATs, and other manipulations of the TCP header.  The\n   protocol is self-contained\
    \ and specifically tailored to TCP\n   implementations, which often reside in\
    \ kernels or other environments\n   in which large external software dependencies\
    \ can be undesirable.\n   Because the size of TCP options is limited, the protocol\
    \ requires one\n   additional one-way message latency to perform key exchange\
    \ before\n   application data can be transmitted.  However, the extra latency\
    \ can\n   be avoided between two hosts that have recently established a\n   previous\
    \ tcpcrypt connection.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are candidates\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8548.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Requirements Language . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Encryption Protocol . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n     3.1.  Cryptographic Algorithms  . . . . . . . . . . . . . .\
    \ . .   4\n     3.2.  Protocol Negotiation  . . . . . . . . . . . . . . . . .\
    \ .   6\n     3.3.  Key Exchange  . . . . . . . . . . . . . . . . . . . . . .\
    \   7\n     3.4.  Session ID  . . . . . . . . . . . . . . . . . . . . . . .  10\n\
    \     3.5.  Session Resumption  . . . . . . . . . . . . . . . . . . .  10\n  \
    \   3.6.  Data Encryption and Authentication  . . . . . . . . . . .  14\n    \
    \ 3.7.  TCP Header Protection . . . . . . . . . . . . . . . . . .  16\n     3.8.\
    \  Rekeying  . . . . . . . . . . . . . . . . . . . . . . . .  16\n     3.9.  Keep-Alive\
    \  . . . . . . . . . . . . . . . . . . . . . . .  17\n   4.  Encodings . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  18\n     4.1.  Key-Exchange Messages\
    \ . . . . . . . . . . . . . . . . . .  18\n     4.2.  Encryption Frames . . .\
    \ . . . . . . . . . . . . . . . . .  20\n       4.2.1.  Plaintext . . . . . .\
    \ . . . . . . . . . . . . . . . .  20\n       4.2.2.  Associated Data . . . .\
    \ . . . . . . . . . . . . . . .  21\n       4.2.3.  Frame ID  . . . . . . . .\
    \ . . . . . . . . . . . . . .  21\n     4.3.  Constant Values . . . . . . . .\
    \ . . . . . . . . . . . . .  22\n   5.  Key-Agreement Schemes . . . . . . . .\
    \ . . . . . . . . . . . .  22\n   6.  AEAD Algorithms . . . . . . . . . . . .\
    \ . . . . . . . . . . .  24\n   7.  IANA Considerations . . . . . . . . . . .\
    \ . . . . . . . . . .  24\n   8.  Security Considerations . . . . . . . . . .\
    \ . . . . . . . . .  25\n     8.1.  Asymmetric Roles  . . . . . . . . . . . .\
    \ . . . . . . . .  27\n     8.2.  Verified Liveness . . . . . . . . . . . . .\
    \ . . . . . . .  27\n     8.3.  Mandatory Key-Agreement Schemes . . . . . . .\
    \ . . . . . .  27\n   9.  Experiments . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  28\n   10. References  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  29\n     10.1.  Normative References . . . . . . . . . . . . . . .\
    \ . . .  29\n     10.2.  Informative References . . . . . . . . . . . . . . .\
    \ . .  30\n   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  31\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  31\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes tcpcrypt, an extension to TCP for\n\
    \   cryptographic protection of session data.  Tcpcrypt was designed to\n   meet\
    \ the following goals:\n   o  Meet the requirements of the TCP Encryption Negotiation\
    \ Option\n      (TCP-ENO) [RFC8547] for protecting connection data.\n   o  Be\
    \ amenable to small, self-contained implementations inside TCP\n      stacks.\n\
    \   o  Minimize additional latency at connection startup.\n   o  As much as possible,\
    \ prevent connection failure in the presence of\n      NATs and other middleboxes\
    \ that might normalize traffic or\n      otherwise manipulate TCP segments.\n\
    \   o  Operate independently of IP addresses, making it possible to\n      authenticate\
    \ resumed sessions efficiently even when either end\n      changes IP address.\n\
    \   A companion document [TCPINC-API] describes recommended interfaces\n   for\
    \ configuring certain parameters of this protocol.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 3.  Encryption Protocol
  contents:
  - "3.  Encryption Protocol\n   This section describes the operation of the tcpcrypt\
    \ protocol.  The\n   wire format of all messages is specified in Section 4.\n"
- title: 3.1.  Cryptographic Algorithms
  contents:
  - "3.1.  Cryptographic Algorithms\n   Setting up a tcpcrypt connection employs three\
    \ types of cryptographic\n   algorithms:\n   o  A key agreement scheme is used\
    \ with a short-lived public key to\n      agree upon a shared secret.\n   o  An\
    \ extract function is used to generate a pseudo-random key (PRK)\n      from some\
    \ initial keying material produced by the key agreement\n      scheme.  The notation\
    \ Extract(S, IKM) denotes the output of the\n      extract function with salt\
    \ S and initial keying material IKM.\n   o  A collision-resistant pseudo-random\
    \ function (CPRF) is used to\n      generate multiple cryptographic keys from\
    \ a pseudo-random key,\n      typically the output of the extract function.  The\
    \ CPRF produces\n      an arbitrary amount of Output Keying Material (OKM), and\
    \ we use\n      the notation CPRF(K, CONST, L) to designate the first L bytes\
    \ of\n      the OKM produced by the CPRF when parameterized by key K and the\n\
    \      constant CONST.\n   The Extract and CPRF functions used by the tcpcrypt\
    \ variants defined\n   in this document are the Extract and Expand functions of\
    \ the HMAC-\n   based Key Derivation Function (HKDF) [RFC5869], which is built\
    \ on\n   Keyed-Hashing for Message Authentication (HMAC) [RFC2104].  These are\n\
    \   defined as follows in terms of the function HMAC-Hash(key, value) for\n  \
    \ a negotiated Hash function such as SHA-256; the symbol \"|\" denotes\n   concatenation,\
    \ and the counter concatenated to the right of CONST\n   occupies a single octet.\n\
    \           HKDF-Extract(salt, IKM) -> PRK\n              PRK = HMAC-Hash(salt,\
    \ IKM)\n           HKDF-Expand(PRK, CONST, L) -> OKM\n              T(0) = empty\
    \ string (zero length)\n              T(1) = HMAC-Hash(PRK, T(0) | CONST | 0x01)\n\
    \              T(2) = HMAC-Hash(PRK, T(1) | CONST | 0x02)\n              T(3)\
    \ = HMAC-Hash(PRK, T(2) | CONST | 0x03)\n              ...\n              OKM\
    \  = first L octets of T(1) | T(2) | T(3) | ...\n              where L <= 255*OutputLength(Hash)\n\
    \             Figure 1: HKDF Functions Used for Key Derivation\n   Lastly, once\
    \ tcpcrypt has been successfully set up and encryption\n   keys have been derived,\
    \ an algorithm for Authenticated Encryption\n   with Associated Data (AEAD) is\
    \ used to protect the confidentiality\n   and integrity of all transmitted application\
    \ data.  AEAD algorithms\n   use a single key to encrypt their input data and\
    \ also to generate a\n   cryptographic tag to accompany the resulting ciphertext;\
    \ when\n   decryption is performed, the tag allows authentication of the\n   encrypted\
    \ data and of optional associated plaintext data.\n"
- title: 3.2.  Protocol Negotiation
  contents:
  - "3.2.  Protocol Negotiation\n   Tcpcrypt depends on TCP-ENO [RFC8547] to negotiate\
    \ whether encryption\n   will be enabled for a connection as well as which key-agreement\n\
    \   scheme to use.  TCP-ENO negotiates the use of a particular TCP\n   encryption\
    \ protocol (TEP) by including protocol identifiers in ENO\n   suboptions.  This\
    \ document associates four TEP identifiers with the\n   tcpcrypt protocol as listed\
    \ in Table 4 of Section 7.  Each identifier\n   indicates the use of a particular\
    \ key-agreement scheme, with an\n   associated CPRF and length parameter.  Future\
    \ standards can associate\n   additional TEP identifiers with tcpcrypt following\
    \ the assignment\n   policy specified by TCP-ENO.\n   An active opener that wishes\
    \ to negotiate the use of tcpcrypt\n   includes an ENO option in its SYN segment.\
    \  That option includes\n   suboptions with tcpcrypt TEP identifiers indicating\
    \ the key-agreement\n   schemes it is willing to enable.  The active opener MAY\
    \ additionally\n   include suboptions indicating support for encryption protocols\
    \ other\n   than tcpcrypt, as well as global suboptions as specified by TCP-ENO.\n\
    \   If a passive opener receives an ENO option including tcpcrypt TEPs\n   that\
    \ it supports, it MAY then attach an ENO option to its SYN-ACK\n   segment, including\
    \ solely the TEP it wishes to enable.\n   To establish distinct roles for the\
    \ two hosts in each connection,\n   tcpcrypt depends on the role-negotiation mechanism\
    \ of TCP-ENO.  As\n   one result of the negotiation process, TCP-ENO assigns hosts\
    \ unique\n   roles abstractly called \"A\" at one end of the connection and \"\
    B\" at\n   the other.  Generally, an active opener plays the \"A\" role and a\n\
    \   passive opener plays the \"B\" role, but in the case of simultaneous\n   open,\
    \ an additional mechanism breaks the symmetry and assigns a\n   distinct role\
    \ to each host.  TCP-ENO uses the terms \"host A\" and\n   \"host B\" to identify\
    \ each end of a connection uniquely; this document\n   employs those terms in\
    \ the same way.\n   An ENO suboption includes a flag \"v\" which indicates the\
    \ presence of\n   associated variable-length data.  In order to propose fresh\
    \ key\n   agreement with a particular tcpcrypt TEP, a host sends a one-byte\n\
    \   suboption containing the TEP identifier and v = 0.  In order to\n   propose\
    \ session resumption (described further below) with a\n   particular TEP, a host\
    \ sends a variable-length suboption containing\n   the TEP identifier, the flag\
    \ v = 1, an identifier derived from a\n   session secret previously negotiated\
    \ with the same host and the same\n   TEP, and a nonce.\n   Once two hosts have\
    \ exchanged SYN segments, TCP-ENO defines the\n   negotiated TEP to be the last\
    \ valid TEP identifier in the SYN segment\n   of host B (that is, the passive\
    \ opener in the absence of simultaneous\n   open) that also occurs in that of\
    \ host A.  If there is no such TEP,\n   hosts MUST disable TCP-ENO and tcpcrypt.\n\
    \   If the negotiated TEP was sent by host B with v = 0, it means that\n   fresh\
    \ key agreement will be performed as described in Section 3.3.\n   If, on the\
    \ other hand, host B sent the TEP with v = 1 and both hosts\n   sent appropriate\
    \ resumption identifiers in their suboption data, then\n   the key-exchange messages\
    \ will be omitted in favor of determining\n   keys via session resumption as described\
    \ in Section 3.5.  With\n   session resumption, protected application data MAY\
    \ be sent\n   immediately as detailed in Section 3.6.\n   Note that the negotiated\
    \ TEP is determined without reference to the\n   \"v\" bits in ENO suboptions,\
    \ so if host A offers resumption with a\n   particular TEP and host B replies\
    \ with a non-resumption suboption\n   with the same TEP, that could become the\
    \ negotiated TEP, in which\n   case fresh key agreement will be performed.  That\
    \ is, sending a\n   resumption suboption also implies willingness to perform fresh\
    \ key\n   agreement with the indicated TEP.\n   As REQUIRED by TCP-ENO, once a\
    \ host has both sent and received an ACK\n   segment containing a valid ENO option,\
    \ encryption MUST be enabled and\n   plaintext application data MUST NOT ever\
    \ be exchanged on the\n   connection.  If the negotiated TEP is among those listed\
    \ in Table 4,\n   a host MUST follow the protocol described in this document.\n"
- title: 3.3.  Key Exchange
  contents:
  - "3.3.  Key Exchange\n   Following successful negotiation of a tcpcrypt TEP, all\
    \ further\n   signaling is performed in the Data portion of TCP segments.  Except\n\
    \   when resumption was negotiated (described in Section 3.5), the two\n   hosts\
    \ perform key exchange through two messages, Init1 and Init2, at\n   the start\
    \ of the data streams of host A and host B, respectively.\n   These messages MAY\
    \ span multiple TCP segments and need not end at a\n   segment boundary.  However,\
    \ the segment containing the last byte of\n   an Init1 or Init2 message MUST have\
    \ TCP's push flag (PSH) set.\n   The key exchange protocol, in abstract, proceeds\
    \ as follows:\n       A -> B:  Init1 = { INIT1_MAGIC, sym_cipher_list, N_A, Pub_A\
    \ }\n       B -> A:  Init2 = { INIT2_MAGIC, sym_cipher, N_B, Pub_B }\n   The concrete\
    \ format of these messages is specified in Section 4.1.\n   The parameters are\
    \ defined as follows:\n   o  INIT1_MAGIC, INIT2_MAGIC: Constants defined in Section\
    \ 4.3.\n   o  sym_cipher_list: A list of identifiers of symmetric ciphers (AEAD\n\
    \      algorithms) acceptable to host A.  These are specified in Table 5\n   \
    \   of Section 7.\n   o  sym_cipher: The symmetric cipher selected by host B from\
    \ the\n      sym_cipher_list sent by host A.\n   o  N_A, N_B: Nonces chosen at\
    \ random by hosts A and B, respectively.\n   o  Pub_A, Pub_B: Ephemeral public\
    \ keys for hosts A and B,\n      respectively.  These, as well as their corresponding\
    \ private keys,\n      are short-lived values that MUST be refreshed frequently.\
    \  The\n      private keys SHOULD NOT ever be written to persistent storage.\n\
    \      The security risks associated with the storage of these keys are\n    \
    \  discussed in Section 8.\n   If a host receives an ephemeral public key from\
    \ its peer and a key-\n   validation step fails (see Section 5), it MUST abort\
    \ the connection\n   and raise an error condition distinct from the end-of-file\
    \ condition.\n   The ephemeral secret ES is the result of the key-agreement algorithm\n\
    \   (see Section 5) indicated by the negotiated TEP.  The inputs to the\n   algorithm\
    \ are the local host's ephemeral private key and the remote\n   host's ephemeral\
    \ public key.  For example, host A would compute ES\n   using its own private\
    \ key (not transmitted) and host B's public key,\n   Pub_B.\n   The two sides\
    \ then compute a pseudo-random key, PRK, from which all\n   session secrets are\
    \ derived, as follows:\n          PRK = Extract(N_A, eno_transcript | Init1 |\
    \ Init2 | ES)\n   Above, \"|\" denotes concatenation, eno_transcript is the protocol-\n\
    \   negotiation transcript defined in Section 4.8 of [RFC8547], and Init1\n  \
    \ and Init2 are the transmitted encodings of the messages described in\n   Section\
    \ 4.1.\n   A series of session secrets are computed from PRK as follows:\n   \
    \              ss[0] = PRK\n                 ss[i] = CPRF(ss[i-1], CONST_NEXTK,\
    \ K_LEN)\n   The value ss[0] is used to generate all key material for the current\n\
    \   connection.  The values ss[i] for i > 0 are used by session\n   resumption\
    \ to avoid public key cryptography when establishing\n   subsequent connections\
    \ between the same two hosts as described in\n   Section 3.5.  The CONST_* values\
    \ are constants defined in\n   Section 4.3.  The length K_LEN depends on the tcpcrypt\
    \ TEP in use,\n   and is specified in Section 5.\n   Given a session secret ss[i],\
    \ the two sides compute a series of\n   master keys as follows:\n            \
    \  mk[0] = CPRF(ss[i], CONST_REKEY | sn[i], K_LEN)\n              mk[j] = CPRF(mk[j-1],\
    \ CONST_REKEY, K_LEN)\n   The process of advancing through the series of master\
    \ keys is\n   described in Section 3.8.  The values represented by sn[i] are\n\
    \   session nonces.  For the initial session with i = 0, the session\n   nonce\
    \ is zero bytes long.  The values for subsequent sessions are\n   derived from\
    \ fresh connection data as described in Section 3.5.\n   Finally, each master\
    \ key mk[j] is used to generate traffic keys for\n   protecting application data\
    \ using authenticated encryption:\n       k_ab[j] = CPRF(mk[j], CONST_KEY_A, ae_key_len\
    \ + ae_nonce_len)\n       k_ba[j] = CPRF(mk[j], CONST_KEY_B, ae_key_len + ae_nonce_len)\n\
    \   In the first session derived from fresh key agreement, traffic keys\n   k_ab[j]\
    \ are used by host A to encrypt and host B to decrypt, while\n   keys k_ba[j]\
    \ are used by host B to encrypt and host A to decrypt.  In\n   a resumed session,\
    \ as described more thoroughly in Section 3.5, each\n   host uses the keys in\
    \ the same way as it did in the original session,\n   regardless of its role in\
    \ the current session; for example, if a host\n   played role \"A\" in the first\
    \ session, it will use keys k_ab[j] to\n   encrypt in each derived session.\n\
    \   The values ae_key_len and ae_nonce_len depend on the authenticated-\n   encryption\
    \ algorithm selected and are given in Table 3 of Section 6.\n   The algorithm\
    \ uses the first ae_key_len bytes of each traffic key as\n   an authenticated-encryption\
    \ key, and it uses the following\n   ae_nonce_len bytes as a nonce randomizer.\n\
    \   Implementations SHOULD provide an interface allowing the user to\n   specify,\
    \ for a particular connection, the set of AEAD algorithms to\n   advertise in\
    \ sym_cipher_list (when playing role \"A\") and also the\n   order of preference\
    \ to use when selecting an algorithm from those\n   offered (when playing role\
    \ \"B\").  A companion document [TCPINC-API]\n   describes recommended interfaces\
    \ for this purpose.\n   After host B sends Init2 or host A receives it, that host\
    \ MAY\n   immediately begin transmitting protected application data as\n   described\
    \ in Section 3.6.\n   If host A receives Init2 with a sym_cipher value that was\
    \ not present\n   in the sym_cipher_list it previously transmitted in Init1, it\
    \ MUST\n   abort the connection and raise an error condition distinct from the\n\
    \   end-of-file condition.\n   Throughout this document, to \"abort the connection\"\
    \ means to issue\n   the \"Abort\" command as described in Section 3.8 of [RFC793].\
    \  That\n   is, the TCP connection is destroyed, RESET is transmitted, and the\n\
    \   local user is alerted to the abort event.\n"
- title: 3.4.  Session ID
  contents:
  - "3.4.  Session ID\n   TCP-ENO requires each TEP to define a session ID value that\
    \ uniquely\n   identifies each encrypted connection.\n   A tcpcrypt session ID\
    \ begins with the byte transmitted by host B that\n   contains the negotiated\
    \ TEP identifier along with the \"v\" bit.  The\n   remainder of the ID is derived\
    \ from the session secret and session\n   nonce, as follows:\n    session_id[i]\
    \ = TEP-byte | CPRF(ss[i], CONST_SESSID | sn[i], K_LEN)\n   Again, the length\
    \ K_LEN depends on the TEP and is specified in\n   Section 5.\n"
- title: 3.5.  Session Resumption
  contents:
  - "3.5.  Session Resumption\n   If two hosts have previously negotiated a session\
    \ with secret\n   ss[i-1], they can establish a new connection without public-key\n\
    \   operations using ss[i], the next session secret in the sequence\n   derived\
    \ from the original PRK.\n   A host signals its willingness to resume with a particular\
    \ session\n   secret by sending a SYN segment with a resumption suboption, i.e.,\
    \ an\n   ENO suboption containing the negotiated TEP identifier of the\n   previous\
    \ session, half of the resumption identifier for the new\n   session, and a resumption\
    \ nonce.\n   The resumption nonce MUST have a minimum length of zero bytes and\n\
    \   maximum length of eight bytes.  The value MUST be chosen randomly or\n   using\
    \ a mechanism that guarantees uniqueness even in the face of\n   virtual-machine\
    \ cloning or other re-execution of the same session.\n   An attacker who can force\
    \ either side of a connection to reuse a\n   session secret with the same nonce\
    \ will completely break the security\n   of tcpcrypt.  Reuse of session secrets\
    \ is possible in the event of\n   virtual-machine cloning or reuse of system-level\
    \ hibernation state.\n   Implementations SHOULD provide an API through which to\
    \ set the\n   resumption nonce length and MUST default to eight bytes if they\n\
    \   cannot prohibit the reuse of session secrets.\n   The resumption identifier\
    \ is calculated from a session secret ss[i]\n   as follows:\n                \
    \ resume[i] = CPRF(ss[i], CONST_RESUME, 18)\n   To name a session for resumption,\
    \ a host sends either the first or\n   second half of the resumption identifier\
    \ according to the role it\n   played in the original session with secret ss[0].\n\
    \   A host that originally played role \"A\" and wishes to resume from a\n   cached\
    \ session sends a suboption with the first half of the\n   resumption identifier:\n\
    \         byte     0      1             9      10\n              +------+------+--...--+------+------+--...--+------+\n\
    \              | TEP- |   resume[i]{0..8}   |       nonce_a       |\n        \
    \      | byte |                     |                     |\n              +------+------+--...--+------+------+--...--+------+\n\
    \      Figure 2: Resumption suboption sent when original role was \"A\".\n   The\
    \ TEP-byte contains a tcpcrypt TEP identifier and v = 1.  The nonce\n   value\
    \ MUST have length between 0 and 8 bytes.\n   Similarly, a host that originally\
    \ played role \"B\" sends a suboption\n   with the second half of the resumption\
    \ identifier:\n         byte     0      1             9      10\n            \
    \  +------+------+--...--+------+------+--...--+------+\n              | TEP-\
    \ |   resume[i]{9..17}  |       nonce_b       |\n              | byte |      \
    \               |                     |\n              +------+------+--...--+------+------+--...--+------+\n\
    \      Figure 3: Resumption suboption sent when original role was \"B\".\n   The\
    \ TEP-byte contains a tcpcrypt TEP identifier and v = 1.  The nonce\n   value\
    \ MUST have length between 0 and 8 bytes.\n   If a passive opener receives a resumption\
    \ suboption containing an\n   identifier-half that names a session secret that\
    \ it has cached, and\n   the subobtion's TEP matches the TEP used in the previous\
    \ session, it\n   SHOULD (with exceptions specified below) agree to resume from\
    \ the\n   cached session by sending its own resumption suboption, which will\n\
    \   contain the other half of the identifier.  Otherwise, it MUST NOT\n   agree\
    \ to resumption.\n   If a passive opener does not agree to resumption with a particular\n\
    \   TEP, it MAY either request fresh key exchange by responding with a\n   non-resumption\
    \ suboption using the same TEP or else respond to any\n   other received TEP suboption.\n\
    \   If a passive opener receives an ENO suboption with a TEP identifier\n   and\
    \ v = 1, but the suboption data is less than 9 bytes in length, it\n   MUST behave\
    \ as if the same TEP had been sent with v = 0.  That is,\n   the suboption MUST\
    \ be interpreted as an offer to negotiate fresh key\n   exchange with that TEP.\n\
    \   If an active opener sends a resumption suboption with a particular\n   TEP\
    \ and the appropriate half of a resumption identifier, and then, in\n   the same\
    \ TCP handshake, it receives a resumption suboption with the\n   same TEP and\
    \ an identifier-half that does not match that resumption\n   identifier, it MUST\
    \ ignore that suboption.  In the typical case that\n   this was the only ENO suboption\
    \ received, this means the host MUST\n   disable TCP-ENO and tcpcrypt; it MUST\
    \ NOT send any more ENO options\n   and MUST NOT encrypt the connection.\n   When\
    \ a host concludes that TCP-ENO negotiation has succeeded for some\n   TEP that\
    \ was received in a resumption suboption, it MUST then enable\n   encryption with\
    \ that TEP using the cached session secret.  To do\n   this, it first constructs\
    \ sn[i] as follows:\n                         sn[i] = nonce_a | nonce_b\n   Master\
    \ keys are then computed from s[i] and sn[i] as described in\n   Section 3.3 as\
    \ well as from application data encrypted as described\n   in Section 3.6.\n \
    \  The session ID (Section 3.4) is constructed in the same way for\n   resumed\
    \ sessions as it is for fresh ones.  In this case, the first\n   byte will always\
    \ have v = 1.  The remainder of the ID is derived from\n   the cached session\
    \ secret and the session nonce that was generated\n   during resumption.\n   In\
    \ the case of simultaneous open where TCP-ENO is able to establish\n   asymmetric\
    \ roles, two hosts that simultaneously send SYN segments\n   with compatible resumption\
    \ suboptions MAY resume the associated\n   session.\n   In a particular SYN segment,\
    \ a host SHOULD NOT send more than one\n   resumption suboption (because this\
    \ consumes TCP option space and is\n   unlikely to be a useful practice), and\
    \ it MUST NOT send more than one\n   resumption suboption with the same TEP identifier.\
    \  But in addition\n   to any resumption suboptions, an active opener MAY include\n\
    \   non-resumption suboptions describing other TEPs it supports (in\n   addition\
    \ to the TEP in the resumption suboption).\n   After using the session secret\
    \ ss[i] to compute mk[0],\n   implementations SHOULD compute and cache ss[i+1]\
    \ for possible use by\n   a later session and then erase ss[i] from memory.  Hosts\
    \ MAY retain\n   ss[i+1] until it is used or the memory needs to be reclaimed.\
    \  Hosts\n   SHOULD NOT write any session secrets to non-volatile storage.\n \
    \  When proposing resumption, the active opener MUST use the lowest\n   value\
    \ of \"i\" that has not already been used (successfully or not) to\n   negotiate\
    \ resumption with the same host and for the same original\n   session secret ss[0].\n\
    \   A given session secret ss[i] MUST NOT be used to secure more than one\n  \
    \ TCP connection.  To prevent this, a host MUST NOT resume with a\n   session\
    \ secret if it has ever enabled encryption in the past with the\n   same secret,\
    \ in either role.  In the event that two hosts\n   simultaneously send SYN segments\
    \ to each other that propose\n   resumption with the same session secret but with\
    \ both segments not\n   part of a simultaneous open, both connections would need\
    \ to revert to\n   fresh key exchange.  To avoid this limitation, implementations\
    \ MAY\n   choose to implement session resumption such that all session secrets\n\
    \   derived from a given ss[0] are used for either passive or active\n   opens\
    \ at the same host, not both.\n   If two hosts have previously negotiated a tcpcrypt\
    \ session, either\n   host MAY later initiate session resumption regardless of\
    \ which host\n   was the active opener or played the \"A\" role in the previous\
    \ session.\n   However, a given host MUST either encrypt with keys k_ab[j] for\
    \ all\n   sessions derived from the same original session secret ss[0], or with\n\
    \   keys k_ba[j].  Thus, which keys a host uses to send segments is not\n   affected\
    \ by the role it plays in the current connection: it depends\n   only on whether\
    \ the host played the \"A\" or \"B\" role in the initial\n   session.\n   Implementations\
    \ that cache session secrets MUST provide a means for\n   applications to control\
    \ that caching.  In particular, when an\n   application requests a new TCP connection,\
    \ it MUST have a way to\n   specify two policies for the duration of the connection:\
    \ 1) that\n   resumption requests will be ignored, and thus fresh key exchange\
    \ will\n   be necessary; and 2) that no session secrets will be cached.  (These\n\
    \   policies can be specified independently or as a unit.)  And for an\n   established\
    \ connection, an application MUST have a means to cause any\n   cache state that\
    \ was used in or resulted from establishing the\n   connection to be flushed.\
    \  A companion document [TCPINC-API]\n   describes recommended interfaces for\
    \ this purpose.\n"
- title: 3.6.  Data Encryption and Authentication
  contents:
  - "3.6.  Data Encryption and Authentication\n   Following key exchange (or its omission\
    \ via session resumption), all\n   further communication in a tcpcrypt-enabled\
    \ connection is carried out\n   within delimited encryption frames that are encrypted\
    \ and\n   authenticated using the agreed-upon keys.\n   This protection is provided\
    \ via algorithms for Authenticated\n   Encryption with Associated Data (AEAD).\
    \  The permitted algorithms are\n   listed in Table 5 of Section 7.  Additional\
    \ algorithms can be\n   specified in the future according to the policy in that\
    \ section.  One\n   algorithm is selected during the negotiation described in\n\
    \   Section 3.3.  The lengths ae_key_len and ae_nonce_len associated with\n  \
    \ each algorithm are found in Table 3 of Section 6 along with\n   requirements\
    \ for which algorithms MUST be implemented.\n   The format of an encryption frame\
    \ is specified in Section 4.2.  A\n   sending host breaks its stream of application\
    \ data into a series of\n   chunks.  Each chunk is placed in the data field of\
    \ a plaintext value,\n   which is then encrypted to yield a frame's ciphertext\
    \ field.  Chunks\n   MUST be small enough that the ciphertext (whose length depends\
    \ on the\n   AEAD cipher used, and is generally slightly longer than the\n   plaintext)\
    \ has length less than 2^16 bytes.\n   An \"associated data\" value (see Section\
    \ 4.2.2) is constructed for the\n   frame.  It contains the frame's control field\
    \ and the length of the\n   ciphertext.\n   A \"frame ID\" value (see Section\
    \ 4.2.3) is also constructed for the\n   frame, but not explicitly transmitted.\
    \  It contains a 64-bit offset\n   field whose integer value is the zero-indexed\
    \ byte offset of the\n   beginning of the current encryption frame in the underlying\
    \ TCP\n   datastream.  (That is, the offset in the framing stream, not the\n \
    \  plaintext application stream.)  The offset is then left-padded with\n   zero-valued\
    \ bytes to form a value of length ae_nonce_len.  Because it\n   is strictly necessary\
    \ for the security of the AEAD algorithms\n   specified in this document, an implementation\
    \ MUST NOT ever transmit\n   distinct frames with the same frame ID value under\
    \ the same\n   encryption key.  In particular, a retransmitted TCP segment MUST\n\
    \   contain the same payload bytes for the same TCP sequence numbers, and\n  \
    \ a host MUST NOT transmit more than 2^64 bytes in the underlying TCP\n   datastream\
    \ (which would cause the offset field to wrap) before\n   rekeying as described\
    \ in Section 3.8.\n   Keys for AEAD encryption are taken from the traffic key\
    \ k_ab[j] or\n   k_ba[j] for some \"j\", according to the host's role as described\
    \ in\n   Section 3.3.  First, the appropriate traffic key is divided into two\n\
    \   parts:\n                                      ae_key_len + ae_nonce_len -\
    \ 1\n                                                       |\n        byte  0\
    \                    ae_key_len          |\n              |                  \
    \         |            |\n              v                           v        \
    \    v\n            +----+----+--...--+----+----+----+--...--+----+\n        \
    \    |             K             |        NR       |\n            +----+----+--...--+----+----+----+--...--+----+\n\
    \                      Figure 4: Format of Traffic Key\n   With reference to the\
    \ \"AEAD Interface\" described in Section 2 of\n   [RFC5116], the first ae_key_len\
    \ bytes of the traffic key provide the\n   AEAD key K.  The remaining ae_nonce_len\
    \ bytes provide a nonce\n   randomizer value NR, which is combined via bitwise\
    \ exclusive-or with\n   the frame ID to yield N, the AEAD nonce for the frame:\n\
    \                            N = frame_ID XOR NR\n   The remaining AEAD inputs,\
    \ P and A, are provided by the frame's\n   plaintext value and associated data,\
    \ respectively.  The output of the\n   AEAD operation, C, is transmitted in the\
    \ frame's ciphertext field.\n   When a frame is received, tcpcrypt reconstructs\
    \ the associated data\n   and frame ID values (the former contains only data sent\
    \ in the clear,\n   and the latter is implicit in the TCP stream), computes the\
    \ nonce N\n   as above, and provides these and the ciphertext value to the AEAD\n\
    \   decryption operation.  The output of this operation is either a\n   plaintext\
    \ value P or the special symbol FAIL.  In the latter case,\n   the implementation\
    \ SHOULD abort the connection and raise an error\n   condition distinct from the\
    \ end-of-file condition.  But if none of\n   the TCP segment(s) containing the\
    \ frame have been acknowledged and\n   retransmission could potentially result\
    \ in a valid frame, an\n   implementation MAY instead drop these segments (and\
    \ renege if they\n   have been selectively acknowledged (SACKed), according to\
    \ Section 8\n   of [RFC2018]).\n"
- title: 3.7.  TCP Header Protection
  contents:
  - "3.7.  TCP Header Protection\n   The ciphertext field of the encryption frame\
    \ contains protected\n   versions of certain TCP header values.\n   When the URGp\
    \ bit is set, the urgent field indicates an offset from\n   the current frame's\
    \ beginning offset; the sum of these offsets gives\n   the index of the last byte\
    \ of urgent data in the application\n   datastream.\n   A sender MUST set the\
    \ FINp bit on the last frame it sends in the\n   connection (unless it aborts\
    \ the connection) and MUST NOT set FINp on\n   any other frame.\n   TCP sets the\
    \ FIN flag when a sender has no more data, which with\n   tcpcrypt means setting\
    \ FIN on the segment containing the last byte of\n   the last frame.  However,\
    \ a receiver MUST report the end-of-file\n   condition to the connection's local\
    \ user when and only when it\n   receives a frame with the FINp bit set.  If a\
    \ host receives a segment\n   with the TCP FIN flag set but the received datastream\
    \ including this\n   segment does not contain a frame with FINp set, the host\
    \ SHOULD abort\n   the connection and raise an error condition distinct from the\
    \ end-of-\n   file condition.  But if there are unacknowledged segments whose\n\
    \   retransmission could potentially result in a valid frame, the host\n   MAY\
    \ instead drop the segment with the TCP FIN flag set (and renege if\n   it has\
    \ been SACKed, according to Section 8 of [RFC2018]).\n"
- title: 3.8.  Rekeying
  contents:
  - "3.8.  Rekeying\n   Rekeying allows hosts to wipe from memory keys that could\
    \ decrypt\n   previously transmitted segments.  It also allows the use of AEAD\n\
    \   ciphers that can securely encrypt only a bounded number of messages\n   under\
    \ a given key.\n   As described in Section 3.3, a master key mk[j] is used to\
    \ generate\n   two encryption keys k_ab[j] and k_ba[j].  We refer to these as\
    \ a key\n   set with generation number \"j\".  Each host maintains both a local\n\
    \   generation number that determines which key set it uses to encrypt\n   outgoing\
    \ frames and a remote generation number equal to the highest\n   generation used\
    \ in frames received from its peer.  Initially, these\n   two generation numbers\
    \ are set to zero.\n   A host MAY increment its local generation number beyond\
    \ the remote\n   generation number it has recorded.  We call this action \"initiating\n\
    \   rekeying\".\n   When a host has incremented its local generation number and\
    \ uses the\n   new key set for the first time to encrypt an outgoing frame, it\
    \ MUST\n   set rekey = 1 for that frame.  It MUST set rekey = 0 in all other\n\
    \   cases.\n   When a host receives a frame with rekey = 1, it increments its\
    \ record\n   of the remote generation number.  If the remote generation number\
    \ is\n   now greater than the local generation number, the receiver MUST\n   immediately\
    \ increment its local generation number to match.\n   Moreover, if the receiver\
    \ has not yet transmitted a segment with the\n   FIN flag set, it MUST immediately\
    \ send a frame (with empty\n   application data if necessary) with rekey = 1.\n\
    \   A host MUST NOT initiate more than one concurrent rekey operation if\n   it\
    \ has no data to send; that is, it MUST NOT initiate rekeying with\n   an empty\
    \ encryption frame more than once while its record of the\n   remote generation\
    \ number is less than its own.\n   Note that when parts of the datastream are\
    \ retransmitted, TCP\n   requires that implementations always send the same data\
    \ bytes for the\n   same TCP sequence numbers.  Thus, frame data in retransmitted\n\
    \   segments MUST be encrypted with the same key as when it was first\n   transmitted,\
    \ regardless of the current local generation number.\n   Implementations SHOULD\
    \ delete older-generation keys from memory once\n   they have received all frames\
    \ they will need to decrypt with the old\n   keys and have encrypted all outgoing\
    \ frames under the old keys.\n"
- title: 3.9.  Keep-Alive
  contents:
  - "3.9.  Keep-Alive\n   Instead of using TCP keep-alives to verify that the remote\
    \ endpoint\n   is still responsive, tcpcrypt implementations SHOULD employ the\n\
    \   rekeying mechanism for this purpose, as follows.  When necessary, a\n   host\
    \ SHOULD probe the liveness of its peer by initiating rekeying and\n   transmitting\
    \ a new frame immediately (with empty application data if\n   necessary).\n  \
    \ As described in Section 3.8, a host receiving a frame encrypted under\n   a\
    \ generation number greater than its own MUST increment its own\n   generation\
    \ number and (if it has not already transmitted a segment\n   with FIN set) immediately\
    \ transmit a new frame (with zero-length\n   application data if necessary).\n\
    \   Implementations MAY use TCP keep-alives for purposes that do not\n   require\
    \ endpoint authentication, as discussed in Section 8.2.\n"
- title: 4.  Encodings
  contents:
  - "4.  Encodings\n   This section provides byte-level encodings for values transmitted\
    \ or\n   computed by the protocol.\n"
- title: 4.1.  Key-Exchange Messages
  contents:
  - "4.1.  Key-Exchange Messages\n   The Init1 message has the following encoding:\n\
    \       byte   0       1       2       3\n          +-------+-------+-------+-------+\n\
    \          |          INIT1_MAGIC          |\n          |                    \
    \           |\n          +-------+-------+-------+-------+\n                 \
    \ 4        5      6       7\n              +-------+-------+-------+-------+\n\
    \              |          message_len          |\n              |            \
    \  = M              |\n              +-------+-------+-------+-------+\n     \
    \             8\n              +--------+-----+----+-----+----+---...---+-----+-----+\n\
    \              |nciphers|sym_      |sym_      |         |sym_       |\n      \
    \        | = K    |cipher[0] |cipher[1] |         |cipher[K-1]|\n            \
    \  +--------+-----+----+-----+----+---...---+-----+-----+\n               2*K\
    \ + 9                     2*K + 9 + N_A_LEN\n                  |             \
    \            |\n                  v                         v\n              +-------+---...---+-------+-------+---...---+-------+\n\
    \              |           N_A           |          Pub_A          |\n       \
    \       |                         |                         |\n              +-------+---...---+-------+-------+---...---+-------+\n\
    \                                  M - 1\n              +-------+---...---+-------+\n\
    \              |         ignored         |\n              |                  \
    \       |\n              +-------+---...---+-------+\n   The constant INIT1_MAGIC\
    \ is defined in Section 4.3.  The four-byte\n   field message_len gives the length\
    \ of the entire Init1 message,\n   encoded as a big-endian integer.  The nciphers\
    \ field contains an\n   integer value that specifies the number of two-byte symmetric-cipher\n\
    \   identifiers that follow.  The sym_cipher[i] identifiers indicate\n   cryptographic\
    \ algorithms in Table 5 in Section 7.  The length N_A_LEN\n   and the length of\
    \ Pub_A are both determined by the negotiated TEP as\n   described in Section\
    \ 5.\n   Implementations of this protocol MUST construct Init1 such that the\n\
    \   ignored field has zero length; that is, they MUST construct the\n   message\
    \ such that its end, as determined by message_len, coincides\n   with the end\
    \ of the field Pub_A.  When receiving Init1, however,\n   implementations MUST\
    \ permit and ignore any bytes following Pub_A.\n   The Init2 message has the following\
    \ encoding:\n       byte   0       1       2       3\n          +-------+-------+-------+-------+\n\
    \          |          INIT2_MAGIC          |\n          |                    \
    \           |\n          +-------+-------+-------+-------+\n                 \
    \ 4        5      6       7       8       9\n              +-------+-------+-------+-------+-------+-------+\n\
    \              |          message_len          |  sym_cipher   |\n           \
    \   |              = M              |               |\n              +-------+-------+-------+-------+-------+-------+\n\
    \                  10                      10 + N_B_LEN\n                  | \
    \                        |\n                  v                         v\n  \
    \            +-------+---...---+-------+-------+---...---+-------+\n         \
    \     |           N_B           |          Pub_B          |\n              | \
    \                        |                         |\n              +-------+---...---+-------+-------+---...---+-------+\n\
    \                                  M - 1\n              +-------+---...---+-------+\n\
    \              |          ignored        |\n              |                  \
    \       |\n              +-------+---...---+-------+\n   The constant INIT2_MAGIC\
    \ is defined in Section 4.3.  The four-byte\n   field message_len gives the length\
    \ of the entire Init2 message,\n   encoded as a big-endian integer.  The sym_cipher\
    \ value is a selection\n   from the symmetric-cipher identifiers in the previously-received\n\
    \   Init1 message.  The length N_B_LEN and the length of Pub_B are both\n   determined\
    \ by the negotiated TEP as described in Section 5.\n   Implementations of this\
    \ protocol MUST construct Init2 such that the\n   field \"ignored\" has zero length;\
    \ that is, they MUST construct the\n   message such that its end, as determined\
    \ by message_len, coincides\n   with the end of the Pub_B field.  When receiving\
    \ Init2, however,\n   implementations MUST permit and ignore any bytes following\
    \ Pub_B.\n"
- title: 4.2.  Encryption Frames
  contents:
  - "4.2.  Encryption Frames\n   An encryption frame comprises a control byte and\
    \ a length-prefixed\n   ciphertext value:\n          byte   0       1       2\
    \       3               clen+2\n             +-------+-------+-------+-------+---...---+-------+\n\
    \             |control|      clen     |        ciphertext       |\n          \
    \   +-------+-------+-------+-------+---...---+-------+\n   The field clen is\
    \ an integer in big-endian format and gives the\n   length of the ciphertext field.\n\
    \   The control field has this structure:\n                  bit     7       \
    \          1       0\n                      +-------+---...---+-------+-------+\n\
    \                      |          cres           | rekey |\n                 \
    \     +-------+---...---+-------+-------+\n   The seven-bit field cres is reserved;\
    \ implementations MUST set these\n   bits to zero when sending and MUST ignore\
    \ them when receiving.\n   The use of the rekey field is described in Section\
    \ 3.8.\n"
- title: 4.2.1.  Plaintext
  contents:
  - "4.2.1.  Plaintext\n   The ciphertext field is the result of applying the negotiated\n\
    \   authenticated-encryption algorithm to a plaintext value, which has\n   one\
    \ of these two formats:\n          byte   0       1               plen-1\n   \
    \          +-------+-------+---...---+-------+\n             | flags |       \
    \    data          |\n             +-------+-------+---...---+-------+\n     \
    \     byte   0       1       2       3               plen-1\n             +-------+-------+-------+-------+---...---+-------+\n\
    \             | flags |    urgent     |          data           |\n          \
    \   +-------+-------+-------+-------+---...---+-------+\n   (Note that clen in\
    \ the previous section will generally be greater\n   than plen, as the ciphertext\
    \ produced by the authenticated-encryption\n   scheme both encrypts the application\
    \ data and provides redundancy\n   with which to verify its integrity.)\n   The\
    \ flags field has this structure:\n               bit    7    6    5    4    3\
    \    2    1    0\n                   +----+----+----+----+----+----+----+----+\n\
    \                   |            fres             |URGp|FINp|\n              \
    \     +----+----+----+----+----+----+----+----+\n   The six-bit field fres is\
    \ reserved; implementations MUST set these\n   six bits to zero when sending,\
    \ and MUST ignore them when receiving.\n   When the URGp bit is set, it indicates\
    \ that the urgent field is\n   present, and thus that the plaintext value has\
    \ the second structure\n   variant above; otherwise, the first variant is used.\n\
    \   The meaning of the urgent field and of the flag bits is described in\n   Section\
    \ 3.7.\n"
- title: 4.2.2.  Associated Data
  contents:
  - "4.2.2.  Associated Data\n   An encryption frame's associated data (which is supplied\
    \ to the AEAD\n   algorithm when decrypting the ciphertext and verifying the frame's\n\
    \   integrity) has this format:\n                       byte   0       1     \
    \  2\n                          +-------+-------+-------+\n                  \
    \        |control|     clen      |\n                          +-------+-------+-------+\n\
    \   It contains the same values as the frame's control and clen fields.\n"
- title: 4.2.3.  Frame ID
  contents:
  - "4.2.3.  Frame ID\n   Lastly, a frame ID (used to construct the nonce for the\
    \ AEAD\n   algorithm) has this format:\n          byte  0            ae_nonce_len\
    \ - 8    ae_nonce_len - 1\n                |                   |             |\n\
    \                v                   v             v\n             +-----+--...--+-----+-----+--...--+-----+\n\
    \             |  0  |       |  0  |       offset      |\n             +-----+--...--+-----+-----+--...--+-----+\n\
    \   The 8-byte offset field contains an integer in big-endian format.\n   Its\
    \ value is specified in Section 3.6.  Zero-valued bytes are\n   prepended to the\
    \ offset field to form a structure of length\n   ae_nonce_len.\n"
- title: 4.3.  Constant Values
  contents:
  - "4.3.  Constant Values\n   The table below defines values for the constants used\
    \ in the\n   protocol.\n                       +------------+--------------+\n\
    \                       | Value      | Name         |\n                      \
    \ +------------+--------------+\n                       | 0x01       | CONST_NEXTK\
    \  |\n                       | 0x02       | CONST_SESSID |\n                 \
    \      | 0x03       | CONST_REKEY  |\n                       | 0x04       | CONST_KEY_A\
    \  |\n                       | 0x05       | CONST_KEY_B  |\n                 \
    \      | 0x06       | CONST_RESUME |\n                       | 0x15101a0e | INIT1_MAGIC\
    \  |\n                       | 0x097105e0 | INIT2_MAGIC  |\n                 \
    \      +------------+--------------+\n               Table 1: Constant Values\
    \ Used in the Protocol\n"
- title: 5.  Key-Agreement Schemes
  contents:
  - "5.  Key-Agreement Schemes\n   The TEP negotiated via TCP-ENO indicates the use\
    \ of one of the key-\n   agreement schemes named in Table 4 in Section 7.  For\
    \ example,\n   TCPCRYPT_ECDHE_P256 names the tcpcrypt protocol using ECDHE-P256\n\
    \   together with the CPRF and length parameters specified below.\n   All the\
    \ TEPs specified in this document require the use of HKDF-\n   Expand-SHA256 as\
    \ the CPRF, and these lengths for nonces and session\n   secrets:\n          \
    \                   N_A_LEN: 32 bytes\n                             N_B_LEN: 32\
    \ bytes\n                             K_LEN:   32 bytes\n   Future documents assigning\
    \ additional TEPs for use with tcpcrypt\n   might specify different values for\
    \ the lengths above.  Note that the\n   minimum session ID length specified by\
    \ TCP-ENO, together with the way\n   tcpcrypt constructs session IDs, implies\
    \ that K_LEN MUST have length\n   at least 32 bytes.\n   Key-agreement schemes\
    \ ECDHE-P256 and ECDHE-P521 employ the Elliptic\n   Curve Secret Value Derivation\
    \ Primitive, Diffie-Hellman version\n   (ECSVDP-DH) defined in [IEEE-1363].  The\
    \ named curves are defined in\n   [NIST-DSS].  When the public-key values Pub_A\
    \ and Pub_B are\n   transmitted as described in Section 4.1, they are encoded\
    \ with the\n   \"Elliptic Curve Point to Octet String Conversion Primitive\" described\n\
    \   in Section E.2.3 of [IEEE-1363] and are prefixed by a two-byte length\n  \
    \ in big-endian format:\n              byte   0       1       2              \
    \ L - 1\n                 +-------+-------+-------+---...---+-------+\n      \
    \           |   pubkey_len  |          pubkey         |\n                 |  \
    \    = L      |                         |\n                 +-------+-------+-------+---...---+-------+\n\
    \   Implementations MUST encode these pubkey values in \"compressed\n   format\"\
    .  Implementations MUST validate these pubkey values according\n   to the algorithm\
    \ in Section A.16.10 of [IEEE-1363].\n   Key-agreement schemes ECDHE-Curve25519\
    \ and ECDHE-Curve448 perform the\n   Diffie-Hellman protocol using the functions\
    \ X25519 and X448,\n   respectively.  Implementations SHOULD compute these functions\
    \ using\n   the algorithms described in [RFC7748].  When they do so,\n   implementations\
    \ MUST check whether the computed Diffie-Hellman shared\n   secret is the all-zero\
    \ value and abort if so, as described in\n   Section 6 of [RFC7748].  Alternative\
    \ implementations of these\n   functions SHOULD abort when either input forces\
    \ the shared secret to\n   one of a small set of values as discussed in Section\
    \ 7 of [RFC7748].\n   For these schemes, public-key values Pub_A and Pub_B are\
    \ transmitted\n   directly with no length prefix: 32 bytes for ECDHE-Curve25519\
    \ and 56\n   bytes for ECDHE-Curve448.\n   Table 2 below specifies the requirement\
    \ levels of the four TEPs\n   specified in this document.  In particular, all\
    \ implementations of\n   tcpcrypt MUST support TCPCRYPT_ECDHE_Curve25519.  However,\
    \ system\n   administrators MAY configure which TEPs a host will negotiate\n \
    \  independent of these implementation requirements.\n                +-------------+---------------------------+\n\
    \                | Requirement | TEP                       |\n               \
    \ +-------------+---------------------------+\n                | REQUIRED    |\
    \ TCPCRYPT_ECDHE_Curve25519 |\n                | RECOMMENDED | TCPCRYPT_ECDHE_Curve448\
    \   |\n                | OPTIONAL    | TCPCRYPT_ECDHE_P256       |\n         \
    \       | OPTIONAL    | TCPCRYPT_ECDHE_P521       |\n                +-------------+---------------------------+\n\
    \             Table 2: Requirements for Implementation of TEPs\n"
- title: 6.  AEAD Algorithms
  contents:
  - "6.  AEAD Algorithms\n   This document uses sym_cipher identifiers in the messages\
    \ Init1 and\n   Init2 (see Section 3.3) to negotiate the use of AEAD algorithms;\
    \ the\n   values of these identifiers are given in Table 5 in Section 7.  The\n\
    \   algorithms AEAD_AES_128_GCM and AEAD_AES_256_GCM are specified in\n   [RFC5116].\
    \  The algorithm AEAD_CHACHA20_POLY1305 is specified in\n   [RFC8439].\n   Implementations\
    \ MUST support certain AEAD algorithms according to\n   Table 3.  Note that system\
    \ administrators MAY configure which\n   algorithms a host will negotiate independently\
    \ of these requirements.\n   Lastly, this document uses the lengths ae_key_len\
    \ and ae_nonce_len to\n   specify aspects of encryption and data formats.  These\
    \ values depend\n   on the negotiated AEAD algorithm, also according to the table\
    \ below.\n   +------------------------+-------------+------------+--------------+\n\
    \   | AEAD Algorithm         | Requirement | ae_key_len | ae_nonce_len |\n   +------------------------+-------------+------------+--------------+\n\
    \   | AEAD_AES_128_GCM       | REQUIRED    | 16 bytes   | 12 bytes     |\n   |\
    \ AEAD_AES_256_GCM       | RECOMMENDED | 32 bytes   | 12 bytes     |\n   | AEAD_CHACHA20_POLY1305\
    \ | RECOMMENDED | 32 bytes   | 12 bytes     |\n   +------------------------+-------------+------------+--------------+\n\
    \         Table 3: Requirement and Lengths for Each AEAD Algorithm\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   For use with TCP-ENO's negotiation mechanism, tcpcrypt's\
    \ TEP\n   identifiers have been incorporated in IANA's \"TCP Encryption Protocol\n\
    \   Identifiers\" registry under the \"Transmission Control Protocol (TCP)\n \
    \  Parameters\" registry, as in Table 4.  The various key-agreement\n   schemes\
    \ used by these tcpcrypt variants are defined in Section 5.\n             +-------+---------------------------+-----------+\n\
    \             | Value | Meaning                   | Reference |\n            \
    \ +-------+---------------------------+-----------+\n             | 0x21  | TCPCRYPT_ECDHE_P256\
    \       | [RFC8548] |\n             | 0x22  | TCPCRYPT_ECDHE_P521       | [RFC8548]\
    \ |\n             | 0x23  | TCPCRYPT_ECDHE_Curve25519 | [RFC8548] |\n        \
    \     | 0x24  | TCPCRYPT_ECDHE_Curve448   | [RFC8548] |\n             +-------+---------------------------+-----------+\n\
    \              Table 4: TEP Identifiers for Use with tcpcrypt\n   In Section 6,\
    \ this document defines the use of several AEAD\n   algorithms for encrypting\
    \ application data.  To name these\n   algorithms, the tcpcrypt protocol uses\
    \ two-byte identifiers in the\n   range 0x0001 to 0xFFFF, inclusively, for which\
    \ IANA maintains a new\n   \"tcpcrypt AEAD Algorithms\" registry under the \"\
    Transmission Control\n   Protocol (TCP) Parameters\" registry.  The initial values\
    \ for this\n   registry are given in Table 5.  Future assignments are to be made\n\
    \   upon satisfying either of two policies defined in [RFC8126]: \"IETF\n   Review\"\
    \ or (for non-IETF stream specifications) \"Expert Review with\n   RFC Required.\"\
    \  IANA will furthermore provide early allocation\n   [RFC7120] to facilitate\
    \ testing before RFCs are finalized.\n        +--------+------------------------+----------------------+\n\
    \        | Value  | AEAD Algorithm         | Reference            |\n        +--------+------------------------+----------------------+\n\
    \        | 0x0001 | AEAD_AES_128_GCM       | [RFC8548], Section 6 |\n        |\
    \ 0x0002 | AEAD_AES_256_GCM       | [RFC8548], Section 6 |\n        | 0x0010 |\
    \ AEAD_CHACHA20_POLY1305 | [RFC8548], Section 6 |\n        +--------+------------------------+----------------------+\n\
    \    Table 5: Authenticated-Encryption Algorithms for Use with tcpcrypt\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   All of the security considerations of TCP-ENO\
    \ apply to tcpcrypt.  In\n   particular, tcpcrypt does not protect against active\
    \ network\n   attackers unless applications authenticate the session ID.  If it\
    \ can\n   be established that the session IDs computed at each end of the\n  \
    \ connection match, then tcpcrypt guarantees that no man-in-the-middle\n   attacks\
    \ occurred unless the attacker has broken the underlying\n   cryptographic primitives,\
    \ e.g., Elliptic Curve Diffie-Hellman (ECDH).\n   A proof of this property for\
    \ an earlier version of the protocol has\n   been published [tcpcrypt].\n   To\
    \ ensure middlebox compatibility, tcpcrypt does not protect TCP\n   headers. \
    \ Therefore, the protocol is vulnerable to denial-of-service\n   from off-path\
    \ attackers just as plain TCP is.  Possible attacks\n   include desynchronizing\
    \ the underlying TCP stream, injecting RST or\n   FIN segments, and forging rekey\
    \ bits.  These attacks will cause a\n   tcpcrypt connection to hang or fail with\
    \ an error, but not in any\n   circumstance where plain TCP could continue uncorrupted.\n\
    \   Implementations MUST give higher-level software a way to distinguish\n   such\
    \ errors from a clean end-of-stream (indicated by an authenticated\n   FINp bit)\
    \ so that applications can avoid semantic truncation attacks.\n   There is no\
    \ \"key confirmation\" step in tcpcrypt.  This is not needed\n   because tcpcrypt's\
    \ threat model includes the possibility of a\n   connection to an adversary. \
    \ If key negotiation is compromised and\n   yields two different keys, failed\
    \ integrity checks on every\n   subsequent frame will cause the connection either\
    \ to hang or to\n   abort.  This is not a new threat as an active attacker can\
    \ achieve\n   the same results against a plain TCP connection by injecting RST\n\
    \   segments or modifying sequence and acknowledgement numbers.\n   Tcpcrypt uses\
    \ short-lived public keys to provide forward secrecy;\n   once an implementation\
    \ removes these keys from memory, a compromise\n   of the system will not provide\
    \ any means to derive the session\n   secrets for past connections.  All currently-specified\
    \ key agreement\n   schemes involve key agreement based on Ephemeral Elliptic\
    \ Curve\n   Diffie-Hellman (ECDHE), meaning a new key pair can be efficiently\n\
    \   computed for each connection.  If implementations reuse these\n   parameters,\
    \ they MUST limit the lifetime of the private parameters as\n   far as is practical\
    \ in order to minimize the number of past\n   connections that are vulnerable.\
    \  Of course, placing private keys in\n   persistent storage introduces severe\
    \ risks that they will not be\n   destroyed reliably and in a timely fashion,\
    \ and it SHOULD be avoided\n   whenever possible.\n   Attackers cannot force passive\
    \ openers to move forward in their\n   session resumption chain without guessing\
    \ the content of the\n   resumption identifier, which will be difficult without\
    \ key knowledge.\n   The cipher-suites specified in this document all use HMAC-SHA256\
    \ to\n   implement the collision-resistant pseudo-random function denoted by\n\
    \   CPRF.  A collision-resistant function is one for which, for\n   sufficiently\
    \ large L, an attacker cannot find two distinct inputs\n   (K_1, CONST_1) and\
    \ (K_2, CONST_2) such that CPRF(K_1, CONST_1, L) =\n   CPRF(K_2, CONST_2, L).\
    \  Collision resistance is important to assure\n   the uniqueness of session IDs,\
    \ which are generated using the CPRF.\n   Lastly, many of tcpcrypt's cryptographic\
    \ functions require random\n   input, and thus any host implementing tcpcrypt\
    \ MUST have access to a\n   cryptographically-secure source of randomness or pseudo-randomness.\n\
    \   [RFC4086] provides recommendations on how to achieve this.\n   Most implementations\
    \ will rely on a device's pseudo-random generator,\n   seeded from hardware events\
    \ and a seed carried over from the previous\n   boot.  Once a pseudo-random generator\
    \ has been properly seeded, it\n   can generate effectively arbitrary amounts\
    \ of pseudo-random data.\n   However, until a pseudo-random generator has been\
    \ seeded with\n   sufficient entropy, not only will tcpcrypt be insecure, it will\n\
    \   reveal information that further weakens the security of the pseudo-\n   random\
    \ generator, potentially harming other applications.  As\n   REQUIRED by TCP-ENO,\
    \ implementations MUST NOT send ENO options unless\n   they have access to an\
    \ adequate source of randomness.\n"
- title: 8.1.  Asymmetric Roles
  contents:
  - "8.1.  Asymmetric Roles\n   Tcpcrypt transforms a shared pseudo-random key (PRK)\
    \ into\n   cryptographic traffic keys for each direction.  Doing so requires an\n\
    \   asymmetry in the protocol, as the key derivation function must be\n   perturbed\
    \ differently to generate different keys in each direction.\n   Tcpcrypt includes\
    \ other asymmetries in the roles of the two hosts,\n   such as the process of\
    \ negotiating algorithms (e.g., proposing vs.\n   selecting cipher suites).\n"
- title: 8.2.  Verified Liveness
  contents:
  - "8.2.  Verified Liveness\n   Many hosts implement TCP keep-alives [RFC1122] as\
    \ an option for\n   applications to ensure that the other end of a TCP connection\
    \ still\n   exists even when there is no data to be sent.  A TCP keep-alive\n\
    \   segment carries a sequence number one prior to the beginning of the\n   send\
    \ window and may carry one byte of \"garbage\" data.  Such a segment\n   causes\
    \ the remote side to send an acknowledgment.\n   Unfortunately, tcpcrypt cannot\
    \ cryptographically verify keep-alive\n   acknowledgments.  Therefore, an attacker\
    \ could prolong the existence\n   of a session at one host after the other end\
    \ of the connection no\n   longer exists.  (Such an attack might prevent a process\
    \ with\n   sensitive data from exiting, giving an attacker more time to\n   compromise\
    \ a host and extract the sensitive data.)\n   To counter this threat, tcpcrypt\
    \ specifies a way to stimulate the\n   remote host to send verifiably fresh and\
    \ authentic data, described in\n   Section 3.9.\n   The TCP keep-alive mechanism\
    \ has also been used for its effects on\n   intermediate nodes in the network,\
    \ such as preventing flow state from\n   expiring at NAT boxes or firewalls. \
    \ As these purposes do not require\n   the authentication of endpoints, implementations\
    \ MAY safely\n   accomplish them using either the existing TCP keep-alive mechanism\
    \ or\n   tcpcrypt's verified keep-alive mechanism.\n"
- title: 8.3.  Mandatory Key-Agreement Schemes
  contents:
  - "8.3.  Mandatory Key-Agreement Schemes\n   This document mandates that tcpcrypt\
    \ implementations provide support\n   for at least one key-agreement scheme: ECDHE\
    \ using Curve25519.  This\n   choice of a single mandatory algorithm is the result\
    \ of a difficult\n   tradeoff between cryptographic diversity and the ease and\
    \ security of\n   actual deployment.\n   The IETF's appraisal of best current\
    \ practice on this matter\n   [RFC7696] says, \"Ideally, two independent sets\
    \ of mandatory-to-\n   implement algorithms will be specified, allowing for a\
    \ primary suite\n   and a secondary suite.  This approach ensures that the secondary\n\
    \   suite is widely deployed if a flaw is found in the primary one.\"\n   To meet\
    \ that ideal, it might appear natural to also mandate ECDHE\n   using P-256. \
    \ However, implementing the Diffie-Hellman function using\n   NIST elliptic curves\
    \ (including those specified for use with\n   tcpcrypt, P-256 and P-521) appears\
    \ to be very difficult to achieve\n   without introducing vulnerability to side-channel\
    \ attacks\n   [NIST-fail].  Although well-trusted implementations are available\
    \ as\n   part of large cryptographic libraries, these can be difficult to\n  \
    \ extract for use in operating-system kernels where tcpcrypt is usually\n   best\
    \ implemented.  In contrast, the characteristics of Curve25519\n   together with\
    \ its recent popularity has led to many safe and\n   efficient implementations,\
    \ including some that fit naturally into the\n   kernel environment.\n   [RFC7696]\
    \ insists that, \"The selected algorithms need to be resistant\n   to side-channel\
    \ attacks and also meet the performance, power, and\n   code size requirements\
    \ on a wide variety of platforms.\"  On this\n   principle, tcpcrypt excludes\
    \ the NIST curves from the set of\n   mandatory-to-implement key-agreement algorithms.\n\
    \   Lastly, this document encourages support for key agreement with\n   Curve448,\
    \ categorizing it as RECOMMENDED.  Curve448 appears likely to\n   admit safe and\
    \ efficient implementations.  However, support is not\n   REQUIRED because existing\
    \ implementations might not yet be\n   sufficiently well proven.\n"
- title: 9.  Experiments
  contents:
  - "9.  Experiments\n   Some experience will be required to determine whether the\
    \ tcpcrypt\n   protocol can be deployed safely and successfully across the diverse\n\
    \   environments of the global internet.\n   Safety means that TCP implementations\
    \ that support tcpcrypt are able\n   to communicate reliably in all the same settings\
    \ as they would\n   without tcpcrypt.  As described in Section 9 of [RFC8547],\
    \ this\n   property can be subverted if middleboxes strip ENO options from\n \
    \  non-SYN segments after allowing them in SYN segments, or if the\n   particular\
    \ communication patterns of tcpcrypt offend the policies of\n   middleboxes doing\
    \ deep-packet inspection.\n   Success, in addition to safety, means hosts that\
    \ implement tcpcrypt\n   actually enable encryption when connecting to one another.\
    \  This\n   property depends on the network's treatment of the TCP-ENO handshake\n\
    \   and can be subverted if middleboxes merely strip unknown TCP options\n   or\
    \ terminate TCP connections and relay data back and forth\n   unencrypted.\n \
    \  Ease of implementation will be a further challenge to deployment.\n   Because\
    \ tcpcrypt requires encryption operations on frames that may\n   span TCP segments,\
    \ kernel implementations are forced to buffer\n   segments in different ways than\
    \ are necessary for plain TCP.  More\n   implementation experience will show how\
    \ much additional code\n   complexity is required in various operating systems\
    \ and what kind of\n   performance effects can be expected.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [IEEE-1363]\n              IEEE, \"IEEE Standard\
    \ Specifications for Public-Key\n              Cryptography\", IEEE Standard 1363-2000,\n\
    \              DOI 10.1109/IEEESTD.2000.92292.\n   [NIST-DSS] National Institute\
    \ of Standards and Technology (NIST),\n              \"Digital Signature Standard\
    \ (DSS)\", FIPS PUB 186-4,\n              DOI 10.6028/NIST.FIPS.186-4, July 2013.\n\
    \   [RFC793]   Postel, J., \"Transmission Control Protocol\", STD 7,\n       \
    \       RFC 793, DOI 10.17487/RFC0793, September 1981,\n              <https://www.rfc-editor.org/info/rfc793>.\n\
    \   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP\n   \
    \           Selective Acknowledgment Options\", RFC 2018,\n              DOI 10.17487/RFC2018,\
    \ October 1996,\n              <https://www.rfc-editor.org/info/rfc2018>.\n  \
    \ [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n     \
    \         Hashing for Message Authentication\", RFC 2104,\n              DOI 10.17487/RFC2104,\
    \ February 1997,\n              <https://www.rfc-editor.org/info/rfc2104>.\n \
    \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n         \
    \     Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC5116]\
    \  McGrew, D., \"An Interface and Algorithms for Authenticated\n             \
    \ Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n              <https://www.rfc-editor.org/info/rfc5116>.\n\
    \   [RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n \
    \             Key Derivation Function (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869,\
    \ May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n   [RFC7120]\
    \  Cotton, M., \"Early IANA Allocation of Standards Track Code\n             \
    \ Points\", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January\n              2014,\
    \ <https://www.rfc-editor.org/info/rfc7120>.\n   [RFC7748]  Langley, A., Hamburg,\
    \ M., and S. Turner, \"Elliptic Curves\n              for Security\", RFC 7748,\
    \ DOI 10.17487/RFC7748, January\n              2016, <https://www.rfc-editor.org/info/rfc7748>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8439]  Nir,\
    \ Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF\n              Protocols\"\
    , RFC 8439, DOI 10.17487/RFC8439, June 2018,\n              <https://www.rfc-editor.org/info/rfc8439>.\n\
    \   [RFC8547]  Bittau, A., Giffin, D., Handley, M., Mazieres, D., and\n      \
    \        E. Smith, \"TCP-ENO: Encryption Negotiation Option\",\n             \
    \ RFC 8547, DOI 10.17487/RFC8547, May 2019,\n              <https://www.rfc-editor.org/info/rfc8547>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [NIST-fail]\n              Bernstein, D. and\
    \ T. Lange, \"Failures in NIST's ECC\n              Standards\", January 2016,\n\
    \              <https://cr.yp.to/newelliptic/nistecc-20160106.pdf>.\n   [RFC1122]\
    \  Braden, R., Ed., \"Requirements for Internet Hosts -\n              Communication\
    \ Layers\", STD 3, RFC 1122,\n              DOI 10.17487/RFC1122, October 1989,\n\
    \              <https://www.rfc-editor.org/info/rfc1122>.\n   [RFC4086]  Eastlake\
    \ 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness Requirements\
    \ for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086, June\
    \ 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n   [RFC7696]\
    \  Housley, R., \"Guidelines for Cryptographic Algorithm\n              Agility\
    \ and Selecting Mandatory-to-Implement Algorithms\",\n              BCP 201, RFC\
    \ 7696, DOI 10.17487/RFC7696, November 2015,\n              <https://www.rfc-editor.org/info/rfc7696>.\n\
    \   [tcpcrypt] Bittau, A., Hamburg, M., Handley, M., Mazieres, D., and\n     \
    \         D. Boneh, \"The case for ubiquitous transport-level\n              encryption\"\
    , USENIX Security Symposium, August 2010.\n   [TCPINC-API]\n              Bittau,\
    \ A., Boneh, D., Giffin, D., Handley, M., Mazieres,\n              D., and E.\
    \ Smith, \"Interface Extensions for TCP-ENO and\n              tcpcrypt\", Work\
    \ in Progress, draft-ietf-tcpinc-api-06,\n              June 2018.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We are grateful for contributions, help, discussions, and\
    \ feedback\n   from the TCPINC Working Group and from other IETF reviewers,\n\
    \   including Marcelo Bagnulo, David Black, Bob Briscoe, Jana Iyengar,\n   Stephen\
    \ Kent, Tero Kivinen, Mirja Kuhlewind, Yoav Nir, Christoph\n   Paasch, Eric Rescorla,\
    \ Kyle Rose, and Dale Worley.\n   This work was funded by gifts from Intel (to\
    \ Brad Karp) and from\n   Google; by NSF award CNS-0716806 (A Clean-Slate Infrastructure\
    \ for\n   Information Flow Control); by DARPA CRASH under contract\n   #N66001-10-2-4088;\
    \ and by the Stanford Secure Internet of Things\n   Project.\n"
- title: Contributors
  contents:
  - "Contributors\n   Dan Boneh and Michael Hamburg were coauthors of the draft that\
    \ became\n   this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Andrea Bittau\n   Google\n   345 Spear Street\n   San\
    \ Francisco, CA  94105\n   United States of America\n   Email: bittau@google.com\n\
    \   Daniel B. Giffin\n   Stanford University\n   353 Serra Mall, Room 288\n  \
    \ Stanford, CA  94305\n   United States of America\n   Email: daniel@beech-grove.net\n\
    \   Mark Handley\n   University College London\n   Gower St.\n   London  WC1E\
    \ 6BT\n   United Kingdom\n   Email: M.Handley@cs.ucl.ac.uk\n   David Mazieres\n\
    \   Stanford University\n   353 Serra Mall, Room 290\n   Stanford, CA  94305\n\
    \   United States of America\n   Email: dm@uun.org\n   Quinn Slack\n   Sourcegraph\n\
    \   121 2nd St Ste 200\n   San Francisco, CA  94105\n   United States of America\n\
    \   Email: sqs@sourcegraph.com\n   Eric W. Smith\n   Kestrel Institute\n   3260\
    \ Hillview Avenue\n   Palo Alto, CA  94304\n   United States of America\n   Email:\
    \ eric.smith@kestrel.edu\n"
