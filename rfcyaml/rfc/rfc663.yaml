- title: __initial_text__
  contents:
  - "        A LOST MESSAGE DETECTION AND RECOVERY PROTOCOL\n1.0 INTRODUCTION\nThe\
    \ current  Host-to-Host  protocol  does  not  provide  for  the\nfollowing three\
    \ aspects of network communication:\n     1. detection of messages lost in the\
    \ transmission path\n     2. detection of errors in the data\n     3. procedures\
    \ for recovery in the event of lost messages or\n        data errors.\nIn this\
    \ memo we propose an extension to the Host-to-Host protocol\nthat  will  allow\
    \  detection  of  lost  messages  and  an orderly\nrecovery from this situation.\
    \  If Host-to-Host protocol  were  to\nbe  amended  to  allow for detection of\
    \ errors in the data, it is\nexpected that the recovery procedures proposed here\
    \  will  apply.\nWith  the  present  protocol,  it  may  some times be possible\
    \ to\ndetect loss of messages in the transmission path.  However, often\na lost\
    \ message (especially one on a control link) simply  results\nin  an  inconsistent\
    \ state of a network connection.  One frequent\n(and frustrating) symptom of a\
    \ message loss on a control link has\nbeen the \"lost allocate\" problem which\
    \ results in  a  \"paralyzed\"\nconnection.   The  NCP (Network Control Program)\
    \ at the receiving\nsite  believes  that  sender  has  sufficient  allocation\
    \  for  a\nconnection,  whereas the NCP of the sending host believes that it\n\
    has no allocation (due to either loss of or error  in  a  message\nthat  contained\
    \  the  allocate  command).  The result is that the\nsending  site  can  not \
    \ transmit  any  more  messages  over  the\nconnection.   This  problem  was \
    \ reported in the NWG-RFC #467 by\nBurchfiel and Tomlinson.  They also proposed\
    \ an extension to  the\nHost-to-Host  protocol  which allows for resynchronization\
    \ of the\nconnection status.  Their proposed solution was opposed by  Edwin\n\
    Meyer  (NWG-RFC  #492)  and  Wayne Hathaway (NWG-RFC #512) on the\ngrounds that\
    \ it tended to mask  the  basic  problem  of  loss  of\nmessages  and  they  suggested\
    \  that  the  fundamental problem of\nmessage loss should be solved rather than\
    \ its  symptoms.   As  an\nalternative  to  the  solution  proposed  in  NWG-RFC\
    \ #467, Wayne\nHathaway suggested that Host-to-Host  protocol  header  could \
    \ be\nextended  to include a \"Sequence Control Byte\" to allow detection\nof\
    \ lost messages.  At about the same time Jon Postel suggested  a\nsimilar  scheme\
    \  using  message numbers (NWG-RFC #516).  A little\nlater David Walden proposed\
    \ that four unused bits of the  message\nsequence  number  (in  the IMP leader)\
    \ be utilized for sequencing\n                    - 1 -\nmessages (NWG-RFC #534).\
    \  His scheme is similar to those proposed\nby Postel and  Hathaway;   however\
    \  it  has  the  advantage  that\nHost-to-Host protocol mechanisms can be tied\
    \ into the IMP-to-Host\nprotocol mechanisms.\nThe  protocol  extension  proposed\
    \ here uses the four bits of the\nmessage sequence number in the message leader\
    \  for  detection  of\nlost  messages.  However, to facilitate recovery, it uses\
    \ another\neight bit field (presently unused) in the 72 bit  header  of  the\n\
    regular  messages.   In the next section of this paper we discuss\nsome of the\
    \ basic ideas underlying our protocol.  In  section  3,\nwe  provide  a  description\
    \ of the protocol.  It is our intention\nthat section 3 be a self-contained and\
    \  complete  description  of\nthe protocol.\n2.0 BASIC IDEAS\nThe  purpose  of\
    \ this section is to provide a gentle introduction\nto the central ideas on which\
    \ this protocol  is  based.   Roughly\nspeaking,   our   protocol   can  be  divided\
    \  into  three  major\ncomponents.   First  is  the  mechanism  for  detecting\
    \  loss  of\nmessages.   Second  is  the  exchange  of information between the\n\
    sender and the receiver in the event  of  a  message  loss.   For\nreasons  that\
    \  will soon become obvious, we have termed this area\nas \"Exchange of Control\
    \ Messages\".  The third  component  of  our\nprotocol  is  the  method of retransmission\
    \ of lost messages.  In\nthis section, we have reversed the order of  discussion\
    \  for  the\nsecond  and third components, because the mechanisms for exchange\n\
    of  control  messages  depend  heavily  upon  the  retransmission\nmethods.\n\
    A  careful  reader  will find that several minor issues have been\nleft unresolved\
    \ in this section.  He (or  she)  should   remember\nthat this section is not\
    \ intended to be a complete description of\nthe  protocol.   Hopefully, we have\
    \ resolved most of these issues\nin the formal description of the protocol provided\
    \ in the section\n3.\n2.1 DETECTION OF LOSS OF MESSAGES\nThe 32 bit Host-to-IMP\
    \ and IMP-to-Host leaders contain a  12  bit\nmessage-id  in  bit  positions \
    \ 17 to 28 (BBN Report #1822).  The\nHost-to-Host protocol (NIC 8246) uses 8 bits\
    \  of  the  message-id\n(bit  positions 17 to 24) as a link number.  The remaining\
    \ 4 bits\nof the message-id (bits 25 to 28) are presently unused.  For  the\n\
    purposes  of  the  protocol to be presented here, we define these\n          \
    \          - 2 -\nfour bits to be  the  message  sequence  number  (MSN  in  short)\n\
    associated  with  the link.  Thus message-id consists of an eight\nbit link number\
    \ and a four bit message sequence number.  The four\nbit MSN provides a sixteen\
    \ element sequence number for each link.\nA network connection has a sending host\
    \ (referred to as  \"sender\"\nhenceforth),   a   receiving   host   (referred\
    \  to  as  receiver\nhenceforth), and a link on which messages  are  transmitted.\
    \   In\nour  protocol  the  sender starts communication with the value of\nMSN\
    \ set to one (i.e. the first message on any link has one in its\nMSN field.) \
    \ For the next message on the same link the  value  of\nMSN  is  increased  by\
    \ one.  When the value of MSN becomes 15 the\nnext value chosen is one.  This\
    \ results in the following sequence\n1, 2, ...., 13, 14, 15, 1, 2, ...., etc.\
    \  The receiver can detect\nloss  of  messages  by  examining  this  sequence.\
    \    Each   hole\ncorresponds  to  a  lost  message.   Notice  that  the  detection\n\
    mechanism will fail if a sequence of exactly 15 messages were  to\nbe   lost.\
    \   For  the  time  being,  we  shall  assume  that  the\nprobability of loosing\
    \ a  sequence  of  exactly  15  messages  is\nnegligible.   However,  we  shall\
    \ later provide a status exchange\nmechanism (Section 2.6) that can be used to\
    \ prevent this failure.\nNotice that in the sequence described above we have \
    \ omitted  the\nvalue  zero.   Following  a  suggestion made by Hathaway (NWG-RFC\n\
    #512) and Walden (NWG-RFC #534) the new protocol uses  the  value\nzero  to  indicate\
    \ to the receiving host that the sending host is\nnot using message sequence numbers.\
    \   We,  in  fact,  extend  the\nmeaning  associated  with  the  MSN  value zero\
    \ to imply that the\nsending host has not implemented the detection and error\
    \ recovery\nprotocol being proposed here.\n2.2 COMPATIBILITY\nThe discussion above\
    \ brings us  to  the  issue  of  compatibility\nbetween  the  present  and  the\
    \ new protocols.  Let us define the\nhosts with the present protocol to be type\
    \ A and the  hosts  with\nthe new protocol to be type B.  We have three situations:\n\
    \     1. Type  A  communicating  with  type  A:   there   is   no\n        difference\
    \ from the present situation.\n     2. Type A communicating with type B: from\
    \  the  zero  value\n        MSNs  in  messages  sent  by the type A host, the\
    \ type B\n        host can detect the fact that the other host is a type A\n \
    \       host.  Therefore  the  type  B  host  can  simulate  the\n        behaviour\
    \ of a type A host in its communication with the\n        other  host,  and  the\
    \ type A host will not be confused.\n        As we will see later  that  this\
    \  simulation  is  really\n        simple and can be easily applied selectively.\n\
    \     3. Type B host communicating with type B:  Both  hosts  can\n        detect\
    \ the fact that the other host is a type B host and\n                    - 3 -\n\
    \        use  the  message detection and error recovery protocol.\nThere is one\
    \ difficulty here that we have not yet resolved.  When\nstarting communication\
    \ how does a type B host  know  whether  the\nother  host is type A or type B?\
    \  This difficulty can be resolved\nby assuming that a type A host will not be\
    \ confused by a non-zero\nMSN in the messages that it receives.   This  assumption\
    \  is  not\nunreasonable   because  a  type  A  host  can  easily  meet  this\n\
    requirement by making a  very  simple  change  to  its  NCP  (the\nNetwork  Control\
    \  Program),  if  it does not already satisfy this\nrequirement.  Another assumption\
    \ that is crucial to our protocol,\nis that the type A hosts always set the  MSN\
    \  field  of  messages\n(they send out) to zero.  As of this writing, the author\
    \ believes\nthat   no  hosts  are  using  the  MSN  field  and  therefore  no\n\
    compatibility problem should arise.\n2.3 RETRANSMISSION OF MESSAGES\nBefore getting\
    \ down to the details of  the  actual  protocol,  we\nwill  attempt here to explain\
    \ the essential ideas underlying this\nprotocol  by  considering  a   somewhat\
    \   simplified   situation.\nConsider  a  logical  communication  channel  X,\
    \ which has at its\ndisposal  an  inexhaustible  supply  of  physical   communication\n\
    channels  C(1),  C(2),  C(3),  ........,  etc.  (See footnote #1)\nChannel X is\
    \  to  be  used  for  transmission  of  messages.   In\naddition  to  carrying\
    \  the  data, these messages contain (1) the\nchannel name X, and (2) a Message\
    \ Sequence Number (MSN).  Let  us\ndenote  the  sender  on  this channel by S\
    \ and the receiver by R.\nLet us also assume that at the start of the communication,\
    \ R  and\nS  are  synchronized  such that R is prepared to receive messages\n\
    for logical channel X  on the physical  channel  C(1)  and  S  is\nprepared for\
    \ sending these messages on C(1).  S starts by pumping\na  sequence  of  messages\
    \  M(1),  M(2), M(3), ........, M(n) into\nchannel C(1).  Since these messages\
    \ contain sequence  numbers,  R\nis  able to detect loss of messages on the channel\
    \ C(1).  Suppose\nnow that R discovers that message number K (where K <n) was\
    \  lost\nin  the  transmission  path.   Let  us further assume that having\n_________________________________________________________________\n\
    (1) One method of recovery may be to let the  receiver  save  all\nproperly  received\
    \  messages and require the sender to retransmit\nonly those messages that were\
    \ lost.   This  method  requires  the\nreceiver  to have the ability to reassemble\
    \ the messages to build\nthe data stream.  A second method of recovery may be\
    \ to abort and\nrestart  the  transmission  at  the  error  point.   This  method\n\
    requires  that  the receiving host be able to distinguish between\nlegitimate\
    \ messages and messages to be ignored.   For  simplicity\nwe  have  chosen the\
    \ second method and an inexhaustible supply of\nphysical  channels  serves  to\
    \  provide  the  distinction   among\nmessages.\n                    - 4 -\ndiscovered\
    \ loss of a message, R can communicate this fact to S by\nsending an appropriate\
    \ control message on another logical channel\nthat is explicitly reserved for\
    \ transmission of control  messages\nfrom  R to S.  This channel, named Y, is\
    \ assumed to be completely\nreliable.\nWe now provide a rather  simplistic  recovery\
    \  protocol  for  the\nscenario sketched above. Having detected the loss of message\
    \ M(K)\non channel X, R takes the following series of actions:\n      1- R stops\
    \ reading messages on C(1),\n      2- R discards those messages that were received\
    \ on C1  and\nare  placed after M(K) in the logical message sequence,\n      3-\
    \ R prepares itself to read messages M(K), M(K+1), .....,\netc.  on the physical\
    \ channel C(2),\n  and 4- R sends a control message to S on  control  channel\
    \  Y,\nwhich  will  inform  S  to the effect that there was an\nerror on logical\
    \ channel X while using physical channel\nC(1) in message number K.\nWhen S receives\
    \ this control message on Y, it takes the following\naction:\n      1- S stops\
    \ sending messages on C(1),\n  and 2- begins  transmission  of  messages  starting\
    \  with  the\nsequence number K, on the physical channel C(2).\nThis  resynchronization\
    \ protocol is executed every time R detects\nan error.  If physical channel C(CN)\
    \ was being used at  the  time\nof  the  error,  then the next channel to be used\
    \ is C(CN+1).  We\ncan define a \"receiver synchronization state\"  for the channel\
    \ X,\nas the triplet R(C, CN, MSN), where C is the name of the group of\nphysical\
    \ channels, CN is the number of the  physical  channel  in\nuse, and MSN is the\
    \ number of message expected. (See footnote #1)\nWe can specify a message received\
    \ on a given C-channel as M(MSN).\nWhen R receives the message M(R.MSN) on the\
    \ channel C(R.CN),  the\nsynch-state  changes  from  R(C,  CN,  MSN)  to  R(C,\
    \ CN, MSN+1).\nHowever if M.MSN for the message received is greater  than  R.MSN\n\
    then  a  message  has been lost, and R changes the synch-state to\nR(C, CN+1,\
    \  MSN).   What  really  happens  may  be  described  as\nfollows:  upon  detection\
    \  of  error  in  a logical channel X, we\nmerely discard the physical channel\
    \ that was in use at  the  time\nof  error, and restart communication on a new\
    \ physical channel at\nthe point where break occurred.\n_________________________________________________________________\n\
    (1) Notice that we have prefixed this triplet  by  the  letter  R\n(for  the \
    \ receiver.)   We  will  prefix  other similarly defined\nquantities by different\
    \ letters.  For example M can be  used  for\nmessages.   This  notation  permits\
    \  us to write expressions like\nM.MSN = R.MSN, where M.MSN stands for the message\
    \ sequence number\nof the message.\n                    - 5 -\nThis scheme provides\
    \ a reliable transmission path X, even  though\nthe physical channels involved\
    \ are unreliable.  In this scheme we\nhave  assumed  that  (1)  a  completely\
    \  reliable  channel  Y  is\navailable for exchange of control messages, and (2)\
    \ that there is\na large supply of physical channels  available for use of X.\
    \   In\nthe  paragraphs that follow we shall revise our protocol to use a\nsingle\
    \ physical channel and  then  apply  this  protocol  to  the\nchannel Y in such\
    \ a way that Y would become \"self-correcting.\"\nNow  suppose  that channel X\
    \ has only one physical channel (named\nX') available for its use rather than\
    \ the inexhaustible supply of\nphysical channels.  Our protocol would still work,\
    \  if  we  could\nsomehow simulate the effect of a large number of C-channels\
    \ using\nthe  single  channel X'.  One method of providing this simulation\nis\
    \ to include in each message the name of the C-channel on  which\nit  is  being\
    \  sent,  and  send  it on X'.  Now the receiver must\nexamine each message received\
    \ on X' to determine the C-channel on\nwhich this message was sent.  Our protocol\
    \ still works except for\none minor difference,  namely,  the  receiver  must\
    \  now  discard\nmessages  corresponding  to C-channels that are no longer in\
    \ use,\nwhereas in the previous system the  C-channels  no  longer  being\nused\
    \  were  simply  discarded.  To be sure, X' can be multiplexed\namong only a finite\
    \ number of C-channels; however, we can provide\na sufficiently large number of\
    \ C-channels so that during the life\ntime of the logical channel X, the probability\
    \ of exhausting  the\nsupply  of  C-channels would be very low.  And even if we\
    \ were to\nexhaust the supply of C-channels, we could recycle them  just  as\n\
    we recycle the message sequence numbers.\nA  physical  message received on X'\
    \ can now be characterized by a\npair of C-channel number and a message sequence\
    \ number, as  M(CN,\nMSN).  The receiver synchronization state becomes a triplet\
    \ R(X',\nCN,  MSN).   This  state  tells  us  that R is ready to receive a\nmessage\
    \ for X on the physical channel X'  and  for  this  message\nM.CN  should be equal\
    \ to R.CN and M.MSN should be equal to R.MSN.\nAll messages with M.CN less than\
    \ R.CN will be  ignored.   If  for\nthe  next  message received on X', M.CN =\
    \ R.CN and M.MSN = R.MSN,\nthen R changes the synch state to R(X', CN, MSN+1).\
    \   If  M.CN  =\nR.CN  but  M.MSN  >  R.MSN  then a message has been lost and\
    \  the\nsynch-state R(X', CN, MSN) changes to R(X', CN+1,  MSN).   Notice\nthat\
    \  we  have  not  yet said anything about the situation M.CN >\nR.CN.  We will\
    \ later describe a scheme for  using  this  case  to\nprovide for error correction\
    \ on the control channel itself.\n2.4 EXCHANGE OF CONTROL INFORMATION\nSo  far\
    \  we  have  discussed  two  schemes  for the detection and\nretransmission aspects\
    \ of  the  lost-message  problem.   In  this\n                    - 6 -\nsection,\
    \ we discuss methods by which the receiver communicates to\nthe sender the fact\
    \ of loss of messages.\nWe continue with the scenario developed in the above section\
    \ with\na small change.  For the purposes of the discussion that is about\nto\
    \  follow  we  shall  assume that there are actually two perfect\nchannels available\
    \ for exchange of control messages.  One channel\nfrom S to R named S->R, and\
    \ the other from R  to  S  named  R->S.\nThe  purpose  of S->R will become clear\
    \ in a moment.  In order to\nlet R communicate the fact of loss of messages to\
    \ S, We provide a\ncontrol message called L\b__\bo_\bs_\bt__\bM_\be_\bs_\bs_\b\
    a_\bg_\be__\bf_\br_\bo_\bm__\bR_\be_\bc_\be_\bi_\bv_\be_\br (LMR) which  is\n\
    of  the  following  form: LMR(X, CN, MSN), where X is the name of\nthe channel,\
    \ CN is the new  C-channel  number,  and  MSN  is  the\nmessage  sequence  number\
    \  of the lost message.  If more than one\nmessage has been lost, then R uses\
    \ the MSN of the  first  message\nonly.  When S receives this message, it can\
    \ restart communication\nat  the  point  where  the  break  occurred  using  the\
    \ C-channel\nspecified  by  the  LMR   message.    This   will   restore   the\n\
    communication  path  X.   What  happens  if  S  can  not  restore\ncommunication\
    \ at the break point because it  does  not  have  the\nrelevant  messages  any\
    \ more?  This issue can be solved in one of\nthe two ways: either let the protocol\
    \ specify a fixed rule that S\nwill be required to close the connection, or the\
    \  protocol  could\nallow  S  and R (and may be the users on whose behalf S and\
    \ R are\ncommunicating on X) to negotiate the action to be taken.  For the\nprotocol\
    \ to be presented here, we have taken the approach that  S\nmay, at its option,\
    \ either close the connection or negotiate with\nR.   What  action  a specific\
    \ host takes can either be built into\nits NCP or determined dynamically.  Those\
    \ hosts that do not  have\nvery  powerful  machines will probably chose the static\
    \ option of\nclosing the  connection;   other  hosts  may  make  the  decision\n\
    depending upon the circumstances.  For example, a host may decide\nthat  loss\
    \  of  messages  is not acceptable during file transfers\nwhereas  loss of a single\
    \ message can  be  ignored  for  terminal\noutput  to  interactive  users.   A\
    \  host might even let the user\nprocesses decide  the  course  of  action  to\
    \  be  taken.   If  S\ndetermines  that it can not retransmit lost messages, it\
    \ may want\nto let R decide what action is to be taken.   If  S  so  decides,\n\
    then  it  may  communicate  this  fact  to  R  by  transmitting a\n_\bL_\bo_\b\
    s_\bt__\bM_\be_\bs_\bs_\ba_\bg_\be__\bf_\br_\bo_\bm__\bS_\be_\bn_\bd_\be_\br \
    \ (LMS)  control  message  to  R  on  the\nchannel  S->R.   An LMS message is\
    \ of the following form:  LMS(X,\nCN, MSN, COUNT), where X is the name of the\
    \ channel,  CN  is  the\nname  of  the C-channel obtained from the LMR message,\
    \ MSN is the\nmessage sequence number of the first message in the  sequence  of\n\
    lost  messages,  and  COUNT  is  the  number  of  messages in the\nsequence. \
    \ S resets its own synch-state for connection X to  S(X,\nCN,  MSN+COUNT).   When\
    \  S  has  informed  R  of its inability to\nretransmit lost messages, the burden\
    \ of the decision falls on  R,\nand  S  simply  awaits R's reply before taking\
    \ any action for the\nchannel X.  When R receives the LMS, it may  either  decide\
    \  that\nloss  is  unacceptable and close the connection, or it may decide\nto\
    \ let S continue.  In the later case R informs S of its decision\n           \
    \         - 7 -\nto continue by transmitting  a  L\b__\bo_\bs_\bs__\bo_\bf__\b\
    M_\be_\bs_\bs_\ba_\bg_\be__\bA_\bc_\bc_\be_\bp_\bt_\ba_\bb_\bl_\be  (LMA)\ncontrol\
    \  message to S.  Upon receiving the LMA control message, S\nresumes transmission\
    \ on X.  To avoid the possibility of errors in\nexchange  of  control  messages,\
    \  the  LMA  control  message   is\nspecified  to  be  an  exact  replica of the\
    \ LMS control message,\nexcept for the message code which determines  whether\
    \  a  control\nmessage is LMA or LMS or something else.\nIn  general,  a  sending\
    \ host has only a limited amount of memory\navailable for storing messages for\
    \ possible retransmission later.\nIn section 2.6 we provide a status exchange\
    \ mechanism that can be\nused to determine when to discard these messages.\n2.5\
    \ RECOVERY ON CONTROL LINKS\nWe continue our discussion with the  scenario  developed\
    \  in  the\nprevious  section.  The receiver R may detect loss of messages on\n\
    control channels by examining the message sequence numbers on the\nmessages. \
    \ When R detects that a message has  been  lost  on  the\nchannel   S->R,  it\
    \  (R)  may  transmit  an  LMR  to  S  on  R->S\ncommunicating the fact of loss\
    \ of messages.  When S receives  the\nLMR  for  the  control  link,  it must either\
    \ retransmit the lost\nmessages,  or  \"close\"  the  connection.  (In  the  \
    \ context   of\nHost-to-Host protocol, closing the network connection for control\n\
    link  implies exchange of reset commands, which has the effect of\nreinitializing\
    \ all communication between R and S.)   For  control\nlinks,  S  does  not  have\
    \  the  option  of sending an LMS to the\nreceiver.  If S can not retransmit \
    \ the  lost  messages  then  it\naborts  the  output  queue  (if  any)  for  the\
    \ channel S->R, and\ninserts a Reset command at the break point.  Essentially,\
    \ we  are\nspecifying  that  if  S  can not retransmit lost control messages\n\
    then the error would be considered irrecoverable and fatal.   All\nuser  communication\
    \  between  S  and  R  is  broken  and  must be\nrestarted from the beginning.\n\
    In the above paragraph, we considered the situation  in  which  R\nwas  able to\
    \ detect the loss of messages.  It is however possible\nthat it is the last message\
    \ transmitted on S->R that is lost.  In\nthis  case,  R will not be aware of the\
    \ loss.  In this situation,\nrecovery can  be  initiated  only  if  S  can  either\
    \  positively\ndetermine  or  simply  suspect  that a message has been lost. \
    \ In\ngeneral, after having transmitted a control message, S  would  be\nexpecting\
    \  some  sort  of  response  from  R.  For  example, if S\ntransmits a Request-for-Connection\
    \ (RFC) control message to R,  S\nexpects  R  to reply either with a Close (CLS)\
    \ command or another\nhas  received  no reply from R, our protocol specifies that\
    \ S may\nretransmit the control message.  In retransmitting,  S  must  use\n \
    \                   - 8 -\nthe same C-channel and MSN values that were used for\
    \ the original\nmessage.    Since  R  can,  now,  receive  duplicate  copies,\
    \  we\nstipulate that if R receives a duplicate of the message  that  it\nhas\
    \ already received, it may simply ignore the duplicate.\n2.6 SOME OTHER PROBLEMS\n\
    There  are  two problems that have not yet been solved.  First, a\nsending host\
    \ will usually have only a limited  amount  of  buffer\nspace   in   which  it\
    \  can  save  messages  for  possible  later\nretransmission.  So far, we have\
    \ not provided any method by which\na  host  may  positively  determine  whether\
    \  the  receiver   has\ncorrectly received a certain message or not.  Thus it\
    \ has no firm\nbasis  on  which  it  may  decide to release the space used up\
    \ by\nmessages that have been already transmitted.  The second  problem\nis  created\
    \  by  our recycling the message sequence numbers.  For\nthe MSN mechanism to\
    \ work correctly, it is essential that at  any\ngiven  instant  of  time there\
    \ be no more than 15 messages in the\ntransmission path.  If there were more than\
    \ 15 messages, some  of\nthese  messages  would have same MSN and LRN, and if\
    \ one of these\nmessages were to be lost, it would be impossible to identify \
    \ the\nlost  message.   However,  the second problem should not arise in\nthe\
    \ ARPA Network, since the IMP sub-network will not  allow  more\nthan  eight \
    \ outstanding  messages between any host pair (NWG-RFC\n#660).\nWe can solve both\
    \ these problems by a simple yet highly  flexible\nscheme.  In this scheme, there\
    \ are two new control messages.  One\nof these, called R\b__\be_\bq_\bu_\be_\b\
    s_\bt S\b__\bt_\ba_\bt_\bu_\bs _\bf_\br_\bo_\bm S\b__\be_\bn_\bd_\be_\br (RSS),\
    \ can be used by\nthe  sending  host to query the receiver regarding the receiver's\n\
    synch-state.  The receiver can supply  its  copies  of  C-channel\nnumber  and\
    \  MSN for a transmission path by sending a S\b__\bt_\ba_\bt_\bu_\bs _\bf_\br_\b\
    o_\bm\nR\b__\be_\bc_\be_\bi_\bv_\be_\br (SFR) control message over the control\
    \ channel.  An  SFR\nprovides  positive  acknowledgement;  differing  with  the\
    \  usual\nacknowledgement schemes in  only  that  here  acknowledgement  is\n\
    provided  only upon demand.  Upon receiving SFR, the sender knows\nexactly which\
    \ messages have been properly delivered, and  it  may\nfree  the  buffer  space\
    \ used by these messages.  The RSS and SFR\nscheme can also be used to ensure\
    \ that there  are  no  more  than\nfifteen messages in the transmission path at\
    \ any given time.\n                    - 9 -\n3.0 LOST MESSAGE DETECTION AND RECOVERY\
    \ PROTOCOL\nThis  protocol  is  proposed  as an amendment to the Host-to-Host\n\
    Protocol for the purpose of letting  hosts  detect  the  loss  of\nmessages  in\
    \  the  network. It also provides  recovery procedures\nfrom such losses.  This\
    \ protocol is divided into two parts.  Part\n1 states the compatibility requirements.\
    \  Part 2 states  the  new\nprotocol and must be implemented by hosts that desire\
    \ to have the\nability  to  recover  from  loss of messages in the network.  The\n\
    reader  will  find  many  comments  interspersed  throughout  the\ndescription\
    \ of this protocol.  These comments are not part of the\nprotocol and are provided\
    \ solely for the purpose of improving the\nreader's understanding of this protocol.\n\
    The  terminology used in this protocol is similar to that used in\nthe Host-to-Host\
    \ protocol.  We speak of  a  \"network  connection\"\nbetween  a pair of hosts,\
    \ called the \"receiver\" and the \"sender.\"\nA network connection is described\
    \ by a pair  of  socket  numbers,\nand  once  established, a network connection\
    \ is associated with a\nlink (which is described by a link number.)  A network\
    \ connection\nis a logical communication path and the link assigned to it is \
    \ a\nphysical  communication  path.   In  addition to links associated\nwith the\
    \ network connections, there are \"control-links\"  for  the\ntransmission  of\
    \  \"control  commands.\"   When  we  use  the  term\n\"connection\" it may refer\
    \ to either a network connection  or  the\nlink  assigned  to  it;  the context\
    \ decides which one.  The term\n\"links\" encompasses the connection-associated-links\
    \  as  well  as\ncontrol-links.   Notice  that  a  receiver  of  a  connection\
    \ may\ntransmit control commands regarding this connection.\n3.1 DEFINTIONS\n\
    3.1.1 HOST TYPE \"A\"\nThose hosts that have not adopted the part  2  of  this\
    \  protocol\namendment will be known as type A hosts.\n(Comment: All existing\
    \ hosts are type A hosts.)\n3.1.2 HOST TYPE \"B\"\nThose  hosts,  that  adopt\
    \  the part 2 of this protocol amendment\nwill be known as type B hosts.\n   \
    \                - 10 -\n3.1.3 MESSAGE SEQUENCE NUMBER (MSN)\nA four bit number\
    \ associated with regular messages and  contained\nin  the  bits  25  through\
    \  28 of the Host-to-IMP and IMP-to-Host\nleaders for regular messages [BBN Report\
    \ No. 1822].  This  number\nis  used  by  the  type  B hosts to detect loss of\
    \ messages  on a\ngiven link.  Type A hosts always set the MSN  (for  the  messages\n\
    they  send out) to zero.  When in use by a type B host, the first\nmessage on\
    \ a link (after the connection has been established) has\nthe MSN value of one.\
    \  For each successive message on this  link,\nthe MSN value is increased by one\
    \ until it reaches a value of 15.\nThe next message has the MSN value of one.\n\
    (Comments:  Type  B  hosts  will  use the MSN mechanism only when\ncommunicating\
    \ with other type B  hosts.  If  a  type  B  host  is\ncommunicating   with  a\
    \  type  A  host,  the  type  B  host  will\nessentially simulate the behaviour\
    \ of a type A host and use  zero\nMSN values for this communication.)\n3.1.4 LINK\
    \ RESYNCH NUMBER (LRN)\nThe  Link Resynch Number is an eight bit number associated\
    \ with a\nlink and used for resynchronizing the communication.   For  links\n\
    associated  with  a  network  connection (i.e. user links), it is\nintially set\
    \ to zero.  For control links, it is set  to  zero  at\nthe  time  of  the  Network\
    \ Control Program (NCP) initialization.\nFor a given link, its current LRN value\
    \ is copied  into  the  LRN\nfield  of  all messages sent out on the link.  The\
    \ LRN values may\nbe manipulated by type B hosts in accordance  with  the  protocol\n\
    described later.\n(Comments:   Our  protocol  specifies  that for all communication\n\
    involving a type A host, the LRN value  will  never  change  from\nzero.   Since\
    \ the LRN field is presently unused, all hosts set it\nto zero even though they\
    \ do not explicitly recognize  this  field\nas an LRN field.  This guarantees\
    \ compatibility.)\n3.1.5 LRN FIELD\nAn  eight bit field in the bits 33 through\
    \ 40 of the Host-to-Host\nmessage header.\n                   - 11 -\n3.2 NEW\
    \ CONTROL COMMANDS\n3.2.1 LMR - LOST MESSAGE FROM RECEIVER\n___8\b______8\b_______8\b\
    _______8\b____\n|     I      I      I     I\nI LMR | link | LRN  | MSN I\nI\b\
    ______I\b_______I\b_______I\b______I\b_\nThe LMR command is sent by a receiving\
    \ host to  let  the  sending\nhost  know  that  one  or  more messages have been\
    \ lost.  The MSN\nfield specifies the message sequence number of the first  message\n\
    lost.   The  LRN  field  specifies the new LRN value that must be\nused if and\
    \ when communication is restored.\n(Comments:  As will be seen later, the LMR\
    \ command also  has  the\neffect of resetting the bit and message allocation in\
    \ the sending\nhost   to   zero.   In  order  to  permit  a  sender  to  restore\n\
    communication, an LMR command will be usually accompanied with an\nallocate command.\
    \  However notice  that  these  comments  do  not\napply  to  the  control  links\
    \  because  there  is  no allocation\nmechanism for the control links.)\n3.2.2\
    \ LMS - LOST MESSAGE FROM SENDER\n____8\b_________8\b________8\b__________8\b\
    _________8\b_____\nI        I       I        I         I       I\nI  LMS   I Link\
    \  I  LRN   I  MSN    I COUNT I\nI\b_\b_________I\b________I\b_________I\b__________I\b\
    ________I\b_\nThis command is sent by a sender host in reply to an LMR  command\n\
    if it (the sender) can not retransmit the lost messages specified\nby  the LMR\
    \ command.  The purpose of this command is to query the\nreceiver whether or not\
    \  the  loss  of  messages  is  acceptable.\nAfter  sending  this command, the\
    \ sender waits for a reply before\ntransmitting any messages over the link involved.\
    \   This  command\nmay  not  be  sent for control links.  The LRN and MSN values\
    \ are\nsame as those specified by the LMR command.  COUNT specifies  the\nnumber\
    \ of messages lost.\n3.2.3  LMA - LOSS OF MESSAGES ACCEPTABLE\nThis  command \
    \ is  identical  to  the  LMS command accept for the\ncommand code.  Upon receipt\
    \ of an LMS  command,  a  receiver  may\n                   - 12 -\nsend  this\
    \ command to the sender to let the sender know that loss\nof messages is acceptable.\
    \  All fields in this command are set to\ncorresponding values in the LMS command.\n\
    3.2.4  CLS2 - CLOSE2\n____8\b___________3\b_2\b_______________3\b_2\b_____________8\b\
    _______8\b__\b____\nI       I              I                 I       I      I\n\
    I CLS2  I  my socket   I your socket     I  LRN  I MSN  I\nI\b________I\b_______________I\b\
    __________________I\b________I\b_______I\b_\nThe CLS2 command is similar to the\
    \ current CLS command except for\nthe LRN and MSN fields included in the  new\
    \  command.   Both  the\nreceiving and sending hosts copy their values of LRN\
    \ and MSN into\nthe CLS2 command.  Upon receiving a CLS2 command, a host compares\n\
    the LRN and MSN values contained in the CLS2 command with its own\nvalues  for\
    \  the  connection  involved.   If  these values do not\nmatch, then an  error\
    \  has  occurred  and  a  host  may  initiate\nrecovery procedures.\n(Comments:\
    \   The  purpose  of  this command is to ensure that the\nlast message  transmitted\
    \  on  a  connection  has  been  received\nsuccesfully.)\n3.2.5 ECLS - ERROR CLOSE\n\
    _____8\b___________3\b_2\b___________3\b_2\b_________\nI        I            \
    \ I             I\nI  ECLS  I my socket   I  your socketI\nI\b_________I\b______________I\b\
    ______________I\b_\nThe  ECLS  command  is similar to the current CLS command.\
    \  It is\nused  for   closing   connections   which   have   sufferred   an\n\
    irrecoverable loss of messages.\n(Comments: A connection may be closed in any\
    \ one of the following\nthree ways:\n      1. A connection which has not yet been\
    \ opened  succesfully\nmay  be  closed  by  the  CLS command.  All connections\n\
    involving type A hosts must be  closed  using  the  CLS\ncommand.\n      2. Connections\
    \ between type B hosts may  be  closed  using\nCLS2  command.   A connection is\
    \ considered closed only\nif matching CLS2 commands have been  exchanged  between\n\
    \                   - 13 -\nthe sender and the receiver.\n      3. Those connections\
    \  between  type  B  hosts,  that  have\nsufferred  an  irrecoverable  loss of\
    \ messages, must be\nclosed by the ECLS command.)\n3.2.6 RSS - REQUEST STATUS\
    \ FROM SENDER\n____8\b_______8\b______\nI      I        I\nI RSS  I LINK   I\n\
    I\b_______I\b_________I\b_\nA sending host may issue an RSS command to  find \
    \ out  about  the\nstatus  of transmission on a particular connection or the control\n\
    link.\n3.2.7  RSR - REQUEST STATUS FROM RECEIVER\n____8\b_________8\b_____\nI\
    \       I        I\nI RSR   I LINK   |\nI\b________I\b_________I\b_\nA receiver\
    \ can issue an RSR command to find out about the  status\nof  transmission  on\
    \ a particular connection or the control link.\n3.2.8 SFR - STATUS FROM RECEIVER\n\
    ____8\b_________8\b_________8\b_________8\b____\nI        I        I        I\
    \       I\nI SFR    I  LINK  I  LRN   I MSN   I\nI\b_________I\b_________I\b_________I\b\
    ________I\b_\nA receiving host may issue this  command  to  inform  the  sender\n\
    about  the  state of a particular connection or the control link.\n3.2.9 SFS -\
    \ STATUS FROM SENDER\n                   - 14 -\n____8\b_________8\b_________8\b\
    _________8\b____\nI        I        I        I       I\nI SFS    I  LINK  I  LRN\
    \   I MSN   I\nI\b_________I\b_________I\b_________I\b________I\b_\nA sending\
    \ host may issue this  command  to  inform  the  receiver\nabout  the  state of\
    \ a particular connection or the control link.\n3.3  THE PROTOCOL\n3.3.1 PART\
    \ ONE\nAll type A hosts must use zero MSN and LRN values on the messages\nsent\
    \ out by them.  When communicating with a host of  type  A,  a\ntype B host must\
    \ simulate the behaviour of type A host.\n(Comments:   Notice  that  this  simulation\
    \ is not complicated at\nall.  All that  is  required  is  that   hosts  that\
    \  adopt  this\nprotocol  must  not use it when communicating with the hosts that\n\
    have not adopted it.)\n3.3.2 PART TWO\nThis part of the protocol is stated as\
    \ a set of rules which  must\nbe  observed  by  all  type B hosts when communicating\
    \ with other\ntype B hosts.\n3.3.2.1 RESPONSIBILITIES OF HOSTS AS SENDERS\n  \
    \  (1). A type B sending host must use message sequence numbers\non all regular\
    \ messages that it sends to other  type  B\nhosts  as  specified  in  the definition\
    \ of the message\nsequence numbers (Section 3.1.3).\n    (2). A type B sending\
    \ host must use link resynch numbers  on\nall  regular  messages  that  it  sends\
    \ to other type B\nhosts as specified in the definition  of  link  resynch\nnumber\
    \ (Section 3.1.4).\n    (3). A sending host may retransmit a message if it  suspects\n\
    that  the  message  may  have  been lost in the network\nduring previous transmission.\n\
    \    (4). A sending host may issue an RSS command to the receiver\nto determine\
    \ the state of transmission on any link.\n    (5). A sending host must use the\
    \ ECLS  command  to  close  a\nconnection, if the connection is being closed due\
    \ to an\n                   - 15 -\nirrecoverable  transmission  error.  Otherwise,\
    \ it must\nthe CLS2 command.\n3.3.2.2 RESPONSIBILITIES OF HOSTS AS RECEIVERS\n\
    \    (1). A receiver host will maintain LRN and  MSN  values  for\neach link on\
    \ which it receives messages.  Initial value\nof  LRN  will be zero, and initial\
    \ value of MSN will be\none.   For  each  receive  link,  the  host  should  be\n\
    prepared  to  receive a message with LRN and MSN values\nspecified by its tables.\
    \  When the  host  has  received\nthe  expected  message  on a given link, it\
    \ will change\nits table MSN value as specified in the  definition  of\nMSN.\n\
    \    (2). On a given link, if a host receives a message  with  an\nLRN  value\
    \  smaller than the one in use, it will ignore\nthe message.\n    (3). If a host\
    \ receives a duplicate message  (same  LRN  and\nMSN values), it will ignore the\
    \ duplicate.\n    (4). A host will examine  the  MSN  values  on  all  regular\n\
    messages  that  it receives to detect loss of messages.\nIf on any link, one or\
    \ more messages are found missing,\nit will concern itself with only the first\
    \ message lost\nand take the following series of action:\n       1. Increase its\
    \ own LRN value for this  link  by\n          one.\n       2. Send an LMR command\
    \ to the sending host  with\n          LRN  field set to the new value and MSN\
    \ field\n          set to  the  sequence  number  of  the  first\n          message\
    \ lost.\n       3. Realizing that LMR  command  will  cause  the\n          allocation\
    \  to be reset to zero, it will send\n          more allocation. This is  not\
    \  applicable  to\n          the control links.\nHowever,  if  a  host  does \
    \ not  want  to initiate the\nrecovery procedures, it may simply close the connection\n\
    by an ECLS command.\n    (5). A receiver host may  issue the RSR command to determine\n\
    the state of transmission on any link.\n    (6). If a connection is being closed\
    \ due to an irrecoverable\nerror, a receiving host  must  use  the  ECLS  command.\n\
    Otherwise it must use the CLS2 command.\n                   - 16 -\n3.3.2.3  SENDING\
    \ HOST'S RESPONSE TO CONTROL MESSAGES\n    (1). RSR command: the sender must transmit\
    \ a SFS command  to\nthe receiver for the link involved.\n    (2). ECLS command:\
    \ The sender must cease transmission, if it\nhas  not  already done so, and issue\
    \ an ECLS command if\nit has  not  already  issues  either  a  ECLS  or  CLS2\n\
    command.\n    (3) CLS2 command: The sender must compare the  LRN  and  MSN\nvalues\
    \  of  the CLS2 command with its own values of the\nLRN and MSN for the connection\
    \ involved.  If  an  error\nis  indicated,  it may either close the connection\
    \ with\nan ECLS, or initiate recovery action  as  specified  in\nthe section 3.3.2.1.\n\
    \    (4). LMR command for  a  connection  (i.e.,  not  a  control\nlink):  The\
    \  sender may follow any one of the following\nthree courses of action:\n    \
    \   1. Close the connection with an ECLS command.\n       2. Set the allocations\
    \ for the link involved  to\n          zero,  set  LRN  to that specified in the\
    \ LMR\n          command, and  restart  communication  at  the\n          point\
    \ of break.\n       3. Set the allocations for the link involved  to\n       \
    \   zero,  set  the  LRN to that specified in the\n          LMR command, and\
    \ send an LMS command  to  the\n          receiver  host informing him that one\
    \ or more\n          of   the   lost   messages   can    not    be\n         \
    \ retransmitted.  After sending an LMS command,\n          a  sending  host  must\
    \  not transmit any more\n          messages  on  the  link  involved  until \
    \ and\n          unless  it  receives  an LMA command from the\n          receiver\
    \ host.\n(Comments:  As  we  have  mentioned  before  (Section  2.3),  the\ndecision\
    \  regarding which course of action to follow depends upon\na number of factors.\
    \  For example, if a host has implemented only\nthe detection of lost messages\
    \ aspect of  our  protocol  (and  no\nrecovery),  then  it  will  chose the first\
    \ option of closing the\nconnection.)\n    (5). LMR for a control link: The sender\
    \ may take one of  the\nfollowing two actions:\n       1. Set the LRN to  that\
    \  specified  in  the  LMR\n          command  and  begin  retransmission  of\
    \  lost\n          messages\n       2. Set the LRN to  that  specified  by  the\
    \  LMR\n          command,  and  insert  a Reset command at the\n          break\
    \ point.\n                   - 17 -\n(Comment:  If a sending host can not retransmit\
    \ messages lost  on\na   control   link,   then   this   protocol  requires  that\
    \  all\ncommunication between the two host be broken, and  reinitialized.\nWe\
    \ do not explicitly specify the actions that are associated with\nthe  exchange\
    \  of Reset commands.  These actions are specified by\nthe Host-to-Host protocol.)\n\
    \    (6). LMA command:  When  a  sending  host  receives  an  LMA\ncommand  matching\
    \  an  LMS command previously issued by\nit, it may resume transmission.\n(Comments:\
    \ The protocol does not require the sending host to take\nany specific action\
    \ with regard to a SFR. However, a sending host\nmay use the information contained\
    \ in the  SFR  command  regarding\nthe  state of transmission.  From a SFR command\
    \ a sender host may\ndetermine what messages have been received properly.  The\
    \  sender\nmay   use  this  information  to  cleanup  its  buffer  space  or\n\
    retransmit messages that it might suspect are lost.)\n3.3.2.4 RECEIVING HOST'S\
    \ RESPONSE TO CONTROL MESSAGES\n    (1). RSS command: A receiver is obligated\
    \ to transmit a  SFR\nto the sender for the link involved.\n    (2). ECLS command:\
    \  The receiver must close  the  connection\nby  issuing  an ECLS command if it\
    \ has not already done\nso.\n    (3). CLS2 command: A receiver must compare the\
    \ LRN  and  MSN\nvalues  of  the  command  with  its  own values for the\nconnection\
    \ involved.  If an error is indicated, it  may\neither  close  the  connection\
    \  by  an  ECLS command or\ninitiate recovery procedures as  specified  in  section\n\
    3.3.2.2.\n    (4). LMS command: The receiver may take one of the following\ntwo\
    \ courses of action:\n     (1). Close the connection  specified  by  the  LMS\n\
    \          command, by issuing an ECLS command.\n     (2). Set the  link  involved\
    \  to  be  prepared  to\n          receive  messages  starting with the sequence\n\
    \          number MSN + COUNT, where MSN and  COUNT  are\n          those   specified\
    \   by   the   LMS   command.\n          (Comment: This action implies  that \
    \ receiver\n          is  willing  to  accept  the loss of messages\n        \
    \  specified by the LMS command.)\n(Comments: The protocol does not require the\
    \ receiver to take any\nspecific action with regard to a SFS command. However\
    \ a  receiver\n                   - 18 -\nhost may use the information  contained\
    \ in it.)\n4.0 CONCLUDING REMARKS\nThe  design  of  this  protocol  has been governed\
    \ by three major\nprinciples.  First, we believe that to be useful within the\
    \  ARPA\nNetwork,  any  new  protocol must be compatible with the existing\nprotocols,\
    \ so that each host can make the transition to  the  new\nprotocol at its own\
    \ pace and without large investment.  Secondly,\nthe  protocol  should  tie  into\
    \  the  recovery  mechanism of the\nIMP-to-Host Protocol.  The price we pay for\
    \ this is the small MSN\nfield and a   message oriented protocol rather than a\
    \ byte stream\noriented protocol.  The third consideration has been flexibility.\n\
    While this protocol guarantees detection of  lost  messages,  the\nphilosophy\
    \  behind  the recovery procedures is that a host should\nhave several options,\
    \ each option providing a different degree of\nsophistication.  A host can implement\
    \ a recovery  procedure  that\nis  most  suitable  for  its  needs  and  the capabilities\
    \ of its\nmachine.  Even though two hosts may  have  implemented  different\n\
    recovery  procedures,  they  can communicate with each other in a\ncompatible\
    \ way.  In a network of independent machines  of  widely\nvarying  capabilities\
    \ and requirements, this seems to be the only\nway of implementing such a protocol.\
    \  Even though  this  protocol\nprovides  a  variety  of  options in a given error\
    \ situation, the\nchoice of a specific action must be  consistent  with  the \
    \ basic\nrequirements  of  the  communication  path.  For example, partial\nrecovery\
    \ is not  acceptable  during  file  transfers.   We  fully\nexpect   the  File\
    \  Transfer  Protocol  to  specify  that  if  an\nirrecoverable error occurs,\
    \ the file transfer must be aborted.\n                   - 19 -\n"
