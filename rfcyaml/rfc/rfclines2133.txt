Abstract The de facto standard application program interface (API) for TCP/IP applications is the "sockets" interface.
Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non Unix systems.
TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications.
But changes are required to the sockets API to support IPv6 and this memo describes these changes.
These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options.
These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications.
Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document [5].
While IPv4 addresses are 32 bits long, IPv6 interfaces are identified by 128 bit addresses.
The socket interface make the size of an IP address quite visible to an application; virtually all TCP/IP applications for BSD based systems have knowledge of the size of an IP address.
Those parts of the API that expose the addresses must be changed to accommodate the larger IPv6 address size.
IPv6 also introduces new features (e.g., flow label and priority), some of which must be made visible to applications via the API.
This memo defines a set of extensions to the socket interface to support the larger address size and new features of IPv6. 2.
There are a number of important considerations in designing changes to this well worn API:
The API changes should provide both source and binary compatibility for programs written to the original API.
That is, existing program binaries should continue to operate when run on a system supporting the new API.
In addition, existing applications that are re compiled and run on a system supporting the new API should continue to operate.
Simply put, the API changes for IPv6 should not break existing programs.
The changes to the API should be as small as possible in order to simplify the task of converting existing IPv4 applications to IPv6.
Where possible, applications should be able to use this API to interoperate with both IPv6 and IPv4 hosts.
Applications should not need to know which type of host they are communicating with.
IPv6 addresses carried in data structures should be 64 bit aligned.
This is necessary in order to obtain optimum performance on 64 bit machine architectures.
Because of the importance of providing IPv4 compatibility in the API, these extensions are explicitly designed to operate on machines that provide complete support for both IPv4 and IPv6.
A subset of this API could probably be designed for operation on systems that support only IPv6.
However, this is not addressed in this memo.
What Needs to be Changed
The socket interface API consists of a few distinct components:  Core socket functions.
Name to address translation functions.
those functions that deal with such things as setting up and tearing down TCP connections, and sending and receiving UDP packets   were designed to be transport independent.
Where protocol addresses are passed as function arguments, they are carried via opaque pointers.
A protocol specific address data structure is defined for each protocol that the socket functions support.
Applications must cast pointers to these protocol specific address structures into pointers to the generic "sockaddr" address structure when using the socket functions.
These functions need not change for IPv6, but a new IPv6 specific address data structure is needed.
The "sockaddr in" structure is the protocol specific data structure for IPv4.
This data structure actually includes 8 octets of unused space, and it is tempting to try to use this space to adapt the sockaddr in structure to IPv6.
Unfortunately, the sockaddr in structure is not large enough to hold the 16 octet IPv6 address as well as the other information (address family and port number) that is needed.
So a new address data structure must be defined for IPv6.
The name to address translation functions in the socket interface are gethostbyname() and gethostbyaddr().
These must be modified to support IPv6 and the semantics defined must provide 100% backward compatibility for all existing IPv4 applications, along with IPv6 support for new applications.
Additionally, the POSIX 1003.g work in progress [4] specifies a new hostname to address translation function which is protocol independent.
This function can also be used with IPv6.
These functions are quite specific to 32 bit IPv4 addresses.
We have designed two analogous functions that convert both IPv4 and IPv6 addresses, and carry an address type parameter so that they can be extended to other protocol families as well.
Finally, a few miscellaneous features are needed to support IPv6.
New interfaces are needed to support the IPv6 flow label, priority, and hop limit header fields.
New socket options are needed to control the sending and receiving of IPv6 multicast packets.
The socket interface will be enhanced in the future to provide access to other IPv6 features.
These extensions are described in [5].
The data types of the structure elements given in this memo are intended to be examples, not absolute requirements.
Whenever possible, POSIX 1003.1g data types are used:
u intN t means an unsigned integer of exactly N bits (e.g., u int16 t) and u intNm t means an unsigned integer of at least N bits (e.g., u int32m t).
We also assume the argument data types from 1003.1g when possible (e.g., the final argument to setsockopt() is a size t value).
Whenever buffer sizes are specified, the POSIX 1003.1 size t data type is used (e.g., the two length arguments to getnameinfo()).
When function prototypes and structures are shown we show the headers that must be #included to cause that item to be defined.
When structures are described the members shown are the ones that must appear in an implementation.
Additional, nonstandard members may also be defined by an implementation.
The ordering shown for the members of a structure is the recommended ordering, given alignment considerations of multibyte members, but an implementation may order the members differently.
This section specifies the socket interface changes for IPv6.
IPv6 Address Family and Protocol Family
A new address family name, AF INET6, is defined in <sys/socket.h
The AF INET6 definition distinguishes between the original sockaddr in address data structure, and the new sockaddr in6 data structure.
A new protocol family name, PF INET6, is defined in <sys/socket.h
Like most of the other protocol family names, this will usually be defined to have the same value as the corresponding address family name: #define
The PF INET6 is used in the first argument to the socket() function to indicate that an IPv6 socket is being created.
A new data structure to hold a single IPv6 address is defined as follows:
This data structure contains an array of sixteen 8 bit elements, which make up one 128 bit IPv6 address.
The IPv6 address is stored in network byte order.
Socket Address Structure for 4.3BSD Based Systems
In the socket interface, a different protocol specific data structure is defined to carry the addresses for each protocol suite.
Each protocol specific data structure is designed so it can be cast into a protocol independent data structure   the "sockaddr" structure.
Each has a "family" field that overlays the "sa family" of the sockaddr data structure.
This field identifies the type of the data structure.
The sockaddr in structure is the protocol specific address data structure for IPv4.
It is used to pass addresses between applications and the system in the socket functions.
The following structure is defined to carry IPv6 addresses: #include <netinet/in.h>
The sin6 family field identifies this as a sockaddr in6 structure.
This field overlays the sa family field when the buffer is cast to a sockaddr data structure.
The value of this field must be AF INET6.
The sin6 port field contains the 16 bit UDP or TCP port number.
This field is used in the same way as the sin port field of the sockaddr in structure.
The port number is stored in network byte order.
The sin6 flowinfo field is a 32 bit field that contains two pieces of information: the 24 bit IPv6 flow label and the 4 bit priority field.
The contents and interpretation of this member is unspecified at this time.
The sin6 addr field is a single in6 addr structure (defined in the previous section).
This field holds one 128 bit IPv6 address.
The address is stored in network byte order.
The ordering of elements in this structure is specifically designed so that the sin6 addr field will be aligned on a 64 bit boundary.
This is done for optimum performance on 64 bit architectures.
Notice that the sockaddr in6 structure will normally be larger than the generic sockaddr structure.
On many existing implementations the sizeof(struct sockaddr in) equals sizeof(struct sockaddr), with both being 16 bytes.
Any existing code that makes this assumption needs to be examined carefully when converting to IPv6.
Socket Address Structure for 4.4BSD Based Systems
The 4.4BSD release includes a small, but incompatible change to the socket interface.
The "sa family" field of the sockaddr data structure was changed from a 16 bit value to an 8 bit value, and the space saved used to hold a length field, named "sa len".
The sockaddr in6 data structure given in the previous section cannot be correctly cast into the newer sockaddr data structure.
For this reason, the following alternative IPv6 address data structure is provided to be used on systems based on 4.4BSD:
The definitions of all the other fields are identical to the structure defined in the previous section.
Systems that provide this version of the sockaddr in6 data structure must also declare SIN6 LEN as a result of including the <netinet/in.h> header.
This macro allows applications to determine whether they are being built on a system that supports the 4.3BSD or 4.4BSD variants of the data structure.
The Socket Functions Applications call the socket() function to create a socket descriptor that represents a communication endpoint.
The arguments to the socket() function tell the system which protocol to use, and what format address structure will be used in subsequent functions.
For example, to create an IPv4/TCP socket, applications make the call
: s   socket(PF INET, SOCK STREAM, 0); To create an IPv4/UDP socket, applications make the call
: s   socket(PF INET, SOCK DGRAM, 0); Applications may create IPv6/TCP and IPv6/UDP sockets by simply using the constant PF INET6 instead of PF INET in the first argument.
For example, to create an IPv6/TCP socket, applications make the call
: s   socket(PF INET6, SOCK STREAM, 0); To create an IPv6/UDP socket, applications make the call
: s   socket(PF INET6, SOCK DGRAM, 0); Once the application has created a PF INET6 socket, it must use the sockaddr in6 address structure when passing addresses in to the system.
The functions that the application uses to pass addresses into the system are: bind() connect()
The system will use the sockaddr in6 address structure to return addresses to applications that are using PF INET6 sockets.
The functions that return an address from the system to an application are: accept(
) recvfrom() recvmsg() getpeername() getsockname()
No changes to the syntax of the socket functions are needed to support IPv6, since all of the "address carrying" functions use an opaque address pointer, and carry an address length as a function argument.
In order to support the large base of applications using the original API, system implementations must provide complete source and binary compatibility with the original API.
This means that systems must continue to support PF INET sockets and the sockaddr in address structure.
Applications must be able to create IPv4/TCP and IPv4/UDP sockets using the PF INET constant in the socket
() function, as described in the previous section.
Applications should be able to hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets simultaneously within the same process.
Applications using the original API should continue to operate as they did on systems supporting only IPv4.
That is, they should continue to interoperate with IPv4 nodes.
The API also provides a different type of compatibility: the ability for IPv6 applications to interoperate with IPv4 applications.
This feature uses the IPv4 mapped IPv6 address format defined in the IPv6 addressing architecture specification [2].
This address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.
The IPv4 address is encoded into the low order 32 bits of the IPv6 address, and the high order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.
IPv4 mapped addresses are written as follows: ::FFFF:<IPv4 address
> These addresses are often generated automatically by the gethostbyname() function when the specified host has only IPv4 addresses (as described in Section 6.1).
Applications may use PF INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by simply encoding the destination's IPv4 address as an IPv4 mapped IPv6 address, and passing that address, within a sockaddr in6 structure, in the connect() or sendto() call.
When applications use PF INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system returns the peer's address to the application in the accept(), recvfrom(), or getpeername()
call using a sockaddr in6 structure encoded this way.
Few applications will likely need to know which type of node they are interoperating with.
However, for those applications that do need to know, the IN6 IS ADDR V4MAPPED() macro, defined in Section 6.6, is provided.
While the bind() function allows applications to select the source IP address of UDP packets and TCP connections, applications often want the system to select the source address for them.
With IPv4, one specifies the address as the symbolic constant INADDR ANY (called the "wildcard" address) in the bind() call, or simply omits the bind() entirely.
Since the IPv6 address type is a structure (struct in6 addr), a symbolic constant can be used to initialize an IPv6 address variable, but cannot be used in an assignment.
Therefore systems provide the IPv6 wildcard address in two forms.
The first version is a global variable named "in6addr
any" that is an in6 addr structure.
The extern declaration for this variable is defined in <netinet/in.h>:
extern const struct in6 addr in6addr
any similarly to the way they use INADDR ANY in IPv4.
; sin6.sin6 flowinfo   0; sin6.sin6 port   htons(23); sin6.sin6 addr   in6addr
The other version is a symbolic constant named IN6ADDR ANY INIT and is defined in <netinet/in.h
This constant can be used to initialize an in6 addr structure: struct in6 addr anyaddr
; Note that this constant can be used ONLY at declaration time.
It can not be used to assign a previously declared in6 addr structure.
For example, the following code will not work: /
Be aware that the IPv4 INADDR xxx constants are all defined in host byte order but the IPv6 IN6ADDR xxx constants and the IPv6 in6addr
xxx externals are defined in network byte order.
Loopback Address Applications may need to send UDP packets to, or originate TCP connections to, services residing on the local node.
In IPv4, they can do this by using the constant IPv4 address INADDR LOOPBACK in their connect(), sendto(), or sendmsg() call.
IPv6 also provides a loopback address to contact local TCP and UDP services.
Like the unspecified address, the IPv6 loopback address is provided in two forms   a global variable and a symbolic constant.
The global variable is an in6 addr structure named "in6addr
The extern declaration for this variable is defined in <netinet/in.h>:
extern const struct in6 addr in6addr
loopback as they would use INADDR LOOPBACK in IPv4 applications (but beware of the byte ordering difference mentioned at the end of the previous section).
; sin6.sin6 flowinfo   0; sin6.sin6 port   htons(23); sin6.sin6 addr   in6addr
The symbolic constant is named IN6ADDR LOOPBACK INIT and is defined in <netinet/in.h
It can be used at declaration time ONLY; for example: struct in6 addr loopbackaddr   IN6ADDR LOOPBACK INIT; Like IN6ADDR ANY INIT, this constant cannot be used in an assignment to a previously declared IPv6 address variable.
This API uses an interface index (a small positive integer) to identify the local interface on which a multicast group is joined (Section 5.3).
Additionally, the advanced API [5] uses these same interface indexes to identify the interface on which a datagram is received, or to specify the interface on which a datagram is to be sent.
Interfaces are normally known by names such as "le0", "sl1", "ppp2", and the like.
On Berkeley derived implementations, when an interface is made known to the system, the kernel assigns a unique positive integer value (called the interface index) to that interface.
These are small positive integers that start at 1.
(Note that 0 is never used for an interface index.)
There may be gaps so that there is no current interface for a particular positive interface index.
This API defines two functions that map between an interface name and index, a third function that returns all the interface names and indexes, and a fourth function to return the dynamic memory allocated by the previous function.
How these functions are implemented is left up to the implementation.
4.4BSD implementations can implement these functions using the existing sysctl() function with the NET RT LIST command.
Other implementations may wish to use ioctl() for this purpose.
The first function maps an interface name into its corresponding index.
if nametoindex(const char  ifname); If the specified interface does not exist, the return value is 0.
The second function maps an interface index into its corresponding name.
if indextoname(unsigned int ifindex, char  ifname); The ifname argument must point to a buffer of at least IFNAMSIZ bytes into which the interface name corresponding to the specified index is returned.
(IFNAMSIZ is also defined in <net/if.h> and its value includes a terminating null byte at the end of the interface name.)
This pointer is also the return value of the function.
If there is no interface corresponding to the specified index, NULL is returned.
Return All Interface Names and Indexes
The final function returns an array of if nameindex structures, one structure per interface.
The function returns a NULL pointer upon an error.
The memory used for this array of structures along with the interface names pointed to by the if name members is obtained dynamically.
This memory is freed by the next function.
The following function frees the dynamic memory that was allocated by if nameindex().
if freenameindex(struct if nameindex  ptr); The argument to this function must be a pointer that was returned by if nameindex().
A number of new socket options are defined for IPv6.
All of these new options are at the IPPROTO IPV6 level.
That is, the "level" parameter in the getsockopt() and setsockopt()
calls is IPPROTO IPV6 when using these options.
The constant name prefix IPV6  is used in all of the new socket options.
This serves to clearly identify these options as applying to IPv6.
The declaration for IPPROTO IPV6, the new IPv6 socket options, and related constants defined in this section are obtained by including the header <netinet/in.h>.
Changing Socket Type Unix allows open sockets to be passed between processes via the exec() call and other means.
It is a relatively common application practice to pass open sockets across exec() calls.
Thus it is possible for an application using the original API to pass an open PF INET socket to an application that is expecting to receive a PF INET6 socket.
Similarly, it is possible for an application using the extended API to pass an open PF INET6 socket to an application using the original API, which would be equipped only to deal with PF INET sockets.
Either of these cases could cause problems, because the application that is passed the open socket might not know how to decode the address structures returned in subsequent socket functions.
To remedy this problem, a new setsockopt() option is defined that allows an application to "convert" a PF INET6 socket into a PF INET socket and vice versa.
An IPv6 application that is passed an open socket from an unknown process may use the IPV6 ADDRFORM setsockopt() option to "convert" the socket to PF INET6.
Once that has been done, the system will return sockaddr in6 address structures in subsequent socket functions.
An IPv6 application that is about to pass an open PF INET6 socket to a program that is not be IPv6 capable can "downgrade" the socket to PF INET before calling exec().
After that, the system will return sockaddr in address structures to the application that was exec()'ed.
Be aware that you cannot downgrade an IPv6 socket to an IPv4 socket unless all nonwildcard addresses already associated with the IPv6 socket
are IPv4 mapped IPv6 addresses.
The IPV6 ADDRFORM option is valid at both the IPPROTO IP and IPPROTO IPV6 levels.
The only valid option values are PF INET6 and PF INET.
For example, to convert a PF INET6 socket to PF INET, a program would call:
printf("This is an IPv4 socket.\n"); else if (addrform   PF INET6)
printf("This is an IPv6 socket.\n"); else printf("This system is broken.\n");
A new setsockopt() option controls the hop limit used in outgoing unicast IPv6 packets.
The name of this option is IPV6 UNICAST HOPS, and it is used at the IPPROTO IPV6 layer.
The following example illustrates how it is used: int
perror("setsockopt IPV6 UNICAST HOPS"); When the IPV6 UNICAST HOPS option is set with setsockopt(), the option value given is used as the hop limit for all subsequent unicast packets sent via that socket.
If the option is not set, the system selects a default value.
The integer hop limit value (called x) is interpreted as follows:
return an error of EINVAL
The IPV6 UNICAST HOPS option may be used with getsockopt() to determine the hop limit value that the system will use for subsequent unicast packets sent via that socket.
For example: int  hoplimit; size t  len
else printf("Using %d for hop limit.\n", hoplimit); 5.3.  Sending and Receiving Multicast Packets IPv6 applications may send UDP multicast packets by simply specifying an IPv6 multicast address in the address argument of the sendto() function.
Three socket options at the IPPROTO IPV6 layer control some of the parameters for sending multicast packets.
Setting these options is not required:  applications may send multicast packets without using these options.
The setsockopt() options for controlling the sending of multicast packets are summarized below:
IF Set the interface to use for outgoing multicast packets.
The argument is the index of the interface to use.
unsigned int IPV6 MULTICAST HOPS Set the hop limit to use for outgoing multicast packets.
(Note a separate option IPV6 UNICAST HOPS is provided to set the hop limit to use for outgoing unicast packets.)
The interpretation of the argument is the same as for the IPV6 UNICAST HOPS option:
return an error of EINVAL Argument type:
int IPV6 MULTICAST LOOP Controls whether outgoing multicast packets
should  be delivered  back  to the local application.
If the option is set to 1, multicast packets are looped back.
If it is set to 0, they are not.
The reception of multicast packets is controlled by the two setsockopt() options summarized below:
IPV6 ADD MEMBERSHIP Join a multicast group on a specified local interface.
If the interface index is specified as 0, the kernel chooses the local interface.
For example, some kernels look up the multicast group in the normal IPv6 routing table and using the resulting interface.
ipv6 mreq IPV6 DROP MEMBERSHIP Leave a multicast group on a specified interface.
The argument type of both of these options is the ipv6 mreq structure, defined as: #
ipv6 mreq { struct in6 addr ipv6mr multiaddr;
; Note that to receive multicast datagrams a process must join the multicast group and bind the UDP port to which datagrams will be sent.
Some processes also bind the multicast group address to the socket, in addition to the port, to prevent other datagrams destined to that same port from being delivered to the socket.
Library Functions New library functions are needed to perform a variety of operations with IPv6 addresses.
Functions are needed to lookup IPv6 addresses in the Domain Name System (DNS).
Both forward lookup (hostname to  address translation) and reverse lookup (address to hostname translation) need to be supported.
Functions are also needed to convert IPv6 addresses between their binary and textual form.
The commonly used function gethostbyname() remains unchanged as does the hostent structure to which it returns a pointer.
Existing applications that call this function continue to receive only IPv4 addresses that are the result of a query in the DNS for A records.
(We assume the DNS is being used; some environments may be using a hosts file or some other name resolution system, either of which may impede renumbering.
We also assume that the RES USE INET6 resolver option is not set, which we describe in more detail shortly.)
Two new changes are made to support IPv6 addresses.
First, the following function is new: #include <sys/socket.h
name, int af); The af argument specifies the address family.
The default operation of this function is simple:  If the af argument is AF INET, then a query is made for A records.
If successful, IPv4 addresses are returned and the h length member of the hostent structure will be 4, else the function returns a NULL pointer.
If the af argument is AF INET6, then a query is made for AAAA records.
If successful, IPv6 addresses are returned and the h length member of the hostent structure will be 16, else the function returns a NULL pointer.
The second change, that provides additional functionality, is a new resolver option RES USE INET6, which is defined as a result of including the <resolv.h> header.
(This option is provided starting with the BIND 4.9.4 release.)
There are three ways to set this option.
This option then affects only the process that is calling the resolver.
The second way to set this option is to set the environment variable RES OPTIONS, as in RES OPTIONS inet6.
(This example is for the Bourne and Korn shells.)
This method affects any processes that see this environment variable.
The third way is to set this option in the resolver configuration file (normally /etc/resolv.conf) and the option then affects all applications on the host.
This final method should not be done until all applications on the host are capable of dealing with IPv6 addresses.
There is no priority among these three methods.
When the RES USE INET6 option is set, two changes occur:  gethostbyname(host) first calls gethostbyname2(host, AF INET6) looking for AAAA records, and if this fails it then calls gethostbyname2(host, AF INET) looking for A records.
gethostbyname2(host, AF INET) always returns IPv4 mapped IPv6 addresses with the h length member of the hostent structure set to 16.
An application must not enable the RES USE INET6 option until it is prepared to deal with 16 byte addresses in the returned hostent structure.
The following table summarizes the operation of the existing gethostbyname() function, the new function gethostbyname2(), along with the new resolver option RES USE INET6.
(host, AF INET6)   addresses (h length 16).
It is expected that when a typical naive application that calls gethostbyname() today is modified to use IPv6, it simply changes the program to use IPv6 sockets and then enables the RES USE INET6 resolver option before calling gethostbyname().
This application will then work with either IPv4 or IPv6 peers.
Note that gethostbyname() and gethostbyname2() are not thread safe, since both return a pointer to a static hostent structure.
But several vendors have defined a thread safe gethostbyname r() function that requires four additional arguments.
We expect these vendors to also define a gethostbyname2 r() function.
The existing gethostbyaddr() function already requires an address family argument and can therefore work with IPv6 addresses:
> struct hostent  gethostbyaddr(const char  src, int len, int af); One possible source of confusion is the handling of IPv4 mapped IPv6 addresses and IPv4 compatible IPv6 addresses.
This is addressed in [6] and involves the following logic: 1.
If af is AF INET6, and if len equals 16, and if the IPv6 address is an IPv4 mapped IPv6 address or an IPv4 compatible IPv6 address, then skip over the first 12 bytes of the IPv6 address, set af to AF INET, and set len to 4. 2.
If af is AF INET, then query for a PTR record in the in  addr.arpa domain.
If af is AF INET6, then query for a PTR record in the ip6.int domain.
If the function is returning success, and if af equals AF INET, and if the RES USE INET6 option was set, then the single address that is returned in the hostent structure (a copy of the first argument to the function) is returned as an IPv4 mapped IPv6 address and the h length member is set to 16.
All four steps listed are performed, in order.
The same caveats regarding a thread safe version of gethostbyname() that were made at the end of the previous section apply here as well.
Protocol Independent Hostname and Service Name Translation Hostname to address translation is done in a protocol independent fashion using the getaddrinfo() function that is taken from the Institute of Electrical and Electronic Engineers (IEEE)
(Protocol Independent Interfaces) work in progress specification [4].
The official specification for this function will be the final POSIX standard.
We are providing this independent description of the function because POSIX standards are not freely available (as are IETF documents).
Should there be any discrepancies between this description and the POSIX description, the POSIX description takes precedence.
int getaddrinfo(const char  hostname, const char
servname, const struct addrinfo  hints, struct addrinfo   res); The addrinfo structure is defined as: #include <sys/socket.h
The following names are the nonzero error codes from getaddrinfo(), and are defined in <netdb.h
servname not supported for ai socktype EAI SOCKTYPE
The hostname and servname arguments are pointers to null terminated strings or NULL.
One or both of these two arguments must be a non  NULL pointer.
In the normal client scenario, both the hostname and servname are specified.
In the normal server scenario, only the servname is specified.
A non NULL hostname string can be either a host name or a numeric host address string (i.e., a dotted decimal IPv4 address or an IPv6 hex address).
A non NULL servname string can be either a service name or a decimal port number.
The caller can optionally pass an addrinfo structure, pointed to by the third argument, to provide hints concerning the type of socket that the caller supports.
In this hints structure all members other than ai flags, ai family, ai socktype, and ai protocol must be zero or a NULL pointer.
A value of PF UNSPEC for ai family means the caller will accept any protocol family.
A value of 0 for ai socktype means the caller will accept any socket type.
A value of 0 for ai protocol means the caller will accept any protocol.
For example, if the caller handles only TCP and not UDP, then the ai socktype member of the hints structure should be set to SOCK STREAM when getaddrinfo() is called.
If the caller handles only IPv4 and not IPv6, then the ai family member of the hints structure should be set to PF INET when getaddrinfo() is called.
If the third argument to getaddrinfo() is a NULL pointer, this is the same as if the caller had filled in an addrinfo structure initialized to zero with ai family set to PF UNSPEC.
Upon successful return a pointer to a linked list of one or more addrinfo structures is returned through the final argument.
The caller can process each addrinfo structure in this list by following the ai next pointer, until a NULL pointer is encountered.
In each returned addrinfo structure
the three members ai family, ai socktype, and ai protocol
are the corresponding arguments for a call to the socket() function.
In each addrinfo structure the ai addr member points to a filled in socket address structure whose length is specified by the ai addrlen member.
If the AI PASSIVE bit is set in the ai flags member of the hints structure, then the caller plans to use the returned socket address structure in a call to bind().
In this case, if the hostname argument is a NULL pointer, then the IP address portion of the socket address structure will be set to INADDR ANY for an IPv4 address or
ANY INIT for an IPv6 address.
If the AI PASSIVE bit is not set in the ai flags member of the hints structure, then the returned socket address structure will be ready for a call to connect() (for a connection oriented protocol) or either connect(), sendto(), or sendmsg() (for a connectionless protocol).
In this case, if the hostname argument is a NULL pointer, then the IP address portion of the socket address structure will be set to the loopback address.
If the AI CANONNAME bit is set in the ai flags member of the hints structure, then upon successful return the ai canonname member of the first addrinfo structure in the linked list will point to a null  terminated string containing the canonical name of the specified hostname.
All of the information returned by getaddrinfo() is dynamically allocated: the addrinfo structures, and the socket address structures and canonical host name strings pointed to by the addrinfo structures.
To return this information to the system the function freeaddrinfo() is called: #include <sys/socket.h
> void freeaddrinfo(struct addrinfo  ai)
; The addrinfo structure pointed to by the ai argument is freed, along with any dynamic storage pointed to by the structure.
This operation is repeated until a NULL ai next pointer is encountered.
To aid applications in printing error messages based on the EAI xxx codes returned by getaddrinfo(), the following function is defined.
> #include <netdb.h> char  gai strerror(int ecode); The argument is one of the EAI xxx values defined earlier and the eturn value points to a string describing the error.
If the argument is not one of the EAI xxx values, the function still returns a pointer to a string whose contents indicate an unknown error.
Socket Address Structure to Hostname and Service Name
Therefore, we define the following function:
struct sockaddr  sa, size t salen, char  host, size t hostlen, char  serv, size t servlen, int flags); This function looks up an IP address and port number provided by the caller in the DNS and system specific database, and returns text strings for both in buffers provided by the caller.
The function indicates successful completion by a zero return value; a non zero return value indicates failure.
The first argument, sa, points to either a sockaddr in structure (for IPv4) or a sockaddr in6 structure (for IPv6) that holds the IP address and port number.
The salen argument gives the length of the sockaddr in or sockaddr in6 structure.
The function returns the hostname associated with the IP address in the buffer pointed to by the host argument.
The caller provides the size of this buffer via the hostlen argument.
The service name associated with the port number is returned in the buffer pointed to by serv, and the servlen argument gives the length of this buffer.
The caller specifies not to return either string by providing a zero value for the hostlen or servlen arguments.
Otherwise, the caller must provide buffers large enough to hold the hostname and the service name, including the terminating null characters.
Unfortunately most systems do not provide constants that specify the maximum size of either a fully qualified domain name or a service name.
Therefore to aid the application in allocating buffers for these two returned strings the following constants are defined in <netdb.h
The first value is actually defined as the constant MAXDNAME in recent versions of BIND's <arpa/nameser.h> header (older versions of BIND define this constant to be 256) and the second is a guess based on the services listed in the current Assigned Numbers RFC.
The final argument is a flag that changes the default actions of this function.
By default the fully qualified domain name (FQDN) for the host is looked up in the DNS and returned.
If the flag bit NI NOFQDN is set, only the hostname portion of the FQDN is returned for local hosts.
If the flag bit NI NUMERICHOST is set, or if the host's name cannot be located in the DNS, the numeric form of the host's address is returned instead of its name (e.g., by calling inet ntop() instead of gethostbyaddr()).
If the flag bit NI NAMEREQD is set, an error is returned if the host's name cannot be located in the DNS.
If the flag bit NI NUMERICSERV is set, the numeric form of the service address is returned (e.g., its port number) instead of its name.
The two NI NUMERICxxx flags are required to support the " n" flag that many commands provide.
A fifth flag bit, NI DGRAM, specifies that the service is a datagram service, and causes getservbyport() to be called with a second argument of "udp" instead of its default of "tcp".
This is required for the few ports (512 514) that have different services for UDP and TCP.
These NI xxx flags are defined in <netdb.h> along with the AI xxx flags already defined for getaddrinfo().
The two functions inet addr() and inet ntoa() convert an IPv4 address between binary and text form.
IPv6 applications need similar functions.
The following two functions convert both IPv6 and IPv4 addresses:
src, char  dst, size t size);
The inet pton() function converts an address in its standard text presentation form into its numeric binary form.
The af argument specifies the family of the address.
Currently the AF INET and AF INET6 address families are supported.
The src argument points to the string being passed in.
The dst argument points to a buffer into which the function stores the numeric address.
The address is returned in network byte order.
Inet pton() returns 1 if the conversion succeeds, 0 if the input is not a valid IPv4 dotted  decimal string or a valid IPv6 address string, or  1 with errno set to EAFNOSUPPORT if the af argument is unknown.
The calling application must ensure that the buffer referred to by dst is large enough to hold the numeric address (e.g., 4 bytes for AF INET or 16 bytes for AF INET6).
If the af argument is AF INET, the function accepts a string in the standard IPv4 dotted decimal form: ddd.ddd.ddd.ddd where ddd is a one to three digit decimal number between 0 and 255.
Note that many implementations of the existing inet addr() and inet aton() functions accept nonstandard input:  octal numbers, hexadecimal numbers, and fewer than four numbers.
inet pton() does not accept these formats.
If the af argument is AF INET6, then the function accepts a string in one of the standard IPv6 text forms defined in Section 2.2 of the addressing architecture specification [2].
The inet ntop() function converts a numeric address into a text string suitable for presentation.
The af argument specifies the family of the address.
This can be AF INET or AF INET6.
The src argument points to a buffer holding an IPv4 address if the af argument is AF INET, or an IPv6 address if the af argument is AF INET6.
The dst argument points to a buffer where the function will store the resulting text string.
The size argument specifies the size of this buffer.
The application must specify a non NULL dst argument.
For IPv6 addresses, the buffer must be at least 46 octets.
For IPv4 addresses, the buffer must be at least 16 octets.
In order to allow applications to easily declare buffers of the proper size to store IPv4 and IPv6 addresses in string form, the following two constants are defined in <netinet/in.h>:
The inet ntop() function returns a pointer to the buffer containing the text string if the conversion succeeds, and NULL otherwise.
Upon failure, errno is set to EAFNOSUPPORT if the af argument is invalid or ENOSPC if the size of the result buffer is inadequate.
The following macros can be used to test for special IPv6 addresses.
The last five test the scope of a multicast address and return true if the address is a multicast address of the specified scope or false if the address is either not a multicast address or not of the specified scope.
The following list summarizes the constants, structure, and extern definitions discussed in this memo, sorted by header.
INIT <netinet/in.h>  IN6ADDR LOOPBACK INIT <netinet/in.h
IPV6 MULTICAST HOPS <netinet/in.h>  IPV6 MULTICAST IF <netinet/in.h>
extern const struct in6 addr in6addr
extern const struct in6 addr in6addr
The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
int IN6 IS ADDR LOOPBACK(const
int IN6 IS ADDR MC
int IN6 IS ADDR MC SITELOCAL(const
int IN6 IS ADDR UNSPECIFIED(const
int IN6 IS ADDR V4COMPAT(const struct
Security Considerations IPv6 provides a number of new security mechanisms, many of which need to be accessible to applications.
A companion memo detailing the extensions to the socket interfaces to support IPv6 security
