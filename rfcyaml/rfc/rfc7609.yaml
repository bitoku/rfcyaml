- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                            M. Fox
  contents:
  - "Independent Submission                                            M. Fox\n  \
    \   IBM's Shared Memory Communications over RDMA (SMC-R) Protocol\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes IBM's Shared Memory Communications over\
    \ RDMA\n   (SMC-R) protocol.  This protocol provides Remote Direct Memory Access\n\
    \   (RDMA) communications to TCP endpoints in a manner that is\n   transparent\
    \ to socket applications.  It further provides for dynamic\n   discovery of partner\
    \ RDMA capabilities and dynamic setup of RDMA\n   connections, as well as transparent\
    \ high availability and load\n   balancing when redundant RDMA network paths are\
    \ available.  It\n   maintains many of the traditional TCP/IP qualities of service\
    \ such as\n   filtering that enterprise users demand, as well as TCP socket\n\
    \   semantics such as urgent data.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7609.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. Protocol Overview ..........................................6\n  \
    \         1.1.1. Hardware Requirements ...............................8\n    \
    \  1.2. Definition of Common Terms .................................8\n      1.3.\
    \ Conventions Used in This Document .........................11\n   2. Link Architecture\
    \ ..............................................11\n      2.1. Remote Memory Buffers\
    \ (RMBs) ..............................12\n      2.2. SMC-R Link Groups .........................................18\n\
    \           2.2.1. Link Group Types ...................................18\n  \
    \         2.2.2. Maximum Number of Links in Link Group ..............21\n    \
    \       2.2.3. Forming and Managing Link Groups ...................23\n      \
    \     2.2.4. SMC-R Link Identifiers .............................24\n      2.3.\
    \ SMC-R Resilience and Load Balancing .......................24\n   3. SMC-R Rendezvous\
    \ Architecture ..................................26\n      3.1. TCP Options ...............................................26\n\
    \      3.2. Connection Layer Control (CLC) Messages ...................27\n  \
    \    3.3. LLC Messages ..............................................27\n    \
    \  3.4. CDC Messages ..............................................29\n      3.5.\
    \ Rendezvous Flows ..........................................29\n           3.5.1.\
    \ First Contact ......................................29\n                  3.5.1.1.\
    \ Pre-negotiation of TCP Options ............29\n                  3.5.1.2. Client\
    \ Proposal ...........................30\n                  3.5.1.3. Server Acceptance\
    \ .........................32\n                  3.5.1.4. Client Confirmation\
    \ .......................32\n                  3.5.1.5. Link (QP) Confirmation\
    \ ....................32\n                  3.5.1.6. Second SMC-R Link Setup ...................35\n\
    \                           3.5.1.6.1. Client Processing of ADD LINK\n       \
    \                               LLC Message from Server ........35\n         \
    \                  3.5.1.6.2. Server Processing of ADD LINK\n                \
    \                      Reply LLC Message from Client ..36\n                  \
    \         3.5.1.6.3. Exchange of RKeys on\n                                  \
    \    Second SMC-R Link ..............38\n                           3.5.1.6.4.\
    \ Aborting SMC-R and\n                                      Falling Back to IP\
    \ .............38\n           3.5.2. Subsequent Contact .................................38\n\
    \                  3.5.2.1. SMC-R Proposal ............................39\n  \
    \                3.5.2.2. SMC-R Acceptance ..........................40\n    \
    \              3.5.2.3. SMC-R Confirmation ........................41\n      \
    \            3.5.2.4. TCP Data Flow Race with SMC\n                          \
    \ Confirm CLC Message .......................41\n           3.5.3. First Contact\
    \ Variation: Creating a\n                  Parallel Link Group ................................42\n\
    \           3.5.4. Normal SMC-R Link Termination ......................43\n  \
    \         3.5.5. Link Group Management Flows ........................44\n    \
    \              3.5.5.1. Adding and Deleting Links in an\n                    \
    \       SMC-R Link Group ..........................44\n                      \
    \     3.5.5.1.1. Server-Initiated ADD\n                                      LINK\
    \ Processing ................45\n                           3.5.5.1.2. Client-Initiated\
    \ ADD\n                                      LINK Processing ................45\n\
    \                           3.5.5.1.3. Server-Initiated DELETE\n             \
    \                         LINK Processing ................46\n               \
    \            3.5.5.1.4. Client-Initiated DELETE\n                            \
    \          LINK Request ...................48\n                  3.5.5.2. Managing\
    \ Multiple RKeys over\n                           Multiple SMC-R Links in a Link\
    \ Group ......49\n                           3.5.5.2.1. Adding a New RMB to an\n\
    \                                      SMC-R Link Group ...............50\n  \
    \                         3.5.5.2.2. Deleting an RMB from an\n               \
    \                       SMC-R Link Group ...............53\n                 \
    \          3.5.5.2.3. Adding a New SMC-R Link to a\n                         \
    \             Link Group with Multiple RMBs ..54\n                  3.5.5.3. Serialization\
    \ of LLC Exchanges,\n                           and Collisions ............................56\n\
    \                           3.5.5.3.1. Collisions with ADD\n                 \
    \                     LINK / CONFIRM LINK Exchange ...57\n                   \
    \        3.5.5.3.2. Collisions during\n                                      DELETE\
    \ LINK Exchange ...........58\n                           3.5.5.3.3. Collisions\
    \ during\n                                      CONFIRM RKEY Exchange ..........59\n\
    \   4. SMC-R Memory-Sharing Architecture ..............................60\n  \
    \    4.1. RMB Element Allocation Considerations .....................60\n    \
    \  4.2. RMB and RMBE Format .......................................60\n      4.3.\
    \ RMBE Control Information ..................................60\n      4.4. Use\
    \ of RMBEs ..............................................61\n           4.4.1.\
    \ Initializing and Accessing RMBEs ...................61\n           4.4.2. RMB\
    \ Element Reuse and Conflict Resolution ..........62\n      4.5. SMC-R Protocol\
    \ Considerations .............................63\n           4.5.1. SMC-R Protocol\
    \ Optimized Window Size Updates .......63\n           4.5.2. Small Data Sends\
    \ ...................................64\n           4.5.3. TCP Keepalive Processing\
    \ ...........................65\n      4.6. TCP Connection Failover between SMC-R\
    \ Links ...............67\n           4.6.1. Validating Data Integrity ..........................67\n\
    \           4.6.2. Resuming the TCP Connection on a New SMC-R Link ....68\n  \
    \    4.7. RMB Data Flows ............................................69\n    \
    \       4.7.1. Scenario 1: Send Flow, Window Size Unconstrained ...69\n      \
    \     4.7.2. Scenario 2: Send/Receive Flow, Window Size\n                  Unconstrained\
    \ ......................................71\n           4.7.3. Scenario 3: Send\
    \ Flow, Window Size Constrained .....72\n           4.7.4. Scenario 4: Large Send,\
    \ Flow Control, Full\n                  Window Size Writes .................................74\n\
    \           4.7.5. Scenario 5: Send Flow, Urgent Data, Window\n              \
    \    Size Unconstrained .................................77\n           4.7.6.\
    \ Scenario 6: Send Flow, Urgent Data, Window\n                  Size Closed ........................................79\n\
    \      4.8. Connection Termination ....................................81\n  \
    \         4.8.1. Normal SMC-R Connection Termination Flows ..........81\n    \
    \       4.8.2. Abnormal SMC-R Connection Termination Flows ........86\n      \
    \     4.8.3. Other SMC-R Connection Termination Conditions ......88\n   5. Security\
    \ Considerations ........................................89\n      5.1. VLAN Considerations\
    \ .......................................89\n      5.2. Firewall Considerations\
    \ ...................................89\n      5.3. Host-Based IP Filters .....................................89\n\
    \      5.4. Intrusion Detection Services ..............................90\n  \
    \    5.5. IP Security (IPsec) .......................................90\n    \
    \  5.6. TLS/SSL ...................................................90\n   6. IANA\
    \ Considerations ............................................90\n   7. Normative\
    \ References ...........................................91\n   Appendix A. Formats\
    \ ...............................................92\n     A.1. TCP Option .................................................92\n\
    \     A.2. CLC Messages ...............................................92\n  \
    \        A.2.1. Peer ID Format ......................................93\n    \
    \      A.2.2. SMC Proposal CLC Message Format .....................94\n      \
    \    A.2.3. SMC Accept CLC Message Format .......................98\n        \
    \  A.2.4. SMC Confirm CLC Message Format .....................102\n          A.2.5.\
    \ SMC Decline CLC Message Format .....................105\n     A.3. LLC Messages\
    \ ..............................................106\n          A.3.1. CONFIRM\
    \ LINK LLC Message Format ....................107\n          A.3.2. ADD LINK LLC\
    \ Message Format ........................109\n          A.3.3. ADD LINK CONTINUATION\
    \ LLC Message Format ...........112\n          A.3.4. DELETE LINK LLC Message\
    \ Format .....................115\n          A.3.5. CONFIRM RKEY LLC Message Format\
    \ ....................117\n          A.3.6. CONFIRM RKEY CONTINUATION LLC Message\
    \ Format .......120\n          A.3.7. DELETE RKEY LLC Message Format .....................122\n\
    \          A.3.8. TEST LINK LLC Message Format .......................124\n  \
    \   A.4. Connection Data Control (CDC) Message Format ..............125\n   Appendix\
    \ B. Socket API Considerations ............................129\n     B.1. setsockopt()\
    \ / getsockopt() Considerations ................130\n   Appendix C. Rendezvous\
    \ Error Scenarios ...........................131\n     C.1. SMC Decline during\
    \ CLC Negotiation ........................131\n     C.2. SMC Decline during LLC\
    \ Negotiation ........................131\n     C.3. The SMC Decline Window ....................................133\n\
    \     C.4. Out-of-Sync Conditions during SMC-R Negotiation ...........133\n  \
    \   C.5. Timeouts during CLC Negotiation ...........................134\n    \
    \ C.6. Protocol Errors during CLC Negotiation ....................134\n     C.7.\
    \ Timeouts during LLC Negotiation ...........................135\n          C.7.1.\
    \ Recovery Actions for LLC Timeouts and Failures .....136\n     C.8. Failure to\
    \ Add Second SMC-R Link to a Link Group ..........142\n   Authors' Addresses ...............................................143\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies IBM's Shared Memory Communications\
    \ over RDMA\n   (SMC-R) protocol.  SMC-R is a protocol for Remote Direct Memory\n\
    \   Access (RDMA) communication between TCP socket endpoints.  SMC-R runs\n  \
    \ over networks that support RDMA over Converged Ethernet (RoCE).  It\n   is designed\
    \ to permit existing TCP applications to benefit from RDMA\n   without requiring\
    \ modifications to the applications or predefinition\n   of RDMA partners.\n \
    \  SMC-R provides dynamic discovery of the RDMA capabilities of TCP\n   peers\
    \ and automatic setup of RDMA connections that those peers can\n   use.  SMC-R\
    \ also provides transparent high availability and\n   load-balancing capabilities\
    \ that are demanded by enterprise\n   installations but are missing from current\
    \ RDMA protocols.  If\n   redundant RoCE-capable hardware such as RDMA-capable\
    \ Network\n   Interface Cards (RNICs) and RoCE-capable switches is present, SMC-R\n\
    \   can load-balance over that redundant hardware and can also\n   non-disruptively\
    \ move TCP traffic from failed paths to surviving\n   paths, all seamlessly to\
    \ the application and the sockets layer.\n   Because SMC-R preserves socket semantics\
    \ and the TCP three-way\n   handshake, many TCP qualities of service such as filtering,\
    \ load\n   balancing, and Secure Socket Layer (SSL) encryption are preserved,\
    \ as\n   are TCP features such as urgent data.\n   Because of the dynamic discovery\
    \ and setup of SMC-R connectivity\n   between peers, no RDMA connection manager\
    \ (RDMA-CM) is required.\n   This also means that support for Unreliable Datagram\
    \ (UD) Queue Pairs\n   (QPs) is also not required.\n   It is recommended that\
    \ the SMC-R services be implemented in kernel\n   space, which enables optimizations\
    \ such as resource-sharing between\n   connections across multiple processes and\
    \ also permits applications\n   using SMC-R to spawn multiple processes (e.g.,\
    \ fork) without losing\n   SMC-R functionality.  A user-space implementation is\
    \ compatible with\n   this architecture, but it may not support spawned processes\
    \ (e.g.,\n   fork), which limits sharing and resource optimization to TCP\n  \
    \ connections that originate from the same process.  This might be an\n   appropriate\
    \ design choice if the use case is a system that hosts a\n   large single process\
    \ application that creates many TCP connections to\n   a peer host, or in implementations\
    \ where a kernel-space\n   implementation is not possible or introduces excessive\
    \ overhead for\n   \"kernel space to user space\" context switches.\n"
- title: 1.1.  Protocol Overview
  contents:
  - "1.1.  Protocol Overview\n   SMC-R defines the concept of the SMC-R link, which\
    \ is a logical\n   point-to-point link using reliably connected queue pairs between\n\
    \   TCP/IP stack peers over a RoCE fabric.  An SMC-R link is bound to a\n   specific\
    \ hardware path, meaning a specific RNIC on each peer.  SMC-R\n   links are created\
    \ and maintained by an SMC-R layer, which may reside\n   in kernel space or user\
    \ space, depending upon operating system and\n   implementation requirements.\
    \  The SMC-R layer resides below the\n   sockets layer and directs data traffic\
    \ for TCP connections between\n   connected peers over the RoCE fabric using RDMA\
    \ rather than over a\n   TCP connection.  The TCP/IP stack, with its requirements\
    \ for\n   fragmentation, packetization, etc., is bypassed, and the application\n\
    \   data is moved between peers using RDMA.\n   Multiple SMC-R links between the\
    \ same two TCP/IP stack peers are also\n   supported.  A set of SMC-R links called\
    \ a link group can be logically\n   bonded together to provide redundant connectivity.\
    \  If there is\n   redundant hardware -- for example, two RNICs on each peer --\
    \ separate\n   SMC-R links are created between the peers to exploit that redundant\n\
    \   hardware.  The link group architecture with redundant links provides\n   load\
    \ balancing and increased bandwidth, as well as seamless failover.\n   Each SMC-R\
    \ link group is associated with an area of memory called\n   Remote Memory Buffers\
    \ (RMBs), which are areas of memory that are\n   available for SMC-R peers to\
    \ write into using RDMA writes.  Multiple\n   TCP connections between peers may\
    \ be multiplexed over a single SMC-R\n   link, in which case the SMC-R layer manages\
    \ the partitioning of the\n   RMBs between the TCP connections.  This multiplexing\
    \ reduces the RDMA\n   resources, such as QPs and RMBs, that are required to support\n\
    \   multiple connections between peers, and it also reduces the\n   processing\
    \ and delays related to setting up QPs, pinning memory, and\n   other RDMA setup\
    \ tasks when new TCP connections are created.  In a\n   kernel-space SMC-R implementation\
    \ in which the RMBs reside in kernel\n   storage, this sharing and optimization\
    \ works across multiple\n   processes executing on the same host.  In a user-space\
    \ SMC-R\n   implementation in which the RMBs reside in user space, this sharing\n\
    \   and optimization is limited to multiple TCP connections created by a\n   single\
    \ process, as separate RMBs and QPs will be required for each\n   process.\n \
    \  SMC-R also introduces a rendezvous protocol that is used to\n   dynamically\
    \ discover the RDMA capabilities of TCP connection partners\n   and exchange credentials\
    \ necessary to exploit that capability if\n   present.  TCP connections are set\
    \ up using the normal TCP three-way\n   handshake [RFC793], with the addition\
    \ of a new TCP option that\n   indicates SMC-R capability.  If both partners indicate\
    \ SMC-R\n   capability, then at the completion of the three-way TCP handshake\
    \ the\n   SMC-R layers in each peer take control of the TCP connection and use\n\
    \   it to exchange additional Connection Layer Control (CLC) messages to\n   negotiate\
    \ SMC-R credentials such as QP information; addressability\n   over the RoCE fabric;\
    \ RMB buffer sizes; and keys and addresses for\n   accessing RMBs over RDMA. \
    \ If at any time during this negotiation a\n   failure or decline occurs, the\
    \ TCP connection falls back to using the\n   IP fabric.\n   If the SMC-R negotiation\
    \ succeeds and either a new SMC-R link is set\n   up or an existing SMC-R link\
    \ is chosen for the TCP connection, then\n   the SMC-R layers open the sockets\
    \ to the applications and the\n   applications use the sockets as normal.  The\
    \ SMC-R layer intercepts\n   the socket reads and writes and moves the TCP connection\
    \ data over\n   the SMC-R link, \"out of band\" to the TCP connection, which remains\n\
    \   open and idle over the IP fabric, except for termination flows and\n   possible\
    \ keepalive flows.  Regular TCP sequence numbering methods are\n   used for the\
    \ TCP flows that do occur; data flowing over RDMA does not\n   use or affect TCP\
    \ sequence numbers.\n   This architecture does not support fallback of active\
    \ SMC-R\n   connections to IP.  Once connection data has completed the switch\
    \ to\n   RDMA, a TCP connection cannot be switched back to IP and will reset\n\
    \   if RDMA becomes unusable.\n   The SMC-R protocol defines the format of the\
    \ RMBs that are used to\n   receive TCP connection data written over RDMA, as\
    \ well as the\n   semantics for managing and writing to these buffers using Connection\n\
    \   Data Control (CDC) messages.\n   Finally, SMC-R defines Link Layer Control\
    \ (LLC) messages that are\n   exchanged over the RoCE fabric between peer SMC-R\
    \ layers to manage\n   the SMC-R links and link groups.  These include messages\
    \ to test and\n   confirm connectivity over an SMC-R link, add and delete SMC-R\
    \ links\n   to or from the link group, and exchange RMB addressability\n   information.\n"
- title: 1.1.1.  Hardware Requirements
  contents:
  - "1.1.1.  Hardware Requirements\n   SMC-R does not require full Converged Enhanced\
    \ Ethernet switch\n   functionality.  SMC-R functions over standard Ethernet fabrics,\n\
    \   provided that endpoint RNICs are provided and IEEE 802.3x Global\n   Pause\
    \ Frame is supported and enabled in the switch fabric.\n   While SMC-R as specified\
    \ in this document is designed to operate over\n   RoCE fabrics, adjustments to\
    \ the rendezvous methods could enable it\n   to run over other RDMA fabrics, such\
    \ as InfiniBand [RoCE] and iWARP.\n"
- title: 1.2.  Definition of Common Terms
  contents:
  - "1.2.  Definition of Common Terms\n   This section provides definitions of terms\
    \ that have a specific\n   meaning to the SMC-R protocol and are used throughout\
    \ this document.\n   SMC-R Link\n      An SMC-R link is a logical point-to-point\
    \ connection over the RoCE\n      fabric via specific physical adapters (Media\
    \ Access Control /\n      Global Identifier (MAC/GID)).  The link is formed during\
    \ the\n      \"first contact\" sequence of the TCP/IP three-way handshake\n  \
    \    sequence that occurs over the IP fabric.  During this handshake,\n      an\
    \ RDMA reliably connected queue pair (RC-QP) connection is formed\n      between\
    \ the two peer SMC hosts and is defined as the SMC-R link.\n      The SMC-R link\
    \ can then support multiple TCP connections between\n      the two peers.  An\
    \ SMC-R link is associated with a single LAN (or\n      VLAN) segment and is not\
    \ routable.\n   SMC-R Link Group\n      An SMC-R link group is a group of SMC-R\
    \ links between the same two\n      SMC-R peers, typically with each link over\
    \ unique RoCE adapters.\n      Each link in the link group has equal characteristics,\
    \ such as the\n      same VLAN ID (if VLANs are in use), access to the same RMB(s),\
    \ and\n      access to the same TCP server/client.\n   SMC-R Peer\n      The SMC-R\
    \ peer is the peer software stack within the peer\n      operating system with\
    \ respect to the Shared Memory Communications\n      (messaging) protocol.\n \
    \  SMC-R Rendezvous\n      SMC-R Rendezvous is the SMC-R peer discovery and handshake\n\
    \      sequence that occurs transparently over the IP (Ethernet) fabric\n    \
    \  during and immediately after the TCP connection three-way\n      handshake\
    \ by exchanging the SMC-R capabilities and credentials\n      using experimental\
    \ TCP option and CLC messages.\n   RoCE SendMsg\n      RoCE SendMsg is a send\
    \ operation posted to a reliably connected\n      queue pair with inline data,\
    \ for the purpose of transferring\n      control information between peers.\n\
    \   TCP Client\n      The TCP client is the TCP socket-based peer that initiates\
    \ a TCP\n      connection.\n   TCP Server\n      The TCP server is the TCP socket-based\
    \ peer that accepts a TCP\n      connection.\n   CLC Messages\n      The SMC-R\
    \ protocol defines a set of Connection Layer Control\n      messages that flow\
    \ over the TCP connection that are used to manage\n      SMC-R link rendezvous\
    \ at TCP connection setup time.  This\n      mechanism is analogous to SSL setup\
    \ messages.\n   LLC Commands\n      The SMC-R protocol defines a set of RoCE Link\
    \ Layer Control\n      commands that flow over the RoCE fabric using RoCE SendMsg,\
    \ that\n      are used to manage SMC-R links, SMC-R link groups, and SMC-R\n \
    \     link group RMB expansion and contraction.\n   CDC Message\n      The SMC-R\
    \ protocol defines a Connection Data Control message that\n      flows over the\
    \ RoCE fabric using RoCE SendMsg that is used to\n      manage the SMC-R connection\
    \ data.  This message provides\n      information about data being transferred\
    \ over the out-of-band RDMA\n      connection, such as data cursors, sequence\
    \ numbers, and data flags\n      (for example, urgent data).  The receipt of this\
    \ message also\n      provides an interrupt to inform the receiver that it has\
    \ received\n      RDMA data.\n   RMB\n      A Remote (RDMA) Memory Buffer is a\
    \ fixed or pinned buffer\n      allocated in each of the peer hosts for a TCP\
    \ (via SMC-R)\n      connection.  The RMB is registered to the RNIC and allows\
    \ remote\n      access by the remote peer using RDMA semantics.  Each host is\n\
    \      passed the peer's RMB-specific access information (RMB Key (RKey)\n   \
    \   and RMB element offset) during the SMC-R Rendezvous process.  The\n      host\
    \ stores socket application user data directly into the peer's\n      RMB using\
    \ RDMA over RoCE.\n   RToken\n      The RToken is the combination of an RMB's\
    \ RKey and RDMA virtual\n      address.  An RToken provides RMB addressability\
    \ information to an\n      RDMA peer.\n   RMBE\n      The Remote Memory Buffer\
    \ Element (RMBE) is an area of an RMB that\n      is allocated to a specific TCP\
    \ connection.  The RMBE contains data\n      for the TCP connection.  The RMBE\
    \ represents the TCP receive\n      buffer, whereby the remote peer writes into\
    \ the RMBE and the local\n      peer reads from the local RMBE.  The alert token\
    \ resolves to a\n      specific RMBE.\n   Alert Token\n      The SMC-R alert token\
    \ is a 4-byte value that uniquely identifies\n      the TCP connection over an\
    \ SMC-R connection.  The alert token\n      allows the SMC peer to quickly identify\
    \ the target TCP connection\n      that now has new work.  The format of the token\
    \ is defined by the\n      owning SMC-R endpoint and is considered opaque to the\
    \ remote peer.\n      However, the token should not simply be an index to an RMBE;\
    \ it\n      should reference a TCP connection and be able to be validated to\n\
    \      avoid reading data from stale connections.\n   RNIC\n      The RDMA-capable\
    \ Network Interface Card (RNIC) is an Ethernet NIC\n      that supports RDMA semantics\
    \ and verbs using RoCE.\n   First Contact\n      \"First contact\" describes an\
    \ SMC-R negotiation to set up the first\n      link in a link group.\n   Subsequent\
    \ Contact\n      \"Subsequent contact\" describes an SMC-R negotiation between\
    \ peers\n      who are using an already-existing SMC-R link group.\n"
- title: 1.3.  Conventions Used in This Document
  contents:
  - "1.3.  Conventions Used in This Document\n   In the rendezvous flow diagrams,\
    \ dashed lines (----) are used to\n   indicate flows over the TCP/IP fabric and\
    \ dotted lines (....) are\n   used to indicate flows over the RoCE fabric.\n \
    \  In the data transfer ladder diagrams, dashed lines (----) are used to\n   indicate\
    \ RDMA write operations and dotted lines (....) are used to\n   indicate CDC messages,\
    \ which are RDMA messages with inline data that\n   contain control information\
    \ for the connection.\n"
- title: 2.  Link Architecture
  contents:
  - "2.  Link Architecture\n   An SMC-R link is based on reliably connected queue\
    \ pairs (QPs) that\n   form a \"logical point-to-point link\" between the two\
    \ SMC-R peers over\n   a RoCE fabric.  An SMC-R link extends from SMC-R peer to\
    \ SMC-R peer,\n   where typically each peer would be a TCP/IP stack and would\
    \ reside on\n   separate hosts.\n                            ,,.--..,_\n     +----+\
    \             _-``         `-,           +-----+\n     |QP 8|            -   RoCE\
    \         ',         |QP 64|\n     |    |          /     VLAN M         .    \
    \    |     |\n     +----+--------+/                     \\+-------+-----+\n  \
    \    | RNIC 1     |    SMC-R Link         | RNIC 2     |\n      |            |<--------------------->|\
    \            |\n      +------------+ ,                    /+------------+\n  \
    \            MAC A (GID A)             MAC B (GID B)\n                       .\
    \                .`\n                        `',          ,-`\n              \
    \             ``''--''``\n                       Figure 1: SMC-R Link Overview\n\
    \   Figure 1 illustrates an overview of the basic concepts of SMC-R peer-\n  \
    \ to-peer connectivity; this is called the SMC-R link.  The SMC-R link\n   forms\
    \ a logical point-to-point connection between two SMC-R peers via\n   RoCE.  The\
    \ SMC-R link is defined and identified by the following\n   attributes:\n    \
    \  SMC-R link = RC QPs\n         (source VMAC GID QP + target VMAC GID QP + VLAN\
    \ ID)\n   The SMC-R link can optionally be associated with a VLAN ID.  If VLANs\n\
    \   are in use for the associated IP (LAN) connection, then the VLAN\n   attribute\
    \ is carried over on the SMC-R link.  When VLANs are in use,\n   each SMC-R link\
    \ group is associated with a single and specific VLAN.\n   The RoCE fabric is\
    \ the same physical Ethernet LAN used for standard\n   TCP/IP-over-Ethernet communications,\
    \ with switches as described in\n   Section 1.1.1.\n   An SMC-R link is designed\
    \ to support multiple TCP connections between\n   the same two peers.  An SMC-R\
    \ link is intended to be long lived,\n   while the underlying TCP connections\
    \ can dynamically come and go.\n   The associated RMBs can also be dynamically\
    \ added and removed from\n   the link as needed.  The first TCP connection between\
    \ the peers\n   establishes the SMC-R link.  Subsequent TCP connections then use\
    \ the\n   previously established link.  When the last TCP connection\n   terminates,\
    \ the link can then be terminated, typically after an\n   implementation-defined\
    \ idle timeout period has elapsed.  The TCP\n   server is responsible for initiating\
    \ and terminating the SMC-R link.\n"
- title: 2.1.  Remote Memory Buffers (RMBs)
  contents:
  - "2.1.  Remote Memory Buffers (RMBs)\n   Figure 2 shows the hosts -- Hosts X and\
    \ Y -- and their associated\n   RMBs within each host.  With the SMC-R link, and\
    \ the associated RKeys\n   and RDMA virtual addresses, each SMC-R-enabled TCP/IP\
    \ stack can\n   remotely access its peer's RMBs using RDMA.  The RKeys and virtual\n\
    \   addresses are exchanged during the rendezvous processing when the\n   link\
    \ is established.  The combination of the RKey and the virtual\n   address is\
    \ the RToken.  Note that the SMC-R link ends at the QP\n   providing access to\
    \ the RMB (via the link + RToken).\n          Host X                         \
    \            Host Y\n     +-------------------+        ,.--.,_       +-------------------+\n\
    \     |                   |     .'`       '.     |                   |\n     |\
    \ Protection        |   ,'            `,   |    Protection     |\n     | Domain\
    \ X          |  /                \\  |    Domain Y       |\n     |           \
    \ +------+ /                  \\ +------+            |\n     |       QP 8 |RNIC\
    \ 1| |   SMC-R Link     | |RNIC 2|  QP 64     |\n     |        |   |      |<-------------------->|\
    \      |   |        |\n     |        |   |      ||                    ||     \
    \ |   |        |\n     |        |   +------+|    VLAN A          |+------+   |\
    \        |\n     |        |          ||                    ||          |     \
    \   |\n     |        |          | |   RoCE           | |          |        |\n\
    \     |        |RToken X  | \\                  / |RToken Y  |        |\n    \
    \ |        |          |  \\                /  |          |        |\n     |  \
    \      V          |   `.            ,'   |          V        |\n     | +--------+\
    \        |     '._       ,'     |        +--------+ |\n     | |        |     \
    \   |        `''-'``       |        |        | |\n     | | RMB    |        | \
    \                     |        | RMB    | |\n     | |        |        |      \
    \                |        |        | |\n     | +--------+        |           \
    \           |        +--------+ |\n     +-------------------+                \
    \      +-------------------+\n                       Figure 2: SMC-R Link and\
    \ RMBs\n   An SMC-R link can support multiple RMBs that are independently\n  \
    \ managed by each peer.  The number and the size of RMBs are managed by\n   the\
    \ peers based on the host's unique memory management requirements;\n   however,\
    \ the maximum number of RMBs that can be associated to a link\n   group on one\
    \ peer is 255.  The QP has a single protection domain, but\n   each RMB has a\
    \ unique RToken.  All RTokens must be exchanged with the\n   peer.\n   Each peer\
    \ manages the RMBs in its local memory for its remote SMC-R\n   peer by sharing\
    \ access to the RMBs via RTokens with its peers.  The\n   remote peer writes into\
    \ the RMBs via RDMA, and the local peer (RMB\n   owner) then reads from the RMBs.\n\
    \   When two peers decide to use SMC-R for a given TCP connection, they\n   each\
    \ allocate a local RMB element for the TCP connection and\n   communicate the\
    \ location of this local RMB element during rendezvous\n   processing.  To that\
    \ end, RMB elements are created in pairs, with one\n   RMB element allocated locally\
    \ on each peer of the SMC-R link.\n                  ---  +------------+---------------+\n\
    \                  /\\   |Eye Catcher |               |\n                   |\
    \   +------------+               |\n                   |   |                 \
    \           |\n         RMB Element 1 |                            |\n       \
    \            |   |   Receive Buffer           |\n                   |   |    \
    \                        |\n                   |   |                         \
    \   |\n                  \\/   |                            |\n              \
    \    ---  +------------+---------------+\n                  /\\   |Eye Catcher\
    \ |               |\n                   |   +------------+               |\n \
    \                  |   |                            |\n         RMB Element 2\
    \ |                            |\n                   |   |   Receive Buffer  \
    \         |\n                   |   |                            |\n         \
    \          |   |                            |\n                  \\/   |     \
    \                       |\n                  ---  +----------------------------+\n\
    \                       |            .               |\n                     \
    \  |            .               |\n                       |            .     \
    \          |\n                       |            .               |\n        \
    \               |    (up to 255 elements)    |\n                       +----------------------------+\n\
    \                           Figure 3: RMB Format\n   Figure 3 illustrates the\
    \ basic format of an RMB.  The RMB is a\n   virtual memory buffer whose backing\
    \ real memory is pinned, which can\n   support up to 255 TCP connections to exactly\
    \ one remote SMC-R peer.\n   Each RMB is therefore associated with the SMC-R links\
    \ within a link\n   group for the two peers and a specific RoCE Protection Domain.\
    \  Other\n   than the two peers identified by the SMC-R link, no other SMC-R peers\n\
    \   can have RDMA access to an RMB; this requires a unique Protection\n   Domain\
    \ for every SMC-R link.  This is critical to ensure integrity of\n   SMC-R communications.\n\
    \   RMBs are subdivided into multiple elements for efficiency, with each\n   RMB\
    \ Element (RMBE) associated with a single TCP connection.\n   Therefore, multiple\
    \ TCP connections across an SMC-R link group can\n   share the same memory for\
    \ RDMA purposes, reducing the overhead of\n   having to register additional memory\
    \ with the RNIC for every new TCP\n   connection.  The number of elements in an\
    \ RMB and the size of each\n   RMBE are entirely governed by the owning peer,\
    \ subject to the SMC-R\n   architecture rules; however, all RMB elements within\
    \ a given RMB must\n   be the same size.  Each peer can decide the level of resource-sharing\n\
    \   that is desirable across TCP connections based on local constraints,\n   such\
    \ as available system memory.  An RMB element is identified to the\n   remote\
    \ SMC-R peer via an RMB Element Token, which consists of the\n   following:\n\
    \   o  RMB RToken: The combination of the RKey and virtual address\n      provided\
    \ by the RNIC that identifies the start of the RMB for RDMA\n      operations.\n\
    \   o  RMB Index: Identifies the RMB element index in the RMB.  Used to\n    \
    \  locate a specific RMB element within an RMB.  Valid value range is\n      1-255.\n\
    \   o  RMB Element Length: The length of the RMB element's eye catcher\n     \
    \ plus the length of the receive buffer.  This length is equal for\n      all\
    \ RMB elements in a given RMB.  This length can be variable\n      across different\
    \ RMBs.\n   Multiple RMBs can be associated to an SMC-R link group, and each peer\n\
    \   in an SMC-R link group manages allocation of its RMBs.  RMB\n   allocation\
    \ can be asymmetric.  For example, Server X can allocate two\n   RMBs to an SMC-R\
    \ link group while Server Y allocates five.  This\n   provides maximum implementation\
    \ flexibility to allow hosts to\n   optimize RMB management for their own local\
    \ requirements.  The\n   maximum number of RMBs that can be allocated on one peer\
    \ to a link\n   group is 255.  If more RMBs are required, the peer may fall back\
    \ to\n   IP for subsequent connections or, if the peer is the server, create a\n\
    \   parallel link group.\n   One use case for multiple RMBs is multiple receive\
    \ buffer sizes.\n   Since every element in an RMB must be the same size, multiple\
    \ RMBs\n   with different element sizes can be allocated if varying receive\n\
    \   buffer sizes are required.\n   Also, since the maximum number of TCP connections\
    \ whose receive\n   buffers can be allocated to an RMB is 255, multiple RMBs may\
    \ be\n   required to provide capacity for large numbers of TCP connections\n \
    \  between two peers.\n   Separately from the RMB, the TCP/IP stack that owns\
    \ each RMB\n   maintains control data for each RMB element within its local control\n\
    \   structures.  The control data contains flags for maintaining the\n   state\
    \ of the TCP data (for example, urgent data indicator) and, most\n   importantly,\
    \ the following two cursors, which are illustrated below\n   in Figure 4:\n  \
    \ o  The peer producer cursor: This is a wrapping offset into the\n      RMB element's\
    \ receive buffer that points to the next byte of data\n      to be written by\
    \ the remote peer.  This cursor is provided by the\n      remote peer in a Connection\
    \ Data Control (CDC) message, which is\n      sent using RoCE SendMsg processing,\
    \ and tells the local peer how\n      far it can consume data in the RMBE buffer.\n\
    \   o  The peer consumer cursor: This is a wrapping offset into the\n      remote\
    \ peer's RMB element's receive buffer that points to the next\n      byte of data\
    \ to be consumed by the remote peer in its own RMBE.\n      The local peer cannot\
    \ write into the remote peer's RMBE beyond\n      this point without causing data\
    \ loss.  This cursor is also\n      provided by the peer using a Connection Data\
    \ Control message.\n   Each TCP connection peer maintains its cursors for a TCP\
    \ connection's\n   RMBE in its local control structures.  In other words, the\
    \ peer who\n   writes into a remote peer's RMBE provides its producer cursor to\
    \ the\n   peer whose RMBE it has written into.  The peer who reads from its\n\
    \   RMBE provides its consumer cursor to the writing peer.  In this\n   manner,\
    \ the reads and writes between peers are kept coordinated.\n   For example, referring\
    \ to Figure 4, Peer B writes the hashed data\n   into the receive buffer of Peer\
    \ A's RMBE.  After that write\n   completes, Peer B uses a CDC message to update\
    \ its producer cursor to\n   Peer A, to indicate to Peer A how much data is available\
    \ for Peer A\n   to consume.  The CDC message that Peer B sends to Peer A wakes\
    \ up\n   Peer A and notifies it that there is data to be consumed.\n   Similarly,\
    \ when Peer A consumes data written by Peer B, it uses a CDC\n   message to update\
    \ its consumer cursor to Peer B to let Peer B know\n   how much data it has consumed,\
    \ so Peer B knows how much space is\n   available for further writes.  If Peer\
    \ B were to write enough data to\n   Peer A that it would wrap the RMBE receive\
    \ buffer and exceed the\n   consumer cursor, data loss would result.\n   Note\
    \ that this is a simplistic description of the control flows, and\n   they are\
    \ optimized to minimize the number of CDC messages required,\n   as described\
    \ in Section 4.7 (\"RMB Data Flows\").\n      Peer A's RMBE Control Info     \
    \       Peer B's RMBE Control Info\n     +--------------------------+        \
    \  +--------------------------+\n     |                          |          |\
    \                          |\n      /----Peer producer cursor |    +-----+-Peer\
    \ consumer cursor     |\n    /|                          |    |     |        \
    \                  |\n   | +--------------------------+    |     +--------------------------+\n\
    \   |  Peer A's RMBE                  |\n   | +--------------------------+   \
    \ |\n   | |            +------------------+\n   | |            |             |\n\
    \   | |            \\/            |\n   | |             +------------|\n   | |-------------+///////////\
    \ |\n   | |//RDMA data written by ///|\n   | |/// Peer B that is ////// |\n  \
    \ | |/available to be consumed/|\n   | |///////////////////////// |\n   | |/////////\
    \ +---------------|\n   | |----------+/\\             |\n   | |            | \
    \            |\n    \\|            |             |\n     \\           /      \
    \        |\n     |\\---------/               |\n     |                       \
    \   |\n     |                          |\n                          Figure 4:\
    \ RMBE Cursors\n   Additional flags and indicators are communicated between peers.\
    \  In\n   all cases, these flags and indicators are updated by the peer using\n\
    \   CDC messages, which are sent using RoCE SendMsg.  More details on\n   these\
    \ additional flags and indicators are described in Section 4.3\n   (\"RMBE Control\
    \ Information\").\n"
- title: 2.2.  SMC-R Link Groups
  contents:
  - "2.2.  SMC-R Link Groups\n   SMC-R links are logically grouped together to form\
    \ an SMC-R link\n   group.  The purpose of the link group is for supporting multiple\n\
    \   links between the same two peers to provide for:\n   o  Resilience: Provides\
    \ transparent and dynamic switching of the link\n      used by existing TCP connections\
    \ during link failures, typically\n      hardware related.  TCP traffic using\
    \ the failing link can be\n      switched to an active link within the link group,\
    \ thereby avoiding\n      disruptions to application workloads.\n   o  Link utilization:\
    \ Provides an active/active link usage model\n      allowing TCP traffic to be\
    \ balanced across the links, which\n      increases bandwidth and also avoids\
    \ hardware imbalances and\n      bottlenecks.  Note that both adapter and switch\
    \ utilization can\n      become potential resource constraint issues.\n   SMC-R\
    \ link group support is required.  Resilience is not optional.\n   However, the\
    \ user can elect to provision a single RNIC (on one or\n   both hosts).\n   Multiple\
    \ links that are formed between the same two peers fall into\n   two distinct\
    \ categories:\n   1. Equal Links: Links providing equal access to the same RMB(s)\
    \ at\n      both endpoints, whereby all TCP connections associated with the\n\
    \      links must have the same VLAN ID and have the same TCP server and\n   \
    \   TCP client roles or relationship.\n   2. Unequal Links: Links providing access\
    \ to unique, unrelated and\n      isolated RMB(s) (i.e., for unique VLANs or unique\
    \ and isolated\n      application workloads, etc.) or having unique TCP server\
    \ or client\n      roles.\n   Links that are logically grouped together forming\
    \ an SMC-R link group\n   must be equal links.\n"
- title: 2.2.1.  Link Group Types
  contents:
  - "2.2.1.  Link Group Types\n   Equal links within a link group also have another\
    \ \"Link Group Type\"\n   attribute based on the link's associated underlying\
    \ physical path.\n   The following SMC-R link types are defined:\n   1. Single\
    \ link: the only active link within a link group\n   2. Parallel link: not allowed\
    \ -- SMC-R links having the same physical\n      RNIC at both hosts\n   3. Asymmetric\
    \ link: links that have unique RNIC adapters at one host\n      but share a single\
    \ adapter at the peer host\n   4. Symmetric link: links that have unique RNIC\
    \ adapters at both hosts\n   These link group types are further explained in the\
    \ following figures\n   and descriptions.\n   Figure 2 above shows the single-link\
    \ case.  The single link\n   illustrated in Figure 2 also establishes the SMC-R\
    \ link group.  Link\n   groups are supposed to have multiple links, but when only\
    \ one RNIC is\n   available at both hosts then only a single link can be created.\
    \  This\n   is expected to be a transient case.\n   Figure 5 shows the symmetric-link\
    \ case.  Both hosts have unique and\n   redundant RNIC adapters.  This configuration\
    \ meets the objectives for\n   providing full RoCE redundancy required to provide\
    \ the level of\n   resilience required for high availability for SMC-R.  While\
    \ this\n   configuration is not required, it is a strongly recommended \"best\n\
    \   practice\" for the exploitation of SMC-R.  Single and asymmetric links\n \
    \  must be supported but are intended to provide for short-term\n   transient\
    \ conditions -- for example, during a temporary outage or\n   recycle of an RNIC.\n\
    \          Host X                                     Host Y\n     +-------------------+\
    \                      +-------------------+\n     |                   |     \
    \                 |                   |\n     | Protection        |          \
    \            |    Protection     |\n     | Domain X          |               \
    \       |    Domain Y       |\n     |            +------+                    \
    \  +------+            |\n     |       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC\
    \ 2|  QP 64     |\n     |RToken X|   |      |<-------------------->|      |  \
    \ |        |\n     |        |   |      |                      |      |   |RToken\
    \ Y|\n     |       \\/   +------+                      +------+  \\/        |\n\
    \     |+--------+         |                      |        +--------+ |\n     ||\
    \        |         |                      |        |        | |\n     || RMB \
    \   |         |                      |        | RMB    | |\n     ||        | \
    \        |                      |        |        | |\n     |+--------+      \
    \   |                      |        +--------+ |\n     |       /\\   +------+\
    \                      +------+  /\\        |\n     |RToken Z|   |      |    \
    \ SMC-R Link 2     |      |   |RToken W|\n     |        |   |RNIC 3|<-------------------->|RNIC\
    \ 4|   |        |\n     |       QP 9 |      |                      |      |  QP\
    \ 65     |\n     |            +------+                      +------+         \
    \   |\n     +-------------------+                      +-------------------+\n\
    \                      Figure 5: Symmetric SMC-R Links\n          Host X     \
    \                                Host Y\n     +-------------------+          \
    \            +-------------------+\n     |                   |               \
    \       |                   |\n     | Protection        |                    \
    \  |    Protection     |\n     | Domain X          |                      |  \
    \  Domain Y       |\n     |            +------+                      +------+\
    \            |\n     |       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2|  QP 64\
    \     |\n     |RToken X|   |      |<-------------------->|      |   |        |\n\
    \     |        |   |      |                   .->|      |   |RToken Y|\n     |\
    \       \\/   +------+                 .`   +------+  \\/        |\n     |+--------+\
    \         |               .`     |        +--------+ |\n     ||        |     \
    \    |             .`       |        |        | |\n     || RMB    |         |\
    \           .`         |        | RMB    | |\n     ||        |         |     \
    \    .`SMC-R      |        |        | |\n     |+--------+         |       .` Link\
    \ 2      |        +--------+ |\n     |       /\\   +------+     .`           \
    \    +------+            |\n     |RToken Z|   |      |   .`                 |\
    \      |down or     |\n     |        |   |RNIC 3|<-`                   |RNIC 4|unavailable\
    \ |\n     |       QP 9 |      |                      |      |            |\n \
    \    |            +------+                      +------+            |\n     +-------------------+\
    \                      +-------------------+\n                     Figure 6: Asymmetric\
    \ SMC-R Links\n   In the example provided by Figure 6, Host X has two RNICs but\
    \ Host Y\n   only has one RNIC because RNIC 4 is not available.  This\n   configuration\
    \ allows for the creation of an asymmetric link.  While\n   an asymmetric link\
    \ will provide some resilience (for example, when\n   RNIC 1 fails), ideally each\
    \ host should provide two redundant RNICs.\n   This should be a transient case,\
    \ and when RNIC 4 becomes available,\n   this configuration must transition to\
    \ a symmetric-link configuration.\n   This transition is accomplished by first\
    \ creating the new symmetric\n   link and then deleting the asymmetric link with\
    \ reason code\n   \"Asymmetric link no longer needed\" specified in the DELETE\
    \ LINK LLC\n   message.\n          Host X                                    \
    \ Host Y\n     +-------------------+                      +-------------------+\n\
    \     |                   |                      |                   |\n     |\
    \ Protection        |                      |    Protection     |\n     | Domain\
    \ X          |                      |    Domain Y       |\n     |            +------+\
    \  SMC-R Link 1        +------+            |\n     |       QP 8 |RNIC 1|<-------------------->|RNIC\
    \ 2|  QP 64     |\n     |RToken X|   |      |                      |      |  \
    \ |        |\n     |        |   |      |<-------------------->|      |   |RToken\
    \ Y|\n     |       \\/   +------+  SMC-R Link 2        +------+  \\/        |\n\
    \     |+--------+   QP 9  |                      | QP 65  +--------+ |\n     ||\
    \        |    |    |                      |  |     |        | |\n     || RMB \
    \   |<-- +    |                      |  +---->| RMB    | |\n     ||        | \
    \        |                      |        |        | |\n     |+--------+      \
    \   |                      |        +--------+ |\n     |            +------+ \
    \                     +------+            |\n     |     down or|      |      \
    \                |      |down or     |\n     | unavailable|RNIC 3|           \
    \           |RNIC 4|unavailable |\n     |            |      |                \
    \      |      |            |\n     |            +------+                     \
    \ +------+            |\n     +-------------------+                      +-------------------+\n\
    \              Figure 7: SMC-R Parallel Links (Not Supported)\n   Figure 7 shows\
    \ parallel links, which are two links in the link group\n   that use the same\
    \ hardware.  This configuration is not permitted.\n   Because SMC-R multiplexes\
    \ multiple TCP connections over an SMC-R link\n   and both links are using the\
    \ exact same hardware, there is no\n   additional redundancy or capacity benefit\
    \ obtained from this\n   configuration.  In addition to providing no real benefit,\
    \ this\n   configuration adds the unnecessary overhead of additional queue\n \
    \  pairs, generation of additional RKeys, etc.\n"
- title: 2.2.2.  Maximum Number of Links in Link Group
  contents:
  - "2.2.2.  Maximum Number of Links in Link Group\n   The SMC-R protocol defines\
    \ a maximum of eight symmetric SMC-R links\n   within a single SMC-R link group.\
    \  This allows for support for up to\n   eight unique physical paths between peer\
    \ hosts.  However, in terms of\n   meeting the basic requirements for redundancy,\
    \ support for at least\n   two symmetric links must be implemented.  Supporting\
    \ more than two\n   links also simplifies implementation for practical matters\
    \ relating\n   to dynamically adding and removing links -- for example, starting\
    \ a\n   third SMC-R link prior to taking down one of the two existing links.\n\
    \   Recall that all links within a link group must have equal access to\n   all\
    \ associated RMBs.\n   The SMC-R protocol allows an implementation to assign an\n\
    \   implementation-specific and appropriate value for maximum symmetric\n   links.\
    \  The implementation value must not exceed the architecture\n   limit of 8; also,\
    \ the value must not be lower than 2, because the\n   SMC-R protocol requires\
    \ redundancy.  This does not mean that two\n   RNICs are physically required to\
    \ enable SMC-R connectivity, but at\n   least two RNICs for redundancy are strongly\
    \ recommended.\n   The SMC-R peers exchange their implementation maximum link\
    \ values\n   during the link group establishment using the defined maximum link\n\
    \   value in the CONFIRM LINK LLC command.  Once the initial exchange\n   completes,\
    \ the value is set for the life of the link group.  The\n   maximum link value\
    \ can be provided by both the server and client.\n   The server must supply a\
    \ value, whereas the client maximum link value\n   is optional.  When the client\
    \ does not supply a value, it indicates\n   that the client accepts the server-supplied\
    \ maximum value.  If the\n   client provides a value, it cannot exceed the server-supplied\
    \ maximum\n   value.  If the client passes a lower value, this lower value then\n\
    \   becomes the final negotiated maximum number of symmetric links for\n   this\
    \ link group.  Again, the minimum value is 2.\n   During run time, the client\
    \ must never request that the server add a\n   symmetric link to a link group\
    \ that would exceed the negotiated\n   maximum link value.  Likewise, the server\
    \ must never attempt to add a\n   symmetric link to a link group that would exceed\
    \ the negotiated\n   maximum value.\n   In terms of counting the number of active\
    \ links within a link group,\n   the initial link (or the only/last) link is always\
    \ counted as 1.\n   Then, as additional links are added, they are either symmetric\
    \ or\n   asymmetric links.\n   With regards to enforcing the maximum link rules,\
    \ asymmetric links\n   are an exception having a unique set of rules:\n   o  Asymmetric\
    \ links are always limited to one asymmetric link allowed\n      per link group.\n\
    \   o  Asymmetric links must not be counted in the maximum symmetric-link\n  \
    \    count calculation.  When tracking the current count or enforcing\n      the\
    \ negotiated maximum number of links, an asymmetric link is not\n      to be counted.\n"
- title: 2.2.3.  Forming and Managing Link Groups
  contents:
  - "2.2.3.  Forming and Managing Link Groups\n   SMC-R link groups are self-defining.\
    \  The first SMC-R link in a link\n   group is created using TCP option flows\
    \ on the TCP three-way\n   handshake followed by CLC message flows over the TCP\
    \ connection.\n   Subsequent SMC-R links in the link group are created by sending\
    \ LLC\n   messages over an SMC-R link that already exists in the link group.\n\
    \   Once an SMC-R link group is created, no additional SMC-R links in\n   that\
    \ group are created using TCP and CLC negotiation.  Because\n   subsequent SMC-R\
    \ links are created exclusively by sending LLC\n   messages over an existing SMC-R\
    \ link in a link group, the membership\n   of SMC-R links in a link group is self-defining.\n\
    \   This architecture does not define a specific identifier for an SMC-R\n   link\
    \ group.  This identification may be useful for network management\n   and may\
    \ be assigned in a platform-specific manner, or in an extension\n   to this architecture.\n\
    \   In each SMC-R link group, one peer is the server for all TCP\n   connections\
    \ and the other peer is the client.  If there are\n   additional TCP connections\
    \ between the peers that use SMC-R and have\n   the client and server roles reversed,\
    \ another SMC-R link group is set\n   up between them with the opposite client-server\
    \ relationship.\n   This is required because there are specific responsibilities\
    \ divided\n   between the client and server in the management of an SMC-R link\n\
    \   group.\n   In this architecture, the decision of whether to use an existing\n\
    \   SMC-R link group or create a new SMC-R link group for a TCP\n   connection\
    \ is made exclusively by the server.\n   Management of the links in an SMC-R link\
    \ group is also a server\n   responsibility.  The server is responsible for adding\
    \ and deleting\n   links in a link group.  The client may request that the server\
    \ take\n   certain actions, but the final responsibility is the server's.\n"
- title: 2.2.4.  SMC-R Link Identifiers
  contents:
  - "2.2.4.  SMC-R Link Identifiers\n   This architecture defines multiple identifiers\
    \ to identify SMC-R\n   links and peers.\n   o  Link number: This is a 1-byte\
    \ value that identifies an SMC-R link\n      within a link group.  Both the server\
    \ and the client use this\n      number to distinguish an SMC-R link from other\
    \ links within the\n      same link group.  It is only unique within a link group.\
    \  In order\n      to prevent timing windows that may occur when a server creates\
    \ a\n      new link while the client is still cleaning up a previously\n     \
    \ existing link, link numbers cannot be reused until the entire link\n      numbering\
    \ space has been exhausted.\n   o  Link user ID: This is an architecturally opaque\
    \ 4-byte value that\n      a peer uses to uniquely define an SMC-R link within\
    \ its own space.\n      This means that a link user ID is unique within one peer\
    \ only.\n      Each peer defines its own link user ID for a link.  The peers\n\
    \      exchange this information once during link setup, and it is never\n   \
    \   used architecturally again.  The purpose of this identifier is for\n     \
    \ network management, display, and debugging.  For example, an\n      operator\
    \ on a client could provide the operator on the server with\n      the server's\
    \ link user ID if he requires the server's operator to\n      check on the operation\
    \ of a link that the client is having trouble\n      with.\n   o  Peer ID: The\
    \ SMC-R peer ID uniquely identifies a specific instance\n      of a specific TCP/IP\
    \ stack.  It is required because in clustered\n      and load-balancing environments,\
    \ an IP address does not uniquely\n      identify a TCP/IP stack.  An RNIC's MAC/GID\
    \ also doesn't uniquely\n      or reliably identify a TCP/IP stack, because RNICs\
    \ can go up and\n      down and even be redeployed to other TCP/IP stacks in a\n\
    \      multiple-partitioned or virtualized environment.  The peer ID is\n    \
    \  not only unique per TCP/IP stack but is also unique per instance\n      of\
    \ a TCP/IP stack, meaning that if a TCP/IP stack is restarted,\n      its peer\
    \ ID changes.\n"
- title: 2.3.  SMC-R Resilience and Load Balancing
  contents:
  - "2.3.  SMC-R Resilience and Load Balancing\n   The SMC-R multilink architecture\
    \ provides resilience for network high\n   availability via failover capability\
    \ to an alternate RoCE adapter.\n   The SMC-R multilink architecture does not\
    \ define primary, secondary,\n   or alternate roles to the links.  Instead, there\
    \ are multiple active\n   links representing multiple redundant RoCE paths over\
    \ the same LAN.\n   Assignment of TCP connections to links is unidirectional and\n\
    \   asymmetric.  This means that the client and server may each choose a\n   separate\
    \ link for their RDMA writes associated with a specific TCP\n   connection.\n\
    \   If a hardware failure occurs or a QP failure associated with an\n   individual\
    \ link occurs, then the TCP connections that were associated\n   with the failing\
    \ link are dynamically and transparently switched to\n   use another available\
    \ link.  The server or the client can detect a\n   failure, immediately move their\
    \ TCP connections, and then notify\n   their peer via the DELETE LINK LLC command.\
    \  While the client can\n   notify the server of an apparent link failure with\
    \ the DELETE LINK\n   LLC command, the server performs the actual link deletion.\n\
    \   The movement of TCP connections to another link can be accomplished\n   with\
    \ minimal coordination between the peers.  The TCP connection\n   movement is\
    \ also transparent to, and non-disruptive to, the TCP\n   socket application workloads\
    \ for most failure scenarios.  After a\n   failure, the surviving links and all\
    \ associated hardware must handle\n   the link group's workload.\n   As each SMC-R\
    \ peer begins to move active TCP connections to another\n   link, all current\
    \ RDMA write operations must be allowed to complete.\n   The moving peer then\
    \ sends a signal to verify receipt of the last\n   successful write by its peer.\
    \  If this verification fails, the TCP\n   connection must be reset.  Once this\
    \ verification is complete, all\n   writes that failed may then be retried, in\
    \ order, over the new link.\n   Any data writes or CDC messages for which the\
    \ sender did not receive\n   write completion must be replayed before any subsequent\
    \ data or CDC\n   write operations are sent.  LLC messages are not retried over\
    \ the new\n   link, because they are dependent on a known link configuration,\
    \ which\n   has just changed because of the failure.  The initiator of an LLC\n\
    \   message exchange that fails will be responsible for retrying once the\n  \
    \ link group configuration stabilizes.\n   When a new link becomes available and\
    \ is re-added to the link group,\n   each peer is free to rebalance its current\
    \ TCP connections as needed\n   or only assign new TCP connections to the newly\
    \ added link.  Both the\n   server and client are free to manage TCP connections\
    \ across the link\n   group as needed.  TCP connection movement does not have\
    \ to be\n   stimulated by a link failure.\n   The SMC-R architecture also defines\
    \ orderly versus disorderly\n   failover.  The type of failover is communicated\
    \ in the LLC\n   DELETE LINK command and is simply a means to indicate that the\
    \ link\n   has terminated (disorderly) or link termination is imminent\n   (orderly).\
    \  The orderly link deletion could be initiated via operator\n   command or programmatically\
    \ to bring down an idle link.  For example,\n   an operator command could initiate\
    \ orderly shutdown of an adapter for\n   service.  Implementation of the two types\
    \ is based on implementation\n   requirements and is beyond the scope of the SMC-R\
    \ architecture.\n"
- title: 3.  SMC-R Rendezvous Architecture
  contents:
  - "3.  SMC-R Rendezvous Architecture\n   \"Rendezvous\" is the process that SMC-R-capable\
    \ peers use to\n   dynamically discover each others' capabilities, negotiate SMC-R\n\
    \   connections, set up SMC-R links and link groups, and manage those\n   link\
    \ groups.  A key aspect of SMC-R Rendezvous is that it occurs\n   dynamically\
    \ and automatically, without requiring SMC-R link\n   configuration to be defined\
    \ by an administrator.\n   SMC-R Rendezvous starts with the TCP/IP three-way handshake,\
    \ during\n   which connection peers use TCP options to announce their SMC-R\n\
    \   capabilities.  If both endpoints are SMC-R capable, then Connection\n   Layer\
    \ Control (CLC) messages are exchanged between the peers' SMC-R\n   layers over\
    \ the newly established TCP connection to negotiate SMC-R\n   credentials.  The\
    \ CLC message mechanism is analogous to the messages\n   exchanged by SSL for\
    \ its handshake processing.\n   If a new SMC-R link is being set up, Link Layer\
    \ Control (LLC)\n   messages are used to confirm RDMA connectivity.  LLC messages\
    \ are\n   also used by the SMC-R layers at each peer to manage the links and\n\
    \   link groups.\n   Once an SMC-R link is set up or agreed to by the peers, the\
    \ TCP\n   sockets are passed to the peer applications, which use them as\n   normal.\
    \  The SMC-R layer, which resides under the sockets layer,\n   transmits the socket\
    \ data between peers over RDMA using the SMC-R\n   protocol, bypassing the TCP/IP\
    \ stack.\n"
- title: 3.1.  TCP Options
  contents:
  - "3.1.  TCP Options\n   During the TCP/IP three-way handshake, the client and server\
    \ indicate\n   their support for SMC-R by including experimental TCP option 254\
    \ on\n   the three-way handshake flows, in accordance with [RFC6994] (\"Shared\n\
    \   Use of Experimental TCP Options\").  The Experiment Identifier (ExID)\n  \
    \ value used is the string \"SMCR\" in EBCDIC (IBM-1047) encoding\n   (0xE2D4C3D9).\
    \  This ExID has been registered in the \"TCP Experimental\n   Option Experiment\
    \ Identifiers (TCP ExIDs)\" registry maintained\n   by IANA.\n   After completion\
    \ of the three-way TCP handshake, each peer queries\n   its peer's options.  If\
    \ both peers set the TCP option on the\n   three-way handshake, inline SMC-R negotiation\
    \ occurs using CLC\n   messages.  If neither peer, or only one peer, sets the\
    \ TCP option,\n   SMC-R cannot be used for the TCP connection, and the TCP connection\n\
    \   completes the setup using the IP fabric.\n"
- title: 3.2.  Connection Layer Control (CLC) Messages
  contents:
  - "3.2.  Connection Layer Control (CLC) Messages\n   CLC messages are sent as data\
    \ payload over the IP network using the\n   TCP connection between SMC-R layers\
    \ at the peers.  They are analogous\n   to the messages used to exchange parameters\
    \ for SSL.\n   The use of CLC messages is detailed in the following sections.\
    \  The\n   following list provides a summary of the defined CLC messages and\n\
    \   their purposes:\n   o  SMC Proposal: Sent from the client to propose that\
    \ this TCP\n      connection is eligible to be moved to SMC-R.  The client\n \
    \     identifies itself and its subnet to the server and passes the\n      SMC-R\
    \ elements for a suggested RoCE path via the MAC and GID.\n   o  SMC Accept: Sent\
    \ from the server to accept the client's TCP\n      connection SMC Proposal. \
    \ The server responds to the client's\n      proposal by identifying itself to\
    \ the client and passing the\n      elements of a RoCE path that the client can\
    \ use to perform RDMA\n      writes to the server.  This consists of such SMC-R\
    \ link elements\n      as RoCE MAC, GID, and RMB information.\n   o  SMC Confirm:\
    \ Sent from the client to confirm the server's\n      acceptance of the SMC connection.\
    \  The client responds to the\n      server's acceptance by passing the elements\
    \ of a RoCE path that\n      the server can use to perform RDMA writes to the\
    \ client.  This\n      consists of such SMC-R link elements as RoCE MAC, GID,\
    \ and RMB\n      information.\n   o  SMC Decline: Sent from either the server\
    \ or the client to reject\n      the SMC connection, indicating the reason the\
    \ peer must decline\n      the SMC Proposal and allowing the TCP connection to\
    \ revert back to\n      IP connectivity.\n"
- title: 3.3.  LLC Messages
  contents:
  - "3.3.  LLC Messages\n   Link Layer Control (LLC) messages are sent between peer\
    \ SMC-R layers\n   over an SMC-R link to manage the link or the link group.  LLC\n\
    \   messages are sent using RoCE SendMsg and are 44 bytes long.  The\n   44-byte\
    \ size is based on what can fit into a RoCE Work Queue Element\n   (WQE) without\
    \ requiring the posting of receive buffers.\n   LLC messages generally follow\
    \ a request-reply semantic.  Each message\n   has a request flavor and a reply\
    \ flavor, and each request must be\n   confirmed with a reply, except where otherwise\
    \ noted.  The use of LLC\n   messages is detailed in the following sections. \
    \ The following list\n   provides a summary of the defined LLC messages and their\
    \ purposes:\n   o  ADD LINK: Used to add a new link to a link group.  Sent from\
    \ the\n      server to the client to initiate addition of a new link to the\n\
    \      link group, or from the client to the server to request that the\n    \
    \  server initiate addition of a new link.\n   o  ADD LINK CONTINUATION: A continuation\
    \ of ADD LINK that allows the\n      ADD LINK to span multiple commands, because\
    \ all of the link\n      information cannot be contained in a single ADD LINK\
    \ message.\n   o  CONFIRM LINK: Used to confirm that RoCE connectivity over a\
    \ newly\n      created SMC-R link is working correctly.  Initiated by the server.\n\
    \      Both this message and its reply must flow over the SMC-R link\n      being\
    \ confirmed.\n   o  DELETE LINK: When initiated by the server, deletes a specific\
    \ link\n      from the link group or deletes the entire link group.  When\n  \
    \    initiated by the client, requests that the server delete a\n      specific\
    \ link or the entire link group.\n   o  CONFIRM RKEY: Informs the peer on the\
    \ SMC-R link of the addition\n      of an RMB to the link group.\n   o  CONFIRM\
    \ RKEY CONTINUATION: A continuation of CONFIRM RKEY that\n      allows the CONFIRM\
    \ RKEY to span multiple commands, in the event\n      that all of the information\
    \ cannot be contained in a single\n      CONFIRM RKEY message.\n   o  DELETE RKEY:\
    \ Informs the peer on the SMC-R link of the deletion of\n      one or more RMBs\
    \ from the link group.\n   o  TEST LINK: Verifies that an already-active SMC-R\
    \ link is active\n      and healthy.\n   o  Optional LLC message: Any LLC message\
    \ in which the two high-order\n      bits of the opcode are b'10'.  This optional\
    \ message must be\n      silently discarded by a receiving peer that does not\
    \ support the\n      opcode.  No such messages are defined in this version of\
    \ the\n      architecture; however, the concept is defined to allow for\n    \
    \  toleration of possible advanced, optional functions.\n   CONFIRM LINK and TEST\
    \ LINK are sensitive to which link they flow on\n   and must flow on the link\
    \ being confirmed or tested.  The other flows\n   may flow over any active link\
    \ in the link group.  When there are\n   multiple links in a link group, a response\
    \ to an LLC message must\n   flow over the same link that the original message\
    \ flowed over, with\n   the following exceptions:\n   o  ADD LINK request from\
    \ a server in response to an ADD LINK from a\n      client.\n   o  DELETE LINK\
    \ request from a server in response to a DELETE LINK\n      from a client.\n"
- title: 3.4.  CDC Messages
  contents:
  - "3.4.  CDC Messages\n   Connection Data Control (CDC) messages are sent over the\
    \ RoCE fabric\n   between peers using RoCE SendMsg and are 44 bytes long.  The\
    \ 44-byte\n   size is based on the size that can fit into a RoCE WQE without\n\
    \   requiring the posting of receive buffers.  CDC messages are used to\n   describe\
    \ the socket application data passed via RDMA write\n   operations, as well as\
    \ TCP connection state information, including\n   producer cursors and consumer\
    \ cursors, RMBE state information, and\n   failover data validation.\n"
- title: 3.5.  Rendezvous Flows
  contents:
  - "3.5.  Rendezvous Flows\n   Rendezvous information for SMC-R is exchanged as TCP\
    \ options on the\n   TCP three-way handshake flows to indicate capability, followed\
    \ by\n   inline TCP negotiation messages to actually do the SMC-R setup.\n   Formats\
    \ of all rendezvous options and messages discussed in this\n   section are detailed\
    \ in Appendix A.\n"
- title: 3.5.1.  First Contact
  contents:
  - "3.5.1.  First Contact\n   First contact between RoCE peers occurs when a new\
    \ SMC-R link group\n   is being set up.  This could be because no SMC-R links\
    \ already exist\n   between the peers, or the server decides to create a new SMC-R\
    \ link\n   group in parallel with an existing one.\n"
- title: 3.5.1.1.  Pre-negotiation of TCP Options
  contents:
  - "3.5.1.1.  Pre-negotiation of TCP Options\n   The client and server indicate their\
    \ SMC-R capability to each other\n   using TCP option 254 on the TCP three-way\
    \ handshake flows.\n   A client who wishes to do SMC-R will include TCP option\
    \ 254 using an\n   ExID equal to the EBCDIC (codepage IBM-1047) encoding of \"\
    SMCR\" on\n   its SYN flow.\n   A server that supports SMC-R will include TCP\
    \ option 254 with the\n   ExID value of EBCDIC \"SMCR\" on its SYN-ACK flow. \
    \ Because the server\n   is listening for connections and does not know where\
    \ client\n   connections will come from, the server implementation may choose\
    \ to\n   unconditionally include this TCP option if it supports SMC-R.  This\n\
    \   may be required for server implementations where extensions to the\n   TCP\
    \ stack are not practical.  For server implementations that can add\n   code to\
    \ examine and react to packets during the three-way handshake,\n   the server\
    \ should only include the SMC-R TCP option on the SYN-ACK if\n   the client included\
    \ it on its SYN packet.\n   A client who supports SMC-R and meets the three conditions\
    \ outlined\n   above may optionally include the TCP option for SMC-R on its ACK\n\
    \   flow, regardless of whether or not the server included it on its\n   SYN-ACK\
    \ flow.  Some TCP/IP stacks may have to include it if the SMC-R\n   layer cannot\
    \ modify the options on the socket until the three-way\n   handshake completes.\
    \  Proprietary servers should not include this\n   option on the ACK flow, since\
    \ including it on the SYN flow was\n   sufficient to indicate the client's capabilities.\n\
    \   Once the initial three-way TCP handshake is completed, each peer\n   examines\
    \ the socket options.  SMC-R implementations may do this by\n   examining what\
    \ was actually provided on the SYN and SYN-ACK packets\n   or by performing a\
    \ getsockopt() operation to determine the options\n   sent by the peer.  If neither\
    \ peer, or only one peer, specified the\n   TCP option for SMC-R, then SMC-R cannot\
    \ be used on this connection\n   and it proceeds using normal IP flows and processing.\n\
    \   If both peers specified the TCP option for SMC-R, then the TCP\n   connection\
    \ is not started yet and the peers proceed to SMC-R\n   negotiation using inline\
    \ data flows.  The socket is not yet turned\n   over to the applications; instead,\
    \ the respective SMC layers exchange\n   CLC messages over the newly formed TCP\
    \ connection.\n"
- title: 3.5.1.2.  Client Proposal
  contents:
  - "3.5.1.2.  Client Proposal\n   If SMC-R is supported by both peers, the client\
    \ sends an SMC Proposal\n   CLC message to the server.  It is not immediately\
    \ apparent on this\n   flow from client to server whether this is a new or existing\
    \ SMC-R\n   link, because in clustered environments a single IP address may\n\
    \   represent multiple hosts.  This type of cluster virtual IP address\n   can\
    \ be owned by a network-based or host-based Layer 4 load balancer\n   that distributes\
    \ incoming TCP connections across a cluster of\n   servers/hosts.  For purposes\
    \ of high availability, other clustered\n   environments may also support the\
    \ movement of a virtual IP address\n   dynamically from one host in the cluster\
    \ to another.  In summary, the\n   client cannot predetermine that a connection\
    \ is targeting the same\n   host by simply matching the destination IP address\
    \ for outgoing TCP\n   connections.  Therefore, it cannot predetermine the SMC-R\
    \ link that\n   will be used for a new TCP connection.  This information will\
    \ be\n   dynamically learned, and the appropriate actions will be taken as the\n\
    \   SMC-R negotiation handshake unfolds.\n   In the SMC-R proposal message, the\
    \ initiator (client) proposes the\n   use of SMC-R by including its peer ID, GID,\
    \ and MAC addresses, as\n   well as the IP subnet number of the outgoing interface\
    \ (if IPv4) or\n   the IP prefix list for the network over which the proposal\
    \ is sent\n   (if IPv6).  At this point in the flow, the client makes no local\n\
    \   commitments of resources for SMC-R.\n   When the server receives the SMC Proposal\
    \ CLC message, it uses the\n   peer ID provided by the client, plus subnet or\
    \ prefix information\n   provided by the client, to determine if it already has\
    \ a usable SMC-R\n   link with this SMC-R peer.  If there are one or more existing\
    \ SMC-R\n   links with this SMC-R peer, the server then decides which SMC-R link\n\
    \   it will use for this TCP connection.  See Sections 3.5.2 and 3.5.3\n   for\
    \ the cases of reusing an existing SMC-R link or creating a\n   parallel SMC-R\
    \ link group between SMC-R peers.\n   If this is a first contact between SMC-R\
    \ peers, the server must\n   validate that it is on the same LAN as the client\
    \ before continuing.\n   For IPv4, the server does this by verifying that it has\
    \ an interface\n   with an IP subnet number that matches the subnet number sent\
    \ by the\n   client in the SMC Proposal.  For IPv6, it does this by verifying\
    \ that\n   it is directly attached to at least one IP prefix that was listed by\n\
    \   the client in its SMC Proposal message.\n   If the server agrees to use SMC-R,\
    \ the server begins the setup of a\n   new SMC-R link by allocating local QP and\
    \ RMB resources (setting its\n   QP state to INIT) and providing its full SMC-R\
    \ information in an SMC\n   Accept CLC message to the client over the TCP connection,\
    \ along with\n   a flag set indicating that this is a first contact flow.  While\
    \ the\n   SMC Accept message could flow over any IP route back to the client\n\
    \   depending upon Layer 3 IP routing, the SMC-R credentials provided\n   must\
    \ be for the common subnet or prefix between the server and\n   client, as determined\
    \ above.  If the server cannot or does not want\n   to do SMC-R with the client,\
    \ it sends an SMC Decline CLC message to\n   the client, and the connection data\
    \ may begin flowing using normal\n   TCP/IP flows.\n"
- title: 3.5.1.3.  Server Acceptance
  contents:
  - "3.5.1.3.  Server Acceptance\n   When the client receives the SMC Accept from\
    \ the server, it\n   determines whether this is a new or existing SMC-R link,\
    \ using the\n   combination of the following: the first contact flag, its MAC/GID\
    \ and\n   the MAC/GID returned by the server, the VLAN over which the\n   connection\
    \ is setting up, and the QP number provided by the server.\n   If it is an existing\
    \ SMC-R link and the client agrees to use that\n   link for the TCP connection,\
    \ see Section 3.5.2 (\"Subsequent Contact\")\n   below.  If it is a new SMC-R\
    \ link between peers that already have an\n   SMC-R link, then the server is starting\
    \ a new SMC-R link group.\n   Assuming that either (1) this is a first contact\
    \ between peers or\n   (2) the server is starting a new SMC-R link group, the\
    \ client now\n   allocates local QP and RMB resources for the SMC-R link (setting\
    \ the\n   QP state to RTR (ready to receive)), associates them with the server\n\
    \   QP as learned from the SMC Accept CLC message, and sends an SMC\n   Confirm\
    \ CLC message to the server over the TCP connection with its\n   SMC-R link information\
    \ included.  The client also starts a timer to\n   wait for the server to confirm\
    \ the reliably connected queue pair, as\n   described below.\n"
- title: 3.5.1.4.  Client Confirmation
  contents:
  - "3.5.1.4.  Client Confirmation\n   Upon receipt of the client's SMC Confirm CLC\
    \ message, the server\n   associates its QP for this SMC-R link with the client's\
    \ QP as learned\n   from the SMC Confirm CLC message and sets its QP state to\
    \ RTS (ready\n   to send).  The client and the server now have reliably connected\n\
    \   queue pairs.\n"
- title: 3.5.1.5.  Link (QP) Confirmation
  contents:
  - "3.5.1.5.  Link (QP) Confirmation\n   Since setting up the SMC-R link and its\
    \ QPs did not require any\n   network flows on the RoCE fabric, the client and\
    \ server must now\n   confirm connectivity over the RoCE fabric.  To accomplish\
    \ this, the\n   server will send a CONFIRM LINK Link Layer Control (LLC) message\
    \ to\n   the client over the newly created SMC-R link, using the RoCE fabric.\n\
    \   The CONFIRM LINK LLC message will provide the server's MAC, GID, and\n   QP\
    \ information for the connection, allow each partner to communicate\n   the maximum\
    \ number of links it can tolerate in this link group (the\n   \"link limit\"),\
    \ and will additionally provide two link IDs:\n   o  a 1-byte server-assigned\
    \ link number that is used by both peers to\n      identify the link within the\
    \ link group and is only unique within\n      a link group.\n   o  a 4-byte link\
    \ user ID.  This opaque value is assigned by the\n      server for the server's\
    \ local use and is provided to the client\n      for management purposes -- for\
    \ example, to use in network\n      management displays and products.\n   When\
    \ the server sends this message, it will set a timer for receiving\n   confirmation\
    \ from the client.\n   When the client receives the server's confirmation in the\
    \ form of a\n   CONFIRM LINK LLC message, it will cancel the confirmation timer\
    \ it\n   set when it sent the SMC Confirm message.  The client will also\n   advance\
    \ its QP state to RTS and respond over the RoCE fabric with a\n   CONFIRM LINK\
    \ response LLC message that (1) provides its MAC, GID,\n   QP number, and link\
    \ limit, (2) confirms the 1-byte link number sent\n   by the server, and (3) provides\
    \ its own 4-byte link user ID to the\n   server.\n       Host X -- Server    \
    \                       Host Y -- Client\n    +-------------------+          \
    \            +-------------------+\n    | Peer ID = PS1     |                \
    \      |   Peer ID = PC1   |\n    |            +------+                      +------+\
    \            |\n    |       QP 8 |RNIC 1|                      |RNIC 2|  QP 64\
    \     |\n    |RToken X|   |MAC MA|                      |MAC MB|   |        |\n\
    \    |        |   |GID GA|                      |GID GB|   |RToken Y|\n    | \
    \      \\/   +------+      (Subnet S1)     +------+  \\/        |\n    |+--------+\
    \         |                      |        +--------+ |\n    || RMB    |      \
    \   |                      |        | RMB    | |\n    |+--------+         |  \
    \                    |        +--------+ |\n    |            +------+        \
    \              +------+            |\n    |            |RNIC 3|              \
    \        |RNIC 4|            |\n    |            |MAC MC|                    \
    \  |MAC MD|            |\n    |            |GID GC|                      |GID\
    \ GD|            |\n    |            +------+                      +------+  \
    \          |\n    +-------------------+                      +-------------------+\n\
    \                     SYN TCP options(254,\"SMCR\")\n        <---------------------------------------------------------\n\
    \                     SYN-ACK TCP options(254,\"SMCR\")\n        --------------------------------------------------------->\n\
    \                     ACK [TCP options(254,\"SMCR\")]\n        <--------------------------------------------------------\n\
    \                    SMC Proposal(PC1,MB,GB,S1)\n        <--------------------------------------------------------\n\
    \    SMC Accept(PS1,first contact,MA,GA,MTU,QP8,RToken=X,RMB elem index)\n   \
    \     --------------------------------------------------------->\n         SMC\
    \ Confirm(PC1,MB,GB,MTU,QP64,RToken=Y,RMB element index)\n         <--------------------------------------------------------\n\
    \       CONFIRM LINK(MA,GA,QP8, link lim, server link user ID, linknum)\n    \
    \    .........................................................>\n    CONFIRM LINK\
    \ rsp(MB,GB,QP64, link lim, client link user ID, linknum)\n        <........................................................\n\
    \                           Legend:\n                    ------------   TCP/IP\
    \ and CLC flows\n                    ............   RoCE (LLC) flows\n       \
    \    Square brackets (\"[ ]\") indicate optional information\n               \
    \  Figure 8: First Contact Rendezvous Flows\n   Technically, the data for the\
    \ TCP connection could now flow over the\n   RoCE path.  However, if this is a\
    \ first contact, there is no\n   alternate for this recently established RoCE\
    \ path.  Since in the\n   current architecture there is no failover from RoCE\
    \ to IP once\n   connection data starts flowing, this means that a failure of\
    \ this\n   path would disrupt the TCP connection, meaning that the level of\n\
    \   redundancy and failover is less than that provided by IP.  If the\n   network\
    \ has alternate RoCE paths available, they would not be usable\n   at this point.\
    \  This situation would be unacceptable.\n"
- title: 3.5.1.6.  Second SMC-R Link Setup
  contents:
  - "3.5.1.6.  Second SMC-R Link Setup\n   Because of the unacceptable situation described\
    \ above, TCP data will\n   not be allowed to flow on the newly established SMC-R\
    \ link until a\n   second path has been set up, or at least attempted.\n   If\
    \ the server has a second RNIC available on the same LAN, it\n   attempts to set\
    \ up the second SMC-R link over that second RNIC.  If\n   it only has one RNIC\
    \ available on the LAN, it will attempt to set up\n   the second SMC-R link over\
    \ that one RNIC.  In the latter case, the\n   server is attempting to set up an\
    \ asymmetric link, in case the client\n   does have a second RNIC on the LAN.\n\
    \   In either case, the server allocates a new QP over the RNIC it is\n   attempting\
    \ to use for the second link and assigns a link number to\n   the new link; the\
    \ server also creates an RToken for the RMB over this\n   second QP (note that\
    \ this means that the first and second QP each\n   have their own RToken to represent\
    \ the same RMB).  The server\n   provides this information, as well as the MAC\
    \ and GID of the RNIC\n   over which it is attempting to set up the second link,\
    \ in an ADD LINK\n   LLC message that it sends to the client over the SMC-R link\
    \ that is\n   already set up.\n"
- title: 3.5.1.6.1.  Client Processing of ADD LINK LLC Message from Server
  contents:
  - "3.5.1.6.1.  Client Processing of ADD LINK LLC Message from Server\n   When the\
    \ client receives the server's ADD LINK LLC message, it\n   examines the GID and\
    \ MAC provided by the server to determine whether\n   the server is attempting\
    \ to use the same server-side RNIC as the\n   existing SMC-R link or a different\
    \ one.\n   If the server is attempting to use the same server-side RNIC as the\n\
    \   existing SMC-R link, then the client verifies that it has a second\n   RNIC\
    \ on the same LAN.  If it does not, the client rejects the\n   ADD LINK request\
    \ from the server, because the resulting link would be\n   a parallel link, which\
    \ is not supported within a link group.  If the\n   client does have a second\
    \ RNIC on the same LAN, it accepts the\n   request, and an asymmetric link will\
    \ be set up.\n   If the server is using a different server-side RNIC from the\
    \ existing\n   SMC-R link, then the client will accept the request and a second\n\
    \   SMC-R link will be set up in this SMC-R link group.  If the client\n   has\
    \ a second RNIC on the same LAN, that second RNIC will be used for\n   the second\
    \ SMC-R link, creating symmetric links.  If the client does\n   not have a second\
    \ RNIC on the same LAN, it will use the same RNIC as\n   was used for the initial\
    \ SMC-R link, resulting in the setup of an\n   asymmetric link in the SMC-R link\
    \ group.\n   In either case, when the client accepts the server's ADD LINK\n \
    \  request, it allocates a new QP on the chosen RNIC and creates an RKey\n   over\
    \ that new QP for the client-side RMB for the SMC-R link group,\n   then sends\
    \ an ADD LINK reply LLC message to the server providing that\n   information as\
    \ well as echoing the link number that was sent by the\n   server.\n   If the\
    \ client rejects the server's ADD LINK request, it sends an ADD\n   LINK reply\
    \ LLC message to the server with the reason code for the\n   rejection.\n"
- title: 3.5.1.6.2.  Server Processing of ADD LINK Reply LLC Message from Client
  contents:
  - "3.5.1.6.2.  Server Processing of ADD LINK Reply LLC Message from Client\n   If\
    \ the client sends a negative response to the server or no reply is\n   received,\
    \ the server frees the RoCE resources it had allocated for\n   the new link. \
    \ Having a single link in an SMC-R link group is\n   undesirable.  The server's\
    \ recovery is detailed in Appendix C.8\n   (\"Failure to Add Second SMC-R Link\
    \ to a Link Group\").\n   If the client sends a positive reply to the server with\n\
    \   MAC/GID/QP/RKey information, the server associates its QP for the new\n  \
    \ SMC-R link to the QP that the client provided.  Now, the new SMC-R\n   link\
    \ is in the same situation that the first was in after the client\n   sent its\
    \ ACK packet -- there is a reliably connected queue pair over\n   the new RoCE\
    \ path, but there have been no RoCE flows to confirm that\n   it's actually usable.\
    \  So, at this point, the client and server will\n   exchange CONFIRM LINK LLC\
    \ messages just like they did on the first\n   SMC-R link.\n   If either peer\
    \ receives a failure during this second CONFIRM LINK LLC\n   exchange (either\
    \ an immediate failure -- which implies that the\n   message did not reach the\
    \ partner -- or a timeout), it sends a DELETE\n   LINK LLC message to the partner\
    \ over the first (and now only) link in\n   the link group.  This DELETE LINK\
    \ LLC message must be acknowledged\n   before data can flow on the single link\
    \ in the link group.\n       Host X -- Server                           Host Y\
    \ -- Client\n    +-------------------+                      +-------------------+\n\
    \    | Peer ID = PS1     |                      |   Peer ID = PC1   |\n    | \
    \           +------+                      +------+            |\n    |       QP\
    \ 8 |RNIC 1|      SMC-R Link 1    |RNIC 2|  QP 64     |\n    |RToken X|   |MAC\
    \ MA|<-------------------->|MAC MB|   |        |\n    |        |   |GID GA|  \
    \                    |GID GB|   |RToken Y|\n    |       \\/   +------+       \
    \               +------+  \\/        |\n    |+--------+         |            \
    \          |        +--------+ |\n    ||        |         |                  \
    \    |        |        | |\n    || RMB    |         |                      | \
    \       | RMB    | |\n    ||        |         |                      |       \
    \ |        | |\n    |+--------+         |                      |        +--------+\
    \ |\n    |       /\\   +------+                      +------+  /\\        |\n\
    \    |        |   |RNIC 3|      SMC-R Link 2    |RNIC 4|  |         |\n    |RToken\
    \ Z|   |MAC MC|<-------------------->|MAC MD|  |RToken W |\n    |       QP 9 |GID\
    \ GC|      (being added)   |GID GD| QP 65      |\n    |            +------+  \
    \                    +------+            |\n    +-------------------+        \
    \              +-------------------+\n                First SMC-R link setup as\
    \ shown in Figure 8\n            <-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.->\n\
    \            ADD LINK request(QP9,MC,GC, link number = 2)\n            ............................................>\n\
    \            ADD LINK response(QP65,MD,GD, link number = 2)\n            <............................................\n\
    \            ADD LINK CONTINUATION request(RToken=Z)\n            ............................................>\n\
    \           ADD LINK CONTINUATION response(RToken=W)\n            <............................................\n\
    \         CONFIRM LINK(MC,GC,QP9, link number = 2, link user ID)\n           \
    \ .............................................>\n      CONFIRM LINK response(MD,GD,QP65,\
    \ link number = 2, link user ID)\n            <.............................................\n\
    \                          Legend:\n                   ------------   TCP/IP and\
    \ CLC flows\n                   ............   RoCE (LLC) flows\n            \
    \    Figure 9: First Contact, Second Link Setup\n"
- title: 3.5.1.6.3.  Exchange of RKeys on Second SMC-R Link
  contents:
  - "3.5.1.6.3.  Exchange of RKeys on Second SMC-R Link\n   Note that in the scenario\
    \ described here -- first contact -- there is\n   only one RMB RKey to exchange\
    \ on the second SMC-R link, and it is\n   exchanged in the ADD LINK CONTINUATION\
    \ request and reply.  In\n   scenarios other than first contact -- for example,\
    \ adding a new SMC-R\n   link to a longstanding link group with multiple RMBs\
    \ -- additional\n   flows will be required to exchange additional RMB RKeys. \
    \ See\n   Section 3.5.5.2.3 (\"Adding a New SMC-R Link to a Link Group with\n\
    \   Multiple RMBs\") for more details on these flows.\n"
- title: 3.5.1.6.4.  Aborting SMC-R and Falling Back to IP
  contents:
  - "3.5.1.6.4.  Aborting SMC-R and Falling Back to IP\n   If both partners don't\
    \ provide the SMC-R TCP option during the\n   three-way TCP handshake, the connection\
    \ falls back to normal TCP/IP.\n   During the SMC-R negotiation that occurs after\
    \ the three-way TCP\n   handshake, either partner may break off SMC-R by sending\
    \ an SMC\n   Decline CLC message.  The SMC Decline CLC message may be sent in\n\
    \   place of any expected message and may also be sent during the CONFIRM\n  \
    \ LINK LLC exchange if there is a failure before any application data\n   has\
    \ flowed over the RoCE fabric.  For more details on exactly when an\n   SMC Decline\
    \ can flow during link group setup, see Appendices C.1\n   (\"SMC Decline during\
    \ CLC Negotiation\") and C.2 (\"SMC Decline during\n   LLC Negotiation\").\n \
    \  If this fallback to IP happens while setting up a new SMC-R link\n   group,\
    \ the RoCE resources allocated for this SMC-R link group\n   relationship are\
    \ torn down, and it will be retried as a new SMC-R\n   link group next time a\
    \ connection starts between these peers with\n   SMC-R proposed.  Note that if\
    \ this happens because one side doesn't\n   support SMC-R, there will be very\
    \ little to tear down, as the TCP\n   option will have failed to flow on either\
    \ the initial SYN or the\n   SYN-ACK before either side had reserved any local\
    \ RoCE resources.\n"
- title: 3.5.2.  Subsequent Contact
  contents:
  - "3.5.2.  Subsequent Contact\n   \"Subsequent contact\" means setting up a new\
    \ TCP connection between\n   two peers that already have an SMC-R link group between\
    \ them and\n   reusing the existing SMC-R link group.  In this case, it is not\n\
    \   necessary to allocate new QPs.  However, it is possible that a new\n   RMB\
    \ has been allocated for this TCP connection, if the previous TCP\n   connection\
    \ used the last element available in the previously used\n   RMB, or for any other\
    \ implementation-dependent reason.  For this\n   reason, and for convenience and\
    \ error checking, the same TCP\n   option 254, followed by the inline negotiation\
    \ method described for\n   initial contact, will be used for subsequent contact,\
    \ but the\n   processing differs in some ways.  That processing is described below.\n"
- title: 3.5.2.1.  SMC-R Proposal
  contents:
  - "3.5.2.1.  SMC-R Proposal\n   When the client begins the inline negotiation with\
    \ the server, it\n   does not know if this is a first contact or a subsequent\
    \ contact.\n   The client cannot know this information until it sees the server's\n\
    \   peer ID, to determine whether or not it already has an SMC-R link\n   with\
    \ this peer that it can use.  There are several reasons why it is\n   not sufficient\
    \ to use the partner IP address, subnet, VLAN, or other\n   IP information to\
    \ make this determination.  The most obvious reason\n   is distributed systems:\
    \ if the server IP address is actually a\n   virtual IP address representing a\
    \ distributed cluster, the actual\n   host serving this TCP connection may not\
    \ be the same as the host that\n   served the last TCP connection to this same\
    \ IP address.\n   After the TCP three-way handshake, assuming that both partners\n\
    \   indicate SMC-R capability, the client builds and sends the\n   SMC Proposal\
    \ CLC message to the server in exactly the same manner as\n   it does in the \"\
    first contact\" case, and in fact at this point\n   doesn't know if it's a first\
    \ contact or a subsequent contact.  As in\n   the \"first contact\" case, the\
    \ client sends its peer ID value,\n   suggested RNIC MAC/GID, and IP subnet or\
    \ prefix information.\n   Upon receiving the client's proposal, the server looks\
    \ up the\n   provided peer ID to determine if it already has a usable SMC-R\n\
    \   link group with this peer.  If it does already have a usable SMC-R\n   link\
    \ group, the server then needs to decide whether it will use the\n   existing\
    \ SMC-R link group or create a new link group.  For the case\n   of the new link\
    \ group, see Section 3.5.3 (\"First Contact Variation:\n   Creating a Parallel\
    \ Link Group\") below.\n   For this discussion, assume that the server decides\
    \ to use the\n   existing SMC-R link group for the TCP connection, which is expected\n\
    \   to be the most common case.  The server is responsible for making\n   this\
    \ decision.  The server then needs to communicate that information\n   to the\
    \ client, but it is not necessary to allocate, associate, and\n   confirm QPs\
    \ for the chosen SMC-R link.  All that remains to be done\n   is to set up RMB\
    \ space for this TCP connection.\n   If one of the RMBs already in use for this\
    \ SMC-R link group has an\n   available element that uses the appropriate buffer\
    \ size, the server\n   merely chooses one for this TCP connection and then sends\
    \ an SMC\n   Accept CLC message providing the full RoCE information for the chosen\n\
    \   SMC-R link to the client, using the same format as the SMC Accept CLC\n  \
    \ message described in Section 3.5.1 (\"First Contact\") above.\n   The server\
    \ may choose to use the SMC-R link that matches the\n   suggested MAC/GID provided\
    \ by the client in the SMC Proposal for its\n   RDMA writes but is not obligated\
    \ to do so.  The final decision on\n   which specific SMC-R link to assign a TCP\
    \ connection to is an\n   independent server and client decision.\n   It may be\
    \ necessary for the server to allocate a new RMB for this\n   connection.  The\
    \ reasons for this are implementation dependent and\n   could include the following:\n\
    \   o  no available space in existing RMB or RMBs, or\n   o  desire to allocate\
    \ a new RMB that uses a different buffer size\n      from the ones already created,\
    \ or\n   o  any other implementation-dependent reason\n   In this case, the server\
    \ will allocate the new RMB and then perform\n   the flows described in Section\
    \ 3.5.5.2.1 (\"Adding a New RMB to an\n   SMC-R Link Group\").  Once that processing\
    \ is complete, the server\n   then provides the full RoCE information, including\
    \ the new RKey, for\n   this connection in an SMC Confirm CLC message to the client.\n"
- title: 3.5.2.2.  SMC-R Acceptance
  contents:
  - "3.5.2.2.  SMC-R Acceptance\n   Upon receiving the SMC Accept CLC message from\
    \ the server, the client\n   examines the RoCE information provided by the server\
    \ to determine\n   whether this is a first contact for a new SMC-R link group\
    \ or a\n   subsequent contact for an existing SMC-R link group.  It is a\n   subsequent\
    \ contact if the server-side peer ID, GID, MAC, and QP\n   number provided in\
    \ the packet match a known SMC-R link, and the first\n   contact flag is not set.\
    \  If this is not the case -- for example, the\n   GID and MAC match but the QP\
    \ is new -- then the server is creating a\n   new, parallel SMC-R link group,\
    \ and this is treated as a first\n   contact.\n   A different RMB RToken does\
    \ not indicate a first contact, as the\n   server may have allocated a new RMB\
    \ or may be using several RMBs for\n   this SMC-R link.  The client needs the\
    \ server's RMB information only\n   for its RDMA writes to the server, and since\
    \ there is no requirement\n   for symmetric RMBs, this information is simply control\
    \ information\n   for the RDMA writes on this SMC-R link.\n   The client must\
    \ validate that the RMB element being provided by the\n   server is not in use\
    \ by another TCP connection on this SMC-R link\n   group.  This validation must\
    \ validate the new <rtoken, index> across\n   all known <rtoken, index> on this\
    \ link group.  See Section 4.4.2\n   (\"RMB Element Reuse and Conflict Resolution\"\
    ) for the case in which\n   the server tries to use an RMB element that is already\
    \ in use on this\n   link group.\n   Once the client has determined that this\
    \ TCP connection is a\n   subsequent contact over an existing SMC-R link, it performs\
    \ an RMB\n   allocation process similar to what the server did: it either\n  \
    \ (1) allocates an element from an RMB already associated with this\n   SMC-R\
    \ link or (2) allocates a new RMB, associates it with this SMC-R\n   link, and\
    \ then chooses an element out of it.\n   If the client allocates a new RMB for\
    \ this TCP connection, it\n   performs the processing described in Section 3.5.5.2.1\
    \ (\"Adding a New\n   RMB to an SMC-R Link Group\").  Once that processing is\
    \ complete, the\n   client provides its full RoCE information for this TCP connection\
    \ in\n   an SMC Confirm CLC message.\n   Because an SMC-R link with a verified\
    \ connected QP already exists and\n   is being reused, there is no need for verification\
    \ or alternate QP\n   selection flows or timers.\n"
- title: 3.5.2.3.  SMC-R Confirmation
  contents:
  - "3.5.2.3.  SMC-R Confirmation\n   When the server receives the client's SMC Confirm\
    \ CLC message on a\n   subsequent contact, it verifies the following:\n   o  The\
    \ RMB element provided by the client is not already in use by\n      another TCP\
    \ connection on this SMC-R link group (see Section 4.4.2\n      (\"RMB Element\
    \ Reuse and Conflict Resolution\") for the case in\n      which it is).\n   o\
    \  The MAC/GID/QP information provided by the client matches an\n      active\
    \ link within the link group.  The client is free to select\n      any valid/active\
    \ link.  The client is not required to select the\n      same link as the server.\n\
    \   If this validation passes, the server stores the client's RMB\n   information\
    \ for this connection, and the RoCE setup of the TCP\n   connection is complete.\n"
- title: 3.5.2.4.  TCP Data Flow Race with SMC Confirm CLC Message
  contents:
  - "3.5.2.4.  TCP Data Flow Race with SMC Confirm CLC Message\n   On a subsequent\
    \ contact TCP/IP connection, a peer may send data as\n   soon as it has received\
    \ the peer RMB information for the connection.\n   There are no additional RoCE\
    \ confirmation flows, since the QPs on the\n   SMC-R link are already reliably\
    \ connected and verified.\n   In the majority of cases, the first data will flow\
    \ from the client to\n   the server.  The client must send the SMC Confirm CLC\
    \ message before\n   sending any connection data over the chosen SMC-R link; however,\
    \ the\n   client need not wait for confirmation of this message, and in fact\n\
    \   there will be no such confirmation.  Since the server is required to\n   have\
    \ the RMB fully set up and ready to receive data from the client\n   before sending\
    \ an SMC Accept CLC message, the client can begin\n   sending data over the SMC-R\
    \ link immediately upon completing the send\n   of the SMC Confirm CLC message.\n\
    \   It is possible that data from the client will arrive at the\n   server-side\
    \ RMB before the SMC Confirm CLC message from the client\n   has been processed.\
    \  In this case, the server must handle this race\n   condition and not provide\
    \ the arrived TCP data to the socket\n   application until the SMC Confirm CLC\
    \ message has been received and\n   fully processed, opening the socket.\n   If\
    \ the server has initial data to send to the client that is not a\n   response\
    \ to the client (this case should be rare), it can send the\n   data immediately\
    \ upon receiving and processing the SMC Confirm CLC\n   message from the client.\
    \  The client must have opened the TCP socket\n   to the client application upon\
    \ sending the SMC Confirm CLC message so\n   the client will be ready to process\
    \ data from the server.\n"
- title: '3.5.3.  First Contact Variation: Creating a Parallel Link Group'
  contents:
  - "3.5.3.  First Contact Variation: Creating a Parallel Link Group\n   Recall that\
    \ parallel SMC-R links within an SMC-R link group are not\n   supported.  These\
    \ are multiple SMC-R links within a link group that\n   use the same network path.\
    \  However, multiple SMC-R link groups\n   between the same peers are supported.\
    \  This means that if multiple\n   SMC-R links over the same RoCE path are desired,\
    \ it is necessary to\n   use multiple SMC-R link groups.  While not a recommended\
    \ practice,\n   this could be done for platform-specific reasons, like QP separation\n\
    \   of different workloads.  Only the server can drive the creation of\n   multiple\
    \ SMC-R link groups between peers.\n   At a high level, when the server decides\
    \ to create an additional\n   SMC-R link group with a client with which it already\
    \ has an SMC-R\n   link group, the flows are basically the same as the normal\n\
    \   \"first contact\" case described above.  The following text provides\n   more\
    \ detail and clarification of processing in this case.\n   When the server receives\
    \ the SMC Proposal CLC message from the client\n   and, using the MAC/GID information,\
    \ determines that it already has an\n   SMC-R link group with this client, the\
    \ server can either reuse the\n   existing SMC-R link group (detailed in Section\
    \ 3.5.2 (\"Subsequent\n   Contact\") above) or create a new SMC-R link group in\
    \ addition to the\n   existing one.\n   If the server decides to create a new\
    \ SMC-R link group, it does the\n   same processing it would have done for first\
    \ contact: allocate QP and\n   RMB resources as well as alternate QP resources,\
    \ and communicate the\n   QP and RMB information to the client in the SMC Accept\
    \ CLC message\n   with the first contact flag set.\n   When the client receives\
    \ the server's SMC Accept CLC message with the\n   new QP information and the\
    \ first contact flag set, it knows that the\n   server is creating a new SMC-R\
    \ link group even though it already has\n   an SMC-R link group with the server.\
    \  In this case, the client will\n   also allocate a new QP for this new SMC-R\
    \ link, allocate an RMB for\n   it, and generate an RKey for it.\n   Note that\
    \ multiple SMC-R link groups between the same peers must\n   access different\
    \ RMB resources, so new RMBs will be required.  Using\n   the same RMBs that are\
    \ in use in another SMC-R link group is not\n   permitted.\n   The client then\
    \ associates its new QP with the server's new QP and\n   sends its SMC Confirm\
    \ CLC message back to the server providing the\n   new QP/RMB information, and\
    \ then sets its confirmation timer for the\n   new SMC-R link.\n   When the server\
    \ receives the client's SMC Confirm CLC message, it\n   associates its QP with\
    \ the client's QP as learned from the SMC\n   Confirm CLC message and sends a\
    \ confirmation LLC message.  The rest\n   of the flow, with the confirmation QP\
    \ and setup of additional SMC-R\n   links, unfolds just like the \"first contact\"\
    \ case.\n"
- title: 3.5.4.  Normal SMC-R Link Termination
  contents:
  - "3.5.4.  Normal SMC-R Link Termination\n   The normal socket API trigger points\
    \ are used by the SMC-R layer to\n   initiate SMC-R connection termination flows.\
    \  The main design point\n   for SMC-R normal connection flows is to use the SMC-R\
    \ protocol to\n   first shut down the SMC-R connection and free up any SMC-R RDMA\n\
    \   resources, and then allow the normal TCP connection termination\n   protocol\
    \ (i.e., FIN processing) to drive cleanup of the TCP\n   connection that exists\
    \ on the IP fabric.  This design point is very\n   important in ensuring that\
    \ RDMA resources such as the RMBEs are only\n   freed and reused when both SMC-R\
    \ endpoints are completely done with\n   their RDMA write operations to the partner's\
    \ RMBE.\n   When the last TCP connection over an SMC-R link group terminates,\
    \ the\n   link group can be terminated.  Similar to creation of SMC-R links and\n\
    \   link groups, the primary responsibility for determining that normal\n   termination\
    \ is needed and initiating it lies with the server.\n   Implementations may opt\
    \ to set timers to keep SMC-R link groups up\n   for a specified time after the\
    \ last TCP connection ends, to avoid\n   churn in cases where TCP connections\
    \ come and go regularly.\n   The link or link group may also be terminated as\
    \ a result of a\n   command initiated by the operator.  This command can be entered\
    \ at\n   either the client or the server.  If entered at the client, the\n   client\
    \ requests that the server perform link or link group\n   termination, and the\
    \ responsibility for doing so ultimately lies with\n   the server.\n   When the\
    \ server determines that the SMC-R link group is to be\n   terminated, it sends\
    \ a DELETE LINK LLC message to the client, with a\n   flag set indicating that\
    \ all links in the link group are to be\n   terminated.  After receiving confirmation\
    \ from the adapter that the\n   DELETE LINK LLC message has been sent, the server\
    \ can clean up its\n   end of the link group (QPs, RMBs, etc.).  Upon receipt\
    \ of the DELETE\n   LINK message from the server, the client must immediately\
    \ comply and\n   clean up its end of the link group.  Any TCP connections that\
    \ the\n   client believes to be active on the link group must be immediately\n\
    \   terminated.\n   The client can request that the server delete the link group\
    \ as well.\n   The client does this by sending a DELETE LINK message to the server,\n\
    \   indicating that cleanup of all links is requested.  The server must\n   comply\
    \ by sending a DELETE LINK to the client and processing as\n   described in the\
    \ previous paragraph.  If there are TCP connections\n   active on the link group\
    \ when the server receives this request, they\n   are immediately terminated by\
    \ sending a RST flow over the IP fabric.\n"
- title: 3.5.5.  Link Group Management Flows
  contents:
  - '3.5.5.  Link Group Management Flows

    '
- title: 3.5.5.1.  Adding and Deleting Links in an SMC-R Link Group
  contents:
  - "3.5.5.1.  Adding and Deleting Links in an SMC-R Link Group\n   The server has\
    \ the lead role in managing the composition of the link\n   group.  Links are\
    \ added to the link group by the server.  The client\n   may notify the server\
    \ of new conditions that may result in the server\n   adding a new link, but the\
    \ server is ultimately responsible.  In\n   general, links are deleted from the\
    \ link group by the server;\n   however, in certain error cases the client may\
    \ inform the server that\n   a link must be deleted and treat it as deleted without\
    \ waiting for\n   action from the server.  These flows are detailed in the sections\n\
    \   that follow.\n"
- title: 3.5.5.1.1.  Server-Initiated ADD LINK Processing
  contents:
  - "3.5.5.1.1.  Server-Initiated ADD LINK Processing\n   As described in previous\
    \ sections, the server initiates an ADD LINK\n   exchange to create redundancy\
    \ in a newly created link group.  Once a\n   link group is established, the server\
    \ may also initiate ADD LINK for\n   other reasons, including:\n   o  Availability\
    \ of additional resources on the server host to support\n      an additional SMC-R\
    \ link.  This may include the provisioning of an\n      additional RNIC, more\
    \ storage becoming available to support\n      additional QP resources, operator\
    \ command, or any other\n      implementation-dependent reason.  Note that in\
    \ order to be\n      available for an existing link group a new RNIC must be attached\n\
    \      to the same RoCE LAN that the link group is using.\n   o  Receipt of notification\
    \ from the client that additional resources\n      on the client are available\
    \ to support an additional SMC-R link.\n      See Section 3.5.5.1.2 (\"Client-Initiated\
    \ ADD LINK Processing\").\n   Server-initiated ADD LINK processing in an established\
    \ SMC-R link\n   group is the same as the ADD LINK processing described in\n \
    \  Section 3.5.1.6 (\"Second SMC-R Link Setup\"), with the following\n   changes:\n\
    \   o  If an asymmetric SMC-R link already exists in the link group, a\n     \
    \ second asymmetric link will not be created.  Only one asymmetric\n      link\
    \ is permitted in a link group.\n   o  TCP data flow on already-existing link(s)\
    \ in the link group is not\n      halted or otherwise affected during the process\
    \ of setting up the\n      additional link.\n   The server will not initiate ADD\
    \ LINK processing if the link group\n   already has the maximum number of links\
    \ negotiated by the partners.\n"
- title: 3.5.5.1.2.  Client-Initiated ADD LINK Processing
  contents:
  - "3.5.5.1.2.  Client-Initiated ADD LINK Processing\n   If an additional RNIC becomes\
    \ available for an existing SMC-R link\n   group on the client's side, the client\
    \ notifies the server by sending\n   an ADD LINK request LLC message to the server.\
    \  Unlike an ADD LINK\n   request sent by the server to the client, this ADD LINK\
    \ request\n   merely informs the server that the client has a new RNIC.  If the\n\
    \   link group lacks redundancy or has redundancy only on an asymmetric\n   link\
    \ with a single RNIC on the client side, the server must initiate\n   an ADD LINK\
    \ exchange in response to this message, to create or\n   improve the link group's\
    \ redundancy.\n   If the link group already has symmetric-link redundancy but\
    \ has fewer\n   than the negotiated maximum number of links, the server may respond\n\
    \   by initiating an ADD LINK exchange to create a new link using the\n   client's\
    \ new resource but is not required to do so.\n   If the link group already has\
    \ the negotiated maximum number of links,\n   the server must ignore the client's\
    \ ADD LINK request LLC message.\n   Because the server is not required to respond\
    \ to the client's\n   ADD LINK LLC message in all cases, the client must not wait\
    \ for a\n   response or throw an error if one does not come.\n"
- title: 3.5.5.1.3.  Server-Initiated DELETE LINK Processing
  contents:
  - "3.5.5.1.3.  Server-Initiated DELETE LINK Processing\n   Reasons that a server\
    \ may delete a link include the following:\n   o  The link has not been used for\
    \ TCP connections for an\n      implementation-defined time interval, and deleting\
    \ the link will\n      not cause the link group to lack redundancy.\n   o  Errors\
    \ in resources supporting the link occur.  These errors may\n      include, but\
    \ are not limited to, RNIC errors, QP errors, and\n      software errors.\n  \
    \ o  The RNIC supporting this SMC-R link is being taken down, either\n      because\
    \ of an error case or because of an operator or software\n      command.\n   If\
    \ a link being deleted is supporting TCP connections and there are\n   one or\
    \ more surviving links in the link group, the TCP connections\n   are moved to\
    \ the surviving links.  For more information on this\n   processing, see Section\
    \ 2.3 (\"SMC-R Resilience and Load Balancing\").\n   The server deletes a link\
    \ from the link group by sending a\n   DELETE LINK request LLC message to the\
    \ client over any of the usable\n   links in the link group.  Because the DELETE\
    \ LINK LLC message\n   specifies which link is to be deleted, it may flow over\
    \ any link in\n   the link group.  The server must not clean up its RoCE resources\
    \ for\n   the link until the client responds.\n   The client responds to the server's\
    \ DELETE LINK request LLC message\n   by sending the server a DELETE LINK response\
    \ LLC message.  The client\n   must respond positively; it cannot decline to delete\
    \ the link.  Once\n   the server has received the client's DELETE LINK response,\
    \ both sides\n   may clean up their resources for the link.\n   Either a positive\
    \ write completion or some other indication from the\n   RNIC on the client's\
    \ side is sufficient to indicate to the client\n   that the server has received\
    \ the DELETE LINK response.\n         Host X                                 \
    \    Host Y\n    +-------------------+                      +-------------------+\n\
    \    |            +------+                      +------+            |\n    | \
    \      QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n    |RToken X|\
    \   |Failed|<--X----X----X----X-->|      |            |\n    |        |   |  \
    \    |                      |      |            |\n    |       \\/   +------+\
    \                      +------+            |\n    |+--------+         |      \
    \                |                   |\n    || Deleted|         |            \
    \          |                   |\n    || RMB    |         |                  \
    \    |                   |\n    ||        |         |                      | \
    \                  |\n    |+--------+         |                      |       \
    \            |\n    |       /\\   +------+                      +------+     \
    \       |\n    |RToken Z|   |      |     SMC-R Link 2     |      |           \
    \ |\n    |        |   |RNIC 3|<-------------------->|RNIC 4|            |\n  \
    \  |       QP 64|      |                      |      | QP 65      |\n    |   \
    \         +------+                      +------+            |\n    +-------------------+\
    \                      +-------------------+\n          DELETE LINK(request, link\
    \ number = 1,\n                ................................................>\n\
    \                       reason code = RNIC failure)\n          DELETE LINK(response,\
    \ link number = 1)\n               <................................................\n\
    \           (Note: Architecturally, this exchange can flow over either\n     \
    \             SMC-R link but most likely flows over Link 2, since\n          \
    \        the RNIC for Link 1 has failed.)\n               Figure 10: Server-Initiated\
    \ DELETE LINK Flow\n"
- title: 3.5.5.1.4.  Client-Initiated DELETE LINK Request
  contents:
  - "3.5.5.1.4.  Client-Initiated DELETE LINK Request\n   The client may request that\
    \ the server delete a link for the same\n   reasons that the server may delete\
    \ a link, except for inactivity\n   timeout.\n   Because the client depends on\
    \ the server to delete links, there are\n   two types of delete requests from\
    \ client to server:\n   o  Orderly: The client is requesting that the server delete\
    \ the link\n      when able.  This would result from an operator command to bring\n\
    \      down the RNIC or some other nonfatal reason.  In this case, the\n     \
    \ server is required to delete the link but may not do it right\n      away.\n\
    \   o  Disorderly: The server must delete the link right away, because\n     \
    \ the client has experienced a fatal error with the link.\n   In either case,\
    \ the server responds by initiating a DELETE LINK\n   exchange with the client,\
    \ as described in the previous section.  The\n   difference between the two is\
    \ whether the server must do so\n   immediately or can delay for an opportunity\
    \ to gracefully delete the\n   link.\n          Host X                       \
    \              Host Y\n     +-------------------+                      +-------------------+\n\
    \     |            +------+                      +------+            |\n     |\
    \       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n     |RToken\
    \ X|   |      |<---X--X--X--X--X--X->|Failed|            |\n     |        |  \
    \ |      |                      |      |            |\n     |       \\/   +------+\
    \                      +------+            |\n     |+--------+         |     \
    \                 |                   |\n     || Deleted|         |          \
    \            |                   |\n     || RMB    |         |               \
    \       |                   |\n     ||        |         |                    \
    \  |                   |\n     |+--------+         |                      |  \
    \                 |\n     |       /\\   +------+                      +------+\
    \            |\n     |RToken Z|   |      |     SMC-R Link 2     |      |     \
    \       |\n     |        |   |RNIC 3|<-------------------->|RNIC 4|          \
    \  |\n     |       QP 64|      |                      |      | QP 65      |\n\
    \     |            +------+                      +------+            |\n     +-------------------+\
    \                      +-------------------+\n           DELETE LINK(request,\
    \ link number = 1, disorderly,\n                <...............................................\n\
    \                       reason code = RNIC failure)\n           DELETE LINK(request,\
    \ link number = 1,\n                 ................................................>\n\
    \                        reason code = RNIC failure)\n           DELETE LINK(response,\
    \ link number = 1)\n                <................................................\n\
    \           (Note: Architecturally, this exchange can flow over either\n     \
    \             SMC-R link but most likely flows over Link 2, since\n          \
    \        the RNIC for Link 1 has failed.)\n               Figure 11: Client-Initiated\
    \ DELETE LINK Flow\n"
- title: 3.5.5.2.  Managing Multiple RKeys over Multiple SMC-R Links in a
  contents:
  - "3.5.5.2.  Managing Multiple RKeys over Multiple SMC-R Links in a\n          Link\
    \ Group\n   After the initial contact sequence completes and the number of TCP\n\
    \   connections increases, it is possible that the SMC peers could add\n   more\
    \ RMBs to the link group.  Recall that each peer independently\n   manages its\
    \ RMBs.  Also recall that an RMB's RToken is specific to a\n   QP, which means\
    \ that when there are multiple SMC-R links in a link\n   group, each RMB accessed\
    \ with the link group requires a separate\n   RToken for each SMC-R link in the\
    \ group.\n   Each RMB that is added to a link must be added to all links within\n\
    \   the link group.  The set of RMBs created for the link is called the\n   \"\
    RToken set\".  The RTokens must be exchanged with the peer.  As RMBs\n   are added\
    \ and deleted, the RToken set must remain in sync.\n"
- title: 3.5.5.2.1.  Adding a New RMB to an SMC-R Link Group
  contents:
  - "3.5.5.2.1.  Adding a New RMB to an SMC-R Link Group\n   A new RMB can be added\
    \ to an SMC-R link group on either the client\n   side or the server side.  When\
    \ an additional RMB is added to an\n   existing SMC-R link group, that RMB must\
    \ be associated with the QPs\n   for each link in the link group.  Therefore,\
    \ when an RMB is added to\n   an SMC-R link group, its RMB RToken for each SMC-R\
    \ link's QP must be\n   communicated to the peer.\n   The tokens for a new RMB\
    \ added to an existing SMC-R link group are\n   communicated using CONFIRM RKEY\
    \ LLC messages, as shown in Figure 12.\n   The RToken set is specified as pairs:\
    \ an SMC-R link number, paired\n   with the new RMB's RToken over that SMC-R link.\
    \  To preserve failover\n   capability, any TCP connection that uses a newly added\
    \ RMB cannot go\n   active until all RTokens for the RMB have been communicated\
    \ for all\n   of the links in the link group.\n          Host X              \
    \                       Host Y\n     +-------------------+                   \
    \   +-------------------+\n     |            +------+                      +------+\
    \            |\n     |       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9\
    \       |\n     |RToken X|   |      |<-------------------->|      |          \
    \  |\n     |        |   |      |                      |      |            |\n\
    \     |       \\/   +------+                      +------+            |\n    \
    \ |+--------+         |                      |                   |\n     || New\
    \    |         |                      |                   |\n     || RMB    |\
    \         |                      |                   |\n     ||        |     \
    \    |                      |                   |\n     |+--------+         |\
    \                      |                   |\n     |       /\\   +------+    \
    \                  +------+            |\n     |RToken Z|   |      |     SMC-R\
    \ Link 2     |      |            |\n     |        |   |RNIC 3|<-------------------->|RNIC\
    \ 4|            |\n     |       QP 64|      |                      |      | QP\
    \ 65      |\n     |            +------+                      +------+        \
    \    |\n     +-------------------+                      +-------------------+\n\
    \           CONFIRM RKEY(request, Add,\n                 ................................................>\n\
    \                      RToken set((Link 1,RToken X),(Link 2,RToken Z)))\n    \
    \       CONFIRM RKEY(response, Add,\n                <................................................\n\
    \                      RToken set((Link 1,RToken X),(Link 2,RToken Z)))\n    \
    \        (Note: This exchange can flow over either SMC-R link.)\n            \
    \     Figure 12: Add RMB to Existing Link Group\n   Implementations may choose\
    \ to proactively add RMBs to link groups in\n   anticipation of need.  For example,\
    \ an implementation may add a new\n   RMB when a certain usage threshold (e.g.,\
    \ percentage used) for all of\n   its existing RMBs has been exceeded.\n   A new\
    \ RMB may also be added to an existing link group on an as-needed\n   basis --\
    \ for example, when a new TCP connection is added to the link\n   group but there\
    \ are no available RMB elements.  In this case, the CLC\n   exchange is paused\
    \ while the peer that requires the new RMB adds it.\n   An example of this is\
    \ illustrated in Figure 13.\n       Host X -- Server                         \
    \   Host Y -- Client\n    +-------------------+                      +--------------------+\n\
    \    | Peer ID = PS1     |                      |   Peer ID = PC1    |\n    |\
    \            +------+                      +------+             |\n    |     \
    \  QP 8 |RNIC 1|    SMC-R Link 1      |RNIC 2|  QP 64      |\n    |RToken X| \
    \  |MAC MA|<-------------------->|MAC MB|   |         |\n    |        |   |GID\
    \ GA|                      |GID GB|   |RToken Y2|\n    |       \\/   +------+\
    \                      +------+  \\/         |\n    |+--------+         |    \
    \                  |        +--------+  |\n    ||        |         |   Subnet\
    \ S1          |        | New    |  |\n    || RMB    |         |              \
    \        |        | RMB    |  |\n    |+--------+         |                   \
    \   |        +--------+  |\n    |       /\\   +------+                      +------+\
    \  /\\         |\n    |        |   |RNIC 3|    SMC-R Link 2      |RNIC 4|   |RToken\
    \ W2|\n    |        |   |MAC MC|<-------------------->|MAC MD|   |         |\n\
    \    |       QP 9 |GID GC|                      |GID GD|  QP 65      |\n    |\
    \            +------+                      +------+             |\n    +-------------------+\
    \                      +--------------------+\n           SYN / SYN-ACK / ACK\
    \ TCP three-way handshake with TCP option\n        <--------------------------------------------------------->\n\
    \                    SMC Proposal(PC1,MB,GB,S1)\n        <--------------------------------------------------------\n\
    \      SMC Accept(PS1,not 1st contact,MA,GA,QP8,RToken=X,RMB elem index)\n   \
    \     --------------------------------------------------------->\n          CONFIRM\
    \ RKEY(request, Add,\n        <........................................................\n\
    \                  RToken set((Link 1,RToken Y2),(Link 2,RToken W2)))\n      \
    \    CONFIRM RKEY(response, Add,\n         ........................................................>\n\
    \                  RToken set((Link 1,RToken Y2),(Link 2,RToken W2)))\n      \
    \    SMC Confirm(PC1,MB,GB,QP64,RToken=Y2, RMB element index)\n        <--------------------------------------------------------\n\
    \                         Legend:\n                  ------------   TCP/IP and\
    \ CLC flows\n                  ............   RoCE (LLC) flows\n          Figure\
    \ 13: Client Adds RMB during TCP Connection Setup\n"
- title: 3.5.5.2.2.  Deleting an RMB from an SMC-R Link Group
  contents:
  - "3.5.5.2.2.  Deleting an RMB from an SMC-R Link Group\n   Either peer can delete\
    \ one or more of its RMBs as long as it is not\n   being used for any TCP connections.\
    \  Ideally, an SMC-R peer would use\n   a timer to avoid freeing an RMB immediately\
    \ after the last TCP\n   connection stops using it, to keep the RMB available\
    \ for later TCP\n   connections and avoid thrashing with addition and deletion\
    \ of RMBs.\n   Once an SMC-R peer decides to delete an RMB, it sends a DELETE\
    \ RKEY\n   LLC message to its peer.  It can then free the RMB once it receives\n\
    \   a response from the peer.  Multiple RMBs can be deleted in a\n   DELETE RKEY\
    \ exchange.\n   Note that in a DELETE RKEY message, it is not necessary to specify\n\
    \   the full RToken for a deleted RMB.  The RMB's RKey over one link in\n   the\
    \ link group is sufficient to specify which RMB is being deleted.\n          Host\
    \ X                                     Host Y\n     +-------------------+   \
    \                   +-------------------+\n     |            +------+        \
    \              +------+            |\n     |       QP 8 |RNIC 1|     SMC-R Link\
    \ 1     |RNIC 2| QP 9       |\n     |RToken X|   |      |<-------------------->|\
    \      |            |\n     |        |   |      |                      |     \
    \ |            |\n     |       \\/   +------+                      +------+  \
    \          |\n     |+--------+         |                      |              \
    \     |\n     || Deleted|         |                      |                   |\n\
    \     || RMB    |         |                      |                   |\n     ||\
    \        |         |                      |                   |\n     |+--------+\
    \         |                      |                   |\n     |       /\\   +------+\
    \                      +------+            |\n     |RToken Z|   |      |     SMC-R\
    \ Link 2     |      |            |\n     |        |   |RNIC 3|<-------------------->|RNIC\
    \ 4|            |\n     |       QP 9 |      |                      |      |  \
    \          |\n     |            +------+                      +------+       \
    \     |\n     +-------------------+                      +-------------------+\n\
    \           DELETE RKEY(request, RKey list(RKey X))\n                 ................................................>\n\
    \           DELETE RKEY(response, RKey list(RKey X))\n                <................................................\n\
    \           (Note: This exchange can flow over either SMC-R link.)\n         \
    \       Figure 14: Delete RMB from SMC-R Link Group\n"
- title: 3.5.5.2.3.  Adding a New SMC-R Link to a Link Group with Multiple RMBs
  contents:
  - "3.5.5.2.3.  Adding a New SMC-R Link to a Link Group with Multiple RMBs\n   When\
    \ a new SMC-R link is added to an existing link group, there could\n   be multiple\
    \ RMBs on each side already associated with the link group.\n   There could also\
    \ be a different number of RMBs on one side than on\n   the other, because each\
    \ peer manages its RMBs independently.  Each of\n   these RMBs will require a\
    \ new RToken to be used on the new SMC-R\n   link, and those new RTokens must\
    \ then be communicated to the peer.\n   This requires two-way communication, as\
    \ the server will have to\n   communicate its RTokens to the client and vice versa.\n\
    \   RTokens are communicated between peers in pairs.  Each RToken pair\n   consists\
    \ of:\n   o  The RToken for the RMB, as is already known on an existing SMC-R\n\
    \      link in the link group.\n   o  The RToken for the same RMB, to be used\
    \ on the new SMC-R link.\n   These pairs are required to ensure that each peer\
    \ knows which RTokens\n   across QPs are equivalent.\n   The ADD LINK request\
    \ and response LLC messages do not have enough\n   space to contain any RToken\
    \ pairs.  ADD LINK CONTINUATION LLC\n   messages are used to communicate these\
    \ pairs, as shown in Figure 15.\n   The ADD LINK CONTINUATION LLC messages are\
    \ sent on the same SMC-R\n   link that the ADD LINK LLC messages were sent over,\
    \ and in both the\n   ADD LINK and ADD LINK CONTINUATION LLC messages the first\
    \ RToken in\n   each RToken pair will be the RToken for the RMB as known on the\
    \ SMC-R\n   link over which the LLC message is being sent.\n       Host X -- Server\
    \                           Host Y -- Client\n    +-------------------+      \
    \                +-------------------+\n    | Peer ID = PS1     |            \
    \          |   Peer ID = PC1   |\n    |            +------+                  \
    \    +------+            |\n    |       QP 8 |RNIC 1|    SMC-R Link 1      |RNIC\
    \ 2|  QP 64     |\n    |RKey set|   |MAC MA|<-------------------->|MAC MB|   |RKey\
    \ set|\n    |X,Y,Z   |   |GID GA|                      |GID GB|   |Q,R,S,T |\n\
    \    |       \\/   +------+                      +------+  \\/        |\n    |+--------+\
    \         |                      |        +--------+ |\n    || 3 RMBs |      \
    \   |                      |        | 4 RMBs | |\n    |+--------+         |  \
    \                    |        +--------+ |\n    |       /\\   +------+       \
    \               +------+  /\\        |\n    |RKey set|   |RNIC 3|    SMC-R Link\
    \ 2      |RNIC 4|  | RKey set|\n    |U,V,W   |   |MAC MC|<-------------------->|MAC\
    \ MD|  | L,M,N,P |\n    |       QP 9 |GID GC|    (being added)     |GID GD| QP\
    \ 65      |\n    |            +------+                      +------+         \
    \   |\n    +-------------------+                      +-------------------+\n\
    \            ADD LINK request (QP9,MC,GC, link number = 2)\n            ............................................>\n\
    \            ADD LINK response (QP65,MD,GD, link number = 2)\n            <............................................\n\
    \    ADD LINK CONTINUATION req(RToken pairs=((X,U),(Y,V),(Z,W)))\n           \
    \  ............................................>\n    ADD LINK CONTINUATION rsp(RToken\
    \ pairs=((Q,L),(R,M),(S,N),(T,P)))\n             <.............................................\n\
    \           CONFIRM LINK req/rsp exchange on Link 2\n            <.............................................>\n\
    \                          Legend:\n                   ------------   TCP/IP and\
    \ CLC flows\n                   ............   RoCE (LLC) flows\n   Figure 15:\
    \ Exchanging RKeys when a New Link Is Added to a Link Group\n"
- title: 3.5.5.3.  Serialization of LLC Exchanges, and Collisions
  contents:
  - "3.5.5.3.  Serialization of LLC Exchanges, and Collisions\n   LLC flows can be\
    \ divided into two main groups for serialization\n   considerations.\n   The first\
    \ group is LLC messages that are independent and can flow at\n   any time.  These\
    \ are one-time, unsolicited messages that either do\n   not have a required response\
    \ or have a simple response that does not\n   interfere with the operations of\
    \ another group of messages.  These\n   messages are as follows:\n   o  TEST LINK\
    \ from either the client or the server: This message\n      requires a TEST LINK\
    \ response to be returned but does not affect\n      the configuration of the\
    \ link group or the RKeys.\n   o  ADD LINK from the client to the server: This\
    \ message is provided\n      as an \"FYI\" to the server to let it know that the\
    \ client has an\n      additional RNIC available.  The server is not required\
    \ to act upon\n      or respond to this message.\n   o  DELETE LINK from the client\
    \ to the server: This message informs\n      the server that either (1) the client\
    \ has experienced an error or\n      problem that requires a link or link group\
    \ to be terminated or\n      (2) an operator has commanded that a link or link\
    \ group be\n      terminated.  The server does not respond directly to the message;\n\
    \      rather, it initiates a DELETE LINK exchange as a result of\n      receiving\
    \ it.\n   o  DELETE LINK from the server to the client, with the \"delete entire\n\
    \      link group\" flag set: This message informs the client that the\n     \
    \ entire link group is being deleted.\n   The second group is LLC messages that\
    \ are part of an exchange of LLC\n   messages that affects link group configuration;\
    \ this exchange must\n   complete before another exchange of LLC messages that\
    \ affects link\n   group configuration can be processed.  When a peer knows that\
    \ one of\n   these exchanges is in progress, it must not start another exchange.\n\
    \   These exchanges are as follows:\n   o  ADD LINK / ADD LINK response / ADD\
    \ LINK CONTINUATION / ADD LINK\n      CONTINUATION response / CONFIRM LINK / CONFIRM\
    \ LINK response: This\n      exchange, by adding a new link, changes the configuration\
    \ of the\n      link group.\n   o  DELETE LINK / DELETE LINK response initiated\
    \ by the server,\n      without the \"delete entire link group\" flag set: This\
    \ exchange, by\n      deleting a link, changes the configuration of the link group.\n\
    \   o  CONFIRM RKEY / CONFIRM RKEY response or DELETE RKEY / DELETE RKEY\n   \
    \   response: This exchange changes the RMB configuration of the link\n      group.\
    \  RKeys cannot change while links are being added or deleted\n      (while an\
    \ ADD LINK or DELETE LINK is in progress).  However,\n      CONFIRM RKEY and DELETE\
    \ RKEY are unique in that both the client\n      and server can independently\
    \ manage (add or remove) their own\n      RMBs.  This allows each peer to concurrently\
    \ change their RKeys\n      and therefore concurrently send CONFIRM RKEY or DELETE\
    \ RKEY\n      requests.  The concurrent CONFIRM RKEY or DELETE RKEY requests can\n\
    \      be independently processed and do not represent a collision.\n   Because\
    \ the server is in control of the configuration of the link\n   group, many timing\
    \ windows and collisions are avoided, but there are\n   still some that must be\
    \ handled.\n"
- title: 3.5.5.3.1.  Collisions with ADD LINK / CONFIRM LINK Exchange
  contents:
  - "3.5.5.3.1.  Collisions with ADD LINK / CONFIRM LINK Exchange\n   Colliding LLC\
    \ message: TEST LINK\n      Action to resolve: Send immediate TEST LINK reply.\n\
    \   Colliding LLC message: ADD LINK from client to server\n      Action to resolve:\
    \ Server ignores the ADD LINK message.  When\n      client receives server's ADD\
    \ LINK, client will consider that\n      message to be in response to its ADD\
    \ LINK message and the flow\n      works.  Since both client and server know not\
    \ to start this\n      exchange if an ADD LINK operation is already underway,\
    \ this can\n      only occur if the client sends this message before receiving\
    \ the\n      server's ADD LINK and this message crosses with the server's ADD\n\
    \      LINK message; therefore, the server's ADD LINK arrives at the\n      client\
    \ immediately after the client sent this message.\n   Colliding LLC message: DELETE\
    \ LINK from client to server, specific\n   link specified\n      Action to resolve:\
    \ Server queues the DELETE LINK message and\n      processes it after the ADD\
    \ LINK exchange completes.  If it is an\n      orderly link termination, it can\
    \ wait until after this exchange\n      continues.  If it is disorderly and the\
    \ link affected is the one\n      that the current exchange is using, the server\
    \ will discover the\n      outage when a message in this exchange fails.\n   Colliding\
    \ LLC message: DELETE LINK from client to server, entire link\n   group to be\
    \ deleted\n      Action to resolve: Immediately clean up the link group.\n   Colliding\
    \ LLC message: CONFIRM RKEY from client\n      Action to resolve: Send a negative\
    \ CONFIRM RKEY response to the\n      client.  Once the current exchange finishes,\
    \ client will have to\n      recompute its RKey set to include the new link and\
    \ then start a\n      new CONFIRM RKEY exchange.\n"
- title: 3.5.5.3.2.  Collisions during DELETE LINK Exchange
  contents:
  - "3.5.5.3.2.  Collisions during DELETE LINK Exchange\n   Colliding LLC message:\
    \ TEST LINK from either peer\n      Action to resolve: Send immediate TEST LINK\
    \ response.\n   Colliding LLC message: ADD LINK from client to server\n      Action\
    \ to resolve: Server queues the ADD LINK and processes it\n      after the current\
    \ exchange completes.\n   Colliding LLC message: DELETE LINK from client to server\
    \ (specific\n   link)\n      Action to resolve: Server queues the DELETE LINK\
    \ message and\n      processes it after the current exchange completes.  If it\
    \ is an\n      orderly link termination, it can wait until after this exchange\n\
    \      continues.  If it is disorderly and the link affected is the one\n    \
    \  that the current exchange is using, the server will discover the\n      outage\
    \ when a message in this exchange fails.\n   Colliding LLC message: DELETE LINK\
    \ from either client or server,\n   deleting the entire link group\n      Action\
    \ to resolve: Immediately clean up the link group.\n   Colliding LLC message:\
    \ CONFIRM RKEY from client to server\n      Action to resolve: Send a negative\
    \ CONFIRM RKEY response to the\n      client.  Once the current exchange finishes,\
    \ client will have to\n      recompute its RKey set to include the new link and\
    \ then start a\n      new CONFIRM RKEY exchange.\n"
- title: 3.5.5.3.3.  Collisions during CONFIRM RKEY Exchange
  contents:
  - "3.5.5.3.3.  Collisions during CONFIRM RKEY Exchange\n   Colliding LLC message:\
    \ TEST LINK\n      Action to resolve: Send immediate TEST LINK reply.\n   Colliding\
    \ LLC message: ADD LINK from client to server\n      Action to resolve: Queue\
    \ the ADD LINK, and process it after the\n      current exchange completes.\n\
    \   Colliding LLC message: ADD LINK from server to client (CONFIRM RKEY\n   exchange\
    \ was initiated by the client, and it crossed with the server\n   initiating an\
    \ ADD LINK exchange)\n      Action to resolve: Process the ADD LINK.  Client will\
    \ receive a\n      negative CONFIRM RKEY from the server and will have to redo\
    \ this\n      CONFIRM RKEY exchange after the ADD LINK exchange completes.\n \
    \  Colliding LLC message: DELETE LINK from client to server, specific\n   link\
    \ to be deleted (CONFIRM RKEY exchange was initiated by the\n   server, and it\
    \ crossed with the client's DELETE LINK request)\n      Action to resolve: Server\
    \ queues the DELETE LINK message and\n      processes it after the CONFIRM RKEY\
    \ exchange completes.  If it is\n      an orderly link termination, it can wait\
    \ until after this exchange\n      continues.  If it is disorderly and the link\
    \ affected is the one\n      that the current exchange is using, the server will\
    \ discover the\n      outage when a message in this exchange fails.\n   Colliding\
    \ LLC message: DELETE LINK from server to client, specific\n   link deleted (CONFIRM\
    \ RKEY exchange was initiated by the client, and\n   it crossed with the server's\
    \ DELETE LINK)\n      Action to resolve: Process the DELETE LINK.  Client will\
    \ receive a\n      negative CONFIRM RKEY from the server and will have to redo\
    \ this\n      CONFIRM RKEY exchange after the ADD LINK exchange completes.\n \
    \  Colliding LLC message: DELETE LINK from either client or server,\n   entire\
    \ link group deleted\n      Action to resolve: Immediately clean up the link group.\n\
    \   Colliding LLC message: CONFIRM LINK from the peer that did not start\n   the\
    \ current CONFIRM LINK exchange\n      Action to resolve: Queue the request, and\
    \ process it after the\n      current exchange completes.\n"
- title: 4.  SMC-R Memory-Sharing Architecture
  contents:
  - '4.  SMC-R Memory-Sharing Architecture

    '
- title: 4.1.  RMB Element Allocation Considerations
  contents:
  - "4.1.  RMB Element Allocation Considerations\n   Each TCP connection using SMC-R\
    \ must be allocated an RMBE by each\n   SMC-R peer.  This allocation is performed\
    \ by each endpoint\n   independently to allow each endpoint to select an RMBE\
    \ that best\n   matches the characteristics on its TCP socket endpoint.  The RMBE\n\
    \   associated with a TCP socket endpoint must have a receive buffer that\n  \
    \ is at least as large as the TCP receive buffer size in effect for\n   that connection.\
    \  The receive buffer size can be determined by what\n   is specified explicitly\
    \ by the application using setsockopt() or\n   implicitly via the system-configured\
    \ default value.  This will allow\n   sufficient data to be RDMA-written by the\
    \ SMC-R peer to fill an\n   entire receive buffer size's worth of data on a given\
    \ data flow.\n   Given that each RMB must have fixed-length RMBEs, this implies\
    \ that\n   an SMC-R endpoint may need to maintain multiple RMBs of various sizes\n\
    \   for SMC-R connections on a given SMC-R link and can then select an\n   RMBE\
    \ that most closely fits a connection.\n"
- title: 4.2.  RMB and RMBE Format
  contents:
  - "4.2.  RMB and RMBE Format\n   An RMB is a virtual memory buffer whose backing\
    \ real memory is\n   pinned.  The RMB is subdivided into a whole number of equal-sized\
    \ RMB\n   Elements (RMBEs).  Each RMBE begins with a 4-byte eye catcher for\n\
    \   diagnostic and service purposes, followed by the receive data buffer.\n  \
    \ The contents of this diagnostic eye catcher are implementation\n   dependent\
    \ and should be used by the local SMC-R peer to check for\n   overlay errors by\
    \ verifying an intact eye catcher with every RMBE\n   access.\n   The RMBE is\
    \ a wrapping receive buffer for receiving RDMA writes from\n   the peer.  Cursors,\
    \ as described below, are exchanged between peers\n   to manage and track RDMA\
    \ writes and local data reads from the RMBE\n   for a TCP connection.\n"
- title: 4.3.  RMBE Control Information
  contents:
  - "4.3.  RMBE Control Information\n   RMBE control information consists of consumer\
    \ cursors, producer\n   cursors, wrap counts, CDC message sequence numbers, control\
    \ flags\n   such as urgent data and \"writer blocked\" indicators, and TCP\n \
    \  connection information such as termination flags.  This information\n   is\
    \ exchanged between SMC-R peers using CDC messages, which are passed\n   using\
    \ RoCE SendMsg.  A TCP/IP stack implementing SMC-R must receive\n   and store\
    \ this information in its internal data structures, as it is\n   used to manage\
    \ the RMBE and its data buffer.\n   The format and contents of the CDC message\
    \ are described in detail in\n   Appendix A.4 (\"Connection Data Control (CDC)\
    \ Message Format\").  The\n   following is a high-level description of what this\
    \ control\n   information contains.\n   o  Connection state flags such as sending\
    \ done, connection closed,\n      failover data validation, and abnormal close.\n\
    \   o  A sequence number that is managed by the sender.  This sequence\n     \
    \ number starts at 1, is increased each send, and wraps to 0.  This\n      sequence\
    \ number tracks the CDC message sent and is not related to\n      the number of\
    \ bytes sent.  It is used for failover data\n      validation.\n   o  Producer\
    \ cursor: a wrapping offset into the receiver's RMBE data\n      area.  Set by\
    \ the peer that is writing into the RMBE, it points to\n      where the writing\
    \ peer will write the next byte of data into an\n      RMBE.  This cursor is accompanied\
    \ by a wrap sequence number to\n      help the RMBE owner (the receiver) identify\
    \ full window size\n      wrapping writes.  Note that this cursor must account\
    \ for (i.e.,\n      skip over) the RMBE eye catcher that is in the beginning of\
    \ the\n      data area.\n   o  Consumer cursor: a wrapping offset into the receiver's\
    \ RMBE data\n      area.  Set by the owner of the RMBE (the peer that is reading\
    \ from\n      it), this cursor points to the offset of the next byte of data to\n\
    \      be consumed by the peer in its own RMBE.  The sender cannot write\n   \
    \   beyond this cursor into the receiver's RMBE without causing data\n      loss.\
    \  Like the producer cursor, this is accompanied by a wrap\n      count to help\
    \ the writer identify full window size wrapping reads.\n      Note that this cursor\
    \ must account for (i.e., skip over) the RMBE\n      eye catcher that is in the\
    \ beginning of the data area.\n   o  Data flags such as urgent data, writer blocked\
    \ indicator, and\n      cursor update requests.\n"
- title: 4.4.  Use of RMBEs
  contents:
  - '4.4.  Use of RMBEs

    '
- title: 4.4.1.  Initializing and Accessing RMBEs
  contents:
  - "4.4.1.  Initializing and Accessing RMBEs\n   The RMBE eye catcher is initialized\
    \ by the RMB owner prior to\n   assigning it to a specific TCP connection and\
    \ communicating its RMB\n   index to the SMC-R partner.  After an RMBE index is\
    \ communicated to\n   the SMC-R partner, the RMBE can only be referenced in \"\
    read-only\n   mode\" by the owner, and all updates to it are performed by the\
    \ remote\n   SMC-R partner via RDMA write operations.\n   Initialization of an\
    \ RMBE must include the following:\n   o  Zeroing out the entire RMBE receive\
    \ buffer, which helps minimize\n      data integrity issues (e.g., data from a\
    \ previous connection\n      somehow being presented to the current connection).\n\
    \   o  Setting the beginning RMBE eye catcher.  This eye catcher plays an\n  \
    \    important role in helping detect accidental overlays of the RMBE.\n     \
    \ The RMB owner should always validate these eye catchers before\n      each new\
    \ reference to the RMBE.  If the eye catchers are found to\n      be corrupted,\
    \ the local host must reset the TCP connection\n      associated with this RMBE\
    \ and log the appropriate diagnostic\n      information.\n"
- title: 4.4.2.  RMB Element Reuse and Conflict Resolution
  contents:
  - "4.4.2.  RMB Element Reuse and Conflict Resolution\n   RMB elements can be reused\
    \ once their associated TCP and SMC-R\n   connections are terminated.  Under normal\
    \ and abnormal SMC-R\n   connection termination processing, both SMC-R peers must\
    \ explicitly\n   acknowledge that they are done using an RMBE before that element\
    \ can\n   be freed and reassigned to another SMC-R connection instance.  For\n\
    \   more details on SMC-R connection termination, refer to Section 4.8.\n   However,\
    \ there are some error scenarios where this two-way explicit\n   acknowledgment\
    \ may not be completed.  In these scenarios, an RMBE\n   owner may choose to reassign\
    \ this RMBE to a new SMC-R connection\n   instance on this SMC-R link group. \
    \ When this occurs, the partner\n   SMC-R peer must detect this condition during\
    \ SMC-R Rendezvous\n   processing when presented with an RMBE that it believes\
    \ is already in\n   use for a different SMC-R connection.  In this case, the SMC-R\
    \ peer\n   must abort the existing SMC-R connection associated with this RMBE.\n\
    \   The abort processing resets the TCP connection (if it is still\n   active),\
    \ but it must not attempt to perform any RDMA writes to this\n   RMBE and must\
    \ also ignore any data sitting in the local RMBE\n   associated with the existing\
    \ connection.  It then proceeds to free up\n   the local RMBE and notify the local\
    \ application that the connection\n   is being abnormally reset.\n   The remote\
    \ SMC-R peer then proceeds to normal processing for this new\n   SMC-R connection.\n"
- title: 4.5.  SMC-R Protocol Considerations
  contents:
  - "4.5.  SMC-R Protocol Considerations\n   The following sections describe considerations\
    \ for the SMC-R protocol\n   as compared to TCP.\n"
- title: 4.5.1.  SMC-R Protocol Optimized Window Size Updates
  contents:
  - "4.5.1.  SMC-R Protocol Optimized Window Size Updates\n   An SMC-R receiver host\
    \ sends its consumer cursor information to the\n   sender to convey the progress\
    \ that the receiving application has made\n   in consuming the sent data.  The\
    \ difference between the writer's\n   producer cursor and the associated receiver's\
    \ consumer cursor\n   indicates the window size available for the sender to write\
    \ into.\n   This is somewhat similar to TCP window update processing and\n   therefore\
    \ has some similar considerations, such as silly window\n   syndrome avoidance,\
    \ whereby TCP has an optimization that minimizes\n   the overhead of very small,\
    \ unproductive window size updates\n   associated with suboptimal socket applications\
    \ consuming very small\n   amounts of data on every receive() invocation.  For\
    \ SMC-R, the\n   receiver only updates its consumer cursor via a unique CDC message\n\
    \   under the following conditions:\n   o  The current window size (from a sender's\
    \ perspective) is less than\n      half of the receive buffer space, and the consumer\
    \ cursor update\n      will result in a minimum increase in the window size of\
    \ 10% of the\n      receive buffer space.  Some examples:\n      a. Receive buffer\
    \ size: 64K, current window size (from a sender's\n         perspective): 50K.\
    \  No need to update the consumer cursor.\n         Plenty of space is available\
    \ for the sender.\n      b. Receive buffer size: 64K, current window size (from\
    \ a sender's\n         perspective): 30K, current window size from a receiver's\n\
    \         perspective: 31K.  No need to update the consumer cursor; even\n   \
    \      though the sender's window size is < 1/2 of the 64K, the window\n     \
    \    update would only increase that by 1K, which is < 1/10th of the\n       \
    \  64K buffer size.\n      c. Receive buffer size: 64K, current window size (from\
    \ a sender's\n         perspective): 30K, current window size from a receiver's\n\
    \         perspective: 64K.  The receiver updates the consumer cursor\n      \
    \   (sender's window size is < 1/2 of the 64K; the window update\n         would\
    \ increase that by > 6.4K).\n   o  The receiver must always include a consumer\
    \ cursor update whenever\n      it sends a CDC message to the partner for another\
    \ flow (i.e., send\n      flow in the opposite direction).  This allows the window\
    \ size\n      update to be delivered with no additional overhead.  This is\n \
    \     somewhat similar to TCP DelayAck processing and quite effective\n      for\
    \ request/response data patterns.\n   o  If a peer has set the B-bit in a CDC\
    \ message, then any consumption\n      of data by the receiver causes a CDC message\
    \ to be sent, updating\n      the consumer cursor until a CDC message with that\
    \ bit cleared is\n      received from the peer.\n   o  The optimized window size\
    \ updates are overridden when the sender\n      sets the Consumer Cursor Update\
    \ Requested flag in a CDC message to\n      the receiver.  When this indicator\
    \ is on, the consumer must send a\n      consumer cursor update immediately when\
    \ data is consumed by the\n      local application or if the cursor has not been\
    \ updated for a\n      while (i.e., local copy of the consumer cursor does not\
    \ match the\n      last consumer cursor value sent to the partner).  This allows\
    \ the\n      sender to perform optional diagnostics for detecting a stalled\n\
    \      receiver application (data has been sent but not consumed).  It is\n  \
    \    recommended that the Consumer Cursor Update Requested flag only be\n    \
    \  sent for diagnostic procedures, as it may result in non-optimal\n      data\
    \ path performance.\n"
- title: 4.5.2.  Small Data Sends
  contents:
  - "4.5.2.  Small Data Sends\n   The SMC-R protocol makes no special provisions for\
    \ handling small\n   data segments sent across a stream socket.  Data is always\
    \ sent if\n   sufficient window space is available.  In contrast to the TCP Nagle\n\
    \   algorithm, there are no special provisions in SMC-R for coalescing\n   small\
    \ data segments.\n   An implementation of SMC-R can be configured to optimize\
    \ its sending\n   processing by coalescing outbound data for a given SMC-R connection\n\
    \   so that it can reduce the number of RDMA write operations it\n   performs,\
    \ in a fashion similar to Nagle's algorithm.  However, any\n   such coalescing\
    \ would require a timer on the sending host that would\n   ensure that data was\
    \ eventually sent.  Also, the sending host would\n   have to opt out of this processing\
    \ if Nagle's algorithm had been\n   disabled (programmatically or via system configuration).\n"
- title: 4.5.3.  TCP Keepalive Processing
  contents:
  - "4.5.3.  TCP Keepalive Processing\n   TCP keepalive processing allows applications\
    \ to direct the local\n   TCP/IP host to periodically \"test\" the viability of\
    \ an idle TCP\n   connection.  Since SMC-R connections have a TCP representation\
    \ along\n   with an SMC-R representation, there are unique keepalive processing\n\
    \   considerations:\n   o  SMC-R-layer keepalive processing: If keepalive is enabled\
    \ for an\n      SMC-R connection, the local host maintains a keepalive timer that\n\
    \      reflects how long an SMC-R connection has been idle.  The local\n     \
    \ host also maintains a timestamp of last activity for each SMC-R\n      link\
    \ (for any SMC-R connection on that link).  When it is\n      determined that\
    \ an SMC-R connection has been idle longer than the\n      keepalive interval,\
    \ the host checks to see whether or not the\n      SMC-R link has been idle for\
    \ a duration longer than the keepalive\n      timeout.  If both conditions are\
    \ met, the local host then performs\n      a TEST LINK LLC command to test the\
    \ viability of the SMC-R link\n      over the RoCE fabric (RC-QPs).  If a TEST\
    \ LINK LLC command\n      response is received within a reasonable amount of time,\
    \ then the\n      link is considered viable, and all connections using this link\
    \ are\n      considered viable as well.  If, however, a response is not\n    \
    \  received in a reasonable amount of time or there's a failure in\n      sending\
    \ the TEST LINK LLC command, then this is considered a\n      failure in the SMC-R\
    \ link, and failover processing to an alternate\n      SMC-R link must be triggered.\
    \  If no alternate SMC-R link exists\n      in the SMC-R link group, then all\
    \ of the SMC-R connections on this\n      link are abnormally terminated by resetting\
    \ the TCP connections\n      represented by these SMC-R connections.  Given that\
    \ multiple SMC-R\n      connections can share the same SMC-R link, implementing\
    \ an SMC-R\n      link-level probe using the TEST LINK LLC command will help reduce\n\
    \      the amount of unproductive keepalive traffic for SMC-R\n      connections;\
    \ as long as some SMC-R connections on a given SMC-R\n      link are active (i.e.,\
    \ have had I/O activity within the keepalive\n      interval), then there is no\
    \ need to perform additional link\n      viability testing.\n   o  TCP-layer keepalive\
    \ processing: Traditional TCP \"keepalive\"\n      packets are not as relevant\
    \ for SMC-R connections, given that the\n      TCP path is not used for these\
    \ connections once the SMC-R\n      Rendezvous processing is completed.  All SMC-R\
    \ connections by\n      default have associated TCP connections that are idle.\
    \  Are TCP\n      keepalive probes still needed for these connections?  There\
    \ are\n      two main scenarios to consider:\n      1. TCP keepalives that are\
    \ used to determine whether or not the\n         peer TCP endpoint is still active.\
    \  This is not needed for\n         SMC-R connections, as the SMC-R-level keepalives\
    \ mentioned\n         above will determine whether or not the remote endpoint\n\
    \         connections are still active.\n      2. TCP keepalives that are used\
    \ to ensure that TCP connections\n         traversing an intermediate proxy maintain\
    \ an active state.  For\n         example, stateful firewalls typically maintain\
    \ state\n         representing every valid TCP connection that traverses the\n\
    \         firewall.  These types of firewalls are known to expire idle\n     \
    \    connections by removing their state in the firewall to conserve\n       \
    \  memory.  TCP keepalives are often used in this scenario to\n         prevent\
    \ firewalls from timing out otherwise idle connections.\n         When using SMC-R,\
    \ both endpoints must reside in the same\n         Layer 2 network (i.e., the\
    \ same subnet).  As a result,\n         firewalls cannot be injected in the path\
    \ between two SMC-R\n         endpoints.  However, other intermediate proxies,\
    \ such as\n         TCP/IP-layer load balancers, may be injected in the path of\
    \ two\n         SMC-R endpoints.  These types of load balancers also maintain\n\
    \         connection state so that they can forward TCP connection\n         traffic\
    \ to the appropriate cluster endpoint.  When using SMC-R,\n         these TCP\
    \ connections will appear to be completely idle, making\n         them susceptible\
    \ to potential timeouts at the load-balancing\n         proxy.  As a result, for\
    \ this scenario, TCP keepalives may\n         still be relevant.\n   The following\
    \ are the TCP-level keepalive processing requirements for\n   SMC-R-enabled hosts:\n\
    \   o  SMC-R peers should allow TCP keepalives to flow on the TCP path of\n  \
    \    SMC-R connections based on existing TCP keepalive configuration\n      and\
    \ programming options.  However, it is strongly recommended that\n      platforms\
    \ provide the ability to specify very granular keepalive\n      timers (for example,\
    \ single-digit-second timers) and should\n      consider providing a configuration\
    \ option that limits the minimum\n      keepalive timer that will be used for\
    \ TCP-layer keepalives on\n      SMC-R connections.  This is important to minimize\
    \ the amount of\n      TCP keepalive packets transmitted in the network for SMC-R\n\
    \      connections.\n   o  SMC-R peers must always respond to inbound TCP-layer\
    \ keepalives\n      (by sending ACKs for these packets) even if the connection\
    \ is\n      using SMC-R.  Typically, once a TCP connection has completed the\n\
    \      SMC-R Rendezvous processing and is using SMC-R for data flows, no\n   \
    \   new inbound TCP segments are expected on that TCP connection,\n      other\
    \ than TCP termination segments (FIN, RST, etc.).  TCP\n      keepalives are the\
    \ one exception that must be supported.  Also,\n      since TCP keepalive probes\
    \ do not carry any application-layer\n      data, this has no adverse impact on\
    \ the application's inbound data\n      stream.\n"
- title: 4.6.  TCP Connection Failover between SMC-R Links
  contents:
  - "4.6.  TCP Connection Failover between SMC-R Links\n   A peer may change which\
    \ SMC-R link within a link group it sends its\n   writes over in the event of\
    \ a link failure.  Since each peer\n   independently chooses which link to send\
    \ writes over for a specific\n   TCP connection, this process is done independently\
    \ by each peer.\n"
- title: 4.6.1.  Validating Data Integrity
  contents:
  - "4.6.1.  Validating Data Integrity\n   Even though RoCE is a reliable transport,\
    \ there is a small subset of\n   failure modes that could cause unrecoverable\
    \ loss of data.  When an\n   RNIC acknowledges receipt of an RDMA write to its\
    \ peer, that creates\n   a write completion event to the sending peer, which allows\
    \ the sender\n   to release any buffers it is holding for that write.  In normal\n\
    \   operation and in most failures, this operation is reliable.\n   However, there\
    \ are failure modes possible in which a receiving RNIC\n   has acknowledged an\
    \ RDMA write but then was not able to place the\n   received data into its host\
    \ memory -- for example, a sudden,\n   disorderly failure of the interface between\
    \ the RNIC and the host.\n   While rare, these types of events must be guarded\
    \ against to ensure\n   data integrity.  The process for switching SMC-R links\
    \ during\n   failover, as described in this section, guards against this\n   possibility\
    \ and is mandatory.\n   Each peer must track the current state of the CDC sequence\
    \ numbers\n   for a TCP connection.  The sender must keep track of the sequence\n\
    \   number of the CDC message that described the last write acknowledged\n   by\
    \ the peer RNIC, or Sequence Sent (SS).  In other words, SS\n   describes the\
    \ last write that the sender believes its peer has\n   successfully received.\
    \  The receiver must keep track of the sequence\n   number of the CDC message\
    \ that described the last write that it has\n   successfully received (i.e., the\
    \ data has been successfully placed\n   into an RMBE), or Sequence Received (SR).\n\
    \   When an RNIC fails and the sender changes SMC-R links, the sender\n   must\
    \ first send a CDC message with the F-bit (failover validation\n   indicator;\
    \ see Appendix A.4) set over the new SMC-R link.  This is\n   the failover data\
    \ validation message.  The sequence number in this\n   CDC message is equal to\
    \ SS.  The CDC message key, the length, and the\n   SMC-R alert token are the\
    \ only other fields in this CDC message that\n   are significant.  No reply is\
    \ expected from this validation message,\n   and once the sender has sent it,\
    \ the sender may resume sending on the\n   new SMC-R link as described in Section\
    \ 4.6.2.\n   Upon receipt of the failover validation message, the receiver must\n\
    \   verify that its SR value for the TCP connection is equal to or\n   greater\
    \ than the sequence number in the failover validation message.\n   If so, no further\
    \ action is required, and the TCP connection resumes\n   on the new SMC-R link.\
    \  If SR is less than the sequence number value\n   in the validation message,\
    \ data has been lost, and the receiver must\n   immediately reset the TCP connection.\n"
- title: 4.6.2.  Resuming the TCP Connection on a New SMC-R Link
  contents:
  - "4.6.2.  Resuming the TCP Connection on a New SMC-R Link\n   When a connection\
    \ is moved to a new SMC-R link and the failover\n   validation message has been\
    \ sent, the sender can immediately resume\n   normal transmission.  In order to\
    \ preserve the application message\n   stream, the sender must replay any RDMA\
    \ writes (and their associated\n   CDC messages) that were in progress or failed\
    \ when the previous SMC-R\n   link failed, before sending new data on the new\
    \ SMC-R link.  The\n   sender has two options for accomplishing this:\n   o  Preserve\
    \ the sequence numbers \"as is\": Retry all failed and\n      pending operations\
    \ as they were originally done, including\n      reposting all associated RDMA\
    \ write operations and their\n      associated CDC messages without making any\
    \ changes.  Then resume\n      sending new data using new sequence numbers.\n\
    \   o  Combine pending messages and possibly add new data: Combine failed\n  \
    \    and pending messages into a single new write with a new sequence\n      number.\
    \  This allows the sender to combine pending messages into\n      fewer operations.\
    \  As a further optimization, this write can also\n      include new data, as\
    \ long as all failed and pending data are also\n      included.  If this approach\
    \ is taken, the sequence number must be\n      increased beyond the last failed\
    \ or pending sequence number.\n"
- title: 4.7.  RMB Data Flows
  contents:
  - "4.7.  RMB Data Flows\n   The following sections describe the RDMA wire flows\
    \ for the SMC-R\n   protocol after a TCP connection has switched into SMC-R mode\
    \ (i.e.,\n   SMC-R Rendezvous processing is complete and a pair of RMB elements\n\
    \   has been assigned and communicated by the SMC-R peers).  The ladder\n   diagrams\
    \ below include the following:\n   o  RMBE control information kept by each peer.\
    \  Only a subset of the\n      information is depicted, specifically only the\
    \ fields that reflect\n      the stream of data written by Host A and read by\
    \ Host B.\n   o  Time line 0-x, which shows the wire flows in a time-relative\n\
    \      fashion.\n   o  Note that RMBE control information is only shown in a time\n\
    \      interval if its value changed (otherwise, assume that the value is\n  \
    \    unchanged from the previously depicted value).\n   o  The local copy of the\
    \ producer cursors and consumer cursors that\n      is maintained by each host\
    \ is not depicted in these figures.  Note\n      that the cursor values in the\
    \ diagram reflect the necessity of\n      skipping over the eye catcher in the\
    \ RMBE data area.  They start\n      and wrap at 4, not 0.\n"
- title: '4.7.1.  Scenario 1: Send Flow, Window Size Unconstrained'
  contents:
  - "4.7.1.  Scenario 1: Send Flow, Window Size Unconstrained\n            SMC Host\
    \ A                             SMC Host B\n           RMBE A Info           \
    \                 RMBE B Info\n       (Consumer Cursors)                     \
    \ (Producer Cursors)\n   Cursor   Wrap Seq# Time               Time Cursor   Wrap\
    \ Seq#  Flags\n   4        0         0                  0    4        0      \
    \    0\n   0        0         1 ---------------> 1    0        0          0\n\
    \                        RDMA-WR Data\n                          (4:1003)\n  \
    \ 4        0         2 ...............> 2    1004     0          0\n         \
    \               CDC Message\n        Figure 16: Scenario 1: Send Flow, Window\
    \ Size Unconstrained\n   Scenario assumptions:\n   o  Kernel implementation.\n\
    \   o  New SMC-R connection; no data has been sent on the connection.\n   o  Host\
    \ A: Application issues send for 1000 bytes to Host B.\n   o  Host B: RMBE receive\
    \ buffer size is 10,000; application has issued\n      a recv for 10,000 bytes.\n\
    \   Flow description:\n   1. The application issues a send() for 1000 bytes; the\
    \ SMC-R layer\n      copies data into a kernel send buffer.  It then schedules\
    \ an RDMA\n      write operation to move the data into the peer's RMBE receive\n\
    \      buffer, at relative position 4-1003 (to skip the 4-byte\n      eye catcher\
    \ in the RMBE data area).  Note that no immediate data\n      or alert (i.e.,\
    \ interrupt) is provided to Host B for this RDMA\n      operation.\n   2. Host\
    \ A sends a CDC message to update the producer cursor to\n      byte 1004.  This\
    \ CDC message will deliver an interrupt to Host B.\n      At this point, the SMC-R\
    \ layer can return control back to the\n      application.  Host B, once notified\
    \ of the completion of the\n      previous RDMA operation, locates the RMBE associated\
    \ with the RMBE\n      alert token that was included in the message and proceeds\
    \ to\n      perform normal receive-side processing, waking up the suspended\n\
    \      application read thread, copying the data into the application's\n    \
    \  receive buffer, etc.  It will use the producer cursor as an\n      indicator\
    \ of how much data is available to be delivered to the\n      local application.\
    \  After this processing is complete, the SMC-R\n      layer will also update\
    \ its local consumer cursor to match the\n      producer cursor (i.e., indicating\
    \ that all data has been\n      consumed).  Note that a message to the peer updating\
    \ the consumer\n      cursor is not needed at this time, as the window size is\n\
    \      unconstrained (> 1/2 of the receive buffer size).  The window size\n  \
    \    is calculated by taking the difference between the producer cursor\n    \
    \  and the consumer cursor in the RMBEs (10,000 - 1004 = 8996).\n"
- title: '4.7.2.  Scenario 2: Send/Receive Flow, Window Size Unconstrained'
  contents:
  - "4.7.2.  Scenario 2: Send/Receive Flow, Window Size Unconstrained\n          \
    \   SMC Host A                             SMC Host B\n            RMBE A Info\
    \                            RMBE B Info\n        (Consumer Cursors)         \
    \             (Producer Cursors)\n    Cursor   Wrap Seq# Time               Time\
    \ Cursor   Wrap Seq#  Flags\n    4        0         0                  0    4\
    \        0          0\n    0        0         1 ---------------> 1    0      \
    \  0          0\n                         RDMA-WR Data\n                     \
    \      (4:1003)\n    4        0         2 ...............> 2    1004     0   \
    \       0\n                         CDC Message\n    0        0         3 <--------------\
    \  3    1004     0          0\n                         RDMA-WR Data\n       \
    \                    (4:503)\n    1004     0         4 <..............  4    1004\
    \     0          0\n                          CDC Message\n    Figure 17: Scenario\
    \ 2: Send/Receive Flow, Window Size Unconstrained\n   Scenario assumptions:\n\
    \   o  New SMC-R connection; no data has been sent on the connection.\n   o  Host\
    \ A: Application issues send for 1000 bytes to Host B.\n   o  Host B: RMBE receive\
    \ buffer size is 10,000; application has\n      already issued a recv for 10,000\
    \ bytes.  Once the receive is\n      completed, the application sends a 500-byte\
    \ response to Host A.\n   Flow description:\n   1. The application issues a send()\
    \ for 1000 bytes; the SMC-R layer\n      copies data into a kernel send buffer.\
    \  It then schedules an RDMA\n      write operation to move the data into the\
    \ peer's RMBE receive\n      buffer, at relative position 4-1003.  Note that no\
    \ immediate data\n      or alert (i.e., interrupt) is provided to Host B for this\
    \ RDMA\n      operation.\n   2. Host A sends a CDC message to update the producer\
    \ cursor to\n      byte 1004.  This CDC message will deliver an interrupt to Host\
    \ B.\n      At this point, the SMC-R layer can return control back to the\n  \
    \    application.\n   3. Host B, once notified of the receipt of the previous\
    \ CDC message,\n      locates the RMBE associated with the RMBE alert token and\
    \ proceeds\n      to perform normal receive-side processing, waking up the suspended\n\
    \      application read thread, copying the data into the application's\n    \
    \  receive buffer, etc.  After this processing is complete, the SMC-R\n      layer\
    \ will also update its local consumer cursor to match the\n      producer cursor\
    \ (i.e., indicating that all data has been\n      consumed).  Note that an update\
    \ of the consumer cursor to the peer\n      is not needed at this time, as the\
    \ window size is unconstrained\n      (> 1/2 of the receive buffer size).  The\
    \ application then performs\n      a send() for 500 bytes to Host A.  The SMC-R\
    \ layer will copy the\n      data into a kernel buffer and then schedule an RDMA\
    \ write into the\n      partner's RMBE receive buffer.  Note that this RDMA write\n\
    \      operation includes no immediate data or notification to Host A.\n   4.\
    \ Host B sends a CDC message to update the partner's RMBE control\n      information\
    \ with the latest producer cursor (set to 503 and not\n      shown in the diagram\
    \ above) and to also inform the peer that the\n      consumer cursor value is\
    \ now 1004.  It also updates the local\n      current consumer cursor and the\
    \ last sent consumer cursor to 1004.\n      This CDC message includes notification,\
    \ since we are updating our\n      producer cursor; this requires attention by\
    \ the peer host.\n"
- title: '4.7.3.  Scenario 3: Send Flow, Window Size Constrained'
  contents:
  - "4.7.3.  Scenario 3: Send Flow, Window Size Constrained\n             SMC Host\
    \ A                             SMC Host B\n            RMBE A Info          \
    \                  RMBE B Info\n        (Consumer Cursors)                   \
    \   (Producer Cursors)\n    Cursor   Wrap Seq# Time               Time Cursor\
    \   Wrap Seq#  Flags\n    4        0         0                  0    4       \
    \ 0          0\n    4        0         1 ---------------> 1    4        0    \
    \      0\n                         RDMA-WR Data\n                           (4:3003)\n\
    \    4        0         2 ...............> 2    3004     0          0\n      \
    \                   CDC Message\n    4        0         3                  3 \
    \   3004     0          0\n    4        0         4 ---------------> 4    3004\
    \     0          0\n                         RDMA-WR Data\n                  \
    \         (3004:7003)\n    4        0         5 ................> 5   7004   \
    \  0          0\n                         CDC Message\n    7004     0        \
    \ 6 <................ 6   7004     0          0\n                         CDC\
    \ Message\n         Figure 18: Scenario 3: Send Flow, Window Size Constrained\n\
    \   Scenario assumptions:\n   o  New SMC-R connection; no data has been sent on\
    \ this connection.\n   o  Host A: Application issues send for 3000 bytes to Host\
    \ B and then\n      another send for 4000 bytes.\n   o  Host B: RMBE receive buffer\
    \ size is 10,000.  Application has\n      already issued a recv for 10,000 bytes.\n\
    \   Flow description:\n   1. The application issues a send() for 3000 bytes; the\
    \ SMC-R layer\n      copies data into a kernel send buffer.  It then schedules\
    \ an RDMA\n      write operation to move the data into the peer's RMBE receive\n\
    \      buffer, at relative position 4-3003.  Note that no immediate data\n   \
    \   or alert (i.e., interrupt) is provided to Host B for this RDMA\n      operation.\n\
    \   2. Host A sends a CDC message to update its producer cursor to\n      byte\
    \ 3003.  This CDC message will deliver an interrupt to Host B.\n      At this\
    \ point, the SMC-R layer can return control back to the\n      application.\n\
    \   3. Host B, once notified of the receipt of the previous CDC message,\n   \
    \   locates the RMBE associated with the RMBE alert token and proceeds\n     \
    \ to perform normal receive-side processing, waking up the suspended\n      application\
    \ read thread, copying the data into the application's\n      receive buffer,\
    \ etc.  After this processing is complete, the SMC-R\n      layer will also update\
    \ its local consumer cursor to match the\n      producer cursor (i.e., indicating\
    \ that all data has been\n      consumed).  It will not, however, update the partner\
    \ with this\n      information, as the window size is not constrained\n      (10,000\
    \ - 3000 = 7000 bytes of available space).  The application\n      on Host B also\
    \ issues a new recv() for 10,000 bytes.\n   4. On Host A, the application issues\
    \ a send() for 4000 bytes.  The\n      SMC-R layer copies the data into a kernel\
    \ buffer and schedules an\n      async RDMA write into the peer's RMBE receive\
    \ buffer at relative\n      position 3003-7004.  Note that no alert is provided\
    \ to Host B for\n      this flow.\n   5. Host A sends a CDC message to update\
    \ the producer cursor to\n      byte 7004.  This CDC message will deliver an interrupt\
    \ to Host B.\n      At this point, the SMC-R layer can return control back to\
    \ the\n      application.\n   6. Host B, once notified of the receipt of the previous\
    \ CDC message,\n      locates the RMBE associated with the RMBE alert token and\
    \ proceeds\n      to perform normal receive-side processing, waking up the suspended\n\
    \      application read thread, copying the data into the application's\n    \
    \  receive buffer, etc.  After this processing is complete, the SMC-R\n      layer\
    \ will also update its local consumer cursor to match the\n      producer cursor\
    \ (i.e., indicating that all data has been\n      consumed).  It will then determine\
    \ whether or not it needs to\n      update the consumer cursor to the peer.  The\
    \ available window size\n      is now 3000 (10,000 - (producer cursor - last sent\
    \ consumer\n      cursor)), which is < 1/2 of the receive buffer size\n      (10,000/2\
    \ = 5000), and the advance of the window size is > 10% of\n      the window size\
    \ (1000).  Therefore, a CDC message is issued to\n      update the consumer cursor\
    \ to Peer A.\n"
- title: '4.7.4.  Scenario 4: Large Send, Flow Control, Full Window Size Writes'
  contents:
  - "4.7.4.  Scenario 4: Large Send, Flow Control, Full Window Size Writes\n     \
    \        SMC Host A                             SMC Host B\n            RMBE A\
    \ Info                            RMBE B Info\n        (Consumer Cursors)    \
    \                  (Producer Cursors)\n    Cursor   Wrap Seq# Time           \
    \    Time Cursor   Wrap Seq#  Flags\n    1004     1         0                \
    \  0    1004     1          0\n    1004     1         1 ---------------> 1   \
    \ 1004     1          0\n                         RDMA-WR Data\n             \
    \              (1004:9999)\n    1004     1         2 ---------------> 2    1004\
    \     1          0\n                         RDMA-WR Data\n                  \
    \         (4:1003)\n    1004     1         3 ...............> 3    1004     2\
    \          Wrt\n                         CDC Message                         \
    \      Blk\n    1004     2         4 <............... 4    1004     2        \
    \  Wrt\n                         CDC Message                               Blk\n\
    \    1004     2         5 ---------------> 5    1004     2          Wrt\n    \
    \                     RDMA-WR Data                              Blk\n        \
    \                   (1004:9999)\n    1004     2         6 ---------------> 6 \
    \   1004     2          Wrt\n                         RDMA-WR Data           \
    \                   Blk\n                          (4:1003)\n    1004     2  \
    \       7 ...............> 7    1004     3          Wrt\n                    \
    \     CDC Message                               Blk\n    1004     3         8\
    \ <............... 8    1004     3          Wrt\n                         CDC\
    \ Message                               Blk\n             Figure 19: Scenario\
    \ 4: Large Send, Flow Control,\n                          Full Window Size Writes\n\
    \   Scenario assumptions:\n   o  Kernel implementation.\n   o  Existing SMC-R\
    \ connection, Host B's receive window size is fully\n      open (peer consumer\
    \ cursor = peer producer cursor).\n   o  Host A: Application issues send for 20,000\
    \ bytes to Host B.\n   o  Host B: RMBE receive buffer size is 10,000; application\
    \ has issued\n      a recv for 10,000 bytes.\n   Flow description:\n   1. The\
    \ application issues a send() for 20,000 bytes; the SMC-R layer\n      copies\
    \ data into a kernel send buffer (assumes that send buffer\n      space of 20,000\
    \ is available for this connection).  It then\n      schedules an RDMA write operation\
    \ to move the data into the peer's\n      RMBE receive buffer, at relative position\
    \ 1004-9999.  Note that no\n      immediate data or alert (i.e., interrupt) is\
    \ provided to Host B\n      for this RDMA operation.\n   2. Host A then schedules\
    \ an RDMA write operation to fill the\n      remaining 1000 bytes of available\
    \ space in the peer's RMBE receive\n      buffer, at relative position 4-1003.\
    \  Note that no immediate data\n      or alert (i.e., interrupt) is provided to\
    \ Host B for this RDMA\n      operation.  Also note that an implementation of\
    \ SMC-R may optimize\n      this processing by combining steps 1 and 2 into a\
    \ single\n      RDMA write operation (with two different data sources).\n   3.\
    \ Host A sends a CDC message to update the producer cursor to\n      byte 1004.\
    \  Since the entire receive buffer space is filled, the\n      producer writer\
    \ blocked flag (the \"Wrt Blk\" indicator (flag) in\n      Figure 19) is set and\
    \ the producer cursor wrap sequence number\n      (the producer \"Wrap Seq#\"\
    \ in Figure 19) is incremented.  This CDC\n      message will deliver an interrupt\
    \ to Host B.  At this point, the\n      SMC-R layer can return control back to\
    \ the application.\n   4. Host B, once notified of the receipt of the previous\
    \ CDC message,\n      locates the RMBE associated with the RMBE alert token and\
    \ proceeds\n      to perform normal receive-side processing, waking up the suspended\n\
    \      application read thread, copying the data into the application's\n    \
    \  receive buffer, etc.  In this scenario, Host B notices that the\n      producer\
    \ cursor has not been advanced (same value as the consumer\n      cursor); however,\
    \ it notices that the producer cursor wrap\n      sequence number is different\
    \ from its local value (1), indicating\n      that a full window of new data is\
    \ available.  All of the data in\n      the receive buffer can be processed, with\
    \ the first segment\n      (1004-9999) followed by the second segment (4-1003).\
    \  Because the\n      producer writer blocked indicator was set, Host B schedules\
    \ a CDC\n      message to update its latest information to the peer: consumer\n\
    \      cursor (1004), consumer cursor wrap sequence number (the current\n    \
    \  value of 2 is used).\n   5. Host A, upon receipt of the CDC message, locates\
    \ the TCP\n      connection associated with the alert token and, upon examining\
    \ the\n      control information provided, notices that Host B has consumed all\n\
    \      of the data (based on the consumer cursor and the consumer cursor\n   \
    \   wrap sequence number) and initiates the next RDMA write to fill\n      the\
    \ receive buffer at offset 1003-9999.\n   6. Host A then moves the next 1000 bytes\
    \ into the beginning of the\n      receive buffer (4-1003) by scheduling an RDMA\
    \ write operation.\n      Note that at this point there are still 8 bytes remaining\
    \ to be\n      written.\n   7. Host A then sends a CDC message to set the producer\
    \ writer blocked\n      indicator and to increment the producer cursor wrap sequence\n\
    \      number (3).\n   8. Host B, upon notification, completes the same processing\
    \ as step 4\n      above, including sending a CDC message to update the peer to\n\
    \      indicate that all data has been consumed.  At this point, Host A\n    \
    \  can write the final 8 bytes to Host B's RMBE into\n      positions 1004-1011\
    \ (not shown).\n"
- title: '4.7.5.  Scenario 5: Send Flow, Urgent Data, Window Size Unconstrained'
  contents:
  - "4.7.5.  Scenario 5: Send Flow, Urgent Data, Window Size Unconstrained\n     \
    \        SMC Host A                             SMC Host B\n            RMBE A\
    \ Info                            RMBE B Info\n        (Consumer Cursors)    \
    \                  (Producer Cursors)\n    Cursor   Wrap Seq# Time           \
    \    Time Cursor   Wrap Seq#  Flag\n    1000     1         0                 \
    \ 0    1000     1          0\n    1000     1         1 ---------------> 1    1000\
    \     1          0\n                         RDMA-WR Data\n                  \
    \         (1000:1499)\n    1000     1         2 ...............> 2    1500   \
    \  1          UrgP\n                         CDC Message                     \
    \          UrgA\n    1500     1         3 <............... 3    1500     1   \
    \       UrgP\n                         CDC Message                           \
    \    UrgA\n    1500     1         4 ---------------> 4    1500     1         \
    \ UrgP\n                         RDMA-WR Data                              UrgA\n\
    \                           (1500:2499)\n    1500     1         5 ...............>\
    \ 5    2500     1          0\n                         CDC Message\n      Figure\
    \ 20: Scenario 5: Send Flow, Urgent Data, Window Size Open\n   Scenario assumptions:\n\
    \   o  Kernel implementation.\n   o  Existing SMC-R connection; window size open\
    \ (unconstrained); all\n      data has been consumed by receiver.\n   o  Host\
    \ A: Application issues send for 500 bytes with urgent data\n      indicator (out\
    \ of band) to Host B, then sends 1000 bytes of\n      normal data.\n   o  Host\
    \ B: RMBE receive buffer size is 10,000; application has issued\n      a recv\
    \ for 10,000 bytes and is also monitoring the socket for\n      urgent data.\n\
    \   Flow description:\n   1. The application issues a send() for 500 bytes of\
    \ urgent data; the\n      SMC-R layer copies data into a kernel send buffer. \
    \ It then\n      schedules an RDMA write operation to move the data into the peer's\n\
    \      RMBE receive buffer, at relative position 1000-1499.  Note that no\n  \
    \    immediate data or alert (i.e., interrupt) is provided to Host B\n      for\
    \ this RDMA operation.\n   2. Host A sends a CDC message to update its producer\
    \ cursor to\n      byte 1500 and to turn on the producer Urgent Data Pending (UrgP)\n\
    \      and Urgent Data Present (UrgA) flags.  This CDC message will\n      deliver\
    \ an interrupt to Host B.  At this point, the SMC-R layer\n      can return control\
    \ back to the application.\n   3. Host B, once notified of the receipt of the\
    \ previous CDC message,\n      locates the RMBE associated with the RMBE alert\
    \ token, notices\n      that the Urgent Data Pending flag is on, and proceeds\
    \ with out-of-\n      band socket API notification -- for example, satisfying\
    \ any\n      outstanding select() or poll() requests on the socket by\n      indicating\
    \ that urgent data is pending (i.e., by setting the\n      exception bit on).\
    \  The urgent data present indicator allows\n      Host B to also determine the\
    \ position of the urgent data (the\n      producer cursor points 1 byte beyond\
    \ the last byte of urgent\n      data).  Host B can then perform normal receive-side\
    \ processing\n      (including specific urgent data processing), copying the data\
    \ into\n      the application's receive buffer, etc.  Host B then sends a CDC\n\
    \      message to update the partner's RMBE control area with its latest\n   \
    \   consumer cursor (1500).  Note that this CDC message must occur,\n      regardless\
    \ of the current local window size that is available.\n      The partner host\
    \ (Host A) cannot initiate any additional RDMA\n      writes until it receives\
    \ acknowledgment that the urgent data has\n      been processed (or at least processed/remembered\
    \ at the SMC-R\n      layer).\n   4. Upon receipt of the message, Host A wakes\
    \ up, sees that the peer\n      consumed all data up to and including the last\
    \ byte of urgent\n      data, and now resumes sending any pending data.  In this\
    \ case, the\n      application had previously issued a send for 1000 bytes of\
    \ normal\n      data, which would have been copied in the send buffer, and control\n\
    \      would have been returned to the application.  Host A now initiates\n  \
    \    an RDMA write to move that data to the peer's receive buffer at\n      position\
    \ 1500-2499.\n   5. Host A then sends a CDC message to update its producer cursor\n\
    \      value (2500) and to turn off the Urgent Data Pending and Urgent\n     \
    \ Data Present flags.  Host B wakes up, processes the new data\n      (resumes\
    \ application, copies data into the application receive\n      buffer), and then\
    \ proceeds to update the local current consumer\n      cursor (2500).  Given that\
    \ the window size is unconstrained, there\n      is no need for a consumer cursor\
    \ update in the peer's RMBE.\n"
- title: '4.7.6.  Scenario 6: Send Flow, Urgent Data, Window Size Closed'
  contents:
  - "4.7.6.  Scenario 6: Send Flow, Urgent Data, Window Size Closed\n            \
    \ SMC Host A                             SMC Host B\n            RMBE A Info \
    \                           RMBE B Info\n        (Consumer Cursors)          \
    \            (Producer Cursors)\n    Cursor   Wrap Seq# Time               Time\
    \ Cursor   Wrap Seq#  Flag\n    1000     1         0                  0    1000\
    \     2          Wrt\n                                                       \
    \            Blk\n    1000     1         1 ...............> 1    1000     2  \
    \        Wrt\n                         CDC Message                           \
    \    Blk\n                                                                   UrgP\n\
    \    1000     2         2 <............... 2    1000     2          Wrt\n    \
    \                     CDC Message                               Blk\n        \
    \                                                           UrgP\n    1000   \
    \  2         3 ---------------> 3    1000     2          Wrt\n               \
    \          RDMA-WR Data                              Blk\n                   \
    \        (1000:1499)                             UrgP\n    1000     2        \
    \ 4 ...............> 4    1500     2          UrgP\n                         CDC\
    \ Message                               UrgA\n    1500     2         5 <...............\
    \ 5    1500     2          UrgP\n                         CDC Message        \
    \                       UrgA\n    1500     2         6 ---------------> 6    1500\
    \     2          UrgP\n                         RDMA-WR Data                 \
    \             UrgA\n                           (1500:2499)\n    1000     2   \
    \      7 ...............> 7    2500     2          0\n                       \
    \  CDC Message\n     Figure 21: Scenario 6: Send Flow, Urgent Data, Window Size\
    \ Closed\n   Scenario assumptions:\n   o  Kernel implementation.\n   o  Existing\
    \ SMC-R connection; window size closed; writer is blocked.\n   o  Host A: Application\
    \ issues send for 500 bytes with urgent data\n      indicator (out of band) to\
    \ Host B, then sends 1000 bytes of\n      normal data.\n   o  Host B: RMBE receive\
    \ buffer size is 10,000; application has no\n      outstanding recv() (for normal\
    \ data) and is monitoring the socket\n      for urgent data.\n   Flow description:\n\
    \   1. The application issues a send() for 500 bytes of urgent data; the\n   \
    \   SMC-R layer copies data into a kernel send buffer (if available).\n      Since\
    \ the writer is blocked (window size closed), it cannot send\n      the data immediately.\
    \  It then sends a CDC message to notify the\n      peer of the Urgent Data Pending\
    \ (UrgP) indicator (the writer\n      blocked indicator remains on as well). \
    \ This serves as a signal to\n      Host B that urgent data is pending in the\
    \ stream.  Control is also\n      returned to the application at this point.\n\
    \   2. Host B, once notified of the receipt of the previous CDC message,\n   \
    \   locates the RMBE associated with the RMBE alert token, notices\n      that\
    \ the Urgent Data Pending flag is on, and proceeds with out-of-\n      band socket\
    \ API notification -- for example, satisfying any\n      outstanding select()\
    \ or poll() requests on the socket by\n      indicating that urgent data is pending\
    \ (i.e., by setting the\n      exception bit on).  At this point, it is expected\
    \ that the\n      application will enter urgent data mode processing, expeditiously\n\
    \      processing all normal data (by issuing recv API calls) so that it\n   \
    \   can get to the urgent data byte.  Whether the application has this\n     \
    \ urgent mode processing or not, at some point, the application will\n      consume\
    \ some or all of the pending data in the receive buffer.\n      When this occurs,\
    \ Host B will also send a CDC message to update\n      its consumer cursor and\
    \ consumer cursor wrap sequence number to\n      the peer.  In the example above,\
    \ a full window's worth of data was\n      consumed.\n   3. Host A, once awakened\
    \ by the message, will notice that the window\n      size is now open on this\
    \ connection (based on the consumer cursor\n      and the consumer cursor wrap\
    \ sequence number, which now matches\n      the producer cursor wrap sequence\
    \ number) and resume sending of\n      the urgent data segment by scheduling an\
    \ RDMA write into relative\n      position 1000-1499.\n   4. Host A then sends\
    \ a CDC message to advance its producer cursor\n      (1500) and to also notify\
    \ Host B of the Urgent Data Present (UrgA)\n      indicator (and turn off the\
    \ writer blocked indicator).  This\n      signals to Host B that the urgent data\
    \ is now in the local receive\n      buffer and that the producer cursor points\
    \ to the last byte of\n      urgent data.\n   5. Host B wakes up, processes the\
    \ urgent data, and, once the urgent\n      data is consumed, sends a CDC message\
    \ to update its consumer\n      cursor (1500).\n   6. Host A wakes up, sees that\
    \ Host B has consumed the sequence number\n      associated with the urgent data,\
    \ and then initiates the next RDMA\n      write operation to move the 1000 bytes\
    \ associated with the next\n      send() of normal data into the peer's receive\
    \ buffer at\n      position 1500-2499.  Note that the send API would have likely\n\
    \      completed earlier in the process by copying the 1000 bytes into a\n   \
    \   send buffer and returning back to the application, even though we\n      could\
    \ not send any new data until the urgent data was processed\n      and acknowledged\
    \ by Host B.\n   7. Host A sends a CDC message to advance its producer cursor\
    \ to 2500\n      and to reset the Urgent Data Pending and Urgent Data Present\n\
    \      flags.  Host B wakes up and processes the inbound data.\n"
- title: 4.8.  Connection Termination
  contents:
  - "4.8.  Connection Termination\n   Just as SMC-R connections are established using\
    \ a combination of TCP\n   connection establishment flows and SMC-R protocol flows,\
    \ the\n   termination of SMC-R connections also uses a similar combination of\n\
    \   SMC-R protocol termination flows and normal TCP connection\n   termination\
    \ flows.  The following sections describe the SMC-R\n   protocol normal and abnormal\
    \ connection termination flows.\n"
- title: 4.8.1.  Normal SMC-R Connection Termination Flows
  contents:
  - "4.8.1.  Normal SMC-R Connection Termination Flows\n   Normal SMC-R connection\
    \ flows are triggered via the normal stream\n   socket API semantics, namely by\
    \ the application issuing a close() or\n   shutdown() API.  Most applications,\
    \ after consuming all incoming data\n   and after sending any outbound data, will\
    \ then issue a close() API to\n   indicate that they are done both sending and\
    \ receiving data.  Some\n   applications, typically a small percentage, make use\
    \ of the\n   shutdown() API that allows them to indicate that the application\
    \ is\n   done sending data, receiving data, or both sending and receiving\n  \
    \ data.  The main use of this API is scenarios where a TCP application\n   wants\
    \ to alert its partner endpoint that it is done sending data but\n   is still\
    \ receiving data on its socket (shutdown for write).  Issuing\n   shutdown() for\
    \ both sending and receiving data is really no different\n   than issuing a close()\
    \ and can therefore be treated in a similar\n   fashion.  Shutdown for read is\
    \ typically not a very useful operation\n   and in normal circumstances does not\
    \ trigger any network flows to\n   notify the partner TCP endpoint of this operation.\n\
    \   These same trigger points will be used by the SMC-R layer to initiate\n  \
    \ SMC-R connection termination flows.  The main design point for SMC-R\n   normal\
    \ connection flows is to use the SMC-R protocol to first shut\n   down the SMC-R\
    \ connection and free up any SMC-R RDMA resources, and\n   then allow the normal\
    \ TCP connection termination protocol (i.e., FIN\n   processing) to drive cleanup\
    \ of the TCP connection.  This design\n   point is very important in ensuring\
    \ that RDMA resources such as\n   the RMBEs are only freed and reused when both\
    \ SMC-R endpoints\n   are completely done with their RDMA write operations to\
    \ the\n   partner's RMBE.\n                                      1\n         \
    \                   +-----------------+\n            |-------------->|     CLOSED\
    \      |<-------------|\n        3D  |               |                 |     \
    \         |  4D\n            |               +-----------------+             \
    \ |\n            |                       |                        |\n        \
    \    |                     2 |                        |\n            |       \
    \                V                        |\n    +----------------+     +-----------------+\
    \     +----------------+\n    |AppFinCloseWait |     |     ACTIVE      |     |PeerFinCloseWait|\n\
    \    |                |     |                 |     |                |\n    +----------------+\
    \     +-----------------+     +----------------+\n            |              \
    \     |         |                   |\n            |     Active Close  | 3A |\
    \ 4A |  Passive Close    |\n            |                   V    |    V      \
    \             |\n            |       +--------------+ | +-------------+      \
    \  |\n            |--<----|PeerCloseWait1| | |AppCloseWait1|--->----|\n      \
    \  3C  |       |              | | |             |        |  4C\n            |\
    \       +--------------+ | +-------------+        |\n            |           \
    \  |          |         |              |\n            |             | 3B     \
    \  |     4B  |              |\n            |             V          |        \
    \ V              |\n            |       +--------------+ | +-------------+   \
    \     |\n            |--<----|PeerCloseWait2| | |AppCloseWait2|--->----|\n   \
    \                 |              | | |             |\n                    +--------------+\
    \ | +-------------+\n                                     |\n                \
    \                     |\n                    Figure 22: SMC-R Connection States\n\
    \   Figure 22 describes the states that an SMC-R connection typically\n   goes\
    \ through.  Note that there are variations to these states that\n   can occur\
    \ when an SMC-R connection is abnormally terminated, similar\n   in a way to when\
    \ a TCP connection is reset.  The following are the\n   high-level state transitions\
    \ for an SMC-R connection:\n   1. An SMC-R connection begins in the Closed state.\
    \  This state is\n      meant to reflect an RMBE that is not currently in use\
    \ (was\n      previously in use but no longer is, or was never allocated).\n \
    \  2. An SMC-R connection progresses to the Active state once the SMC-R\n    \
    \  Rendezvous processing has successfully completed, RMB element\n      indices\
    \ have been exchanged, and SMC-R links have been activated.\n      In this state,\
    \ the TCP connection is fully established, rendezvous\n      processing has been\
    \ completed, and SMC-R peers can begin the\n      exchange of data via RDMA.\n\
    \   3. Active close processing (on the SMC-R peer that is initiating the\n   \
    \   connection termination).\n      A. When an application on one of the SMC-R\
    \ connection peers issues\n         a close(), a shutdown() for write, or a shutdown()\
    \ for both\n         read and write, the SMC-R layer on that host will initiate\n\
    \         SMC-R connection termination processing.  First, if a close()\n    \
    \     or shutdown(both) is issued, it will check to see that there's\n       \
    \  no data in the local RMB element that has not been read by the\n         application.\
    \  If unread data is detected, the SMC-R connection\n         must be abnormally\
    \ reset; for more details on this, refer to\n         Section 4.8.2 (\"Abnormal\
    \ SMC-R Connection Termination Flows\").\n         If no unread data is pending,\
    \ it then checks to see whether or\n         not any outstanding data is waiting\
    \ to be written to the peer,\n         or if any outstanding RDMA writes for this\
    \ SMC-R connection\n         have not yet completed.  If either of these two scenarios\
    \ is\n         true, an indicator that this connection is in a pending close\n\
    \         state is saved in internal data structures representing this\n     \
    \    SMC-R connection, and control is returned to the application.\n         If\
    \ all data to be written to the partner has completed, this\n         peer will\
    \ send a CDC message to notify the peer of either the\n         PeerConnectionClosed\
    \ indicator (close or shutdown for both was\n         issued) or the PeerDoneWriting\
    \ indicator.  This will provide an\n         interrupt to inform that partner\
    \ SMC-R peer that the connection\n         is terminating.  At this point, the\
    \ local side of the SMC-R\n         connection transitions in the PeerCloseWait1\
    \ state, and control\n         can be returned to the application.  If this process\
    \ could not\n         be completed synchronously (the pending close condition\n\
    \         mentioned above), it is completed when all RDMA writes for data\n  \
    \       and control cursors have been completed.\n      B. At some point, the\
    \ SMC-R peer application (passive close) will\n         consume all incoming data,\
    \ realize that that partner is done\n         sending data on this connection,\
    \ and proceed to initiate its\n         own close of the connection once it has\
    \ completed sending all\n         data from its end.  The partner application\
    \ can initiate this\n         connection termination processing via close() or\
    \ shutdown()\n         APIs.  If the application does so by issuing a shutdown()\
    \ for\n         write, then the partner SMC-R layer will send a CDC message to\n\
    \         notify the peer (the active close side) of the PeerDoneWriting\n   \
    \      indicator.  When the \"active close\" SMC-R peer wakes up as a\n      \
    \   result of the previous CDC message, it will notice that the\n         PeerDoneWriting\
    \ indicator is now on and transition to the\n         PeerCloseWait2 state.  This\
    \ state indicates that the peer is\n         done sending data and may still be\
    \ reading data.  At this\n         point, the \"active close\" peer will also\
    \ need to ensure that\n         any outstanding recv() calls for this socket are\
    \ woken up and\n         remember that no more data is forthcoming on this connection\n\
    \         (in case the local connection was shutdown() for write only).\n    \
    \  C. This flow is a common transition from 3A or 3B above.  When the\n      \
    \   SMC-R peer (passive close) consumes all data and updates all\n         necessary\
    \ cursors to the peer, and the application closes its\n         socket (close\
    \ or shutdown for both), it will send a CDC message\n         to the peer (the\
    \ active close side) with the\n         PeerConnectionClosed indicator set.  At\
    \ this point, the\n         connection can transition back to the Closed state\
    \ if the local\n         application has already closed (or issued shutdown for\
    \ both)\n         the socket.  Once in the Closed state, the RMBE can now be\n\
    \         safely reused for a new SMC-R connection.  When the\n         PeerConnectionClosed\
    \ indicator is turned on, the SMC-R peer is\n         indicating that it is done\
    \ updating the partner's RMBE.\n      D. Conditional state: If the local application\
    \ has not yet issued\n         a close() or shutdown(both), we need to wait until\
    \ the\n         application does so.  Once it does, the local host will send a\n\
    \         CDC message to notify the peer of the PeerConnectionClosed\n       \
    \  indicator and then transition to the Closed state.\n   4. Passive close processing\
    \ (on the SMC-R peer that receives an\n      indication that the partner is closing\
    \ the connection).\n      A. Upon receipt of a CDC message, the SMC-R layer will\
    \ detect that\n         the PeerConnectionClosed indicator or PeerDoneWriting\
    \ indicator\n         is on.  If any outstanding recv() calls are pending, they\
    \ are\n         completed with an indicator that the partner has closed the\n\
    \         connection (zero-length data presented to the application).  If\n  \
    \       there is any pending data to be written and\n         PeerConnectionClosed\
    \ is on, then an SMC-R connection reset must\n         be performed.  The connection\
    \ then enters the AppCloseWait1\n         state on the passive close side waiting\
    \ for the local\n         application to initiate its own close processing.\n\
    \      B. If the local application issues a shutdown() for writing, then\n   \
    \      the SMC-R layer will send a CDC message to notify the partner\n       \
    \  of the PeerDoneWriting indicator and then transition the local\n         side\
    \ of the SMC-R connection to the AppCloseWait2 state.\n      C. When the application\
    \ issues a close() or shutdown() for both,\n         the local SMC-R peer will\
    \ send a message informing the peer of\n         the PeerConnectionClosed indicator\
    \ and transition to the Closed\n         state if the remote peer has also sent\
    \ the local peer the\n         PeerConnectionClosed indicator.  If the peer has\
    \ not sent the\n         PeerConnectionClosed indicator, we transition into the\n\
    \         PeerFinCloseWait state.\n      D. The local SMC-R connection stays in\
    \ this state until the peer\n         sends the PeerConnectionClosed indicator\
    \ in a CDC message.\n         When the indicator is sent, we transition to the\
    \ Closed state\n         and are then free to reuse this RMBE.\n   Note that each\
    \ SMC-R peer needs to provide some logic that will\n   prevent being stranded\
    \ in a termination state indefinitely.  For\n   example, if an Active Close SMC-R\
    \ peer is in a PeerCloseWait (1 or 2)\n   state waiting for the remote SMC-R peer\
    \ to update its connection\n   termination status, it needs to provide a timer\
    \ that will prevent it\n   from waiting in that state indefinitely should the\
    \ remote SMC-R peer\n   not respond to this termination request.  This could occur\
    \ in error\n   scenarios -- for example, if the remote SMC-R peer suffered a failure\n\
    \   prior to being able to respond to the termination request or the\n   remote\
    \ application is not responding to this connection termination\n   request by\
    \ closing its own socket.  This latter scenario is similar\n   to the TCP FINWAIT2\
    \ state, which has been known to sometimes cause\n   issues when remote TCP/IP\
    \ hosts lose track of established connections\n   and neglect to close them. \
    \ Even though the TCP standards do not\n   mandate a timeout from the TCP FINWAIT2\
    \ state, most TCP/IP\n   implementations assign a timeout for this state.  A similar\
    \ timeout\n   will be required for SMC-R connections.  When this timeout occurs,\n\
    \   the local SMC-R peer performs TCP reset processing for this\n   connection.\
    \  However, no additional RDMA writes to the partner RMBE\n   can occur at this\
    \ point (we have already indicated that we are done\n   updating the peer's RMBE).\
    \  After the TCP connection is reset, the\n   RMBE can be returned to the free\
    \ pool for reallocation.  See\n   Section 4.4.2 for more details.\n   Also note\
    \ that it is possible to have two SMC-R endpoints initiate an\n   Active close\
    \ concurrently.  In that scenario, the flows above still\n   apply; however, both\
    \ endpoints follow the active close path (path 3).\n"
- title: 4.8.2.  Abnormal SMC-R Connection Termination Flows
  contents:
  - "4.8.2.  Abnormal SMC-R Connection Termination Flows\n   Abnormal SMC-R connection\
    \ termination can occur for a variety of\n   reasons, including the following:\n\
    \   o  The TCP connection associated with an SMC-R connection is reset.\n    \
    \  In TCP, either endpoint can send a RST segment to abort an\n      existing\
    \ TCP connection when error conditions are detected for the\n      connection\
    \ or the application overtly requests that the connection\n      be reset.\n \
    \  o  Normal SMC-R connection termination processing has unexpectedly\n      stalled\
    \ for a given connection.  When the stall is detected\n      (connection termination\
    \ timeout condition), an abnormal SMC-R\n      connection termination flow is\
    \ initiated.\n   In these scenarios, it is very important that resources associated\n\
    \   with the affected SMC-R connections are properly cleaned up to ensure\n  \
    \ that there are no orphaned resources and that resources can reliably\n   be\
    \ reused for new SMC-R connections.  Given that SMC-R relies heavily\n   on the\
    \ RDMA write processing, special care needs to be taken to\n   ensure that an\
    \ RMBE is no longer being used by an SMC-R peer before\n   logically reassigning\
    \ that RMBE to a new SMC-R connection.\n   When an SMC-R peer initiates a TCP\
    \ connection reset, it also\n   initiates an SMC-R abnormal connection flow at\
    \ the same time.  The\n   SMC-R peers explicitly signal their intent to abnormally\
    \ terminate an\n   SMC-R connection and await explicit acknowledgment that the\
    \ peer has\n   received this notification and has also completed abnormal connection\n\
    \   termination on its end.  Note that TCP connection reset processing\n   can\
    \ occur in parallel to these flows.\n                            +-----------------+\n\
    \            |-------------->|     CLOSED      |<-------------|\n            |\
    \               |                 |              |\n            |            \
    \   +-----------------+              |\n            |                        \
    \                        |\n            |                                    \
    \            |\n            |                                                |\n\
    \            |           +-----------------------+            |\n            |\
    \           |     Any state         |            |\n            |1B         |\
    \ (before setting       |          2B|\n            |           |  PeerConnectionClosed\
    \ |            |\n            |           |  indicator in         |          \
    \  |\n            |           |  peer's RMBE)         |            |\n       \
    \     |           +-----------------------+            |\n            |      \
    \   1A        |         |      2A          |\n            |     Active Abort \
    \ |         |  Passive Abort   |\n            |                   V         V\
    \                  |\n            |       +--------------+   +--------------+\
    \      |\n            |-------|PeerAbortWait |   | Process Abort|------|\n   \
    \                 |              |   |              |\n                    +--------------+\
    \   +--------------+\n      Figure 23: SMC-R Abnormal Connection Termination State\
    \ Diagram\n   Figure 23 above shows the SMC-R abnormal connection termination\
    \ state\n   diagram:\n   1. Active abort designates the SMC-R peer that is initiating\
    \ the TCP\n      RST processing.  At the time that the TCP RST is sent, the active\n\
    \      abort side must also do the following:\n      A. Send the PeerConnAbort\
    \ indicator to the partner in a CDC\n         message, and then transition to\
    \ the PeerAbortWait state.\n         During this state, it will monitor this SMC-R\
    \ connection\n         waiting for the peer to send its corresponding PeerConnAbort\n\
    \         indicator but will ignore any other activity in this connection\n  \
    \       (i.e., new incoming data).  It will also generate an\n         appropriate\
    \ error to any socket API calls issued against this\n         socket (e.g., ECONNABORTED,\
    \ ECONNRESET).\n      B. Once the peer sends the PeerConnAbort indicator to the\
    \ local\n         host, the local host can transition this SMC-R connection to\n\
    \         the Closed state and reuse this RMBE.  Note that the SMC-R peer\n  \
    \       that goes into the active abort state must provide some\n         protection\
    \ against staying in that state indefinitely should\n         the remote SMC-R\
    \ peer not respond by sending its own\n         PeerConnAbort indicator to the\
    \ local host.  While this should\n         be a rare scenario, it could occur\
    \ if the remote SMC-R peer\n         (passive abort) suffered a failure right\
    \ after the local SMC-R\n         peer (active abort) sent the PeerConnAbort indicator.\
    \  To\n         protect against these types of failures, a timer can be set\n\
    \         after entering the PeerAbortWait state, and if that timer pops\n   \
    \      before the peer has sent its local PeerConnAbort indicator (to\n      \
    \   the active abort side), this RMBE can be returned to the free\n         pool\
    \ for possible reallocation.  See Section 4.4.2 for more\n         details.\n\
    \   2. Passive abort designates the SMC-R peer that is the recipient of\n    \
    \  an SMC-R abort from the peer designated by the PeerConnAbort\n      indicator\
    \ being sent by the peer in a CDC message.  Upon receiving\n      this request,\
    \ the local peer must do the following:\n      A. Using the appropriate error\
    \ codes, indicate to the socket\n         application that this connection has\
    \ been aborted, and then\n         purge all in-flight data for this connection\
    \ that is waiting to\n         be read or waiting to be sent.\n      B. Send a\
    \ CDC message to notify the peer of the PeerConnAbort\n         indicator and,\
    \ once that is completed, transition this RMBE to\n         the Closed state.\n\
    \   If an SMC-R peer receives a TCP RST for a given SMC-R connection, it\n   also\
    \ initiates SMC-R abnormal connection termination processing if it\n   has not\
    \ already been notified (via the PeerConnAbort indicator) that\n   the partner\
    \ is severing the connection.  It is possible to have two\n   SMC-R endpoints\
    \ concurrently be in an active abort role for a given\n   connection.  In that\
    \ scenario, the flows above still apply but both\n   endpoints take the active\
    \ abort path (path 1).\n"
- title: 4.8.3.  Other SMC-R Connection Termination Conditions
  contents:
  - "4.8.3.  Other SMC-R Connection Termination Conditions\n   The following are additional\
    \ conditions that have implications for\n   SMC-R connection termination:\n  \
    \ o  An SMC-R peer being gracefully shut down.  If an SMC-R peer\n      supports\
    \ a graceful shutdown operation, it should attempt to\n      terminate all SMC-R\
    \ connections as part of shutdown processing.\n      This could be accomplished\
    \ via LLC DELETE LINK requests on all\n      active SMC-R links.\n   o  Abnormal\
    \ termination of an SMC-R peer.  In this example, there may\n      be no opportunity\
    \ for the host to perform any SMC-R cleanup\n      processing.  In this scenario,\
    \ it is up to the remote peer to\n      detect a RoCE communications failure with\
    \ the failing host.  This\n      could trigger SMC-R link switchover, but that\
    \ would also generate\n      RoCE errors, causing the remote host to eventually\
    \ terminate all\n      existing SMC-R connections to this peer.\n   o  Loss of\
    \ RoCE connectivity between two SMC-R peers.  If two peers\n      are no longer\
    \ reachable across any links in their SMC-R link\n      group, then both peers\
    \ perform a TCP reset for the connections,\n      generate an error to the local\
    \ applications, and free up all QP\n      resources associated with the link group.\n"
- title: 5.  Security Considerations
  contents:
  - '5.  Security Considerations

    '
- title: 5.1.  VLAN Considerations
  contents:
  - "5.1.  VLAN Considerations\n   The concepts and access control of virtual LANs\
    \ (VLANs) must be\n   extended to also cover the RoCE network traffic flowing\
    \ across the\n   Ethernet.\n   The RoCE VLAN configuration and access permissions\
    \ must mirror the IP\n   VLAN configuration and access permissions over the Converged\
    \ Enhanced\n   Ethernet fabric.  This means that hosts, routers, and switches\
    \ that\n   have access to specific VLANs on the IP fabric must also have the\n\
    \   same VLAN access across the RoCE fabric.  In other words, the SMC-R\n   connectivity\
    \ will follow the same virtual network access permissions\n   as normal TCP/IP\
    \ traffic.\n"
- title: 5.2.  Firewall Considerations
  contents:
  - "5.2.  Firewall Considerations\n   As mentioned above, the RoCE fabric inherits\
    \ the same VLAN\n   topology/access as the IP fabric.  RoCE is a Layer 2 protocol\
    \ that\n   requires both endpoints to reside in the same Layer 2 network (i.e.,\n\
    \   VLAN).  RoCE traffic cannot traverse multiple VLANs, as there is no\n   support\
    \ for routing RoCE traffic beyond a single VLAN.  As a result,\n   SMC-R communications\
    \ will also be confined to peers that are members\n   of the same VLAN.  IP-based\
    \ firewalls are typically inserted between\n   VLANs (or physical LANs) and rely\
    \ on normal IP routing to insert\n   themselves in the data path.  Since RoCE\
    \ (and by extension SMC-R) is\n   not routable beyond the local VLAN, there is\
    \ no ability to insert a\n   firewall in the network path of two SMC-R peers.\n"
- title: 5.3.  Host-Based IP Filters
  contents:
  - "5.3.  Host-Based IP Filters\n   Because SMC-R maintains the TCP three-way handshake\
    \ for connection\n   setup before switching to RoCE out of band, existing IP filters\
    \ that\n   control connection setup flows remain effective in an SMC-R\n   environment.\
    \  IP filters that operate on traffic flowing in an active\n   TCP connection\
    \ are not supported, because the connection data does\n   not flow over IP.\n"
- title: 5.4.  Intrusion Detection Services
  contents:
  - "5.4.  Intrusion Detection Services\n   Similar to IP filters, intrusion detection\
    \ services that operate on\n   TCP connection setups are compatible with SMC-R\
    \ with no changes\n   required.  However, once the TCP connection has switched\
    \ to RoCE out\n   of band, packets are not available for examination.\n"
- title: 5.5.  IP Security (IPsec)
  contents:
  - "5.5.  IP Security (IPsec)\n   IP security is not compatible with SMC-R, because\
    \ there are no IP\n   packets on which to operate.  TCP connections that require\
    \ IP\n   security must opt out of SMC-R.\n"
- title: 5.6.  TLS/SSL
  contents:
  - "5.6.  TLS/SSL\n   Transport Layer Security/Secure Socket Layer (TLS/SSL) is preserved\n\
    \   in an SMC-R environment.  The TLS/SSL layer resides above the SMC-R\n   layer,\
    \ and outgoing connection data is encrypted before being passed\n   down to the\
    \ SMC-R layer for RDMA write.  Similarly, incoming\n   connection data goes through\
    \ the SMC-R layer encrypted and is\n   decrypted by the TLS/SSL layer as it is\
    \ today.\n   The TLS/SSL handshake messages flow over the TCP connection after\
    \ the\n   connection has switched to SMC-R, and so they are exchanged using\n\
    \   RDMA writes by the SMC-R layer, transparently to the TLS/SSL layer.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   The scarcity of TCP option codes available for assignment\
    \ is\n   understood, and this architecture uses experimental TCP options\n   following\
    \ the conventions of [RFC6994] (\"Shared Use of Experimental\n   TCP Options\"\
    ).\n   TCP ExID 0xE2D4C3D9 has been registered with IANA as a TCP Experiment\n\
    \   Identifier.  See Section 3.1.\n   If this protocol achieves wide acceptance,\
    \ a discrete option code may\n   be requested by subsequent versions of this protocol.\n"
- title: 7.  Normative References
  contents:
  - "7.  Normative References\n   [RFC793]   Postel, J., \"Transmission Control Protocol\"\
    , STD 7,\n              RFC 793, DOI 10.17487/RFC0793, September 1981,\n     \
    \         <http://www.rfc-editor.org/info/rfc793>.\n   [RFC6994]  Touch, J., \"\
    Shared Use of Experimental TCP Options\",\n              RFC 6994, DOI 10.17487/RFC6994,\
    \ August 2013,\n              <http://www.rfc-editor.org/info/rfc6994>.\n   [RoCE]\
    \     InfiniBand, \"RDMA over Converged Ethernet specification\",\n          \
    \    <https://cw.infinibandta.org/wg/Members/documentRevision/\n             \
    \ download/7149>.\n"
- title: Appendix A.  Formats
  contents:
  - 'Appendix A.  Formats

    '
- title: A.1.  TCP Option
  contents:
  - "A.1.  TCP Option\n   The SMC-R TCP option is formatted in accordance with [RFC6994]\n\
    \   (\"Shared Use of Experimental TCP Options\").  The ExID value is\n   IBM-1047\
    \ (EBCDIC) encoding for \"SMCR\".\n      0                   1               \
    \    2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   Kind = 254  | Length = 6    |   x'E2'       |   x'D4'       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  x'C3'      |    x'D9'      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                Figure 24: SMC-R TCP Option Format\n"
- title: A.2.  CLC Messages
  contents:
  - "A.2.  CLC Messages\n   The following rules apply to all CLC messages:\n   General\
    \ rules on formats:\n   o  Reserved fields must be set to zero and not validated.\n\
    \   o  Each message has an eye catcher at the start and another\n      eye catcher\
    \ at the end.  These must both be validated by the\n      receiver.\n   o  SMC\
    \ version indicator: The only SMC-R version defined in this\n      architecture\
    \ is version 1.  In the future, if peers have a\n      mismatch of versions, the\
    \ lowest common version number is used.\n"
- title: A.2.1.  Peer ID Format
  contents:
  - "A.2.1.  Peer ID Format\n   All CLC messages contain a peer ID that uniquely identifies\
    \ an\n   instance of a TCP/IP stack.  This peer ID is required to be\n   universally\
    \ unique across TCP/IP stacks and instances (including\n   restarts) of TCP/IP\
    \ stacks.\n      0                   1                   2                   3\n\
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Instance ID          |    RoCE MAC (first 2 bytes)   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                  RoCE MAC (last 4 bytes)                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 25: Peer ID Format\n   Instance ID\n      A 2-byte\
    \ instance count that ensures that if the same RNIC MAC is\n      later used in\
    \ the peer ID for a different TCP/IP stack -- for\n      example, if an RNIC is\
    \ redeployed to another stack -- the values\n      are unique.  It also ensures\
    \ that if a TCP/IP stack is restarted,\n      the instance ID changes.  The value\
    \ is implementation defined,\n      with one suggestion being 2 bytes of the system\
    \ clock.\n   RoCE MAC\n      The RoCE MAC address for one of the peer's RNICs.\
    \  Note that in a\n      virtualized environment this will be the virtual MAC\
    \ of one of the\n      peer's RNICs.\n"
- title: A.2.2.  SMC Proposal CLC Message Format
  contents:
  - "A.2.2.  SMC Proposal CLC Message Format\n      0                   1        \
    \           2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Type\
    \ = 1     |           Length              |Version| Rsrvd |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                       Client's Peer ID                      -+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \           Client's preferred GID                       -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Client's preferred RoCE                                      |\n    \
    \ +- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                             |Offset to mask/prefix area (0) |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     .                                                               .\n    \
    \ .                  Area for future growth                       .\n     .  \
    \                                                             .\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         IPv4 Subnet Mask                      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | IPv4\
    \ Mask Lgth|           Reserved            |Num IPv6 prfx  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     :                                                               :\n    \
    \ :           Array of IPv6 prefixes (variable length)            :\n     :  \
    \                                                             :\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \        Figure 26: SMC Proposal CLC Message Format\n   The fields present in\
    \ the SMC Proposal CLC message are:\n   Eye catchers\n      Like all CLC messages,\
    \ the SMC Proposal has beginning and ending\n      eye catchers to aid with verification\
    \ and parsing.  The hex digits\n      spell \"SMCR\" in IBM-1047 (EBCDIC).\n \
    \  Type\n      CLC message Type 1 indicates SMC Proposal.\n   Length\n      The\
    \ length of this CLC message.  If this is an IPv4 flow, this\n      value is 52.\
    \  Otherwise, it is variable, depending upon how many\n      prefixes are listed.\n\
    \   Version\n      Version of the SMC-R protocol.  Version 1 is the only currently\n\
    \      defined value.\n   Client's Peer ID\n      As described in Appendix A.2.1\
    \ above.\n   Client's preferred RoCE GID\n      The IPv6 address of the client's\
    \ preferred RNIC on the RoCE\n      fabric.\n   Client's preferred RoCE MAC address\n\
    \      The MAC address of the client's preferred RNIC on the RoCE fabric.\n  \
    \    It is required, as some operating systems do not have neighbor\n      discovery\
    \ or ARP support for RoCE RNICs.\n   Offset to mask/prefix area\n      Provides\
    \ the number of bytes that must be skipped after this\n      field, to access\
    \ the IPv4 Subnet Mask field and the fields that\n      follow it.  Allows for\
    \ future growth of this signal.  In this\n      version of the architecture, this\
    \ value is always zero.\n   Area for future growth\n      In this version of the\
    \ architecture, this field does not exist.\n      This indicates where additional\
    \ information may be inserted into\n      the signal in the future.  The \"Offset\
    \ to mask/prefix area\" field\n      must be used to skip over this area.\n  \
    \ IPv4 Subnet Mask\n      If this message is flowing over an IPv4 TCP connection,\
    \ the value\n      of the subnet mask associated with the interface over which\
    \ the\n      client sent this message.  If this is an IPv6 flow, this field is\n\
    \      all zeros.\n      This field, along with all fields that follow it in this\
    \ signal,\n      must be accessed by skipping the number of bytes listed in the\n\
    \      \"Offset to mask/prefix area\" field after the end of that field.\n   IPv4\
    \ Mask Lgth\n      If this message is flowing over an IPv4 TCP connection, the\
    \ number\n      of significant bits in the IPv4 Subnet Mask field.  If this is\
    \ an\n      IPv6 flow, this field is zero.\n   Num IPv6 prfx\n      If this message\
    \ is flowing over an IPv6 TCP connection, the number\n      of IPv6 prefixes that\
    \ follow, with a maximum value of 8.  If this\n      is an IPv4 flow, this field\
    \ is zero and is immediately followed by\n      the ending eye catcher.\n   Array\
    \ of IPv6 prefixes\n      For IPv6 TCP connections, a list of the IPv6 prefixes\
    \ associated\n      with the network over which the client sent this message,\
    \ up to a\n      maximum of eight prefixes.\n      0                   1     \
    \              2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                                                               +\n     |  \
    \                                                             |\n     +      \
    \            IPv6 prefix value                            +\n     |          \
    \                                                     |\n     +              \
    \                                                 +\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Prefix Length |\n     +-+-+-+-+-+-+-+-+\n              Figure 27: Format\
    \ for IPv6 Prefix Array Element\n"
- title: A.2.3.  SMC Accept CLC Message Format
  contents:
  - "A.2.3.  SMC Accept CLC Message Format\n      0                   1          \
    \         2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Type\
    \ = 2     |    Length = 68                |Version|F|Rsrvd|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                       Server's Peer ID                      -+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \           Server's RoCE GID                            -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Server's RoCE                                                |\n    \
    \ +- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                             |     Server QP (bytes 1-2)     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---+\n\
    \     |Srvr QP byte 3 |         Server RMB RKey (bytes 1-3)           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |Srvr\
    \ RMB byte 4|Server RMB indx| Srvr RMB alert tkn (bytes 1-2)|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Srvr RMB alert tkn (bytes 3-4)|Bsize  | MTU   |   Reserved    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +-     \
    \                Server's RMB virtual address            -+\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Reserved      |    Server's initial packet sequence number    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 28: SMC Accept CLC Message Format\n   The fields present\
    \ in the SMC Accept CLC message are:\n   Eye catchers\n      Like all CLC messages,\
    \ the SMC Accept has beginning and ending\n      eye catchers to aid with verification\
    \ and parsing.  The hex digits\n      spell \"SMCR\" in IBM-1047 (EBCDIC).\n \
    \  Type\n      CLC message Type 2 indicates SMC Accept.\n   Length\n      The\
    \ SMC Accept CLC message is 68 bytes long.\n   Version\n      Version of the SMC-R\
    \ protocol.  Version 1 is the only currently\n      defined value.\n   F-bit\n\
    \      First contact flag: A 1-bit flag that indicates that the server\n     \
    \ believes this TCP connection is the first SMC-R contact for this\n      link\
    \ group.\n   Server's Peer ID\n      As described in Appendix A.2.1 above.\n \
    \  Server's RoCE GID\n      The IPv6 address of the RNIC that the server chose\
    \ for this SMC-R\n      link.\n   Server's RoCE MAC address\n      The MAC address\
    \ of the server's RNIC for the SMC-R link.  It is\n      required, as some operating\
    \ systems do not have neighbor discovery\n      or ARP support for RoCE RNICs.\n\
    \   Server's QP number\n      The number for the reliably connected queue pair\
    \ that the server\n      created for this SMC-R link.\n   Server's RMB RKey\n\
    \      The RDMA RKey for the RMB that the server created or chose for\n      this\
    \ TCP connection.\n   Server's RMB element index\n      Indexes which element\
    \ within the server's RMB will represent this\n      TCP connection.\n   Server's\
    \ RMB element alert token\n      A platform-defined, architecturally opaque token\
    \ that identifies\n      this TCP connection.  Added by the client as immediate\
    \ data on\n      RDMA writes from the client to the server to inform the server\n\
    \      that there is data for this connection to retrieve from the\n      RMB\
    \ element.\n   Bsize:\n      Server's RMB element buffer size in 4-bit compressed\
    \ notation:\n      x = 4 bits.  Actual buffer size value is (2^(x + 4)) * 1K.\n\
    \      Smallest possible value is 16K.  Largest size supported by this\n     \
    \ architecture is 512K.\n   MTU\n      An enumerated value indicating this peer's\
    \ QP MTU size.  The two\n      peers exchange their MTU values, and whichever\
    \ value is smaller\n      will be used for the QP.  This field should only be\
    \ validated in\n      the first contact exchange.\n      The enumerated MTU values\
    \ are:\n         0:  reserved\n         1:  256\n         2:  512\n         3:\
    \  1024\n         4:  2048\n         5:  4096\n         6-15: reserved\n   Server's\
    \ RMB virtual address\n      The virtual address of the server's RMB as assigned\
    \ by the\n      server's RNIC.\n   Server's initial packet sequence number\n \
    \     The starting packet sequence number that this peer will use when\n     \
    \ sending to the other peer, so that the other peer can prepare its\n      QP\
    \ for the sequence number to expect.\n"
- title: A.2.4.  SMC Confirm CLC Message Format
  contents:
  - "A.2.4.  SMC Confirm CLC Message Format\n      0                   1         \
    \          2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Type\
    \ = 3     |    Length = 68                |Version| Rsrvd |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                       Client's Peer ID                      -+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \           Client's RoCE GID                            -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Client's RoCE                                                |\n    \
    \ +- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                             |     Client QP (bytes 1-2)     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---+\n\
    \     |Clnt QP byte 3 |         Client RMB RKey (bytes 1-3)           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |Clnt\
    \ RMB byte 4|Client RMB indx| Clnt RMB alert tkn (bytes 1-2)|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Clnt RMB alert tkn (bytes 3-4)|Bsize  | MTU   |   Reserved    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +-     \
    \             Client's RMB Virtual Address               -+\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Reserved      |    Client's initial packet sequence number    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 29: SMC Confirm CLC Message Format\n   The SMC Confirm\
    \ CLC message is nearly identical to the SMC Accept,\n   except that it contains\
    \ client information and lacks a first contact\n   flag.\n   The fields present\
    \ in the SMC Confirm CLC message are:\n   Eye catchers\n      Like all CLC messages,\
    \ the SMC Confirm has beginning and ending\n      eye catchers to aid with verification\
    \ and parsing.  The hex digits\n      spell \"SMCR\" in IBM-1047 (EBCDIC).\n \
    \  Type\n      CLC message Type 3 indicates SMC Confirm.\n   Length\n      The\
    \ SMC Confirm CLC message is 68 bytes long.\n   Version\n      Version of the\
    \ SMC-R protocol.  Version 1 is the only currently\n      defined value.\n   Client's\
    \ Peer ID\n      As described in Appendix A.2.1 above.\n   Client's RoCE GID\n\
    \      The IPv6 address of the RNIC that the client chose for this SMC-R\n   \
    \   link.\n   Client's RoCE MAC address\n      The MAC address of the client's\
    \ RNIC for the SMC-R link.  It is\n      required, as some operating systems do\
    \ not have neighbor discovery\n      or ARP support for RoCE RNICs.\n   Client's\
    \ QP number\n      The number for the reliably connected queue pair that the client\n\
    \      created for this SMC-R link.\n   Client's RMB RKey\n      The RDMA RKey\
    \ for the RMB that the client created or chose for\n      this TCP connection.\n\
    \   Client's RMB element index\n      Indexes which element within the client's\
    \ RMB will represent this\n      TCP connection.\n   Client's RMB element alert\
    \ token\n      A platform-defined, architecturally opaque token that identifies\n\
    \      this TCP connection.  Added by the server as immediate data on\n      RDMA\
    \ writes from the server to the client to inform the client\n      that there\
    \ is data for this connection to retrieve from the\n      RMB element.\n   Bsize:\n\
    \      Client's RMB element buffer size in 4-bit compressed notation:\n      x\
    \ = 4 bits.  Actual buffer size value is (2^(x + 4)) * 1K.\n      Smallest possible\
    \ value is 16K.  Largest size supported by this\n      architecture is 512K.\n\
    \   MTU\n      An enumerated value indicating this peer's QP MTU size.  The two\n\
    \      peers exchange their MTU values, and whichever value is smaller\n     \
    \ will be used for the QP.  The values are enumerated in\n      Appendix A.2.3.\
    \  This value should only be validated in the first\n      contact exchange.\n\
    \   Client's RMB Virtual Address\n      The virtual address of the client's RMB\
    \ as assigned by the\n      server's RNIC.\n   Client's initial packet sequence\
    \ number\n      The starting packet sequence number that this peer will use when\n\
    \      sending to the other peer, so that the other peer can prepare its\n   \
    \   QP for the sequence number to expect.\n"
- title: A.2.5.  SMC Decline CLC Message Format
  contents:
  - "A.2.5.  SMC Decline CLC Message Format\n      0                   1         \
    \          2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Type\
    \ = 4     |    Length = 28                |Version|S|Rsrvd|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                       Sender's Peer ID                      -+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |              Peer Diagnosis Information                       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \         Figure 30: SMC Decline CLC Message Format\n   The fields present in\
    \ the SMC Decline CLC message are:\n   Eye catchers\n      Like all CLC messages,\
    \ the SMC Decline has beginning and ending\n      eye catchers to aid with verification\
    \ and parsing.  The hex digits\n      spell \"SMCR\" in IBM-1047 (EBCDIC).\n \
    \  Type\n      CLC message Type 4 indicates SMC Decline.\n   Length\n      The\
    \ SMC Decline CLC message is 28 bytes long.\n   Version\n      Version of the\
    \ SMC-R protocol.  Version 1 is the only currently\n      defined value.\n   S-bit\n\
    \      Sync Bit.  Indicates that the link group is out of sync and the\n     \
    \ receiving peer must clean up its representation of the link group.\n   Sender's\
    \ Peer ID\n      As described in Appendix A.2.1 above.\n   Peer Diagnosis Information\n\
    \      4 bytes of diagnosis information provided by the peer.  These\n      values\
    \ are defined by the individual peers, and it is necessary to\n      consult the\
    \ peer's system documentation to interpret the results.\n"
- title: A.3.  LLC Messages
  contents:
  - "A.3.  LLC Messages\n   LLC messages are sent over an existing SMC-R link using\
    \ RoCE SendMsg\n   and are always 44 bytes long so that they fit into the space\n\
    \   available in a single WQE without requiring the receiver to post\n   receive\
    \ buffers.  If all 44 bytes are not needed, they are padded out\n   with zeros.\
    \  LLC messages are in a request/response format.  The\n   message type is the\
    \ same for request and response, and a flag\n   indicates whether a message is\
    \ flowing as a request or a response.\n   The two high-order bits of an LLC message\
    \ opcode indicate how it is\n   to be handled by a peer that does not support\
    \ the opcode.\n   If the high-order bits of the opcode are b'00', then the peer\
    \ must\n   support the LLC message and indicate a protocol error if it does not.\n\
    \   If the high-order bits of the opcode are b'10', then the peer must\n   silently\
    \ discard the LLC message if it does not support the opcode.\n   This requirement\
    \ is included to allow for toleration of advanced, but\n   optional, functionality.\n\
    \   High-order bits of b'11' indicate a Connection Data Control (CDC)\n   message\
    \ as described in Appendix A.4.\n"
- title: A.3.1.  CONFIRM LINK LLC Message Format
  contents:
  - "A.3.1.  CONFIRM LINK LLC Message Format\n      0                   1        \
    \           2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 1     |  Length = 44  |   Reserved    |R|  Reserved   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Sender's\
    \ RoCE                                                |\n     +-   MAC address\
    \                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |                   \
    \            |                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n     |                                    \
    \                           |\n     +-                                       \
    \                      -+\n     |                 Sender's RoCE GID          \
    \                   |\n     +-                                               \
    \              -+\n     |                                                    \
    \           |\n     +-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                               |Sender's QP number, bytes 1-2  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |Sender\
    \ QP byte3| Link number   |Sender's link userID, bytes 1-2|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Sender's link userID, bytes 3-4| Max links     |  Reserved     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +-     \
    \                    Reserved                            -+\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 31: CONFIRM LINK LLC Message Format\n   The CONFIRM LINK\
    \ LLC message is required to be exchanged between the\n   server and client over\
    \ a newly created SMC-R link to complete the\n   setup of an SMC-R link.  Its\
    \ purpose is to confirm that the RoCE path\n   is actually usable.\n   On first\
    \ contact, this message flows after the server receives the\n   SMC Confirm CLC\
    \ message from the client over the IP connection.  For\n   additional links added\
    \ to an SMC-R link group, it flows after the\n   ADD LINK and ADD LINK CONTINUATION\
    \ exchange.  This flow provides\n   confirmation that the queue pair is in fact\
    \ usable.  Each peer echoes\n   its RoCE information back to the other.\n   The\
    \ contents of the CONFIRM LINK LLC message are:\n   Type\n      Type 1 indicates\
    \ CONFIRM LINK.\n   Length\n      The CONFIRM LINK LLC message is 44 bytes long.\n\
    \   R\n      Reply flag.  When set, indicates that this is a CONFIRM LINK\n  \
    \    reply.\n   Sender's RoCE MAC address\n      The MAC address of the sender's\
    \ RNIC for the SMC-R link.  It is\n      required, as some operating systems do\
    \ not have neighbor discovery\n      or ARP support for RoCE RNICs.\n   Sender's\
    \ RoCE GID\n      The IPv6 address of the RNIC that the sender is using for this\n\
    \      SMC-R link.\n   Sender's QP number\n      The number for the reliably connected\
    \ queue pair that the sender\n      created for this SMC-R link.\n   Link number\n\
    \      An identifier assigned by the server that uniquely identifies the\n   \
    \   link within the link group.  This identifier is ONLY unique within\n     \
    \ a link group.  Provided by the server and echoed back by the\n      client.\n\
    \   Link user ID\n      An opaque, implementation-defined identifier assigned\
    \ by the\n      sender and provided to the receiver solely for purposes of\n \
    \     display, diagnosis, network management, etc.  The link user ID\n      should\
    \ be unique across the sender's entire software space,\n      including all other\
    \ link groups.\n   Max links\n      The maximum number of links the sender can\
    \ support in a link\n      group.  The maximum for this link group is the smaller\
    \ of the\n      values provided by the two peers.\n"
- title: A.3.2.  ADD LINK LLC Message Format
  contents:
  - "A.3.2.  ADD LINK LLC Message Format\n      0                   1            \
    \       2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 2     |  Length = 44  | Rsrvd |RsnCode|R|Z| Reserved  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Sender's\
    \ RoCE                                                |\n     +-   MAC address\
    \                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |                   \
    \            |                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n     |                                    \
    \                           |\n     +-                                       \
    \                      -+\n     |                 Sender's RoCE GID          \
    \                   |\n     +-                                               \
    \              -+\n     |                                                    \
    \           |\n     +-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                               |Sender's QP number, bytes 1-2  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |Sender\
    \ QP byte3| Link number   |Rsrvd  |  MTU  |Initial PSN    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Initial PSN (continued)      |                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              -+\n     |  \
    \                        Reserved                             |\n     +-     \
    \                                                        -+\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 32: ADD LINK LLC Message Format\n   The ADD LINK LLC\
    \ message is sent over an existing link in the link\n   group when a peer wishes\
    \ to add an SMC-R link to an existing SMC-R\n   link group.  It is sent by the\
    \ server to add a new SMC-R link to the\n   group, or by the client to request\
    \ that the server add a new link --\n   for example, when a new RNIC becomes active.\
    \  When sent from the\n   client to the server, it represents a request that the\
    \ server\n   initiate an ADD LINK exchange.\n   This message is sent immediately\
    \ after the initial SMC-R link in the\n   group completes, as described in Section\
    \ 3.5.1 (\"First Contact\").  It\n   can also be sent over an existing SMC-R link\
    \ group at any time as new\n   RNICs are added and become available.  Therefore,\
    \ there can be as few\n   as one new RMB RToken to be communicated, or several.\
    \  RTokens will\n   be communicated using ADD LINK CONTINUATION messages.\n  \
    \ The contents of the ADD LINK LLC message are:\n   Type\n      Type 2 indicates\
    \ ADD LINK.\n   Length\n      The ADD LINK LLC message is 44 bytes long.\n   RsnCode\n\
    \      If the Z (rejection) flag is set, this field provides the reason\n    \
    \  code.  Values can be:\n         X'1' - no alternate path available: set when\
    \ the server\n                provides the same MAC/GID as an existing SMC-R link\
    \ in\n                the group, and the client does not have any additional\n\
    \                RNICs available (i.e., the server is attempting to set\n    \
    \            up an asymmetric link but none is available).\n         X'2' - Invalid\
    \ MTU value specified.\n   R\n      Reply flag.  When set, indicates that this\
    \ is an ADD LINK reply.\n   Z\n      Rejection flag.  When set on reply, indicates\
    \ that the server's\n      ADD LINK was rejected by the client.  When this flag\
    \ is set, the\n      reason code will also be set.\n   Sender's RoCE MAC address\n\
    \      The MAC address of the sender's RNIC for the new SMC-R link.  It\n    \
    \  is required, as some operating systems do not have neighbor\n      discovery\
    \ or ARP support for RoCE RNICs.\n   Sender's RoCE GID\n      The IPv6 address\
    \ of the RNIC that the sender is using for the new\n      SMC-R link.\n   Sender's\
    \ QP number\n      The number for the reliably connected queue pair that the sender\n\
    \      created for the new SMC-R link.\n   Link number\n      An identifier for\
    \ the new SMC-R link.  This is assigned by the\n      server and uniquely identifies\
    \ the link within the link group.\n      This identifier is ONLY unique within\
    \ a link group.  Provided by\n      the server and echoed back by the client.\n\
    \   MTU\n      An enumerated value indicating this peer's QP MTU size.  The two\n\
    \      peers exchange their MTU values, and whichever value is smaller\n     \
    \ will be used for the QP.  The values are enumerated in\n      Appendix A.2.3.\n\
    \   Initial PSN\n      The starting packet sequence number (PSN) that this peer\
    \ will use\n      when sending to the other peer, so that the other peer can prepare\n\
    \      its QP for the sequence number to expect.\n"
- title: A.3.3.  ADD LINK CONTINUATION LLC Message Format
  contents:
  - "A.3.3.  ADD LINK CONTINUATION LLC Message Format\n      0                   1\
    \                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 3     |  Length = 44  |  Reserved     |R|  Reserved   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ Linknum     | NumRTokens    |         Reserved              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \             RKey/RToken pair                           -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \             RKey/RToken pair or zeros                  -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                        Reserved                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \    Figure 33: ADD LINK CONTINUATION LLC Message Format\n   When a new SMC-R\
    \ link is added to an SMC-R link group, it is\n   necessary to communicate the\
    \ new link's RTokens for the RMBs that the\n   SMC-R link group can access.  This\
    \ message follows the ADD LINK and\n   provides the RTokens.\n   The server kicks\
    \ off this exchange by sending the first ADD LINK\n   CONTINUATION LLC message,\
    \ and the server controls the exchange as\n   described below.\n   o  If the client\
    \ and the server require the same number of ADD LINK\n      CONTINUATION messages\
    \ to communicate their RTokens, the server\n      starts the exchange by sending\
    \ the first ADD LINK CONTINUATION\n      request to the client with its (the server's)\
    \ RTokens.  The client\n      then responds with an ADD LINK CONTINUATION response\
    \ with its\n      RTokens, and so on until the exchange is completed.\n   o  If\
    \ the server requires more ADD LINK CONTINUATION messages than\n      the client,\
    \ then after the client has communicated all of its\n      RTokens, the server\
    \ continues to send ADD LINK CONTINUATION\n      request messages to the client.\
    \  The client continues to respond,\n      using empty (number of RTokens to be\
    \ communicated = 0) ADD LINK\n      CONTINUATION response messages.\n   o  If\
    \ the client requires more ADD LINK CONTINUATION messages than\n      the server,\
    \ then after communicating all of its RTokens, the\n      server will continue\
    \ to send empty ADD LINK CONTINUATION messages\n      to the client to solicit\
    \ replies with the client's RTokens, until\n      all have been communicated.\n\
    \   The contents of the ADD LINK CONTINUATION LLC message are:\n   Type\n    \
    \  Type 3 indicates ADD LINK CONTINUATION.\n   Length\n      The ADD LINK CONTINUATION\
    \ LLC message is 44 bytes long.\n   R\n      Reply flag.  When set, indicates\
    \ that this is an ADD LINK\n      CONTINUATION reply.\n   LinkNum\n      The link\
    \ number of the new link within the SMC-R link group for\n      which RKeys are\
    \ being communicated.\n   NumRTokens\n      Number of RTokens remaining to be\
    \ communicated (including the ones\n      in this message).  If the value is less\
    \ than or equal to 2, this\n      is the last message.  If it is greater than\
    \ 2, another\n      continuation message will be required, and its value will\
    \ be the\n      value in this message minus 2, and so on until all RKeys are\n\
    \      communicated.  The maximum value for this field is 255.\n   RKey/RToken\
    \ pairs (two or less)\n      These consist of an RKey for an RMB that is known\
    \ on the SMC-R\n      link over which this message was sent (the reference RKey),\
    \ paired\n      with the same RMB's RToken over the new SMC-R link.  A full RToken\n\
    \      is not required for the reference, because it is only being used\n    \
    \  to distinguish which RMB it applies to, not address it.\n      0          \
    \         1                   2                   3\n      0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         Reference RKey                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                          New RKey                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                       New Virtual Address                   -+\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 34: RKey/RToken Pair Format\n   The contents of the\
    \ RKey/RToken pair are:\n   Reference RKey\n      The RKey of the RMB as it is\
    \ already known on the SMC-R link over\n      which this message is being sent.\
    \  Required so that the peer knows\n      with which RMB to associate the new\
    \ RToken.\n   New RKey\n      The RKey of this RMB as it is known over the new\
    \ SMC-R link.\n   New Virtual Address\n      The virtual address of this RMB as\
    \ it is known over the new\n      SMC-R link.\n"
- title: A.3.4.  DELETE LINK LLC Message Format
  contents:
  - "A.3.4.  DELETE LINK LLC Message Format\n      0                   1         \
    \          2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 4     |  Length = 44  |  Reserved     |R|A|O| Rsrvd   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ Linknum     |         reason code (bytes 1-3)               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |RsnCode byte 4 |                                               |\n    \
    \ +-+-+-+-+-+-+-+-+                                              -+\n     |  \
    \                                                             |\n     +-     \
    \                                                        -+\n     |          \
    \                                                     |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-                     \
    \     Reserved                           -+\n     |                          \
    \                                     |\n     +-                             \
    \                                -+\n     |                                  \
    \                             |\n     +-                                     \
    \                        -+\n     |                                          \
    \                     |\n     +-                                             \
    \                -+\n     |                                                  \
    \             |\n     +-                                                     \
    \        -+\n     |                                                          \
    \     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 35: DELETE LINK LLC Message Format\n   When the client\
    \ or server detects that a QP or SMC-R link goes down\n   or needs to come down,\
    \ it sends this message over one of the other\n   links in the link group.\n \
    \  When the DELETE LINK is sent from the client, it only serves as a\n   notification,\
    \ and the client expects the server to respond by sending\n   a DELETE LINK request.\
    \  To avoid races, only the server will initiate\n   the actual DELETE LINK request\
    \ and response sequence that results\n   from notification from the client.\n\
    \   The server can also initiate the DELETE LINK without notification\n   from\
    \ the client if it detects an error or if orderly link termination\n   was initiated.\n\
    \   The client may also request termination of the entire link group, and\n  \
    \ the server may terminate the entire link group using this message.\n   The contents\
    \ of the DELETE LINK LLC message are:\n   Type\n      Type 4 indicates DELETE\
    \ LINK.\n   Length\n      The DELETE LINK LLC message is 44 bytes long.\n   R\n\
    \      Reply flag.  When set, indicates that this is a DELETE LINK reply.\n  \
    \ A\n      \"All\" flag.  When set, indicates that all links in the link group\n\
    \      are to be terminated.  This terminates the link group.\n   O\n      Orderly\
    \ flag.  Indicates orderly termination.  Orderly termination\n      is generally\
    \ caused by an operator command rather than an error on\n      the link.  When\
    \ the client requests orderly termination, the\n      server may wait to complete\
    \ other work before terminating.\n   LinkNum\n      The link number of the link\
    \ to be terminated.  If the A flag is\n      set, this field has no meaning and\
    \ is set to 0.\n   RsnCode\n      The termination reason code.  Currently defined\
    \ reason codes are:\n      Request reason codes:\n         X'00010000' = Lost\
    \ path\n         X'00020000' = Operator initiated termination\n         X'00030000'\
    \ = Program initiated termination (link inactivity)\n         X'00040000' = LLC\
    \ protocol violation\n         X'00050000' = Asymmetric link no longer needed\n\
    \      Response reason code:\n         X'00100000' = Unknown link ID (no link)\n"
- title: A.3.5.  CONFIRM RKEY LLC Message Format
  contents:
  - "A.3.5.  CONFIRM RKEY LLC Message Format\n      0                   1        \
    \           2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 6     |  Length = 44  |   Reserved    |R|0|Z|C|Rsrvd  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ NumTkns     |  New RMB RKey for this link (bytes 1-3)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |ThisLink byte 4|                                               |\n    \
    \ +-+-+-+-+-+-+-+-+                                              -+\n     |  \
    \         New RMB virtual address for this link               |\n     +-     \
    \         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |          \
    \     |                                               |\n     +-+-+-+-+-+-+-+-+\
    \                                              -+\n     |                    \
    \                                           |\n     +-   Other link RMB specification\
    \ or zeros                     -+\n     |                                    \
    \                           |\n     +-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                               |                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              -+\n     |  \
    \                                                             |\n     +-     \
    \                                                        -+\n     |      Other\
    \ link RMB specification or zeros                    |\n     +-              \
    \                                +-+-+-+-+-+-+-+-+\n     |                   \
    \                            |  Reserved     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 36: CONFIRM RKEY LLC Message Format\n   The CONFIRM RKEY\
    \ flow can be sent at any time from either the client\n   or the server, to inform\
    \ the peer that an RMB has been created or\n   deleted.  The creator of a new\
    \ RMB must inform its peer of the new\n   RMB's RToken for all SMC-R links in\
    \ the SMC-R link group.\n   For RMB creation, the creator sends this message over\
    \ the SMC-R link\n   that the first TCP connection that uses the new RMB is using.\
    \  This\n   message contains the new RMB RToken for the SMC-R link over which\n\
    \   the message is sent.  It then lists the sender's SMC-R links in the\n   link\
    \ group paired with the new RToken for the new RMB for that link.\n   This message\
    \ can communicate the new RTokens for three QPs: the QP\n   for the link over\
    \ which this message is sent, and two others.  If\n   there are more than three\
    \ links in the SMC-R link group, a\n   CONFIRM RKEY CONTINUATION will be required.\n\
    \   The peer responds by simply echoing the message with the response\n   flag\
    \ set.  If the response is a negative response, the sender must\n   recalculate\
    \ the RToken set and start a new CONFIRM RKEY exchange from\n   the beginning.\
    \  The timing of this retry is controlled by the C flag,\n   as described below.\n\
    \   The contents of the CONFIRM RKEY LLC message are:\n   Type\n      Type 6 indicates\
    \ CONFIRM RKEY.\n   Length\n      The CONFIRM RKEY LLC message is 44 bytes long.\n\
    \   R\n      Reply flag.  When set, indicates that this is a CONFIRM RKEY\n  \
    \    reply.\n   0\n      Reserved bit.\n   Z\n      Negative response flag.\n\
    \   C\n      Configuration Retry bit.  If this is a negative response and this\n\
    \      flag is set, the originator should recalculate the RKey set and\n     \
    \ retry this exchange as soon as the current configuration change is\n      completed.\
    \  If this flag is not set on a negative response, the\n      originator must\
    \ wait for the next natural stimulus (for example, a\n      new TCP connection\
    \ started that requires a new RMB) before\n      retrying.\n   NumTkns\n     \
    \ The number of other link/RToken pairs, including those provided in\n      this\
    \ message, to be communicated.  Note that this value does not\n      include the\
    \ RToken for the link on which this message was sent\n      (i.e., the maximum\
    \ value is 2).  If this value is 3 or less, this\n      is the only message in\
    \ the exchange.  If this value is greater\n      than 3, a CONFIRM RKEY CONTINUATION\
    \ message will be required.\n      Note: In this version of the architecture,\
    \ eight is the maximum\n      number of links supported in a link group.\n   New\
    \ RMB RKey for this link\n      The new RMB's RKey as assigned on the link over\
    \ which this message\n      is being sent.\n   New RMB virtual address for this\
    \ link\n      The new RMB's virtual address as assigned on the link over which\n\
    \      this message is being sent.\n   Other link RMB specification\n      The\
    \ new RMB's specification on the other links in the link group,\n      as shown\
    \ in Figure 37.\n      0                   1                   2             \
    \      3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Link number   | RMB's RKey for the specified link (bytes 1-3) |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |New\
    \ RKey byte 4|                                               |\n     +-+-+-+-+-+-+-+-+\
    \                                              -+\n     |           RMB's virtual\
    \ address for the specified link        |\n     +-              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               |\n     +-+-+-+-+-+-+-+-+\n                Figure 37: Format\
    \ of Link Number/RKey Pairs\n   Link number\n      The link number for a link\
    \ in the link group.\n   RMB's RKey for the specified link\n      The RKey used\
    \ to reach the RMB over the link whose number was\n      specified in the Link\
    \ number field.\n   RMB's virtual address for the specified link\n      The virtual\
    \ address used to reach the RMB over the link whose\n      number was specified\
    \ in the Link number field.\n"
- title: A.3.6.  CONFIRM RKEY CONTINUATION LLC Message Format
  contents:
  - "A.3.6.  CONFIRM RKEY CONTINUATION LLC Message Format\n      0               \
    \    1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 8     |  Length = 44  |   Reserved    |R|0|Z|  Rsrvd  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  NumTknsLeft\
    \  |                                               |\n     +-+-+-+-+-+-+-+-+ \
    \                                             -+\n     |                     \
    \                                          |\n     +-          Other link RMB\
    \ specification                       -+\n     |                             \
    \                                  |\n     +-              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               |                                               |\n    \
    \ +-+-+-+-+-+-+-+-+                                              -+\n     |  \
    \                                                             |\n     +-   Other\
    \ link RMB specification or zeros                     -+\n     |             \
    \                                                  |\n     +-                \
    \              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |                     \
    \          |                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                              -+\n     |                                    \
    \                           |\n     +-                                       \
    \                      -+\n     |      Other link RMB specification or zeros \
    \                   |\n     +-                                              +-+-+-+-+-+-+-+-+\n\
    \     |                                               |  Reserved     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \  Figure 38: CONFIRM RKEY CONTINUATION LLC Message Format\n   The CONFIRM RKEY\
    \ CONTINUATION LLC message is used to communicate any\n   additional RMB RTokens\
    \ that did not fit into the CONFIRM RKEY\n   message.  Each of these messages\
    \ can hold up to three RMB RTokens.\n   The NumTknsLeft field indicates how many\
    \ RMB RTokens are to be\n   communicated, including the ones in this message.\
    \  If the value is 3\n   or less, this is the last message of the group.  If the\
    \ value is 4 or\n   higher, additional CONFIRM RKEY CONTINUATION messages will\
    \ follow,\n   and the NumTknsLeft value will be a countdown until all are\n  \
    \ communicated.\n   Like the CONFIRM RKEY message, the peer responds by echoing\
    \ the\n   message back with the reply flag set.\n   The contents of the CONFIRM\
    \ RKEY CONTINUATION LLC message are:\n   Type\n      Type 8 indicates CONFIRM\
    \ RKEY CONTINUATION.\n   Length\n      The CONFIRM RKEY CONTINUATION LLC message\
    \ is 44 bytes long.\n   R\n      Reply flag.  When set, indicates that this is\
    \ a CONFIRM RKEY\n      CONTINUATION reply.\n   0\n      Reserved bit.\n   Z\n\
    \      Negative response flag.\n   NumTknsLeft\n      The number of link/RToken\
    \ pairs, including those provided in this\n      message, that are remaining to\
    \ be communicated.  If this value is\n      3 or less, this is the last message\
    \ in the exchange.  If this\n      value is greater than 3, another CONFIRM RKEY\
    \ CONTINUATION message\n      will be required.  Note that in this version of\
    \ the architecture,\n      eight is the maximum number of links supported in a\
    \ link group.\n   Other link RMB specification\n      The new RMB's specification\
    \ on other links in the link group, as\n      shown in Figure 37.\n"
- title: A.3.7.  DELETE RKEY LLC Message Format
  contents:
  - "A.3.7.  DELETE RKEY LLC Message Format\n      0                   1         \
    \          2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 9     |  Length = 44  |   Reserved    |R|0|Z|  Rsrvd  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \   Count     | Error Mask    |        Reserved               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                First deleted RKey                             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \          Second deleted RKey or zeros                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            Third deleted RKey or zeros                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \          Fourth deleted RKey or zeros                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            Fifth deleted RKey or zeros                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \          Sixth deleted RKey or zeros                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            Seventh deleted RKey or zeros                      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \          Eighth deleted RKey or zeros                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       Reserved                                |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \         Figure 39: DELETE RKEY LLC Message Format\n   The DELETE RKEY flow can\
    \ be sent at any time from either the client\n   or the server, to inform the\
    \ peer that one or more RMBs have been\n   deleted.  Because the peer already\
    \ knows every RMB's RKey on each\n   link in the link group, this message only\
    \ specifies one RKey for each\n   RMB being deleted.  The RKey provided for each\
    \ deleted RMB will be\n   its RKey as known on the SMC-R link over which this\
    \ message is sent.\n   It is not necessary to provide the entire RToken.  The\
    \ RKey alone is\n   sufficient for identifying an existing RMB.\n   The peer responds\
    \ by simply echoing the message with the response\n   flag set.  If the peer did\
    \ not recognize an RKey, a negative response\n   flag will be set; however, no\
    \ aggressive recovery action beyond\n   logging the error will be taken.\n   The\
    \ contents of the DELETE RKEY LLC message are:\n   Type\n      Type 9 indicates\
    \ DELETE RKEY.\n   Length\n      The DELETE RKEY LLC message is 44 bytes long.\n\
    \   R\n      Reply flag.  When set, indicates that this is a DELETE RKEY reply.\n\
    \   0\n      Reserved bit.\n   Z\n      Negative response flag.\n   Count\n  \
    \    Number of RMBs being deleted by this message.  Maximum value is 8.\n   Error\
    \ Mask\n      If this is a negative response, indicates which RMBs were not\n\
    \      successfully deleted.  Each bit corresponds to a listed RMB; for\n    \
    \  example, b'01010000' indicates that the second and fourth RKeys\n      weren't\
    \ successfully deleted.\n   Deleted RKeys\n      A list of Count RKeys.  Provided\
    \ on the request flow and echoed\n      back on the response flow.  Each RKey\
    \ is valid on the link over\n      which this message is sent and represents a\
    \ deleted RMB.  Up to\n      eight RMBs can be deleted in this message.\n"
- title: A.3.8.  TEST LINK LLC Message Format
  contents:
  - "A.3.8.  TEST LINK LLC Message Format\n      0                   1           \
    \        2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Type = 7     |  Length = 44  |   Reserved    |R|  Reserved   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +-     \
    \                                                        -+\n     |          \
    \                                                     |\n     +-             \
    \            User Data                           -+\n     |                  \
    \                                             |\n     +-                     \
    \                                        -+\n     |                          \
    \                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +-                                                             -+\n     |  \
    \                                                             |\n     +-     \
    \                                                        -+\n     |          \
    \                Reserved                             |\n     +-             \
    \                                                -+\n     |                  \
    \                                             |\n     +-                     \
    \                                        -+\n     |                          \
    \                                     |\n     +-                             \
    \                                -+\n     |                                  \
    \                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 40: TEST LINK LLC Message Format\n   The TEST LINK request\
    \ can be sent from either peer to the other on an\n   existing SMC-R link at any\
    \ time to test that the SMC-R link is active\n   and healthy at the software level.\
    \  A peer that receives a TEST LINK\n   LLC message immediately sends back a TEST\
    \ LINK reply, echoing back\n   the user data.  Refer also to Section 4.5.3 (\"\
    TCP Keepalive\n   Processing\").\n   The contents of the TEST LINK LLC message\
    \ are:\n   Type\n      Type 7 indicates TEST LINK.\n   Length\n      The TEST\
    \ LINK LLC message is 44 bytes long.\n   R\n      Reply flag.  When set, indicates\
    \ that this is a TEST LINK reply.\n   User Data\n      The receiver of this message\
    \ echoes the sender's data back in a\n      TEST LINK response LLC message.\n"
- title: A.4.  Connection Data Control (CDC) Message Format
  contents:
  - "A.4.  Connection Data Control (CDC) Message Format\n   The RMBE control data\
    \ is communicated using Connection Data Control\n   (CDC) messages, which use\
    \ RoCE SendMsg, similar to LLC messages.\n   Also, as with LLC messages, CDC messages\
    \ are 44 bytes long to ensure\n   that they can fit into private data areas of\
    \ receive WQEs without\n   requiring the receiver to post receive buffers.\n \
    \  Unlike LLC messages, this data is integral to the data path, so its\n   processing\
    \ must be prioritized and optimized similarly to other data\n   path processing.\
    \  While LLC messages may be processed on a slower\n   path than data, these messages\
    \ cannot be.\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   0  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   | Type = x'FE'  | Length = 44   |      Sequence number          |\n   4  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       SMC-R alert token                       |\n   8\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \         Reserved              | Producer cursor wrap seqno    |\n   12 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Producer Cursor                         |\n   16\
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      | \
    \        Reserved              | Consumer cursor wrap seqno    |\n   20 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Consumer Cursor                         |\n   24\
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |B|P|U|R|F|Rsrvd|D|C|A|\
    \             Reserved                    |\n   28 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   32\
    \ +-                                                             -+\n      | \
    \                                                              |\n   36 +-   \
    \                      Reserved                            -+\n      |       \
    \                                                        |\n   40 +-         \
    \                                                    -+\n      |             \
    \                                                  |\n   44 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 41: Connection Data Control (CDC) Message Format\n   Type =\
    \ x'FE'\n      This type number has the two high-order bits turned on to enable\n\
    \      processing to quickly distinguish it from an LLC message.\n   Length =\
    \ 44\n      The length of inline data that does not require the posting of a\n\
    \      receive buffer.\n   Sequence number\n      A 2-byte unsigned integer that\
    \ represents a wrapping sequence\n      number.  The initial value is 1, and this\
    \ value can wrap to 0.\n      Incremented with every control message sent, except\
    \ for the\n      failover data validation message, and used to guard against\n\
    \      processing an old control message out of sequence.  Also used in\n    \
    \  failover data validation.  In normal usage, if this number is less\n      than\
    \ the last received value, discard this message.  If greater,\n      process this\
    \ message.  Old control messages can be lost with no\n      ill effect but cannot\
    \ be processed after newer ones.\n      If this is a failover validation CDC message\
    \ (F flag set), then\n      the receiver must verify that it has received and\
    \ fully processed\n      the RDMA write that was described by the CDC message\
    \ with the\n      sequence number in this message.  If not, the TCP connection\
    \ must\n      be reset to guard against data loss.  Details of this processing\n\
    \      are provided in Section 4.6.1.\n   SMC-R alert token\n      The endpoint-assigned\
    \ alert token that identifies to which TCP\n      connection on the link group\
    \ this control message refers.\n   Producer cursor wrap seqno\n      A 2-byte\
    \ unsigned integer that represents a wrapping counter\n      incremented by the\
    \ producer whenever the data written into this\n      RMBE receive buffer causes\
    \ a wrap (i.e., the producer cursor\n      wraps).  This is used by the receiver\
    \ to determine when new data\n      is available even though the cursors appear\
    \ unchanged, such as\n      when a full window size write is completed (producer\
    \ cursor of\n      this RMBE sent by peer = local consumer cursor) or in scenarios\n\
    \      where the producer cursor sent for this RMBE < local consumer\n      cursor.\n\
    \   Producer Cursor\n      A 4-byte unsigned integer that is a wrapping offset\
    \ into the RMBE\n      data area.  Points to the next byte of data to be written\
    \ by the\n      sender.  Can advance up to the receiver's consumer cursor as known\n\
    \      by the sender.  When the urgent data present indicator is on,\n      points\
    \ 1 byte beyond the last byte of urgent data.  When computing\n      this cursor,\
    \ the presence of the eye catcher in the RMBE data area\n      must be accounted\
    \ for.  The first writable data location in the\n      RMBE is at offset 4, so\
    \ this cursor begins at 4 and wraps to 4.\n   Consumer cursor wrap seqno\n   \
    \   A 2-byte unsigned integer that mirrors the value of the producer\n      cursor\
    \ wrap sequence number when the last read from this RMBE\n      occurred.  Used\
    \ as an indicator of how far along the consumer is\n      in reading data (i.e.,\
    \ processed last wrap point or not).  The\n      producer side can use this indicator\
    \ to detect whether or not more\n      data can be written to the partner in full\
    \ window write scenarios\n      (where the producer cursor = consumer cursor as\
    \ known on the\n      remote RMBE).  In this scenario, if the consumer sequence\
    \ number\n      equals the local producer sequence number, the producer knows\
    \ that\n      more data can be written.\n   Consumer Cursor\n      A 4-byte unsigned\
    \ integer that is a wrapping offset into the\n      sender's RMBE data area. \
    \ Points to the offset of the next byte of\n      data to be consumed by the peer\
    \ in its own RMBE.  When computing\n      this cursor, the presence of the eye\
    \ catcher in the RMBE data area\n      must be accounted for.  The first writable\
    \ data location in the\n      RMBE is at offset 4, so this cursor begins at 4\
    \ and wraps to 4.\n      The sender cannot write beyond this cursor into the peer's\
    \ RMBE\n      without causing data loss.\n   B-bit\n      Writer blocked indicator:\
    \ Sender is blocked for writing.  If this\n      bit is set, sender will require\
    \ explicit notification when receive\n      buffer space is available.\n   P-bit\n\
    \      Urgent data pending: Sender has urgent data pending for this\n      connection.\n\
    \   U-bit\n      Urgent data present: Indicates that urgent data is present in\
    \ the\n      RMBE data area, and the producer cursor points to 1 byte beyond\n\
    \      the last byte of urgent data.\n   R-bit\n      Request for consumer cursor\
    \ update: Indicates that an immediate\n      consumer cursor update is requested,\
    \ regardless of whether or not\n      one is warranted according to the window\
    \ size optimization\n      algorithm described in Section 4.5.1.\n   F-bit\n \
    \     Failover validation indicator: Sent by a peer to guard against\n      data\
    \ loss during failover when the TCP connection is being moved\n      to another\
    \ SMC-R link in the link group.  When this bit is set,\n      the only other fields\
    \ in the CDC message that are significant are\n      the Type, Length, SMC-R alert\
    \ token, and Sequence number fields.\n      The receiver must validate that it\
    \ has fully processed the RDMA\n      write described by the previous CDC message\
    \ bearing the same\n      sequence number as this validation message.  If it has,\
    \ no further\n      action is required.  If it has not, the TCP connection must\
    \ be\n      reset.  This processing is described in detail in Section 4.6.1.\n\
    \   D-bit\n      Sending done indicator: Sent by a peer when it is done writing\
    \ new\n      data into the receiver's RMBE data area.\n   C-bit\n      PeerConnectionClosed\
    \ indicator: Sent by a peer when it is\n      completely done with this connection\
    \ and will no longer be making\n      any updates to the receiver's RMBE or sending\
    \ any more control\n      messages.\n   A-bit\n      Abnormal close indicator:\
    \ Sent by a peer when the connection is\n      abnormally terminated (for example,\
    \ the TCP connection was reset).\n      When sent, it indicates that the peer\
    \ is completely done with this\n      connection and will no longer be making\
    \ any updates to this RMBE\n      or sending any more control messages.  It also\
    \ indicates that the\n      RMBE owner must flush any remaining data on this connection\
    \ and\n      generate an error return code to any outstanding socket APIs on\n\
    \      this connection (same processing as receiving a RST segment on a\n    \
    \  TCP connection).\n"
- title: Appendix B.  Socket API Considerations
  contents:
  - "Appendix B.  Socket API Considerations\n   A key design goal for SMC-R is to\
    \ require no application changes for\n   exploitation.  It is confined to socket\
    \ applications using stream\n   (i.e., TCP) sockets over IPv4 or IPv6.  By virtue\
    \ of the fact that\n   the switch to the SMC-R protocol occurs after a TCP connection\
    \ is\n   established, no changes are required in a socket address family or in\n\
    \   the IP addresses and ports that the socket applications are using.\n   Existing\
    \ socket APIs that allow applications to retrieve local and\n   remote socket\
    \ address structures for an established TCP connection\n   (for example, getsockname()\
    \ and getpeername()) will continue to\n   function as they have before.  Existing\
    \ DNS setup and APIs for\n   resolving hostnames to IP addresses and vice versa\
    \ also continue to\n   function without any changes.  In general, all of the usual\
    \ socket\n   APIs that are used for TCP communications (send APIs, recv APIs,\n\
    \   etc.) will continue to function as they do today, even if SMC-R is\n   used\
    \ as the underlying protocol.\n   Each SMC-R-enabled implementation does, however,\
    \ need to pay special\n   attention to any socket APIs that have a reliance on\
    \ the underlying\n   TCP and IP protocols and also ensure that their behavior\
    \ in an SMC-R\n   environment is reasonable and minimizes impact on the application.\n\
    \   While the basic socket API set is fairly similar across different\n   operating\
    \ systems, there is more variability when it comes to\n   advanced socket API\
    \ options.  Each implementation needs to perform a\n   detailed analysis of its\
    \ API options, any possible impact that SMC-R\n   may have, and any resultant\
    \ implications.  As part of that step, a\n   discussion or review with other implementations\
    \ supporting SMC-R\n   would be useful to ensure consistent implementation.\n"
- title: B.1.  setsockopt() / getsockopt() Considerations
  contents:
  - "B.1.  setsockopt() / getsockopt() Considerations\n   These APIs allow socket\
    \ applications to manipulate socket, transport\n   (TCP/UDP), and IP-level options\
    \ associated with a given socket.\n   Typically, a platform restricts the number\
    \ of IP options available to\n   stream (TCP) socket applications, given their\
    \ connection-oriented\n   nature.  The general guideline here is to continue processing\
    \ these\n   APIs in a manner that allows for application compatibility.  Some\n\
    \   options will be relevant to the SMC-R protocol and will require\n   special\
    \ processing \"under the covers\".  For example, the ability to\n   manipulate\
    \ TCP send and receive buffer sizes is still valid for\n   SMC-R.  However, other\
    \ options may have no meaning for SMC-R.  For\n   example, if an application enabled\
    \ the TCP_NODELAY socket option to\n   disable Nagle's algorithm, it should have\
    \ no real effect on SMC-R\n   communications, as there is no notion of Nagle's\
    \ algorithm with this\n   new protocol.  But the implementation must accept the\
    \ TCP_NODELAY\n   option as it does today and save it so that it can be later\
    \ extracted\n   via getsockopt() processing.  Note that any TCP or IP-level options\n\
    \   will still have an effect on any TCP/IP packets flowing for an SMC-R\n   connection\
    \ (i.e., as part of TCP/IP connection establishment and\n   TCP/IP connection\
    \ termination packet flows).\n   Under the covers, manipulation of the TCP options\
    \ will also include\n   the SMC-layer setting, as well as reading the SMC-R experimental\n\
    \   option before and after completion of the three-way TCP handshake.\n"
- title: Appendix C.  Rendezvous Error Scenarios
  contents:
  - "Appendix C.  Rendezvous Error Scenarios\n   This section discusses error scenarios\
    \ for setting up and managing\n   SMC-R links.\n"
- title: C.1.  SMC Decline during CLC Negotiation
  contents:
  - "C.1.  SMC Decline during CLC Negotiation\n   A peer to the SMC-R CLC negotiation\
    \ can send an SMC Decline in lieu\n   of any expected CLC message to decline SMC\
    \ and force the TCP\n   connection back to the IP fabric.  There can be several\
    \ reasons for\n   an SMC Decline during the CLC negotiation, including the following:\n\
    \   o  RNIC went down\n   o  SMC-R forbidden by local policy\n   o  subnet (IPv4)\
    \ or prefix (IPv6) doesn't match\n   o  lack of resources to perform SMC-R\n \
    \  In all cases, when an SMC Decline is sent in lieu of an expected CLC\n   message,\
    \ no confirmation is required, and the TCP connection\n   immediately falls back\
    \ to using the IP fabric.\n   To prevent ambiguity between CLC messages and application\
    \ data, an\n   SMC Decline cannot \"chase\" another CLC message.  An SMC Decline\
    \ can\n   only be sent in lieu of an expected CLC message.  For example, if the\n\
    \   client sends an SMC Proposal and then its RNIC goes down, it must\n   wait\
    \ for the SMC Accept from the server and then reply to the\n   SMC Accept with\
    \ an SMC Decline.\n   This \"no chase\" rule means that if this TCP connection\
    \ is not a first\n   contact between RoCE peers, a server cannot send an SMC Decline\
    \ after\n   sending an SMC Accept -- it can only either break the TCP connection\n\
    \   or fail over if a problem arises in the RoCE fabric after it has sent\n  \
    \ the SMC Accept.  Similarly, once the client sends an SMC Confirm on a\n   TCP\
    \ connection that isn't a first contact, it is committed to SMC-R\n   for this\
    \ TCP connection and cannot fall back to IP.\n"
- title: C.2.  SMC Decline during LLC Negotiation
  contents:
  - "C.2.  SMC Decline during LLC Negotiation\n   For a TCP connection that represents\
    \ a first contact between RoCE\n   pairs, it is possible for SMC to fall back\
    \ to IP during the LLC\n   negotiation.  This is possible until the first contact\
    \ SMC-R link is\n   confirmed.  For example, see Figure 42.  After a first contact\
    \ SMC-R\n   link is confirmed, fallback to IP is no longer possible.  This\n \
    \  translates to the following rule: a first contact peer can send an\n   SMC\
    \ Decline at any time during LLC negotiation until it has\n   successfully sent\
    \ its CONFIRM LINK (request or response) flow.  After\n   that point, it cannot\
    \ fall back to IP.\n       Host X -- Server                           Host Y --\
    \ Client\n    +-------------------+                      +-------------------+\n\
    \    | Peer ID = PS1     |                      |   Peer ID = PC1   |\n    | \
    \           +------+                      +------+            |\n    |       QP\
    \ 8 |RNIC 1|    SMC-R Link 1      |RNIC 2|  QP 64     |\n    | RKey X |   |MAC\
    \ MA|<-------------------->|MAC MB|   |        |\n    |        |   |GID GA|  \
    \ attempted setup    |GID GB|   | RKey Y2|\n    |       \\/   +------+       \
    \               +------+  \\/        |\n    |+--------+         |            \
    \          |        +--------+ |\n    || RMB    |         |                  \
    \    |        | RMB    | |\n    |+--------+         |                      | \
    \       +--------+ |\n    |       /\\   +------+                      +------+\
    \  /\\        |\n    |        |   |RNIC 3|                      |RNIC 4|   | RKey\
    \ W2|\n    |        |   |MAC MC|                      |MAC MD|   |        |\n\
    \    |       QP 9 |GID GC|                      |GID GD|  QP 65     |\n    | \
    \           +------+                      +------+            |\n    +-------------------+\
    \                      +-------------------+\n          SYN / SYN-ACK / ACK TCP\
    \ three-way handshake with TCP option\n         <--------------------------------------------------------->\n\
    \            SMC Proposal / SMC Accept / SMC Confirm exchange\n         <-------------------------------------------------------->\n\
    \           CONFIRM LINK(request, Link 1)\n         .........................................................>\n\
    \                           CONFIRM LINK(response, Link 1)\n                 \
    \             X...................................\n                         \
    \       :\n                                : RoCE write failure\n            \
    \                    :.................................>\n           SMC Decline(PC1,\
    \ reason code)\n          <--------------------------------------------------------\n\
    \              Connection data flows over IP fabric\n          <------------------------------------------------------->\n\
    \                          Legend:\n                   ------------   TCP/IP and\
    \ CLC flows\n                   ............   RoCE (LLC) flows\n            \
    \   Figure 42: SMC Decline during LLC Negotiation\n"
- title: C.3.  The SMC Decline Window
  contents:
  - "C.3.  The SMC Decline Window\n   Because SMC-R does not support fallback to IP\
    \ for a TCP connection\n   that is already using RDMA, there are specific rules\
    \ on when the\n   SMC Decline CLC message, which signals a fallback to IP because\
    \ of an\n   error or problem with the RoCE fabric, can be sent during TCP\n  \
    \ connection setup.  There is a \"point of no return\" after which a\n   connection\
    \ cannot fall back to IP, and RoCE errors that occur after\n   this point require\
    \ the connection to be broken with a RST flow in the\n   IP fabric.\n   For a\
    \ first contact, that point of no return is after the ADD LINK\n   LLC message\
    \ has been successfully sent for the second SMC-R link.\n   Specifically, the\
    \ server cannot fall back to IP after receiving\n   either (1) a positive write\
    \ completion indication for the ADD LINK\n   request or (2) the ADD LINK response\
    \ from the client, whichever comes\n   first.  The client cannot fall back to\
    \ IP after sending a negative\n   ADD LINK response, receiving a positive write\
    \ complete on a positive\n   ADD LINK response, or receiving a CONFIRM LINK for\
    \ the second SMC-R\n   link from the server, whichever comes first.\n   For a\
    \ subsequent contact, that point of no return is after the last\n   send of the\
    \ CLC negotiation completes.  This, in combination with the\n   rule that error\
    \ \"chasers\" are not allowed during CLC negotiation,\n   means that the server\
    \ cannot send an SMC Decline after sending an SMC\n   Accept, and the client cannot\
    \ send an SMC Decline after sending an\n   SMC Confirm.\n"
- title: C.4.  Out-of-Sync Conditions during SMC-R Negotiation
  contents:
  - "C.4.  Out-of-Sync Conditions during SMC-R Negotiation\n   The SMC Accept CLC\
    \ message contains a first contact flag that\n   indicates to the client whether\
    \ the server believes it is setting up\n   a new link group or using an existing\
    \ link group.  This flag is used\n   to detect an out-of-sync condition between\
    \ the client and the server.\n   The scenario for such a condition is as follows:\
    \ there is a single\n   existing SMC-R link between the peers.  After the client\
    \ sends the\n   SMC Proposal CLC message, the existing SMC-R link between the\
    \ client\n   and the server fails.  The client cannot chase the SMC Proposal CLC\n\
    \   message with an SMC Decline CLC message in this case, because the\n   client\
    \ does not yet know that the server would have wanted to choose\n   the SMC-R\
    \ link that just crashed.  The QP that failed recovers before\n   the server returns\
    \ its SMC Accept CLC message.  This means that there\n   is a QP but no SMC-R\
    \ link.  Since the server had not yet learned of\n   the SMC-R link failure when\
    \ it sent the SMC Accept CLC message, it\n   attempts to reuse the SMC-R link\
    \ that just failed.  This means that\n   the server would not set the first contact\
    \ flag, indicating to the\n   client that the server thinks it is reusing an SMC-R\
    \ link.  However,\n   the client does not have an SMC-R link that matches the\
    \ server's\n   specification.  Because the first contact flag is off, the client\n\
    \   realizes it is out of sync with the server and sends an SMC Decline\n   to\
    \ cause the connection to fall back to IP.\n"
- title: C.5.  Timeouts during CLC Negotiation
  contents:
  - "C.5.  Timeouts during CLC Negotiation\n   Because the SMC-R negotiation flows\
    \ as TCP data, there are built-in\n   timeouts and retransmits at the TCP layer\
    \ for individual messages.\n   Implementations also must protect the overall TCP/CLC\
    \ handshake with\n   a timer or timers to prevent connections from hanging indefinitely\n\
    \   due to SMC-R processing.  This can be done with individual timers for\n  \
    \ individual CLC messages or an overall timer for the entire exchange,\n   which\
    \ may include the TCP handshake and the CLC handshake under one\n   timer or separate\
    \ timers.  This decision is implementation dependent.\n   If the TCP and/or CLC\
    \ handshakes time out, the TCP connection must be\n   terminated as it would be\
    \ in a legacy IP environment when connection\n   setup doesn't complete in a timely\
    \ manner.  Because the CLC flows are\n   TCP messages, if they cannot be sent\
    \ and received in a timely\n   fashion, the TCP connection is not healthy and\
    \ would not work if\n   fallback to IP were attempted.\n"
- title: C.6.  Protocol Errors during CLC Negotiation
  contents:
  - "C.6.  Protocol Errors during CLC Negotiation\n   Protocol errors occur during\
    \ CLC negotiation when a message is\n   received that is not expected.  For example,\
    \ a peer that is expecting\n   a CLC message but instead receives application\
    \ data has experienced a\n   protocol error; this also indicates a likely software\
    \ error, as the\n   two sides are out of sync.  When application data is expected,\
    \ this\n   data is not parsed to ensure that it's not a CLC message.\n   When\
    \ a peer is expecting a CLC negotiation message, any parsing error\n   except\
    \ a bad enumerated value in that message must be treated as\n   application data.\
    \  The CLC negotiation messages are designed with\n   beginning and ending eye\
    \ catchers to help verify that a CLC\n   negotiation message is actually the expected\
    \ message.  If other\n   parsing errors in an expected CLC message occur, such\
    \ as incorrect\n   length fields or incorrectly formatted fields, the message\
    \ must be\n   treated as application data.\n   All protocol errors, with the exception\
    \ of bad enumerated values,\n   must result in termination of the TCP connection.\
    \  No fallback to IP\n   is allowed in the case of a protocol error, because if\
    \ the protocols\n   are out of sync, mismatched, or corrupted, then data and security\n\
    \   integrity cannot be ensured.\n   The exception to this rule is enumerated\
    \ values -- for example, the\n   QP MTU values on SMC Accept and SMC Confirm.\
    \  If a reserved value is\n   received, the proper error response is to send an\
    \ SMC Decline and\n   fall back to IP; this is because the use of a reserved enumerated\n\
    \   value indicates that the other partner likely has additional support\n   that\
    \ the receiving partner does not have.  This indicated mismatch of\n   SMC-R capabilities\
    \ is not an integrity problem but indicates that\n   SMC-R cannot be used for\
    \ this connection.\n"
- title: C.7.  Timeouts during LLC Negotiation
  contents:
  - "C.7.  Timeouts during LLC Negotiation\n   Whenever a peer sends an LLC message\
    \ to which a reply is expected, it\n   sets a timer after the send posts to wait\
    \ for the reply.  An expected\n   response may be a reply flavor of the LLC message\
    \ (for example, a\n   CONFIRM LINK reply) or a new LLC message (for example, an\
    \ ADD LINK\n   CONTINUATION expected from the server by the client if there are\
    \ more\n   RKeys to be communicated).\n   On LLC flows that are part of a first\
    \ contact setup of a link group,\n   the value of the timer is implementation\
    \ dependent but should be long\n   enough to allow the other peer to have a write\
    \ complete timeout and\n   2-3 retransmits of an SMC Decline on the TCP fabric.\
    \  For LLC flows\n   that are maintaining the link group and are not part of a\
    \ first\n   contact setup of a link group, the timers may be shorter.  Upon\n\
    \   receipt of an expected reply, the timer is cancelled.  If a timer\n   pops\
    \ without a reply having been received, the sender must initiate a\n   recovery\
    \ action.\n   During first contact processing, failure of an LLC verification\
    \ timer\n   is a \"should-not-occur\" that indicates a problem with one of the\n\
    \   endpoints; this is because if there is a \"routine\" failure in the\n   RoCE\
    \ fabric that causes an LLC verification send to fail, the sender\n   will get\
    \ a write completion failure and will then send an SMC Decline\n   to the partner.\
    \  The only time an LLC verification timer will expire\n   on a first contact\
    \ is when the sender thinks the send succeeded but\n   it actually didn't.  Because\
    \ of the reliably connected nature of QP\n   connections on the RoCE fabric, this\
    \ indicates a problem with one of\n   the peers, not with the RoCE fabric.\n \
    \  After the reliably connected queue pair for the first SMC-R link in a\n   link\
    \ group is set up on initial contact, the client sets a timer to\n   wait for\
    \ a RoCE verification message from the server that the QP is\n   actually connected\
    \ and usable.  If the server experiences a failure\n   sending its QP confirmation\
    \ message, it will send an SMC Decline,\n   which should arrive at the client\
    \ before the client's verification\n   timer expires.  If the client's timer expires\
    \ without receiving\n   either an SMC Decline or a RoCE message confirmation from\
    \ the server,\n   there is a problem with either the server or the TCP fabric.\
    \  In\n   either case, the client must break the TCP connection and clean up\n\
    \   the SMC-R link.\n   There are two scenarios in which the client's response\
    \ to the QP\n   verification message fails to reach the server.  The main difference\n\
    \   is whether or not the client has successfully completed the send of\n   the\
    \ CONFIRM LINK response.\n   In the normal case of a problem with the RoCE path,\
    \ the client will\n   learn of the failure by getting a write completion failure,\
    \ before\n   the server's timer expires.  In this case, the client sends an SMC\n\
    \   Decline CLC message to the server, and the TCP connection falls back\n   to\
    \ IP.\n   If the client's send of the confirmation message receives a positive\n\
    \   return code but for some reason still does not reach the server, or\n   the\
    \ client's SMC Decline CLC message fails to reach the server after\n   the client\
    \ fails to send its RoCE confirmation message, then the\n   server's timer will\
    \ time out and the server must break the TCP\n   connection by sending a RST.\
    \  This is expected to be a very rare\n   case, because if the client cannot send\
    \ its CONFIRM LINK response LLC\n   message, the client should get a negative\
    \ return code and initiate\n   fallback to IP.  A client receiving a positive\
    \ return code on a send\n   that fails to reach the server should also be an extremely\
    \ rare case.\n"
- title: C.7.1.  Recovery Actions for LLC Timeouts and Failures
  contents:
  - "C.7.1.  Recovery Actions for LLC Timeouts and Failures\n   The following list\
    \ describes recovery actions for LLC timeouts.  A\n   write completion failure\
    \ or other indication of send failure for an\n   LLC command is treated the same\
    \ as a timeout.\n   LLC message: CONFIRM LINK from server (first contact, first\
    \ link in\n   the link group)\n      Timer waits for: CONFIRM LINK reply from\
    \ client.\n      Recovery action: Break the TCP connection by sending a RST, and\n\
    \      clean up the link.  The server should have received an SMC Decline\n  \
    \    from the client by now if the client had an LLC send failure.\n   LLC message:\
    \ CONFIRM LINK from server (first contact, second link in\n   the link group)\n\
    \      Timer waits for: CONFIRM LINK reply from client.\n      Recovery action:\
    \ The second link was not successfully set up.\n      Send a DELETE LINK to the\
    \ client.  Connection data cannot flow in\n      the first link in the link group,\
    \ until the reply to this DELETE\n      LINK is received, to prevent the peers\
    \ from being out of sync on\n      the state of the link group.\n   LLC message:\
    \ CONFIRM LINK from server (not first contact)\n      Timer waits for: CONFIRM\
    \ LINK reply from client.\n      Recovery action: Clean up the new link, and set\
    \ a timer to retry.\n      Send a DELETE LINK to the client, in case the client\
    \ has a longer\n      timer interval, so the client can stop waiting.\n   LLC\
    \ message: CONFIRM LINK reply from client (first contact)\n      Timer waits for:\
    \ ADD LINK from server.\n      Recovery action: Clean up the SMC-R link, and break\
    \ the TCP\n      connection by sending a RST over the IP fabric.  There is a\n\
    \      problem with the server.  If the server had a send failure, it\n      should\
    \ have sent an SMC Decline by now.\n   LLC message: ADD LINK from server (first\
    \ contact)\n      Timer waits for: ADD LINK reply from client.\n      Recovery\
    \ action: Break the TCP connection with a RST, and clean up\n      RoCE resources.\
    \  The connection is past the point where the server\n      can fall back to IP,\
    \ and if the client had a send problem it\n      should have sent an SMC Decline\
    \ by now.\n   LLC message: ADD LINK from server (not first contact)\n      Timer\
    \ waits for: ADD LINK reply from client.\n      Recovery action: Clean up resources\
    \ (QP, RKeys, etc.) for the new\n      link, and treat the link over which the\
    \ ADD LINK was sent as if it\n      had failed.  If there is another link available\
    \ to resend the\n      ADD LINK and the link group still needs another link, retry\
    \ the\n      ADD LINK over another link in the link group.\n   LLC message: ADD\
    \ LINK reply from client (and there are more RKeys to\n   be communicated)\n \
    \     Timer waits for: ADD LINK CONTINUATION from server.\n      Recovery action:\
    \ Treat the same as ADD LINK timer failure.\n   LLC message: ADD LINK reply or\
    \ ADD LINK CONTINUATION reply from\n   client (and there are no more RKeys to\
    \ be communicated, for the\n   second link in a first contact scenario)\n    \
    \  Timer waits for: CONFIRM LINK from the server, over the new link.\n      Recovery\
    \ action: The setup of the new link failed.  Send a\n      DELETE LINK to the\
    \ server.  Do not consider the socket opened to\n      the client application\
    \ until receiving confirmation from the\n      server in the form of a DELETE\
    \ LINK request for this link and\n      sending the reply (to prevent the partners\
    \ from being out of sync\n      on the state of the link group).\n      Set a\
    \ timer to send another ADD LINK to the server if there is\n      still an unused\
    \ RNIC on the client side.\n   LLC message: ADD LINK reply or ADD LINK CONTINUATION\
    \ reply from\n   client (and there are no more RKeys to be communicated)\n   \
    \   Timer waits for: CONFIRM LINK from the server, over the new link.\n      Recovery\
    \ action: Send a DELETE LINK to the server for the new\n      link, then clean\
    \ up any resource allocated for the new link and\n      set a timer to send an\
    \ ADD LINK to the server if there is still an\n      unused RNIC on the client\
    \ side.  The setup of the new link failed,\n      but the link over which the\
    \ ADD LINK exchange occurred is\n      unaffected.\n   LLC message: ADD LINK CONTINUATION\
    \ from server\n      Timer waits for: ADD LINK CONTINUATION reply from client.\n\
    \      Recovery action: Treat the same as ADD LINK timer failure.\n   LLC message:\
    \ ADD LINK CONTINUATION reply from client (first contact,\n   and RMB count fields\
    \ indicate that the server owes more ADD LINK\n   CONTINUATION messages)\n   \
    \   Timer waits for: ADD LINK CONTINUATION from server.\n      Recovery action:\
    \ Clean up the SMC-R link, and break the TCP\n      connection by sending a RST.\
    \  There is a problem with the server.\n      If the server had a send failure,\
    \ it should have sent an\n      SMC Decline by now.\n   LLC message: ADD LINK\
    \ CONTINUATION reply from client (not first\n   contact, and RMB count fields\
    \ indicate that the server owes more\n   ADD LINK CONTINUATION messages)\n   \
    \   Timer waits for: ADD LINK CONTINUATION from server.\n      Recovery action:\
    \ Treat as if client detected link failure on the\n      link that the ADD LINK\
    \ exchange is using.  Send a DELETE LINK to\n      the server over another active\
    \ link if one exists; otherwise,\n      clean up the link group.\n   LLC message:\
    \ DELETE LINK from client\n      Timer waits for: DELETE LINK request from server.\n\
    \      Recovery action: If the scope of the request is to delete a single\n  \
    \    link, the surviving link over which the client sent the\n      DELETE LINK\
    \ is no longer usable either.  If this is the last link\n      in the link group,\
    \ end TCP connections over the link group by\n      sending RST packets.  If there\
    \ are other surviving links in the\n      link group, resend over a surviving\
    \ link.  Also send a DELETE LINK\n      over a surviving link for the link over\
    \ which the client attempted\n      to send the initial DELETE LINK message. \
    \ If the scope of the\n      request is to delete the entire link group, try resending\
    \ on other\n      links in the link group until success is achieved.  If all sends\n\
    \      fail, tear down the link group and any TCP connections that exist\n   \
    \   on it.\n   LLC message: DELETE LINK from server (scope: entire link group)\n\
    \      Timer waits for: Confirmation from the adapter that the message\n     \
    \ was delivered.\n      Recovery action: Tear down the link group and any TCP\
    \ connections\n      that exist on it.\n   LLC message: DELETE LINK from server\
    \ (scope: single link)\n      Timer waits for: DELETE LINK reply from client.\n\
    \      Recovery action: The link over which the server sent the\n      DELETE\
    \ LINK is no longer usable either.  If this is the last link\n      in the link\
    \ group, end TCP connections over the link group by\n      sending RST packets.\
    \  If there are other surviving links in the\n      link group, resend over a\
    \ surviving link.  Also send a DELETE LINK\n      over a surviving link for the\
    \ link over which the server attempted\n      to send the initial DELETE LINK\
    \ message.  If the scope of the\n      request is to delete the entire link group,\
    \ try resending on other\n      links in the link group until success is achieved.\
    \  If all sends\n      fail, tear down the link group and any TCP connections\
    \ that exist\n      on it.\n   LLC message: CONFIRM RKEY from client\n      Timer\
    \ waits for: CONFIRM RKEY reply from server.\n      Recovery action: Perform normal\
    \ client procedures for detection of\n      failed link.  The link over which\
    \ the message was sent has failed.\n   LLC message: CONFIRM RKEY from server\n\
    \      Timer waits for: CONFIRM RKEY reply from client.\n      Recovery action:\
    \ Perform normal server procedures for detection of\n      failed link.  The link\
    \ over which the message was sent has failed.\n   LLC message: TEST LINK from\
    \ client\n      Timer waits for: TEST LINK reply from server.\n      Recovery\
    \ action: Perform normal client procedures for detection of\n      failed link.\
    \  The link over which the message was sent has failed.\n   LLC message: TEST\
    \ LINK from server\n      Timer waits for: TEST LINK reply from client.\n    \
    \  Recovery action: Perform normal server procedures for detection of\n      failed\
    \ link.  The link over which the message was sent has failed.\n   The following\
    \ list describes recovery actions for invalid LLC\n   messages.  These could be\
    \ misformatted or contain out-of-sync data.\n   LLC message received: CONFIRM\
    \ LINK from server\n      What it indicates: Incorrect link information.\n   \
    \   Recovery action: Protocol error.  The link must be brought down by\n     \
    \ sending a DELETE LINK for the link over another link in the link\n      group\
    \ if one exists.  If this is a first contact, fall back to IP\n      by sending\
    \ an SMC Decline to the server.\n   LLC message received: ADD LINK\n      What\
    \ it indicates: Undefined enumerated MTU value.\n      Recovery action: Send a\
    \ negative ADD LINK reply with reason\n      code x'2'.\n   LLC message received:\
    \ ADD LINK reply from client\n      What it indicates: Client-side link information\
    \ that would result\n      in a parallel link being set up.\n      Recovery action:\
    \ Parallel links are not permitted.  Delete the\n      link by sending a DELETE\
    \ LINK to the client over another link in\n      the link group.\n   LLC message\
    \ received: Any link group command from the server, except\n   DELETE LINK for\
    \ the entire link group\n      What it indicates: Client has sent a DELETE LINK\
    \ for the link on\n      which the message was received.\n      Recovery action:\
    \ Ignore the LLC message.  Worst case: the server\n      will time out.  Best\
    \ case: the DELETE LINK crosses with the\n      command from the server, and the\
    \ server realizes it failed.\n   LLC message received: ADD LINK CONTINUATION from\
    \ server or ADD LINK\n   CONTINUATION reply from client\n      What it indicates:\
    \ Number of RMBs provided doesn't match count\n      given on initial ADD LINK\
    \ or ADD LINK reply message.\n      Recovery action: Protocol error.  Treat as\
    \ if detected link\n      outage.\n   LLC message received: DELETE LINK from client\n\
    \      What it indicates: Link indicated doesn't exist.\n      Recovery action:\
    \ If the link is in the process of being cleaned\n      up, assume timing window\
    \ and ignore message.  Otherwise, send a\n      DELETE LINK reply with reason\
    \ code 1.\n   LLC message received: DELETE LINK from server\n      What it indicates:\
    \ Link indicated doesn't exist.\n      Recovery action: Send a DELETE LINK reply\
    \ with reason code 1.\n   LLC message received: CONFIRM RKEY from either client\
    \ or server\n      What it indicates: No RKey provided for one or more of the\
    \ links\n      in the link group.\n      Recovery action: Treat as if detected\
    \ failure of the link(s) for\n      which no RKey was provided.\n   LLC message\
    \ received: DELETE RKEY\n      What it indicates: Specified RKey doesn't exist.\n\
    \      Recovery action: Send a negative DELETE RKEY response.\n   LLC message\
    \ received: TEST LINK reply\n      What it indicates: User data doesn't match\
    \ what was sent in the\n      TEST LINK request.\n      Recovery action: Treat\
    \ as if detected that the link has gone down.\n      This is a protocol error.\n\
    \   LLC message received: Unknown LLC type with high-order bits of opcode\n  \
    \ equal to b'10'\n      What it indicates: This is an optional LLC message that\
    \ the\n      receiver does not support.\n      Recovery action: Ignore (silently\
    \ discard) the message.\n   LLC message received: Any unambiguously incorrect\
    \ or out-of-sync LLC\n   message\n      What it indicates: Link is out of sync.\n\
    \      Recovery action: Treat as if detected that the link has gone down.\n  \
    \    Note that an unsupported or unknown LLC opcode whose two\n      high-order\
    \ bits are b'10' is not an error and must be silently\n      discarded.  Any other\
    \ unknown or unsupported LLC opcode is an\n      error.\n"
- title: C.8.  Failure to Add Second SMC-R Link to a Link Group
  contents:
  - "C.8.  Failure to Add Second SMC-R Link to a Link Group\n   When there is any\
    \ failure in setting up the second SMC-R link in an\n   SMC-R link group, including\
    \ confirmation timer expiration, the SMC-R\n   link group is allowed to continue\
    \ without available failover.\n   However, this situation is extremely undesirable,\
    \ and the server must\n   endeavor to correct it as soon as it can.\n   The server\
    \ peer in the SMC-R link group must set a timer to drive it\n   to retry setup\
    \ of a failed additional SMC-R link.  The server will\n   immediately retry the\
    \ SMC-R link setup when the first of the\n   following events occurs:\n   o  The\
    \ retry timer expires.\n   o  A new RNIC becomes available to the server, on the\
    \ same LAN as the\n      SMC-R link group.\n   o  An ADD LINK LLC request message\
    \ is received from the client; this\n      indicates the availability of a new\
    \ RNIC on the client side.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mike Fox\n   IBM\n   3039 Cornwallis Rd.\n   Research\
    \ Triangle Park, NC  27709\n   United States\n   Email: mjfox@us.ibm.com\n   Constantinos\
    \ (Gus) Kassimis\n   IBM\n   3039 Cornwallis Rd.\n   Research Triangle Park, NC\
    \  27709\n   United States\n   Email: kassimis@us.ibm.com\n   Jerry Stevens\n\
    \   IBM\n   3039 Cornwallis Rd.\n   Research Triangle Park, NC  27709\n   United\
    \ States\n   Email: sjerry@us.ibm.com\n"
