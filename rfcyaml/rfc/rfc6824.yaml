- title: __initial_text__
  contents:
  - '     TCP Extensions for Multipath Operation with Multiple Addresses

    '
- title: Abstract
  contents:
  - "Abstract\n   TCP/IP communication is currently restricted to a single path per\n\
    \   connection, yet multiple paths often exist between peers.  The\n   simultaneous\
    \ use of these multiple paths for a TCP/IP session would\n   improve resource\
    \ usage within the network and, thus, improve user\n   experience through higher\
    \ throughput and improved resilience to\n   network failure.\n   Multipath TCP\
    \ provides the ability to simultaneously use multiple\n   paths between peers.\
    \  This document presents a set of extensions to\n   traditional TCP to support\
    \ multipath operation.  The protocol offers\n   the same type of service to applications\
    \ as TCP (i.e., reliable\n   bytestream), and it provides the components necessary\
    \ to establish\n   and use multiple TCP flows across potentially disjoint paths.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6824.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Design Assumptions .........................................4\n  \
    \    1.2. Multipath TCP in the Networking Stack ......................5\n    \
    \  1.3. Terminology ................................................6\n      1.4.\
    \ MPTCP Concept ..............................................7\n      1.5. Requirements\
    \ Language ......................................8\n   2. Operation Overview ..............................................8\n\
    \      2.1. Initiating an MPTCP Connection .............................9\n  \
    \    2.2. Associating a New Subflow with an Existing MPTCP\n           Connection\
    \ .................................................9\n      2.3. Informing the\
    \ Other Host about Another Potential Address ..10\n      2.4. Data Transfer Using\
    \ MPTCP .................................11\n      2.5. Requesting a Change in\
    \ a Path's Priority ..................11\n      2.6. Closing an MPTCP Connection\
    \ ...............................12\n      2.7. Notable Features ..........................................12\n\
    \   3. MPTCP Protocol .................................................12\n  \
    \    3.1. Connection Initiation .....................................14\n    \
    \  3.2. Starting a New Subflow ....................................18\n      3.3.\
    \ General MPTCP Operation ...................................23\n           3.3.1.\
    \ Data Sequence Mapping ..............................25\n           3.3.2. Data\
    \ Acknowledgments ...............................28\n           3.3.3. Closing\
    \ a Connection ...............................29\n           3.3.4. Receiver Considerations\
    \ ............................30\n           3.3.5. Sender Considerations ..............................31\n\
    \           3.3.6. Reliability and Retransmissions ....................32\n  \
    \         3.3.7. Congestion Control Considerations ..................33\n    \
    \       3.3.8. Subflow Policy .....................................34\n      3.4.\
    \ Address Knowledge Exchange (Path Management) ..............35\n           3.4.1.\
    \ Address Advertisement ..............................36\n           3.4.2. Remove\
    \ Address .....................................39\n      3.5. Fast Close ................................................40\n\
    \      3.6. Fallback ..................................................41\n  \
    \    3.7. Error Handling ............................................45\n    \
    \  3.8. Heuristics ................................................45\n      \
    \     3.8.1. Port Usage .........................................46\n        \
    \   3.8.2. Delayed Subflow Start ..............................46\n          \
    \ 3.8.3. Failure Handling ...................................47\n   4. Semantic\
    \ Issues ................................................48\n   5. Security Considerations\
    \ ........................................49\n   6. Interactions with Middleboxes\
    \ ..................................51\n   7. Acknowledgments ................................................55\n\
    \   8. IANA Considerations ............................................55\n  \
    \ 9. References .....................................................57\n    \
    \  9.1. Normative References ......................................57\n      9.2.\
    \ Informative References ....................................57\n   Appendix A.\
    \ Notes on Use of TCP Options ...........................59\n   Appendix B. Control\
    \ Blocks ........................................60\n      B.1. MPTCP Control\
    \ Block .......................................60\n           B.1.1. Authentication\
    \ and Metadata ........................60\n           B.1.2. Sending Side .......................................61\n\
    \           B.1.3. Receiving Side .....................................61\n  \
    \    B.2. TCP Control Blocks ........................................62\n    \
    \       B.2.1. Sending Side .......................................62\n      \
    \     B.2.2. Receiving Side .....................................62\n   Appendix\
    \ C. Finite State Machine ..................................63\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Multipath TCP (MPTCP) is a set of extensions to regular\
    \ TCP [1] to\n   provide a Multipath TCP [2] service, which enables a transport\n\
    \   connection to operate across multiple paths simultaneously.  This\n   document\
    \ presents the protocol changes required to add multipath\n   capability to TCP;\
    \ specifically, those for signaling and setting up\n   multiple paths (\"subflows\"\
    ), managing these subflows, reassembly of\n   data, and termination of sessions.\
    \  This is not the only information\n   required to create a Multipath TCP implementation,\
    \ however.  This\n   document is complemented by three others:\n   o  Architecture\
    \ [2], which explains the motivations behind Multipath\n      TCP, contains a\
    \ discussion of high-level design decisions on which\n      this design is based,\
    \ and an explanation of a functional\n      separation through which an extensible\
    \ MPTCP implementation can be\n      developed.\n   o  Congestion control [5]\
    \ presents a safe congestion control\n      algorithm for coupling the behavior\
    \ of the multiple paths in order\n      to \"do no harm\" to other network users.\n\
    \   o  Application considerations [6] discusses what impact MPTCP will\n     \
    \ have on applications, what applications will want to do with\n      MPTCP, and\
    \ as a consequence of these factors, what API extensions\n      an MPTCP implementation\
    \ should present.\n"
- title: 1.1.  Design Assumptions
  contents:
  - "1.1.  Design Assumptions\n   In order to limit the potentially huge design space,\
    \ the working\n   group imposed two key constraints on the Multipath TCP design\n\
    \   presented in this document:\n   o  It must be backwards-compatible with current,\
    \ regular TCP, to\n      increase its chances of deployment.\n   o  It can be\
    \ assumed that one or both hosts are multihomed and\n      multiaddressed.\n \
    \  To simplify the design, we assume that the presence of multiple\n   addresses\
    \ at a host is sufficient to indicate the existence of\n   multiple paths.  These\
    \ paths need not be entirely disjoint: they may\n   share one or many routers\
    \ between them.  Even in such a situation,\n   making use of multiple paths is\
    \ beneficial, improving resource\n   utilization and resilience to a subset of\
    \ node failures.  The\n   congestion control algorithms defined in [5] ensure\
    \ this does not act\n   detrimentally.  Furthermore, there may be some scenarios\
    \ where\n   different TCP ports on a single host can provide disjoint paths (such\n\
    \   as through certain Equal-Cost Multipath (ECMP) implementations [7]),\n   and\
    \ so the MPTCP design also supports the use of ports in path\n   identifiers.\n\
    \   There are three aspects to the backwards-compatibility listed above\n   (discussed\
    \ in more detail in [2]):\n   External Constraints:  The protocol must function\
    \ through the vast\n      majority of existing middleboxes such as NATs, firewalls,\
    \ and\n      proxies, and as such must resemble existing TCP as far as possible\n\
    \      on the wire.  Furthermore, the protocol must not assume the\n      segments\
    \ it sends on the wire arrive unmodified at the\n      destination: they may be\
    \ split or coalesced; TCP options may be\n      removed or duplicated.\n   Application\
    \ Constraints:  The protocol must be usable with no change\n      to existing\
    \ applications that use the common TCP API (although it\n      is reasonable that\
    \ not all features would be available to such\n      legacy applications).  Furthermore,\
    \ the protocol must provide the\n      same service model as regular TCP to the\
    \ application.\n   Fallback:  The protocol should be able to fall back to standard\
    \ TCP\n      with no interference from the user, to be able to communicate with\n\
    \      legacy hosts.\n   The complementary application considerations document\
    \ [6] discusses\n   the necessary features of an API to provide backwards-compatibility,\n\
    \   as well as API extensions to convey the behavior of MPTCP at a level\n   of\
    \ control and information equivalent to that available with regular,\n   single-path\
    \ TCP.\n   Further discussion of the design constraints and associated design\n\
    \   decisions are given in the MPTCP Architecture document [2] and in\n   [8].\n"
- title: 1.2.  Multipath TCP in the Networking Stack
  contents:
  - "1.2.  Multipath TCP in the Networking Stack\n   MPTCP operates at the transport\
    \ layer and aims to be transparent to\n   both higher and lower layers.  It is\
    \ a set of additional features on\n   top of standard TCP; Figure 1 illustrates\
    \ this layering.  MPTCP is\n   designed to be usable by legacy applications with\
    \ no changes;\n   detailed discussion of its interactions with applications is\
    \ given in\n   [6].\n                                   +-------------------------------+\n\
    \                                   |           Application         |\n      +---------------+\
    \            +-------------------------------+\n      |  Application  |      \
    \      |             MPTCP             |\n      +---------------+            +\
    \ - - - - - - - + - - - - - - - +\n      |      TCP      |            | Subflow\
    \ (TCP) | Subflow (TCP) |\n      +---------------+            +-------------------------------+\n\
    \      |      IP       |            |       IP      |      IP       |\n      +---------------+\
    \            +-------------------------------+\n      Figure 1: Comparison of\
    \ Standard TCP and MPTCP Protocol Stacks\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   This document makes use of a number of terms that are either\
    \ MPTCP-\n   specific or have defined meaning in the context of MPTCP, as follows:\n\
    \   Path:  A sequence of links between a sender and a receiver, defined\n    \
    \  in this context by a 4-tuple of source and destination address/\n      port\
    \ pairs.\n   Subflow:  A flow of TCP segments operating over an individual path,\n\
    \      which forms part of a larger MPTCP connection.  A subflow is\n      started\
    \ and terminated similar to a regular TCP connection.\n   (MPTCP) Connection:\
    \  A set of one or more subflows, over which an\n      application can communicate\
    \ between two hosts.  There is a one-to-\n      one mapping between a connection\
    \ and an application socket.\n   Data-level:  The payload data is nominally transferred\
    \ over a\n      connection, which in turn is transported over subflows.  Thus,\
    \ the\n      term \"data-level\" is synonymous with \"connection level\", in\n\
    \      contrast to \"subflow-level\", which refers to properties of an\n     \
    \ individual subflow.\n   Token:  A locally unique identifier given to a multipath\
    \ connection\n      by a host.  May also be referred to as a \"Connection ID\"\
    .\n   Host:  An end host operating an MPTCP implementation, and either\n     \
    \ initiating or accepting an MPTCP connection.\n   In addition to these terms,\
    \ note that MPTCP's interpretation of, and\n   effect on, regular single-path\
    \ TCP semantics are discussed in\n   Section 4.\n"
- title: 1.4.  MPTCP Concept
  contents:
  - "1.4.  MPTCP Concept\n   This section provides a high-level summary of normal\
    \ operation of\n   MPTCP, and is illustrated by the scenario shown in Figure 2.\
    \  A\n   detailed description of operation is given in Section 3.\n   o  To a\
    \ non-MPTCP-aware application, MPTCP will behave the same as\n      normal TCP.\
    \  Extended APIs could provide additional control to\n      MPTCP-aware applications\
    \ [6].  An application begins by opening a\n      TCP socket in the normal way.\
    \  MPTCP signaling and operation are\n      handled by the MPTCP implementation.\n\
    \   o  An MPTCP connection begins similarly to a regular TCP connection.\n   \
    \   This is illustrated in Figure 2 where an MPTCP connection is\n      established\
    \ between addresses A1 and B1 on Hosts A and B,\n      respectively.\n   o  If\
    \ extra paths are available, additional TCP sessions (termed\n      MPTCP \"subflows\"\
    ) are created on these paths, and are combined\n      with the existing session,\
    \ which continues to appear as a single\n      connection to the applications\
    \ at both ends.  The creation of the\n      additional TCP session is illustrated\
    \ between Address A2 on Host A\n      and Address B1 on Host B.\n   o  MPTCP identifies\
    \ multiple paths by the presence of multiple\n      addresses at hosts.  Combinations\
    \ of these multiple addresses\n      equate to the additional paths.  In the example,\
    \ other potential\n      paths that could be set up are A1<->B2 and A2<->B2. \
    \ Although this\n      additional session is shown as being initiated from A2,\
    \ it could\n      equally have been initiated from B1.\n   o  The discovery and\
    \ setup of additional subflows will be achieved\n      through a path management\
    \ method; this document describes a\n      mechanism by which a host can initiate\
    \ new subflows by using its\n      own additional addresses, or by signaling its\
    \ available addresses\n      to the other host.\n   o  MPTCP adds connection-level\
    \ sequence numbers to allow the\n      reassembly of segments arriving on multiple\
    \ subflows with\n      differing network delays.\n   o  Subflows are terminated\
    \ as regular TCP connections, with a four-\n      way FIN handshake.  The MPTCP\
    \ connection is terminated by a\n      connection-level FIN.\n               Host\
    \ A                               Host B\n      ------------------------     \
    \        ------------------------\n      Address A1    Address A2            \
    \ Address B1    Address B2\n      ----------    ----------             ----------\
    \    ----------\n          |             |                      |            \
    \ |\n          |     (initial connection setup)     |             |\n        \
    \  |----------------------------------->|             |\n          |<-----------------------------------|\
    \             |\n          |             |                      |            \
    \ |\n          |            (additional subflow setup)            |\n        \
    \  |             |--------------------->|             |\n          |         \
    \    |<---------------------|             |\n          |             |       \
    \               |             |\n          |             |                   \
    \   |             |\n                  Figure 2: Example MPTCP Usage Scenario\n"
- title: 1.5.  Requirements Language
  contents:
  - "1.5.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [3].\n"
- title: 2.  Operation Overview
  contents:
  - "2.  Operation Overview\n   This section presents a single description of common\
    \ MPTCP operation,\n   with reference to the protocol operation.  This is a high-level\n\
    \   overview of the key functions; the full specification follows in\n   Section\
    \ 3.  Extensibility and negotiated features are not discussed\n   here.  Considerable\
    \ reference is made to symbolic names of MPTCP\n   options throughout this section\
    \ -- these are subtypes of the IANA-\n   assigned MPTCP option (see Section 8),\
    \ and their formats are defined\n   in the detailed protocol specification that\
    \ follows in Section 3.\n   A Multipath TCP connection provides a bidirectional\
    \ bytestream\n   between two hosts communicating like normal TCP and, thus, does\
    \ not\n   require any change to the applications.  However, Multipath TCP\n  \
    \ enables the hosts to use different paths with different IP addresses\n   to\
    \ exchange packets belonging to the MPTCP connection.  A Multipath\n   TCP connection\
    \ appears like a normal TCP connection to an\n   application.  However, to the\
    \ network layer, each MPTCP subflow looks\n   like a regular TCP flow whose segments\
    \ carry a new TCP option type.\n   Multipath TCP manages the creation, removal,\
    \ and utilization of these\n   subflows to send data.  The number of subflows\
    \ that are managed\n   within a Multipath TCP connection is not fixed and it can\
    \ fluctuate\n   during the lifetime of the Multipath TCP connection.\n   All MPTCP\
    \ operations are signaled with a TCP option -- a single\n   numerical type for\
    \ MPTCP, with \"sub-types\" for each MPTCP message.\n   What follows is a summary\
    \ of the purpose and rationale of these\n   messages.\n"
- title: 2.1.  Initiating an MPTCP Connection
  contents:
  - "2.1.  Initiating an MPTCP Connection\n   This is the same signaling as for initiating\
    \ a normal TCP connection,\n   but the SYN, SYN/ACK, and ACK packets also carry\
    \ the MP_CAPABLE\n   option.  This is variable length and serves multiple purposes.\n\
    \   Firstly, it verifies whether the remote host supports Multipath TCP;\n   secondly,\
    \ this option allows the hosts to exchange some information\n   to authenticate\
    \ the establishment of additional subflows.  Further\n   details are given in\
    \ Section 3.1.\n      Host A                                  Host B\n      ------\
    \                                  ------\n      MP_CAPABLE            ->\n  \
    \    [A's key, flags]\n                            <-                MP_CAPABLE\n\
    \                                              [B's key, flags]\n      ACK + MP_CAPABLE\
    \      ->\n      [A's key, B's key, flags]\n"
- title: 2.2.  Associating a New Subflow with an Existing MPTCP Connection
  contents:
  - "2.2.  Associating a New Subflow with an Existing MPTCP Connection\n   The exchange\
    \ of keys in the MP_CAPABLE handshake provides material\n   that can be used to\
    \ authenticate the endpoints when new subflows will\n   be set up.  Additional\
    \ subflows begin in the same way as initiating a\n   normal TCP connection, but\
    \ the SYN, SYN/ACK, and ACK packets also\n   carry the MP_JOIN option.\n   Host\
    \ A initiates a new subflow between one of its addresses and one\n   of Host B's\
    \ addresses.  The token -- generated from the key -- is\n   used to identify which\
    \ MPTCP connection it is joining, and the HMAC\n   is used for authentication.\
    \  The Hash-based Message Authentication\n   Code (HMAC) uses the keys exchanged\
    \ in the MP_CAPABLE handshake, and\n   the random numbers (nonces) exchanged in\
    \ these MP_JOIN options.\n   MP_JOIN also contains flags and an Address ID that\
    \ can be used to\n   refer to the source address without the sender needing to\
    \ know if it\n   has been changed by a NAT.  Further details are in Section 3.2.\n\
    \      Host A                                  Host B\n      ------          \
    \                        ------\n      MP_JOIN               ->\n      [B's token,\
    \ A's nonce,\n       A's Address ID, flags]\n                            <-  \
    \              MP_JOIN\n                                              [B's HMAC,\
    \ B's nonce,\n                                               B's Address ID, flags]\n\
    \      ACK + MP_JOIN         ->\n      [A's HMAC]\n                          \
    \  <-                ACK\n"
- title: 2.3.  Informing the Other Host about Another Potential Address
  contents:
  - "2.3.  Informing the Other Host about Another Potential Address\n   The set of\
    \ IP addresses associated to a multihomed host may change\n   during the lifetime\
    \ of an MPTCP connection.  MPTCP supports the\n   addition and removal of addresses\
    \ on a host both implicitly and\n   explicitly.  If Host A has established a subflow\
    \ starting at address\n   IP#-A1 and wants to open a second subflow starting at\
    \ address IP#-A2,\n   it simply initiates the establishment of the subflow as\
    \ explained\n   above.  The remote host will then be implicitly informed about\
    \ the\n   new address.\n   In some circumstances, a host may want to advertise\
    \ to the remote\n   host the availability of an address without establishing a\
    \ new\n   subflow, for example, when a NAT prevents setup in one direction.  In\n\
    \   the example below, Host A informs Host B about its alternative IP\n   address\
    \ (IP#-A2).  Host B may later send an MP_JOIN to this new\n   address.  Due to\
    \ the presence of middleboxes that may translate IP\n   addresses, this option\
    \ uses an address identifier to unambiguously\n   identify an address on a host.\
    \  Further details are in Section 3.4.1.\n      Host A                       \
    \          Host B\n      ------                                 ------\n     \
    \ ADD_ADDR                  ->\n      [IP#-A2,\n       IP#-A2's Address ID]\n\
    \   There is a corresponding signal for address removal, making use of\n   the\
    \ Address ID that is signaled in the add address handshake.\n   Further details\
    \ in Section 3.4.2.\n      Host A                                 Host B\n   \
    \   ------                                 ------\n      REMOVE_ADDR         \
    \      ->\n      [IP#-A2's Address ID]\n"
- title: 2.4.  Data Transfer Using MPTCP
  contents:
  - "2.4.  Data Transfer Using MPTCP\n   To ensure reliable, in-order delivery of\
    \ data over subflows that may\n   appear and disappear at any time, MPTCP uses\
    \ a 64-bit data sequence\n   number (DSN) to number all data sent over the MPTCP\
    \ connection.  Each\n   subflow has its own 32-bit sequence number space and an\
    \ MPTCP option\n   maps the subflow sequence space to the data sequence space.\
    \  In this\n   way, data can be retransmitted on different subflows (mapped to\
    \ the\n   same DSN) in the event of failure.\n   The \"Data Sequence Signal\"\
    \ carries the \"Data Sequence Mapping\".  The\n   data sequence mapping consists\
    \ of the subflow sequence number, data\n   sequence number, and length for which\
    \ this mapping is valid.  This\n   option can also carry a connection-level acknowledgment\
    \ (the \"Data\n   ACK\") for the received DSN.\n   With MPTCP, all subflows share\
    \ the same receive buffer and advertise\n   the same receive window.  There are\
    \ two levels of acknowledgment in\n   MPTCP.  Regular TCP acknowledgments are\
    \ used on each subflow to\n   acknowledge the reception of the segments sent over\
    \ the subflow\n   independently of their DSN.  In addition, there are connection-level\n\
    \   acknowledgments for the data sequence space.  These acknowledgments\n   track\
    \ the advancement of the bytestream and slide the receiving\n   window.\n   Further\
    \ details are in Section 3.3.\n      Host A                                 Host\
    \ B\n      ------                                 ------\n      DATA_SEQUENCE_SIGNAL\
    \      ->\n      [Data Sequence Mapping]\n      [Data ACK]\n      [Checksum]\n"
- title: 2.5.  Requesting a Change in a Path's Priority
  contents:
  - "2.5.  Requesting a Change in a Path's Priority\n   Hosts can indicate at initial\
    \ subflow setup whether they wish the\n   subflow to be used as a regular or backup\
    \ path -- a backup path only\n   being used if there are no regular paths available.\
    \  During a\n   connection, Host A can request a change in the priority of a subflow\n\
    \   through the MP_PRIO signal to Host B.  Further details are in\n   Section\
    \ 3.3.8.\n      Host A                                 Host B\n      ------  \
    \                               ------\n      MP_PRIO                   ->\n"
- title: 2.6.  Closing an MPTCP Connection
  contents:
  - "2.6.  Closing an MPTCP Connection\n   When Host A wants to inform Host B that\
    \ it has no more data to send,\n   it signals this \"Data FIN\" as part of the\
    \ Data Sequence Signal (see\n   above).  It has the same semantics and behavior\
    \ as a regular TCP FIN,\n   but at the connection level.  Once all the data on\
    \ the MPTCP\n   connection has been successfully received, then this message is\n\
    \   acknowledged at the connection level with a DATA_ACK.  Further\n   details\
    \ are in Section 3.3.3.\n      Host A                                 Host B\n\
    \      ------                                 ------\n      DATA_SEQUENCE_SIGNAL\
    \      ->\n      [Data FIN]\n                                <-           (MPTCP\
    \ DATA_ACK)\n"
- title: 2.7.  Notable Features
  contents:
  - "2.7.  Notable Features\n   It is worth highlighting that MPTCP's signaling has\
    \ been designed\n   with several key requirements in mind:\n   o  To cope with\
    \ NATs on the path, addresses are referred to by\n      Address IDs, in case the\
    \ IP packet's source address gets changed\n      by a NAT.  Setting up a new TCP\
    \ flow is not possible if the\n      passive opener is behind a NAT; to allow\
    \ subflows to be created\n      when either end is behind a NAT, MPTCP uses the\
    \ ADD_ADDR message.\n   o  MPTCP falls back to ordinary TCP if MPTCP operation\
    \ is not\n      possible, for example, if one host is not MPTCP capable or if\
    \ a\n      middlebox alters the payload.\n   o  To meet the threats identified\
    \ in [9], the following steps are\n      taken: keys are sent in the clear in\
    \ the MP_CAPABLE messages;\n      MP_JOIN messages are secured with HMAC-SHA1\
    \ ([10], [4]) using\n      those keys; and standard TCP validity checks are made\
    \ on the other\n      messages (ensuring sequence numbers are in-window).\n"
- title: 3.  MPTCP Protocol
  contents:
  - "3.  MPTCP Protocol\n   This section describes the operation of the MPTCP protocol,\
    \ and is\n   subdivided into sections for each key part of the protocol operation.\n\
    \   All MPTCP operations are signaled using optional TCP header fields.\n   A\
    \ single TCP option number (\"Kind\") has been assigned by IANA for\n   MPTCP\
    \ (see Section 8), and then individual messages will be\n   determined by a \"\
    subtype\", the values of which are also stored in an\n   IANA registry (and are\
    \ also listed in Section 8).\n   Throughout this document, when reference is made\
    \ to an MPTCP option\n   by symbolic name, such as \"MP_CAPABLE\", this refers\
    \ to a TCP option\n   with the single MPTCP option type, and with the subtype\
    \ value of the\n   symbolic name as defined in Section 8.  This subtype is a 4-bit\
    \ field\n   -- the first 4 bits of the option payload, as shown in Figure 3. \
    \ The\n   MPTCP messages are defined in the following sections.\n            \
    \               1                   2                   3\n       0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-----------------------+\n\
    \      |     Kind      |    Length     |Subtype|                       |\n   \
    \   +---------------+---------------+-------+                       |\n      |\
    \                     Subtype-specific data                     |\n      |   \
    \                    (variable length)                       |\n      +---------------------------------------------------------------+\n\
    \                       Figure 3: MPTCP Option Format\n   Those MPTCP options\
    \ associated with subflow initiation are used on\n   packets with the SYN flag\
    \ set.  Additionally, there is one MPTCP\n   option for signaling metadata to\
    \ ensure segmented data can be\n   recombined for delivery to the application.\n\
    \   The remaining options, however, are signals that do not need to be on\n  \
    \ a specific packet, such as those for signaling additional addresses.\n   Whilst\
    \ an implementation may desire to send MPTCP options as soon as\n   possible,\
    \ it may not be possible to combine all desired options (both\n   those for MPTCP\
    \ and for regular TCP, such as SACK (selective\n   acknowledgment) [11]) on a\
    \ single packet.  Therefore, an\n   implementation may choose to send duplicate\
    \ ACKs containing the\n   additional signaling information.  This changes the\
    \ semantics of a\n   duplicate ACK; these are usually only sent as a signal of\
    \ a lost\n   segment [12] in regular TCP.  Therefore, an MPTCP implementation\n\
    \   receiving a duplicate ACK that contains an MPTCP option MUST NOT\n   treat\
    \ it as a signal of congestion.  Additionally, an MPTCP\n   implementation SHOULD\
    \ NOT send more than two duplicate ACKs in a row\n   for the purposes of sending\
    \ MPTCP options alone, in order to ensure\n   no middleboxes misinterpret this\
    \ as a sign of congestion.\n   Furthermore, standard TCP validity checks (such\
    \ as ensuring the\n   sequence number and acknowledgment number are within window)\
    \ MUST be\n   undertaken before processing any MPTCP signals, as described in\
    \ [13].\n"
- title: 3.1.  Connection Initiation
  contents:
  - "3.1.  Connection Initiation\n   Connection initiation begins with a SYN, SYN/ACK,\
    \ ACK exchange on a\n   single path.  Each packet contains the Multipath Capable\
    \ (MP_CAPABLE)\n   TCP option (Figure 4).  This option declares its sender is\
    \ capable of\n   performing Multipath TCP and wishes to do so on this particular\n\
    \   connection.\n   This option is used to declare the 64-bit key that the sender\
    \ has\n   generated for this MPTCP connection.  This key is used to\n   authenticate\
    \ the addition of future subflows to this connection.\n   This is the only time\
    \ the key will be sent in clear on the wire\n   (unless \"fast close\", Section\
    \ 3.5, is used); all future subflows will\n   identify the connection using a\
    \ 32-bit \"token\".  This token is a\n   cryptographic hash of this key.  The\
    \ algorithm for this process is\n   dependent on the authentication algorithm\
    \ selected; the method of\n   selection is defined later in this section.\n  \
    \ This key is generated by its sender, and its method of generation is\n   implementation\
    \ specific.  The key MUST be hard to guess, and it MUST\n   be unique for the\
    \ sending host at any one time.  Recommendations for\n   generating random numbers\
    \ for use in keys are given in [14].\n   Connections will be indexed at each host\
    \ by the token (a one-way hash\n   of the key).  Therefore, an implementation\
    \ will require a mapping\n   from each token to the corresponding connection,\
    \ and in turn to the\n   keys for the connection.\n   There is a risk that two\
    \ different keys will hash to the same token.\n   The risk of hash collisions\
    \ is usually small, unless the host is\n   handling many tens of thousands of\
    \ connections.  Therefore, an\n   implementation SHOULD check its list of connection\
    \ tokens to ensure\n   there is not a collision before sending its key in the\
    \ SYN/ACK.  This\n   would, however, be costly for a server with thousands of\
    \ connections.\n   The subflow handshake mechanism (Section 3.2) will ensure that\
    \ new\n   subflows only join the correct connection, however, through the\n  \
    \ cryptographic handshake, as well as checking the connection tokens in\n   both\
    \ directions, and ensuring sequence numbers are in-window.  So in\n   the worst\
    \ case if there was a token collision, the new subflow would\n   not succeed,\
    \ but the MPTCP connection would continue to provide a\n   regular TCP service.\n\
    \   The MP_CAPABLE option is carried on the SYN, SYN/ACK, and ACK packets\n  \
    \ that start the first subflow of an MPTCP connection.  The data\n   carried by\
    \ each packet is as follows, where A = initiator and B =\n   listener.\n   o \
    \ SYN (A->B): A's Key for this connection.\n   o  SYN/ACK (B->A): B's Key for\
    \ this connection.\n   o  ACK (A->B): A's Key followed by B's Key.\n   The contents\
    \ of the option is determined by the SYN and ACK flags of\n   the packet, verified\
    \ by the option's length field.  For the diagram\n   shown in Figure 4, \"sender\"\
    \ and \"receiver\" refer to the sender or\n   receiver of the TCP packet (which\
    \ can be either host).  If the SYN\n   flag is set, a single key is included;\
    \ if only an ACK flag is set,\n   both keys are present.\n   B's Key is echoed\
    \ in the ACK in order to allow the listener (Host B)\n   to act statelessly until\
    \ the TCP connection reaches the ESTABLISHED\n   state.  If the listener acts\
    \ in this way, however, it MUST generate\n   its key in a way that would allow\
    \ it to verify that it generated the\n   key when it is echoed in the ACK.\n \
    \  This exchange allows the safe passage of MPTCP options on SYN packets\n   to\
    \ be determined.  If any of these options are dropped, MPTCP will\n   gracefully\
    \ fall back to regular single-path TCP, as documented in\n   Section 3.6.  Note\
    \ that new subflows MUST NOT be established (using\n   the process documented\
    \ in Section 3.2) until a Digital Signature\n   Standard (DSS) option has been\
    \ successfully received across the path\n   (as documented in Section 3.3).\n\
    \                           1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-------+---------------+\n\
    \      |     Kind      |    Length     |Subtype|Version|A|B|C|D|E|F|G|H|\n   \
    \   +---------------+---------------+-------+-------+---------------+\n      |\
    \                   Option Sender's Key (64 bits)               |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      +---------------------------------------------------------------+\n\
    \      |                  Option Receiver's Key (64 bits)              |\n   \
    \   |                     (if option Length == 20)                  |\n      |\
    \                                                               |\n      +---------------------------------------------------------------+\n\
    \              Figure 4: Multipath Capable (MP_CAPABLE) Option\n   The first 4\
    \ bits of the first octet in the MP_CAPABLE option\n   (Figure 4) define the MPTCP\
    \ option subtype (see Section 8; for\n   MP_CAPABLE, this is 0), and the remaining\
    \ 4 bits of this octet\n   specify the MPTCP version in use (for this specification,\
    \ this is 0).\n   The second octet is reserved for flags, allocated as follows:\n\
    \   A: The leftmost bit, labeled \"A\", SHOULD be set to 1 to indicate\n     \
    \ \"Checksum Required\", unless the system administrator has decided\n      that\
    \ checksums are not required (for example, if the environment\n      is controlled\
    \ and no middleboxes exist that might adjust the\n      payload).\n   B: The second\
    \ bit, labeled \"B\", is an extensibility flag, and MUST be\n      set to 0 for\
    \ current implementations.  This will be used for an\n      extensibility mechanism\
    \ in a future specification, and the impact\n      of this flag will be defined\
    \ at a later date.  If receiving a\n      message with the 'B' flag set to 1,\
    \ and this is not understood,\n      then this SYN MUST be silently ignored; the\
    \ sender is expected to\n      retry with a format compatible with this legacy\
    \ specification.\n      Note that the length of the MP_CAPABLE option, and the\
    \ meanings of\n      bits \"C\" through \"H\", may be altered by setting B=1.\n\
    \   C through H:  The remaining bits, labeled \"C\" through \"H\", are used\n\
    \      for crypto algorithm negotiation.  Currently only the rightmost\n     \
    \ bit, labeled \"H\", is assigned.  Bit \"H\" indicates the use of HMAC-\n   \
    \   SHA1 (as defined in Section 3.2).  An implementation that only\n      supports\
    \ this method MUST set bit \"H\" to 1, and bits \"C\" through\n      \"G\" to\
    \ 0.\n   A crypto algorithm MUST be specified.  If flag bits C through H are\n\
    \   all 0, the MP_CAPABLE option MUST be treated as invalid and ignored\n   (that\
    \ is, it must be treated as a regular TCP handshake).\n   The selection of the\
    \ authentication algorithm also impacts the\n   algorithm used to generate the\
    \ token and the initial data sequence\n   number (IDSN).  In this specification,\
    \ with only the SHA-1 algorithm\n   (bit \"H\") specified and selected, the token\
    \ MUST be a truncated (most\n   significant 32 bits) SHA-1 hash ([4], [15]) of\
    \ the key.  A different,\n   64-bit truncation (the least significant 64 bits)\
    \ of the SHA-1 hash\n   of the key MUST be used as the initial data sequence number.\
    \  Note\n   that the key MUST be hashed in network byte order.  Also note that\n\
    \   the \"least significant\" bits MUST be the rightmost bits of the SHA-1\n \
    \  digest, as per [4].  Future specifications of the use of the crypto\n   bits\
    \ may choose to specify different algorithms for token and IDSN\n   generation.\n\
    \   Both the crypto and checksum bits negotiate capabilities in similar\n   ways.\
    \  For the Checksum Required bit (labeled \"A\"), if either host\n   requires\
    \ the use of checksums, checksums MUST be used.  In other\n   words, the only\
    \ way for checksums not to be used is if both hosts in\n   their SYNs set A=0.\
    \  This decision is confirmed by the setting of the\n   \"A\" bit in the third\
    \ packet (the ACK) of the handshake.  For example,\n   if the initiator sets A=0\
    \ in the SYN, but the responder sets A=1 in\n   the SYN/ACK, checksums MUST be\
    \ used in both directions, and the\n   initiator will set A=1 in the ACK.  The\
    \ decision whether to use\n   checksums will be stored by an implementation in\
    \ a per-connection\n   binary state variable.\n   For crypto negotiation, the\
    \ responder has the choice.  The initiator\n   creates a proposal setting a bit\
    \ for each algorithm it supports to 1\n   (in this version of the specification,\
    \ there is only one proposal, so\n   bit \"H\" will be always set to 1).  The\
    \ responder responds with only 1\n   bit set -- this is the chosen algorithm.\
    \  The rationale for this\n   behavior is that the responder will typically be\
    \ a server with\n   potentially many thousands of connections, so it may wish\
    \ to choose\n   an algorithm with minimal computational complexity, depending\
    \ on the\n   load.  If a responder does not support (or does not want to support)\n\
    \   any of the initiator's proposals, it can respond without an\n   MP_CAPABLE\
    \ option, thus forcing a fallback to regular TCP.\n   The MP_CAPABLE option is\
    \ only used in the first subflow of a\n   connection, in order to identify the\
    \ connection; all following\n   subflows will use the \"Join\" option (see Section\
    \ 3.2) to join the\n   existing connection.\n   If a SYN contains an MP_CAPABLE\
    \ option but the SYN/ACK does not, it\n   is assumed that the passive opener is\
    \ not multipath capable; thus,\n   the MPTCP session MUST operate as a regular,\
    \ single-path TCP.  If a\n   SYN does not contain a MP_CAPABLE option, the SYN/ACK\
    \ MUST NOT\n   contain one in response.  If the third packet (the ACK) does not\n\
    \   contain the MP_CAPABLE option, then the session MUST fall back to\n   operating\
    \ as a regular, single-path TCP.  This is to maintain\n   compatibility with middleboxes\
    \ on the path that drop some or all TCP\n   options.  Note that an implementation\
    \ MAY choose to attempt sending\n   MPTCP options more than one time before making\
    \ this decision to\n   operate as regular TCP (see Section 3.8).\n   If the SYN\
    \ packets are unacknowledged, it is up to local policy to\n   decide how to respond.\
    \  It is expected that a sender will eventually\n   fall back to single-path TCP\
    \ (i.e., without the MP_CAPABLE option) in\n   order to work around middleboxes\
    \ that may drop packets with unknown\n   options; however, the number of multipath-capable\
    \ attempts that are\n   made first will be up to local policy.  It is possible\
    \ that MPTCP and\n   non-MPTCP SYNs could get reordered in the network.  Therefore,\
    \ the\n   final state is inferred from the presence or absence of the\n   MP_CAPABLE\
    \ option in the third packet of the TCP handshake.  If this\n   option is not\
    \ present, the connection SHOULD fall back to regular\n   TCP, as documented in\
    \ Section 3.6.\n   The initial data sequence number on an MPTCP connection is\
    \ generated\n   from the key.  The algorithm for IDSN generation is also determined\n\
    \   from the negotiated authentication algorithm.  In this specification,\n  \
    \ with only the SHA-1 algorithm specified and selected, the IDSN of a\n   host\
    \ MUST be the least significant 64 bits of the SHA-1 hash of its\n   key, i.e.,\
    \ IDSN-A = Hash(Key-A) and IDSN-B = Hash(Key-B).  This\n   deterministic generation\
    \ of the IDSN allows a receiver to ensure that\n   there are no gaps in sequence\
    \ space at the start of the connection.\n   The SYN with MP_CAPABLE occupies the\
    \ first octet of data sequence\n   space, although this does not need to be acknowledged\
    \ at the\n   connection level until the first data is sent (see Section 3.3).\n"
- title: 3.2.  Starting a New Subflow
  contents:
  - "3.2.  Starting a New Subflow\n   Once an MPTCP connection has begun with the\
    \ MP_CAPABLE exchange,\n   further subflows can be added to the connection.  Hosts\
    \ have\n   knowledge of their own address(es), and can become aware of the other\n\
    \   host's addresses through signaling exchanges as described in\n   Section 3.4.\
    \  Using this knowledge, a host can initiate a new subflow\n   over a currently\
    \ unused pair of addresses.  It is permitted for\n   either host in a connection\
    \ to initiate the creation of a new\n   subflow, but it is expected that this\
    \ will normally be the original\n   connection initiator (see Section 3.8 for\
    \ heuristics).\n   A new subflow is started as a normal TCP SYN/ACK exchange.\
    \  The Join\n   Connection (MP_JOIN) TCP option is used to identify the connection\
    \ to\n   be joined by the new subflow.  It uses keying material that was\n   exchanged\
    \ in the initial MP_CAPABLE handshake (Section 3.1), and that\n   handshake also\
    \ negotiates the crypto algorithm in use for the MP_JOIN\n   handshake.\n   This\
    \ section specifies the behavior of MP_JOIN using the HMAC-SHA1\n   algorithm.\
    \  An MP_JOIN option is present in the SYN, SYN/ACK, and ACK\n   of the three-way\
    \ handshake, although in each case with a different\n   format.\n   In the first\
    \ MP_JOIN on the SYN packet, illustrated in Figure 5, the\n   initiator sends\
    \ a token, random number, and address ID.\n   The token is used to identify the\
    \ MPTCP connection and is a\n   cryptographic hash of the receiver's key, as exchanged\
    \ in the initial\n   MP_CAPABLE handshake (Section 3.1).  In this specification,\
    \ the\n   tokens presented in this option are generated by the SHA-1 ([4],\n \
    \  [15]) algorithm, truncated to the most significant 32 bits.  The\n   token\
    \ included in the MP_JOIN option is the token that the receiver\n   of the packet\
    \ uses to identify this connection; i.e., Host A will\n   send Token-B (which\
    \ is generated from Key-B).  Note that the hash\n   generation algorithm can be\
    \ overridden by the choice of cryptographic\n   handshake algorithm, as defined\
    \ in Section 3.1.\n   The MP_JOIN SYN sends not only the token (which is static\
    \ for a\n   connection) but also random numbers (nonces) that are used to prevent\n\
    \   replay attacks on the authentication method.  Recommendations for the\n  \
    \ generation of random numbers for this purpose are given in [14].\n   The MP_JOIN\
    \ option includes an \"Address ID\".  This is an identifier\n   that only has\
    \ significance within a single connection, where it\n   identifies the source\
    \ address of this packet, even if the IP header\n   has been changed in transit\
    \ by a middlebox.  The Address ID allows\n   address removal (Section 3.4.2) without\
    \ needing to know what the\n   source address at the receiver is, thus allowing\
    \ address removal\n   through NATs.  The Address ID also allows correlation between\
    \ new\n   subflow setup attempts and address signaling (Section 3.4.1), to\n \
    \  prevent setting up duplicate subflows on the same path, if an MP_JOIN\n   and\
    \ ADD_ADDR are sent at the same time.\n   The Address IDs of the subflow used\
    \ in the initial SYN exchange of\n   the first subflow in the connection are implicit,\
    \ and have the value\n   zero.  A host MUST store the mappings between Address\
    \ IDs and\n   addresses both for itself and the remote host.  An implementation\n\
    \   will also need to know which local and remote Address IDs are\n   associated\
    \ with which established subflows, for when addresses are\n   removed from a local\
    \ or remote host.\n   The MP_JOIN option on packets with the SYN flag set also\
    \ includes 4\n   bits of flags, 3 of which are currently reserved and MUST be\
    \ set to\n   zero by the sender.  The final bit, labeled \"B\", indicates whether\n\
    \   the sender of this option wishes this subflow to be used as a backup\n   path\
    \ (B=1) in the event of failure of other paths, or whether it\n   wants it to\
    \ be used as part of the connection immediately.  By\n   setting B=1, the sender\
    \ of the option is requesting the other host to\n   only send data on this subflow\
    \ if there are no available subflows\n   where B=0.  Subflow policy is discussed\
    \ in more detail in\n   Section 3.3.8.\n                           1         \
    \          2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-----+-+---------------+\n\
    \      |     Kind      |  Length = 12  |Subtype|     |B|   Address ID  |\n   \
    \   +---------------+---------------+-------+-----+-+---------------+\n      |\
    \                   Receiver's Token (32 bits)                  |\n      +---------------------------------------------------------------+\n\
    \      |                Sender's Random Number (32 bits)               |\n   \
    \   +---------------------------------------------------------------+\n      \
    \ Figure 5: Join Connection (MP_JOIN) Option (for Initial SYN)\n   When receiving\
    \ a SYN with an MP_JOIN option that contains a valid\n   token for an existing\
    \ MPTCP connection, the recipient SHOULD respond\n   with a SYN/ACK also containing\
    \ an MP_JOIN option containing a random\n   number and a truncated (leftmost 64\
    \ bits) Hash-based Message\n   Authentication Code (HMAC).  This version of the\
    \ option is shown in\n   Figure 6.  If the token is unknown, or the host wants\
    \ to refuse\n   subflow establishment (for example, due to a limit on the number\
    \ of\n   subflows it will permit), the receiver will send back a reset (RST)\n\
    \   signal, analogous to an unknown port in TCP.  Although calculating an\n  \
    \ HMAC requires cryptographic operations, it is believed that the 32-\n   bit\
    \ token in the MP_JOIN SYN gives sufficient protection against\n   blind state\
    \ exhaustion attacks; therefore, there is no need to\n   provide mechanisms to\
    \ allow a responder to operate statelessly at the\n   MP_JOIN stage.\n   An HMAC\
    \ is sent by both hosts -- by the initiator (Host A) in the\n   third packet (the\
    \ ACK) and by the responder (Host B) in the second\n   packet (the SYN/ACK). \
    \ Doing the HMAC exchange at this stage allows\n   both hosts to have first exchanged\
    \ random data (in the first two SYN\n   packets) that is used as the \"message\"\
    .  This specification defines\n   that HMAC as defined in [10] is used, along\
    \ with the SHA-1 hash\n   algorithm [4] (potentially implemented as in [15]),\
    \ thus generating a\n   160-bit / 20-octet HMAC.  Due to option space limitations,\
    \ the HMAC\n   included in the SYN/ACK is truncated to the leftmost 64 bits, but\n\
    \   this is acceptable since random numbers are used; thus, an attacker\n   only\
    \ has one chance to guess the HMAC correctly (if the HMAC is\n   incorrect, the\
    \ TCP connection is closed, so a new MP_JOIN negotiation\n   with a new random\
    \ number is required).\n   The initiator's authentication information is sent\
    \ in its first ACK\n   (the third packet of the handshake), as shown in Figure\
    \ 7.  This data\n   needs to be sent reliably, since it is the only time this\
    \ HMAC is\n   sent; therefore, receipt of this packet MUST trigger a regular TCP\n\
    \   ACK in response, and the packet MUST be retransmitted if this ACK is\n   not\
    \ received.  In other words, sending the ACK/MP_JOIN packet places\n   the subflow\
    \ in the PRE_ESTABLISHED state, and it moves to the\n   ESTABLISHED state only\
    \ on receipt of an ACK from the receiver.  It is\n   not permitted to send data\
    \ while in the PRE_ESTABLISHED state.  The\n   reserved bits in this option MUST\
    \ be set to zero by the sender.\n   The key for the HMAC algorithm, in the case\
    \ of the message\n   transmitted by Host A, will be Key-A followed by Key-B, and\
    \ in the\n   case of Host B, Key-B followed by Key-A.  These are the keys that\n\
    \   were exchanged in the original MP_CAPABLE handshake.  The \"message\"\n  \
    \ for the HMAC algorithm in each case is the concatenations of random\n   number\
    \ for each host (denoted by R): for Host A, R-A followed by R-B;\n   and for Host\
    \ B, R-B followed by R-A.\n                           1                   2  \
    \                 3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-----+-+---------------+\n\
    \      |     Kind      |  Length = 16  |Subtype|     |B|   Address ID  |\n   \
    \   +---------------+---------------+-------+-----+-+---------------+\n      |\
    \                                                               |\n      |   \
    \             Sender's Truncated HMAC (64 bits)              |\n      |      \
    \                                                         |\n      +---------------------------------------------------------------+\n\
    \      |                Sender's Random Number (32 bits)               |\n   \
    \   +---------------------------------------------------------------+\n    Figure\
    \ 6: Join Connection (MP_JOIN) Option (for Responding SYN/ACK)\n             \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-----------------------+\n\
    \      |     Kind      |  Length = 24  |Subtype|      (reserved)       |\n   \
    \   +---------------+---------------+-------+-----------------------+\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      |      \
    \             Sender's HMAC (160 bits)                    |\n      |         \
    \                                                      |\n      |            \
    \                                                   |\n      +---------------------------------------------------------------+\n\
    \        Figure 7: Join Connection (MP_JOIN) Option (for Third ACK)\n   These\
    \ various TCP options fit together to enable authenticated\n   subflow setup as\
    \ illustrated in Figure 8.\n              Host A                             \
    \     Host B\n     ------------------------                       ----------\n\
    \     Address A1    Address A2                       Address B1\n     ----------\
    \    ----------                       ----------\n         |             |   \
    \                             |\n         |            SYN + MP_CAPABLE(Key-A)\
    \           |\n         |--------------------------------------------->|\n   \
    \      |<---------------------------------------------|\n         |          SYN/ACK\
    \ + MP_CAPABLE(Key-B)         |\n         |             |                    \
    \            |\n         |        ACK + MP_CAPABLE(Key-A, Key-B)        |\n  \
    \       |--------------------------------------------->|\n         |         \
    \    |                                |\n         |             |   SYN + MP_JOIN(Token-B,\
    \ R-A)  |\n         |             |------------------------------->|\n       \
    \  |             |<-------------------------------|\n         |             |\
    \ SYN/ACK + MP_JOIN(HMAC-B, R-B) |\n         |             |                 \
    \               |\n         |             |     ACK + MP_JOIN(HMAC-A)      |\n\
    \         |             |------------------------------->|\n         |       \
    \      |<-------------------------------|\n         |             |          \
    \   ACK                |\n   HMAC-A = HMAC(Key=(Key-A+Key-B), Msg=(R-A+R-B))\n\
    \   HMAC-B = HMAC(Key=(Key-B+Key-A), Msg=(R-B+R-A))\n               Figure 8:\
    \ Example Use of MPTCP Authentication\n   If the token received at Host B is unknown\
    \ or local policy prohibits\n   the acceptance of the new subflow, the recipient\
    \ MUST respond with a\n   TCP RST for the subflow.\n   If the token is accepted\
    \ at Host B, but the HMAC returned to Host A\n   does not match the one expected,\
    \ Host A MUST close the subflow with a\n   TCP RST.\n   If Host B does not receive\
    \ the expected HMAC, or the MP_JOIN option\n   is missing from the ACK, it MUST\
    \ close the subflow with a TCP RST.\n   If the HMACs are verified as correct,\
    \ then both hosts have\n   authenticated each other as being the same peers as\
    \ existed at the\n   start of the connection, and they have agreed of which connection\n\
    \   this subflow will become a part.\n   If the SYN/ACK as received at Host A\
    \ does not have an MP_JOIN option,\n   Host A MUST close the subflow with a RST.\n\
    \   This covers all cases of the loss of an MP_JOIN.  In more detail, if\n   MP_JOIN\
    \ is stripped from the SYN on the path from A to B, and Host B\n   does not have\
    \ a passive opener on the relevant port, it will respond\n   with a RST in the\
    \ normal way.  If in response to a SYN with an\n   MP_JOIN option, a SYN/ACK is\
    \ received without the MP_JOIN option\n   (either since it was stripped on the\
    \ return path, or it was stripped\n   on the outgoing path but the passive opener\
    \ on Host B responded as if\n   it were a new regular TCP session), then the subflow\
    \ is unusable and\n   Host A MUST close it with a RST.\n   Note that additional\
    \ subflows can be created between any pair of\n   ports (but see Section 3.8 for\
    \ heuristics); no explicit application-\n   level accept calls or bind calls are\
    \ required to open additional\n   subflows.  To associate a new subflow with an\
    \ existing connection,\n   the token supplied in the subflow's SYN exchange is\
    \ used for\n   demultiplexing.  This then binds the 5-tuple of the TCP subflow\
    \ to\n   the local token of the connection.  A consequence is that it is\n   possible\
    \ to allow any port pairs to be used for a connection.\n   Demultiplexing subflow\
    \ SYNs MUST be done using the token; this is\n   unlike traditional TCP, where\
    \ the destination port is used for\n   demultiplexing SYN packets.  Once a subflow\
    \ is set up, demultiplexing\n   packets is done using the 5-tuple, as in traditional\
    \ TCP.  The\n   5-tuples will be mapped to the local connection identifier (token).\n\
    \   Note that Host A will know its local token for the subflow even\n   though\
    \ it is not sent on the wire -- only the responder's token is\n   sent.\n"
- title: 3.3.  General MPTCP Operation
  contents:
  - "3.3.  General MPTCP Operation\n   This section discusses operation of MPTCP for\
    \ data transfer.  At a\n   high level, an MPTCP implementation will take one input\
    \ data stream\n   from an application, and split it into one or more subflows,\
    \ with\n   sufficient control information to allow it to be reassembled and\n\
    \   delivered reliably and in order to the recipient application.  The\n   following\
    \ subsections define this behavior in detail.\n   The data sequence mapping and\
    \ the Data ACK are signaled in the Data\n   Sequence Signal (DSS) option (Figure\
    \ 9).  Either or both can be\n   signaled in one DSS, dependent on the flags set.\
    \  The data sequence\n   mapping defines how the sequence space on the subflow\
    \ maps to the\n   connection level, and the Data ACK acknowledges receipt of data\
    \ at\n   the connection level.  These functions are described in more detail\n\
    \   in the following two subsections.\n   Either or both the data sequence mapping\
    \ and the Data ACK can be\n   signaled in the DSS option, dependent on the flags\
    \ set.\n                          1                   2                   3\n\
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +---------------+---------------+-------+----------------------+\n\
    \     |     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|\n     +---------------+---------------+-------+----------------------+\n\
    \     |           Data ACK (4 or 8 octets, depending on flags)       |\n     +--------------------------------------------------------------+\n\
    \     |   Data sequence number (4 or 8 octets, depending on flags)   |\n     +--------------------------------------------------------------+\n\
    \     |              Subflow Sequence Number (4 octets)              |\n     +-------------------------------+------------------------------+\n\
    \     |  Data-Level Length (2 octets) |      Checksum (2 octets)     |\n     +-------------------------------+------------------------------+\n\
    \                Figure 9: Data Sequence Signal (DSS) Option\n   The flags, when\
    \ set, define the contents of this option, as follows:\n   o  A = Data ACK present\n\
    \   o  a = Data ACK is 8 octets (if not set, Data ACK is 4 octets)\n   o  M =\
    \ Data Sequence Number (DSN), Subflow Sequence Number (SSN),\n      Data-Level\
    \ Length, and Checksum present\n   o  m = Data sequence number is 8 octets (if\
    \ not set, DSN is 4 octets)\n   The flags 'a' and 'm' only have meaning if the\
    \ corresponding 'A' or\n   'M' flags are set; otherwise, they will be ignored.\
    \  The maximum\n   length of this option, with all flags set, is 28 octets.\n\
    \   The 'F' flag indicates \"DATA_FIN\".  If present, this means that this\n \
    \  mapping covers the final data from the sender.  This is the\n   connection-level\
    \ equivalent to the FIN flag in single-path TCP.  A\n   connection is not closed\
    \ unless there has been a DATA_FIN exchange or\n   a timeout.  The purpose of\
    \ the DATA_FIN and the interactions between\n   this flag, the subflow-level FIN\
    \ flag, and the data sequence mapping\n   are described in Section 3.3.3.  The\
    \ remaining reserved bits MUST be\n   set to zero by an implementation of this\
    \ specification.\n   Note that the checksum is only present in this option if\
    \ the use of\n   MPTCP checksumming has been negotiated at the MP_CAPABLE handshake\n\
    \   (see Section 3.1).  The presence of the checksum can be inferred from\n  \
    \ the length of the option.  If a checksum is present, but its use had\n   not\
    \ been negotiated in the MP_CAPABLE handshake, the checksum field\n   MUST be\
    \ ignored.  If a checksum is not present when its use has been\n   negotiated,\
    \ the receiver MUST close the subflow with a RST as it is\n   considered broken.\n"
- title: 3.3.1.  Data Sequence Mapping
  contents:
  - "3.3.1.  Data Sequence Mapping\n   The data stream as a whole can be reassembled\
    \ through the use of the\n   data sequence mapping components of the DSS option\
    \ (Figure 9), which\n   define the mapping from the subflow sequence number to\
    \ the data\n   sequence number.  This is used by the receiver to ensure in-order\n\
    \   delivery to the application layer.  Meanwhile, the subflow-level\n   sequence\
    \ numbers (i.e., the regular sequence numbers in the TCP\n   header) have subflow-only\
    \ relevance.  It is expected (but not\n   mandated) that SACK [11] is used at\
    \ the subflow level to improve\n   efficiency.\n   The data sequence mapping specifies\
    \ a mapping from subflow sequence\n   space to data sequence space.  This is expressed\
    \ in terms of starting\n   sequence numbers for the subflow and the data level,\
    \ and a length of\n   bytes for which this mapping is valid.  This explicit mapping\
    \ for a\n   range of data was chosen rather than per-packet signaling to assist\n\
    \   with compatibility with situations where TCP/IP segmentation or\n   coalescing\
    \ is undertaken separately from the stack that is generating\n   the data flow\
    \ (e.g., through the use of TCP segmentation offloading\n   on network interface\
    \ cards, or by middleboxes such as performance\n   enhancing proxies).  It also\
    \ allows a single mapping to cover many\n   packets, which may be useful in bulk\
    \ transfer situations.\n   A mapping is fixed, in that the subflow sequence number\
    \ is bound to\n   the data sequence number after the mapping has been processed.\
    \  A\n   sender MUST NOT change this mapping after it has been declared;\n   however,\
    \ the same data sequence number can be mapped to by different\n   subflows for\
    \ retransmission purposes (see Section 3.3.6).  This would\n   also permit the\
    \ same data to be sent simultaneously on multiple\n   subflows for resilience\
    \ or efficiency purposes, especially in the\n   case of lossy links.  Although\
    \ the detailed specification of such\n   operation is outside the scope of this\
    \ document, an implementation\n   SHOULD treat the first data that is received\
    \ at a subflow for the\n   data sequence space as that which should be delivered\
    \ to the\n   application, and any later data for that sequence space ignored.\n\
    \   The data sequence number is specified as an absolute value, whereas\n   the\
    \ subflow sequence numbering is relative (the SYN at the start of\n   the subflow\
    \ has relative subflow sequence number 0).  This is to\n   allow middleboxes to\
    \ change the initial sequence number of a subflow,\n   such as firewalls that\
    \ undertake ISN randomization.\n   The data sequence mapping also contains a checksum\
    \ of the data that\n   this mapping covers, if use of checksums has been negotiated\
    \ at the\n   MP_CAPABLE exchange.  Checksums are used to detect if the payload\
    \ has\n   been adjusted in any way by a non-MPTCP-aware middlebox.  If this\n\
    \   checksum fails, it will trigger a failure of the subflow, or a\n   fallback\
    \ to regular TCP, as documented in Section 3.6, since MPTCP\n   can no longer\
    \ reliably know the subflow sequence space at the\n   receiver to build data sequence\
    \ mappings.\n   The checksum algorithm used is the standard TCP checksum [1],\n\
    \   operating over the data covered by this mapping, along with a pseudo-\n  \
    \ header as shown in Figure 10.\n                          1                 \
    \  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +--------------------------------------------------------------+\n\
    \     |                                                              |\n     |\
    \                Data Sequence Number (8 octets)               |\n     |     \
    \                                                         |\n     +--------------------------------------------------------------+\n\
    \     |              Subflow Sequence Number (4 octets)              |\n     +-------------------------------+------------------------------+\n\
    \     |  Data-Level Length (2 octets) |        Zeros (2 octets)      |\n     +-------------------------------+------------------------------+\n\
    \                 Figure 10: Pseudo-Header for DSS Checksum\n   Note that the\
    \ data sequence number used in the pseudo-header is\n   always the 64-bit value,\
    \ irrespective of what length is used in the\n   DSS option itself.  The standard\
    \ TCP checksum algorithm has been\n   chosen since it will be calculated anyway\
    \ for the TCP subflow, and if\n   calculated first over the data before adding\
    \ the pseudo-headers, it\n   only needs to be calculated once.  Furthermore, since\
    \ the TCP\n   checksum is additive, the checksum for a DSN_MAP can be constructed\n\
    \   by simply adding together the checksums for the data of each\n   constituent\
    \ TCP segment, and adding the checksum for the DSS pseudo-\n   header.\n   Note\
    \ that checksumming relies on the TCP subflow containing\n   contiguous data;\
    \ therefore, a TCP subflow MUST NOT use the Urgent\n   Pointer to interrupt an\
    \ existing mapping.  Further note, however,\n   that if Urgent data is received\
    \ on a subflow, it SHOULD be mapped to\n   the data sequence space and delivered\
    \ to the application analogous to\n   Urgent data in regular TCP.\n   To avoid\
    \ possible deadlock scenarios, subflow-level processing should\n   be undertaken\
    \ separately from that at connection level.  Therefore,\n   even if a mapping\
    \ does not exist from the subflow space to the data-\n   level space, the data\
    \ SHOULD still be ACKed at the subflow (if it is\n   in-window).  This data cannot,\
    \ however, be acknowledged at the data\n   level (Section 3.3.2) because its data\
    \ sequence numbers are unknown.\n   Implementations MAY hold onto such unmapped\
    \ data for a short while in\n   the expectation that a mapping will arrive shortly.\
    \  Such unmapped\n   data cannot be counted as being within the connection level\
    \ receive\n   window because this is relative to the data sequence numbers, so\
    \ if\n   the receiver runs out of memory to hold this data, it will have to be\n\
    \   discarded.  If a mapping for that subflow-level sequence space does\n   not\
    \ arrive within a receive window of data, that subflow SHOULD be\n   treated as\
    \ broken, closed with a RST, and any unmapped data silently\n   discarded.\n \
    \  Data sequence numbers are always 64-bit quantities, and MUST be\n   maintained\
    \ as such in implementations.  If a connection is\n   progressing at a slow rate,\
    \ so protection against wrapped sequence\n   numbers is not required, then it\
    \ is permissible to include just the\n   lower 32 bits of the data sequence number\
    \ in the data sequence\n   mapping and/or Data ACK as an optimization, and an\
    \ implementation can\n   make this choice independently for each packet.\n   An\
    \ implementation MUST send the full 64-bit data sequence number if\n   it is transmitting\
    \ at a sufficiently high rate that the 32-bit value\n   could wrap within the\
    \ Maximum Segment Lifetime (MSL) [16].  The\n   lengths of the DSNs used in these\
    \ values (which may be different) are\n   declared with flags in the DSS option.\
    \  Implementations MUST accept a\n   32-bit DSN and implicitly promote it to a\
    \ 64-bit quantity by\n   incrementing the upper 32 bits of sequence number each\
    \ time the lower\n   32 bits wrap.  A sanity check MUST be implemented to ensure\
    \ that a\n   wrap occurs at an expected time (e.g., the sequence number jumps\
    \ from\n   a very high number to a very low number) and is not triggered by out-\n\
    \   of-order packets.\n   As with the standard TCP sequence number, the data sequence\
    \ number\n   should not start at zero, but at a random value to make blind session\n\
    \   hijacking harder.  This specification requires setting the initial\n   data\
    \ sequence number (IDSN) of each host to the least significant 64\n   bits of\
    \ the SHA-1 hash of the host's key, as described in\n   Section 3.1.\n   A data\
    \ sequence mapping does not need to be included in every MPTCP\n   packet, as\
    \ long as the subflow sequence space in that packet is\n   covered by a mapping\
    \ known at the receiver.  This can be used to\n   reduce overhead in cases where\
    \ the mapping is known in advance; one\n   such case is when there is a single\
    \ subflow between the hosts,\n   another is when segments of data are scheduled\
    \ in larger than packet-\n   sized chunks.\n   An \"infinite\" mapping can be\
    \ used to fall back to regular TCP by\n   mapping the subflow-level data to the\
    \ connection-level data for the\n   remainder of the connection (see Section 3.6).\
    \  This is achieved by\n   setting the Data-Level Length field of the DSS option\
    \ to the reserved\n   value of 0.  The checksum, in such a case, will also be\
    \ set to zero.\n"
- title: 3.3.2.  Data Acknowledgments
  contents:
  - "3.3.2.  Data Acknowledgments\n   To provide full end-to-end resilience, MPTCP\
    \ provides a connection-\n   level acknowledgment, to act as a cumulative ACK\
    \ for the connection\n   as a whole.  This is the \"Data ACK\" field of the DSS\
    \ option\n   (Figure 9).  The Data ACK is analogous to the behavior of the\n \
    \  standard TCP cumulative ACK -- indicating how much data has been\n   successfully\
    \ received (with no holes).  This is in comparison to the\n   subflow-level ACK,\
    \ which acts analogous to TCP SACK, given that there\n   may still be holes in\
    \ the data stream at the connection level.  The\n   Data ACK specifies the next\
    \ data sequence number it expects to\n   receive.\n   The Data ACK, as for the\
    \ DSN, can be sent as the full 64-bit value,\n   or as the lower 32 bits.  If\
    \ data is received with a 64-bit DSN, it\n   MUST be acknowledged with a 64-bit\
    \ Data ACK.  If the DSN received is\n   32 bits, it is valid for the implementation\
    \ to choose whether to send\n   a 32-bit or 64-bit Data ACK.\n   The Data ACK\
    \ proves that the data, and all required MPTCP signaling,\n   has been received\
    \ and accepted by the remote end.  One key use of the\n   Data ACK signal is that\
    \ it is used to indicate the left edge of the\n   advertised receive window. \
    \ As explained in Section 3.3.4, the\n   receive window is shared by all subflows\
    \ and is relative to the Data\n   ACK.  Because of this, an implementation MUST\
    \ NOT use the RCV.WND\n   field of a TCP segment at the connection level if it\
    \ does not also\n   carry a DSS option with a Data ACK field.  Furthermore, separating\n\
    \   the connection-level acknowledgments from the subflow level allows\n   processing\
    \ to be done separately, and a receiver has the freedom to\n   drop segments after\
    \ acknowledgment at the subflow level, for example,\n   due to memory constraints\
    \ when many segments arrive out of order.\n   An MPTCP sender MUST NOT free data\
    \ from the send buffer until it has\n   been acknowledged by both a Data ACK received\
    \ on any subflow and at\n   the subflow level by all subflows on which the data\
    \ was sent.  The\n   former condition ensures liveness of the connection and the\
    \ latter\n   condition ensures liveness and self-consistence of a subflow when\n\
    \   data needs to be retransmitted.  Note, however, that if some data\n   needs\
    \ to be retransmitted multiple times over a subflow, there is a\n   risk of blocking\
    \ the sending window.  In this case, the MPTCP sender\n   can decide to terminate\
    \ the subflow that is behaving badly by sending\n   a RST.\n   The Data ACK MAY\
    \ be included in all segments; however, optimizations\n   SHOULD be considered\
    \ in more advanced implementations, where the Data\n   ACK is present in segments\
    \ only when the Data ACK value advances, and\n   this behavior MUST be treated\
    \ as valid.  This behavior ensures the\n   sender buffer is freed, while reducing\
    \ overhead when the data\n   transfer is unidirectional.\n"
- title: 3.3.3.  Closing a Connection
  contents:
  - "3.3.3.  Closing a Connection\n   In regular TCP, a FIN announces the receiver\
    \ that the sender has no\n   more data to send.  In order to allow subflows to\
    \ operate\n   independently and to keep the appearance of TCP over the wire, a\
    \ FIN\n   in MPTCP only affects the subflow on which it is sent.  This allows\n\
    \   nodes to exercise considerable freedom over which paths are in use at\n  \
    \ any one time.  The semantics of a FIN remain as for regular TCP;\n   i.e., it\
    \ is not until both sides have ACKed each other's FINs that\n   the subflow is\
    \ fully closed.\n   When an application calls close() on a socket, this indicates\
    \ that it\n   has no more data to send; for regular TCP, this would result in\
    \ a FIN\n   on the connection.  For MPTCP, an equivalent mechanism is needed,\
    \ and\n   this is referred to as the DATA_FIN.\n   A DATA_FIN is an indication\
    \ that the sender has no more data to send,\n   and as such can be used to verify\
    \ that all data has been successfully\n   received.  A DATA_FIN, as with the FIN\
    \ on a regular TCP connection,\n   is a unidirectional signal.\n   The DATA_FIN\
    \ is signaled by setting the 'F' flag in the Data Sequence\n   Signal option (Figure\
    \ 9) to 1.  A DATA_FIN occupies 1 octet (the\n   final octet) of the connection-level\
    \ sequence space.  Note that the\n   DATA_FIN is included in the Data-Level Length,\
    \ but not at the subflow\n   level: for example, a segment with DSN 80, and Data-Level\
    \ Length 11,\n   with DATA_FIN set, would map 10 octets from the subflow into\
    \ data\n   sequence space 80-89, the DATA_FIN is DSN 90; therefore, this segment\n\
    \   including DATA_FIN would be acknowledged with a DATA_ACK of 91.\n   Note that\
    \ when the DATA_FIN is not attached to a TCP segment\n   containing data, the\
    \ Data Sequence Signal MUST have a subflow\n   sequence number of 0, a Data-Level\
    \ Length of 1, and the data sequence\n   number that corresponds with the DATA_FIN\
    \ itself.  The checksum in\n   this case will only cover the pseudo-header.\n\
    \   A DATA_FIN has the semantics and behavior as a regular TCP FIN, but\n   at\
    \ the connection level.  Notably, it is only DATA_ACKed once all\n   data has\
    \ been successfully received at the connection level.  Note,\n   therefore, that\
    \ a DATA_FIN is decoupled from a subflow FIN.  It is\n   only permissible to combine\
    \ these signals on one subflow if there is\n   no data outstanding on other subflows.\
    \  Otherwise, it may be\n   necessary to retransmit data on different subflows.\
    \  Essentially, a\n   host MUST NOT close all functioning subflows unless it is\
    \ safe to do\n   so, i.e., until all outstanding data has been DATA_ACKed, or\
    \ until\n   the segment with the DATA_FIN flag set is the only outstanding\n \
    \  segment.\n   Once a DATA_FIN has been acknowledged, all remaining subflows\
    \ MUST be\n   closed with standard FIN exchanges.  Both hosts SHOULD send FINs\
    \ on\n   all subflows, as a courtesy to allow middleboxes to clean up state\n\
    \   even if an individual subflow has failed.  It is also encouraged to\n   reduce\
    \ the timeouts (Maximum Segment Life) on subflows at end hosts.\n   In particular,\
    \ any subflows where there is still outstanding data\n   queued (which has been\
    \ retransmitted on other subflows in order to\n   get the DATA_FIN acknowledged)\
    \ MAY be closed with a RST.\n   A connection is considered closed once both hosts'\
    \ DATA_FINs have\n   been acknowledged by DATA_ACKs.\n   As specified above, a\
    \ standard TCP FIN on an individual subflow only\n   shuts down the subflow on\
    \ which it was sent.  If all subflows have\n   been closed with a FIN exchange,\
    \ but no DATA_FIN has been received\n   and acknowledged, the MPTCP connection\
    \ is treated as closed only\n   after a timeout.  This implies that an implementation\
    \ will have\n   TIME_WAIT states at both the subflow and connection levels (see\n\
    \   Appendix C).  This permits \"break-before-make\" scenarios where\n   connectivity\
    \ is lost on all subflows before a new one can be re-\n   established.\n"
- title: 3.3.4.  Receiver Considerations
  contents:
  - "3.3.4.  Receiver Considerations\n   Regular TCP advertises a receive window in\
    \ each packet, telling the\n   sender how much data the receiver is willing to\
    \ accept past the\n   cumulative ack.  The receive window is used to implement\
    \ flow\n   control, throttling down fast senders when receivers cannot keep up.\n\
    \   MPTCP also uses a unique receive window, shared between the subflows.\n  \
    \ The idea is to allow any subflow to send data as long as the receiver\n   is\
    \ willing to accept it.  The alternative, maintaining per subflow\n   receive\
    \ windows, could end up stalling some subflows while others\n   would not use\
    \ up their window.\n   The receive window is relative to the DATA_ACK.  As in\
    \ TCP, a\n   receiver MUST NOT shrink the right edge of the receive window (i.e.,\n\
    \   DATA_ACK + receive window).  The receiver will use the data sequence\n   number\
    \ to tell if a packet should be accepted at the connection\n   level.\n   When\
    \ deciding to accept packets at subflow level, regular TCP checks\n   the sequence\
    \ number in the packet against the allowed receive window.\n   With multipath,\
    \ such a check is done using only the connection-level\n   window.  A sanity check\
    \ SHOULD be performed at subflow level to\n   ensure that the subflow and mapped\
    \ sequence numbers meet the\n   following test: SSN - SUBFLOW_ACK <= DSN - DATA_ACK,\
    \ where SSN is the\n   subflow sequence number of the received packet and SUBFLOW_ACK\
    \ is the\n   RCV.NXT (next expected sequence number) of the subflow (with the\n\
    \   equivalent connection-level definitions for DSN and DATA_ACK).\n   In regular\
    \ TCP, once a segment is deemed in-window, it is put either\n   in the in-order\
    \ receive queue or in the out-of-order queue.  In\n   Multipath TCP, the same\
    \ happens but at the connection level: a\n   segment is placed in the connection\
    \ level in-order or out-of-order\n   queue if it is in-window at both connection\
    \ and subflow levels.  The\n   stack still has to remember, for each subflow,\
    \ which segments were\n   received successfully so that it can ACK them at subflow\
    \ level\n   appropriately.  Typically, this will be implemented by keeping per\n\
    \   subflow out-of-order queues (containing only message headers, not the\n  \
    \ payloads) and remembering the value of the cumulative ACK.\n   It is important\
    \ for implementers to understand how large a receiver\n   buffer is appropriate.\
    \  The lower bound for full network utilization\n   is the maximum bandwidth-delay\
    \ product of any one of the paths.\n   However, this might be insufficient when\
    \ a packet is lost on a slower\n   subflow and needs to be retransmitted (see\
    \ Section 3.3.6).  A tight\n   upper bound would be the maximum round-trip time\
    \ (RTT) of any path\n   multiplied by the total bandwidth available across all\
    \ paths.  This\n   permits all subflows to continue at full speed while a packet\
    \ is\n   fast-retransmitted on the maximum RTT path.  Even this might be\n   insufficient\
    \ to maintain full performance in the event of a\n   retransmit timeout on the\
    \ maximum RTT path.  It is for future study\n   to determine the relationship\
    \ between retransmission strategies and\n   receive buffer sizing.\n"
- title: 3.3.5.  Sender Considerations
  contents:
  - "3.3.5.  Sender Considerations\n   The sender remembers receiver window advertisements\
    \ from the\n   receiver.  It should only update its local receive window values\
    \ when\n   the largest sequence number allowed (i.e., DATA_ACK + receive window)\n\
    \   increases, on the receipt of a DATA_ACK.  This is important to allow\n   using\
    \ paths with different RTTs, and thus different feedback loops.\n   MPTCP uses\
    \ a single receive window across all subflows, and if the\n   receive window was\
    \ guaranteed to be unchanged end-to-end, a host\n   could always read the most\
    \ recent receive window value.  However,\n   some classes of middleboxes may alter\
    \ the TCP-level receive window.\n   Typically, these will shrink the offered window,\
    \ although for short\n   periods of time it may be possible for the window to\
    \ be larger\n   (however, note that this would not continue for long periods since\n\
    \   ultimately the middlebox must keep up with delivering data to the\n   receiver).\
    \  Therefore, if receive window sizes differ on multiple\n   subflows, when sending\
    \ data MPTCP SHOULD take the largest of the most\n   recent window sizes as the\
    \ one to use in calculations.  This rule is\n   implicit in the requirement not\
    \ to reduce the right edge of the\n   window.\n   The sender MUST also remember\
    \ the receive windows advertised by each\n   subflow.  The allowed window for\
    \ subflow i is (ack_i, ack_i +\n   rcv_wnd_i), where ack_i is the subflow-level\
    \ cumulative ACK of\n   subflow i.  This ensures data will not be sent to a middlebox\
    \ unless\n   there is enough buffering for the data.\n   Putting the two rules\
    \ together, we get the following: a sender is\n   allowed to send data segments\
    \ with data-level sequence numbers\n   between (DATA_ACK, DATA_ACK + receive_window).\
    \  Each of these\n   segments will be mapped onto subflows, as long as subflow\
    \ sequence\n   numbers are in the allowed windows for those subflows.  Note that\n\
    \   subflow sequence numbers do not generally affect flow control if the\n   same\
    \ receive window is advertised across all subflows.  They will\n   perform flow\
    \ control for those subflows with a smaller advertised\n   receive window.\n \
    \  The send buffer MUST, at a minimum, be as big as the receive buffer,\n   to\
    \ enable the sender to reach maximum throughput.\n"
- title: 3.3.6.  Reliability and Retransmissions
  contents:
  - "3.3.6.  Reliability and Retransmissions\n   The data sequence mapping allows\
    \ senders to resend data with the same\n   data sequence number on a different\
    \ subflow.  When doing this, a host\n   MUST still retransmit the original data\
    \ on the original subflow, in\n   order to preserve the subflow integrity (middleboxes\
    \ could replay old\n   data, and/or could reject holes in subflows), and a receiver\
    \ will\n   ignore these retransmissions.  While this is clearly suboptimal, for\n\
    \   compatibility reasons this is sensible behavior.  Optimizations could\n  \
    \ be negotiated in future versions of this protocol.\n   This protocol specification\
    \ does not mandate any mechanisms for\n   handling retransmissions, and much will\
    \ be dependent upon local\n   policy (as discussed in Section 3.3.8).  One can\
    \ imagine aggressive\n   connection-level retransmissions policies where every\
    \ packet lost at\n   subflow level is retransmitted on a different subflow (hence,\
    \ wasting\n   bandwidth but possibly reducing application-to-application delays),\n\
    \   or conservative retransmission policies where connection-level\n   retransmits\
    \ are only used after a few subflow-level retransmission\n   timeouts occur.\n\
    \   It is envisaged that a standard connection-level retransmission\n   mechanism\
    \ would be implemented around a connection-level data queue:\n   all segments\
    \ that haven't been DATA_ACKed are stored.  A timer is set\n   when the head of\
    \ the connection-level is ACKed at subflow level but\n   its corresponding data\
    \ is not ACKed at data level.  This timer will\n   guard against failures in retransmission\
    \ by middleboxes that\n   proactively ACK data.\n   The sender MUST keep data\
    \ in its send buffer as long as the data has\n   not been acknowledged at both\
    \ connection level and on all subflows on\n   which it has been sent.  In this\
    \ way, the sender can always\n   retransmit the data if needed, on the same subflow\
    \ or on a different\n   one.  A special case is when a subflow fails: the sender\
    \ will\n   typically resend the data on other working subflows after a timeout,\n\
    \   and will keep trying to retransmit the data on the failed subflow\n   too.\
    \  The sender will declare the subflow failed after a predefined\n   upper bound\
    \ on retransmissions is reached (which MAY be lower than\n   the usual TCP limits\
    \ of the Maximum Segment Life), or on the receipt\n   of an ICMP error, and only\
    \ then delete the outstanding data segments.\n   Multiple retransmissions are\
    \ triggers that will indicate that a\n   subflow performs badly and could lead\
    \ to a host resetting the subflow\n   with a RST.  However, additional research\
    \ is required to understand\n   the heuristics of how and when to reset underperforming\
    \ subflows.\n   For example, a highly asymmetric path may be misdiagnosed as\n\
    \   underperforming.\n"
- title: 3.3.7.  Congestion Control Considerations
  contents:
  - "3.3.7.  Congestion Control Considerations\n   Different subflows in an MPTCP\
    \ connection have different congestion\n   windows.  To achieve fairness at bottlenecks\
    \ and resource pooling, it\n   is necessary to couple the congestion windows in\
    \ use on each subflow,\n   in order to push most traffic to uncongested links.\
    \  One algorithm\n   for achieving this is presented in [5]; the algorithm does\
    \ not\n   achieve perfect resource pooling but is \"safe\" in that it is readily\n\
    \   deployable in the current Internet.  By this, we mean that it does\n   not\
    \ take up more capacity on any one path than if it was a single\n   path flow\
    \ using only that route, so this ensures fair coexistence\n   with single-path\
    \ TCP at shared bottlenecks.\n   It is foreseeable that different congestion controllers\
    \ will be\n   implemented for MPTCP, each aiming to achieve different properties\
    \ in\n   the resource pooling/fairness/stability design space, as well as\n  \
    \ those for achieving different properties in quality of service,\n   reliability,\
    \ and resilience.\n   Regardless of the algorithm used, the design of the MPTCP\
    \ protocol\n   aims to provide the congestion control implementations sufficient\n\
    \   information to take the right decisions; this information includes,\n   for\
    \ each subflow, which packets were lost and when.\n"
- title: 3.3.8.  Subflow Policy
  contents:
  - "3.3.8.  Subflow Policy\n   Within a local MPTCP implementation, a host may use\
    \ any local policy\n   it wishes to decide how to share the traffic to be sent\
    \ over the\n   available paths.\n   In the typical use case, where the goal is\
    \ to maximize throughput,\n   all available paths will be used simultaneously\
    \ for data transfer,\n   using coupled congestion control as described in [5].\
    \  It is\n   expected, however, that other use cases will appear.\n   For instance,\
    \ a possibility is an 'all-or-nothing' approach, i.e.,\n   have a second path\
    \ ready for use in the event of failure of the first\n   path, but alternatives\
    \ could include entirely saturating one path\n   before using an additional path\
    \ (the 'overflow' case).  Such choices\n   would be most likely based on the monetary\
    \ cost of links, but may\n   also be based on properties such as the delay or\
    \ jitter of links,\n   where stability (of delay or bandwidth) is more important\
    \ than\n   throughput.  Application requirements such as these are discussed in\n\
    \   detail in [6].\n   The ability to make effective choices at the sender requires\
    \ full\n   knowledge of the path \"cost\", which is unlikely to be the case. \
    \ It\n   would be desirable for a receiver to be able to signal their own\n  \
    \ preferences for paths, since they will often be the multihomed party,\n   and\
    \ may have to pay for metered incoming bandwidth.\n   Whilst fine-grained control\
    \ may be the most powerful solution, that\n   would require some mechanism such\
    \ as overloading the Explicit\n   Congestion Notification (ECN) signal [17], which\
    \ is undesirable, and\n   it is felt that there would not be sufficient benefit\
    \ to justify an\n   entirely new signal.  Therefore, the MP_JOIN option (see Section\
    \ 3.2)\n   contains the 'B' bit, which allows a host to indicate to its peer\n\
    \   that this path should be treated as a backup path to use only in the\n   event\
    \ of failure of other working subflows (i.e., a subflow where the\n   receiver\
    \ has indicated B=1 SHOULD NOT be used to send data unless\n   there are no usable\
    \ subflows where B=0).\n   In the event that the available set of paths changes,\
    \ a host may wish\n   to signal a change in priority of subflows to the peer (e.g.,\
    \ a\n   subflow that was previously set as backup should now take priority\n \
    \  over all remaining subflows).  Therefore, the MP_PRIO option, shown\n   in\
    \ Figure 11, can be used to change the 'B' flag of the subflow on\n   which it\
    \ is sent.\n                           1                   2                 \
    \  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +---------------+---------------+-------+-----+-+--------------+\n    \
    \  |     Kind      |     Length    |Subtype|     |B| AddrID (opt) |\n      +---------------+---------------+-------+-----+-+--------------+\n\
    \            Figure 11: Change Subflow Priority (MP_PRIO) Option\n   It should\
    \ be noted that the backup flag is a request from a data\n   receiver to a data\
    \ sender only, and the data sender SHOULD adhere to\n   these requests.  A host\
    \ cannot assume that the data sender will do\n   so, however, since local policies\
    \ -- or technical difficulties -- may\n   override MP_PRIO requests.  Note also\
    \ that this signal applies to a\n   single direction, and so the sender of this\
    \ option could choose to\n   continue using the subflow to send data even if it\
    \ has signaled B=1\n   to the other host.\n   This option can also be applied\
    \ to other subflows than the one on\n   which it is sent, by setting the optional\
    \ Address ID field.  This\n   applies the given setting of B to all subflows in\
    \ this connection\n   that use the address identified by the given Address ID.\
    \  The\n   presence of this field is determined by the option length; if\n   Length==4\
    \ then it is present.  If Length==3, then it applies to the\n   current subflow\
    \ only.  The use case of this is that a host can signal\n   to its peer that an\
    \ address is temporarily unavailable (for example,\n   if it has radio coverage\
    \ issues) and the peer should therefore drop\n   to backup state on all subflows\
    \ using that Address ID.\n"
- title: 3.4.  Address Knowledge Exchange (Path Management)
  contents:
  - "3.4.  Address Knowledge Exchange (Path Management)\n   We use the term \"path\
    \ management\" to refer to the exchange of\n   information about additional paths\
    \ between hosts, which in this\n   design is managed by multiple addresses at\
    \ hosts.  For more detail of\n   the architectural thinking behind this design,\
    \ see the MPTCP\n   Architecture document [2].\n   This design makes use of two\
    \ methods of sharing such information, and\n   both can be used on a connection.\
    \  The first is the direct setup of\n   new subflows, already described in Section\
    \ 3.2, where the initiator\n   has an additional address.  The second method,\
    \ described in the\n   following subsections, signals addresses explicitly to\
    \ the other host\n   to allow it to initiate new subflows.  The two mechanisms\
    \ are\n   complementary: the first is implicit and simple, while the explicit\n\
    \   is more complex but is more robust.  Together, the mechanisms allow\n   addresses\
    \ to change in flight (and thus support operation through\n   NATs, since the\
    \ source address need not be known), and also allow the\n   signaling of previously\
    \ unknown addresses, and of addresses belonging\n   to other address families\
    \ (e.g., both IPv4 and IPv6).\n   Here is an example of typical operation of the\
    \ protocol:\n   o  An MPTCP connection is initially set up between address/port\
    \ A1 of\n      Host A and address/port B1 of Host B.  If Host A is multihomed\
    \ and\n      multiaddressed, it can start an additional subflow from its\n   \
    \   address A2 to B1, by sending a SYN with a Join option from A2 to\n      B1,\
    \ using B's previously declared token for this connection.\n      Alternatively,\
    \ if B is multihomed, it can try to set up a new\n      subflow from B2 to A1,\
    \ using A's previously declared token.  In\n      either case, the SYN will be\
    \ sent to the port already in use for\n      the original subflow on the receiving\
    \ host.\n   o  Simultaneously (or after a timeout), an ADD_ADDR option\n     \
    \ (Section 3.4.1) is sent on an existing subflow, informing the\n      receiver\
    \ of the sender's alternative address(es).  The recipient\n      can use this\
    \ information to open a new subflow to the sender's\n      additional address.\
    \  In our example, A will send ADD_ADDR option\n      informing B of address/port\
    \ A2.  The mix of using the SYN-based\n      option and the ADD_ADDR option, including\
    \ timeouts, is\n      implementation specific and can be tailored to agree with\
    \ local\n      policy.\n   o  If subflow A2-B1 is successfully set up, Host B\
    \ can use the\n      Address ID in the Join option to correlate this with the\
    \ ADD_ADDR\n      option that will also arrive on an existing subflow; now B knows\n\
    \      not to open A2-B1, ignoring the ADD_ADDR.  Otherwise, if B has not\n  \
    \    received the A2-B1 MP_JOIN SYN but received the ADD_ADDR, it can\n      try\
    \ to initiate a new subflow from one or more of its addresses to\n      address\
    \ A2.  This permits new sessions to be opened if one host is\n      behind a NAT.\n\
    \   Other ways of using the two signaling mechanisms are possible; for\n   instance,\
    \ signaling addresses in other address families can only be\n   done explicitly\
    \ using the Add Address option.\n"
- title: 3.4.1.  Address Advertisement
  contents:
  - "3.4.1.  Address Advertisement\n   The Add Address (ADD_ADDR) TCP option announces\
    \ additional addresses\n   (and optionally, ports) on which a host can be reached\
    \ (Figure 12).\n   Multiple instances of this TCP option can be added in a single\n\
    \   message if there is sufficient TCP option space; otherwise, multiple\n   TCP\
    \ messages containing this option will be sent.  This option can be\n   used at\
    \ any time during a connection, depending on when the sender\n   wishes to enable\
    \ multiple paths and/or when paths become available.\n   As with all MPTCP signals,\
    \ the receiver MUST undertake standard TCP\n   validity checks before acting upon\
    \ it.\n   Every address has an Address ID that can be used for uniquely\n   identifying\
    \ the address within a connection for address removal.\n   This is also used to\
    \ identify MP_JOIN options (see Section 3.2)\n   relating to the same address,\
    \ even when address translators are in\n   use.  The Address ID MUST uniquely\
    \ identify the address to the sender\n   (within the scope of the connection),\
    \ but the mechanism for\n   allocating such IDs is implementation specific.\n\
    \   All address IDs learned via either MP_JOIN or ADD_ADDR SHOULD be\n   stored\
    \ by the receiver in a data structure that gathers all the\n   Address ID to address\
    \ mappings for a connection (identified by a\n   token pair).  In this way, there\
    \ is a stored mapping between Address\n   ID, observed source address, and token\
    \ pair for future processing of\n   control information for a connection.  Note\
    \ that an implementation\n   MAY discard incoming address advertisements at will,\
    \ for example, for\n   avoiding the required mapping state, or because advertised\
    \ addresses\n   are of no use to it (for example, IPv6 addresses when it has IPv4\n\
    \   only).  Therefore, a host MUST treat address advertisements as soft\n   state,\
    \ and it MAY choose to refresh advertisements periodically.\n   This option is\
    \ shown in Figure 12.  The illustration is sized for\n   IPv4 addresses (IPVer\
    \ = 4).  For IPv6, the IPVer field will read 6,\n   and the length of the address\
    \ will be 16 octets (instead of 4).\n   The presence of the final 2 octets, specifying\
    \ the TCP port number to\n   use, are optional and can be inferred from the length\
    \ of the option.\n   Although it is expected that the majority of use cases will\
    \ use the\n   same port pairs as used for the initial subflow (e.g., port 80\n\
    \   remains port 80 on all subflows, as does the ephemeral port at the\n   client),\
    \ there may be cases (such as port-based load balancing) where\n   the explicit\
    \ specification of a different port is required.  If no\n   port is specified,\
    \ MPTCP SHOULD attempt to connect to the specified\n   address on the same port\
    \ as is already in use by the subflow on which\n   the ADD_ADDR signal was sent;\
    \ this is discussed in more detail in\n   Section 3.8.\n                     \
    \      1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+-------+---------------+\n\
    \      |     Kind      |     Length    |Subtype| IPVer |  Address ID   |\n   \
    \   +---------------+---------------+-------+-------+---------------+\n      |\
    \          Address (IPv4 - 4 octets / IPv6 - 16 octets)         |\n      +-------------------------------+-------------------------------+\n\
    \      |   Port (2 octets, optional)   |\n      +-------------------------------+\n\
    \                 Figure 12: Add Address (ADD_ADDR) Option\n   Due to the proliferation\
    \ of NATs, it is reasonably likely that one\n   host may attempt to advertise\
    \ private addresses [18].  It is not\n   desirable to prohibit this, since there\
    \ may be cases where both hosts\n   have additional interfaces on the same private\
    \ network, and a host\n   MAY want to advertise such addresses.  The MP_JOIN handshake\
    \ to\n   create a new subflow (Section 3.2) provides mechanisms to minimize\n\
    \   security risks.  The MP_JOIN message contains a 32-bit token that\n   uniquely\
    \ identifies the connection to the receiving host.  If the\n   token is unknown,\
    \ the host will return with a RST.  In the unlikely\n   event that the token is\
    \ known, subflow setup will continue, but the\n   HMAC exchange must occur for\
    \ authentication.  This will fail, and\n   will provide sufficient protection\
    \ against two unconnected hosts\n   accidentally setting up a new subflow upon\
    \ the signal of a private\n   address.  Further security considerations around\
    \ the issue of\n   ADD_ADDR messages that accidentally misdirect, or maliciously\
    \ direct,\n   new MP_JOIN attempts are discussed in Section 5.\n   Ideally, ADD_ADDR\
    \ and REMOVE_ADDR options would be sent reliably, and\n   in order, to the other\
    \ end.  This would ensure that this address\n   management does not unnecessarily\
    \ cause an outage in the connection\n   when remove/add addresses are processed\
    \ in reverse order, and also to\n   ensure that all possible paths are used. \
    \ Note, however, that losing\n   reliability and ordering will not break the multipath\
    \ connections, it\n   will just reduce the opportunity to open multipath paths\
    \ and to\n   survive different patterns of path failures.\n   Therefore, implementing\
    \ reliability signals for these TCP options is\n   not necessary.  In order to\
    \ minimize the impact of the loss of these\n   options, however, it is RECOMMENDED\
    \ that a sender should send these\n   options on all available subflows.  If these\
    \ options need to be\n   received in order, an implementation SHOULD only send\
    \ one ADD_ADDR/\n   REMOVE_ADDR option per RTT, to minimize the risk of misordering.\n\
    \   A host can send an ADD_ADDR message with an already assigned Address\n   ID,\
    \ but the Address MUST be the same as previously assigned to this\n   Address\
    \ ID, and the Port MUST be different from one already in use\n   for this Address\
    \ ID.  If these conditions are not met, the receiver\n   SHOULD silently ignore\
    \ the ADD_ADDR.  A host wishing to replace an\n   existing Address ID MUST first\
    \ remove the existing one\n   (Section 3.4.2).\n   A host that receives an ADD_ADDR\
    \ but finds a connection set up to\n   that IP address and port number is unsuccessful\
    \ SHOULD NOT perform\n   further connection attempts to this address/port combination\
    \ for this\n   connection.  A sender that wants to trigger a new incoming connection\n\
    \   attempt on a previously advertised address/port combination can\n   therefore\
    \ refresh ADD_ADDR information by sending the option again.\n   During normal\
    \ MPTCP operation, it is unlikely that there will be\n   sufficient TCP option\
    \ space for ADD_ADDR to be included along with\n   those for data sequence numbering\
    \ (Section 3.3.1).  Therefore, it is\n   expected that an MPTCP implementation\
    \ will send the ADD_ADDR option\n   on separate ACKs.  As discussed earlier, however,\
    \ an MPTCP\n   implementation MUST NOT treat duplicate ACKs with any MPTCP option,\n\
    \   with the exception of the DSS option, as indications of congestion\n   [12],\
    \ and an MPTCP implementation SHOULD NOT send more than two\n   duplicate ACKs\
    \ in a row for signaling purposes.\n"
- title: 3.4.2.  Remove Address
  contents:
  - "3.4.2.  Remove Address\n   If, during the lifetime of an MPTCP connection, a\
    \ previously\n   announced address becomes invalid (e.g., if the interface\n \
    \  disappears), the affected host SHOULD announce this so that the peer\n   can\
    \ remove subflows related to this address.\n   This is achieved through the Remove\
    \ Address (REMOVE_ADDR) option\n   (Figure 13), which will remove a previously\
    \ added address (or list of\n   addresses) from a connection and terminate any\
    \ subflows currently\n   using that address.\n   For security purposes, if a host\
    \ receives a REMOVE_ADDR option, it\n   must ensure the affected path(s) are no\
    \ longer in use before it\n   instigates closure.  The receipt of REMOVE_ADDR\
    \ SHOULD first trigger\n   the sending of a TCP keepalive [19] on the path, and\
    \ if a response is\n   received the path SHOULD NOT be removed.  Typical TCP validity\
    \ tests\n   on the subflow (e.g., ensuring sequence and ACK numbers are correct)\n\
    \   MUST also be undertaken.  An implementation can use indications of\n   these\
    \ test failures as part of intrusion detection or error logging.\n   The sending\
    \ and receipt (if no keepalive response was received) of\n   this message SHOULD\
    \ trigger the sending of RSTs by both hosts on the\n   affected subflow(s) (if\
    \ possible), as a courtesy to cleaning up\n   middlebox state, before cleaning\
    \ up any local state.\n   Address removal is undertaken by ID, so as to permit\
    \ the use of NATs\n   and other middleboxes that rewrite source addresses.  If\
    \ there is no\n   address at the requested ID, the receiver will silently ignore\
    \ the\n   request.\n   A subflow that is still functioning MUST be closed with\
    \ a FIN\n   exchange as in regular TCP, rather than using this option.  For more\n\
    \   information, see Section 3.3.3.\n                        1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+-------+-------+---------------+\n\
    \   |     Kind      |  Length = 3+n |Subtype|(resvd)|   Address ID  | ...\n  \
    \ +---------------+---------------+-------+-------+---------------+\n        \
    \                      (followed by n-1 Address IDs, if required)\n          \
    \    Figure 13: Remove Address (REMOVE_ADDR) Option\n"
- title: 3.5.  Fast Close
  contents:
  - "3.5.  Fast Close\n   Regular TCP has the means of sending a reset (RST) signal\
    \ to abruptly\n   close a connection.  With MPTCP, the RST only has the scope\
    \ of the\n   subflow and will only close the concerned subflow but not affect\
    \ the\n   remaining subflows.  MPTCP's connection will stay alive at the data\n\
    \   level, in order to permit break-before-make handover between\n   subflows.\
    \  It is therefore necessary to provide an MPTCP-level\n   \"reset\" to allow\
    \ the abrupt closure of the whole MPTCP connection,\n   and this is the MP_FASTCLOSE\
    \ option.\n   MP_FASTCLOSE is used to indicate to the peer that the connection\
    \ will\n   be abruptly closed and no data will be accepted anymore.  The reasons\n\
    \   for triggering an MP_FASTCLOSE are implementation specific.  Regular\n   TCP\
    \ does not allow sending a RST while the connection is in a\n   synchronized state\
    \ [1].  Nevertheless, implementations allow the\n   sending of a RST in this state,\
    \ if, for example, the operating system\n   is running out of resources.  In these\
    \ cases, MPTCP should send the\n   MP_FASTCLOSE.  This option is illustrated in\
    \ Figure 14.\n                            1                   2              \
    \     3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n       +---------------+---------------+-------+-----------------------+\n\
    \       |     Kind      |    Length     |Subtype|      (reserved)       |\n  \
    \     +---------------+---------------+-------+-----------------------+\n    \
    \   |                      Option Receiver's Key                    |\n      \
    \ |                            (64 bits)                          |\n       |\
    \                                                               |\n       +---------------------------------------------------------------+\n\
    \                Figure 14: Fast Close (MP_FASTCLOSE) Option\n   If Host A wants\
    \ to force the closure of an MPTCP connection, the\n   MPTCP Fast Close procedure\
    \ is as follows:\n   o  Host A sends an ACK containing the MP_FASTCLOSE option\
    \ on one\n      subflow, containing the key of Host B as declared in the initial\n\
    \      connection handshake.  On all the other subflows, Host A sends a\n    \
    \  regular TCP RST to close these subflows, and tears them down.\n      Host A\
    \ now enters FASTCLOSE_WAIT state.\n   o  Upon receipt of an MP_FASTCLOSE, containing\
    \ the valid key, Host B\n      answers on the same subflow with a TCP RST and\
    \ tears down all\n      subflows.  Host B can now close the whole MPTCP connection\
    \ (it\n      transitions directly to CLOSED state).\n   o  As soon as Host A has\
    \ received the TCP RST on the remaining\n      subflow, it can close this subflow\
    \ and tear down the whole\n      connection (transition from FASTCLOSE_WAIT to\
    \ CLOSED states).  If\n      Host A receives an MP_FASTCLOSE instead of a TCP\
    \ RST, both hosts\n      attempted fast closure simultaneously.  Host A should\
    \ reply with a\n      TCP RST and tear down the connection.\n   o  If Host A does\
    \ not receive a TCP RST in reply to its MP_FASTCLOSE\n      after one retransmission\
    \ timeout (RTO) (the RTO of the subflow\n      where the MPTCP_RST has been sent),\
    \ it SHOULD retransmit the\n      MP_FASTCLOSE.  The number of retransmissions\
    \ SHOULD be limited to\n      avoid this connection from being retained for a\
    \ long time, but\n      this limit is implementation specific.  A RECOMMENDED\
    \ number is 3.\n"
- title: 3.6.  Fallback
  contents:
  - "3.6.  Fallback\n   Sometimes, middleboxes will exist on a path that could prevent\
    \ the\n   operation of MPTCP.  MPTCP has been designed in order to cope with\n\
    \   many middlebox modifications (see Section 6), but there are still\n   some\
    \ cases where a subflow could fail to operate within the MPTCP\n   requirements.\
    \  These cases are notably the following: the loss of TCP\n   options on a path\
    \ and the modification of payload data.  If such an\n   event occurs, it is necessary\
    \ to \"fall back\" to the previous, safe\n   operation.  This may be either falling\
    \ back to regular TCP or\n   removing a problematic subflow.\n   At the start\
    \ of an MPTCP connection (i.e., the first subflow), it is\n   important to ensure\
    \ that the path is fully MPTCP capable and the\n   necessary TCP options can reach\
    \ each host.  The handshake as\n   described in Section 3.1 SHOULD fall back to\
    \ regular TCP if either of\n   the SYN messages do not have the MPTCP options:\
    \ this is the same, and\n   desired, behavior in the case where a host is not\
    \ MPTCP capable, or\n   the path does not support the MPTCP options.  When attempting\
    \ to join\n   an existing MPTCP connection (Section 3.2), if a path is not MPTCP\n\
    \   capable and the TCP options do not get through on the SYNs, the\n   subflow\
    \ will be closed according to the MP_JOIN logic.\n   There is, however, another\
    \ corner case that should be addressed.\n   That is one of MPTCP options getting\
    \ through on the SYN, but not on\n   regular packets.  This can be resolved if\
    \ the subflow is the first\n   subflow, and thus all data in flight is contiguous,\
    \ using the\n   following rules.\n   A sender MUST include a DSS option with data\
    \ sequence mapping in\n   every segment until one of the sent segments has been\
    \ acknowledged\n   with a DSS option containing a Data ACK.  Upon reception of\
    \ the\n   acknowledgment, the sender has the confirmation that the DSS option\n\
    \   passes in both directions and may choose to send fewer DSS options\n   than\
    \ once per segment.\n   If, however, an ACK is received for data (not just for\
    \ the SYN)\n   without a DSS option containing a Data ACK, the sender determines\
    \ the\n   path is not MPTCP capable.  In the case of this occurring on an\n  \
    \ additional subflow (i.e., one started with MP_JOIN), the host MUST\n   close\
    \ the subflow with a RST.  In the case of the first subflow\n   (i.e., that started\
    \ with MP_CAPABLE), it MUST drop out of an MPTCP\n   mode back to regular TCP.\
    \  The sender will send one final data\n   sequence mapping, with the Data-Level\
    \ Length value of 0 indicating an\n   infinite mapping (in case the path drops\
    \ options in one direction\n   only), and then revert to sending data on the single\
    \ subflow without\n   any MPTCP options.\n   Note that this rule essentially prohibits\
    \ the sending of data on the\n   third packet of an MP_CAPABLE or MP_JOIN handshake,\
    \ since both that\n   option and a DSS cannot fit in TCP option space.  If the\
    \ initiator is\n   to send first, another segment must be sent that contains the\
    \ data\n   and DSS.  Note also that an additional subflow cannot be used until\n\
    \   the initial path has been verified as MPTCP capable.\n   These rules should\
    \ cover all cases where such a failure could happen:\n   whether it's on the forward\
    \ or reverse path and whether the server or\n   the client first sends data. \
    \ If lost options on data packets occur\n   on any other subflow apart from the\
    \ initial subflow, it should be\n   treated as a standard path failure.  The data\
    \ would not be DATA_ACKed\n   (since there is no mapping for the data), and the\
    \ subflow can be\n   closed with a RST.\n   The case described above is a specialized\
    \ case of fallback, for when\n   the lack of MPTCP support is detected before\
    \ any data is acknowledged\n   at the connection level on a subflow.  More generally,\
    \ fallback\n   (either closing a subflow, or to regular TCP) can become necessary\
    \ at\n   any point during a connection if a non-MPTCP-aware middlebox changes\n\
    \   the data stream.\n   As described in Section 3.3, each portion of data for\
    \ which there is\n   a mapping is protected by a checksum.  This mechanism is\
    \ used to\n   detect if middleboxes have made any adjustments to the payload\n\
    \   (added, removed, or changed data).  A checksum will fail if the data\n   has\
    \ been changed in any way.  This will also detect if the length of\n   data on\
    \ the subflow is increased or decreased, and this means the\n   data sequence\
    \ mapping is no longer valid.  The sender no longer knows\n   what subflow-level\
    \ sequence number the receiver is genuinely\n   operating at (the middlebox will\
    \ be faking ACKs in return), and it\n   cannot signal any further mappings.  Furthermore,\
    \ in addition to the\n   possibility of payload modifications that are valid at\
    \ the\n   application layer, there is the possibility that false positives\n \
    \  could be hit across MPTCP segment boundaries, corrupting the data.\n   Therefore,\
    \ all data from the start of the segment that failed the\n   checksum onwards\
    \ is not trustworthy.\n   When multiple subflows are in use, the data in flight\
    \ on a subflow\n   will likely involve data that is not contiguously part of the\n\
    \   connection-level stream, since segments will be spread across the\n   multiple\
    \ subflows.  Due to the problems identified above, it is not\n   possible to determine\
    \ what the adjustment has done to the data\n   (notably, any changes to the subflow\
    \ sequence numbering).  Therefore,\n   it is not possible to recover the subflow,\
    \ and the affected subflow\n   must be immediately closed with a RST, featuring\
    \ an MP_FAIL option\n   (Figure 15), which defines the data sequence number at\
    \ the start of\n   the segment (defined by the data sequence mapping) that had\
    \ the\n   checksum failure.  Note that the MP_FAIL option requires the use of\n\
    \   the full 64-bit sequence number, even if 32-bit sequence numbers are\n   normally\
    \ in use in the DSS signals on the path.\n                           1       \
    \            2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+-------+----------------------+\n\
    \      |     Kind      |   Length=12   |Subtype|      (reserved)      |\n    \
    \  +---------------+---------------+-------+----------------------+\n      | \
    \                                                             |\n      |     \
    \            Data Sequence Number (8 octets)              |\n      |         \
    \                                                     |\n      +--------------------------------------------------------------+\n\
    \                   Figure 15: Fallback (MP_FAIL) Option\n   The receiver MUST\
    \ discard all data following the data sequence number\n   specified.  Failed data\
    \ MUST NOT be DATA_ACKed and so will be\n   retransmitted on other subflows (Section\
    \ 3.3.6).\n   A special case is when there is a single subflow and it fails with\
    \ a\n   checksum error.  If it is known that all unacknowledged data in\n   flight\
    \ is contiguous (which will usually be the case with a single\n   subflow), an\
    \ infinite mapping can be applied to the subflow without\n   the need to close\
    \ it first, and essentially turn off all further\n   MPTCP signaling.  In this\
    \ case, if a receiver identifies a checksum\n   failure when there is only one\
    \ path, it will send back an MP_FAIL\n   option on the subflow-level ACK, referring\
    \ to the data-level sequence\n   number of the start of the segment on which the\
    \ checksum error was\n   detected.  The sender will receive this, and if all unacknowledged\n\
    \   data in flight is contiguous, will signal an infinite mapping.  This\n   infinite\
    \ mapping will be a DSS option (Section 3.3) on the first new\n   packet, containing\
    \ a data sequence mapping that acts retroactively,\n   referring to the start\
    \ of the subflow sequence number of the last\n   segment that was known to be\
    \ delivered intact.  From that point\n   onwards, data can be altered by a middlebox\
    \ without affecting MPTCP,\n   as the data stream is equivalent to a regular,\
    \ legacy TCP session.\n   In the rare case that the data is not contiguous (which\
    \ could happen\n   when there is only one subflow but it is retransmitting data\
    \ from a\n   subflow that has recently been uncleanly closed), the receiver MUST\n\
    \   close the subflow with a RST with MP_FAIL.  The receiver MUST discard\n  \
    \ all data that follows the data sequence number specified.  The sender\n   MAY\
    \ attempt to create a new subflow belonging to the same connection,\n   and, if\
    \ it chooses to do so, SHOULD place the single subflow\n   immediately in single-path\
    \ mode by setting an infinite data sequence\n   mapping.  This mapping will begin\
    \ from the data-level sequence number\n   that was declared in the MP_FAIL.\n\
    \   After a sender signals an infinite mapping, it MUST only use subflow\n   ACKs\
    \ to clear its send buffer.  This is because Data ACKs may become\n   misaligned\
    \ with the subflow ACKs when middleboxes insert or delete\n   data.  The receive\
    \ SHOULD stop generating Data ACKs after it receives\n   an infinite mapping.\n\
    \   When a connection has fallen back, only one subflow can send data;\n   otherwise,\
    \ the receiver would not know how to reorder the data.  In\n   practice, this\
    \ means that all MPTCP subflows will have to be\n   terminated except one.  Once\
    \ MPTCP falls back to regular TCP, it MUST\n   NOT revert to MPTCP later in the\
    \ connection.\n   It should be emphasized that we are not attempting to prevent\
    \ the use\n   of middleboxes that want to adjust the payload.  An MPTCP-aware\n\
    \   middlebox could provide such functionality by also rewriting\n   checksums.\n"
- title: 3.7.  Error Handling
  contents:
  - "3.7.  Error Handling\n   In addition to the fallback mechanism as described above,\
    \ the\n   standard classes of TCP errors may need to be handled in an MPTCP-\n\
    \   specific way.  Note that changing semantics -- such as the relevance\n   of\
    \ a RST -- are covered in Section 4.  Where possible, we do not want\n   to deviate\
    \ from regular TCP behavior.\n   The following list covers possible errors and\
    \ the appropriate MPTCP\n   behavior:\n   o  Unknown token in MP_JOIN (or HMAC\
    \ failure in MP_JOIN ACK, or\n      missing MP_JOIN in SYN/ACK response): send\
    \ RST (analogous to TCP's\n      behavior on an unknown port)\n   o  DSN out of\
    \ window (during normal operation): drop the data, do not\n      send Data ACKs\n\
    \   o  Remove request for unknown address ID: silently ignore\n"
- title: 3.8.  Heuristics
  contents:
  - "3.8.  Heuristics\n   There are a number of heuristics that are needed for performance\
    \ or\n   deployment but that are not required for protocol correctness.  In\n\
    \   this section, we detail such heuristics.  Note that discussion of\n   buffering\
    \ and certain sender and receiver window behaviors are\n   presented in Sections\
    \ 3.3.4 and 3.3.5, as well as retransmission in\n   Section 3.3.6.\n"
- title: 3.8.1.  Port Usage
  contents:
  - "3.8.1.  Port Usage\n   Under typical operation, an MPTCP implementation SHOULD\
    \ use the same\n   ports as already in use.  In other words, the destination port\
    \ of a\n   SYN containing an MP_JOIN option SHOULD be the same as the remote\n\
    \   port of the first subflow in the connection.  The local port for such\n  \
    \ SYNs SHOULD also be the same as for the first subflow (and as such,\n   an implementation\
    \ SHOULD reserve ephemeral ports across all local IP\n   addresses), although\
    \ there may be cases where this is infeasible.\n   This strategy is intended to\
    \ maximize the probability of the SYN\n   being permitted by a firewall or NAT\
    \ at the recipient and to avoid\n   confusing any network monitoring software.\n\
    \   There may also be cases, however, where the passive opener wishes to\n   signal\
    \ to the other host that a specific port should be used, and\n   this facility\
    \ is provided in the Add Address option as documented in\n   Section 3.4.1.  It\
    \ is therefore feasible to allow multiple subflows\n   between the same two addresses\
    \ but using different port pairs, and\n   such a facility could be used to allow\
    \ load balancing within the\n   network based on 5-tuples (e.g., some ECMP implementations\
    \ [7]).\n"
- title: 3.8.2.  Delayed Subflow Start
  contents:
  - "3.8.2.  Delayed Subflow Start\n   Many TCP connections are short-lived and consist\
    \ only of a few\n   segments, and so the overheads of using MPTCP outweigh any\
    \ benefits.\n   A heuristic is required, therefore, to decide when to start using\n\
    \   additional subflows in an MPTCP connection.  We expect that\n   experience\
    \ gathered from deployments will provide further guidance on\n   this, and will\
    \ be affected by particular application characteristics\n   (which are likely\
    \ to change over time).  However, a suggested\n   general-purpose heuristic that\
    \ an implementation MAY choose to employ\n   is as follows.  Results from experimental\
    \ deployments are needed in\n   order to verify the correctness of this proposal.\n\
    \   If a host has data buffered for its peer (which implies that the\n   application\
    \ has received a request for data), the host opens one\n   subflow for each initial\
    \ window's worth of data that is buffered.\n   Consideration should also be given\
    \ to limiting the rate of adding new\n   subflows, as well as limiting the total\
    \ number of subflows open for a\n   particular connection.  A host may choose\
    \ to vary these values based\n   on its load or knowledge of traffic and path\
    \ characteristics.\n   Note that this heuristic alone is probably insufficient.\
    \  Traffic for\n   many common applications, such as downloads, is highly asymmetric\
    \ and\n   the host that is multihomed may well be the client that will never\n\
    \   fill its buffers, and thus never use MPTCP.  Advanced APIs that allow\n  \
    \ an application to signal its traffic requirements would aid in these\n   decisions.\n\
    \   An additional time-based heuristic could be applied, opening\n   additional\
    \ subflows after a given period of time has passed.  This\n   would alleviate\
    \ the above issue, and also provide resilience for low-\n   bandwidth but long-lived\
    \ applications.\n   This section has shown some of the considerations that an\
    \ implementer\n   should give when developing MPTCP heuristics, but is not intended\
    \ to\n   be prescriptive.\n"
- title: 3.8.3.  Failure Handling
  contents:
  - "3.8.3.  Failure Handling\n   Requirements for MPTCP's handling of unexpected\
    \ signals have been\n   given in Section 3.7.  There are other failure cases,\
    \ however, where\n   a hosts can choose appropriate behavior.\n   For example,\
    \ Section 3.1 suggests that a host SHOULD fall back to\n   trying regular TCP\
    \ SYNs after one or more failures of MPTCP SYNs for\n   a connection.  A host\
    \ may keep a system-wide cache of such\n   information, so that it can back off\
    \ from using MPTCP, firstly for\n   that particular destination host, and eventually\
    \ on a whole\n   interface, if MPTCP connections continue failing.\n   Another\
    \ failure could occur when the MP_JOIN handshake fails.\n   Section 3.7 specifies\
    \ that an incorrect handshake MUST lead to the\n   subflow being closed with a\
    \ RST.  A host operating an active\n   intrusion detection system may choose to\
    \ start blocking MP_JOIN\n   packets from the source host if multiple failed MP_JOIN\
    \ attempts are\n   seen.  From the connection initiator's point of view, if an\
    \ MP_JOIN\n   fails, it SHOULD NOT attempt to connect to the same IP address and\n\
    \   port during the lifetime of the connection, unless the other host\n   refreshes\
    \ the information with another ADD_ADDR option.  Note that\n   the ADD_ADDR option\
    \ is informational only, and does not guarantee the\n   other host will attempt\
    \ a connection.\n   In addition, an implementation may learn, over a number of\n\
    \   connections, that certain interfaces or destination addresses\n   consistently\
    \ fail and may default to not trying to use MPTCP for\n   these.  Behavior could\
    \ also be learned for particularly badly\n   performing subflows or subflows that\
    \ regularly fail during use, in\n   order to temporarily choose not to use these\
    \ paths.\n"
- title: 4.  Semantic Issues
  contents:
  - "4.  Semantic Issues\n   In order to support multipath operation, the semantics\
    \ of some TCP\n   components have changed.  To aid clarity, this section collects\
    \ these\n   semantic changes as a reference.\n   Sequence number:  The (in-header)\
    \ TCP sequence number is specific to\n      the subflow.  To allow the receiver\
    \ to reorder application data,\n      an additional data-level sequence space\
    \ is used.  In this data-\n      level sequence space, the initial SYN and the\
    \ final DATA_FIN\n      occupy 1 octet of sequence space.  There is an explicit\
    \ mapping of\n      data sequence space to subflow sequence space, which is signaled\n\
    \      through TCP options in data packets.\n   ACK:  The ACK field in the TCP\
    \ header acknowledges only the subflow\n      sequence number, not the data-level\
    \ sequence space.\n      Implementations SHOULD NOT attempt to infer a data-level\n\
    \      acknowledgment from the subflow ACKs.  This separates subflow- and\n  \
    \    connection-level processing at an end host.\n   Duplicate ACK:  A duplicate\
    \ ACK that includes any MPTCP signaling\n      (with the exception of the DSS\
    \ option) MUST NOT be treated as a\n      signal of congestion.  To limit the\
    \ chances of non-MPTCP-aware\n      entities mistakenly interpreting duplicate\
    \ ACKs as a signal of\n      congestion, MPTCP SHOULD NOT send more than two duplicate\
    \ ACKs\n      containing (non-DSS) MPTCP signals in a row.\n   Receive Window:\
    \  The receive window in the TCP header indicates the\n      amount of free buffer\
    \ space for the whole data-level connection\n      (as opposed to for this subflow)\
    \ that is available at the\n      receiver.  This is the same semantics as regular\
    \ TCP, but to\n      maintain these semantics the receive window must be interpreted\
    \ at\n      the sender as relative to the sequence number given in the\n     \
    \ DATA_ACK rather than the subflow ACK in the TCP header.  In this\n      way,\
    \ the original flow control role is preserved.  Note that some\n      middleboxes\
    \ may change the receive window, and so a host SHOULD\n      use the maximum value\
    \ of those recently seen on the constituent\n      subflows for the connection-level\
    \ receive window, and also needs\n      to maintain a subflow-level window for\
    \ subflow-level processing.\n   FIN:  The FIN flag in the TCP header applies only\
    \ to the subflow it\n      is sent on, not to the whole connection.  For connection-level\
    \ FIN\n      semantics, the DATA_FIN option is used.\n   RST:  The RST flag in\
    \ the TCP header applies only to the subflow it\n      is sent on, not to the\
    \ whole connection.  The MP_FASTCLOSE option\n      provides the fast close functionality\
    \ of a RST at the MPTCP\n      connection level.\n   Address List:  Address list\
    \ management (i.e., knowledge of the local\n      and remote hosts' lists of available\
    \ IP addresses) is handled on a\n      per-connection basis (as opposed to per\
    \ subflow, per host, or per\n      pair of communicating hosts).  This permits\
    \ the application of\n      per-connection local policy.  Adding an address to\
    \ one connection\n      (either explicitly through an Add Address message, or\
    \ implicitly\n      through a Join) has no implication for other connections between\n\
    \      the same pair of hosts.\n   5-tuple:  The 5-tuple (protocol, local address,\
    \ local port, remote\n      address, remote port) presented by kernel APIs to\
    \ the application\n      layer in a non-multipath-aware application is that of\
    \ the first\n      subflow, even if the subflow has since been closed and removed\n\
    \      from the connection.  This decision, and other related API issues,\n  \
    \    are discussed in more detail in [6].\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   As identified in [9], the addition of multipath\
    \ capability to TCP\n   will bring with it a number of new classes of threat.\
    \  In order to\n   prevent these, [2] presents a set of requirements for a security\n\
    \   solution for MPTCP.  The fundamental goal is for the security of\n   MPTCP\
    \ to be \"no worse\" than regular TCP today, and the key security\n   requirements\
    \ are:\n   o  Provide a mechanism to confirm that the parties in a subflow\n \
    \     handshake are the same as in the original connection setup.\n   o  Provide\
    \ verification that the peer can receive traffic at a new\n      address before\
    \ using it as part of a connection.\n   o  Provide replay protection, i.e., ensure\
    \ that a request to add/\n      remove a subflow is 'fresh'.\n   In order to achieve\
    \ these goals, MPTCP includes a hash-based\n   handshake algorithm documented\
    \ in Sections 3.1 and 3.2.\n   The security of the MPTCP connection hangs on the\
    \ use of keys that\n   are shared once at the start of the first subflow, and\
    \ are never sent\n   again over the network (unless used in the fast close mechanism,\n\
    \   Section 3.5).  To ease demultiplexing while not giving away any\n   cryptographic\
    \ material, future subflows use a truncated cryptographic\n   hash of this key\
    \ as the connection identification \"token\".  The keys\n   are concatenated and\
    \ used as keys for creating Hash-based Message\n   Authentication Codes (HMACs)\
    \ used on subflow setup, in order to\n   verify that the parties in the handshake\
    \ are the same as in the\n   original connection setup.  It also provides verification\
    \ that the\n   peer can receive traffic at this new address.  Replay attacks would\n\
    \   still be possible when only keys are used; therefore, the handshakes\n   use\
    \ single-use random numbers (nonces) at both ends -- this ensures\n   the HMAC\
    \ will never be the same on two handshakes.  Guidance on\n   generating random\
    \ numbers suitable for use as keys is given in [14]\n   and discussed in Section\
    \ 3.1.\n   The use of crypto capability bits in the initial connection handshake\n\
    \   to negotiate use of a particular algorithm allows the deployment of\n   additional\
    \ crypto mechanisms in the future.  Note that this would be\n   susceptible to\
    \ bid-down attacks only if the attacker was on-path (and\n   thus would be able\
    \ to modify the data anyway).  The security\n   mechanism presented in this document\
    \ should therefore protect against\n   all forms of flooding and hijacking attacks\
    \ discussed in [9].\n   During normal operation, regular TCP protection mechanisms\
    \ (such as\n   ensuring sequence numbers are in-window) will provide the same\
    \ level\n   of protection against attacks on individual TCP subflows as exists\n\
    \   for regular TCP today.  Implementations will introduce additional\n   buffers\
    \ compared to regular TCP, to reassemble data at the connection\n   level.  The\
    \ application of window sizing will minimize the risk of\n   denial-of-service\
    \ attacks consuming resources.\n   As discussed in Section 3.4.1, a host may advertise\
    \ its private\n   addresses, but these might point to different hosts in the receiver's\n\
    \   network.  The MP_JOIN handshake (Section 3.2) will ensure that this\n   does\
    \ not succeed in setting up a subflow to the incorrect host.\n   However, it could\
    \ still create unwanted TCP handshake traffic.  This\n   feature of MPTCP could\
    \ be a target for denial-of-service exploits,\n   with malicious participants\
    \ in MPTCP connections encouraging the\n   recipient to target other hosts in\
    \ the network.  Therefore,\n   implementations should consider heuristics (Section\
    \ 3.8) at both the\n   sender and receiver to reduce the impact of this.\n   A\
    \ small security risk could theoretically exist with key reuse, but\n   in order\
    \ to accomplish a replay attack, both the sender and receiver\n   keys, and the\
    \ sender and receiver random numbers, in the MP_JOIN\n   handshake (Section 3.2)\
    \ would have to match.\n   Whilst this specification defines a \"medium\" security\
    \ solution,\n   meeting the criteria specified at the start of this section and\
    \ the\n   threat analysis ([9]), since attacks only ever get worse, it is\n  \
    \ likely that a future Standards Track version of MPTCP would need to\n   be able\
    \ to support stronger security.  There are several ways the\n   security of MPTCP\
    \ could potentially be improved; some of these would\n   be compatible with MPTCP\
    \ as defined in this document, whilst others\n   may not be.  For now, the best\
    \ approach is to get experience with the\n   current approach, establish what\
    \ might work, and check that the\n   threat analysis is still accurate.\n   Possible\
    \ ways of improving MPTCP security could include:\n   o  defining a new MPCTP\
    \ cryptographic algorithm, as negotiated in\n      MP_CAPABLE.  A sub-case could\
    \ be to include an additional\n      deployment assumption, such as stateful servers,\
    \ in order to allow\n      a more powerful algorithm to be used.\n   o  defining\
    \ how to secure data transfer with MPTCP, whilst not\n      changing the signaling\
    \ part of the protocol.\n   o  defining security that requires more option space,\
    \ perhaps in\n      conjunction with a \"long options\" proposal for extending\
    \ the TCP\n      options space (such as those surveyed in [20]), or perhaps\n\
    \      building on the current approach with a second stage of MPTCP-\n      option-based\
    \ security.\n   o  revisiting the working group's decision to exclusively use\
    \ TCP\n      options for MPTCP signaling, and instead look at also making use\n\
    \      of the TCP payloads.\n   MPTCP has been designed with several methods available\
    \ to indicate a\n   new security mechanism, including:\n   o  available flags\
    \ in MP_CAPABLE (Figure 4);\n   o  available subtypes in the MPTCP option (Figure\
    \ 3);\n   o  the version field in MP_CAPABLE (Figure 4);\n"
- title: 6.  Interactions with Middleboxes
  contents:
  - "6.  Interactions with Middleboxes\n   Multipath TCP was designed to be deployable\
    \ in the present world.\n   Its design takes into account \"reasonable\" existing\
    \ middlebox\n   behavior.  In this section, we outline a few representative\n\
    \   middlebox-related failure scenarios and show how Multipath TCP\n   handles\
    \ them.  Next, we list the design decisions multipath has made\n   to accommodate\
    \ the different middleboxes.\n   A primary concern is our use of a new TCP option.\
    \  Middleboxes should\n   forward packets with unknown options unchanged, yet\
    \ there are some\n   that don't.  These we expect will either strip options and\
    \ pass the\n   data, drop packets with new options, copy the same option into\n\
    \   multiple segments (e.g., when doing segmentation), or drop options\n   during\
    \ segment coalescing.\n   MPTCP uses a single new TCP option \"Kind\", and all\
    \ message types are\n   defined by \"subtype\" values (see Section 8).  This should\
    \ reduce the\n   chances of only some types of MPTCP options being passed, and\
    \ instead\n   the key differing characteristics are different paths, and the\n\
    \   presence of the SYN flag.\n   MPTCP SYN packets on the first subflow of a\
    \ connection contain the\n   MP_CAPABLE option (Section 3.1).  If this is dropped,\
    \ MPTCP SHOULD\n   fall back to regular TCP.  If packets with the MP_JOIN option\n\
    \   (Section 3.2) are dropped, the paths will simply not be used.\n   If a middlebox\
    \ strips options but otherwise passes the packets\n   unchanged, MPTCP will behave\
    \ safely.  If an MP_CAPABLE option is\n   dropped on either the outgoing or the\
    \ return path, the initiating\n   host can fall back to regular TCP, as illustrated\
    \ in Figure 16 and\n   discussed in Section 3.1.\n   Subflow SYNs contain the\
    \ MP_JOIN option.  If this option is stripped\n   on the outgoing path, the SYN\
    \ will appear to be a regular SYN to Host\n   B.  Depending on whether there is\
    \ a listening socket on the target\n   port, Host B will reply either with SYN/ACK\
    \ or RST (subflow\n   connection fails).  When Host A receives the SYN/ACK it\
    \ sends a RST\n   because the SYN/ACK does not contain the MP_JOIN option and\
    \ its\n   token.  Either way, the subflow setup fails, but otherwise does not\n\
    \   affect the MPTCP connection as a whole.\n        Host A                  \
    \           Host B\n         |              Middlebox M            |\n       \
    \  |                   |                 |\n         |  SYN(MP_CAPABLE)  |   \
    \     SYN      |\n         |-------------------|---------------->|\n         |\
    \                SYN/ACK              |\n         |<------------------------------------|\n\
    \     a) MP_CAPABLE option stripped on outgoing path\n       Host A          \
    \                     Host B\n         |            SYN(MP_CAPABLE)          |\n\
    \         |------------------------------------>|\n         |             Middlebox\
    \ M             |\n         |                 |                   |\n        \
    \ |    SYN/ACK      |SYN/ACK(MP_CAPABLE)|\n         |<----------------|-------------------|\n\
    \     b) MP_CAPABLE option stripped on return path\n   Figure 16: Connection Setup\
    \ with Middleboxes that\n              Strip Options from Packets\n   We now examine\
    \ data flow with MPTCP, assuming the flow is correctly\n   set up, which implies\
    \ the options in the SYN packets were allowed\n   through by the relevant middleboxes.\
    \  If options are allowed through\n   and there is no resegmentation or coalescing\
    \ to TCP segments,\n   Multipath TCP flows can proceed without problems.\n   The\
    \ case when options get stripped on data packets has been discussed\n   in the\
    \ Fallback section.  If a fraction of options are stripped,\n   behavior is not\
    \ deterministic.  If some data sequence mappings are\n   lost, the connection\
    \ can continue so long as mappings exist for the\n   subflow-level data (e.g.,\
    \ if multiple maps have been sent that\n   reinforce each other).  If some subflow-level\
    \ space is left unmapped,\n   however, the subflow is treated as broken and is\
    \ closed, through the\n   process described in Section 3.6.  MPTCP should survive\
    \ with a loss\n   of some Data ACKs, but performance will degrade as the fraction\
    \ of\n   stripped options increases.  We do not expect such cases to appear in\n\
    \   practice, though: most middleboxes will either strip all options or\n   let\
    \ them all through.\n   We end this section with a list of middlebox classes,\
    \ their behavior,\n   and the elements in the MPTCP design that allow operation\
    \ through\n   such middleboxes.  Issues surrounding dropping packets with options\n\
    \   or stripping options were discussed above, and are not included here:\n  \
    \ o  NATs [21] (Network Address (and Port) Translators) change the\n      source\
    \ address (and often source port) of packets.  This means\n      that a host will\
    \ not know its public-facing address for signaling\n      in MPTCP.  Therefore,\
    \ MPTCP permits implicit address addition via\n      the MP_JOIN option, and the\
    \ handshake mechanism ensures that\n      connection attempts to private addresses\
    \ [18] do not cause\n      problems.  Explicit address removal is undertaken by\
    \ an Address ID\n      to allow no knowledge of the source address.\n   o  Performance\
    \ Enhancing Proxies (PEPs) [22] might proactively ACK\n      data to increase\
    \ performance.  MPTCP, however, relies on accurate\n      congestion control signals\
    \ from the end host, and non-MPTCP-aware\n      PEPs will not be able to provide\
    \ such signals.  MPTCP will,\n      therefore, fall back to single-path TCP, or\
    \ close the problematic\n      subflow (see Section 3.6).\n   o  Traffic Normalizers\
    \ [23] may not allow holes in sequence numbers,\n      and may cache packets and\
    \ retransmit the same data.  MPTCP looks\n      like standard TCP on the wire,\
    \ and will not retransmit different\n      data on the same subflow sequence number.\
    \  In the event of a\n      retransmission, the same data will be retransmitted\
    \ on the\n      original TCP subflow even if it is additionally retransmitted\
    \ at\n      the connection level on a different subflow.\n   o  Firewalls [24]\
    \ might perform initial sequence number randomization\n      on TCP connections.\
    \  MPTCP uses relative sequence numbers in data\n      sequence mapping to cope\
    \ with this.  Like NATs, firewalls will not\n      permit many incoming connections,\
    \ so MPTCP supports address\n      signaling (ADD_ADDR) so that a multiaddressed\
    \ host can invite its\n      peer behind the firewall/NAT to connect out to its\
    \ additional\n      interface.\n   o  Intrusion Detection Systems look out for\
    \ traffic patterns and\n      content that could threaten a network.  Multipath\
    \ will mean that\n      such data is potentially spread, so it is more difficult\
    \ for an\n      IDS to analyze the whole traffic, and potentially increases the\n\
    \      risk of false positives.  However, for an MPTCP-aware IDS, tokens\n   \
    \   can be read by such systems to correlate multiple subflows and\n      reassemble\
    \ for analysis.\n   o  Application-level middleboxes such as content-aware firewalls\
    \ may\n      alter the payload within a subflow, such as rewriting URIs in HTTP\n\
    \      traffic.  MPTCP will detect these using the checksum and close the\n  \
    \    affected subflow(s), if there are other subflows that can be used.\n    \
    \  If all subflows are affected, multipath will fall back to TCP,\n      allowing\
    \ such middleboxes to change the payload.  MPTCP-aware\n      middleboxes should\
    \ be able to adjust the payload and MPTCP\n      metadata in order not to break\
    \ the connection.\n   In addition, all classes of middleboxes may affect TCP traffic\
    \ in the\n   following ways:\n   o  TCP options may be removed, or packets with\
    \ unknown options\n      dropped, by many classes of middleboxes.  It is intended\
    \ that the\n      initial SYN exchange, with a TCP option, will be sufficient\
    \ to\n      identify the path capabilities.  If such a packet does not get\n \
    \     through, MPTCP will end up falling back to regular TCP.\n   o  Segmentation/Coalescing\
    \ (e.g., TCP segmentation offloading) might\n      copy options between packets\
    \ and might strip some options.\n      MPTCP's data sequence mapping includes\
    \ the relative subflow\n      sequence number instead of using the sequence number\
    \ in the\n      segment.  In this way, the mapping is independent of the packets\n\
    \      that carry it.\n   o  The receive window may be shrunk by some middleboxes\
    \ at the\n      subflow level.  MPTCP will use the maximum window at data level,\n\
    \      but will also obey subflow-specific windows.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   The authors were originally supported by Trilogy\n  \
    \ (http://www.trilogy-project.org), a research project (ICT-216372)\n   partially\
    \ funded by the European Community under its Seventh\n   Framework Program.\n\
    \   Alan Ford was originally supported by Roke Manor Research.\n   The authors\
    \ gratefully acknowledge significant input into this\n   document from Sebastien\
    \ Barre, Christoph Paasch, and Andrew McDonald.\n   The authors also wish to acknowledge\
    \ reviews and contributions from\n   Iljitsch van Beijnum, Lars Eggert, Marcelo\
    \ Bagnulo, Robert Hancock,\n   Pasi Sarolahti, Toby Moncaster, Philip Eardley,\
    \ Sergio Lembo,\n   Lawrence Conroy, Yoshifumi Nishida, Bob Briscoe, Stein Gjessing,\n\
    \   Andrew McGregor, Georg Hampel, Anumita Biswas, Wes Eddy, Alexey\n   Melnikov,\
    \ Francis Dupont, Adrian Farrel, Barry Leiba, Robert Sparks,\n   Sean Turner,\
    \ Stephen Farrell, and Martin Stiemerling.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document defines a new TCP option for MPTCP,\
    \ assigned a value of\n   30 (decimal) from the TCP option space.  This value\
    \ is the value of\n   \"Kind\" as seen in all MPTCP options in this document.\
    \  This value is\n   defined as:\n           +------+--------+-----------------------+-----------+\n\
    \           | Kind | Length |        Meaning        | Reference |\n          \
    \ +------+--------+-----------------------+-----------+\n           |  30  | \
    \   N   | Multipath TCP (MPTCP) |  RFC 6824 |\n           +------+--------+-----------------------+-----------+\n\
    \                     Table 1: TCP Option Kind Numbers\n   This document also\
    \ defines a 4-bit subtype field, for which IANA has\n   created and will maintain\
    \ a new sub-registry entitled \"MPTCP Option\n   Subtypes\" under the \"Transmission\
    \ Control Protocol (TCP) Parameters\"\n   registry.  Initial values for the MPTCP\
    \ option subtype registry are\n   given below; future assignments are to be defined\
    \ by Standards Action\n   as defined by [25].  Assignments consist of the MPTCP\
    \ subtype's\n   symbolic name and its associated value, as per the following table.\n\
    \   +-------+--------------+----------------------------+---------------+\n  \
    \ | Value |    Symbol    |            Name            |   Reference   |\n   +-------+--------------+----------------------------+---------------+\n\
    \   |  0x0  |  MP_CAPABLE  |      Multipath Capable     |  Section 3.1  |\n  \
    \ |  0x1  |    MP_JOIN   |       Join Connection      |  Section 3.2  |\n   |\
    \  0x2  |      DSS     | Data Sequence Signal (Data |  Section 3.3  |\n   |  \
    \     |              |    ACK and data sequence   |               |\n   |    \
    \   |              |          mapping)          |               |\n   |  0x3 \
    \ |   ADD_ADDR   |         Add Address        | Section 3.4.1 |\n   |  0x4  |\
    \  REMOVE_ADDR |       Remove Address       | Section 3.4.2 |\n   |  0x5  |  \
    \  MP_PRIO   |   Change Subflow Priority  | Section 3.3.8 |\n   |  0x6  |    MP_FAIL\
    \   |          Fallback          |  Section 3.6  |\n   |  0x7  | MP_FASTCLOSE\
    \ |         Fast Close         |  Section 3.5  |\n   +-------+--------------+----------------------------+---------------+\n\
    \                      Table 2: MPTCP Option Subtypes\n   Values 0x8 through 0xe\
    \ are currently unassigned.  The value 0xf is\n   reserved for Private Use within\
    \ controlled testbeds.\n   IANA has created another sub-registry, \"MPTCP Handshake\
    \ Algorithms\"\n   under the \"Transmission Control Protocol (TCP) Parameters\"\
    \ registry,\n   based on the flags in MP_CAPABLE (Section 3.1).  The flags consist\
    \ of\n   8 bits, labeled \"A\" through \"H\", and this document assigns the bits\n\
    \   as follows:\n         +----------+-------------------+-----------------------+\n\
    \         | Flag Bit |      Meaning      |       Reference       |\n         +----------+-------------------+-----------------------+\n\
    \         |     A    | Checksum required | RFC 6824, Section 3.1 |\n         |\
    \     B    |   Extensibility   | RFC 6824, Section 3.1 |\n         |    C-G  \
    \ |     Unassigned    |                       |\n         |     H    |     HMAC-SHA1\
    \     | RFC 6824, Section 3.2 |\n         +----------+-------------------+-----------------------+\n\
    \                    Table 3: MPTCP Handshake Algorithms\n   Note that the meanings\
    \ of bits C through H can be dependent upon bit\n   B, depending on how Extensibility\
    \ is defined in future\n   specifications; see Section 3.1 for more information.\n\
    \   Future assignments in this registry are also to be defined by\n   Standards\
    \ Action as defined by [25].  Assignments consist of the\n   value of the flags,\
    \ a symbolic name for the algorithm, and a\n   reference to its specification.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [1]   Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC 793,\n         September 1981.\n   [2]   Ford, A., Raiciu, C., Handley,\
    \ M., Barre, S., and J. Iyengar,\n         \"Architectural Guidelines for Multipath\
    \ TCP Development\",\n         RFC 6182, March 2011.\n   [3]   Bradner, S., \"\
    Key words for use in RFCs to Indicate Requirement\n         Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n   [4]   National Institute of Science and Technology,\
    \ \"Secure Hash\n         Standard\", Federal Information Processing Standard\n\
    \         (FIPS) 180-3, October 2008, <http://csrc.nist.gov/publications/\n  \
    \       fips/fips180-3/fips180-3_final.pdf>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [5]   Raiciu, C., Handley, M., and D. Wischik,\
    \ \"Coupled Congestion\n         Control for Multipath Transport Protocols\",\
    \ RFC 6356,\n         October 2011.\n   [6]   Scharf, M. and A. Ford, \"MPTCP\
    \ Application Interface\n         Considerations\", Work in Progress, October\
    \ 2012.\n   [7]   Hopps, C., \"Analysis of an Equal-Cost Multi-Path Algorithm\"\
    ,\n         RFC 2992, November 2000.\n   [8]   Raiciu, C., Paasch, C., Barre,\
    \ S., Ford, A., Honda, M.,\n         Duchene, F., Bonaventure, O., and M. Handley,\
    \ \"How Hard Can It\n         Be? Designing and Implementing a Deployable Multipath\
    \ TCP\",\n         Usenix Symposium on Networked Systems Design and\n        \
    \ Implementation 012, 2012, <https://www.usenix.org/conference/\n         nsdi12/how-hard-can-it-be-designing-and-implementing-\n\
    \         deployable-multipath-tcp>.\n   [9]   Bagnulo, M., \"Threat Analysis\
    \ for TCP Extensions for Multipath\n         Operation with Multiple Addresses\"\
    , RFC 6181, March 2011.\n   [10]  Krawczyk, H., Bellare, M., and R. Canetti, \"\
    HMAC: Keyed-Hashing\n         for Message Authentication\", RFC 2104, February\
    \ 1997.\n   [11]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP\n\
    \         Selective Acknowledgment Options\", RFC 2018, October 1996.\n   [12]\
    \  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n         Control\"\
    , RFC 5681, September 2009.\n   [13]  Gont, F., \"Survey of Security Hardening\
    \ Methods for\n         Transmission Control Protocol (TCP) Implementations\"\
    , Work\n         in Progress, March 2012.\n   [14]  Eastlake, D., Schiller, J.,\
    \ and S. Crocker, \"Randomness\n         Requirements for Security\", BCP 106,\
    \ RFC 4086, June 2005.\n   [15]  Eastlake, D. and T. Hansen, \"US Secure Hash\
    \ Algorithms (SHA and\n         SHA-based HMAC and HKDF)\", RFC 6234, May 2011.\n\
    \   [16]  Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions for\n    \
    \     High Performance\", RFC 1323, May 1992.\n   [17]  Ramakrishnan, K., Floyd,\
    \ S., and D. Black, \"The Addition of\n         Explicit Congestion Notification\
    \ (ECN) to IP\", RFC 3168,\n         September 2001.\n   [18]  Rekhter, Y., Moskowitz,\
    \ R., Karrenberg, D., Groot, G., and E.\n         Lear, \"Address Allocation for\
    \ Private Internets\", BCP 5,\n         RFC 1918, February 1996.\n   [19]  Braden,\
    \ R., \"Requirements for Internet Hosts - Communication\n         Layers\", STD\
    \ 3, RFC 1122, October 1989.\n   [20]  Ramaiah, A., \"TCP option space extension\"\
    , Work in Progress,\n         March 2012.\n   [21]  Srisuresh, P. and K. Egevang,\
    \ \"Traditional IP Network Address\n         Translator (Traditional NAT)\", RFC\
    \ 3022, January 2001.\n   [22]  Border, J., Kojo, M., Griner, J., Montenegro,\
    \ G., and Z.\n         Shelby, \"Performance Enhancing Proxies Intended to Mitigate\n\
    \         Link-Related Degradations\", RFC 3135, June 2001.\n   [23]  Handley,\
    \ M., Paxson, V., and C. Kreibich, \"Network Intrusion\n         Detection: Evasion,\
    \ Traffic Normalization, and End-to-End\n         Protocol Semantics\", Usenix\
    \ Security 2001, 2001,\n         <http://www.usenix.org/events/sec01/full_papers/\n\
    \         handley/handley.pdf>.\n   [24]  Freed, N., \"Behavior of and Requirements\
    \ for Internet\n         Firewalls\", RFC 2979, October 2000.\n   [25]  Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing an IANA\n         Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226, May 2008.\n"
- title: Appendix A.  Notes on Use of TCP Options
  contents:
  - "Appendix A.  Notes on Use of TCP Options\n   The TCP option space is limited\
    \ due to the length of the Data Offset\n   field in the TCP header (4 bits), which\
    \ defines the TCP header length\n   in 32-bit words.  With the standard TCP header\
    \ being 20 bytes, this\n   leaves a maximum of 40 bytes for options, and many\
    \ of these may\n   already be used by options such as timestamp and SACK.\n  \
    \ We have performed a brief study on the commonly used TCP options in\n   SYN,\
    \ data, and pure ACK packets, and found that there is enough room\n   to fit all\
    \ the options we propose using in this document.\n   SYN packets typically include\
    \ Maximum Segment Size (MSS) (4 bytes),\n   window scale (3 bytes), SACK permitted\
    \ (2 bytes), and timestamp (10\n   bytes) options.  Together these sum to 19 bytes.\
    \  Some operating\n   systems appear to pad each option up to a word boundary,\
    \ thus using\n   24 bytes (a brief survey suggests Windows XP and Mac OS X do\
    \ this,\n   whereas Linux does not).  Optimistically, therefore, we have 21 bytes\n\
    \   spare, or 16 if it has to be word-aligned.  In either case, however,\n   the\
    \ SYN versions of Multipath Capable (12 bytes) and Join (12 or 16\n   bytes) options\
    \ will fit in this remaining space.\n   TCP data packets typically carry timestamp\
    \ options in every packet,\n   taking 10 bytes (or 12 with padding).  That leaves\
    \ 30 bytes (or 28,\n   if word-aligned).  The Data Sequence Signal (DSS) option\
    \ varies in\n   length depending on whether the data sequence mapping and DATA_ACK\n\
    \   are included, and whether the sequence numbers in use are 4 or 8\n   octets.\
    \  The maximum size of the DSS option is 28 bytes, so even that\n   will fit in\
    \ the available space.  But unless a connection is both\n   bidirectional and\
    \ high-bandwidth, it is unlikely that all that option\n   space will be required\
    \ on each DSS option.\n   Within the DSS option, it is not necessary to include\
    \ the data\n   sequence mapping and DATA_ACK in each packet, and in many cases\
    \ it\n   may be possible to alternate their presence (so long as the mapping\n\
    \   covers the data being sent in the following packet).  It would also\n   be\
    \ possible to alternate between 4- and 8-byte sequence numbers in\n   each option.\n\
    \   On subflow and connection setup, an MPTCP option is also set on the\n   third\
    \ packet (an ACK).  These are 20 bytes (for Multipath Capable)\n   and 24 bytes\
    \ (for Join), both of which will fit in the available\n   option space.\n   Pure\
    \ ACKs in TCP typically contain only timestamps (10 bytes).  Here,\n   Multipath\
    \ TCP typically needs to encode only the DATA_ACK (maximum of\n   12 bytes). \
    \ Occasionally, ACKs will contain SACK information.\n   Depending on the number\
    \ of lost packets, SACK may utilize the entire\n   option space.  If a DATA_ACK\
    \ had to be included, then it is probably\n   necessary to reduce the number of\
    \ SACK blocks to accommodate the\n   DATA_ACK.  However, the presence of the DATA_ACK\
    \ is unlikely to be\n   necessary in a case where SACK is in use, since until\
    \ at least some\n   of the SACK blocks have been retransmitted, the cumulative\
    \ data-level\n   ACK will not be moving forward (or if it does, due to retransmissions\n\
    \   on another path, then that path can also be used to transmit the new\n   DATA_ACK).\n\
    \   The ADD_ADDR option can be between 8 and 22 bytes, depending on\n   whether\
    \ IPv4 or IPv6 is used, and whether or not the port number is\n   present.  It\
    \ is unlikely that such signaling would fit in a data\n   packet (although if\
    \ there is space, it is fine to include it).  It is\n   recommended to use duplicate\
    \ ACKs with no other payload or options in\n   order to transmit these rare signals.\
    \  Note this is the reason for\n   mandating that duplicate ACKs with MPTCP options\
    \ are not taken as a\n   signal of congestion.\n   Finally, there are issues with\
    \ reliable delivery of options.  As\n   options can also be sent on pure ACKs,\
    \ these are not reliably sent.\n   This is not an issue for DATA_ACK due to their\
    \ cumulative nature, but\n   may be an issue for ADD_ADDR/REMOVE_ADDR options.\
    \  Here, it is\n   recommended to send these options redundantly (whether on multiple\n\
    \   paths or on the same path on a number of ACKs -- but interspersed\n   with\
    \ data in order to avoid interpretation as congestion).  The cases\n   where options\
    \ are stripped by middleboxes are discussed in Section 6.\n"
- title: Appendix B.  Control Blocks
  contents:
  - "Appendix B.  Control Blocks\n   Conceptually, an MPTCP connection can be represented\
    \ as an MPTCP\n   control block that contains several variables that track the\
    \ progress\n   and the state of the MPTCP connection and a set of linked TCP control\n\
    \   blocks that correspond to the subflows that have been established.\n   RFC\
    \ 793 [1] specifies several state variables.  Whenever possible, we\n   reuse\
    \ the same terminology as RFC 793 to describe the state variables\n   that are\
    \ maintained by MPTCP.\n"
- title: B.1.  MPTCP Control Block
  contents:
  - "B.1.  MPTCP Control Block\n   The MPTCP control block contains the following\
    \ variable per\n   connection.\n"
- title: B.1.1.  Authentication and Metadata
  contents:
  - "B.1.1.  Authentication and Metadata\n   Local.Token (32 bits):  This is the token\
    \ chosen by the local host on\n      this MPTCP connection.  The token MUST be\
    \ unique among all\n      established MPTCP connections, generated from the local\
    \ key.\n   Local.Key (64 bits):  This is the key sent by the local host on this\n\
    \      MPTCP connection.\n   Remote.Token (32 bits):  This is the token chosen\
    \ by the remote host\n      on this MPTCP connection, generated from the remote\
    \ key.\n   Remote.Key (64 bits):  This is the key chosen by the remote host on\n\
    \      this MPTCP connection\n   MPTCP.Checksum (flag):  This flag is set to true\
    \ if at least one of\n      the hosts has set the C bit in the MP_CAPABLE options\
    \ exchanged\n      during connection establishment, and is set to false otherwise.\n\
    \      If this flag is set, the checksum must be computed in all DSS\n      options.\n"
- title: B.1.2.  Sending Side
  contents:
  - "B.1.2.  Sending Side\n   SND.UNA (64 bits):  This is the data sequence number\
    \ of the next byte\n      to be acknowledged, at the MPTCP connection level. \
    \ This variable\n      is updated upon reception of a DSS option containing a\
    \ DATA_ACK.\n   SND.NXT (64 bits):  This is the data sequence number of the next\
    \ byte\n      to be sent.  SND.NXT is used to determine the value of the DSN in\n\
    \      the DSS option.\n   SND.WND (32 bits with RFC 1323, 16 bits otherwise):\
    \  This is the\n      sending window.  MPTCP maintains the sending window at the\
    \ MPTCP\n      connection level and the same window is shared by all subflows.\n\
    \      All subflows use the MPTCP connection level SND.WND to compute the\n  \
    \    SEQ.WND value that is sent in each transmitted segment.\n"
- title: B.1.3.  Receiving Side
  contents:
  - "B.1.3.  Receiving Side\n   RCV.NXT (64 bits):  This is the data sequence number\
    \ of the next byte\n      that is expected on the MPTCP connection.  This state\
    \ variable is\n      modified upon reception of in-order data.  The value of RCV.NXT\
    \ is\n      used to specify the DATA_ACK that is sent in the DSS option on all\n\
    \      subflows.\n   RCV.WND (32 bits with RFC 1323, 16 bits otherwise):  This\
    \ is the\n      connection-level receive window, which is the maximum of the\n\
    \      RCV.WND on all the subflows.\n"
- title: B.2.  TCP Control Blocks
  contents:
  - "B.2.  TCP Control Blocks\n   The MPTCP control block also contains a list of\
    \ the TCP control\n   blocks that are associated to the MPTCP connection.\n  \
    \ Note that the TCP control block on the TCP subflows does not contain\n   the\
    \ RCV.WND and SND.WND state variables as these are maintained at\n   the MPTCP\
    \ connection level and not at the subflow level.\n   Inside each TCP control block,\
    \ the following state variables are\n   defined.\n"
- title: B.2.1.  Sending Side
  contents:
  - "B.2.1.  Sending Side\n   SND.UNA (32 bits):  This is the sequence number of the\
    \ next byte to\n      be acknowledged on the subflow.  This variable is updated\
    \ upon\n      reception of each TCP acknowledgment on the subflow.\n   SND.NXT\
    \ (32 bits):  This is the sequence number of the next byte to\n      be sent on\
    \ the subflow.  SND.NXT is used to set the value of\n      SEG.SEQ upon transmission\
    \ of the next segment.\n"
- title: B.2.2.  Receiving Side
  contents:
  - "B.2.2.  Receiving Side\n   RCV.NXT (32 bits):  This is the sequence number of\
    \ the next byte that\n      is expected on the subflow.  This state variable is\
    \ modified upon\n      reception of in-order segments.  The value of RCV.NXT is\
    \ copied to\n      the SEG.ACK field of the next segments transmitted on the subflow.\n\
    \   RCV.WND (32 bits with RFC 1323, 16 bits otherwise):  This is the\n      subflow-level\
    \ receive window that is updated with the window field\n      from the segments\
    \ received on this subflow.\n"
- title: Appendix C.  Finite State Machine
  contents:
  - "Appendix C.  Finite State Machine\n   The diagram in Figure 17 shows the Finite\
    \ State Machine for\n   connection-level closure.  This illustrates how the DATA_FIN\n\
    \   connection-level signal (indicated as the DFIN flag on a DATA_ACK)\n   interacts\
    \ with subflow-level FINs, and permits \"break-before-make\"\n   handover between\
    \ subflows.\n                              +---------+\n                     \
    \         | M_ESTAB |\n                              +---------+\n           \
    \          M_CLOSE    |     |    rcv DATA_FIN\n                      ------- \
    \  |     |    -------\n +---------+       snd DATA_FIN /       \\ snd DATA_ACK[DFIN]\
    \ +---------+\n |  M_FIN  |<-----------------           ------------------->|\
    \ M_CLOSE |\n | WAIT-1  |---------------------------                      |  \
    \ WAIT  |\n +---------+               rcv DATA_FIN \\                    +---------+\n\
    \   | rcv DATA_ACK[DFIN]         ------- |                   M_CLOSE |\n   | --------------\
    \        snd DATA_ACK |                   ------- |\n   | CLOSE all subflows \
    \                |              snd DATA_FIN |\n   V                         \
    \           V                           V\n +-----------+              +-----------+\
    \                  +-----------+\n |M_FINWAIT-2|              | M_CLOSING |  \
    \                | M_LAST-ACK|\n +-----------+              +-----------+    \
    \              +-----------+\n   |              rcv DATA_ACK[DFIN] |         \
    \  rcv DATA_ACK[DFIN] |\n   | rcv DATA_FIN     -------------- |              \
    \ -------------- |\n   |  -------     CLOSE all subflows |           CLOSE all\
    \ subflows |\n   | snd DATA_ACK[DFIN]              V            delete MPTCP PCB\
    \  V\n   \\                          +-----------+                  +---------+\n\
    \     ------------------------>|M_TIME WAIT|----------------->| M_CLOSED|\n  \
    \                            +-----------+                  +---------+\n    \
    \                                     All subflows in CLOSED\n               \
    \                              ------------\n                                \
    \         delete MPTCP PCB\n          Figure 17: Finite State Machine for Connection\
    \ Closure\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alan Ford\n   Cisco\n   Ruscombe Business Park\n   Ruscombe,\
    \ Berkshire  RG10 9NN\n   UK\n   EMail: alanford@cisco.com\n   Costin Raiciu\n\
    \   University Politehnica of Bucharest\n   Splaiul Independentei 313\n   Bucharest\n\
    \   Romania\n   EMail: costin.raiciu@cs.pub.ro\n   Mark Handley\n   University\
    \ College London\n   Gower Street\n   London  WC1E 6BT\n   UK\n   EMail: m.handley@cs.ucl.ac.uk\n\
    \   Olivier Bonaventure\n   Universite catholique de Louvain\n   Pl. Ste Barbe,\
    \ 2\n   Louvain-la-Neuve  1348\n   Belgium\n   EMail: olivier.bonaventure@uclouvain.be\n"
