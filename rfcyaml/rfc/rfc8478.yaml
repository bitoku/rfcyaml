- title: __initial_text__
  contents:
  - '       Zstandard Compression and the application/zstd Media Type

    '
- title: Abstract
  contents:
  - "Abstract\n   Zstandard, or \"zstd\" (pronounced \"zee standard\"), is a data\n\
    \   compression mechanism.  This document describes the mechanism and\n   registers\
    \ a media type and content encoding to be used when\n   transporting zstd-compressed\
    \ content via Multipurpose Internet Mail\n   Extensions (MIME).\n   Despite use\
    \ of the word \"standard\" as part of its name, readers are\n   advised that this\
    \ document is not an Internet Standards Track\n   specification; it is being published\
    \ for informational purposes only.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are candidates for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8478.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Definitions . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Compression Algorithm . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     3.1.  Frames  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   6\n       3.1.1.  Zstandard Frames  . . . . . . . . . . . . . . . . .\
    \ .   6\n         3.1.1.1.  Frame Header  . . . . . . . . . . . . . . . . . .\
    \   7\n         3.1.1.2.  Blocks  . . . . . . . . . . . . . . . . . . . . .  12\n\
    \         3.1.1.3.  Compressed Blocks . . . . . . . . . . . . . . . .  14\n  \
    \       3.1.1.4.  Sequence Execution  . . . . . . . . . . . . . . .  28\n    \
    \     3.1.1.5.  Repeat Offsets  . . . . . . . . . . . . . . . . .  29\n      \
    \ 3.1.2.  Skippable Frames  . . . . . . . . . . . . . . . . . .  30\n   4.  Entropy\
    \ Encoding  . . . . . . . . . . . . . . . . . . . . . .  30\n     4.1.  FSE .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . .  31\n       4.1.1.  FSE\
    \ Table Description . . . . . . . . . . . . . . . .  31\n     4.2.  Huffman Coding\
    \  . . . . . . . . . . . . . . . . . . . . .  34\n       4.2.1.  Huffman Tree\
    \ Description  . . . . . . . . . . . . . .  35\n         4.2.1.1.  Huffman Tree\
    \ Header . . . . . . . . . . . . . . .  36\n         4.2.1.2.  FSE Compression\
    \ of Huffman Weights  . . . . . . .  37\n         4.2.1.3.  Conversion from Weights\
    \ to Huffman Prefix Codes .  38\n       4.2.2.  Huffman-Coded Streams . . . .\
    \ . . . . . . . . . . . .  39\n   5.  Dictionary Format . . . . . . . . . . .\
    \ . . . . . . . . . . .  40\n   6.  IANA Considerations . . . . . . . . . . .\
    \ . . . . . . . . . .  42\n     6.1.  The 'application/zstd' Media Type . . .\
    \ . . . . . . . . .  42\n     6.2.  Content Encoding  . . . . . . . . . . . .\
    \ . . . . . . . .  43\n     6.3.  Dictionaries  . . . . . . . . . . . . . . .\
    \ . . . . . . .  43\n   7.  Security Considerations . . . . . . . . . . . . .\
    \ . . . . . .  43\n   8.  Implementation Status . . . . . . . . . . . . . . .\
    \ . . . . .  44\n   9.  References  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  45\n     9.1.  Normative References  . . . . . . . . . . . . . . .\
    \ . . .  45\n     9.2.  Informative References  . . . . . . . . . . . . . . .\
    \ . .  45\n   Appendix A.  Decoding Tables for Predefined Codes . . . . . . .\
    \ .  46\n     A.1.  Literal Length Code Table . . . . . . . . . . . . . . . .\
    \  46\n     A.2.  Match Length Code Table . . . . . . . . . . . . . . . . .  49\n\
    \     A.3.  Offset Code Table . . . . . . . . . . . . . . . . . . . .  52\n  \
    \ Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  53\n   Authors'\
    \ Addresses  . . . . . . . . . . . . . . . . . . . . . . .  54\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Zstandard, or \"zstd\" (pronounced \"zee standard\"), is\
    \ a data\n   compression mechanism, akin to gzip [RFC1952].\n   Despite use of\
    \ the word \"standard\" as part of its name, readers are\n   advised that this\
    \ document is not an Internet Standards Track\n   specification; it is being published\
    \ for informational purposes only.\n   This document describes the Zstandard format.\
    \  Also, to enable the\n   transport of a data object compressed with Zstandard,\
    \ this document\n   registers a media type that can be used to identify such content\
    \ when\n   it is used in a payload encoded using Multipurpose Internet Mail\n\
    \   Extensions (MIME).\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   Some terms used elsewhere in this document are defined here\
    \ for\n   clarity.\n   uncompressed:  Describes an arbitrary set of bytes in their\
    \ original\n      form, prior to being subjected to compression.\n   compress,\
    \ compression:  The act of processing a set of bytes via the\n      compression\
    \ mechanism described here.\n   compressed:  Describes the result of passing a\
    \ set of bytes through\n      this mechanism.  The original input has thus been\
    \ compressed.\n   decompress, decompression:  The act of processing a set of bytes\n\
    \      through the inverse of the compression mechanism described here,\n    \
    \  in an attempt to recover the original set of bytes prior to\n      compression.\n\
    \   decompressed:  Describes the result of passing a set of bytes through\n  \
    \    the reverse of this mechanism.  When this is successful, the\n      decompressed\
    \ payload and the uncompressed payload are\n      indistinguishable.\n   encode:\
    \  The process of translating data from one form to another;\n      this may include\
    \ compression or it may refer to other translations\n      done as part of this\
    \ specification.\n   decode:  The reverse of \"encode\"; describes a process of\
    \ reversing a\n      prior encoding to recover the original content.\n   frame:\
    \  Content compressed by Zstandard is transformed into a\n      Zstandard frame.\
    \  Multiple frames can be appended into a single\n      file or stream.  A frame\
    \ is completely independent, has a defined\n      beginning and end, and has a\
    \ set of parameters that tells the\n      decoder how to decompress it.\n   block:\
    \  A frame encapsulates one or multiple blocks.  Each block\n      contains arbitrary\
    \ content, which is described by its header, and\n      has a guaranteed maximum\
    \ content size that depends upon frame\n      parameters.  Unlike frames, each\
    \ block depends on previous blocks\n      for proper decoding.  However, each\
    \ block can be decompressed\n      without waiting for its successor, allowing\
    \ streaming operations.\n   natural order:  A sequence or ordering of objects\
    \ or values that is\n      typical of that type of object or value.  A set of\
    \ unique\n      integers, for example, is in \"natural order\" if when progressing\n\
    \      from one element in the set or sequence to the next, there is\n      never\
    \ a decrease in value.\n   The naming convention for identifiers within the specification\
    \ is\n   Mixed_Case_With_Underscores.  Identifiers inside square brackets\n  \
    \ indicate that the identifier is optional in the presented context.\n"
- title: 3.  Compression Algorithm
  contents:
  - "3.  Compression Algorithm\n   This section describes the Zstandard algorithm.\n\
    \   The purpose of this document is to define a lossless compressed data\n   format\
    \ that is a) independent of the CPU type, operating system, file\n   system, and\
    \ character set and b) is suitable for file compression and\n   pipe and streaming\
    \ compression, using the Zstandard algorithm.  The\n   text of the specification\
    \ assumes a basic background in programming\n   at the level of bits and other\
    \ primitive data representations.\n   The data can be produced or consumed, even\
    \ for an arbitrarily long\n   sequentially presented input data stream, using\
    \ only an a priori\n   bounded amount of intermediate storage, and hence can be\
    \ used in data\n   communications.  The format uses the Zstandard compression\
    \ method,\n   and an optional xxHash-64 checksum method [XXHASH], for detection\
    \ of\n   data corruption.\n   The data format defined by this specification does\
    \ not attempt to\n   allow random access to compressed data.\n   Unless otherwise\
    \ indicated below, a compliant compressor must produce\n   data sets that conform\
    \ to the specifications presented here.\n   However, it does not need to support\
    \ all options.\n   A compliant decompressor must be able to decompress at least\
    \ one\n   working set of parameters that conforms to the specifications\n   presented\
    \ here.  It may also ignore informative fields, such as the\n   checksum.  Whenever\
    \ it does not support a parameter defined in the\n   compressed stream, it must\
    \ produce a non-ambiguous error code and\n   associated error message explaining\
    \ which parameter is unsupported.\n   This specification is intended for use by\
    \ implementers of software to\n   compress data into Zstandard format and/or decompress\
    \ data from\n   Zstandard format.  The Zstandard format is supported by an open\n\
    \   source reference implementation, written in portable C, and available\n  \
    \ at [ZSTD].\n"
- title: 3.1.  Frames
  contents:
  - "3.1.  Frames\n   Zstandard compressed data is made up of one or more frames.\
    \  Each\n   frame is independent and can be decompressed independently of other\n\
    \   frames.  The decompressed content of multiple concatenated frames is\n   the\
    \ concatenation of each frame's decompressed content.\n   There are two frame\
    \ formats defined for Zstandard: Zstandard frames\n   and skippable frames.  Zstandard\
    \ frames contain compressed data,\n   while skippable frames contain custom user\
    \ metadata.\n"
- title: 3.1.1.  Zstandard Frames
  contents:
  - "3.1.1.  Zstandard Frames\n   The structure of a single Zstandard frame is as\
    \ follows:\n     +--------------------+------------+\n     |    Magic_Number \
    \   | 4 bytes    |\n     +--------------------+------------+\n     |    Frame_Header\
    \    | 2-14 bytes |\n     +--------------------+------------+\n     |     Data_Block\
    \     | n bytes    |\n     +--------------------+------------+\n     | [More Data_Blocks]\
    \ |            |\n     +--------------------+------------+\n     | [Content_Checksum]\
    \ | 0-4 bytes  |\n     +--------------------+------------+\n   Magic_Number: \
    \ 4 bytes, little-endian format.  Value: 0xFD2FB528.\n   Frame_Header:  2 to 14\
    \ bytes, detailed in Section 3.1.1.1.\n   Data_Block:  Detailed in Section 3.1.1.2.\
    \  This is where data\n      appears.\n   Content_Checksum:  An optional 32-bit\
    \ checksum, only present if\n      Content_Checksum_Flag is set.  The content\
    \ checksum is the result\n      of the XXH64() hash function [XXHASH] digesting\
    \ the original\n      (decoded) data as input, and a seed of zero.  The low 4\
    \ bytes of\n      the checksum are stored in little-endian format.\n   The magic\
    \ number was selected to be less probable to find at the\n   beginning of an arbitrary\
    \ file.  It avoids trivial patterns (0x00,\n   0xFF, repeated bytes, increasing\
    \ bytes, etc.), contains byte values\n   outside of ASCII range, and doesn't map\
    \ into UTF-8 space, all of\n   which reduce the likelihood of its appearance at\
    \ the top of a text\n   file.\n"
- title: 3.1.1.1.  Frame Header
  contents:
  - "3.1.1.1.  Frame Header\n   The frame header has a variable size, with a minimum\
    \ of 2 bytes and\n   up to 14 bytes depending on optional parameters.  The structure\
    \ of\n   Frame_Header is as follows:\n     +-------------------------+-----------+\n\
    \     | Frame_Header_Descriptor | 1 byte    |\n     +-------------------------+-----------+\n\
    \     |   [Window_Descriptor]   | 0-1 byte  |\n     +-------------------------+-----------+\n\
    \     |     [Dictionary_ID]     | 0-4 bytes |\n     +-------------------------+-----------+\n\
    \     |  [Frame_Content_Size]   | 0-8 bytes |\n     +-------------------------+-----------+\n"
- title: 3.1.1.1.1.  Frame_Header_Descriptor
  contents:
  - "3.1.1.1.1.  Frame_Header_Descriptor\n   The first header's byte is called the\
    \ Frame_Header_Descriptor.  It\n   describes which other fields are present. \
    \ Decoding this byte is\n   enough to tell the size of Frame_Header.\n     +------------+-------------------------+\n\
    \     | Bit Number | Field Name              |\n     +------------+-------------------------+\n\
    \     |    7-6     | Frame_Content_Size_Flag |\n     +------------+-------------------------+\n\
    \     |     5      | Single_Segment_Flag     |\n     +------------+-------------------------+\n\
    \     |     4      | (unused)                |\n     +------------+-------------------------+\n\
    \     |     3      | (reserved)              |\n     +------------+-------------------------+\n\
    \     |     2      | Content_Checksum_Flag   |\n     +------------+-------------------------+\n\
    \     |    1-0     | Dictionary_ID_Flag      |\n     +------------+-------------------------+\n\
    \   In this table, bit 7 is the highest bit, while bit 0 is the lowest\n   one.\n"
- title: 3.1.1.1.1.1.  Frame_Content_Size_Flag
  contents:
  - "3.1.1.1.1.1.  Frame_Content_Size_Flag\n   This is a 2-bit flag (equivalent to\
    \ Frame_Header_Descriptor right-\n   shifted 6 bits) specifying whether Frame_Content_Size\
    \ (the\n   decompressed data size) is provided within the header.  Flag_Value\n\
    \   provides FCS_Field_Size, which is the number of bytes used by\n   Frame_Content_Size\
    \ according to the following table:\n     +----------------+--------+---+---+---+\n\
    \     | Flag_Value     |   0    | 1 | 2 | 3 |\n     +----------------+--------+---+---+---+\n\
    \     | FCS_Field_Size | 0 or 1 | 2 | 4 | 8 |\n     +----------------+--------+---+---+---+\n\
    \   When Flag_Value is 0, FCS_Field_Size depends on Single_Segment_Flag:\n   If\
    \ Single_Segment_Flag is set, FCS_Field_Size is 1.  Otherwise,\n   FCS_Field_Size\
    \ is 0; Frame_Content_Size is not provided.\n"
- title: 3.1.1.1.1.2.  Single_Segment_Flag
  contents:
  - "3.1.1.1.1.2.  Single_Segment_Flag\n   If this flag is set, data must be regenerated\
    \ within a single\n   continuous memory segment.\n   In this case, Window_Descriptor\
    \ byte is skipped, but\n   Frame_Content_Size is necessarily present.  As a consequence,\
    \ the\n   decoder must allocate a memory segment of size equal or larger than\n\
    \   Frame_Content_Size.\n   In order to protect the decoder from unreasonable\
    \ memory\n   requirements, a decoder is allowed to reject a compressed frame that\n\
    \   requests a memory size beyond the decoder's authorized range.\n   For broader\
    \ compatibility, decoders are recommended to support memory\n   sizes of at least\
    \ 8 MB.  This is only a recommendation; each decoder\n   is free to support higher\
    \ or lower limits, depending on local\n   limitations.\n"
- title: 3.1.1.1.1.3.  Unused Bit
  contents:
  - "3.1.1.1.1.3.  Unused Bit\n   A decoder compliant with this specification version\
    \ shall not\n   interpret this bit.  It might be used in a future version, to\
    \ signal\n   a property that is not mandatory to properly decode the frame.  An\n\
    \   encoder compliant with this specification must set this bit to zero.\n"
- title: 3.1.1.1.1.4.  Reserved Bit
  contents:
  - "3.1.1.1.1.4.  Reserved Bit\n   This bit is reserved for some future feature.\
    \  Its value must be\n   zero.  A decoder compliant with this specification version\
    \ must\n   ensure it is not set.  This bit may be used in a future revision, to\n\
    \   signal a feature that must be interpreted to decode the frame\n   correctly.\n"
- title: 3.1.1.1.1.5.  Content_Checksum_Flag
  contents:
  - "3.1.1.1.1.5.  Content_Checksum_Flag\n   If this flag is set, a 32-bit Content_Checksum\
    \ will be present at the\n   frame's end.  See the description of Content_Checksum\
    \ above.\n"
- title: 3.1.1.1.1.6.  Dictionary_ID_Flag
  contents:
  - "3.1.1.1.1.6.  Dictionary_ID_Flag\n   This is a 2-bit flag (= Frame_Header_Descriptor\
    \ & 0x3) indicating\n   whether a dictionary ID is provided within the header.\
    \  It also\n   specifies the size of this field as DID_Field_Size:\n     +----------------+---+---+---+---+\n\
    \     | Flag_Value     | 0 | 1 | 2 | 3 |\n     +----------------+---+---+---+---+\n\
    \     | DID_Field_Size | 0 | 1 | 2 | 4 |\n     +----------------+---+---+---+---+\n"
- title: 3.1.1.1.2.  Window Descriptor
  contents:
  - "3.1.1.1.2.  Window Descriptor\n   This provides guarantees about the minimum\
    \ memory buffer required to\n   decompress a frame.  This information is important\
    \ for decoders to\n   allocate enough memory.\n   The Window_Descriptor byte is\
    \ optional.  When Single_Segment_Flag is\n   set, Window_Descriptor is not present.\
    \  In this case, Window_Size is\n   Frame_Content_Size, which can be any value\
    \ from 0 to 2^64-1 bytes (16\n   ExaBytes).\n     +------------+----------+----------+\n\
    \     | Bit Number |   7-3    |   2-0    |\n     +------------+----------+----------+\n\
    \     | Field Name | Exponent | Mantissa |\n     +------------+----------+----------+\n\
    \   The minimum memory buffer size is called Window_Size.  It is\n   described\
    \ by the following formulae:\n     windowLog = 10 + Exponent;\n     windowBase\
    \ = 1 << windowLog;\n     windowAdd = (windowBase / 8) * Mantissa;\n     Window_Size\
    \ = windowBase + windowAdd;\n   The minimum Window_Size is 1 KB.  The maximum\
    \ Window_Size is (1<<41)\n   + 7*(1<<38) bytes, which is 3.75 TB.\n   In general,\
    \ larger Window_Size values tend to improve the compression\n   ratio, but at\
    \ the cost of increased memory usage.\n   To properly decode compressed data,\
    \ a decoder will need to allocate a\n   buffer of at least Window_Size bytes.\n\
    \   In order to protect decoders from unreasonable memory requirements, a\n  \
    \ decoder is allowed to reject a compressed frame that requests a\n   memory size\
    \ beyond decoder's authorized range.\n   For improved interoperability, it's recommended\
    \ for decoders to\n   support values of Window_Size up to 8 MB and for encoders\
    \ not to\n   generate frames requiring a Window_Size larger than 8 MB.  It's\n\
    \   merely a recommendation though, and decoders are free to support\n   larger\
    \ or lower limits, depending on local limitations.\n"
- title: 3.1.1.1.3.  Dictionary_ID
  contents:
  - "3.1.1.1.3.  Dictionary_ID\n   This is a variable size field, which contains the\
    \ ID of the\n   dictionary required to properly decode the frame.  This field\
    \ is\n   optional.  When it's not present, it's up to the decoder to know\n  \
    \ which dictionary to use.\n   Dictionary_ID field size is provided by DID_Field_Size.\n\
    \   DID_Field_Size is directly derived from the value of\n   Dictionary_ID_Flag.\
    \  One byte can represent an ID 0-255; 2 bytes can\n   represent an ID 0-65535;\
    \ 4 bytes can represent an ID 0-4294967295.\n   Format is little-endian.\n   It\
    \ is permitted to represent a small ID (for example, 13) with a\n   large 4-byte\
    \ dictionary ID, even if it is less efficient.\n   Within private environments,\
    \ any dictionary ID can be used.  However,\n   for frames and dictionaries distributed\
    \ in public space,\n   Dictionary_ID must be attributed carefully.  The following\
    \ ranges are\n   reserved for use only with dictionaries that have been registered\n\
    \   with IANA (see Section 6.3):\n   low range:  <= 32767\n   high range:  >=\
    \ (1 << 31)\n   Any other value for Dictionary_ID can be used by private arrangement\n\
    \   between participants.\n   Any payload presented for decompression that references\
    \ an\n   unregistered reserved dictionary ID results in an error.\n"
- title: 3.1.1.1.4.  Frame Content Size
  contents:
  - "3.1.1.1.4.  Frame Content Size\n   This is the original (uncompressed) size.\
    \  This information is\n   optional.  Frame_Content_Size uses a variable number\
    \ of bytes,\n   provided by FCS_Field_Size.  FCS_Field_Size is provided by the\
    \ value\n   of Frame_Content_Size_Flag.  FCS_Field_Size can be equal to 0 (not\n\
    \   present), 1, 2, 4, or 8 bytes.\n     +----------------+--------------+\n \
    \    | FCS Field Size | Range        |\n     +----------------+--------------+\n\
    \     |        0       | unknown      |\n     +----------------+--------------+\n\
    \     |        1       | 0 - 255      |\n     +----------------+--------------+\n\
    \     |        2       | 256 - 65791  |\n     +----------------+--------------+\n\
    \     |        4       | 0 - 2^32 - 1 |\n     +----------------+--------------+\n\
    \     |        8       | 0 - 2^64 - 1 |\n     +----------------+--------------+\n\
    \   Frame_Content_Size format is little-endian.  When FCS_Field_Size is\n   1,\
    \ 4, or 8 bytes, the value is read directly.  When FCS_Field_Size is\n   2, the\
    \ offset of 256 is added.  It's allowed to represent a small\n   size (for example\
    \ 18) using any compatible variant.\n"
- title: 3.1.1.2.  Blocks
  contents:
  - "3.1.1.2.  Blocks\n   After Magic_Number and Frame_Header, there are some number\
    \ of blocks.\n   Each frame must have at least 1 block, but there is no upper\
    \ limit on\n   the number of blocks per frame.\n   The structure of a block is\
    \ as follows:\n     +--------------+---------------+\n     | Block_Header | Block_Content\
    \ |\n     +--------------+---------------+\n     |    3 bytes   |    n bytes \
    \   |\n     +--------------+---------------+\n   Block_Header uses 3 bytes, written\
    \ using little-endian convention.\n   It contains three fields:\n     +------------+------------+------------+\n\
    \     | Last_Block | Block_Type | Block_Size |\n     +------------+------------+------------+\n\
    \     |    bit 0   |   bits 1-2 |  bits 3-23 |\n     +------------+------------+------------+\n"
- title: 3.1.1.2.1.  Last_Block
  contents:
  - "3.1.1.2.1.  Last_Block\n   The lowest bit (Last_Block) signals whether this block\
    \ is the last\n   one.  The frame will end after this last block.  It may be followed\n\
    \   by an optional Content_Checksum (see Section 3.1.1).\n"
- title: 3.1.1.2.2.  Block_Type
  contents:
  - "3.1.1.2.2.  Block_Type\n   The next 2 bits represent the Block_Type.  There are\
    \ four block\n   types:\n     +-----------+------------------+\n     |   Value\
    \   |    Block_Type    |\n     +-----------+------------------+\n     |     0\
    \     |     Raw_Block    |\n     +-----------+------------------+\n     |    \
    \ 1     |     RLE_Block    |\n     +-----------+------------------+\n     |  \
    \   2     | Compressed_Block |\n     +-----------+------------------+\n     |\
    \     3     |     Reserved     |\n     +-----------+------------------+\n   Raw_Block:\
    \  This is an uncompressed block.  Block_Content contains\n      Block_Size bytes.\n\
    \   RLE_Block:  This is a single byte, repeated Block_Size times.\n      Block_Content\
    \ consists of a single byte.  On the decompression\n      side, this byte must\
    \ be repeated Block_Size times.\n   Compressed_Block:  This is a compressed block\
    \ as described in\n      Section 3.1.1.3.  Block_Size is the length of Block_Content,\n\
    \      namely the compressed data.  The decompressed size is not known,\n    \
    \  but its maximum possible value is guaranteed (see below).\n   Reserved:  This\
    \ is not a block.  This value cannot be used with the\n      current specification.\
    \  If such a value is present, it is\n      considered to be corrupt data.\n"
- title: 3.1.1.2.3.  Block_Size
  contents:
  - "3.1.1.2.3.  Block_Size\n   The upper 21 bits of Block_Header represent the Block_Size.\n\
    \   Block_Size is the size of the block excluding the header.  A block\n   can\
    \ contain any number of bytes (even zero), up to\n   Block_Maximum_Decompressed_Size,\
    \ which is the smallest of:\n   o  Window_Size\n   o  128 KB\n   A Compressed_Block\
    \ has the extra restriction that Block_Size is\n   always strictly less than the\
    \ decompressed size.  If this condition\n   cannot be respected, the block must\
    \ be sent uncompressed instead\n   (i.e., treated as a Raw_Block).\n"
- title: 3.1.1.3.  Compressed Blocks
  contents:
  - "3.1.1.3.  Compressed Blocks\n   To decompress a compressed block, the compressed\
    \ size must be\n   provided from the Block_Size field within Block_Header.\n \
    \  A compressed block consists of two sections: a Literals\n   Section (Section\
    \ 3.1.1.3.1) and a\n   Sequences_Section (Section 3.1.1.3.2).  The results of\
    \ the two\n   sections are then combined to produce the decompressed data in\n\
    \   Sequence Execution (Section 3.1.1.4).\n   To decode a compressed block, the\
    \ following elements are necessary:\n   o  Previous decoded data, up to a distance\
    \ of Window_Size, or the\n      beginning of the Frame, whichever is smaller.\
    \  Single_Segment_Flag\n      will be set in the latter case.\n   o  List of \"\
    recent offsets\" from the previous Compressed_Block.\n   o  The previous Huffman\
    \ tree, required by Treeless_Literals_Block\n      type.\n   o  Previous Finite\
    \ State Entropy (FSE) decoding tables, required by\n      Repeat_Mode, for each\
    \ symbol type (literals lengths, match\n      lengths, offsets).\n   Note that\
    \ decoding tables are not always from the previous\n   Compressed_Block:\n   o\
    \  Every decoding table can come from a dictionary.\n   o  The Huffman tree comes\
    \ from the previous\n      Compressed_Literals_Block.\n"
- title: 3.1.1.3.1.  Literals_Section_Header
  contents:
  - "3.1.1.3.1.  Literals_Section_Header\n   All literals are regrouped in the first\
    \ part of the block.  They can\n   be decoded first and then copied during Sequence\
    \ Execution (see\n   Section 3.1.1.4), or they can be decoded on the flow during\
    \ Sequence\n   Execution.\n   Literals can be stored uncompressed or compressed\
    \ using Huffman\n   prefix codes.  When compressed, an optional tree description\
    \ can be\n   present, followed by 1 or 4 streams.\n     +----------------------------+\n\
    \     |   Literals_Section_Header  |\n     +----------------------------+\n  \
    \   | [Huffman_Tree_Description] |\n     +----------------------------+\n    \
    \ |        [Jump_Table]        |\n     +----------------------------+\n     |\
    \          Stream_1          |\n     +----------------------------+\n     |  \
    \       [Stream_2]         |\n     +----------------------------+\n     |    \
    \     [Stream_3]         |\n     +----------------------------+\n     |      \
    \   [Stream_4]         |\n     +----------------------------+\n"
- title: 3.1.1.3.1.1.  Literals_Section_Header
  contents:
  - "3.1.1.3.1.1.  Literals_Section_Header\n   This field describes how literals are\
    \ packed.  It's a byte-aligned\n   variable-size bit field, ranging from 1 to\
    \ 5 bytes, using little-\n   endian convention.\n     +---------------------+-----------+\n\
    \     | Literals_Block_Type |  2 bits   |\n     +---------------------+-----------+\n\
    \     |     Size_Format     | 1-2 bits  |\n     +---------------------+-----------+\n\
    \     |   Regenerated_Size  | 5-20 bits |\n     +---------------------+-----------+\n\
    \     |  [Compressed_Size]  | 0-18 bits |\n     +---------------------+-----------+\n\
    \   In this representation, bits at the top are the lowest bits.\n   The Literals_Block_Type\
    \ field uses the two lowest bits of the first\n   byte, describing four different\
    \ block types:\n     +---------------------------+-------+\n     |    Literals_Block_Type\
    \    | Value |\n     +---------------------------+-------+\n     |     Raw_Literals_Block\
    \    |   0   |\n     +---------------------------+-------+\n     |     RLE_Literals_Block\
    \    |   1   |\n     +---------------------------+-------+\n     | Compressed_Literals_Block\
    \ |   2   |\n     +---------------------------+-------+\n     |  Treeless_Literals_Block\
    \  |   3   |\n     +---------------------------+-------+\n   Raw_Literals_Block:\
    \  Literals are stored uncompressed.\n      Literals_Section_Content is Regenerated_Size.\n\
    \   RLE_Literals_Block:  Literals consist of a single-byte value repeated\n  \
    \    Regenerated_Size times.  Literals_Section_Content is 1.\n   Compressed_Literals_Block:\
    \  This is a standard Huffman-compressed\n      block, starting with a Huffman\
    \ tree description.  See details\n      below.  Literals_Section_Content is Compressed_Size.\n\
    \   Treeless_Literals_Block:  This is a Huffman-compressed block, using\n    \
    \  the Huffman tree from the previous Compressed_Literals_Block, or a\n      dictionary\
    \ if there is no previous Huffman-compressed literals\n      block.  Huffman_Tree_Description\
    \ will be skipped.  Note that if\n      this mode is triggered without any previous\
    \ Huffman-table in the\n      frame (or dictionary, per Section 5), it should\
    \ be treated as data\n      corruption.  Literals_Section_Content is Compressed_Size.\n\
    \   The Size_Format is divided into two families:\n   o  For Raw_Literals_Block\
    \ and RLE_Literals_Block, it's only necessary\n      to decode Regenerated_Size.\
    \  There is no Compressed_Size field.\n   o  For Compressed_Block and Treeless_Literals_Block,\
    \ it's required to\n      decode both Compressed_Size and Regenerated_Size (the\
    \ decompressed\n      size).  It's also necessary to decode the number of streams\
    \ (1 or\n      4).\n   For values spanning several bytes, the convention is little\
    \ endian.\n   Size_Format for Raw_Literals_Block and RLE_Literals_Block uses 1\
    \ or 2\n   bits.  Its value is (Literals_Section_Header[0]>>2) & 0x3.\n   Size_Format\
    \ == 00 or 10:  Size_Format uses 1 bit.  Regenerated_Size\n      uses 5 bits (value\
    \ 0-31).  Literals_Section_Header uses 1 byte.\n      Regenerated_Size = Literal_Section_Header[0]>>3.\n\
    \   Size_Format == 01:  Size_Format uses 2 bits.  Regenerated_Size uses\n    \
    \  12 bits (values 0-4095).  Literals_Section_Header uses 2 bytes.\n      Regenerated_Size\
    \ = (Literals_Section_Header[0]>>4) +\n      (Literals_Section_Header[1]<<4).\n\
    \   Size_Format == 11:  Size_Format uses 2 bits.  Regenerated_Size uses\n    \
    \  20 bits (values 0-1048575).  Literals_Section_Header uses 3 bytes.\n      Regenerated_Size\
    \ = (Literals_Section_Header[0]>>4) +\n      (Literals_Section_Header[1]<<4) +\
    \ (Literals_Section_Header[2]<<12)\n   Only Stream_1 is present for these cases.\
    \  Note that it is permitted\n   to represent a short value (for example, 13)\
    \ using a long format,\n   even if it's less efficient.\n   Size_Format for Compressed_Literals_Block\
    \ and Treeless_Literals_Block\n   always uses 2 bits.\n   Size_Format == 00: \
    \ A single stream.  Both Regenerated_Size and\n      Compressed_Size use 10 bits\
    \ (values 0-1023).\n      Literals_Section_Header uses 3 bytes.\n   Size_Format\
    \ == 01:  4 streams.  Both Regenerated_Size and\n      Compressed_Size use 10\
    \ bits (values 0-1023).\n      Literals_Section_Header uses 3 bytes.\n   Size_Format\
    \ == 10:  4 streams.  Both Regenerated_Size and\n      Compressed_Size use 14\
    \ bits (values 0-16383).\n      Literals_Section_Header uses 4 bytes.\n   Size_Format\
    \ == 11:  4 streams.  Both Regenerated_Size and\n      Compressed_Size use 18\
    \ bits (values 0-262143).\n      Literals_Section_Header uses 5 bytes.\n   Both\
    \ the Compressed_Size and Regenerated_Size fields follow little-\n   endian convention.\
    \  Note that Compressed_Size includes the size of\n   the Huffman_Tree_Description\
    \ when it is present.\n"
- title: 3.1.1.3.1.2.  Raw_Literals_Block
  contents:
  - "3.1.1.3.1.2.  Raw_Literals_Block\n   The data in Stream_1 is Regenerated_Size\
    \ bytes long.  It contains the\n   raw literals data to be used during Sequence\
    \ Execution\n   (Section 3.1.1.3.2).\n"
- title: 3.1.1.3.1.3.  RLE_Literals_Block
  contents:
  - "3.1.1.3.1.3.  RLE_Literals_Block\n   Stream_1 consists of a single byte that\
    \ should be repeated\n   Regenerated_Size times to generate the decoded literals.\n"
- title: 3.1.1.3.1.4.  Compressed_Literals_Block and Treeless_Literals_Block
  contents:
  - "3.1.1.3.1.4.  Compressed_Literals_Block and Treeless_Literals_Block\n   Both\
    \ of these modes contain Huffman-encoded data.  For\n   Treeless_Literals_Block,\
    \ the Huffman table comes from the previously\n   compressed literals block, or\
    \ from a dictionary; see Section 5.\n"
- title: 3.1.1.3.1.5.  Huffman_Tree_Description
  contents:
  - "3.1.1.3.1.5.  Huffman_Tree_Description\n   This section is only present when\
    \ the Literals_Block_Type type is\n   Compressed_Literals_Block (2).  The format\
    \ of\n   Huffman_Tree_Description can be found in Section 4.2.1.  The size of\n\
    \   Huffman_Tree_Description is determined during the decoding process.\n   It\
    \ must be used to determine where streams begin.\n     Total_Streams_Size = Compressed_Size\n\
    \                          - Huffman_Tree_Description_Size\n"
- title: 3.1.1.3.1.6.  Jump_Table
  contents:
  - "3.1.1.3.1.6.  Jump_Table\n   The Jump_Table is only present when there are 4\
    \ Huffman-coded\n   streams.\n   (Reminder: Huffman-compressed data consists of\
    \ either 1 or 4 Huffman-\n   coded streams.)\n   If only 1 stream is present,\
    \ it is a single bitstream occupying the\n   entire remaining portion of the literals\
    \ block, encoded as described\n   within Section 4.2.2.\n   If there are 4 streams,\
    \ Literals_Section_Header only provides enough\n   information to know the decompressed\
    \ and compressed sizes of all 4\n   streams combined.  The decompressed size of\
    \ each stream is equal to\n   (Regenerated_Size+3)/4, except for the last stream,\
    \ which may be up\n   to 3 bytes smaller, to reach a total decompressed size as\
    \ specified\n   in Regenerated_Size.\n   The compressed size of each stream is\
    \ provided explicitly in the\n   Jump_Table.  The Jump_Table is 6 bytes long and\
    \ consists of three\n   2-byte little-endian fields, describing the compressed\
    \ sizes of the\n   first 3 streams.  Stream4_Size is computed from Total_Streams_Size\n\
    \   minus sizes of other streams.\n     Stream4_Size = Total_Streams_Size - 6\n\
    \                    - Stream1_Size - Stream2_Size\n                    - Stream3_Size\n\
    \   Note that if Stream1_Size + Stream2_Size + Stream3_Size exceeds\n   Total_Streams_Size,\
    \ the data are considered corrupted.\n   Each of these 4 bitstreams is then decoded\
    \ independently as a\n   Huffman-Coded stream, as described in Section 4.2.2.\n"
- title: 3.1.1.3.2.  Sequences_Section
  contents:
  - "3.1.1.3.2.  Sequences_Section\n   A compressed block is a succession of sequences.\
    \  A sequence is a\n   literal copy command, followed by a match copy command.\
    \  A literal\n   copy command specifies a length.  It is the number of bytes to\
    \ be\n   copied (or extracted) from the Literals Section.  A match copy\n   command\
    \ specifies an offset and a length.\n   When all sequences are decoded, if there\
    \ are literals left in the\n   literals section, these bytes are added at the\
    \ end of the block.\n   This is described in more detail in Section 3.1.1.4.\n\
    \   The Sequences_Section regroups all symbols required to decode\n   commands.\
    \  There are three symbol types: literals lengths, offsets,\n   and match lengths.\
    \  They are encoded together, interleaved, in a\n   single \"bitstream\".\n  \
    \ The Sequences_Section starts by a header, followed by optional\n   probability\
    \ tables for each symbol type, followed by the bitstream.\n     Sequences_Section_Header\n\
    \       [Literals_Length_Table]\n       [Offset_Table]\n       [Match_Length_Table]\n\
    \       bitStream\n   To decode the Sequences_Section, it's necessary to know\
    \ its size.\n   This size is deduced from the size of the Literals_Section:\n\
    \   Sequences_Section_Size = Block_Size - Literals_Section_Header -\n   Literals_Section_Content\n"
- title: 3.1.1.3.2.1.  Sequences_Section_Header
  contents:
  - "3.1.1.3.2.1.  Sequences_Section_Header\n   This header consists of two items:\n\
    \   o  Number_of_Sequences\n   o  Symbol_Compression_Modes\n   Number_of_Sequences\
    \ is a variable size field using between 1 and 3\n   bytes.  If the first byte\
    \ is \"byte0\":\n   o  if (byte0 == 0): there are no sequences.  The sequence\
    \ section\n      stops here.  Decompressed content is defined entirely as Literals\n\
    \      Section content.  The FSE tables used in Repeat_Mode are not\n      updated.\n\
    \   o  if (byte0 < 128): Number_of_Sequences = byte0.  Uses 1 byte.\n   o  if\
    \ (byte0 < 255): Number_of_Sequences = ((byte0 - 128) << 8) +\n      byte1.  Uses\
    \ 2 bytes.\n   o  if (byte0 == 255): Number_of_Sequences = byte1 + (byte2 << 8)\
    \ +\n      0x7F00.  Uses 3 bytes.\n   Symbol_Compression_Modes is a single byte,\
    \ defining the compression\n   mode of each symbol type.\n     +-------------+----------------------+\n\
    \     | Bit Number  |      Field Name      |\n     +-------------+----------------------+\n\
    \     |     7-6     | Literal_Lengths_Mode |\n     +-------------+----------------------+\n\
    \     |     5-4     |     Offsets_Mode     |\n     +-------------+----------------------+\n\
    \     |     3-2     |  Match_Lengths_Mode  |\n     +-------------+----------------------+\n\
    \     |     1-0     |       Reserved       |\n     +-------------+----------------------+\n\
    \   The last field, Reserved, must be all zeroes.\n   Literals_Lengths_Mode, Offsets_Mode,\
    \ and Match_Lengths_Mode define\n   the Compression_Mode of literals lengths,\
    \ offsets, and match lengths\n   symbols, respectively.  They follow the same\
    \ enumeration:\n     +-------+---------------------+\n     | Value |  Compression_Mode\
    \   |\n     +-------+---------------------+\n     |   0   |   Predefined_Mode\
    \   |\n     +-------+---------------------+\n     |   1   |      RLE_Mode    \
    \   |\n     +-------+---------------------+\n     |   2   | FSE_Compressed_Mode\
    \ |\n     +-------+---------------------+\n     |   3   |     Repeat_Mode    \
    \ |\n     +-------+---------------------+\n   Predefined_Mode:  A predefined FSE\
    \ (see Section 4.1) distribution\n      table is used, as defined in Section 3.1.1.3.2.2.\
    \  No distribution\n      table will be present.\n   RLE_Mode:  The table description\
    \ consists of a single byte, which\n      contains the symbol's value.  This symbol\
    \ will be used for all\n      sequences.\n   FSE_Compressed_Mode:  Standard FSE\
    \ compression.  A distribution table\n      will be present.  The format of this\
    \ distribution table is\n      described in Section 4.1.1.  Note that the maximum\
    \ allowed\n      accuracy log for literals length and match length tables is 9,\
    \ and\n      the maximum accuracy log for the offsets table is 8.  This mode\n\
    \      must not be used when only one symbol is present; RLE_Mode should\n   \
    \   be used instead (although any other mode will work).\n   Repeat_Mode:  The\
    \ table used in the previous Compressed_Block with\n      Number_Of_Sequences\
    \ > 0 will be used again, or if this is the\n      first block, the table in the\
    \ dictionary will be used.  Note that\n      this includes RLE_Mode, so if Repeat_Mode\
    \ follows RLE_Mode, the\n      same symbol will be repeated.  It also includes\
    \ Predefined_Mode,\n      in which case Repeat_Mode will have the same outcome\
    \ as\n      Predefined_Mode.  No distribution table will be present.  If this\n\
    \      mode is used without any previous sequence table in the frame (or\n   \
    \   dictionary; see Section 5) to repeat, this should be treated as\n      corruption.\n"
- title: 3.1.1.3.2.1.1.  Sequence Codes for Lengths and Offsets
  contents:
  - "3.1.1.3.2.1.1.  Sequence Codes for Lengths and Offsets\n   Each symbol is a code\
    \ in its own context, which specifies Baseline\n   and Number_of_Bits to add.\
    \  Codes are FSE compressed and interleaved\n   with raw additional bits in the\
    \ same bitstream.\n   Literals length codes are values ranging from 0 to 35 inclusive.\n\
    \   They define lengths from 0 to 131071 bytes.  The literals length is\n   equal\
    \ to the decoded Baseline plus the result of reading\n   Number_of_Bits bits from\
    \ the bitstream, as a little-endian value.\n     +----------------------+----------+----------------+\n\
    \     | Literals_Length_Code | Baseline | Number_of_Bits |\n     +----------------------+----------+----------------+\n\
    \     |         0-15         |  length  |       0        |\n     +----------------------+----------+----------------+\n\
    \     |          16          |    16    |       1        |\n     +----------------------+----------+----------------+\n\
    \     |          17          |    18    |       1        |\n     +----------------------+----------+----------------+\n\
    \     |          18          |    20    |       1        |\n     +----------------------+----------+----------------+\n\
    \     |          19          |    22    |       1        |\n     +----------------------+----------+----------------+\n\
    \     |          20          |    24    |       2        |\n     +----------------------+----------+----------------+\n\
    \     |          21          |    28    |       2        |\n     +----------------------+----------+----------------+\n\
    \     |          22          |    32    |       3        |\n     +----------------------+----------+----------------+\n\
    \     |          23          |    40    |       3        |\n     +----------------------+----------+----------------+\n\
    \     |          24          |    48    |       4        |\n     +----------------------+----------+----------------+\n\
    \     |          25          |    64    |       6        |\n     +----------------------+----------+----------------+\n\
    \     |          26          |    128   |       7        |\n     +----------------------+----------+----------------+\n\
    \     |          27          |    256   |       8        |\n     +----------------------+----------+----------------+\n\
    \     |          28          |    512   |       9        |\n     +----------------------+----------+----------------+\n\
    \     |          29          |   1024   |       10       |\n     +----------------------+----------+----------------+\n\
    \     |          30          |   2048   |       11       |\n     +----------------------+----------+----------------+\n\
    \     |          31          |   4096   |       12       |\n     +----------------------+----------+----------------+\n\
    \     |          32          |   8192   |       13       |\n     +----------------------+----------+----------------+\n\
    \     |          33          |  16384   |       14       |\n     +----------------------+----------+----------------+\n\
    \     |          34          |  32768   |       15       |\n     +----------------------+----------+----------------+\n\
    \     |          35          |  65536   |       16       |\n     +----------------------+----------+----------------+\n\
    \   Match length codes are values ranging from 0 to 52 inclusive.  They\n   define\
    \ lengths from 3 to 131074 bytes.  The match length is equal to\n   the decoded\
    \ Baseline plus the result of reading Number_of_Bits bits\n   from the bitstream,\
    \ as a little-endian value.\n     +-------------------+-----------------------+----------------+\n\
    \     | Match_Length_Code |       Baseline        | Number_of_Bits |\n     +-------------------+-----------------------+----------------+\n\
    \     |        0-31       | Match_Length_Code + 3 |       0        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         32        |          35           |       1        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         33        |          37           |       1        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         34        |          39           |       1        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         35        |          41           |       1        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         36        |          43           |       2        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         37        |          47           |       2        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         38        |          51           |       3        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         39        |          59           |       3        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         40        |          67           |       4        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         41        |          83           |       4        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         42        |          99           |       5        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         43        |         131           |       7        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         44        |         259           |       8        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         45        |         515           |       9        |\n     +-------------------+-----------------------+----------------+\n\
    \     |         46        |         1027          |       10       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         47        |         2051          |       11       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         48        |         4099          |       12       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         49        |         8195          |       13       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         50        |         16387         |       14       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         51        |         32771         |       15       |\n     +-------------------+-----------------------+----------------+\n\
    \     |         52        |         65539         |       16       |\n     +-------------------+-----------------------+----------------+\n\
    \   Offset codes are values ranging from 0 to N.\n   A decoder is free to limit\
    \ its maximum supported value for N.\n   Support for values of at least 22 is\
    \ recommended.  At the time of\n   this writing, the reference decoder supports\
    \ a maximum N value of 31.\n   An offset code is also the number of additional\
    \ bits to read in\n   little-endian fashion and can be translated into an Offset_Value\n\
    \   using the following formulas:\n     Offset_Value = (1 << offsetCode) + readNBits(offsetCode);\n\
    \     if (Offset_Value > 3) Offset = Offset_Value - 3;\n   This means that maximum\
    \ Offset_Value is (2^(N+1))-1, supporting back-\n   reference distance up to (2^(N+1))-4,\
    \ but it is limited by the\n   maximum back-reference distance (see Section 3.1.1.1.2).\n\
    \   Offset_Value from 1 to 3 are special: they define \"repeat codes\".\n   This\
    \ is described in more detail in Section 3.1.1.5.\n"
- title: 3.1.1.3.2.1.2.  Decoding Sequences
  contents:
  - "3.1.1.3.2.1.2.  Decoding Sequences\n   FSE bitstreams are read in reverse of\
    \ the direction they are written.\n   In zstd, the compressor writes bits forward\
    \ into a block, and the\n   decompressor must read the bitstream backwards.\n\
    \   To find the start of the bitstream, it is therefore necessary to know\n  \
    \ the offset of the last byte of the block, which can be found by\n   counting\
    \ Block_Size bytes after the block header.\n   After writing the last bit containing\
    \ information, the compressor\n   writes a single 1 bit and then fills the byte\
    \ with 0-7 zero bits of\n   padding.  The last byte of the compressed bitstream\
    \ cannot be zero\n   for that reason.\n   When decompressing, the last byte containing\
    \ the padding is the first\n   byte to read.  The decompressor needs to skip 0-7\
    \ initial zero bits\n   until the first 1 bit occurs.  Afterwards, the useful\
    \ part of the\n   bitstream begins.\n   FSE decoding requires a 'state' to be\
    \ carried from symbol to symbol.\n   For more explanation on FSE decoding, see\
    \ Section 4.1.\n   For sequence decoding, a separate state keeps track of each\
    \ literal\n   lengths, offsets, and match lengths symbols.  Some FSE primitives\
    \ are\n   also used.  For more details on the operation of these primitives,\n\
    \   see Section 4.1.\n   The bitstream starts with initial FSE state values, each\
    \ using the\n   required number of bits in their respective accuracy, decoded\n\
    \   previously from their normalized distribution.  It starts with\n   Literals_Length_State,\
    \ followed by Offset_State, and finally\n   Match_Length_State.\n   Note that\
    \ all values are read backward, so the 'start' of the\n   bitstream is at the\
    \ highest position in memory, immediately before\n   the last 1 bit for padding.\n\
    \   After decoding the starting states, a single sequence is decoded\n   Number_Of_Sequences\
    \ times.  These sequences are decoded in order from\n   first to last.  Since\
    \ the compressor writes the bitstream in the\n   forward direction, this means\
    \ the compressor must encode the\n   sequences starting with the last one and\
    \ ending with the first.\n   For each of the symbol types, the FSE state can be\
    \ used to determine\n   the appropriate code.  The code then defines the Baseline\
    \ and\n   Number_of_Bits to read for each type.  The description of the codes\n\
    \   for how to determine these values can be found in\n   Section 3.1.1.3.2.1.\n\
    \   Decoding starts by reading the Number_of_Bits required to decode\n   offset.\
    \  It does the same for Match_Length and then for\n   Literals_Length.  This sequence\
    \ is then used for Sequence Execution\n   (see Section 3.1.1.4).\n   If it is\
    \ not the last sequence in the block, the next operation is to\n   update states.\
    \  Using the rules pre-calculated in the decoding\n   tables, Literals_Length_State\
    \ is updated, followed by\n   Match_Length_State, and then Offset_State.  See\
    \ Section 4.1 for\n   details on how to update states from the bitstream.\n  \
    \ This operation will be repeated Number_of_Sequences times.  At the\n   end,\
    \ the bitstream shall be entirely consumed; otherwise, the\n   bitstream is considered\
    \ corrupted.\n"
- title: 3.1.1.3.2.2.  Default Distributions
  contents:
  - "3.1.1.3.2.2.  Default Distributions\n   If Predefined_Mode is selected for a\
    \ symbol type, its FSE decoding\n   table is generated from a predefined distribution\
    \ table defined here.\n   For details on how to convert this distribution into\
    \ a decoding\n   table, see Section 4.1.\n"
- title: 3.1.1.3.2.2.1.  Literals Length
  contents:
  - "3.1.1.3.2.2.1.  Literals Length\n   The decoding table uses an accuracy log of\
    \ 6 bits (64 states).\n     short literalsLength_defaultDistribution[36] =\n \
    \      { 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,\n         2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1,\n         -1,-1,-1,-1\n       };\n"
- title: 3.1.1.3.2.2.2.  Match Length
  contents:
  - "3.1.1.3.2.2.2.  Match Length\n   The decoding table uses an accuracy log of 6\
    \ bits (64 states).\n     short matchLengths_defaultDistribution[53] =\n     \
    \  { 1, 4, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,\n         1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1,-1,-1,\n         -1,-1,-1,-1,-1\n       };\n"
- title: 3.1.1.3.2.2.3.  Offset Codes
  contents:
  - "3.1.1.3.2.2.3.  Offset Codes\n   The decoding table uses an accuracy log of 5\
    \ bits (32 states), and\n   supports a maximum N value of 28, allowing offset\
    \ values up to\n   536,870,908.\n   If any sequence in the compressed block requires\
    \ a larger offset than\n   this, it's not possible to use the default distribution\
    \ to represent\n   it.\n     short offsetCodes_defaultDistribution[29] =\n   \
    \    { 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,\n         1, 1, 1, 1, 1,\
    \ 1, 1, 1,-1,-1,-1,-1,-1\n       };\n"
- title: 3.1.1.4.  Sequence Execution
  contents:
  - "3.1.1.4.  Sequence Execution\n   Once literals and sequences have been decoded,\
    \ they are combined to\n   produce the decoded content of a block.\n   Each sequence\
    \ consists of a tuple of (literals_length, offset_value,\n   match_length), decoded\
    \ as described in the\n   Sequences_Section (Section 3.1.1.3.2).  To execute a\
    \ sequence, first\n   copy literals_length bytes from the decoded literals to\
    \ the output.\n   Then, match_length bytes are copied from previous decoded data.\
    \  The\n   offset to copy from is determined by offset_value:\n   o  if Offset_Value\
    \ > 3, then the offset is Offset_Value - 3;\n   o  if Offset_Value is from 1-3,\
    \ the offset is a special repeat offset\n      value.  See Section 3.1.1.5 for\
    \ how the offset is determined in\n      this case.\n   The offset is defined\
    \ as from the current position (after copying the\n   literals), so an offset\
    \ of 6 and a match length of 3 means that 3\n   bytes should be copied from 6\
    \ bytes back.  Note that all offsets\n   leading to previously decoded data must\
    \ be smaller than Window_Size\n   defined in Frame_Header_Descriptor (Section\
    \ 3.1.1.1.1).\n"
- title: 3.1.1.5.  Repeat Offsets
  contents:
  - "3.1.1.5.  Repeat Offsets\n   As seen above, the first three values define a repeated\
    \ offset; we\n   will call them Repeated_Offset1, Repeated_Offset2, and\n   Repeated_Offset3.\
    \  They are sorted in recency order, with\n   Repeated_Offset1 meaning \"most\
    \ recent one\".\n   If offset_value is 1, then the offset used is Repeated_Offset1,\
    \ etc.\n   There is one exception: When the current sequence's literals_length\n\
    \   is 0, repeated offsets are shifted by 1, so an offset_value of 1\n   means\
    \ Repeated_Offset2, an offset_value of 2 means Repeated_Offset3,\n   and an offset_value\
    \ of 3 means Repeated_Offset1 - 1_byte.\n   For the first block, the starting\
    \ offset history is populated with\n   the following values: Repeated_Offset1\
    \ (1), Repeated_Offset2 (4), and\n   Repeated_Offset3 (8), unless a dictionary\
    \ is used, in which case they\n   come from the dictionary.\n   Then each block\
    \ gets its starting offset history from the ending\n   values of the most recent\
    \ Compressed_Block.  Note that blocks that\n   are not Compressed_Block are skipped;\
    \ they do not contribute to\n   offset history.\n   The newest offset takes the\
    \ lead in offset history, shifting others\n   back (up to its previous place if\
    \ it was already present).  This\n   means that when Repeated_Offset1 (most recent)\
    \ is used, history is\n   unmodified.  When Repeated_Offset2 is used, it is swapped\
    \ with\n   Repeated_Offset1.  If any other offset is used, it becomes\n   Repeated_Offset1,\
    \ and the rest are shifted back by 1.\n"
- title: 3.1.2.  Skippable Frames
  contents:
  - "3.1.2.  Skippable Frames\n     +--------------+------------+-----------+\n  \
    \   | Magic_Number | Frame_Size | User_Data |\n     +--------------+------------+-----------+\n\
    \     |    4 bytes   |   4 bytes  |  n bytes  |\n     +--------------+------------+-----------+\n\
    \   Skippable frames allow the insertion of user-defined metadata into a\n   flow\
    \ of concatenated frames.\n   Skippable frames defined in this specification are\
    \ compatible with\n   skippable frames in [LZ4].\n   From a compliant decoder\
    \ perspective, skippable frames simply need to\n   be skipped, and their content\
    \ ignored, resuming decoding after the\n   skippable frame.\n   It should be noted\
    \ that a skippable frame can be used to watermark a\n   stream of concatenated\
    \ frames embedding any kind of tracking\n   information (even just a Universally\
    \ Unique Identifier (UUID)).\n   Users wary of such possibility should scan the\
    \ stream of concatenated\n   frames in an attempt to detect such frames for analysis\
    \ or removal.\n   The fields are:\n   Magic_Number:  4 bytes, little-endian format.\
    \  Value: 0x184D2A5?,\n      which means any value from 0x184D2A50 to 0x184D2A5F.\
    \  All 16\n      values are valid to identify a skippable frame.  This\n     \
    \ specification does not detail any specific tagging methods for\n      skippable\
    \ frames.\n   Frame_Size:  This is the size, in bytes, of the following User_Data\n\
    \      (without including the magic number nor the size field itself).\n     \
    \ This field is represented using 4 bytes, little-endian format,\n      unsigned\
    \ 32 bits.  This means User_Data can't be bigger than\n      (2^32-1) bytes.\n\
    \   User_Data:  This field can be anything.  Data will just be skipped by\n  \
    \    the decoder.\n"
- title: 4.  Entropy Encoding
  contents:
  - "4.  Entropy Encoding\n   Two types of entropy encoding are used by the Zstandard\
    \ format: FSE\n   and Huffman coding.  Huffman is used to compress literals, while\
    \ FSE\n   is used for all other symbols (Literals_Length_Code,\n   Match_Length_Code,\
    \ and offset codes) and to compress Huffman headers.\n"
- title: 4.1.  FSE
  contents:
  - "4.1.  FSE\n   FSE, short for Finite State Entropy, is an entropy codec based\
    \ on\n   [ANS].  FSE encoding/decoding involves a state that is carried over\n\
    \   between symbols, so decoding must be done in the opposite direction\n   as\
    \ encoding.  Therefore, all FSE bitstreams are read from end to\n   beginning.\
    \  Note that the order of the bits in the stream is not\n   reversed; they are\
    \ simply read in the reverse order from which they\n   were written.\n   For additional\
    \ details on FSE, see Finite State Entropy [FSE].\n   FSE decoding involves a\
    \ decoding table that has a power of 2 size and\n   contains three elements: Symbol,\
    \ Num_Bits, and Baseline.  The base 2\n   logarithm of the table size is its Accuracy_Log.\
    \  An FSE state value\n   represents an index in this table.\n   To obtain the\
    \ initial state value, consume Accuracy_Log bits from the\n   stream as a little-endian\
    \ value.  The next symbol in the stream is\n   the Symbol indicated in the table\
    \ for that state.  To obtain the next\n   state value, the decoder should consume\
    \ Num_Bits bits from the stream\n   as a little-endian value and add it to Baseline.\n"
- title: 4.1.1.  FSE Table Description
  contents:
  - "4.1.1.  FSE Table Description\n   To decode FSE streams, it is necessary to construct\
    \ the decoding\n   table.  The Zstandard format encodes FSE table descriptions\
    \ as\n   described here.\n   An FSE distribution table describes the probabilities\
    \ of all symbols\n   from 0 to the last present one (included) on a normalized\
    \ scale of\n   (1 << Accuracy_Log).  Note that there must be two or more symbols\n\
    \   with non-zero probability.\n   A bitstream is read forward, in little-endian\
    \ fashion.  It is not\n   necessary to know its exact size, since the size will\
    \ be discovered\n   and reported by the decoding process.  The bitstream starts\
    \ by\n   reporting on which scale it operates.  If low4bits designates the\n \
    \  lowest 4 bits of the first byte, then Accuracy_Log = low4bits + 5.\n   This\
    \ is followed by each symbol value, from 0 to the last present\n   one.  The number\
    \ of bits used by each field is variable and depends\n   on:\n   Remaining probabilities\
    \ + 1:  For example, presuming an Accuracy_Log\n      of 8, and presuming 100\
    \ probabilities points have already been\n      distributed, the decoder may read\
    \ any value from 0 to\n      (256 - 100 + 1) == 157, inclusive.  Therefore, it\
    \ must read\n      log2sup(157) == 8 bits.\n   Value decoded:  Small values use\
    \ 1 fewer bit.  For example, presuming\n      values from 0 to 157 (inclusive)\
    \ are possible, 255 - 157 = 98\n      values are remaining in an 8-bit field.\
    \  The first 98 values\n      (hence from 0 to 97) use only 7 bits, and values\
    \ from 98 to 157\n      use 8 bits.  This is achieved through this scheme:\n \
    \    +------------+---------------+-----------+\n     | Value Read | Value Decoded\
    \ | Bits Used |\n     +------------+---------------+-----------+\n     |   0 -\
    \ 97   |     0 - 97    |     7     |\n     +------------+---------------+-----------+\n\
    \     |  98 - 127  |    98 - 127   |     8     |\n     +------------+---------------+-----------+\n\
    \     | 128 - 225  |     0 - 97    |     7     |\n     +------------+---------------+-----------+\n\
    \     | 226 - 255  |   128 - 157   |     8     |\n     +------------+---------------+-----------+\n\
    \   Symbol probabilities are read one by one, in order.  The probability\n   is\
    \ obtained from Value decoded using the formula P = Value - 1.  This\n   means\
    \ the value 0 becomes the negative probability -1.  This is a\n   special probability\
    \ that means \"less than 1\".  Its effect on the\n   distribution table is described\
    \ below.  For the purpose of\n   calculating total allocated probability points,\
    \ it counts as 1.\n   When a symbol has a probability of zero, it is followed\
    \ by a 2-bit\n   repeat flag.  This repeat flag tells how many probabilities of\
    \ zeroes\n   follow the current one.  It provides a number ranging from 0 to 3.\n\
    \   If it is a 3, another 2-bit repeat flag follows, and so on.\n   When the last\
    \ symbol reaches a cumulated total of\n   (1 << Accuracy_Log), decoding is complete.\
    \  If the last symbol makes\n   the cumulated total go above (1 << Accuracy_Log),\
    \ distribution is\n   considered corrupted.\n   Finally, the decoder can tell\
    \ how many bytes were used in this\n   process and how many symbols are present.\
    \  The bitstream consumes a\n   round number of bytes.  Any remaining bit within\
    \ the last byte is\n   simply unused.\n   The distribution of normalized probabilities\
    \ is enough to create a\n   unique decoding table.  The table has a size of (1\
    \ << Accuracy_Log).\n   Each cell describes the symbol decoded and instructions\
    \ to get the\n   next state.\n   Symbols are scanned in their natural order for\
    \ \"less than 1\"\n   probabilities as described above.  Symbols with this probability\
    \ are\n   being attributed a single cell, starting from the end of the table\n\
    \   and retreating.  These symbols define a full state reset, reading\n   Accuracy_Log\
    \ bits.\n   All remaining symbols are allocated in their natural order.  Starting\n\
    \   from symbol 0 and table position 0, each symbol gets allocated as\n   many\
    \ cells as its probability.  Cell allocation is spread, not\n   linear; each successor\
    \ position follows this rule:\n     position += (tableSize >> 1) + (tableSize\
    \ >> 3) + 3;\n     position &= tableSize - 1;\n   A position is skipped if it\
    \ is already occupied by a \"less than 1\"\n   probability symbol.  Position does\
    \ not reset between symbols; it\n   simply iterates through each position in the\
    \ table, switching to the\n   next symbol when enough states have been allocated\
    \ to the current\n   one.\n   The result is a list of state values.  Each state\
    \ will decode the\n   current symbol.\n   To get the Number_of_Bits and Baseline\
    \ required for the next state,\n   it is first necessary to sort all states in\
    \ their natural order.  The\n   lower states will need 1 more bit than higher\
    \ ones.  The process is\n   repeated for each symbol.\n   For example, presuming\
    \ a symbol has a probability of 5, it receives\n   five state values.  States\
    \ are sorted in natural order.  The next\n   power of 2 is 8.  The space of probabilities\
    \ is divided into 8 equal\n   parts.  Presuming the Accuracy_Log is 7, this defines\
    \ 128 states, and\n   each share (divided by 8) is 16 in size.  In order to reach\
    \ 8, 8 - 5\n   = 3 lowest states will count \"double\", doubling the number of\
    \ shares\n   (32 in width), requiring 1 more bit in the process.\n   Baseline\
    \ is assigned starting from the higher states using fewer\n   bits, and proceeding\
    \ naturally, then resuming at the first state,\n   each taking its allocated width\
    \ from Baseline.\n     +----------------+-------+-------+--------+------+-------+\n\
    \     |   state order  |   0   |   1   |   2    |  3   |  4    |\n     +----------------+-------+-------+--------+------+-------+\n\
    \     |     width      |   32  |   32  |   32   |  16  |  16   |\n     +----------------+-------+-------+--------+------+-------+\n\
    \     | Number_of_Bits |   5   |   5   |   5    |  4   |  4    |\n     +----------------+-------+-------+--------+------+-------+\n\
    \     |  range number  |   2   |   4   |   6    |  0   |  1    |\n     +----------------+-------+-------+--------+------+-------+\n\
    \     |    Baseline    |   32  |   64  |   96   |  0   |  16   |\n     +----------------+-------+-------+--------+------+-------+\n\
    \     |     range      | 32-63 | 64-95 | 96-127 | 0-15 | 16-31 |\n     +----------------+-------+-------+--------+------+-------+\n\
    \   The next state is determined from the current state by reading the\n   required\
    \ Number_of_Bits and adding the specified Baseline.\n   See Appendix A for the\
    \ results of this process that are applied to\n   the default distributions.\n"
- title: 4.2.  Huffman Coding
  contents:
  - "4.2.  Huffman Coding\n   Zstandard Huffman-coded streams are read backwards,\
    \ similar to the\n   FSE bitstreams.  Therefore, to find the start of the bitstream,\
    \ it is\n   necessary to know the offset of the last byte of the Huffman-coded\n\
    \   stream.\n   After writing the last bit containing information, the compressor\n\
    \   writes a single 1 bit and then fills the byte with 0-7 0 bits of\n   padding.\
    \  The last byte of the compressed bitstream cannot be 0 for\n   that reason.\n\
    \   When decompressing, the last byte containing the padding is the first\n  \
    \ byte to read.  The decompressor needs to skip 0-7 initial 0 bits and\n   the\
    \ first 1 bit that occurs.  Afterwards, the useful part of the\n   bitstream begins.\n\
    \   The bitstream contains Huffman-coded symbols in little-endian order,\n   with\
    \ the codes defined by the method below.\n"
- title: 4.2.1.  Huffman Tree Description
  contents:
  - "4.2.1.  Huffman Tree Description\n   Prefix coding represents symbols from an\
    \ a priori known alphabet by\n   bit sequences (codewords), one codeword for each\
    \ symbol, in a manner\n   such that different symbols may be represented by bit\
    \ sequences of\n   different lengths, but a parser can always parse an encoded\
    \ string\n   unambiguously symbol by symbol.\n   Given an alphabet with known\
    \ symbol frequencies, the Huffman\n   algorithm allows the construction of an\
    \ optimal prefix code using the\n   fewest bits of any possible prefix codes for\
    \ that alphabet.\n   The prefix code must not exceed a maximum code length.  More\
    \ bits\n   improve accuracy but yield a larger header size and require more\n\
    \   memory or more complex decoding operations.  This specification\n   limits\
    \ the maximum code length to 11 bits.\n   All literal values from zero (included)\
    \ to the last present one\n   (excluded) are represented by Weight with values\
    \ from 0 to\n   Max_Number_of_Bits.  Transformation from Weight to Number_of_Bits\n\
    \   follows this pseudocode:\n     if Weight == 0\n       Number_of_Bits = 0\n\
    \     else\n       Number_of_Bits = Max_Number_of_Bits + 1 - Weight\n   The last\
    \ symbol's Weight is deduced from previously decoded ones, by\n   completing to\
    \ the nearest power of 2.  This power of 2 gives\n   Max_Number_of_Bits the depth\
    \ of the current tree.\n   For example, presume the following Huffman tree must\
    \ be described:\n     +---------------+----------------+\n     | Literal Value\
    \ | Number_of_Bits |\n     +---------------+----------------+\n     |       0\
    \       |        1       |\n     +---------------+----------------+\n     |  \
    \     1       |        2       |\n     +---------------+----------------+\n  \
    \   |       2       |        3       |\n     +---------------+----------------+\n\
    \     |       3       |        0       |\n     +---------------+----------------+\n\
    \     |       4       |        4       |\n     +---------------+----------------+\n\
    \     |       5       |        4       |\n     +---------------+----------------+\n\
    \   The tree depth is 4, since its longest element uses 4 bits.  (The\n   longest\
    \ elements are those with the smallest frequencies.)  Value 5\n   will not be\
    \ listed as it can be determined from the values for 0-4,\n   nor will values\
    \ above 5 as they are all 0.  Values from 0 to 4 will\n   be listed using Weight\
    \ instead of Number_of_Bits.  The pseudocode to\n   determine Weight is:\n   \
    \  if Number_of_Bits == 0\n       Weight = 0\n     else\n       Weight = Max_Number_of_Bits\
    \ + 1 - Number_of_Bits\n   It gives the following series of weights:\n     +---------------+--------+\n\
    \     | Literal Value | Weight |\n     +---------------+--------+\n     |    \
    \   0       |   4    |\n     +---------------+--------+\n     |       1      \
    \ |   3    |\n     +---------------+--------+\n     |       2       |   2    |\n\
    \     +---------------+--------+\n     |       3       |   0    |\n     +---------------+--------+\n\
    \     |       4       |   1    |\n     +---------------+--------+\n   The decoder\
    \ will do the inverse operation: having collected weights\n   of literals from\
    \ 0 to 4, it knows the last literal, 5, is present\n   with a non-zero Weight.\
    \  The Weight of 5 can be determined by\n   advancing to the next power of 2.\
    \  The sum of 2^(Weight-1) (excluding\n   0's) is 15.  The nearest power of 2\
    \ is 16.  Therefore,\n   Max_Number_of_Bits = 4 and Weight[5] = 16 - 15 = 1.\n"
- title: 4.2.1.1.  Huffman Tree Header
  contents:
  - "4.2.1.1.  Huffman Tree Header\n   This is a single byte value (0-255), which\
    \ describes how the series\n   of weights is encoded.\n   headerByte < 128:  The\
    \ series of weights is compressed using FSE (see\n      below).  The length of\
    \ the FSE-compressed series is equal to\n      headerByte (0-127).\n   headerByte\
    \ >= 128:  This is a direct representation, where each\n      Weight is written\
    \ directly as a 4-bit field (0-15).  They are\n      encoded forward, 2 weights\
    \ to a byte with the first weight taking\n      the top 4 bits and the second\
    \ taking the bottom 4; for example,\n      the following operations could be used\
    \ to read the weights:\n     Weight[0] = (Byte[0] >> 4)\n     Weight[1] = (Byte[0]\
    \ & 0xf),\n     etc.\n      The full representation occupies ceiling(Number_of_Symbols/2)\n\
    \      bytes, meaning it uses only full bytes even if Number_of_Symbols\n    \
    \  is odd.  Number_of_Symbols = headerByte - 127.  Note that maximum\n      Number_of_Symbols\
    \ is 255 - 127 = 128.  If any literal has a value\n      over 128, raw header\
    \ mode is not possible, and it is necessary to\n      use FSE compression.\n"
- title: 4.2.1.2.  FSE Compression of Huffman Weights
  contents:
  - "4.2.1.2.  FSE Compression of Huffman Weights\n   In this case, the series of\
    \ Huffman weights is compressed using FSE\n   compression.  It is a single bitstream\
    \ with two interleaved states,\n   sharing a single distribution table.\n   To\
    \ decode an FSE bitstream, it is necessary to know its compressed\n   size.  Compressed\
    \ size is provided by headerByte.  It's also\n   necessary to know its maximum\
    \ possible decompressed size, which is\n   255, since literal values span from\
    \ 0 to 255, and the last symbol's\n   Weight is not represented.\n   An FSE bitstream\
    \ starts by a header, describing probabilities\n   distribution.  It will create\
    \ a decoding table.  For a list of\n   Huffman weights, the maximum accuracy log\
    \ is 6 bits.  For more\n   details, see Section 4.1.1.\n   The Huffman header\
    \ compression uses two states, which share the same\n   FSE distribution table.\
    \  The first state (State1) encodes the even-\n   numbered index symbols, and\
    \ the second (State2) encodes the odd-\n   numbered index symbols.  State1 is\
    \ initialized first, and then\n   State2, and they take turns decoding a single\
    \ symbol and updating\n   their state.  For more details on these FSE operations,\
    \ see\n   Section 4.1.\n   The number of symbols to be decoded is determined by\
    \ tracking the\n   bitStream overflow condition: If updating state after decoding\
    \ a\n   symbol would require more bits than remain in the stream, it is\n   assumed\
    \ that extra bits are zero.  Then, symbols for each of the\n   final states are\
    \ decoded and the process is complete.\n"
- title: 4.2.1.3.  Conversion from Weights to Huffman Prefix Codes
  contents:
  - "4.2.1.3.  Conversion from Weights to Huffman Prefix Codes\n   All present symbols\
    \ will now have a Weight value.  It is possible to\n   transform weights into\
    \ Number_of_Bits, using this formula:\n     if Weight > 0\n         Number_of_Bits\
    \ = Max_Number_of_Bits + 1 - Weight\n     else\n         Number_of_Bits = 0\n\
    \   Symbols are sorted by Weight.  Within the same Weight, symbols keep\n   natural\
    \ sequential order.  Symbols with a Weight of zero are removed.\n   Then, starting\
    \ from the lowest Weight, prefix codes are distributed\n   in sequential order.\n\
    \   For example, assume the following list of weights has been decoded:\n    \
    \ +---------+--------+\n     | Literal | Weight |\n     +---------+--------+\n\
    \     |    0    |   4    |\n     +---------+--------+\n     |    1    |   3  \
    \  |\n     +---------+--------+\n     |    2    |   2    |\n     +---------+--------+\n\
    \     |    3    |   0    |\n     +---------+--------+\n     |    4    |   1  \
    \  |\n     +---------+--------+\n     |    5    |   1    |\n     +---------+--------+\n\
    \   Sorting by weight and then the natural sequential order yields the\n   following\
    \ distribution:\n     +---------+--------+----------------+--------------+\n \
    \    | Literal | Weight | Number_Of_Bits | Prefix Codes |\n     +---------+--------+----------------|--------------+\n\
    \     |    3    |   0    |        0       |      N/A     |\n     +---------+--------+----------------|--------------+\n\
    \     |    4    |   1    |        4       |     0000     |\n     +---------+--------+----------------|--------------+\n\
    \     |    5    |   1    |        4       |     0001     |\n     +---------+--------+----------------|--------------+\n\
    \     |    2    |   2    |        3       |      001     |\n     +---------+--------+----------------|--------------+\n\
    \     |    1    |   3    |        2       |       01     |\n     +---------+--------+----------------|--------------+\n\
    \     |    0    |   4    |        1       |        1     |\n     +---------+--------+----------------|--------------+\n"
- title: 4.2.2.  Huffman-Coded Streams
  contents:
  - "4.2.2.  Huffman-Coded Streams\n   Given a Huffman decoding table, it is possible\
    \ to decode a Huffman-\n   coded stream.\n   Each bitstream must be read backward,\
    \ which starts from the end and\n   goes up to the beginning.  Therefore, it is\
    \ necessary to know the\n   size of each bitstream.\n   It is also necessary to\
    \ know exactly which bit is the last.  This is\n   detected by a final bit flag:\
    \ the highest bit of the last byte is a\n   final-bit-flag.  Consequently, a last\
    \ byte of 0 is not possible.  And\n   the final-bit-flag itself is not part of\
    \ the useful bitstream.\n   Hence, the last byte contains between 0 and 7 useful\
    \ bits.\n   Starting from the end, it is possible to read the bitstream in a\n\
    \   little-endian fashion, keeping track of already used bits.  Since the\n  \
    \ bitstream is encoded in reverse order, starting from the end, read\n   symbols\
    \ in forward order.\n   For example, if the literal sequence \"0145\" was encoded\
    \ using the\n   above prefix code, it would be encoded (in reverse order) as:\n\
    \     +---------+----------+\n     | Symbol  | Encoding |\n     +---------+----------+\n\
    \     |    5    |   0000   |\n     +---------+----------+\n     |    4    |  \
    \ 0001   |\n     +---------+----------+\n     |    1    |    01    |\n     +---------+----------+\n\
    \     |    0    |    1     |\n     +---------+----------+\n     | Padding |  \
    \ 00001  |\n     +---------+----------+\n   This results in the following 2-byte\
    \ bitstream:\n     00010000 00001101\n   Here is an alternative representation\
    \ with the symbol codes separated\n   by underscores:\n     0001_0000 00001_1_01\n\
    \   Reading the highest Max_Number_of_Bits bits, it's possible to compare\n  \
    \ the extracted value to the decoding table, determining the symbol to\n   decode\
    \ and number of bits to discard.\n   The process continues reading up to the required\
    \ number of symbols\n   per stream.  If a bitstream is not entirely and exactly\
    \ consumed,\n   hence reaching exactly its beginning position with all bits consumed,\n\
    \   the decoding process is considered faulty.\n"
- title: 5.  Dictionary Format
  contents:
  - "5.  Dictionary Format\n   Zstandard is compatible with \"raw content\" dictionaries,\
    \ free of any\n   format restriction, except that they must be at least 8 bytes.\
    \  These\n   dictionaries function as if they were just the content part of a\n\
    \   formatted dictionary.\n   However, dictionaries created by \"zstd --train\"\
    \ in the reference\n   implementation follow a specific format, described here.\n\
    \   Dictionaries are not included in the compressed content but rather\n   are\
    \ provided out of band.  That is, the Dictionary_ID identifies\n   which should\
    \ be used, but this specification does not describe the\n   mechanism by which\
    \ the dictionary is obtained prior to use during\n   compression or decompression.\n\
    \   A dictionary has a size, defined either by a buffer limit or a file\n   size.\
    \  The general format is:\n     +--------------+---------------+----------------+---------+\n\
    \     | Magic_Number | Dictionary_ID | Entropy_Tables | Content |\n     +--------------+---------------+----------------+---------+\n\
    \   Magic_Number:  4 bytes ID, value 0xEC30A437, little-endian format.\n   Dictionary_ID:\
    \  4 bytes, stored in little-endian format.\n      Dictionary_ID can be any value,\
    \ except 0 (which means no\n      Dictionary_ID).  It is used by decoders to check\
    \ if they use the\n      correct dictionary.  If the frame is going to be distributed\
    \ in a\n      private environment, any Dictionary_ID can be used.  However, for\n\
    \      public distribution of compressed frames, the following ranges are\n  \
    \    reserved and shall not be used:\n         low range: <= 32767\n         high\
    \ range: >= (2^31)\n   Entropy_Tables:  Follow the same format as the tables in\
    \ compressed\n      blocks.  See the relevant FSE and Huffman sections for how\
    \ to\n      decode these tables.  They are stored in the following order:\n  \
    \    Huffman table for literals, FSE table for offsets, FSE table for\n      match\
    \ lengths, and FSE table for literals lengths.  These tables\n      populate the\
    \ Repeat Stats literals mode and Repeat distribution\n      mode for sequence\
    \ decoding.  It is finally followed by 3 offset\n      values, populating repeat\
    \ offsets (instead of using {1,4,8}),\n      stored in order, 4-bytes little-endian\
    \ each, for a total of 12\n      bytes.  Each repeat offset must have a value\
    \ less than the\n      dictionary size.\n   Content:  The rest of the dictionary\
    \ is its content.  The content\n      acts as a \"past\" in front of data to be\
    \ compressed or\n      decompressed, so it can be referenced in sequence commands.\
    \  As\n      long as the amount of data decoded from this frame is less than or\n\
    \      equal to Window_Size, sequence commands may specify offsets longer\n  \
    \    than the total length of decoded output so far to reference back\n      to\
    \ the dictionary, even parts of the dictionary with offsets\n      larger than\
    \ Window_Size.  After the total output has surpassed\n      Window_Size, however,\
    \ this is no longer allowed, and the\n      dictionary is no longer accessible.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   IANA has made two registrations, as described below.\n"
- title: 6.1.  The 'application/zstd' Media Type
  contents:
  - "6.1.  The 'application/zstd' Media Type\n   The 'application/zstd' media type\
    \ identifies a block of data that is\n   compressed using zstd compression.  The\
    \ data is a stream of bytes as\n   described in this document.  IANA has added\
    \ the following to the\n   \"Media Types\" registry:\n   Type name:  application\n\
    \   Subtype name:  zstd\n   Required parameters:  N/A\n   Optional parameters:\
    \  N/A\n   Encoding considerations:  binary\n   Security considerations:  See\
    \ Section 7 of RFC 8478\n   Interoperability considerations:  N/A\n   Published\
    \ specification:  RFC 8478\n   Applications that use this media type:  anywhere\
    \ data size is an\n      issue\n   Additional information:\n      Magic number(s):\
    \  4 bytes, little-endian format.\n         Value: 0xFD2FB528\n      File extension(s):\
    \  zst\n      Macintosh file type code(s):  N/A\n   For further information: \
    \ See [ZSTD]\n   Intended usage:  common\n   Restrictions on usage:  N/A\n   Author:\
    \  Murray S.  Kucherawy\n   Change Controller:  IETF\n   Provisional registration:\
    \  no\n"
- title: 6.2.  Content Encoding
  contents:
  - "6.2.  Content Encoding\n   IANA has added the following entry to the \"HTTP Content\
    \ Coding\n   Registry\" within the \"Hypertext Transfer Protocol (HTTP) Parameters\"\
    \n   registry:\n   Name:  zstd\n   Description:  A stream of bytes compressed\
    \ using the Zstandard\n      protocol\n   Pointer to specification text:  RFC\
    \ 8478\n"
- title: 6.3.  Dictionaries
  contents:
  - "6.3.  Dictionaries\n   Work in progress includes development of dictionaries\
    \ that will\n   optimize compression and decompression of particular types of\
    \ data.\n   Specification of such dictionaries for public use will necessitate\n\
    \   registration of a code point from the reserved range described in\n   Section\
    \ 3.1.1.1.3 and its association with a specific dictionary.\n   However, there\
    \ are at present no such dictionaries published for\n   public use, so this document\
    \ makes no immediate request of IANA to\n   create such a registry.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Any data compression method involves the reduction\
    \ of redundancy in\n   the data.  Zstandard is no exception, and the usual precautions\n\
    \   apply.\n   One should never compress a message whose content must remain secret\n\
    \   with a message generated by a third party.  Such a compression can be\n  \
    \ used to guess the content of the secret message through analysis of\n   entropy\
    \ reduction.  This was demonstrated in the Compression Ratio\n   Info-leak Made\
    \ Easy (CRIME) attack [CRIME], for example.\n   A decoder has to demonstrate capabilities\
    \ to detect and prevent any\n   kind of data tampering in the compressed frame\
    \ from triggering system\n   faults, such as reading or writing beyond allowed\
    \ memory ranges.\n   This can be guaranteed by either the implementation language\
    \ or\n   careful bound checkings.  Of particular note is the encoding of\n   Number_of_Sequences\
    \ values that cause the decoder to read into the\n   block header (and beyond),\
    \ as well as the indication of a\n   Frame_Content_Size that is smaller than the\
    \ actual decompressed data,\n   in an attempt to trigger a buffer overflow.  It\
    \ is highly recommended\n   to fuzz-test (i.e., provide invalid, unexpected, or\
    \ random input and\n   verify safe operation of) decoder implementations to test\
    \ and harden\n   their capability to detect bad frames and deal with them without\
    \ any\n   adverse system side effect.\n   An attacker may provide correctly formed\
    \ compressed frames with\n   unreasonable memory requirements.  A decoder must\
    \ always control\n   memory requirements and enforce some (system-specific) limits\
    \ in\n   order to protect memory usage from such scenarios.\n   Compression can\
    \ be optimized by training a dictionary on a variety of\n   related content payloads.\
    \  This dictionary must then be available at\n   the decoder for decompression\
    \ of the payload to be possible.  While\n   this document does not specify how\
    \ to acquire a dictionary for a\n   given compressed payload, it is worth noting\
    \ that third-party\n   dictionaries may interact unexpectedly with a decoder,\
    \ leading to\n   possible memory or other resource exhaustion attacks.  We expect\
    \ such\n   topics to be discussed in further detail in the Security\n   Considerations\
    \ section of a forthcoming RFC for dictionary\n   acquisition and transmission,\
    \ but highlight this issue now out of an\n   abundance of caution.\n   As discussed\
    \ in Section 3.1.2, it is possible to store arbitrary user\n   metadata in skippable\
    \ frames.  While such frames are ignored during\n   decompression of the data,\
    \ they can be used as a watermark to track\n   the path of the compressed payload.\n"
- title: 8.  Implementation Status
  contents:
  - "8.  Implementation Status\n   Source code for a C language implementation of\
    \ a Zstandard-compliant\n   library is available at [ZSTD-GITHUB].  This implementation\
    \ is\n   considered to be the reference implementation and is production\n   ready;\
    \ it implements the full range of the specification.  It is\n   routinely tested\
    \ against security hazards and widely deployed within\n   Facebook infrastructure.\n\
    \   The reference version is optimized for speed and is highly portable.\n   It\
    \ has been proven to run safely on multiple architectures (e.g.,\n   x86, x64,\
    \ ARM, MIPS, PowerPC, IA64) featuring 32- or 64-bit\n   addressing schemes, a\
    \ little- or big-endian storage scheme, a number\n   of different operating systems\
    \ (e.g., UNIX (including Linux, BSD,\n   OS-X, and Solaris) and Windows), and\
    \ a number of compilers (e.g.,\n   gcc, clang, visual, and icc).\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [ZSTD]     \"Zstandard\", <http://www.zstd.net>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [ANS]      Duda, J., \"Asymmetric numeral systems:\
    \ entropy coding\n              combining speed of Huffman coding with compression\
    \ rate of\n              arithmetic coding\", January 2014,\n              <https://arxiv.org/pdf/1311.2540>.\n\
    \   [CRIME]    \"CRIME\", June 2018, <https://en.wikipedia.org/w/\n          \
    \    index.php?title=CRIME&oldid=844538656>.\n   [FSE]      \"FiniteStateEntropy\"\
    , commit 6efa78a, June 2018,\n              <https://github.com/Cyan4973/FiniteStateEntropy/>.\n\
    \   [LZ4]      \"LZ4 Frame Format Description\", commit d03224b, January\n   \
    \           2018, <https://github.com/lz4/lz4/blob/master/doc/\n             \
    \ lz4_Frame_format.md>.\n   [RFC1952]  Deutsch, P., \"GZIP file format specification\
    \ version 4.3\",\n              RFC 1952, DOI 10.17487/RFC1952, May 1996,\n  \
    \            <https://www.rfc-editor.org/info/rfc1952>.\n   [XXHASH]   \"XXHASH\
    \ Algorithm\", <http://www.xxhash.org>.\n   [ZSTD-GITHUB]\n              \"zstd\"\
    , commit 8514bd8, August 2018,\n              <https://github.com/facebook/zstd>.\n"
- title: Appendix A.  Decoding Tables for Predefined Codes
  contents:
  - "Appendix A.  Decoding Tables for Predefined Codes\n   This appendix contains\
    \ FSE decoding tables for the predefined literal\n   length, match length, and\
    \ offset codes.  The tables have been\n   constructed using the algorithm as given\
    \ above in Section 4.1.1.  The\n   tables here can be used as examples to crosscheck\
    \ that an\n   implementation has built its decoding tables correctly.\n"
- title: A.1.  Literal Length Code Table
  contents:
  - "A.1.  Literal Length Code Table\n     +-------+--------+----------------+------+\n\
    \     | State | Symbol | Number_Of_Bits | Base |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        0       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    1  |    0   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |    2  |    1   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |    3  |    3   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    4  |    4   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    5  |    6   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    6  |    7   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    7  |    9   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    8  |   10   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    9  |   12   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   10  |   14   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   11  |   16   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   12  |   18   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   13  |   19   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   14  |   21   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   15  |   22   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   16  |   24   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   17  |   25   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   18  |   26   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   19  |   27   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   20  |   29   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   21  |   31   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   22  |    0   |        4       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   23  |    1   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   24  |    2   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   25  |    4   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   26  |    5   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   27  |    7   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   28  |    8   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   29  |   10   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   30  |   11   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   31  |   13   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   32  |   16   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   33  |   17   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   34  |   19   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   35  |   20   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   36  |   22   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   37  |   23   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   38  |   25   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   39  |   25   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   40  |   26   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   41  |   28   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   42  |   30   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   43  |    0   |        4       |  48  |\n     +-------+--------+----------------+------+\n\
    \     |   44  |    1   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   45  |    2   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   46  |    3   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   47  |    5   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   48  |    6   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   49  |    8   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   50  |    9   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   51  |   11   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   52  |   12   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   53  |   15   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   54  |   17   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   55  |   18   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   56  |   20   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   57  |   21   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   58  |   23   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   59  |   24   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   60  |   35   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   61  |   34   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   62  |   33   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   63  |   32   |        6       |   0  |\n     +-------+--------+----------------+------+\n"
- title: A.2.  Match Length Code Table
  contents:
  - "A.2.  Match Length Code Table\n     +-------+--------+----------------+------+\n\
    \     | State | Symbol | Number_Of_Bits | Base |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        0       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    1  |    1   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    2  |    2   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |    3  |    3   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    4  |    5   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    5  |    6   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    6  |    8   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    7  |   10   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    8  |   13   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    9  |   16   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   10  |   19   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   11  |   22   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   12  |   25   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   13  |   28   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   14  |   31   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   15  |   33   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   16  |   35   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   17  |   37   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   18  |   39   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   19  |   41   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   20  |   43   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   21  |   45   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   22  |    1   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   23  |    2   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   24  |    3   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   25  |    4   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   26  |    6   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   27  |    7   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   28  |    9   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   29  |   12   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   30  |   15   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   31  |   18   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   32  |   21   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   33  |   24   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   34  |   27   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   35  |   30   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   36  |   32   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   37  |   34   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   38  |   36   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   39  |   38   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   40  |   40   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   41  |   42   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   42  |   44   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   43  |    1   |        4       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   44  |    1   |        4       |  48  |\n     +-------+--------+----------------+------+\n\
    \     |   45  |    2   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   46  |    4   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   47  |    5   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   48  |    7   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   49  |    8   |        5       |  32  |\n     +-------+--------+----------------+------+\n\
    \     |   50  |   11   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   51  |   14   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   52  |   17   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   53  |   20   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   54  |   23   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   55  |   26   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   56  |   29   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   57  |   52   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   58  |   51   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   59  |   50   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   60  |   49   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   61  |   48   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   62  |   47   |        6       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   63  |   46   |        6       |   0  |\n     +-------+--------+----------------+------+\n"
- title: A.3.  Offset Code Table
  contents:
  - "A.3.  Offset Code Table\n     +-------+--------+----------------+------+\n  \
    \   | State | Symbol | Number_Of_Bits | Base |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        0       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    0  |    0   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    1  |    6   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    2  |    9   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    3  |   15   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    4  |   21   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    5  |    3   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    6  |    7   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    7  |   12   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    8  |   18   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |    9  |   23   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   10  |    5   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   11  |    8   |        4       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   12  |   14   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   13  |   20   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   14  |    2   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   15  |    7   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   16  |   11   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   17  |   17   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   18  |   22   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   19  |    4   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   20  |    8   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   21  |   13   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   22  |   19   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   23  |    1   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   24  |    6   |        4       |  16  |\n     +-------+--------+----------------+------+\n\
    \     |   25  |   10   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   26  |   16   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   27  |   28   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   28  |   27   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   29  |   26   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   30  |   25   |        5       |   0  |\n     +-------+--------+----------------+------+\n\
    \     |   31  |   24   |        5       |   0  |\n     +-------+--------+----------------+------+\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   zstd was developed by Yann Collet.\n   Bobo Bose-Kolanu,\
    \ Felix Handte, Kyle Nekritz, Nick Terrell, and David\n   Schleimer provided helpful\
    \ feedback during the development of this\n   document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Yann Collet\n   Facebook\n   1 Hacker Way\n   Menlo Park,\
    \ CA  94025\n   United States of America\n   Email: cyan@fb.com\n   Murray S.\
    \ Kucherawy (editor)\n   Facebook\n   1 Hacker Way\n   Menlo Park, CA  94025\n\
    \   United States of America\n   Email: msk@fb.com\n"
