- title: __initial_text__
  contents:
  - '           OAuth 2.0 Threat Model and Security Considerations

    '
- title: Abstract
  contents:
  - "Abstract\n   This document gives additional security considerations for OAuth,\n\
    \   beyond those in the OAuth 2.0 specification, based on a comprehensive\n  \
    \ threat model for the OAuth 2.0 protocol.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6819.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................6\n\
    \   2. Overview ........................................................7\n  \
    \    2.1. Scope ......................................................7\n    \
    \  2.2. Attack Assumptions .........................................7\n      2.3.\
    \ Architectural Assumptions ..................................8\n           2.3.1.\
    \ Authorization Servers ...............................8\n           2.3.2. Resource\
    \ Server .....................................9\n           2.3.3. Client ..............................................9\n\
    \   3. Security Features ...............................................9\n  \
    \    3.1. Tokens ....................................................10\n    \
    \       3.1.1. Scope ..............................................11\n      \
    \     3.1.2. Limited Access Token Lifetime ......................11\n      3.2.\
    \ Access Token ..............................................11\n      3.3. Refresh\
    \ Token .............................................11\n      3.4. Authorization\
    \ \"code\" ......................................12\n      3.5. Redirect URI ..............................................13\n\
    \      3.6. \"state\" Parameter .........................................13\n\
    \      3.7. Client Identifier .........................................13\n  \
    \ 4. Threat Model ...................................................15\n    \
    \  4.1. Clients ...................................................16\n      \
    \     4.1.1. Threat: Obtaining Client Secrets ...................16\n        \
    \   4.1.2. Threat: Obtaining Refresh Tokens ...................17\n          \
    \ 4.1.3. Threat: Obtaining Access Tokens ....................19\n           4.1.4.\
    \ Threat: End-User Credentials Phished Using\n                  Compromised or\
    \ Embedded Browser ....................19\n           4.1.5. Threat: Open Redirectors\
    \ on Client .................20\n      4.2. Authorization Endpoint ....................................21\n\
    \           4.2.1. Threat: Password Phishing by Counterfeit\n                \
    \  Authorization Server ...............................21\n           4.2.2. Threat:\
    \ User Unintentionally Grants Too\n                  Much Access Scope ..................................21\n\
    \           4.2.3. Threat: Malicious Client Obtains Existing\n               \
    \   Authorization by Fraud .............................22\n           4.2.4.\
    \ Threat: Open Redirector ............................22\n      4.3. Token Endpoint\
    \ ............................................23\n           4.3.1. Threat: Eavesdropping\
    \ Access Tokens ................23\n           4.3.2. Threat: Obtaining Access\
    \ Tokens from\n                  Authorization Server Database ......................23\n\
    \           4.3.3. Threat: Disclosure of Client Credentials\n                \
    \  during Transmission ................................23\n           4.3.4. Threat:\
    \ Obtaining Client Secret from\n                  Authorization Server Database\
    \ ......................24\n           4.3.5. Threat: Obtaining Client Secret\
    \ by Online Guessing .24\n      4.4. Obtaining Authorization ...................................25\n\
    \           4.4.1. Authorization \"code\" ...............................25\n\
    \                  4.4.1.1. Threat: Eavesdropping or Leaking\n               \
    \            Authorization \"codes\" .....................25\n               \
    \   4.4.1.2. Threat: Obtaining Authorization \"codes\"\n                     \
    \      from Authorization Server Database ........26\n                  4.4.1.3.\
    \ Threat: Online Guessing of\n                           Authorization \"codes\"\
    \ .....................27\n                  4.4.1.4. Threat: Malicious Client\
    \ Obtains\n                           Authorization .............................27\n\
    \                  4.4.1.5. Threat: Authorization \"code\" Phishing .....29\n\
    \                  4.4.1.6. Threat: User Session Impersonation ........29\n  \
    \                4.4.1.7. Threat: Authorization \"code\" Leakage\n           \
    \                through Counterfeit Client ................30\n             \
    \     4.4.1.8. Threat: CSRF Attack against redirect-uri ..32\n               \
    \   4.4.1.9. Threat: Clickjacking Attack against\n                           Authorization\
    \ .............................33\n                  4.4.1.10. Threat: Resource\
    \ Owner Impersonation .....33\n                  4.4.1.11. Threat: DoS Attacks\
    \ That Exhaust\n                            Resources ................................34\n\
    \                  4.4.1.12. Threat: DoS Using Manufactured\n                \
    \            Authorization \"codes\" ....................35\n                \
    \  4.4.1.13. Threat: Code Substitution (OAuth Login) ..36\n           4.4.2. Implicit\
    \ Grant .....................................37\n                  4.4.2.1. Threat:\
    \ Access Token Leak in\n                           Transport/Endpoints .......................37\n\
    \                  4.4.2.2. Threat: Access Token Leak in\n                   \
    \        Browser History ...........................38\n                  4.4.2.3.\
    \ Threat: Malicious Client Obtains\n                           Authorization .............................38\n\
    \                  4.4.2.4. Threat: Manipulation of Scripts ...........38\n  \
    \                4.4.2.5. Threat: CSRF Attack against redirect-uri ..39\n    \
    \              4.4.2.6. Threat: Token Substitution (OAuth Login) ..39\n      \
    \     4.4.3. Resource Owner Password Credentials ................40\n        \
    \          4.4.3.1. Threat: Accidental Exposure of\n                         \
    \  Passwords at Client Site ..................41\n                  4.4.3.2. Threat:\
    \ Client Obtains Scopes\n                           without End-User Authorization\
    \ ............42\n                  4.4.3.3. Threat: Client Obtains Refresh\n\
    \                           Token through Automatic Authorization .....42\n  \
    \                4.4.3.4. Threat: Obtaining User Passwords\n                 \
    \          on Transport ..............................43\n                  4.4.3.5.\
    \ Threat: Obtaining User Passwords\n                           from Authorization\
    \ Server Database ........43\n                  4.4.3.6. Threat: Online Guessing\
    \ ...................43\n           4.4.4. Client Credentials .................................44\n\
    \      4.5. Refreshing an Access Token ................................44\n  \
    \         4.5.1. Threat: Eavesdropping Refresh Tokens from\n                 \
    \ Authorization Server ...............................44\n           4.5.2. Threat:\
    \ Obtaining Refresh Token from\n                  Authorization Server Database\
    \ ......................44\n           4.5.3. Threat: Obtaining Refresh Token\
    \ by Online\n                  Guessing ...........................................45\n\
    \           4.5.4. Threat: Refresh Token Phishing by\n                  Counterfeit\
    \ Authorization Server ...................45\n      4.6. Accessing Protected Resources\
    \ .............................46\n           4.6.1. Threat: Eavesdropping Access\
    \ Tokens on Transport ...46\n           4.6.2. Threat: Replay of Authorized Resource\n\
    \                  Server Requests ....................................46\n  \
    \         4.6.3. Threat: Guessing Access Tokens .....................46\n    \
    \       4.6.4. Threat: Access Token Phishing by\n                  Counterfeit\
    \ Resource Server ........................47\n           4.6.5. Threat: Abuse\
    \ of Token by Legitimate\n                  Resource Server or Client ..........................48\n\
    \           4.6.6. Threat: Leak of Confidential Data in HTTP Proxies ..48\n  \
    \         4.6.7. Threat: Token Leakage via Log Files and\n                  HTTP\
    \ Referrers .....................................48\n   5. Security Considerations\
    \ ........................................49\n      5.1. General ...................................................49\n\
    \           5.1.1. Ensure Confidentiality of Requests .................49\n  \
    \         5.1.2. Utilize Server Authentication ......................50\n    \
    \       5.1.3. Always Keep the Resource Owner Informed ............50\n      \
    \     5.1.4. Credentials ........................................51\n        \
    \          5.1.4.1. Enforce Credential Storage\n                           Protection\
    \ Best Practices .................51\n                  5.1.4.2. Online Attacks\
    \ on Secrets .................52\n           5.1.5. Tokens (Access, Refresh, Code)\
    \ .....................53\n                  5.1.5.1. Limit Token Scope .........................53\n\
    \                  5.1.5.2. Determine Expiration Time .................54\n  \
    \                5.1.5.3. Use Short Expiration Time .................54\n    \
    \              5.1.5.4. Limit Number of Usages or One-Time Usage ..55\n      \
    \            5.1.5.5. Bind Tokens to a Particular\n                          \
    \ Resource Server (Audience) ................55\n                  5.1.5.6. Use\
    \ Endpoint Address as Token Audience ....56\n                  5.1.5.7. Use Explicitly\
    \ Defined Scopes for\n                           Audience and Tokens .......................56\n\
    \                  5.1.5.8. Bind Token to Client id ...................56\n  \
    \                5.1.5.9. Sign Self-Contained Tokens ................56\n    \
    \              5.1.5.10. Encrypt Token Content ....................56\n      \
    \            5.1.5.11. Adopt a Standard Assertion Format ........57\n        \
    \   5.1.6. Access Tokens ......................................57\n      5.2.\
    \ Authorization Server ......................................57\n           5.2.1.\
    \ Authorization \"codes\" ..............................57\n                 \
    \ 5.2.1.1. Automatic Revocation of Derived\n                           Tokens\
    \ If Abuse Is Detected ...............57\n           5.2.2. Refresh Tokens .....................................57\n\
    \                  5.2.2.1. Restricted Issuance of Refresh Tokens .....57\n  \
    \                5.2.2.2. Binding of Refresh Token to \"client_id\" ...58\n  \
    \                5.2.2.3. Refresh Token Rotation ....................58\n    \
    \              5.2.2.4. Revocation of Refresh Tokens ..............58\n      \
    \            5.2.2.5. Device Identification .....................59\n        \
    \          5.2.2.6. X-FRAME-OPTIONS Header ....................59\n          \
    \ 5.2.3. Client Authentication and Authorization ............59\n            \
    \      5.2.3.1. Don't Issue Secrets to Clients with\n                        \
    \   Inappropriate Security Policy .............60\n                  5.2.3.2.\
    \ Require User Consent for Public\n                           Clients without\
    \ Secret ....................60\n                  5.2.3.3. Issue a \"client_id\"\
    \ Only in\n                           Combination with \"redirect_uri\" ...........61\n\
    \                  5.2.3.4. Issue Installation-Specific Client\n             \
    \              Secrets ...................................61\n               \
    \   5.2.3.5. Validate Pre-Registered \"redirect_uri\" ....62\n               \
    \   5.2.3.6. Revoke Client Secrets .....................63\n                 \
    \ 5.2.3.7. Use Strong Client Authentication\n                           (e.g.,\
    \ client_assertion/client_token) .....63\n           5.2.4. End-User Authorization\
    \ .............................63\n                  5.2.4.1. Automatic Processing\
    \ of Repeated\n                           Authorizations Requires Client Validation\
    \ .63\n                  5.2.4.2. Informed Decisions Based on Transparency ..63\n\
    \                  5.2.4.3. Validation of Client Properties by\n             \
    \              End User ..................................64\n               \
    \   5.2.4.4. Binding of Authorization \"code\" to\n                          \
    \ \"client_id\" ...............................64\n                  5.2.4.5.\
    \ Binding of Authorization \"code\" to\n                           \"redirect_uri\"\
    \ ............................64\n      5.3. Client App Security .......................................65\n\
    \           5.3.1. Don't Store Credentials in Code or\n                  Resources\
    \ Bundled with Software Packages ...........65\n           5.3.2. Use Standard\
    \ Web Server Protection Measures\n                  (for Config Files and Databases)\
    \ ...................65\n           5.3.3. Store Secrets in Secure Storage ....................65\n\
    \           5.3.4. Utilize Device Lock to Prevent Unauthorized\n             \
    \     Device Access ......................................66\n           5.3.5.\
    \ Link the \"state\" Parameter to User Agent Session ...66\n      5.4. Resource\
    \ Servers ..........................................66\n           5.4.1. Authorization\
    \ Headers ..............................66\n           5.4.2. Authenticated Requests\
    \ .............................67\n           5.4.3. Signed Requests ....................................67\n\
    \      5.5. A Word on User Interaction and User-Installed Apps ........68\n  \
    \ 6. Acknowledgements ...............................................69\n   7.\
    \ References .....................................................69\n      7.1.\
    \ Normative References ......................................69\n      7.2. Informative\
    \ References ....................................69\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document gives additional security considerations for\
    \ OAuth,\n   beyond those in the OAuth specification, based on a comprehensive\n\
    \   threat model for the OAuth 2.0 protocol [RFC6749].  It contains the\n   following\
    \ content:\n   o  Documents any assumptions and scope considered when creating\
    \ the\n      threat model.\n   o  Describes the security features built into the\
    \ OAuth protocol and\n      how they are intended to thwart attacks.\n   o  Gives\
    \ a comprehensive threat model for OAuth and describes the\n      respective countermeasures\
    \ to thwart those threats.\n   Threats include any intentional attacks on OAuth\
    \ tokens and resources\n   protected by OAuth tokens, as well as security risks\
    \ introduced if\n   the proper security measures are not put in place.  Threats\
    \ are\n   structured along the lines of the protocol structure to help\n   development\
    \ teams implement each part of the protocol securely, for\n   example, all threats\
    \ for granting access, or all threats for a\n   particular grant type, or all\
    \ threats for protecting the resource\n   server.\n   Note: This document cannot\
    \ assess the probability or the risk\n   associated with a particular threat because\
    \ those aspects strongly\n   depend on the particular application and deployment\
    \ OAuth is used to\n   protect.  Similarly, impacts are given on a rather abstract\
    \ level.\n   But the information given here may serve as a foundation for\n  \
    \ deployment-specific threat models.  Implementors may refine and\n   detail the\
    \ abstract threat model in order to account for the specific\n   properties of\
    \ their deployment and to come up with a risk analysis.\n   As this document is\
    \ based on the base OAuth 2.0 specification, it\n   does not consider proposed\
    \ extensions such as client registration or\n   discovery, many of which are still\
    \ under discussion.\n"
- title: 2.  Overview
  contents:
  - '2.  Overview

    '
- title: 2.1.  Scope
  contents:
  - "2.1.  Scope\n   This security considerations document only considers clients\
    \ bound to\n   a particular deployment as supported by [RFC6749].  Such deployments\n\
    \   have the following characteristics:\n   o  Resource server URLs are static\
    \ and well-known at development\n      time; authorization server URLs can be\
    \ static or discovered.\n   o  Token scope values (e.g., applicable URLs and methods)\
    \ are well-\n      known at development time.\n   o  Client registration is out\
    \ of scope of the current core\n      specification.  Therefore, this document\
    \ assumes a broad variety\n      of options, from static registration during development\
    \ time to\n      dynamic registration at runtime.\n   The following are considered\
    \ out of scope:\n   o  Communication between the authorization server and resource\n\
    \      server.\n   o  Token formats.\n   o  Except for the resource owner password\
    \ credentials grant type (see\n      [RFC6749], Section 4.3), the mechanism used\
    \ by authorization\n      servers to authenticate the user.\n   o  Mechanism by\
    \ which a user obtained an assertion and any resulting\n      attacks mounted\
    \ as a result of the assertion being false.\n   o  Clients not bound to a specific\
    \ deployment: An example could be a\n      mail client with support for contact\
    \ list access via the portable\n      contacts API (see [Portable-Contacts]).\
    \  Such clients cannot be\n      registered upfront with a particular deployment\
    \ and should\n      dynamically discover the URLs relevant for the OAuth protocol.\n"
- title: 2.2.  Attack Assumptions
  contents:
  - "2.2.  Attack Assumptions\n   The following assumptions relate to an attacker\
    \ and resources\n   available to an attacker.  It is assumed that:\n   o  the\
    \ attacker has full access to the network between the client and\n      authorization\
    \ servers and the client and the resource server,\n      respectively.  The attacker\
    \ may eavesdrop on any communications\n      between those parties.  He is not\
    \ assumed to have access to\n      communication between the authorization server\
    \ and resource\n      server.\n   o  an attacker has unlimited resources to mount\
    \ an attack.\n   o  two of the three parties involved in the OAuth protocol may\n\
    \      collude to mount an attack against the 3rd party.  For example,\n     \
    \ the client and authorization server may be under control of an\n      attacker\
    \ and collude to trick a user to gain access to resources.\n"
- title: 2.3.  Architectural Assumptions
  contents:
  - "2.3.  Architectural Assumptions\n   This section documents assumptions about\
    \ the features, limitations,\n   and design options of the different entities\
    \ of an OAuth deployment\n   along with the security-sensitive data elements managed\
    \ by those\n   entities.  These assumptions are the foundation of the threat\n\
    \   analysis.\n   The OAuth protocol leaves deployments with a certain degree\
    \ of\n   freedom regarding how to implement and apply the standard.  The core\n\
    \   specification defines the core concepts of an authorization server\n   and\
    \ a resource server.  Both servers can be implemented in the same\n   server entity,\
    \ or they may also be different entities.  The latter is\n   typically the case\
    \ for multi-service providers with a single\n   authentication and authorization\
    \ system and is more typical in\n   middleware architectures.\n"
- title: 2.3.1.  Authorization Servers
  contents:
  - "2.3.1.  Authorization Servers\n   The following data elements are stored or accessible\
    \ on the\n   authorization server:\n   o  usernames and passwords\n   o  client\
    \ ids and secrets\n   o  client-specific refresh tokens\n   o  client-specific\
    \ access tokens (in the case of handle-based design;\n      see Section 3.1)\n\
    \   o  HTTPS certificate/key\n   o  per-authorization process (in the case of\
    \ handle-based design;\n      Section 3.1): \"redirect_uri\", \"client_id\", authorization\
    \ \"code\"\n"
- title: 2.3.2.  Resource Server
  contents:
  - "2.3.2.  Resource Server\n   The following data elements are stored or accessible\
    \ on the resource\n   server:\n   o  user data (out of scope)\n   o  HTTPS certificate/key\n\
    \   o  either authorization server credentials (handle-based design; see\n   \
    \   Section 3.1) or authorization server shared secret/public key\n      (assertion-based\
    \ design; see Section 3.1)\n   o  access tokens (per request)\n   It is assumed\
    \ that a resource server has no knowledge of refresh\n   tokens, user passwords,\
    \ or client secrets.\n"
- title: 2.3.3.  Client
  contents:
  - "2.3.3.  Client\n   In OAuth, a client is an application making protected resource\n\
    \   requests on behalf of the resource owner and with its authorization.\n   There\
    \ are different types of clients with different implementation\n   and security\
    \ characteristics, such as web, user-agent-based, and\n   native applications.\
    \  A full definition of the different client types\n   and profiles is given in\
    \ [RFC6749], Section 2.1.\n   The following data elements are stored or accessible\
    \ on the client:\n   o  client id (and client secret or corresponding client credential)\n\
    \   o  one or more refresh tokens (persistent) and access tokens\n      (transient)\
    \ per end user or other security-context or delegation\n      context\n   o  trusted\
    \ certification authority (CA) certificates (HTTPS)\n   o  per-authorization process:\
    \ \"redirect_uri\", authorization \"code\"\n"
- title: 3.  Security Features
  contents:
  - "3.  Security Features\n   These are some of the security features that have been\
    \ built into the\n   OAuth 2.0 protocol to mitigate attacks and security issues.\n"
- title: 3.1.  Tokens
  contents:
  - "3.1.  Tokens\n   OAuth makes extensive use of many kinds of tokens (access tokens,\n\
    \   refresh tokens, authorization \"codes\").  The information content of a\n\
    \   token can be represented in two ways, as follows:\n   Handle (or artifact)\
    \  A 'handle' is a reference to some internal data\n      structure within the\
    \ authorization server; the internal data\n      structure contains the attributes\
    \ of the token, such as user id\n      (UID), scope, etc.  Handles enable simple\
    \ revocation and do not\n      require cryptographic mechanisms to protect token\
    \ content from\n      being modified.  On the other hand, handles require communication\n\
    \      between the issuing and consuming entity (e.g., the authorization\n   \
    \   server and resource server) in order to validate the token and\n      obtain\
    \ token-bound data.  This communication might have a negative\n      impact on\
    \ performance and scalability if both entities reside on\n      different systems.\
    \  Handles are therefore typically used if the\n      issuing and consuming entity\
    \ are the same.  A 'handle' token is\n      often referred to as an 'opaque' token\
    \ because the resource server\n      does not need to be able to interpret the\
    \ token directly; it\n      simply uses the token.\n   Assertion (aka self-contained\
    \ token)  An assertion is a parseable\n      token.  An assertion typically has\
    \ a duration, has an audience,\n      and is digitally signed in order to ensure\
    \ data integrity and\n      origin authentication.  It contains information about\
    \ the user and\n      the client.  Examples of assertion formats are Security\
    \ Assertion\n      Markup Language (SAML) assertions [OASIS.saml-core-2.0-os]\
    \ and\n      Kerberos tickets [RFC4120].  Assertions can typically be directly\n\
    \      validated and used by a resource server without interactions with\n   \
    \   the authorization server.  This results in better performance and\n      scalability\
    \ in deployments where the issuing and consuming\n      entities reside on different\
    \ systems.  Implementing token\n      revocation is more difficult with assertions\
    \ than with handles.\n   Tokens can be used in two ways to invoke requests on\
    \ resource\n   servers, as follows:\n   bearer token  A 'bearer token' is a token\
    \ that can be used by any\n      client who has received the token (e.g., [RFC6750]).\
    \  Because mere\n      possession is enough to use the token, it is important\
    \ that\n      communication between endpoints be secured to ensure that only\n\
    \      authorized endpoints may capture the token.  The bearer token is\n    \
    \  convenient for client applications, as it does not require them to\n      do\
    \ anything to use them (such as a proof of identity).  Bearer\n      tokens have\
    \ similar characteristics to web single-sign-on (SSO)\n      cookies used in browsers.\n\
    \   proof token  A 'proof token' is a token that can only be used by a\n     \
    \ specific client.  Each use of the token requires the client to\n      perform\
    \ some action that proves that it is the authorized user of\n      the token.\
    \  Examples of this are MAC-type access tokens, which\n      require the client\
    \ to digitally sign the resource request with a\n      secret corresponding to\
    \ the particular token sent with the request\n      (e.g., [OAuth-HTTP-MAC]).\n"
- title: 3.1.1.  Scope
  contents:
  - "3.1.1.  Scope\n   A scope represents the access authorization associated with\
    \ a\n   particular token with respect to resource servers, resources, and\n  \
    \ methods on those resources.  Scopes are the OAuth way to explicitly\n   manage\
    \ the power associated with an access token.  A scope can be\n   controlled by\
    \ the authorization server and/or the end user in order\n   to limit access to\
    \ resources for OAuth clients that these parties\n   deem less secure or trustworthy.\
    \  Optionally, the client can request\n   the scope to apply to the token but\
    \ only for a lesser scope than\n   would otherwise be granted, e.g., to reduce\
    \ the potential impact if\n   this token is sent over non-secure channels.  A\
    \ scope is typically\n   complemented by a restriction on a token's lifetime.\n"
- title: 3.1.2.  Limited Access Token Lifetime
  contents:
  - "3.1.2.  Limited Access Token Lifetime\n   The protocol parameter \"expires_in\"\
    \ allows an authorization server\n   (based on its policies or on behalf of the\
    \ end user) to limit the\n   lifetime of an access token and to pass this information\
    \ to the\n   client.  This mechanism can be used to issue short-lived tokens to\n\
    \   OAuth clients that the authorization server deems less secure, or\n   where\
    \ sending tokens over non-secure channels.\n"
- title: 3.2.  Access Token
  contents:
  - "3.2.  Access Token\n   An access token is used by a client to access a resource.\
    \  Access\n   tokens typically have short life spans (minutes or hours) that cover\n\
    \   typical session lifetimes.  An access token may be refreshed through\n   the\
    \ use of a refresh token.  The short lifespan of an access token,\n   in combination\
    \ with the usage of refresh tokens, enables the\n   possibility of passive revocation\
    \ of access authorization on the\n   expiry of the current access token.\n"
- title: 3.3.  Refresh Token
  contents:
  - "3.3.  Refresh Token\n   A refresh token represents a long-lasting authorization\
    \ of a certain\n   client to access resources on behalf of a resource owner. \
    \ Such\n   tokens are exchanged between the client and authorization server\n\
    \   only.  Clients use this kind of token to obtain (\"refresh\") new\n   access\
    \ tokens used for resource server invocations.\n   A refresh token, coupled with\
    \ a short access token lifetime, can be\n   used to grant longer access to resources\
    \ without involving end-user\n   authorization.  This offers an advantage where\
    \ resource servers and\n   authorization servers are not the same entity, e.g.,\
    \ in a distributed\n   environment, as the refresh token is always exchanged at\
    \ the\n   authorization server.  The authorization server can revoke the\n   refresh\
    \ token at any time, causing the granted access to be revoked\n   once the current\
    \ access token expires.  Because of this, a short\n   access token lifetime is\
    \ important if timely revocation is a high\n   priority.\n   The refresh token\
    \ is also a secret bound to the client identifier and\n   client instance that\
    \ originally requested the authorization; the\n   refresh token also represents\
    \ the original resource owner grant.\n   This is ensured by the authorization\
    \ process as follows:\n   1.  The resource owner and user agent safely deliver\
    \ the\n       authorization \"code\" to the client instance in the first place.\n\
    \   2.  The client uses it immediately in secure transport-level\n       communications\
    \ to the authorization server and then securely\n       stores the long-lived\
    \ refresh token.\n   3.  The client always uses the refresh token in secure transport-\n\
    \       level communications to the authorization server to get an access\n  \
    \     token (and optionally roll over the refresh token).\n   So, as long as the\
    \ confidentiality of the particular token can be\n   ensured by the client, a\
    \ refresh token can also be used as an\n   alternative means to authenticate the\
    \ client instance itself.\n"
- title: 3.4.  Authorization "code"
  contents:
  - "3.4.  Authorization \"code\"\n   An authorization \"code\" represents the intermediate\
    \ result of a\n   successful end-user authorization process and is used by the\
    \ client\n   to obtain access and refresh tokens.  Authorization \"codes\" are\
    \ sent\n   to the client's redirect URI instead of tokens for two purposes:\n\
    \   1.  Browser-based flows expose protocol parameters to potential\n       attackers\
    \ via URI query parameters (HTTP referrer), the browser\n       cache, or log\
    \ file entries, and could be replayed.  In order to\n       reduce this threat,\
    \ short-lived authorization \"codes\" are passed\n       instead of tokens and\
    \ exchanged for tokens over a more secure\n       direct connection between the\
    \ client and the authorization\n       server.\n   2.  It is much simpler to authenticate\
    \ clients during the direct\n       request between the client and the authorization\
    \ server than in\n       the context of the indirect authorization request.  The\
    \ latter\n       would require digital signatures.\n"
- title: 3.5.  Redirect URI
  contents:
  - "3.5.  Redirect URI\n   A redirect URI helps to detect malicious clients and prevents\n\
    \   phishing attacks from clients attempting to trick the user into\n   believing\
    \ the phisher is the client.  The value of the actual\n   redirect URI used in\
    \ the authorization request has to be presented\n   and is verified when an authorization\
    \ \"code\" is exchanged for tokens.\n   This helps to prevent attacks where the\
    \ authorization \"code\" is\n   revealed through redirectors and counterfeit web\
    \ application clients.\n   The authorization server should require public clients\
    \ and\n   confidential clients using the implicit grant type to pre-register\n\
    \   their redirect URIs and validate against the registered redirect URI\n   in\
    \ the authorization request.\n"
- title: 3.6.  "state" Parameter
  contents:
  - "3.6.  \"state\" Parameter\n   The \"state\" parameter is used to link requests\
    \ and callbacks to\n   prevent cross-site request forgery attacks (see Section\
    \ 4.4.1.8)\n   where an attacker authorizes access to his own resources and then\n\
    \   tricks a user into following a redirect with the attacker's token.\n   This\
    \ parameter should bind to the authenticated state in a user agent\n   and, as\
    \ per the core OAuth spec, the user agent must be capable of\n   keeping it in\
    \ a location accessible only by the client and user\n   agent, i.e., protected\
    \ by same-origin policy.\n"
- title: 3.7.  Client Identifier
  contents:
  - "3.7.  Client Identifier\n   Authentication protocols have typically not taken\
    \ into account the\n   identity of the software component acting on behalf of\
    \ the end user.\n   OAuth does this in order to increase the security level in\
    \ delegated\n   authorization scenarios and because the client will be able to\
    \ act\n   without the user being present.\n   OAuth uses the client identifier\
    \ to collate associated requests to\n   the same originator, such as\n   o  a\
    \ particular end-user authorization process and the corresponding\n      request\
    \ on the token's endpoint to exchange the authorization\n      \"code\" for tokens,\
    \ or\n   o  the initial authorization and issuance of a token by an end user\n\
    \      to a particular client, and subsequent requests by this client to\n   \
    \   obtain tokens without user consent (automatic processing of\n      repeated\
    \ authorizations)\n   This identifier may also be used by the authorization server\
    \ to\n   display relevant registration information to a user when requesting\n\
    \   consent for a scope requested by a particular client.  The client\n   identifier\
    \ may be used to limit the number of requests for a\n   particular client or to\
    \ charge the client per request.  It may\n   furthermore be useful to differentiate\
    \ access by different clients,\n   e.g., in server log files.\n   OAuth defines\
    \ two client types, confidential and public, based on\n   their ability to authenticate\
    \ with the authorization server (i.e.,\n   ability to maintain the confidentiality\
    \ of their client credentials).\n   Confidential clients are capable of maintaining\
    \ the confidentiality\n   of client credentials (i.e., a client secret associated\
    \ with the\n   client identifier) or capable of secure client authentication using\n\
    \   other means, such as a client assertion (e.g., SAML) or key\n   cryptography.\
    \  The latter is considered more secure.\n   The authorization server should determine\
    \ whether the client is\n   capable of keeping its secret confidential or using\
    \ secure\n   authentication.  Alternatively, the end user can verify the identity\n\
    \   of the client, e.g., by only installing trusted applications.  The\n   redirect\
    \ URI can be used to prevent the delivery of credentials to a\n   counterfeit\
    \ client after obtaining end-user authorization in some\n   cases but can't be\
    \ used to verify the client identifier.\n   Clients can be categorized as follows\
    \ based on the client type,\n   profile (e.g., native vs. web application; see\
    \ [RFC6749], Section 9),\n   and deployment model:\n   Deployment-independent\
    \ \"client_id\" with pre-registered \"redirect_uri\"\n      and without \"client_secret\"\
    \  Such an identifier is used by\n      multiple installations of the same software\
    \ package.  The\n      identifier of such a client can only be validated with\
    \ the help of\n      the end-user.  This is a viable option for native applications\
    \ in\n      order to identify the client for the purpose of displaying meta\n\
    \      information about the client to the user and to differentiate\n      clients\
    \ in log files.  Revocation of the rights associated with\n      such a client\
    \ identifier will affect ALL deployments of the\n      respective software.\n\
    \   Deployment-independent \"client_id\" with pre-registered \"redirect_uri\"\n\
    \      and with \"client_secret\"  This is an option for native\n      applications\
    \ only, since web applications would require different\n      redirect URIs. \
    \ This category is not advisable because the client\n      secret cannot be protected\
    \ appropriately (see Section 4.1.1).  Due\n      to its security weaknesses, such\
    \ client identities have the same\n      trust level as deployment-independent\
    \ clients without secrets.\n      Revocation will affect ALL deployments.\n  \
    \ Deployment-specific \"client_id\" with pre-registered \"redirect_uri\"\n   \
    \   and with \"client_secret\"  The client registration process ensures\n    \
    \  the validation of the client's properties, such as redirect URI,\n      web\
    \ site URL, web site name, and contacts.  Such a client\n      identifier can\
    \ be utilized for all relevant use cases cited above.\n      This level can be\
    \ achieved for web applications in combination\n      with a manual or user-bound\
    \ registration process.  Achieving this\n      level for native applications is\
    \ much more difficult.  Either the\n      installation of the application is conducted\
    \ by an administrator,\n      who validates the client's authenticity, or the\
    \ process from\n      validating the application to the installation of the application\n\
    \      on the device and the creation of the client credentials is\n      controlled\
    \ end-to-end by a single entity (e.g., application market\n      provider).  Revocation\
    \ will affect a single deployment only.\n   Deployment-specific \"client_id\"\
    \ with \"client_secret\" without\n      validated properties  Such a client can\
    \ be recognized by the\n      authorization server in transactions with subsequent\
    \ requests\n      (e.g., authorization and token issuance, refresh token issuance,\n\
    \      and access token refreshment).  The authorization server cannot\n     \
    \ assure any property of the client to end users.  Automatic\n      processing\
    \ of re-authorizations could be allowed as well.  Such\n      client credentials\
    \ can be generated automatically without any\n      validation of client properties,\
    \ which makes it another option,\n      especially for native applications.  Revocation\
    \ will affect a\n      single deployment only.\n"
- title: 4.  Threat Model
  contents:
  - "4.  Threat Model\n   This section gives a comprehensive threat model of OAuth\
    \ 2.0.\n   Threats are grouped first by attacks directed against an OAuth\n  \
    \ component, which are the client, authorization server, and resource\n   server.\
    \  Subsequently, they are grouped by flow, e.g., obtain token\n   or access protected\
    \ resources.  Every countermeasure description\n   refers to a detailed description\
    \ in Section 5.\n"
- title: 4.1.  Clients
  contents:
  - "4.1.  Clients\n   This section describes possible threats directed to OAuth clients.\n"
- title: '4.1.1.  Threat: Obtaining Client Secrets'
  contents:
  - "4.1.1.  Threat: Obtaining Client Secrets\n   The attacker could try to get access\
    \ to the secret of a particular\n   client in order to:\n   o  replay its refresh\
    \ tokens and authorization \"codes\", or\n   o  obtain tokens on behalf of the\
    \ attacked client with the privileges\n      of that \"client_id\" acting as an\
    \ instance of the client.\n   The resulting impact would be the following:\n \
    \  o  Client authentication of access to the authorization server can be\n   \
    \   bypassed.\n   o  Stolen refresh tokens or authorization \"codes\" can be replayed.\n\
    \   Depending on the client category, the following attacks could be\n   utilized\
    \ to obtain the client secret.\n   Attack: Obtain Secret From Source Code or Binary:\n\
    \   This applies for all client types.  For open source projects, secrets\n  \
    \ can be extracted directly from source code in their public\n   repositories.\
    \  Secrets can be extracted from application binaries\n   just as easily when\
    \ the published source is not available to the\n   attacker.  Even if an application\
    \ takes significant measures to\n   obfuscate secrets in their application distribution,\
    \ one should\n   consider that the secret can still be reverse-engineered by anyone\n\
    \   with access to a complete functioning application bundle or binary.\n   Countermeasures:\n\
    \   o  Don't issue secrets to public clients or clients with\n      inappropriate\
    \ security policy (Section 5.2.3.1).\n   o  Require user consent for public clients\
    \ (Section 5.2.3.2).\n   o  Use deployment-specific client secrets (Section 5.2.3.4).\n\
    \   o  Revoke client secrets (Section 5.2.3.6).\n   Attack: Obtain a Deployment-Specific\
    \ Secret:\n   An attacker may try to obtain the secret from a client installation,\n\
    \   either from a web site (web server) or a particular device (native\n   application).\n\
    \   Countermeasures:\n   o  Web server: Apply standard web server protection measures\
    \ (for\n      config files and databases) (see Section 5.3.2).\n   o  Native applications:\
    \ Store secrets in secure local storage\n      (Section 5.3.3).\n   o  Revoke\
    \ client secrets (Section 5.2.3.6).\n"
- title: '4.1.2.  Threat: Obtaining Refresh Tokens'
  contents:
  - "4.1.2.  Threat: Obtaining Refresh Tokens\n   Depending on the client type, there\
    \ are different ways that refresh\n   tokens may be revealed to an attacker. \
    \ The following sub-sections\n   give a more detailed description of the different\
    \ attacks with\n   respect to different client types and further specialized\n\
    \   countermeasures.  Before detailing those threats, here are some\n   generally\
    \ applicable countermeasures:\n   o  The authorization server should validate\
    \ the client id associated\n      with the particular refresh token with every\
    \ refresh request\n      (Section 5.2.2.2).\n   o  Limit token scope (Section\
    \ 5.1.5.1).\n   o  Revoke refresh tokens (Section 5.2.2.4).\n   o  Revoke client\
    \ secrets (Section 5.2.3.6).\n   o  Refresh tokens can automatically be replaced\
    \ in order to detect\n      unauthorized token usage by another party (see \"\
    Refresh Token\n      Rotation\", Section 5.2.2.3).\n   Attack: Obtain Refresh\
    \ Token from Web Application:\n   An attacker may obtain the refresh tokens issued\
    \ to a web application\n   by way of overcoming the web server's security controls.\n\
    \   Impact: Since a web application manages the user accounts of a\n   certain\
    \ site, such an attack would result in an exposure of all\n   refresh tokens on\
    \ that site to the attacker.\n   Countermeasures:\n   o  Standard web server protection\
    \ measures (Section 5.3.2).\n   o  Use strong client authentication (e.g., client_assertion/\n\
    \      client_token) so the attacker cannot obtain the client secret\n      required\
    \ to exchange the tokens (Section 5.2.3.7).\n   Attack: Obtain Refresh Token from\
    \ Native Clients:\n   On native clients, leakage of a refresh token typically\
    \ affects a\n   single user only.\n   Read from local file system: The attacker\
    \ could try to get file\n   system access on the device and read the refresh tokens.\
    \  The\n   attacker could utilize a malicious application for that purpose.\n\
    \   Countermeasures:\n   o  Store secrets in secure storage (Section 5.3.3).\n\
    \   o  Utilize device lock to prevent unauthorized device access\n      (Section\
    \ 5.3.4).\n   Attack: Steal Device:\n   The host device (e.g., mobile phone) may\
    \ be stolen.  In that case,\n   the attacker gets access to all applications under\
    \ the identity of\n   the legitimate user.\n   Countermeasures:\n   o  Utilize\
    \ device lock to prevent unauthorized device access\n      (Section 5.3.4).\n\
    \   o  Where a user knows the device has been stolen, they can revoke the\n  \
    \    affected tokens (Section 5.2.2.4).\n   Attack: Clone Device:\n   All device\
    \ data and applications are copied to another device.\n   Applications are used\
    \ as-is on the target device.\n   Countermeasures:\n   o  Utilize device lock\
    \ to prevent unauthorized device access\n      (Section 5.3.4).\n   o  Combine\
    \ refresh token request with device identification\n      (Section 5.2.2.5).\n\
    \   o  Refresh token rotation (Section 5.2.2.3).\n   o  Where a user knows the\
    \ device has been cloned, they can use\n      refresh token revocation (Section\
    \ 5.2.2.4).\n"
- title: '4.1.3.  Threat: Obtaining Access Tokens'
  contents:
  - "4.1.3.  Threat: Obtaining Access Tokens\n   Depending on the client type, there\
    \ are different ways that access\n   tokens may be revealed to an attacker.  Access\
    \ tokens could be stolen\n   from the device if the application stores them in\
    \ a storage device\n   that is accessible to other applications.\n   Impact: Where\
    \ the token is a bearer token and no additional mechanism\n   is used to identify\
    \ the client, the attacker can access all resources\n   associated with the token\
    \ and its scope.\n   Countermeasures:\n   o  Keep access tokens in transient memory\
    \ and limit grants\n      (Section 5.1.6).\n   o  Limit token scope (Section 5.1.5.1).\n\
    \   o  Keep access tokens in private memory or apply same protection\n      means\
    \ as for refresh tokens (Section 5.2.2).\n   o  Keep access token lifetime short\
    \ (Section 5.1.5.3).\n"
- title: '4.1.4.  Threat: End-User Credentials Phished Using Compromised or'
  contents:
  - "4.1.4.  Threat: End-User Credentials Phished Using Compromised or\n        Embedded\
    \ Browser\n   A malicious application could attempt to phish end-user passwords\
    \ by\n   misusing an embedded browser in the end-user authorization process,\n\
    \   or by presenting its own user interface instead of allowing a trusted\n  \
    \ system browser to render the authorization user interface.  By doing\n   so,\
    \ the usual visual trust mechanisms may be bypassed (e.g.,\n   Transport Layer\
    \ Security (TLS) confirmation, web site mechanisms).\n   By using an embedded\
    \ or internal client application user interface,\n   the client application has\
    \ access to additional information to which\n   it should not have access (e.g.,\
    \ UID/password).\n   Impact: If the client application or the communication is\n\
    \   compromised, the user would not be aware of this, and all information\n  \
    \ in the authorization exchange, such as username and password, could\n   be captured.\n\
    \   Countermeasures:\n   o  The OAuth flow is designed so that client applications\
    \ never need\n      to know user passwords.  Client applications should avoid\
    \ directly\n      asking users for their credentials.  In addition, end users\
    \ could\n      be educated about phishing attacks and best practices, such as\n\
    \      only accessing trusted clients, as OAuth does not provide any\n      protection\
    \ against malicious applications and the end user is\n      solely responsible\
    \ for the trustworthiness of any native\n      application installed.\n   o  Client\
    \ applications could be validated prior to publication in an\n      application\
    \ market for users to access.  That validation is out of\n      scope for OAuth\
    \ but could include validating that the client\n      application handles user\
    \ authentication in an appropriate way.\n   o  Client developers should not write\
    \ client applications that\n      collect authentication information directly\
    \ from users and should\n      instead delegate this task to a trusted system\
    \ component, e.g.,\n      the system browser.\n"
- title: '4.1.5.  Threat: Open Redirectors on Client'
  contents:
  - "4.1.5.  Threat: Open Redirectors on Client\n   An open redirector is an endpoint\
    \ using a parameter to automatically\n   redirect a user agent to the location\
    \ specified by the parameter\n   value without any validation.  If the authorization\
    \ server allows the\n   client to register only part of the redirect URI, an attacker\
    \ can use\n   an open redirector operated by the client to construct a redirect\
    \ URI\n   that will pass the authorization server validation but will send the\n\
    \   authorization \"code\" or access token to an endpoint under the control\n\
    \   of the attacker.\n   Impact: An attacker could gain access to authorization\
    \ \"codes\" or\n   access tokens.\n   Countermeasures:\n   o  Require clients\
    \ to register full redirect URI (Section 5.2.3.5).\n"
- title: 4.2.  Authorization Endpoint
  contents:
  - '4.2.  Authorization Endpoint

    '
- title: '4.2.1.  Threat: Password Phishing by Counterfeit Authorization Server'
  contents:
  - "4.2.1.  Threat: Password Phishing by Counterfeit Authorization Server\n   OAuth\
    \ makes no attempt to verify the authenticity of the\n   authorization server.\
    \  A hostile party could take advantage of this\n   by intercepting the client's\
    \ requests and returning misleading or\n   otherwise incorrect responses.  This\
    \ could be achieved using DNS or\n   Address Resolution Protocol (ARP) spoofing.\
    \  Wide deployment of OAuth\n   and similar protocols may cause users to become\
    \ inured to the\n   practice of being redirected to web sites where they are asked\
    \ to\n   enter their passwords.  If users are not careful to verify the\n   authenticity\
    \ of these web sites before entering their credentials, it\n   will be possible\
    \ for attackers to exploit this practice to steal\n   users' passwords.\n   Countermeasures:\n\
    \   o  Authorization servers should consider such attacks when developing\n  \
    \    services based on OAuth and should require the use of transport-\n      layer\
    \ security for any requests where the authenticity of the\n      authorization\
    \ server or of request responses is an issue (see\n      Section 5.1.2).\n   o\
    \  Authorization servers should attempt to educate users about the\n      risks\
    \ posed by phishing attacks and should provide mechanisms that\n      make it\
    \ easy for users to confirm the authenticity of their sites.\n"
- title: '4.2.2.  Threat: User Unintentionally Grants Too Much Access Scope'
  contents:
  - "4.2.2.  Threat: User Unintentionally Grants Too Much Access Scope\n   When obtaining\
    \ end-user authorization, the end user may not\n   understand the scope of the\
    \ access being granted and to whom, or they\n   may end up providing a client\
    \ with access to resources that should\n   not be permitted.\n   Countermeasures:\n\
    \   o  Explain the scope (resources and the permissions) the user is\n      about\
    \ to grant in an understandable way (Section 5.2.4.2).\n   o  Narrow the scope,\
    \ based on the client.  When obtaining end-user\n      authorization and where\
    \ the client requests scope, the\n      authorization server may want to consider\
    \ whether to honor that\n      scope based on the client identifier.  That decision\
    \ is between\n      the client and authorization server and is outside the scope\
    \ of\n      this spec.  The authorization server may also want to consider\n \
    \     what scope to grant based on the client type, e.g., providing\n      lower\
    \ scope to public clients (Section 5.1.5.1).\n"
- title: '4.2.3.  Threat: Malicious Client Obtains Existing Authorization by Fraud'
  contents:
  - "4.2.3.  Threat: Malicious Client Obtains Existing Authorization by Fraud\n  \
    \ Authorization servers may wish to automatically process authorization\n   requests\
    \ from clients that have been previously authorized by the\n   user.  When the\
    \ user is redirected to the authorization server's end-\n   user authorization\
    \ endpoint to grant access, the authorization server\n   detects that the user\
    \ has already granted access to that particular\n   client.  Instead of prompting\
    \ the user for approval, the\n   authorization server automatically redirects\
    \ the user back to the\n   client.\n   A malicious client may exploit that feature\
    \ and try to obtain such an\n   authorization \"code\" instead of the legitimate\
    \ client.\n   Countermeasures:\n   o  Authorization servers should not automatically\
    \ process repeat\n      authorizations to public clients unless the client is\
    \ validated\n      using a pre-registered redirect URI (Section 5.2.3.5).\n  \
    \ o  Authorization servers can mitigate the risks associated with\n      automatic\
    \ processing by limiting the scope of access tokens\n      obtained through automated\
    \ approvals (Section 5.1.5.1).\n"
- title: '4.2.4.  Threat: Open Redirector'
  contents:
  - "4.2.4.  Threat: Open Redirector\n   An attacker could use the end-user authorization\
    \ endpoint and the\n   redirect URI parameter to abuse the authorization server\
    \ as an open\n   redirector.  An open redirector is an endpoint using a parameter\
    \ to\n   automatically redirect a user agent to the location specified by the\n\
    \   parameter value without any validation.\n   Impact: An attacker could utilize\
    \ a user's trust in an authorization\n   server to launch a phishing attack.\n\
    \   Countermeasures:\n   o  Require clients to register any full redirect URIs\n\
    \      (Section 5.2.3.5).\n   o  Don't redirect to a redirect URI if the client\
    \ identifier or\n      redirect URI can't be verified (Section 5.2.3.5).\n"
- title: 4.3.  Token Endpoint
  contents:
  - '4.3.  Token Endpoint

    '
- title: '4.3.1.  Threat: Eavesdropping Access Tokens'
  contents:
  - "4.3.1.  Threat: Eavesdropping Access Tokens\n   Attackers may attempt to eavesdrop\
    \ access tokens in transit from the\n   authorization server to the client.\n\
    \   Impact: The attacker is able to access all resources with the\n   permissions\
    \ covered by the scope of the particular access token.\n   Countermeasures:\n\
    \   o  As per the core OAuth spec, the authorization servers must ensure\n   \
    \   that these transmissions are protected using transport-layer\n      mechanisms\
    \ such as TLS (see Section 5.1.1).\n   o  If end-to-end confidentiality cannot\
    \ be guaranteed, reducing scope\n      (see Section 5.1.5.1) and expiry time (Section\
    \ 5.1.5.3) for access\n      tokens can be used to reduce the damage in case of\
    \ leaks.\n"
- title: '4.3.2.  Threat: Obtaining Access Tokens from Authorization Server'
  contents:
  - "4.3.2.  Threat: Obtaining Access Tokens from Authorization Server\n        Database\n\
    \   This threat is applicable if the authorization server stores access\n   tokens\
    \ as handles in a database.  An attacker may obtain access\n   tokens from the\
    \ authorization server's database by gaining access to\n   the database or launching\
    \ a SQL injection attack.\n   Impact: Disclosure of all access tokens.\n   Countermeasures:\n\
    \   o  Enforce system security measures (Section 5.1.4.1.1).\n   o  Store access\
    \ token hashes only (Section 5.1.4.1.3).\n   o  Enforce standard SQL injection\
    \ countermeasures\n      (Section 5.1.4.1.2).\n"
- title: '4.3.3.  Threat: Disclosure of Client Credentials during Transmission'
  contents:
  - "4.3.3.  Threat: Disclosure of Client Credentials during Transmission\n   An attacker\
    \ could attempt to eavesdrop the transmission of client\n   credentials between\
    \ the client and server during the client\n   authentication process or during\
    \ OAuth token requests.\n   Impact: Revelation of a client credential enabling\
    \ phishing or\n   impersonation of a client service.\n   Countermeasures:\n  \
    \ o  The transmission of client credentials must be protected using\n      transport-layer\
    \ mechanisms such as TLS (see Section 5.1.1).\n   o  Use alternative authentication\
    \ means that do not require the\n      sending of plaintext credentials over the\
    \ wire (e.g., Hash-based\n      Message Authentication Code).\n"
- title: '4.3.4.  Threat: Obtaining Client Secret from Authorization Server'
  contents:
  - "4.3.4.  Threat: Obtaining Client Secret from Authorization Server\n        Database\n\
    \   An attacker may obtain valid \"client_id\"/secret combinations from the\n\
    \   authorization server's database by gaining access to the database or\n   launching\
    \ a SQL injection attack.\n   Impact: Disclosure of all \"client_id\"/secret combinations.\
    \  This\n   allows the attacker to act on behalf of legitimate clients.\n   Countermeasures:\n\
    \   o  Enforce system security measures (Section 5.1.4.1.1).\n   o  Enforce standard\
    \ SQL injection countermeasures\n      (Section 5.1.4.1.2).\n   o  Ensure proper\
    \ handling of credentials as per \"Enforce Credential\n      Storage Protection\
    \ Best Practices\" (Section 5.1.4.1).\n"
- title: '4.3.5.  Threat: Obtaining Client Secret by Online Guessing'
  contents:
  - "4.3.5.  Threat: Obtaining Client Secret by Online Guessing\n   An attacker may\
    \ try to guess valid \"client_id\"/secret pairs.\n   Impact: Disclosure of a single\
    \ \"client_id\"/secret pair.\n   Countermeasures:\n   o  Use high entropy for\
    \ secrets (Section 5.1.4.2.2).\n   o  Lock accounts (Section 5.1.4.2.3).\n   o\
    \  Use strong client authentication (Section 5.2.3.7).\n"
- title: 4.4.  Obtaining Authorization
  contents:
  - "4.4.  Obtaining Authorization\n   This section covers threats that are specific\
    \ to certain flows\n   utilized to obtain access tokens.  Each flow is characterized\
    \ by\n   response types and/or grant types on the end-user authorization and\n\
    \   token endpoint, respectively.\n"
- title: 4.4.1.  Authorization "code"
  contents:
  - '4.4.1.  Authorization "code"

    '
- title: '4.4.1.1.  Threat: Eavesdropping or Leaking Authorization "codes"'
  contents:
  - "4.4.1.1.  Threat: Eavesdropping or Leaking Authorization \"codes\"\n   An attacker\
    \ could try to eavesdrop transmission of the authorization\n   \"code\" between\
    \ the authorization server and client.  Furthermore,\n   authorization \"codes\"\
    \ are passed via the browser, which may\n   unintentionally leak those codes to\
    \ untrusted web sites and attackers\n   in different ways:\n   o  Referrer headers:\
    \ Browsers frequently pass a \"referer\" header when\n      a web page embeds\
    \ content, or when a user travels from one web\n      page to another web page.\
    \  These referrer headers may be sent even\n      when the origin site does not\
    \ trust the destination site.  The\n      referrer header is commonly logged for\
    \ traffic analysis purposes.\n   o  Request logs: Web server request logs commonly\
    \ include query\n      parameters on requests.\n   o  Open redirectors: Web sites\
    \ sometimes need to send users to\n      another destination via a redirector.\
    \  Open redirectors pose a\n      particular risk to web-based delegation protocols\
    \ because the\n      redirector can leak verification codes to untrusted destination\n\
    \      sites.\n   o  Browser history: Web browsers commonly record visited URLs\
    \ in the\n      browser history.  Another user of the same web browser may be\
    \ able\n      to view URLs that were visited by previous users.\n   Note: A description\
    \ of similar attacks on the SAML protocol can be\n   found at [OASIS.sstc-saml-bindings-1.1],\
    \ Section 4.1.1.9.1;\n   [Sec-Analysis]; and [OASIS.sstc-sec-analysis-response-01].\n\
    \   Countermeasures:\n   o  As per the core OAuth spec, the authorization server\
    \ as well as\n      the client must ensure that these transmissions are protected\n\
    \      using transport-layer mechanisms such as TLS (see Section 5.1.1).\n   o\
    \  The authorization server will require the client to authenticate\n      wherever\
    \ possible, so the binding of the authorization \"code\" to a\n      certain client\
    \ can be validated in a reliable way (see\n      Section 5.2.4.4).\n   o  Use\
    \ short expiry time for authorization \"codes\" (Section 5.1.5.3).\n   o  The\
    \ authorization server should enforce a one-time usage\n      restriction (see\
    \ Section 5.1.5.4).\n   o  If an authorization server observes multiple attempts\
    \ to redeem an\n      authorization \"code\", the authorization server may want\
    \ to revoke\n      all tokens granted based on the authorization \"code\" (see\n\
    \      Section 5.2.1.1).\n   o  In the absence of these countermeasures, reducing\
    \ scope\n      (Section 5.1.5.1) and expiry time (Section 5.1.5.3) for access\n\
    \      tokens can be used to reduce the damage in case of leaks.\n   o  The client\
    \ server may reload the target page of the redirect URI\n      in order to automatically\
    \ clean up the browser cache.\n"
- title: '4.4.1.2.  Threat: Obtaining Authorization "codes" from Authorization'
  contents:
  - "4.4.1.2.  Threat: Obtaining Authorization \"codes\" from Authorization\n    \
    \      Server Database\n   This threat is applicable if the authorization server\
    \ stores\n   authorization \"codes\" as handles in a database.  An attacker may\n\
    \   obtain authorization \"codes\" from the authorization server's database\n\
    \   by gaining access to the database or launching a SQL injection\n   attack.\n\
    \   Impact: Disclosure of all authorization \"codes\", most likely along\n   with\
    \ the respective \"redirect_uri\" and \"client_id\" values.\n   Countermeasures:\n\
    \   o  Best practices for credential storage protection should be\n      employed\
    \ (Section 5.1.4.1).\n   o  Enforce system security measures (Section 5.1.4.1.1).\n\
    \   o  Store access token hashes only (Section 5.1.4.1.3).\n   o  Enforce standard\
    \ SQL injection countermeasures\n      (Section 5.1.4.1.2).\n"
- title: '4.4.1.3.  Threat: Online Guessing of Authorization "codes"'
  contents:
  - "4.4.1.3.  Threat: Online Guessing of Authorization \"codes\"\n   An attacker\
    \ may try to guess valid authorization \"code\" values and\n   send the guessed\
    \ code value using the grant type \"code\" in order to\n   obtain a valid access\
    \ token.\n   Impact: Disclosure of a single access token and probably also an\n\
    \   associated refresh token.\n   Countermeasures:\n   o  Handle-based tokens\
    \ must use high entropy (Section 5.1.4.2.2).\n   o  Assertion-based tokens should\
    \ be signed (Section 5.1.5.9).\n   o  Authenticate the client; this adds another\
    \ value that the attacker\n      has to guess (Section 5.2.3.4).\n   o  Bind the\
    \ authorization \"code\" to the redirect URI; this adds\n      another value that\
    \ the attacker has to guess (Section 5.2.4.5).\n   o  Use short expiry time for\
    \ tokens (Section 5.1.5.3).\n"
- title: '4.4.1.4.  Threat: Malicious Client Obtains Authorization'
  contents:
  - "4.4.1.4.  Threat: Malicious Client Obtains Authorization\n   A malicious client\
    \ could pretend to be a valid client and obtain an\n   access authorization in\
    \ this way.  The malicious client could even\n   utilize screen-scraping techniques\
    \ in order to simulate a user's\n   consent in the authorization flow.\n   Assumption:\
    \ It is not the task of the authorization server to protect\n   the end-user's\
    \ device from malicious software.  This is the\n   responsibility of the platform\
    \ running on the particular device,\n   probably in cooperation with other components\
    \ of the respective\n   ecosystem (e.g., an application management infrastructure).\
    \  The sole\n   responsibility of the authorization server is to control access\
    \ to\n   the end-user's resources maintained in resource servers and to\n   prevent\
    \ unauthorized access to them via the OAuth protocol.  Based on\n   this assumption,\
    \ the following countermeasures are available to cope\n   with the threat.\n \
    \  Countermeasures:\n   o  The authorization server should authenticate the client,\
    \ if\n      possible (see Section 5.2.3.4).  Note: The authentication takes\n\
    \      place after the end user has authorized the access.\n   o  The authorization\
    \ server should validate the client's redirect URI\n      against the pre-registered\
    \ redirect URI, if one exists (see\n      Section 5.2.3.5).  Note: An invalid\
    \ redirect URI indicates an\n      invalid client, whereas a valid redirect URI\
    \ does not necessarily\n      indicate a valid client.  The level of confidence\
    \ depends on the\n      client type.  For web applications, the level of confidence\
    \ is\n      high, since the redirect URI refers to the globally unique network\n\
    \      endpoint of this application, whose fully qualified domain name\n     \
    \ (FQDN) is also validated using HTTPS server authentication by the\n      user\
    \ agent.  In contrast, for native clients, the redirect URI\n      typically refers\
    \ to device local resources, e.g., a custom scheme.\n      So, a malicious client\
    \ on a particular device can use the valid\n      redirect URI the legitimate\
    \ client uses on all other devices.\n   o  After authenticating the end user,\
    \ the authorization server should\n      ask him/her for consent.  In this context,\
    \ the authorization\n      server should explain to the end user the purpose,\
    \ scope, and\n      duration of the authorization the client asked for.  Moreover,\
    \ the\n      authorization server should show the user any identity information\n\
    \      it has for that client.  It is up to the user to validate the\n      binding\
    \ of this data to the particular application (e.g., Name)\n      and to approve\
    \ the authorization request (see Section 5.2.4.3).\n   o  The authorization server\
    \ should not perform automatic\n      re-authorizations for clients it is unable\
    \ to reliably\n      authenticate or validate (see Section 5.2.4.1).\n   o  If\
    \ the authorization server automatically authenticates the end\n      user, it\
    \ may nevertheless require some user input in order to\n      prevent screen scraping.\
    \  Examples are CAPTCHAs (Completely\n      Automated Public Turing tests to tell\
    \ Computers and Humans Apart)\n      or other multi-factor authentication techniques\
    \ such as random\n      questions, token code generators, etc.\n   o  The authorization\
    \ server may also limit the scope of tokens it\n      issues to clients it cannot\
    \ reliably authenticate (see\n      Section 5.1.5.1).\n"
- title: '4.4.1.5.  Threat: Authorization "code" Phishing'
  contents:
  - "4.4.1.5.  Threat: Authorization \"code\" Phishing\n   A hostile party could impersonate\
    \ the client site and get access to\n   the authorization \"code\".  This could\
    \ be achieved using DNS or ARP\n   spoofing.  This applies to clients, which are\
    \ web applications; thus,\n   the redirect URI is not local to the host where\
    \ the user's browser is\n   running.\n   Impact: This affects web applications\
    \ and may lead to a disclosure of\n   authorization \"codes\" and, potentially,\
    \ the corresponding access and\n   refresh tokens.\n   Countermeasures:\n   It\
    \ is strongly recommended that one of the following countermeasures\n   be utilized\
    \ in order to prevent this attack:\n   o  The redirect URI of the client should\
    \ point to an HTTPS-protected\n      endpoint, and the browser should be utilized\
    \ to authenticate this\n      redirect URI using server authentication (see Section\
    \ 5.1.2).\n   o  The authorization server should require that the client be\n\
    \      authenticated, i.e., confidential client, so the binding of the\n     \
    \ authorization \"code\" to a certain client can be validated in a\n      reliable\
    \ way (see Section 5.2.4.4).\n"
- title: '4.4.1.6.  Threat: User Session Impersonation'
  contents:
  - "4.4.1.6.  Threat: User Session Impersonation\n   A hostile party could impersonate\
    \ the client site and impersonate the\n   user's session on this client.  This\
    \ could be achieved using DNS or\n   ARP spoofing.  This applies to clients, which\
    \ are web applications;\n   thus, the redirect URI is not local to the host where\
    \ the user's\n   browser is running.\n   Impact: An attacker who intercepts the\
    \ authorization \"code\" as it is\n   sent by the browser to the callback endpoint\
    \ can gain access to\n   protected resources by submitting the authorization \"\
    code\" to the\n   client.  The client will exchange the authorization \"code\"\
    \ for an\n   access token and use the access token to access protected resources\n\
    \   for the benefit of the attacker, delivering protected resources to\n   the\
    \ attacker, or modifying protected resources as directed by the\n   attacker.\
    \  If OAuth is used by the client to delegate authentication\n   to a social site\
    \ (e.g., as in the implementation of a \"Login\" button\n   on a third-party social\
    \ network site), the attacker can use the\n   intercepted authorization \"code\"\
    \ to log into the client as the user.\n   Note: Authenticating the client during\
    \ authorization \"code\" exchange\n   will not help to detect such an attack,\
    \ as it is the legitimate\n   client that obtains the tokens.\n   Countermeasures:\n\
    \   o  In order to prevent an attacker from impersonating the end-user's\n   \
    \   session, the redirect URI of the client should point to an HTTPS\n      protected\
    \ endpoint, and the browser should be utilized to\n      authenticate this redirect\
    \ URI using server authentication (see\n      Section 5.1.2).\n"
- title: '4.4.1.7.  Threat: Authorization "code" Leakage through Counterfeit'
  contents:
  - "4.4.1.7.  Threat: Authorization \"code\" Leakage through Counterfeit\n      \
    \    Client\n   The attacker leverages the authorization \"code\" grant type in\
    \ an\n   attempt to get another user (victim) to log in, authorize access to\n\
    \   his/her resources, and subsequently obtain the authorization \"code\"\n  \
    \ and inject it into a client application using the attacker's account.\n   The\
    \ goal is to associate an access authorization for resources of the\n   victim\
    \ with the user account of the attacker on a client site.\n   The attacker abuses\
    \ an existing client application and combines it\n   with his own counterfeit\
    \ client web site.  The attacker depends on\n   the victim expecting the client\
    \ application to request access to a\n   certain resource server.  The victim,\
    \ seeing only a normal request\n   from an expected application, approves the\
    \ request.  The attacker\n   then uses the victim's authorization to gain access\
    \ to the\n   information unknowingly authorized by the victim.\n   The attacker\
    \ conducts the following flow:\n   1.  The attacker accesses the client web site\
    \ (or application) and\n       initiates data access to a particular resource\
    \ server.  The\n       client web site in turn initiates an authorization request\
    \ to the\n       resource server's authorization server.  Instead of proceeding\n\
    \       with the authorization process, the attacker modifies the\n       authorization\
    \ server end-user authorization URL as constructed by\n       the client to include\
    \ a redirect URI parameter referring to a web\n       site under his control (attacker's\
    \ web site).\n   2.  The attacker tricks another user (the victim) into opening\
    \ that\n       modified end-user authorization URI and authorizing access (e.g.,\n\
    \       via an email link or blog link).  The way the attacker achieves\n    \
    \   this goal is out of scope.\n   3.  Having clicked the link, the victim is\
    \ requested to authenticate\n       and authorize the client site to have access.\n\
    \   4.  After completion of the authorization process, the authorization\n   \
    \    server redirects the user agent to the attacker's web site\n       instead\
    \ of the original client web site.\n   5.  The attacker obtains the authorization\
    \ \"code\" from his web site\n       by means that are out of scope of this document.\n\
    \   6.  He then constructs a redirect URI to the target web site (or\n       application)\
    \ based on the original authorization request's\n       redirect URI and the newly\
    \ obtained authorization \"code\", and\n       directs his user agent to this\
    \ URL.  The authorization \"code\" is\n       injected into the original client\
    \ site (or application).\n   7.  The client site uses the authorization \"code\"\
    \ to fetch a token\n       from the authorization server and associates this token\
    \ with the\n       attacker's user account on this site.\n   8.  The attacker\
    \ may now access the victim's resources using the\n       client site.\n   Impact:\
    \ The attacker gains access to the victim's resources as\n   associated with his\
    \ account on the client site.\n   Countermeasures:\n   o  The attacker will need\
    \ to use another redirect URI for its\n      authorization process rather than\
    \ the target web site because it\n      needs to intercept the flow.  So, if the\
    \ authorization server\n      associates the authorization \"code\" with the redirect\
    \ URI of a\n      particular end-user authorization and validates this redirect\
    \ URI\n      with the redirect URI passed to the token's endpoint, such an\n \
    \     attack is detected (see Section 5.2.4.5).\n   o  The authorization server\
    \ may also enforce the usage and validation\n      of pre-registered redirect\
    \ URIs (see Section 5.2.3.5).  This will\n      allow for early recognition of\
    \ authorization \"code\" disclosure to\n      counterfeit clients.\n   o  For\
    \ native applications, one could also consider using deployment-\n      specific\
    \ client ids and secrets (see Section 5.2.3.4), along with\n      the binding\
    \ of authorization \"codes\" to \"client_ids\" (see\n      Section 5.2.4.4) to\
    \ detect such an attack because the attacker\n      does not have access to the\
    \ deployment-specific secret.  Thus, he\n      will not be able to exchange the\
    \ authorization \"code\".\n   o  The client may consider using other flows that\
    \ are not vulnerable\n      to this kind of attack, such as the implicit grant\
    \ type (see\n      Section 4.4.2) or resource owner password credentials (see\n\
    \      Section 4.4.3).\n"
- title: '4.4.1.8.  Threat: CSRF Attack against redirect-uri'
  contents:
  - "4.4.1.8.  Threat: CSRF Attack against redirect-uri\n   Cross-site request forgery\
    \ (CSRF) is a web-based attack whereby HTTP\n   requests are transmitted from\
    \ a user that the web site trusts or has\n   authenticated (e.g., via HTTP redirects\
    \ or HTML forms).  CSRF attacks\n   on OAuth approvals can allow an attacker to\
    \ obtain authorization to\n   OAuth protected resources without the consent of\
    \ the user.\n   This attack works against the redirect URI used in the authorization\n\
    \   \"code\" flow.  An attacker could authorize an authorization \"code\" to\n\
    \   their own protected resources on an authorization server.  He then\n   aborts\
    \ the redirect flow back to the client on his device and tricks\n   the victim\
    \ into executing the redirect back to the client.  The\n   client receives the\
    \ redirect, fetches the token(s) from the\n   authorization server, and associates\
    \ the victim's client session with\n   the resources accessible using the token.\n\
    \   Impact: The user accesses resources on behalf of the attacker.  The\n   effective\
    \ impact depends on the type of resource accessed.  For\n   example, the user\
    \ may upload private items to an attacker's\n   resources.  Or, when using OAuth\
    \ in 3rd-party login scenarios, the\n   user may associate his client account\
    \ with the attacker's identity at\n   the external Identity Provider.  In this\
    \ way, the attacker could\n   easily access the victim's data at the client by\
    \ logging in from\n   another device with his credentials at the external Identity\n\
    \   Provider.\n   Countermeasures:\n   o  The \"state\" parameter should be used\
    \ to link the authorization\n      request with the redirect URI used to deliver\
    \ the access token\n      (Section 5.3.5).\n   o  Client developers and end users\
    \ can be educated to not follow\n      untrusted URLs.\n"
- title: '4.4.1.9.  Threat: Clickjacking Attack against Authorization'
  contents:
  - "4.4.1.9.  Threat: Clickjacking Attack against Authorization\n   With clickjacking,\
    \ a malicious site loads the target site in a\n   transparent iFrame (see [iFrame])\
    \ overlaid on top of a set of dummy\n   buttons that are carefully constructed\
    \ to be placed directly under\n   important buttons on the target site.  When\
    \ a user clicks a visible\n   button, they are actually clicking a button (such\
    \ as an \"Authorize\"\n   button) on the hidden page.\n   Impact: An attacker\
    \ can steal a user's authentication credentials and\n   access their resources.\n\
    \   Countermeasures:\n   o  For newer browsers, avoidance of iFrames during authorization\
    \ can\n      be enforced on the server side by using the X-FRAME-OPTIONS header\n\
    \      (Section 5.2.2.6).\n   o  For older browsers, JavaScript frame-busting\
    \ (see [Framebusting])\n      techniques can be used but may not be effective\
    \ in all browsers.\n"
- title: '4.4.1.10.  Threat: Resource Owner Impersonation'
  contents:
  - "4.4.1.10.  Threat: Resource Owner Impersonation\n   When a client requests access\
    \ to protected resources, the\n   authorization flow normally involves the resource\
    \ owner's explicit\n   response to the access request, either granting or denying\
    \ access to\n   the protected resources.  A malicious client can exploit knowledge\
    \ of\n   the structure of this flow in order to gain authorization without the\n\
    \   resource owner's consent, by transmitting the necessary requests\n   programmatically\
    \ and simulating the flow against the authorization\n   server.  That way, the\
    \ client may gain access to the victim's\n   resources without her approval. \
    \ An authorization server will be\n   vulnerable to this threat if it uses non-interactive\
    \ authentication\n   mechanisms or splits the authorization flow across multiple\
    \ pages.\n   The malicious client might embed a hidden HTML user agent, interpret\n\
    \   the HTML forms sent by the authorization server, and automatically\n   send\
    \ the corresponding form HTTP POST requests.  As a prerequisite,\n   the attacker\
    \ must be able to execute the authorization process in the\n   context of an already-authenticated\
    \ session of the resource owner\n   with the authorization server.  There are\
    \ different ways to achieve\n   this:\n   o  The malicious client could abuse\
    \ an existing session in an\n      external browser or cross-browser cookies on\
    \ the particular\n      device.\n   o  The malicious client could also request\
    \ authorization for an\n      initial scope acceptable to the user and then silently\
    \ abuse the\n      resulting session in his browser instance to \"silently\" request\n\
    \      another scope.\n   o  Alternatively, the attacker might exploit an authorization\n\
    \      server's ability to authenticate the resource owner automatically\n   \
    \   and without user interactions, e.g., based on certificates.\n   In all cases,\
    \ such an attack is limited to clients running on the\n   victim's device, either\
    \ within the user agent or as a native app.\n   Please note: Such attacks cannot\
    \ be prevented using CSRF\n   countermeasures, since the attacker just \"executes\"\
    \ the URLs as\n   prepared by the authorization server including any nonce, etc.\n\
    \   Countermeasures:\n   Authorization servers should decide, based on an analysis\
    \ of the risk\n   associated with this threat, whether to detect and prevent this\n\
    \   threat.\n   In order to prevent such an attack, the authorization server may\n\
    \   force a user interaction based on non-predictable input values as\n   part\
    \ of the user consent approval.  The authorization server could\n   o  combine\
    \ password authentication and user consent in a single form,\n   o  make use of\
    \ CAPTCHAs, or\n   o  use one-time secrets sent out of band to the resource owner\
    \ (e.g.,\n      via text or instant message).\n   Alternatively, in order to allow\
    \ the resource owner to detect abuse,\n   the authorization server could notify\
    \ the resource owner of any\n   approval by appropriate means, e.g., text or instant\
    \ message, or\n   email.\n"
- title: '4.4.1.11.  Threat: DoS Attacks That Exhaust Resources'
  contents:
  - "4.4.1.11.  Threat: DoS Attacks That Exhaust Resources\n   If an authorization\
    \ server includes a nontrivial amount of entropy in\n   authorization \"codes\"\
    \ or access tokens (limiting the number of\n   possible codes/tokens) and automatically\
    \ grants either without user\n   intervention and has no limit on codes or access\
    \ tokens per user, an\n   attacker could exhaust the pool of authorization \"\
    codes\" by\n   repeatedly directing the user's browser to request authorization\n\
    \   \"codes\" or access tokens.\n   Countermeasures:\n   o  The authorization\
    \ server should consider limiting the number of\n      access tokens granted per\
    \ user.\n   o  The authorization server should include a nontrivial amount of\n\
    \      entropy in authorization \"codes\".\n"
- title: '4.4.1.12.  Threat: DoS Using Manufactured Authorization "codes"'
  contents:
  - "4.4.1.12.  Threat: DoS Using Manufactured Authorization \"codes\"\n   An attacker\
    \ who owns a botnet can locate the redirect URIs of clients\n   that listen on\
    \ HTTP, access them with random authorization \"codes\",\n   and cause a large\
    \ number of HTTPS connections to be concentrated onto\n   the authorization server.\
    \  This can result in a denial-of-service\n   (DoS) attack on the authorization\
    \ server.\n   This attack can still be effective even when CSRF defense/the \"\
    state\"\n   parameter (see Section 4.4.1.8) is deployed on the client side.  With\n\
    \   such a defense, the attacker might need to incur an additional HTTP\n   request\
    \ to obtain a valid CSRF code/\"state\" parameter.  This\n   apparently cuts down\
    \ the effectiveness of the attack by a factor of\n   2.  However, if the HTTPS/HTTP\
    \ cost ratio is higher than 2 (the cost\n   factor is estimated to be around 3.5x\
    \ at [SSL-Latency]), the attacker\n   still achieves a magnification of resource\
    \ utilization at the expense\n   of the authorization server.\n   Impact: There\
    \ are a few effects that the attacker can accomplish with\n   this OAuth flow\
    \ that they cannot easily achieve otherwise.\n   1.  Connection laundering: With\
    \ the clients as the relay between the\n       attacker and the authorization\
    \ server, the authorization server\n       learns little or no information about\
    \ the identity of the\n       attacker.  Defenses such as rate-limiting on the\
    \ offending\n       attacker machines are less effective because it is difficult\
    \ to\n       identify the attacking machines.  Although an attacker could also\n\
    \       launder its connections through an anonymizing system such as\n      \
    \ Tor, the effectiveness of that approach depends on the capacity\n       of the\
    \ anonymizing system.  On the other hand, a potentially\n       large number of\
    \ OAuth clients could be utilized for this attack.\n   2.  Asymmetric resource\
    \ utilization: The attacker incurs the cost of\n       an HTTP connection and\
    \ causes an HTTPS connection to be made on\n       the authorization server; the\
    \ attacker can coordinate the timing\n       of such HTTPS connections across\
    \ multiple clients relatively\n       easily.  Although the attacker could achieve\
    \ something similar,\n       say, by including an iFrame pointing to the HTTPS\
    \ URL of the\n       authorization server in an HTTP web page and luring web users\
    \ to\n       visit that page, timing attacks using such a scheme may be more\n\
    \       difficult, as it seems nontrivial to synchronize a large number\n    \
    \   of users to simultaneously visit a particular site under the\n       attacker's\
    \ control.\n   Countermeasures:\n   o  Though not a complete countermeasure by\
    \ themselves, CSRF defense\n      and the \"state\" parameter created with secure\
    \ random codes should\n      be deployed on the client side.  The client should\
    \ forward the\n      authorization \"code\" to the authorization server only after\
    \ both\n      the CSRF token and the \"state\" parameter are validated.\n   o\
    \  If the client authenticates the user, either through a single-\n      sign-on\
    \ protocol or through local authentication, the client\n      should suspend the\
    \ access by a user account if the number of\n      invalid authorization \"codes\"\
    \ submitted by this user exceeds a\n      certain threshold.\n   o  The authorization\
    \ server should send an error response to the\n      client reporting an invalid\
    \ authorization \"code\" and rate-limit or\n      disallow connections from clients\
    \ whose number of invalid requests\n      exceeds a threshold.\n"
- title: '4.4.1.13.  Threat: Code Substitution (OAuth Login)'
  contents:
  - "4.4.1.13.  Threat: Code Substitution (OAuth Login)\n   An attacker could attempt\
    \ to log into an application or web site\n   using a victim's identity.  Applications\
    \ relying on identity data\n   provided by an OAuth protected service API to login\
    \ users are\n   vulnerable to this threat.  This pattern can be found in so-called\n\
    \   \"social login\" scenarios.\n   As a prerequisite, a resource server offers\
    \ an API to obtain personal\n   information about a user that could be interpreted\
    \ as having obtained\n   a user identity.  In this sense, the client is treating\
    \ the resource\n   server API as an \"identity\" API.  A client utilizes OAuth\
    \ to obtain\n   an access token for the identity API.  It then queries the identity\n\
    \   API for an identifier and uses it to look up its internal user\n   account\
    \ data (login).  The client assumes that, because it was able\n   to obtain information\
    \ about the user, the user has been\n   authenticated.\n   If the client uses\
    \ the grant type \"code\", the attacker needs to\n   gather a valid authorization\
    \ \"code\" of the respective victim from the\n   same Identity Provider used by\
    \ the target client application.  The\n   attacker tricks the victim into logging\
    \ into a malicious app (which\n   may appear to be legitimate to the Identity\
    \ Provider) using the same\n   Identity Provider as the target application.  This\
    \ results in the\n   Identity Provider's authorization server issuing an authorization\n\
    \   \"code\" for the respective identity API.  The malicious app then sends\n\
    \   this code to the attacker, which in turn triggers a login process\n   within\
    \ the target application.  The attacker now manipulates the\n   authorization\
    \ response and substitutes their code (bound to their\n   identity) for the victim's\
    \ code.  This code is then exchanged by the\n   client for an access token, which\
    \ in turn is accepted by the identity\n   API, since the audience, with respect\
    \ to the resource server, is\n   correct.  But since the identifier returned by\
    \ the identity API is\n   determined by the identity in the access token (issued\
    \ based on the\n   victim's code), the attacker is logged into the target application\n\
    \   under the victim's identity.\n   Impact: The attacker gains access to an application\
    \ and user-specific\n   data within the application.\n   Countermeasures:\n  \
    \ o  All clients must indicate their client ids with every request to\n      exchange\
    \ an authorization \"code\" for an access token.  The\n      authorization server\
    \ must validate whether the particular\n      authorization \"code\" has been\
    \ issued to the particular client.  If\n      possible, the client shall be authenticated\
    \ beforehand.\n   o  Clients should use an appropriate protocol, such as OpenID\
    \ (cf.\n      [OPENID]) or SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to\n    \
    \  implement user login.  Both support audience restrictions on\n      clients.\n"
- title: 4.4.2.  Implicit Grant
  contents:
  - "4.4.2.  Implicit Grant\n   In the implicit grant type flow, the access token\
    \ is directly\n   returned to the client as a fragment part of the redirect URI.\
    \  It is\n   assumed that the token is not sent to the redirect URI target, as\n\
    \   HTTP user agents do not send the fragment part of URIs to HTTP\n   servers.\
    \  Thus, an attacker cannot eavesdrop the access token on this\n   communication\
    \ path, and the token cannot leak through HTTP referrer\n   headers.\n"
- title: '4.4.2.1.  Threat: Access Token Leak in Transport/Endpoints'
  contents:
  - "4.4.2.1.  Threat: Access Token Leak in Transport/Endpoints\n   This token might\
    \ be eavesdropped by an attacker.  The token is sent\n   from the server to the\
    \ client via a URI fragment of the redirect URI.\n   If the communication is not\
    \ secured or the endpoint is not secured,\n   the token could be leaked by parsing\
    \ the returned URI.\n   Impact: The attacker would be able to assume the same\
    \ rights granted\n   by the token.\n   Countermeasures:\n   o  The authorization\
    \ server should ensure confidentiality (e.g.,\n      using TLS) of the response\
    \ from the authorization server to the\n      client (see Section 5.1.1).\n"
- title: '4.4.2.2.  Threat: Access Token Leak in Browser History'
  contents:
  - "4.4.2.2.  Threat: Access Token Leak in Browser History\n   An attacker could\
    \ obtain the token from the browser's history.  Note\n   that this means the attacker\
    \ needs access to the particular device.\n   Countermeasures:\n   o  Use short\
    \ expiry time for tokens (see Section 5.1.5.3).  Reduced\n      scope of the token\
    \ may reduce the impact of that attack (see\n      Section 5.1.5.1).\n   o  Make\
    \ responses non-cacheable.\n"
- title: '4.4.2.3.  Threat: Malicious Client Obtains Authorization'
  contents:
  - "4.4.2.3.  Threat: Malicious Client Obtains Authorization\n   A malicious client\
    \ could attempt to obtain a token by fraud.\n   The same countermeasures as for\
    \ Section 4.4.1.4 are applicable,\n   except client authentication.\n"
- title: '4.4.2.4.  Threat: Manipulation of Scripts'
  contents:
  - "4.4.2.4.  Threat: Manipulation of Scripts\n   A hostile party could act as the\
    \ client web server and replace or\n   modify the actual implementation of the\
    \ client (script).  This could\n   be achieved using DNS or ARP spoofing.  This\
    \ applies to clients\n   implemented within the web browser in a scripting language.\n\
    \   Impact: The attacker could obtain user credential information and\n   assume\
    \ the full identity of the user.\n   Countermeasures:\n   o  The authorization\
    \ server should authenticate the server from which\n      scripts are obtained\
    \ (see Section 5.1.2).\n   o  The client should ensure that scripts obtained have\
    \ not been\n      altered in transport (see Section 5.1.1).\n   o  Introduce one-time,\
    \ per-use secrets (e.g., \"client_secret\") values\n      that can only be used\
    \ by scripts in a small time window once\n      loaded from a server.  The intention\
    \ would be to reduce the\n      effectiveness of copying client-side scripts for\
    \ re-use in an\n      attacker's modified code.\n"
- title: '4.4.2.5.  Threat: CSRF Attack against redirect-uri'
  contents:
  - "4.4.2.5.  Threat: CSRF Attack against redirect-uri\n   CSRF attacks (see Section\
    \ 4.4.1.8) also work against the redirect URI\n   used in the implicit grant flow.\
    \  An attacker could acquire an access\n   token to their own protected resources.\
    \  He could then construct a\n   redirect URI and embed their access token in\
    \ that URI.  If he can\n   trick the user into following the redirect URI and\
    \ the client does\n   not have protection against this attack, the user may have\
    \ the\n   attacker's access token authorized within their client.\n   Impact:\
    \ The user accesses resources on behalf of the attacker.  The\n   effective impact\
    \ depends on the type of resource accessed.  For\n   example, the user may upload\
    \ private items to an attacker's\n   resources.  Or, when using OAuth in 3rd-party\
    \ login scenarios, the\n   user may associate his client account with the attacker's\
    \ identity at\n   the external Identity Provider.  In this way, the attacker could\n\
    \   easily access the victim's data at the client by logging in from\n   another\
    \ device with his credentials at the external Identity\n   Provider.\n   Countermeasures:\n\
    \   o  The \"state\" parameter should be used to link the authorization\n    \
    \  request with the redirect URI used to deliver the access token.\n      This\
    \ will ensure that the client is not tricked into completing\n      any redirect\
    \ callback unless it is linked to an authorization\n      request initiated by\
    \ the client.  The \"state\" parameter should not\n      be guessable, and the\
    \ client should be capable of keeping the\n      \"state\" parameter secret.\n\
    \   o  Client developers and end users can be educated to not follow\n      untrusted\
    \ URLs.\n"
- title: '4.4.2.6.  Threat: Token Substitution (OAuth Login)'
  contents:
  - "4.4.2.6.  Threat: Token Substitution (OAuth Login)\n   An attacker could attempt\
    \ to log into an application or web site\n   using a victim's identity.  Applications\
    \ relying on identity data\n   provided by an OAuth protected service API to login\
    \ users are\n   vulnerable to this threat.  This pattern can be found in so-called\n\
    \   \"social login\" scenarios.\n   As a prerequisite, a resource server offers\
    \ an API to obtain personal\n   information about a user that could be interpreted\
    \ as having obtained\n   a user identity.  In this sense, the client is treating\
    \ the resource\n   server API as an \"identity\" API.  A client utilizes OAuth\
    \ to obtain\n   an access token for the identity API.  It then queries the identity\n\
    \   API for an identifier and uses it to look up its internal user\n   account\
    \ data (login).  The client assumes that, because it was able\n   to obtain information\
    \ about the user, the user has been\n   authenticated.\n   To succeed, the attacker\
    \ needs to gather a valid access token of the\n   respective victim from the same\
    \ Identity Provider used by the target\n   client application.  The attacker tricks\
    \ the victim into logging into\n   a malicious app (which may appear to be legitimate\
    \ to the Identity\n   Provider) using the same Identity Provider as the target\
    \ application.\n   This results in the Identity Provider's authorization server\
    \ issuing\n   an access token for the respective identity API.  The malicious\
    \ app\n   then sends this access token to the attacker, which in turn triggers\n\
    \   a login process within the target application.  The attacker now\n   manipulates\
    \ the authorization response and substitutes their access\n   token (bound to\
    \ their identity) for the victim's access token.  This\n   token is accepted by\
    \ the identity API, since the audience, with\n   respect to the resource server,\
    \ is correct.  But since the identifier\n   returned by the identity API is determined\
    \ by the identity in the\n   access token, the attacker is logged into the target\
    \ application\n   under the victim's identity.\n   Impact: The attacker gains\
    \ access to an application and user-specific\n   data within the application.\n\
    \   Countermeasures:\n   o  Clients should use an appropriate protocol, such as\
    \ OpenID (cf.\n      [OPENID]) or SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to\n\
    \      implement user login.  Both support audience restrictions on\n      clients.\n"
- title: 4.4.3.  Resource Owner Password Credentials
  contents:
  - "4.4.3.  Resource Owner Password Credentials\n   The resource owner password credentials\
    \ grant type (see [RFC6749],\n   Section 4.3), often used for legacy/migration\
    \ reasons, allows a\n   client to request an access token using an end-user's\
    \ user id and\n   password along with its own credential.  This grant type has\
    \ higher\n   risk because it maintains the UID/password anti-pattern.\n   Additionally,\
    \ because the user does not have control over the\n   authorization process, clients\
    \ using this grant type are not limited\n   by scope but instead have potentially\
    \ the same capabilities as the\n   user themselves.  As there is no authorization\
    \ step, the ability to\n   offer token revocation is bypassed.\n   Because passwords\
    \ are often used for more than 1 service, this\n   anti-pattern may also put at\
    \ risk whatever else is accessible with\n   the supplied credential.  Additionally,\
    \ any easily derived equivalent\n   (e.g., joe@example.com and joe@example.net)\
    \ might easily allow\n   someone to guess that the same password can be used elsewhere.\n\
    \   Impact: The resource server can only differentiate scope based on the\n  \
    \ access token being associated with a particular client.  The client\n   could\
    \ also acquire long-lived tokens and pass them up to an\n   attacker's web service\
    \ for further abuse.  The client, eavesdroppers,\n   or endpoints could eavesdrop\
    \ the user id and password.\n   Countermeasures:\n   o  Except for migration reasons,\
    \ minimize use of this grant type.\n   o  The authorization server should validate\
    \ the client id associated\n      with the particular refresh token with every\
    \ refresh request\n      (Section 5.2.2.2).\n   o  As per the core OAuth specification,\
    \ the authorization server must\n      ensure that these transmissions are protected\
    \ using transport-\n      layer mechanisms such as TLS (see Section 5.1.1).\n\
    \   o  Rather than encouraging users to use a UID and password, service\n    \
    \  providers should instead encourage users not to use the same\n      password\
    \ for multiple services.\n   o  Limit use of resource owner password credential\
    \ grants to\n      scenarios where the client application and the authorizing\
    \ service\n      are from the same organization.\n"
- title: '4.4.3.1.  Threat: Accidental Exposure of Passwords at Client Site'
  contents:
  - "4.4.3.1.  Threat: Accidental Exposure of Passwords at Client Site\n   If the\
    \ client does not provide enough protection, an attacker or\n   disgruntled employee\
    \ could retrieve the passwords for a user.\n   Countermeasures:\n   o  Use other\
    \ flows that do not rely on the client's cooperation for\n      secure resource\
    \ owner credential handling.\n   o  Use digest authentication instead of plaintext\
    \ credential\n      processing.\n   o  Obfuscate passwords in logs.\n"
- title: '4.4.3.2.  Threat: Client Obtains Scopes without End-User Authorization'
  contents:
  - "4.4.3.2.  Threat: Client Obtains Scopes without End-User Authorization\n   All\
    \ interaction with the resource owner is performed by the client.\n   Thus it\
    \ might, intentionally or unintentionally, happen that the\n   client obtains\
    \ a token with scope unknown for, or unintended by, the\n   resource owner.  For\
    \ example, the resource owner might think the\n   client needs and acquires read-only\
    \ access to its media storage only\n   but the client tries to acquire an access\
    \ token with full access\n   permissions.\n   Countermeasures:\n   o  Use other\
    \ flows that do not rely on the client's cooperation for\n      resource owner\
    \ interaction.\n   o  The authorization server may generally restrict the scope\
    \ of\n      access tokens (Section 5.1.5.1) issued by this flow.  If the\n   \
    \   particular client is trustworthy and can be authenticated in a\n      reliable\
    \ way, the authorization server could relax that\n      restriction.  Resource\
    \ owners may prescribe (e.g., in their\n      preferences) what the maximum scope\
    \ is for clients using this\n      flow.\n   o  The authorization server could\
    \ notify the resource owner by an\n      appropriate medium, e.g., email, of the\
    \ grant issued (see\n      Section 5.1.3).\n"
- title: '4.4.3.3.  Threat: Client Obtains Refresh Token through Automatic'
  contents:
  - "4.4.3.3.  Threat: Client Obtains Refresh Token through Automatic\n          Authorization\n\
    \   All interaction with the resource owner is performed by the client.\n   Thus\
    \ it might, intentionally or unintentionally, happen that the\n   client obtains\
    \ a long-term authorization represented by a refresh\n   token even if the resource\
    \ owner did not intend so.\n   Countermeasures:\n   o  Use other flows that do\
    \ not rely on the client's cooperation for\n      resource owner interaction.\n\
    \   o  The authorization server may generally refuse to issue refresh\n      tokens\
    \ in this flow (see Section 5.2.2.1).  If the particular\n      client is trustworthy\
    \ and can be authenticated in a reliable way\n      (see client authentication),\
    \ the authorization server could relax\n      that restriction.  Resource owners\
    \ may allow or deny (e.g., in\n      their preferences) the issuing of refresh\
    \ tokens using this flow\n      as well.\n   o  The authorization server could\
    \ notify the resource owner by an\n      appropriate medium, e.g., email, of the\
    \ refresh token issued (see\n      Section 5.1.3).\n"
- title: '4.4.3.4.  Threat: Obtaining User Passwords on Transport'
  contents:
  - "4.4.3.4.  Threat: Obtaining User Passwords on Transport\n   An attacker could\
    \ attempt to eavesdrop the transmission of end-user\n   credentials with the grant\
    \ type \"password\" between the client and\n   server.\n   Impact: Disclosure\
    \ of a single end-user's password.\n   Countermeasures:\n   o  Ensure confidentiality\
    \ of requests (Section 5.1.1).\n   o  Use alternative authentication means that\
    \ do not require the\n      sending of plaintext credentials over the wire (e.g.,\
    \ Hash-based\n      Message Authentication Code).\n"
- title: '4.4.3.5.  Threat: Obtaining User Passwords from Authorization Server'
  contents:
  - "4.4.3.5.  Threat: Obtaining User Passwords from Authorization Server\n      \
    \    Database\n   An attacker may obtain valid username/password combinations\
    \ from the\n   authorization server's database by gaining access to the database\
    \ or\n   launching a SQL injection attack.\n   Impact: Disclosure of all username/password\
    \ combinations.  The impact\n   may exceed the domain of the authorization server,\
    \ since many users\n   tend to use the same credentials on different services.\n\
    \   Countermeasures:\n   o  Enforce credential storage protection best practices\n\
    \      (Section 5.1.4.1).\n"
- title: '4.4.3.6.  Threat: Online Guessing'
  contents:
  - "4.4.3.6.  Threat: Online Guessing\n   An attacker may try to guess valid username/password\
    \ combinations\n   using the grant type \"password\".\n   Impact: Revelation of\
    \ a single username/password combination.\n   Countermeasures:\n   o  Utilize\
    \ secure password policy (Section 5.1.4.2.1).\n   o  Lock accounts (Section 5.1.4.2.3).\n\
    \   o  Use tar pit (Section 5.1.4.2.4).\n   o  Use CAPTCHAs (Section 5.1.4.2.5).\n\
    \   o  Consider not using the grant type \"password\".\n   o  Client authentication\
    \ (see Section 5.2.3) will provide another\n      authentication factor and thus\
    \ hinder the attack.\n"
- title: 4.4.4.  Client Credentials
  contents:
  - "4.4.4.  Client Credentials\n   Client credentials (see [RFC6749], Section 3)\
    \ consist of an\n   identifier (not secret) combined with an additional means\
    \ (such as a\n   matching client secret) of authenticating a client.  The threats\
    \ to\n   this grant type are similar to those described in Section 4.4.3.\n"
- title: 4.5.  Refreshing an Access Token
  contents:
  - '4.5.  Refreshing an Access Token

    '
- title: '4.5.1.  Threat: Eavesdropping Refresh Tokens from Authorization Server'
  contents:
  - "4.5.1.  Threat: Eavesdropping Refresh Tokens from Authorization Server\n   An\
    \ attacker may eavesdrop refresh tokens when they are transmitted\n   from the\
    \ authorization server to the client.\n   Countermeasures:\n   o  As per the core\
    \ OAuth spec, the authorization servers must ensure\n      that these transmissions\
    \ are protected using transport-layer\n      mechanisms such as TLS (see Section\
    \ 5.1.1).\n   o  If end-to-end confidentiality cannot be guaranteed, reducing\
    \ scope\n      (see Section 5.1.5.1) and expiry time (see Section 5.1.5.3) for\n\
    \      issued access tokens can be used to reduce the damage in case of\n    \
    \  leaks.\n"
- title: '4.5.2.  Threat: Obtaining Refresh Token from Authorization Server'
  contents:
  - "4.5.2.  Threat: Obtaining Refresh Token from Authorization Server\n        Database\n\
    \   This threat is applicable if the authorization server stores refresh\n   tokens\
    \ as handles in a database.  An attacker may obtain refresh\n   tokens from the\
    \ authorization server's database by gaining access to\n   the database or launching\
    \ a SQL injection attack.\n   Impact: Disclosure of all refresh tokens.\n   Countermeasures:\n\
    \   o  Enforce credential storage protection best practices\n      (Section 5.1.4.1).\n\
    \   o  Bind token to client id, if the attacker cannot obtain the\n      required\
    \ id and secret (Section 5.1.5.8).\n"
- title: '4.5.3.  Threat: Obtaining Refresh Token by Online Guessing'
  contents:
  - "4.5.3.  Threat: Obtaining Refresh Token by Online Guessing\n   An attacker may\
    \ try to guess valid refresh token values and send it\n   using the grant type\
    \ \"refresh_token\" in order to obtain a valid\n   access token.\n   Impact: Exposure\
    \ of a single refresh token and derivable access\n   tokens.\n   Countermeasures:\n\
    \   o  For handle-based designs (Section 5.1.4.2.2).\n   o  For assertion-based\
    \ designs (Section 5.1.5.9).\n   o  Bind token to client id, because the attacker\
    \ would guess the\n      matching client id, too (see Section 5.1.5.8).\n   o\
    \  Authenticate the client; this adds another element that the\n      attacker\
    \ has to guess (see Section 5.2.3.4).\n"
- title: '4.5.4.  Threat: Refresh Token Phishing by Counterfeit Authorization'
  contents:
  - "4.5.4.  Threat: Refresh Token Phishing by Counterfeit Authorization\n       \
    \ Server\n   An attacker could try to obtain valid refresh tokens by proxying\n\
    \   requests to the authorization server.  Given the assumption that the\n   authorization\
    \ server URL is well-known at development time or can at\n   least be obtained\
    \ from a well-known resource server, the attacker\n   must utilize some kind of\
    \ spoofing in order to succeed.\n   Countermeasures:\n   o  Utilize server authentication\
    \ (as described in Section 5.1.2).\n"
- title: 4.6.  Accessing Protected Resources
  contents:
  - '4.6.  Accessing Protected Resources

    '
- title: '4.6.1.  Threat: Eavesdropping Access Tokens on Transport'
  contents:
  - "4.6.1.  Threat: Eavesdropping Access Tokens on Transport\n   An attacker could\
    \ try to obtain a valid access token on transport\n   between the client and resource\
    \ server.  As access tokens are shared\n   secrets between the authorization server\
    \ and resource server, they\n   should be treated with the same care as other\
    \ credentials (e.g., end-\n   user passwords).\n   Countermeasures:\n   o  Access\
    \ tokens sent as bearer tokens should not be sent in the\n      clear over an\
    \ insecure channel.  As per the core OAuth spec,\n      transmission of access\
    \ tokens must be protected using transport-\n      layer mechanisms such as TLS\
    \ (see Section 5.1.1).\n   o  A short lifetime reduces impact in case tokens are\
    \ compromised\n      (see Section 5.1.5.3).\n   o  The access token can be bound\
    \ to a client's identifier and require\n      the client to prove legitimate ownership\
    \ of the token to the\n      resource server (see Section 5.4.2).\n"
- title: '4.6.2.  Threat: Replay of Authorized Resource Server Requests'
  contents:
  - "4.6.2.  Threat: Replay of Authorized Resource Server Requests\n   An attacker\
    \ could attempt to replay valid requests in order to obtain\n   or to modify/destroy\
    \ user data.\n   Countermeasures:\n   o  The resource server should utilize transport\
    \ security measures\n      (e.g., TLS) in order to prevent such attacks (see Section\
    \ 5.1.1).\n      This would prevent the attacker from capturing valid requests.\n\
    \   o  Alternatively, the resource server could employ signed requests\n     \
    \ (see Section 5.4.3) along with nonces and timestamps in order to\n      uniquely\
    \ identify requests.  The resource server should detect and\n      refuse every\
    \ replayed request.\n"
- title: '4.6.3.  Threat: Guessing Access Tokens'
  contents:
  - "4.6.3.  Threat: Guessing Access Tokens\n   Where the token is a handle, the attacker\
    \ may attempt to guess the\n   access token values based on knowledge they have\
    \ from other access\n   tokens.\n   Impact: Access to a single user's data.\n\
    \   Countermeasures:\n   o  Handle tokens should have a reasonable level of entropy\
    \ (see\n      Section 5.1.4.2.2) in order to make guessing a valid token value\n\
    \      infeasible.\n   o  Assertion (or self-contained token) token contents should\
    \ be\n      protected by a digital signature (see Section 5.1.5.9).\n   o  Security\
    \ can be further strengthened by using a short access token\n      duration (see\
    \ Sections 5.1.5.2 and 5.1.5.3).\n"
- title: '4.6.4.  Threat: Access Token Phishing by Counterfeit Resource Server'
  contents:
  - "4.6.4.  Threat: Access Token Phishing by Counterfeit Resource Server\n   An attacker\
    \ may pretend to be a particular resource server and to\n   accept tokens from\
    \ a particular authorization server.  If the client\n   sends a valid access token\
    \ to this counterfeit resource server, the\n   server in turn may use that token\
    \ to access other services on behalf\n   of the resource owner.\n   Countermeasures:\n\
    \   o  Clients should not make authenticated requests with an access\n      token\
    \ to unfamiliar resource servers, regardless of the presence\n      of a secure\
    \ channel.  If the resource server URL is well-known to\n      the client, it\
    \ may authenticate the resource servers (see\n      Section 5.1.2).\n   o  Associate\
    \ the endpoint URL of the resource server the client\n      talked to with the\
    \ access token (e.g., in an audience field) and\n      validate the association\
    \ at a legitimate resource server.  The\n      endpoint URL validation policy\
    \ may be strict (exact match) or more\n      relaxed (e.g., same host).  This\
    \ would require telling the\n      authorization server about the resource server\
    \ endpoint URL in the\n      authorization process.\n   o  Associate an access\
    \ token with a client and authenticate the\n      client with resource server\
    \ requests (typically via a signature,\n      in order to not disclose a secret\
    \ to a potential attacker).  This\n      prevents the attack because the counterfeit\
    \ server is assumed to\n      lack the capability to correctly authenticate on\
    \ behalf of the\n      legitimate client to the resource server (Section 5.4.2).\n\
    \   o  Restrict the token scope (see Section 5.1.5.1) and/or limit the\n     \
    \ token to a certain resource server (Section 5.1.5.5).\n"
- title: '4.6.5.  Threat: Abuse of Token by Legitimate Resource Server or Client'
  contents:
  - "4.6.5.  Threat: Abuse of Token by Legitimate Resource Server or Client\n   A\
    \ legitimate resource server could attempt to use an access token to\n   access\
    \ another resource server.  Similarly, a client could try to use\n   a token obtained\
    \ for one server on another resource server.\n   Countermeasures:\n   o  Tokens\
    \ should be restricted to particular resource servers (see\n      Section 5.1.5.5).\n"
- title: '4.6.6.  Threat: Leak of Confidential Data in HTTP Proxies'
  contents:
  - "4.6.6.  Threat: Leak of Confidential Data in HTTP Proxies\n   An OAuth HTTP authentication\
    \ scheme as discussed in [RFC6749] is\n   optional.  However, [RFC2616] relies\
    \ on the Authorization and\n   WWW-Authenticate headers to distinguish authenticated\
    \ content so that\n   it can be protected.  Proxies and caches, in particular,\
    \ may fail to\n   adequately protect requests not using these headers.  For example,\n\
    \   private authenticated content may be stored in (and thus be\n   retrievable\
    \ from) publicly accessible caches.\n   Countermeasures:\n   o  Clients and resource\
    \ servers not using an OAuth HTTP\n      authentication scheme (see Section 5.4.1)\
    \ should take care to use\n      Cache-Control headers to minimize the risk that\
    \ authenticated\n      content is not protected.  Such clients should send a\n\
    \      Cache-Control header containing the \"no-store\" option [RFC2616].\n  \
    \    Resource server success (2XX status) responses to these requests\n      should\
    \ contain a Cache-Control header with the \"private\" option\n      [RFC2616].\n\
    \   o  Reducing scope (see Section 5.1.5.1) and expiry time\n      (Section 5.1.5.3)\
    \ for access tokens can be used to reduce the\n      damage in case of leaks.\n"
- title: '4.6.7.  Threat: Token Leakage via Log Files and HTTP Referrers'
  contents:
  - "4.6.7.  Threat: Token Leakage via Log Files and HTTP Referrers\n   If access\
    \ tokens are sent via URI query parameters, such tokens may\n   leak to log files\
    \ and the HTTP \"referer\".\n   Countermeasures:\n   o  Use Authorization headers\
    \ or POST parameters instead of URI\n      request parameters (see Section 5.4.1).\n\
    \   o  Set logging configuration appropriately.\n   o  Prevent unauthorized persons\
    \ from access to system log files (see\n      Section 5.1.4.1.1).\n   o  Abuse\
    \ of leaked access tokens can be prevented by enforcing\n      authenticated requests\
    \ (see Section 5.4.2).\n   o  The impact of token leakage may be reduced by limiting\
    \ scope (see\n      Section 5.1.5.1) and duration (see Section 5.1.5.3) and by\n\
    \      enforcing one-time token usage (see Section 5.1.5.4).\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This section describes the countermeasures as\
    \ recommended to mitigate\n   the threats described in Section 4.\n"
- title: 5.1.  General
  contents:
  - "5.1.  General\n   This section covers considerations that apply generally across\
    \ all\n   OAuth components (client, resource server, token server, and user\n\
    \   agents).\n"
- title: 5.1.1.  Ensure Confidentiality of Requests
  contents:
  - "5.1.1.  Ensure Confidentiality of Requests\n   This is applicable to all requests\
    \ sent from the client to the\n   authorization server or resource server.  While\
    \ OAuth provides a\n   mechanism for verifying the integrity of requests, it provides\
    \ no\n   guarantee of request confidentiality.  Unless further precautions are\n\
    \   taken, eavesdroppers will have full access to request content and may\n  \
    \ be able to mount interception or replay attacks by using the contents\n   of\
    \ requests, e.g., secrets or tokens.\n   Attacks can be mitigated by using transport-layer\
    \ mechanisms such as\n   TLS [RFC5246].  A virtual private network (VPN), e.g.,\
    \ based on IPsec\n   VPNs [RFC4301], may be considered as well.\n   Note: This\
    \ document assumes end-to-end TLS protected connections\n   between the respective\
    \ protocol entities.  Deployments deviating from\n   this assumption by offloading\
    \ TLS in between (e.g., on the data\n   center edge) must refine this threat model\
    \ in order to account for\n   the additional (mainly insider) threat this may\
    \ cause.\n   This is a countermeasure against the following threats:\n   o  Replay\
    \ of access tokens obtained on the token's endpoint or the\n      resource server's\
    \ endpoint\n   o  Replay of refresh tokens obtained on the token's endpoint\n\
    \   o  Replay of authorization \"codes\" obtained on the token's endpoint\n  \
    \    (redirect?)\n   o  Replay of user passwords and client secrets\n"
- title: 5.1.2.  Utilize Server Authentication
  contents:
  - "5.1.2.  Utilize Server Authentication\n   HTTPS server authentication or similar\
    \ means can be used to\n   authenticate the identity of a server.  The goal is\
    \ to reliably bind\n   the fully qualified domain name of the server to the public\
    \ key\n   presented by the server during connection establishment (see\n   [RFC2818]).\n\
    \   The client should validate the binding of the server to its domain\n   name.\
    \  If the server fails to prove that binding, the communication\n   is considered\
    \ a man-in-the-middle attack.  This security measure\n   depends on the certification\
    \ authorities the client trusts for that\n   purpose.  Clients should carefully\
    \ select those trusted CAs and\n   protect the storage for trusted CA certificates\
    \ from modifications.\n   This is a countermeasure against the following threats:\n\
    \   o  Spoofing\n   o  Proxying\n   o  Phishing by counterfeit servers\n"
- title: 5.1.3.  Always Keep the Resource Owner Informed
  contents:
  - "5.1.3.  Always Keep the Resource Owner Informed\n   Transparency to the resource\
    \ owner is a key element of the OAuth\n   protocol.  The user should always be\
    \ in control of the authorization\n   processes and get the necessary information\
    \ to make informed\n   decisions.  Moreover, user involvement is a further security\n\
    \   countermeasure.  The user can probably recognize certain kinds of\n   attacks\
    \ better than the authorization server.  Information can be\n   presented/exchanged\
    \ during the authorization process, after the\n   authorization process, and every\
    \ time the user wishes to get informed\n   by using techniques such as:\n   o\
    \  User consent forms.\n   o  Notification messages (e.g., email, SMS, ...). \
    \ Note that\n      notifications can be a phishing vector.  Messages should be\
    \ such\n      that look-alike phishing messages cannot be derived from them.\n\
    \   o  Activity/event logs.\n   o  User self-care applications or portals.\n"
- title: 5.1.4.  Credentials
  contents:
  - "5.1.4.  Credentials\n   This section describes countermeasures used to protect\
    \ all kinds of\n   credentials from unauthorized access and abuse.  Credentials\
    \ are\n   long-term secrets, such as client secrets and user passwords as well\n\
    \   as all kinds of tokens (refresh and access tokens) or authorization\n   \"\
    codes\".\n"
- title: 5.1.4.1.  Enforce Credential Storage Protection Best Practices
  contents:
  - "5.1.4.1.  Enforce Credential Storage Protection Best Practices\n   Administrators\
    \ should undertake industry best practices to protect\n   the storage of credentials\
    \ (for example, see [OWASP]).  Such\n   practices may include but are not limited\
    \ to the following\n   sub-sections.\n"
- title: 5.1.4.1.1.  Enforce Standard System Security Means
  contents:
  - "5.1.4.1.1.  Enforce Standard System Security Means\n   A server system may be\
    \ locked down so that no attacker may get access\n   to sensitive configuration\
    \ files and databases.\n"
- title: 5.1.4.1.2.  Enforce Standard SQL Injection Countermeasures
  contents:
  - "5.1.4.1.2.  Enforce Standard SQL Injection Countermeasures\n   If a client identifier\
    \ or other authentication component is queried\n   or compared against a SQL database,\
    \ it may become possible for an\n   injection attack to occur if parameters received\
    \ are not validated\n   before submission to the database.\n   o  Ensure that\
    \ server code is using the minimum database privileges\n      possible to reduce\
    \ the \"surface\" of possible attacks.\n   o  Avoid dynamic SQL using concatenated\
    \ input.  If possible, use\n      static SQL.\n   o  When using dynamic SQL, parameterize\
    \ queries using bind arguments.\n      Bind arguments eliminate the possibility\
    \ of SQL injections.\n   o  Filter and sanitize the input.  For example, if an\
    \ identifier has\n      a known format, ensure that the supplied value matches\
    \ the\n      identifier syntax rules.\n"
- title: 5.1.4.1.3.  No Cleartext Storage of Credentials
  contents:
  - "5.1.4.1.3.  No Cleartext Storage of Credentials\n   The authorization server\
    \ should not store credentials in clear text.\n   Typical approaches are to store\
    \ hashes instead or to encrypt\n   credentials.  If the credential lacks a reasonable\
    \ entropy level\n   (because it is a user password), an additional salt will harden\
    \ the\n   storage to make offline dictionary attacks more difficult.\n   Note:\
    \ Some authentication protocols require the authorization server\n   to have access\
    \ to the secret in the clear.  Those protocols cannot be\n   implemented if the\
    \ server only has access to hashes.  Credentials\n   should be strongly encrypted\
    \ in those cases.\n"
- title: 5.1.4.1.4.  Encryption of Credentials
  contents:
  - "5.1.4.1.4.  Encryption of Credentials\n   For client applications, insecurely\
    \ persisted client credentials are\n   easy targets for attackers to obtain. \
    \ Store client credentials using\n   an encrypted persistence mechanism such as\
    \ a keystore or database.\n   Note that compiling client credentials directly\
    \ into client code\n   makes client applications vulnerable to scanning as well\
    \ as difficult\n   to administer should client credentials change over time.\n"
- title: 5.1.4.1.5.  Use of Asymmetric Cryptography
  contents:
  - "5.1.4.1.5.  Use of Asymmetric Cryptography\n   Usage of asymmetric cryptography\
    \ will free the authorization server\n   of the obligation to manage credentials.\n"
- title: 5.1.4.2.  Online Attacks on Secrets
  contents:
  - '5.1.4.2.  Online Attacks on Secrets

    '
- title: 5.1.4.2.1.  Utilize Secure Password Policy
  contents:
  - "5.1.4.2.1.  Utilize Secure Password Policy\n   The authorization server may decide\
    \ to enforce a complex user\n   password policy in order to increase the user\
    \ passwords' entropy to\n   hinder online password attacks.  Note that too much\
    \ complexity can\n   increase the likelihood that users re-use passwords or write\
    \ them\n   down, or otherwise store them insecurely.\n"
- title: 5.1.4.2.2.  Use High Entropy for Secrets
  contents:
  - "5.1.4.2.2.  Use High Entropy for Secrets\n   When creating secrets not intended\
    \ for usage by human users (e.g.,\n   client secrets or token handles), the authorization\
    \ server should\n   include a reasonable level of entropy in order to mitigate\
    \ the risk\n   of guessing attacks.  The token value should be >=128 bits long\
    \ and\n   constructed from a cryptographically strong random or pseudo-random\n\
    \   number sequence (see [RFC4086] for best current practice) generated\n   by\
    \ the authorization server.\n"
- title: 5.1.4.2.3.  Lock Accounts
  contents:
  - "5.1.4.2.3.  Lock Accounts\n   Online attacks on passwords can be mitigated by\
    \ locking the\n   respective accounts after a certain number of failed attempts.\n\
    \   Note: This measure can be abused to lock down legitimate service\n   users.\n"
- title: 5.1.4.2.4.  Use Tar Pit
  contents:
  - "5.1.4.2.4.  Use Tar Pit\n   The authorization server may react on failed attempts\
    \ to authenticate\n   by username/password by temporarily locking the respective\
    \ account\n   and delaying the response for a certain duration.  This duration\
    \ may\n   increase with the number of failed attempts.  The objective is to\n\
    \   slow the attacker's attempts on a certain username down.\n   Note: This may\
    \ require a more complex and stateful design of the\n   authorization server.\n"
- title: 5.1.4.2.5.  Use CAPTCHAs
  contents:
  - "5.1.4.2.5.  Use CAPTCHAs\n   The idea is to prevent programs from automatically\
    \ checking a huge\n   number of passwords, by requiring human interaction.\n \
    \  Note: This has a negative impact on user experience.\n"
- title: 5.1.5.  Tokens (Access, Refresh, Code)
  contents:
  - '5.1.5.  Tokens (Access, Refresh, Code)

    '
- title: 5.1.5.1.  Limit Token Scope
  contents:
  - "5.1.5.1.  Limit Token Scope\n   The authorization server may decide to reduce\
    \ or limit the scope\n   associated with a token.  The basis of this decision\
    \ is out of scope;\n   examples are:\n   o  a client-specific policy, e.g., issue\
    \ only less powerful tokens to\n      public clients,\n   o  a service-specific\
    \ policy, e.g., it is a very sensitive service,\n   o  a resource-owner-specific\
    \ setting, or\n   o  combinations of such policies and preferences.\n   The authorization\
    \ server may allow different scopes dependent on the\n   grant type.  For example,\
    \ end-user authorization via direct\n   interaction with the end user (authorization\
    \ \"code\") might be\n   considered more reliable than direct authorization via\
    \ grant type\n   \"username\"/\"password\".  This means will reduce the impact\
    \ of the\n   following threats:\n   o  token leakage\n   o  token issuance to\
    \ malicious software\n   o  unintended issuance of powerful tokens with resource\
    \ owner\n      credentials flow\n"
- title: 5.1.5.2.  Determine Expiration Time
  contents:
  - "5.1.5.2.  Determine Expiration Time\n   Tokens should generally expire after\
    \ a reasonable duration.  This\n   complements and strengthens other security\
    \ measures (such as\n   signatures) and reduces the impact of all kinds of token\
    \ leaks.\n   Depending on the risk associated with token leakage, tokens may\n\
    \   expire after a few minutes (e.g., for payment transactions) or stay\n   valid\
    \ for hours (e.g., read access to contacts).\n   The expiration time is determined\
    \ by several factors, including:\n   o  risk associated with token leakage,\n\
    \   o  duration of the underlying access grant,\n   o  duration until the modification\
    \ of an access grant should take\n      effect, and\n   o  time required for an\
    \ attacker to guess or produce a valid token.\n"
- title: 5.1.5.3.  Use Short Expiration Time
  contents:
  - "5.1.5.3.  Use Short Expiration Time\n   A short expiration time for tokens is\
    \ a means of protection against\n   the following threats:\n   o  replay\n   o\
    \  token leak (a short expiration time will reduce impact)\n   o  online guessing\
    \ (a short expiration time will reduce the\n      likelihood of success)\n   Note:\
    \ Short token duration requires more precise clock\n   synchronization between\
    \ the authorization server and resource server.\n   Furthermore, shorter duration\
    \ may require more token refreshes\n   (access token) or repeated end-user authorization\
    \ processes\n   (authorization \"code\" and refresh token).\n"
- title: 5.1.5.4.  Limit Number of Usages or One-Time Usage
  contents:
  - "5.1.5.4.  Limit Number of Usages or One-Time Usage\n   The authorization server\
    \ may restrict the number of requests or\n   operations that can be performed\
    \ with a certain token.  This\n   mechanism can be used to mitigate the following\
    \ threats:\n   o  replay of tokens\n   o  guessing\n   For example, if an authorization\
    \ server observes more than one\n   attempt to redeem an authorization \"code\"\
    , the authorization server\n   may want to revoke all access tokens granted based\
    \ on the\n   authorization \"code\" as well as reject the current request.\n \
    \  As with the authorization \"code\", access tokens may also have a\n   limited\
    \ number of operations.  This either forces client applications\n   to re-authenticate\
    \ and use a refresh token to obtain a fresh access\n   token, or forces the client\
    \ to re-authorize the access token by\n   involving the user.\n"
- title: 5.1.5.5.  Bind Tokens to a Particular Resource Server (Audience)
  contents:
  - "5.1.5.5.  Bind Tokens to a Particular Resource Server (Audience)\n   Authorization\
    \ servers in multi-service environments may consider\n   issuing tokens with different\
    \ content to different resource servers\n   and to explicitly indicate in the\
    \ token the target server to which a\n   token is intended to be sent.  SAML assertions\
    \ (see\n   [OASIS.saml-core-2.0-os]) use the Audience element for this purpose.\n\
    \   This countermeasure can be used in the following situations:\n   o  It reduces\
    \ the impact of a successful replay attempt, since the\n      token is applicable\
    \ to a single resource server only.\n   o  It prevents abuse of a token by a rogue\
    \ resource server or client,\n      since the token can only be used on that server.\
    \  It is rejected\n      by other servers.\n   o  It reduces the impact of leakage\
    \ of a valid token to a counterfeit\n      resource server.\n"
- title: 5.1.5.6.  Use Endpoint Address as Token Audience
  contents:
  - "5.1.5.6.  Use Endpoint Address as Token Audience\n   This may be used to indicate\
    \ to a resource server which endpoint URL\n   has been used to obtain the token.\
    \  This measure will allow the\n   detection of requests from a counterfeit resource\
    \ server, since such\n   a token will contain the endpoint URL of that server.\n"
- title: 5.1.5.7.  Use Explicitly Defined Scopes for Audience and Tokens
  contents:
  - "5.1.5.7.  Use Explicitly Defined Scopes for Audience and Tokens\n   Deployments\
    \ may consider only using tokens with explicitly defined\n   scopes, where every\
    \ scope is associated with a particular resource\n   server.  This approach can\
    \ be used to mitigate attacks where a\n   resource server or client uses a token\
    \ for a different purpose than\n   the one intended.\n"
- title: 5.1.5.8.  Bind Token to Client id
  contents:
  - "5.1.5.8.  Bind Token to Client id\n   An authorization server may bind a token\
    \ to a certain client\n   identifier.  This identifier should be validated for\
    \ every request\n   with that token.  This technique can be used to\n   o  detect\
    \ token leakage and\n   o  prevent token abuse.\n   Note: Validating the client\
    \ identifier may require the target server\n   to authenticate the client's identifier.\
    \  This authentication can be\n   based on secrets managed independently of the\
    \ token (e.g.,\n   pre-registered client id/secret on authorization server) or\
    \ sent with\n   the token itself (e.g., as part of the encrypted token content).\n"
- title: 5.1.5.9.  Sign Self-Contained Tokens
  contents:
  - "5.1.5.9.  Sign Self-Contained Tokens\n   Self-contained tokens should be signed\
    \ in order to detect any attempt\n   to modify or produce faked tokens (e.g.,\
    \ Hash-based Message\n   Authentication Code or digital signatures).\n"
- title: 5.1.5.10.  Encrypt Token Content
  contents:
  - "5.1.5.10.  Encrypt Token Content\n   Self-contained tokens may be encrypted for\
    \ confidentiality reasons or\n   to protect system internal data.  Depending on\
    \ token format, keys\n   (e.g., symmetric keys) may have to be distributed between\
    \ server\n   nodes.  The method of distribution should be defined by the token\
    \ and\n   the encryption used.\n"
- title: 5.1.5.11.  Adopt a Standard Assertion Format
  contents:
  - "5.1.5.11.  Adopt a Standard Assertion Format\n   For service providers intending\
    \ to implement an assertion-based token\n   design, it is highly recommended to\
    \ adopt a standard assertion format\n   (such as SAML [OASIS.saml-core-2.0-os]\
    \ or the JavaScript Object\n   Notation Web Token (JWT) [OAuth-JWT]).\n"
- title: 5.1.6.  Access Tokens
  contents:
  - "5.1.6.  Access Tokens\n   The following measures should be used to protect access\
    \ tokens:\n   o  Keep them in transient memory (accessible by the client\n   \
    \   application only).\n   o  Pass tokens securely using secure transport (TLS).\n\
    \   o  Ensure that client applications do not share tokens with 3rd\n      parties.\n"
- title: 5.2.  Authorization Server
  contents:
  - "5.2.  Authorization Server\n   This section describes considerations related\
    \ to the OAuth\n   authorization server endpoint.\n"
- title: 5.2.1.  Authorization "codes"
  contents:
  - '5.2.1.  Authorization "codes"

    '
- title: 5.2.1.1.  Automatic Revocation of Derived Tokens If Abuse Is Detected
  contents:
  - "5.2.1.1.  Automatic Revocation of Derived Tokens If Abuse Is Detected\n   If\
    \ an authorization server observes multiple attempts to redeem an\n   authorization\
    \ grant (e.g., such as an authorization \"code\"), the\n   authorization server\
    \ may want to revoke all tokens granted based on\n   the authorization grant.\n"
- title: 5.2.2.  Refresh Tokens
  contents:
  - '5.2.2.  Refresh Tokens

    '
- title: 5.2.2.1.  Restricted Issuance of Refresh Tokens
  contents:
  - "5.2.2.1.  Restricted Issuance of Refresh Tokens\n   The authorization server\
    \ may decide, based on an appropriate policy,\n   not to issue refresh tokens.\
    \  Since refresh tokens are long-term\n   credentials, they may be subject to\
    \ theft.  For example, if the\n   authorization server does not trust a client\
    \ to securely store such\n   tokens, it may refuse to issue such a client a refresh\
    \ token.\n"
- title: 5.2.2.2.  Binding of Refresh Token to "client_id"
  contents:
  - "5.2.2.2.  Binding of Refresh Token to \"client_id\"\n   The authorization server\
    \ should match every refresh token to the\n   identifier of the client to whom\
    \ it was issued.  The authorization\n   server should check that the same \"client_id\"\
    \ is present for every\n   request to refresh the access token.  If possible (e.g.,\
    \ confidential\n   clients), the authorization server should authenticate the\
    \ respective\n   client.\n   This is a countermeasure against refresh token theft\
    \ or leakage.\n   Note: This binding should be protected from unauthorized\n \
    \  modifications.\n"
- title: 5.2.2.3.  Refresh Token Rotation
  contents:
  - "5.2.2.3.  Refresh Token Rotation\n   Refresh token rotation is intended to automatically\
    \ detect and\n   prevent attempts to use the same refresh token in parallel from\n\
    \   different apps/devices.  This happens if a token gets stolen from the\n  \
    \ client and is subsequently used by both the attacker and the\n   legitimate\
    \ client.  The basic idea is to change the refresh token\n   value with every\
    \ refresh request in order to detect attempts to\n   obtain access tokens using\
    \ old refresh tokens.  Since the\n   authorization server cannot determine whether\
    \ the attacker or the\n   legitimate client is trying to access, in case of such\
    \ an access\n   attempt the valid refresh token and the access authorization\n\
    \   associated with it are both revoked.\n   The OAuth specification supports\
    \ this measure in that the token's\n   response allows the authorization server\
    \ to return a new refresh\n   token even for requests with grant type \"refresh_token\"\
    .\n   Note: This measure may cause problems in clustered environments,\n   since\
    \ usage of the currently valid refresh token must be ensured.  In\n   such an\
    \ environment, other measures might be more appropriate.\n"
- title: 5.2.2.4.  Revocation of Refresh Tokens
  contents:
  - "5.2.2.4.  Revocation of Refresh Tokens\n   The authorization server may allow\
    \ clients or end users to explicitly\n   request the invalidation of refresh tokens.\
    \  A mechanism to revoke\n   tokens is specified in [OAuth-REVOCATION].\n   This\
    \ is a countermeasure against:\n   o  device theft,\n   o  impersonation of a\
    \ resource owner, or\n   o  suspected compromised client applications.\n"
- title: 5.2.2.5.  Device Identification
  contents:
  - "5.2.2.5.  Device Identification\n   The authorization server may require the\
    \ binding of authentication\n   credentials to a device identifier.  The International\
    \ Mobile Station\n   Equipment Identity [IMEI] is one example of such an identifier;\
    \ there\n   are also operating system-specific identifiers.  The authorization\n\
    \   server could include such an identifier when authenticating user\n   credentials\
    \ in order to detect token theft from a particular device.\n   Note: Any implementation\
    \ should consider potential privacy\n   implications of using device identifiers.\n"
- title: 5.2.2.6.  X-FRAME-OPTIONS Header
  contents:
  - "5.2.2.6.  X-FRAME-OPTIONS Header\n   For newer browsers, avoidance of iFrames\
    \ can be enforced on the\n   server side by using the X-FRAME-OPTIONS header (see\n\
    \   [X-Frame-Options]).  This header can have two values, \"DENY\" and\n   \"\
    SAMEORIGIN\", which will block any framing or any framing by sites\n   with a\
    \ different origin, respectively.  The value \"ALLOW-FROM\"\n   specifies a list\
    \ of trusted origins that iFrames may originate from.\n   This is a countermeasure\
    \ against the following threat:\n   o  Clickjacking attacks\n"
- title: 5.2.3.  Client Authentication and Authorization
  contents:
  - "5.2.3.  Client Authentication and Authorization\n   As described in Section 3\
    \ (Security Features), clients are\n   identified, authenticated, and authorized\
    \ for several purposes, such\n   as to:\n   o  Collate requests to the same client,\n\
    \   o  Indicate to the user that the client is recognized by the\n      authorization\
    \ server,\n   o  Authorize access of clients to certain features on the\n    \
    \  authorization server or resource server, and\n   o  Log a client identifier\
    \ to log files for analysis or statistics.\n   Due to the different capabilities\
    \ and characteristics of the\n   different client types, there are different ways\
    \ to support these\n   objectives, which will be described in this section.  Authorization\n\
    \   server providers should be aware of the security policy and\n   deployment\
    \ of a particular client and adapt its treatment\n   accordingly.  For example,\
    \ one approach could be to treat all clients\n   as less trustworthy and unsecure.\
    \  On the other extreme, a service\n   provider could activate every client installation\
    \ individually by an\n   administrator and in that way gain confidence in the\
    \ identity of the\n   software package and the security of the environment in\
    \ which the\n   client is installed.  There are several approaches in between.\n"
- title: 5.2.3.1.  Don't Issue Secrets to Clients with Inappropriate Security
  contents:
  - "5.2.3.1.  Don't Issue Secrets to Clients with Inappropriate Security\n      \
    \    Policy\n   Authorization servers should not issue secrets to clients that\
    \ cannot\n   protect secrets (\"public\" clients).  This reduces the probability\
    \ of\n   the server treating the client as strongly authenticated.\n   For example,\
    \ it is of limited benefit to create a single client id\n   and secret that are\
    \ shared by all installations of a native\n   application.  Such a scenario requires\
    \ that this secret must be\n   transmitted from the developer via the respective\
    \ distribution\n   channel, e.g., an application market, to all installations\
    \ of the\n   application on end-user devices.  A secret, burned into the source\n\
    \   code of the application or an associated resource bundle, is not\n   protected\
    \ from reverse engineering.  Secondly, such secrets cannot be\n   revoked, since\
    \ this would immediately put all installations out of\n   work.  Moreover, since\
    \ the authorization server cannot really trust\n   the client's identifier, it\
    \ would be dangerous to indicate to end\n   users the trustworthiness of the client.\n\
    \   There are other ways to achieve a reasonable security level, as\n   described\
    \ in the following sections.\n"
- title: 5.2.3.2.  Require User Consent for Public Clients without Secret
  contents:
  - "5.2.3.2.  Require User Consent for Public Clients without Secret\n   Authorization\
    \ servers should not allow automatic authorization for\n   public clients.  The\
    \ authorization server may issue an individual\n   client id but should require\
    \ that all authorizations are approved by\n   the end user.  For clients without\
    \ secrets, this is a countermeasure\n   against the following threat:\n   o  Impersonation\
    \ of public client applications.\n"
- title: 5.2.3.3.  Issue a "client_id" Only in Combination with "redirect_uri"
  contents:
  - "5.2.3.3.  Issue a \"client_id\" Only in Combination with \"redirect_uri\"\n \
    \  The authorization server may issue a \"client_id\" and bind the\n   \"client_id\"\
    \ to a certain pre-configured \"redirect_uri\".  Any\n   authorization request\
    \ with another redirect URI is refused\n   automatically.  Alternatively, the\
    \ authorization server should not\n   accept any dynamic redirect URI for such\
    \ a \"client_id\" and instead\n   should always redirect to the well-known pre-configured\
    \ redirect URI.\n   This is a countermeasure for clients without secrets against\
    \ the\n   following threats:\n   o  Cross-site scripting attacks\n   o  Impersonation\
    \ of public client applications\n"
- title: 5.2.3.4.  Issue Installation-Specific Client Secrets
  contents:
  - "5.2.3.4.  Issue Installation-Specific Client Secrets\n   An authorization server\
    \ may issue separate client identifiers and\n   corresponding secrets to the different\
    \ installations of a particular\n   client (i.e., software package).  The effect\
    \ of such an approach\n   would be to turn otherwise \"public\" clients back into\
    \ \"confidential\"\n   clients.\n   For web applications, this could mean creating\
    \ one \"client_id\" and\n   \"client_secret\" for each web site on which a software\
    \ package is\n   installed.  So, the provider of that particular site could request\
    \ a\n   client id and secret from the authorization server during the setup\n\
    \   of the web site.  This would also allow the validation of some of the\n  \
    \ properties of that web site, such as redirect URI, web site URL, and\n   whatever\
    \ else proves useful.  The web site provider has to ensure the\n   security of\
    \ the client secret on the site.\n   For native applications, things are more\
    \ complicated because every\n   copy of a particular application on any device\
    \ is a different\n   installation.  Installation-specific secrets in this scenario\
    \ will\n   require obtaining a \"client_id\" and \"client_secret\" either\n  \
    \ 1.  during the download process from the application market, or\n   2.  during\
    \ installation on the device.\n   Either approach will require an automated mechanism\
    \ for issuing\n   client ids and secrets, which is currently not defined by OAuth.\n\
    \   The first approach would allow the achievement of a certain level of\n   trust\
    \ in the authenticity of the application, whereas the second\n   option only allows\
    \ the authentication of the installation but not the\n   validation of properties\
    \ of the client.  But this would at least help\n   to prevent several replay attacks.\
    \  Moreover, installation-specific\n   \"client_ids\" and secrets allow the selective\
    \ revocation of all\n   refresh tokens of a specific installation at once.\n"
- title: 5.2.3.5.  Validate Pre-Registered "redirect_uri"
  contents:
  - "5.2.3.5.  Validate Pre-Registered \"redirect_uri\"\n   An authorization server\
    \ should require all clients to register their\n   \"redirect_uri\", and the \"\
    redirect_uri\" should be the full URI as\n   defined in [RFC6749].  The way that\
    \ this registration is performed is\n   out of scope of this document.  As per\
    \ the core spec, every actual\n   redirect URI sent with the respective \"client_id\"\
    \ to the end-user\n   authorization endpoint must match the registered redirect\
    \ URI.  Where\n   it does not match, the authorization server should assume that\
    \ the\n   inbound GET request has been sent by an attacker and refuse it.\n  \
    \ Note: The authorization server should not redirect the user agent\n   back to\
    \ the redirect URI of such an authorization request.\n   Validating the pre-registered\
    \ \"redirect_uri\" is a countermeasure\n   against the following threats:\n  \
    \ o  Authorization \"code\" leakage through counterfeit web site: allows\n   \
    \   authorization servers to detect attack attempts after the first\n      redirect\
    \ to an end-user authorization endpoint (Section 4.4.1.7).\n   o  Open redirector\
    \ attack via a client redirection endpoint\n      (Section 4.1.5).\n   o  Open\
    \ redirector phishing attack via an authorization server\n      redirection endpoint\
    \ (Section 4.2.4).\n   The underlying assumption of this measure is that an attacker\
    \ will\n   need to use another redirect URI in order to get access to the\n  \
    \ authorization \"code\".  Deployments might consider the possibility of\n   an\
    \ attacker using spoofing attacks to a victim's device to circumvent\n   this\
    \ security measure.\n   Note: Pre-registering clients might not scale in some\
    \ deployments\n   (manual process) or require dynamic client registration (not\n\
    \   specified yet).  With the lack of dynamic client registration, a\n   pre-registered\
    \ \"redirect_uri\" only works for clients bound to certain\n   deployments at\
    \ development/configuration time.  As soon as dynamic\n   resource server discovery\
    \ is required, the pre-registered\n   \"redirect_uri\" may no longer be feasible.\n"
- title: 5.2.3.6.  Revoke Client Secrets
  contents:
  - "5.2.3.6.  Revoke Client Secrets\n   An authorization server may revoke a client's\
    \ secret in order to\n   prevent abuse of a revealed secret.\n   Note: This measure\
    \ will immediately invalidate any authorization\n   \"code\" or refresh token\
    \ issued to the respective client.  This might\n   unintentionally impact client\
    \ identifiers and secrets used across\n   multiple deployments of a particular\
    \ native or web application.\n   This a countermeasure against:\n   o  Abuse of\
    \ revealed client secrets for private clients\n"
- title: 5.2.3.7.  Use Strong Client Authentication (e.g., client_assertion/
  contents:
  - "5.2.3.7.  Use Strong Client Authentication (e.g., client_assertion/\n       \
    \   client_token)\n   By using an alternative form of authentication such as client\n\
    \   assertion [OAuth-ASSERTIONS], the need to distribute a\n   \"client_secret\"\
    \ is eliminated.  This may require the use of a secure\n   private key store or\
    \ other supplemental authentication system as\n   specified by the client assertion\
    \ issuer in its authentication\n   process.\n"
- title: 5.2.4.  End-User Authorization
  contents:
  - "5.2.4.  End-User Authorization\n   This section includes considerations for authorization\
    \ flows\n   involving the end user.\n"
- title: 5.2.4.1.  Automatic Processing of Repeated Authorizations Requires
  contents:
  - "5.2.4.1.  Automatic Processing of Repeated Authorizations Requires\n        \
    \  Client Validation\n   Authorization servers should NOT automatically process\
    \ repeat\n   authorizations where the client is not authenticated through a client\n\
    \   secret or some other authentication mechanism such as a signed\n   authentication\
    \ assertion certificate (Section 5.2.3.7) or validation\n   of a pre-registered\
    \ redirect URI (Section 5.2.3.5).\n"
- title: 5.2.4.2.  Informed Decisions Based on Transparency
  contents:
  - "5.2.4.2.  Informed Decisions Based on Transparency\n   The authorization server\
    \ should clearly explain to the end user what\n   happens in the authorization\
    \ process and what the consequences are.\n   For example, the user should understand\
    \ what access he is about to\n   grant to which client for what duration.  It\
    \ should also be obvious\n   to the user whether the server is able to reliably\
    \ certify certain\n   client properties (web site URL, security policy).\n"
- title: 5.2.4.3.  Validation of Client Properties by End User
  contents:
  - "5.2.4.3.  Validation of Client Properties by End User\n   In the authorization\
    \ process, the user is typically asked to approve\n   a client's request for authorization.\
    \  This is an important security\n   mechanism by itself because the end user\
    \ can be involved in the\n   validation of client properties, such as whether\
    \ the client name\n   known to the authorization server fits the name of the web\
    \ site or\n   the application the end user is using.  This measure is especially\n\
    \   helpful in situations where the authorization server is unable to\n   authenticate\
    \ the client.  It is a countermeasure against:\n   o  A malicious application\n\
    \   o  A client application masquerading as another client\n"
- title: 5.2.4.4.  Binding of Authorization "code" to "client_id"
  contents:
  - "5.2.4.4.  Binding of Authorization \"code\" to \"client_id\"\n   The authorization\
    \ server should bind every authorization \"code\" to\n   the id of the respective\
    \ client that initiated the end-user\n   authorization process.  This measure\
    \ is a countermeasure against:\n   o  Replay of authorization \"codes\" with different\
    \ client credentials,\n      since an attacker cannot use another \"client_id\"\
    \ to exchange an\n      authorization \"code\" into a token\n   o  Online guessing\
    \ of authorization \"codes\"\n   Note: This binding should be protected from unauthorized\n\
    \   modifications (e.g., using protected memory and/or a secure\n   database).\n"
- title: 5.2.4.5.  Binding of Authorization "code" to "redirect_uri"
  contents:
  - "5.2.4.5.  Binding of Authorization \"code\" to \"redirect_uri\"\n   The authorization\
    \ server should be able to bind every authorization\n   \"code\" to the actual\
    \ redirect URI used as the redirect target of the\n   client in the end-user authorization\
    \ process.  This binding should be\n   validated when the client attempts to exchange\
    \ the respective\n   authorization \"code\" for an access token.  This measure\
    \ is a\n   countermeasure against authorization \"code\" leakage through\n   counterfeit\
    \ web sites, since an attacker cannot use another redirect\n   URI to exchange\
    \ an authorization \"code\" into a token.\n"
- title: 5.3.  Client App Security
  contents:
  - "5.3.  Client App Security\n   This section deals with considerations for client\
    \ applications.\n"
- title: 5.3.1.  Don't Store Credentials in Code or Resources Bundled with
  contents:
  - "5.3.1.  Don't Store Credentials in Code or Resources Bundled with\n        Software\
    \ Packages\n   Because of the number of copies of client software, there is limited\n\
    \   benefit in creating a single client id and secret that is shared by\n   all\
    \ installations of an application.  Such an application by itself\n   would be\
    \ considered a \"public\" client, as it cannot be presumed to be\n   able to keep\
    \ client secrets.  A secret, burned into the source code\n   of the application\
    \ or an associated resource bundle, cannot be\n   protected from reverse engineering.\
    \  Secondly, such secrets cannot be\n   revoked, since this would immediately\
    \ put all installations out of\n   work.  Moreover, since the authorization server\
    \ cannot really trust\n   the client's identifier, it would be dangerous to indicate\
    \ to end\n   users the trustworthiness of the client.\n"
- title: 5.3.2.  Use Standard Web Server Protection Measures (for Config Files
  contents:
  - "5.3.2.  Use Standard Web Server Protection Measures (for Config Files\n     \
    \   and Databases)\n   Use standard web server protection and configuration measures\
    \ to\n   protect the integrity of the server, databases, configuration files,\n\
    \   and other operational components of the server.\n"
- title: 5.3.3.  Store Secrets in Secure Storage
  contents:
  - "5.3.3.  Store Secrets in Secure Storage\n   There are different ways to store\
    \ secrets of all kinds (tokens,\n   client secrets) securely on a device or server.\n\
    \   Most multi-user operating systems segregate the personal storage of\n   different\
    \ system users.  Moreover, most modern smartphone operating\n   systems even support\
    \ the storage of application-specific data in\n   separate areas of file systems\
    \ and protect the data from access by\n   other applications.  Additionally, applications\
    \ can implement\n   confidential data by using a user-supplied secret, such as\
    \ a PIN or\n   password.\n   Another option is to swap refresh token storage to\
    \ a trusted backend\n   server.  This option in turn requires a resilient authentication\n\
    \   mechanism between the client and backend server.  Note: Applications\n   should\
    \ ensure that confidential data is kept confidential even after\n   reading from\
    \ secure storage, which typically means keeping this data\n   in the local memory\
    \ of the application.\n"
- title: 5.3.4.  Utilize Device Lock to Prevent Unauthorized Device Access
  contents:
  - "5.3.4.  Utilize Device Lock to Prevent Unauthorized Device Access\n   On a typical\
    \ modern phone, there are many \"device lock\" options that\n   can be utilized\
    \ to provide additional protection when a device is\n   stolen or misplaced. \
    \ These include PINs, passwords, and other\n   biometric features such as \"face\
    \ recognition\".  These are not equal\n   in the level of security they provide.\n"
- title: 5.3.5.  Link the "state" Parameter to User Agent Session
  contents:
  - "5.3.5.  Link the \"state\" Parameter to User Agent Session\n   The \"state\"\
    \ parameter is used to link client requests and prevent\n   CSRF attacks, for\
    \ example, attacks against the redirect URI.  An\n   attacker could inject their\
    \ own authorization \"code\" or access token,\n   which can result in the client\
    \ using an access token associated with\n   the attacker's protected resources\
    \ rather than the victim's (e.g.,\n   save the victim's bank account information\
    \ to a protected resource\n   controlled by the attacker).\n   The client should\
    \ utilize the \"state\" request parameter to send the\n   authorization server\
    \ a value that binds the request to the user\n   agent's authenticated state (e.g.,\
    \ a hash of the session cookie used\n   to authenticate the user agent) when making\
    \ an authorization request.\n   Once authorization has been obtained from the\
    \ end user, the\n   authorization server redirects the end-user's user agent back\
    \ to the\n   client with the required binding value contained in the \"state\"\
    \n   parameter.\n   The binding value enables the client to verify the validity\
    \ of the\n   request by matching the binding value to the user agent's\n   authenticated\
    \ state.\n"
- title: 5.4.  Resource Servers
  contents:
  - "5.4.  Resource Servers\n   The following section details security considerations\
    \ for resource\n   servers.\n"
- title: 5.4.1.  Authorization Headers
  contents:
  - "5.4.1.  Authorization Headers\n   Authorization headers are recognized and specially\
    \ treated by HTTP\n   proxies and servers.  Thus, the usage of such headers for\
    \ sending\n   access tokens to resource servers reduces the likelihood of leakage\n\
    \   or unintended storage of authenticated requests in general, and\n   especially\
    \ Authorization headers.\n"
- title: 5.4.2.  Authenticated Requests
  contents:
  - "5.4.2.  Authenticated Requests\n   An authorization server may bind tokens to\
    \ a certain client\n   identifier and enable resource servers to validate that\
    \ association\n   on resource access.  This will require the resource server to\n\
    \   authenticate the originator of a request as the legitimate owner of a\n  \
    \ particular token.  There are several options to implement this\n   countermeasure:\n\
    \   o  The authorization server may associate the client identifier with\n   \
    \   the token (either internally or in the payload of a self-contained\n     \
    \ token).  The client then uses client certificate-based HTTP\n      authentication\
    \ on the resource server's endpoint to authenticate\n      its identity, and the\
    \ resource server validates the name with the\n      name referenced by the token.\n\
    \   o  Same as the option above, but the client uses his private key to\n    \
    \  sign the request to the resource server (the public key is either\n      contained\
    \ in the token or sent along with the request).\n   o  Alternatively, the authorization\
    \ server may issue a token-bound\n      key, which the client uses in a Holder-of-Key\
    \ proof to\n      authenticate the client's use of the token.  The resource server\n\
    \      obtains the secret directly from the authorization server, or the\n   \
    \   secret is contained in an encrypted section of the token.  In that\n     \
    \ way, the resource server does not \"know\" the client but is able to\n     \
    \ validate whether the authorization server issued the token to that\n      client.\n\
    \   Authenticated requests are a countermeasure against abuse of tokens\n   by\
    \ counterfeit resource servers.\n"
- title: 5.4.3.  Signed Requests
  contents:
  - "5.4.3.  Signed Requests\n   A resource server may decide to accept signed requests\
    \ only, either\n   to replace transport-level security measures or to complement\
    \ such\n   measures.  Every signed request should be uniquely identifiable and\n\
    \   should not be processed twice by the resource server.  This\n   countermeasure\
    \ helps to mitigate:\n   o  modifications of the message and\n   o  replay attempts\n"
- title: 5.5.  A Word on User Interaction and User-Installed Apps
  contents:
  - "5.5.  A Word on User Interaction and User-Installed Apps\n   OAuth, as a security\
    \ protocol, is distinctive in that its flow\n   usually involves significant user\
    \ interaction, making the end user a\n   part of the security model.  This creates\
    \ some important difficulties\n   in defending against some of the threats discussed\
    \ above.  Some of\n   these points have already been made, but it's worth repeating\
    \ and\n   highlighting them here.\n   o  End users must understand what they are\
    \ being asked to approve\n      (see Section 5.2.4.2).  Users often do not have\
    \ the expertise to\n      understand the ramifications of saying \"yes\" to an\
    \ authorization\n      request and are likely not to be able to see subtle differences\
    \ in\n      the wording of requests.  Malicious software can confuse the user,\n\
    \      tricking the user into approving almost anything.\n   o  End-user devices\
    \ are prone to software compromise.  This has been\n      a long-standing problem,\
    \ with frequent attacks on web browsers and\n      other parts of the user's system.\
    \  But with the increasing\n      popularity of user-installed \"apps\", the threat\
    \ posed by\n      compromised or malicious end-user software is very strong and\
    \ is\n      one that is very difficult to mitigate.\n   o  Be aware that users\
    \ will demand to install and run such apps, and\n      that compromised or malicious\
    \ ones can steal credentials at many\n      points in the data flow.  They can\
    \ intercept the very user login\n      credentials that OAuth is designed to protect.\
    \  They can request\n      authorization far beyond what they have led the user\
    \ to understand\n      and approve.  They can automate a response on behalf of\
    \ the user,\n      hiding the whole process.  No solution is offered here, because\n\
    \      none is known; this remains in the space between better security\n    \
    \  and better usability.\n   o  Addressing these issues by restricting the use\
    \ of user-installed\n      software may be practical in some limited environments\
    \ and can be\n      used as a countermeasure in those cases.  Such restrictions\
    \ are\n      not practical in the general case, and mechanisms for after-the-\n\
    \      fact recovery should be in place.\n   o  While end users are mostly incapable\
    \ of properly vetting\n      applications they load onto their devices, those\
    \ who deploy\n      authorization servers might have tools at their disposal to\n\
    \      mitigate malicious clients.  For example, a well-run authorization\n  \
    \    server must only assert client properties to the end user it is\n      effectively\
    \ capable of validating, explicitly point out which\n      properties it cannot\
    \ validate, and indicate to the end user the\n      risk associated with granting\
    \ access to the particular client.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   We would like to thank Stephen Farrell, Barry Leiba,\
    \ Hui-Lan Lu,\n   Francisco Corella, Peifung E. Lam, Shane B. Weeden, Skylar Woodward,\n\
    \   Niv Steingarten, Tim Bray, and James H. Manger for their comments and\n  \
    \ contributions.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC6749]  Hardt, D., \"The OAuth 2.0 Authorization\
    \ Framework\",\n              RFC 6749, October 2012.\n   [RFC6750]  Jones, M.\
    \ and D. Hardt, \"The OAuth 2.0 Authorization\n              Framework: Bearer\
    \ Token Usage\", RFC 6750, October 2012.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [Framebusting]\n              Rydstedt, G.,\
    \ Bursztein, Boneh, D., and C. Jackson,\n              \"Busting Frame Busting:\
    \ a Study of Clickjacking\n              Vulnerabilities on Popular Sites\", IEEE\
    \ 3rd Web 2.0\n              Security and Privacy Workshop, May 2010, <http://elie.im/\n\
    \              publication/busting-frame-busting-a-study-of-\n              clickjacking-vulnerabilities-on-popular-sites>.\n\
    \   [IMEI]     3GPP, \"International Mobile station Equipment Identities\n   \
    \           (IMEI)\", 3GPP TS 22.016 11.0.0, September 2012,\n              <http://www.3gpp.org/ftp/Specs/html-info/22016.htm>.\n\
    \   [OASIS.saml-core-2.0-os]\n              Cantor, S., Ed., Kemp, J., Ed., Philpott,\
    \ R., Ed., and E.\n              Maler, Ed., \"Assertions and Protocols for the\
    \ OASIS\n              Security Assertion Markup Language (SAML) V2.0\", OASIS\n\
    \              Standard saml-core-2.0-os, March 2005,\n              <http://docs.oasis-open.org/security/saml/\n\
    \              v2.0/saml-core-2.0-os.pdf>.\n   [OASIS.sstc-saml-bindings-1.1]\n\
    \              Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed.,\n      \
    \        \"Bindings and Profiles for the OASIS Security Assertion\n          \
    \    Markup Language (SAML) V1.1\", September 2003,\n              <http://www.oasis-open.org/committees/download.php/3405/\n\
    \              oasis-sstc-saml-bindings-1.1.pdf>.\n   [OASIS.sstc-sec-analysis-response-01]\n\
    \              Linn, J., Ed., and P. Mishra, Ed., \"SSTC Response to\n       \
    \       \"Security Analysis of the SAML Single Sign-on Browser/\n            \
    \  Artifact Profile\"\", January 2005,\n              <http://www.oasis-open.org/committees/download.php/\n\
    \              11191/sstc-gross-sec-analysis-response-01.pdf>.\n   [OAuth-ASSERTIONS]\n\
    \              Campbell, B., Mortimore, C., Jones, M., and Y. Goland,\n      \
    \        \"Assertion Framework for OAuth 2.0\", Work in Progress,\n          \
    \    December 2012.\n   [OAuth-HTTP-MAC]\n              Richer, J., Ed., Mills,\
    \ W., Ed., and H. Tschofenig, Ed.,\n              \"OAuth 2.0 Message Authentication\
    \ Code (MAC) Tokens\", Work\n              in Progress, November 2012.\n   [OAuth-JWT]\n\
    \              Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token\n   \
    \           (JWT)\", Work in Progress, December 2012.\n   [OAuth-REVOCATION]\n\
    \              Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"Token\n \
    \             Revocation\", Work in Progress, November 2012.\n   [OPENID]   \"\
    OpenID Foundation Home Page\", <http://openid.net/>.\n   [OWASP]    \"Open Web\
    \ Application Security Project Home Page\",\n              <https://www.owasp.org/>.\n\
    \   [Portable-Contacts]\n              Smarr, J., \"Portable Contacts 1.0 Draft\
    \ C\", August 2008,\n              <http://portablecontacts.net/>.\n   [RFC2616]\
    \  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter,\
    \ L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol\
    \ -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC2818]  Rescorla, E., \"HTTP Over\
    \ TLS\", RFC 2818, May 2000.\n   [RFC4086]  Eastlake, D., Schiller, J., and S.\
    \ Crocker, \"Randomness\n              Requirements for Security\", BCP 106, RFC\
    \ 4086, June 2005.\n   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn,\
    \ \"The\n              Kerberos Network Authentication Service (V5)\", RFC 4120,\n\
    \              July 2005.\n   [RFC4301]  Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n              Internet Protocol\", RFC 4301, December 2005.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246, August 2008.\n   [SSL-Latency]\n         \
    \     Sissel, J., Ed., \"SSL handshake latency and HTTPS\n              optimizations\"\
    , June 2010.\n   [Sec-Analysis]\n              Gross, T., \"Security Analysis\
    \ of the SAML Single Sign-on\n              Browser/Artifact Profile\", 19th Annual\
    \ Computer Security\n              Applications Conference, Las Vegas, December\
    \ 2003.\n   [X-Frame-Options]\n              Ross, D. and T. Gondrom, \"HTTP Header\
    \ X-Frame-Options\",\n              Work in Progress, October 2012.\n   [iFrame]\
    \   World Wide Web Consortium, \"Frames in HTML documents\",\n              W3C\
    \ HTML 4.01, December 1999,\n              <http://www.w3.org/TR/html4/present/frames.html#h-16.5>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Torsten Lodderstedt (editor)\n   Deutsche Telekom AG\n\
    \   EMail: torsten@lodderstedt.net\n   Mark McGloin\n   IBM\n   EMail: mark.mcgloin@ie.ibm.com\n\
    \   Phil Hunt\n   Oracle Corporation\n   EMail: phil.hunt@yahoo.com\n"
