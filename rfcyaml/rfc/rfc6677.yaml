- contents:
  - "                        Channel-Binding Support\n          for Extensible Authentication
    Protocol (EAP) Methods\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines how to implement channel bindings for\n   Extensible
    Authentication Protocol (EAP) methods to address the\n   \"lying Network Access
    Service (NAS)\" problem as well as the \"lying\n   provider\" problem.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6677.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . . . .  5\n   3.  Problem Statement  . . . . . . . . . . . . . . . . . . . .
    . .  5\n   4.  Channel Bindings . . . . . . . . . . . . . . . . . . . . . . .
    \ 7\n     4.1.  Types of EAP Channel Bindings  . . . . . . . . . . . . . .  8\n
    \    4.2.  Channel Bindings in the Secure Association Protocol  . . .  9\n     4.3.
    \ Channel-Binding Scope  . . . . . . . . . . . . . . . . . . 10\n   5.  Channel-Binding
    Process  . . . . . . . . . . . . . . . . . . . 12\n     5.1.  Protocol Operation
    . . . . . . . . . . . . . . . . . . . . 12\n     5.2.  Channel-Binding Consistency
    Check  . . . . . . . . . . . . 14\n     5.3.  EAP Protocol . . . . . . . . . .
    . . . . . . . . . . . . . 15\n       5.3.1.  Channel-Binding Codes  . . . . .
    . . . . . . . . . . . 17\n       5.3.2.  Namespace Identifiers  . . . . . . .
    . . . . . . . . . 17\n       5.3.3.  RADIUS Namespace . . . . . . . . . . . .
    . . . . . . . 18\n   6.  System Requirements  . . . . . . . . . . . . . . . .
    . . . . . 18\n     6.1.  General Transport Protocol Requirements  . . . . . .
    . . . 18\n     6.2.  EAP Method Requirements  . . . . . . . . . . . . . . . .
    . 19\n   7.  Channel-Binding TLV  . . . . . . . . . . . . . . . . . . . . . 19\n
    \    7.1.  Requirements for Lower-Layer Bindings  . . . . . . . . . . 19\n     7.2.
    \ EAP Lower-Layer Attribute  . . . . . . . . . . . . . . . . 20\n   8.  AAA-Layer
    Bindings . . . . . . . . . . . . . . . . . . . . . . 20\n   9.  Security Considerations
    \ . . . . . . . . . . . . . . . . . . . 21\n     9.1.  Trust Model  . . . . .
    . . . . . . . . . . . . . . . . . . 21\n     9.2.  Consequences of Trust Violation
    \ . . . . . . . . . . . . . 23\n     9.3.  Bid-Down Attacks . . . . . . . . .
    . . . . . . . . . . . . 24\n     9.4.  Privacy Violations . . . . . . . . . .
    . . . . . . . . . . 24\n   10. Operations and Management Considerations . . .
    . . . . . . . . 25\n   11. IANA Considerations  . . . . . . . . . . . . . . .
    . . . . . . 25\n     11.1. EAP Lower Layers Registry  . . . . . . . . . . . .
    . . . . 26\n     11.2. RADIUS Registration  . . . . . . . . . . . . . . . . .
    . . 26\n   12. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . .
    27\n   13. References . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n
    \    13.1. Normative References . . . . . . . . . . . . . . . . . . . 27\n     13.2.
    Informative References . . . . . . . . . . . . . . . . . . 27\n   Appendix A.
    \ Attacks Prevented by Channel Bindings . . . . . . . . 29\n     A.1.  Enterprise
    Subnetwork Masquerading . . . . . . . . . . . . 29\n     A.2.  Forced Roaming
    . . . . . . . . . . . . . . . . . . . . . . 29\n     A.3.  Downgrading Attacks
    \ . . . . . . . . . . . . . . . . . . . 30\n     A.4.  Bogus Beacons in IEEE 802.11r
    \ . . . . . . . . . . . . . . 30\n     A.5.  Forcing False Authorization in IEEE
    802.11i  . . . . . . . 30\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The so-called \"lying NAS\" problem is a well-documented
    problem with\n   the current Extensible Authentication Protocol (EAP) architecture\n
    \  [RFC3748] when used in pass-through authenticator mode.  Here, a\n   Network
    Access Server (NAS), or pass-through authenticator, may\n   represent one set
    of information (e.g., network identity,\n   capabilities, configuration, etc)
    to the backend Authentication,\n   Authorization, and Accounting (AAA) infrastructure,
    while\n   representing contrary information to EAP peers.  Another possibility\n
    \  is that the same false information could be provided to both the EAP\n   peer
    and EAP server by the NAS.  A \"lying\" entity can also be located\n   anywhere
    on the AAA path between the NAS and the EAP server.\n   This problem results when
    the same credentials are used to access\n   multiple services that differ in some
    interesting property.  The EAP\n   server learns which client credentials are
    in use.  The client knows\n   which EAP credentials are used, but cannot distinguish
    between\n   servers that use those credentials.  For methods that distinguish\n
    \  between client and server credentials, either using different server\n   credentials
    for access to the different services or having client\n   credentials with access
    to a disjoint set of services can potentially\n   defend against the attack.\n
    \  As a concrete example, consider an organization with two different\n   IEEE
    802.11 wireless networks.  One is a relatively low-security\n   network for accessing
    the web, while the other has access to valuable\n   confidential information.
    \ An access point on the web network could\n   act as a lying NAS, sending the
    Service Set Identifier (SSID) of the\n   confidential network in its beacons.
    \ This access point could gain an\n   advantage by doing so if it tricks clients
    that intend to connect to\n   the confidential network to connect to it and disclose
    confidential\n   information.\n   A similar problem can be observed in the context
    of roaming.  Here,\n   the lying entity is located in a visited service provider
    network,\n   e.g., attempting to lure peers to connect to the network based on\n
    \  falsely advertised roaming rates.  This is referred to as the \"lying\n   provider\"
    problem in the remainder of this document.  The lying\n   entity's motivation
    often is financial; the entity may be paid\n   whenever peers roam to its service.
    \ However, a lying entity in a\n   provider network can also gain access to traffic
    that it might not\n   otherwise see.\n   This document defines and implements
    EAP channel bindings to solve\n   the \"lying NAS\" and the \"lying provider\"
    problems, using a process in\n   which the EAP peer gives information about the
    characteristics of the\n   service provided by the authenticator to the AAA server
    protected\n   within the EAP method.  This allows the server to verify the\n   authenticator
    is providing information to the peer that is consistent\n   with the information
    received from this authenticator as well as the\n   information stored about this
    authenticator.  \"AAA Payloads\" defined\n   in [AAA-PAY] served as the starting
    point for the mechanism proposed\n   in this specification to carry this information.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   In this document, several words are used to signify the requirements\n
    \  of the specification.  These words are often capitalized.  The key\n   words
    \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n
    \  \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document\n
    \  are to be interpreted as described in [RFC2119].\n"
  title: 2.  Terminology
- contents:
  - "3.  Problem Statement\n   In an EAP authentication compliant with [RFC4017],
    the EAP peer and\n   EAP server mutually authenticate each other, and derive keying\n
    \  material.  However, when operating in pass-through mode, the EAP\n   server
    can be far removed from the authenticator both in terms of\n   network distance
    and number of entities who need to be trusted in\n   order to establish trusted
    communication.  A malicious or compromised\n   authenticator may represent incorrect
    information about the network\n   to the peer in an effort to affect its operation
    in some way.\n   Additionally, while an authenticator may not be compromised,
    other\n   compromised elements in the network (such as proxies) could provide\n
    \  false information to the authenticator that it could simply be\n   relaying
    to EAP peers.  Hence, the goal must be to ensure that the\n   authenticator is
    providing correct information to the EAP peer during\n   the initial network discovery,
    selection, and authentication.\n   There are two different types of networks to
    consider: enterprise\n   networks and service provider networks.  In enterprise
    networks,\n   assuming a single administrative domain, it is feasible for an EAP\n
    \  server to have information about all the authenticators in the\n   network.
    \ In service provider networks, global knowledge is\n   infeasible due to indirection
    via roaming.  When a peer is outside\n   its home administrative domain, the goal
    is to ensure that the level\n   of service received by the peer is consistent
    with the contractual\n   agreement between the two service providers.  The same
    EAP server may\n   need to support both types of networks.  For example an enterprise\n
    \  may have a roaming agreement permitting its users to use the networks\n   of
    third-party service providers.  In these situations, the EAP\n   server may authenticate
    for an enterprise and provider network.\n   The following are example attacks
    possible by presenting false\n   network information to peers.\n   o  Enterprise
    network: A corporate network may have multiple virtual\n      LANs (VLANs) available
    throughout their campus network, and have\n      IEEE 802.11 access points connected
    to each VLAN.  Assume one VLAN\n      connects users to the firewalled corporate
    network, while the\n      other connects users to a public guest network.  The
    corporate\n      network is assumed to be free of adversarial elements, while
    the\n      guest network is assumed to possibly have malicious elements.\n      Access
    points on both VLANs are serviced by the same EAP server,\n      but broadcast
    different SSIDs to differentiate.  A compromised\n      access point connected
    to the guest network but not the corporate\n      network could advertise the
    SSID of the corporate network in an\n      effort to lure peers to connect to
    a network with a false sense of\n      security regarding their traffic.  Conditions
    and further details\n      of this attack can be found in the appendix.\n   o
    \ Enterprise network: The EAP Generic Security Service Application\n      Program
    Interface (GSS-API) mechanism [GSS-API-EAP] mechanism\n      provides a way to
    use EAP to authenticate to mail servers, instant\n      messaging servers, and
    other non-network services.  Without EAP\n      channel binding, an attacker could
    trick the user into connecting\n      to a relatively untrusted service instead
    of a relatively trusted\n      service.  For example, the instant messaging service
    could\n      impersonate the mail server.\n   o  Service provider network: An
    EAP-enabled mobile phone provider\n      could advertise very competitive flat
    rates but send per-minute\n      rates to the home server, thus luring peers to
    connect to their\n      network and overcharging them.  In more elaborate attacks,
    peers\n      can be tricked into roaming without their knowledge.  For example,\n
    \     a mobile phone provider operating along a geopolitical boundary\n      could
    boost their cell towers' transmission power and advertise\n      the network identity
    of the neighboring country's indigenous\n      provider.  This would cause unknowing
    handsets to associate with\n      an unintended operator, and consequently be
    subject to high\n      roaming fees without realizing they had roamed off their
    home\n      provider's network.  These types of scenarios can be considered as\n
    \     the \"lying provider\" problem, because here the provider configures\n      its
    NAS to broadcast false information.  For the purpose of\n      channel bindings
    as defined in this document, it does not matter\n      which local entity (or
    entities) is \"lying\" in a service provider\n      network (local NAS, local
    authentication server, and/or local\n      proxies), because the only information
    received from the visited\n      network that is verified by channel bindings
    is the information\n      the home authentication server received from the last
    hop in the\n      communication chain.  In other words, channel bindings enable
    the\n      detection of inconsistencies in the information from a visited\n      network,
    but cannot enable the determination of which entity is\n      lying.  Naturally,
    channel bindings for EAP methods can only\n      verify the endpoints; if desirable,
    intermediate hops need to be\n      protected by the employed AAA protocol.\n
    \  o  Enterprise and provider networks: In a situation where an\n      enterprise
    has roaming agreements with providers, a compromised\n      access point in a
    provider network could masquerade as the\n      enterprise network in an attempt
    to gain confidential information.\n      Today this could potentially be solved
    by using different\n      credentials for internal and external access.  Depending
    on the\n      type of credential, this may introduce usability or man-in-the-\n
    \     middle security issues.\n   To address these problems, a mechanism is required
    to validate\n   unauthenticated information advertised by EAP authenticators.\n"
  title: 3.  Problem Statement
- contents:
  - "4.  Channel Bindings\n   EAP channel bindings seek to authenticate previously
    unauthenticated\n   information provided by the authenticator to the EAP peer
    by allowing\n   the peer and server to compare their perception of network properties\n
    \  in a secure channel.\n   It should be noted that the definition of EAP channel
    bindings\n   differs somewhat from channel bindings documented in [RFC5056], which\n
    \  seek to securely bind together the endpoints of a multi-layer\n   protocol,
    allowing lower layers to protect data from higher layers.\n   Unlike [RFC5056],
    EAP channel bindings do not ensure the binding of\n   different layers of a session;
    rather, they ensure the accuracy of\n   the information advertised to an EAP peer
    by an authenticator acting\n   as the pass-through device during an EAP execution.
    \ The term\n   \"channel bindings\" was independently adopted for these two related\n
    \  concepts; by the time the conflict was discovered, a wide body of\n   literature
    existed for each usage.  EAP channel bindings could be\n   used to provide [RFC5056]
    channel bindings.  In particular, an inner\n   EAP method could be bound to an
    outer method by including the\n   [RFC5056] channel-binding data for the outer
    channel in the inner EAP\n   method's channel bindings.  Doing so would provide
    a facility similar\n   to EAP cryptographic binding, except that a man-in-the-middle
    could\n   not extract the inner method from the tunnel.  This specification\n
    \  does not weigh the advantages of doing so nor specify how to do so;\n   the
    example is provided only to illustrate how EAP channel binding\n   and [RFC5056]
    channel binding overlap.\n"
  - contents:
    - "4.1.  Types of EAP Channel Bindings\n   There are two categories of approach
      to EAP channel bindings:\n   o  After keys have been derived during an EAP execution,
      the peer and\n      server can, in an integrity-protected channel, exchange
      plaintext\n      information about the network with each other and verify\n
      \     consistency and correctness.\n   o  The peer and server can both uniquely
      encode their respective view\n      of the network information without exchanging
      it, resulting into\n      an opaque blob that can be included directly into
      the derivation\n      of EAP session keys.\n   Both approaches are only applicable
      to key-deriving EAP methods and\n   both have advantages and disadvantages.
      \ Various hybrid approaches\n   are also possible.  Advantages of exchanging
      plaintext information\n   include:\n   o  It allows for policy-based comparisons
      of network properties,\n      rather than requiring precise matches for every
      field, which\n      achieves a policy-defined consistency, rather than bitwise\n
      \     equality.  This allows network operators to define which\n      properties
      are important and even verifiable in their network.\n   o  EAP methods that
      support extensible, integrity-protected channels\n      can easily include support
      for exchanging this network\n      information.  In contrast, direct inclusion
      into the key\n      derivation would require more extensive revisions to existing
      EAP\n      methods or a wrapper EAP method.\n   o  Given it doesn't affect the
      key derivation, this approach\n      facilitates debugging, incremental deployment,
      backward\n      compatibility, and a logging mode in which verification results\n
      \     are recorded but do not have an effect on the remainder of the EAP\n      execution.
      \ The exact use of the verification results can be\n      subject to the network
      policy.  Additionally, consistent\n      information canonicalization and formatting
      for the key derivation\n      approach would likely cause significant deployment
      problems.\n   The following are advantages of directly including channel-binding\n
      \  information in the key derivation:\n   o  EAP methods not supporting extensible,
      integrity-protected\n      channels could still be supported, either by revising
      their key\n      derivation, revising EAP, or wrapping them in a universal method\n
      \     that supports channel binding.\n   o  It can guarantee proper channel
      information, since subsequent\n      communication would be impossible if differences
      in channel\n      information yield different session keys on the EAP peer and\n
      \     server.\n"
    title: 4.1.  Types of EAP Channel Bindings
  - contents:
    - "4.2.  Channel Bindings in the Secure Association Protocol\n   This document
      describes channel bindings performed by transporting\n   channel-binding information
      as part of an integrity-protected\n   exchange within an EAP method.  Alternatively,
      some future document\n   could specify a mechanism for transporting channel
      bindings within\n   the lower layer's secure association protocol.  Such a specification\n
      \  would need to describe how channel bindings are exchanged over the\n   lower-layer
      protocol between the peer and authenticator.  In\n   addition, since the EAP
      exchange concludes before the secure\n   association protocol begins, a mechanism
      for transporting the channel\n   bindings from the authenticator to the EAP
      server needs to be\n   specified.  A mechanism for transporting a protected
      result from the\n   EAP server, through the authenticator, back to the peer
      needs to be\n   specified.\n   The channel bindings MUST be transported with
      integrity protection\n   based on a key known only to the peer and EAP server.
      \ The channel\n   bindings SHOULD be confidentiality protected using a key known
      only\n   to the peer and EAP server.  For the system to function, the EAP\n
      \  server or AAA server needs access to the channel-binding information\n   from
      the peer as well as the AAA attributes and a local database\n   described later
      in this document.\n   The primary advantage of sending channel bindings as part
      of the\n   secure association protocol is that EAP methods need not be changed.\n
      \  The disadvantage is that a new AAA exchange is required, and secure\n   association
      protocols need to be changed.  As the results of the\n   secure association
      protocol change, every NAS needs to be upgraded to\n   support channel bindings
      within the secure association protocol.\n   For many deployments, changing all
      the NASes is expensive, and adding\n   channel-binding support to enough EAP
      methods to meet the goals of\n   the deployment will be cheaper.  However for
      deployment of new\n   equipment, or especially deployment of a new lower-layer
      technology,\n   changing the NASes may be cheaper than changing EAP methods.\n
      \  Especially if such a deployment needed to support a large number of\n   EAP
      methods, sending channel bindings in the secure association\n   protocol might
      make sense.  Sending channel bindings in the secure\n   association protocol
      can work even with the EAP Re-authentication\n   Protocol (ERP) [RFC5296] in
      which previously established EAP key\n   material is used for the secure association
      protocol without carrying\n   out any EAP method during re-authentication.\n
      \  If channel bindings using a secure association protocol are\n   specified,
      semantics as well as the set of information that peers\n   exchange can be shared
      with the mechanism described in this document.\n"
    title: 4.2.  Channel Bindings in the Secure Association Protocol
  - contents:
    - "4.3.  Channel-Binding Scope\n   The scope of EAP channel bindings differs somewhat
      depending on the\n   type of deployment in which they are being used.  In enterprise\n
      \  networks, they can be used to authenticate very specific properties\n   of
      the authenticator (e.g., Medium Access Control (MAC) address,\n   supported
      link types and data rates, etc.), while in service provider\n   networks they
      can generally only authenticate broader information\n   about a roaming partner's
      network (e.g., network name, roaming\n   information, link security requirements,
      etc.).  The reason for the\n   difference has to do with the amount of information
      about the\n   authenticator and/or network to which the peer is connected the
      home\n   EAP server is expected to have access to.  In roaming cases, the home\n
      \  server is likely to only have access to information contained in\n   their
      roaming agreements.\n   With any multi-hop AAA infrastructure, many of the NAS-specific
      AAA\n   attributes are obscured by the AAA proxy that's decrypting,\n   reframing,
      and retransmitting the underlying AAA messages.\n   Especially service provider
      networks are affected by this, and the\n   AAA information received from the
      last hop may not contain much\n   verifiable information after transformations
      performed by AAA\n   proxies.  For example, information carried in AAA attributes
      such as\n   the NAS IP address may have been lost in transition and thus are
      not\n   known to the EAP server.  Even worse, information may still be\n   available
      but be useless, for example, representing the identity of a\n   device on a
      private network or a middlebox.  This affects the ability\n   of the EAP server
      to verify specific NAS properties.  However, often\n   verification of the MAC
      or IP address of the NAS is not useful for\n   improving the overall security
      posture of a network.  More often, the\n   best approach is to make policy decisions
      about services being\n   offered to peers.  For example, in an IEEE 802.11 network,
      the EAP\n   server may wish to ensure that peers connecting to the corporate\n
      \  intranet are using secure link-layer encryption, while link-layer\n   security
      requirements for peers connecting to the guest network could\n   be less stringent.
      \ These types of policy decisions can be made\n   without knowing or being able
      to verify the IP address of the NAS\n   through which the peer is connecting.\n
      \  The properties of the network that the peer wishes to validate depend\n   on
      the specific deployment.  In a mobile phone network, peers\n   generally don't
      care what the name of the network is, as long as they\n   can make their phone
      call and are charged the expected amount for the\n   call.  However, in an enterprise
      network, the administrators of a\n   peer may be more concerned with specifics
      of where their network\n   traffic is being routed and what VLAN is in use.
      \ To establish\n   policies surrounding these requirements, administrators would
      capture\n   some attribute such as SSID to describe the properties of the network\n
      \  they care about.  Channel bindings could validate the SSID.  The\n   administrator
      would need to make sure that the network guarantees\n   that when an authenticator
      trusted by the AAA infrastructure to offer\n   a particular SSID to clients
      does offer this SSID, that network has\n   the intended properties.  Generally,
      it is not possible for channel\n   bindings to detect lying NAS behavior when
      the NAS is authorized to\n   claim a particular service.  That is, if the same
      physical\n   authenticator is permitted to advertise two networks, the AAA\n
      \  infrastructure is unlikely to be able to determine when this\n   authenticator
      lies.\n   As discussed in the next section, some of the most important\n   information
      to verify cannot come from AAA attributes but instead\n   comes from local configuration.
      \ For example, in the mobile phone\n   case, the expected roaming rate cannot
      come from the roaming provider\n   without being verified against the contract
      between the two\n   providers.  Similarly, in an enterprise, the SSID that a
      particular\n   access point is expected to advertise comes from configuration
      rather\n   than an AAA exchange (which can be confirmed with channel binding).\n
      \  The peer and authenticator do not initially have a basis for trust.\n   The
      peer has a credential with the EAP server that forms a basis for\n   trust.
      \ The EAP server and authenticator have a potentially indirect\n   trust path
      using the AAA infrastructure.  Channel binding leverages\n   the trust between
      the peer and EAP server to build trust in certain\n   attributes between the
      peer and authenticator.\n   Channel bindings can be important for forming areas
      of trust,\n   especially when provider networks are involved, and exact information\n
      \  is not available to the EAP server.  Without channel bindings, all\n   entities
      in the system need to be held to the standards of the most\n   trusted entity
      that could be accessed using the EAP credential.\n   Otherwise, a less trusted
      entity can impersonate a more trusted\n   entity.  However when channel bindings
      are used, the EAP server can\n   use information supplied by the peer, AAA protocols
      and local\n   database to distinguish less trusted entities from more trusted\n
      \  entities.  One possible deployment involves being able to verify a\n   number
      of characteristics about relatively trusted entities while for\n   other entities
      simply verifying that they are less trusted.\n   Any deployment of channel bindings
      should take into consideration\n   both what information the EAP server is likely
      to know or have access\n   to, and what type of network information the peer
      would want and need\n   authenticated.\n"
    title: 4.3.  Channel-Binding Scope
  title: 4.  Channel Bindings
- contents:
  - "5.  Channel-Binding Process\n   This section defines the process for verifying
    channel-binding\n   information during an EAP authentication.  The protocol uses
    the\n   approach where plaintext data is exchanged, since it allows channel\n
    \  bindings to be used more flexibly in varied deployment models (see\n   Section
    4.1).  In the first subsection, the general communication\n   infrastructure is
    outlined, the messages used for channel-binding\n   verifications are specified,
    and the protocol flows are defined.  The\n   second subsection explores the difficulties
    of checking the different\n   pieces of information that are exchanged during
    the channel-binding\n   protocol for consistency.  The third subsection describes
    the\n   information carried in the EAP exchange.\n"
  - contents:
    - "5.1.  Protocol Operation\n   Channel bindings are always provided between two
      communication\n   endpoints (here, the EAP peer and the EAP server), who communicate\n
      \  through an authenticator typically in pass-through mode.\n   Specifications
      treat the AAA server and EAP server as distinct\n   entities.  However, there
      is no standardized protocol for the AAA\n   server and EAP server to communicate
      with each other.  For the\n   channel-binding protocol presented in this document
      to work, the EAP\n   server needs to be able to access information from the
      AAA server\n   that is utilized during the EAP session (i2 below) and a local\n
      \  database.  For example, the EAP server and the local database can be\n   co-located
      with the AAA server, as illustrated in Figure 1.  An\n   alternate architecture
      would be to provide a mechanism for the EAP\n   server to inform the AAA server
      what channel-binding attributes were\n   supplied and the AAA server to inform
      the EAP server about what\n   channel-binding attributes it considered when
      making its decision.\n                                        + -------------------------+\n
      \    --------        -------------      |   ----------     ______  |\n    |EAP
      peer|<---->|Authenticator|<--> |  |EAP Server|___(______) |\n     --------        -------------
      \     |   ----------    | DB   | |\n        .                 .             |AAA
      \             (______) |\n        .       i1        .             +--------------------------+\n
      \       .<----------------.      i2     .       .\n        .                 .------------>
      \       .\n        .                  i1                   .\n        .-------------------------------------->.\n
      \       .     CB_success/failure(i1, i2,info)   .\n        .<--------------------------------------.\n
      \             Figure 1: Overview of Channel-Binding Protocol\n   During network
      advertisement, selection, and authentication, the\n   authenticator presents
      unauthenticated information, labeled i1, about\n   the network to the peer.
      \ Message i1 could include an authenticator\n   identifier and the identity
      of the network it represents, in addition\n   to advertised network information
      such as offered services and\n   roaming information.  Information (such as
      the type of media in use)\n   may be communicated implicitly in i1.  As there
      is no established\n   trust relationship between the peer and authenticator,
      there is no\n   way for the peer to validate this information.\n   Additionally,
      during the transaction the authenticator presents a\n   number of information
      properties in the form of AAA attributes about\n   itself and the current request.
      \ These AAA attributes may or may not\n   contain accurate information.  This
      information is labeled i2.\n   Message i2 is the information the AAA server
      receives from the last\n   hop in the AAA proxy chain which is not necessarily
      the\n   authenticator.\n   AAA hops between the authenticator and AAA server
      can validate some\n   of i2.  Whether the AAA server will be able to rely on
      this depends\n   significantly on the business relationship executed with these\n
      \  proxies and on the structure of the AAA network.\n   The local database is
      perhaps the most important part of this system.\n   In order for the EAP server
      or AAA server to know whether i1 and i2\n   are correct, they need access to
      trustworthy information, since an\n   authenticator could include false information
      in both i1 and i2.\n   Additional reasons why such a database is necessary for
      channel\n   bindings to work are discussed in the next subsection.  The\n   information
      contained within the database could involve wildcards.\n   For example, this
      could be used to check whether IEEE 802.11 access\n   points on a particular
      IP subnet all use a specific SSID.  The exact\n   IP address is immaterial,
      provided it is on the correct subnet.\n   During an EAP method execution with
      channel bindings, the peer sends\n   i1 to the EAP server using the mechanism
      described in Section 5.3.\n   The EAP server verifies the consistency of i1
      provided by the peer,\n   i2 provided by the authenticator, and the information
      in the local\n   database.  Upon the check, the EAP server sends a message to
      the peer\n   indicating whether the channel-binding validation check succeeded
      or\n   failed and includes the attributes that were used in the check.  The\n
      \  message flow is illustrated in Figure 1.\n   Above, the EAP server is described
      as performing the channel-binding\n   validation.  In most deployments, this
      will be a necessary\n   implementation constraint.  The EAP exchange needs to
      include an\n   indication of channel-binding success or failure.  Most existing\n
      \  implementations do not have a way to have an exchange between the EAP\n   server
      and another AAA entity during the EAP server's processing of a\n   single EAP
      message.  However, another AAA entity can provide\n   information to the EAP
      server to make its decision.\n   If the compliance of i1 or i2 information with
      the authoritative\n   policy source is mandatory and a consistency check failed,
      then after\n   sending a protected indication of failed consistency, the EAP
      server\n   MUST send an EAP-Failure message to terminate the session.  If the\n
      \  EAP server is otherwise configured, it MUST allow the EAP session to\n   complete
      normally and leave the decision about network access up to\n   the peer's policy.
      \ If i1 or i2 does not comply with policy, the EAP\n   server MUST NOT list
      information that failed to comply in the set of\n   information used to perform
      channel binding.  In this case, the EAP\n   server SHOULD indicate channel-binding
      failure; this requirement may\n   be upgraded to a MUST in the future.\n"
    title: 5.1.  Protocol Operation
  - contents:
    - "5.2.  Channel-Binding Consistency Check\n   The validation check that is the
      core of the channel-binding protocol\n   described in the previous subsection
      consists of two parts in which\n   the server checks whether:\n   1.  the authenticator
      is lying to the peer, i.e., i1 contains false\n       information, and\n   2.
      \ the authenticator or any entity on the AAA path to the AAA server\n       provides
      false information in form of AAA attributes, i.e., i2\n       contains false
      information.\n   These checks enable the EAP server to detect lying NASes or\n
      \  authenticators in enterprise networks and lying providers in service\n   provider
      networks.\n   Checking the consistency of i1 and i2 is nontrivial, as has been\n
      \  pointed out already in [HC07].  First, i1 can contain any type of\n   information
      propagated by the authenticator, whereas i2 is restricted\n   to information
      that can be carried in AAA attributes.  Second,\n   because the authenticator
      typically communicates over different link\n   layers with the peer and the
      AAA infrastructure, different types of\n   identifiers and addresses may have
      been presented to both\n   communication endpoints.  Whether these different
      identifiers and\n   addresses belong to the same device cannot be directly checked
      by the\n   EAP server or AAA server without additional information.  Finally,
      i2\n   may be different from the original information sent by the\n   authenticator
      because of en route processing or malicious\n   modifications.  As a result,
      in the service provider model, typically\n   the i1 information available to
      the EAP server can only be verified\n   against the last-hop portion of i2 or
      against values propagated by\n   proxy servers.  In addition, checking the consistency
      of i1 and i2\n   alone is insufficient because an authenticator could lie to
      both the\n   peer and the EAP server, i.e., i1 and i2 may be consistent but
      both\n   contain false information.\n   A local database is required to leverage
      the above-mentioned\n   shortcomings and support the consistency and validation
      checks.  In\n   particular, information stored for each NAS/authenticator (enterprise\n
      \  scenario) or each roaming partner (service provider scenario) enables\n   a
      comparison of any information received in i1 with AAA attributes in\n   i2 as
      well as additionally stored AAA attributes that might have been\n   lost in
      transition.  Furthermore, only such a database enables the\n   EAP server and
      AAA server to check the received information against\n   trusted information
      about the network including roaming agreements.\n   Section 7 describes lower-layer-specific
      properties that can be\n   exchanged as a part of i1.  Section 8 describes specific
      AAA\n   attributes that can be included and evaluated in i2.  The EAP server\n
      \  reports back the results from the channel-binding validation check\n   that
      compares the consistency of all the values with those in the\n   local database.
      \ The challenges of setting up such a local database\n   are discussed in Section
      10.\n"
    title: 5.2.  Channel-Binding Consistency Check
  - contents:
    - "5.3.  EAP Protocol\n   EAP methods supporting channel binding consistent with
      this\n   specification provide a mechanism for carrying channel-binding data\n
      \  from the peer to the EAP server and a channel-binding response from\n   the
      EAP server to the peer.  The specifics of this mechanism are\n   dependent on
      the method, although the content of the channel-binding\n   data and channel-binding
      response are defined by this section.\n   Typically the lower layer will communicate
      a set of attributes to the\n   EAP implementation on the peer that should be
      part of channel\n   binding.  The EAP implementation may need to indicate to
      the lower\n   layer that channel-binding information cannot be sent.  Reasons
      for\n   failing to send channel-binding information include an EAP method\n
      \  that does not support channel binding is selected, or channel-binding\n   data
      is too big for the EAP method selected.  Peers SHOULD provide\n   appropriate
      policy controls to select channel binding or mandate its\n   success.\n   The
      EAP server receives the channel-binding data and performs the\n   validation.
      \ The EAP method provides a way to return a response; the\n   channel-binding
      response uses the same basic format as the channel-\n   binding data.\n    0
      \                  1                   2                   3\n    0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Code      |             Length            |      NSID     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       NS-Specific...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |             Length            |      NSID     | NS-Specific...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                   Figure 2: Channel-Binding Encoding\n   Both the channel-binding
      data and response use the format illustrated\n   in Figure 2.  The protocol
      starts with a one-byte code; see\n   Section 5.3.1.  Then, for each type of
      attribute contained in the\n   channel-binding data, the following information
      is encoded:\n   Length:  Two octets of length in network byte order, indicating
      the\n      length of the NS-Specific data.  The NSID and length octets are\n
      \     not included.\n   NSID:  Namespace identifier.  One octet describing the
      namespace from\n      which the attributes are drawn.  See Section 5.3.3 for
      a\n      description of how to encode RADIUS attributes in channel-binding\n
      \     data and responses.  RADIUS uses a namespace identifier of 1 .\n   NS-Specific:
      \ The encoding of the attributes in a manner specific to\n      the type of
      attribute.\n   A given NSID MUST NOT appear more than once in a channel-binding
      data\n   or channel-binding response.  Instead, all NS-Specific data for a\n
      \  particular NSID must occur inside one set of fields (NSID, Length,\n   and
      NS-Specific).  This set of fields may be repeated if multiple\n   namespaces
      are included.\n   In channel-binding data, the code is set to 1 (channel-binding
      data),\n   and the full attributes and values that the peer wishes the EAP\n
      \  server to validate are included.\n   In a channel-binding response, the server
      selects the code; see\n   Section 5.3.1.  For successful channel binding, the
      server returns\n   code 2.  The set of attributes that the EAP server returns
      depend on\n   the code.  For success, the server returns the attributes that
      were\n   considered by the server in making the determination that channel\n
      \  bindings are successfully validated; attributes that the server is\n   unable
      to check or that failed to validate against what is sent by\n   the peer MUST
      NOT be returned in a success response.  Generally,\n   servers will not return
      a success response if any attributes were\n   checked and failed to validate
      those specified by the peer.  Special\n   circumstances such as a new attribute
      being phased in at a server MAY\n   require servers to return success when such
      an attribute fails to\n   validate.  The server returns the value supplied by
      the peer when\n   returning an attribute in channel-binding responses.\n   For
      channel-binding failure (code 3), the server SHOULD include any\n   attributes
      that were successfully validated.  This code means that\n   server policy indicates
      that the attributes sent by the client do not\n   accurately describe the authenticator.
      \ Servers MAY include no\n   attributes in this response; for example, if the
      server checks the\n   attributes supplied by the peer and they fail to be consistent,
      it\n   may send a response without attributes.\n   Peers MUST treat unknown
      codes as channel-binding failure.  Peers\n   MUST ignore differences between
      attribute values sent in the channel-\n   binding data and those sent in the
      response.  Peers and servers MUST\n   ignore any attributes contained in a field
      with an unknown NSID.\n   Peers MUST ignore any attributes in a response not
      present in the\n   channel-binding data.\n"
    - contents:
      - "5.3.1.  Channel-Binding Codes\n               +------+-----------------------------------+\n
        \              | Code | Meaning                           |\n               +------+-----------------------------------+\n
        \              | 1    | Channel-binding data from client  |\n               |
        2    | Channel-binding response: success |\n               | 3    | Channel-binding
        response: failure |\n               +------+-----------------------------------+\n"
      title: 5.3.1.  Channel-Binding Codes
    - contents:
      - "5.3.2.  Namespace Identifiers\n            +-----+--------------------------+---------------+\n
        \           | ID  | Namespace                | Reference     |\n            +-----+--------------------------+---------------+\n
        \           | 1   | RADIUS                   | Section 5.3.3 |\n            |
        255 | Reserved for Private Use |               |\n            +-----+--------------------------+---------------+\n"
      title: 5.3.2.  Namespace Identifiers
    - contents:
      - "5.3.3.  RADIUS Namespace\n   RADIUS attribute-value pairs (AVPs) are encoded
        with a one-octet\n   attribute type followed by a one-octet length followed
        by the value\n   of the RADIUS attribute being encoded.  The length includes
        the type\n   and length octets; the minimum legal length is 3.  Attributes
        are\n   concatenated to form the namespace-specific portion of the packet.\n
        \      0                   1                   2\n       0 1 2 3 4 5 6 7 8
        9 0 1 2 3 4 5 6 7 8 9 0\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \     |     Type      |    Length     |  Value ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \                      Figure 3: RADIUS AVP Encoding\n   The full value of
        an attribute is included in the channel-binding\n   data and response.\n"
      title: 5.3.3.  RADIUS Namespace
    title: 5.3.  EAP Protocol
  title: 5.  Channel-Binding Process
- contents:
  - "6.  System Requirements\n   This section defines requirements on components used
    to implement the\n   channel-bindings protocol.\n   The channel-binding protocol
    defined in this document must be\n   transported after keying material has been
    derived between the EAP\n   peer and server, and before the peer would suffer
    adverse affects\n   from joining an adversarial network.  This document describes
    a\n   protocol for performing channel binding within EAP methods.  As\n   discussed
    in Section 4.2, an alternative approach for meeting this\n   requirement is to
    perform channel bindings during the secure\n   association protocol of the lower
    layer.\n"
  - contents:
    - "6.1.  General Transport Protocol Requirements\n   The transport protocol for
      carrying channel-binding information MUST\n   support end-to-end (i.e., between
      the EAP peer and server) message\n   integrity protection to prevent the adversarial
      NAS or AAA device\n   from manipulating the transported data.  The transport
      protocol\n   SHOULD provide confidentiality.  The motivation for this is that
      the\n   channel bindings could contain private information, including peer\n
      \  identities, which SHOULD be protected.  If confidentiality cannot be\n   provided,
      private information MUST NOT be sent as part of the\n   channel-binding information.\n
      \  Any transport needs to be careful not to exceed the MTU for its\n   lower-layer
      medium.  In particular, if channel-binding information is\n   exchanged within
      protected EAP method channels, these methods may or\n   may not support fragmentation.
      \ In order to work with all methods,\n   the channel-binding messages must fit
      within the available payload.\n   For example, if the EAP MTU is 1020 octets,
      and EAP - Generalized\n   Pre-Shared Key (EAP-GPSK) is used as the authentication
      method, and\n   maximal-length identities are used, a maximum of 384 octets
      is\n   available for conveying channel-binding information.  Other methods,\n
      \  such as EAP Tunneled Transport Layer Security (EAP-TTLS), support\n   fragmentation
      and could carry significantly longer payloads.\n"
    title: 6.1.  General Transport Protocol Requirements
  - contents:
    - "6.2.  EAP Method Requirements\n   When transporting data directly within an
      EAP method, the method MUST\n   be able to carry integrity-protected data from
      the EAP peer to server\n   and from EAP server to peer.  EAP methods MUST exchange
      channel-\n   binding data with the AAA subsystem hosting the EAP server.  EAP\n
      \  methods MUST be able to import channel-binding data from the lower\n   layer
      on the EAP peer.\n"
    title: 6.2.  EAP Method Requirements
  title: 6.  System Requirements
- contents:
  - "7.  Channel-Binding TLV\n   This section defines some channel-binding TLVs.  While
    message i1 is\n   not limited to AAA attributes, for the sake of tangible attributes\n
    \  that are already in place, this section discusses AAA AVPs that are\n   appropriate
    for carrying channel bindings (i.e., data from i1 in\n   Section 5).\n   For any
    lower-layer protocol, network information of interest to the\n   peer and server
    can be encapsulated in AVPs or other defined payload\n   containers.  The appropriate
    AVPs depend on the lower-layer protocol\n   as well as on the network type (i.e.,
    enterprise network or service\n   provider network) and its application.\n"
  - contents:
    - "7.1.  Requirements for Lower-Layer Bindings\n   Lower-layer protocols MUST
      support EAP in order to support EAP\n   channel bindings.  These lower layers
      MUST support EAP methods that\n   derive keying material, as otherwise no integrity-protected
      channel\n   would be available to execute the channel-bindings protocol.  Lower-\n
      \  layer protocols need not support traffic encryption, since this is\n   independent
      of the authentication phase.\n   The data conveyed within the AVP type MUST
      NOT conflict with the\n   externally defined usage of the AVP.  Additional TLV
      types MAY be\n   defined for values that are not communicated within AAA attributes.\n
      \  In general, lower layers will need to specify what information should\n   be
      included in i1.  Existing lower layers will probably require new\n   documents
      to specify this information.  Lower-layer specifications\n   need to include
      sufficient information in i1 to uniquely identify\n   which lower layer is involved.
      \ The preferred way to do this is to\n   include the EAP-Lower-Layer attribute
      defined in the next section.\n   This MUST be included in i1 unless an attribute
      specific to a\n   particular lower layer is included in i1.\n"
    title: 7.1.  Requirements for Lower-Layer Bindings
  - contents:
    - "7.2.  EAP Lower-Layer Attribute\n   A new RADIUS attribute is defined to carry
      information on which EAP\n   lower layer is used for this EAP authentication.
      \ This attribute\n   provides information relating to the lower layer over which
      EAP is\n   transported.  This attribute MAY be sent by the NAS to the RADIUS\n
      \  server in an Access-Request or an Accounting-Request packet.  A\n   summary
      of the EAP-Lower-Layer attribute format is shown below.  The\n   fields are
      transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     |             Value\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \            Value (cont.)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The code is 163, the length is 6, and the value is a 32-bit unsigned\n   integer
      in network byte order.  The value specifies the EAP lower\n   layer in use.
      \ Values are taken from the IANA registry established in\n   Section 11.1.\n"
    title: 7.2.  EAP Lower-Layer Attribute
  title: 7.  Channel-Binding TLV
- contents:
  - "8.  AAA-Layer Bindings\n   This section discusses which AAA attributes in a AAA
    Access-Request\n   message can and should be validated by a EAP server (i.e.,
    data from\n   i2 in Section 5).  As noted before, this data can be manipulated
    by\n   AAA proxies either to enable functionality (e.g., removing realm\n   information
    after messages have been proxied) or to act maliciously\n   (e.g., in the case
    of a lying provider).  As such, this data cannot\n   always be easily validated.
    \ However, as thorough of a validation as\n   possible should be conducted in
    an effort to detect possible attacks.\n   NAS-IP-Address:  This value is typically
    the IP address of the\n      authenticator; however, in a proxied connection,
    it likely will\n      not match the source IP address of an Access-Request.  A\n
    \     consistency check MAY verify the subnet of the IP address was\n      correct
    based on the last-hop proxy.\n   NAS-IPv6-Address:  This value is typically the
    IPv6 address of the\n      authenticator; however, in a proxied connection, it
    likely will\n      not match the source IPv6 address of an Access-Request.  A\n
    \     consistency check MAY verify the subnet of the IPv6 address was\n      correct
    based on the last-hop proxy.\n   NAS-Identifier:  This is an identifier populated
    by the NAS to\n      identify the NAS to the AAA server; it SHOULD be validated
    against\n      the local database.\n   NAS-Port-Type:  This specifies the underlying
    link technology.  It\n      SHOULD be validated against the value received from
    the peer in\n      the information exchange and against a database of authorized\n
    \     link-layer technologies.\n"
  title: 8.  AAA-Layer Bindings
- contents:
  - "9.  Security Considerations\n   This section discusses security considerations
    surrounding the use of\n   EAP channel bindings.\n"
  - contents:
    - "9.1.  Trust Model\n   In the considered trust model, EAP peer and authentication
      server are\n   honest, while the authenticator is maliciously sending false\n
      \  information to peer and/or server.  In the model, the peer and server\n   trust
      each other, which is not an unreasonable assumption,\n   considering they already
      have a trust relationship.  The following\n   are the trust relationships:\n
      \  o  The server trusts that the channel-binding information received\n      from
      the peer is the information that the peer received from the\n      authenticator.\n
      \  o  The peer trusts the channel-binding result received from the\n      server.\n
      \  o  The server trusts the information contained within its local\n      database.\n
      \  In order to establish the first two trust relationships during an EAP\n   execution,
      an EAP method MUST provide the following:\n   o  mutual authentication between
      peer and server\n   o  derivation of keying material including a key for integrity\n
      \     protection of channel-binding messages known to the peer and EAP\n      server
      but not the authenticator\n   o  transmission of the channel-binding request
      from peer to server\n      over an integrity-protected channel\n   o  transmission
      of the channel-binding result from server to peer\n      over an integrity-protected
      channel\n   This trust model is a significant departure from the standard EAP\n
      \  model.  In many EAP deployments today, attacks where one\n   authenticator
      can impersonate another are not a significant concern\n   because all authenticators
      provide the same service.  A authenticator\n   does not gain significant advantage
      by impersonating another\n   authenticator.  The use of EAP in situations where
      different\n   authenticators provide different services may give an attacker
      who\n   can impersonate a authenticator greater advantage.  The system as a\n
      \  whole needs to be analyzed to evaluate cases where one authenticator\n   may
      impersonate another and to evaluate the impact of this\n   impersonation.\n
      \  One attractive implementation strategy for channel binding is to add\n   channel-binding
      support to a tunnel method that can tunnel an inner\n   EAP authentication.
      \ This way, channel binding can be achieved with\n   any method that can act
      as an inner method even if that inner method\n   does not have native channel-binding
      support.  The requirement for\n   mutual authentication and key derivation is
      at the layer of EAP that\n   actually performs the channel binding.  Tunnel
      methods sometimes use\n   cryptographic binding, a process where a peer proves
      that the peer\n   for the outer method is the same as the peer for an inner
      method to\n   tie authentication at one layer together with an inner layer.\n
      \  Cryptographic binding does not always provide mutual authentication;\n   its
      definition does not require the server to prove that the inner\n   server and
      outer server are the same.  Even when cryptographic\n   binding does attempt
      to confirm that the inner and outer server are\n   the same, the Master Session
      Key (MSK) from the inner method is\n   typically used to protect the binding.
      \ An attacker such as an\n   authenticator that wishes to subvert channel binding
      could establish\n   an outer tunnel terminating at the authenticator.  If the
      outer\n   method tunnel terminates on the authenticator, the MSK is disclosed\n
      \  to the authenticator, which can typically attack cryptographic\n   binding.
      \ If the authenticator controls cryptographic binding, then\n   it typically
      controls the channel-binding parameters and results.  If\n   the channel-binding
      process is used to differentiate one\n   authenticator from another, then the
      authenticator can claim to\n   support services that it was not authorized to.
      \ This attack was not\n   in scope for existing threat models for cryptographic
      binding because\n   differentiated authenticators was not a consideration.  Thus,\n
      \  existing cryptographic binding does not typically provide mutual\n   authentication
      of the inner-method server required for channel\n   binding.  Other methods
      besides cryptographic binding are available\n   to provide mutual authentication
      required by channel binding.  As an\n   example, if server certificates are
      validated and names checked,\n   mutual authentication can be provided directly
      by the tunnel.\n"
    title: 9.1.  Trust Model
  - contents:
    - "9.2.  Consequences of Trust Violation\n   If any of the trust relationships
      listed in Section 9.1 are violated,\n   channel binding cannot be provided.
      \ In other words, if mutual\n   authentication with key establishment as part
      of the EAP method as\n   well as protected database access are not provided,
      then achieving\n   channel binding is not feasible.\n   Dishonest peers can
      only manipulate the first message i1 of the\n   channel-binding protocol.  In
      this scenario, a peer sends i1' to the\n   server.  If i1' is invalid, the channel-binding
      validation will fail.\n   On the other hand, if i1' passes the validation, either
      the original\n   i1 was wrong and i1' corrected the problem, or both i1 and
      i1'\n   constitute valid information.  A peer could potentially gain an\n   advantage
      in auditing or charging if both are valid and information\n   from i1' is used
      for auditing or charging.  Such peers can be\n   detected by including the information
      in i2 and checking i1 against\n   i2.\n   If information from i1 does not validate,
      an EAP server cannot\n   generally determine whether the authenticator advertised
      incorrect\n   information or whether the peer is dishonest.  This should be\n
      \  considered before using channel-binding validation failures to\n   determine
      the reputation either of the peer or authenticator.\n   Dishonest servers can
      send EAP-Failure messages and abort the EAP\n   authentication even if the received
      i1 is valid.  However, servers\n   can always abort any EAP session, independent
      of whether or not\n   channel binding is offered.  On the other hand, dishonest
      servers can\n   claim a successful validation even if i1 contains invalid\n
      \  information.  This can be seen as collaboration of authenticator and\n   server.
      \ Channel binding can neither prevent nor detect such attacks.\n   In general,
      such attacks cannot be prevented by cryptographic means\n   and should be addressed
      using policies that make servers liable for\n   their provided information and
      services.\n   Additional network entities (such as proxies) might be on the\n
      \  communication path between peer and server and may attempt to\n   manipulate
      the channel-binding protocol.  If these entities do not\n   possess the keying
      material used for integrity protection of the\n   channel-binding messages,
      the same threat analysis applies as for the\n   dishonest authenticators.  Hence,
      such entities cannot manipulate a\n   single channel-binding message or the
      outcome.  On the other hand,\n   entities with access to the keying material
      must be treated like a\n   server in a threat analysis.  Hence, such entities
      are able to\n   manipulate the channel-binding protocol without being detected.\n
      \  However, the required knowledge of keying material is unlikely since\n   channel
      binding is executed before the EAP method is completed, and\n   thus before
      keying material is typically transported to other\n   entities.\n"
    title: 9.2.  Consequences of Trust Violation
  - contents:
    - "9.3.  Bid-Down Attacks\n   EAP methods that add channel binding will typically
      negotiate its\n   use.  Even for entirely new EAP methods designed with channel
      binding\n   from the first version, some deployments may not use it.  It is\n
      \  desirable to protect against attacks on the negotiation of channel\n   bindings.
      \ An attacker including the NAS SHOULD NOT be able to\n   prevent a peer and
      server who support channel bindings from using\n   them.\n   Unfortunately,
      existing EAP methods may make it difficult or\n   impossible to protect against
      attacks on negotiation.  For example,\n   many EAP state machines will accept
      a success message at any point\n   after key derivation to terminate authentication.
      \ EAP success\n   messages are not integrity protected; an attacker who could
      insert a\n   message can generate one.  The NAS is always in a position to\n
      \  generate a success message.  Common EAP servers take advantage of\n   state
      machines accepting success messages even in cases where an EAP\n   method might
      support a protected indication of success.  It may be\n   challenging to define
      channel-binding support for existing EAP\n   methods in a manner that permits
      peers to distinguish an old EAP\n   server that sends a success indication and
      does not support channel\n   binding from an attacker injecting a success indication.\n"
    title: 9.3.  Bid-Down Attacks
  - contents:
    - "9.4.  Privacy Violations\n   While the channel-binding information exchanged
      between EAP peer and\n   EAP server (i.e., i1 and the result message) must always
      be integrity\n   protected, it may not be encrypted.  In the case that these
      messages\n   contain identifiers of peer and/or network entities, the privacy\n
      \  property of the executed EAP method may be violated.  Hence, in order\n   to
      maintain the privacy of an EAP method, the exchanged channel-\n   binding information
      must be encrypted.  If encryption is not\n   available, private information
      is not sent as part of the channel-\n   binding information, as described in
      Section 6.1.\n   Privacy implications of attributes selected for channel binding
      need\n   to be considered.  Consider channel binding the username attribute.\n
      \  A peer sends a privacy protecting anonymous identifier in its EAP\n   identity
      message, but sends the full username in the protected i1\n   message.  However,
      the authenticator would like to learn the full\n   username.  It makes a guess
      and sends that in i2 rather than the\n   anonymous identifier.  If the EAP server
      validates this attribute and\n   fails when the username from the peer mismatches
      i2, then the EAP\n   server confirms the authenticator's guess.  Similar privacy
      exposures\n   may result whenever one party is in a position to guess channel-\n
      \  binding information provided by another party.\n"
    title: 9.4.  Privacy Violations
  title: 9.  Security Considerations
- contents:
  - "10.  Operations and Management Considerations\n   As with any extension to existing
    protocols, there will be an impact\n   on existing systems.  Typically, the goal
    is to develop an extension\n   that minimizes the impact on both development and
    deployment of the\n   new system, subject to the system requirements.  This section\n
    \  discusses the impact on existing devices that currently utilize EAP,\n   assuming
    the channel-binding information is transported within the\n   EAP method execution.\n
    \  The EAP peer will need an API between the EAP lower layer and the EAP\n   method
    that exposes the necessary information from the NAS to be\n   validated to the
    EAP peer, which can then feed that information into\n   the EAP methods for transport.
    \ For example, an IEEE 802.11 system\n   would need to make available the various
    information elements that\n   require validation to the EAP peer, which would
    properly format them\n   and pass them to the EAP method.  Additionally, the EAP
    peer will\n   require updated EAP methods that support transporting channel-binding\n
    \  information.  While most method documents are written modularly to\n   allow
    incorporating arbitrary protected information, implementations\n   of those methods
    would need to be revised to support these\n   extensions.  Driver updates are
    also required so methods can access\n   the required information.\n   No changes
    to the pass-through authenticator would be required.\n   The EAP server would
    need an API between the database storing NAS\n   information and the individual
    EAP server.  The database may already\n   exist on the AAA server, in which case
    the EAP server passes the\n   parameters to the AAA server for validation.  The
    EAP methods need to\n   be able to export received channel-binding information
    to the EAP\n   server so it can be validated.\n"
  title: 10.  Operations and Management Considerations
- contents:
  - "11.  IANA Considerations\n   A new top-level registry has been created for \"Extensible\n
    \  Authentication Protocol (EAP) Channel Binding Parameters\".  This\n   registry
    consists of several sub-registries.\n   The \"EAP Channel-Binding Codes\" sub-registry
    defines values for the\n   code field in the channel-binding data and channel-binding
    response\n   packet.  See the table in Section 5.3.1 for initial registrations.\n
    \  This registry requires Standards Action [RFC5226] for new\n   registrations.
    \ Early allocation [RFC4020] is allowed.  An additional\n   reference column has
    been added to the table for the registry,\n   pointing all codes in the initial
    registration to this specification.\n   Valid values in this sub-registry range
    from 0-255; 0 is reserved.\n   The \"EAP Channel-Binding Namespaces\" sub-registry
    contains\n   registrations for the NSID field in the channel-binding data and\n
    \  channel-binding response.  Initial registrations are found in the\n   table
    in Section 5.3.2.  Registrations in this registry require IETF\n   Review.  Valid
    values range from 0-255; 0 is reserved.  As with the\n   \"EAP Channel-Binding
    Codes\" sub-registry, a reference column has been\n   included to point to this
    document for initial registrations.\n"
  - contents:
    - "11.1.  EAP Lower Layers Registry\n   A new sub-registry in the EAP Numbers
      registry at\n   http://www.iana.org/assignments/eap-numbers has been created
      for EAP\n   Lower Layers.  Registration requires Expert Review [RFC5226]; the\n
      \  primary role of the expert is to prevent multiple registrations for\n   the
      same lower layer.\n   The following table gives the initial registrations for
      this\n   registry.\n            +-------+----------------------------------------+\n
      \           | Value | Lower Layer                            |\n            +-------+----------------------------------------+\n
      \           | 1     | Wired IEEE 802.1X                      |\n            |
      2     | IEEE 802.11 (no-pre-auth)              |\n            | 3     | IEEE
      802.11 (pre-authentication)       |\n            | 4     | IEEE 802.16e                           |\n
      \           | 5     | IKEv2                                  |\n            |
      6     | PPP                                    |\n            | 7     | PANA
      (no pre-authentication) [RFC5191] |\n            | 8     | GSS-API [GSS-API-EAP]
      \                 |\n            | 9     | PANA (pre-authentication) [RFC5873]
      \   |\n            +-------+----------------------------------------+\n"
    title: 11.1.  EAP Lower Layers Registry
  - contents:
    - "11.2.  RADIUS Registration\n   A new RADIUS attribute is registered with the
      name EAP-Lower-Layer;\n   163.  The RADIUS attributes are in the registry at\n
      \  http://www.iana.org/assignments/radius-types.\n"
    title: 11.2.  RADIUS Registration
  title: 11.  IANA Considerations
- contents:
  - "12.  Acknowledgments\n   The authors and editor would like to thank Bernard Aboba,
    Glen Zorn,\n   Joe Salowey, Stephen Hanna, and Klaas Wierenga for their valuable\n
    \  inputs that helped to improve and shape this document over the time.\n   Sam
    Hartman's work on this specification is funded by JANET(UK).\n   The EAP-Lower-Layer
    attribute was taken from \"RADIUS Attributes for\n   IEEE 802 Networks\" [RADIUS-WLAN].\n"
  title: 12.  Acknowledgments
- contents:
  - '13.  References

    '
  - contents:
    - "13.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for
      use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC3748]      Aboba, B., Blunk, L., Vollbrecht, J., Carlson,
      J., and\n                  H. Levkowetz, \"Extensible Authentication Protocol\n
      \                 (EAP)\", RFC 3748, June 2004.\n   [RFC4020]      Kompella,
      K. and A. Zinin, \"Early IANA Allocation of\n                  Standards Track
      Code Points\", BCP 100, RFC 4020,\n                  February 2005.\n   [RFC5226]
      \     Narten, T. and H. Alvestrand, \"Guidelines for Writing\n                  an
      IANA Considerations Section in RFCs\", BCP 26,\n                  RFC 5226,
      May 2008.\n"
    title: 13.1.  Normative References
  - contents:
    - "13.2.  Informative References\n   [AAA-PAY]      Clancy, T., Lior, A., Ed.,
      Zorn, G., and K. Hoeper,\n                  \"EAP Method Support for Transporting
      AAA Payloads\",\n                  Work in Progress, May 2010.\n   [GSS-API-EAP]
      \ Hartman, S., Ed. and J. Howlett, \"A GSS-API Mechanism\n                  for
      the Extensible Authentication Protocol\", Work in\n                  Progress,
      June 2012.\n   [HC07]         Hoeper, K. and L. Chen, \"Where EAP Security Claims\n
      \                 Fail\", Institute for Computer Sciences, Social\n                  Informatics
      and Telecommunications Engineering\n                  (ICST), The Fourth International
      Conference on\n                  Heterogeneous Networking for Quality, Reliability,\n
      \                 Security and Robustness (QShine 2007), August 2007.\n   [RADIUS-WLAN]
      \ Aboba, B., Malinen, J., Congdon, P., and J. Salowey,\n                  \"RADIUS
      Attributes for IEEE 802 Networks\", Work in\n                  Progress, October
      2011.\n   [RFC4017]      Stanley, D., Walker, J., and B. Aboba, \"Extensible\n
      \                 Authentication Protocol (EAP) Method Requirements for\n                  Wireless
      LANs\", RFC 4017, March 2005.\n   [RFC5056]      Williams, N., \"On the Use
      of Channel Bindings to\n                  Secure Channels\", RFC 5056, November
      2007.\n   [RFC5191]      Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H.,
      and\n                  A. Yegin, \"Protocol for Carrying Authentication for\n
      \                 Network Access (PANA)\", RFC 5191, May 2008.\n   [RFC5296]
      \     Narayanan, V. and L. Dondeti, \"EAP Extensions for EAP\n                  Re-authentication
      Protocol (ERP)\", RFC 5296,\n                  August 2008.\n   [RFC5873]      Ohba,
      Y. and A. Yegin, \"Pre-Authentication Support for\n                  the Protocol
      for Carrying Authentication for Network\n                  Access (PANA)\",
      RFC 5873, May 2010.\n"
    title: 13.2.  Informative References
  title: 13.  References
- contents:
  - "Appendix A.  Attacks Prevented by Channel Bindings\n   In the following appendix,
    it is demonstrated how the presented\n   channel bindings can prevent attacks
    by malicious authenticators\n   (representing the \"lying NAS\" problem) as well
    as malicious visited\n   networks (representing the \"lying provider\" problem).
    \ This document\n   only provides part of the solution necessary to realize a
    defense\n   against these attacks.  In addition, lower-layer protocols need to\n
    \  describe what attributes should be included in channel-binding\n   requests.
    \ EAP methods need to be updated in order to describe how\n   the channel-binding
    request and response are carried.  In addition,\n   deployments may need to decide
    what information is populated in the\n   local database.  The following sections
    describe types of attacks\n   that can be prevented by this framework with appropriate
    lower-layer\n   attributes carried in channel bindings, EAP methods with channel-\n
    \  binding support, and appropriate local database information at the\n   EAP
    server.\n"
  - contents:
    - "A.1.  Enterprise Subnetwork Masquerading\n   As outlined in Section 3, an enterprise
      network may have multiple\n   VLANs providing different levels of security.
      \ In an attack, a\n   malicious NAS connecting to a guest network with lesser
      security\n   protection could broadcast the SSID of a subnetwork with higher\n
      \  protection.  This could lead peers to believe that they are accessing\n   the
      network over secure connections and, e.g., transmit confidential\n   information
      that they normally would not send over a weakly protected\n   connection.  This
      attack works under the conditions that peers use\n   the same set of credentials
      to authenticate to the different kinds of\n   VLANs and that the VLANs support
      at least one common EAP method.  If\n   these conditions are not met, the EAP
      server would not authorize the\n   peers to connect to the guest network, because
      the peers used\n   credentials and/or an EAP method that is associated with
      the\n   corporate network.\n"
    title: A.1.  Enterprise Subnetwork Masquerading
  - contents:
    - "A.2.  Forced Roaming\n   Mobile phone providers boosting their cell towers'
      transmission power\n   to get more users to use their networks have occurred
      in the past.\n   The increased transmission range combined with a NAS sending
      a false\n   network identity lures users to connect to the network without being\n
      \  aware that they are roaming.\n   Channel bindings would detect the bogus
      network identifier because\n   the network identifier sent to the authentication
      server in i1 will\n   match neither information i2 nor the stored data.  The
      verification\n   fails because the info in i1 claims to come from the peer's
      home\n   network, while the home authentication server knows that the\n   connection
      is through a visited network outside the home domain.  In\n   the same context,
      channel bindings can be utilized to provide a \"home\n   zone\" feature that
      notifies users every time they are about to\n   connect to a NAS outside their
      home domain.\n"
    title: A.2.  Forced Roaming
  - contents:
    - "A.3.  Downgrading Attacks\n   A malicious authenticator could modify the set
      of offered EAP methods\n   in its beacon to force the peer to choose from only
      the weakest EAP\n   method(s) accepted by the authentication server.  For instance,\n
      \  instead of having a choice between the EAP MD5 Challenge Handshake\n   Authentication
      Protocol (EAP-MD5-CHAP), the Flexible Authentication\n   via Secure Tunneling
      EAP (EAP-FAST), and some other methods, the\n   authenticator reduces the choice
      for the peer to the weaker EAP-MD5-\n   CHAP method.  Assuming that weak EAP
      methods are supported by the\n   authentication server, such a downgrading attack
      can enable the\n   authenticator to attack the integrity and confidentiality
      of the\n   remaining EAP execution and/or break the authentication and key\n
      \  exchange.  The presented channel bindings prevent such downgrading\n   attacks,
      because peers submit the offered EAP method selection that\n   they have received
      in the beacon as part of i1 to the authentication\n   server.  As a result,
      the authentication server recognizes the\n   modification when comparing the
      information to the respective\n   information in its policy database.  This
      presumes that all\n   acceptable EAP methods support channel binding and that
      an attacker\n   cannot break the EAP method in real-time.\n"
    title: A.3.  Downgrading Attacks
  - contents:
    - "A.4.  Bogus Beacons in IEEE 802.11r\n   In IEEE 802.11r, the SSID is bound
      to the TSK calculations, so that\n   the TSK needs to be consistent with the
      SSID advertised in an\n   authenticator's beacon.  While this prevents outsiders
      from spoofing\n   a beacon, it does not stop a \"lying NAS\" from sending a
      bogus beacon\n   and calculating the TSK accordingly.\n   By implementing channel
      bindings, as described in this document, in\n   IEEE 802.11r, the verification
      by the authentication server would\n   detect the inconsistencies between the
      information the authenticator\n   has sent to the peer and the information the
      server received from the\n   authenticator and stores in the policy database.\n"
    title: A.4.  Bogus Beacons in IEEE 802.11r
  - contents:
    - "A.5.  Forcing False Authorization in IEEE 802.11i\n   In IEEE 802.11i, a malicious
      NAS can modify the beacon to make the\n   peer believe it is connected to a
      network different from the one the\n   peer is actually connected to.\n   In
      addition, a malicious NAS can force an authentication server into\n   authorizing
      access by sending an incorrect Called-Station-ID that\n   belongs to an authorized
      NAS in the network.  This could cause the\n   authentication server to believe
      it had granted access to a different\n   network or even provider than the one
      the peer got access to.\n   Both attacks can be prevented by implementing channel
      bindings,\n   because the server can compare the information sent to the peer,
      the\n   information it received from the authenticator during the AAA\n   communication,
      and the information stored in the policy database.\n"
    title: A.5.  Forcing False Authorization in IEEE 802.11i
  title: Appendix A.  Attacks Prevented by Channel Bindings
- contents:
  - "Authors' Addresses\n   Sam Hartman (editor)\n   Painless Security\n   356 Abbott
    St.\n   North Andover, MA  01845\n   USA\n   EMail: hartmans-ietf@mit.edu\n   T.
    Charles Clancy\n   Virginia Polytechnic Institute and State University\n   Electrical
    and Computer Engineering\n   900 North Glebe Road\n   Arlington, VA  22203\n   USA\n
    \  EMail: tcc@vt.edu\n   Katrin Hoeper\n   Motorola Solutions, Inc.\n   1301 E.
    Algonquin Road\n   Schaumburg, IL  60196\n   USA\n   EMail: khoeper@motorolasolutions.com\n"
  title: Authors' Addresses
