- title: __initial_text__
  contents:
  - '               XDR: External Data Representation Standard

    '
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This RFC describes a standard that Sun Microsystems,\
    \ Inc., and others\n   are using, one we wish to propose for the Internet's consideration.\n\
    \   Distribution of this memo is unlimited.\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   XDR is a standard for the description and encoding of data.\
    \  It is\n   useful for transferring data between different computer\n   architectures,\
    \ and has been used to communicate data between such\n   diverse machines as the\
    \ SUN WORKSTATION*, VAX*, IBM-PC*, and Cray*.\n   XDR fits into the ISO presentation\
    \ layer, and is roughly analogous in\n   purpose to X.409, ISO Abstract Syntax\
    \ Notation.  The major difference\n   between these two is that XDR uses implicit\
    \ typing, while X.409 uses\n   explicit typing.\n   XDR uses a language to describe\
    \ data formats.  The language can only\n   be used only to describe data; it is\
    \ not a programming language.\n   This language allows one to describe intricate\
    \ data formats in a\n   concise manner. The alternative of using graphical representations\n\
    \   (itself an informal language) quickly becomes incomprehensible when\n   faced\
    \ with complexity.  The XDR language itself is similar to the C\n   language [1],\
    \ just as Courier [4] is similar to Mesa. Protocols such\n   as Sun RPC (Remote\
    \ Procedure Call) and the NFS* (Network File System)\n   use XDR to describe the\
    \ format of their data.\n   The XDR standard makes the following assumption: that\
    \ bytes (or\n   octets) are portable, where a byte is defined to be 8 bits of\
    \ data.\n   A given hardware device should encode the bytes onto the various\n\
    \   media in such a way that other hardware devices may decode the bytes\n   without\
    \ loss of meaning.  For example, the Ethernet* standard\n   suggests that bytes\
    \ be encoded in \"little-endian\" style [2], or least\n   significant bit first.\n"
- title: 2. BASIC BLOCK SIZE
  contents:
  - "2. BASIC BLOCK SIZE\n   The representation of all items requires a multiple of\
    \ four bytes (or\n   32 bits) of data.  The bytes are numbered 0 through n-1.\
    \  The bytes\n   are read or written to some byte stream such that byte m always\n\
    \   precedes byte m+1.  If the n bytes needed to contain the data are not\n  \
    \ a multiple of four, then the n bytes are followed by enough (0 to 3)\n   residual\
    \ zero bytes, r, to make the total byte count a multiple of 4.\n   We include\
    \ the familiar graphic box notation for illustration and\n   comparison.  In most\
    \ illustrations, each box (delimited by a plus\n   sign at the 4 corners and vertical\
    \ bars and dashes) depicts a byte.\n   Ellipses (...) between boxes show zero\
    \ or more additional bytes where\n   required.\n        +--------+--------+...+--------+--------+...+--------+\n\
    \        | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |   BLOCK\n    \
    \    +--------+--------+...+--------+--------+...+--------+\n        |<-----------n\
    \ bytes---------->|<------r bytes------>|\n        |<-----------n+r (where (n+r)\
    \ mod 4 = 0)>----------->|\n"
- title: 3. XDR DATA TYPES
  contents:
  - "3. XDR DATA TYPES\n   Each of the sections that follow describes a data type\
    \ defined in the\n   XDR standard, shows how it is declared in the language, and\
    \ includes\n   a graphic illustration of its encoding.\n   For each data type\
    \ in the language we show a general paradigm\n   declaration.  Note that angle\
    \ brackets (< and >) denote\n   variablelength sequences of data and square brackets\
    \ ([ and ]) denote\n   fixed-length sequences of data.  \"n\", \"m\" and \"r\"\
    \ denote integers.\n   For the full language specification and more formal definitions\
    \ of\n   terms such as \"identifier\" and \"declaration\", refer to section 5:\n\
    \   \"The XDR Language Specification\".\n   For some data types, more specific\
    \ examples are included.  A more\n   extensive example of a data description is\
    \ in section 6:  \"An Example\n   of an XDR Data Description\".\n"
- title: 3.1 Integer
  contents:
  - "3.1 Integer\n   An XDR signed integer is a 32-bit datum that encodes an integer\
    \ in\n   the range [-2147483648,2147483647].  The integer is represented in\n\
    \   two's complement notation.  The most and least significant bytes are\n   0\
    \ and 3, respectively.  Integers are declared as follows:\n         int identifier;\n\
    \           (MSB)                   (LSB)\n         +-------+-------+-------+-------+\n\
    \         |byte 0 |byte 1 |byte 2 |byte 3 |                      INTEGER\n   \
    \      +-------+-------+-------+-------+\n         <------------32 bits------------>\n"
- title: 3.2.Unsigned Integer
  contents:
  - "3.2.Unsigned Integer\n   An XDR unsigned integer is a 32-bit datum that encodes\
    \ a nonnegative\n   integer in the range [0,4294967295].  It is represented by\
    \ an\n   unsigned binary number whose most and least significant bytes are 0\n\
    \   and 3, respectively.  An unsigned integer is declared as follows:\n      \
    \   unsigned int identifier;\n           (MSB)                   (LSB)\n     \
    \    +-------+-------+-------+-------+\n         |byte 0 |byte 1 |byte 2 |byte\
    \ 3 |             UNSIGNED INTEGER\n         +-------+-------+-------+-------+\n\
    \         <------------32 bits------------>\n"
- title: 3.3 Enumeration
  contents:
  - "3.3 Enumeration\n   Enumerations have the same representation as signed integers.\n\
    \   Enumerations are handy for describing subsets of the integers.\n   Enumerated\
    \ data is declared as follows:\n         enum { name-identifier = constant, ...\
    \ } identifier;\n   For example, the three colors red, yellow, and blue could\
    \ be\n   described by an enumerated type:\n         enum { RED = 2, YELLOW = 3,\
    \ BLUE = 5 } colors;\n   It is an error to encode as an enum any other integer\
    \ than those that\n   have been given assignments in the enum declaration.\n"
- title: 3.4 Boolean
  contents:
  - "3.4 Boolean\n   Booleans are important enough and occur frequently enough to\
    \ warrant\n   their own explicit type in the standard.  Booleans are declared\
    \ as\n   follows:\n      bool identifier;\n      This is equivalent to:\n    \
    \     enum { FALSE = 0, TRUE = 1 } identifier;\n"
- title: 3.5 Hyper Integer and Unsigned Hyper Integer
  contents:
  - "3.5 Hyper Integer and Unsigned Hyper Integer\n   The standard also defines 64-bit\
    \ (8-byte) numbers called hyper\n   integer and unsigned hyper integer.  Their\
    \ representations are the\n   obvious extensions of integer and unsigned integer\
    \ defined above.\n   They are represented in two's complement notation.  The most\
    \ and\n   least significant bytes are 0 and 7, respectively.  Their\n   declarations:\n\
    \   hyper identifier; unsigned hyper identifier;\n        (MSB)              \
    \                                     (LSB)\n      +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \      |byte 0 |byte 1 |byte 2 |byte 3 |byte 4 |byte 5 |byte 6 |byte 7 |\n   \
    \   +-------+-------+-------+-------+-------+-------+-------+-------+\n      <----------------------------64\
    \ bits---------------------------->\n                                        \
    \         HYPER INTEGER\n                                                 UNSIGNED\
    \ HYPER INTEGER\n"
- title: 3.6 Floating-point
  contents:
  - "3.6 Floating-point\n   The standard defines the floating-point data type \"float\"\
    \ (32 bits or\n   4 bytes).  The encoding used is the IEEE standard for normalized\n\
    \   single-precision floating-point numbers [3].  The following three\n   fields\
    \ describe the single-precision floating-point number:\n      S: The sign of the\
    \ number.  Values 0 and 1 represent positive and\n         negative, respectively.\
    \  One bit.\n      E: The exponent of the number, base 2.  8 bits are devoted\
    \ to this\n         field.  The exponent is biased by 127.\n      F: The fractional\
    \ part of the number's mantissa, base 2.  23 bits\n         are devoted to this\
    \ field.\n   Therefore, the floating-point number is described by:\n         (-1)**S\
    \ * 2**(E-Bias) * 1.F\n   It is declared as follows:\n         float identifier;\n\
    \         +-------+-------+-------+-------+\n         |byte 0 |byte 1 |byte 2\
    \ |byte 3 |              SINGLE-PRECISION\n         S|   E   |           F   \
    \       |         FLOATING-POINT NUMBER\n         +-------+-------+-------+-------+\n\
    \         1|<- 8 ->|<-------23 bits------>|\n         <------------32 bits------------>\n\
    \   Just as the most and least significant bytes of a number are 0 and 3,\n  \
    \ the most and least significant bits of a single-precision floating-\n   point\
    \ number are 0 and 31.  The beginning bit (and most significant\n   bit) offsets\
    \ of S, E, and F are 0, 1, and 9, respectively.  Note that\n   these numbers refer\
    \ to the mathematical positions of the bits, and\n   NOT to their actual physical\
    \ locations (which vary from medium to\n   medium).\n   The EEE specifications\
    \ should be consulted concerning the encoding\n   for signed zero, signed infinity\
    \ (overflow), and denormalized numbers\n   (underflow) [3].  According to IEEE\
    \ specifications, the \"NaN\" (not a\n   number) is system dependent and should\
    \ not be used externally.\n"
- title: 3.7 Double-precision Floating-point
  contents:
  - "3.7 Double-precision Floating-point\n   The standard defines the encoding for\
    \ the double-precision floating-\n   point data type \"double\" (64 bits or 8\
    \ bytes).  The encoding used is\n   the IEEE standard for normalized double-precision\
    \ floating-point\n   numbers [3].  The standard encodes the following three fields,\
    \ which\n   describe the double-precision floating-point number:\n      S: The\
    \ sign of the number.  Values 0 and 1 represent positive and\n         negative,\
    \ respectively.  One bit.\n      E: The exponent of the number, base 2.  11 bits\
    \ are devoted to\n         this field.  The exponent is biased by 1023.\n    \
    \  F: The fractional part of the number's mantissa, base 2.  52 bits\n       \
    \  are devoted to this field.\n   Therefore, the floating-point number is described\
    \ by:\n         (-1)**S * 2**(E-Bias) * 1.F\n   It is declared as follows:\n \
    \        double identifier;\n         +------+------+------+------+------+------+------+------+\n\
    \         |byte 0|byte 1|byte 2|byte 3|byte 4|byte 5|byte 6|byte 7|\n        \
    \ S|    E   |                    F                        |\n         +------+------+------+------+------+------+------+------+\n\
    \         1|<--11-->|<-----------------52 bits------------------->|\n        \
    \ <-----------------------64 bits------------------------->\n                \
    \                        DOUBLE-PRECISION FLOATING-POINT\n   Just as the most\
    \ and least significant bytes of a number are 0 and 3,\n   the most and least\
    \ significant bits of a double-precision floating-\n   point number are 0 and\
    \ 63.  The beginning bit (and most significant\n   bit) offsets of S, E , and\
    \ F are 0, 1, and 12, respectively.  Note\n   that these numbers refer to the\
    \ mathematical positions of the bits,\n   and NOT to their actual physical locations\
    \ (which vary from medium to\n   medium).\n   The IEEE specifications should be\
    \ consulted concerning the encoding\n   for signed zero, signed infinity (overflow),\
    \ and denormalized numbers\n   (underflow) [3].  According to IEEE specifications,\
    \ the \"NaN\" (not a\n   number) is system dependent and should not be used externally.\n"
- title: 3.8 Fixed-length Opaque Data
  contents:
  - "3.8 Fixed-length Opaque Data\n   At times, fixed-length uninterpreted data needs\
    \ to be passed among\n   machines.  This data is called \"opaque\" and is declared\
    \ as follows:\n         opaque identifier[n];\n   where the constant n is the\
    \ (static) number of bytes necessary to\n   contain the opaque data.  If n is\
    \ not a multiple of four, then the n\n   bytes are followed by enough (0 to 3)\
    \ residual zero bytes, r, to make\n   the total byte count of the opaque object\
    \ a multiple of four.\n          0        1     ...\n      +--------+--------+...+--------+--------+...+--------+\n\
    \      | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |\n      +--------+--------+...+--------+--------+...+--------+\n\
    \      |<-----------n bytes---------->|<------r bytes------>|\n      |<-----------n+r\
    \ (where (n+r) mod 4 = 0)------------>|\n                                    \
    \               FIXED-LENGTH OPAQUE\n"
- title: 3.9 Variable-length Opaque Data
  contents:
  - "3.9 Variable-length Opaque Data\n   The standard also provides for variable-length\
    \ (counted) opaque data,\n   defined as a sequence of n (numbered 0 through n-1)\
    \ arbitrary bytes\n   to be the number n encoded as an unsigned integer (as described\n\
    \   below), and followed by the n bytes of the sequence.\n   Byte m of the sequence\
    \ always precedes byte m+1 of the sequence, and\n   byte 0 of the sequence always\
    \ follows the sequence's length (count).\n   If n is not a multiple of four, then\
    \ the n bytes are followed by\n   enough (0 to 3) residual zero bytes, r, to make\
    \ the total byte count\n   a multiple of four.  Variable-length opaque data is\
    \ declared in the\n   following way:\n         opaque identifier<m>;\n      or\n\
    \         opaque identifier<>;\n   The constant m denotes an upper bound of the\
    \ number of bytes that the\n   sequence may contain.  If m is not specified, as\
    \ in the second\n   declaration, it is assumed to be (2**32) - 1, the maximum\
    \ length.\n   The constant m would normally be found in a protocol specification.\n\
    \   For example, a filing protocol may state that the maximum data\n   transfer\
    \ size is 8192 bytes, as follows:\n         opaque filedata<8192>;\n         \
    \   0     1     2     3     4     5   ...\n         +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n\
    \         |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |\n  \
    \       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n    \
    \     |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|\n      \
    \                           |<----n+r (where (n+r) mod 4 = 0)---->|\n        \
    \                                          VARIABLE-LENGTH OPAQUE\n   It is an\
    \ error to encode a length greater than the maximum described\n   in the specification.\n"
- title: 3.10 String
  contents:
  - "3.10 String\n   The standard defines a string of n (numbered 0 through n-1) ASCII\n\
    \   bytes to be the number n encoded as an unsigned integer (as described\n  \
    \ above), and followed by the n bytes of the string.  Byte m of the\n   string\
    \ always precedes byte m+1 of the string, and byte 0 of the\n   string always\
    \ follows the string's length.  If n is not a multiple of\n   four, then the n\
    \ bytes are followed by enough (0 to 3) residual zero\n   bytes, r, to make the\
    \ total byte count a multiple of four.  Counted\n   byte strings are declared\
    \ as follows:\n         string object<m>;\n      or\n         string object<>;\n\
    \   The constant m denotes an upper bound of the number of bytes that a\n   string\
    \ may contain.  If m is not specified, as in the second\n   declaration, it is\
    \ assumed to be (2**32) - 1, the maximum length.\n   The constant m would normally\
    \ be found in a protocol specification.\n   For example, a filing protocol may\
    \ state that a file name can be no\n   longer than 255 bytes, as follows:\n  \
    \       string filename<255>;\n            0     1     2     3     4     5   ...\n\
    \         +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n  \
    \       |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |\n    \
    \     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+\n      \
    \   |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|\n        \
    \                         |<----n+r (where (n+r) mod 4 = 0)---->|\n          \
    \                                                        STRING\n   It is an error\
    \ to encode a length greater than the maximum described\n   in the specification.\n"
- title: 3.11 Fixed-length Array
  contents:
  - "3.11 Fixed-length Array\n   Declarations for fixed-length arrays of homogeneous\
    \ elements are in\n   the following form:\n         type-name identifier[n];\n\
    \   Fixed-length arrays of elements numbered 0 through n-1 are encoded by\n  \
    \ individually encoding the elements of the array in their natural\n   order,\
    \ 0 through n-1.  Each element's size is a multiple of four\n   bytes. Though\
    \ all elements are of the same type, the elements may\n   have different sizes.\
    \  For example, in a fixed-length array of\n   strings, all elements are of type\
    \ \"string\", yet each element will\n   vary in its length.\n         +---+---+---+---+---+---+---+---+...+---+---+---+---+\n\
    \         |   element 0   |   element 1   |...|  element n-1  |\n         +---+---+---+---+---+---+---+---+...+---+---+---+---+\n\
    \         |<--------------------n elements------------------->|\n            \
    \                                   FIXED-LENGTH ARRAY\n"
- title: 3.12 Variable-length Array
  contents:
  - "3.12 Variable-length Array\n   Counted arrays provide the ability to encode variable-length\
    \ arrays\n   of homogeneous elements.  The array is encoded as the element count\
    \ n\n   (an unsigned integer) followed by the encoding of each of the array's\n\
    \   elements, starting with element 0 and progressing through element n-\n   1.\
    \  The declaration for variable-length arrays follows this form:\n         type-name\
    \ identifier<m>;\n      or\n         type-name identifier<>;\n   The constant\
    \ m specifies the maximum acceptable element count of an\n   array; if m is not\
    \ specified, as in the second declaration, it is\n   assumed to be (2**32) - 1.\n\
    \           0  1  2  3\n         +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+\n\
    \         |     n     | element 0 | element 1 |...|element n-1|\n         +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+\n\
    \         |<-4 bytes->|<--------------n elements------------->|\n            \
    \                                             COUNTED ARRAY\n   It is an error\
    \ to encode a value of n that is greater than the\n   maximum described in the\
    \ specification.\n"
- title: 3.13 Structure
  contents:
  - "3.13 Structure\n   Structures are declared as follows:\n         struct {\n \
    \           component-declaration-A;\n            component-declaration-B;\n \
    \           ...\n         } identifier;\n   The components of the structure are\
    \ encoded in the order of their\n   declaration in the structure.  Each component's\
    \ size is a multiple of\n   four bytes, though the components may be different\
    \ sizes.\n         +-------------+-------------+...\n         | component A |\
    \ component B |...                      STRUCTURE\n         +-------------+-------------+...\n"
- title: 3.14 Discriminated Union
  contents:
  - "3.14 Discriminated Union\n   A discriminated union is a type composed of a discriminant\
    \ followed\n   by a type selected from a set of prearranged types according to\
    \ the\n   value of the discriminant.  The type of discriminant is either \"int\"\
    ,\n   \"unsigned int\", or an enumerated type, such as \"bool\".  The component\n\
    \   types are called \"arms\" of the union, and are preceded by the value\n  \
    \ of the discriminant which implies their encoding.  Discriminated\n   unions\
    \ are declared as follows:\n         union switch (discriminant-declaration) {\n\
    \         case discriminant-value-A:\n            arm-declaration-A;\n       \
    \  case discriminant-value-B:\n            arm-declaration-B;\n         ...\n\
    \         default: default-declaration;\n         } identifier;\n   Each \"case\"\
    \ keyword is followed by a legal value of the discriminant.\n   The default arm\
    \ is optional.  If it is not specified, then a valid\n   encoding of the union\
    \ cannot take on unspecified discriminant values.\n   The size of the implied\
    \ arm is always a multiple of four bytes.\n   The discriminated union is encoded\
    \ as its discriminant followed by\n   the encoding of the implied arm.\n     \
    \      0   1   2   3\n         +---+---+---+---+---+---+---+---+\n         | \
    \ discriminant |  implied arm  |          DISCRIMINATED UNION\n         +---+---+---+---+---+---+---+---+\n\
    \         |<---4 bytes--->|\n"
- title: 3.15 Void
  contents:
  - "3.15 Void\n   An XDR void is a 0-byte quantity.  Voids are useful for describing\n\
    \   operations that take no data as input or no data as output. They are\n   also\
    \ useful in unions, where some arms may contain data and others do\n   not.  The\
    \ declaration is simply as follows:\n         void;\n   Voids are illustrated\
    \ as follows:\n           ++\n           ||                                  \
    \                   VOID\n           ++\n         --><-- 0 bytes\n"
- title: 3.16 Constant
  contents:
  - "3.16 Constant\n   The data declaration for a constant follows this form:\n  \
    \       const name-identifier = n;\n   \"const\" is used to define a symbolic\
    \ name for a constant; it does not\n   declare any data.  The symbolic constant\
    \ may be used anywhere a\n   regular constant may be used.  For example, the following\
    \ defines a\n   symbolic constant DOZEN, equal to 12.\n         const DOZEN =\
    \ 12;\n"
- title: 3.17 Typedef
  contents:
  - "3.17 Typedef\n   \"typedef\" does not declare any data either, but serves to\
    \ define new\n   identifiers for declaring data. The syntax is:\n         typedef\
    \ declaration;\n   The new type name is actually the variable name in the declaration\n\
    \   part of the typedef.  For example, the following defines a new type\n   called\
    \ \"eggbox\" using an existing type called \"egg\":\n         typedef egg eggbox[DOZEN];\n\
    \   Variables declared using the new type name have the same type as the\n   new\
    \ type name would have in the typedef, if it was considered a\n   variable.  For\
    \ example, the following two declarations are equivalent\n   in declaring the\
    \ variable \"fresheggs\":\n         eggbox  fresheggs;\n         egg     fresheggs[DOZEN];\n\
    \   When a typedef involves a struct, enum, or union definition, there is\n  \
    \ another (preferred) syntax that may be used to define the same type.\n   In\
    \ general, a typedef of the following form:\n         typedef <<struct, union,\
    \ or enum definition>> identifier;\n   may be converted to the alternative form\
    \ by removing the \"typedef\"\n   part and placing the identifier after the \"\
    struct\", \"union\", or\n   \"enum\" keyword, instead of at the end.  For example,\
    \ here are the two\n   ways to define the type \"bool\":\n         typedef enum\
    \ {    /* using typedef */\n            FALSE = 0,\n            TRUE = 1\n   \
    \      } bool;\n         enum bool {       /* preferred alternative */\n     \
    \       FALSE = 0,\n            TRUE = 1\n         };\n   The reason this syntax\
    \ is preferred is one does not have to wait\n   until the end of a declaration\
    \ to figure out the name of the new\n   type.\n"
- title: 3.18 Optional-data
  contents:
  - "3.18 Optional-data\n   Optional-data is one kind of union that occurs so frequently\
    \ that we\n   give it a special syntax of its own for declaring it.  It is declared\n\
    \   as follows:\n         type-name *identifier;\n   This is equivalent to the\
    \ following union:\n         union switch (bool opted) {\n         case TRUE:\n\
    \            type-name element;\n         case FALSE:\n            void;\n   \
    \      } identifier;\n   It is also equivalent to the following variable-length\
    \ array\n   declaration, since the boolean \"opted\" can be interpreted as the\n\
    \   length of the array:\n         type-name identifier<1>;\n   Optional-data\
    \ is not so interesting in itself, but it is very useful\n   for describing recursive\
    \ data-structures such as linked-lists and\n   trees.  For example, the following\
    \ defines a type \"stringlist\" that\n   encodes lists of arbitrary length strings:\n\
    \         struct *stringlist {\n            string item<>;\n            stringlist\
    \ next;\n         };\n   It could have been equivalently declared as the following\
    \ union:\n         union stringlist switch (bool opted) {\n         case TRUE:\n\
    \            struct {\n               string item<>;\n               stringlist\
    \ next;\n            } element;\n         case FALSE:\n            void;\n   \
    \      };\n      or as a variable-length array:\n         struct stringlist<1>\
    \ {\n            string item<>;\n            stringlist next;\n         };\n \
    \  Both of these declarations obscure the intention of the stringlist\n   type,\
    \ so the optional-data declaration is preferred over both of\n   them.  The optional-data\
    \ type also has a close correlation to how\n   recursive data structures are represented\
    \ in high-level languages\n   such as Pascal or C by use of pointers. In fact,\
    \ the syntax is the\n   same as that of the C language for pointers.\n"
- title: 3.19 Areas for Future Enhancement
  contents:
  - "3.19 Areas for Future Enhancement\n   The XDR standard lacks representations\
    \ for bit fields and bitmaps,\n   since the standard is based on bytes.  Also\
    \ missing are packed (or\n   binary-coded) decimals.\n   The intent of the XDR\
    \ standard was not to describe every kind of data\n   that people have ever sent\
    \ or will ever want to send from machine to\n   machine. Rather, it only describes\
    \ the most commonly used data-types\n   of high-level languages such as Pascal\
    \ or C so that applications\n   written in these languages will be able to communicate\
    \ easily over\n   some medium.\n   One could imagine extensions to XDR that would\
    \ let it describe almost\n   any existing protocol, such as TCP.  The minimum\
    \ necessary for this\n   are support for different block sizes and byte-orders.\
    \  The XDR\n   discussed here could then be considered the 4-byte big-endian member\n\
    \   of a larger XDR family.\n"
- title: 4. DISCUSSION
  contents:
  - "4. DISCUSSION\n   (1) Why use a language for describing data?  What's wrong with\n\
    \   diagrams?\n   There are many advantages in using a data-description language\
    \ such\n   as  XDR  versus using  diagrams.   Languages are  more  formal than\n\
    \   diagrams   and   lead  to less  ambiguous   descriptions  of  data.\n   Languages\
    \ are also easier  to understand and allow  one to think of\n   other   issues\
    \ instead of  the   low-level details of bit-encoding.\n   Also,  there is  a\
    \ close analogy  between the  types  of XDR and  a\n   high-level language   such\
    \  as C   or    Pascal.   This makes   the\n   implementation of XDR encoding\
    \ and decoding modules an easier task.\n   Finally, the language specification\
    \ itself  is an ASCII string that\n   can be passed from  machine to machine \
    \ to perform  on-the-fly data\n   interpretation.\n   (2) Why is there only one\
    \ byte-order for an XDR unit?\n   Supporting two byte-orderings requires a higher\
    \ level protocol for\n   determining in which byte-order the data is encoded.\
    \  Since XDR is\n   not a protocol, this can't be done.  The advantage of this,\
    \ though,\n   is that data in XDR format can be written to a magnetic tape, for\n\
    \   example, and any machine will be able to interpret it, since no\n   higher\
    \ level protocol is necessary for determining the byte-order.\n   (3) Why is the\
    \ XDR byte-order big-endian instead of little-endian?\n   Isn't this unfair to\
    \ little-endian machines such as the VAX(r), which\n   has to convert from one\
    \ form to the other?\n   Yes, it is unfair, but having only one byte-order means\
    \ you have to\n   be unfair to somebody.  Many architectures, such as the Motorola\n\
    \   68000* and IBM 370*, support the big-endian byte-order.\n   (4) Why is the\
    \ XDR unit four bytes wide?\n   There is a tradeoff in choosing the XDR unit size.\
    \  Choosing a small\n   size such as two makes the encoded data small, but causes\
    \ alignment\n   problems for machines that aren't aligned on these boundaries.\
    \  A\n   large size such as eight means the data will be aligned on virtually\n\
    \   every machine, but causes the encoded data to grow too big.  We chose\n  \
    \ four as a compromise.  Four is big enough to support most\n   architectures\
    \ efficiently, except for rare machines such as the\n   eight-byte aligned Cray*.\
    \  Four is also small enough to keep the\n   encoded data restricted to a reasonable\
    \ size.\n   (5) Why must variable-length data be padded with zeros?\n   It is\
    \ desirable that the same data encode into the same thing on all\n   machines,\
    \ so that encoded data can be meaningfully compared or\n   checksummed.  Forcing\
    \ the padded bytes to be zero ensures this.\n   (6) Why is there no explicit data-typing?\n\
    \   Data-typing has a relatively high cost for what small advantages it\n   may\
    \ have.  One cost is the expansion of data due to the inserted type\n   fields.\
    \  Another is the added cost of interpreting these type fields\n   and acting\
    \ accordingly.  And most protocols already know what type\n   they expect, so\
    \ data-typing supplies only redundant information.\n   However, one can still\
    \ get the benefits of data-typing using XDR. One\n   way is to encode two things:\
    \ first a string which is the XDR data\n   description of the encoded data, and\
    \ then the encoded data itself.\n   Another way is to assign a value to all the\
    \ types in XDR, and then\n   define a universal type which takes this value as\
    \ its discriminant\n   and for each value, describes the corresponding data type.\n"
- title: 5. THE XDR LANGUAGE SPECIFICATION
  contents:
  - "5. THE XDR LANGUAGE SPECIFICATION\n   5.1 Notational Conventions\n   This specification\
    \ uses an extended Back-Naur Form notation for\n   describing the XDR language.\
    \  Here is a brief description of the\n   notation:\n   (1) The characters '|',\
    \ '(', ')', '[', ']', '\"', and '*' are special.\n   (2) Terminal symbols are\
    \ strings of any characters surrounded by\n   double quotes.\n   (3) Non-terminal\
    \ symbols are strings of non-special characters.\n   (4) Alternative items are\
    \ separated by a vertical bar (\"|\").\n   (5) Optional items are enclosed in\
    \ brackets.\n   (6) Items are grouped together by enclosing them in parentheses.\n\
    \   (7) A '*' following an item means 0 or more occurrences of that item.\n  \
    \ For example,  consider  the  following pattern:\n         \"a \" \"very\" (\"\
    , \" \"very\")* [\" cold \" \"and \"]  \" rainy \"\n         (\"day\" | \"night\"\
    )\n   An infinite number of strings match this pattern. A few of them are:\n \
    \        \"a very rainy day\"\n         \"a very, very rainy day\"\n         \"\
    a very cold and  rainy day\"\n         \"a very, very, very cold and  rainy night\"\
    \n"
- title: 5.2 Lexical Notes
  contents:
  - "5.2 Lexical Notes\n   (1) Comments begin with '/*' and terminate with '*/'.\n\
    \   (2) White space serves to separate items and is otherwise ignored.\n   (3)\
    \ An identifier is a letter followed by an optional sequence of\n   letters, digits\
    \ or underbar ('_'). The case of identifiers is not\n   ignored.\n   (4) A constant\
    \ is a sequence of one or more decimal digits,\n   optionally preceded by a minus-sign\
    \ ('-').\n"
- title: 5.3 Syntax Information
  contents:
  - "5.3 Syntax Information\n      declaration:\n           type-specifier identifier\n\
    \         | type-specifier identifier \"[\" value \"]\"\n         | type-specifier\
    \ identifier \"<\" [ value ] \">\"\n         | \"opaque\" identifier \"[\" value\
    \ \"]\"\n         | \"opaque\" identifier \"<\" [ value ] \">\"\n         | \"\
    string\" identifier \"<\" [ value ] \">\"\n         | type-specifier \"*\" identifier\n\
    \         | \"void\"\n      value:\n           constant\n         | identifier\n\
    \      type-specifier:\n           [ \"unsigned\" ] \"int\"\n         | [ \"unsigned\"\
    \ ] \"hyper\"\n         | \"float\"\n         | \"double\"\n         | \"bool\"\
    \n         | enum-type-spec\n         | struct-type-spec\n         | union-type-spec\n\
    \         | identifier\n      enum-type-spec:\n         \"enum\" enum-body\n \
    \     enum-body:\n         \"{\"\n            ( identifier \"=\" value )\n   \
    \         ( \",\" identifier \"=\" value )*\n         \"}\"\n      struct-type-spec:\n\
    \         \"struct\" struct-body\n      struct-body:\n         \"{\"\n       \
    \     ( declaration \";\" )\n            ( declaration \";\" )*\n         \"}\"\
    \n      union-type-spec:\n         \"union\" union-body\n      union-body:\n \
    \        \"switch\" \"(\" declaration \")\" \"{\"\n            ( \"case\" value\
    \ \":\" declaration \";\" )\n            ( \"case\" value \":\" declaration \"\
    ;\" )*\n            [ \"default\" \":\" declaration \";\" ]\n         \"}\"\n\
    \      constant-def:\n         \"const\" identifier \"=\" constant \";\"\n   \
    \   type-def:\n           \"typedef\" declaration \";\"\n         | \"enum\" identifier\
    \ enum-body \";\"\n         | \"struct\" identifier struct-body \";\"\n      \
    \   | \"union\" identifier union-body \";\"\n      definition:\n           type-def\n\
    \         | constant-def\n      specification:\n           definition *\n"
- title: 5.4 Syntax Notes
  contents:
  - "5.4 Syntax Notes\n   (1) The following are keywords and cannot be used as identifiers:\n\
    \   \"bool\", \"case\", \"const\", \"default\", \"double\", \"enum\", \"float\"\
    ,\n   \"hyper\", \"opaque\", \"string\", \"struct\", \"switch\", \"typedef\",\
    \ \"union\",\n   \"unsigned\" and \"void\".\n   (2) Only unsigned constants may\
    \ be used as size specifications for\n   arrays.  If an identifier is used, it\
    \ must have been declared\n   previously as an unsigned constant in a \"const\"\
    \ definition.\n   (3) Constant and type identifiers within the scope of a specification\n\
    \   are in the same name space and must be declared uniquely within this\n   scope.\n\
    \   (4) Similarly, variable names must  be unique within  the scope  of\n   struct\
    \ and union declarations. Nested struct and union declarations\n   create new\
    \ scopes.\n   (5) The discriminant of a union must be of a type that evaluates\
    \ to\n   an integer. That is, \"int\", \"unsigned int\", \"bool\", an enumerated\n\
    \   type or any typedefed type that evaluates to one of these is legal.\n   Also,\
    \ the case values must be one of the legal values of the\n   discriminant.  Finally,\
    \ a case value may not be specified more than\n   once within the scope of a union\
    \ declaration.\n"
- title: 6. AN EXAMPLE OF AN XDR DATA DESCRIPTION
  contents:
  - "6. AN EXAMPLE OF AN XDR DATA DESCRIPTION\n   Here is a short XDR data description\
    \ of a thing called a \"file\",\n   which might be used to transfer files from\
    \ one machine to another.\n         const MAXUSERNAME = 32;     /* max length\
    \ of a user name */\n         const MAXFILELEN = 65535;   /* max length of a file\
    \      */\n         const MAXNAMELEN = 255;     /* max length of a file name */\n\
    \         /*\n          * Types of files:\n          */\n         enum filekind\
    \ {\n            TEXT = 0,       /* ascii data */\n            DATA = 1,     \
    \  /* raw data   */\n            EXEC = 2        /* executable */\n         };\n\
    \         /*\n          * File information, per kind of file:\n          */\n\
    \         union filetype switch (filekind kind) {\n         case TEXT:\n     \
    \       void;                           /* no extra information */\n         case\
    \ DATA:\n            string creator<MAXNAMELEN>;     /* data creator         */\n\
    \         case EXEC:\n            string interpretor<MAXNAMELEN>; /* program interpretor\
    \  */\n         };\n         /*\n          * A complete file:\n          */\n\
    \         struct file {\n            string filename<MAXNAMELEN>; /* name of file\
    \    */\n            filetype type;               /* info about file */\n    \
    \        string owner<MAXUSERNAME>;   /* owner of file   */\n            opaque\
    \ data<MAXFILELEN>;     /* file data       */\n         };\n   Suppose now that\
    \ there is a user named \"john\" who wants to store his\n   lisp program \"sillyprog\"\
    \ that contains just the data \"(quit)\".  His\n   file would be encoded as follows:\n\
    \       OFFSET  HEX BYTES       ASCII    COMMENTS\n       ------  ---------  \
    \     -----    --------\n        0      00 00 00 09     ....     -- length of\
    \ filename = 9\n        4      73 69 6c 6c     sill     -- filename characters\n\
    \        8      79 70 72 6f     ypro     -- ... and more characters ...\n    \
    \   12      67 00 00 00     g...     -- ... and 3 zero-bytes of fill\n       16\
    \      00 00 00 02     ....     -- filekind is EXEC = 2\n       20      00 00\
    \ 00 04     ....     -- length of interpretor = 4\n       24      6c 69 73 70\
    \     lisp     -- interpretor characters\n       28      00 00 00 04     ....\
    \     -- length of owner = 4\n       32      6a 6f 68 6e     john     -- owner\
    \ characters\n       36      00 00 00 06     ....     -- length of file data =\
    \ 6\n       40      28 71 75 69     (qui     -- file data bytes ...\n       44\
    \      74 29 00 00     t)..     -- ... and 2 zero-bytes of fill\n"
- title: 7. REFERENCES
  contents:
  - "7. REFERENCES\n   [1]  Brian W. Kernighan & Dennis M. Ritchie, \"The C Programming\n\
    \        Language\", Bell Laboratories, Murray Hill, New Jersey, 1978.\n   [2]\
    \  Danny Cohen, \"On Holy Wars and a Plea for Peace\", IEEE Computer,\n      \
    \  October 1981.\n   [3]  \"IEEE Standard for Binary Floating-Point Arithmetic\"\
    , ANSI/IEEE\n        Standard 754-1985, Institute of Electrical and Electronics\n\
    \        Engineers, August 1985.\n   [4]  \"Courier: The Remote Procedure Call\
    \ Protocol\", XEROX\n        Corporation, XSIS 038112, December 1981.\n"
- title: 8. TRADEMARKS AND OWNERS
  contents:
  - "8. TRADEMARKS AND OWNERS\n        SUN WORKSTATION  Sun Microsystems, Inc.\n \
    \       VAX              Digital Equipment Corporation\n        IBM-PC       \
    \    International Business Machines Corporation\n        Cray             Cray\
    \ Research\n        NFS              Sun Microsystems, Inc.\n        Ethernet\
    \         Xerox Corporation.\n        Motorola 68000   Motorola, Inc.\n      \
    \  IBM 370          International Business Machines Corporation\n"
