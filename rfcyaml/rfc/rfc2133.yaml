- title: __initial_text__
  contents:
  - '               Basic Socket Interface Extensions for IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The de facto standard application program interface (API) for TCP/IP\n\
    \   applications is the \"sockets\" interface.  Although this API was\n   developed\
    \ for Unix in the early 1980s it has also been implemented on\n   a wide variety\
    \ of non-Unix systems.  TCP/IP applications written\n   using the sockets API\
    \ have in the past enjoyed a high degree of\n   portability and we would like\
    \ the same portability with IPv6\n   applications.  But changes are required to\
    \ the sockets API to support\n   IPv6 and this memo describes these changes. \
    \ These include a new\n   socket address structure to carry IPv6 addresses, new\
    \ address\n   conversion functions, and some new socket options.  These extensions\n\
    \   are designed to provide access to the basic IPv6 features required by\n  \
    \ TCP and UDP applications, including multicasting, while introducing a\n   minimum\
    \ of change into the system and providing complete\n   compatibility for existing\
    \ IPv4 applications.  Additional extensions\n   for advanced IPv6 features (raw\
    \ sockets and access to the IPv6\n   extension headers) are defined in another\
    \ document [5].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction ................................................\
    \  2\n   2.  Design Considerations .......................................  3\n\
    \   2.1.  What Needs to be Changed ..................................  3\n   2.2.\
    \  Data Types ................................................  5\n   2.3.  Headers\
    \ ...................................................  5\n   2.4.  Structures\
    \ ................................................  5\n   3.  Socket Interface\
    \ ............................................  5\n   3.1.  IPv6 Address Family\
    \ and Protocol Family ...................  5\n   3.2.  IPv6 Address Structure\
    \ ....................................  6\n   3.3.  Socket Address Structure for\
    \ 4.3BSD-Based Systems .........  6\n   3.4.  Socket Address Structure for 4.4BSD-Based\
    \ Systems .........  7\n   3.5.  The Socket Functions ......................................\
    \  8\n   3.6.  Compatibility with IPv4 Applications ......................  9\n\
    \   3.7.  Compatibility with IPv4 Nodes .............................  9\n   3.8.\
    \  IPv6 Wildcard Address ..................................... 10\n   3.9.  IPv6\
    \ Loopback Address ..................................... 11\n   4.  Interface\
    \ Identification .................................... 12\n   4.1.  Name-to-Index\
    \ ............................................. 13\n   4.2.  Index-to-Name .............................................\
    \ 13\n   4.3.  Return All Interface Names and Indexes .................... 14\n\
    \   4.4.  Free Memory ............................................... 14\n   5.\
    \  Socket Options .............................................. 14\n   5.1. \
    \ Changing Socket Type ...................................... 15\n   5.2.  Unicast\
    \ Hop Limit ......................................... 16\n   5.3.  Sending and\
    \ Receiving Multicast Packets ................... 17\n   6.  Library Functions\
    \ ........................................... 19\n   6.1.  Hostname-to-Address\
    \ Translation ........................... 19\n   6.2.  Address To Hostname Translation\
    \ ........................... 22\n   6.3.  Protocol-Independent Hostname and Service\
    \ Name Translation  22\n   6.4.  Socket Address Structure to Hostname and Service\
    \ Name ..... 25\n   6.5.  Address Conversion Functions ..............................\
    \ 27\n   6.6.  Address Testing Macros .................................... 28\n\
    \   7.  Summary of New Definitions .................................. 29\n   8.\
    \  Security Considerations ..................................... 31\n   9.  Acknowledgments\
    \ ............................................. 31\n   10.  References .................................................\
    \ 31\n   11.  Authors' Addresses ......................................... 32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   While IPv4 addresses are 32 bits long, IPv6 interfaces are\
    \ identified\n   by 128-bit addresses.  The socket interface make the size of\
    \ an IP\n   address quite visible to an application; virtually all TCP/IP\n  \
    \ applications for BSD-based systems have knowledge of the size of an\n   IP address.\
    \  Those parts of the API that expose the addresses must be\n   changed to accommodate\
    \ the larger IPv6 address size.  IPv6 also\n   introduces new features (e.g.,\
    \ flow label and priority), some of\n   which must be made visible to applications\
    \ via the API.  This memo\n   defines a set of extensions to the socket interface\
    \ to support the\n   larger address size and new features of IPv6.\n"
- title: 2.  Design Considerations
  contents:
  - "2.  Design Considerations\n   There are a number of important considerations\
    \ in designing changes\n   to this well-worn API:\n   -  The API changes should\
    \ provide both source and binary\n       compatibility for programs written to\
    \ the original API.  That is,\n       existing program binaries should continue\
    \ to operate when run on\n       a system supporting the new API.  In addition,\
    \ existing\n       applications that are re-compiled and run on a system supporting\n\
    \       the new API should continue to operate.  Simply put, the API\n       changes\
    \ for IPv6 should not break existing programs.\n   -  The changes to the API should\
    \ be as small as possible in order to\n       simplify the task of converting\
    \ existing IPv4 applications to\n       IPv6.\n   -  Where possible, applications\
    \ should be able to use this API to\n       interoperate with both IPv6 and IPv4\
    \ hosts.  Applications should\n       not need to know which type of host they\
    \ are communicating with.\n   -  IPv6 addresses carried in data structures should\
    \ be 64-bit\n       aligned.  This is necessary in order to obtain optimum\n \
    \      performance on 64-bit machine architectures.\n   Because of the importance\
    \ of providing IPv4 compatibility in the API,\n   these extensions are explicitly\
    \ designed to operate on machines that\n   provide complete support for both IPv4\
    \ and IPv6.  A subset of this\n   API could probably be designed for operation\
    \ on systems that support\n   only IPv6.  However, this is not addressed in this\
    \ memo.\n"
- title: 2.1.  What Needs to be Changed
  contents:
  - "2.1.  What Needs to be Changed\n   The socket interface API consists of a few\
    \ distinct components:\n    -  Core socket functions.\n    -  Address data structures.\n\
    \    -  Name-to-address translation functions.\n    -  Address conversion functions.\n\
    \    The core socket functions -- those functions that deal with such\n    things\
    \ as setting up and tearing down TCP connections, and sending\n    and receiving\
    \ UDP packets -- were designed to be transport\n    independent.  Where protocol\
    \ addresses are passed as function\n    arguments, they are carried via opaque\
    \ pointers.  A protocol-specific\n    address data structure is defined for each\
    \ protocol that the socket\n    functions support.  Applications must cast pointers\
    \ to these\n    protocol-specific address structures into pointers to the generic\n\
    \    \"sockaddr\" address structure when using the socket functions.  These\n\
    \    functions need not change for IPv6, but a new IPv6-specific address\n   \
    \ data structure is needed.\n    The \"sockaddr_in\" structure is the protocol-specific\
    \ data structure\n    for IPv4.  This data structure actually includes 8-octets\
    \ of unused\n    space, and it is tempting to try to use this space to adapt the\n\
    \    sockaddr_in structure to IPv6.  Unfortunately, the sockaddr_in\n    structure\
    \ is not large enough to hold the 16-octet IPv6 address as\n    well as the other\
    \ information (address family and port number) that\n    is needed.  So a new\
    \ address data structure must be defined for IPv6.\n    The name-to-address translation\
    \ functions in the socket interface are\n    gethostbyname() and gethostbyaddr().\
    \  These must be modified to\n    support IPv6 and the semantics defined must\
    \ provide 100% backward\n    compatibility for all existing IPv4 applications,\
    \ along with IPv6\n    support for new applications.  Additionally, the POSIX\
    \ 1003.g work in\n    progress [4] specifies a new hostname-to-address translation\
    \ function\n    which is protocol independent.  This function can also be used\
    \ with\n    IPv6.\n    The address conversion functions -- inet_ntoa() and inet_addr()\
    \ --\n    convert IPv4 addresses between binary and printable form.  These\n \
    \   functions are quite specific to 32-bit IPv4 addresses.  We have\n    designed\
    \ two analogous functions that convert both IPv4 and IPv6\n    addresses, and\
    \ carry an address type parameter so that they can be\n    extended to other protocol\
    \ families as well.\n    Finally, a few miscellaneous features are needed to support\
    \ IPv6.\n    New interfaces are needed to support the IPv6 flow label, priority,\n\
    \    and hop limit header fields.  New socket options are needed to\n    control\
    \ the sending and receiving of IPv6 multicast packets.\n    The socket interface\
    \ will be enhanced in the future to provide access\n    to other IPv6 features.\
    \  These extensions are described in [5].\n"
- title: 2.2.  Data Types
  contents:
  - "2.2.  Data Types\n   The data types of the structure elements given in this memo\
    \ are\n   intended to be examples, not absolute requirements.  Whenever\n   possible,\
    \ POSIX 1003.1g data types are used:  u_intN_t means an\n   unsigned integer of\
    \ exactly N bits (e.g., u_int16_t) and u_intNm_t\n   means an unsigned integer\
    \ of at least N bits (e.g., u_int32m_t).  We\n   also assume the argument data\
    \ types from 1003.1g when possible (e.g.,\n    the final argument to setsockopt()\
    \ is a size_t value).  Whenever\n   buffer sizes are specified, the POSIX 1003.1\
    \ size_t data type is used\n   (e.g., the two length arguments to getnameinfo()).\n"
- title: 2.3.  Headers
  contents:
  - "2.3.  Headers\n   When function prototypes and structures are shown we show the\
    \ headers\n   that must be #included to cause that item to be defined.\n"
- title: 2.4.  Structures
  contents:
  - "2.4.  Structures\n   When structures are described the members shown are the\
    \ ones that\n   must appear in an implementation.  Additional, nonstandard members\n\
    \   may also be defined by an implementation.\n   The ordering shown for the members\
    \ of a structure is the recommended\n   ordering, given alignment considerations\
    \ of multibyte members, but an\n   implementation may order the members differently.\n"
- title: 3.  Socket Interface
  contents:
  - "3.  Socket Interface\n   This section specifies the socket interface changes\
    \ for IPv6.\n"
- title: 3.1.  IPv6 Address Family and Protocol Family
  contents:
  - "3.1.  IPv6 Address Family and Protocol Family\n   A new address family name,\
    \ AF_INET6, is defined in <sys/socket.h>.\n   The AF_INET6 definition distinguishes\
    \ between the original\n   sockaddr_in address data structure, and the new sockaddr_in6\
    \ data\n   structure.\n   A new protocol family name, PF_INET6, is defined in\
    \ <sys/socket.h>.\n   Like most of the other protocol family names, this will\
    \ usually be\n   defined to have the same value as the corresponding address family\n\
    \   name:\n       #define PF_INET6        AF_INET6\n   The PF_INET6 is used in\
    \ the first argument to the socket() function\n   to indicate that an IPv6 socket\
    \ is being created.\n"
- title: 3.2.  IPv6 Address Structure
  contents:
  - "3.2.  IPv6 Address Structure\n   A new data structure to hold a single IPv6 address\
    \ is defined as\n    follows:\n       #include <netinet/in.h>\n       struct in6_addr\
    \ {\n           u_int8_t  s6_addr[16];      /* IPv6 address */\n       }\n   This\
    \ data structure contains an array of sixteen 8-bit elements,\n   which make up\
    \ one 128-bit IPv6 address.  The IPv6 address is stored\n   in network byte order.\n"
- title: 3.3.  Socket Address Structure for 4.3BSD-Based Systems
  contents:
  - "3.3.  Socket Address Structure for 4.3BSD-Based Systems\n   In the socket interface,\
    \ a different protocol-specific data structure\n   is defined to carry the addresses\
    \ for each protocol suite.  Each\n   protocol-specific data structure is designed\
    \ so it can be cast into a\n   protocol-independent data structure -- the \"sockaddr\"\
    \ structure.\n   Each has a \"family\" field that overlays the \"sa_family\" of\
    \ the\n   sockaddr data structure.  This field identifies the type of the data\n\
    \   structure.\n   The sockaddr_in structure is the protocol-specific address\
    \ data\n   structure for IPv4.  It is used to pass addresses between\n   applications\
    \ and the system in the socket functions.  The following\n   structure is defined\
    \ to carry IPv6 addresses:\n       #include <netinet/in.h>\n       struct sockaddr_in6\
    \ {\n           u_int16m_t      sin6_family;    /* AF_INET6 */\n           u_int16m_t\
    \      sin6_port;      /* transport layer port # */\n           u_int32m_t   \
    \   sin6_flowinfo;  /* IPv6 flow information */\n           struct in6_addr sin6_addr;\
    \      /* IPv6 address */\n       };\n   This structure is designed to be compatible\
    \ with the sockaddr data\n   structure used in the 4.3BSD release.\n   The sin6_family\
    \ field identifies this as a sockaddr_in6 structure.\n   This field overlays the\
    \ sa_family field when the buffer is cast to a\n   sockaddr data structure.  The\
    \ value of this field must be AF_INET6.\n   The sin6_port field contains the 16-bit\
    \ UDP or TCP port number.  This\n   field is used in the same way as the sin_port\
    \ field of the\n   sockaddr_in structure.  The port number is stored in network\
    \ byte\n   order.\n   The sin6_flowinfo field is a 32-bit field that contains\
    \ two pieces of\n   information: the 24-bit IPv6 flow label and the 4-bit priority\
    \ field.\n   The contents and interpretation of this member is unspecified at\
    \ this\n   time.\n   The sin6_addr field is a single in6_addr structure (defined\
    \ in the\n   previous section).  This field holds one 128-bit IPv6 address.  The\n\
    \   address is stored in network byte order.\n   The ordering of elements in this\
    \ structure is specifically designed\n   so that the sin6_addr field will be aligned\
    \ on a 64-bit boundary.\n   This is done for optimum performance on 64-bit architectures.\n\
    \   Notice that the sockaddr_in6 structure will normally be larger than\n   the\
    \ generic sockaddr structure.  On many existing implementations the\n   sizeof(struct\
    \ sockaddr_in) equals sizeof(struct sockaddr), with both\n   being 16 bytes. \
    \ Any existing code that makes this assumption needs\n   to be examined carefully\
    \ when converting to IPv6.\n"
- title: 3.4.  Socket Address Structure for 4.4BSD-Based Systems
  contents:
  - "3.4.  Socket Address Structure for 4.4BSD-Based Systems\n   The 4.4BSD release\
    \ includes a small, but incompatible change to the\n   socket interface.  The\
    \ \"sa_family\" field of the sockaddr data\n   structure was changed from a 16-bit\
    \ value to an 8-bit value, and the\n   space saved used to hold a length field,\
    \ named \"sa_len\".  The\n   sockaddr_in6 data structure given in the previous\
    \ section cannot be\n   correctly cast into the newer sockaddr data structure.\
    \  For this\n   reason, the following alternative IPv6 address data structure\
    \ is\n   provided to be used on systems based on 4.4BSD:\n       #include <netinet/in.h>\n\
    \       #define SIN6_LEN\n       struct sockaddr_in6 {\n           u_char    \
    \      sin6_len;       /* length of this struct */\n           u_char        \
    \  sin6_family;    /* AF_INET6 */\n           u_int16m_t      sin6_port;     \
    \ /* transport layer port # */\n           u_int32m_t      sin6_flowinfo;  /*\
    \ IPv6 flow information */\n           struct in6_addr sin6_addr;      /* IPv6\
    \ address */\n       };\n   The only differences between this data structure and\
    \ the 4.3BSD\n   variant are the inclusion of the length field, and the change\
    \ of the\n   family field to a 8-bit data type.  The definitions of all the other\n\
    \   fields are identical to the structure defined in the previous\n   section.\n\
    \   Systems that provide this version of the sockaddr_in6 data structure\n   must\
    \ also declare SIN6_LEN as a result of including the\n   <netinet/in.h> header.\
    \  This macro allows applications to determine\n   whether they are being built\
    \ on a system that supports the 4.3BSD or\n   4.4BSD variants of the data structure.\n"
- title: 3.5.  The Socket Functions
  contents:
  - "3.5.  The Socket Functions\n   Applications call the socket() function to create\
    \ a socket descriptor\n   that represents a communication endpoint.  The arguments\
    \ to the\n   socket() function tell the system which protocol to use, and what\n\
    \   format address structure will be used in subsequent functions.  For\n   example,\
    \ to create an IPv4/TCP socket, applications make the call:\n       s = socket(PF_INET,\
    \ SOCK_STREAM, 0);\n   To create an IPv4/UDP socket, applications make the call:\n\
    \       s = socket(PF_INET, SOCK_DGRAM, 0);\n   Applications may create IPv6/TCP\
    \ and IPv6/UDP sockets by simply using\n   the constant PF_INET6 instead of PF_INET\
    \ in the first argument.  For\n   example, to create an IPv6/TCP socket, applications\
    \ make the call:\n       s = socket(PF_INET6, SOCK_STREAM, 0);\n   To create an\
    \ IPv6/UDP socket, applications make the call:\n       s = socket(PF_INET6, SOCK_DGRAM,\
    \ 0);\n   Once the application has created a PF_INET6 socket, it must use the\n\
    \   sockaddr_in6 address structure when passing addresses in to the\n   system.\
    \  The functions that the application uses to pass addresses\n   into the system\
    \ are:\n       bind()\n       connect()\n       sendmsg()\n       sendto()\n \
    \  The system will use the sockaddr_in6 address structure to return\n   addresses\
    \ to applications that are using PF_INET6 sockets.  The\n   functions that return\
    \ an address from the system to an application\n   are:\n          accept()\n\
    \          recvfrom()\n          recvmsg()\n          getpeername()\n        \
    \  getsockname()\n   No changes to the syntax of the socket functions are needed\
    \ to\n   support IPv6, since all of the \"address carrying\" functions use an\n\
    \   opaque address pointer, and carry an address length as a function\n   argument.\n"
- title: 3.6.  Compatibility with IPv4 Applications
  contents:
  - "3.6.  Compatibility with IPv4 Applications\n   In order to support the large\
    \ base of applications using the original\n   API, system implementations must\
    \ provide complete source and binary\n   compatibility with the original API.\
    \  This means that systems must\n   continue to support PF_INET sockets and the\
    \ sockaddr_in address\n   structure.  Applications must be able to create IPv4/TCP\
    \ and IPv4/UDP\n   sockets using the PF_INET constant in the socket() function,\
    \ as\n   described in the previous section.  Applications should be able to\n\
    \   hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP\n   sockets\
    \ simultaneously within the same process.\n   Applications using the original\
    \ API should continue to operate as\n   they did on systems supporting only IPv4.\
    \  That is, they should\n   continue to interoperate with IPv4 nodes.\n"
- title: 3.7.  Compatibility with IPv4 Nodes
  contents:
  - "3.7.  Compatibility with IPv4 Nodes\n   The API also provides a different type\
    \ of compatibility: the ability\n   for IPv6 applications to interoperate with\
    \ IPv4 applications.  This\n   feature uses the IPv4-mapped IPv6 address format\
    \ defined in the IPv6\n   addressing architecture specification [2].  This address\
    \ format\n   allows the IPv4 address of an IPv4 node to be represented as an IPv6\n\
    \   address.  The IPv4 address is encoded into the low-order 32 bits of\n   the\
    \ IPv6 address, and the high-order 96 bits hold the fixed prefix\n   0:0:0:0:0:FFFF.\
    \  IPv4-mapped addresses are written as follows:\n       ::FFFF:<IPv4-address>\n\
    \   These addresses are often generated automatically by the\n   gethostbyname()\
    \ function when the specified host has only IPv4\n   addresses (as described in\
    \ Section 6.1).\n   Applications may use PF_INET6 sockets to open TCP connections\
    \ to IPv4\n   nodes, or send UDP packets to IPv4 nodes, by simply encoding the\n\
    \   destination's IPv4 address as an IPv4-mapped IPv6 address, and\n   passing\
    \ that address, within a sockaddr_in6 structure, in the\n   connect() or sendto()\
    \ call.  When applications use PF_INET6 sockets\n   to accept TCP connections\
    \ from IPv4 nodes, or receive UDP packets\n   from IPv4 nodes, the system returns\
    \ the peer's address to the\n   application in the accept(), recvfrom(), or getpeername()\
    \ call using\n   a sockaddr_in6 structure encoded this way.\n   Few applications\
    \ will likely need to know which type of node they are\n   interoperating with.\
    \  However, for those applications that do need to\n   know, the IN6_IS_ADDR_V4MAPPED()\
    \ macro, defined in Section 6.6, is\n   provided.\n"
- title: 3.8.  IPv6 Wildcard Address
  contents:
  - "3.8.  IPv6 Wildcard Address\n   While the bind() function allows applications\
    \ to select the source IP\n   address of UDP packets and TCP connections, applications\
    \ often want\n   the system to select the source address for them.  With IPv4,\
    \ one\n   specifies the address as the symbolic constant INADDR_ANY (called the\n\
    \   \"wildcard\" address) in the bind() call, or simply omits the bind()\n   entirely.\n\
    \   Since the IPv6 address type is a structure (struct in6_addr), a\n   symbolic\
    \ constant can be used to initialize an IPv6 address variable,\n   but cannot\
    \ be used in an assignment.  Therefore systems provide the\n   IPv6 wildcard address\
    \ in two forms.\n   The first version is a global variable named \"in6addr_any\"\
    \ that is an\n   in6_addr structure.  The extern declaration for this variable\
    \ is\n   defined in <netinet/in.h>:\n       extern const struct in6_addr in6addr_any;\n\
    \   Applications use in6addr_any similarly to the way they use INADDR_ANY\n  \
    \ in IPv4.  For example, to bind a socket to port number 23, but let\n   the system\
    \ select the source address, an application could use the\n   following code:\n\
    \       struct sockaddr_in6 sin6;\n        . . .\n       sin6.sin6_family = AF_INET6;\n\
    \       sin6.sin6_flowinfo = 0;\n       sin6.sin6_port = htons(23);\n       sin6.sin6_addr\
    \ = in6addr_any;  /* structure assignment */\n        . . .\n       if (bind(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n               . . .\n   The\
    \ other version is a symbolic constant named IN6ADDR_ANY_INIT and\n   is defined\
    \ in <netinet/in.h>.  This constant can be used to\n   initialize an in6_addr\
    \ structure:\n       struct in6_addr anyaddr = IN6ADDR_ANY_INIT;\n   Note that\
    \ this constant can be used ONLY at declaration time.  It can\n   not be used\
    \ to assign a previously declared in6_addr structure.  For\n   example, the following\
    \ code will not work:\n       /* This is the WRONG way to assign an unspecified\
    \ address */\n       struct sockaddr_in6 sin6;\n        . . .\n       sin6.sin6_addr\
    \ = IN6ADDR_ANY_INIT; /* will NOT compile */\n   Be aware that the IPv4 INADDR_xxx\
    \ constants are all defined in host\n   byte order but the IPv6 IN6ADDR_xxx constants\
    \ and the IPv6\n   in6addr_xxx externals are defined in network byte order.\n"
- title: 3.9.  IPv6 Loopback Address
  contents:
  - "3.9.  IPv6 Loopback Address\n   Applications may need to send UDP packets to,\
    \ or originate TCP\n   connections to, services residing on the local node.  In\
    \ IPv4, they\n   can do this by using the constant IPv4 address INADDR_LOOPBACK\
    \ in\n   their connect(), sendto(), or sendmsg() call.\n   IPv6 also provides\
    \ a loopback address to contact local TCP and UDP\n   services.  Like the unspecified\
    \ address, the IPv6 loopback address is\n   provided in two forms -- a global\
    \ variable and a symbolic constant.\n   The global variable is an in6_addr structure\
    \ named\n   \"in6addr_loopback.\"  The extern declaration for this variable is\n\
    \   defined in <netinet/in.h>:\n       extern const struct in6_addr in6addr_loopback;\n\
    \   Applications use in6addr_loopback as they would use INADDR_LOOPBACK\n   in\
    \ IPv4 applications (but beware of the byte ordering difference\n   mentioned\
    \ at the end of the previous section).  For example, to open\n   a TCP connection\
    \ to the local telnet server, an application could use\n   the following code:\n\
    \       struct sockaddr_in6 sin6;\n        . . .\n       sin6.sin6_family = AF_INET6;\n\
    \       sin6.sin6_flowinfo = 0;\n       sin6.sin6_port = htons(23);\n       sin6.sin6_addr\
    \ = in6addr_loopback;  /* structure assignment */\n        . . .\n       if (connect(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n               . . .\n   The\
    \ symbolic constant is named IN6ADDR_LOOPBACK_INIT and is defined\n   in <netinet/in.h>.\
    \  It can be used at declaration time ONLY; for\n   example:\n       struct in6_addr\
    \ loopbackaddr = IN6ADDR_LOOPBACK_INIT;\n   Like IN6ADDR_ANY_INIT, this constant\
    \ cannot be used in an assignment\n   to a previously declared IPv6 address variable.\n"
- title: 4.  Interface Identification
  contents:
  - "4.  Interface Identification\n   This API uses an interface index (a small positive\
    \ integer) to\n   identify the local interface on which a multicast group is joined\n\
    \   (Section 5.3).  Additionally, the advanced API [5] uses these same\n   interface\
    \ indexes to identify the interface on which a datagram is\n   received, or to\
    \ specify the interface on which a datagram is to be\n   sent.\n   Interfaces\
    \ are normally known by names such as \"le0\", \"sl1\", \"ppp2\",\n   and the\
    \ like.  On Berkeley-derived implementations, when an interface\n   is made known\
    \ to the system, the kernel assigns a unique positive\n   integer value (called\
    \ the interface index) to that interface.  These\n   are small positive integers\
    \ that start at 1.  (Note that 0 is never\n   used for an interface index.)  There\
    \ may be gaps so that there is no\n   current interface for a particular positive\
    \ interface index.\n   This API defines two functions that map between an interface\
    \ name and\n   index, a third function that returns all the interface names and\n\
    \   indexes, and a fourth function to return the dynamic memory allocated\n  \
    \ by the previous function.  How these functions are implemented is\n   left up\
    \ to the implementation.  4.4BSD implementations can implement\n   these functions\
    \ using the existing sysctl() function with the\n   NET_RT_LIST command.  Other\
    \ implementations may wish to use ioctl()\n   for this purpose.\n"
- title: 4.1.  Name-to-Index
  contents:
  - "4.1.  Name-to-Index\n   The first function maps an interface name into its corresponding\n\
    \   index.\n       #include <net/if.h>\n       unsigned int  if_nametoindex(const\
    \ char *ifname);\n   If the specified interface does not exist, the return value\
    \ is 0.\n"
- title: 4.2.  Index-to-Name
  contents:
  - "4.2.  Index-to-Name\n   The second function maps an interface index into its\
    \ corresponding\n   name.\n       #include <net/if.h>\n       char  *if_indextoname(unsigned\
    \ int ifindex, char *ifname);\n   The ifname argument must point to a buffer of\
    \ at least IFNAMSIZ bytes\n   into which the interface name corresponding to the\
    \ specified index is\n   returned.  (IFNAMSIZ is also defined in <net/if.h> and\
    \ its value\n   includes a terminating null byte at the end of the interface name.)\n\
    \   This pointer is also the return value of the function.  If there is\n   no\
    \ interface corresponding to the specified index, NULL is returned.\n"
- title: 4.3.  Return All Interface Names and Indexes
  contents:
  - "4.3.  Return All Interface Names and Indexes\n   The final function returns an\
    \ array of if_nameindex structures, one\n   structure per interface.\n       #include\
    \ <net/if.h>\n       struct if_nameindex {\n         unsigned int   if_index;\
    \  /* 1, 2, ... */\n         char          *if_name;   /* null terminated name:\
    \ \"le0\", ... */\n       };\n       struct if_nameindex  *if_nameindex(void);\n\
    \   The end of the array of structures is indicated by a structure with\n   an\
    \ if_index of 0 and an if_name of NULL.  The function returns a NULL\n   pointer\
    \ upon an error.\n   The memory used for this array of structures along with the\
    \ interface\n   names pointed to by the if_name members is obtained dynamically.\n\
    \   This memory is freed by the next function.\n"
- title: 4.4.  Free Memory
  contents:
  - "4.4.  Free Memory\n   The following function frees the dynamic memory that was\
    \ allocated by\n   if_nameindex().\n       #include <net/if.h>\n       void  if_freenameindex(struct\
    \ if_nameindex *ptr);\n   The argument to this function must be a pointer that\
    \ was returned by\n   if_nameindex().\n"
- title: 5.  Socket Options
  contents:
  - "5.  Socket Options\n   A number of new socket options are defined for IPv6. \
    \ All of these\n   new options are at the IPPROTO_IPV6 level.  That is, the \"\
    level\"\n   parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6\n\
    \   when using these options.  The constant name prefix IPV6_ is used in\n   all\
    \ of the new socket options.  This serves to clearly identify these\n   options\
    \ as applying to IPv6.\n   The declaration for IPPROTO_IPV6, the new IPv6 socket\
    \ options, and\n   related constants defined in this section are obtained by including\n\
    \   the header <netinet/in.h>.\n"
- title: 5.1.  Changing Socket Type
  contents:
  - "5.1.  Changing Socket Type\n   Unix allows open sockets to be passed between\
    \ processes via the\n   exec() call and other means.  It is a relatively common\
    \ application\n   practice to pass open sockets across exec() calls.  Thus it\
    \ is\n   possible for an application using the original API to pass an open\n\
    \   PF_INET socket to an application that is expecting to receive a\n   PF_INET6\
    \ socket.  Similarly, it is possible for an application using\n   the extended\
    \ API to pass an open PF_INET6 socket to an application\n   using the original\
    \ API, which would be equipped only to deal with\n   PF_INET sockets.  Either\
    \ of these cases could cause problems, because\n   the application that is passed\
    \ the open socket might not know how to\n   decode the address structures returned\
    \ in subsequent socket\n   functions.\n   To remedy this problem, a new setsockopt()\
    \ option is defined that\n   allows an application to \"convert\" a PF_INET6 socket\
    \ into a PF_INET\n   socket and vice versa.\n   An IPv6 application that is passed\
    \ an open socket from an unknown\n   process may use the IPV6_ADDRFORM setsockopt()\
    \ option to \"convert\"\n   the socket to PF_INET6.  Once that has been done,\
    \ the system will\n   return sockaddr_in6 address structures in subsequent socket\n\
    \   functions.\n   An IPv6 application that is about to pass an open PF_INET6\
    \ socket to\n   a program that is not be IPv6 capable can \"downgrade\" the socket\
    \ to\n   PF_INET before calling exec().  After that, the system will return\n\
    \   sockaddr_in address structures to the application that was exec()'ed.\n  \
    \ Be aware that you cannot downgrade an IPv6 socket to an IPv4 socket\n   unless\
    \ all nonwildcard addresses already associated with the IPv6\n   socket are IPv4-mapped\
    \ IPv6 addresses.\n   The IPV6_ADDRFORM option is valid at both the IPPROTO_IP\
    \ and\n   IPPROTO_IPV6 levels.  The only valid option values are PF_INET6 and\n\
    \   PF_INET.  For example, to convert a PF_INET6 socket to PF_INET, a\n   program\
    \ would call:\n       int  addrform = PF_INET;\n       if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_ADDRFORM,\n                      (char *) &addrform, sizeof(addrform))\
    \ == -1)\n           perror(\"setsockopt IPV6_ADDRFORM\");\n   An application\
    \ may use IPV6_ADDRFORM with getsockopt() to learn\n   whether an open socket\
    \ is a PF_INET of PF_INET6 socket.  For example:\n       int  addrform;\n    \
    \   size_t  len = sizeof(addrform);\n       if (getsockopt(s, IPPROTO_IPV6, IPV6_ADDRFORM,\n\
    \                      (char *) &addrform, &len) == -1)\n           perror(\"\
    getsockopt IPV6_ADDRFORM\");\n       else if (addrform == PF_INET)\n         \
    \  printf(\"This is an IPv4 socket.\\n\");\n       else if (addrform == PF_INET6)\n\
    \           printf(\"This is an IPv6 socket.\\n\");\n       else\n           printf(\"\
    This system is broken.\\n\");\n"
- title: 5.2.  Unicast Hop Limit
  contents:
  - "5.2.  Unicast Hop Limit\n   A new setsockopt() option controls the hop limit\
    \ used in outgoing\n   unicast IPv6 packets.  The name of this option is IPV6_UNICAST_HOPS,\n\
    \   and it is used at the IPPROTO_IPV6 layer.  The following example\n   illustrates\
    \ how it is used:\n       int  hoplimit = 10;\n       if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_UNICAST_HOPS,\n                      (char *) &hoplimit, sizeof(hoplimit))\
    \ == -1)\n           perror(\"setsockopt IPV6_UNICAST_HOPS\");\n   When the IPV6_UNICAST_HOPS\
    \ option is set with setsockopt(), the\n   option value given is used as the hop\
    \ limit for all subsequent\n   unicast packets sent via that socket.  If the option\
    \ is not set, the\n   system selects a default value.  The integer hop limit value\
    \ (called\n   x) is interpreted as follows:\n       x < -1:        return an error\
    \ of EINVAL\n       x == -1:       use kernel default\n       0 <= x <= 255: use\
    \ x\n       x >= 256:      return an error of EINVAL\n   The IPV6_UNICAST_HOPS\
    \ option may be used with getsockopt() to\n   determine the hop limit value that\
    \ the system will use for subsequent\n   unicast packets sent via that socket.\
    \  For example:\n       int  hoplimit;\n       size_t  len = sizeof(hoplimit);\n\
    \       if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n                 \
    \     (char *) &hoplimit, &len) == -1)\n           perror(\"getsockopt IPV6_UNICAST_HOPS\"\
    );\n       else\n           printf(\"Using %d for hop limit.\\n\", hoplimit);\n"
- title: 5.3.  Sending and Receiving Multicast Packets
  contents:
  - "5.3.  Sending and Receiving Multicast Packets\n   IPv6 applications may send\
    \ UDP multicast packets by simply specifying\n   an IPv6 multicast address in\
    \ the address argument of the sendto()\n   function.\n   Three socket options\
    \ at the IPPROTO_IPV6 layer control some of the\n   parameters for sending multicast\
    \ packets.  Setting these options is\n   not required:  applications may send\
    \ multicast packets without using\n   these options.  The setsockopt() options\
    \ for controlling the sending\n   of multicast packets are summarized below:\n\
    \       IPV6_MULTICAST_IF\n           Set the interface to use for outgoing multicast\
    \ packets.  The\n           argument is the index of the interface to use.\n \
    \          Argument type: unsigned int\n       IPV6_MULTICAST_HOPS\n         \
    \  Set the hop limit to use for outgoing multicast packets.\n           (Note\
    \ a separate option - IPV6_UNICAST_HOPS - is provided to\n           set the hop\
    \ limit to use for outgoing unicast packets.)  The\n           interpretation\
    \ of the argument is the same as for the\n           IPV6_UNICAST_HOPS option:\n\
    \               x < -1:        return an error of EINVAL\n               x ==\
    \ -1:       use kernel default\n               0 <= x <= 255: use x\n        \
    \       x >= 256:      return an error of EINVAL\n           Argument type: int\n\
    \       IPV6_MULTICAST_LOOP\n           Controls whether outgoing multicast packets\
    \  sent  should  be\n           delivered  back  to the local application.  A\
    \ toggle.  If the\n           option is set to 1, multicast packets are looped\
    \ back.  If it\n           is set to 0, they are not.\n           Argument type:\
    \ unsigned int\n   The reception of multicast packets is controlled by the two\n\
    \   setsockopt() options summarized below:\n       IPV6_ADD_MEMBERSHIP\n     \
    \      Join a multicast group on a specified local interface.  If\n          \
    \ the interface index is specified as 0, the kernel chooses the\n           local\
    \ interface.  For example, some kernels look up the\n           multicast group\
    \ in the normal IPv6 routing table and using\n           the resulting interface.\n\
    \           Argument type: struct ipv6_mreq\n       IPV6_DROP_MEMBERSHIP\n   \
    \        Leave a multicast group on a specified interface.\n           Argument\
    \ type: struct ipv6_mreq\n   The argument type of both of these options is the\
    \ ipv6_mreq\n   structure, defined as:\n       #include <netinet/in.h>\n     \
    \  struct ipv6_mreq {\n           struct in6_addr ipv6mr_multiaddr; /* IPv6 multicast\
    \ addr */\n           unsigned int    ipv6mr_interface; /* interface index */\n\
    \       };\n   Note that to receive multicast datagrams a process must join the\n\
    \   multicast group and bind the UDP port to which datagrams will be\n   sent.\
    \  Some processes also bind the multicast group address to the\n   socket, in\
    \ addition to the port, to prevent other datagrams destined\n   to that same port\
    \ from being delivered to the socket.\n"
- title: 6.  Library Functions
  contents:
  - "6.  Library Functions\n   New library functions are needed to perform a variety\
    \ of operations\n   with IPv6 addresses.  Functions are needed to lookup IPv6\
    \ addresses\n   in the Domain Name System (DNS).  Both forward lookup (hostname-to-\n\
    \   address translation) and reverse lookup (address-to-hostname\n   translation)\
    \ need to be supported.  Functions are also needed to\n   convert IPv6 addresses\
    \ between their binary and textual form.\n"
- title: 6.1.  Hostname-to-Address Translation
  contents:
  - "6.1.  Hostname-to-Address Translation\n   The commonly used function gethostbyname()\
    \ remains unchanged as does\n   the hostent structure to which it returns a pointer.\
    \  Existing\n   applications that call this function continue to receive only\
    \ IPv4\n   addresses that are the result of a query in the DNS for A records.\n\
    \   (We assume the DNS is being used; some environments may be using a\n   hosts\
    \ file or some other name resolution system, either of which may\n   impede renumbering.\
    \  We also assume that the RES_USE_INET6 resolver\n   option is not set, which\
    \ we describe in more detail shortly.)\n   Two new changes are made to support\
    \ IPv6 addresses.  First, the\n   following function is new:\n       #include\
    \ <sys/socket.h>\n       #include <netdb.h>\n       struct hostent *gethostbyname2(const\
    \ char *name, int af);\n   The af argument specifies the address family.  The\
    \ default operation\n   of this function is simple:\n    -  If the af argument\
    \ is AF_INET, then a query is made for A\n       records.  If successful, IPv4\
    \ addresses are returned and the\n       h_length member of the hostent structure\
    \ will be 4, else the\n       function returns a NULL pointer.\n    -  If the\
    \ af argument is AF_INET6, then a query is made for AAAA\n       records.  If\
    \ successful, IPv6 addresses are returned and the\n       h_length member of the\
    \ hostent structure will be 16, else the\n       function returns a NULL pointer.\n\
    \   The second change, that provides additional functionality, is a new\n   resolver\
    \ option RES_USE_INET6, which is defined as a result of\n   including the <resolv.h>\
    \ header.  (This option is provided starting\n   with the BIND 4.9.4 release.)\
    \  There are three ways to set this\n   option.\n    -  The first way is\n   \
    \        res_init();\n           _res.options |= RES_USE_INET6;\n       and then\
    \ call either gethostbyname() or gethostbyname2().  This\n       option then affects\
    \ only the process that is calling the\n       resolver.\n    -  The second way\
    \ to set this option is to set the environment\n       variable RES_OPTIONS, as\
    \ in RES_OPTIONS=inet6.  (This example is\n       for the Bourne and Korn shells.)\
    \  This method affects any\n       processes that see this environment variable.\n\
    \    -  The third way is to set this option in the resolver configuration\n  \
    \     file (normally /etc/resolv.conf) and the option then affects all\n     \
    \  applications on the host.  This final method should not be done\n       until\
    \ all applications on the host are capable of dealing with\n       IPv6 addresses.\n\
    \   There is no priority among these three methods.  When the\n   RES_USE_INET6\
    \ option is set, two changes occur:\n    -  gethostbyname(host) first calls gethostbyname2(host,\
    \ AF_INET6)\n       looking for AAAA records, and if this fails it then calls\n\
    \       gethostbyname2(host, AF_INET) looking for A records.\n    -  gethostbyname2(host,\
    \ AF_INET) always returns IPv4-mapped IPv6\n       addresses with the h_length\
    \ member of the hostent structure set\n       to 16.\n   An application must not\
    \ enable the RES_USE_INET6 option until it is\n   prepared to deal with 16-byte\
    \ addresses in the returned hostent\n   structure.\n   The following table summarizes\
    \ the operation of the existing\n   gethostbyname() function, the new function\
    \ gethostbyname2(), along\n   with the new resolver option RES_USE_INET6.\n"
- title: +------------------+---------------------------------------------------+
  contents:
  - '+------------------+---------------------------------------------------+

    '
- title: '|                  |              RES_USE_INET6 option                 |'
  contents:
  - '|                  |              RES_USE_INET6 option                 |

    '
- title: '|                  +-------------------------+-------------------------+'
  contents:
  - '|                  +-------------------------+-------------------------+

    '
- title: '|                  |          off            |           on            |'
  contents:
  - '|                  |          off            |           on            |

    '
- title: +------------------+-------------------------+-------------------------+
  contents:
  - '+------------------+-------------------------+-------------------------+

    '
- title: '|                  |Search for A records.    |Search for AAAA records. |'
  contents:
  - '|                  |Search for A records.    |Search for AAAA records. |

    '
- title: '| gethostbyname    | If found, return IPv4   | If found, return IPv6   |'
  contents:
  - '| gethostbyname    | If found, return IPv4   | If found, return IPv6   |

    '
- title: '| (host)           | addresses (h_length=4). | addresses (h_length=16).|'
  contents:
  - '| (host)           | addresses (h_length=4). | addresses (h_length=16).|

    '
- title: '|                  | Else error.             | Else search for A       |'
  contents:
  - '|                  | Else error.             | Else search for A       |

    '
- title: '|                  |                         | records.  If found,     |'
  contents:
  - '|                  |                         | records.  If found,     |

    '
- title: '|                  |Provides backward        | return IPv4-mapped IPv6 |'
  contents:
  - '|                  |Provides backward        | return IPv4-mapped IPv6 |

    '
- title: '|                  | compatibility with all  | addresses (h_length=16).|'
  contents:
  - '|                  | compatibility with all  | addresses (h_length=16).|

    '
- title: '|                  | existing IPv4 appls.    | Else error.             |'
  contents:
  - '|                  | existing IPv4 appls.    | Else error.             |

    '
- title: +------------------+-------------------------+-------------------------+
  contents:
  - '+------------------+-------------------------+-------------------------+

    '
- title: '|                  |Search for A records.    |Search for A records.    |'
  contents:
  - '|                  |Search for A records.    |Search for A records.    |

    '
- title: '| gethostbyname2   | If found, return IPv4   | If found, return        |'
  contents:
  - '| gethostbyname2   | If found, return IPv4   | If found, return        |

    '
- title: '| (host, AF_INET)  | addresses (h_length=4). | IPv4-mapped IPv6        |'
  contents:
  - '| (host, AF_INET)  | addresses (h_length=4). | IPv4-mapped IPv6        |

    '
- title: '|                  | Else error.             | addresses (h_length=16).|'
  contents:
  - '|                  | Else error.             | addresses (h_length=16).|

    '
- title: '|                  |                         | Else error.             |'
  contents:
  - '|                  |                         | Else error.             |

    '
- title: +------------------+-------------------------+-------------------------+
  contents:
  - '+------------------+-------------------------+-------------------------+

    '
- title: '|                  |Search for AAAA records. |Search for AAAA records. |'
  contents:
  - '|                  |Search for AAAA records. |Search for AAAA records. |

    '
- title: '| gethostbyname2   | If found, return IPv6   | If found, return IPv6   |'
  contents:
  - '| gethostbyname2   | If found, return IPv6   | If found, return IPv6   |

    '
- title: '| (host, AF_INET6) | addresses (h_length=16).| addresses (h_length=16).|'
  contents:
  - '| (host, AF_INET6) | addresses (h_length=16).| addresses (h_length=16).|

    '
- title: '|                  | Else error.             | Else error.             |'
  contents:
  - '|                  | Else error.             | Else error.             |

    '
- title: +------------------+-------------------------+-------------------------+
  contents:
  - "+------------------+-------------------------+-------------------------+\n  \
    \ It is expected that when a typical naive application that calls\n   gethostbyname()\
    \ today is modified to use IPv6, it simply changes the\n   program to use IPv6\
    \ sockets and then enables the RES_USE_INET6\n   resolver option before calling\
    \ gethostbyname().  This application\n   will then work with either IPv4 or IPv6\
    \ peers.\n   Note that gethostbyname() and gethostbyname2() are not thread-safe,\n\
    \   since both return a pointer to a static hostent structure.  But\n   several\
    \ vendors have defined a thread-safe gethostbyname_r() function\n   that requires\
    \ four additional arguments.  We expect these vendors to\n   also define a gethostbyname2_r()\
    \ function.\n"
- title: 6.2.  Address To Hostname Translation
  contents:
  - "6.2.  Address To Hostname Translation\n   The existing gethostbyaddr() function\
    \ already requires an address\n   family argument and can therefore work with\
    \ IPv6 addresses:\n       #include <sys/socket.h>\n       #include <netdb.h>\n\
    \       struct hostent *gethostbyaddr(const char *src, int len, int af);\n   One\
    \ possible source of confusion is the handling of IPv4-mapped IPv6\n   addresses\
    \ and IPv4-compatible IPv6 addresses.  This is addressed in\n   [6] and involves\
    \ the following logic:\n    1.  If af is AF_INET6, and if len equals 16, and if\
    \ the IPv6 address\n        is an IPv4-mapped IPv6 address or an IPv4-compatible\
    \ IPv6\n        address, then skip over the first 12 bytes of the IPv6 address,\n\
    \        set af to AF_INET, and set len to 4.\n    2.  If af is AF_INET, then\
    \ query for a PTR record in the in-\n        addr.arpa domain.\n    3.  If af\
    \ is AF_INET6, then query for a PTR record in the ip6.int\n        domain.\n \
    \   4.  If the function is returning success, and if af equals AF_INET,\n    \
    \    and if the RES_USE_INET6 option was set, then the single address\n      \
    \  that is returned in the hostent structure (a copy of the first\n        argument\
    \ to the function) is returned as an IPv4-mapped IPv6\n        address and the\
    \ h_length member is set to 16.\n   All four steps listed are performed, in order.\
    \  The same caveats\n   regarding a thread-safe version of gethostbyname() that\
    \ were made at\n   the end of the previous section apply here as well.\n"
- title: 6.3.  Protocol-Independent Hostname and Service Name Translation
  contents:
  - "6.3.  Protocol-Independent Hostname and Service Name Translation\n   Hostname-to-address\
    \ translation is done in a protocol-independent\n   fashion using the getaddrinfo()\
    \ function that is taken from the\n   Institute of Electrical and Electronic Engineers\
    \ (IEEE) POSIX 1003.1g\n   (Protocol Independent Interfaces) work in progress\
    \ specification [4].\n   The official specification for this function will be\
    \ the final POSIX\n   standard.  We are providing this independent description\
    \ of the\n   function because POSIX standards are not freely available (as are\n\
    \   IETF documents).  Should there be any discrepancies between this\n   description\
    \ and the POSIX description, the POSIX description takes\n   precedence.\n   \
    \    #include <sys/socket.h>\n       #include <netdb.h>\n       int getaddrinfo(const\
    \ char *hostname, const char *servname,\n                       const struct addrinfo\
    \ *hints,\n                       struct addrinfo **res);\n   The addrinfo structure\
    \ is defined as:\n       #include <sys/socket.h>\n       #include <netdb.h>\n\
    \       struct addrinfo {\n         int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME\
    \ */\n         int     ai_family;    /* PF_xxx */\n         int     ai_socktype;\
    \  /* SOCK_xxx */\n         int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4\
    \ and IPv6 */\n         size_t  ai_addrlen;   /* length of ai_addr */\n      \
    \   char   *ai_canonname; /* canonical name for hostname */\n         struct sockaddr\
    \  *ai_addr; /* binary address */\n         struct addrinfo  *ai_next; /* next\
    \ structure in linked list */\n       };\n   The return value from the function\
    \ is 0 upon success or a nonzero\n   error code.  The following names are the\
    \ nonzero error codes from\n   getaddrinfo(), and are defined in <netdb.h>:\n\
    \       EAI_ADDRFAMILY  address family for hostname not supported\n       EAI_AGAIN\
    \       temporary failure in name resolution\n       EAI_BADFLAGS    invalid value\
    \ for ai_flags\n       EAI_FAIL        non-recoverable failure in name resolution\n\
    \       EAI_FAMILY      ai_family not supported\n       EAI_MEMORY      memory\
    \ allocation failure\n       EAI_NODATA      no address associated with hostname\n\
    \       EAI_NONAME      hostname nor servname provided, or not known\n       EAI_SERVICE\
    \     servname not supported for ai_socktype\n       EAI_SOCKTYPE    ai_socktype\
    \ not supported\n       EAI_SYSTEM      system error returned in errno\n   The\
    \ hostname and servname arguments are pointers to null-terminated\n   strings\
    \ or NULL.  One or both of these two arguments must be a non-\n   NULL pointer.\
    \  In the normal client scenario, both the hostname and\n   servname are specified.\
    \  In the normal server scenario, only the\n   servname is specified.  A non-NULL\
    \ hostname string can be either a\n   host name or a numeric host address string\
    \ (i.e., a dotted-decimal\n   IPv4 address or an IPv6 hex address).  A non-NULL\
    \ servname string can\n   be either a service name or a decimal port number.\n\
    \   The caller can optionally pass an addrinfo structure, pointed to by\n   the\
    \ third argument, to provide hints concerning the type of socket\n   that the\
    \ caller supports.  In this hints structure all members other\n   than ai_flags,\
    \ ai_family, ai_socktype, and ai_protocol must be zero\n   or a NULL pointer.\
    \  A value of PF_UNSPEC for ai_family means the\n   caller will accept any protocol\
    \ family.  A value of 0 for ai_socktype\n   means the caller will accept any socket\
    \ type.  A value of 0 for\n   ai_protocol means the caller will accept any protocol.\
    \  For example,\n   if the caller handles only TCP and not UDP, then the ai_socktype\n\
    \   member of the hints structure should be set to SOCK_STREAM when\n   getaddrinfo()\
    \ is called.  If the caller handles only IPv4 and not\n   IPv6, then the ai_family\
    \ member of the hints structure should be set\n   to PF_INET when getaddrinfo()\
    \ is called.  If the third argument to\n   getaddrinfo() is a NULL pointer, this\
    \ is the same as if the caller\n   had filled in an addrinfo structure initialized\
    \ to zero with\n   ai_family set to PF_UNSPEC.\n   Upon successful return a pointer\
    \ to a linked list of one or more\n   addrinfo structures is returned through\
    \ the final argument.  The\n   caller can process each addrinfo structure in this\
    \ list by following\n   the ai_next pointer, until a NULL pointer is encountered.\
    \  In each\n   returned addrinfo structure the three members ai_family, ai_socktype,\n\
    \   and ai_protocol are the corresponding arguments for a call to the\n   socket()\
    \ function.  In each addrinfo structure the ai_addr member\n   points to a filled-in\
    \ socket address structure whose length is\n   specified by the ai_addrlen member.\n\
    \   If the AI_PASSIVE bit is set in the ai_flags member of the hints\n   structure,\
    \ then the caller plans to use the returned socket address\n   structure in a\
    \ call to bind().  In this case, if the hostname\n   argument is a NULL pointer,\
    \ then the IP address portion of the socket\n   address structure will be set\
    \ to INADDR_ANY for an IPv4 address or\n   IN6ADDR_ANY_INIT for an IPv6 address.\n\
    \   If the AI_PASSIVE bit is not set in the ai_flags member of the hints\n   structure,\
    \ then the returned socket address structure will be ready\n   for a call to connect()\
    \ (for a connection-oriented protocol) or\n   either connect(), sendto(), or sendmsg()\
    \ (for a connectionless\n   protocol).  In this case, if the hostname argument\
    \ is a NULL pointer,\n   then the IP address portion of the socket address structure\
    \ will be\n   set to the loopback address.\n   If the AI_CANONNAME bit is set\
    \ in the ai_flags member of the hints\n   structure, then upon successful return\
    \ the ai_canonname member of the\n   first addrinfo structure in the linked list\
    \ will point to a null-\n   terminated string containing the canonical name of\
    \ the specified\n   hostname.\n   All of the information returned by getaddrinfo()\
    \ is dynamically\n   allocated: the addrinfo structures, and the socket address\
    \ structures\n   and canonical host name strings pointed to by the addrinfo\n\
    \   structures.  To return this information to the system the function\n   freeaddrinfo()\
    \ is called:\n       #include <sys/socket.h>\n       #include <netdb.h>\n    \
    \   void freeaddrinfo(struct addrinfo *ai);\n   The addrinfo structure pointed\
    \ to by the ai argument is freed, along\n   with any dynamic storage pointed to\
    \ by the structure.  This operation\n   is repeated until a NULL ai_next pointer\
    \ is encountered.\n   To aid applications in printing error messages based on\
    \ the EAI_xxx\n   codes returned by getaddrinfo(), the following function is defined.\n\
    \       #include <sys/socket.h>\n       #include <netdb.h>\n       char *gai_strerror(int\
    \ ecode);\n   The argument is one of the EAI_xxx values defined earlier and the\n\
    \   eturn value points to a string describing the error.  If the argument\n  \
    \ is not one of the EAI_xxx values, the function still returns a\n   pointer to\
    \ a string whose contents indicate an unknown error.\n"
- title: 6.4.  Socket Address Structure to Hostname and Service Name
  contents:
  - "6.4.  Socket Address Structure to Hostname and Service Name\n   The POSIX 1003.1g\
    \ specification includes no function to perform the\n   reverse conversion from\
    \ getaddrinfo():  to look up a hostname and\n   service name, given the binary\
    \ address and port.  Therefore, we\n   define the following function:\n      \
    \ #include <sys/socket.h>\n       #include <netdb.h>\n       int getnameinfo(const\
    \ struct sockaddr *sa, size_t salen,\n                       char *host, size_t\
    \ hostlen,\n                       char *serv, size_t servlen,\n             \
    \          int flags);\n   This function looks up an IP address and port number\
    \ provided by the\n   caller in the DNS and system-specific database, and returns\
    \ text\n   strings for both in buffers provided by the caller.  The function\n\
    \   indicates successful completion by a zero return value; a non-zero\n   return\
    \ value indicates failure.\n   The first argument, sa, points to either a sockaddr_in\
    \ structure (for\n   IPv4) or a sockaddr_in6 structure (for IPv6) that holds the\
    \ IP\n   address and port number.  The salen argument gives the length of the\n\
    \   sockaddr_in or sockaddr_in6 structure.\n   The function returns the hostname\
    \ associated with the IP address in\n   the buffer pointed to by the host argument.\
    \  The caller provides the\n   size of this buffer via the hostlen argument. \
    \ The service name\n   associated with the port number is returned in the buffer\
    \ pointed to\n   by serv, and the servlen argument gives the length of this buffer.\n\
    \   The caller specifies not to return either string by providing a zero\n   value\
    \ for the hostlen or servlen arguments.  Otherwise, the caller\n   must provide\
    \ buffers large enough to hold the hostname and the\n   service name, including\
    \ the terminating null characters.\n   Unfortunately most systems do not provide\
    \ constants that specify the\n   maximum size of either a fully-qualified domain\
    \ name or a service\n   name.  Therefore to aid the application in allocating\
    \ buffers for\n   these two returned strings the following constants are defined\
    \ in\n   <netdb.h>:\n       #define NI_MAXHOST  1025\n       #define NI_MAXSERV\
    \    32\n   The first value is actually defined as the constant MAXDNAME in\n\
    \   recent versions of BIND's <arpa/nameser.h> header (older versions of\n   BIND\
    \ define this constant to be 256) and the second is a guess based\n   on the services\
    \ listed in the current Assigned Numbers RFC.\n   The final argument is a flag\
    \ that changes the default actions of this\n   function.  By default the fully-qualified\
    \ domain name (FQDN) for the\n   host is looked up in the DNS and returned.  If\
    \ the flag bit NI_NOFQDN\n   is set, only the hostname portion of the FQDN is\
    \ returned for local\n   hosts.\n   If the flag bit NI_NUMERICHOST is set, or\
    \ if the host's name cannot\n   be located in the DNS, the numeric form of the\
    \ host's address is\n   returned instead of its name (e.g., by calling inet_ntop()\
    \ instead of\n   gethostbyaddr()).  If the flag bit NI_NAMEREQD is set, an error\
    \ is\n   returned if the host's name cannot be located in the DNS.\n   If the\
    \ flag bit NI_NUMERICSERV is set, the numeric form of the\n   service address\
    \ is returned (e.g., its port number) instead of its\n   name.  The two NI_NUMERICxxx\
    \ flags are required to support the \"-n\"\n   flag that many commands provide.\n\
    \   A fifth flag bit, NI_DGRAM, specifies that the service is a datagram\n   service,\
    \ and causes getservbyport() to be called with a second\n   argument of \"udp\"\
    \ instead of its default of \"tcp\".  This is required\n   for the few ports (512-514)\
    \ that have different services for UDP and\n   TCP.\n   These NI_xxx flags are\
    \ defined in <netdb.h> along with the AI_xxx\n   flags already defined for getaddrinfo().\n"
- title: 6.5.  Address Conversion Functions
  contents:
  - "6.5.  Address Conversion Functions\n   The two functions inet_addr() and inet_ntoa()\
    \ convert an IPv4 address\n   between binary and text form.  IPv6 applications\
    \ need similar\n   functions.  The following two functions convert both IPv6 and\
    \ IPv4\n   addresses:\n       #include <sys/socket.h>\n       #include <arpa/inet.h>\n\
    \       int inet_pton(int af, const char *src, void *dst);\n       const char\
    \ *inet_ntop(int af, const void *src,\n                             char *dst,\
    \ size_t size);\n   The inet_pton() function converts an address in its standard\
    \ text\n   presentation form into its numeric binary form.  The af argument\n\
    \   specifies the family of the address.  Currently the AF_INET and\n   AF_INET6\
    \ address families are supported.  The src argument points to\n   the string being\
    \ passed in.  The dst argument points to a buffer into\n   which the function\
    \ stores the numeric address.  The address is\n   returned in network byte order.\
    \  Inet_pton() returns 1 if the\n   conversion succeeds, 0 if the input is not\
    \ a valid IPv4 dotted-\n   decimal string or a valid IPv6 address string, or -1\
    \ with errno set\n   to EAFNOSUPPORT if the af argument is unknown.  The calling\n\
    \   application must ensure that the buffer referred to by dst is large\n   enough\
    \ to hold the numeric address (e.g., 4 bytes for AF_INET or 16\n   bytes for AF_INET6).\n\
    \   If the af argument is AF_INET, the function accepts a string in the\n   standard\
    \ IPv4 dotted-decimal form:\n       ddd.ddd.ddd.ddd\n   where ddd is a one to\
    \ three digit decimal number between 0 and 255.\n   Note that many implementations\
    \ of the existing inet_addr() and\n   inet_aton() functions accept nonstandard\
    \ input:  octal numbers,\n   hexadecimal numbers, and fewer than four numbers.\
    \  inet_pton() does\n   not accept these formats.\n   If the af argument is AF_INET6,\
    \ then the function accepts a string in\n   one of the standard IPv6 text forms\
    \ defined in Section 2.2 of the\n   addressing architecture specification [2].\n\
    \   The inet_ntop() function converts a numeric address into a text\n   string\
    \ suitable for presentation.  The af argument specifies the\n   family of the\
    \ address.  This can be AF_INET or AF_INET6.  The src\n   argument points to a\
    \ buffer holding an IPv4 address if the af\n   argument is AF_INET, or an IPv6\
    \ address if the af argument is\n   AF_INET6.  The dst argument points to a buffer\
    \ where the function\n   will store the resulting text string.  The size argument\
    \ specifies\n   the size of this buffer.  The application must specify a non-NULL\
    \ dst\n   argument.  For IPv6 addresses, the buffer must be at least 46-octets.\n\
    \   For IPv4 addresses, the buffer must be at least 16-octets.  In order\n   to\
    \ allow applications to easily declare buffers of the proper size to\n   store\
    \ IPv4 and IPv6 addresses in string form, the following two\n   constants are\
    \ defined in <netinet/in.h>:\n       #define INET_ADDRSTRLEN    16\n       #define\
    \ INET6_ADDRSTRLEN   46\n   The inet_ntop() function returns a pointer to the\
    \ buffer containing\n   the text string if the conversion succeeds, and NULL otherwise.\
    \  Upon\n   failure, errno is set to EAFNOSUPPORT if the af argument is invalid\n\
    \   or ENOSPC if the size of the result buffer is inadequate.\n"
- title: 6.6.  Address Testing Macros
  contents:
  - "6.6.  Address Testing Macros\n   The following macros can be used to test for\
    \ special IPv6 addresses.\n       #include <netinet/in.h>\n       int  IN6_IS_ADDR_UNSPECIFIED\
    \ (const struct in6_addr *);\n       int  IN6_IS_ADDR_LOOPBACK    (const struct\
    \ in6_addr *);\n       int  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\n\
    \       int  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);\n       int  IN6_IS_ADDR_SITELOCAL\
    \   (const struct in6_addr *);\n       int  IN6_IS_ADDR_V4MAPPED    (const struct\
    \ in6_addr *);\n       int  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);\n\
    \       int  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\n       int  IN6_IS_ADDR_MC_LINKLOCAL(const\
    \ struct in6_addr *);\n       int  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr\
    \ *);\n       int  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);\n      \
    \ int  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);\n   The first seven\
    \ macros return true if the address is of the specified\n   type, or false otherwise.\
    \  The last five test the scope of a\n   multicast address and return true if\
    \ the address is a multicast\n   address of the specified scope or false if the\
    \ address is either not\n   a multicast address or not of the specified scope.\n"
- title: 7.  Summary of New Definitions
  contents:
  - "7.  Summary of New Definitions\n   The following list summarizes the constants,\
    \ structure, and extern\n   definitions discussed in this memo, sorted by header.\n\
    \     <net/if.h>      IFNAMSIZ\n     <net/if.h>      struct if_nameindex{};\n\
    \     <netdb.h>       AI_CANONNAME\n     <netdb.h>       AI_PASSIVE\n     <netdb.h>\
    \       EAI_ADDRFAMILY\n     <netdb.h>       EAI_AGAIN\n     <netdb.h>       EAI_BADFLAGS\n\
    \     <netdb.h>       EAI_FAIL\n     <netdb.h>       EAI_FAMILY\n     <netdb.h>\
    \       EAI_MEMORY\n     <netdb.h>       EAI_NODATA\n     <netdb.h>       EAI_NONAME\n\
    \     <netdb.h>       EAI_SERVICE\n     <netdb.h>       EAI_SOCKTYPE\n     <netdb.h>\
    \       EAI_SYSTEM\n     <netdb.h>       NI_DGRAM\n     <netdb.h>       NI_MAXHOST\n\
    \     <netdb.h>       NI_MAXSERV\n     <netdb.h>       NI_NAMEREQD\n     <netdb.h>\
    \       NI_NOFQDN\n     <netdb.h>       NI_NUMERICHOST\n     <netdb.h>       NI_NUMERICSERV\n\
    \     <netdb.h>       struct addrinfo{};\n     <netinet/in.h>  IN6ADDR_ANY_INIT\n\
    \     <netinet/in.h>  IN6ADDR_LOOPBACK_INIT\n     <netinet/in.h>  INET6_ADDRSTRLEN\n\
    \     <netinet/in.h>  INET_ADDRSTRLEN\n     <netinet/in.h>  IPPROTO_IPV6\n   \
    \  <netinet/in.h>  IPV6_ADDRFORM\n     <netinet/in.h>  IPV6_ADD_MEMBERSHIP\n \
    \    <netinet/in.h>  IPV6_DROP_MEMBERSHIP\n     <netinet/in.h>  IPV6_MULTICAST_HOPS\n\
    \     <netinet/in.h>  IPV6_MULTICAST_IF\n     <netinet/in.h>  IPV6_MULTICAST_LOOP\n\
    \     <netinet/in.h>  IPV6_UNICAST_HOPS\n     <netinet/in.h>  SIN6_LEN\n     <netinet/in.h>\
    \  extern const struct in6_addr in6addr_any;\n     <netinet/in.h>  extern const\
    \ struct in6_addr in6addr_loopback;\n     <netinet/in.h>  struct in6_addr{};\n\
    \     <netinet/in.h>  struct ipv6_mreq{};\n     <netinet/in.h>  struct sockaddr_in6{};\n\
    \     <resolv.h>      RES_USE_INET6\n     <sys/socket.h>  AF_INET6\n     <sys/socket.h>\
    \  PF_INET6\n   The following list summarizes the function and macro prototypes\n\
    \   discussed in this memo, sorted by header.\n"
- title: <arpa/inet.h>   int inet_pton(int, const char *, void *);
  contents:
  - '<arpa/inet.h>   int inet_pton(int, const char *, void *);

    '
- title: <arpa/inet.h>   const char *inet_ntop(int, const void *,
  contents:
  - "<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                  \
    \                    char *, size_t);\n"
- title: <net/if.h>      char *if_indextoname(unsigned int, char *);
  contents:
  - '<net/if.h>      char *if_indextoname(unsigned int, char *);

    '
- title: <net/if.h>      unsigned int if_nametoindex(const char *);
  contents:
  - '<net/if.h>      unsigned int if_nametoindex(const char *);

    '
- title: <net/if.h>      void if_freenameindex(struct if_nameindex *);
  contents:
  - '<net/if.h>      void if_freenameindex(struct if_nameindex *);

    '
- title: <net/if.h>      struct if_nameindex *if_nameindex(void);
  contents:
  - '<net/if.h>      struct if_nameindex *if_nameindex(void);

    '
- title: <netdb.h>       int getaddrinfo(const char *, const char *,
  contents:
  - "<netdb.h>       int getaddrinfo(const char *, const char *,\n               \
    \                 const struct addrinfo *,\n                                struct\
    \ addrinfo **);\n"
- title: <netdb.h>       int getnameinfo(const struct sockaddr *, size_t,
  contents:
  - "<netdb.h>       int getnameinfo(const struct sockaddr *, size_t,\n          \
    \                      char *, size_t, char *, size_t, int);\n"
- title: <netdb.h>       void freeaddrinfo(struct addrinfo *);
  contents:
  - '<netdb.h>       void freeaddrinfo(struct addrinfo *);

    '
- title: <netdb.h>       char *gai_strerror(int);
  contents:
  - '<netdb.h>       char *gai_strerror(int);

    '
- title: <netdb.h>       struct hostent *gethostbyname(const char *);
  contents:
  - '<netdb.h>       struct hostent *gethostbyname(const char *);

    '
- title: <netdb.h>       struct hostent *gethostbyaddr(const char *, int, int);
  contents:
  - '<netdb.h>       struct hostent *gethostbyaddr(const char *, int, int);

    '
- title: <netdb.h>       struct hostent *gethostbyname2(const char *, int);
  contents:
  - '<netdb.h>       struct hostent *gethostbyname2(const char *, int);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);

    '
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   IPv6 provides a number of new security mechanisms,\
    \ many of which need\n   to be accessible to applications.  A companion memo detailing\
    \ the\n   extensions to the socket interfaces to support IPv6 security is being\n\
    \   written [3].\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   Thanks to the many people who made suggestions and provided\
    \ feedback\n   to to the numerous revisions of this document, including: Werner\n\
    \   Almesberger, Ran Atkinson, Fred Baker, Dave Borman, Andrew Cherenson,\n  \
    \ Alex Conta, Alan Cox, Steve Deering, Richard Draves, Francis Dupont,\n   Robert\
    \ Elz, Marc Hasson, Tim Hartrick, Tom Herbert, Bob Hinden, Wan-\n   Yen Hsu, Christian\
    \ Huitema, Koji Imada, Markus Jork, Ron Lee, Alan\n   Lloyd, Charles Lynn, Jack\
    \ McCann, Dan McDonald, Dave Mitton, Thomas\n   Narten, Erik Nordmark, Josh Osborne,\
    \ Craig Partridge, Jean-Luc\n   Richier, Erik Scoredos, Keith Sklower, Matt Thomas,\
    \ Harvey Thompson,\n   Dean D. Throop, Karen Tracey, Glenn Trewitt, Paul Vixie,\
    \ David\n   Waitzman, Carl Williams, and Kazuhiko Yamamoto,\n   The getaddrinfo()\
    \ and getnameinfo() functions are taken from an\n   earlier Work in Progress by\
    \ Keith Sklower.  As noted in that\n   document, William Durst, Steven Wise, Michael\
    \ Karels, and Eric Allman\n   provided many useful discussions on the subject\
    \ of protocol-\n   independent name-to-address translation, and reviewed early\
    \ versions\n   of Keith Sklower's original proposal.  Eric Allman implemented\
    \ the\n   first prototype of getaddrinfo().  The observation that specifying\n\
    \   the pair of name and service would suffice for connecting to a\n   service\
    \ independent of protocol details was made by Marshall Rose in\n   a proposal\
    \ to X/Open for a \"Uniform Network Interface\".\n   Craig Metz made many contributions\
    \ to this document.  Ramesh Govindan\n   made a number of contributions and co-authored\
    \ an earlier version of\n   this memo.\n"
- title: 10.  References
  contents:
  - "10.  References\n   [1] Deering, S., and R. Hinden, \"Internet Protocol, Version\
    \ 6 (IPv6)\n       Specification\", RFC 1883, December 1995.\n   [2] Hinden, R.,\
    \ and S. Deering, \"IP Version 6 Addressing Architecture\",\n       RFC 1884,\
    \ December 1995.\n   [3] McDonald, D., \"A Simple IP Security API Extension to\
    \ BSD Sockets\",\n       Work in Progress.\n   [4] IEEE, \"Protocol Independent\
    \ Interfaces\", IEEE Std 1003.1g, DRAFT\n       6.3, November 1995.\n   [5] Stevens,\
    \ W., and M. Thomas, \"Advanced Sockets API for IPv6\",\n       Work in Progress.\n\
    \   [6] Vixie, P., \"Reverse Name Lookups of Encapsulated IPv4 Addresses in\n\
    \       IPv6\", Work in Progress.\n"
- title: 11.  Authors' Addresses
  contents:
  - "11.  Authors' Addresses\n    Robert E. Gilligan\n    Freegate Corporation\n \
    \   710 Lakeway Dr.  STE 230\n    Sunnyvale, CA 94086\n    Phone: +1 408 524 4804\n\
    \    EMail: gilligan@freegate.net\n    Susan Thomson\n    Bell Communications\
    \ Research\n    MRE 2P-343, 445 South Street\n    Morristown, NJ 07960\n    Phone:\
    \ +1 201 829 4514\n    EMail: set@thumper.bellcore.com\n    Jim Bound\n    Digital\
    \ Equipment Corporation\n    110 Spitbrook Road ZK3-3/U14\n    Nashua, NH 03062-2698\n\
    \    Phone: +1 603 881 0400\n    Email: bound@zk3.dec.com\n    W. Richard Stevens\n\
    \    1202 E. Paseo del Zorro\n    Tucson, AZ 85718-2826\n    Phone: +1 520 297\
    \ 9416\n    EMail: rstevens@kohala.com\n"
