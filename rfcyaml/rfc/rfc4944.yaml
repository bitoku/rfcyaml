- contents:
  - '        Transmission of IPv6 Packets over IEEE 802.15.4 Networks

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document describes the frame format for transmission of IPv6\n
    \  packets and the method of forming IPv6 link-local addresses and\n   statelessly
    autoconfigured addresses on IEEE 802.15.4 networks.\n   Additional specifications
    include a simple header compression scheme\n   using shared context and provisions
    for packet delivery in IEEE\n   802.15.4 meshes.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  2\n     1.1.  Requirements Notation  . . . . . . . . . . . . . .
    . . . .  3\n     1.2.  Terms Used . . . . . . . . . . . . . . . . . . . . . .
    . .  3\n   2.  IEEE 802.15.4 Mode for IP  . . . . . . . . . . . . . . . . . .
    \ 3\n   3.  Addressing Modes . . . . . . . . . . . . . . . . . . . . . . .  4\n
    \  4.  Maximum Transmission Unit  . . . . . . . . . . . . . . . . . .  5\n   5.
    \ LoWPAN Adaptation Layer and Frame Format . . . . . . . . . . .  6\n     5.1.
    \ Dispatch Type and Header . . . . . . . . . . . . . . . . .  8\n     5.2.  Mesh
    Addressing Type and Header  . . . . . . . . . . . . . 10\n     5.3.  Fragmentation
    Type and Header  . . . . . . . . . . . . . . 11\n   6.  Stateless Address Autoconfiguration
    \ . . . . . . . . . . . . . 13\n   7.  IPv6 Link Local Address  . . . . . . .
    . . . . . . . . . . . . 14\n   8.  Unicast Address Mapping  . . . . . . . . .
    . . . . . . . . . . 14\n   9.  Multicast Address Mapping  . . . . . . . . . .
    . . . . . . . . 16\n   10. Header Compression . . . . . . . . . . . . . . . .
    . . . . . . 16\n     10.1. Encoding of IPv6 Header Fields . . . . . . . . . .
    . . . . 17\n     10.2. Encoding of UDP Header Fields  . . . . . . . . . . . .
    . . 19\n     10.3. Non-Compressed Fields  . . . . . . . . . . . . . . . . . .
    21\n       10.3.1.  Non-Compressed IPv6 Fields  . . . . . . . . . . . . . 21\n
    \      10.3.2.  Non-Compressed and Partially Compressed UDP Fields  . 21\n   11.
    Frame Delivery in a Link-Layer Mesh  . . . . . . . . . . . . . 21\n     11.1.
    LoWPAN Broadcast . . . . . . . . . . . . . . . . . . . . . 23\n   12. IANA Considerations
    \ . . . . . . . . . . . . . . . . . . . . . 23\n   13. Security Considerations
    \ . . . . . . . . . . . . . . . . . . . 25\n   14. Acknowledgements . . . . .
    . . . . . . . . . . . . . . . . . . 25\n   15. References . . . . . . . . . .
    . . . . . . . . . . . . . . . . 26\n     15.1. Normative References . . . . .
    . . . . . . . . . . . . . . 26\n     15.2. Informative References . . . . . .
    . . . . . . . . . . . . 26\n   Appendix A.  Alternatives for Delivery of Frames
    in a Mesh . . . . 28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The IEEE 802.15.4 standard [ieee802.15.4] targets low-power
    personal\n   area networks.  This document defines the frame format for\n   transmission
    of IPv6 [RFC2460] packets as well as the formation of\n   IPv6 link-local addresses
    and statelessly autoconfigured addresses on\n   top of IEEE 802.15.4 networks.
    \ Since IPv6 requires support of packet\n   sizes much larger than the largest
    IEEE 802.15.4 frame size, an\n   adaptation layer is defined.  This document also
    defines mechanisms\n   for header compression required to make IPv6 practical
    on IEEE\n   802.15.4 networks, and the provisions required for packet delivery
    in\n   IEEE 802.15.4 meshes.  However, a full specification of mesh routing\n
    \  (the specific protocol used, the interactions with neighbor\n   discovery,
    etc) is out of the scope of this document.\n"
  - contents:
    - "1.1.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n"
    title: 1.1.  Requirements Notation
  - contents:
    - "1.2.  Terms Used\n   AES:  Advanced Encryption Scheme\n   CSMA/CA:  Carrier
      Sense Multiple Access / Collision Avoidance\n   FFD:  Full Function Device\n
      \  GTS:  Guaranteed Time Service\n   MTU:  Maximum Transmission Unit\n   MAC:
      \ Media Access Control\n   PAN:  Personal Area Network\n   RFD:  Reduced Function
      Device\n"
    title: 1.2.  Terms Used
  title: 1.  Introduction
- contents:
  - "2.  IEEE 802.15.4 Mode for IP\n   IEEE 802.15.4 defines four types of frames:
    beacon frames, MAC\n   command frames, acknowledgement frames, and data frames.
    \ IPv6\n   packets MUST be carried on data frames.  Data frames may optionally\n
    \  request that they be acknowledged.  In keeping with [RFC3819], it is\n   recommended
    that IPv6 packets be carried in frames for which\n   acknowledgements are requested
    so as to aid link-layer recovery.\n   IEEE 802.15.4 networks can either be nonbeacon-enabled
    or beacon-\n   enabled [ieee802.15.4].  The latter is an optional mode in which\n
    \  devices are synchronized by a so-called coordinator's beacons.  This\n   allows
    the use of superframes within which a contention-free\n   Guaranteed Time Service
    (GTS) is possible.  This document does not\n   require that IEEE networks run
    in beacon-enabled mode.  In nonbeacon-\n   enabled networks, data frames (including
    those carrying IPv6 packets)\n   are sent via the contention-based channel access
    method of unslotted\n   CSMA/CA.\n   In nonbeacon-enabled networks, beacons are
    not used for\n   synchronization.  However, they are still useful for link-layer\n
    \  device discovery to aid in association and disassociation events.\n   This
    document recommends that beacons be configured so as to aid\n   these functions.
    \ A further recommendation is for these events to be\n   available at the IPv6
    layer to aid in detecting network attachment, a\n   problem being worked on at
    the IETF at the time of this writing.\n   The specification allows for frames
    in which either the source or\n   destination addresses (or both) are elided.
    \ The mechanisms defined\n   in this document require that both source and destination
    addresses\n   be included in the IEEE 802.15.4 frame header.  The source or\n
    \  destination PAN ID fields may also be included.\n"
  title: 2.  IEEE 802.15.4 Mode for IP
- contents:
  - "3.  Addressing Modes\n   IEEE 802.15.4 defines several addressing modes: it allows
    the use of\n   either IEEE 64-bit extended addresses or (after an association
    event)\n   16-bit addresses unique within the PAN [ieee802.15.4].  This document\n
    \  supports both 64-bit extended addresses, and 16-bit short addresses.\n   For
    use within 6LoWPANs, this document imposes additional constraints\n   (beyond
    those imposed by IEEE 802.15.4) on the format of the 16-bit\n   short addresses,
    as specified in Section 12.  Short addresses being\n   transient in nature, a
    word of caution is in order: since they are\n   doled out by the PAN coordinator
    function during an association\n   event, their validity and uniqueness is limited
    by the lifetime of\n   that association.  This can be cut short by the expiration
    of the\n   association or simply by any mishap occurring to the PAN coordinator.\n
    \  Because of the scalability issues posed by such a centralized\n   allocation
    and single point of failure at the PAN coordinator,\n   deployers should carefully
    weigh the tradeoffs (and implement the\n   necessary mechanisms) of growing such
    networks based on short\n   addresses.  Of course, IEEE 64-bit extended addresses
    may not suffer\n   from these drawbacks, but still share the remaining scalability\n
    \  issues concerning routing, discovery, configuration, etc.\n   This document
    assumes that a PAN maps to a specific IPv6 link.  This\n   complies with the recommendation
    that shared networks support link-\n   layer subnet [RFC3819] broadcast.  Strictly
    speaking, it is multicast\n   not broadcast that exists in IPv6.  However, multicast
    is not\n   supported natively in IEEE 802.15.4.  Hence, IPv6 level multicast\n
    \  packets MUST be carried as link-layer broadcast frames in IEEE\n   802.15.4
    networks.  This MUST be done such that the broadcast frames\n   are only heeded
    by devices within the specific PAN of the link in\n   question.  As per Section
    7.5.6.2 in [ieee802.15.4], this is\n   accomplished as follows:\n   1.  A destination
    PAN identifier is included in the frame, and it\n       MUST match the PAN ID
    of the link in question.\n   2.  A short destination address is included in the
    frame, and it MUST\n       match the broadcast address (0xffff).\n   Additionally,
    support for mapping of IPv6 multicast addresses per\n   Section 9 MUST only be
    used in a mesh configuration.  A full\n   specification of such functionality
    is out of the scope of this\n   document.\n   As usual, hosts learn IPv6 prefixes
    via router advertisements as per\n   [RFC4861].\n"
  title: 3.  Addressing Modes
- contents:
  - "4.  Maximum Transmission Unit\n   The MTU size for IPv6 packets over IEEE 802.15.4
    is 1280 octets.\n   However, a full IPv6 packet does not fit in an IEEE 802.15.4
    frame.\n   802.15.4 protocol data units have different sizes depending on how\n
    \  much overhead is present [ieee802.15.4].  Starting from a maximum\n   physical
    layer packet size of 127 octets (aMaxPHYPacketSize) and a\n   maximum frame overhead
    of 25 (aMaxFrameOverhead), the resultant\n   maximum frame size at the media access
    control layer is 102 octets.\n   Link-layer security imposes further overhead,
    which in the maximum\n   case (21 octets of overhead in the AES-CCM-128 case,
    versus 9 and 13\n   for AES-CCM-32 and AES-CCM-64, respectively) leaves only 81
    octets\n   available.  This is obviously far below the minimum IPv6 packet size\n
    \  of 1280 octets, and in keeping with Section 5 of the IPv6\n   specification
    [RFC2460], a fragmention and reassembly adaptation\n   layer must be provided
    at the layer below IP.  Such a layer is\n   defined below in Section 5.\n   Furthermore,
    since the IPv6 header is 40 octets long, this leaves\n   only 41 octets for upper-layer
    protocols, like UDP.  The latter uses\n   8 octets in the header which leaves
    only 33 octets for application\n   data.  Additionally, as pointed out above,
    there is a need for a\n   fragmentation and reassembly layer, which will use even
    more octets.\n   The above considerations lead to the following two observations:\n
    \  1.  The adaptation layer must be provided to comply with the IPv6\n       requirements
    of a minimum MTU.  However, it is expected that (a)\n       most applications
    of IEEE 802.15.4 will not use such large\n       packets, and (b) small application
    payloads in conjunction with\n       the proper header compression will produce
    packets that fit\n       within a single IEEE 802.15.4 frame.  The justification
    for this\n       adaptation layer is not just for IPv6 compliance, as it is quite\n
    \      likely that the packet sizes produced by certain application\n       exchanges
    (e.g., configuration or provisioning) may require a\n       small number of fragments.\n
    \  2.  Even though the above space calculation shows the worst-case\n       scenario,
    it does point out the fact that header compression is\n       compelling to the
    point of almost being unavoidable.  Since we\n       expect that most (if not
    all) applications of IP over IEEE\n       802.15.4 will make use of header compression,
    it is defined below\n       in Section 10.\n"
  title: 4.  Maximum Transmission Unit
- contents:
  - "5.  LoWPAN Adaptation Layer and Frame Format\n   The encapsulation formats defined
    in this section (subsequently\n   referred to as the \"LoWPAN encapsulation\")
    are the payload in the\n   IEEE 802.15.4 MAC protocol data unit (PDU).  The LoWPAN
    payload\n   (e.g., an IPv6 packet) follows this encapsulation header.\n   All
    LoWPAN encapsulated datagrams transported over IEEE 802.15.4 are\n   prefixed
    by an encapsulation header stack.  Each header in the header\n   stack contains
    a header type followed by zero or more header fields.\n   Whereas in an IPv6 header
    the stack would contain, in the following\n   order, addressing, hop-by-hop options,
    routing, fragmentation,\n   destination options, and finally payload [RFC2460];
    in a LoWPAN\n   header, the analogous header sequence is mesh (L2) addressing,
    hop-\n   by-hop options (including L2 broadcast/multicast), fragmentation, and\n
    \  finally payload.  These examples show typical header stacks that may\n   be
    used in a LoWPAN network.\n   A LoWPAN encapsulated IPv6 datagram:\n      +---------------+-------------+---------+\n
    \     | IPv6 Dispatch | IPv6 Header | Payload |\n      +---------------+-------------+---------+\n
    \  A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram:\n      +--------------+------------+---------+\n
    \     | HC1 Dispatch | HC1 Header | Payload |\n      +--------------+------------+---------+\n
    \  A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram that\n   requires
    mesh addressing:\n      +-----------+-------------+--------------+------------+---------+\n
    \     | Mesh Type | Mesh Header | HC1 Dispatch | HC1 Header | Payload |\n      +-----------+-------------+--------------+------------+---------+\n
    \  A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram that\n   requires
    fragmentation:\n      +-----------+-------------+--------------+------------+---------+\n
    \     | Frag Type | Frag Header | HC1 Dispatch | HC1 Header | Payload |\n      +-----------+-------------+--------------+------------+---------+\n
    \  A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram that\n   requires
    both mesh addressing and fragmentation:\n      +-------+-------+-------+-------+---------+---------+---------+\n
    \     | M Typ | M Hdr | F Typ | F Hdr | HC1 Dsp | HC1 Hdr | Payload |\n      +-------+-------+-------+-------+---------+---------+---------+\n
    \  A LoWPAN encapsulated LOWPAN_HC1 compressed IPv6 datagram that\n   requires
    both mesh addressing and a broadcast header to support mesh\n   broadcast/multicast:\n
    \     +-------+-------+-------+-------+---------+---------+---------+\n      |
    M Typ | M Hdr | B Dsp | B Hdr | HC1 Dsp | HC1 Hdr | Payload |\n      +-------+-------+-------+-------+---------+---------+---------+\n
    \  When more than one LoWPAN header is used in the same packet, they\n   MUST
    appear in the following order:\n      Mesh Addressing Header\n      Broadcast
    Header\n      Fragmentation Header\n   All protocol datagrams (e.g., IPv6, compressed
    IPv6 headers, etc.)\n   SHALL be preceded by one of the valid LoWPAN encapsulation
    headers,\n   examples of which are given above.  This permits uniform software\n
    \  treatment of datagrams without regard to the mode of their\n   transmission.\n
    \  The definition of LoWPAN headers, other than mesh addressing and\n   fragmentation,
    consists of the dispatch value, the definition of the\n   header fields that follow,
    and their ordering constraints relative to\n   all other headers.  Although the
    header stack structure provides a\n   mechanism to address future demands on the
    LoWPAN adaptation layer,\n   it is not intended to provided general purpose extensibility.
    \ This\n   format document specifies a small set of header types using the\n   header
    stack for clarity, compactness, and orthogonality.\n"
  - contents:
    - "5.1.  Dispatch Type and Header\n   The dispatch type is defined by a zero bit
      as the first bit and a one\n   bit as the second bit.  The dispatch type and
      header are shown here:\n                        1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |0 1| Dispatch  |  type-specific header\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Dispatch               6-bit selector.  Identifies the type of header\n                          immediately
      following the Dispatch Header.\n   type-specific header   A header determined
      by the Dispatch Header.\n                    Figure 1: Dispatch Type and Header\n
      \  The dispatch value may be treated as an unstructured namespace.  Only\n   a
      few symbols are required to represent current LoWPAN functionality.\n   Although
      some additional savings could be achieved by encoding\n   additional functionality
      into the dispatch byte, these measures would\n   tend to constrain the ability
      to address future alternatives.\n           Pattern    Header Type\n         +------------+-----------------------------------------------+\n
      \        | 00  xxxxxx | NALP       - Not a LoWPAN frame               |\n         |
      01  000001 | IPv6       - Uncompressed IPv6 Addresses      |\n         | 01
      \ 000010 | LOWPAN_HC1 - LOWPAN_HC1 compressed IPv6       |\n         | 01  000011
      | reserved   - Reserved for future use          |\n         |   ...      | reserved
      \  - Reserved for future use          |\n         | 01  001111 | reserved   -
      Reserved for future use          |\n         | 01  010000 | LOWPAN_BC0 - LOWPAN_BC0
      broadcast             |\n         | 01  010001 | reserved   - Reserved for future
      use          |\n         |   ...      | reserved   - Reserved for future use
      \         |\n         | 01  111110 | reserved   - Reserved for future use          |\n
      \        | 01  111111 | ESC        - Additional Dispatch byte follows |\n         |
      10  xxxxxx | MESH       - Mesh Header                      |\n         | 11
      \ 000xxx | FRAG1      - Fragmentation Header (first)     |\n         | 11  001000
      | reserved   - Reserved for future use          |\n         |   ...      | reserved
      \  - Reserved for future use          |\n         | 11  011111 | reserved   -
      Reserved for future use          |\n         | 11  100xxx | FRAGN      - Fragmentation
      Header (subsequent)|\n         | 11  101000 | reserved   - Reserved for future
      use          |\n         |   ...      | reserved   - Reserved for future use
      \         |\n         | 11  111111 | reserved   - Reserved for future use          |\n
      \        +------------+-----------------------------------------------+\n                   Figure
      2: Dispatch Value Bit Pattern\n   NALP:  Specifies that the following bits are
      not a part of the LoWPAN\n      encapsulation, and any LoWPAN node that encounters
      a dispatch\n      value of 00xxxxxx shall discard the packet.  Other non-LoWPAN\n
      \     protocols that wish to coexist with LoWPAN nodes should include a\n      byte
      matching this pattern immediately following the 802.15.4.\n      header.\n   IPv6:
      \ Specifies that the following header is an uncompressed IPv6\n      header
      [RFC2460].\n   LOWPAN_HC1:  Specifies that the following header is a LOWPAN_HC1\n
      \     compressed IPv6 header.  This header format is defined in\n      Figure
      9.\n   LOWPAN_BC0:  Specifies that the following header is a LOWPAN_BC0\n      header
      for mesh broadcast/multicast support and is described in\n      Section 11.1.\n
      \  ESC:  Specifies that the following header is a single 8-bit field for\n      the
      Dispatch value.  It allows support for Dispatch values larger\n      than 127.\n"
    title: 5.1.  Dispatch Type and Header
  - contents:
    - "5.2.  Mesh Addressing Type and Header\n   The mesh type is defined by a one
      bit and zero bit as the first two\n   bits.  The mesh type and header are shown
      here:\n                           1                   2                   3\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |1 0|V|F|HopsLft| originator address, final address\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                Figure 3: Mesh Addressing Type and Header\n   Field definitions
      are as follows:\n   V: This 1-bit field SHALL be zero if the Originator (or
      \"Very first\")\n      Address is an IEEE extended 64-bit address (EUI-64),
      or 1 if it is\n      a short 16-bit addresses.\n   F: This 1-bit field SHALL
      be zero if the Final Destination Address is\n      an IEEE extended 64-bit address
      (EUI-64), or 1 if it is a short\n      16-bit addresses.\n   Hops Left:  This
      4-bit field SHALL be decremented by each forwarding\n      node before sending
      this packet towards its next hop.  The packet\n      is not forwarded any further
      if Hops Left is decremented to zero.\n      The value 0xF is reserved and signifies
      an 8-bit Deep Hops Left\n      field immediately following, and allows a source
      node to specify a\n      hop limit greater than 14 hops.\n   Originator Address:
      \ This is the link-layer address of the\n      Originator.\n   Final Destination
      Address:  This is the link-layer address of the\n      Final Destination.\n
      \  Note that the 'V' and 'F' bits allow for a mix of 16 and 64-bit\n   addresses.
      \ This is useful at least to allow for mesh layer\n   \"broadcast\", as 802.15.4
      broadcast addresses are defined as 16-bit\n   short addresses.\n   A further
      discussion of frame delivery within a mesh is in\n   Section 11.\n"
    title: 5.2.  Mesh Addressing Type and Header
  - contents:
    - "5.3.  Fragmentation Type and Header\n   If an entire payload (e.g., IPv6) datagram
      fits within a single\n   802.15.4 frame, it is unfragmented and the LoWPAN encapsulation\n
      \  should not contain a fragmentation header.  If the datagram does not\n   fit
      within a single IEEE 802.15.4 frame, it SHALL be broken into link\n   fragments.
      \ As the fragment offset can only express multiples of\n   eight bytes, all
      link fragments for a datagram except the last one\n   MUST be multiples of eight
      bytes in length.  The first link fragment\n   SHALL contain the first fragment
      header as defined below.\n                           1                   2                   3\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |1 1 0 0 0|    datagram_size    |         datagram_tag          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                        Figure 4: First Fragment\n   The second and subsequent
      link fragments (up to and including the\n   last) SHALL contain a fragmentation
      header that conforms to the\n   format shown below.\n                           1
      \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |1 1 1 0 0|    datagram_size    |         datagram_tag          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |datagram_offset|\n      +-+-+-+-+-+-+-+-+\n                      Figure
      5: Subsequent Fragments\n   datagram_size:  This 11-bit field encodes the size
      of the entire IP\n      packet before link-layer fragmentation (but after IP
      layer\n      fragmentation).  The value of datagram_size SHALL be the same for\n
      \     all link-layer fragments of an IP packet.  For IPv6, this SHALL be\n      40
      octets (the size of the uncompressed IPv6 header) more than the\n      value
      of Payload Length in the IPv6 header [RFC2460] of the\n      packet.  Note that
      this packet may already be fragmented by hosts\n      involved in the communication,
      i.e., this field needs to encode a\n      maximum length of 1280 octets (the
      IEEE 802.15.4 link MTU, as\n      defined in this document).\n      NOTE: This
      field does not need to be in every packet, as one could\n      send it with
      the first fragment and elide it subsequently.\n      However, including it in
      every link fragment eases the task of\n      reassembly in the event that a
      second (or subsequent) link\n      fragment arrives before the first.  In this
      case, the guarantee of\n      learning the datagram_size as soon as any of the
      fragments arrives\n      tells the receiver how much buffer space to set aside
      as it waits\n      for the rest of the fragments.  The format above trades off\n
      \     simplicity for efficiency.\n   datagram_tag:  The value of datagram_tag
      (datagram tag) SHALL be the\n      same for all link fragments of a payload
      (e.g., IPv6) datagram.\n      The sender SHALL increment datagram_tag for successive,
      fragmented\n      datagrams.  The incremented value of datagram_tag SHALL wrap
      from\n      65535 back to zero.  This field is 16 bits long, and its initial\n
      \     value is not defined.\n   datagram_offset:  This field is present only
      in the second and\n      subsequent link fragments and SHALL specify the offset,
      in\n      increments of 8 octets, of the fragment from the beginning of the\n
      \     payload datagram.  The first octet of the datagram (e.g., the\n      start
      of the IPv6 header) has an offset of zero; the implicit\n      value of datagram_offset
      in the first link fragment is zero.  This\n      field is 8 bits long.\n   The
      recipient of link fragments SHALL use (1) the sender's 802.15.4\n   source address
      (or the Originator Address if a Mesh Addressing field\n   is present), (2) the
      destination's 802.15.4 address (or the Final\n   Destination address if a Mesh
      Addressing field is present), (3)\n   datagram_size, and (4) datagram_tag to
      identify all the link\n   fragments that belong to a given datagram.\n   Upon
      receipt of a link fragment, the recipient starts constructing\n   the original
      unfragmented packet whose size is datagram_size.  It\n   uses the datagram_offset
      field to determine the location of the\n   individual fragments within the original
      unfragmented packet.  For\n   example, it may place the data payload (except
      the encapsulation\n   header) within a payload datagram reassembly buffer at
      the location\n   specified by datagram_offset.  The size of the reassembly buffer\n
      \  SHALL be determined from datagram_size.\n   If a link fragment that overlaps
      another fragment is received, as\n   identified above, and differs in either
      the size or datagram_offset\n   of the overlapped fragment, the fragment(s)
      already accumulated in\n   the reassembly buffer SHALL be discarded.  A fresh
      reassembly may be\n   commenced with the most recently received link fragment.
      \ Fragment\n   overlap is determined by the combination of datagram_offset from
      the\n   encapsulation header and \"Frame Length\" from the 802.15.4 Physical\n
      \  Layer Protocol Data Unit (PPDU) packet header.\n   Upon detection of a IEEE
      802.15.4 Disassociation event, fragment\n   recipients MUST discard all link
      fragments of all partially\n   reassembled payload datagrams, and fragment senders
      MUST discard all\n   not yet transmitted link fragments of all partially transmitted\n
      \  payload (e.g., IPv6) datagrams.  Similarly, when a node first\n   receives
      a fragment with a given datagram_tag, it starts a reassembly\n   timer.  When
      this time expires, if the entire packet has not been\n   reassembled, the existing
      fragments MUST be discarded and the\n   reassembly state MUST be flushed.  The
      reassembly timeout MUST be set\n   to a maximum of 60 seconds (this is also
      the timeout in the IPv6\n   reassembly procedure [RFC2460]).\n"
    title: 5.3.  Fragmentation Type and Header
  title: 5.  LoWPAN Adaptation Layer and Frame Format
- contents:
  - "6.  Stateless Address Autoconfiguration\n   This section defines how to obtain
    an IPv6 interface identifier.\n   The Interface Identifier [RFC4291] for an IEEE
    802.15.4 interface may\n   be based on the EUI-64 identifier [EUI64] assigned
    to the IEEE\n   802.15.4 device.  In this case, the Interface Identifier is formed\n
    \  from the EUI-64 according to the \"IPv6 over Ethernet\" specification\n   [RFC2464].\n
    \  All 802.15.4 devices have an IEEE EUI-64 address, but 16-bit short\n   addresses
    (Section 3 and Section 12) are also possible.  In these\n   cases, a \"pseudo
    48-bit address\" is formed as follows.  First, the\n   left-most 32 bits are formed
    by concatenating 16 zero bits to the 16-\n   bit PAN ID (alternatively, if no
    PAN ID is known, 16 zero bits may be\n   used).  This produces a 32-bit field
    as follows:\n      16_bit_PAN:16_zero_bits\n   Then, these 32 bits are concatenated
    with the 16-bit short address.\n   This produces a 48-bit address as follows:\n
    \     32_bits_as_specified_previously:16_bit_short_address\n   The interface identifier
    is formed from this 48-bit address as per\n   the \"IPv6 over Ethernet\" specification
    [RFC2464].  However, in the\n   resultant interface identifier, the \"Universal/Local\"
    (U/L) bit SHALL\n   be set to zero in keeping with the fact that this is not a
    globally\n   unique value.  For either address format, all zero addresses MUST
    NOT\n   be used.\n   A different MAC address set manually or by software MAY be
    used to\n   derive the Interface Identifier.  If such a MAC address is used, its\n
    \  global uniqueness property should be reflected in the value of the\n   U/L
    bit.\n   An IPv6 address prefix used for stateless autoconfiguration [RFC4862]\n
    \  of an IEEE 802.15.4 interface MUST have a length of 64 bits.\n"
  title: 6.  Stateless Address Autoconfiguration
- contents:
  - "7.  IPv6 Link Local Address\n   The IPv6 link-local address [RFC4291] for an
    IEEE 802.15.4 interface\n   is formed by appending the Interface Identifier, as
    defined above, to\n   the prefix FE80::/64.\n          10 bits            54 bits
    \                 64 bits\n       +----------+-----------------------+----------------------------+\n
    \      |1111111010|         (zeros)       |    Interface Identifier    |\n       +----------+-----------------------+----------------------------+\n
    \                                Figure 6\n"
  title: 7.  IPv6 Link Local Address
- contents:
  - "8.  Unicast Address Mapping\n   The address resolution procedure for mapping
    IPv6 non-multicast\n   addresses into IEEE 802.15.4 link-layer addresses follows
    the general\n   description in Section 7.2 of [RFC4861], unless otherwise specified.\n
    \  The Source/Target Link-layer Address option has the following forms\n   when
    the link layer is IEEE 802.15.4 and the addresses are EUI-64 or\n   16-bit short
    addresses, respectively.\n                       0                   1\n                       0
    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |     Type      |    Length=2   |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |                               |\n                      +-
    \       IEEE 802.15.4        -+\n                      |          EUI-64               |\n
    \                     +-                             -+\n                      |
    \                              |\n                      +-         Address             -+\n
    \                     |                               |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |                               |\n                      +-
    \        Padding             -+\n                      |                               |\n
    \                     +-        (all zeros)          -+\n                      |
    \                              |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                      0                   1\n                       0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |     Type      |    Length=1   |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |     16-bit short Address      |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |                               |\n                      +-
    \        Padding             -+\n                      |         (all zeros)           |\n
    \                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                 Figure
    7\n   Option fields:\n   Type:\n      1: for Source Link-layer address.\n      2:
    for Target Link-layer address.\n   Length:  This is the length of this option
    (including the type and\n      length fields) in units of 8 octets.  The value
    of this field is 2\n      if using EUI-64 addresses, or 1 if using 16-bit short
    addresses.\n   IEEE 802.15.4 Address:  The 64-bit IEEE 802.15.4 address, or the
    16-\n      bit short address (as per the format in Section 9), in canonical\n
    \     bit order.  This is the address the interface currently responds\n      to.
    \ This address may be different from the built-in address used\n      to derive
    the Interface Identifier, because of privacy or security\n      (e.g., of neighbor
    discovery) considerations.\n"
  title: 8.  Unicast Address Mapping
- contents:
  - "9.  Multicast Address Mapping\n   The functionality in this section MUST only
    be used in a mesh-enabled\n   LoWPAN.  An IPv6 packet with a multicast destination
    address (DST),\n   consisting of the sixteen octets DST[1] through DST[16], is\n
    \  transmitted to the following 802.15.4 16-bit multicast address:\n                       0
    \                  1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n
    \                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      |1
    0 0|DST[15]* |   DST[16]     |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                                Figure 8\n   Here, DST[15]* refers to the last
    5 bits in octet DST[15], that is,\n   bits 3-7 within DST[15].  The initial 3-bit
    pattern of \"100\" follows\n   the 16-bit address format for multicast addresses
    (Section 12).\n   This allows for multicast support within 6LoWPAN networks, but
    the\n   full specification of such support is out of the scope of this\n   document.
    \ Example mechanisms are: flooding, controlled flooding,\n   unicasting to the
    PAN coordinator, etc.  It is expected that this\n   would be specified by the
    different mesh routing mechanisms.\n"
  title: 9.  Multicast Address Mapping
- contents:
  - "10.  Header Compression\n   There is much published and in-progress standardization
    work on\n   header compression.  Nevertheless, header compression for IPv6 over\n
    \  IEEE 802.15.4 has differing constraints summarized as follows:\n      Existing
    work assumes that there are many flows between any two\n      devices.  Here,
    we assume a very simple and low-context flavor of\n      header compression.  Whereas
    this works independently of flows\n      (potentially several), it does not use
    any context specific to any\n      flow.  Thus, it cannot achieve as much compression
    as schemes that\n      build a separate context for each flow to be compressed.\n
    \     Given the very limited packet sizes, it is highly desirable to\n      integrate
    layer 2 with layer 3 compression, something\n      traditionally not done (although
    now changing due to the ROHC\n      (RObust Header Compression) working group).\n
    \     It is expected that IEEE 802.15.4 devices will be deployed in\n      multi-hop
    networks.  However, header compression in a mesh departs\n      from the usual
    point-to-point link scenario in which the\n      compressor and decompressor are
    in direct and exclusive\n      communication with each other.  In an IEEE 802.15.4
    network, it is\n      highly desirable for a device to be able to send header
    compressed\n      packets via any of its neighbors, with as little preliminary\n
    \     context-building as possible.\n   Any new packet formats required by header
    compression reuse the basic\n   packet formats defined in Section 5 by using different
    dispatch\n   values.\n   Header compression may result in alignment not falling
    on an octet\n   boundary.  Since hardware typically cannot transmit data in units\n
    \  less than an octet, padding must be used.  Padding is done as\n   follows:
    First, the entire series of contiguous compressed headers is\n   laid out (this
    document only defines IPv6 and UDP header compression\n   schemes, but others
    may be defined elsewhere).  Then, zero bits\n   SHOULD be added as appropriate
    to align to an octet boundary.  This\n   counteracts any potential misalignment
    caused by header compression,\n   so subsequent fields (e.g., non-compressed headers
    or data payloads)\n   start on an octet boundary and follow as usual.\n"
  - contents:
    - "10.1.  Encoding of IPv6 Header Fields\n   By virtue of having joined the same
      6LoWPAN network, devices share\n   some state.  This makes it possible to compress
      headers without\n   explicitly building any compression context state.  Therefore,\n
      \  6LoWPAN header compression does not keep any flow state; instead, it\n   relies
      on information pertaining to the entire link.  The following\n   IPv6 header
      values are expected to be common on 6LoWPAN networks, so\n   the HC1 header
      has been constructed to efficiently compress them from\n   the onset: Version
      is IPv6; both IPv6 source and destination\n   addresses are link local; the
      IPv6 interface identifiers (bottom 64\n   bits) for the source or destination
      addresses can be inferred from\n   the layer two source and destination addresses
      (of course, this is\n   only possible for interface identifiers derived from
      an underlying\n   802.15.4 MAC address); the packet length can be inferred either
      from\n   layer two (\"Frame Length\" in the IEEE 802.15.4 PPDU) or from the\n
      \  \"datagram_size\" field in the fragment header (if present); both the\n   Traffic
      Class and the Flow Label are zero; and the Next Header is\n   UDP, ICMP or TCP.
      \ The only field in the IPv6 header that always\n   needs to be carried in full
      is the Hop Limit (8 bits).  Depending on\n   how closely the packet matches
      this common case, different fields may\n   not be compressible thus needing
      to be carried \"in-line\" as well\n   (Section 10.3.1).  This common IPv6 header
      (as mentioned above) can\n   be compressed to 2 octets (1 octet for the HC1
      encoding and 1 octet\n   for the Hop Limit), instead of 40 octets.  Such a packet
      is\n   compressible via the LOWPAN_HC1 format by using a Dispatch value of\n
      \  LOWPAN_HC1 followed by a LOWPAN_HC1 header \"HC1 encoding\" field (8\n   bits)
      to encode the different combinations as shown below.  This\n   header may be
      preceded by a fragmentation header, which may be\n   preceded by a mesh header.\n
      \                          1                   2                   3\n       0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     | HC1 encoding  |     Non-Compressed fields follow...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        Figure 9: LOWPAN_HC1 (common compressed header encoding)\n   As can
      be seen below (bit 7), an HC2 encoding may follow an HC1\n   octet.  In this
      case, the non-compressed fields follow the HC2\n   encoding field (Section 10.3).\n
      \  The address fields encoded by \"HC1 encoding\" are interpreted as\n   follows:\n
      \     PI:  Prefix carried in-line (Section 10.3.1).\n      PC:  Prefix compressed
      (link-local prefix assumed).\n      II:  Interface identifier carried in-line
      (Section 10.3.1).\n      IC:  Interface identifier elided (derivable from the
      corresponding\n         link-layer address).  If applied to the interface identifier
      of\n         either the source or destination address when routing in a mesh\n
      \        (Section 11), the corresponding link-layer address is that\n         found
      in the \"Mesh Addressing\" field (Section 5.2).\n   The \"HC1 encoding\" is
      shown below (starting with bit 0 and ending at\n   bit 7):\n      IPv6 source
      address (bits 0 and 1):\n         00:  PI, II\n         01:  PI, IC\n         10:
      \ PC, II\n         11:  PC, IC\n      IPv6 destination address (bits 2 and 3):\n
      \        00:  PI, II\n         01:  PI, IC\n         10:  PC, II\n         11:
      \ PC, IC\n      Traffic Class and Flow Label (bit 4):\n         0: not compressed;
      full 8 bits for Traffic Class and 20 bits\n            for Flow Label are sent\n
      \        1: Traffic Class and Flow Label are zero\n      Next Header (bits 5
      and 6):\n         00:  not compressed; full 8 bits are sent\n         01:  UDP\n
      \        10:  ICMP\n         11:  TCP\n      HC2 encoding(bit 7):\n         0:
      No more header compression bits\n         1: HC1 encoding immediately followed
      by more header compression\n            bits per HC2 encoding format.  Bits
      5 and 6 determine which\n            of the possible HC2 encodings apply (e.g.,
      UDP, ICMP, or TCP\n            encodings).\n"
    title: 10.1.  Encoding of IPv6 Header Fields
  - contents:
    - "10.2.  Encoding of UDP Header Fields\n   Bits 5 and 6 of the LOWPAN_HC1 allows
      compressing the Next Header\n   field in the IPv6 header (for UDP, TCP, and
      ICMP).  Further\n   compression of each of these protocol headers is also possible.
      \ This\n   section explains how the UDP header itself may be compressed.  The\n
      \  HC2 encoding in this section is the HC_UDP encoding, and it only\n   applies
      if bits 5 and 6 in HC1 indicate that the protocol that\n   follows the IPv6
      header is UDP.  The HC_UDP encoding (Figure 10)\n   allows compressing the following
      fields in the UDP header: source\n   port, destination port, and length.  The
      UDP header's checksum field\n   is not compressed and is therefore carried in
      full.  The scheme\n   defined below allows compressing the UDP header to 4 octets
      instead\n   of the original 8 octets.\n   The only UDP header field whose value
      may be deduced from information\n   available elsewhere is the Length.  The
      other fields must be carried\n   in-line either in full or in a partially compressed
      manner\n   (Section 10.3.2).\n                           1                   2
      \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |HC_UDP encoding|     Fields carried in-line follow...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        Figure 10: HC_UDP (UDP common compressed header encoding)\n   The \"HC_UDP
      encoding\" for UDP is shown below (starting with bit 0 and\n   ending at bit
      7):\n      UDP source port (bit 0):\n         0: Not compressed, carried \"in-line\"
      (Section 10.3.2)\n         1: Compressed to 4 bits.  The actual 16-bit source
      port is\n            obtained by calculating: P + short_port value.  The value
      of\n            P is the number 61616 (0xF0B0).  The short_port is expressed\n
      \           as a 4-bit value which is carried \"in-line\" (Section 10.3.2)\n
      \     UDP destination port (bit 1):\n         0: Not compressed, carried \"in-line\"
      (Section 10.3.2)\n         1: Compressed to 4 bits.  The actual 16-bit destination
      port is\n            obtained by calculating: P + short_port value.  The value
      of\n            P is the number 61616 (0xF0B0).  The short_port is expressed\n
      \           as a 4-bit value which is carried \"in-line\" (Section 10.3.2)\n
      \     Length (bit 2):\n         0: not compressed, carried \"in-line\" (Section
      10.3.2)\n         1: compressed, length computed from IPv6 header length\n            information.
      \ The value of the UDP length field is equal to\n            the Payload Length
      from the IPv6 header, minus the length of\n            any extension headers
      present between the IPv6 header and\n            the UDP header.\n      Reserved
      (bit 3 through 7)\n"
    title: 10.2.  Encoding of UDP Header Fields
  - contents:
    - '10.3.  Non-Compressed Fields

      '
    - contents:
      - "10.3.1.  Non-Compressed IPv6 Fields\n   This scheme allows the IPv6 header
        to be compressed to different\n   degrees.  Hence, instead of the entire (standard)
        IPv6 header, only\n   non-compressed fields need to be sent.  The subsequent
        header (as\n   specified by the Next Header field in the original IPv6 header)\n
        \  immediately follows the IPv6 non-compressed fields.\n   Uncompressed IPv6
        addressing is described by a dispatch type\n   containing an IPv6 dispatch
        value followed by the uncompressed IPv6\n   header.  This dispatch type may
        be preceded by additional LoWPAN\n   headers.\n   The non-compressed IPv6
        field that MUST be always present is the Hop\n   Limit (8 bits).  This field
        MUST always follow the encoding fields\n   (e.g., \"HC1 encoding\" as shown
        in Figure 9), perhaps including other\n   future encoding fields).  Other
        non-compressed fields MUST follow the\n   Hop Limit as implied by the \"HC1
        encoding\" in the exact same order as\n   shown above (Section 10.1): source
        address prefix (64 bits) and/or\n   interface identifier (64 bits), destination
        address prefix (64 bits)\n   and/or interface identifier (64 bits), Traffic
        Class (8 bits), Flow\n   Label (20 bits) and Next Header (8 bits).  The actual
        next header\n   (e.g., UDP, TCP, ICMP, etc) follows the non-compressed fields.\n"
      title: 10.3.1.  Non-Compressed IPv6 Fields
    - contents:
      - "10.3.2.  Non-Compressed and Partially Compressed UDP Fields\n   This scheme
        allows the UDP header to be compressed to different\n   degrees.  Hence, instead
        of the entire (standard) UDP header, only\n   non-compressed or partially
        compressed fields need to be sent.\n   The non-compressed or partially compressed
        fields in the UDP header\n   MUST always follow the IPv6 header and any of
        its associated in-line\n   fields.  Any UDP header in-line fields present
        MUST appear in the\n   same order as the corresponding fields appear in a
        normal UDP header\n   [RFC0768], e.g., source port, destination port, length,
        and checksum.\n   If either the source or destination ports are in \"short_port\"\n
        \  notation (as indicated in the compressed UDP header), then instead of\n
        \  taking 16 bits, the inline port numbers take 4 bits.\n"
      title: 10.3.2.  Non-Compressed and Partially Compressed UDP Fields
    title: 10.3.  Non-Compressed Fields
  title: 10.  Header Compression
- contents:
  - "11.  Frame Delivery in a Link-Layer Mesh\n   Even though 802.15.4 networks are
    expected to commonly use mesh\n   routing, the IEEE 802.15.4-2003 specification
    [ieee802.15.4] does not\n   define such capability.  In such cases, Full Function
    Devices (FFDs)\n   run an ad hoc or mesh routing protocol to populate their routing\n
    \  tables (outside the scope of this document).  In such mesh scenarios,\n   two
    devices do not require direct reachability in order to\n   communicate.  Of these
    devices, the sender is known as the\n   \"Originator\", and the receiver is known
    as the \"Final Destination\".\n   An originator device may use other intermediate
    devices as forwarders\n   towards the final destination.  In order to achieve
    such frame\n   delivery using unicast, it is necessary to include the link-layer\n
    \  addresses of the originator and final destinations, in addition to\n   the
    hop-by-hop source and destination.\n   This section defines how to effect delivery
    of layer 2 frames in a\n   mesh, given a target \"Final Destination\" link-layer
    address.\n   Mesh delivery is enabled by including a Mesh Addressing header prior\n
    \  to any other headers of the LoWPAN encapsulation (Section 5), an\n   unfragmented
    and fragmented header; a full-blown IPv6 header; or a\n   compressed IPv6 header
    as per Section 10 or any others defined\n   elsewhere.\n   If a node wishes to
    use a default mesh forwarder to deliver a packet\n   (i.e., because it does not
    have direct reachability to the\n   destination), it MUST include a Mesh Addressing
    header with the\n   originator's link-layer address set to its own, and the final\n
    \  destination's link-layer address set to the packet's ultimate\n   destination.
    \ It sets the source address in the 802.15.4 header to\n   its own link-layer
    address, and puts the forwarder's link-layer\n   address in the 802.15.4 header's
    destination address field.  Finally,\n   it transmits the packet.\n   Similarly,
    if a node receives a frame with a Mesh Addressing header,\n   it must look at
    the Mesh Addressing header's \"Final Destination\"\n   field to determine the
    real destination.  If the node is itself the\n   final destination, it consumes
    the packet as per normal delivery.  If\n   it is not the final destination, the
    device then reduces the \"Hops\n   Left\" field, and if the result is zero, discards
    the packet.\n   Otherwise, the node consults its link-layer routing table, determines\n
    \  what the next hop towards the final destination should be, and puts\n   that
    address in the destination address field of the 802.15.4 header.\n   Finally,
    the node changes the source address in the 802.15.4 header\n   to its own link-layer
    address and transmits the packet.\n   Whereas a node must participate in a mesh
    routing protocol to be a\n   forwarder, no such requirement exists for simply
    using mesh\n   forwarding.  Only \"Full Function Devices\" (FFDs) are expected
    to\n   participate as routers in a mesh.  \"Reduced Function Devices\" (RFDs)\n
    \  limit themselves to discovering FFDs and using them for all their\n   forwarding,
    in a manner similar to how IP hosts typically use default\n   routers to forward
    all their off-link traffic.  For an RFD using mesh\n   delivery, the \"forwarder\"
    is always the appropriate FFD.\n"
  - contents:
    - "11.1.  LoWPAN Broadcast\n   Additional mesh routing functionality is encoded
      using a routing\n   header immediately following the Mesh header.  In particular,
      a\n   broadcast header consists of a LOWPAN_BC0 dispatch followed by a\n   sequence
      number field.  The sequence number is used to detect\n   duplicate packets (and
      hopefully suppress them).\n                           1\n       0 1 2 3 4 5
      6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0|1|LOWPAN_BC0
      |Sequence Number|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                        Figure
      11: Broadcast Header\n   Field definitions are as follows:\n   Sequence Number:
      \ This 8-bit field SHALL be incremented by the\n      originator whenever it
      sends a new mesh broadcast or multicast\n      packet.  Full specification of
      how to handle this field is out of\n      the scope of this document.\n   Further
      implications of such mesh-layer broadcast, e.g., whether it\n   maps to a controlled
      flooding mechanism or its role in, say, topology\n   discovery, is out of the
      scope of this document.\n   Additional mesh routing capabilities, such as specifying
      the mesh\n   routing protocol, source routing, and so on may be expressed by\n
      \  defining additional routing headers that precede the fragmentation or\n   addressing
      header in the header stack.  The full specification of\n   such mesh routing
      capabilities are out of the scope of this document.\n"
    title: 11.1.  LoWPAN Broadcast
  title: 11.  Frame Delivery in a Link-Layer Mesh
- contents:
  - "12.  IANA Considerations\n   This document creates two new IANA registries, as
    discussed below.\n   Future assignments in these registries are to be coordinated
    via IANA\n   under the policy of \"Specification Required\" [RFC2434].  It is\n
    \  expected that this policy will allow for other (non-IETF)\n   organizations
    to more easily obtain assignments.\n   This document creates a new IANA registry
    for the Dispatch type field\n   shown in the header definitions in Section 5.
    \ This document defines\n   the values IPv6, LOWPAN_HC1 header compression, BC0
    broadcast and two\n   escape patterns (NALP to indicate not a LOWPAN frame and
    ESC to allow\n   additional dispatch bytes).  This document defines this field
    to be 8\n   bits long.  The values 00xxxxxx being reserved and not used, allows\n
    \  for a total of 192 different values, which should be more than\n   enough.
    \ If header compression formats in addition to HC1 are defined\n   or if additional
    TCP, ICMP HC2 formats are defined, it is expected\n   that these will use reserved
    dispatch values following LOWPAN_HC1.\n   If additional mesh delivery formats
    are defined these will use\n   reserved values following LOWPAN_BC0.\n   This
    document creates a new IANA registry for the 16-bit short\n   address fields as
    used in 6LoWPAN packets.\n                       0                   1\n                       0
    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     |     16-bit short Address      |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                                Figure 12\n   This registry MUST include the
    addresses 0xffff (16-bit broadcast\n   address accepted by all devices currently
    listening to the channel)\n   and 0xfffe as defined in [ieee802.15.4].  Additionally,
    within\n   6LoWPAN networks, 16-bit short addresses MUST follow this format\n
    \  (referring to bit fields in the order from 0 to 7), where \"x\" is a\n   place
    holder for an unspecified bit value:\n   Range 1, 0xxxxxxxxxxxxxxx:  The first
    bit (bit 0) SHALL be zero if\n      the 16-bit address is a unicast address.  This
    leaves 15 bits for\n      the actual address.\n   Range 2, 100xxxxxxxxxxxxx:  Bits
    0, 1, and 2 SHALL follow this\n      pattern if the 16-bit address is a multicast
    address (see\n      Section 9).  This leaves 13 bits for the actual multicast
    address.\n   Range 3, 101xxxxxxxxxxxxx:  This pattern for bits 0, 1, and 2 is\n
    \     reserved.  Any future assignment shall follow the policy mentioned\n      above.\n
    \  Range 4, 110xxxxxxxxxxxxx:  This pattern for bits 0, 1, and 2 is\n      reserved.
    \ Any future assignment shall follow the policy mentioned\n      above.\n   Range
    5, 111xxxxxxxxxxxxx:  This pattern for bits 0, 1, and 2 is\n      reserved.  Any
    future assignment shall follow the policy mentioned\n      above.\n"
  title: 12.  IANA Considerations
- contents:
  - "13.  Security Considerations\n   The method of derivation of Interface Identifiers
    from EUI-64 MAC\n   addresses is intended to preserve global uniqueness when possible.\n
    \  However, there is no protection from duplication through accident or\n   forgery.\n
    \  Neighbor Discovery in IEEE 802.15.4 links may be susceptible to\n   threats
    as detailed in [RFC3756].  Mesh routing is expected to be\n   common in IEEE 802.15.4
    networks.  This implies additional threats\n   due to ad hoc routing as per [KW03].
    \ IEEE 802.15.4 provides some\n   capability for link-layer security.  Users are
    urged to make use of\n   such provisions if at all possible and practical.  Doing
    so will\n   alleviate the threats stated above.\n   A sizeable portion of IEEE
    802.15.4 devices is expected to always\n   communicate within their PAN (i.e.,
    within their link, in IPv6\n   terms).  In response to cost and power consumption
    considerations,\n   and in keeping with the IEEE 802.15.4 model of \"Reduced Function\n
    \  Devices\" (RFDs), these devices will typically implement the minimum\n   set
    of features necessary.  Accordingly, security for such devices\n   may rely quite
    strongly on the mechanisms defined at the link layer\n   by IEEE 802.15.4.  The
    latter, however, only defines the Advanced\n   Encryption Standard (AES) modes
    for authentication or encryption of\n   IEEE 802.15.4 frames, and does not, in
    particular, specify key\n   management (presumably group oriented).  Other issues
    to address in\n   real deployments relate to secure configuration and management.\n
    \  Whereas such a complete picture is out of the scope of this document,\n   it
    is imperative that IEEE 802.15.4 networks be deployed with such\n   considerations
    in mind.  Of course, it is also expected that some\n   IEEE 802.15.4 devices (the
    so-called \"Full Function Devices\", or\n   \"FFDs\") will implement coordination
    or integration functions.  These\n   may communicate regularly with off-link IPv6
    peers (in addition to\n   the more common on-link exchanges).  Such IPv6 devices
    are expected\n   to secure their end-to-end communications with the usual mechanisms\n
    \  (e.g., IPsec, TLS, etc).\n"
  title: 13.  Security Considerations
- contents:
  - "14.  Acknowledgements\n   Thanks to the authors of RFC 2464 and RFC 2734, as
    parts of this\n   document are patterned after theirs.  Thanks to Geoff Mulligan
    for\n   useful discussions which helped shape this document.  Erik Nordmark's\n
    \  suggestions were instrumental for the header compression section.\n   Also
    thanks to Shoichi Sakane, Samita Chakrabarti, Vipul Gupta,\n   Carsten Bormann,
    Ki-Hyung Kim, Mario Mao, Phil Levis, Magnus\n   Westerlund, and Jari Arkko.\n"
  title: 14.  Acknowledgements
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [RFC2119]       Bradner, S., \"Key words for
      use in RFCs to Indicate\n                   Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2434]       Narten, T. and H. Alvestrand, \"Guidelines
      for Writing\n                   an IANA Considerations Section in RFCs\", BCP
      26,\n                   RFC 2434, October 1998.\n   [RFC2460]       Deering,
      S. and R. Hinden, \"Internet Protocol,\n                   Version 6 (IPv6)
      Specification\", RFC 2460,\n                   December 1998.\n   [RFC2464]
      \      Crawford, M., \"Transmission of IPv6 Packets over\n                   Ethernet
      Networks\", RFC 2464, December 1998.\n   [RFC4291]       Hinden, R. and S. Deering,
      \"IP Version 6 Addressing\n                   Architecture\", RFC 4291, February
      2006.\n   [RFC4861]       Narten, T., Nordmark, E., Simpson, W., and H.\n                   Soliman,
      \"Neighbor Discovery for IP version 6\n                   (IPv6)\", RFC 4861,
      September 2007.\n   [RFC4862]       Thomson, S., Narten, T., and T. Jinmei,
      \"IPv6\n                   Stateless Address Autoconfiguration\", RFC 4862,\n
      \                  September 2007.\n   [ieee802.15.4]  IEEE Computer Society,
      \"IEEE Std. 802.15.4-2003\",\n                   October 2003.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [EUI64]         \"GUIDELINES FOR 64-BIT GLOBAL
      IDENTIFIER (EUI-64)\n                   REGISTRATION AUTHORITY\", IEEE http://\n
      \                  standards.ieee.org/regauth/oui/tutorials/EUI64.html.\n   [KW03]
      \         Karlof, Chris and Wagner, David, \"Secure Routing in\n                   Sensor
      Networks: Attacks and Countermeasures\",\n                   Elsevier's AdHoc
      Networks Journal, Special Issue on\n                   Sensor Network Applications
      and Protocols vol 1,\n                   issues 2-3, September 2003.\n   [RFC0768]
      \      Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n                   August
      1980.\n   [RFC3756]       Nikander, P., Kempf, J., and E. Nordmark, \"IPv6\n
      \                  Neighbor Discovery (ND) Trust Models and Threats\",\n                   RFC
      3756, May 2004.\n   [RFC3819]       Karn, P., Bormann, C., Fairhurst, G., Grossman,
      D.,\n                   Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J.,\n
      \                  and L. Wood, \"Advice for Internet Subnetwork\n                   Designers\",
      BCP 89, RFC 3819, July 2004.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Alternatives for Delivery of Frames in a Mesh\n   Before settling
    on the mechanism finally adopted for delivery in a\n   mesh (Section 11), several
    alternatives were considered.  In addition\n   to the hop-by-hop source and destination
    link-layer addresses,\n   delivering a packet in a LoWPAN mesh requires the end-to-end\n
    \  originator and destination addresses.  These could be expressed\n   either
    as layer 2 or as layer 3 (i.e., IP ) addresses.  In the latter\n   case, there
    would be no need to provide any additional header support\n   in this document
    (i.e., within the LoWPAN header itself).  The link-\n   layer destination address
    would point to the next hop destination\n   address while the IP header destination
    address would point to the\n   final destination (IP) address (possibly multiple
    hops away from the\n   source), and similarly for the source addresses.  Thus,
    while\n   forwarding data, the single-hop source and destination addresses\n   would
    change at each hop (always pointing to the node doing the\n   forwarding and the
    \"best\" next link-layer hop, respectively), while\n   the source and destination
    IP addresses would remain unchanged.\n   Notice that if an IP packet is fragmented,
    the individual fragments\n   may arrive at any node out of order.  If the initial
    fragment (which\n   contains the IP header) is delayed for some reason, a node
    that\n   receives a subsequent fragment would lack the required information.\n
    \  It would be forced to wait until it receives the IP header (within\n   the
    first fragment) before being able to forward the fragment any\n   further.  This
    imposes some additional buffering requirements on\n   intermediate nodes.  Additionally,
    such a specification would only\n   work for one type of LoWPAN payload: IPv6.
    \ In general, it would have\n   to be adapted for any other payload, and would
    require that payload\n   to provide its own end-to-end addressing information.\n
    \  On the other hand, the approach finally followed (Section 11) creates\n   a
    mesh at the LoWPAN layer (below layer 3).  Accordingly, the link-\n   layer originator
    and final destination address are included within\n   the LoWPAN header.  This
    enables mesh delivery for any protocol or\n   application layered on the LoWPAN
    adaptation layer (Section 5).  For\n   IPv6 as supported in this document, another
    advantage of expressing\n   the originator and final destinations as layer 2 addresses
    is that\n   the IPv6 addresses can be compressed as per the header compression\n
    \  specified in Section 10.  Furthermore, the number of octets needed to\n   maintain
    routing tables is reduced due to the smaller size of\n   802.15.4 addresses (either
    64 bits or 16 bits) as compared to IPv6\n   addresses (128 bits).  A disadvantage
    is that applications on top of\n   IP do not address packets to link-layer destination
    addresses, but to\n   IP (layer 3) destination addresses.  Thus, given an IP address,
    there\n   is a need to resolve the corresponding link-layer address.\n   Accordingly,
    a mesh routing specification needs to clarify the\n   Neighbor Discovery implications,
    although in some special cases, it\n   may be possible to derive a device's address
    at layer 2 from its\n   address at layer 3 (and vice versa).  Such complete specification
    is\n   outside the scope of this document.\n"
  title: Appendix A.  Alternatives for Delivery of Frames in a Mesh
- contents:
  - "Authors' Addresses\n   Gabriel Montenegro\n   Microsoft Corporation\n   EMail:
    gabriel.montenegro@microsoft.com\n   Nandakishore Kushalnagar\n   Intel Corp\n
    \  EMail: nandakishore.kushalnagar@intel.com\n   Jonathan W. Hui\n   Arch Rock
    Corp\n   EMail: jhui@archrock.com\n   David E. Culler\n   Arch Rock Corp\n   EMail:
    dculler@archrock.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
