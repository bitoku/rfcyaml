- title: __initial_text__
  contents:
  - "          Network Working Group                                  J. Case\n  \
    \        Request for Comments: 1442                 SNMP Research, Inc.\n    \
    \                   Structure of Management Information\n                    \
    \           for version 2 of the\n                   Simple Network Management\
    \ Protocol (SNMPv2)\n          Status of this Memo\n          This RFC specifes\
    \ an IAB standards track protocol for the\n          Internet community, and requests\
    \ discussion and suggestions\n          for improvements.  Please refer to the\
    \ current edition of the\n          \"IAB Official Protocol Standards\" for the\
    \ standardization\n          state and status of this protocol.  Distribution\
    \ of this memo\n          is unlimited.\n          Table of Contents\n       \
    \   1 Introduction ..........................................    2\n         \
    \ 1.1 A Note on Terminology ...............................    3\n          2\
    \ Definitions ...........................................    4\n          3.1\
    \ The MODULE-IDENTITY macro ...........................    5\n          3.2 Object\
    \ Names and Syntaxes ...........................    7\n          3.3 The OBJECT-TYPE\
    \ macro ...............................   10\n          3.5 The NOTIFICATION-TYPE\
    \ macro .........................   12\n          3 Information Modules ...................................\
    \   13\n          3.1 Macro Invocation ....................................  \
    \ 13\n          3.1.1 Textual Clauses ...................................   14\n\
    \          3.2 IMPORTing Symbols ...................................   14\n  \
    \        4 Naming Hierarchy ......................................   16\n    \
    \      5 Mapping of the MODULE-IDENTITY macro ..................   17\n      \
    \    5.1 Mapping of the LAST-UPDATED clause ..................   17\n        \
    \  5.2 Mapping of the ORGANIZATION clause ..................   17\n          5.3\
    \ Mapping of the CONTACT-INFO clause ..................   17\n          5.4 Mapping\
    \ of the DESCRIPTION clause ...................   17\n          5.5 Mapping of\
    \ the REVISION clause ......................   17\n          5.6 Mapping of the\
    \ DESCRIPTION clause ...................   18\n          5.7 Mapping of the MODULE-IDENTITY\
    \ value ................   18\n          5.8 Usage Example .......................................\
    \   19\n          RFC 1442                SMI for SNMPv2              April 1993\n\
    \          6 Mapping of the OBJECT-IDENTITY macro ..................   20\n  \
    \        6.1 Mapping of the STATUS clause ........................   20\n    \
    \      6.2 Mapping of the DESCRIPTION clause ...................   20\n      \
    \    6.3 Mapping of the REFERENCE clause .....................   20\n        \
    \  6.4 Mapping of the OBJECT-IDENTITY value ................   20\n          6.5\
    \ Usage Example .......................................   21\n          7 Mapping\
    \ of the OBJECT-TYPE macro ......................   22\n          7.1 Mapping\
    \ of the SYNTAX clause ........................   22\n          7.1.1 Integer32\
    \ and INTEGER .............................   22\n          7.1.2 OCTET STRING\
    \ ......................................   23\n          7.1.3 OBJECT IDENTIFIER\
    \ .................................   23\n          7.1.4 BIT STRING ........................................\
    \   23\n          7.1.5 IpAddress .........................................  \
    \ 23\n          7.1.6 Counter32 .........................................   24\n\
    \          7.1.7 Gauge32 ...........................................   24\n  \
    \        7.1.8 TimeTicks .........................................   24\n    \
    \      7.1.9 Opaque ............................................   25\n      \
    \    7.1.10 NsapAddress ......................................   25\n        \
    \  7.1.11 Counter64 ........................................   26\n          7.1.12\
    \ UInteger32 .......................................   26\n          7.2 Mapping\
    \ of the UNITS clause .........................   26\n          7.3 Mapping of\
    \ the MAX-ACCESS clause ....................   27\n          7.4 Mapping of the\
    \ STATUS clause ........................   27\n          7.5 Mapping of the DESCRIPTION\
    \ clause ...................   27\n          7.6 Mapping of the REFERENCE clause\
    \ .....................   28\n          7.7 Mapping of the INDEX clause .........................\
    \   28\n          7.7.1 Creation and Deletion of Conceptual Rows ..........  \
    \ 30\n          7.8 Mapping of the AUGMENTS clause ......................   31\n\
    \          7.8.1 Relation between INDEX and AUGMENTS clauses .......   31\n  \
    \        7.9 Mapping of the DEFVAL clause ........................   32\n    \
    \      7.10 Mapping of the OBJECT-TYPE value ...................   33\n      \
    \    7.11 Usage Example ......................................   35\n        \
    \  8 Mapping of the NOTIFICATION-TYPE macro ................   37\n          8.1\
    \ Mapping of the OBJECTS clause .......................   37\n          8.2 Mapping\
    \ of the STATUS clause ........................   37\n          8.3 Mapping of\
    \ the DESCRIPTION clause ...................   37\n          8.4 Mapping of the\
    \ REFERENCE clause .....................   37\n          8.5 Mapping of the NOTIFICATION-TYPE\
    \ value ..............   38\n          8.6 Usage Example .......................................\
    \   39\n          9 Refined Syntax ........................................  \
    \ 40\n          10 Extending an Information Module ......................   41\n\
    \          10.1 Object Assignments .................................   41\n  \
    \        10.2 Object Definitions .................................   41\n    \
    \      10.3 Notification Definitions ...........................   42\n      \
    \    RFC 1442                SMI for SNMPv2              April 1993\n        \
    \  11 Appendix: de-OSIfying a MIB module ...................   43\n          11.1\
    \ Managed Object Mapping .............................   43\n          11.1.1\
    \ Mapping to the SYNTAX clause .....................   44\n          11.1.2 Mapping\
    \ to the UNITS clause ......................   45\n          11.1.3 Mapping to\
    \ the MAX-ACCESS clause .................   45\n          11.1.4 Mapping to the\
    \ STATUS clause .....................   45\n          11.1.5 Mapping to the DESCRIPTION\
    \ clause ................   45\n          11.1.6 Mapping to the REFERENCE clause\
    \ ..................   45\n          11.1.7 Mapping to the INDEX clause ......................\
    \   45\n          11.1.8 Mapping to the DEFVAL clause .....................  \
    \ 45\n          11.2 Action Mapping .....................................   46\n\
    \          11.2.1 Mapping to the SYNTAX clause .....................   46\n  \
    \        11.2.2 Mapping to the MAX-ACCESS clause .................   46\n    \
    \      11.2.3 Mapping to the STATUS clause .....................   46\n      \
    \    11.2.4 Mapping to the DESCRIPTION clause ................   46\n        \
    \  11.2.5 Mapping to the REFERENCE clause ..................   46\n          11.3\
    \ Event Mapping ......................................   46\n          11.3.1\
    \ Mapping to the STATUS clause .....................   47\n          11.3.2 Mapping\
    \ to the DESCRIPTION clause ................   47\n          11.3.3 Mapping to\
    \ the REFERENCE clause ..................   47\n          12 Acknowledgements\
    \ .....................................   48\n          13 References ...........................................\
    \   52\n          14 Security Considerations ..............................  \
    \ 54\n          15 Authors' Addresses ...................................   54\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        1.  Introduction\n          A network management system contains: several\
    \ (potentially\n          many) nodes, each with a processing entity, termed an\
    \ agent,\n          which has access to management instrumentation; at least one\n\
    \          management station; and, a management protocol, used to convey\n  \
    \        management information between the agents and management\n          stations.\
    \  Operations of the protocol are carried out under an\n          administrative\
    \ framework which defines both authentication and\n          authorization policies.\n\
    \          Network management stations execute management applications\n     \
    \     which monitor and control network elements.  Network elements\n        \
    \  are devices such as hosts, routers, terminal servers, etc.,\n          which\
    \ are monitored and controlled through access to their\n          management information.\n\
    \          Management information is viewed as a collection of managed\n     \
    \     objects, residing in a virtual information store, termed the\n         \
    \ Management Information Base (MIB).  Collections of related\n          objects\
    \ are defined in MIB modules.  These modules are written\n          using a subset\
    \ of OSI's Abstract Syntax Notation One (ASN.1)\n          [1].  It is the purpose\
    \ of this document, the Structure of\n          Management Information (SMI),\
    \ to define that subset.\n          The SMI is divided into three parts: module\
    \ definitions,\n          object definitions, and, trap definitions.\n       \
    \   (1)  Module definitions are used when describing information\n           \
    \    modules.  An ASN.1 macro, MODULE-IDENTITY, is used to\n               concisely\
    \ convey the semantics of an information module.\n          (2)  Object definitions\
    \ are used when describing managed\n               objects.  An ASN.1 macro, OBJECT-TYPE,\
    \ is used to\n               concisely convey the syntax and semantics of a managed\n\
    \               object.\n          (3)  Notification definitions are used when\
    \ describing\n               unsolicited transmissions of management information.\
    \  An\n               ASN.1 macro, NOTIFICATION-TYPE, is used to concisely\n \
    \              convey the syntax and semantics of a notification.\n          RFC\
    \ 1442                SMI for SNMPv2              April 1993\n          1.1. \
    \ A Note on Terminology\n          For the purpose of exposition, the original\
    \ Internet-standard\n          Network Management Framework, as described in RFCs\
    \ 1155, 1157,\n          and 1212, is termed the SNMP version 1 framework (SNMPv1).\n\
    \          The current framework is termed the SNMP version 2 framework\n    \
    \      (SNMPv2).\n          RFC 1442                SMI for SNMPv2           \
    \   April 1993\n          2.  Definitions\n          SNMPv2-SMI DEFINITIONS ::=\
    \ BEGIN\n          -- the path to the root\n          internet       OBJECT IDENTIFIER\
    \ ::= { iso 3 6 1 }\n          directory      OBJECT IDENTIFIER ::= { internet\
    \ 1 }\n          mgmt           OBJECT IDENTIFIER ::= { internet 2 }\n       \
    \   experimental   OBJECT IDENTIFIER ::= { internet 3 }\n          private   \
    \     OBJECT IDENTIFIER ::= { internet 4 }\n          enterprises    OBJECT IDENTIFIER\
    \ ::= { private 1 }\n          security       OBJECT IDENTIFIER ::= { internet\
    \ 5 }\n          snmpV2         OBJECT IDENTIFIER ::= { internet 6 }\n       \
    \   -- transport domains\n          snmpDomains    OBJECT IDENTIFIER ::= { snmpV2\
    \ 1 }\n          -- transport proxies\n          snmpProxys     OBJECT IDENTIFIER\
    \ ::= { snmpV2 2 }\n          -- module identities\n          snmpModules    OBJECT\
    \ IDENTIFIER ::= { snmpV2 3 }\n          RFC 1442                SMI for SNMPv2\
    \              April 1993\n          -- definitions for information modules\n\
    \          MODULE-IDENTITY MACRO ::=\n          BEGIN\n              TYPE NOTATION\
    \ ::=\n                            \"LAST-UPDATED\" value(Update UTCTime)\n  \
    \                          \"ORGANIZATION\" Text\n                           \
    \ \"CONTACT-INFO\" Text\n                            \"DESCRIPTION\" Text\n  \
    \                          RevisionPart\n              VALUE NOTATION ::=\n  \
    \                          value(VALUE OBJECT IDENTIFIER)\n              RevisionPart\
    \ ::=\n                            Revisions\n                          | empty\n\
    \              Revisions ::=\n                            Revision\n         \
    \                 | Revisions Revision\n              Revision ::=\n         \
    \                   \"REVISION\" value(Update UTCTime)\n                     \
    \       \"DESCRIPTION\" Text\n              -- uses the NVT ASCII character set\n\
    \              Text ::= \"\"\"\" string \"\"\"\"\n          END\n          RFC\
    \ 1442                SMI for SNMPv2              April 1993\n          OBJECT-IDENTITY\
    \ MACRO ::=\n          BEGIN\n              TYPE NOTATION ::=\n              \
    \              \"STATUS\" Status\n                            \"DESCRIPTION\"\
    \ Text\n                            ReferPart\n              VALUE NOTATION ::=\n\
    \                            value(VALUE OBJECT IDENTIFIER)\n              Status\
    \ ::=\n                            \"current\"\n                          | \"\
    obsolete\"\n              ReferPart ::=\n                          \"REFERENCE\"\
    \ Text\n                        | empty\n              Text ::= \"\"\"\" string\
    \ \"\"\"\"\n          END\n          RFC 1442                SMI for SNMPv2  \
    \            April 1993\n          -- names of objects\n          ObjectName ::=\n\
    \              OBJECT IDENTIFIER\n          -- syntax of objects\n          ObjectSyntax\
    \ ::=\n              CHOICE {\n                  simple\n                    \
    \  SimpleSyntax,\n                    -- note that SEQUENCEs for conceptual tables\
    \ and\n                    -- rows are not mentioned here...\n               \
    \   application-wide\n                      ApplicationSyntax\n              }\n\
    \          -- built-in ASN.1 types\n          SimpleSyntax ::=\n             \
    \ CHOICE {\n                  -- INTEGERs with a more restrictive range\n    \
    \              -- may also be used\n                  integer-value\n        \
    \              INTEGER (-2147483648..2147483647),\n                  string-value\n\
    \                      OCTET STRING,\n                  objectID-value\n     \
    \                 OBJECT IDENTIFIER,\n                  -- only the enumerated\
    \ form is allowed\n                  bit-value\n                      BIT STRING\n\
    \              }\n          RFC 1442                SMI for SNMPv2           \
    \   April 1993\n          -- indistinguishable from INTEGER, but never needs more\
    \ than\n          -- 32-bits for a two's complement representation\n         \
    \ Integer32 ::=\n              [UNIVERSAL 2]\n                  IMPLICIT INTEGER\
    \ (-2147483648..2147483647)\n          -- application-wide types\n          ApplicationSyntax\
    \ ::=\n              CHOICE {\n                  ipAddress-value\n           \
    \           IpAddress,\n                  counter-value\n                    \
    \  Counter32,\n                  gauge-value\n                      Gauge32,\n\
    \                  timeticks-value\n                      TimeTicks,\n       \
    \           arbitrary-value\n                      Opaque,\n                 \
    \ nsapAddress-value\n                      NsapAddress,\n                  big-counter-value\n\
    \                      Counter64,\n                  unsigned-integer-value\n\
    \                      UInteger32\n              }\n          -- in network-byte\
    \ order\n          -- (this is a tagged type for historical reasons)\n       \
    \   IpAddress ::=\n              [APPLICATION 0]\n                  IMPLICIT OCTET\
    \ STRING (SIZE (4))\n          RFC 1442                SMI for SNMPv2        \
    \      April 1993\n          -- this wraps\n          Counter32 ::=\n        \
    \      [APPLICATION 1]\n                  IMPLICIT INTEGER (0..4294967295)\n \
    \         -- this doesn't wrap\n          Gauge32 ::=\n              [APPLICATION\
    \ 2]\n                  IMPLICIT INTEGER (0..4294967295)\n          -- hundredths\
    \ of seconds since an epoch\n          TimeTicks ::=\n              [APPLICATION\
    \ 3]\n                  IMPLICIT INTEGER (0..4294967295)\n          -- for backward-compatibility\
    \ only\n          Opaque ::=\n              [APPLICATION 4]\n                \
    \  IMPLICIT OCTET STRING\n          -- for OSI NSAP addresses\n          -- (this\
    \ is a tagged type for historical reasons)\n          NsapAddress ::=\n      \
    \        [APPLICATION 5]\n                  IMPLICIT OCTET STRING (SIZE (1 | 4..21))\n\
    \          -- for counters that wrap in less than one hour with only 32 bits\n\
    \          Counter64 ::=\n              [APPLICATION 6]\n                  IMPLICIT\
    \ INTEGER (0..18446744073709551615)\n          -- an unsigned 32-bit quantity\n\
    \          UInteger32 ::=\n              [APPLICATION 7]\n                  IMPLICIT\
    \ INTEGER (0..4294967295)\n          RFC 1442                SMI for SNMPv2  \
    \            April 1993\n          -- definition for objects\n          OBJECT-TYPE\
    \ MACRO ::=\n          BEGIN\n              TYPE NOTATION ::=\n              \
    \              \"SYNTAX\" type(Syntax)\n                            UnitsPart\n\
    \                            \"MAX-ACCESS\" Access\n                         \
    \   \"STATUS\" Status\n                            \"DESCRIPTION\" Text\n    \
    \                        ReferPart\n                            IndexPart\n  \
    \                          DefValPart\n              VALUE NOTATION ::=\n    \
    \                        value(VALUE ObjectName)\n              UnitsPart ::=\n\
    \                            \"UNITS\" Text\n                          | empty\n\
    \              Access ::=\n                            \"not-accessible\"\n  \
    \                        | \"read-only\"\n                          | \"read-write\"\
    \n                          | \"read-create\"\n              Status ::=\n    \
    \                        \"current\"\n                          | \"deprecated\"\
    \n                          | \"obsolete\"\n              ReferPart ::=\n    \
    \                        \"REFERENCE\" Text\n                          | empty\n\
    \              IndexPart ::=\n                            \"INDEX\"    \"{\" IndexTypes\
    \ \"}\"\n                          | \"AUGMENTS\" \"{\" Entry      \"}\"\n   \
    \                       | empty\n              IndexTypes ::=\n              \
    \              IndexType\n                          | IndexTypes \",\" IndexType\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \            IndexType ::=\n                            \"IMPLIED\" Index\n  \
    \                        | Index\n              Index ::=\n                  \
    \            -- use the SYNTAX value of the\n                              --\
    \ correspondent OBJECT-TYPE invocation\n                            value(Indexobject\
    \ ObjectName)\n              Entry ::=\n                              -- use the\
    \ INDEX value of the\n                              -- correspondent OBJECT-TYPE\
    \ invocation\n                            value(Entryobject ObjectName)\n    \
    \          DefValPart ::=\n                            \"DEFVAL\" \"{\" value(Defval\
    \ Syntax) \"}\"\n                          | empty\n              -- uses the\
    \ NVT ASCII character set\n              Text ::= \"\"\"\" string \"\"\"\"\n \
    \         END\n          RFC 1442                SMI for SNMPv2              April\
    \ 1993\n          -- definitions for notifications\n          NOTIFICATION-TYPE\
    \ MACRO ::=\n          BEGIN\n              TYPE NOTATION ::=\n              \
    \              ObjectsPart\n                            \"STATUS\" Status\n  \
    \                          \"DESCRIPTION\" Text\n                            ReferPart\n\
    \              VALUE NOTATION ::=\n                            value(VALUE OBJECT\
    \ IDENTIFIER)\n              ObjectsPart ::=\n                            \"OBJECTS\"\
    \ \"{\" Objects \"}\"\n                          | empty\n              Objects\
    \ ::=\n                            Object\n                          | Objects\
    \ \",\" Object\n              Object ::=\n                            value(Name\
    \ ObjectName)\n              Status ::=\n                            \"current\"\
    \n                          | \"deprecated\"\n                          | \"obsolete\"\
    \n              ReferPart ::=\n                          \"REFERENCE\" Text\n\
    \                        | empty\n              -- uses the NVT ASCII character\
    \ set\n              Text ::= \"\"\"\" string \"\"\"\"\n          END\n      \
    \    END\n          RFC 1442                SMI for SNMPv2              April\
    \ 1993\n          3.  Information Modules\n          An \"information module\"\
    \ is an ASN.1 module defining\n          information relating to network management.\n\
    \          The SMI describes how to use a subset of ASN.1 to define an\n     \
    \     information module.  Further, additional restrictions are\n          placed\
    \ on \"standard\" information modules.  It is strongly\n          recommended\
    \ that \"enterprise-specific\" information modules\n          also adhere to these\
    \ restrictions.\n          Typically, there are three kinds of information modules:\n\
    \          (1)  MIB modules, which contain definitions of inter-related\n    \
    \           managed objects, make use of the OBJECT-TYPE and\n               NOTIFICATION-TYPE\
    \ macros;\n          (2)  compliance statements for MIB modules, which make use\
    \ of\n               the MODULE-COMPLIANCE and OBJECT-GROUP macros [2]; and,\n\
    \          (3)  capability statements for agent implementations which\n      \
    \         make use of the AGENT-CAPABILITIES macros [2].\n          This classification\
    \ scheme does not imply a rigid taxonomy.\n          For example, a \"standard\"\
    \ information module might include\n          definitions of managed objects and\
    \ a compliance statement.\n          Similarly, an \"enterprise-specific\" information\
    \ module might\n          include definitions of managed objects and a capability\n\
    \          statement.  Of course, a \"standard\" information module may not\n\
    \          contain capability statements.\n          All information modules start\
    \ with exactly one invocation of\n          the MODULE-IDENTITY macro, which provides\
    \ contact and revision\n          history.  This invocation must appear immediately\
    \ after any\n          IMPORTs or EXPORTs statements.\n          3.1.  Macro Invocation\n\
    \          Within an information module, each macro invocation appears\n     \
    \     as:\n               <descriptor> <macro> <clauses> ::= <value>\n       \
    \   where <descriptor> corresponds to an ASN.1 identifier, <macro>\n         \
    \ RFC 1442                SMI for SNMPv2              April 1993\n          names\
    \ the macro being invoked, and <clauses> and <value>\n          depend on the\
    \ definition of the macro.\n          An ASN.1 identifier consists of one or more\
    \ letters, digits,\n          or hyphens.  The initial character must be a lower-case\n\
    \          letter, and the final character may not be a hyphen.  Further,\n  \
    \        a hyphen may not be immediatedly followed by another hyphen.\n      \
    \    For all descriptors appearing in an information module, the\n          descriptor\
    \ shall be unique and mnemonic, and shall not exceed\n          64 characters\
    \ in length.  This promotes a common language for\n          humans to use when\
    \ discussing the information module and also\n          facilitates simple table\
    \ mappings for user-interfaces.\n          The set of descriptors defined in all\
    \ \"standard\" information\n          modules shall be unique.  Further, within\
    \ any information\n          module, the hyphen is not allowed as a character\
    \ in any\n          descriptor.\n          Finally, by convention, if the descriptor\
    \ refers to an object\n          with a SYNTAX clause value of either Counter32\
    \ or Counter64,\n          then the descriptor used for the object should denote\n\
    \          plurality.\n          3.1.1.  Textual Clauses\n          Some clauses\
    \ in a macro invocation may take a textual value\n          (e.g., the DESCRIPTION\
    \ clause).  Note that, in order to\n          conform to the ASN.1 syntax, the\
    \ entire value of these clauses\n          must be enclosed in double quotation\
    \ marks, and therefore\n          cannot itself contain double quotation marks,\
    \ although the\n          value may be multi-line.\n          3.2.  IMPORTing\
    \ Symbols\n          To reference an external object, the IMPORTS statement must\
    \ be\n          used to identify both the descriptor and the module defining\n\
    \          the descriptor.\n          Note that when symbols from \"enterprise-specific\"\
    \ information\n          modules are referenced  (e.g., a descriptor), there is\
    \ the\n          possibility of collision.  As such, if different objects with\n\
    \          the same descriptor are IMPORTed, then this ambiguity is\n        \
    \  RFC 1442                SMI for SNMPv2              April 1993\n          resolved\
    \ by prefixing the descriptor with the name of the\n          information module\
    \ and a dot (\".\"), i.e.,\n               \"module.descriptor\"\n          (All\
    \ descriptors must be unique within any information\n          module.)\n    \
    \      Of course, this notation can be used even when there is no\n          collision\
    \ when IMPORTing symbols.\n          Finally, the IMPORTS statement may not be\
    \ used to import an\n          ASN.1 named type which corresponds to either the\
    \ SEQUENCE or\n          SEQUENCE OF type.\n          RFC 1442               \
    \ SMI for SNMPv2              April 1993\n          4.  Naming Hierarchy\n   \
    \       The root of the subtree administered by the Internet Assigned\n      \
    \    Numbers Authority (IANA) for the Internet is:\n               internet  \
    \     OBJECT IDENTIFIER ::= { iso 3 6 1 }\n          That is, the Internet subtree\
    \ of OBJECT IDENTIFIERs starts\n          with the prefix:\n               1.3.6.1.\n\
    \          Several branches underneath this subtree are used for network\n   \
    \       management:\n               mgmt           OBJECT IDENTIFIER ::= { internet\
    \ 2 }\n               experimental   OBJECT IDENTIFIER ::= { internet 3 }\n  \
    \             private        OBJECT IDENTIFIER ::= { internet 4 }\n          \
    \     enterprises    OBJECT IDENTIFIER ::= { private 1 }\n          However, the\
    \ SMI does not prohibit the definition of objects\n          in other portions\
    \ of the object tree.\n          The mgmt(2) subtree is used to identify \"standard\"\
    \ objects.\n          The experimental(3) subtree is used to identify objects\
    \ being\n          designed by working groups of the IETF.  If an information\n\
    \          module produced by a working group becomes a \"standard\"\n       \
    \   information module, then at the very beginning of its entry\n          onto\
    \ the Internet standards track, the objects are moved under\n          the mgmt(2)\
    \ subtree.\n          The private(4) subtree is used to identify objects defined\n\
    \          unilaterally.  The enterprises(1) subtree beneath private is\n    \
    \      used, among other things, to permit providers of networking\n         \
    \ subsystems to register models of their products.\n          RFC 1442       \
    \         SMI for SNMPv2              April 1993\n          5.  Mapping of the\
    \ MODULE-IDENTITY macro\n          The MODULE-IDENTITY macro is used to provide\
    \ contact and\n          revision history for each information module.  It must\
    \ appear\n          exactly once in every information module.  It should be noted\n\
    \          that the expansion of the MODULE-IDENTITY macro is something\n    \
    \      which conceptually happens during implementation and not\n          during\
    \ run-time.\n          5.1.  Mapping of the LAST-UPDATED clause\n          The\
    \ LAST-UPDATED clause, which must be present, contains the\n          date and\
    \ time that this information module was last edited.\n          5.2.  Mapping\
    \ of the ORGANIZATION clause\n          The ORGANIZATION clause, which must be\
    \ present, contains a\n          textual description of the organization under\
    \ whose auspices\n          this information module was developed.\n         \
    \ 5.3.  Mapping of the CONTACT-INFO clause\n          The CONTACT-INFO clause,\
    \ which must be present, contains the\n          name, postal address, telephone\
    \ number, and electronic mail\n          address of the person to whom technical\
    \ queries concerning\n          this information module should be sent.\n    \
    \      5.4.  Mapping of the DESCRIPTION clause\n          The DESCRIPTION clause,\
    \ which must be present, contains a\n          high-level textual description\
    \ of the contents of this\n          information module.\n          5.5.  Mapping\
    \ of the REVISION clause\n          The REVISION clause, which need not be present,\
    \ is repeatedly\n          used to describe the revisions made to this information\n\
    \          module, in reverse chronological order.  Each instance of this\n  \
    \        clause contains the date and time of the revision.\n          RFC 1442\
    \                SMI for SNMPv2              April 1993\n          5.6.  Mapping\
    \ of the DESCRIPTION clause\n          The DESCRIPTION clause, which must be present\
    \ for each\n          REVISION clause, contains a high-level textual description\
    \ of\n          the revision identified in that REVISION clause.\n          5.7.\
    \  Mapping of the MODULE-IDENTITY value\n          The value of an invocation\
    \ of the MODULE-IDENTITY macro is an\n          OBJECT IDENTIFIER.  As such, this\
    \ value may be authoritatively\n          used when referring to the information\
    \ module containing the\n          invocation.\n          RFC 1442           \
    \     SMI for SNMPv2              April 1993\n          5.8.  Usage Example\n\
    \          Consider how a skeletal MIB module might be constructed: e.g.,\n  \
    \        FIZBIN-MIB DEFINITIONS ::= BEGIN\n          IMPORTS\n              MODULE-IDENTITY,\
    \ OBJECT-TYPE, experimental\n                  FROM SNMPv2-SMI;\n          fizbin\
    \ MODULE-IDENTITY\n              LAST-UPDATED \"9210070433Z\"\n              ORGANIZATION\
    \ \"IETF SNMPv2 Working Group\"\n              CONTACT-INFO\n                \
    \      \"        Marshall T. Rose\n                       Postal: Dover Beach\
    \ Consulting, Inc.\n                               420 Whisman Court\n       \
    \                        Mountain View, CA  94043-2186\n                     \
    \          US\n                          Tel: +1 415 968 1052\n              \
    \            Fax: +1 415 968 2510\n                       E-mail: mrose@dbc.mtview.ca.us\"\
    \n              DESCRIPTION\n                      \"The MIB module for entities\
    \ implementing the xxxx\n                      protocol.\"\n              REVISION\
    \      \"9210070433Z\"\n              DESCRIPTION\n                      \"Initial\
    \ version of this MIB module.\"\n          -- contact IANA for actual number\n\
    \              ::= { experimental xx }\n          END\n          RFC 1442    \
    \            SMI for SNMPv2              April 1993\n          6.  Mapping of\
    \ the OBJECT-IDENTITY macro\n          The OBJECT-IDENTITY macro is used to define\
    \ information about\n          an OBJECT IDENTIFIER assignment.  It should be\
    \ noted that the\n          expansion of the OBJECT-IDENTITY macro is something\
    \ which\n          conceptually happens during implementation and not during\n\
    \          run-time.\n          6.1.  Mapping of the STATUS clause\n         \
    \ The STATUS clause, which must be present, indicates whether\n          this\
    \ definition is current or historic.\n          The values \"current\", and \"\
    obsolete\" are self-explanatory.\n          6.2.  Mapping of the DESCRIPTION clause\n\
    \          The DESCRIPTION clause, which must be present, contains a\n       \
    \   textual description of the object assignment.\n          6.3.  Mapping of\
    \ the REFERENCE clause\n          The REFERENCE clause, which need not be present,\
    \ contains a\n          textual cross-reference to an object assignment defined\
    \ in\n          some other information module.\n          6.4.  Mapping of the\
    \ OBJECT-IDENTITY value\n          The value of an invocation of the OBJECT-IDENTITY\
    \ macro is an\n          OBJECT IDENTIFIER.\n          RFC 1442              \
    \  SMI for SNMPv2              April 1993\n          6.5.  Usage Example\n   \
    \       Consider how an OBJECT IDENTIFIER assignment might be made:\n        \
    \  e.g.,\n          fizbin69 OBJECT-IDENTITY\n              STATUS  current\n\
    \              DESCRIPTION\n                      \"The authoritative identity\
    \ of the Fizbin 69\n                      chipset.\"\n              ::= { fizbinChipSets\
    \ 1 }\n          RFC 1442                SMI for SNMPv2              April 1993\n\
    \          7.  Mapping of the OBJECT-TYPE macro\n          The OBJECT-TYPE macro\
    \ is used to define a managed object.  It\n          should be noted that the\
    \ expansion of the OBJECT-TYPE macro is\n          something which conceptually\
    \ happens during implementation and\n          not during run-time.\n        \
    \  7.1.  Mapping of the SYNTAX clause\n          The SYNTAX clause, which must\
    \ be present, defines the abstract\n          data structure corresponding to\
    \ that object.  The data\n          structure must be one of the alternatives\
    \ defined in the\n          ObjectSyntax CHOICE.\n          Full ASN.1 sub-typing\
    \ is allowed, as appropriate to the\n          underingly ASN.1 type, primarily\
    \ as an aid to implementors in\n          understanding the meaning of the object.\
    \  Any such restriction\n          on size, range, enumerations or repertoire\
    \ specified in this\n          clause represents the maximal level of support\
    \ which makes\n          \"protocol sense\".  Of course, sub-typing is not allowed\
    \ for\n          the Counter32 or Counter64 types, but is allowed for the\n  \
    \        Gauge32 type.\n          The semantics of ObjectSyntax are now described.\n\
    \          7.1.1.  Integer32 and INTEGER\n          The Integer32 type represents\
    \ integer-valued information\n          between -2^31 and 2^31-1 inclusive (-2147483648\
    \ to 2147483647\n          decimal).  This type is indistinguishable from the\
    \ INTEGER\n          type.\n          The INTEGER type may also be used to represent\
    \ integer-valued\n          information, if it contains named-number enumerations,\
    \ or if\n          it is sub-typed to be more constrained than the Integer32\n\
    \          type.  In the former case, only those named-numbers so\n          enumerated\
    \ may be present as a value.  Note that although it\n          is recommended\
    \ that enumerated values start at 1 and be\n          numbered contiguously, any\
    \ valid value for Integer32 is\n          allowed for an enumerated value and,\
    \ further, enumerated\n          values needn't be contiguously assigned.\n  \
    \        RFC 1442                SMI for SNMPv2              April 1993\n    \
    \      Finally, the hyphen character is not allowed as a part of the\n       \
    \   label name for any named-number enumeration.\n          7.1.2.  OCTET STRING\n\
    \          The OCTET STRING type represents arbitrary binary or textual\n    \
    \      data.  Although there is no SMI-specified size limitation for\n       \
    \   this type, MIB designers should realize that there may be\n          implementation\
    \ and interoperability limitations for sizes in\n          excess of 255 octets.\n\
    \          7.1.3.  OBJECT IDENTIFIER\n          The OBJECT IDENTIFIER type represents\
    \ administratively\n          assigned names.  Any instance of this type may have\
    \ at most\n          128 sub-identifiers.  Further, each sub-identifier must not\n\
    \          exceed the value 2^32-1 (4294967295 decimal).\n          7.1.4.  BIT\
    \ STRING\n          The BIT STRING type represents an enumeration of named bits.\n\
    \          This collection is assigned non-negative, contiguous values,\n    \
    \      starting at zero.  Only those named-bits so enumerated may be\n       \
    \   present in a value.\n          A requirement on \"standard\" MIB modules is\
    \ that the hyphen\n          character is not allowed as a part of the label name\
    \ for any\n          named-bit enumeration.\n          7.1.5.  IpAddress\n   \
    \       The IpAddress type represents a 32-bit internet address.  It\n       \
    \   is represented as an OCTET STRING of length 4, in network\n          byte-order.\n\
    \          Note that the IpAddress type is a tagged type for historical\n    \
    \      reasons.  Network addresses should be represented using an\n          invocation\
    \ of the TEXTUAL-CONVENTION macro [3].\n          RFC 1442                SMI\
    \ for SNMPv2              April 1993\n          7.1.6.  Counter32\n          The\
    \ Counter32 type represents a non-negative integer which\n          monotonically\
    \ increases until it reaches a maximum value of\n          2^32-1 (4294967295\
    \ decimal), when it wraps around and starts\n          increasing again from zero.\n\
    \          Counters have no defined \"initial\" value, and thus, a single\n  \
    \        value of a Counter has (in general) no information content.\n       \
    \   Discontinuities in the monotonically increasing value normally\n         \
    \ occur at re-initialization of the management system, and at\n          other\
    \ times as specified in the description of an object-type\n          using this\
    \ ASN.1 type.  If such other times can occur, for\n          example, the creation\
    \ of an object instance at times other\n          than re-initialization, then\
    \ a corresponding object should be\n          defined with a SYNTAX clause value\
    \ of TimeStamp (a textual\n          convention defined in [3]) indicating the\
    \ time of the last\n          discontinuity.\n          The value of the MAX-ACCESS\
    \ clause for objects with a SYNTAX\n          clause value of Counter32 is always\
    \ \"read-only\".\n          A DEFVAL clause is not allowed for objects with a\
    \ SYNTAX\n          clause value of Counter32.\n          7.1.7.  Gauge32\n  \
    \        The Gauge32 type represents a non-negative integer, which may\n     \
    \     increase or decrease, but shall never exceed a maximum value.\n        \
    \  The maximum value can not be greater than 2^32-1 (4294967295\n          decimal).\
    \  The value of a Gauge has its maximum value whenever\n          the information\
    \ being modeled is greater or equal to that\n          maximum value; if the information\
    \ being modeled subsequently\n          decreases below the maximum value, the\
    \ Gauge also decreases.\n          7.1.8.  TimeTicks\n          The TimeTicks\
    \ type represents a non-negative integer which\n          represents the time,\
    \ modulo 2^32 (4294967296 decimal), in\n          hundredths of a second between\
    \ two epochs.  When objects are\n          defined which use this ASN.1 type,\
    \ the description of the\n          object identifies both of the reference epochs.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        For example, [3] defines the TimeStamp textual convention\n         \
    \ which is based on the TimeTicks type.  With a TimeStamp, the\n          first\
    \ reference epoch is defined as when MIB-II's sysUpTime\n          [7] was zero,\
    \ and the second reference epoch is defined as the\n          current value of\
    \ sysUpTime.\n          7.1.9.  Opaque\n          The Opaque type is provided\
    \ solely for backward-compatibility,\n          and shall not be used for newly-defined\
    \ object types.\n          The Opaque type supports the capability to pass arbitrary\n\
    \          ASN.1 syntax.  A value is encoded using the ASN.1 Basic\n         \
    \ Encoding Rules [4] into a string of octets.  This, in turn, is\n          encoded\
    \ as an OCTET STRING, in effect \"double-wrapping\" the\n          original ASN.1\
    \ value.\n          Note that a conforming implementation need only be able to\n\
    \          accept and recognize opaquely-encoded data.  It need not be\n     \
    \     able to unwrap the data and then interpret its contents.\n          A requirement\
    \ on \"standard\" MIB modules is that no object may\n          have a SYNTAX clause\
    \ value of Opaque.\n          7.1.10.  NsapAddress\n          The NsapAddress\
    \ type represents an OSI address as a variable-\n          length OCTET STRING.\
    \  The first octet of the string contains a\n          binary value in the range\
    \ of 0..20, and indicates the length\n          in octets of the NSAP.  Following\
    \ the first octet, is the\n          NSAP, expressed in concrete binary notation,\
    \ starting with the\n          most significant octet.  A zero-length NSAP is\
    \ used as a\n          \"special\" address meaning \"the default NSAP\" (analogous\
    \ to the\n          IP address of 0.0.0.0).  Such an NSAP is encoded as a single\n\
    \          octet, containing the value 0.  All other NSAPs are encoded in\n  \
    \        at least 4 octets.\n          Note that the NsapAddress type is a tagged\
    \ type for historical\n          reasons.  Network addresses should be represented\
    \ using an\n          invocation of the TEXTUAL-CONVENTION macro [3].\n      \
    \    RFC 1442                SMI for SNMPv2              April 1993\n        \
    \  7.1.11.  Counter64\n          The Counter64 type represents a non-negative\
    \ integer which\n          monotonically increases until it reaches a maximum\
    \ value of\n          2^64-1 (18446744073709551615 decimal), when it wraps around\n\
    \          and starts increasing again from zero.\n          Counters have no\
    \ defined \"initial\" value, and thus, a single\n          value of a Counter\
    \ has (in general) no information content.\n          Discontinuities in the monotonically\
    \ increasing value normally\n          occur at re-initialization of the management\
    \ system, and at\n          other times as specified in the description of an\
    \ object-type\n          using this ASN.1 type.  If such other times can occur,\
    \ for\n          example, the creation of an object instance at times other\n\
    \          than re-initialization, then a corresponding object should be\n   \
    \       defined with a SYNTAX clause value of TimeStamp (a textual\n         \
    \ convention defined in [3]) indicating the time of the last\n          discontinuity.\n\
    \          The value of the MAX-ACCESS clause for objects with a SYNTAX\n    \
    \      clause value of Counter64 is always \"read-only\".\n          A requirement\
    \ on \"standard\" MIB modules is that the Counter64\n          type may be used\
    \ only if the information being modeled would\n          wrap in less than one\
    \ hour if the Counter32 type was used\n          instead.\n          A DEFVAL\
    \ clause is not allowed for objects with a SYNTAX\n          clause value of Counter64.\n\
    \          7.1.12.  UInteger32\n          The UInteger32 type represents integer-valued\
    \ information\n          between 0 and 2^32-1 inclusive (0 to 4294967295 decimal).\n\
    \          7.2.  Mapping of the UNITS clause\n          This UNITS clause, which\
    \ need not be present, contains a\n          textual definition of the units associated\
    \ with that object.\n          RFC 1442                SMI for SNMPv2        \
    \      April 1993\n          7.3.  Mapping of the MAX-ACCESS clause\n        \
    \  The MAX-ACCESS clause, which must be present, defines whether\n          it\
    \ makes \"protocol sense\" to read, write and/or create an\n          instance\
    \ of the object.  This is the maximal level of access\n          for the object.\
    \  (This maximal level of access is independent\n          of any administrative\
    \ authorization policy.)\n          The value \"read-write\" indicates that read\
    \ and write access\n          make \"protocol sense\", but create does not.  The\
    \ value \"read-\n          create\" indicates that read, write and create access\
    \ make\n          \"protocol sense\".  The value \"not-accessible\" indicates\
    \ either\n          an auxiliary object (see Section 7.7) or an object which is\n\
    \          accessible only via a notificationn (e.g., snmpTrapOID [5]).\n    \
    \      These values are ordered, from least to greatest: \"not-\n          accessible\"\
    , \"read-only\", \"read-write\", \"read-create\".\n          If any columnar object\
    \ in a conceptual row has \"read-create\"\n          as its maximal level of access,\
    \ then no other columnar object\n          of the same conceptual row may have\
    \ a maximal access of\n          \"read-write\".  (Note that \"read-create\" is\
    \ a superset of\n          \"read-write\".)\n          7.4.  Mapping of the STATUS\
    \ clause\n          The STATUS clause, which must be present, indicates whether\n\
    \          this definition is current or historic.\n          The values \"current\"\
    , and \"obsolete\" are self-explanatory.\n          The \"deprecated\" value indicates\
    \ that the object is obsolete,\n          but that an implementor may wish to\
    \ support that object to\n          foster interoperability with older implementations.\n\
    \          7.5.  Mapping of the DESCRIPTION clause\n          The DESCRIPTION\
    \ clause, which must be present, contains a\n          textual definition of that\
    \ object which provides all semantic\n          definitions necessary for implementation,\
    \ and should embody\n          any information which would otherwise be communicated\
    \ in any\n          ASN.1 commentary annotations associated with the object.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        7.6.  Mapping of the REFERENCE clause\n          The REFERENCE clause,\
    \ which need not be present, contains a\n          textual cross-reference to\
    \ an object defined in some other\n          information module.  This is useful\
    \ when de-osifying a MIB\n          module produced by some other organization.\n\
    \          7.7.  Mapping of the INDEX clause\n          The INDEX clause, which\
    \ must be present if that object\n          corresponds to a conceptual row (unless\
    \ an AUGMENTS clause is\n          present instead), and must be absent otherwise,\
    \ defines\n          instance identification information for the columnar objects\n\
    \          subordinate to that object.\n          Management operations apply\
    \ exclusively to scalar objects.\n          However, it is convenient for developers\
    \ of management\n          applications to impose imaginary, tabular structures\
    \ on the\n          ordered collection of objects that constitute the MIB.  Each\n\
    \          such conceptual table contains zero or more rows, and each row\n  \
    \        may contain one or more scalar objects, termed columnar\n          objects.\
    \  This conceptualization is formalized by using the\n          OBJECT-TYPE macro\
    \ to define both an object which corresponds\n          to a table and an object\
    \ which corresponds to a row in that\n          table.  A conceptual table has\
    \ SYNTAX of the form:\n               SEQUENCE OF <EntryType>\n          where\
    \ <EntryType> refers to the SEQUENCE type of its\n          subordinate conceptual\
    \ row.  A conceptual row has SYNTAX of\n          the form:\n               <EntryType>\n\
    \          where <EntryType> is a SEQUENCE type defined as follows:\n        \
    \       <EntryType> ::= SEQUENCE { <type1>, ... , <typeN> }\n          where there\
    \ is one <type> for each subordinate object, and\n          each <type> is of\
    \ the form:\n               <descriptor> <syntax>\n          where <descriptor>\
    \ is the descriptor naming a subordinate\n          RFC 1442                SMI\
    \ for SNMPv2              April 1993\n          object, and <syntax> has the value\
    \ of that subordinate\n          object's SYNTAX clause, optionally omitting the\
    \ sub-typing\n          information.  Further, these ASN.1 types are always present\n\
    \          (the DEFAULT and OPTIONAL clauses are disallowed in the\n         \
    \ SEQUENCE definition).  The MAX-ACCESS clause for conceptual\n          tables\
    \ and rows is \"not-accessible\".\n          For leaf objects which are not columnar\
    \ objects, instances of\n          the object are identified by appending a sub-identifier\
    \ of\n          zero to the name of that object.  Otherwise, the INDEX clause\n\
    \          of the conceptual row object superior to a columnar object\n      \
    \    defines instance identification information.\n          The instance identification\
    \ information in an INDEX clause\n          must specify object(s) such that value(s)\
    \ of those object(s)\n          will unambiguously distinguish a conceptual row.\
    \  The syntax\n          of those objects indicate how to form the instance-identifier:\n\
    \          (1)  integer-valued: a single sub-identifier taking the\n         \
    \      integer value (this works only for non-negative\n               integers);\n\
    \          (2)  string-valued, fixed-length strings (or variable-length\n    \
    \           preceded by the IMPLIED keyword): `n' sub-identifiers,\n         \
    \      where `n' is the length of the string (each octet of the\n            \
    \   string is encoded in a separate sub-identifier);\n          (3)  string-valued,\
    \ variable-length strings (not preceded by\n               the IMPLIED keyword):\
    \ `n+1' sub-identifiers, where `n' is\n               the length of the string\
    \ (the first sub-identifier is `n'\n               itself, following this, each\
    \ octet of the string is\n               encoded in a separate sub-identifier);\n\
    \          (4)  object identifier-valued: `n+1' sub-identifiers, where\n     \
    \          `n' is the number of sub-identifiers in the value (the\n          \
    \     first sub-identifier is `n' itself, following this, each\n             \
    \  sub-identifier in the value is copied);\n          (5)  IpAddress-valued: 4\
    \ sub-identifiers, in the familiar\n               a.b.c.d notation.\n       \
    \   (6)  NsapAddress-valued: `n' sub-identifiers, where `n' is the\n         \
    \      length of the value (each octet of the value is encoded\n             \
    \  in a separate sub-identifier);\n          RFC 1442                SMI for SNMPv2\
    \              April 1993\n          Note that the IMPLIED keyword can only be\
    \ present for objects\n          having a variable-length syntax (e.g., variable-length\
    \ strings\n          or object identifier-valued objects).  Further, the IMPLIED\n\
    \          keyword may appear at most once within the INDEX clause, and\n    \
    \      if so, is associated with the right-most object having a\n          variable-length\
    \ syntax.  Finally, the IMPLIED keyword may not\n          be used on a variable-length\
    \ string object if that string\n          might have a value of zero-length.\n\
    \          Instances identified by use of integer-valued objects should\n    \
    \      be numbered starting from one (i.e., not from zero).  The use\n       \
    \   of zero as a value for an integer-valued index object should\n          be\
    \ avoided, except in special cases.\n          Objects which are both specified\
    \ in the INDEX clause of a\n          conceptual row and also columnar objects\
    \ of the same\n          conceptual row are termed auxiliary objects.  The MAX-ACCESS\n\
    \          clause for newly-defined auxiliary objects is \"not-\n          accessible\"\
    .  However, a conceptual row must contain at least\n          one columnar object\
    \ which is not an auxiliary object (i.e.,\n          the value of the MAX-ACCESS\
    \ clause for such an object is\n          either \"read-only\" or \"read-create\"\
    ).\n          Note that objects specified in a conceptual row's INDEX clause\n\
    \          need not be columnar objects of that conceptual row.  In this\n   \
    \       situation, the DESCRIPTION clause of the conceptual row must\n       \
    \   include a textual explanation of how the objects which are\n          included\
    \ in the INDEX clause but not columnar objects of that\n          conceptual row,\
    \ are used in uniquely identifying instances of\n          the conceptual row's\
    \ columnar objects.\n          7.7.1.  Creation and Deletion of Conceptual Rows\n\
    \          For newly-defined conceptual rows which allow the creation of\n   \
    \       new object instances and the deletion of existing object\n          instances,\
    \ there should be one columnar object with a SYNTAX\n          clause value of\
    \ RowStatus (a textual convention defined in\n          [3]) and a MAX-ACCESS\
    \ clause value of read-create.  By\n          convention, this is termed the status\
    \ column for the\n          conceptual row.\n          RFC 1442              \
    \  SMI for SNMPv2              April 1993\n          7.8.  Mapping of the AUGMENTS\
    \ clause\n          The AUGMENTS clause, which must not be present unless the\n\
    \          object corresponds to a conceptual row, is an alternative to\n    \
    \      the INDEX clause.  Every object corresponding to a conceptual\n       \
    \   row has either an INDEX clause or an AUGMENTS clause.\n          If an object\
    \ corresponding to a conceptual row has an INDEX\n          clause, that row is\
    \ termed a base conceptual row;\n          alternatively, if the object has an\
    \ AUGMENTS clause, the row\n          is said to be a conceptual row augmentation,\
    \ where the\n          AUGMENTS clause names the object corresponding to the base\n\
    \          conceptual row which is augmented by this conceptual row\n        \
    \  extension.  Instances of subordinate columnar objects of a\n          conceptual\
    \ row extension are identified according to the INDEX\n          clause of the\
    \ base conceptual row corresponding to the object\n          named in the AUGMENTS\
    \ clause.  Further, instances of\n          subordinate columnar objects of a\
    \ conceptual row extension\n          exist according to the same semantics as\
    \ instances of\n          subordinate columnar objects of the base conceptual\
    \ row being\n          augmented.  As such, note that creation of a base conceptual\n\
    \          row implies the correspondent creation of any conceptual row\n    \
    \      augmentations.\n          For example, a MIB designer might wish to define\
    \ additional\n          columns in an \"enterprise-specific\" MIB which logically\
    \ extend\n          a conceptual row in a \"standard\" MIB.  The \"standard\"\
    \ MIB\n          definition of the conceptual row would include the INDEX\n  \
    \        clause and the \"enterprise-specific\" MIB would contain the\n      \
    \    definition of a conceptual row using the AUGMENTS clause.\n          Note\
    \ that a base conceptual row may be augmented by multiple\n          conceptual\
    \ row extensions.\n          7.8.1.  Relation between INDEX and AUGMENTS clauses\n\
    \          When defining instance identification information for a\n         \
    \ conceptual table:\n          (1)  If there is a one-to-one correspondence between\
    \ the\n               conceptual rows of this table and an existing table, then\n\
    \               the AUGMENTS clause should be used.\n          RFC 1442      \
    \          SMI for SNMPv2              April 1993\n          (2)  Otherwise, if\
    \ there is a sparse relationship between the\n               conceptuals rows\
    \ of this table and an existing table,\n               then an INDEX clause should\
    \ be used which is identical to\n               that in the existing table.\n\
    \          (3)  Otherwise, auxiliary objects should be defined within the\n  \
    \             conceptual row for the new table, and those objects\n          \
    \     should be used within the INDEX clause for the conceptual\n            \
    \   row.\n          7.9.  Mapping of the DEFVAL clause\n          The DEFVAL clause,\
    \ which need not be present, defines an\n          acceptable default value which\
    \ may be used at the discretion\n          of a SNMPv2 entity acting in an agent\
    \ role when an object\n          instance is created.\n          During conceptual\
    \ row creation, if an instance of a columnar\n          object is not present\
    \ as one of the operands in the\n          correspondent management protocol set\
    \ operation, then the\n          value of the DEFVAL clause, if present, indicates\
    \ an\n          acceptable default value that a SNMPv2 entity acting in an\n \
    \         agent role might use.\n          The value of the DEFVAL clause must,\
    \ of course, correspond to\n          the SYNTAX clause for the object.  If the\
    \ value is an OBJECT\n          IDENTIFIER, then it must be expressed as a single\
    \ ASN.1\n          identifier, and not as a collection of sub-identifiers.\n \
    \         Note that if an operand to the management protocol set\n          operation\
    \ is an instance of a read-only object, then the error\n          `notWritable'\
    \ [6] will be returned.  As such, the DEFVAL\n          clause can be used to\
    \ provide an acceptable default value that\n          a SNMPv2 entity acting in\
    \ an agent role might use.\n          By way of example, consider the following\
    \ possible DEFVAL\n          clauses:\n          RFC 1442                SMI for\
    \ SNMPv2              April 1993\n         ObjectSyntax        DEFVAL clause\n\
    \         -----------------   ------------\n         Integer32           1\n \
    \                            -- same for Gauge32, TimeTicks, UInteger32\n    \
    \     INTEGER             valid -- enumerated value\n         OCTET STRING   \
    \     'ffffffffffff'H\n         OBJECT IDENTIFIER   sysDescr\n         BIT STRING\
    \          { primary, secondary } -- enumerated values\n               IpAddress\
    \           'c0210415'H -- 192.33.4.21\n          Object types with SYNTAX of\
    \ Counter32 and Counter64 may not\n          have DEFVAL clauses, since they do\
    \ not have defined initial\n          values.  However, it is recommended that\
    \ they be initialized\n          to zero.\n          7.10.  Mapping of the OBJECT-TYPE\
    \ value\n          The value of an invocation of the OBJECT-TYPE macro is the\n\
    \          name of the object, which is an OBJECT IDENTIFIER, an\n          administratively\
    \ assigned name.\n          When an OBJECT IDENTIFIER is assigned to an object:\n\
    \          (1)  If the object corresponds to a conceptual table, then\n      \
    \         only a single assignment, that for a conceptual row, is\n          \
    \     present immediately beneath that object.  The\n               administratively\
    \ assigned name for the conceptual row\n               object is derived by appending\
    \ a sub-identifier of \"1\" to\n               the administratively assigned name\
    \ for the conceptual\n               table.\n          (2)  If the object corresponds\
    \ to a conceptual row, then at\n               least one assignment, one for each\
    \ column in the\n               conceptual row, is present beneath that object.\
    \  The\n               administratively assigned name for each column is derived\n\
    \               by appending a unique, positive sub-identifier to the\n      \
    \         administratively assigned name for the conceptual row.\n          (3)\
    \  Otherwise, no other OBJECT IDENTIFIERs which are\n               subordinate\
    \ to the object may be assigned.\n          Note that the final sub-identifier\
    \ of any administratively\n          assigned name for an object shall be positive.\
    \  A zero-valued\n          final sub-identifier is reserved for future use.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        Further note that although conceptual tables and rows are\n         \
    \ given administratively assigned names, these conceptual\n          objects may\
    \ not be manipulated in aggregate form by the\n          management protocol.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        7.11.  Usage Example\n          Consider how one might define a conceptual\
    \ table and its\n          subordinates.\n          evalSlot OBJECT-TYPE\n   \
    \           SYNTAX      INTEGER\n              MAX-ACCESS  read-only\n       \
    \       STATUS      current\n              DESCRIPTION\n                     \
    \ \"The index number of the first unassigned entry in\n                      the\
    \ evaluation table.\n                      A management station should create\
    \ new entries in\n                      the evaluation table using this algorithm:\
    \ first,\n                      issue a management protocol retrieval operation\
    \ to\n                      determine the value of evalSlot; and, second,\n  \
    \                    issue a management protocol set operation to\n          \
    \            create an instance of the evalStatus object\n                   \
    \   setting its value to underCreation(1).  If this\n                      latter\
    \ operation succeeds, then the management\n                      station may continue\
    \ modifying the instances\n                      corresponding to the newly created\
    \ conceptual row,\n                      without fear of collision with other\
    \ management\n                      stations.\"\n              ::= { eval 1 }\n\
    \          evalTable OBJECT-TYPE\n              SYNTAX      SEQUENCE OF EvalEntry\n\
    \              MAX-ACCESS  not-accessible\n              STATUS      current\n\
    \              DESCRIPTION\n                      \"The (conceptual) evaluation\
    \ table.\"\n              ::= { eval 2 }\n          evalEntry OBJECT-TYPE\n  \
    \            SYNTAX      EvalEntry\n              MAX-ACCESS  not-accessible\n\
    \              STATUS      current\n              DESCRIPTION\n              \
    \        \"An entry (conceptual row) in the evaluation\n                     \
    \ table.\"\n              INDEX   { evalIndex }\n              ::= { evalTable\
    \ 1 }\n          RFC 1442                SMI for SNMPv2              April 1993\n\
    \          EvalEntry ::=\n              SEQUENCE {\n                  evalIndex\
    \       Integer32,\n                  evalString      DisplayString,\n       \
    \           evalValue       Integer32,\n                  evalStatus      RowStatus\n\
    \              }\n          evalIndex OBJECT-TYPE\n              SYNTAX      Integer32\n\
    \              MAX-ACCESS  not-accessible\n              STATUS      current\n\
    \              DESCRIPTION\n                      \"The auxiliary variable used\
    \ for identifying\n                      instances of the columnar objects in\
    \ the\n                      evaluation table.\"\n                  ::= { evalEntry\
    \ 1 }\n          evalString OBJECT-TYPE\n              SYNTAX      DisplayString\n\
    \              MAX-ACCESS  read-create\n              STATUS      current\n  \
    \            DESCRIPTION\n                      \"The string to evaluate.\"\n\
    \                  ::= { evalEntry 2 }\n          evalValue OBJECT-TYPE\n    \
    \          SYNTAX      Integer32\n              MAX-ACCESS  read-only\n      \
    \        STATUS      current\n              DESCRIPTION\n                    \
    \  \"The value when evalString was last executed.\"\n              DEFVAL  { 0\
    \ }\n                  ::= { evalEntry 3 }\n          evalStatus OBJECT-TYPE\n\
    \              SYNTAX      RowStatus\n              MAX-ACCESS  read-create\n\
    \              STATUS      current\n              DESCRIPTION\n              \
    \        \"The status column used for creating, modifying,\n                 \
    \     and deleting instances of the columnar objects in\n                    \
    \  the evaluation  table.\"\n              DEFVAL  { active }\n              \
    \    ::= { evalEntry 4 }\n          RFC 1442                SMI for SNMPv2   \
    \           April 1993\n          8.  Mapping of the NOTIFICATION-TYPE macro\n\
    \          The NOTIFICATION-TYPE macro is used to define the information\n   \
    \       contained within an unsolicited transmission of management\n         \
    \ information (i.e., within either a SNMPv2-Trap-PDU or\n          InformRequest-PDU).\
    \  It should be noted that the expansion of\n          the NOTIFICATION-TYPE macro\
    \ is something which conceptually\n          happens during implementation and\
    \ not during run-time.\n          8.1.  Mapping of the OBJECTS clause\n      \
    \    The OBJECTS clause, which need not be present, defines the\n          ordered\
    \ sequence of MIB objects which are contained within\n          every instance\
    \ of the notification.\n          8.2.  Mapping of the STATUS clause\n       \
    \   The STATUS clause, which must be present, indicates whether\n          this\
    \ definition is current or historic.\n          The values \"current\", and \"\
    obsolete\" are self-explanatory.\n          The \"deprecated\" value indicates\
    \ that the notification is\n          obsolete, but that an implementor may wish\
    \ to support that\n          object to foster interoperability with older implementations.\n\
    \          8.3.  Mapping of the DESCRIPTION clause\n          The DESCRIPTION\
    \ clause, which must be present, contains a\n          textual definition of the\
    \ notification which provides all\n          semantic definitions necessary for\
    \ implementation, and should\n          embody any information which would otherwise\
    \ be communicated\n          in any ASN.1 commentary annotations associated with\
    \ the\n          object.  In particular, the DESCRIPTION clause should document\n\
    \          which instances of the objects mentioned in the OBJECTS clause\n  \
    \        should be contained within notifications of this type.\n          8.4.\
    \  Mapping of the REFERENCE clause\n          The REFERENCE clause, which need\
    \ not be present, contains a\n          textual cross-reference to a notification\
    \ defined in some\n          other information module.  This is useful when de-osifying\
    \ a\n          RFC 1442                SMI for SNMPv2              April 1993\n\
    \          MIB module produced by some other organization.\n          8.5.  Mapping\
    \ of the NOTIFICATION-TYPE value\n          The value of an invocation of the\
    \ NOTIFICATION-TYPE macro is\n          the name of the notification, which is\
    \ an OBJECT IDENTIFIER,\n          an administratively assigned name.\n      \
    \    Sections 4.2.6 and 4.2.7 of [6] describe how the\n          NOTIFICATION-TYPE\
    \ macro is used to generate a SNMPv2-Trap-PDU\n          or InformRequest-PDU,\
    \ respectively.\n          RFC 1442                SMI for SNMPv2            \
    \  April 1993\n          8.6.  Usage Example\n          Consider how a linkUp\
    \ trap might be described:\n          linkUp NOTIFICATION-TYPE\n             \
    \ OBJECTS { ifIndex }\n              STATUS  current\n              DESCRIPTION\n\
    \                      \"A linkUp trap signifies that the SNMPv2 entity,\n   \
    \                   acting in an agent role, recognizes that one of\n        \
    \              the communication links represented in its\n                  \
    \    configuration has come up.\"\n              ::= { snmpTraps 4 }\n       \
    \   According to this invocation, the trap authoritatively\n          identified\
    \ as\n               { snmpTraps 4 }\n          is used to report a link coming\
    \ up.\n          Note that a SNMPv2 entity acting in an agent role can be\n  \
    \        configured to send this trap to zero or more SNMPv2 entities\n      \
    \    acting in a manager role, depending on the contents of the\n          aclTable\
    \ and viewTable [8] tables.  For example, by judicious\n          use of the viewTable,\
    \ a SNMPv2 entity acting in an agent role\n          might be configured to send\
    \ all linkUp traps to one particular\n          SNMPv2 entity, and linkUp traps\
    \ for only certain interfaces to\n          other SNMPv2 entities.\n         \
    \ RFC 1442                SMI for SNMPv2              April 1993\n          9.\
    \  Refined Syntax\n          Some macros allow an object's syntax to be refined\
    \ (e.g., the\n          SYNTAX clause in the MODULE-COMPLIANCE macro [2]).  However,\n\
    \          not all refinements of syntax are appropriate.  In particular,\n  \
    \        the object's primitive or application type must not be\n          changed.\n\
    \          Further, the following restrictions apply:\n                      \
    \          Restrictions to Refinement on\n      object syntax         range  \
    \ enumeration     size    repertoire\n      -----------------     -----   -----------\
    \     ----    ----------\n                INTEGER      (1)        (2)        \
    \   -         -\n           OCTET STRING       -          -           (3)    \
    \   (4)\n      OBJECT IDENTIFIER       -          -            -         -\n \
    \            BIT STRING       -         (2)           -         -\n          \
    \    IpAddress       -          -            -         -\n              Counter32\
    \       -          -            -         -\n                Gauge32      (1)\
    \         -            -         -\n              TimeTicks       -          -\
    \            -         -\n            NsapAddress       -          -         \
    \   -         -\n              Counter64       -          -            -     \
    \    -\n          where:\n          (1)  the range of permitted values may be\
    \ refined by raising\n               the lower-bounds, by reducing the upper-bounds,\
    \ and/or by\n               reducing the alternative value/range choices;\n  \
    \        (2)  the enumeration of named-values may be refined by\n            \
    \   removing one or more named-values;\n          (3)  the size in characters\
    \ of the value may be refined by\n               raising the lower-bounds, by\
    \ reducing the upper-bounds,\n               and/or by reducing the alternative\
    \ size choices; or,\n          (4)  the repertoire of characters in the value\
    \ may be reduced\n               by further sub-typing.\n          Otherwise no\
    \ refinements are possible.\n          Note that when refining an object with\
    \ a SYNTAX clause value\n          of Integer32 or UInteger32, the refined SYNTAX\
    \ is expressed as\n          an INTEGER and the restrictions of the table above\
    \ are used.\n          RFC 1442                SMI for SNMPv2              April\
    \ 1993\n          10.  Extending an Information Module\n          As experience\
    \ is gained with a published information module,\n          it may be desirable\
    \ to revise that information module.\n          To begin, the invocation of the\
    \ MODULE-IDENTITY macro should\n          be updated to include information about\
    \ the revision.\n          Usually, this consists of updating the LAST-UPDATED\
    \ clause and\n          adding a pair of REVISION and DESCRIPTION clauses.  However,\n\
    \          other existing clauses in the invocation may be updated.\n        \
    \  Note that the module's label (e.g., \"FIZBIN-MIB\" from the\n          example\
    \ in Section 5.8), is not changed when the information\n          module is revised.\n\
    \          10.1.  Object Assignments\n          If any non-editorial change is\
    \ made to any clause of a object\n          assignment, then the OBJECT IDENTIFIER\
    \ value associated with\n          that object assignment must also be changed,\
    \ along with its\n          associated descriptor.\n          10.2.  Object Definitions\n\
    \          An object definition may be revised in any of the following\n     \
    \     ways:\n          (1)  A SYNTAX clause containing an enumerated INTEGER may\
    \ have\n               new enumerations added or existing labels changed.\n  \
    \        (2)  A STATUS clause value of \"current\" may be revised as\n       \
    \        \"deprecated\" or \"obsolete\".  Similarly, a STATUS clause\n       \
    \        value of \"deprecated\" may be revised as \"obsolete\".\n          (3)\
    \  A DEFVAL clause may be added or updated.\n          (4)  A REFERENCE clause\
    \ may be added or updated.\n          (5)  A UNITS clause may be added.\n    \
    \      (6)  A conceptual row may be augmented by adding new columnar\n       \
    \        objects at the end of the row.\n          RFC 1442                SMI\
    \ for SNMPv2              April 1993\n          (7)  Entirely new objects may\
    \ be defined, named with\n               previously unassigned OBJECT IDENTIFIER\
    \ values.\n          Otherwise, if the semantics of any previously defined object\n\
    \          are changed (i.e., if a non-editorial change is made to any\n     \
    \     clause other those specifically allowed above), then the\n          OBJECT\
    \ IDENTIFIER value associated with that object must also\n          be changed.\n\
    \          Note that changing the descriptor associated with an existing\n   \
    \       object is considered a semantic change, as these strings may\n       \
    \   be used in an IMPORTS statement.\n          Finally, note that if an object\
    \ has the value of its STATUS\n          clause changed, then the value of its\
    \ DESCRIPTION clause\n          should be updated accordingly.\n          10.3.\
    \  Notification Definitions\n          A notification definition may be revised\
    \ in any of the\n          following ways:\n          (1)  A REFERENCE clause\
    \ may be added or updated.\n          Otherwise, if the semantics of any previously\
    \ defined\n          notification are changed (i.e., if a non-editorial change\
    \ is\n          made to any clause other those specifically allowed above),\n\
    \          then the OBJECT IDENTIFIER value associated with that\n          notification\
    \ must also be changed.\n          Note that changing the descriptor associated\
    \ with an existing\n          notification is considered a semantic change, as\
    \ these strings\n          may be used in an IMPORTS statement.\n          Finally,\
    \ note that if an object has the value of its STATUS\n          clause changed,\
    \ then the value of its DESCRIPTION clause\n          should be updated accordingly.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        11.  Appendix: de-OSIfying a MIB module\n          There has been an\
    \ increasing amount of work recently on taking\n          MIBs defined by other\
    \ organizations (e.g., the IEEE) and de-\n          osifying them for use with\
    \ the Internet-standard network\n          management framework.  The steps to\
    \ achieve this are\n          straight-forward, though tedious.  Of course, it\
    \ is helpful to\n          already be experienced in writing MIB modules for use\
    \ with the\n          Internet-standard network management framework.\n      \
    \    The first step is to construct a skeletal MIB module, as shown\n        \
    \  earlier in Section 5.8.  The next step is to categorize the\n          objects\
    \ into groups.  Optional objects are not permitted.\n          Thus, when a MIB\
    \ module is created, optional objects must be\n          placed in a additional\
    \ groups, which, if implemented, all\n          objects in the group must be implemented.\
    \  For the first pass,\n          it is wisest to simply ignore any optional objects\
    \ in the\n          original MIB: experience shows it is better to define a core\n\
    \          MIB module first, containing only essential objects; later, if\n  \
    \        experience demands, other objects can be added.\n          11.1.  Managed\
    \ Object Mapping\n          Next for each managed object class, determine whether\
    \ there\n          can exist multiple instances of that managed object class.\
    \  If\n          not, then for each of its attributes, use the OBJECT-TYPE\n \
    \         macro to make an equivalent definition.\n          Otherwise, if multiple\
    \ instances of the managed object class\n          can exist, then define a conceptual\
    \ table having conceptual\n          rows each containing a columnar object for\
    \ each of the managed\n          object class's attributes.  If the managed object\
    \ class is\n          contained within the containment tree of another managed\n\
    \          object class, then the assignment of an object is normally\n      \
    \    required for each of the \"distinguished attributes\" of the\n          containing\
    \ managed object class.  If they do not already exist\n          within the MIB\
    \ module, then they can be added via the\n          definition of additional columnar\
    \ objects in the conceptual\n          row corresponding to the contained managed\
    \ object class.\n          In defining a conceptual row, it is useful to consider\
    \ the\n          optimization of network management operations which will act\n\
    \          upon its columnar objects.  In particular, it is wisest to\n      \
    \    avoid defining more columnar objects within a conceptual row,\n         \
    \ RFC 1442                SMI for SNMPv2              April 1993\n          than\
    \ can fit in a single PDU.  As a rule of thumb, a\n          conceptual row should\
    \ contain no more than approximately 20\n          objects.  Similarly, or as\
    \ a way to abide by the \"20 object\n          guideline\", columnar objects should\
    \ be grouped into tables\n          according to the expected grouping of network\
    \ management\n          operations upon them.  As such, the content of conceptual\
    \ rows\n          should reflect typical access scenarios, e.g., they should be\n\
    \          organized along functional lines such as one row for\n          statistics\
    \ and another row for parameters, or along usage\n          lines such as commonly-needed\
    \ objects versus rarely-needed\n          objects.\n          On the other hand,\
    \ the definition of conceptual rows where the\n          number of columnar objects\
    \ used as indexes outnumbers the\n          number used to hold information, should\
    \ also be avoided.  In\n          particular, the splitting of a managed object\
    \ class's\n          attributes into many conceptual tables should not be used\
    \ as a\n          way to obtain the same degree of flexibility/complexity as is\n\
    \          often found in MIBs with a myriad of optionals.\n          11.1.1.\
    \  Mapping to the SYNTAX clause\n          When mapping to the SYNTAX clause of\
    \ the OBJECT-type macro:\n          (1)  An object with BOOLEAN syntax becomes\
    \ a TruthValue [3].\n          (2)  An object with INTEGER syntax becomes an Integer32.\n\
    \          (3)  An object with ENUMERATED syntax becomes an INTEGER with\n   \
    \            enumerations, taking any of the values given which can be\n     \
    \          represented with an Integer32.\n          (4)  An object with BIT STRING\
    \ syntax but no enumerations\n               becomes an OCTET STRING.\n      \
    \    (5)  An object with a character string syntax becomes either\n          \
    \     an OCTET STRING, or a DisplayString [3], depending on the\n            \
    \   repertoire of the character string.\n          (6)  A non-tabular object with\
    \ a complex syntax, such as REAL\n               or EXTERNAL, must be decomposed,\
    \ usually into an OCTET\n               STRING (if sensible).  As a rule, any\
    \ object with a\n               complicated syntax should be avoided.\n      \
    \    RFC 1442                SMI for SNMPv2              April 1993\n        \
    \  (7)  Tabular objects must be decomposed into rows of columnar\n           \
    \    objects.\n          11.1.2.  Mapping to the UNITS clause\n          If the\
    \ description of this managed object defines a unit-\n          basis, then mapping\
    \ to this clause is straight-forward.\n          11.1.3.  Mapping to the MAX-ACCESS\
    \ clause\n          This is straight-forward.\n          11.1.4.  Mapping to the\
    \ STATUS clause\n          This is straight-forward.\n          11.1.5.  Mapping\
    \ to the DESCRIPTION clause\n          This is straight-forward: simply copy the\
    \ text, making sure\n          that any embedded double quotation marks are sanitized\
    \ (i.e.,\n          replaced with single-quotes or removed).\n          11.1.6.\
    \  Mapping to the REFERENCE clause\n          This is straight-forward: simply\
    \ include a textual reference\n          to the object being mapped, the document\
    \ which defines the\n          object, and perhaps a page number in the document.\n\
    \          11.1.7.  Mapping to the INDEX clause\n          If necessary, decide\
    \ how instance-identifiers for columnar\n          objects are to be formed and\
    \ define this clause accordingly.\n          11.1.8.  Mapping to the DEFVAL clause\n\
    \          Decide if a meaningful default value can be assigned to the\n     \
    \     object being mapped, and if so, define the DEFVAL clause\n          accordingly.\n\
    \          RFC 1442                SMI for SNMPv2              April 1993\n  \
    \        11.2.  Action Mapping\n          Actions are modeled as read-write objects,\
    \ in which writing a\n          particular value results in a state change.  (Usually,\
    \ as a\n          part of this state change, some action might take place.)\n\
    \          11.2.1.  Mapping to the SYNTAX clause\n          Usually the Integer32\
    \ syntax is used with a distinguished\n          value provided for each action\
    \ that the object provides access\n          to.  In addition, there is usually\
    \ one other distinguished\n          value, which is the one returned when the\
    \ object is read.\n          11.2.2.  Mapping to the MAX-ACCESS clause\n     \
    \     Always use read-write or read-create.\n          11.2.3.  Mapping to the\
    \ STATUS clause\n          This is straight-forward.\n          11.2.4.  Mapping\
    \ to the DESCRIPTION clause\n          This is straight-forward: simply copy the\
    \ text, making sure\n          that any embedded double quotation marks are sanitized\
    \ (i.e.,\n          replaced with single-quotes or removed).\n          11.2.5.\
    \  Mapping to the REFERENCE clause\n          This is straight-forward: simply\
    \ include a textual reference\n          to the action being mapped, the document\
    \ which defines the\n          action, and perhaps a page number in the document.\n\
    \          11.3.  Event Mapping\n          Events are modeled as SNMPv2 notifications\
    \ using\n          NOTIFICATION-TYPE macro.  However, recall that SNMPv2\n   \
    \       emphasizes trap-directed polling.  As such, few, and usually\n       \
    \   no, notifications, need be defined for any MIB module.\n          RFC 1442\
    \                SMI for SNMPv2              April 1993\n          11.3.1.  Mapping\
    \ to the STATUS clause\n          This is straight-forward.\n          11.3.2.\
    \  Mapping to the DESCRIPTION clause\n          This is straight-forward: simply\
    \ copy the text, making sure\n          that any embedded double quotation marks\
    \ are sanitized (i.e.,\n          replaced with single-quotes or removed).\n \
    \         11.3.3.  Mapping to the REFERENCE clause\n          This is straight-forward:\
    \ simply include a textual reference\n          to the notification being mapped,\
    \ the document which defines\n          the notification, and perhaps a page number\
    \ in the document.\n          RFC 1442                SMI for SNMPv2         \
    \     April 1993\n          12.  Acknowledgements\n          The section on object\
    \ definitions (and MIB de-osification) is\n          based, in part, on RFCs 1155\
    \ and 1212.  The IMPLIED keyword is\n          based on a conversation with David\
    \ T. Perkins in December,\n          1991.\n          The section on trap definitions\
    \ is based, in part, on RFC\n          1215.\n          Finally, the comments\
    \ of the SNMP version 2 working group are\n          gratefully acknowledged:\n\
    \               Beth Adams, Network Management Forum\n               Steve Alexander,\
    \ INTERACTIVE Systems Corporation\n               David Arneson, Cabletron Systems\n\
    \               Toshiya Asaba\n               Fred Baker, ACC\n              \
    \ Jim Barnes, Xylogics, Inc.\n               Brian Bataille\n               Andy\
    \ Bierman, SynOptics Communications, Inc.\n               Uri Blumenthal, IBM\
    \ Corporation\n               Fred Bohle, Interlink\n               Jack Brown\n\
    \               Theodore Brunner, Bellcore\n               Stephen F. Bush, GE\
    \ Information Services\n               Jeffrey D. Case, University of Tennessee,\
    \ Knoxville\n               John Chang, IBM Corporation\n               Szusin\
    \ Chen, Sun Microsystems\n               Robert Ching\n               Chris Chiotasso,\
    \ Ungermann-Bass\n               Bobby A. Clay, NASA/Boeing\n               John\
    \ Cooke, Chipcom\n               Tracy Cox, Bellcore\n               Juan Cruz,\
    \ Datability, Inc.\n               David Cullerot, Cabletron Systems\n       \
    \        Cathy Cunningham, Microcom\n               James R. (Chuck) Davin, Bellcore\n\
    \               Michael Davis, Clearpoint\n               Mike Davison, FiberCom\n\
    \               Cynthia DellaTorre, MITRE\n               Taso N. Devetzis, Bellcore\n\
    \               Manual Diaz, DAVID Systems, Inc.\n               Jon Dreyer, Sun\
    \ Microsystems\n               David Engel, Optical Data Systems\n          RFC\
    \ 1442                SMI for SNMPv2              April 1993\n               Mike\
    \ Erlinger, Lexcel\n               Roger Fajman, NIH\n               Daniel Fauvarque,\
    \ Sun Microsystems\n               Karen Frisa, CMU\n               Shari Galitzer,\
    \ MITRE\n               Shawn Gallagher, Digital Equipment Corporation\n     \
    \          Richard Graveman, Bellcore\n               Maria Greene, Xyplex, Inc.\n\
    \               Michel Guittet, Apple\n               Robert Gutierrez, NASA\n\
    \               Bill Hagerty, Cabletron Systems\n               Gary W. Haney,\
    \ Martin Marietta Energy Systems\n               Patrick Hanil, Nokia Telecommunications\n\
    \               Matt Hecht, SNMP Research, Inc.\n               Edward A. Heiner,\
    \ Jr., Synernetics Inc.\n               Susan E. Hicks, Martin Marietta Energy\
    \ Systems\n               Geral Holzhauer, Apple\n               John Hopprich,\
    \ DAVID Systems, Inc.\n               Jeff Hughes, Hewlett-Packard\n         \
    \      Robin Iddon, Axon Networks, Inc.\n               David Itusak\n       \
    \        Kevin M. Jackson, Concord Communications, Inc.\n               Ole J.\
    \ Jacobsen, Interop Company\n               Ronald Jacoby, Silicon Graphics, Inc.\n\
    \               Satish Joshi, SynOptics Communications, Inc.\n               Frank\
    \ Kastenholz, FTP Software\n               Mark Kepke, Hewlett-Packard\n     \
    \          Ken Key, SNMP Research, Inc.\n               Zbiginew Kielczewski,\
    \ Eicon\n               Jongyeoi Kim\n               Andrew Knutsen, The Santa\
    \ Cruz Operation\n               Michael L. Kornegay, VisiSoft\n             \
    \  Deirdre C. Kostik, Bellcore\n               Cheryl Krupczak, Georgia Tech\n\
    \               Mark S. Lewis, Telebit\n               David Lin\n           \
    \    David Lindemulder, AT&T/NCR\n               Ben Lisowski, Sprint\n      \
    \         David Liu, Bell-Northern Research\n               John Lunny, The Wollongong\
    \ Group\n               Robert C. Lushbaugh Martin, Marietta Energy Systems\n\
    \               Michael Luufer, BBN\n               Carl Madison, Star-Tek, Inc.\n\
    \               Keith McCloghrie, Hughes LAN Systems\n               Evan McGinnis,\
    \ 3Com Corporation\n          RFC 1442                SMI for SNMPv2         \
    \     April 1993\n               Bill McKenzie, IBM Corporation\n            \
    \   Donna McMaster, SynOptics Communications, Inc.\n               John Medicke,\
    \ IBM Corporation\n               Doug Miller, Telebit\n               Dave Minnich,\
    \ FiberCom\n               Mohammad Mirhakkak, MITRE\n               Rohit Mital,\
    \ Protools\n               George Mouradian, AT&T Bell Labs\n               Patrick\
    \ Mullaney, Cabletron Systems\n               Dan Myers, 3Com Corporation\n  \
    \             Rina Nathaniel, Rad Network Devices Ltd.\n               Hien V.\
    \ Nguyen, Sprint\n               Mo Nikain\n               Tom Nisbet\n      \
    \         William B. Norton, MERIT\n               Steve Onishi, Wellfleet Communications,\
    \ Inc.\n               David T. Perkins, SynOptics Communications, Inc.\n    \
    \           Carl Powell, BBN\n               Ilan Raab, SynOptics Communications,\
    \ Inc.\n               Richard Ramons, AT&T\n               Venkat D. Rangan,\
    \ Metric Network Systems, Inc.\n               Louise Reingold, Sprint\n     \
    \          Sam Roberts, Farallon Computing, Inc.\n               Kary Robertson,\
    \ Concord Communications, Inc.\n               Dan Romascanu, Lannet Data Communications\
    \ Ltd.\n               Marshall T. Rose, Dover Beach Consulting, Inc.\n      \
    \         Shawn A. Routhier, Epilogue Technology Corporation\n               Chris\
    \ Rozman\n               Asaf Rubissa, Fibronics\n               Jon Saperia,\
    \ Digital Equipment Corporation\n               Michael Sapich\n             \
    \  Mike Scanlon, Interlan\n               Sam Schaen, MITRE\n               John\
    \ Seligson, Ultra Network Technologies\n               Paul A. Serice, Corporation\
    \ for Open Systems\n               Chris Shaw, Banyan Systems\n              \
    \ Timon Sloane\n               Robert Snyder, Cisco Systems\n               Joo\
    \ Young Song\n               Roy Spitier, Sprint\n               Einar Stefferud,\
    \ Network Management Associates\n               John Stephens, Cayman Systems,\
    \ Inc.\n               Robert L. Stewart, Xyplex, Inc. (chair)\n             \
    \  Kaj Tesink, Bellcore\n               Dean Throop, Data General\n          RFC\
    \ 1442                SMI for SNMPv2              April 1993\n               Ahmet\
    \ Tuncay, France Telecom-CNET\n               Maurice Turcotte, Racal Datacom\n\
    \               Warren Vik, INTERACTIVE Systems Corporation\n               Yannis\
    \ Viniotis\n               Steven L. Waldbusser, Carnegie Mellon Universitty\n\
    \               Timothy M. Walden, ACC\n               Alice Wang, Sun Microsystems\n\
    \               James Watt, Newbridge\n               Luanne Waul, Timeplex\n\
    \               Donald E. Westlake III, Digital Equipment Corporation\n      \
    \         Gerry White\n               Bert Wijnen, IBM Corporation\n         \
    \      Peter Wilson, 3Com Corporation\n               Steven Wong, Digital Equipment\
    \ Corporation\n               Randy Worzella, IBM Corporation\n              \
    \ Daniel Woycke, MITRE\n               Honda Wu\n               Jeff Yarnell,\
    \ Protools\n               Chris Young, Cabletron\n               Kiho Yum, 3Com\
    \ Corporation\n          RFC 1442                SMI for SNMPv2              April\
    \ 1993\n          13.  References\n          [1]  Information processing systems\
    \ - Open Systems\n               Interconnection - Specification of Abstract Syntax\n\
    \               Notation One (ASN.1), International Organization for\n       \
    \        Standardization.  International Standard 8824, (December,\n         \
    \      1987).\n          [2]  Case, J., McCloghrie, K., Rose, M., and Waldbusser,\
    \ S.,\n               \"Conformance Statements for version 2 of the the Simple\n\
    \               Network Management Protocol (SNMPv2)\", RFC 1444, SNMP\n     \
    \          Research, Inc., Hughes LAN Systems, Dover Beach\n               Consulting,\
    \ Inc., Carnegie Mellon University, April 1993.\n          [3]  Case, J., McCloghrie,\
    \ K., Rose, M., and Waldbusser, S.,\n               \"Textual Conventions for\
    \ version 2 of the the Simple\n               Network Management Protocol (SNMPv2)\"\
    , RFC 1443, SNMP\n               Research, Inc., Hughes LAN Systems, Dover Beach\n\
    \               Consulting, Inc., Carnegie Mellon University, April 1993.\n  \
    \        [4]  Information processing systems - Open Systems\n               Interconnection\
    \ - Specification of Basic Encoding Rules\n               for Abstract Syntax\
    \ Notation One (ASN.1), International\n               Organization for Standardization.\
    \  International Standard\n               8825, (December, 1987).\n          [5]\
    \  Case, J., McCloghrie, K., Rose, M., and Waldbusser, S.,\n               \"\
    Management Information Base for version 2 of the Simple\n               Network\
    \ Management Protocol (SNMPv2)\", RFC 1450, SNMP\n               Research, Inc.,\
    \ Hughes LAN Systems, Dover Beach\n               Consulting, Inc., Carnegie Mellon\
    \ University, April 1993.\n          [6]  Case, J., McCloghrie, K., Rose, M.,\
    \ and Waldbusser, S.,\n               \"Protocol Operations for version 2 of the\
    \ Simple Network\n               Management Protocol (SNMPv2)\", RFC 1448, SNMP\
    \ Research,\n               Inc., Hughes LAN Systems, Dover Beach Consulting,\
    \ Inc.,\n               Carnegie Mellon University, April 1993.\n          [7]\
    \  McCloghrie, K., and Rose, M., \"Management Information\n               Base\
    \ for Network Management of TCP/IP-based internets:\n               MIB-II\",\
    \ STD 17, RFC 1213, March 1991.\n          [8]  McCloghrie, K., and Galvin, J.,\
    \ \"Party MIB for version 2\n               of the Simple Network Management Protocol\
    \ (SNMPv2)\", RFC\n               1447, Hughes LAN Systems, Trusted Information\
    \ Systems,\n          RFC 1442                SMI for SNMPv2              April\
    \ 1993\n               April 1993.\n          RFC 1442                SMI for\
    \ SNMPv2              April 1993\n          14.  Security Considerations\n   \
    \       Security issues are not discussed in this memo.\n          15.  Authors'\
    \ Addresses\n               Jeffrey D. Case\n               SNMP Research, Inc.\n\
    \               3001 Kimberlin Heights Rd.\n               Knoxville, TN  37920-9716\n\
    \               US\n               Phone: +1 615 573 1434\n               Email:\
    \ case@snmp.com\n               Keith McCloghrie\n               Hughes LAN Systems\n\
    \               1225 Charleston Road\n               Mountain View, CA  94043\n\
    \               US\n               Phone: +1 415 966 7934\n               Email:\
    \ kzm@hls.com\n               Marshall T. Rose\n               Dover Beach Consulting,\
    \ Inc.\n               420 Whisman Court\n               Mountain View, CA  94043-2186\n\
    \               US\n               Phone: +1 415 968 1052\n               Email:\
    \ mrose@dbc.mtview.ca.us\n               Steven Waldbusser\n               Carnegie\
    \ Mellon University\n               4910 Forbes Ave\n               Pittsburgh,\
    \ PA  15213\n               US\n               Phone: +1 412 268 6628\n      \
    \         Email: waldbusser@cmu.edu\n"
