- title: __initial_text__
  contents:
  - "                         Loader Debugger Protocol\n                         \
    \   Christopher Welles\n                      BBN Communications Corporation\n\
    \                              Walter Milliken\n                             BBN\
    \ Laboratories\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This RFC specifies a proposed protocol for the ARPA Internet\n\
    \   community, and requests discussion and suggestions for\n                 \
    \            Table of Contents\n     1   Introduction..........................................\
    \ 1\n     1.1   Purpose of This Document............................ 1\n     1.2\
    \   Summary of Features................................. 2\n     2   General Description...................................\
    \ 3\n     2.1   Motivation.......................................... 3\n     2.2\
    \   Relation to Other Protocols......................... 4\n     2.2.1   Transport\
    \ Service Requirements.................... 5\n     3   Protocol Operation....................................\
    \ 9\n     3.1   Overview............................................ 9\n     3.2\
    \   Session Management.................................. 9\n     3.3   Command\
    \ Sequencing................................. 10\n     3.4   Data Packing and\
    \ Transmission...................... 10\n     3.5   Implementations....................................\
    \ 12\n     4   Commands and Formats................................. 15\n    \
    \ 4.1   Packet Format...................................... 15\n     4.2   Command\
    \ Format..................................... 16\n     4.2.1   Command Header...................................\
    \ 16\n     4.3   Addressing......................................... 19\n    \
    \ 4.3.1   Long Address Format.............................. 20\n     4.3.2   Short\
    \ Address Format............................. 25\n     5   Protocol Commands....................................\
    \ 29\n     5.1   HELLO Command...................................... 29\n    \
    \ 5.2   HELLO_REPLY........................................ 29\n     5.3   SYNCH\
    \ Command...................................... 33\n     5.4   SYNCH_REPLY........................................\
    \ 34\n     5.5   ABORT Command...................................... 35\n    \
    \ 5.6   ABORT_DONE Reply................................... 35\n     5.7   ERROR\
    \ Reply........................................ 36\n     5.8   ERRACK Acknowledgement.............................\
    \ 39\n     6   Data Transfer Commands............................... 41\n    \
    \ 6.1   WRITE Command...................................... 42\n     6.2   READ\
    \ Command....................................... 43\n     6.3   READ_DATA Response.................................\
    \ 45\n     6.4   READ_DONE Reply.................................... 47\n    \
    \ 6.5   MOVE Command....................................... 48\n     6.6   MOVE_DATA\
    \ Response................................. 50\n     6.7   MOVE_DONE Reply....................................\
    \ 52\n     6.8   REPEAT_DATA........................................ 53\n    \
    \ 6.9   WRITE_MASK Command (Optional)...................... 54\n     7   Control\
    \ Commands..................................... 59\n     7.1   START Command......................................\
    \ 59\n     7.2   STOP Command....................................... 61\n    \
    \ 7.3   CONTINUE Command................................... 62\n     7.4   STEP\
    \ Command....................................... 62\n     7.5   REPORT Command.....................................\
    \ 63\n     7.6   STATUS Reply....................................... 64\n    \
    \ 7.7   EXCEPTION Trap..................................... 66\n     8   Management\
    \ Commands.................................. 69\n     8.1   CREATE Command.....................................\
    \ 69\n     8.2   CREATE_DONE Reply.................................. 74\n    \
    \ 8.3   DELETE Command..................................... 75\n     8.4   DELETE_DONE\
    \ Reply.................................. 76\n     8.5   LIST_ADDRESSES Command.............................\
    \ 76\n     8.6   ADDRESS_LIST Reply................................. 77\n    \
    \ 8.7   LIST_BREAKPOINTS Command........................... 79\n     8.8   BREAKPOINT_LIST\
    \ Reply.............................. 80\n     8.9   LIST_PROCESSES Command.............................\
    \ 82\n     8.10   PROCESS_LIST Reply................................ 83\n    \
    \ 8.11   LIST_NAMES Command................................ 84\n     8.12   NAME_LIST\
    \ Reply................................... 85\n     8.13   GET_PHYS_ADDR Command.............................\
    \ 87\n     8.14   GOT_PHYS_ADDR Reply............................... 88\n    \
    \ 8.15   GET_OBJECT Command................................ 90\n     8.16   GOT_OBJECT\
    \ Reply.................................. 91\n     9   Breakpoints and Watchpoints..........................\
    \ 93\n     9.1   BREAKPOINT_DATA Command............................ 95\n    \
    \ 10   Conditional Commands................................ 99\n     10.1   Condition\
    \ Command Format......................... 100\n     10.2   COUNT Conditions.................................\
    \ 101\n     10.3   CHANGED Condition................................ 102\n   \
    \  10.4   COMPARE Condition................................ 103\n     10.5   TEST\
    \ Condition................................... 105\n     11   Breakpoint Commands................................\
    \ 109\n     11.1   INCREMENT Command................................ 109\n   \
    \  11.2   INC_COUNT Command................................ 110\n     11.3   OR\
    \ Command....................................... 111\n     11.4   SET_PTR Command..................................\
    \ 112\n     11.5   SET_STATE Command................................ 113\n   \
    \  A   Diagram Conventions................................. 115\n     B   Command\
    \ Summary..................................... 117\n     C   Commands, Responses\
    \ and Replies..................... 121\n     D   Glossary............................................\
    \ 123\n                                  FIGURES\n     1  Relation to Other Protocols............................\
    \ 4\n     2  Form of Data Exchange Between Layers................... 6\n     3\
    \  Packing of 16-bit Words............................... 11\n     4  Packing\
    \ of 20-bit Words............................... 12\n     5  Network Packet Format.................................\
    \ 15\n     6  LDP Command Header Format............................. 16\n    \
    \ 7  Command Classes....................................... 17\n     8  Command\
    \ Types......................................... 18\n     9  Long Address Format...................................\
    \ 20\n     10  Long Address Modes................................... 21\n    \
    \ 11  Short Address Format................................. 26\n     12  Short\
    \ Address Modes.................................. 27\n     13  HELLO Command Format.................................\
    \ 29\n     14  HELLO_REPLY Format................................... 30\n    \
    \ 15  System Types......................................... 31\n     16  Target\
    \ Address Codes................................. 31\n     17  Feature Levels.......................................\
    \ 32\n     18  Options.............................................. 33\n    \
    \ 19  SYNCH Command Format................................. 33\n     20  SYNCH_REPLY\
    \ Format................................... 34\n     21  ABORT Command Format.................................\
    \ 35\n     22  ABORT_DONE Reply Format.............................. 36\n    \
    \ 23  ERROR Reply Format................................... 37\n     24  ERROR\
    \ Codes.......................................... 38\n     25  ERRACK Command\
    \ Format................................ 40\n     26  WRITE Command Format.................................\
    \ 42\n     27  READ Command Format.................................. 44\n    \
    \ 28  DATA Response Format................................. 46\n     29  READ_DONE\
    \ Reply Format............................... 47\n     30  MOVE Command Format..................................\
    \ 49\n     31  MOVE_DATA Response Format............................ 51\n    \
    \ 32  MOVE_DONE Reply Format............................... 52\n     33  REPEAT_DATA\
    \ Command Format........................... 54\n     34  WRITE_MASK Format....................................\
    \ 56\n     35  START Command Format................................. 60\n    \
    \ 36  STOP Command Format.................................. 61\n     37  CONTINUE\
    \ Command Format.............................. 62\n     38  STEP Command Format..................................\
    \ 63\n     39  REPORT Command Format................................ 64\n    \
    \ 40  STATUS Reply Format.................................. 65\n     41  EXCEPTION\
    \ Format..................................... 66\n     42  CREATE Command Format................................\
    \ 70\n     43  Create Types......................................... 71\n    \
    \ 44  CREATE BREAKPOINT Format............................. 71\n     45  CREATE\
    \ MEMORY_OBJECT Format.......................... 73\n     46  CREATE_DONE Reply\
    \ Format............................. 74\n     47  DELETE Command Format................................\
    \ 75\n     48  DELETE_DONE Reply Format............................. 76\n    \
    \ 49  LIST_ADDRESSES Command Format........................ 77\n     50  ADDRESS_LIST\
    \ Reply Format............................ 78\n     51  LIST_BREAKPOINTS Command\
    \ Format...................... 80\n     52  BREAKPOINT_LIST Reply Format.........................\
    \ 81\n     53  LIST_PROCESSES Command Format........................ 82\n    \
    \ 54  PROCESS_LIST Reply Format............................ 84\n     55  LIST_NAMES\
    \ Command Format............................ 85\n     56  NAME_LIST Reply Format...............................\
    \ 86\n     57  GET_PHYS_ADDR Command Format......................... 88\n    \
    \ 58  GOT_PHYS_ADDR Reply Format........................... 89\n     59  GET_OBJECT\
    \ Command Format............................ 90\n     60  GOT_OBJECT Reply Format..............................\
    \ 91\n     61  Commands to Manipulate Breakpoints................... 93\n    \
    \ 62  Breakpoint Conditional Command Lists................. 95\n     63  BREAKPOINT_DATA\
    \ Command Format....................... 96\n     64  Breakpoint Data Stream Format........................\
    \ 97\n     65  Conditional Command Summary.......................... 99\n    \
    \ 66  Condition Command Header............................ 101\n     67  COUNT\
    \ Condition Format.............................. 101\n     68  CHANGED Condition...................................\
    \ 102\n     69  COMPARE Condition................................... 104\n   \
    \  70  TEST Condition...................................... 106\n     71  Breakpoint\
    \ Command Summary.......................... 109\n     72  INCREMENT Command Format............................\
    \ 110\n     73  INC_COUNT Command Format............................ 111\n   \
    \  74  OR Command Format................................... 111\n     75  SET_PTR\
    \ Command Format.............................. 112\n     76  SET_STATE Command\
    \ Format............................ 113\n     77  Sample Diagram......................................\
    \ 115\n     78  Command Summary..................................... 118\n   \
    \  79  Commands, Responses and Replies..................... 122\n            \
    \                     CHAPTER 1\n                               Introduction\n\
    \          The Loader-Debugger Protocol (LDP) is an  application  layer\n    \
    \ protocol   for  loading, dumping  and  debugging  target machines\n     from\
    \ hosts in a network environment.  This protocol  is  designed\n     to  accommodate\
    \ a variety  of  target  cpu  types.  It provides a\n     powerful set of debugging\
    \ services.  At  the  same  time,  it  is\n     structured  so  that  a  simple\
    \  subset  may  be  implemented  in\n     applications like boot  loading   where\
    \ efficiency and space  are\n     at a premium.\n          The authors would like\
    \  to  thank  Dan  Franklin  and  Peter\n     Cudhea  for providing many of the\
    \ ideas on which this protocol is\n     based.\n     1.1  Purpose of This Document\n\
    \          This is a technical specification for the LDP protocol.   It\n    \
    \ is intended to be comprehensive enough to be used by implementors\n     of the\
    \  protocol.   It  contains  detailed  descriptions  of  the\n     formats  and\
    \ usage of over forty commands.  Readers interested in\n     an overview of LDP\
    \ should read the Summary  of  Features,  below,\n     and  skim  Sections  2\
    \  through  3.1.   Also  see Appendix B, the\n     Command Summary.  The remainder\
    \ of the document reads  best  when\n     accompanied by strong coffee or tea.\n\
    \     1.2  Summary of Features\n          LDP has the following features:\n  \
    \        o   commands to perform loading, dumping and debugging\n          o \
    \  support for multiple connections to a single target\n          o   reliable\
    \ performance in an internet environment\n          o   a small protocol subset\
    \ for target loaders\n          o   addressing  modes  and  commands  to  support\
    \   multiple\n              machine types\n          o   breakpoints and watchpoints\
    \  which  run  in  the  target\n              machine.\n                     \
    \            CHAPTER 2\n                            General Description\n    \
    \ 2.1  Motivation\n          LDP is an  application  protocol  that  provides\
    \  a  set  of\n     commands  used  by  application programs for loading, dumping\
    \ and\n     debugging target machines across a network.\n          The goals of\
    \ this protocol are shown in the following list:\n          o   The protocol should\
    \ support various processor types  and\n              operating  systems.   Overhead\
    \  and complexity should be\n              minimized for simpler cases.\n    \
    \      o   The protocol should provide support for applications  in\n        \
    \      which  more  than  one  user  can  debug the same target\n            \
    \  machine.  This implies an underlying transport mechanism\n              that\
    \ supports multiple connections between a host-target\n              pair.\n \
    \         o   LDP should have a minimal subset of  commands  for  boot\n     \
    \         loading  and dumping.  Target machine implementations of\n         \
    \     these applications are often restricted in the amount of\n             \
    \ code-space  they  may  take.   The  services  needed for\n              loading\
    \ and dumping  should  be  provided  in  a  small,\n              easily implemented\
    \ set of commands.\n          o   There should be a means for communicating exceptions\
    \ and\n              errors from the target LDP process to the host process.\n\
    \          o   LDP should allow the application to implement a full set\n    \
    \          of debugging functions without crippling the performance\n        \
    \      of the target's application (i.e., PSN,  PAD,  gateway).\n            \
    \  For  example,  a  breakpoint  mechanism  that  halts the\n              target\
    \ machine while breakpoint commands are  sent  from\n              the  host \
    \ to the target is of limited usefulness, since\n              the target will\
    \  be  unable  to  service  the  real-time\n              demands of its application.\n\
    \     2.2  Relation to Other Protocols\n          LDP is an application protocol\
    \ that fits  into  the  layered\n     internet  protocol environment. Figure 1\
    \ illustrates the place of\n     LDP in the protocol hierarchy.\n            \
    \      +------------------------------+\n                  |              LDP\
    \             |        Application\n                  +------------------------------+\
    \        Layer\n                        |                  |\n               \
    \         |                  |\n                        |                  |\n\
    \                  +---------+          +---------+\n                  |   RDP\
    \   |    or    |  TCP    |        Transport Layer\n                  +---------+\
    \          +---------+\n                    | or |                |\n        \
    \            |    |                |\n                    |  +--------------------+\n\
    \                    |  |  Internet Protocol |             Internetwork\n    \
    \                |  +--------------------+             Layer\n               \
    \     |              |\n                  +------------------------------+\n \
    \                 |    Network Access Protocol   |        Network Layer\n    \
    \              +------------------------------+\n                        Relation\
    \ to Other Protocols\n                                 Figure 1\n     2.2.1  Transport\
    \ Service Requirements\n          LDP requires that the underlying transport layer:\n\
    \          o   allow connections to be opened by specifying  a  network\n    \
    \          (or  internet)  address.   Support  passive  and  active\n        \
    \      opens.\n          o   for each connection, specify the maximum message\
    \ size.\n          o   provide a mechanism for sending and  receiving  messages\n\
    \              over an open connection.\n          o   deliver messages reliably\
    \ and in sequence\n          o   support multiple connections, and  distinguish\
    \  messages\n              associated  with  different connections.  This is only\
    \ a\n              requirement where LDP is  expected  to  support  several\n\
    \              users at the same time.\n          o   explictly return the outcome\
    \ (success/failure)  of  each\n              request  (open,  send,  receive),\
    \ and provide a means of\n              querying the  status  of  a  connection\
    \  (unacknowledged\n              message count, etc.).\n          Data is passed\
    \ from the application program to the LDP  user\n     process  in  the  form of\
    \ commands.  In the case of an LDP server\n     process, command responses originate\
    \ in LDP itself.  Below LDP is\n     the  transport  protocol.  The  Reliable\
    \  Data  Protocol  (RDP --\n     RFC 908) is the recommended transport procotol.\
    \  Data  is  passed\n     across  the  LDP/RDP interface in the form of messages.\
    \  (TCP may\n     be used in place of RDP, but it will be  less  efficient  and\
    \  it\n     will  require  more  resources  to implement.)  An internet layer\n\
    \     (IP) normally comes between RDP and the network  layer,  but  RDP\n    \
    \ may exchange data packets directly with the network layer.\n          Figure\
    \  2  shows  the  flow  of  data  across  the  protocol\n     interfaces:\n  \
    \                             +------+\n                               |     \
    \ |\n                               |Appli-|\n                               |cation|\n\
    \                               |      |\n                               +------+\n\
    \                                  ^\n                       Commands   |\n  \
    \                                V\n                               +------+\n\
    \                               |      |\n                               | LDP\
    \  |\n                               |      |\n                              \
    \ +------+\n                                  ^\n                       Messages\
    \   |\n                                  V\n                               +-----+\n\
    \                               |     |\n                               | RDP\
    \ |\n                               |     |\n                               +-----+\n\
    \                                  ^\n                       Segments   |\n  \
    \                                V\n                                +----+\n \
    \                               |    |\n                                | IP |\n\
    \                                |    |\n                                +----+\n\
    \                                  ^\n                       Datagrams  |\n  \
    \                                V\n                              ?  *     !\n\
    \                           $  =      ^   +\n                             *\n\
    \                          >    Internet\n                            ,      \
    \      ?\n                                 !    )\n                          \
    \    *   %     $\n                   Form of Data Exchange Between Layers\n  \
    \                               Figure 2\n                                 CHAPTER\
    \ 3\n                            Protocol Operation\n     3.1  Overview\n    \
    \      An LDP session consists  of  an  exchange  of  commands  and\n     responses\
    \  between an LDP user process and an LDP server process.\n     Normally,  the\
    \  user  process  resides  on  a  host  machine   (a\n     timesharing  computer\
    \  used  for network monitoring and control),\n     and the server process resides\
    \ on a  target  machine  (PSN,  PAD,\n     gateway,  etc.).   Throughout  this\
    \ document, host and target are\n     used  as  synonyms  for  user   process\
    \   and   server   process,\n     respectively,  although  in  some implementations\
    \ (the Butterfly,\n     for example) this  correspondence  may  be  reversed.\
    \   The  host\n     controls  the  session  by  sending commands to the target.\
    \  Some\n     commands elicit responses, and all commands may elicit  an  error\n\
    \     reply.\n          The protocol contains five classes  of  commands:  protocol,\n\
    \     data  transfer,  management,   control  and breakpoint.  Protocol\n    \
    \ commands are used to verify the command sequencing mechanism  and\n     to handle\
    \ erroneous commands.  Data transfer commands involve the\n     transfer of data\
    \ from one place to another, such  as  for  memory\n     examine/deposit,  or\
    \  loading.  Management  commands are used for\n     creating   and   deleting\
    \   objects   (processes,    breakpoints,\n     watchpoints,  etc.)  in the target\
    \ machine.  Control commands are\n     used to control the execution of  target\
    \  code  and  breakpoints.\n     Breakpoint commands are used to control the execution\
    \ of commands\n     inside breakpoints and watchpoints.\n     3.2  Session Management\n\
    \          An LDP session consists of a series of commands sent from  a\n    \
    \ host  LDP  to  a  target  LDP,  some  of which may be followed by\n     responses\
    \ from the target.  A session begins when a host opens  a\n     transport  connection\
    \ to a target listening on a well known port.\n     LDP uses RDP port number zzz\
    \ or TCP port number  yyy.   When  the\n     connection  has been established,\
    \ the host sends a HELLO command,\n     and the target  replies  with  a  HELLO_REPLY.\
    \   The  HELLO_REPLY\n     contains  parameters that describe the target's implementation\
    \ of\n     LDP, including protocol  version,  implementation  level,  system\n\
    \     type,  and  address format.  The session terminates when the host\n    \
    \ closes the underlying  transport  connection.   When  the  target\n     detects\
    \  that the transport connection has been closed, it should\n     deallocate any\
    \ resources dedicated to the session.\n          The target process is the passive\
    \ partner in an LDP session,\n     and  it  waits for the host process to terminate\
    \ the session.  As\n     an implementation consideration, either LDP  or  the\
    \   underlying\n     transport  protocol  in  the  target  should  have  a  method\
    \ for\n     detecting if the host process  has  died.   Otherwise,   an   LDP\n\
    \     target  that  supported  only  one  connection  could be rendered\n    \
    \ useless by a host that crashed in the  middle of a session.   The\n     problem\
    \  of  detecting  half-dead  connections  can be avoided by\n     taking a different\
    \ tack:  the target could allow new  connections\n     to  usurp  inactive  connections.\
    \  A  connection with no activity\n     could be declared 'dead', but would  not\
    \  be  usurped  until  the\n     connection  resource  was  needed.   However,\
    \  this  would  still\n     require the transport layer to support two  connection\
    \  channels:\n     one  to  receive  connection  requests, and another to use\
    \ for an\n     active connection.\n     3.3  Command Sequencing\n          Each\
    \ command sent from the host to the target has a sequence\n     number.   The\
    \  sequence  number is used by the target to refer to\n     the command in normal\
    \ replies and error replies.  To save  space,\n     these  numbers  are  not \
    \ actually  included  in  host  commands.\n     Instead, each command sent from\
    \ the host is assigned an  implicit\n     sequence  number.   The  sequence  number\
    \  starts  at zero at the\n     beginning of the LDP  session  and  increases\
    \  by  one  for  each\n     command sent.  The host and target each keep track\
    \ of the current\n     number.  The SYNCH <sequence number> command may be used\
    \  by  the\n     host to synchronize the sequence number.\n     3.4  Data Packing\
    \ and Transmission\n          The convention for the order of data packing was\
    \ chosen  for\n     its  simplicity:  data  are packed most significant bit first,\
    \ in\n     order of increasing target address, into  eight-bit  octets.  The\n\
    \     octets of packed data are transmitted in sequential order.\n          Data\
    \ are always packed according to the  address  format  of\n     the  target  machine.\
    \   For  example, in an LDP session between a\n     20-bit host and  a  16-bit\
    \  target,  16-bit  words  (packed  into\n     octets)   are  transmitted  in\
    \  both  directions.   For  ease  of\n     discussion, targets are treated here\
    \  as  if  they  have  uniform\n     address  spaces.  In practice, the size of\
    \ address units may vary\n     within a target -- 16-bit macromemory, 32-bit micromemory,\
    \ 10-bit\n     dispatch  memory,  etc.   Data packing between host and target\
    \ is\n     tailored to the units of the current target address space.\n      \
    \    Figures showing the packing of data for targets with various\n     address\
    \  unit  sizes  are given below.  The order of transmission\n     with respect\
    \ to the diagrams is top to bottom.  Bit numbering  in\n     the  following diagrams\
    \ refers to significance in the octet:  bit\n     zero  is  the  least  significant\
    \  bit  in  an  octet.   For   an\n     explanation  of  the bit numbering convention\
    \ that applies in the\n     rest of this document, please see Appendix A.\n  \
    \        The packing of data for targets with word lengths  that  are\n     multiples\
    \   of  8  is  straightforward.   The  following  diagram\n     illustrates 16-bit\
    \ packing:\n                          7                               0\n    \
    \                      ---------------------------------\n               Octet\
    \ 0    |      WORD 0 bits 15-08        |\n                          ---------------------------------\n\
    \               Octet 1    |      WORD 0 bits 07-00        |\n               \
    \           ---------------------------------\n               Octet 2    |   \
    \   WORD 1 bits 15-08        |\n                          ---------------------------------\n\
    \               Octet 3    |      WORD 1 bits 07-00        |\n               \
    \           ---------------------------------\n                              \
    \          *\n                                        *\n                    \
    \                    *\n                          ---------------------------------\n\
    \               Octet 2n-1 |      WORD n bits 07-00        |\n               \
    \           ---------------------------------\n                          Packing\
    \ of 16-bit Words\n                                 Figure 3\n     Packing  for\
    \  targets  with  peculiar  word   lengths   is   more\n     complicated.   For\
    \  20-bit  machines,  2 words of data are packed\n     into  5  octets.   When\
    \  an  odd  number  of  20-bit  words   are\n     transmitted,  the  partially\
    \ used octet is included in the length\n     of the command, and the octet is\
    \ padded to the right with zeroes.\n                          7              \
    \                 0\n                          ---------------------------------\n\
    \               Octet 0    |      WORD 0 bits 19-12        |\n               \
    \           ---------------------------------\n               Octet 1    |   \
    \   WORD 0 bits 11-04        |\n                          ---------------------------------\n\
    \               Octet 2    |  WORD 0 03-00 |  WORD 1 19-16 |\n               \
    \           ---------------------------------\n               Octet 3    |   \
    \   WORD 1 bits 15-08        |\n                          ---------------------------------\n\
    \               Octet 4    |      WORD 1 bits 07-00        |\n               \
    \           ---------------------------------\n                          Packing\
    \ of 20-bit Words\n                                 Figure 4\n     3.5  Implementations\n\
    \          A subset of LDP commands may be implemented in targets where\n    \
    \ machine  resources  are  limited and the full capabilities of LDP\n     are\
    \  not  needed.  There  are  three  basic  levels   of   target\n     implementations:\
    \       LOADER_DUMPER,      BASIC_DEBUGGER     and\n     FULL_DEBUGGER.  The target\
    \ communicates  its  LDP  implementation\n     level  to the host during session\
    \ initiation.  The implementation\n     levels are described below:\n     LOADER_DUMPER\n\
    \          Used  for   loading/dumping    of   the   target    machine.\n    \
    \      Includes   all  protocol   class  commands and replies; data\n        \
    \  transfer commands READ, WRITE,  MOVE  and  their  responses;\n          control\
    \   command   START  and  control  reply    EXCEPTION.\n          Understands\
    \ at least PHYS_MACRO and HOST  addressing  modes;\n          others if desired.\n\
    \     BASIC_DEBUGGER\n          Implements  LOADER_DUMPER  commands,  all  control\
    \ commands,\n          all  addressing modes appropriate to the target machine,\
    \ but\n          does  not  have finite state machine  (FSM)  breakpoints  or\n\
    \          watchpoints.   Default  breakpoints  are  implemented.   The\n    \
    \      target understands long addressing mode.\n     FULL_DEBUGGER\n        \
    \  Implements all commands and addressing modes appropriate  to\n          the\
    \   target  machine,  and  includes  breakpoint  commands,\n          conditional\
    \ commands and BREAKPOINT_DATA.   Watchpoints  are\n          optional.\n    \
    \                             CHAPTER 4\n                           Commands and\
    \ Formats\n     4.1  Packet Format\n          LDP commands are enclosed in RDP\
    \ transport messages.  An RDP\n     message  may contain more than one command,\
    \ but each command must\n     fit entirely within a single message.  Network packets\
    \ containing\n     LDP commands have the format shown in Figure 5.\n         \
    \             +----------------+\n                      |  Local Network |\n \
    \                     |    Header(s)   |\n                      +----------------+\n\
    \                      |   IP Header    |\n                      +----------------+\n\
    \                      |   RDP Header   |\n                      +----------------+\
    \     +-+\n                      |   LDP Command  |      |\n                 \
    \     |   Header       |      |\n                      +----------------+    \
    \  |\n                      |   Optional     |      |\n                      .\
    \   LDP          .      | LDP Command\n                      .   Data        \
    \ .      | Format\n                      |                |      |\n         \
    \             +----------------+      |\n                      |   LDP Padding\
    \  |      |\n                      +----------------+     +-+\n              \
    \        |   Additional   |\n                      .   LDP          .\n      \
    \                .   Commands     .\n                      .                .\n\
    \                      +----------------+\n                           Network\
    \ Packet Format\n                                 Figure 5\n     4.2  Command\
    \ Format\n          LDP commands consist of a standard two-word header  followed\n\
    \     optionally  by  additional data.  To facilitate parsing of multi-\n    \
    \ command messages, all commands contain an even number of  octets.\n     Commands\
    \ that contain an odd number of data octets must be padded\n     with a null octet.\n\
    \          The commands defined by the LDP specification  are  intended\n    \
    \ to  be of universal application to provide a common basis for all\n     implementations.\
    \  Command class and type codes from 0 to 63.  are\n     reserved  by the protocol.\
    \  Codes above 63. are available for the\n     implementation of target-specific\
    \ commands.\n     4.2.1  Command Header\n          LDP commands begin with a fixed\
    \ length header.   The  header\n     specifies the type of command and its length\
    \ in octets.\n                       0             0 0   1         1\n       \
    \                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |     Command Length (octets)   |\n                   \
    \   +---------------+---------------+\n                    1 | Command Class |\
    \ Command Type  |\n                      +---------------+---------------+\n \
    \                        LDP Command Header Format\n                         \
    \        Figure 6\n     HEADER FIELDS:\n     Command Length\n          The command\
    \ length gives the total number of octets  in  the\n          command,  including\
    \ the length field and data, and excluding\n          padding.\n     Command Class\n\
    \     Command Type\n          The command class and type  together  specify  a\
    \  particular\n          command.   The  class selects one of six command categories,\n\
    \          and the type gives the command within  that  category.   All\n    \
    \      codes are decimal.  The symbols given in Figures 7 and 8 for\n        \
    \  command classes and types are used in the remainder of  this\n          document\
    \ for reference.\n          The command classes that have been defined are:\n\
    \                     Command Class  |  Symbol\n                    ----------------+-----------\n\
    \                            1       | PROTOCOL\n                            2\
    \       | DATA_TRANSFER\n                            3       | CONTROL\n     \
    \                       4       | MANAGEMENT\n                            5  \
    \     | BREAKPOINT\n                            6       | CONDITION\n        \
    \                    7 - 63  | <reserved>\n                              Command\
    \ Classes\n                                 Figure 7\n          Command  type\
    \  codes  are  assigned  in  order  of  expected\n          frequency  of use.\
    \  Commands and their responses/replies are\n          numbered  sequentially.\
    \   The  command  types,  ordered   by\n          command class, are:\n      \
    \               Command Class  |  Command Type | Symbol\n                    ----------------+---------------+----------\n\
    \                      PROTOCOL      |       1       | HELLO\n               \
    \                     |       2       | HELLO_REPLY\n                        \
    \            |       3       | SYNCH\n                                    |  \
    \     4       | SYNCH_REPLY\n                                    |       5   \
    \    | ERROR\n                                    |       6       | ERRACK\n \
    \                                   |       7       | ABORT\n                \
    \                    |       8       | ABORT_DONE\n                          \
    \          |       9 - 63  | <reserved>\n                                    |\
    \               |\n                      DATA_TRANSFER |       1       | WRITE\n\
    \                                    |       2       | READ\n                \
    \                    |       3       | READ_DONE\n                           \
    \         |       4       | READ_DATA\n                                    | \
    \      5       | MOVE\n                                    |       6       | MOVE_DONE\n\
    \                                    |       7       | MOVE_DATA\n           \
    \                         |       8       | REPEAT_DATA\n                    \
    \                |       9       | BREAKPOINT_DATA\n                         \
    \           |       10      | WRITE_MASK\n                                   \
    \ |       11 - 63 | <reserved>\n                                    |        \
    \       |\n                      CONTROL       |       1       | START\n     \
    \                               |       2       | STOP\n                     \
    \               |       3       | CONTINUE\n                                 \
    \   |       4       | STEP\n                                    |       5    \
    \   | REPORT\n                                    |       6       | STATUS\n \
    \                                   |       7       | EXCEPTION\n            \
    \                        |       8 - 63  | <reserved>\n                      \
    \              |               |\n                      MANAGEMENT    |      \
    \ 1       | CREATE\n                                    |       2       | CREATE_DONE\n\
    \                                    |       3       | DELETE\n              \
    \                      |       4       | DELETE_DONE\n                       \
    \             |       5       | LIST_ADDRESSES\n                             \
    \       |       6       | ADDRESS_LIST\n                                    |\
    \       7       | GET_PHYS_ADDRESS\n                                    |    \
    \   8       | GOT_PHYS_ADDRESS\n                                    |       9\
    \       | GET_OBJECT\n                                    |       10      | GOT_OBJECT\n\
    \                                    |       11      | LIST_BREAKPOINTS\n    \
    \                                |       12      | BREAKPOINT_LIST\n         \
    \                           |       13      | LIST_NAMES\n                   \
    \                 |       14      | NAME_LIST\n                              \
    \      |       15      | LIST_PROCESSES\n                                    |\
    \       16      | PROCESS_LIST\n                                    |       17\
    \ - 63 | <reserved>\n                                    |               |\n \
    \                     BREAKPOINT    |       1       | INCREMENT\n            \
    \                        |       2       | INC_COUNT\n                       \
    \             |       3       | OR\n                                    |    \
    \   4       | SET_PTR\n                                    |       5       | SET_STATE\n\
    \                                    |       6 - 63  | <reserved>\n          \
    \                          |               |\n                      CONDITION\
    \     |       1       | CHANGED\n                                    |       2\
    \       | COMPARE\n                                    |       3       | COUNT_EQ\n\
    \                                    |       4       | COUNT_GT\n            \
    \                        |       5       | COUNT_LT\n                        \
    \            |       6       | TEST\n                                    |   \
    \    7 - 63  | <reserved>\n                               Command Types\n    \
    \                             Figure 8\n     4.3  Addressing\n          Addresses\
    \ are used  in  LDP  commands  to  refer  to  memory\n     locations,  processes,\
    \  buffers,  breakpoints and other entities.\n     Many of these entities are\
    \ machine-dependent; some machines  have\n     named  objects,  some  machines\
    \ have multiple address spaces, the\n     size of address spaces varies, etc.\
    \  The  format  for  specifying\n     addresses  needs  to  be  general  enough\
    \  to handle all of these\n     cases.   This  speaks  for  a  large,  hierarchically\
    \  structured\n     address  format.   However, the disadvantage of a large format\
    \ is\n     that it imposes extra overhead on communication with targets that\n\
    \     have simpler address schemes.\n          LDP resolves this conflict by employing\
    \ two address formats:\n     a  short  three-word format for addressing simpler\
    \ targets, and a\n     long five-word format for others.  Each target LDP is required\
    \ to\n     implement  at least one of these formats.  At the start of an LDP\n\
    \     session, the target specifies the address format(s)  it  uses  in\n    \
    \ the  Flag field of the HELLO_REPLY message.  In each address, the\n     first\
    \ bit of the mode octet is a format flag:  0  indicates  LONG\n     address format,\
    \ and 1 indicates SHORT format.\n     4.3.1  Long Address Format\n          The\
    \ long address format is five words long and consists of a\n     three-word  address\
    \  descriptor and a two-word offset (see Figure\n     9). The descriptor specifies\
    \ an address space to which the offset\n     is applied.  The descriptor is subdivided\
    \ into several fields, as\n     described below.  The structuring of the descriptor\
    \  is  designed\n     to  support  complex  addressing  modes.  For example, on\
    \ targets\n     with  multiple  processes,  descriptors  may  reference   virtual\n\
    \     addresses,  registers,  and  other  entities  within a particular\n    \
    \ process.\n          The addressing modes defined below are intended as a base\
    \ to\n     which  target-specific  modes  may be added.  Modes up to 63. are\n\
    \     reserved by the protocol.  The range 64. to 127. may be used  for\n    \
    \ target-specific address modes.\n               Long Format - Format bit is LONG=0\n\
    \                0             0 0   1         1\n                0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5\n               +-------------------------------+  +-+\n\
    \               |0|       Mode  |  Mode Arg     |   |\n               +-------------------------------+\
    \   |\n               |                    (31-16)    |   | Descriptor\n     \
    \          +----          ID            ---+   |\n               |           \
    \         (15-0)     |   |\n               +-------------------------------+ \
    \ +-+\n               |                    (31-16)    |   |\n               +----\
    \        Offset          ---+   | Offset\n               |                   \
    \ (15-0)     |   |\n               +-------------------------------+  +-+\n  \
    \                          Long Address Format\n                             \
    \    Figure 9\n     LONG ADDRESS FIELDS:\n     Mode\n          The address mode\
    \ identifies the type of address space  being\n          referenced.   The mode\
    \ is qualified by the mode argument and\n          the ID field.  Implementation\
    \ of modes other  than  physical\n          and  host is machine-dependent.  Currently\
    \ defined modes and\n          the address space they reference are shown in Figure\
    \ 10.\n          Mode | Symbol               | Address space\n          -----+----------------------+---------------------------\n\
    \            0    HOST                   Host\n            1    PHYS_MACRO   \
    \          Macromemory\n            2    PHYS_MICRO             Micromemory\n\
    \            3    PHYS_I/O               I/O space\n            4    PHYS_MACRO_PTR\
    \         Macro contains a pointer\n            5    PHYS_REG               Register\n\
    \            6    PHYS_REG_OFFSET        Register plus offset\n            7 \
    \   PHYS_REG_INDIRECT      Register contains address\n                       \
    \                 of a pointer\n            8    PROCESS_CODE           Process\
    \ code space\n            9    PROCESS_DATA           Process data space\n   \
    \        10    PROCESS_DATA_PTR       Process data contains a ptr\n          \
    \ 11    PROCESS_REG            Process virtual register\n           12    PROCESS_REG_OFFSET\
    \     Process register plus offset\n           13    PROCESS_REG_INDIRECT   Process\
    \ register contains\n                                        address of a pointer\n\
    \           14    OBJECT_OFFSET          Memory object (queue, pool)\n       \
    \    15    OBJECT_HEADER          System header for an object\n           16 \
    \   BREAKPOINT             Breakpoint\n           17    WATCHPOINT           \
    \  Watchpoint\n           18    BPT_PTR_OFFSET         Breakpoint ptr plus offset\n\
    \           19    BPT_PTR_INDIRECT       Breakpoint ptr plus offset\n        \
    \                                gives address of a pointer\n           20 - \
    \ <reserved>\n           63\n                            Long Address Modes\n\
    \                                 Figure 10\n     Mode Argument\n          Provides\
    \ a numeric argument to the  mode  field.   Specifies\n          the  register\
    \  in  physical  and  process REG and REG_OFFSET\n          modes.\n     ID Field\n\
    \          Identifies a particular process, buffer or object.\n     Offset\n \
    \         The offset into the linear  address  space  defined  by  the\n     \
    \     mode.  The size of the machine word determines the number of\n         \
    \ significant bits in the offset.   Likewise,  the  addressing\n          units\
    \ of the target are the units of the offset.\n     The interpretation of the mode\
    \ argument, ID field and offset  for\n     each address mode is given below:\n\
    \     HOST\n          The ID and offset fields are numbers assigned arbitrarily\
    \ by\n          the  host  side  of the debugger.  These numbers are used in\n\
    \          MOVE and MOVE_DATA messages.  MOVE_DATA responses containing\n    \
    \      this  mode  as the destination are sent by the target to the\n        \
    \  host.  This may occur in debugging when data is sent to  the\n          host\
    \ from the target breakpoint.\n     PHYS_MACRO\n          The  offset  contains\
    \  the  32-bit  physical  address  of  a\n          location in macromemory. \
    \ The mode argument and ID field are\n          not used.   For  example,  mode=PHYS_MACRO\
    \  and  offset=1000\n          specifies location 1000 in physical memory.\n \
    \    PHYS_MICRO\n          Like PHYS_MACRO, but the location is in micromemory.\n\
    \     PHYS_I/O\n          Like PHYS_MACRO, but the location is in I/O space.\n\
    \     PHYS_MACRO_PTR\n          The offset contains the address of a pointer in\
    \ macromemory.\n          The  location  pointed to (the effective address) is\
    \ also in\n          macromemory.  The mode argument and ID field are unused.\n\
    \     PHYS_REG\n          The mode argument  gives  the  physical  register. \
    \  If  the\n          register  is  used by the LDP target process, then the saved\n\
    \          copy from  the  previous  context  is  used.   This  comment\n    \
    \      applies  to  PHYS_REG_OFFSET  mode as well.  The ID field is\n        \
    \  not used.\n     PHYS_REG_OFFSET\n          The offset is added to the contents\
    \ of a register  given  as\n          the mode argument.  The result is used as\
    \ a physical address\n          in macromemory.  ID is unused.\n     PHYS_REG_INDIRECT\n\
    \          The register specified in the mode arg contains the  address\n    \
    \      of  a  pointer in macromemory.  The effective address is the\n        \
    \  macromemory location specified  in  the  pointer,  plus  the\n          offset.\
    \  The ID field is unused.\n     PROCESS_CODE\n          The ID is a process ID,\
    \ the offset is into  the  code  space\n          for this process.  Mode argument\
    \ is not used.\n     PROCESS_DATA\n          The ID is a process ID, the offset\
    \ is into  the  data  space\n          for  this  process.   Mode argument is\
    \ not used.  On systems\n          that do not distinguish between code and data\
    \  space,  these\n          two  modes are equivalent, and reference the virtual\
    \ address\n          space of the process.\n     PROCESS_DATA_PTR\n          The\
    \ offset contains the address of a  pointer  in  the  data\n          space  of\
    \  the  process  specified  by the ID.  The location\n          pointed to (the\
    \ effective  address)  is  also  in  the  data\n          space.  The mode argument\
    \ is not used.\n     PROCESS_REG\n          Accesses the  registers  (and  other\
    \  system  data)  of  the\n          process  given  by the ID field.  Mode argument\
    \ 0 starts the\n          registers.  After the registers, the  mode  argument\
    \  is  an\n          offset into the system area for the process.\n     PROCESS_REG_OFFSET\n\
    \          The offset plus the contents of the register  given  in  the\n    \
    \      mode  argument specifies a location in the data space of the\n        \
    \  process specified by the ID.\n     PROCESS_REG_INDIRECT\n          The register\
    \ specified in the mode arg contains the  address\n          of  a  pointer in\
    \ the data space of the process given by the\n          ID.  The effective address\
    \ is the location in  process  data\n          space specified in the pointer,\
    \ plus the offset.\n     OBJECT_OFFSET (optional)\n          The offset is into\
    \ the memory space defined by the object ID\n          in   ID.    Recommended\
    \  for  remote  control  of  parameter\n          segments.\n     OBJECT_HEADER\
    \ (optional)\n          The  offset  is  into  the  system  header  for  the \
    \ object\n          specified by the ID.  Intended for use with the Butterfly.\n\
    \     BREAKPOINT\n          The descriptor specifies a breakpoint.  The offset\
    \ is  never\n          used,  this  type  is  only used in descriptors referring\
    \ to\n          breakpoints.  (See Breakpoints and Watchpoints,  below,  for\n\
    \          an explanation of breakpoint descriptors.)\n     WATCHPOINT\n     \
    \     The descriptor specifies a watchpoint.  The offset is  never\n         \
    \ used,  this  type  is  only used in descriptors referring to\n          watchpoints.\
    \  (See Breakpoints and Watchpoints,  below,  for\n          an explanation of\
    \ watchpoint descriptors).\n     BPT_PTR_OFFSET\n          For  this  mode  and\
    \  BPT_PTR_INDIRECT,  the  mode  argument\n          specifies  one  of two breakpoint\
    \ pointer variables local to\n          the breakpoint in which this address occurs.\
    \  These pointers\n          and  the  SET_PTR command which manipulates them\
    \ provide for\n          an  arbitrary  amount  of  address  indirection.   They\
    \  are\n          intended for use in traversing data structures: for example,\n\
    \          chasing queues.  In BPT_PTR_OFFSET, the offset is  added  to\n    \
    \      the  pointer  variable  to  give  the effective address.  In\n        \
    \  targets which support multiple processes, the location is in\n          the\
    \  data  space of the process given by the ID.  Otherwise,\n          the  location\
    \  is  a  physical  address   in   macro-memory.\n          BPT_PTR.*   modes\
    \   are   valid   only  in  breakpoints  and\n          watchpoints.\n     BPT_PTR_INDIRECT\n\
    \          Like BPT_PTR_OFFSET, except that it uses one more  level  of\n    \
    \      indirection.    The  pointer  variable  given  by  the  mode\n        \
    \  argument plus the offset specify an address which points  to\n          the\
    \    effective    address.    See   the   description   of\n          BPT_PTR_OFFSET\
    \ for a discussion of  usage,  limitations  and\n          address space.\n  \
    \   4.3.2  Short Address Format\n          The  short  address  format   is  \
    \ intended   for   use   in\n     implementations  where protocol overhead must\
    \ be minimized.  This\n     format is a subset of the long address format:  it\
    \  contains  the\n     same  fields  except  for  the  ID  field.   Therefore,\
    \ the short\n     addressing format supports only HOST and  PHYS_*  address  modes.\n\
    \     Only  the LOADER_DUMPER implementation level commands may be used\n    \
    \ with the short addressing format.  The short  address  format  is\n     three\
    \  words  long,  consisting  of  a 16-bit word describing the\n     address space,\
    \ and a 32-bit offset.\n                    Short Format - Format bit is SHORT=1\n\
    \                     0             0 0   1         1\n                     0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                    +-------------------------------+\n\
    \                    |1|       Mode  | Mode Argument |\n                    +-------------------------------+\
    \  +-+\n                    |                    (31-16)    |   |\n          \
    \          +----        Offset          ---+   | Offset\n                    |\
    \                    (15-0)     |   |\n                    +-------------------------------+\
    \  +-+\n                           Short Address Format\n                    \
    \             Figure 11\n     SHORT ADDRESS FIELDS:\n     Mode\n          The\
    \ high-order  bit  is  1,  indicating  the  short  address\n          format.\
    \   A  list  of  the  address modes supported is given\n          below.  The\
    \ interpretation of the  remaining  fields  is  as\n          described above\
    \ for the long addressing format.\n          Mode | Symbol             | Address\
    \ space\n          -----+--------------------+---------------------------\n  \
    \          0    HOST                 Host\n            1    PHYS_MACRO       \
    \    Macro-memory\n            2    PHYS_MICRO           Micro-memory\n      \
    \      3    PHYS_I/O             I/O space\n            4    PHYS_MACRO_PTR  \
    \     Macro contains a pointer\n            5    PHYS_REG             Register\n\
    \            6    PHYS_REG_OFFSET      Register plus offset\n            7   \
    \ PHYS_REG_INDIRECT    Register contains address\n                           \
    \           of a pointer\n            8 -\n            32   <reserved>\n     \
    \                       Short Address Modes\n                                \
    \ Figure 12\n                                 CHAPTER 5\n                    \
    \         Protocol Commands\n          Protocol  commands  are  used  for   error\
    \   handling,   for\n     synchronizing  the command sequence number, and for\
    \ communicating\n     protocol implementation parameters.  Every protocol command\
    \ has a\n     corresponding  reply.   All  protocol  commands are sent from the\n\
    \     host  to  the  target,  with  replies  flowing  in  the  opposite\n    \
    \ direction.\n     5.1  HELLO Command\n          The HELLO command is sent by\
    \ the host to signal the start of\n     an LDP session.  The target responds with\
    \ HELLO_REPLY.\n                       0             0 0   1         1\n     \
    \                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               4               |\n                   \
    \   +---------------+---------------+\n                    1 |   PROTOCOL    |\
    \    HELLO      |\n                      +---------------+---------------+\n \
    \                          HELLO Command Format\n                            \
    \     Figure 13\n     5.2  HELLO_REPLY\n          A HELLO_REPLY is sent by the\
    \ target in response to the HELLO\n     command  at  the  start of an LDP session.\
    \  This reply is used to\n     inform the host about the  target's implementation\
    \ of LDP.\n                       0             0 0   1         1\n          \
    \             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               10              |\n                   \
    \   +---------------+---------------+\n                    1 |    PROTOCOL   |\
    \   HELLO_REPLY |\n                      +---------------+---------------+\n \
    \                   2 |   LDP Version |  System Type  |\n                    \
    \  +---------------+---------------+\n                    3 |   Options |W|S|\
    \ Implementation|\n                      +---------------+---------------+\n \
    \                   4 | Address Code  |    Reserved   |\n                    \
    \  +---------------+---------------+\n                            HELLO_REPLY\
    \ Format\n                                 Figure 14\n     HELLO_REPLY FIELDS:\n\
    \     LDP Version\n          The  target's  LDP  protocol  version.    If   the\
    \   current\n          host  protocol  version  does not agree  with  the  target's\n\
    \          protocol  version,  the  host may terminate the session,  or\n    \
    \      may  continue it, at the discretion of the implementor.  The\n        \
    \  current version number is 2.\n     System Type\n          The type of system\
    \ running on the target.  This is used as a\n          check  against what the\
    \ host thinks the target is.  The host\n          is expected to have a table\
    \  of  target  system  types  with\n          information  about  target  address\
    \  spaces, target-specific\n          commands and addressing modes, and so forth.\n\
    \          Currently defined system types are shown in Figure 15.  This\n    \
    \      list  includes  some  systems normally thought of as 'hosts'\n        \
    \  (e.g. C70, VAX), for implementations where targets  actively\n          initiate\
    \ and direct a load of themselves.\n             Code |  System       |  Description\n\
    \          --------+---------------+---------------------------\n            \
    \   1     C30_16_BIT      BBN 16-bit C30\n               2     C30_20_BIT    \
    \  BBN 20-bit C30\n               3     H316            Honeywell-316\n      \
    \         4     BUTTERFLY       BBN Butterfly\n               5     PDP-11   \
    \       DEC PDP-11\n               6     C10             BBN C10\n           \
    \    7     C50             BBN C50\n               8     PLURIBUS        BBN Pluribus\n\
    \               9     C70             BBN C70\n              10     VAX      \
    \       DEC VAX\n              11     MACINTOSH       Apple MacIntosh\n      \
    \                         System Types\n                                 Figure\
    \ 15\n     Address Code\n          The address code indicates which LDP address\
    \  format(s)  the\n          target is prepared to use.  Address codes are show\
    \ in Figure\n          16.\n           Address Code |  Symbol       | Description\n\
    \          --------------+---------------+-----------------------------\n    \
    \            1         LONG_ADDRESS    Five word address format.\n           \
    \                               Supports all address modes\n                 \
    \                         and commands.\n                2         SHORT_ADDRESS\
    \   Three word address format.\n                                          Supports\
    \ only physical and\n                                          host address modes.\
    \  Only\n                                          the LOADER_DUMPER set of\n\
    \                                          commands are supported.\n         \
    \                  Target Address Codes\n                                 Figure\
    \ 16\n     Implementation\n          The implementation level   specifies   which\
    \   features   of\n          the   protocol   are  implemented  in the target.\
    \  There are\n          three levels of protocol implementation.  These  levels\
    \  are\n          intended to correspond to the three most likely applications\n\
    \          of LDP:  simple loading and dumping,  basic  debugging,  and\n    \
    \      full  debugging.   (Please see Implementations, above, for a\n        \
    \  detailed description of implementation  levels.)  There  are\n          are\
    \  also several optional features that are not included in\n          any particular\
    \ level.\n          Implementation levels are cumulative, that is,  each  higher\n\
    \          level  includes  the  features  of all previous levels.  The\n    \
    \      levels are shown in Figure 17.\n          Feature Level |  Symbol     \
    \  | Description\n          --------------+---------------+-----------------------------\n\
    \                 1        LOADER_DUMPER   Loader/dumper subset of LDP\n     \
    \            2        BASIC_DEBUGGER  Control commands, CREATE\n             \
    \    3        FULL_DEBUGGER   FSM breakpoints\n                              Feature\
    \ Levels\n                                 Figure 17\n     Options\n         \
    \ The options field (see  Figure  18)  is  an  eight-bit  flag\n          field.\
    \   Bit  flags  are  used to indicate if the target has\n          implemented\
    \ particular optional commands.  Not all  optional\n          commands  are  referenced\
    \  in  this  field.  Commands  whose\n          implementation   depends  on \
    \ target  machine  features  are\n          omitted.   The  LDP  application is\
    \ expected to 'know' about\n          target features that are  not  intrinsic\
    \  to  the  protocol.\n          Examples  of  target-dependent  commands  are\
    \  commands that\n          refer to named objects (CREATE, LIST_NAMES).\n   \
    \             Mask |  Symbol     | Description\n               ------+-------------+---------------+-----------------\n\
    \                 1     STEP          The STEP command is implemented\n      \
    \           2     WATCHPOINTS   Watchpoints are implemented\n                \
    \                  Options\n                                 Figure 18\n     5.3\
    \  SYNCH Command\n          The SYNCH command is sent by the host  to  the  target.\
    \  The\n     target  responds  with  a  SYNCH_REPLY.   The SYNCH - SYNCH_REPLY\n\
    \     exchange serves two functions: it synchronizes the host-to-target\n    \
    \ implicit sequence number and acts as a cumulative acknowledgement\n     of the\
    \ receipt and execution of  all  host  commands  up  to  the\n     SYNCH.\n  \
    \                     0             0 0   1         1\n                      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               6               |\n                   \
    \   +---------------+---------------+\n                    1 |   PROTOCOL    |\
    \    SYNCH      |\n                      +---------------+---------------+\n \
    \                   2 |       Sequence Number         |\n                    \
    \  +---------------+---------------+\n                           SYNCH Command\
    \ Format\n                                 Figure 19\n     SYNCH FIELDS:\n   \
    \  Sequence Number\n          The sequence number of this command.  If this  is\
    \  not  what\n          the  target  is  expecting,  the target will reset to\
    \ it and\n          respond with an ERROR reply.\n     5.4  SYNCH_REPLY\n    \
    \      A SYNCH_REPLY is sent by the target in reponse  to  a  valid\n     SYNCH\
    \  command.   A SYNCH command is valid if its sequence number\n     agrees  with\
    \  the  sequence  number  the  target  is   expecting.\n     Otherwise, the target\
    \ will reset its sequence number to the SYNCH\n     command and send an ERROR\
    \ reply.\n                       0             0 0   1         1\n           \
    \            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               6               |\n                   \
    \   +---------------+---------------+\n                    1 |   PROTOCOL    |\
    \  SYNCH_REPLY  |\n                      +---------------+---------------+\n \
    \                   2 |       Sequence Number         |\n                    \
    \  +---------------+---------------+\n                            SYNCH_REPLY\
    \ Format\n                                 Figure 20\n     SYNCH_REPLY FIELDS:\n\
    \     Sequence Number\n          The sequence number of  the  SYNCH  command \
    \ to  which  this\n          SYNCH_REPLY is the response.\n     5.5  ABORT Command\n\
    \          The ABORT command is sent from the host to abort all pending\n    \
    \ operations  at  the target.  The target responds with ABORT_DONE.\n     This\
    \ is primarily intended to stop large data transfers from  the\n     target. \
    \ A likely application would be during a debugging session\n     when the user\
    \ types an interrupt to abort  a  large  printout  of\n     data  from  the  target.\
    \   The ABORT command has no effect on any\n     breakpoints or watchpoints that\
    \ may be enabled in the target.\n          As a practical matter, the ABORT command\
    \ may be difficult to\n     implement  on  some  targets.   Its  ability to interrupt\
    \ command\n     processing on the target depends on the target being able to look\n\
    \     ahead at incoming commands and receive an out-of-band signal from\n    \
    \ the host.  However, the effect of an ABORT  may  be  achieved  by\n     simply\
    \ closing and reopening the transport connection.\n                       0  \
    \           0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5\n                      +---------------+---------------+\n         \
    \           0 |               4               |\n                      +---------------+---------------+\n\
    \                    1 |   PROTOCOL    |    ABORT      |\n                   \
    \   +---------------+---------------+\n                           ABORT Command\
    \ Format\n                                 Figure 21\n     5.6  ABORT_DONE Reply\n\
    \          The ABORT_DONE reply is sent from the target to the host  in\n    \
    \ response to an ABORT command.  This indicates that the target has\n     terminated\
    \ all  operations  that  were  pending  when  the  ABORT\n     command  was  received.\
    \  The sequence number of the ABORT command\n     is included in the reply.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               4               |\n                   \
    \   +---------------+---------------+\n                    1 |   PROTOCOL    |\
    \    ABORT_DONE |\n                      +---------------+---------------+\n \
    \                   2 |       Sequence Number         |\n                    \
    \  +---------------+---------------+\n                          ABORT_DONE Reply\
    \ Format\n                                 Figure 22\n     ABORT_DONE FIELDS:\n\
    \     Sequence Number\n          The sequence number of the ABORT command that\
    \ elicited  this\n          reply.   This  enables   the  host  to  distinguish\
    \  between\n          replies to multiple aborts.\n     5.7  ERROR Reply\n   \
    \       The ERROR reply is sent by the target in response to  a  bad\n     command.\
    \   The  ERROR  reply  gives  the  sequence  number of the\n     offending command\
    \ and a reason code.  The target ignores  further\n     commands   until  an \
    \ ERRACK command is received.  The reason for\n     ignoring commands is that\
    \ the  proper  operation  of  outstanding\n     commands  may  be  predicated\
    \  on  the execution of the erroneous\n     command.\n                       0\
    \             0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5\n                      +---------------+---------------+\n       \
    \             0 |        Command Length         |\n                      +---------------+---------------+\n\
    \                    1 |   PROTOCOL    |    ERROR      |\n                   \
    \   +---------------+---------------+\n                    2 |   Command Sequence\
    \ Number     |\n                      +---------------+---------------+\n    \
    \                3 |          Error code           |\n                      +---------------+---------------+\n\
    \                    4 |       Optional Data           |\n                   \
    \   +---------------+---------------+\n                                      *\n\
    \                                      *\n                                   \
    \   *\n                      +---------------+---------------+\n             \
    \       n |       Optional Data           |\n                      +---------------+---------------+\n\
    \                            ERROR Reply Format\n                            \
    \     Figure 23\n     ERROR Reply FIELDS:\n     Command Sequence Number\n    \
    \      The implicit sequence number of the erroneous command.\n     Error Code\n\
    \          A code specifying what error has taken place.  The currently\n    \
    \      defined codes are shown in Figure 24.\n                    Error Code |\
    \  Symbol\n                    -----------+------------------------\n        \
    \                1         BAD_COMMAND\n                        2         BAD_ADDRESS_MODE\n\
    \                        3         BAD_ADDRESS_ID\n                        4 \
    \        BAD_ADDRESS_OFFSET\n                        5         BAD_CREATE_TYPE\n\
    \                        6         NO_RESOURCES\n                        7   \
    \      NO_OBJECT\n                        8         OUT_OF_SYNCH\n           \
    \             9         IN_BREAKPOINT\n                                ERROR Codes\n\
    \                                 Figure 24\n          An explanation of each\
    \ of these error codes follows:\n          BAD_COMMAND\n               The command\
    \ was not meaningful to the  target  machine.\n               This includes commands\
    \ that are valid but unimplemented\n               in this target.  Also, the\
    \ command  was  not  valid  in\n               this context.  For example, a command\
    \ given by the host\n               that  is  only  legal  in  a   breakpoint\
    \   (e.g.   IF,\n               SET_STATE).\n          BAD_ADDRESS_MODE <offending-address>\n\
    \               The mode of an address given  in  the  command  is  not\n    \
    \           meaningful  to  this  target  system.   For  example, a\n        \
    \       PROCESS address mode on a target that does not  support\n            \
    \   multi-processing.\n          BAD_ADDRESS_ID <offending-address>\n        \
    \       The ID field of an  address  didn't  correspond  to  an\n            \
    \   appropriate  thing.  For example, for a PROCESS address\n               mode,\
    \ the ID of a non-existent process.\n          BAD_ADDRESS_OFFSET <offending-address>\n\
    \               The offset field of the address was outside  the  legal\n    \
    \           range  for the thing addressed.  For example, an offset\n        \
    \       of 200,000 in PHYS_MACRO mode on a target with  64K  of\n            \
    \   macro-memory.\n          BAD_CREATE_TYPE\n               The object type in\
    \ a CREATE command was unknown.\n          NO_RESOURCES\n               A CREATE\
    \  command  failed  due  to  lack  of  necessary\n               resources.\n\
    \          NO_OBJECT\n               A GET_OBJECT command failed to find the named\
    \ object.\n          OUT_OF_SYNCH\n               The sequence  number  of  the\
    \  SYNCH  command  was  not\n               expected  by the target.  The target\
    \ has resynchronized\n               to it.\n          IN_BREAKPOINT <breakpoint-descriptor>\
    \ <breakpoint-sequence#>\n               <reason-code> [<optional-info>]\n   \
    \            An error occurred within  a  breakpoint  command  list.\n       \
    \        The given 16-bit sequence-number refers to the sequence\n           \
    \    number  of  the  CREATE  command   that   created   the\n               breakpoint,\
    \  while  breakpoint-sequence#  refers to the\n               sequence number\
    \ of the command  within  the  breakpoint\n               given by <breakpoint-descriptor>.\n\
    \     5.8  ERRACK Acknowledgement\n          An  ERRACK  is sent by the host \
    \ in  response  to  an  ERROR\n     reply  from  the  target.  The ERRACK is used\
    \ to acknowledge that\n     the host has received the ERROR reply.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               4               |\n                   \
    \   +---------------+---------------+\n                    1 |   PROTOCOL    |\
    \    ERRACK     |\n                      +---------------+---------------+\n \
    \                          ERRACK Command Format\n                           \
    \      Figure 25\n                                 CHAPTER 6\n               \
    \           Data Transfer Commands\n          Data transfer commands  transfer\
    \ data between the  host  and\n     the  target.  These commands are used for\
    \ loading and dumping the\n     target, and examining and depositing  locations\
    \  on  the  target.\n     The  READ  command  reads  data from the target, the\
    \ MOVE command\n     moves data within the  target  or  from  the  target  to\
    \  another\n     entity,  and  the  WRITE  command  writes  data  to  the  target.\n\
    \     REPEAT_DATA makes copies of a pattern to  the  target  --  it  is\n    \
    \ useful  for  zeroing memory.  WRITE_MASK writes data with a mask,\n     and\
    \ is intended for modifying target  parameter tables.\n          Data transmitted\
    \ to  and from the target always  contains  a\n     target  address.   In  writes\
    \  to the target, this is used as the\n     destination of the data.  In reads\
    \ from the  target,  the  target\n     address  is  used by the host to identify\
    \ where in the target the\n     data came from.  In addition, the  MOVE  command\
    \  may  contain  a\n     'host'  address  as  its  destination;  this  permits\
    \ the host to\n     further discriminate between possible sources of  data  from\
    \  the\n     target -- from different breakpoints, debugging windows, etc.\n \
    \         A read request to  the  target  may  generate  one  or  more\n     response\
    \  messages.   In  particular,  responses  to requests for\n     large amounts\
    \ of data -- core  dumps,  for  example  --  must  be\n     broken  up into multiple\
    \ messages, if the block of data requested\n     plus the LDP header exceeds the\
    \ transport layer message size.\n          In commands which contain data (WRITE,\
    \ READ_DATA,  MOVE_DATA\n     and REPEAT_DATA), if there are an odd number of\
    \ data octets, then\n     a  null octet is appended.  This is so that the next\
    \  command  in\n     the  message,  if  any, will begin on an even octet.  The\
    \ command\n     length is the sum of the number of octets in the  command  header\n\
    \     and  the  number  of octets of data, excluding the null octet, if\n    \
    \ any.\n          The addressing formats which may be used with data  transfer\n\
    \     commands  are  specified for each LDP session at the start of the\n    \
    \ session by the target  in  the  HELLO_REPLY  response.   See  the\n     section\
    \  entitled  'Addressing',  above, for a description of LDP\n     addressing formats\
    \ and modes.   In  the  command  diagrams  given\n     below,  the  short  addressing\
    \  format  is  illustrated.  For LDP\n     sessions using long addressing, addresses\
    \ are  five  words  long,\n     instead of three words, as shown here.  In both\
    \ addressing modes,\n     descriptors are three words and offsets are two words.\n\
    \     6.1  WRITE Command\n          The WRITE command is used to send octets of\
    \  data  from  the\n     host  to  the  target.  This command specifies the address\
    \ in the\n     target where the data is to be stored, followed by  a  stream \
    \ of\n     data  octets.   If  the  data  stream  contains  an odd number of\n\
    \     octets, then a  null octet is appended so that the next  command,\n    \
    \ if  any,  will  begin  on  an even octet.  Since LDP must observe\n     message\
    \ size limitations  imposed  by  the  underlying  transport\n     layer,  a  single\
    \  logical  write  may  need to be broken up into\n     multiple WRITEs in separate\
    \ transport messages.\n                       0             0 0   1         1\n\
    \                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                    \
    \  +---------------+---------------+\n                    0 |        Command Length\
    \         |\n                      +---------------+---------------+\n       \
    \             1 | DATA_TRANSFER |    WRITE      |\n                      +---------------+---------------+\n\
    \                    2 |                               |\n                   \
    \   +--          Target           --+\n                    3 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  4 |                               |\n                     \
    \ +---------------+---------------+\n                    5 |  Data Octet   | \
    \ Data Octet   |\n                      +---------------+---------------+\n  \
    \                                    *\n                                     \
    \ *\n                                      *\n                      +---------------+---------------+\n\
    \                    n |  Data Octet   | Data or Null  |\n                   \
    \   +---------------+---------------+\n                           WRITE Command\
    \ Format\n                                 Figure 26\n     WRITE FIELDS:\n   \
    \  Command Length\n          The command  length  gives  the  number  of  octets\
    \  in  the\n          command,  including  data  octets, but excluding the padding\n\
    \          octet, if any.\n     Target Start Address\n          This is the address\
    \ to begin storing  data  in  the  target.\n          The  length  of the data\
    \ to be stored may be inferred by the\n          target from the command length.\
    \  An illegal address or range\n          will generate an ERROR reply.\n    \
    \ Data Octets\n          Octets of data to be stored in the target.  Data are\
    \  packed\n          according  to  the packing convention described above.  Ends\n\
    \          with a null octet if there are an odd number of data octets.\n    \
    \ 6.2  READ Command\n          The host uses the READ command  to   ask   the\
    \   target   to\n     send  back  a contiguous block of data.  The data is specified\
    \ by\n     a target starting address and a count.  The  target  returns  the\n\
    \     data  in  one or more READ_DATA commands, which give the starting\n    \
    \ address (in the target) of each segment of returned  data.   When\n     the\
    \  transfer  is completed, the target sends a READ_DONE command\n     to the host.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               14              |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \    READ       |\n                      +---------------+---------------+\n \
    \                   2 |                               |\n                    \
    \  +--          Target           --+\n                    3 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  4 |                               |\n                     \
    \ +---------------+---------------+\n                    5 |            Address\
    \            |\n                      +--          Unit             --+\n    \
    \                6 |            Count              |\n                      +---------------+---------------+\n\
    \                            READ Command Format\n                           \
    \      Figure 27\n     READ FIELDS:\n     Target Start Address\n          The\
    \ starting address of the requested block of target  data.\n          The  target\
    \  sends an ERROR reply if the starting address is\n          illegal, if the\
    \ ending address computed from the sum of  the\n          start  and the count\
    \ is illegal, or if holes are encountered\n          in the middle of the range.\n\
    \     Address Unit Count\n          The count of the number  of  target  indivisibly-addressable\n\
    \          units  to be transferred.  For example, if the address space\n    \
    \      is PHYS_MACRO, a count of two and a start  address  of  1000\n        \
    \  selects the contents of locations 1000 and 1001.  'Count' is\n          used\
    \ instead of 'length' to avoid the problem of determining\n          units  the\
    \  length  should be denominated in (octets, words,\n          etc.).  The size\
    \ and type of the unit will vary depending on\n          the address space selected\
    \ by the target start address.  The\n          target should  reply  with  an\
    \  error  (if  it  is  able  to\n          determine  in  advance of a transfer)\
    \ if the inclusive range\n          of addresses specified by the start address\
    \  and  the  count\n          contains an illegal or nonexistent address.\n  \
    \   6.3  READ_DATA Response\n          The target uses the  READ_DATA  response\
    \  to  transmit  data\n     requested  by  a  host  READ  command.   One  or \
    \ more  READ_DATA\n     responses  may  be  needed  to  fulfill  a  given  READ\
    \  command,\n     depending  on  the  size  of  the  data  block  requested and\
    \ the\n     transport layer message size  limits.   Each  READ_DATA  response\n\
    \     gives the target starting address of its segment of data.  If the\n    \
    \ response contains an odd number of data octets, the  target  ends\n     the\
    \ response with a null octet.\n                       0             0 0   1  \
    \       1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n          \
    \            +---------------+---------------+\n                    0 |      \
    \  Command Length         |\n                      +---------------+---------------+\n\
    \                    1 | DATA_TRANSFER |    READ_DATA  |\n                   \
    \   +---------------+---------------+\n                    2 |               \
    \                |\n                      +--          Target           --+\n\
    \                    3 |            Start              |\n                   \
    \   +--          Address          --+\n                    4 |               \
    \                |\n                      +---------------+---------------+  +-+\n\
    \                    5 |  Data Octet   |  Data Octet   |   |\n               \
    \       +---------------+---------------+   |\n                              \
    \        *                   |\n                                      *      \
    \             | Data\n                                      *                \
    \   |\n                      +---------------+---------------+   |\n         \
    \           n |  Data Octet   | Data or Null  |   |\n                      +---------------+---------------+\
    \  +-+\n                           DATA Response Format\n                    \
    \             Figure 28\n     READ_DATA FIELDS:\n     Command Length\n       \
    \   The command  length  gives  the  number  of  octets  in  the\n          command,\
    \  including  data  octets, but excluding the padding\n          octet, if any.\
    \  The host can calculate  the  length  of  the\n          data  by  subtracting\
    \  the  header  length  from the command\n          length.  Since the target\
    \ address may be either three  words\n          (short format) or five words (long\
    \ format), the address mode\n          must be checked to determine which is being\
    \ used.\n     Target Start Address\n          This is the starting address of\
    \ the  data  segment  in  this\n          message.  The host may infer the length\
    \ of the data from the\n          command length.  The address format (short or\
    \ long)  is  the\n          same as on the initial READ command.\n     Data Octets\n\
    \          Octets of data from the target.  Data are  packed  according\n    \
    \      to the packing convention described above.  Ends with a null\n        \
    \  octet if there are an odd number of data octets.\n     6.4  READ_DONE Reply\n\
    \          The target sends a READ_DONE reply to the host after it  has\n    \
    \ finished  transferring  the  data  requested  by  a READ command.\n     READ_DONE\
    \ specifies the sequence number of the READ command.\n                       0\
    \             0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5\n                      +---------------+---------------+\n       \
    \             0 |               6               |\n                      +---------------+---------------+\n\
    \                    1 | DATA_TRANSFER |    READ_DONE  |\n                   \
    \   +---------------+---------------+\n                    2 |      READ Sequence\
    \ Number     |\n                      +---------------+---------------+\n    \
    \                      READ_DONE Reply Format\n                              \
    \   Figure 29\n     READ_DONE FIELDS:\n     READ Sequence Number\n          The\
    \ sequence number of the READ command this is a reply to.\n     6.5  MOVE Command\n\
    \          The MOVE command is sent by the host to move a block of data\n    \
    \ from  the  target  to  a  specified destination.  The destination\n     address\
    \ may specify a location in the target, in the host, or  in\n     another  target\
    \  (for loading one target from another).  The data\n     is specified by a target\
    \ starting address  and  an  address  unit\n     count.   The  target sends an\
    \ ERROR reply if the starting address\n     is illegal, if the ending address\
    \ computed from the  sum  of  the\n     start  and  the  count is illegal, or\
    \ if holes are encountered in\n     the middle of the range.  If the MOVE destination\
    \ is  off-target,\n     the  target  moves the data in one or MOVE_DATAs.  Other\
    \ commands\n     arriving at the target during the transfer should be processed\
    \ in\n     a  timely fashion, particularly the ABORT command.  When the data\n\
    \     has been moved,  the  target  sends  a  MOVE_DONE  to  the  host.\n    \
    \ However,   a  MOVE  within  a  breakpoint  will  not  generate  a\n     MOVE_DONE.\n\
    \          A MOVE with a host destination differs from a READ  in  that\n    \
    \ it contains a host address.  This field is specified  by the host\n     in the\
    \ MOVE command and copied by the target into the  responding\n     MOVE_DATA(s).\
    \   The   address   may   be  used  by  the  host  to\n     differentiate data\
    \ returned from multiple  MOVE  requests.   This\n     information   may  be \
    \ useful  in  breakpoints,  in  multi-window\n     debugging  and  in  communication\
    \  with  targets  with   multiple\n     processors.   For example, the host sends\
    \ the MOVE command to the\n     target to  be  executed  during  a breakpoint.\
    \  The ID  field  in\n     the  host address might be an index into a host breakpoint\
    \ table.\n     When the breakpoint executes,  the  host  would  use  the  ID \
    \ to\n     associate the returning MOVE_DATA with this breakpoint.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \    MOVE       |\n                      +---------------+---------------+\n \
    \                   2 |                               |\n                    \
    \  +--          Source           --+\n                    3 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  4 |                               |\n                     \
    \ +---------------+---------------+\n                    5 |            Address\
    \            |\n                      +--          Unit             --+\n    \
    \                6 |            Count              |\n                      +---------------+---------------+\n\
    \                    7 |                               |\n                   \
    \   +--          Destination      --+\n                    8 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  9 |                               |\n                     \
    \ +---------------+---------------+\n                            MOVE Command\
    \ Format\n                                 Figure 30\n     MOVE  FIELDS:\n   \
    \  Source Start Address\n          The starting address of the requested block\
    \ of target  data.\n          An illegal address type will generate an error reply.\n\
    \     Address Unit Count\n          The count of the number  of  target  indivisibly-addressable\n\
    \          units  to be transferred.  For example, if the address space\n    \
    \      is PHYS_MACRO, a count of two and a start  address  of  1000\n        \
    \  selects the contents of locations 1000 and 1001.  'Count' is\n          used\
    \ instead of 'length' to avoid the problem of determining\n          units  the\
    \  length  should be denominated in (octets, words,\n          etc.).  The size\
    \ and type of the unit will vary depending on\n          the address space selected\
    \ by the target start address.  The\n          target should  reply  with  an\
    \  error  (if  it  is  able  to\n          determine  in  advance of a transfer)\
    \ if the inclusive range\n          of addresses specified by the start address\
    \  and  the  count\n          contains an illegal or nonexistent address.\n  \
    \   Destination Address\n          The destination of the MOVE.  If the address\
    \ space is on the\n          target,  the address unit size should agree with\
    \ that of the\n          source address space.  If the address  mode  is  HOST,\
    \   the\n          values  and  interpretations of the remaining address fields\n\
    \          are   arbitrary,   and   are   determined   by   the    host\n    \
    \      implementation.    For  example,  the  mode  argument  might\n        \
    \  specify a table (breakpoint, debugging window, etc.) and the\n          ID\
    \ field an index into the table.\n     6.6  MOVE_DATA Response\n          The\
    \ target uses the MOVE_DATA  responses  to  transmit  data\n     requested  by\
    \  a  host  MOVE  command.   One  or  more  MOVE_DATA\n     responses  may  be\
    \  needed  to  fulfill  a  given  MOVE  command,\n     depending  on  the  size\
    \  of  the  data  block  requested and the\n     transport layer message size\
    \  limits.   Each  MOVE_DATA  response\n     gives the target starting address\
    \ of its segment of data.  If the\n     response contains an odd number of data\
    \ octets, the target should\n     end the response with a null octet.\n      \
    \                 0             0 0   1         1\n                       0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \    MOVE_DATA  |\n                      +---------------+---------------+\n \
    \                   2 |                               |\n                    \
    \  +--          Source           --+\n                    3 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  4 |                               |\n                     \
    \ +---------------+---------------+\n                    5 |                 \
    \              |\n                      +--          Destination      --+\n  \
    \                  6 |            Start              |\n                     \
    \ +--          Address          --+\n                    7 |                 \
    \              |\n                      +---------------+---------------+    +-+\n\
    \                    8 |  Data Octet   |  Data Octet   |     |\n             \
    \         +---------------+---------------+     |\n                          \
    \            *                     |\n                                      *\
    \                     | Data\n                                      *        \
    \             |\n                      +---------------+---------------+     |\n\
    \                    n |  Data Octet   | Data or Null  |     |\n             \
    \         +---------------+---------------+    +-+\n                         MOVE_DATA\
    \ Response Format\n                                 Figure 31\n     MOVE_DATA\
    \ FIELDS:\n     Command Length\n          The command  length  gives  the  number\
    \  of  octets  in  the\n          command,  including  data  octets, but excluding\
    \ the padding\n          octet, if any.\n     Source Start Address\n         \
    \ This is the starting address of the  data  segment  in  this\n          message.\
    \   The  host  may  infer length of the data from the\n          command length.\n\
    \     Destination Address\n          The destination address copied from the \
    \ MOVE  command  that\n          initiated this transfer.  In the case of HOST\
    \ MOVEs, this is\n          used by the host to identify the source of the data.\n\
    \     Data Octets\n          Octets of data from the target.  Data are  packed\
    \  according\n          to the packing convention described above.  Ends with\
    \ a null\n          octet if there are an odd number of data octets.\n     6.7\
    \  MOVE_DONE Reply\n          The target sends a MOVE_DONE reply to the host after\
    \ it  has\n     finished  transferring  the  data  requested  by  a MOVE command.\n\
    \     MOVE_DONE specifies the sequence number of the MOVE command.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               6               |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \    MOVE_DONE  |\n                      +---------------+---------------+\n \
    \                   2 |      MOVE Sequence Number     |\n                    \
    \  +---------------+---------------+\n                          MOVE_DONE Reply\
    \ Format\n                                 Figure 32\n     MOVE_DONE FIELDS:\n\
    \     MOVE Sequence Number\n          The sequence number of the MOVE command\
    \ this is a reply to.\n     6.8  REPEAT_DATA\n          The REPEAT_DATA command\
    \ is sent by the host to write  copies\n     of  a  specified  pattern  into \
    \ the  target.   This  provides an\n     efficient way of zeroing target memory\
    \  and  initializing  target\n     data  structures.   The  command  specifies\
    \  the  target starting\n     address, the number of copies of the pattern to\
    \ be  made,  and  a\n     stream of octets that constitutes the pattern.\n   \
    \       This command differs from the other data  transfer  commands\n     in\
    \  that  the effect of a REPEAT_DATA with a large pattern cannot\n     be duplicated\
    \ by sending the data in smaller chunks over  several\n     commands.   Therefore,\
    \  the maximum size of a pattern that can be\n     copied with REPEAT_DATA will\
    \ depend on the message size limits of\n     the transport layer.\n          \
    \             0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \ REPEAT_DATA   |\n                      +---------------+---------------+\n \
    \                   2 |                               |\n                    \
    \  +--          Target           --+\n                    3 |            Start\
    \              |\n                      +--          Address          --+\n  \
    \                  4 |                               |\n                     \
    \ +---------------+---------------+\n                    6 |         Repeat Count\
    \          |\n                      +---------------+---------------+  +-+\n \
    \                   7 |  Data Octet   |  Data Octet   |   |\n                \
    \      +---------------+---------------+   |\n                               \
    \       *                   |\n                                      *       \
    \            | Pattern\n                                      *              \
    \     |\n                      +---------------+---------------+   |\n       \
    \             n |  Data Octet   | Data or Null  |   |\n                      +---------------+---------------+\
    \  +-+\n                        REPEAT_DATA Command Format\n                 \
    \                Figure 33\n     REPEAT_DATA FIELDS:\n     Command Length\n  \
    \        The command  length  gives  the  number  of  octets  in  the\n      \
    \    command, including data octets in the pattern, but excluding\n          the\
    \ padding octet, if any.\n     Target Start Address\n          This is the starting\
    \ address where the  first  copy  of  the\n          pattern  should be written\
    \ in the target.  Successive copies\n          of the  pattern  are  made  contiguously\
    \  starting  at  this\n          address.\n     Repeat Count\n          The repeat\
    \ count specifies  the  number  of  copies  of  the\n          pattern that should\
    \ be made in the target.  The repeat count\n          should be greater than zero.\n\
    \     Pattern\n          The pattern to be copied into  the  target,  packed \
    \ into  a\n          stream  of octets.  Data are packed according to the packing\n\
    \          convention described above.  Ends with a null octet if there\n    \
    \      are an odd number of data octets.\n     6.9  WRITE_MASK Command (Optional)\n\
    \          The host sends a WRITE_MASK command to the target  to  write\n    \
    \ one  or  more  masked  values.   The  command  uses an address to\n     specify\
    \ a target base location, followed by one or  more  offset-\n     mask-value triplets.\
    \  Each triplet gives an offset from the base,\n     a value, and a mask indicating\
    \ which bits in the location at  the\n     offset are to be changed.\n       \
    \   This optional command is intended for use in controlling the\n     target\
    \  by changing locations in a table.  For example, it may be\n     used  to  change\
    \  entries  in  a  target  parameter  table.   The\n     operation  of  modifying\
    \ a specified location with a masked value\n     is intended to be atomic.  In\
    \ other words, another target process\n     should  not be able to access the\
    \ location to be modified between\n     the start and the end of the modification.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 | DATA_TRANSFER |\
    \ WRITE_MASK    |\n                      +---------------+---------------+\n \
    \                   2 |                               |\n                    \
    \  +--          Target           --+\n                    3 |            Base\
    \               |\n                      +--          Address          --+\n \
    \                   4 |                               |\n                    \
    \  +---------------+---------------+   +-+\n                    5 |          \
    \                     |    |\n                      +--          Offset      \
    \     --+    |\n                    6 |                               |    |\n\
    \                      +---------------+---------------+    | Offset-Mask-Value\n\
    \                    7 |                               |    | Triplet\n      \
    \                +--          Mask             --+    |\n                    8\
    \ |                               |    |\n                      +---------------+---------------+\
    \    |\n                    9 |                               |    |\n       \
    \               +--          Value            --+    |\n                    10|\
    \                               |    |\n                      +---------------+---------------+\
    \   +-+\n                                      *\n                           \
    \           *\n                                      *\n                     \
    \ +---------------+---------------+   +-+\n                      |           \
    \                    |    |\n                      +--          Offset       \
    \    --+    |\n                      |                               |    |\n\
    \                      +---------------+---------------+    | Offset-Mask-Value\n\
    \                      |                               |    | Triplet\n      \
    \                +--          Mask             --+    |\n                    \
    \  |                               |    |\n                      +---------------+---------------+\
    \    |\n                      |                               |    |\n       \
    \               +--          Value            --+    |\n                     \
    \ |                               |    |\n                      +---------------+---------------+\
    \   +-+\n                             WRITE_MASK Format\n                    \
    \             Figure 34\n     WRITE_MASK FIELDS:\n     Command Length\n      \
    \    The command  length  gives  the  number  of  octets  in  the\n          command.\
    \  The number of offset-value pairs may be calculated\n          from this, since\
    \ the command  header  is  either  10  or  12\n          octets  long  (short\
    \  or  long  address  format),  and  each\n          offset-mask-value triplet\
    \ is 12 octets long.\n     Target Base Address\n          Specifies the target\
    \ location to which the offset  is  added\n          to yield the location to\
    \ be modified.\n     Offset\n          An offset to be added to the base to select\
    \ a location to be\n          modified.\n     Mask\n          Specifies which\
    \ bits in the value are to be copied into  the\n          location.\n     Value\n\
    \          A value to be stored at the specified offset from the  base.\n    \
    \      The  set  bits in the mask determine which bits in the value\n        \
    \  are applied to the location.  The following  algorithm  will\n          achieve\
    \  the  intended result:  take the one's complement of\n          the mask and\
    \ AND it with the location, leaving the result in\n          the  location.  \
    \ Then AND the mask and the value, and OR the\n          result into the location.\n\
    \                                 CHAPTER 7\n                             Control\
    \ Commands\n          Control commands are used to control the execution of target\n\
    \     code,  breakpoints  and  watchpoints.  They are also used to read\n    \
    \ and report  the  state  of  these  objects.   The  object  to  be\n     controlled\
    \  or reported on is specified with a descriptor.  Valid\n     descriptor modes\
    \ include PHYS_* (for some commands) PROCESS_CODE,\n     BREAKPOINT  and  WATCHPOINT.\
    \   Control  commands which change the\n     state of the target are START, STOP,\
    \ CONTINUE and  STEP.   REPORT\n     requests  a  STATUS  report  on  a target\
    \ object.  EXCEPTION is a\n     spontaneous report on an  object,  used  to  report\
    \  asynchronous\n     events such as hardware traps.  The host may verify the\
    \ action of\n     a START, STOP, STEP or CONTINUE command by following  it  with\
    \  a\n     REPORT command.\n     7.1  START Command\n          The START command\
    \ is sent by the host to start execution  of\n     a  specified  object  in  the\
    \  target.  For targets which support\n     multiple processes, a PROCESS_CODE\
    \ address specifies the  process\n     to  be  started.  Otherwise, one of the\
    \  PHYS_* modes may specify\n     a location  in  macro-memory  where  execution\
    \  is  to  continue.\n     Applied  to  a  breakpoint or watchpoint, START sets\
    \ the value of\n     the object's state variable, and activates the  breakpoint.\
    \   The\n     breakpoint counter and pointer variables are initialized to zero.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               14              |\n                   \
    \   +---------------+---------------+\n                    1 |   CONTROL     |\
    \     START     |\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       |     0         |   |\n               \
    \       +---------------+---------------+   |\n                    3 |       \
    \                        |   |\n                      +--            ID      \
    \       --+   |\n                    4 |              Field            |   | \
    \ Address\n                      +-------------------------------+   |\n     \
    \               5 |                               |   |\n                    \
    \  +--            Offset         --+   |\n                    6 |            \
    \                   |   |\n                      +-------------------------------+\
    \  +-+\n                           START Command Format\n                    \
    \             Figure 35\n     START FIELDS:\n     Address\n          The descriptor\
    \ specifies the object to be started.   If  the\n          mode  is  PROCESS_CODE,\
    \  ID  specifies  the  process  to  be\n          started, and offset gives the\
    \  process  virtual  address  to\n          start at.  If the mode is PHYS_*,\
    \ execution of the target is\n          continued at the specified address.\n\
    \          For modes of BREAKPOINT and WATCHPOINT, the offset specifies\n    \
    \      the  new  value  of the FSM state variable.  This is for FSM\n        \
    \  breakpoints and watchpoints.\n     7.2  STOP Command\n          The STOP command\
    \ is sent by the host to stop execution of  a\n     specified  object  in  the\
    \  target.   A  descriptor specifies the\n     object. Applied to a breakpoint\
    \ or watchpoint,  STOP  deactivates\n     it.   The  breakpoint/watchpoint may\
    \ be re-activated by issuing a\n     START or a CONTINUE command for it.\n   \
    \                    0             0 0   1         1\n                       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               10              |\n                   \
    \   +---------------+---------------+\n                    1 |   CONTROL     |\
    \     STOP      |\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       |     0         |   |\n               \
    \       +---------------+---------------+   |\n                    3 |       \
    \                        |   |  Descriptor\n                      +--        \
    \    ID             --+   |\n                    4 |              Field      \
    \      |   |\n                      +-------------------------------+  +-+\n \
    \                           STOP Command Format\n                            \
    \     Figure 36\n     STOP FIELDS:\n     Descriptor\n          The  descriptor\
    \  specifies  the  object  to  be  stopped  or\n          disarmed.  If the mode\
    \ is PROCESS_CODE, the ID specifies the\n          process to be stopped.\n  \
    \        For  modes  of  BREAKPOINT  and  WATCHPOINT,  the  specified\n      \
    \    breakpoint  or  watchpoint  is  deactivated.   It may be re-\n          activated\
    \ by a CONTINUE or START command.\n     7.3  CONTINUE Command\n          The CONTINUE\
    \ command is sent by the host to resume execution\n     of  a specified object\
    \ in the target.  A descriptor specifies the\n     object. Applied to a breakpoint\
    \ or watchpoint, CONTINUE activates\n     it.\n                       0      \
    \       0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5\n                      +---------------+---------------+\n             \
    \       0 |               10              |\n                      +---------------+---------------+\n\
    \                    1 |   CONTROL     |     CONTINUE  |\n                   \
    \   +---------------+---------------+  +-+\n                    2 |    Mode  \
    \     |     0         |   |\n                      +---------------+---------------+\
    \   |\n                    3 |                               |   |  Descriptor\n\
    \                      +--            ID             --+   |\n               \
    \     4 |              Field            |   |\n                      +-------------------------------+\
    \  +-+\n                          CONTINUE Command Format\n                  \
    \               Figure 37\n     CONTINUE FIELDS:\n     Descriptor\n          The\
    \ descriptor specifies the object to be resumed or  armed.\n          If the mode\
    \ is PROCESS_CODE, the ID specifies the process to\n          be resumed.\n  \
    \        For  modes  of  BREAKPOINT  and  WATCHPOINT,  the  specified\n      \
    \    breakpoint or watchpoint is armed.\n     7.4  STEP Command\n          The\
    \ STEP command is sent by the  host  to  the  target.   It\n     requests   the\
    \  execution  of  one  instruction  (or  appropriate\n     operation) in the object\
    \ specified by the descriptor.\n                       0             0 0   1 \
    \        1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n         \
    \             +---------------+---------------+\n                    0 |     \
    \          10              |\n                      +---------------+---------------+\n\
    \                    1 |   CONTROL     |     STEP      |\n                   \
    \   +---------------+---------------+  +-+\n                    2 |    Mode  \
    \     |     0         |   |\n                      +---------------+---------------+\
    \   |\n                    3 |                               |   |  Descriptor\n\
    \                      +--            ID             --+   |\n               \
    \     4 |              Field            |   |\n                      +-------------------------------+\
    \  +-+\n                            STEP Command Format\n                    \
    \             Figure 38\n     STEP FIELDS:\n     Descriptor\n          The descriptor\
    \ specifies the object to be stepped.   If  the\n          mode is PROCESS_CODE,\
    \ the ID specifies a process.\n     7.5  REPORT Command\n          The REPORT\
    \ command is sent by the host to request  a  status\n     report on a specified\
    \ target object.  The status is returned in a\n     STATUS reply.\n          \
    \             0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               10              |\n                   \
    \   +---------------+---------------+\n                    1 |   CONTROL     |\
    \     REPORT    |\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       |     0         |   |\n               \
    \       +---------------+---------------+   |\n                    3 |       \
    \                        |   |  Descriptor\n                      +--        \
    \    ID             --+   |\n                    4 |              Field      \
    \      |   |\n                      +-------------------------------+  +-+\n \
    \                          REPORT Command Format\n                           \
    \      Figure 39\n     REPORT FIELDS:\n     Descriptor\n          The descriptor\
    \ specifies  the  object  for  which  a  STATUS\n          report  is  requested.\
    \   For  a mode of PROCESS_CODE, the ID\n          specifies a process.  Other\
    \ valid modes are  PHYS_MACRO,  to\n          query  the  status of the target\
    \ application, and BREAKPOINT\n          and WATCHPOINT,  to  get  the  status\
    \  of  a  breakpoint  or\n          watchpoint.\n     7.6  STATUS Reply\n    \
    \      The target sends a STATUS reply  in  response  to  a  REPORT\n     command\
    \  from  the  host.   STATUS gives the state of a specified\n     object.  For\
    \ example, it may tell  whether  a  particular  target\n     process is running\
    \ or stopped.\n                       0             0 0   1         1\n      \
    \                 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |         Command Length        |\n                   \
    \   +---------------+---------------+\n                    1 |   CONTROL     |\
    \     STATUS    |\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       |     0         |   |\n               \
    \       +---------------+---------------+   |\n                    3 |       \
    \                        |   |  Descriptor\n                      +--        \
    \    ID             --+   |\n                    4 |              Field      \
    \      |   |\n                      +-------------------------------+  +-+\n \
    \                   5 |              Status           |\n                    \
    \  +-------------------------------+  +-+\n                                  \
    \    *                   |\n                                      *          \
    \         |\n                                      *                   |  Other\
    \ Data\n                      +-------------------------------+   |\n        \
    \            n |        Other Data             |   |\n                      +-------------------------------+\
    \  +-+\n                            STATUS Reply Format\n                    \
    \             Figure 40\n     STATUS FIELDS:\n     Descriptor\n          The descriptor\
    \ specifies the object whose  status  is  being\n          given.  If the mode\
    \ is PROCESS_CODE, then the ID specifies a\n          process.  If the mode is\
    \ PHYS_MACRO, then the status is that\n          of the target application.\n\
    \     Status\n          The status code describes the status of the object.  \
    \ Status\n          codes  are  0=STOPPED  and  1=RUNNING.   For breakpoints and\n\
    \          watchpoints, STOPPED means disarmed and RUNNING means armed.\n    \
    \ Other Data\n          For breakpoints and watchpoints, Other Data  consists\
    \  of  a\n          16-bit  word  giving  the  current  value  of  the FSM state\n\
    \          variable.\n     7.7  EXCEPTION Trap\n          An EXCEPTION is a spontaneous\
    \ message sent from  the  target\n     indicating   a   target-machine   exception\
    \   associated  with  a\n     particular object. The object is specified by an\
    \ address.\n                       0             0 0   1         1\n         \
    \              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |         Command Length        |\n                   \
    \   +---------------+---------------+\n                    1 |   CONTROL     |\
    \   EXCEPTION   |\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       |     0         |   |\n               \
    \       +---------------+---------------+   |\n                    3 |       \
    \                        |   |\n                      +--            ID      \
    \       --+   |\n                    4 |              Field            |   | \
    \ Address\n                      +-------------------------------+   |\n     \
    \               5 |                               |   |\n                    \
    \  +--            Offset         --+   |\n                    6 |            \
    \                   |   |\n                      +-------------------------------+\
    \  +-+\n                    7 |              Type             |\n            \
    \          +-------------------------------+  +-+\n                          \
    \            *                   |\n                                      *  \
    \                 |\n                                      *                 \
    \  |  Other Data\n                      +-------------------------------+   |\n\
    \                    n |        Other Data             |   |\n               \
    \       +-------------------------------+  +-+\n                             EXCEPTION\
    \ Format\n                                 Figure 41\n     EXCEPTION FIELDS:\n\
    \     Address\n          The address specifies the object the exception is for.\n\
    \     Type\n          The type of exception.  Values are target-dependent.\n \
    \    Other Data\n          Values are target-dependent.\n                    \
    \             CHAPTER 8\n                            Management Commands\n   \
    \       Management commands are used to  control  resources  in  the\n     target\
    \  machine.   There  are  two kinds of commands:  those that\n     interrogate\
    \ the remote machine about resources,  and  those  that\n     allocate  and  free\
    \  resources.  There are management commands to\n     create,  list  and  delete\
    \  breakpoints.    All   commands   have\n     corresponding  replies  which \
    \ include the sequence number of the\n     request command.  Failing requests\
    \ produce ERROR replies.\n          There are  two  resource  allocation  commands,\
    \  CREATE  and\n     DELETE,  which  create  and delete objects in the remote\
    \ machine.\n     There are a number of listing commands for listing a  variety\
    \  of\n     target objects -- breakpoints, watchpoints, processes, and names.\n\
    \     The amount of data returned  by  listing  commands  may  vary  in\n    \
    \ length,  depending  on the state of the target.  If a list is too\n     large\
    \ to fit in a single message, the  target  will  send  it  in\n     several  list\
    \  replies.   A  flag in each reply specifies whether\n     more messages are\
    \ to follow.\n     8.1  CREATE Command\n          The CREATE command is sent from\
    \ the host to  the  target  to\n     create  a target object.  If the CREATE is\
    \ successful, the target\n     returns  a  CREATE_DONE  reply,  which  contains\
    \   a   descriptor\n     associated  with  the  CREATEd object.  The types of\
    \ objects that\n     may be specified in  a  CREATE  include  breakpoints,  processes,\n\
    \     memory  objects  and  descriptors.   All  are optional except for\n    \
    \ breakpoints.\n                       0             0 0   1         1\n     \
    \                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 | MANAGEMENT    |\
    \     CREATE    |\n                      +---------------+---------------+\n \
    \                   2 |           Create Type         |\n                    \
    \  +---------------+---------------+   +-+\n                                 \
    \     *                    |\n                                      *        \
    \            |  Create\n                                      *              \
    \      |  Arguments\n                      +---------------+---------------+ \
    \   |\n                    n |         Create Arguments      |    |\n        \
    \              +---------------+---------------+   +-+\n                     \
    \      CREATE Command Format\n                                 Figure 42\n   \
    \  CREATE FIELDS:\n     Create Type\n          The type of object to be created.\
    \  Arguments vary  with  the\n          type.   Currently defined types are shown\
    \ in Figure 43.  All\n          are optional except for BREAKPOINT.\n        \
    \            Create Type  |  Symbol\n                    -------------+----------------\n\
    \                       0            BREAKPOINT\n                       1    \
    \        WATCHPOINT\n                       2            PROCESS\n           \
    \            3            MEMORY_OBJECT\n                       4            DESCRIPTOR\n\
    \                               Create Types\n                               \
    \  Figure 43\n     Create Arguments\n          Create arguments depend on the\
    \ type of object being created.\n          The formats for each type of object\
    \ are described below.\n                       0             0 0   1         1\n\
    \                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                    \
    \  +---------------+---------------+\n                    0 |               22\
    \              |\n                      +---------------+---------------+\n  \
    \                  1 |   MANAGEMENT  |     CREATE    |\n                     \
    \ +---------------+---------------+\n                    2 |           BREAKPOINT\
    \          |\n                      +---------------+---------------+  +-+\n \
    \                   3 |    Mode       | Mode Argument |   |\n                \
    \      +---------------+---------------+   |\n                    4 |        \
    \                       |   |\n                      +--            ID       \
    \      --+   |  Create\n                    5 |              Field           \
    \ |   |  BREAKPOINT\n                      +-------------------------------+ \
    \  |  Arguments\n                    6 |                               |   |\n\
    \                      +--            Offset         --+   |\n               \
    \     7 |                               |   |\n                      +-------------------------------+\
    \   |\n                    8 |        Maximum States         |   |\n         \
    \             +---------------+---------------+   |\n                    9 | \
    \       Maximum Size           |   |\n                      +---------------+---------------+\
    \   |\n                    10|     Maximum Local Variables   |   |\n         \
    \             +---------------+---------------+  +-+\n                       \
    \  CREATE BREAKPOINT Format\n                                 Figure 44\n    \
    \ BREAKPOINT and WATCHPOINT\n          The format  is the same for  CREATE  BREAKPOINT\
    \  and  CREATE\n          WATCHPOINT.   In  the following discussion, 'breakpoint'\
    \ may\n          be taken to mean either breakpoint or watchpoint.\n         \
    \ The address is the location where the breakpoint  is  to  be\n          set.\
    \   In  the  case of watchpoints it is the location to be\n          watched.\
    \  Valid modes are any  PHYS_*  mode  that  addresses\n          macro-memory,\
    \  PROCESS_CODE for breakpoints and PROCESS_DATA\n          for watchpoints.\n\
    \          'Maximum states' is the number of states  the  finite  state\n    \
    \      machine  for  this  breakpoint  will  have.  A value of zero\n        \
    \  indicates a default breakpoint, for  targets  which  do  not\n          implement\
    \ finite state machine (FSM) breakpoints.  A default\n          breakpoint is\
    \ the same as an FSM with one  state  consisting\n          of  a  STOP  and a\
    \ REPORT command for the process containing\n          the breakpoint.\n     \
    \     'Maximum  size'  is  the  total  size,  in  octets,  of  the\n         \
    \ breakpoint  data  to  be sent via subsequent BREAKPOINT_DATA\n          commands.\
    \  This is the size of the data only, and  does  not\n          include the LDP\
    \ command headers and breakpoint descriptors.\n          'Maximum local variables'\
    \ is the number of 32-bit  longs  to\n          reserve  for  local variables\
    \ for this breakpoint.  Normally\n          this value will be zero.\n     PROCESS\n\
    \          Creates a new process.  Arguments are target-dependent.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \     CREATE    |\n                      +---------------+---------------+\n \
    \                   2 |         MEMORY_OBJECT         |\n                    \
    \  +---------------+---------------+\n                    3 |         Object Size\
    \           |\n                      +---------------+---------------+\n     \
    \               4 |           Name Size           |\n                      +-------------------------------+\
    \  +-+\n                    5 |    Name char  |  Name char    |   |\n        \
    \              +-------------------------------+   |\n                       \
    \               *                   |  Object\n                              \
    \        *                   |  Name\n                                      *\
    \                   |\n                      +---------------+---------------+\
    \   |\n                    n | 0 or Name char|       0       |   |\n         \
    \             +---------------+---------------+  +-+\n                       \
    \ CREATE MEMORY_OBJECT Format\n                                 Figure 45\n  \
    \   MEMORY_OBJECT\n          Creates an object of size Object Size, with the given\
    \  name.\n          Object  Size  is in target dependent units.  The name may\
    \ be\n          the null string for unnamed objects.  Name  Size  gives  the\n\
    \          number  of  characters  in  Object  Name,  and must be even.\n    \
    \      Always ends with a null octect.\n     DESCRIPTOR\n          Used for obtaining\
    \ descriptors from IDs  on  target  systems\n          where  IDs  are  longer\
    \  than  32  bits.   There is a single\n          argument, Long ID, whose length\
    \ is target dependent.\n     8.2  CREATE_DONE Reply\n          The target sends\
    \ a CREATE_DONE reply to the host in response\n     to  a successful CREATE command.\
    \  The reply contains the sequence\n     number of the CREATE request, and a \
    \ descriptor  for  the  object\n     created.   This  descriptor  is  used  by\
    \ the host to specify the\n     object in subsequent commands referring to  it.\
    \   Commands  which\n     refer  to  created  objects  include  LIST_* commands,\
    \ DELETE and\n     BREAKPOINT_DATA.  For example, to delete a  CREATEd  object,\
    \  the\n     host  sends  a  DELETE  command  that  specifies  the  descriptor\n\
    \     returned by the CREATE_DONE reply.\n                       0           \
    \  0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\
    \                      +---------------+---------------+\n                   \
    \ 0 |               12              |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  |  CREATE_DONE  |\n                   \
    \   +---------------+---------------+\n                    2 |     Create Sequence\
    \ Number    |\n                      +---------------+---------------+  +-+\n\
    \                    3 |    Mode       | Mode Argmuent |   |\n               \
    \       +---------------+---------------+   |  Created\n                    4\
    \ |                               |   |  Object\n                      +--   \
    \         ID             --+   |  Descriptor\n                    5 |        \
    \      Field            |   |\n                      +---------------+---------------+\
    \  +-+\n                         CREATE_DONE Reply Format\n                  \
    \               Figure 46\n     CREATE_DONE FIELDS:\n     Create Sequence Number\n\
    \          The sequence number of the CREATE command to which  this  is\n    \
    \      the reply.\n     Created Object Descriptor\n          A descriptor assigned\
    \ by the target to the  created  object.\n          The  contents  of  the  descriptor\
    \  fields  are  arbitrarily\n          assigned by the target at its convenience.\
    \  The host  treats\n          the  descriptor  as  a unitary object, used for\
    \ referring to\n          the created object in subsequent commands.\n     8.3\
    \  DELETE Command\n          The host sends a DELETE command to remove an object\
    \  created\n     by  an  earlier  CREATE  command.   The  object  to be deleted\
    \ is\n     specified  with  a  descriptor.   The  descriptor  is  from   the\n\
    \     CREATE_DONE reply to the original CREATE command.\n                    \
    \   0             0 0   1         1\n                       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5\n                      +---------------+---------------+\n   \
    \                 0 |               10              |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  |    DELETE     |\n                   \
    \   +---------------+---------------+  +-+\n                    2 |    Mode  \
    \     | Mode Argument |   |\n                      +---------------+---------------+\
    \   |\n                    3 |                               |   |  Created\n\
    \                      +--            ID             --+   |  Object\n       \
    \             4 |              Field            |   |  Descriptor\n          \
    \            +---------------+---------------+  +-+\n                        \
    \   DELETE Command Format\n                                 Figure 47\n     DELETE\
    \ FIELDS:\n          Created Object Descriptor\n          Specifies the object\
    \ to be deleted.  This is the  descriptor\n          that  was returned by the\
    \ target in the CREATE_DONE reply to\n          the original CREATE command.\n\
    \     8.4  DELETE_DONE Reply\n          The target sends a DELETE_DONE reply to\
    \ the host in response\n     to  a successful DELETE command.  The reply contains\
    \ the sequence\n     number of the DELETE request.\n                       0 \
    \            0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5\n                      +---------------+---------------+\n         \
    \           0 |               6               |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  | DELETE_DONE   |\n                   \
    \   +---------------+---------------+\n                    2 |     Delete Sequence\
    \ Number    |\n                      +---------------+---------------+\n     \
    \                    DELETE_DONE Reply Format\n                              \
    \   Figure 48\n     DELETE_DONE FIELDS:\n     Request Sequence Number\n      \
    \    The sequence number of the DELETE command to which  this  is\n          the\
    \ reply.\n     8.5  LIST_ADDRESSES Command\n          The host sends a LIST_ADDRESSES\
    \ command to request a list of\n     valid address ranges for a specified object.\
    \  The object is given\n     by a descriptor.  Typical objects are a target  process,\
    \  or  the\n     target   physical   machine.    The   target   responds  with\
    \  an\n     ADDRESS_LIST reply.  This command is used for obtaining the  size\n\
    \     of dynamic address spaces and for determining dump ranges.\n           \
    \            0             0 0   1         1\n                       0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               10              |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \ LIST_ADDRESSES|\n                      +---------------+---------------+  +-+\n\
    \                    2 |    Mode       | Mode Argument |   |\n               \
    \       +---------------+---------------+   |  Object\n                    3 |\
    \                               |   |  Descriptor\n                      +-- \
    \           ID             --+   |\n                    4 |              Field\
    \            |   |\n                      +---------------+---------------+  +-+\n\
    \                       LIST_ADDRESSES Command Format\n                      \
    \           Figure 49\n     LIST_ADDRESSES FIELDS:\n          Object Descriptor\n\
    \          Specifies the object whose address ranges are to be  listed.\n    \
    \      Valid  modes  include  PHYS_MACRO, PHYS_MICRO, PROCESS_CODE,\n        \
    \  and PROCESS_DATA.\n     8.6  ADDRESS_LIST Reply\n          The target sends\
    \  an  ADDRESS_LIST  reply  to  the  host  in\n     response  to  a  successful\
    \  LIST_ADDRESSES  command.   The reply\n     contains the sequence number of\
    \ the LIST_ADDRESSES  request,  the\n     descriptor  of  the  object being listed,\
    \ and a list of the valid\n     address ranges within the  object.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \ ADDRESS_LIST  |\n                      +---------------+---------------+\n \
    \                   2 |      List Sequence Number     |\n                    \
    \  +---------------+---------------+\n                    3 |   Flags     |M|\
    \ Item Count    |\n                      +---------------+---------------+\n \
    \                   4 |                               |\n                    \
    \  +--                           --+\n                    5 |          Descriptor\
    \           |\n                      +--                           --+\n     \
    \               6 |                               |\n                      +---------------+---------------+\
    \  +-+\n                    7 |                               |   |\n        \
    \              +--        First Address      --+   | First\n                 \
    \   8 |                               |   | Address\n                      +-------------------------------+\
    \   | Range\n                    9 |                               |   |\n   \
    \                   +--         Last Address      --+   |\n                  \
    \  10|                               |   |\n                      +-------------------------------+\
    \  +-+\n                                      *\n                            \
    \          *\n                                      *\n                      +---------------+---------------+\
    \  +-+\n                      |                               |   |\n        \
    \              +--        First Address      --+   | Last\n                  \
    \    |                               |   | Address\n                      +-------------------------------+\
    \   | Range\n                      |                               |   |\n   \
    \                   +--         Last Address      --+   |\n                  \
    \    |                               |   |\n                      +-------------------------------+\
    \  +-+\n                         ADDRESS_LIST Reply Format\n                 \
    \                Figure 50\n     ADDRESS_LIST FIELDS:\n     List Sequence Number\n\
    \          The sequence number of the LIST_ADDRESSES command  to  which\n    \
    \      this is the reply.\n     Flags\n          If M=1, the  address  list  is\
    \  continued  in  one  or  more\n          subsequent  ADDRESS_LIST replies. \
    \ If M=0, this is the final\n          ADDRESS_LIST.\n     Item Count\n      \
    \    The number of address ranges described in this command.\n     Descriptor\n\
    \          The descriptor of the object being listed.\n     Address Range\n  \
    \        Each address range is composed of a pair of 32-bit addresses\n      \
    \    which  give  the  first and last addresses of the range.  If\n          there\
    \ are 'holes' in the address space of the  object,  then\n          multiple \
    \ address  ranges will be used to describe the valid\n          address space.\n\
    \     8.7  LIST_BREAKPOINTS Command\n          The host sends a LIST_BREAKPOINTS\
    \ command to request a  list\n     of  all  breakpoints associated with the current\
    \ connection.  The\n     target replies with BREAKPOINT_LIST.\n              \
    \         0             0 0   1         1\n                       0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               4               |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |LIST_BREAKPOINTS\n\
    \                      +---------------+---------------+\n                   \
    \   LIST_BREAKPOINTS Command Format\n                                 Figure 51\n\
    \     8.8  BREAKPOINT_LIST Reply\n          The target sends a BREAKPOINT_LIST\
    \  reply  to  the  host  in\n     response  to  a LIST_BREAKPOINTS command.  The\
    \ reply contains the\n     sequence number of the LIST_BREAKPOINTS request, and\
    \  a  list  of\n     all  breakpoints  associated  with  the  current connection.\
    \  The\n     descriptor and address of each breakpoint are listed.\n         \
    \              0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |        Command Length         |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |BREAKPOINT_LIST|\n\
    \                      +---------------+---------------+\n                   \
    \ 2 |      List Sequence Number     |\n                      +---------------+---------------+\n\
    \                    3 |   Flags     |M| Item Count    |\n                   \
    \   +---------------+---------------+  +-+\n                    4 |    Mode  \
    \     |     0         |   |\n                      +---------------+---------------+\
    \   |\n                    5 |                               |   |  Breakpoint\n\
    \                      +--            ID             --+   |  Descriptor\n   \
    \                 6 |              Field            |   |\n                  \
    \    +---------------+---------------+  +-+\n                    7 |    Mode \
    \      | Mode Argument |   |\n                      +---------------+---------------+\
    \   |\n                    8 |                               |   |\n         \
    \             +--            ID             --+   |  Breakpoint\n            \
    \        9 |              Field            |   |  Address\n                  \
    \    +-------------------------------+   |\n                    10|          \
    \                     |   |\n                      +--            Offset     \
    \    --+   |\n                    11|                               |   |\n  \
    \                    +-------------------------------+  +-+\n                \
    \                      *                   |  Additional\n                   \
    \                   *                   |  Descriptor-Address\n              \
    \                        *                   |  Pairs\n                      \
    \                                   +-+\n                       BREAKPOINT_LIST\
    \ Reply Format\n                                 Figure 52\n     BREAKPOINT_LIST\
    \ FIELDS:\n     List Sequence Number\n          The sequence number of the LIST_BREAKPOINTS\
    \ command to which\n          this is the reply.\n     Flags\n          If M=1,\
    \ the breakpoint list is  continued  in  one  or  more\n          subsequent \
    \ BREAKPOINT_LIST  replies.   If  M=0, this is the\n          final BREAKPOINT_LIST.\n\
    \     Item Count\n          The number of breakpoints described in this list.\n\
    \     Breakpoint Descriptor\n          A descriptor assigned by  the  target \
    \ to  this  breakpoint.\n          Used   by   the   host   to   specify   this\
    \  breakpoint  in\n          BREAKPOINT_DATA and DELETE commands.\n     Breakpoint\
    \ Address\n          The address at which this breakpoint is set.\n     8.9  LIST_PROCESSES\
    \ Command\n          The host sends a LIST_PROCESSES command to request a list\
    \ of\n     descriptors  for all processes on the target.  The target replies\n\
    \     with PROCESS_LIST.\n                       0             0 0   1       \
    \  1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n               \
    \       +---------------+---------------+\n                    0 |           \
    \    4               |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  |LIST_PROCESSES |\n                   \
    \   +---------------+---------------+\n                       LIST_PROCESSES Command\
    \ Format\n                                 Figure 53\n     8.10  PROCESS_LIST\
    \ Reply\n          The target  sends  a  PROCESS_LIST  reply  to  the  host  in\n\
    \     response  to  a  LIST_PROCESSES  command.  The reply contains the\n    \
    \ sequence number of the LIST_PROCESSES request, and a list of  all\n     processes\
    \  in  the  target.  For each process, a descriptor and a\n     target-dependent\
    \ amount of process data are given.\n                       0             0 0\
    \   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n    \
    \                  +---------------+---------------+\n                    0 |\
    \        Command Length         |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  | PROCESS_LIST  |\n                   \
    \   +---------------+---------------+\n                    2 |      List Sequence\
    \ Number     |\n                      +---------------+---------------+\n    \
    \                3 |   Flags     |M| Item Count    |\n                      +---------------+---------------+\
    \  +-+\n                    4 | PROCESS_CODE  |     0         |   |\n        \
    \              +---------------+---------------+   |\n                    5 |\
    \                               |   |  Process\n                      +--    \
    \        ID             --+   |  Descriptor\n                    6 |         \
    \     Field            |   |\n                      +---------------+---------------+\
    \  +-+\n                    7 |       Process data count      |   |\n        \
    \              +---------------+---------------+   |\n                    8 |\
    \  Process data |  Process data |   |\n                      +-------------------------------+\
    \   |  Process\n                                      *                   |  Data\n\
    \                                      *                   |\n               \
    \                       *                   |\n                      +---------------+---------------+\
    \   |\n                    n |  Process data |  Process data |   |\n         \
    \             +-------------------------------+  +-+\n                       \
    \               *                   |  Additional\n                          \
    \            *                   |  Descriptor-Data\n                        \
    \              *                   |  Pairs\n                                \
    \                         +-+\n                         PROCESS_LIST Reply Format\n\
    \                                 Figure 54\n     PROCESS_LIST FIELDS:\n     List\
    \ Sequence Number\n          The sequence number of the LIST_PROCESSES command\
    \  to  which\n          this is the reply.\n     Flags\n          If M=1, the\
    \  process  list  is  continued  in  one  or  more\n          subsequent  PROCESS_LIST\
    \ replies.  If M=0, this is the final\n          PROCESS_LIST.\n     Item Count\n\
    \          The number of processes described in this  list.   For  each\n    \
    \      process  there  is  a  descriptor  and  a variable number of\n        \
    \  octets of process data.\n     Process Descriptor\n          A descriptor assigned\
    \ by the target to this  process.   Used\n          by the host to specify this\
    \ PROCESS in a DELETE command.\n     Process Data Count\n          Number of octets\
    \ of process data for this process.  Must  be\n          even.\n     Process Data\n\
    \          Target-dependent information about this process.  Number  of\n    \
    \      octets is given by the process data count.\n     8.11  LIST_NAMES Command\n\
    \          The host sends a LIST_NAMES command to  request  a  list  of\n    \
    \ available names as strings.  The target replies with NAME_LIST.\n          \
    \             0             0 0   1         1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               4               |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \ LIST_NAMES    |\n                      +---------------+---------------+\n \
    \                        LIST_NAMES Command Format\n                         \
    \        Figure 55\n     8.12  NAME_LIST Reply\n          The target sends a NAME_LIST\
    \ reply to the host  in  response\n     to  a LIST_NAMES command.  The reply contains\
    \ the sequence number\n     of the LIST_NAMES request, and a list of  all  target\
    \  names,  as\n     strings.\n                       0             0 0   1   \
    \      1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n           \
    \           +---------------+---------------+\n                    0 |       \
    \ Command Length         |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  | NAME_LIST     |\n                   \
    \   +---------------+---------------+\n                    2 |      List Sequence\
    \ Number     |\n                      +---------------+---------------+\n    \
    \                3 |   Flags     |M| Item Count    |\n                      +---------------+---------------+\
    \  +-+\n                    4 |           Name Size           |   |\n        \
    \              +---------------+---------------+   |\n                    5 |\
    \  Name Char    |   Name Char   |   |  Name\n                      +---------------+---------------+\
    \   |  String\n                                      *                   |\n \
    \                                     *                   |\n                \
    \                      *                   |\n                      +---------------+---------------+\
    \   |\n                    n | 0 or Name Char|       0       |   |\n         \
    \             +---------------+---------------+  +-+\n                       \
    \               *                   |  Additional\n                          \
    \            *                   |  Name\n                                   \
    \   *                   |  Strings\n                                         \
    \                +-+\n                          NAME_LIST Reply Format\n     \
    \                            Figure 56\n     NAME_LIST FIELDS:\n     List Sequence\
    \ Number\n          The sequence number of the LIST_NAMES command to which  this\n\
    \          is the reply.\n     Flags\n          If M=1, the name list is continued\
    \ in one or more subsequent\n          NAME_LIST replies.  If M=0, this is the\
    \ final NAME_LIST.\n     Item Count\n          The number of name strings in this\
    \ list.  Each  name  string\n          consists  of  a character count and a null-terminated\
    \ string\n          of characters.\n     Name Size\n          The number of octets\
    \ in this name string.  Must be even.\n     Name Characters\n          A string\
    \ of octets composing the name.   Ends  with  a  null\n          octet.   The\
    \  number  of  characters must be even, so if the\n          terminating null\
    \ comes on an  odd  octet,  another  null  is\n          appended.\n     8.13\
    \  GET_PHYS_ADDR Command\n          The host sends a GET_PHYS_ADDR command to\
    \ convert an address\n     into physical form.  The target returns the physical\
    \ address in a\n     GOT_PHYS_ADDR  reply.   For  example,  the  host  could \
    \ send   a\n     GET_PHYS_ADDR  command  containing a register-offset address,\
    \ and\n     the target would return the physical address derived from this in\n\
    \     a GOT_PHYS_ADDR reply.\n                       0             0 0   1   \
    \      1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n           \
    \           +---------------+---------------+\n                    0 |       \
    \        14              |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  | GET_PHYS_ADDR |\n                   \
    \   +---------------+---------------+  +-+\n                    2 |    Mode  \
    \     | Mode Argument |   |\n                      +---------------+---------------+\
    \   |\n                    3 |              ID               |   |\n         \
    \             +--            Field          --+   |\n                    4 | \
    \                              |   |  Address\n                      +---------------+---------------+\
    \   |\n                    5 |                               |   |\n         \
    \             +--            Offset         --+   |\n                    6 | \
    \                              |   |\n                      +---------------+---------------+\
    \  +-+\n                       GET_PHYS_ADDR Command Format\n                \
    \                 Figure 57\n     GET_PHYS_ADDR FIELDS:\n     Address\n      \
    \    The address to be converted to a physical address.  The mode\n          may\
    \    be   one   of   PHYS_REG_OFFSET,   PHYS_REG_INDIRECT,\n          PHYS_MACRO_PTR,\
    \ any OBJECT_* mode, and  any  PROCESS_*  mode\n          except for PROCESS_REG.\n\
    \     8.14  GOT_PHYS_ADDR Reply\n          The target sends  a  GOT_PHYS_ADDR\
    \  reply  to  the  host  in\n     response  to  a  successful  GET_PHYS_ADDR \
    \ command.   The  reply\n     contains the sequence number of the  GET_PHYS_ADDR\
    \  request,  and\n     the specified address converted into a physical address.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               16              |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \ GOT_PHYS_ADDR |\n                      +---------------+---------------+\n \
    \                   2 |      Get  Sequence Number     |\n                    \
    \  +---------------+---------------+  +-+\n                    3 | PHYS_MACRO\
    \    |      0        |   |\n                      +---------------+---------------+\
    \   |\n                    4 |                               |   |\n         \
    \             +--             0             --+   |\n                    5 | \
    \                              |   |  Address\n                      +---------------+---------------+\
    \   |\n                    6 |                               |   |\n         \
    \             +--            Offset         --+   |\n                    7 | \
    \                              |   |\n                      +---------------+---------------+\
    \  +-+\n                        GOT_PHYS_ADDR Reply Format\n                 \
    \                Figure 58\n     GOT_PHYS_ADDR FIELDS:\n     Get Sequence Number\n\
    \          The sequence number of the GET_PHYS_ADDR  command  to  which\n    \
    \      this is the reply.\n     Address\n          The address resulting from\
    \ translating the address given  in\n          the  GET_PHYS_ADDR command into\
    \ a physical address.  Mode is\n          always PHYS_MACRO and ID and mode argument\
    \ are always  zero.\n          Offset gives the 32-bit physical address.\n   \
    \  8.15  GET_OBJECT Command\n          The host sends a GET_OBJECT command to\
    \ convert a name string\n     into  a  descriptor.   The  target  returns  the\
    \  descriptor in a\n     GOT_OBJECT reply.  Intended for use in finding control\
    \  parameter\n     objects.\n                       0             0 0   1    \
    \     1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n            \
    \          +---------------+---------------+\n                    0 |        Command\
    \ Length         |\n                      +---------------+---------------+\n\
    \                    1 |   MANAGEMENT  | GET_OBJECT    |\n                   \
    \   +---------------+---------------+  +-+\n                    2 |          \
    \ Name Size           |   |\n                      +---------------+---------------+\
    \   |\n                    3 |  Name Char    |   Name Char   |   |  Name\n   \
    \                   +---------------+---------------+   |  String\n          \
    \                            *                   |\n                         \
    \             *                   |\n                                      * \
    \                  |\n                      +---------------+---------------+\
    \   |\n                    n | 0 or Name Char|       0       |   |\n         \
    \             +---------------+---------------+  +-+\n                       \
    \  GET_OBJECT Command Format\n                                 Figure 59\n   \
    \  GET_OBJECT FIELDS:\n     Name String\n          The name of an object.\n  \
    \   Name Size\n          The number of octets in this name string.  Must be even.\n\
    \     Name Characters\n          A string of octets composing the name.   Ends\
    \  with  a  null\n          octet.   The  number  of  characters must be even,\
    \ so if the\n          terminating null comes on an  odd  octet,  another  null\
    \  is\n          appended.\n     8.16  GOT_OBJECT Reply\n          The target\
    \ sends a GOT_OBJECT reply to the host in  response\n     to  a  successful  GET_OBJECT\
    \  command.   The  reply contains the\n     sequence number of the  GET_OBJECT\
    \  request,  and  the  specified\n     object name converted into a descriptor.\n\
    \                       0             0 0   1         1\n                    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +---------------+---------------+\n\
    \                    0 |               12              |\n                   \
    \   +---------------+---------------+\n                    1 |   MANAGEMENT  |\
    \ GOT_OBJECT    |\n                      +---------------+---------------+\n \
    \                   2 |      Get  Sequence Number     |\n                    \
    \  +---------------+---------------+  +-+\n                    3 | Mode      \
    \    | Mode Argument |   |\n                      +---------------+---------------+\
    \   |\n                    4 |                               |   |\n         \
    \             +--             ID            --+   |  Object\n                \
    \    5 |                               |   |  Descriptor\n                   \
    \   +---------------+---------------+  +-+\n                          GOT_OBJECT\
    \ Reply Format\n                                 Figure 60\n     GOT_OBJECT FIELDS:\n\
    \     Get Sequence Number\n          The sequence number of the GET_OBJECT command\
    \ to which  this\n          is the reply.\n     Descriptor\n          The  descriptor\
    \  of  the  object  named  in  the  GET_OBJECT\n          command.\n         \
    \                        CHAPTER 9\n                        Breakpoints and Watchpoints\n\
    \          Breakpoints  and   watchpoints   are   used   in   debugging\n    \
    \ applications.   Each  breakpoint or watchpoint is associated with\n     one\
    \ debugger connection and one address.  When  a  breakpoint  or\n     watchpoint\
    \ is triggered, the target executes one or more commands\n     associated with\
    \ it.  A breakpoint is triggered when  its  address\n     is  executed.   A  watchpoint\
    \  is  triggered  when its address is\n     modified.  The same mechanism is used\
    \ for structuring  breakpoint\n     and  watchpoint  commands.  For brevity's\
    \ sake, 'breakpoint' will\n     be used in the remainder of this document to refer\
    \  to  either  a\n     breakpoint or a watchpoint.\n          The commands used\
    \ by the host to manipulate breakpoints  are\n     given in Figure 61, in the\
    \ order in which they are normally used.\n     All commands are sent from the\
    \  host  to  the  target,  and  each\n     specifies the descriptor of a breakpoint.\n\
    \      Command               Description\n     ---------------------+------------------------------------\n\
    \      CREATE                Create a breakpoint\n      BREAKPOINT_DATA      \
    \ Send commands to be executed in an\n                            FSM breakpoint\n\
    \      START                 Activate a breakpoint, set state\n              \
    \              and initialize breakpoint variables\n      STOP               \
    \   Deactivate a breakpoint\n      CONTINUE              Activate a breakpoint\n\
    \      LIST_BREAKPOINTS      List all breakpoints\n      REPORT              \
    \  Report the status of a breakpoint\n      DELETE                Delete a breakpoint\n\
    \                    Commands to Manipulate Breakpoints\n                    \
    \             Figure 61\n          There are two kinds of breakpoints:  default\
    \ breakpoints and\n     finite state machine (FSM) breakpoints.  They differ in\
    \ their use\n     of commands.\n          Default breakpoints  do  not  contain\
    \  any  commands.   When\n     triggered,  a  default  breakpoint stops the target\
    \ object (i.e.,\n     target process or application) it is located in.  A STATUS\
    \ report\n     on  the  stopped  object is sent to the host.  At this point, the\n\
    \     host may send further commands to debug the target.\n          An FSM breakpoint\
    \ has one or more conditional command lists,\n     organized into a finite state\
    \ machine.  When an FSM breakpoint is\n     created, the total number of states\
    \ is specified.  The host  then\n     sends commands (using BREAKPOINT_DATA) to\
    \ be associated with each\n     state.  The target maintains a state variable\
    \ for the breakpoint,\n     which  determines  which  command  list  will  be\
    \ executed if the\n     breakpoint is triggered.  When  the  breakpoint  is  created\
    \  its\n     state  variable is initialized to zero (zero is the first state).\n\
    \     A breakpoint command, SET_STATE, may be used within a  breakpoint\n    \
    \ to  change  the  value  of  the state variable.  A REPORT command\n     applied\
    \ to a breakpoint descriptor returns its  address,  whether\n     it is armed\
    \ or disarmed, and the value of its state variable.\n          Commands valid\
    \ in breakpoints include all  implemented  data\n     transfer and control commands,\
    \ a set of conditional commands, and\n     a set of breakpoint commands.  The\
    \ conditional commands  and  the\n     breakpoint  commands  act on a set of local\
    \ breakpoint variables.\n     The  breakpoint  variables  consist  of  the  state\
    \  variable,  a\n     counter,  and  two  pointer  variables.  The conditional\
    \ commands\n     control the execution of breakpoint command lists  based  on\
    \  the\n     contents  of  one  of  the  breakpoint variables.  The breakpoint\n\
    \     commands are used to set the value of the  breakpoint  variables:\n    \
    \ SET_STATE  sets  the  state  variable,  SET_PTR  sets  one of the\n     pointer\
    \  variables,  and  INC_COUNT  increments  the   breakpoint\n     counter.   There\
    \ may be implementation restrictions on the number\n     of breakpoints, the number\
    \ of states, the number  of  conditions,\n     and  the  size  of  the  command\
    \  lists.  Management commands and\n     protocol commands are forbidden in breakpoints.\n\
    \          In FSM breakpoints, the execution of commands is  controlled\n    \
    \ as  follows.   When  a  breakpoint is triggered, the breakpoint's\n     state\
    \  variable  selects  a  particular  state.   One   or   more\n     conditional\
    \  command  lists  is  associated  with  this state.  A\n     conditional  command\
    \  list  consists  of  a  list  of  conditions\n     followed  by  a  list  of\
    \  commands  which  are  executed  if the\n     condition list is satisfied. \
    \ The debugger starts a breakpoint by\n     executing  the  first  of  these lists.\
    \  If the condition list is\n     satisfied, the debugger executes the associated\
    \ command list  and\n     leaves the breakpoint.  If the condition list fails,\
    \ the debugger\n     skips  to  the  next  conditional  command  list.   This\
    \  process\n     continues  until  the  debugger  either  encounters  a successful\n\
    \     condition list, or exhausts all the conditional command lists for\n    \
    \ the  state.   The  relationship  of commands, lists and states is\n     shown\
    \ in Figure 62 (IFs,  THENs  and  ELSEs  are  used  below  to\n     clarify  the\
    \  logical structure within a state; they are not part\n     of the protocol).\n\
    \                    State 0\n                            IF <condition list 0>\n\
    \                               THEN <command list 0>\n                      \
    \      ELSE IF <condition list 1>\n                               THEN <command\
    \ list 1>\n                            *\n                            *\n    \
    \                        *\n                            ELSE IF <condition list\
    \ n>\n                                THEN <command list n>\n                \
    \            ELSE <exit>\n                      *\n                      *\n \
    \                     *\n                    State n\n                   Breakpoint\
    \ Conditional Command Lists\n                                 Figure 62\n    \
    \ 9.1  BREAKPOINT_DATA Command\n          BREAKPOINT_DATA is a data transfer command\
    \ used by the  host\n     to  send  commands to be executed in breakpoints and\
    \ watchpoints.\n     The command  specifies  the  descriptor  of  the   breakpoint\
    \  or\n     watchpoint, and a stream of commands to be appended to the end of\n\
    \     the  breakpoint's  command  list.   BREAKPOINT_DATA  is   applied\n    \
    \ sequentially  to  successive  breakpoint  states,  and successive\n     command\
    \ lists within each state.  Multiple  BREAKPOINT_DATAs  may\n     be  sent  for\
    \ a given breakpoint.  Breaks between BREAKPOINT_DATA\n     commands may occur\
    \ anywhere within the data stream,  even  within\n     individual  commands  in\
    \ the data.  Sufficient space to store the\n     data must have been allocated\
    \ by the maximum size  field  in  the\n     CREATE BREAKPOINT/WATCHPOINT command.\n\
    \                  0             0 0   1         1\n                  0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                 +---------------+---------------+\n\
    \               0 |        Command Length         |\n                 +---------------+---------------+\n\
    \               1 | DATA_TRANSFER |BREAKPOINT_DATA|\n                 +---------------+---------------+\
    \  +-+\n               2 |    Mode       | Mode Argument |   |\n             \
    \    +---------------+---------------+   |  Breakpoint or\n               3 |\
    \                               |   |  Watchpoint\n                 +--      \
    \      ID             --+   |  Descriptor\n               4 |              Field\
    \            |   |\n                 +-------------------------------+  +-+\n\
    \               5 |     Data      |  Data         |   |\n                 +-------------------------------+\
    \   |\n                                 *                   |\n              \
    \                   *                   |  Data\n                            \
    \     *                   |\n                 +---------------+---------------+\
    \   |\n               n |     Data      |  Data or 0    |   |\n              \
    \   +---------------+---------------+  +-+\n                      BREAKPOINT_DATA\
    \ Command Format\n                                 Figure 63\n     BREAKPOINT_DATA\
    \ FIELDS:\n     Command Length\n          Total length of this  command  in  octets,\
    \  including  data,\n          excluding the final padding octet, if any.\n  \
    \   Data\n          A stream of data  to  be  appended  to  the  data  for  this\n\
    \          breakpoint  or  watchpoint.  This stream has the form of one\n    \
    \      or more states, each  containing  one  or  more  conditional\n        \
    \  command lists.  The first BREAKPOINT_DATA command sent for a\n          breakpoint\
    \ contains data starting with state zero.  The data\n          for  each  state\
    \  starts with the state size.  A conditional\n          command list is composed\
    \ of two parts: a condition list, and\n          a command list.  Each list begins\
    \ with a word that gives its\n          size in octets.\n          <state 0 size>\n\
    \                   <condition list 0 size> <condition list 0>\n             \
    \      <command list 0 size>   <command list 0>\n                            \
    \  *\n                              *\n                              *\n     \
    \              <condition list n size> <condition list n>\n                  \
    \ <command list n size>   <command list n>\n          <state 1 size>\n       \
    \                     <etc>\n               *\n               *\n            \
    \   *\n          <state n size>\n                       Breakpoint Data Stream\
    \ Format\n                                 Figure 64\n     Sizes\n          All\
    \ sizes are stored in 16-bit words, and include their  own\n          length.\
    \   The state size gives the total number of octets of\n          breakpoint data\
    \ for the  state.   The  condition  list  size\n          gives  the total octets\
    \ of breakpoint data for the following\n          condition list.  A condition\
    \ list size  of  2  indicates  an\n          empty  condition  list:  in  this\
    \ case the following command\n          list is executed unconditionally.   The\
    \  command  list  size\n          gives  the total octets of breakpoint data for\
    \ the following\n          command list.\n     Lists\n          Condition  and\
    \  command  lists  come  in  pairs.   When  the\n          breakpoint  occurs,\
    \  the condition list controls whether the\n          following command list should\
    \ be executed.  A condition list\n          consists  of one or more commands\
    \ from the CONDITION command\n          class.  A command list consists one or\
    \  more  LDP  commands.\n          Valid   commands  are  any  commands  from\
    \  the  BREAKPOINT,\n          DATA_TRANSFER or CONTROL command classes.\n   \
    \                             CHAPTER 10\n                           Conditional\
    \ Commands\n          Conditional commands are used in breakpoints to control\
    \  the\n     execution  of  breakpoint  commands.   One  or more conditions in\n\
    \     sequence form a condition list.  If a condition list is satisfied\n    \
    \ (evaluates  to  TRUE),  the  breakpoint  command list immediately\n     following\
    \ it is  executed.   (See  Breakpoints  and  Watchpoints,\n     above,  for a\
    \ discussion of the logic flow in conditional/command\n     lists.) Conditional\
    \ commands perform tests  on  local  breakpoint\n     variables,  and  other \
    \ locations.   Each  condition evaluates to\n     either  TRUE  or  FALSE.   Figure\
    \  65  contains  a   summary   of\n     conditional commands:\n      Command \
    \                      Description\n     -----------------------------+------------------------------------\n\
    \     CHANGED <loc>                  Determine if a location has changed\n   \
    \  COMPARE <loc1> <mask> <loc2>   Compare two locations, using a mask\n     COUNT_[EQ\
    \ | GT | LT] <value>   Compare the counter to a value\n     TEST  <loc> <mask>\
    \ <value>     Compare a location to a value\n                        Conditional\
    \ Command Summary\n                                 Figure 65\n     The rules\
    \ for forming and evaluating condition lists are:\n     o   consecutive conditions\
    \ have an implicit logical  AND  between\n         them.  A sequence of such conditions\
    \ is called an 'and_list'.\n         and_lists are delimited by an OR command\
    \ and by  the  end  of\n         the condition list.\n     o   the breakpoint\
    \ OR command may be inserted between any pair of\n         conditions\n     o\
    \   AND takes precedence over OR\n     o   nested condition lists are not supported.\
    \  A  condition  list\n         is simply one or more and_lists, separated by\
    \ ORs.\n     o   the condition list is evaluated in sequence  until  either  a\n\
    \         TRUE  and_list  is found (condition list <- TRUE), or the end\n    \
    \     of the condition list is reached (condition list  <-  FALSE).\n        \
    \ An and_list is TRUE if all its conditions are TRUE.\n     The distillation of\
    \ these rules into BNF is:\n         <condition_list> :== <and_list>  [OR <and_list>]*\n\
    \         <and_list>       :== <condition> [AND <condition>]*\n         <condition>\
    \      :== CHANGED | COMPARE | COUNT | TEST\n         where:  OR  is a breakpoint\
    \ command\n                 AND is implicit for any pair of consecutive conditions\n\
    \     For example, the following condition list, with one  command  per\n    \
    \ line,\n         COUNT_EQ 1\n         OR\n         COUNT_GT 10\n         COUNT_LT\
    \ 20\n     evaluates to:\n         (COUNT = 1) OR (COUNT > 10  AND COUNT < 20)\n\
    \     and will cause the command list that follows it to be executed if\n    \
    \ the counter is equal to one, or is between 10 and 20.\n     10.1  Condition\
    \ Command Format\n          Condition  commands  start  with  the  standard  \
    \ four-octet\n     command  header.   The high-order bit of the command type byte\
    \ is\n     used as a negate flag:  if this bit is set, the boolean value  of\n\
    \     the  condition  is  negated.   This flag applies to one condition\n    \
    \ only, and not to other conditions in the condition list.\n                 \
    \ 0             0 0   1         1\n                  0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5\n                 +---------------+---------------+\n               0\
    \ |        Command Length         |\n                 +---------------+---------------+\n\
    \               1 | CONDITION     |N|    Type     |\n                 +---------------+---------------+\n\
    \                         Condition Command Header\n                         \
    \        Figure 66\n     10.2  COUNT Conditions\n          The COUNT conditions\
    \ (COUNT_EQ, COUNT_GT and  COUNT_LT)  are\n     used to compare the breakpoint\
    \ counter to a specified value.  The\n     counter is set to zero when the breakpoint\
    \  is  STARTed,  and  is\n     incremented  by  the INC_COUNT breakpoint command.\
    \  The format is\n     the same for the COUNT_EQ, COUNT_GT and COUNT_LT conditions.\n\
    \                  0             0 0   1         1\n                  0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                 +---------------+---------------+\n\
    \               0 |               8               |\n                 +---------------+---------------+\n\
    \               1 | CONDITION     |N|  Type       |\n                 +---------------+---------------+\n\
    \               2 |                               |\n                 +--    \
    \      Value            --+\n               3 |                              \
    \ |\n                 +---------------+---------------+\n                    \
    \      COUNT Condition Format\n                                 Figure 67\n  \
    \   COUNT_* Condition FIELDS:\n     Type\n          One of COUNT_EQ, COUNT_LT\
    \ and COUNT_GT.   The  condition  is\n          TRUE  if  the  breakpoint  counter\
    \  is  [EQ  |  LT | GT] the\n          specified value.\n     Value\n        \
    \  A 32-bit value to be compared to the counter.\n     10.3  CHANGED Condition\n\
    \          The CHANGED  condition  is  TRUE  if  the  contents  of  the\n    \
    \ specified   location  have  changed  since  the  last  time  this\n     breakpoint\
    \ occurred.  Only one location may be specified  as  the\n     object   of  CHANGED\
    \  conditions  per  breakpoint.   The  CHANGED\n     condition is always FALSE\
    \ the first time the breakpoint occurs.\n                  0             0 0 \
    \  1         1\n                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n          \
    \       +---------------+---------------+\n               0 |              14\
    \               |\n                 +---------------+---------------+\n      \
    \         1 | CONDITION     |N|  CHANGED    |\n                 +---------------+---------------+\n\
    \               2 |                               |\n                 +--    \
    \                       --+\n               3 |            Address           \
    \ |\n                 +--                           --+\n               4 |  \
    \                             |\n                 +--                        \
    \   --+\n               5 |                               |\n                \
    \ +--                           --+\n               6 |                      \
    \         |\n                 +---------------+---------------+\n            \
    \                 CHANGED Condition\n                                 Figure 68\n\
    \     CHANGED FIELDS:\n     Address\n          The full 5-word address of the\
    \ location to be tested by  the\n          CHANGED command.\n     10.4  COMPARE\
    \ Condition\n          The COMPARE condition compares two locations using  a \
    \ mask.\n     The condition is TRUE if (<loc1> & <mask>) = (<loc2> & <mask>).\n\
    \                  0             0 0   1         1\n                  0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                 +---------------+---------------+\n\
    \               0 |              28               |\n                 +---------------+---------------+\n\
    \               1 | CONDITION     |N|  COMPARE    |\n                 +---------------+---------------+\n\
    \               2 |                               |\n                 +--    \
    \                       --+\n               3 |            Address 1         \
    \ |\n                 +--                           --+\n               4 |  \
    \                             |\n                 +--                        \
    \   --+\n               5 |                               |\n                \
    \ +--                           --+\n               6 |                      \
    \         |\n                 +---------------+---------------+\n            \
    \   7 |                               |\n                 +--          Mask  \
    \           --+\n               8 |                               |\n        \
    \         +-------------------------------+\n               9 |              \
    \                 |\n                 +--                           --+\n    \
    \           10|            Address 2          |\n                 +--        \
    \                   --+\n               11|                               |\n\
    \                 +--                           --+\n               12|      \
    \                         |\n                 +--                           --+\n\
    \               13|                               |\n                 +-------------------------------+\n\
    \                             COMPARE Condition\n                            \
    \     Figure 69\n     COMPARE FIELDS:\n     Address 1\n     Address 2\n      \
    \    The 5-word addresses of the locations to be compared.\n     Mask\n      \
    \    A 32-bit mask specifying which bits in the locations  should\n          be\
    \ compared.\n     10.5  TEST Condition\n          The TEST condition is used to\
    \ compare a location to a value,\n     using  a  mask.   The  condition  is  TRUE\
    \  if (<loc> & <mask>) =\n     <value>.\n                  0             0 0 \
    \  1         1\n                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n          \
    \       +---------------+---------------+\n               0 |              22\
    \               |\n                 +---------------+---------------+\n      \
    \         1 | CONDITION     |N|  TEST       |\n                 +---------------+---------------+\n\
    \               2 |                               |\n                 +--    \
    \                       --+\n               3 |            Address           \
    \ |\n                 +--                           --+\n               4 |  \
    \                             |\n                 +--                        \
    \   --+\n               5 |                               |\n                \
    \ +--                           --+\n               6 |                      \
    \         |\n                 +---------------+---------------+\n            \
    \   7 |                               |\n                 +--          Mask  \
    \           --+\n               8 |                               |\n        \
    \         +-------------------------------+\n               9 |              \
    \                 |\n                 +--          Value            --+\n    \
    \           10|                               |\n                 +-------------------------------+\n\
    \                              TEST Condition\n                              \
    \   Figure 70\n     TEST FIELDS:\n     Address\n          The 5-word address of\
    \ the location to  be  compared  to  the\n          value.\n     Mask\n      \
    \    A 32-bit mask specifying which bits in the  location  should\n          be\
    \ compared.\n     Value\n          A 32-bit value to compare to the masked location.\n\
    \                                CHAPTER 11\n                            Breakpoint\
    \ Commands\n          Breakpoint commands are used to set the value of  breakpoint\n\
    \     variables.   These commands are only valid within breakpoints and\n    \
    \ watchpoints.  They are sent from the host to the target  as  data\n     in \
    \ BREAKPOINT_DATA  commands.   Figure  71 contains a summary of\n     breakpoint\
    \ commands:\n      Command                  Description\n     ------------------------+-------------------------------------\n\
    \     INCREMENT <location>      Increment the specified location\n     INC_COUNT\
    \                 Increment the breakpoint counter\n     OR                  \
    \      OR two breakpoint condition lists\n     SET_PTR <n> <location>    Set pointer\
    \ <n> to the contents of\n                               <location>\n     SET_STATE\
    \ <n>             Set the breakpoint state variable\n                        \
    \       to <n>\n                        Breakpoint Command Summary\n         \
    \                        Figure 71\n     11.1  INCREMENT Command\n          The\
    \ INCREMENT command increments the contents of a specified\n     location.  The\
    \ location may be in any address space writable from\n     LDP.\n            \
    \      0             0 0   1         1\n                  0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5\n                 +---------------+---------------+\n          \
    \     0 |               14              |\n                 +---------------+---------------+\n\
    \               1 | BREAKPOINT    |  INCREMENT    |\n                 +---------------+---------------+\n\
    \               2 |                               |\n                 +--    \
    \                       --+\n               3 |            Address           \
    \ |\n                 +--                           --+\n               4 |  \
    \                             |\n                 +--                        \
    \   --+\n               5 |                               |\n                \
    \ +--                           --+\n               6 |                      \
    \         |\n                 +---------------+---------------+\n            \
    \             INCREMENT Command Format\n                                 Figure\
    \ 72\n     INCREMENT FIELDS:\n     Address\n          The full address of the\
    \ location whose contents  are  to  be\n          incremented.\n     11.2  INC_COUNT\
    \ Command\n          The INC_COUNT command  increments  the  breakpoint  counter.\n\
    \     There  is  one  counter  variable  for  each   breakpoint.  It is\n    \
    \ initialized to zero when the breakpoint is created,  when  it  is\n     armed\
    \  with  the START command, and whenever the breakpoint state\n     changes. \
    \ The counter is tested by the COUNT_* conditions.\n                  0      \
    \       0 0   1         1\n                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\
    \                 +---------------+---------------+\n               0 |      \
    \         4               |\n                 +---------------+---------------+\n\
    \               1 | BREAKPOINT    |  INC_COUNT    |\n                 +---------------+---------------+\n\
    \                         INC_COUNT Command Format\n                         \
    \        Figure 73\n     11.3  OR Command\n          The OR command delineates\
    \  two  and_lists  in  a  breakpoint\n     condition  list.   A  condition  list\
    \  is  TRUE  if any of the OR\n     separated and_lists in it are TRUE.  A breakpoint\
    \ condition  list\n     may  contain  zero,  one  or,  many  OR commands.  See\
    \ 'Condition\n     Commands' for an explanation of condition lists.\n        \
    \          0             0 0   1         1\n                  0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5\n                 +---------------+---------------+\n      \
    \         0 |               4               |\n                 +---------------+---------------+\n\
    \               1 | BREAKPOINT    |      OR       |\n                 +---------------+---------------+\n\
    \                             OR Command Format\n                            \
    \     Figure 74\n     11.4  SET_PTR Command\n          The SET_PTR command loads\
    \ the specified  breakpoint  pointer\n     with  the  contents of a location.\
    \  The pointer variables and the\n     SET_PTR command are intended to provide\
    \ a primitive but unlimited\n     indirect    addressing   capability.    Two\
    \   addressing   modes,\n     BPT_PTR_OFFSET and BPT_PTR_INDIRECT, are used for\
    \ referencing the\n     breakpoint  pointers.   For example, to follow a linked\
    \ list, use\n     SET_PTR to load a pointer with the start of the  list,  then\
    \  use\n     successive  SET_PTR  commands with addressing mode BPT_PTR_OFFSET\n\
    \     to get successive elements.\n                  0             0 0   1   \
    \      1\n                  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                \
    \ +---------------+---------------+\n               0 |               16     \
    \         |\n                 +---------------+---------------+\n            \
    \   1 | BREAKPOINT    |  SET_PTR      |\n                 +---------------+---------------+\n\
    \               2 |            Pointer            |\n                 +---------------+---------------+\n\
    \               3 |                               |\n                 +--    \
    \                       --+\n               4 |            Address           \
    \ |\n                 +--                           --+\n               5 |  \
    \                             |\n                 +--                        \
    \   --+\n               6 |                               |\n                \
    \ +--                           --+\n               7 |                      \
    \         |\n                 +---------------+---------------+\n            \
    \              SET_PTR Command Format\n                                 Figure\
    \ 75\n     SET_PTR FIELDS:\n     Pointer\n          The pointer to be changed.\
    \  Allowable values are 0 and 1.\n     Address\n          The full address of\
    \ the location whose contents  are  to  be\n          loaded into the given pointer\
    \ variable.\n     11.5  SET_STATE Command\n          The SET_STATE command sets\
    \ the breakpoint state variable  to\n     the  specified  value.   This  is  the\
    \  only method of changing a\n     breakpoint's state from within  a  breakpoint.\
    \  The  breakpoint's\n     state  may  be  also be changed by a START command\
    \ from the host.\n     The state variable is initialized to zero when the breakpoint\
    \  is\n     created.\n                  0             0 0   1         1\n    \
    \              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                 +---------------+---------------+\n\
    \               0 |               6               |\n                 +---------------+---------------+\n\
    \               1 | BREAKPOINT    |  SET_STATE    |\n                 +---------------+---------------+\n\
    \               2 |         State Value           |\n                 +-------------------------------+\n\
    \                         SET_STATE Command Format\n                         \
    \        Figure 76\n     SET_STATE FIELDS:\n     State Value\n          The new\
    \ value for the breakpoint state variable.   Must  not\n          be  greater\
    \  than  the  maximum state value specified in the\n          CREATE BREAKPOINT\
    \ command that created this breakpoint.\n                                APPENDIX\
    \ A\n                            Diagram Conventions\n          Command and message\
    \ diagrams are used in  this  document  to\n     illustrate  the  format  of these\
    \ entities.   Words are listed in\n     order of transmission down the page. \
    \  The  first  word  is  word\n     zero.   Bits within a word run left to right,\
    \ most significant to\n     least.   However,   following  a  convention  observed\
    \  in  other\n     protocol  documents,  bits are numbered in order of transmission;\n\
    \     the most significant bit in a word is transmitted first.  The bit\n    \
    \ labelled '0' is the most significant bit.\n                       0        \
    \     0 0   1         1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5\n                      +---------------+---------------+\n               \
    \     0 |M|                           |L|\n                      +---------------+---------------+\n\
    \                    1 | Most Sig Octet| Least S. Octet|\n                   \
    \   +---------------+---------------+\n                      M = most significant\
    \ bit in word zero,\n                          transmitted first\n           \
    \           L = least significant bit in word zero,\n                        \
    \  transmitted last\n                              Sample Diagram\n          \
    \                       Figure 77\n                                APPENDIX B\n\
    \                              Command Summary\n          The following table\
    \ lists all non-breakpoint LDP commands in\n     alphabetical order, with a brief\
    \ description of each.\n                            Sender\n     Command     \
    \       | Host Target | Function\n     -------------------+-------------+---------------------------\n\
    \     ABORT                 X            Abort outstanding commands\n     ABORT_DONE\
    \                  X      Acknowledge ABORT\n     ADDRESS_LIST               \
    \ X      Return valid address ranges\n     BREAKPOINT_DATA       X           \
    \ Send breakpoint commands\n     BREAKPOINT_LIST             X      Return list\
    \ of breakpoints\n     CONTINUE              X            Resume execution\n \
    \    CREATE                X            Create target object\n     CREATE_DONE\
    \                 X      Acknowledge CREATE\n     DELETE                X    \
    \        Delete target object\n     DELETE_DONE                 X      Acknowledge\
    \ DELETE\n     EXCEPTION                   X      Report target exception\n  \
    \   ERROR                       X      Report error with a host command\n    \
    \ ERRACK                X            Acknowledge ERROR\n     GET_OBJECT      \
    \      X            Get object descriptor from name\n     GET_PHYS_ADDRESS   \
    \   X            Get address in physical form\n     GOT_OBJECT               \
    \   X      Return object descriptor\n     GOT_PHYS_ADDRESS            X      Return\
    \ physical address\n     HELLO                 X            Initiate LDP session\n\
    \     HELLO_REPLY                 X      Return LDP parameters\n     LIST_ADDRESSES\
    \        X            Request valid address ranges\n     LIST_BREAKPOINTS    \
    \  X            Request breakpoint list\n     LIST_NAMES            X        \
    \    Request name list\n     LIST_PROCESSES        X            Request process\
    \ list\n     MOVE                  X            Read data from target\n     MOVE_DONE\
    \                   X      Acknowledge MOVE completion\n     MOVE_DATA       \
    \            X      Send data request by MOVE\n     NAME_LIST                \
    \   X      Return name list\n     PROCESS_LIST                X      Return process\
    \ list\n     READ                  X            Read data from target\n     READ_DATA\
    \                   X      Return data requested by READ\n     READ_DONE     \
    \              X      Acknowledge READ completion\n     REPEAT_DATA          \
    \ X            Write copies of data\n     REPORT                X            Request\
    \ status of object\n     START                 X            Start target object\n\
    \     STATUS                      X      Return status of object\n     STEP  \
    \                X            Step execution of target object\n     STOP     \
    \             X            Stop target object\n     SYNCH                 X  \
    \          Check sequence number\n     SYNCH_REPLY                 X      Confirm\
    \ sequence number\n     WRITE                 X            Write data\n     WRITE_MASK\
    \            X            Write data with mask\n                             \
    \ Command Summary\n                                 Figure 78\n              \
    \                  APPENDIX C\n                      Commands, Responses and Replies\n\
    \          The following table shows the relationship between commands,\n    \
    \ responses  and  replies.   Commands are sent from the host to the\n     target.\
    \  Some commands elicit responses and/or replies  from  the\n     target.   Responses\
    \  and  replies are sent from the target to the\n     host.  The distinction between\
    \ them is that the target sends only\n     one  reply  to  a  command,  but  may\
    \  send  multiple  responses.\n     Responses always contain data, whereas replies\
    \ may or may not.\n          Command            | Response     | Reply\n     \
    \     -------------------+--------------+------------------\n          ABORT \
    \                              ABORT_DONE\n          BREAKPOINT_DATA\n       \
    \   CONTINUE\n          CREATE                              CREATE_DONE\n    \
    \      DELETE                              DELETE_DONE\n          GET_OBJECT \
    \                         GOT_OBJECT\n          GET_PHYS_ADDRESS             \
    \       GOT_PHYS_ADDRESS\n          HELLO                               HELLO_REPLY\n\
    \          LIST_ADDRESSES                      ADDRESS_LIST\n          LIST_BREAKPOINTS\
    \                    BREAKPOINT_LIST\n          LIST_NAMES                   \
    \       NAME_LIST\n          LIST_PROCESSES                      PROCESS_LIST\n\
    \          MOVE               MOVE_DATA        MOVE_DONE\n          READ     \
    \          READ_DATA        READ_DONE\n          REPEAT_DATA\n          REPORT\
    \                              STATUS\n          START\n          STEP\n     \
    \     STOP\n          SYNCH                               SYNCH_REPLY\n      \
    \    WRITE\n          WRITE_MASK\n                      Commands, Responses and\
    \ Replies\n                                 Figure 79\n                      \
    \          APPENDIX D\n                                 Glossary\n     FSM\n \
    \         Finite  state  machine.   Commands  of  each  breakpoint  or\n     \
    \     watchpoint   are  implemented  as  part  of  a  finite state\n         \
    \ machine.  A list of breakpoint commands is  associated  with\n          each\
    \ state.  There are several breakpoint commands to change\n          from one\
    \ state to another.\n     host\n          The 'host' in an LDP session is the\
    \  timesharing  system  on\n          which the user process runs.\n     long\n\
    \          A long is a 32-bit quantity.\n     octet\n          An octet is an\
    \ eight-bit quantity.\n     RDP\n          The  Reliable  Data  Protocol  (RDP)\
    \ is  a  transport  layer\n          protocol designed as a low-overhead alternative\
    \ to TCP.  RDP\n          is a connection oriented protocol  that  provides  reliable,\n\
    \          sequenced message delivery.\n     server process\n          The LDP\
    \ server process is the passive participant in an  LDP\n          session.   The\
    \  server  process  usually resides on a target\n          machine such as a PAD,\
    \ PSN or gateway.  The  server  process\n          waits for a user process to\
    \ initiate a session, and responds\n          to commands from the user  process.\
    \   In  response  to  user\n          commands, the server may perform services\
    \ on the target like\n          reading and writing memory locations or setting\
    \ breakpoints.\n          'Server'  is  sometimes  employed as a shorthand for\
    \ 'server\n          process'.\n     target\n          The 'target' in an LDP\
    \ session is the PSN,  PAD  or  gateway\n          that  is  being  loaded,  dumped\
    \  or  debugged  by the host.\n          Normally, LDP will be implemented in\
    \ the target as a  server\n          process.     However,   in   some   targets\
    \   with   strange\n          requirements, notably the Butterfly, the target\
    \ LDP may be a\n          user process.\n     user process\n          The LDP\
    \ user process is the active  participant  in  an  LDP\n          session.   The\
    \  user  process  initiates  and terminates the\n          session and sends commands\
    \  to  the  server  process   which\n          control  the session.  The user\
    \ process usually resides on a\n          timesharing host and is  driven  by\
    \  a  higher-level  entity\n          (e.g., an application program like an interactive\
    \ debugger).\n          'User' is  sometimes  employed  as  a  shorthand  for\
    \  'user\n          process'.\n     word\n          A word is a sixteen-bit quantity.\n\
    \                                   INDEX\n     ABORT command............................................\
    \ 35\n     ABORT_DONE reply......................................... 36\n    \
    \ address.............................................. 60, 66\n     address descriptor.......................................\
    \ 20\n     address format................................... 19, 25, 31\n    \
    \ address ID............................................... 22\n     address mode.........................................\
    \ 20, 22\n     address mode argument.................................... 21\n\
    \     address offset........................................... 20\n     addressing...............................................\
    \ 19\n     ADDRESS_LIST reply................................... 76, 77\n    \
    \ BASIC_DEBUGGER....................................... 12, 32\n     breakpoint...\
    \ 9, 13, 57, 60, 71, 79, 92, 93, 95, 96, 99, 107\n     breakpoint commands..........................\
    \ 9, 94, 95, 107\n     breakpoint counter........................ 94, 100, 101,\
    \ 110\n     breakpoint data...................................... 97, 99\n   \
    \  breakpoint state variable........................... 94, 107\n     breakpoint\
    \ variables..................................... 94\n     BREAKPOINT_DATA command.....................\
    \ 73, 94, 95, 107\n     BREAKPOINT_LIST reply................................\
    \ 79, 80\n     CHANGED condition....................................... 102\n\
    \     command class............................................ 16\n     command\
    \ length field..................................... 16\n     COMPARE Condition.......................................\
    \ 103\n     condition command header................................ 101\n   \
    \  conditional commands................................. 94, 99\n     CONTINUE\
    \ command......................................... 62\n     control commands......................................\
    \ 9, 57\n     COUNT condition.................................... 110, 111\n \
    \    COUNT_EQ condition...................................... 101\n     COUNT_GT\
    \ condition...................................... 101\n     COUNT_LT condition......................................\
    \ 101\n     CREATE command............................... 69, 70, 73, 75\n   \
    \  create types............................................. 70\n     CREATE_DONE\
    \ reply.................................... 73, 75\n     data octets......................................\
    \ 43, 47, 52\n     data packing............................................. 10\n\
    \     data transfer commands................................ 9, 41\n     data\
    \ transmission........................................ 10\n     datagrams.................................................\
    \ 5\n     debugging.............................................. 1, 3\n     default\
    \ breakpoint................................... 71, 92\n     DELETE command.......................................\
    \ 73, 75\n     DELETE_DONE reply........................................ 75\n\
    \     descriptor........... 20, 57, 61, 62, 63, 64, 65, 73, 75, 93\n     dumping...................................................\
    \ 3\n     ERRACK............................................... 10, 39\n     ERROR\
    \ codes.............................................. 38\n     ERROR reply..........................................\
    \ 37, 67\n     EXCEPTION trap........................................... 66\n\
    \     finite state machine................................. 60, 93\n     FSM breakpoint...................................\
    \ 71, 92, 94\n     FULL-DEBUGGER............................................ 12\n\
    \     FULL_DEBUGGER............................................ 32\n     gateway................................................\
    \ 3, 9\n     GET_OBJECT command................................... 89, 91\n  \
    \   GET_PHYS_ADDR command................................ 87, 88\n     GOT_OBJECT\
    \ reply..................................... 89, 91\n     GOT_PHYS_ADDR reply..................................\
    \ 87, 88\n     HELLO command......................................... 9, 29\n\
    \     HELLO_REPLY....................................... 9, 19, 30\n     host\
    \ descriptor.......................................... 41\n     implementation.......................................\
    \ 12, 31\n     INC_COUNT command......................... 94, 107, 110, 111\n\
    \     INCREMENT command....................................... 109\n     internet..................................................\
    \ 5\n     internet protocols........................................ 4\n     IP........................................................\
    \ 5\n     LDP command formats...................................... 15\n     LDP\
    \ header........................................... 15, 16\n     LDP Version..............................................\
    \ 30\n     LIST commands............................................ 73\n    \
    \ LIST_ADDRESSES command............................... 76, 77\n     LIST_BREAKPOINTS\
    \ command............................. 79, 80\n     LIST_NAMES command...................................\
    \ 84, 85\n     LIST_PROCESSES command................................... 82\n\
    \     LOADER_DUMPER........................................ 12, 32\n     loading................................................\
    \ 1, 3\n     long address format...................................... 20\n  \
    \   management commands...................................... 67\n     memory\
    \ object............................................ 73\n     MOVE command.................................\
    \ 22, 41, 47, 49\n     MOVE sequence number.....................................\
    \ 52\n     MOVE_DATA response................................... 22, 51\n    \
    \ MOVE_DONE reply.......................................... 52\n     NAME_LIST\
    \ reply...................................... 84, 85\n     offset...............................................\
    \ 20, 22\n     OR command.............................................. 111\n\
    \     PAD.................................................... 3, 9\n     pattern..................................................\
    \ 54\n     PHYS_ADDRESS............................................. 57\n    \
    \ PHYS_MACRO............................................... 60\n     PROCESS..................................................\
    \ 57\n     PROCESS_CODE............................................. 60\n    \
    \ PROCESS_LIST reply....................................... 82\n     protocol\
    \ commands......................................... 9\n     PSN....................................................\
    \ 3, 9\n     RDP................................................... 5, 15\n  \
    \   READ command..................................... 41, 43, 44\n     READ sequence\
    \ number..................................... 47\n     READ_DATA response...................................\
    \ 45, 46\n     READ_DONE reply.......................................... 47\n\
    \     repeat count............................................. 54\n     REPEAT_DATA\
    \ command.................................. 41, 53\n     REPORT command...................................\
    \ 63, 64, 94\n     sequence number...................................... 10, 39\n\
    \     session................................................... 9\n     SET_PTR\
    \ command................................ 94, 111, 112\n     SET_STATE command..............................\
    \ 94, 107, 113\n     short address format.....................................\
    \ 25\n     START command........................................ 59, 60\n    \
    \ STATUS reply..................................... 64, 65, 94\n     STEP command.........................................\
    \ 62, 63\n     STOP command......................................... 60, 61\n\
    \     SYNCH.................................................... 10\n     SYNCH\
    \ command............................................ 33\n     SYNCH_REPLY..............................................\
    \ 34\n     system type.............................................. 30\n    \
    \ target start address......................... 43, 44, 46, 54\n     transport.................................................\
    \ 9\n     watchpoint.......... 13, 57, 60, 71, 92, 93, 95, 96, 99, 107\n     WRITE\
    \ command........................................ 41, 42\n     WRITE_MASK command.......................................\
    \ 56\n"
