- title: __initial_text__
  contents:
  - '                  The text/enriched MIME Content-type

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   MIME [RFC-1521] defines a format and general framework for the\n\
    \   representation of a wide variety of data types in Internet mail. This\n  \
    \ document defines one particular type of MIME data, the text/enriched\n   MIME\
    \ type. The text/enriched MIME type is intended to facilitate the\n   wider interoperation\
    \ of simple enriched text across a wide variety of\n   hardware and software platforms.\
    \ This document is only a minor\n   revision to the text/enriched MIME type that\
    \ was first described in\n   [RFC-1523] and [RFC-1563], and is only intended to\
    \ be used in the\n   short term until other MIME types for text formatting in\
    \ Internet\n   mail are developed and deployed.\n"
- title: The text/enriched MIME type
  contents:
  - "The text/enriched MIME type\n   In order to promote the wider interoperability\
    \ of simple formatted\n   text, this document defines an extremely simple subtype\
    \ of the MIME\n   content-type \"text\", the \"text/enriched\" subtype. The content-type\n\
    \   line for this type may have one optional parameter, the \"charset\"\n   parameter,\
    \ with the same values permitted for the \"text/plain\" MIME\n   content-type.\n\
    \   The text/enriched subtype was designed to meet the following\n   criteria:\n\
    \   1. The syntax must be extremely simple to parse, so that even\n      teletype-oriented\
    \ mail systems can easily strip away the\n      formatting information and leave\
    \ only the readable text.\n   2. The syntax must be extensible to allow for new\
    \ formatting\n      commands that are deemed essential for some application.\n\
    \   3. If the character set in use is ASCII or an 8-bit ASCII superset,\n    \
    \  then the raw form of the data must be readable enough to be\n      largely\
    \ unobjectionable in the event that it is displayed on the\n      screen of the\
    \ user of a non-MIME-conformant mail reader.\n   4. The capabilities must be extremely\
    \ limited, to ensure that it can\n      represent no more than is likely to be\
    \ representable by the\n      user's primary word processor. While this limits\
    \ what can be\n      sent, it increases the likelihood that what is sent can be\n\
    \      properly displayed.\n   There are other text formatting standards which\
    \ meet some of these\n   criteria. In particular, HTML and SGML have come into\
    \ widespread use\n   on the Internet. However, there are two important reasons\
    \ that this\n   document further promotes the use of text/enriched in Internet\
    \ mail\n   over other such standards:\n   1. Most MIME-aware Internet mail applications\
    \ are already able to\n      either properly format text/enriched mail or, at\
    \ the very least,\n      are able to strip out the formatting commands and display\
    \ the\n      readable text. The same is not true for HTML or SGML.\n   2. The\
    \ current RFC on HTML [RFC-1866] and Internet Drafts on SGML\n      have many\
    \ features which are not necessary for Internet mail, and\n      are missing a\
    \ few capabilities that text/enriched already has.\n   For these reasons, this\
    \ document is promoting the use of\n   text/enriched until other Internet standards\
    \ come into more\n   widespread use. For those who will want to use HTML, Appendix\
    \ B of\n   this document contains a very simple C program that converts\n   text/enriched\
    \ to HTML 2.0 described in [RFC-1866].\n"
- title: Syntax
  contents:
  - "Syntax\n   The syntax of \"text/enriched\" is very simple. It represents text\
    \ in a\n   single character set--US-ASCII by default, although a different\n \
    \  character set can be specified by the use of the \"charset\" parameter.\n \
    \  (The semantics of text/enriched in non-ASCII character sets are\n   discussed\
    \ later in this document.) All characters represent\n   themselves, with the exception\
    \ of the \"<\" character (ASCII 60), which\n   is used to mark the beginning of\
    \ a formatting command. A literal\n   less-than sign (\"<\") can be represented\
    \ by a sequence of two such\n   characters, \"<<\".\n   Formatting instructions\
    \ consist of formatting commands surrounded by\n   angle brackets (\"<>\", ASCII\
    \ 60 and 62). Each formatting command may\n   be no more than 60 characters in\
    \ length, all in US-ASCII, restricted\n   to the alphanumeric and hyphen (\"-\"\
    ) characters. Formatting commands\n   may be preceded by a solidus (\"/\", ASCII\
    \ 47), making them negations,\n   and such negations must always exist to balance\
    \ the initial opening\n   commands.  Thus, if the formatting command \"<bold>\"\
    \ appears at some\n   point, there must later be a \"</bold>\" to balance it.\
    \ (NOTE: The 60\n   character limit on formatting commands does NOT include the\
    \ \"<\", \">\",\n   or \"/\" characters that might be attached to such commands.)\n\
    \   Formatting commands are always case-insensitive. That is, \"bold\" and\n \
    \  \"BoLd\" are equivalent in effect, if not in good taste.\n"
- title: Line break rules
  contents:
  - "Line break rules\n   Line breaks (CRLF pairs in standard network representation)\
    \ are\n   handled specially. In particular, isolated CRLF pairs are translated\n\
    \   into a single SPACE character. Sequences of N consecutive CRLF pairs,\n  \
    \ however, are translated into N-1 actual line breaks. This permits\n   long lines\
    \ of data to be represented in a natural looking manner\n   despite the frequency\
    \ of line-wrapping in Internet mailers. When\n   preparing the data for mail transport,\
    \ isolated line breaks should be\n   inserted wherever necessary to keep each\
    \ line shorter than 80\n   characters. When preparing such data for presentation\
    \ to the user,\n   isolated line breaks should be replaced by a single SPACE character,\n\
    \   and N consecutive CRLF pairs should be presented to the user as N-1\n   line\
    \ breaks.\n   Thus text/enriched data that looks like this:\n     This is\n  \
    \   a single\n     line\n     This is the\n     next line.\n     This is the\n\
    \     next section.\n   should be displayed by a text/enriched interpreter as\
    \ follows:\n     This is a single line\n     This is the next line.\n     This\
    \ is the next section.\n   The formatting commands, not all of which will be implemented\
    \ by all\n   implementations, are described in the following sections.\n"
- title: Formatting Commands
  contents:
  - "Formatting Commands\n   The text/enriched formatting commands all begin with\
    \ <commandname>\n   and end with </commandname>, affecting the formatting of the\
    \ text\n   between those two tokens. The commands are described here, grouped\n\
    \   according to type.\n"
- title: Parameter Command
  contents:
  - "Parameter Command\n   Some of the formatting commands may require one or more\
    \ associated\n   parameters. The \"param\" command is a special formatting command\
    \ used\n   to include these parameters.\n     Param\n          Marks the affected\
    \ text as command parameters, to be\n          interpreted or ignored by the text/enriched\
    \ interpreter,\n          but not to be shown to the reader. The \"param\" command\n\
    \          always immediately follows some other formatting command,\n       \
    \   and the parameter data indicates some additional\n          information about\
    \ the formatting that is to be done. The\n          syntax of the parameter data\
    \ (whatever appears between\n          the initial \"<param>\" and the terminating\
    \ \"</param>\") is\n          defined for each command that uses it. However,\
    \ it is\n          always required that the format of such data must not\n   \
    \       contain nested \"param\" commands, and either must not use\n         \
    \ the \"<\" character or must use it in a way that is\n          compatible with\
    \ text/enriched parsing. That is, the end\n          of the parameter data should\
    \ be recognizable with either\n          of two algorithms: simply searching for\
    \ the first\n          occurrence of \"</param>\" or parsing until a balanced\n\
    \          \"</param>\" command is found. In either case, however, the\n     \
    \     parameter data should not be shown to the human reader.\n"
- title: Font-Alteration Commands
  contents:
  - "Font-Alteration Commands\n   The following formatting commands are intended to\
    \ alter the font in\n   which text is displayed, but not to alter the indentation\
    \ or\n   justification state of the text:\n     Bold\n          causes the affected\
    \ text to be in a bold font. Nested\n          bold commands have the same effect\
    \ as a single bold\n          command.\n     Italic\n          causes the affected\
    \ text to be in an italic font. Nested\n          italic commands have the same\
    \ effect as a single italic\n          command.\n     Underline\n          causes\
    \ the affected text to be underlined. Nested\n          underline commands have\
    \ the same effect as a single\n          underline command.\n     Fixed\n    \
    \      causes the affected text to be in a fixed width font.\n          Nested\
    \ fixed commands have the same effect as a single\n          fixed command.\n\
    \     FontFamily\n          causes the affected text to be displayed in a specified\n\
    \          typeface. The \"fontfamily\" command requires a parameter\n       \
    \   that is specified by using the \"param\" command. The\n          parameter\
    \ data is a case-insensitive string containing\n          the name of a font family.\
    \ Any currently available font\n          family name (e.g. Times, Palatino, Courier,\
    \ etc.) may be\n          used. This includes font families defined by commercial\n\
    \          type foundries such as Adobe, BitStream, or any other\n          such\
    \ foundry. Note that implementations should only use\n          the general font\
    \ family name, not the specific font name\n          (e.g. use \"Times\", not\
    \ \"TimesRoman\" nor\n          \"TimesBoldItalic\"). When nested, the inner \"\
    fontfamily\"\n          command takes precedence. Also note that the \"fontfamily\"\
    \n          command is advisory only; it should not be expected that\n       \
    \   other implementations will honor the typeface information\n          in this\
    \ command since the font capabilities of systems\n          vary drastically.\n\
    \     Color\n          causes the affected text to be displayed in a specified\n\
    \          color. The \"color\" command requires a parameter that is\n       \
    \   specified by using the \"param\" command. The parameter\n          data can\
    \ be one of the following:\n               red\n               blue\n        \
    \       green\n               yellow\n               cyan\n               magenta\n\
    \               black\n               white\n          or an RGB color value in\
    \ the form:\n               ####,####,####\n          where '#' is a hexadecimal\
    \ digit '0' through '9', 'A'\n          through 'F', or 'a' through 'f'. The three\
    \ 4-digit\n          hexadecimal values are the RGB values for red, green, and\n\
    \          blue respectively, where each component is expressed as\n         \
    \ an unsigned value between 0 (0000) and 65535 (FFFF). The\n          default\
    \ color for the message is unspecified, though\n          black is a common choice\
    \ in many environments. When\n          nested, the inner \"color\" command takes\
    \ precedence.\n     Smaller\n          causes the affected text to be in a smaller\
    \ font. It is\n          recommended that the font size be changed by two points,\n\
    \          but other amounts may be more appropriate in some\n          environments.\
    \ Nested smaller commands produce ever\n          smaller fonts, to the limits\
    \ of the implementation's\n          capacity to reasonably display them, after\
    \ which further\n          smaller commands have no incremental effect.\n    \
    \ Bigger\n          causes the affected text to be in a bigger font. It is\n \
    \         recommended that the font size be changed by two points,\n         \
    \ but other amounts may be more appropriate in some\n          environments. Nested\
    \ bigger commands produce ever bigger\n          fonts, to the limits of the implementation's\
    \ capacity to\n          reasonably display them, after which further bigger\n\
    \          commands have no incremental effect.\n   While the \"bigger\" and \"\
    smaller\" operators are effectively inverses,\n   it is not recommended, for example,\
    \ that \"<smaller>\" be used to end\n   the effect of \"<bigger>\". This is properly\
    \ done with \"</bigger>\".\n   Since the capabilities of implementations will\
    \ vary, it is to be\n   expected that some implementations will not be able to\
    \ act on some of\n   the font-alteration commands. However, an implementation\
    \ should still\n   display the text to the user in a reasonable fashion. In particular,\n\
    \   the lack of capability to display a particular font family, color, or\n  \
    \ other text attribute does not mean that an implementation should fail\n   to\
    \ display text.\n"
- title: Fill/Justification/Indentation Commands
  contents:
  - "Fill/Justification/Indentation Commands\n   Initially, text/enriched text is\
    \ intended to be displayed fully\n   filled (that is, using the rules specified\
    \ for replacing CRLF pairs\n   with spaces or removing them as appropriate) with\
    \ appropriate kerning\n   and letter-tracking, and using the maximum available\
    \ margins as suits\n   the capabilities of the receiving user agent software.\n\
    \   The following commands alter that state. Each of these commands force\n  \
    \ a line break before and after the formatting environment if there is\n   not\
    \ otherwise a line break. For example, if one of these commands\n   occurs anywhere\
    \ other than the beginning of a line of text as\n   presented, a new line is begun.\n\
    \     Center\n          causes the affected text to be centered.\n     FlushLeft\n\
    \          causes the affected text to be left-justified with a\n          ragged\
    \ right margin.\n     FlushRight\n          causes the affected text to be right-justified\
    \ with a\n          ragged left margin.\n     FlushBoth\n          causes the\
    \ affected text to be filled and padded so as to\n          create smooth left\
    \ and right margins, i.e., to be fully\n          justified.\n     ParaIndent\n\
    \          causes the running margins of the affected text to be\n          moved\
    \ in. The recommended indentation change is the width\n          of four characters,\
    \ but this may differ among\n          implementations. The \"paraindent\" command\
    \ requires a\n          parameter that is specified by using the \"param\" command.\n\
    \          The parameter data is a comma-seperated list of one or\n          more\
    \ of the following:\n          Left\n               causes the running left margin\
    \ to be moved to the\n               right.\n          Right\n               causes\
    \ the running right margin to be moved to the\n               left.\n        \
    \  In\n               causes the first line of the affected paragraph to\n   \
    \            be indented in addition to the running margin. The\n            \
    \   remaining lines remain flush to the running margin.\n          Out\n     \
    \          causes all lines except for the first line of the\n               affected\
    \ paragraph to be indented in addition to the\n               running margin.\
    \ The first line remains flush to the\n               running margin.\n     Nofill\n\
    \          causes the affected text to be displayed without filling.\n       \
    \   That is, the text is displayed without using the rules\n          for replacing\
    \ CRLF pairs with spaces or removing\n          consecutive sequences of CRLF\
    \ pairs. However, the current\n          state of the margins and justification\
    \ is honored; any\n          indentation or justification commands are still applied\n\
    \          to the text within the scope of the \"nofill\".\n   The \"center\"\
    , \"flushleft\", \"flushright\", and \"flushboth\" commands are\n   mutually exclusive,\
    \ and, when nested, the inner command takes\n   precedence.\n   The \"nofill\"\
    \ command is mutually exclusive with the \"in\" and \"out\"\n   parameters of\
    \ the \"paraindent\" command; when they occur in the same\n   scope, their behavior\
    \ is undefined.\n   The parameter data for the \"paraindent\" command may contain\
    \ multiple\n   occurances of the same parameter (i.e. \"left\", \"right\", \"\
    in\", or\n   \"out\").  Each occurance causes the text to be further indented\
    \ in the\n   manner indicated by that parameter. Nested \"paraindent\" commands\n\
    \   cause the affected text to be further indented according to the\n   parameters.\
    \ Note that the \"in\" and \"out\" parameters for \"paraindent\"\n   are mutually\
    \ exclusive; when they appear together or when nested\n   \"paraindent\" commands\
    \ contain both of them, their behavior is\n   undefined.\n   For purposes of the\
    \ \"in\" and \"out\" parameters, a paragraph is defined\n   as text that is delimited\
    \ by line breaks after applying the rules for\n   replacing CRLF pairs with spaces\
    \ or removing consecutive sequences of\n   CRLF pairs. For example, within the\
    \ scope of an \"out\", the line\n   following each CRLF is made flush with the\
    \ running margin, and\n   subsequent lines are indented. Within the scope of an\
    \ \"in\", the first\n   line following each CRLF is indented, and subsequent lines\
    \ remain\n   flush to the running margin.\n   Whether or not text is justified\
    \ by default (that is, whether the\n   default environment is \"flushleft\", \"\
    flushright\", or \"flushboth\") is\n   unspecified, and depends on the preferences\
    \ of the user, the\n   capabilities of the local software and hardware, and the\
    \ nature of\n   the character set in use. On systems where full justification\
    \ is\n   considered undesirable, the \"flushboth\" environment may be identical\n\
    \   to the default environment. Note that full justification should never\n  \
    \ be performed inside of \"center\", \"flushleft\", \"flushright\", or\n   \"\
    nofill\" environments.  Note also that for some non-ASCII character\n   sets,\
    \ full justification may be fundamentally inappropriate.\n   Note that [RFC-1563]\
    \ defined two additional indentation commands,\n   \"Indent\" and \"IndentRight\"\
    . These commands did not force a line\n   break, and therefore their behavior\
    \ was unpredictable since they\n   depended on the margins and character sizes\
    \ that a particular\n   implementation used.  Therefore, their use is deprecated\
    \ and they\n   should be ignored just as other unrecognized commands.\n"
- title: Markup Commands
  contents:
  - "Markup Commands\n   Commands in this section, unlike the other text/enriched\
    \ commands are\n   declarative markup commands. Text/enriched is not intended\
    \ as a full\n   markup language, but instead as a simple way to represent common\n\
    \   formatting commands. Therefore, markup commands are purposely kept to\n  \
    \ a minimum. It is only because each was deemed so prevalent or\n   necessary\
    \ in an e-mail environment that these particular commands\n   have been included\
    \ at all.\n     Excerpt\n          causes the affected text to be interpreted\
    \ as a textual\n          excerpt from another source, probably a message being\n\
    \          responded to. Typically this will be displayed using\n          indentation\
    \ and an alternate font, or by indenting lines\n          and preceding them with\
    \ \"> \", but such decisions are up\n          to the implementation. Note that\
    \ as with the\n          justification commands, the excerpt command implicitly\n\
    \          begins and ends with a line break if one is not already\n         \
    \ there. Nested \"excerpt\" commands are acceptable and\n          should be interpreted\
    \ as meaning that the excerpted text\n          was excerpted from yet another\
    \ source. Again, this can be\n          displayed using additional indentation,\
    \ different colors,\n          etc.\n          Optionally, the \"excerpt\" command\
    \ can take a parameter by\n          using the \"param\" command. The format of\
    \ the data is\n          unspecified, but it is intended to uniquely identify\
    \ the\n          text from which the excerpt is taken. With this\n          information,\
    \ an implementation should be able to uniquely\n          identify the source\
    \ of any particular excerpt, especially\n          if two or more excerpts in\
    \ the message are from the same\n          source, and display it in some way\
    \ that makes this\n          apparent to the user.\n     Lang\n          causes\
    \ the affected text to be interpreted as belonging\n          to a particular\
    \ language. This is most useful when two\n          different languages use the\
    \ same character set, but may\n          require a different font or formatting\
    \ depending on the\n          language. For instance, Chinese and Japanese share\n\
    \          similar character glyphs, and in some character sets like\n       \
    \   UNICODE share common code points, but it is considered\n          very important\
    \ that different fonts be used for the two\n          languages, especially if\
    \ they appear together, so that\n          meaning is not lost. Also, language\
    \ information can be\n          used to allow for fancier text handling, like\
    \ spell\n          checking or hyphenation.\n          The \"lang\" command requires\
    \ a parameter using the \"param\"\n          command. The parameter data can be\
    \ any of the language\n          tags specified in [RFC-1766], \"Tags for the\n\
    \          Identification of Languages\". These tags are the two\n          letter\
    \ language codes taken from [ISO-639] or can be\n          other language codes\
    \ that are registered according to the\n          instructions in the Langauge\
    \ Tags RFC. Consult that memo\n          for further information.\n"
- title: Balancing and Nesting of Formatting Commands
  contents:
  - "Balancing and Nesting of Formatting Commands\n   Pairs of formatting commands\
    \ must be properly balanced and nested.\n   Thus, a proper way to describe text\
    \ in bold italics is:\n     <bold><italic>the-text</italic></bold>\n   or, alternately,\n\
    \     <italic><bold>the-text</bold></italic>\n   but, in particular, the following\
    \ is illegal text/enriched:\n     <bold><italic>the-text</bold></italic>\n   The\
    \ nesting requirement for formatting commands imposes a slightly\n   higher burden\
    \ upon the composers of text/enriched bodies, but\n   potentially simplifies text/enriched\
    \ displayers by allowing them to\n   be stack-based. The main goal of text/enriched\
    \ is to be simple enough\n   to make multifont, formatted email widely readable,\
    \ so that those\n   with the capability of sending it will be able to do so with\n\
    \   confidence. Thus slightly increased complexity in the composing\n   software\
    \ was deemed a reasonable tradeoff for simplified reading\n   software. Nonetheless,\
    \ implementors of text/enriched readers are\n   encouraged to follow the general\
    \ Internet guidelines of being\n   conservative in what you send and liberal in\
    \ what you accept. Those\n   implementations that can do so are encouraged to\
    \ deal reasonably with\n   improperly nested text/enriched data.\n"
- title: Unrecognized formatting commands
  contents:
  - "Unrecognized formatting commands\n   Implementations must regard any unrecognized\
    \ formatting command as\n   \"no-op\" commands, that is, as commands having no\
    \ effect, thus\n   facilitating future extensions to \"text/enriched\". Private\
    \ extensions\n   may be defined using formatting commands that begin with \"X-\"\
    , by\n   analogy to Internet mail header field names.\n   In order to formally\
    \ define extended commands, a new Internet\n   document should be published.\n"
- title: White Space in Text/enriched Data
  contents:
  - "White Space in Text/enriched Data\n   No special behavior is required for the\
    \ SPACE or TAB (HT) character.\n   It is recommended, however, that, at least\
    \ when fixed-width fonts are\n   in use, the common semantics of the TAB (HT)\
    \ character should be\n   observed, namely that it moves to the next column position\
    \ that is a\n   multiple of 8. (In other words, if a TAB (HT) occurs in column\
    \ n,\n   where the leftmost column is column 0, then that TAB (HT) should be\n\
    \   replaced by 8-(n mod 8) SPACE characters.) It should also be noted\n   that\
    \ some mail gateways are notorious for losing (or, less commonly,\n   adding)\
    \ white space at the end of lines, so reliance on SPACE or TAB\n   characters\
    \ at the end of a line is not recommended.\n"
- title: Initial State of a text/enriched interpreter
  contents:
  - "Initial State of a text/enriched interpreter\n   Text/enriched is assumed to\
    \ begin with filled text in a variable-\n   width font in a normal typeface and\
    \ a size that is average for the\n   current display and user. The left and right\
    \ margins are assumed to\n   be maximal, that is, at the leftmost and rightmost\
    \ acceptable\n   positions.\n"
- title: Non-ASCII character sets
  contents:
  - "Non-ASCII character sets\n   One of the great benefits of MIME is the ability\
    \ to use different\n   varieties of non-ASCII text in messages. To use non-ASCII\
    \ text in a\n   message, normally a charset parameter is specified in the Content-\n\
    \   type line that indicates the character set being used. For purposes\n   of\
    \ this RFC, any legal MIME charset parameter can be used with the\n   text/enriched\
    \ Content-type. However, there are two difficulties that\n   arise with regard\
    \ to the text/enriched Content-type when non-ASCII\n   text is desired. The first\
    \ problem involves difficulties that occur\n   when the user wishes to create\
    \ text which would normally require\n   multiple non-ASCII character sets in the\
    \ same text/enriched message.\n   The second problem is an ambiguity that arises\
    \ because of the\n   text/enriched use of the \"<\" character in formatting commands.\n"
- title: Using multiple non-ASCII character sets
  contents:
  - "Using multiple non-ASCII character sets\n   Normally, if a user wishes to produce\
    \ text which contains characters\n   from entirely different character sets within\
    \ the same MIME message\n   (for example, using Russian Cyrillic characters from\
    \ ISO 8859-5 and\n   Hebrew characters from ISO 8859-8), a multipart message is\
    \ used.\n   Every time a new character set is desired, a new MIME body part is\n\
    \   started with different character sets specified in the charset\n   parameter\
    \ of the Content-type line. However, using multiple character\n   sets this way\
    \ in text/enriched messages introduces problems. Since a\n   change in the charset\
    \ parameter requires a new part, text/enriched\n   formatting commands used in\
    \ the first part would not be able to apply\n   to text that occurs in subsequent\
    \ parts. It is not possible for\n   text/enriched formatting commands to apply\
    \ across MIME body part\n   boundaries.\n   [RFC-1341] attempted to get around\
    \ this problem in the now obsolete\n   text/richtext format by introducing different\
    \ character set\n   formatting commands like \"iso-8859-5\" and \"us-ascii\".\
    \ But this, or\n   even a more general solution along the same lines, is still\n\
    \   undesirable: It is common for a MIME application to decide, for\n   example,\
    \ what character font resources or character lookup tables it\n   will require\
    \ based on the information provided by the charset\n   parameter of the Content-type\
    \ line, before it even begins to\n   interpret or display the data in that body\
    \ part. By allowing the\n   text/enriched interpreter to subsequently change the\
    \ character set,\n   perhaps to one completely different from the charset specified\
    \ in the\n   Content-type line (with potentially much different resource\n   requirements),\
    \ too much burden would be placed on the text/enriched\n   interpreter itself.\n\
    \   Therefore, if multiple types of non-ASCII characters are desired in a\n  \
    \ text/enriched document, one of the following two methods must be\n   used:\n\
    \   1. For cases where the different types of non-ASCII text can be\n      limited\
    \ to their own paragraphs with distinct formatting, a\n      multipart message\
    \ can be used with each part having a\n      Content-Type of text/enriched and\
    \ a different charset parameter.\n      The one caveat to using this method is\
    \ that each new part must\n      start in the initial state for a text/enriched\
    \ document. That\n      means that all of the text/enriched commands in the preceding\n\
    \      part must be properly balanced with ending commands before the\n      next\
    \ text/enriched part begins. Also, each text/enriched part\n      must begin a\
    \ new paragraph.\n   2. If different types of non-ASCII text are to appear in\
    \ the same\n      line or paragraph, or if text/enriched formatting (e.g. margins,\n\
    \      typeface, justification) is required across several different\n      types\
    \ of non-ASCII text, a single text/enriched body part should\n      be used with\
    \ a character set specified that contains all of the\n      required characters.\
    \ For example, a charset parameter of\n      \"UNICODE-1-1-UTF-7\" as specified\
    \ in [RFC-1642] could be used for\n      such purposes. Not only does UNICODE\
    \ contain all of the\n      characters that can be represented in all of the other\
    \ registered\n      ISO 8859 MIME character sets, but UTF-7 is fully compatible\
    \ with\n      other aspects of the text/enriched standard, including the use of\n\
    \      the \"<\" character referred to below. Any other character sets\n     \
    \ that are specified for use in MIME which contain different types\n      of non-ASCII\
    \ text can also be used in these instances.\n"
- title: Use of the "<" character in formatting commands
  contents:
  - "Use of the \"<\" character in formatting commands\n   If the character set specified\
    \ by the charset parameter on the\n   Content-type line is anything other than\
    \ \"US-ASCII\", this means that\n   the text being described by text/enriched\
    \ formatting commands is in a\n   non-ASCII character set. However, the commands\
    \ themselves are still\n   the same ASCII commands that are defined in this document.\
    \ This\n   creates an ambiguity only with reference to the \"<\" character, the\n\
    \   octet with numeric value 60. In single byte character sets, such as\n   the\
    \ ISO-8859 family, this is not a problem; the octet 60 can be\n   quoted by including\
    \ it twice, just as for ASCII. The problem is more\n   complicated, however, in\
    \ the case of multi-byte character sets, where\n   the octet 60 might appear at\
    \ any point in the byte sequence for any\n   of several characters.\n   In practice,\
    \ however, most multi-byte character sets address this\n   problem internally.\
    \ For example, the UNICODE character sets can use\n   the UTF-7 encoding which\
    \ preserves all of the important ASCII\n   characters in their single byte form.\
    \ The ISO-2022 family of\n   character sets can use certain character sequences\
    \ to switch back\n   into ASCII at any moment.  Therefore it is specified that,\
    \ before\n   text/enriched formatting commands, the prevailing character set\n\
    \   should be \"switched back\" into ASCII, and that only those characters\n \
    \  which would be interpreted as \"<\" in plain text should be interpreted\n \
    \  as token delimiters in text/enriched.\n   The question of what to do for hypothetical\
    \ future character sets\n   that do not subsume ASCII is not addressed in this\
    \ memo.\n"
- title: Minimal text/enriched conformance
  contents:
  - "Minimal text/enriched conformance\n   A minimal text/enriched implementation\
    \ is one that converts \"<<\" to\n   \"<\", removes everything between a <param>\
    \ command and the next\n   balancing </param> command, removes all other formatting\
    \ commands\n   (all text enclosed in angle brackets), and, outside of <nofill>\n\
    \   environments, converts any series of n CRLFs to n-1 CRLFs, and\n   converts\
    \ any lone CRLF pairs to SPACE.\n"
- title: Notes for Implementors
  contents:
  - "Notes for Implementors\n   It is recognized that implementors of future mail\
    \ systems will want\n   rich text functionality far beyond that currently defined\
    \ for\n   text/enriched.  The intent of text/enriched is to provide a common\n\
    \   format for expressing that functionality in a form in which much of\n   it,\
    \ at least, will be understood by interoperating software. Thus, in\n   particular,\
    \ software with a richer notion of formatted text than\n   text/enriched can still\
    \ use text/enriched as its basic\n   representation, but can extend it with new\
    \ formatting commands and by\n   hiding information specific to that software\
    \ system in text/enriched\n   <param> constructs. As such systems evolve, it is\
    \ expected that the\n   definition of text/enriched will be further refined by\
    \ future\n   published specifications, but text/enriched as defined here provides\n\
    \   a platform on which evolutionary refinements can be based.\n   An expected\
    \ common way that sophisticated mail programs will generate\n   text/enriched\
    \ data is as part of a multipart/alternative construct.\n   For example, a mail\
    \ agent that can generate enriched mail in ODA\n   format can generate that mail\
    \ in a more widely interoperable form by\n   generating both text/enriched and\
    \ ODA versions of the same data,\n   e.g.:\n     Content-type: multipart/alternative;\
    \ boundary=foo\n     --foo\n     Content-type: text/enriched\n     [text/enriched\
    \ version of data]\n     --foo Content-type: application/oda\n     [ODA version\
    \ of data]\n     --foo--\n   If such a message is read using a MIME-conformant\
    \ mail reader that\n   understands ODA, the ODA version will be displayed; otherwise,\
    \ the\n   text/enriched version will be shown.\n   In some environments, it might\
    \ be impossible to combine certain\n   text/enriched formatting commands, whereas\
    \ in others they might be\n   combined easily. For example, the combination of\
    \ <bold> and <italic>\n   might produce bold italics on systems that support such\
    \ fonts, but\n   there exist systems that can make text bold or italicized, but\
    \ not\n   both. In such cases, the most recently issued (innermost) recognized\n\
    \   formatting command should be preferred.\n   One of the major goals in the\
    \ design of text/enriched was to make it\n   so simple that even text-only mailers\
    \ will implement enriched-to-\n   plain-text translators, thus increasing the\
    \ likelihood that enriched\n   text will become \"safe\" to use very widely. To\
    \ demonstrate this\n   simplicity, an extremely simple C program that converts\
    \ text/enriched\n   input into plain text output is included in Appendix A.\n"
- title: Extensions to text/enriched
  contents:
  - "Extensions to text/enriched\n   It is expected that various mail system authors\
    \ will desire\n   extensions to text/enriched. The simple syntax of text/enriched,\
    \ and\n   the specification that unrecognized formatting commands should simply\n\
    \   be ignored, are intended to promote such extensions.\n"
- title: An Example
  contents:
  - "An Example\n   Putting all this together, the following \"text/enriched\" body\n\
    \   fragment:\n     From: Nathaniel Borenstein <nsb@bellcore.com>\n     To: Ned\
    \ Freed <ned@innosoft.com>\n     Content-type: text/enriched\n     <bold>Now</bold>\
    \ is the time for <italic>all</italic>\n     good men\n     <smaller>(and <<women>)</smaller>\
    \ to\n     <ignoreme>come</ignoreme>\n     to the aid of their\n     <color><param>red</param>beloved</color>\n\
    \     country.\n     By the way,\n     I think that <paraindent><param>left</param><<smaller>\n\
    \     </paraindent>should REALLY be called\n     <paraindent><param>left</param><<tinier></paraindent>\n\
    \     and that I am always right.\n     -- the end\n   represents the following\
    \ formatted text (which will, no doubt, look\n   somewhat cryptic in the text-only\
    \ version of this document):\n     Now is the time for all good men (and <women>)\
    \ to come\n     to the aid of their\n     beloved country.\n     By the way, I\
    \ think that\n          <smaller>\n     should REALLY be called\n          <tinier>\n\
    \     and that I am always right.\n     -- the end\n   where the word \"beloved\"\
    \ would be in red on a color display.\n   ti 0 Security Considerations\n   Security\
    \ issues are not discussed in this memo, as the mechanism\n   raises no security\
    \ issues.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   For more information, the authors of this document may\
    \ be contacted\n   via Internet mail:\n   Peter W. Resnick\n   QUALCOMM Incorporated\n\
    \   6455 Lusk Boulevard\n   San Diego, CA 92121-2779\n   Phone: +1 619 587 1121\n\
    \   Fax: +1 619 658 2230\n   EMail: presnick@qualcomm.com\n   Amanda Walker\n\
    \   InterCon Systems Corporation\n   950 Herndon Parkway\n   Herndon, VA 22070\n\
    \   Phone: +1 703 709 5500\n   Fax: +1 703 709 5555\n   EMail: amanda@intercon.com\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors gratefully acknowledge the input of many contributors,\n\
    \   readers, and implementors of the specification in this document.\n   Particular\
    \ thanks are due to Nathaniel Borenstein, the original\n   author of RFC 1563.\n"
- title: References
  contents:
  - "References\n   [RFC-1341]\n        Borenstein, N., and N. Freed, \"MIME (Multipurpose\
    \ Internet Mail\n        Extensions): Mechanisms for Specifying and Describing\
    \ the Format\n        of Internet Message Bodies\", 06/11/1992.\n   [RFC-1521]\n\
    \        Borenstein, N., and N. Freed, \"MIME (Multipurpose Internet Mail\n  \
    \      Extensions) Part One: Mechanisms for Specifying and Describing\n      \
    \  the Format of Internet Message Bodies\", 09/23/1993.\n   [RFC-1523]\n     \
    \   Borenstein, N., \"The text/enriched MIME Content-type\",\n        09/23/1993.\n\
    \   [RFC-1563]\n        Borenstein, N., \"The text/enriched MIME Content-type\"\
    ,\n        01/10/1994.\n   [RFC-1642]\n        Goldsmith, D., Davis, M., \"UTF-7\
    \ - A Mail-Safe Transformation\n        Format of Unicode\", 07/13/1994.\n   [RFC-1766]\n\
    \        Alvestrand, H., \"Tags for the Identification of Languages\",\n     \
    \   03/02/1995.\n   [RFC-1866]\n        Berners-Lee, T., and D. Connolly, D.,\
    \ \"Hypertext Markup Language\n        - 2.0\", 11/03/1995.\n"
- title: Appendix A--A Simple enriched-to-plain Translator in C
  contents:
  - "Appendix A--A Simple enriched-to-plain Translator in C\n   One of the major goals\
    \ in the design of the text/enriched subtype of\n   the text Content-Type is to\
    \ make formatted text so simple that even\n   text-only mailers will implement\
    \ enriched-to-plain-text translators,\n   thus increasing the likelihood that\
    \ multifont text will become \"safe\"\n   to use very widely. To demonstrate this\
    \ simplicity, what follows is a\n   simple C program that converts text/enriched\
    \ input into plain text\n   output. Note that the local newline convention (the\
    \ single character\n   represented by \"\\n\") is assumed by this program, but\
    \ that special\n   CRLF handling might be necessary on some systems.\n"
- title: '#include <ctype.h>'
  contents:
  - '#include <ctype.h>

    '
- title: '#include <stdio.h>'
  contents:
  - '#include <stdio.h>

    '
- title: '#include <stdlib.h>'
  contents:
  - '#include <stdlib.h>

    '
- title: '#include <string.h>'
  contents:
  - '#include <string.h>

    '
- title: main() {
  contents:
  - "main() {\n    int c, i, paramct=0, newlinect=0, nofill=0;\n    char token[62],\
    \ *p;\n    while ((c=getc(stdin)) != EOF) {\n        if (c == '<') {\n       \
    \     if (newlinect == 1) putc(' ', stdout);\n            newlinect = 0;\n   \
    \         c = getc(stdin);\n            if (c == '<') {\n                if (paramct\
    \ <= 0) putc(c, stdout);\n            } else {\n                ungetc(c, stdin);\n\
    \                for (i=0, p=token;\n                    (c=getc(stdin)) != EOF\
    \ && c != '>'; i++) {\n                    if (i < sizeof(token)-1)\n        \
    \                *p++ = isupper(c) ? tolower(c) : c;\n                }\n    \
    \            *p = '\\0';\n                if (c == EOF) break;\n             \
    \   if (strcmp(token, \"param\") == 0)\n                    paramct++;\n     \
    \           else if (strcmp(token, \"nofill\") == 0)\n                    nofill++;\n\
    \                else if (strcmp(token, \"/param\") == 0)\n                  \
    \  paramct--;\n                else if (strcmp(token, \"/nofill\") == 0)\n   \
    \                 nofill--;\n            }\n        } else {\n            if (paramct\
    \ > 0)\n                ; /* ignore params */\n            else if (c == '\\n'\
    \ && nofill <= 0) {\n                if (++newlinect > 1) putc(c, stdout);\n \
    \           } else {\n                if (newlinect == 1) putc(' ', stdout);\n\
    \                newlinect = 0;\n                putc(c, stdout);\n          \
    \  }\n        }\n    }\n    /* The following line is only needed with line-buffering\
    \ */\n    putc('\\n', stdout);\n    exit(0);\n"
- title: '}'
  contents:
  - "}\n   It should be noted that one can do considerably better than this in\n \
    \  displaying text/enriched data on a dumb terminal. In particular, one\n   can\
    \ replace font information such as \"bold\" with textual emphasis\n   (like *this*\
    \ or _T_H_I_S_). One can also properly handle the\n   text/enriched formatting\
    \ commands regarding indentation,\n   justification, and others.  However, the\
    \ above program is all that is\n   necessary in order to present text/enriched\
    \ on a dumb terminal\n   without showing the user any formatting artifacts.\n"
- title: Appendix B--A Simple enriched-to-HTML Translator in C
  contents:
  - "Appendix B--A Simple enriched-to-HTML Translator in C\n   It is fully expected\
    \ that other text formatting standards like HTML\n   and SGML will supplant text/enriched\
    \ in Internet mail. It is also\n   likely that as this happens, recipients of\
    \ text/enriched mail will\n   wish to view such mail with an HTML viewer. To this\
    \ end, the\n   following is a simple example of a C program to convert text/enriched\n\
    \   to HTML. Since the current version of HTML at the time of this\n   document's\
    \ publication is HTML 2.0 defined in [RFC-1866], this\n   program converts to\
    \ that standard.  There are several text/enriched\n   commands that have no HTML\
    \ 2.0 equivalent. In those cases, this\n   program simply puts those commands\
    \ into processing instructions; that\n   is, surrounded by \"<?\" and \">\". As\
    \ in Appendix A, the local newline\n   convention (the single character represented\
    \ by \"\\n\") is assumed by\n   this program, but special CRLF handling might\
    \ be necessary on some\n   systems.\n"
- title: '#include <ctype.h>'
  contents:
  - '#include <ctype.h>

    '
- title: '#include <stdio.h>'
  contents:
  - '#include <stdio.h>

    '
- title: '#include <stdlib.h>'
  contents:
  - '#include <stdlib.h>

    '
- title: '#include <string.h>'
  contents:
  - '#include <string.h>

    '
- title: main() {
  contents:
  - "main() {\n    int c, i, paramct=0, nofill=0;\n    char token[62], *p;\n    while((c=getc(stdin))\
    \ != EOF) {\n        if(c == '<') {\n            c = getc(stdin);\n          \
    \  if(c == '<') {\n                fputs(\"&lt;\", stdout);\n            } else\
    \ {\n                ungetc(c, stdin);\n                for (i=0, p=token;\n \
    \                   (c=getc(stdin)) != EOF && c != '>'; i++) {\n             \
    \       if (i < sizeof(token)-1)\n                        *p++ = isupper(c) ?\
    \ tolower(c) : c;\n                }\n                *p = '\\0';\n          \
    \      if(c == EOF) break;\n                if(strcmp(token, \"/param\") == 0)\
    \ {\n                    paramct--;\n                    putc('>', stdout);\n\
    \                } else if(paramct > 0) {\n                    fputs(\"&lt;\"\
    , stdout);\n                    fputs(token, stdout);\n                    fputs(\"\
    &gt;\", stdout);\n                } else {\n                    putc('<', stdout);\n\
    \                    if(strcmp(token, \"nofill\") == 0) {\n                  \
    \      nofill++;\n                        fputs(\"pre\", stdout);\n          \
    \          } else if(strcmp(token, \"/nofill\") == 0) {\n                    \
    \    nofill--;\n                        fputs(\"/pre\", stdout);\n           \
    \         } else if(strcmp(token, \"bold\") == 0) {\n                        fputs(\"\
    b\", stdout);\n                    } else if(strcmp(token, \"/bold\") == 0) {\n\
    \                        fputs(\"/b\", stdout);\n                    } else if(strcmp(token,\
    \ \"italic\") == 0) {\n                        fputs(\"i\", stdout);\n       \
    \             } else if(strcmp(token, \"/italic\") == 0) {\n                 \
    \       fputs(\"/i\", stdout);\n                    } else if(strcmp(token, \"\
    fixed\") == 0) {\n                        fputs(\"tt\", stdout);\n           \
    \         } else if(strcmp(token, \"/fixed\") == 0) {\n                      \
    \  fputs(\"/tt\", stdout);\n                    } else if(strcmp(token, \"excerpt\"\
    ) == 0) {\n                        fputs(\"blockquote\", stdout);\n          \
    \          } else if(strcmp(token, \"/excerpt\") == 0) {\n                   \
    \     fputs(\"/blockquote\", stdout);\n                    } else {\n        \
    \                putc('?', stdout);\n                        fputs(token, stdout);\n\
    \                        if(strcmp(token, \"param\") == 0) {\n               \
    \             paramct++;\n                            putc(' ', stdout);\n   \
    \                         continue;\n                        }\n             \
    \       }\n                    putc('>', stdout);\n                }\n       \
    \     }\n        } else if(c == '>') {\n            fputs(\"&gt;\", stdout);\n\
    \        } else if (c == '&') {\n            fputs(\"&amp;\", stdout);\n     \
    \   } else {\n            if(c == '\\n' && nofill <= 0 && paramct <= 0) {\n  \
    \              while((i=getc(stdin)) == '\\n') fputs(\"<br>\", stdout);\n    \
    \            ungetc(i, stdin);\n            }\n            putc(c, stdout);\n\
    \        }\n    }\n    /* The following line is only needed with line-buffering\
    \ */\n    putc('\\n', stdout);\n    exit(0);\n"
- title: '}'
  contents:
  - '}

    '
