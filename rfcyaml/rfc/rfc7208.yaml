- contents:
  - "                     Sender Policy Framework (SPF)\n           for Authorizing
    Use of Domains in Email, Version 1\n"
  title: __initial_text__
- contents:
  - "Abstract\n   Email on the Internet can be forged in a number of ways.  In\n   particular,
    existing protocols place no restriction on what a sending\n   host can use as
    the \"MAIL FROM\" of a message or the domain given on\n   the SMTP HELO/EHLO commands.
    \ This document describes version 1 of\n   the Sender Policy Framework (SPF) protocol,
    whereby ADministrative\n   Management Domains (ADMDs) can explicitly authorize
    the hosts that\n   are allowed to use their domain names, and a receiving host
    can check\n   such authorization.\n   This document obsoletes RFC 4408.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7208.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \     1.1. Terminology ................................................5\n           1.1.1.
    Key Words ...........................................5\n           1.1.2. Imported
    Definitions ................................5\n           1.1.3. MAIL FROM Definition
    ................................6\n           1.1.4. HELO Definition .....................................6\n
    \     1.2. check_host() ...............................................6\n   2.
    Operational Overview ............................................6\n      2.1.
    Publishing Authorization ...................................6\n      2.2. Checking
    Authorization .....................................7\n      2.3. The \"HELO\"
    Identity ........................................8\n      2.4. The \"MAIL FROM\"
    Identity ...................................9\n      2.5. Location of Checks .........................................9\n
    \     2.6. Results of Evaluation ......................................9\n           2.6.1.
    None ...............................................10\n           2.6.2. Neutral
    ............................................10\n           2.6.3. Pass ...............................................10\n
    \          2.6.4. Fail ...............................................10\n           2.6.5.
    Softfail ...........................................10\n           2.6.6. Temperror
    ..........................................10\n           2.6.7. Permerror ..........................................10\n
    \  3. SPF Records ....................................................11\n      3.1.
    DNS Resource Records ......................................11\n      3.2. Multiple
    DNS Records ......................................12\n      3.3. Multiple Strings
    in a Single DNS Record ...................12\n      3.4. Record Size ...............................................13\n
    \     3.5. Wildcard Records ..........................................13\n   4.
    The check_host() Function ......................................14\n      4.1.
    Arguments .................................................14\n      4.2. Results
    ...................................................15\n      4.3. Initial Processing
    ........................................15\n      4.4. Record Lookup .............................................15\n
    \     4.5. Selecting Records .........................................15\n      4.6.
    Record Evaluation .........................................16\n           4.6.1.
    Term Evaluation ....................................16\n           4.6.2. Mechanisms
    .........................................16\n           4.6.3. Modifiers ..........................................17\n
    \          4.6.4. DNS Lookup Limits ..................................17\n      4.7.
    Default Result ............................................18\n      4.8. Domain
    Specification ......................................19\n   5. Mechanism Definitions
    ..........................................20\n      5.1. \"all\" .....................................................21\n
    \     5.2. \"include\" .................................................21\n      5.3.
    \"a\" .......................................................23\n      5.4. \"mx\"
    ......................................................23\n      5.5. \"ptr\" (do
    not use) ........................................23\n      5.6. \"ip4\" and \"ip6\"
    ...........................................25\n      5.7. \"exists\" ..................................................25\n
    \  6. Modifier Definitions ...........................................26\n      6.1.
    redirect: Redirected Query ................................26\n      6.2. exp:
    Explanation ..........................................27\n   7. Macros .........................................................28\n
    \     7.1. Formal Specification ......................................29\n      7.2.
    Macro Definitions .........................................29\n      7.3. Macro
    Processing Details ..................................30\n      7.4. Expansion
    Examples ........................................32\n   8. Result Handling ................................................33\n
    \     8.1. None ......................................................34\n      8.2.
    Neutral ...................................................34\n      8.3. Pass
    ......................................................34\n      8.4. Fail ......................................................35\n
    \     8.5. Softfail ..................................................35\n      8.6.
    Temperror .................................................36\n      8.7. Permerror
    .................................................36\n   9. Recording the Result
    ...........................................36\n      9.1. The Received-SPF Header
    Field .............................37\n      9.2. SPF Results in the Authentication-Results
    Header Field ....39\n   10. Effects on Infrastructure .....................................39\n
    \     10.1. Sending Domains ..........................................40\n           10.1.1.
    DNS Resource Considerations .......................40\n           10.1.2. Administrator's
    Considerations ....................41\n           10.1.3. Bounces ...........................................41\n
    \     10.2. Receivers ................................................42\n      10.3.
    Mediators ................................................42\n   11. Security
    Considerations .......................................43\n      11.1. Processing
    Limits ........................................43\n      11.2. SPF-Authorized
    Email May Contain Other False Identities ..44\n      11.3. Spoofed DNS and IP
    Data ..................................44\n      11.4. Cross-User Forgery .......................................44\n
    \     11.5. Untrusted Information Sources ............................45\n           11.5.1.
    Recorded Results ..................................45\n           11.5.2. External
    Explanations .............................45\n           11.5.3. Macro Expansion
    ...................................46\n      11.6. Privacy Exposure .........................................46\n
    \     11.7. Delivering Mail Producing a \"Fail\" Result ................46\n   12.
    Collected ABNF ................................................46\n   13. Contributors
    and Acknowledgements .............................48\n   14. IANA Considerations
    ...........................................49\n      14.1. The SPF DNS Record
    Type ..................................49\n      14.2. The Received-SPF Mail Header
    Field .......................50\n      14.3. SPF Modifier Registry ....................................50\n
    \  15. References ....................................................50\n      15.1.
    Normative References .....................................50\n      15.2. Informative
    References ...................................51\n   Appendix A. Extended Examples
    .....................................54\n     A.1. Simple Examples ............................................55\n
    \    A.2. Multiple Domain Example ....................................56\n     A.3.
    DNS Blacklist (DNSBL) Style Example ........................56\n     A.4. Multiple
    Requirements Example ..............................57\n   Appendix B. Changes
    in Implementation Requirements from RFC 4408 ..57\n   Appendix C. Further Testing
    Advice ................................58\n   Appendix D. SPF/Mediator Interactions
    .............................59\n     D.1. Originating ADMDs ..........................................59\n
    \    D.2. Mediators ..................................................60\n     D.3.
    Receiving ADMDs ............................................60\n   Appendix E.
    Mail Services .........................................61\n   Appendix F. MTA
    Relays ............................................61\n   Appendix G. Local Policy
    Considerations ...........................62\n     G.1. Policy for SPF Pass ........................................62\n
    \    G.2. Policy for SPF Fail ........................................62\n     G.3.
    Policy for SPF Permerror ...................................63\n     G.4. Policy
    for SPF Temperror ...................................63\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The current email infrastructure has the property that any
    host\n   injecting mail into the system can use any DNS domain name it wants\n
    \  in each of the various identifiers specified by [RFC5321] and\n   [RFC5322].
    \ Although this feature is desirable in some circumstances,\n   it is a major
    obstacle to reducing Unsolicited Bulk Email (UBE, aka\n   spam).  Furthermore,
    ADMDs (as described in [RFC5598]) are\n   understandably concerned about the ease
    with which other entities can\n   make use of their domain names, often with malicious
    intent.\n   This document defines a protocol by which ADMDs can authorize hosts\n
    \  to use their domain names in the \"MAIL FROM\" or \"HELO\" identities.\n   Compliant
    ADMDs publish Sender Policy Framework (SPF) records in the\n   DNS specifying
    which hosts are permitted to use their names, and\n   compliant mail receivers
    use the published SPF records to test the\n   authorization of sending Mail Transfer
    Agents (MTAs) using a given\n   \"HELO\" or \"MAIL FROM\" identity during a mail
    transaction.\n   An additional benefit to mail receivers is that after the use
    of an\n   identity is verified, local policy decisions about the mail can be\n
    \  made based on the sender's domain, rather than the host's IP address.\n   This
    is advantageous because reputation of domain names is likely to\n   be more accurate
    than reputation of host IP addresses since domains\n   are likely to be more stable
    over a longer period.  Furthermore, if a\n   claimed identity fails verification,
    local policy can take stronger\n   action against such email, such as rejecting
    it.\n"
  - contents:
    - '1.1.  Terminology

      '
    - contents:
      - "1.1.1.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
        \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
        \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to
        be interpreted as described in\n   [RFC2119].\n"
      title: 1.1.1.  Key Words
    - contents:
      - "1.1.2.  Imported Definitions\n   ABNF (Augmented Backus-Naur Form) ABNF is
        defined in [RFC5234], as\n   are the tokens \"ALPHA\", \"DIGIT\", and \"SP\"
        (space).\n   The tokens \"Local-part\", \"Domain\", and \"Mailbox\" are defined
        in\n   [RFC5321].\n   \"dot-atom\", \"quoted-string\", \"comment\", \"CFWS\"
        (comment folded white\n   space), \"FWS\" (folded white space), and \"CRLF\"
        (carriage-return/\n   line-feed) are defined in [RFC5322].\n"
      title: 1.1.2.  Imported Definitions
    - contents:
      - "1.1.3.  MAIL FROM Definition\n   This document is concerned with the identity
        of the sender of a mail\n   message, as referred to in [RFC5321]:\n      The
        transaction starts with a MAIL command that gives the sender\n      identification.\n
        \  Since there are many other names for this identity, it is important\n   to
        choose a name that is:\n   1.  commonly used\n   2.  well defined\n   As such,
        throughout this document the term \"MAIL FROM\" will be used,\n   which is
        defined as the RFC5321.MailFrom (reverse-path) identity\n   described in [RFC5598].\n"
      title: 1.1.3.  MAIL FROM Definition
    - contents:
      - "1.1.4.  HELO Definition\n   This document also makes use of the HELO/EHLO
        identity.  The \"HELO\"\n   identity derives from either the SMTP HELO or
        EHLO command (see\n   [RFC5321]).  Since HELO and EHLO can, in many cases,
        be used\n   interchangeably, they are identified commonly as \"HELO\" in this\n
        \  document.  This means RFC5321.HELO/.EHLO as defined in [RFC5598].\n   These
        commands supply the identity of the SMTP client (sending host)\n   for the
        SMTP session.\n"
      title: 1.1.4.  HELO Definition
    title: 1.1.  Terminology
  - contents:
    - "1.2.  check_host()\n   Section 4 introduces an algorithm to evaluate an SPF
      policy against\n   an arriving email transaction.  In an early implementation,
      this\n   algorithm was encoded in a function called check_host().  That name\n
      \  is used in this document as symbolic of the SPF evaluation algorithm,\n   but
      of course implementers are not required to use this name.\n"
    title: 1.2.  check_host()
  title: 1.  Introduction
- contents:
  - '2.  Operational Overview

    '
  - contents:
    - "2.1.  Publishing Authorization\n   An SPF-compliant domain publishes valid
      SPF records as described in\n   Section 3.  These records authorize the use
      of the relevant domain\n   names in the \"HELO\" and \"MAIL FROM\" identities
      by the MTAs specified\n   therein.\n   SPF results can be used to make both
      positive (source is authorized)\n   and negative (source is not authorized)
      determinations.  If ADMDs\n   choose to publish SPF records and want to support
      receivers making\n   negative authorization determinations, it is necessary
      for them to\n   publish records that end in \"-all\", or redirect to other records
      that\n   do; otherwise, no definitive determination of authorization can be\n
      \  made.  Potential issues and mitigations associated with negative\n   determinations
      are discussed in Section 10.\n   ADMDs that wish to declare that no hosts are
      authorized to use their\n   DNS domain names in the HELO or MAIL FROM commands
      during SMTP\n   sessions can publish SPF records that say so for domain names
      that\n   are neither used in the domain part of email addresses nor expected\n
      \  to originate mail.\n   When changing SPF records, care has to be taken to
      ensure that there\n   is a transition period so that the old policy remains
      valid until all\n   legitimate email can reasonably expect to have been checked.\n
      \  [RFC5321], Section 4.5.4.1 discusses how long a message might be in\n   transit.
      \ While offline checks are possible, the closer to the\n   original transmission
      time checks are performed, the more likely they\n   are to get an SPF result
      that matches the sending ADMD intent at the\n   time the message was sent.\n"
    title: 2.1.  Publishing Authorization
  - contents:
    - "2.2.  Checking Authorization\n   A mail receiver can perform a set of SPF checks
      for each mail message\n   it receives.  An SPF check tests the authorization
      of a client host\n   to emit mail with a given identity.  Typically, such checks
      are done\n   by a receiving MTA, but can be performed elsewhere in the mail\n
      \  processing chain so long as the required information is available and\n   reliable.
      \ The \"MAIL FROM\" and \"HELO\" identities are checked as\n   described in
      Sections 2.4 and 2.3, respectively.\n   Without explicit approval of the publishing
      ADMD, checking other\n   identities against SPF version 1 records is NOT RECOMMENDED
      because\n   there are cases that are known to give incorrect results.  For\n
      \  example, almost all mailing lists rewrite the \"MAIL FROM\" identity\n   (see
      Section 10.3), but some do not change any other identities in\n   the message.
      \ Documents that define other identities will have to\n   define the method
      for explicit approval.\n   It is possible that mail receivers will use the SPF
      check as part of\n   a larger set of tests on incoming mail.  The results of
      other tests\n   might influence whether or not a particular SPF check is performed.\n
      \  For example, finding the sending host's IP address on a local\n   whitelist
      might cause all other tests to be skipped and all mail from\n   that host to
      be accepted.\n   When a mail receiver decides to perform an SPF check, it has
      to use a\n   correctly implemented check_host() function (Section 4) evaluated\n
      \  with the correct parameters.  Although the test as a whole is\n   optional,
      once it has been decided to perform a test it has to be\n   performed as specified
      so that the correct semantics are preserved\n   between publisher and receiver.\n
      \  To make the test, the mail receiver MUST evaluate the check_host()\n   function
      with the arguments described in Section 4.1.\n   Although invalid, malformed,
      or non-existent domains cause SPF checks\n   to return \"none\" because no SPF
      record can be found, it has long been\n   the policy of many MTAs to reject
      email from such domains, especially\n   in the case of invalid \"MAIL FROM\".
      \ Rejecting email will prevent one\n   method of circumventing of SPF records.\n
      \  Implementations have to take care to correctly extract the <domain>\n   from
      the data given with the SMTP MAIL FROM command as many MTAs will\n   still accept
      such things as source routes (see Appendix C of\n   [RFC5321]), the %-hack (see
      [RFC1123]), and bang paths (see\n   [RFC1983]).  These archaic features have
      been maliciously used to\n   bypass security systems.\n"
    title: 2.2.  Checking Authorization
  - contents:
    - "2.3.  The \"HELO\" Identity\n   It is RECOMMENDED that SPF verifiers not only
      check the \"MAIL FROM\"\n   identity but also separately check the \"HELO\"
      identity by applying\n   the check_host() function (Section 4) to the \"HELO\"
      identity as the\n   <sender>.  Checking \"HELO\" promotes consistency of results
      and can\n   reduce DNS resource usage.  If a conclusive determination about
      the\n   message can be made based on a check of \"HELO\", then the use of DNS\n
      \  resources to process the typically more complex \"MAIL FROM\" can be\n   avoided.
      \ Additionally, since SPF records published for \"HELO\"\n   identities refer
      to a single host, when available, they are a very\n   reliable source of host
      authorization status.  Checking \"HELO\" before\n   \"MAIL FROM\" is the RECOMMENDED
      sequence if both are checked.\n   Note that requirements for the domain presented
      in the EHLO or HELO\n   command are not always clear to the sending party, and
      SPF verifiers\n   have to be prepared for the identity to be an IP address literal
      (see\n   [RFC5321], Section 4.1.3) or simply be malformed.  This SPF check can\n
      \  only be performed when the \"HELO\" string is a valid, multi-label\n   domain
      name.\n"
    title: 2.3.  The "HELO" Identity
  - contents:
    - "2.4.  The \"MAIL FROM\" Identity\n   SPF verifiers MUST check the \"MAIL FROM\"
      identity if a \"HELO\" check\n   either has not been performed or has not reached
      a definitive policy\n   result by applying the check_host() function to the
      \"MAIL FROM\"\n   identity as the <sender>.\n   [RFC5321] allows the reverse-path
      to be null (see Section 4.5.5 in\n   [RFC5321]).  In this case, there is no
      explicit sender mailbox, and\n   such a message can be assumed to be a notification
      message from the\n   mail system itself.  When the reverse-path is null, this
      document\n   defines the \"MAIL FROM\" identity to be the mailbox composed of
      the\n   local-part \"postmaster\" and the \"HELO\" identity (which might or
      might\n   not have been checked separately before).\n"
    title: 2.4.  The "MAIL FROM" Identity
  - contents:
    - "2.5.  Location of Checks\n   The authorization check SHOULD be performed during
      the processing of\n   the SMTP transaction that receives the mail.  This reduces
      the\n   complexity of determining the correct IP address to use as an input\n
      \  to check_host() and allows errors to be returned directly to the\n   sending
      MTA by way of SMTP replies.  Appendix D of [RFC7001] provides\n   a more thorough
      discussion of this topic.\n   The authorization check is performed during the
      SMTP transaction at\n   the time of the MAIL command, and uses the MAIL FROM
      value and the\n   client IP address.  Performing the check at later times or
      with other\n   input can cause problems such as the following:\n   o  It might
      be difficult to accurately extract the required\n      information from potentially
      deceptive headers.\n   o  Legitimate email might fail the authorization check
      because the\n      sender's policy has since changed.\n   Generating non-delivery
      notifications to forged identities that have\n   failed the authorization check
      often constitutes backscatter, i.e.,\n   nuisance rejection notices that are
      not actionable.  Operators are\n   strongly advised to avoid such practices.
      \ Section 2 of [RFC3834]\n   describes backscatter and the problems it causes.\n"
    title: 2.5.  Location of Checks
  - contents:
    - "2.6.  Results of Evaluation\n   Section 4 defines check_host(), a model function
      definition that uses\n   the inputs defined above and the sender's policy published
      in the DNS\n   to reach a conclusion about client authorization.  An SPF verifier\n
      \  implements something semantically equivalent to the function defined\n   there.\n
      \  This section enumerates and briefly defines the possible outputs of\n   that
      function.  Note, however, that the protocol establishes no\n   normative requirements
      for handling any particular result.\n   Discussion of handling options for each
      result can be found in\n   Section 8.\n"
    - contents:
      - "2.6.1.  None\n   A result of \"none\" means either (a) no syntactically valid
        DNS domain\n   name was extracted from the SMTP session that could be used
        as the\n   one to be authorized, or (b) no SPF records were retrieved from\n
        \  the DNS.\n"
      title: 2.6.1.  None
    - contents:
      - "2.6.2.  Neutral\n   A \"neutral\" result means the ADMD has explicitly stated
        that it is\n   not asserting whether the IP address is authorized.\n"
      title: 2.6.2.  Neutral
    - contents:
      - "2.6.3.  Pass\n   A \"pass\" result is an explicit statement that the client
        is\n   authorized to inject mail with the given identity.\n"
      title: 2.6.3.  Pass
    - contents:
      - "2.6.4.  Fail\n   A \"fail\" result is an explicit statement that the client
        is not\n   authorized to use the domain in the given identity.\n"
      title: 2.6.4.  Fail
    - contents:
      - "2.6.5.  Softfail\n   A \"softfail\" result is a weak statement by the publishing
        ADMD that\n   the host is probably not authorized.  It has not published a\n
        \  stronger, more definitive policy that results in a \"fail\".\n"
      title: 2.6.5.  Softfail
    - contents:
      - "2.6.6.  Temperror\n   A \"temperror\" result means the SPF verifier encountered
        a transient\n   (generally DNS) error while performing the check.  A later
        retry may\n   succeed without further DNS operator action.\n"
      title: 2.6.6.  Temperror
    - contents:
      - "2.6.7.  Permerror\n   A \"permerror\" result means the domain's published
        records could not\n   be correctly interpreted.  This signals an error condition
        that\n   definitely requires DNS operator intervention to be resolved.\n"
      title: 2.6.7.  Permerror
    title: 2.6.  Results of Evaluation
  title: 2.  Operational Overview
- contents:
  - "3.  SPF Records\n   An SPF record is a DNS record that declares which hosts are,
    and are\n   not, authorized to use a domain name for the \"HELO\" and \"MAIL FROM\"\n
    \  identities.  Loosely, the record partitions hosts into permitted and\n   not-permitted
    sets (though some hosts might fall into neither\n   category).\n   The SPF record
    is expressed as a single string of text found in the\n   RDATA of a single DNS
    TXT resource record; multiple SPF records are\n   not permitted for the same owner
    name.  The record format and the\n   process for selecting records are described
    below in Section 4.  An\n   example record is the following:\n      v=spf1 +mx
    a:colo.example.com/28 -all\n   This record has a version of \"spf1\" and three
    directives: \"+mx\",\n   \"a:colo.example.com/28\" (the \"+\" is implied), and
    \"-all\".\n   Each SPF record is placed in the DNS tree at the owner name it\n
    \  pertains to, not in a subdomain under the owner name.  This is\n   similar
    to how SRV records [RFC2782] are done.\n   The example in this section might be
    published via these lines in a\n   domain zone file:\n      example.com.          TXT
    \"v=spf1 +mx a:colo.example.com/28 -all\"\n   Since TXT records have multiple
    uses, beware of other TXT records\n   published there for other purposes.  They
    might cause problems with\n   size limits (see Section 3.4), and care has to be
    taken to ensure\n   that only SPF records are used for SPF processing.\n   ADMDs
    publishing SPF records ought to keep the amount of DNS\n   information needed
    to evaluate a record to a minimum.  Sections 4.6.4\n   and 10.1.1 provide some
    suggestions about \"include\" mechanisms and\n   chained \"redirect\" modifiers.\n"
  - contents:
    - "3.1.  DNS Resource Records\n   SPF records MUST be published as a DNS TXT (type
      16) Resource Record\n   (RR) [RFC1035] only.  The character content of the record
      is encoded\n   as [US-ASCII].  Use of alternative DNS RR types was supported
      in\n   SPF's experimental phase but has been discontinued.\n   In 2003, when
      SPF was first being developed, the requirements for\n   assignment of a new
      DNS RR type were considerably more stringent than\n   they are now.  Additionally,
      support for easy deployment of new DNS\n   RR types was not widely deployed
      in DNS servers and provisioning\n   systems.  As a result, developers of SPF
      found it easier and more\n   practical to use the TXT RR type for SPF records.\n
      \  In its review of [RFC4408], the SPFbis working group concluded that\n   its
      dual RR type transition model was fundamentally flawed since it\n   contained
      no common RR type that implementers were required to serve\n   and required
      to check.  Many alternatives were considered to resolve\n   this issue, but
      ultimately the working group concluded that\n   significant migration to the
      SPF RR type in the foreseeable future\n   was very unlikely and that the best
      solution for resolving this\n   interoperability issue was to drop support for
      the SPF RR type from\n   SPF version 1.  See Appendix A of [RFC6686] for further
      information.\n   The circumstances surrounding SPF's initial deployment a decade
      ago\n   are unique.  If a future update to SPF were developed that did not\n
      \  reuse existing SPF records, it could use the SPF RR type.  SPF's use\n   of
      the TXT RR type for structured data should in no way be taken as\n   precedent
      for future protocol designers.  Further discussion of\n   design considerations
      when using new DNS RR types can be found in\n   [RFC5507].\n"
    title: 3.1.  DNS Resource Records
  - contents:
    - "3.2.  Multiple DNS Records\n   A domain name MUST NOT have multiple records
      that would cause an\n   authorization check to select more than one record.
      \ See Section 4.5\n   for the selection rules.\n"
    title: 3.2.  Multiple DNS Records
  - contents:
    - "3.3.  Multiple Strings in a Single DNS Record\n   As defined in [RFC1035],
      Sections 3.3 and 3.3.14, a single text DNS\n   record can be composed of more
      than one string.  If a published\n   record contains multiple character-strings,
      then the record MUST be\n   treated as if those strings are concatenated together
      without adding\n   spaces.  For example:\n      IN TXT \"v=spf1 .... first\"
      \"second string...\"\n   is equivalent to:\n      IN TXT \"v=spf1 .... firstsecond
      string...\"\n   TXT records containing multiple strings are useful in constructing\n
      \  records that would exceed the 255-octet maximum length of a\n   character-string
      within a single TXT record.\n"
    title: 3.3.  Multiple Strings in a Single DNS Record
  - contents:
    - "3.4.  Record Size\n   The published SPF record for a given domain name SHOULD
      remain small\n   enough that the results of a query for it will fit within 512
      octets.\n   Otherwise, there is a possibility of exceeding a DNS protocol limit.\n
      \  This UDP limit is defined in [RFC1035], Section 2.3.4, although it\n   was
      raised by [RFC2671].  Staying below 512 octets ought to prevent\n   older DNS
      implementations from failing over to TCP and will work with\n   UDP in the absence
      of EDNS0 [RFC6891] support.  Since the answer size\n   is dependent on many
      things outside the scope of this document, it is\n   only possible to give this
      guideline: If the size of the DNS message,\n   the combined length of the DNS
      name and the text of all the records\n   of a given type is under 450 octets,
      then DNS answers ought to fit in\n   UDP packets.  Records that are too long
      to fit in a single UDP packet\n   could be silently ignored by SPF verifiers
      due to firewall and other\n   issues that interfere with the operation of DNS
      over TCP or using\n   ENDS0.\n   Note that when computing the sizes for replies
      to queries of the TXT\n   format, one has to take into account any other TXT
      records published\n   at the domain name.  Similarly, the sizes for replies
      to all queries\n   related to SPF have to be evaluated to fit in a single 512-octet
      UDP\n   packet (i.e., DNS message size limited to 450 octets).\n"
    title: 3.4.  Record Size
  - contents:
    - "3.5.  Wildcard Records\n   Use of wildcard records for publishing is discouraged,
      and care has\n   to be taken if they are used.  If a zone includes wildcard
      MX\n   records, it might want to publish wildcard declarations, subject to\n
      \  the same requirements and problems.  In particular, the declaration\n   MUST
      be repeated for any host that has any RR records at all, and for\n   subdomains
      thereof.  Consider the example in [RFC1034],\n   Section 4.3.3.  Based on that,
      we can do the following:\n      EXAMPLE.COM.          MX      10      A.EXAMPLE.COM\n
      \     EXAMPLE.COM.          TXT     \"v=spf1 a:A.EXAMPLE.COM -all\"\n      *.EXAMPLE.COM.
      \       MX      10      A.EXAMPLE.COM\n      *.EXAMPLE.COM.        TXT     \"v=spf1
      a:A.EXAMPLE.COM -all\"\n      A.EXAMPLE.COM.        A       203.0.113.1\n      A.EXAMPLE.COM.
      \       MX      10      A.EXAMPLE.COM\n      A.EXAMPLE.COM.        TXT     \"v=spf1
      a:A.EXAMPLE.COM -all\"\n      *.A.EXAMPLE.COM.      MX      10      A.EXAMPLE.COM\n
      \     *.A.EXAMPLE.COM.      TXT     \"v=spf1 a:A.EXAMPLE.COM -all\"\n   SPF
      records have to be listed twice for every name within the zone:\n   once for
      the name, and once with a wildcard to cover the tree under\n   the name, in
      order to cover all domains in use in outgoing mail.\n"
    title: 3.5.  Wildcard Records
  title: 3.  SPF Records
- contents:
  - "4.  The check_host() Function\n   This description is not an application programming
    interface\n   definition, but rather a function description used to illustrate
    the\n   algorithm.  A compliant SPF implementation MUST produce results\n   semantically
    equivalent to this description.\n   The check_host() function fetches SPF records,
    parses them, and\n   evaluates them to determine whether a particular host is
    or is not\n   permitted to send mail with a given identity.  Receiving ADMDs that\n
    \  perform this check MUST correctly evaluate the check_host() function\n   as
    described here.\n   Implementations MAY use a different algorithm than the canonical\n
    \  algorithm defined here, so long as the results are the same in all\n   cases.\n"
  - contents:
    - "4.1.  Arguments\n   The check_host() function takes these arguments:\n   <ip>
      \    - the IP address of the SMTP client that is emitting\n              the
      mail, either IPv4 or IPv6.\n   <domain> - the domain that provides the sought-after
      authorization\n              information; initially, the domain portion of the\n
      \             \"MAIL FROM\" or \"HELO\" identity.\n   <sender> - the \"MAIL
      FROM\" or \"HELO\" identity.\n   For recursive evaluations, the domain portion
      of <sender> might not\n   be the same as the <domain> argument when check_host()
      is initially\n   evaluated.  In most other cases it will be the same (see Section
      5.2\n   below).  The overall DNS lookup limit for SPF terms described below\n
      \  in Section 4.6.4 must be tracked as a single global limit for all\n   evaluations,
      not just for a single instance of a recursive\n   evaluation.\n   Note that
      the <domain> argument might not be a well-formed domain\n   name.  For example,
      if the reverse-path was null, then the EHLO/HELO\n   domain is used, with its
      associated problems (see Section 2.3).  In\n   these cases, check_host() is
      defined in Section 4.3 to return a\n   \"none\" result.\n"
    title: 4.1.  Arguments
  - contents:
    - "4.2.  Results\n   The check_host() function can return one of several results
      described\n   in Section 2.6.  Based on the result, the action to be taken is\n
      \  determined by the local policies of the receiver.  This is discussed\n   in
      Section 8.\n"
    title: 4.2.  Results
  - contents:
    - "4.3.  Initial Processing\n   If the <domain> is malformed (e.g., label longer
      than 63 characters,\n   zero-length label not at the end, etc.) or is not a
      multi-label\n   domain name, or if the DNS lookup returns \"Name Error\" (RCODE
      3, also\n   known as \"NXDOMAIN\" [RFC2308]), check_host() immediately returns
      the\n   result \"none\".  DNS RCODEs are defined in [RFC1035].  Properly formed\n
      \  domains are fully qualified domains as defined in [RFC1983].  That\n   is,
      in the DNS they are implicitly qualified relative to the root\n   (see Section
      3.1 of [RFC1034]).  Internationalized domain names MUST\n   be encoded as A-labels,
      as described in Section 2.3 of [RFC5890].\n   If the <sender> has no local-part,
      substitute the string \"postmaster\"\n   for the local-part.\n"
    title: 4.3.  Initial Processing
  - contents:
    - "4.4.  Record Lookup\n   In accordance with how the records are published (see
      Section 3\n   above), a DNS query needs to be made for the <domain> name, querying\n
      \  for type TXT only.\n   If the DNS lookup returns a server failure (RCODE
      2) or some other\n   error (RCODE other than 0 or 3), or if the lookup times
      out, then\n   check_host() terminates immediately with the result \"temperror\".\n"
    title: 4.4.  Record Lookup
  - contents:
    - "4.5.  Selecting Records\n   Records begin with a version section:\n   record
      \          = version terms *SP\n   version          = \"v=spf1\"\n   Starting
      with the set of records that were returned by the lookup,\n   discard records
      that do not begin with a version section of exactly\n   \"v=spf1\".  Note that
      the version section is terminated by either an\n   SP character or the end of
      the record.  As an example, a record with\n   a version section of \"v=spf10\"
      does not match and is discarded.\n   If the resultant record set includes no
      records, check_host()\n   produces the \"none\" result.  If the resultant record
      set includes\n   more than one record, check_host() produces the \"permerror\"
      result.\n"
    title: 4.5.  Selecting Records
  - contents:
    - "4.6.  Record Evaluation\n   The check_host() function parses and interprets
      the SPF record to\n   find a result for the current test.  The syntax of the
      record is\n   validated first, and if there are any syntax errors anywhere in
      the\n   record, check_host() returns immediately with the result \"permerror\",\n
      \  without further interpretation or evaluation.\n"
    - contents:
      - "4.6.1.  Term Evaluation\n   There are two types of terms: mechanisms (defined
        in Section 5) and\n   modifiers (defined in Section 6).  A record contains
        an ordered list\n   of these as specified in the following Augmented Backus-Naur
        Form\n   (ABNF).\n   terms            = *( 1*SP ( directive / modifier ) )\n
        \  directive        = [ qualifier ] mechanism\n   qualifier        = \"+\"
        / \"-\" / \"?\" / \"~\"\n   mechanism        = ( all / include\n                      /
        a / mx / ptr / ip4 / ip6 / exists )\n   modifier         = redirect / explanation
        / unknown-modifier\n   unknown-modifier = name \"=\" macro-string\n                      ;
        where name is not any known modifier\n   name             = ALPHA *( ALPHA
        / DIGIT / \"-\" / \"_\" / \".\" )\n   Most mechanisms allow a \":\" or \"/\"
        character after the name.\n   Modifiers always contain an equals ('=') character
        immediately after\n   the name, and before any \":\" or \"/\" characters that
        might be part of\n   the macro-string.\n   Terms that do not contain any of
        \"=\", \":\", or \"/\" are mechanisms, as\n   defined in Section 5.\n   As
        per the definition of the ABNF notation in [RFC5234], mechanism\n   and modifier
        names are case-insensitive.\n"
      title: 4.6.1.  Term Evaluation
    - contents:
      - "4.6.2.  Mechanisms\n   Each mechanism is considered in turn from left to
        right.  If there\n   are no more mechanisms, the result is the default result
        as described\n   in Section 4.7.\n   When a mechanism is evaluated, one of
        three things can happen: it can\n   match, not match, or return an exception.\n
        \  If it matches, processing ends and the qualifier value is returned as\n
        \  the result of that record.  If it does not match, processing\n   continues
        with the next mechanism.  If it returns an exception,\n   mechanism processing
        ends and the exception value is returned.\n   The possible qualifiers, and
        the results they cause check_host() to\n   return, are as follows:\n      \"+\"
        pass\n      \"-\" fail\n      \"~\" softfail\n      \"?\" neutral\n   The
        qualifier is optional and defaults to \"+\".\n   When a mechanism matches
        and the qualifier is \"-\", then a \"fail\"\n   result is returned and the
        explanation string is computed as\n   described in Section 6.2.\n   The specific
        mechanisms are described in Section 5.\n"
      title: 4.6.2.  Mechanisms
    - contents:
      - "4.6.3.  Modifiers\n   Modifiers are not mechanisms.  They do not return match
        or not-match.\n   Instead, they provide additional information.  Although
        modifiers do\n   not directly affect the evaluation of the record, the \"redirect\"\n
        \  modifier has an effect after all the mechanisms have been evaluated.\n"
      title: 4.6.3.  Modifiers
    - contents:
      - "4.6.4.  DNS Lookup Limits\n   Some mechanisms and modifiers (collectively,
        \"terms\") cause DNS\n   queries at the time of evaluation, and some do not.
        \ The following\n   terms cause DNS queries: the \"include\", \"a\", \"mx\",
        \"ptr\", and\n   \"exists\" mechanisms, and the \"redirect\" modifier.  SPF\n
        \  implementations MUST limit the total number of those terms to 10\n   during
        SPF evaluation, to avoid unreasonable load on the DNS.  If\n   this limit
        is exceeded, the implementation MUST return \"permerror\".\n   The other terms
        -- the \"all\", \"ip4\", and \"ip6\" mechanisms, and the\n   \"exp\" modifier
        -- do not cause DNS queries at the time of SPF\n   evaluation (the \"exp\"
        modifier only causes a lookup at a later time),\n   and their use is not subject
        to this limit.\n   When evaluating the \"mx\" mechanism, the number of \"MX\"
        resource\n   records queried is included in the overall limit of 10 mechanisms/\n
        \  modifiers that cause DNS lookups as described above.  In addition to\n
        \  that limit, the evaluation of each \"MX\" record MUST NOT result in\n   querying
        more than 10 address records -- either \"A\" or \"AAAA\"\n   resource records.
        \ If this limit is exceeded, the \"mx\" mechanism MUST\n   produce a \"permerror\"
        result.\n   When evaluating the \"ptr\" mechanism or the %{p} macro, the number
        of\n   \"PTR\" resource records queried is included in the overall limit of
        10\n   mechanisms/modifiers that cause DNS lookups as described above.  In\n
        \  addition to that limit, the evaluation of each \"PTR\" record MUST NOT\n
        \  result in querying more than 10 address records -- either \"A\" or\n   \"AAAA\"
        resource records.  If this limit is exceeded, all records\n   other than the
        first 10 MUST be ignored.\n   The reason for the disparity is that the set
        of and contents of the\n   MX record are under control of the publishing ADMD,
        while the set of\n   and contents of PTR records are under control of the
        owner of the IP\n   address actually making the connection.\n   These limits
        are per mechanism or macro in the record, and are in\n   addition to the lookup
        limits specified above.\n   MTAs or other processors SHOULD impose a limit
        on the maximum amount\n   of elapsed time to evaluate check_host().  Such
        a limit SHOULD allow\n   at least 20 seconds.  If such a limit is exceeded,
        the result of\n   authorization SHOULD be \"temperror\".\n   As described
        at the end of Section 11.1, there may be cases where it\n   is useful to limit
        the number of \"terms\" for which DNS queries return\n   either a positive
        answer (RCODE 0) with an answer count of 0, or a\n   \"Name Error\" (RCODE
        3) answer.  These are sometimes collectively\n   referred to as \"void lookups\".
        \ SPF implementations SHOULD limit\n   \"void lookups\" to two.  An implementation
        MAY choose to make such a\n   limit configurable.  In this case, a default
        of two is RECOMMENDED.\n   Exceeding the limit produces a \"permerror\" result.\n"
      title: 4.6.4.  DNS Lookup Limits
    title: 4.6.  Record Evaluation
  - contents:
    - "4.7.  Default Result\n   If none of the mechanisms match and there is no \"redirect\"
      modifier,\n   then the check_host() returns a result of \"neutral\", just as
      if\n   \"?all\" were specified as the last directive.  If there is a\n   \"redirect\"
      modifier, check_host() proceeds as defined in Section 6.1.\n   It is better
      to use either a \"redirect\" modifier or an \"all\"\n   mechanism to explicitly
      terminate processing.  Although there is an\n   implicit \"?all\" at the end
      of every record that is not explicitly\n   terminated, it aids debugging efforts
      when it is explicitly provided.\n   For example:\n      v=spf1 +mx -all\n   or\n
      \     v=spf1 +mx redirect=_spf.example.com\n"
    title: 4.7.  Default Result
  - contents:
    - "4.8.  Domain Specification\n   Several of these mechanisms and modifiers have
      a <domain-spec>\n   section.  The <domain-spec> string is subject to macro expansion
      (see\n   Section 7).  The resulting string is the common presentation form of\n
      \  a fully qualified DNS name: a series of labels separated by periods.\n   This
      domain is called the <target-name> in the rest of this document.\n   Note: The
      result of the macro expansion is not subject to any further\n   escaping.  Hence,
      this facility cannot produce all characters that\n   are legal in a DNS label
      (e.g., the control characters).  However,\n   this facility is powerful enough
      to express legal host names and\n   common utility labels (such as \"_spf\")
      that are used in DNS.\n   For several mechanisms, the <domain-spec> is optional.
      \ If it is not\n   provided, the <domain> from the check_host() arguments (see\n
      \  Section 4.1) is used as the <target-name>.  \"domain\" and\n   <domain-spec>
      are syntactically identical after macro expansion.\n   \"domain\" is an input
      value for check_host(), while <domain-spec> is\n   computed by check_host().\n
      \  The result of evaluating check_host() with a syntactically invalid\n   domain
      is undefined.\n   Note: This document and its predecessors make no provisions
      for\n   defining correct handling of a syntactically invalid <domain-spec>\n
      \  (which might be the result of macro expansion), per [RFC1035].\n   Examples
      include names with empty labels, such as \"foo..example.com\",\n   and labels
      that are longer than 63 characters.  Some implementations\n   choose to treat
      such errors as not-match and therefore ignore such\n   names, while others return
      a \"permerror\" exception.\n"
    title: 4.8.  Domain Specification
  title: 4.  The check_host() Function
- contents:
  - "5.  Mechanism Definitions\n   This section defines two types of mechanisms: basic
    language\n   framework mechanisms and designated sender mechanisms.\n   Basic
    mechanisms contribute to the language framework.  They do not\n   specify a particular
    type of authorization scheme.  The basic\n   mechanisms are as follows:\n      all\n
    \     include\n   Designated sender mechanisms are used to identify a set of <ip>\n
    \  addresses as being permitted or not permitted to use the <domain> for\n   sending
    mail.  The designated sender mechanisms are as follows:\n      a\n      mx\n      ptr
    (do not use)\n      ip4\n      ip6\n      exists\n   The following conventions
    apply to all mechanisms that perform a\n   comparison between <ip> and an IP address
    at any point:\n   If no CIDR prefix length is given in the directive, then <ip>
    and the\n   IP address are compared for equality.  (Here, CIDR is Classless\n
    \  Inter-Domain Routing, described in [RFC4632].)\n   If a CIDR prefix length
    is specified, then only the specified number\n   of high-order bits of <ip> and
    the IP address are compared for\n   equality.\n   When any mechanism fetches host
    addresses to compare with <ip>, when\n   <ip> is an IPv4, \"A\" records are fetched;
    when <ip> is an IPv6\n   address, \"AAAA\" records are fetched.  SPF implementations
    on IPv6\n   servers need to handle both \"AAAA\" and \"A\" records, for clients
    on\n   IPv4-mapped IPv6 addresses [RFC4291].  IPv4 <ip> addresses are only\n   listed
    in an SPF record using the \"ip4\" mechanism.\n   Several mechanisms rely on information
    fetched from the DNS.  For\n   these DNS queries, except where noted, if the DNS
    server returns an\n   error (RCODE other than 0 or 3) or the query times out,
    the mechanism\n   stops and the topmost check_host() returns \"temperror\".  If
    the\n   server returns \"Name Error\" (RCODE 3), then evaluation of the\n   mechanism
    continues as if the server returned no error (RCODE 0) and\n   zero answer records.\n"
  - contents:
    - "5.1.  \"all\"\n   all              = \"all\"\n   The \"all\" mechanism is a
      test that always matches.  It is used as the\n   rightmost mechanism in a record
      to provide an explicit default.\n   For example:\n      v=spf1 a mx -all\n   Mechanisms
      after \"all\" will never be tested.  Mechanisms listed after\n   \"all\" MUST
      be ignored.  Any \"redirect\" modifier (Section 6.1) MUST be\n   ignored when
      there is an \"all\" mechanism in the record, regardless of\n   the relative
      ordering of the terms.\n"
    title: 5.1.  "all"
  - contents:
    - "5.2.  \"include\"\n   include          = \"include\"  \":\" domain-spec\n   The
      \"include\" mechanism triggers a recursive evaluation of\n   check_host().\n
      \  1.  The <domain-spec> is expanded as per Section 7.\n   2.  check_host()
      is evaluated with the resulting string as the\n       <domain>.  The <ip> and
      <sender> arguments remain the same as in\n       the current evaluation of check_host().\n
      \  3.  The recursive evaluation returns match, not-match, or an error.\n   4.
      \ If it returns match, then the appropriate result for the\n       \"include\"
      mechanism is used (e.g., include or +include produces a\n       \"pass\" result
      and -include produces \"fail\").\n   5.  If it returns not-match or an error,
      the parent check_host()\n       resumes processing as per the table below, with
      the previous\n       value of <domain> restored.\n   In hindsight, the name
      \"include\" was poorly chosen.  Only the\n   evaluated result of the referenced
      SPF record is used, rather than\n   literally including the mechanisms of the
      referenced record in the\n   first.  For example, evaluating a \"-all\" directive
      in the referenced\n   record does not terminate the overall processing and does
      not\n   necessarily result in an overall \"fail\".  (Better names for this\n
      \  mechanism would have been \"if-match\", \"on-match\", etc.)\n   The \"include\"
      mechanism makes it possible for one domain to designate\n   multiple administratively
      independent domains.  For example, a vanity\n   domain \"example.net\" might
      send mail using the servers of\n   administratively independent domains example.com
      and example.org.\n   Example.net could say\n      IN TXT \"v=spf1 include:example.com
      include:example.org -all\"\n   This would direct check_host() to, in effect,
      check the records of\n   example.com and example.org for a \"pass\" result.
      \ Only if the host\n   were not permitted for either of those domains would
      the result be\n   \"fail\".\n   Whether this mechanism matches, does not match,
      or returns an\n   exception depends on the result of the recursive evaluation
      of\n   check_host():\n   +---------------------------------+---------------------------------+\n
      \  | A recursive check_host() result | Causes the \"include\" mechanism  |\n
      \  | of:                             | to:                             |\n   +---------------------------------+---------------------------------+\n
      \  | pass                            | match                           |\n   |
      \                                |                                 |\n   | fail
      \                           | not match                       |\n   |                                 |
      \                                |\n   | softfail                        | not
      match                       |\n   |                                 |                                 |\n
      \  | neutral                         | not match                       |\n   |
      \                                |                                 |\n   | temperror
      \                      | return temperror                |\n   |                                 |
      \                                |\n   | permerror                       | return
      permerror                |\n   |                                 |                                 |\n
      \  | none                            | return permerror                |\n   +---------------------------------+---------------------------------+\n
      \  The \"include\" mechanism is intended for crossing administrative\n   boundaries.
      \ When remaining within one administrative authority,\n   \"include\" is usually
      not the best choice.  For example, if\n   example.com and example.org were managed
      by the same entity, and if\n   the permitted set of hosts for both domains was
      \"mx:example.com\", it\n   would be possible for example.org to specify \"include:example.com\",\n
      \  but it would be preferable to specify \"redirect=example.com\" or even\n
      \  \"mx:example.com\".\n   With the \"include\" mechanism, an administratively
      external set of\n   hosts can be authorized, but determination of sender policy
      is still\n   a function of the original domain's SPF record (as determined by
      the\n   \"all\" mechanism in that record).  The \"redirect\" modifier is more\n
      \  suitable for consolidating both authorizations and policy into a\n   common
      set to be shared within an ADMD.  Redirect is much more like a\n   common code
      element to be shared among records in a single ADMD.  It\n   is possible to
      control both authorized hosts and policy for an\n   arbitrary number of domains
      from a single record.\n"
    title: 5.2.  "include"
  - contents:
    - "5.3.  \"a\"\n   This mechanism matches if <ip> is one of the <target-name>'s
      IP\n   addresses.  For clarity, this means the \"a\" mechanism also matches\n
      \  AAAA records.\n   a                = \"a\"      [ \":\" domain-spec ] [ dual-cidr-length
      ]\n   An address lookup is done on the <target-name> using the type of\n   lookup
      (A or AAAA) appropriate for the connection type (IPv4 or\n   IPv6).  The <ip>
      is compared to the returned address(es).  If any\n   address matches, the mechanism
      matches.\n"
    title: 5.3.  "a"
  - contents:
    - "5.4.  \"mx\"\n   This mechanism matches if <ip> is one of the MX hosts for
      a domain\n   name.\n   mx               = \"mx\"     [ \":\" domain-spec ] [
      dual-cidr-length ]\n   check_host() first performs an MX lookup on the <target-name>.
      \ Then\n   it performs an address lookup on each MX name returned.  The <ip>
      is\n   compared to each returned IP address.  To prevent denial-of-service\n
      \  (DoS) attacks, the processing limits defined in Section 4.6.4 MUST be\n   followed.
      \ If the MX lookup limit is exceeded, then \"permerror\" is\n   returned and
      the evaluation is terminated.  If any address matches,\n   the mechanism matches.\n
      \  Note regarding implicit MXes: If the <target-name> has no MX record,\n   check_host()
      MUST NOT apply the implicit MX rules of [RFC5321] by\n   querying for an A or
      AAAA record for the same name.\n"
    title: 5.4.  "mx"
  - contents:
    - "5.5.  \"ptr\" (do not use)\n   This mechanism tests whether the DNS reverse-mapping
      for <ip> exists\n   and correctly points to a domain name within a particular
      domain.\n   This mechanism SHOULD NOT be published.  See the note at the end
      of\n   this section for more information.\n   ptr              = \"ptr\"    [
      \":\" domain-spec ]\n   The <ip>'s name is looked up using this procedure:\n
      \  o  Perform a DNS reverse-mapping for <ip>: Look up the corresponding\n      PTR
      record in \"in-addr.arpa.\" if the address is an IPv4 address\n      and in
      \"ip6.arpa.\" if it is an IPv6 address.\n   o  For each record returned, validate
      the domain name by looking up\n      its IP addresses.  To prevent DoS attacks,
      the PTR processing\n      limits defined in Section 4.6.4 MUST be applied.  If
      they are\n      exceeded, processing is terminated and the mechanism does not\n
      \     match.\n   o  If <ip> is among the returned IP addresses, then that domain
      name\n      is validated.\n   Check all validated domain names to see if they
      either match the\n   <target-name> domain or are a subdomain of the <target-name>
      domain.\n   If any do, this mechanism matches.  If no validated domain name
      can\n   be found, or if none of the validated domain names match or are a\n
      \  subdomain of the <target-name>, this mechanism fails to match.  If a\n   DNS
      error occurs while doing the PTR RR lookup, then this mechanism\n   fails to
      match.  If a DNS error occurs while doing an A RR lookup,\n   then that domain
      name is skipped and the search continues.\n   This mechanism matches if\n   o
      \ the <target-name> is a subdomain of a validated domain name, or\n   o  the
      <target-name> and a validated domain name are the same.\n   For example, \"mail.example.com\"
      is within the domain \"example.com\",\n   but \"mail.bad-example.com\" is not.\n
      \  Note: This mechanism is slow, it is not as reliable as other\n   mechanisms
      in cases of DNS errors, and it places a large burden on\n   the .arpa name servers.
      \ If used, proper PTR records have to be in\n   place for the domain's hosts
      and the \"ptr\" mechanism SHOULD be one of\n   the last mechanisms checked.
      \ After many years of SPF deployment\n   experience, it has been concluded that
      it is unnecessary and more\n   reliable alternatives should be used instead.
      \ It is, however, still\n   in use as part of the SPF protocol, so compliant
      check_host()\n   implementations MUST support it.\n"
    title: 5.5.  "ptr" (do not use)
  - contents:
    - "5.6.  \"ip4\" and \"ip6\"\n   These mechanisms test whether <ip> is contained
      within a given\n   IP network.\n   ip4              = \"ip4\"      \":\" ip4-network
      \  [ ip4-cidr-length ]\n   ip6              = \"ip6\"      \":\" ip6-network
      \  [ ip6-cidr-length ]\n   ip4-cidr-length  = \"/\" (\"0\" / %x31-39 0*1DIGIT)
      ; value range 0-32\n   ip6-cidr-length  = \"/\" (\"0\" / %x31-39 0*2DIGIT) ;
      value range 0-128\n   dual-cidr-length = [ ip4-cidr-length ] [ \"/\" ip6-cidr-length
      ]\n   ip4-network      = qnum \".\" qnum \".\" qnum \".\" qnum\n   qnum             =
      DIGIT                 ; 0-9\n                      / %x31-39 DIGIT       ; 10-99\n
      \                     / \"1\" 2DIGIT          ; 100-199\n                      /
      \"2\" %x30-34 DIGIT   ; 200-249\n                      / \"25\" %x30-35        ;
      250-255\n            ; as per conventional dotted-quad notation, e.g., 192.0.2.0\n
      \  ip6-network      = <as per Section 2.2 of [RFC4291]>\n            ; e.g.,
      2001:db8::cd30\n   The <ip> is compared to the given network.  If CIDR prefix
      length\n   high-order bits match, the mechanism matches.\n   If ip4-cidr-length
      is omitted, it is taken to be \"/32\".  If\n   ip6-cidr-length is omitted, it
      is taken to be \"/128\".  It is not\n   permitted to omit parts of the IP address
      instead of using CIDR\n   notations.  That is, use 192.0.2.0/24 instead of 192.0.2.\n"
    title: 5.6.  "ip4" and "ip6"
  - contents:
    - "5.7.  \"exists\"\n   This mechanism is used to construct an arbitrary domain
      name that is\n   used for a DNS A record query.  It allows for complicated schemes\n
      \  involving arbitrary parts of the mail envelope to determine what is\n   permitted.\n
      \  exists           = \"exists\"   \":\" domain-spec\n   The <domain-spec> is
      expanded as per Section 7.  The resulting domain\n   name is used for a DNS
      A RR lookup (even when the connection type is\n   IPv6).  If any A record is
      returned, this mechanism matches.\n   Domains can use this mechanism to specify
      arbitrarily complex\n   queries.  For example, suppose example.com publishes
      the record:\n      v=spf1 exists:%{ir}.%{l1r+-}._spf.%{d} -all\n   The <target-name>
      might expand to\n   \"1.2.0.192.someuser._spf.example.com\".  This makes fine-grained\n
      \  decisions possible at the level of the user and client IP address.\n"
    title: 5.7.  "exists"
  title: 5.  Mechanism Definitions
- contents:
  - "6.  Modifier Definitions\n   Modifiers are name/value pairs that provide additional
    information.\n   Modifiers always have an \"=\" separating the name and the value.\n
    \  The modifiers defined in this document (\"redirect\" and \"exp\") SHOULD\n
    \  appear at the end of the record, after all mechanisms, though\n   syntactically
    they can appear anywhere in the record.  Ordering of\n   these two modifiers does
    not matter.  These two modifiers MUST NOT\n   appear in a record more than once
    each.  If they do, then\n   check_host() exits with a result of \"permerror\".\n
    \  Unrecognized modifiers MUST be ignored no matter where, or how often,\n   they
    appear in a record.  This allows implementations conforming to\n   this document
    to gracefully handle records with modifiers that are\n   defined in other specifications.\n"
  - contents:
    - "6.1.  redirect: Redirected Query\n   The \"redirect\" modifier is intended
      for consolidating both\n   authorizations and policy into a common set to be
      shared within a\n   single ADMD.  It is possible to control both authorized
      hosts and\n   policy for an arbitrary number of domains from a single record.\n
      \  redirect         = \"redirect\" \"=\" domain-spec\n   If all mechanisms fail
      to match, and a \"redirect\" modifier is\n   present, then processing proceeds
      as follows:\n   The <domain-spec> portion of the redirect section is expanded
      as per\n   the macro rules in Section 7.  Then check_host() is evaluated with\n
      \  the resulting string as the <domain>.  The <ip> and <sender>\n   arguments
      remain the same as in the current evaluation of\n   check_host().\n   The result
      of this new evaluation of check_host() is then considered\n   the result of
      the current evaluation with the exception that if no\n   SPF record is found,
      or if the <target-name> is malformed, the result\n   is a \"permerror\" rather
      than \"none\".\n   Note that the newly queried domain can itself specify redirect\n
      \  processing.\n   This facility is intended for use by organizations that wish
      to apply\n   the same record to multiple domains.  For example:\n     la.example.com.
      TXT \"v=spf1 redirect=_spf.example.com\"\n     ny.example.com. TXT \"v=spf1
      redirect=_spf.example.com\"\n     sf.example.com. TXT \"v=spf1 redirect=_spf.example.com\"\n
      \  _spf.example.com. TXT \"v=spf1 mx:example.com -all\"\n   In this example,
      mail from any of the three domains is described by\n   the same record.  This
      can be an administrative advantage.\n   Note: In general, the domain \"A\" cannot
      reliably use a redirect to\n   another domain \"B\" not under the same administrative
      control.  Since\n   the <sender> stays the same, there is no guarantee that
      the record at\n   domain \"B\" will correctly work for mailboxes in domain \"A\",\n
      \  especially if domain \"B\" uses mechanisms involving local-parts.  An\n   \"include\"
      directive will generally be more appropriate.\n   For clarity, any \"redirect\"
      modifier SHOULD appear as the very last\n   term in a record.  Any \"redirect\"
      modifier MUST be ignored if there\n   is an \"all\" mechanism anywhere in the
      record.\n"
    title: '6.1.  redirect: Redirected Query'
  - contents:
    - "6.2.  exp: Explanation\n   explanation      = \"exp\" \"=\" domain-spec\n   If
      check_host() results in a \"fail\" due to a mechanism match (such as\n   \"-all\"),
      and the \"exp\" modifier is present, then the explanation\n   string returned
      is computed as described below.  If no \"exp\" modifier\n   is present, then
      either a default explanation string or an empty\n   explanation string MUST
      be returned to the calling application.\n   The <domain-spec> is macro expanded
      (see Section 7) and becomes the\n   <target-name>.  The DNS TXT RRset for the
      <target-name> is fetched.\n   If there are any DNS processing errors (any RCODE
      other than 0), or\n   if no records are returned, or if more than one record
      is returned,\n   or if there are syntax errors in the explanation string, then
      proceed\n   as if no \"exp\" modifier was given.\n   The fetched TXT record's
      strings are concatenated with no spaces, and\n   then treated as an explain-string,
      which is macro-expanded.  This\n   final result is the explanation string.  Implementations
      MAY limit\n   the length of the resulting explanation string to allow for other\n
      \  protocol constraints and/or reasonable processing limits.  Since the\n   explanation
      string is intended for an SMTP response and Section 2.4\n   of [RFC5321] says
      that responses are in [US-ASCII], the explanation\n   string MUST be limited
      to [US-ASCII].\n   Software evaluating check_host() can use this string to communicate\n
      \  information from the publishing domain in the form of a short message\n   or
      URL.  Software SHOULD make it clear that the explanation string\n   comes from
      a third party.  For example, it can prepend the macro\n   string \"%{o} explains:
      \" to the explanation, as shown in the example\n   in Section 8.4.\n   Suppose
      example.com has this record:\n      v=spf1 mx -all exp=explain._spf.%{d}\n   Here
      are some examples of possible explanation TXT records at\n   explain._spf.example.com:\n
      \     \"Mail from example.com should only be sent by its own servers.\"\n         --
      a simple, constant message\n      \"%{i} is not one of %{d}'s designated mail
      servers.\"\n         -- a message with a little more information, including
      the\n            IP address that failed the check\n      \"See http://%{d}/why.html?s=%{S}&i=%{I}\"\n
      \        -- a complicated example that constructs a URL with the\n            arguments
      to check_host() so that a web page can be\n            generated with detailed,
      custom instructions\n   Note: During recursion into an \"include\" mechanism,
      an \"exp\" modifier\n   from the <target-name> MUST NOT be used.  In contrast,
      when executing\n   a \"redirect\" modifier, an \"exp\" modifier from the original
      domain\n   MUST NOT be used.  This is because \"include\" is meant to cross\n
      \  administrative boundaries and the explanation provided should be the\n   one
      from the receiving ADMD, while \"redirect\" is meant to operate as\n   a tool
      to consolidate policy records within an ADMD so the redirected\n   explanation
      is the one that ought to have priority.\n"
    title: '6.2.  exp: Explanation'
  title: 6.  Modifier Definitions
- contents:
  - "7.  Macros\n   When evaluating an SPF policy record, certain character sequences
    are\n   intended to be replaced by parameters of the message or of the\n   connection.
    \ These character sequences are referred to as \"macros\".\n"
  - contents:
    - "7.1.  Formal Specification\n   The ABNF description for a macro is as follows:\n
      \  domain-spec      = macro-string domain-end\n   domain-end       = ( \".\"
      toplabel [ \".\" ] ) / macro-expand\n   toplabel         = ( *alphanum ALPHA
      *alphanum ) /\n                      ( 1*alphanum \"-\" *( alphanum / \"-\"
      ) alphanum )\n   alphanum         = ALPHA / DIGIT\n   explain-string   = *(
      macro-string / SP )\n   macro-string     = *( macro-expand / macro-literal )\n
      \  macro-expand     = ( \"%{\" macro-letter transformers *delimiter \"}\" )\n
      \                     / \"%%\" / \"%_\" / \"%-\"\n   macro-literal    = %x21-24
      / %x26-7E\n                      ; visible characters except \"%\"\n   macro-letter
      \    = \"s\" / \"l\" / \"o\" / \"d\" / \"i\" / \"p\" / \"h\" /\n                      \"c\"
      / \"r\" / \"t\" / \"v\"\n   transformers     = *DIGIT [ \"r\" ]\n   delimiter
      \       = \".\" / \"-\" / \"+\" / \",\" / \"/\" / \"_\" / \"=\"\n   The \"toplabel\"
      construction is subject to the letter-digit-hyphen\n   (LDH) rule plus additional
      top-level domain (TLD) restrictions.  See\n   Section 2 of [RFC3696] for background.\n
      \  Some special cases:\n   o  A literal \"%\" is expressed by \"%%\".\n   o
      \ \"%_\" expands to a single \" \" space.\n   o  \"%-\" expands to a URL-encoded
      space, viz., \"%20\".\n"
    title: 7.1.  Formal Specification
  - contents:
    - "7.2.  Macro Definitions\n   The following macro letters are expanded in term
      arguments:\n      s = <sender>\n      l = local-part of <sender>\n      o =
      domain of <sender>\n      d = <domain>\n      i = <ip>\n      p = the validated
      domain name of <ip> (do not use)\n      v = the string \"in-addr\" if <ip> is
      ipv4, or \"ip6\" if <ip> is ipv6\n      h = HELO/EHLO domain\n   <domain>, <sender>,
      and <ip> are defined in Section 4.1.\n   The following macro letters are allowed
      only in \"exp\" text:\n      c = SMTP client IP (easily readable format)\n      r
      = domain name of host performing the check\n      t = current timestamp\n"
    title: 7.2.  Macro Definitions
  - contents:
    - "7.3.  Macro Processing Details\n   A '%' character not followed by a '{', '%',
      '-', or '_' character is\n   a syntax error.  So:\n      -exists:%(ir).sbl.example.org\n
      \  is incorrect and will cause check_host() to yield a \"permerror\".\n   Instead,
      the following is legal:\n      -exists:%{ir}.sbl.example.org\n   Optional transformers
      are the following:\n      *DIGIT = zero or more digits\n      'r'    = reverse
      value, splitting on dots by default\n   If transformers or delimiters are provided,
      the replacement value for\n   a macro letter is split into parts separated by
      one or more of the\n   specified delimiter characters.  After performing any
      reversal\n   operation and/or removal of left-hand parts, the parts are rejoined\n
      \  using \".\" and not the original splitting characters.\n   By default, strings
      are split on \".\" (dots).  Note that no special\n   treatment is given to leading,
      trailing, or consecutive delimiters in\n   input strings, and so the list of
      parts might contain empty strings.\n   Some older implementations of SPF prohibit
      trailing dots in domain\n   names, so trailing dots SHOULD NOT be published,
      although they MUST\n   be accepted by implementations conforming to this document.
      \ Macros\n   can specify delimiter characters that are used instead of \".\".\n
      \  The \"r\" transformer indicates a reversal operation: if the client IP\n
      \  address were 192.0.2.1, the macro %{i} would expand to \"192.0.2.1\"\n   and
      the macro %{ir} would expand to \"1.2.0.192\".\n   The DIGIT transformer indicates
      the number of right-hand parts to\n   use, after optional reversal.  If a DIGIT
      is specified, the value\n   MUST be nonzero.  If no DIGITs are specified, or
      if the value\n   specifies more parts than are available, all the available
      parts are\n   used.  If the DIGIT was 5, and only 3 parts were available, the
      macro\n   interpreter would pretend the DIGIT was 3.  Implementations MUST\n
      \  support at least a value of 127, as that is the maximum number of\n   labels
      in a domain name (less the zero-length label at the end).\n   The \"s\" macro
      expands to the <sender> argument.  It is an email\n   address with a local-part,
      an \"@\" character, and a domain.  The \"l\"\n   macro expands to just the local-part.
      \ The \"o\" macro expands to just\n   the domain part.  Note that these values
      remain the same during\n   recursive and chained evaluations due to \"include\"
      and/or \"redirect\".\n   Note also that if the original <sender> had no local-part,
      the\n   local-part was set to \"postmaster\" in initial processing (see\n   Section
      4.3).\n   For IPv4 addresses, both the \"i\" and \"c\" macros expand to the\n
      \  standard dotted-quad format.\n   For IPv6 addresses, the \"i\" macro expands
      to a dot-format address; it\n   is intended for use in %{ir}.  The \"c\" macro
      can expand to any of the\n   hexadecimal colon-format addresses specified in
      Section 2.2 of\n   [RFC4291].  It is intended for humans to read.\n   The \"p\"
      macro expands to the validated domain name of <ip>.  The\n   procedure for finding
      the validated domain name is defined in\n   Section 5.5.  If the <domain> is
      present in the list of validated\n   domains, it SHOULD be used.  Otherwise,
      if a subdomain of the\n   <domain> is present, it SHOULD be used.  Otherwise,
      any name from the\n   list can be used.  If there are no validated domain names
      or if a DNS\n   error occurs, the string \"unknown\" is used.\n   This macro
      SHOULD NOT be published (see Section 5.5 for the\n   discussion).\n   The \"h\"
      macro expands to the parameter that was provided to the SMTP\n   server via
      the HELO or EHLO SMTP verb.  For sessions where that verb\n   was provided more
      than once, the most recent instance is used.\n   The \"r\" macro expands to
      the name of the receiving MTA.  This SHOULD\n   be a fully qualified domain
      name, but if one does not exist (as when\n   the checking is done by a Mail
      User Agent (MUA)) or if policy\n   restrictions dictate otherwise, the word
      \"unknown\" SHOULD be\n   substituted.  The domain name can be different from
      the name found in\n   the MX record that the client MTA used to locate the receiving
      MTA.\n   The \"t\" macro expands to the decimal representation of the\n   approximate
      number of seconds since the Epoch (Midnight, January 1,\n   1970, UTC) at the
      time of the evaluation.  This is the same value as\n   the value that is returned
      by the Portable Operating System Interface\n   (POSIX) time() function in most
      standards-compliant libraries.\n   When the result of macro expansion is used
      in a domain name query, if\n   the expanded domain name exceeds 253 characters
      (the maximum length\n   of a domain name in this format), the left side is truncated
      to fit,\n   by removing successive domain labels (and their following dots)
      until\n   the total length does not exceed 253 characters.\n   Uppercase macros
      expand exactly as their lowercase equivalents, and\n   are then URL escaped.
      \ URL escaping MUST be performed for characters\n   not in the \"unreserved\"
      set, which is defined in [RFC3986].\n   Care has to be taken by the sending
      ADMD so that macro expansion for\n   legitimate email does not exceed the 63-character
      limit on DNS\n   labels.  The local-part of email addresses, in particular,
      can have\n   more than 63 characters between dots.\n   To minimize DNS lookup
      resource requirements, it is better if sending\n   ADMDs avoid using the \"s\",
      \"l\", \"o\", or \"h\" macros in conjunction\n   with any mechanism directive.
      \ Although these macros are powerful and\n   allow per-user records to be published,
      they severely limit the\n   ability of implementations to cache results of check_host()
      and they\n   reduce the effectiveness of DNS caches.\n   If no directive processed
      during the evaluation of check_host()\n   contains an \"s\", \"l\", \"o\", or
      \"h\" macro, then the results of the\n   evaluation can be cached on the basis
      of <domain> and <ip> alone for\n   as long as the DNS record involved with the
      shortest Time to Live\n   (TTL) has not expired.\n"
    title: 7.3.  Macro Processing Details
  - contents:
    - "7.4.  Expansion Examples\n   The <sender> is strong-bad@email.example.com.
      \ The IPv4 SMTP client\n   IP is 192.0.2.3.  The IPv6 SMTP client IP is 2001:db8::cb01.
      \ The PTR\n   domain name of the client IP is mx.example.org.\n   macro                       expansion\n
      \  -------  ----------------------------\n   %{s}     strong-bad@email.example.com\n
      \  %{o}                email.example.com\n   %{d}                email.example.com\n
      \  %{d4}               email.example.com\n   %{d3}               email.example.com\n
      \  %{d2}                     example.com\n   %{d1}                             com\n
      \  %{dr}               com.example.email\n   %{d2r}                  example.email\n
      \  %{l}                       strong-bad\n   %{l-}                      strong.bad\n
      \  %{lr}                      strong-bad\n   %{lr-}                     bad.strong\n
      \  %{l1r-}                        strong\n   macro-string                                               expansion\n
      \  --------------------------------------------------------------------\n   %{ir}.%{v}._spf.%{d2}
      \            3.2.0.192.in-addr._spf.example.com\n   %{lr-}.lp._spf.%{d2}                  bad.strong.lp._spf.example.com\n
      \  %{lr-}.lp.%{ir}.%{v}._spf.%{d2}\n                       bad.strong.lp.3.2.0.192.in-addr._spf.example.com\n
      \  %{ir}.%{v}.%{l1r-}.lp._spf.%{d2}\n                           3.2.0.192.in-addr.strong.lp._spf.example.com\n
      \  %{d2}.trusted-domains.example.net\n                                example.com.trusted-domains.example.net\n
      \  IPv6:\n   %{ir}.%{v}._spf.%{d2}                               1.0.b.c.0.0.0.0.\n
      \  0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6._spf.example.com\n"
    title: 7.4.  Expansion Examples
  title: 7.  Macros
- contents:
  - "8.  Result Handling\n   This section provides guidance for SPF verifier operators
    in response\n   to the various possible outputs of check_host() on a message.\n
    \  Definitions of SPF results are presented in Section 2.6; this section\n   provides
    more detail on each for use in developing local policy for\n   message handling.\n
    \  Every operating environment is different.  There are some receivers\n   for
    whom strict adherence to SPF is appropriate, and definitive\n   treatment of messages
    that are evaluated to be explicitly\n   unauthorized (\"fail\" and sometimes \"softfail\")
    is the norm.  There\n   are others for which the \"false negative\" cases are
    more of a\n   concern.  This concern is typically handled by merely recording
    the\n   result in the header and allowing the message to pass on for\n   additional
    processing.  There are still others where SPF is one of\n   several inputs to
    the message-handling decision.  As such, there is\n   no comprehensive normative
    requirement for message handling in\n   response to any particular result.  This
    section is provided to\n   present a complete picture of the likely cause of each
    result and,\n   where available, the experience gained during experimental\n   deployment.\n
    \  There are essentially two classes of handling choices:\n   o  Handling within
    the SMTP session that attempted to deliver the\n      message, such as by returning
    a permanent SMTP error (rejection)\n      or temporary SMTP error (\"try again
    later\");\n   o  Permitting the message to pass (a successful SMTP reply code)
    and\n      adding an additional header field that indicates the result\n      returned
    by check_host() and other salient details; this is\n      discussed in more detail
    in Section 9.\n"
  - contents:
    - "8.1.  None\n   With a \"none\" result, the SPF verifier has no information
      at all\n   about the authorization or lack thereof of the client to use the\n
      \  checked identity or identities.  The check_host() function completed\n   without
      errors but was not able to reach any conclusion.\n"
    title: 8.1.  None
  - contents:
    - "8.2.  Neutral\n   A \"neutral\" result indicates that although a policy for
      the identity\n   was discovered, there is no definite assertion (positive or
      negative)\n   about the client.\n   A \"neutral\" result MUST be treated exactly
      like the \"none\" result;\n   the distinction exists only for informational
      purposes.  Treating\n   \"neutral\" more harshly than \"none\" would discourage
      ADMDs from\n   testing the use of SPF records (see Section 10.1).\n"
    title: 8.2.  Neutral
  - contents:
    - "8.3.  Pass\n   A \"pass\" result means the client is authorized to inject mail
      with\n   the given identity.  The domain can now, in the sense of reputation,\n
      \  be considered responsible for sending the message.  Further policy\n   checks
      can now proceed with confidence in the legitimate use of the\n   identity.  This
      is further discussed in Appendix G.1.\n"
    title: 8.3.  Pass
  - contents:
    - "8.4.  Fail\n   A \"fail\" result is an explicit statement that the client is
      not\n   authorized to use the domain in the given identity.  Disposition of\n
      \  SPF fail messages is a matter of local policy.  See Appendix G.2 for\n   considerations
      on developing local policy.\n   If the checking software chooses to reject the
      mail during the SMTP\n   transaction, then it SHOULD use an SMTP reply code
      of 550 (see\n   [RFC5321]) and, if supported, the 5.7.1 enhanced status code
      (see\n   [RFC3463], Section 3.8), in addition to an appropriate reply text.\n
      \  The check_host() function will return either a default explanation\n   string
      or one from the domain that published the SPF records (see\n   Section 6.2).
      \ If the information does not originate with the\n   checking software, it is
      good to make it clear that the text is\n   provided by the sender's domain.
      \ For example:\n       550 5.7.1 SPF MAIL FROM check failed:\n       550 5.7.1
      The domain example.com explains:\n       550 5.7.1 Please see http://www.example.com/mailpolicy.html\n
      \  If the checking software chooses not to reject the mail during the\n   SMTP
      transaction, then it SHOULD add a Received-SPF or\n   Authentication-Results
      header field (see Section 9) to communicate\n   this result to downstream message
      processors.  While this is true for\n   all SPF results, it is of particular
      importance for \"fail\" results\n   since the message is explicitly not authorized
      by the ADMD.\n"
    title: 8.4.  Fail
  - contents:
    - "8.5.  Softfail\n   A \"softfail\" result ought to be treated as somewhere between
      \"fail\"\n   and \"neutral\"/\"none\".  The ADMD believes the host is not authorized\n
      \  but is not willing to make a strong policy statement.  Receiving\n   software
      SHOULD NOT reject the message based solely on this result,\n   but MAY subject
      the message to closer scrutiny than normal.\n   The ADMD wants to discourage
      the use of this host and thus desires\n   limited feedback when a \"softfail\"
      result occurs.  For example, the\n   recipient's MUA could highlight the \"softfail\"
      status, or the\n   receiving MTA could give the sender a message using greylisting\n
      \  [RFC6647], with a note the first time the message is received, but\n   accept
      it on a later attempt based on receiver policy.\n"
    title: 8.5.  Softfail
  - contents:
    - "8.6.  Temperror\n   A \"temperror\" result means the SPF verifier encountered
      a transient\n   (generally DNS) error while performing the check.  Checking
      software\n   can choose to accept or temporarily reject the message.  If the\n
      \  message is rejected during the SMTP transaction for this reason, the\n   software
      SHOULD use an SMTP reply code of 451 and, if supported, the\n   4.4.3 enhanced
      status code (see Section 3.5 of [RFC3463]).  These\n   errors can be caused
      by problems in either the sender's or receiver's\n   DNS software.  See Appendix
      G.4 for considerations on developing\n   local policy.\n"
    title: 8.6.  Temperror
  - contents:
    - "8.7.  Permerror\n   A \"permerror\" result means the domain's published records
      could not\n   be correctly interpreted.  This signals an error condition that\n
      \  definitely requires DNS operator intervention to be resolved.  If the\n   message
      is rejected during the SMTP transaction for this reason, the\n   software SHOULD
      use an SMTP reply code of 550 and, if supported, the\n   5.5.2 enhanced status
      code (see [RFC3463], Section 3.6).  Be aware\n   that if the ADMD uses macros
      (Section 7), it is possible that this\n   result is due to the checked identities
      having an unexpected format.\n   It is also possible that this result is generated
      by certain SPF\n   verifiers due to the input arguments having an unexpected
      format; see\n   Section 4.8.  See Appendix G.3 for considerations on developing
      local\n   policy.\n"
    title: 8.7.  Permerror
  title: 8.  Result Handling
- contents:
  - "9.  Recording the Result\n   To provide downstream agents, such as MUAs, with
    the information they\n   might need in terms of evaluating or representing the
    apparent safety\n   of the message content, it is RECOMMENDED that SMTP receivers
    record\n   the result of SPF processing in the message header.  For SPF verifier\n
    \  operators that choose to record SPF results in the header of the\n   message
    for processing by internal filters or MUAs, two methods are\n   presented: Section
    9.1 defines the Received-SPF field, which is the\n   results field originally
    defined for SPF use.  Section 9.2 discusses\n   the Authentication-Results header
    field [RFC7001], which was\n   specified more recently and is designed for use
    by SPF and other\n   authentication methods.\n   Both are in common use, and hence
    both are included here.  However,\n   it is important to note that they were designed
    to serve slightly\n   different purposes.  Received-SPF is intended to include
    enough\n   information to enable reconstruction of the SPF evaluation of the\n
    \  message, while Authentication-Results is designed only to relay the\n   result
    itself and related output details of likely use to end users\n   (e.g., what property
    of the message was actually authenticated and\n   what it contained), leaving
    reconstructive work to the purview of\n   system logs and the Received field contents.
    \ Also, Received-SPF\n   relies on compliance of agents within the receiving ADMD
    to adhere to\n   the header field ordering rules of [RFC5321] and [RFC5322], while\n
    \  Authentication-Results includes some provisions to protect against\n   non-compliant
    implementations.\n   An SPF verifier operator could choose to use both to serve
    different\n   downstream agents.  In such cases, care needs to be taken to ensure\n
    \  that both fields are conveying the same details, or unexpected\n   results
    can occur.\n"
  - contents:
    - "9.1.  The Received-SPF Header Field\n   The Received-SPF header field is a
      trace field (see [RFC5322],\n   Section 3.6.7) and SHOULD be prepended to the
      existing header, above\n   the Received: field that is generated by the SMTP
      receiver.  It MUST\n   appear above all other Received-SPF fields in the message.
      \ The\n   header field has the following format:\n   header-field     = \"Received-SPF:\"
      [CFWS] result FWS [comment FWS]\n                      [ key-value-list ] CRLF\n
      \  result           = \"pass\" / \"fail\" / \"softfail\" / \"neutral\" /\n                      \"none\"
      / \"temperror\" / \"permerror\"\n   key-value-list   = key-value-pair *( \";\"
      [CFWS] key-value-pair )\n                      [\";\"]\n   key-value-pair   =
      key [CFWS] \"=\" ( dot-atom / quoted-string )\n   key              = \"client-ip\"
      / \"envelope-from\" / \"helo\" /\n                      \"problem\" / \"receiver\"
      / \"identity\" /\n                       \"mechanism\" / name\n   identity         =
      \"mailfrom\"   ; for the \"MAIL FROM\" identity\n                      / \"helo\"
      \    ; for the \"HELO\" identity\n                      / name       ; other
      identities\n   dot-atom         = <unquoted word as per [RFC5322]>\n   quoted-string
      \   = <quoted string as per [RFC5322]>\n   comment          = <comment string
      as per [RFC5322]>\n   CFWS             = <comment or folding white space as
      per [RFC5322]>\n   FWS              = <folding white space as per [RFC5322]>\n
      \  CRLF             = <standard end-of-line token as per [RFC5322]>\n   The
      header field SHOULD include a \"(...)\" style comment after the\n   result,
      conveying supporting information for the result, such as\n   <ip>, <sender>,
      and <domain>.\n   The following key-value pairs are designed for later machine
      parsing.\n   SPF verifiers SHOULD give enough information so that the SPF results\n
      \  can be verified -- that is, at least \"client-ip\", \"helo\", and, if the\n
      \  \"MAIL FROM\" identity was checked, \"envelope-from\".\n   client-ip      the
      IP address of the SMTP client\n   envelope-from  the envelope sender mailbox\n
      \  helo           the host name given in the HELO or EHLO command\n   mechanism
      \     the mechanism that matched (if no mechanisms matched,\n                  substitute
      the word \"default\")\n   problem        if an error was returned, details about
      the error\n   receiver       the host name of the SPF verifier\n   identity
      \      the identity that was checked; see the <identity>\n                  ABNF
      rule\n   Other keys MAY be defined by SPF verifiers.\n   SPF verifiers MUST
      make sure that the Received-SPF header field does\n   not contain invalid characters,
      is not excessively long (see\n   [RFC5322], Section 2.1.1), and does not contain
      malicious data that\n   has been provided by the sender.\n   Examples of various
      header field styles that could be generated are\n   the following:\n   Received-SPF:
      pass (mybox.example.org: domain of\n    myname@example.com designates 192.0.2.1
      as permitted sender)\n       receiver=mybox.example.org; client-ip=192.0.2.1;\n
      \      envelope-from=\"myname@example.com\"; helo=foo.example.com;\n   Received-SPF:
      fail (mybox.example.org: domain of\n                     myname@example.com
      does not designate\n                     192.0.2.1 as permitted sender)\n                     identity=mailfrom;
      client-ip=192.0.2.1;\n                     envelope-from=\"myname@example.com\";\n
      \  Received-SPF: pass (mybox.example.org: domain of\n    myname@example.com
      designates 192.0.2.1 as permitted sender)\n       receiver=mybox.example.org;
      client-ip=192.0.2.1;\n       mechanism=ip4:192.0.2.1; envelope-from=\"myname@example.com\";\n
      \      helo=foo.example.com;\n"
    title: 9.1.  The Received-SPF Header Field
  - contents:
    - "9.2.  SPF Results in the Authentication-Results Header Field\n   As mentioned
      in Section 9, the Authentication-Results header field is\n   designed to communicate
      lists of tests a border MTA did and their\n   results.  The specified elements
      of the field provide less\n   information than the Received-SPF field:\n   Authentication-Results:
      myhost.example.org; spf=pass\n     smtp.mailfrom=example.net\n   Received-SPF:
      pass (myhost.example.org: domain of\n    myname@example.com designates 192.0.2.1
      as permitted sender)\n       receiver=mybox.example.org; client-ip=192.0.2.1;\n
      \      envelope-from=\"myname@example.com\"; helo=foo.example.com;\n   It is,
      however, possible to add CFWS in the \"reason\" part of an\n   Authentication-Results
      header field and provide the equivalent\n   information, if desired.\n   As
      an example, an expanded Authentication-Results header field might\n   look like
      (for a \"MAIL FROM\" check in this example):\n   Authentication-Results: myhost.example.org;
      spf=pass\n     reason=\"client-ip=192.0.2.1; smtp.helo=foo.example.com\"\n     smtp.mailfrom=user@example.net\n"
    title: 9.2.  SPF Results in the Authentication-Results Header Field
  title: 9.  Recording the Result
- contents:
  - "10.  Effects on Infrastructure\n   This section outlines the major implications
    that adoption of this\n   protocol will have on various entities involved in Internet
    email.\n   It is intended to make clear to the reader where this protocol\n   knowingly
    affects the operation of such entities.  This section is\n   not a \"how-to\"
    manual, or a \"best practices\" document, and it is not\n   a comprehensive list
    of what such entities ought to do in light of\n   this specification.\n   This
    section provides operational advice and instruction only.  It is\n   non-normative.\n
    \  [RFC5598] describes the Internet email architecture.  This section is\n   organized
    based on the different segments of the architecture.\n"
  - contents:
    - "10.1.  Sending Domains\n   Originating ADMDs (ADministrative Management Domains
      --\n   Sections 2.2.1 and 2.3 of [RFC5598]) that wish to be compliant with\n
      \  this specification will need to determine the list of relays\n   ([RFC5598],
      Section 2.2.2) that they allow to use their domain name\n   in the \"HELO\"
      and \"MAIL FROM\" identities when relaying to other\n   ADMDs.  It is recognized
      that forming such a list is not just a\n   simple technical exercise, but involves
      policy decisions with both\n   technical and administrative considerations.\n"
    - contents:
      - "10.1.1.  DNS Resource Considerations\n   Minimizing the DNS resources needed
        for SPF lookups can be done by\n   choosing directives that require less DNS
        information and by placing\n   lower-cost mechanisms earlier in the SPF record.\n
        \  Section 4.6.4 specifies the limits receivers have to use.  It is\n   essential
        to publish records that do not exceed these requirements.\n   It is also required
        to carefully weigh the cost and the\n   maintainability of licit solutions.\n
        \  For example, consider a domain set up as follows:\n      example.com.     IN
        MX   10 mx.example.com.\n                       IN MX   20 mx2.example.com.\n
        \     mx.example.com.  IN A    192.0.2.1\n      mx2.example.com. IN A    192.0.2.129\n
        \  Assume the administrative point is to authorize (pass) mx and mx2\n   while
        failing every other host.  Compare the following solutions:\n   Best record:\n
        \     example.com.   IN TXT  \"v=spf1 ip4:192.0.2.1 ip4:192.0.2.129 -all\"\n
        \  Good record:\n      $ORIGIN example.com.\n      @              IN TXT  \"v=spf1
        a:authorized-spf.example.com -all\"\n      authorized-spf IN A    192.0.2.1\n
        \                    IN A    192.0.2.129\n   Expensive record:\n      example.com.
        \  IN TXT  \"v=spf1 mx:example.com -all\"\n   Wasteful, bad record:\n      example.com.
        \  IN TXT  \"v=spf1 ip4:192.0.2.0/24 mx -all\"\n"
      title: 10.1.1.  DNS Resource Considerations
    - contents:
      - "10.1.2.  Administrator's Considerations\n   There might be administrative
        considerations: using \"a\" over \"ip4\" or\n   \"ip6\" allows hosts to be
        renumbered easily at the cost of a DNS query\n   per receiver.  Using \"mx\"
        over \"a\" allows the set of mail hosts to be\n   changed easily.  Unless
        such changes are common, it is better to use\n   the less resource-intensive
        mechanisms like \"ip4\" and \"ip6\" over \"a\"\n   or \"a\" over \"mx\".\n
        \  In some specific cases, standard advice on record content is\n   appropriate.
        \ Publishing SPF records for domains that send no mail is\n   a well-established
        best practice.  The record for a domain that sends\n   no mail is:\n      www.example.com.
        \  IN TXT  \"v=spf1 -all\"\n   Publishing SPF records for individual hosts
        is also best practice.\n   The host name is generally the identity used in
        the 5321.HELO/.EHLO\n   command.  In the case of messages with a null 5321.MailFrom,
        this is\n   used as the domain for 5321.MailFrom SPF checks, in addition to
        being\n   used in 5321.HELO/.EHLO-based SPF checks.  The standard SPF record\n
        \  for an individual host that is involved in mail processing is:\n      relay.example.com.
        \  IN TXT  \"v=spf1 a -all\"\n   Validating correct deployment is difficult.
        \ [RFC6652] describes one\n   mechanism for soliciting feedback on SPF failures.
        \ Another\n   suggestion can be found in Appendix C.\n   Regardless of the
        method used, understanding the ADMD's outbound mail\n   architecture is essential
        to effective deployment.\n"
      title: 10.1.2.  Administrator's Considerations
    - contents:
      - "10.1.3.  Bounces\n   As explained in Section 2.4, [RFC5321] allows the MAIL
        FROM to be\n   null, which is typical of some Delivery Status Notifications\n
        \  [RFC3464], commonly called email bounces.  In this case, the only\n   entity
        available for performing an SPF check is the \"HELO\" identity\n   defined
        in Section 1.1.4.  SPF functionality is enhanced by\n   administrators ensuring
        this identity is set correctly and has an\n   appropriate SPF record.  It
        is normal to have the \"HELO\" identity set\n   to the host name instead of
        the domain.  Zone file generation for\n   significant numbers of hosts can
        be consolidated using the \"redirect\"\n   modifier and scripted for initial
        deployment.  Specific deployment\n   advice is given above in Section 10.1.2.\n"
      title: 10.1.3.  Bounces
    title: 10.1.  Sending Domains
  - contents:
    - "10.2.  Receivers\n   SPF results can be used in combination with other methods
      to\n   determine the final local disposition (either positive or negative)\n
      \  of a message.  It can also be considered dispositive on its own.\n   An attempt
      to have one organization (sender) direct the email-\n   handling policies of
      another (receiver) is inherently challenging and\n   often controversial.  As
      stated elsewhere in this document, there is\n   no comprehensive normative requirement
      for specific handling of a\n   message based on SPF results.  The information
      presented in Section 8\n   and in Appendix G is offered for receiver consideration
      when forming\n   local handling policies.\n   The primary considerations are
      that SPF might return \"pass\" for mail\n   that is ultimately harmful (e.g.,
      spammers that arrange for SPF to\n   pass using disposable domain names, or
      virus or spam outbreaks from\n   within trusted sources), and might also return
      \"fail\" for mail that\n   is ultimately legitimate (e.g., legitimate mail that
      has traversed a\n   mail alias).  It is important to take both of these cases
      under\n   consideration when establishing local handling policy.\n"
    title: 10.2.  Receivers
  - contents:
    - "10.3.  Mediators\n   Mediators are a type of User Actor [RFC5598].  That is,
      a mediator\n   takes 'delivery' of a message and posts a 'submission' of a new\n
      \  message.  The mediator can make the newly posted message be as\n   similar
      to or as different from the original message as they wish.\n   Examples include
      mailing lists (see Section 5.3 of [RFC5598]) and\n   ReSenders (Section 5.2
      of [RFC5598]).  This is discussed in\n   [RFC5321], Section 3.9.  For the operation
      of SPF, the essential\n   concern is the email address in the 5321.MailFrom
      command for the new\n   message.\n   Because SPF evaluation is based on the
      IP address of the \"last\"\n   sending SMTP server, the address of the mediator
      will be used, rather\n   than the address of the SMTP server that sent the message
      to the\n   mediator.  Some mediators retain the email address from the original\n
      \  message, while some use a new address.\n   If the address is the same as
      for the original message, and the\n   original message had an associated SPF
      record, then the SPF\n   evaluation will fail unless mitigations such as those
      described in\n   Appendix D are used.\n"
    title: 10.3.  Mediators
  title: 10.  Effects on Infrastructure
- contents:
  - '11.  Security Considerations

    '
  - contents:
    - "11.1.  Processing Limits\n   As with most aspects of email, there are a number
      of ways that\n   malicious parties could use the protocol as an avenue for a
      DoS\n   attack.  The processing limits outlined in Section 4.6.4 are designed\n
      \  to prevent attacks such as the following:\n   o  A malicious party could
      create an SPF record with many references\n      to a victim's domain and send
      many emails to different SPF\n      verifiers; those SPF verifiers would then
      create a DoS attack.  In\n      effect, the SPF verifiers are being used to
      amplify the attacker's\n      bandwidth by using fewer octets in the SMTP session
      than are used\n      by the DNS queries.  Using SPF verifiers also allows the
      attacker\n      to hide the true source of the attack.  This potential attack
      is\n      based on large volumes of mail being transmitted.\n   o  Whereas implementations
      of check_host() are supposed to limit the\n      number of DNS lookups, malicious
      domains could publish records\n      that exceed these limits in an attempt
      to waste computation effort\n      at their targets when they send them mail.
      \ Malicious domains\n      could also design SPF records that cause particular\n
      \     implementations to use excessive memory or CPU or to trigger bugs.\n      If
      a receiver is configured to accept mail with an SPF result of\n      \"temperror\",
      such an attack might result in mail that would\n      otherwise have been rejected
      due to an SPF \"fail\" result being\n      accepted.  This potential attack
      is based on specially crafted SPF\n      records being used to exhaust DNS resources
      of the victim.\n   o  Malicious parties could send a large volume of mail purporting
      to\n      come from the intended target to a wide variety of legitimate mail\n
      \     hosts.  These legitimate machines would then present a DNS load on\n      the
      target as they fetched the relevant records.\n   o  Malicious parties could,
      in theory, use SPF records as a vehicle\n      for DNS lookup amplification
      for a DoS attack.  In this scenario,\n      the attacker publishes an SPF record
      in its own DNS that uses \"a\"\n      and \"mx\" mechanisms directed toward
      the intended victim, e.g.,\n      \"a:example.com a:foo.example.com a:bar.example.com
      ...\" and then\n      distributes mail with a MAIL FROM value including its
      own domain\n      in large volume to a wide variety of destinations.  Any such\n
      \     destination operating an SPF verifier will begin querying all of\n      the
      names associated with the \"a\" mechanisms in that record.  The\n      names
      used in the record needn't exist for the attack to be\n      effective.  Operational
      experience since the publication of\n      [RFC4408] suggests that mitigation
      of this class of attack can be\n      accomplished with minimal impact on the
      deployed base by having\n      the verifier abort processing and return \"permerror\"\n
      \     (Section 2.6.7) as soon as more than two \"void lookups\" have been\n
      \     encountered (defined in Section 4.6.4).\n   Of these, the case of a third
      party referenced in the SPF record is\n   the easiest for a DoS attack to effectively
      exploit.  As a result,\n   limits that might seem reasonable for an individual
      mail server can\n   still allow an unreasonable amount of bandwidth amplification.\n
      \  Therefore, the processing limits need to be quite low.\n"
    title: 11.1.  Processing Limits
  - contents:
    - "11.2.  SPF-Authorized Email May Contain Other False Identities\n   The \"MAIL
      FROM\" and \"HELO\" identity authorizations do not provide\n   assurance about
      the authorization/authenticity of other identities\n   used in the message.
      \ It is entirely possible for a malicious sender\n   to inject a message using
      his own domain in the identities used by\n   SPF and have that domain's SPF
      record authorize the sending host, and\n   yet the message can easily list other
      identities in its header.\n   Unless the user or the MUA takes care to note
      that the authorized\n   identity does not match the other more commonly presented
      identities\n   (such as the From: header field), the user might be lulled into
      a\n   false sense of security.\n"
    title: 11.2.  SPF-Authorized Email May Contain Other False Identities
  - contents:
    - "11.3.  Spoofed DNS and IP Data\n   There are two aspects of this protocol that
      malicious parties could\n   exploit to undermine the validity of the check_host()
      function:\n   o  The evaluation of check_host() relies heavily on DNS.  A malicious\n
      \     attacker could attack the DNS infrastructure and cause\n      check_host()
      to see spoofed DNS data, and then return incorrect\n      results.  This could
      include returning \"pass\" for an <ip> value\n      where the actual domain's
      record would evaluate to \"fail\".  See\n      [RFC3833] for a description of
      DNS weaknesses, and see [RFC4033]\n      for a countermeasure.\n   o  The client
      IP address, <ip>, is assumed to be correct.  In a\n      modern, correctly configured
      system, the risk of this not being\n      true is nil.\n"
    title: 11.3.  Spoofed DNS and IP Data
  - contents:
    - "11.4.  Cross-User Forgery\n   By definition, SPF policies just map domain names
      to sets of\n   authorized MTAs, not whole email addresses to sets of authorized\n
      \  users.  Although the \"l\" macro (Section 7) provides a limited way to\n
      \  define individual sets of authorized MTAs for specific email\n   addresses,
      it is generally impossible to verify, through SPF, the use\n   of specific email
      addresses by individual users of the same MTA.\n   It is up to mail services
      and their MTAs to directly prevent\n   cross-user forgery: based on SMTP AUTH
      ([RFC4954]), users have to be\n   restricted to using only those email addresses
      that are actually\n   under their control (see Section 6.1 of [RFC6409]).  Another
      means to\n   verify the identity of individual users is message cryptography,
      such\n   as Pretty Good Privacy (PGP) ([RFC4880]) or S/MIME ([RFC5751]).\n"
    title: 11.4.  Cross-User Forgery
  - contents:
    - "11.5.  Untrusted Information Sources\n   An SPF-compliant receiver gathers
      information from the SMTP commands\n   it receives and from the published DNS
      records of the sending domain\n   holder (e.g., \"HELO\" domain name, the \"MAIL
      FROM\" address from the\n   envelope, and SPF DNS records published by the domain
      holder).  These\n   parameters are not validated in the SMTP process.\n   All
      of these pieces of information are generated by actors outside of\n   the authority
      of the receiver, and thus are not guaranteed to be\n   accurate or legitimate.\n"
    - contents:
      - "11.5.1.  Recorded Results\n   This information, passed to the receiver in
        the Received-SPF: or\n   Authentication-Results: trace fields, can be returned
        to the client\n   MTA as an SMTP rejection message.  If such an SMTP rejection
        message\n   is generated, the information from the trace fields has to be
        checked\n   for such problems as invalid characters and excessively long lines.\n"
      title: 11.5.1.  Recorded Results
    - contents:
      - "11.5.2.  External Explanations\n   When the authorization check fails, an
        explanation string could be\n   included in the reject response.  Both the
        sender and the rejecting\n   receiver need to be aware that the explanation
        was determined by the\n   publisher of the SPF record checked and, in general,
        not the\n   receiver.  The explanation can contain malicious URLs, or it might
        be\n   offensive or misleading.\n   Explanations returned to sender domains
        due to \"exp\" modifiers\n   (Section 6.2) were generated by the sender policy
        published by the\n   domain holders themselves.  As long as messages are only
        returned\n   with non-delivery notifications ([RFC3464]) to domains publishing
        the\n   explanation strings from their own DNS SPF records, the only affected\n
        \  parties are the original publishers of the domain's SPF records.\n   In
        practice, such non-delivery notifications can be misdirected, such\n   as
        when an MTA accepts an email and only later generates the\n   notification
        to a forged address, or when an email forwarder does not\n   direct the bounce
        back to the original sender.\n"
      title: 11.5.2.  External Explanations
    - contents:
      - "11.5.3.  Macro Expansion\n   Macros (Section 7) allow senders to inject arbitrary
        text (any\n   non-null [US-ASCII] character) into receiver DNS queries.  It
        is\n   necessary to be prepared for hostile or unexpected content.\n"
      title: 11.5.3.  Macro Expansion
    title: 11.5.  Untrusted Information Sources
  - contents:
    - "11.6.  Privacy Exposure\n   Checking SPF records causes DNS queries to be sent
      to the domain\n   owner.  These DNS queries, especially if they are caused by
      the\n   \"exists\" mechanism, can contain information about who is sending\n
      \  email and likely to which MTA the email is being sent.  This can\n   introduce
      some privacy concerns, which are more or less of an issue\n   depending on local
      laws and the relationship between the ADMD and the\n   person sending the email.\n"
    title: 11.6.  Privacy Exposure
  - contents:
    - "11.7.  Delivering Mail Producing a \"Fail\" Result\n   Operators that choose
      to deliver mail for which SPF produces a \"fail\"\n   result need to understand
      that they are admitting content that is\n   explicitly not authorized by the
      purported sender.  While there are\n   known failure modes that can be considered
      \"false negatives\", the\n   distinct choice to admit those messages increases
      end-user exposure\n   to likely harm.  This is especially true for domains belonging
      to\n   known good actors that are typically well-behaved; unauthorized mail\n
      \  from those sources might well be subjected to much higher skepticism\n   and
      content analysis.\n   SPF does not, however, include the capacity to distinguish
      good\n   actors from bad ones, nor does it handle the concept of known actors\n
      \  versus unknown ones.  Those notions are out of scope for this\n   specification.\n"
    title: 11.7.  Delivering Mail Producing a "Fail" Result
  title: 11.  Security Considerations
- contents:
  - "12.  Collected ABNF\n   This section is normative, and any discrepancies with
    the ABNF\n   fragments in the preceding text are to be resolved in favor of this\n
    \  grammar.\n   See [RFC5234] for ABNF notation.  Please note that as per this
    ABNF\n   definition, literal text strings (those in quotes) are case-\n   insensitive.
    \ Hence, \"mx\" matches \"mx\", \"MX\", \"mX\", and \"Mx\".\n   record           =
    version terms *SP\n   version          = \"v=spf1\"\n   terms            = *(
    1*SP ( directive / modifier ) )\n   directive        = [ qualifier ] mechanism\n
    \  qualifier        = \"+\" / \"-\" / \"?\" / \"~\"\n   mechanism        = ( all
    / include\n                      / a / mx / ptr / ip4 / ip6 / exists )\n   all
    \             = \"all\"\n   include          = \"include\"  \":\" domain-spec\n
    \  a                = \"a\"      [ \":\" domain-spec ] [ dual-cidr-length ]\n
    \  mx               = \"mx\"     [ \":\" domain-spec ] [ dual-cidr-length ]\n
    \  ptr              = \"ptr\"    [ \":\" domain-spec ]\n   ip4              =
    \"ip4\"      \":\" ip4-network   [ ip4-cidr-length ]\n   ip6              = \"ip6\"
    \     \":\" ip6-network   [ ip6-cidr-length ]\n   exists           = \"exists\"
    \  \":\" domain-spec\n   modifier         = redirect / explanation / unknown-modifier\n
    \  redirect         = \"redirect\" \"=\" domain-spec\n   explanation      = \"exp\"
    \"=\" domain-spec\n   unknown-modifier = name \"=\" macro-string\n                      ;
    where name is not any known modifier\n   ip4-cidr-length  = \"/\" (\"0\" / %x31-39
    0*1DIGIT) ; value range 0-32\n   ip6-cidr-length  = \"/\" (\"0\" / %x31-39 0*2DIGIT)
    ; value range 0-128\n   dual-cidr-length = [ ip4-cidr-length ] [ \"/\" ip6-cidr-length
    ]\n   ip4-network      = qnum \".\" qnum \".\" qnum \".\" qnum\n   qnum             =
    DIGIT                 ; 0-9\n                      / %x31-39 DIGIT       ; 10-99\n
    \                     / \"1\" 2DIGIT          ; 100-199\n                      /
    \"2\" %x30-34 DIGIT   ; 200-249\n                      / \"25\" %x30-35        ;
    250-255\n            ; conventional dotted-quad notation, e.g., 192.0.2.0\n   ip6-network
    \     = <as per Section 2.2 of [RFC4291]>\n            ; e.g., 2001:db8::cd30\n
    \  domain-spec      = macro-string domain-end\n   domain-end       = ( \".\" toplabel
    [ \".\" ] ) / macro-expand\n   toplabel         = ( *alphanum ALPHA *alphanum
    ) /\n                      ( 1*alphanum \"-\" *( alphanum / \"-\" ) alphanum )\n
    \                     ; LDH rule plus additional TLD restrictions\n                      ;
    (see Section 2 of [RFC3696] for background)\n   alphanum         = ALPHA / DIGIT\n
    \  explain-string   = *( macro-string / SP )\n   macro-string     = *( macro-expand
    / macro-literal )\n   macro-expand     = ( \"%{\" macro-letter transformers *delimiter
    \"}\" )\n                      / \"%%\" / \"%_\" / \"%-\"\n   macro-literal    =
    %x21-24 / %x26-7E\n                      ; visible characters except \"%\"\n   macro-letter
    \    = \"s\" / \"l\" / \"o\" / \"d\" / \"i\" / \"p\" / \"h\" /\n                      \"c\"
    / \"r\" / \"t\" / \"v\"\n   transformers     = *DIGIT [ \"r\" ]\n   delimiter
    \       = \".\" / \"-\" / \"+\" / \",\" / \"/\" / \"_\" / \"=\"\n   name             =
    ALPHA *( ALPHA / DIGIT / \"-\" / \"_\" / \".\" )\n   header-field     = \"Received-SPF:\"
    [CFWS] result FWS [comment FWS]\n                      [ key-value-list ] CRLF\n
    \  result           = \"pass\" / \"fail\" / \"softfail\" / \"neutral\" /\n                      \"none\"
    / \"temperror\" / \"permerror\"\n   key-value-list   = key-value-pair *( \";\"
    [CFWS] key-value-pair )\n                      [\";\"]\n   key-value-pair   =
    key [CFWS] \"=\" ( dot-atom / quoted-string )\n   key              = \"client-ip\"
    / \"envelope-from\" / \"helo\" /\n                      \"problem\" / \"receiver\"
    / \"identity\" /\n                       \"mechanism\" / name\n   identity         =
    \"mailfrom\"   ; for the \"MAIL FROM\" identity\n                      / \"helo\"
    \    ; for the \"HELO\" identity\n                      / name       ; other identities\n
    \  sender           = Mailbox\n   ip               = ip4-network / ip6-network\n
    \  ALPHA            = <A-Z / a-z as per [RFC5234]>\n   DIGIT            = <0-9
    as per [RFC5234]>\n   SP               = <space character as per [RFC5234]>\n
    \  dot-atom         = <unquoted word as per [RFC5322]>\n   quoted-string    =
    <quoted string as per [RFC5322]>\n   comment          = <comment string as per
    [RFC5322]>\n   CFWS             = <comment or folding white space as per [RFC5322]>\n
    \  FWS              = <folding white space as per [RFC5322]>\n   CRLF             =
    <standard end-of-line token as per [RFC5322]>\n"
  title: 12.  Collected ABNF
- contents:
  - "13.  Contributors and Acknowledgements\n   This document is largely based on
    the work of Meng Weng Wong, Mark\n   Lentczner, and Wayne Schlitt.  Although,
    as this section\n   acknowledges, many people have contributed to this document,
    a very\n   large portion of the writing and editing is due to Meng, Mark, and\n
    \  Wayne.\n   This design owes a debt of parentage to [RMX] by Hadmut Danisch
    and\n   to [DMP] by Gordon Fecyk.  The idea of using a DNS record to check\n   the
    legitimacy of an email address traces its ancestry further back\n   through messages
    on the namedroppers mailing list by Paul Vixie\n   [Vixie] (based on suggestion
    by Jim Miller) and by David Green\n   [Green].\n   Philip Gladstone contributed
    the concept of macros to the\n   specification, multiplying the expressiveness
    of the language and\n   making per-user and per-IP lookups possible.\n   The authors
    of both this document and [RFC4408] would also like to\n   thank the literally
    hundreds of individuals who have participated in\n   the development of this design.
    \ They are far too numerous to name,\n   but they include the following:\n      The
    participants in the SPFbis working group.  The folks on the\n      spf-discuss
    mailing list.  The folks on the SPAM-L mailing list.\n      The folks on the IRTF
    ASRG mailing list.  The folks on the IETF\n      MARID mailing list.  The folks
    on #perl.\n"
  title: 13.  Contributors and Acknowledgements
- contents:
  - '14.  IANA Considerations

    '
  - contents:
    - "14.1.  The SPF DNS Record Type\n   Per [RFC4408], the IANA assigned the Resource
      Record Type and Qtype\n   from the \"Domain Name System (DNS) Parameters\" registry
      for the SPF\n   RR type with code 99.  The format of this type is identical
      to the\n   TXT RR [RFC1035].  The character content of the record is encoded
      as\n   [US-ASCII].\n   Studies have shown that RRTYPE 99 has not seen any substantial
      use,\n   and in fact its existence and mechanism defined in [RFC4408] have led\n
      \  to some interoperability issues.  Accordingly, its use is no longer\n   appropriate
      for SPF version 1; implementations are not to use it.\n   IANA has updated the
      \"Resource Record (RR) TYPEs\" registry to\n   indicate that this document is
      the reference document for that\n   RRTYPE.\n"
    title: 14.1.  The SPF DNS Record Type
  - contents:
    - "14.2.  The Received-SPF Mail Header Field\n   Per [RFC3864], the \"Received-SPF:\"
      header field is added to the IANA\n   \"Permanent Message Header Field Names\"
      registry.  The following is\n   the registration template:\n      Header field
      name: Received-SPF Applicable protocol: mail\n      ([RFC5322]) Status: standard
      Author/Change controller: IETF\n      Specification document(s): RFC 7208\n"
    title: 14.2.  The Received-SPF Mail Header Field
  - contents:
    - "14.3.  SPF Modifier Registry\n   IANA has changed the reference for the \"exp\"
      and \"redirect\" modifiers\n   in the \"Modifier Names\" registry, under Sender
      Policy Framework\n   Parameters, from [RFC4408] to this document.  Their status
      is\n   unchanged.\n"
    title: 14.3.  SPF Modifier Registry
  title: 14.  IANA Considerations
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [RFC1035]  Mockapetris, P., \"Domain names
      - implementation and\n              specification\", STD 13, RFC 1035, November
      1987.\n   [RFC1123]  Braden, R., \"Requirements for Internet Hosts - Application\n
      \             and Support\", STD 3, RFC 1123, October 1989.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC3463]  Vaudreuil, G., \"Enhanced Mail
      System Status Codes\",\n              RFC 3463, January 2003.\n   [RFC3864]
      \ Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n              Procedures
      for Message Header Fields\", BCP 90, RFC 3864,\n              September 2004.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January
      2005.\n   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n
      \             Architecture\", RFC 4291, February 2006.\n   [RFC5234]  Crocker,
      D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC5321]  Klensin, J., \"Simple
      Mail Transfer Protocol\", RFC 5321,\n              October 2008.\n   [RFC5322]
      \ Resnick, P., Ed., \"Internet Message Format\", RFC 5322,\n              October
      2008.\n   [RFC5598]  Crocker, D., \"Internet Mail Architecture\", RFC 5598,\n
      \             July 2009.\n   [RFC5890]  Klensin, J., \"Internationalized Domain
      Names for\n              Applications (IDNA): Definitions and Document Framework\",\n
      \             RFC 5890, August 2010.\n   [RFC7001]  Kucherawy, M., \"Message
      Header Field for Indicating\n              Message Authentication Status\",
      RFC 7001, September 2013.\n   [US-ASCII]\n              American National Standards
      Institute (formerly United\n              States of America Standards Institute),
      \"USA Code for\n              Information Interchange, X3.4\", 1968.\n              ANSI
      X3.4-1968 has been replaced by newer versions with\n              slight modifications,
      but the 1968 version remains\n              definitive for the Internet.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [BATV]     Levine, J., Crocker, D., Silberman,
      S., and T. Finch,\n              \"Bounce Address Tag Validation (BATV)\", Work
      in Progress,\n              May 2008.\n   [DMP]      Fecyk, G., \"Designated
      Mailers Protocol\", Work in\n              Progress, May 2004.\n   [Green]    Green,
      D., \"Domain-Authorized SMTP Mail\", June 2002,\n              <http://www.mhonarc.org/archive/html/ietf-asrg/2003-03/\n
      \             msg01525.html>.\n   [RFC1034]  Mockapetris, P., \"Domain names
      - concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n
      \  [RFC1983]  Malkin, G., \"Internet Users' Glossary\", RFC 1983,\n              August
      1996.\n   [RFC2308]  Andrews, M., \"Negative Caching of DNS Queries (DNS\n              NCACHE)\",
      RFC 2308, March 1998.\n   [RFC2671]  Vixie, P., \"Extension Mechanisms for DNS
      (EDNS0)\",\n              RFC 2671, August 1999.\n   [RFC2782]  Gulbrandsen,
      A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying the location
      of services (DNS SRV)\", RFC 2782,\n              February 2000.\n   [RFC3464]
      \ Moore, K. and G. Vaudreuil, \"An Extensible Message Format\n              for
      Delivery Status Notifications\", RFC 3464,\n              January 2003.\n   [RFC3696]
      \ Klensin, J., \"Application Techniques for Checking and\n              Transformation
      of Names\", RFC 3696, February 2004.\n   [RFC3833]  Atkins, D. and R. Austein,
      \"Threat Analysis of the Domain\n              Name System (DNS)\", RFC 3833,
      August 2004.\n   [RFC3834]  Moore, K., \"Recommendations for Automatic Responses
      to\n              Electronic Mail\", RFC 3834, August 2004.\n   [RFC4033]  Arends,
      R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"DNS Security
      Introduction and Requirements\",\n              RFC 4033, March 2005.\n   [RFC4408]
      \ Wong, M. and W. Schlitt, \"Sender Policy Framework (SPF)\n              for
      Authorizing Use of Domains in E-Mail, Version 1\",\n              RFC 4408,
      April 2006.\n   [RFC4632]  Fuller, V. and T. Li, \"Classless Inter-domain Routing\n
      \             (CIDR): The Internet Address Assignment and Aggregation\n              Plan\",
      BCP 122, RFC 4632, August 2006.\n   [RFC4880]  Callas, J., Donnerhacke, L.,
      Finney, H., Shaw, D., and R.\n              Thayer, \"OpenPGP Message Format\",
      RFC 4880, November 2007.\n   [RFC4954]  Siemborski, R. and A. Melnikov, \"SMTP
      Service Extension\n              for Authentication\", RFC 4954, July 2007.\n
      \  [RFC5507]  IAB, Faltstrom, P., Austein, R., and P. Koch, \"Design\n              Choices
      When Expanding the DNS\", RFC 5507, April 2009.\n   [RFC5751]  Ramsdell, B.
      and S. Turner, \"Secure/Multipurpose Internet\n              Mail Extensions
      (S/MIME) Version 3.2 Message\n              Specification\", RFC 5751, January
      2010.\n   [RFC5782]  Levine, J., \"DNS Blacklists and Whitelists\", RFC 5782,\n
      \             February 2010.\n   [RFC6409]  Gellens, R. and J. Klensin, \"Message
      Submission for Mail\",\n              STD 72, RFC 6409, November 2011.\n   [RFC6647]
      \ Kucherawy, M. and D. Crocker, \"Email Greylisting: An\n              Applicability
      Statement for SMTP\", RFC 6647, June 2012.\n   [RFC6648]  Saint-Andre, P., Crocker,
      D., and M. Nottingham,\n              \"Deprecating the \"X-\" Prefix and Similar
      Constructs in\n              Application Protocols\", BCP 178, RFC 6648, June
      2012.\n   [RFC6652]  Kitterman, S., \"Sender Policy Framework (SPF)\n              Authentication
      Failure Reporting Using the Abuse Reporting\n              Format\", RFC 6652,
      June 2012.\n   [RFC6686]  Kucherawy, M., \"Resolution of the Sender Policy Framework\n
      \             (SPF) and Sender ID Experiments\", RFC 6686, July 2012.\n   [RFC6891]
      \ Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms\n              for
      DNS (EDNS(0))\", STD 75, RFC 6891, April 2013.\n   [RMX]      Danisch, H., \"The
      RMX DNS RR and method for lightweight\n              SMTP sender authorization\",
      Work in Progress, May 2004.\n   [Vixie]    Vixie, P., \"Repudiating MAIL FROM\",
      2002,\n              <http://marc.info/?l=namedroppers&m=102298170127004&w=4>.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Extended Examples\n   These examples are based on the following
    DNS setup:\n   ; A domain with two mail servers, two hosts, and two servers\n
    \  ; at the domain name\n   $ORIGIN example.com.\n   @           MX  10 mail-a\n
    \              MX  20 mail-b\n               A   192.0.2.10\n               A
    \  192.0.2.11\n   amy         A   192.0.2.65\n   bob         A   192.0.2.66\n
    \  mail-a      A   192.0.2.129\n   mail-b      A   192.0.2.130\n   www         CNAME
    example.com.\n   ; A related domain\n   $ORIGIN example.org.\n   @           MX
    \ 10 mail-c\n   mail-c      A   192.0.2.140\n   ; The reverse IP for those addresses\n
    \  $ORIGIN 2.0.192.in-addr.arpa.\n   10          PTR example.com.\n   11          PTR
    example.com.\n   65          PTR amy.example.com.\n   66          PTR bob.example.com.\n
    \  129         PTR mail-a.example.com.\n   130         PTR mail-b.example.com.\n
    \  140         PTR mail-c.example.org.\n   ; A rogue reverse IP domain that claims
    to be\n   ; something it's not\n   $ORIGIN 0.0.10.in-addr.arpa.\n   4           PTR
    bob.example.com.\n"
  - contents:
    - "A.1.  Simple Examples\n   These examples show various possible published records
      for\n   example.com and which values of <ip> would cause check_host() to\n   return
      \"pass\".  Note that <domain> is \"example.com\".\n   v=spf1 +all\n      --
      any <ip> passes\n   v=spf1 a -all\n      -- hosts 192.0.2.10 and 192.0.2.11
      pass\n   v=spf1 a:example.org -all\n      -- no sending hosts pass since example.org
      has no A records\n   v=spf1 mx -all\n      -- sending hosts 192.0.2.129 and
      192.0.2.130 pass\n   v=spf1 mx:example.org -all\n      -- sending host 192.0.2.140
      passes\n   v=spf1 mx mx:example.org -all\n      -- sending hosts 192.0.2.129,
      192.0.2.130, and 192.0.2.140 pass\n   v=spf1 mx/30 mx:example.org/30 -all\n
      \     -- any sending host in 192.0.2.128/30 or 192.0.2.140/30 passes\n   v=spf1
      ptr -all\n      -- sending host 192.0.2.65 passes (reverse DNS is valid and
      is\n         in example.com)\n      -- sending host 192.0.2.140 fails (reverse
      DNS is valid, but not\n         in example.com)\n      -- sending host 10.0.0.4
      fails (reverse IP is not valid)\n   v=spf1 ip4:192.0.2.128/28 -all\n      --
      sending host 192.0.2.65 fails\n      -- sending host 192.0.2.129 passes\n"
    title: A.1.  Simple Examples
  - contents:
    - "A.2.  Multiple Domain Example\n   These examples show the effect of related
      records:\n      example.org: \"v=spf1 include:example.com include:example.net
      -all\"\n   This record would be used if mail from example.org actually came\n
      \  through servers at example.com and example.net.  Example.org's\n   designated
      servers are the union of example.com's and example.net's\n   designated servers.\n
      \     la.example.org: \"v=spf1 redirect=example.org\"\n      ny.example.org:
      \"v=spf1 redirect=example.org\"\n      sf.example.org: \"v=spf1 redirect=example.org\"\n
      \  These records allow a set of domains that all use the same mail\n   system
      to make use of that mail system's record.  In this way, only\n   the mail system's
      record needs to be updated when the mail setup\n   changes.  These domains'
      records never have to change.\n"
    title: A.2.  Multiple Domain Example
  - contents:
    - "A.3.  DNS Blacklist (DNSBL) Style Example\n   Imagine that, in addition to
      the domain records listed above, there\n   are these (see [RFC5782]):\n   $ORIGIN
      _spf.example.com.\n   mary.mobile-users                   A 127.0.0.2\n   fred.mobile-users
      \                  A 127.0.0.2\n   15.15.168.192.joel.remote-users     A 127.0.0.2\n
      \  16.15.168.192.joel.remote-users     A 127.0.0.2\n   The following records
      describe users at example.com who mail from\n   arbitrary servers, or who mail
      from personal servers.\n   example.com:\n   v=spf1 mx\n          include:mobile-users._spf.%{d}\n
      \         include:remote-users._spf.%{d}\n          -all\n   mobile-users._spf.example.com:\n
      \  v=spf1 exists:%{l1r+}.%{d}\n   remote-users._spf.example.com:\n   v=spf1
      exists:%{ir}.%{l1r+}.%{d}\n"
    title: A.3.  DNS Blacklist (DNSBL) Style Example
  - contents:
    - "A.4.  Multiple Requirements Example\n   Say that your sender policy requires
      both that the IP address is\n   within a certain range and that the reverse
      DNS for the IP matches.\n   This can be done several ways, including the following:\n
      \  example.com.           SPF  ( \"v=spf1 \"\n                                 \"-include:ip4._spf.%{d}
      \"\n                                 \"-include:ptr._spf.%{d} \"\n                                 \"+all\"
      )\n   ip4._spf.example.com.  SPF  \"v=spf1 -ip4:192.0.2.0/24 +all\"\n   ptr._spf.example.com.
      \ SPF  \"v=spf1 -ptr +all\"\n   This example shows how the \"-include\" mechanism
      can be useful, how an\n   SPF record that ends in \"+all\" can be very restrictive,
      and the use\n   of De Morgan's Law.\n"
    title: A.4.  Multiple Requirements Example
  title: Appendix A.  Extended Examples
- contents:
  - "Appendix B.  Changes in Implementation Requirements from RFC 4408\n   The modifications
    to implementation requirements from [RFC4408] are\n   all either (a) corrections
    to errors in [RFC4408] or (b) additional\n   documentation based on consensus
    of operational experience acquired\n   since the publication of [RFC4408].\n   o
    \ Use of DNS RR type SPF (99) has been removed from the protocol;\n      see [RFC6686]
    for background.\n   o  A new DNS-related processing limit based on \"void lookups\"
    has\n      been added (Section 4.6.4).\n   o  Use of the ptr mechanism and the
    %p macro has been strongly\n      discouraged (Sections 5.5 and 7.2).  The ptr
    mechanism and the %p\n      macro remain part of the protocol because they were
    found to be in\n      use, but records ought to be updated to avoid them.\n   o
    \ Use of the \"Authentication-Results\" header field [RFC7001] as a\n      possible
    alternative to use of the \"Received-SPF\" header field is\n      discussed (Section
    9.2).\n   o  There have been a number of minor corrections to the ABNF to make\n
    \     it more clear and correct (Section 12).  SPF library implementers\n      should
    give the revised ABNF a careful review to determine if\n      implementation changes
    are needed.\n   o  Use of X- fields in the ABNF has been removed; see [RFC6648]
    for\n      background.\n   o  Ambiguity about how to deal with invalid <domain-spec>
    after macro\n      expansion has been documented.  Depending on one specific behavior\n
    \     has to be avoided (Section 4.8).\n   o  General operational information
    has been updated and expanded\n      based on eight years of post-[RFC4408] operations
    experience.  See\n      Section 10 and Appendices D through G below.\n   o  Security
    considerations have been reviewed and updated\n      (Section 11).\n"
  title: Appendix B.  Changes in Implementation Requirements from RFC 4408
- contents:
  - "Appendix C.  Further Testing Advice\n   Another approach that can be helpful
    is to publish records that\n   include a \"tracking exists:\" mechanism.  By looking
    at the name\n   server logs, a rough list can then be generated.  For example:\n
    \     v=spf1 exists:_h.%{h}._l.%{l}._o.%{o}._i.%{i}._spf.%{d} ?all\n   This associated
    macro expansion would cause the sending HELO domain,\n   local-part of the sending
    email address, domain part of the sending\n   email address, and the IP address
    from which the connection was\n   received to be embedded in an SPF query and
    logged in the sender's\n   DNS logs.\n   This approach, which has been used since
    very early in the SPF\n   project, allows senders to unilaterally collect data
    to evaluate the\n   correctness of their SPF records.  Unlike newer feedback mechanisms,\n
    \  it does not require any special cooperation from SPF verifiers.  A\n   similar
    example, one of the earliest SPF records published, can still\n   be found as
    of this writing at altavista.net.\n"
  title: Appendix C.  Further Testing Advice
- contents:
  - "Appendix D.  SPF/Mediator Interactions\n   There are three places that techniques
    can be used to ameliorate\n   unintended SPF failures with mediators.\n"
  - contents:
    - "D.1.  Originating ADMDs\n   The beginning, when email is first sent:\n   o
      \ \"Neutral\" results could be given for IP addresses that might be\n      forwarders,
      instead of \"fail\" results based on a list of known\n      reliable forwarders.
      \ For example:\n         \"v=spf1 mx ?exists:%{ir}.whitelist.example.org -all\"\n
      \     This would cause a lookup on a DNS White List (DNSWL) and cause a\n      result
      of \"fail\" only for email not coming from either the\n      domain's mx host(s)
      (SPF pass) or whitelisted sources (SPF\n      neutral).  This, in effect, outsources
      an element of sender policy\n      to the maintainer of the whitelist.\n   o
      \ The \"MAIL FROM\" identity could have additional information in the\n      local-part
      that cryptographically identifies the mail as coming\n      from an authorized
      source.  In this case, an SPF record such as\n      the following could be used:\n
      \        \"v=spf1 mx exists:%{l}._spf_verify.%{d} -all\"\n      Then, a specialized
      DNS server can be set up to serve the\n      _spf_verify subdomain that validates
      the local-part.  Although\n      this requires an extra DNS lookup, this happens
      only when the\n      email would otherwise be rejected as not coming from a
      known good\n      source.\n      Note that due to the 63-character limit for
      domain labels, this\n      approach only works reliably if the local-part signature
      scheme is\n      guaranteed to either only produce local-parts with a maximum
      of\n      63 characters or gracefully handle truncated local-parts.  The\n      method
      used to secure the local-part is a local implementation\n      issue; it need
      not be standard.  An example of one way to do it\n      can be found in [BATV].\n
      \  o  Similarly, a specialized DNS server could be set up that will\n      rate-limit
      the email coming from unexpected IP addresses.\n         \"v=spf1 mx exists:%{ir}._spf_rate.%{d}
      -all\"\n   o  SPF allows the creation of per-user policies for special cases.\n
      \     For example, the following SPF record and appropriate wildcard DNS\n      records
      can be used:\n         \"v=spf1 mx redirect=%{l1r+}._at_.%{o}._spf.%{d}\"\n"
    title: D.1.  Originating ADMDs
  - contents:
    - "D.2.  Mediators\n   The middle, when email is forwarded:\n   o  Mediators can
      solve the problem by rewriting the \"MAIL FROM\" to be\n      in their own domain.
      \ This means mail rejected from the external\n      mailbox will have to be
      forwarded back to the original sender by\n      the forwarding service.  Various
      schemes to do this exist, though\n      they vary widely in complexity and resource
      requirements on the\n      part of the mediator.\n   o  Several popular MTAs
      can be forced from \"alias\" semantics to\n      \"mailing list\" semantics
      by configuring an additional alias with\n      \"owner-\" prepended to the original
      alias name (e.g., an alias of\n      \"friends: george@example.com, fred@example.org\"
      would need another\n      alias of the form \"owner-friends: localowner\").\n
      \  o  Mediators could reject mail that would \"fail\" SPF if forwarded\n      using
      an SMTP reply code of 551, User not local (see Section 3.4\n      of [RFC5321])
      to communicate the correct target address to resend\n      the mail to.\n"
    title: D.2.  Mediators
  - contents:
    - "D.3.  Receiving ADMDs\n   The end, when email is received:\n   o  If the owner
      of the external mailbox wishes to trust the mediator,\n      he can direct the
      external mailbox's MTA to skip SPF tests when\n      the client host belongs
      to the mediator.\n   o  Tests against other identities, such as the \"HELO\"
      identity, can\n      be used to override a failed test against the \"MAIL FROM\"\n
      \     identity.\n   o  For larger domains, it might not be possible to have
      a complete or\n      accurate list of forwarding services used by the owners
      of the\n      domain's mailboxes.  In such cases, whitelists of generally\n
      \     recognized forwarding services could be employed.\n"
    title: D.3.  Receiving ADMDs
  title: Appendix D.  SPF/Mediator Interactions
- contents:
  - "Appendix E.  Mail Services\n   MSPs (Mail Service Providers -- Section 2.3 of
    [RFC5598]) that offer\n   mail services to third-party domains, such as the sending
    of bulk\n   mail, might want to adjust their configurations in light of the\n
    \  authorization check described in this document.  If the domain part\n   of
    the \"MAIL FROM\" identity used for such email uses one of the MSP's\n   domains,
    then the provider needs only to ensure that its sending host\n   is authorized
    by its own SPF record, if any.\n   If the \"MAIL FROM\" identity does not use
    the MSP's domain, then extra\n   care has to be taken.  The SPF record format
    has several options for\n   the third-party domain to authorize the service provider's
    MTAs to\n   send mail on its behalf.  For MSPs, such as ISPs, that have a wide\n
    \  variety of customers using the same MTA, steps are required to\n   mitigate
    the risk of cross-customer forgery (see Section 11.4).\n"
  title: Appendix E.  Mail Services
- contents:
  - "Appendix F.  MTA Relays\n   Relays are described in [RFC5598], Section 2.2.2.
    \ The authorization\n   check generally precludes the use of arbitrary MTA relays
    between the\n   sender and receiver of an email message.\n   Within an organization,
    MTA relays can be effectively deployed.\n   However, for the purposes of this
    document, such relays are\n   effectively transparent.  The SPF authorization
    check is a check\n   between border MTAs of different ADMDs.\n   For mail senders,
    this means published SPF records have to authorize\n   any MTAs that actually
    send across the Internet.  Usually, these are\n   just the border MTAs as internal
    MTAs simply forward mail to these\n   MTAs for relaying.\n   The receiving ADMD
    will generally want to perform the authorization\n   check at the boundary MTAs,
    including all secondary MXs.  Internal\n   MTAs (including MTAs that might serve
    as both boundary MTAs and\n   internal relays from secondary MXs when they are
    processing the\n   relayed mail stream) then do not perform the authorization
    test.  To\n   perform the authorization test other than at the boundary, the host\n
    \  that first transferred the message to the receiving ADMD has to be\n   determined,
    which can be difficult to extract from the message header\n   because (a) header
    fields can be forged or malformed, and (b) there's\n   no standard way to encode
    that information such that it can be\n   reliably extracted.  Testing other than
    at the boundary is likely to\n   produce unreliable results.  This is described
    further in Appendix D\n   of [RFC7001].\n"
  title: Appendix F.  MTA Relays
- contents:
  - "Appendix G.  Local Policy Considerations\n   SPF results can be used in combination
    with other methods to\n   determine the final local disposition (either positive
    or negative)\n   of a message.  It can also be considered dispositive on its own.\n"
  - contents:
    - "G.1.  Policy for SPF Pass\n   SPF \"pass\" results can be used in combination
      with \"whitelists\" of\n   known \"good\" domains to bypass some or all additional
      pre-delivery\n   email checks.  Exactly which checks and how to determine appropriate\n
      \  whitelist entries have to be based on local conditions and\n   requirements.\n"
    title: G.1.  Policy for SPF Pass
  - contents:
    - "G.2.  Policy for SPF Fail\n   SPF \"fail\" results can be used to reject messages
      during the SMTP\n   transaction based on either \"MAIL FROM\" or \"HELO\" identity
      results.\n   This reduces resource requirements for various content-filtering\n
      \  methods and conserves bandwidth since rejection can be done before\n   the
      SMTP content is transferred.  It also gives immediate feedback to\n   the sender,
      who might then be able to resolve the issue.  Due to some\n   of the issues
      described in this section (Appendix G), SPF-based\n   rejection does present
      some risk of rejecting legitimate email when\n   rejecting email based on \"MAIL
      FROM\" results.\n   SPF \"fail\" results can alternately be used as one input
      into a larger\n   set of evaluations that might, based on a combination of SPF
      \"fail\"\n   results with other evaluation techniques, result in the email being\n
      \  marked negatively in some way (this might be via delivery to a\n   special
      spam folder, modifying subject lines, or other locally\n   determined means).
      \ Developing the details of such an approach has to\n   be based on local conditions
      and requirements.  Using SPF results in\n   this way does not have the advantages
      of resource conservation and\n   immediate feedback to the sender associated
      with SMTP rejection, but\n   could produce fewer undesirable rejections in a
      well-designed system.\n   Such an approach might result in email that was not
      authorized by the\n   sending ADMD being unknowingly delivered to end users.\n
      \  Either general approach can be used, as they both leave a clear\n   disposition
      of emails; either they are delivered in some manner or\n   the sender is notified
      of the failure.  Other dispositions such as\n   \"dropping\" or deleting email
      after acceptance are inappropriate\n   because they leave uncertainty and reduce
      the overall reliability and\n   utility of email across the Internet.\n"
    title: G.2.  Policy for SPF Fail
  - contents:
    - "G.3.  Policy for SPF Permerror\n   The \"permerror\" result (see Section 2.6.7)
      indicates that the SPF\n   processing module at the receiver determined that
      the retrieved SPF\n   policy record could not be interpreted.  This gives no
      true\n   indication about the authorized use of the data found in the\n   envelope.\n
      \  As with all results, implementers have a choice to make regarding\n   what
      to do with a message that yields this result.  SMTP allows only\n   a few basic
      options.\n   Rejection of the message is an option, in that it is the one thing
      a\n   receiver can do to draw attention to the difficulty encountered while\n
      \  protecting itself from messages that do not have a definite SPF\n   result
      of some kind.  However, if the SPF implementation is defective\n   and returns
      spurious \"permerror\" results, only the sender is actively\n   notified of
      the defect (in the form of rejected mail), and not the\n   receiver making use
      of SPF.\n   The less intrusive handling choice is to deliver the message, perhaps\n
      \  with some kind of annotation of the difficulty encountered and/or\n   logging
      of a similar nature.  However, this will not be desirable to\n   SPF verifier
      operators that wish to implement SPF checking as\n   strictly as possible, nor
      is this sort of passive reporting of\n   problems typically effective.\n   There
      is of course the option of placing this choice in the hands of\n   the SPF verifier
      operator rather than the implementer since this kind\n   of choice is often
      a matter of local policy rather than a condition\n   with a universal solution,
      but this adds one more piece of complexity\n   to an already non-trivial environment.\n
      \  Both implementers and SPF verifier operators need to be cautious of\n   all
      choices and outcomes when handling SPF results.\n"
    title: G.3.  Policy for SPF Permerror
  - contents:
    - "G.4.  Policy for SPF Temperror\n   The \"temperror\" result (see Section 2.6.6)
      indicates that the SPF\n   processing module at the receiver could not retrieve
      an SPF policy\n   record due to a (probably) transient condition.  This gives
      no true\n   indication about the authorized use of the data found in the\n   envelope.\n
      \  As with all results, implementers have a choice to make regarding\n   what
      to do with a message that yields this result.  SMTP allows only\n   a few basic
      options.\n   Deferring the message is an option, in that it is the one thing
      a\n   receiver can do to draw attention to the difficulty encountered while\n
      \  protecting itself from messages that do not have a definite SPF\n   result
      of some kind.  However, if the SPF implementation is defective\n   and returns
      spurious \"temperror\" results, only the sender is actively\n   notified of
      the defect (in the form of mail rejected after it times\n   out of the sending
      queue), and not the receiver making use of SPF.\n   Because of long queue lifetimes,
      it is possible that mail will be\n   repeatedly deferred for several days, and
      so any awareness that the\n   sender may have regarding a problem could be quite
      delayed.  If\n   \"temperrors\" persist for multiple delivery attempts, it might
      be\n   preferable to treat the error as permanent and reduce the amount of\n
      \  time the message is in transit.\n   The less intrusive handling choice is
      to deliver the message, perhaps\n   with some kind of annotation of the difficulty
      encountered and/or\n   logging of a similar nature.  However, this will not
      be desirable to\n   SPF verifier operators that wish to implement SPF checking
      as\n   strictly as possible, nor is this sort of passive reporting of\n   problems
      typically effective.\n   There is of course the option of placing this choice
      in the hands of\n   the SPF verifier operator rather than the implementer since
      this kind\n   of choice is often a matter of local policy rather than a condition\n
      \  with a universal solution, but this adds one more piece of complexity\n   to
      an already non-trivial environment.\n   Both implementers and SPF verifier operators
      need to be cautious of\n   all choices and outcomes when handling SPF results.\n"
    title: G.4.  Policy for SPF Temperror
  title: Appendix G.  Local Policy Considerations
- contents:
  - "Author's Address\n   Scott Kitterman\n   Kitterman Technical Services\n   3611
    Scheel Dr.\n   Ellicott City, MD  21042\n   United States of America\n   EMail:
    scott@kitterman.com\n"
  title: Author's Address
