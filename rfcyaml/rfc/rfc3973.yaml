- title: __initial_text__
  contents:
  - "         Protocol Independent Multicast - Dense Mode (PIM-DM):\n            \
    \        Protocol Specification (Revised)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Protocol Independent Multicast - Dense Mode\n\
    \   (PIM-DM).  PIM-DM is a multicast routing protocol that uses the\n   underlying\
    \ unicast routing information base to flood multicast\n   datagrams to all multicast\
    \ routers.  Prune messages are used to\n   prevent future messages from propagating\
    \ to routers without group\n   membership information.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n       2.1.  Definitions  . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n       2.2.  Pseudocode Notation  . . . . . . . . . . . . . . .\
    \ . . .  5\n   3.  PIM-DM Protocol Overview . . . . . . . . . . . . . . . . .\
    \ . .  5\n   4.  Protocol Specification . . . . . . . . . . . . . . . . . . .\
    \ .  6\n       4.1.  PIM Protocol State . . . . . . . . . . . . . . . . . . .\
    \  7\n             4.1.1.  General Purpose State  . . . . . . . . . . . . .  7\n\
    \             4.1.2.  (S,G) State  . . . . . . . . . . . . . . . . . .  8\n  \
    \           4.1.3.  State Summarization Macros . . . . . . . . . . .  8\n    \
    \   4.2.  Data Packet Forwarding Rules . . . . . . . . . . . . . . 10\n      \
    \ 4.3.  Hello Messages . . . . . . . . . . . . . . . . . . . . . 11\n        \
    \     4.3.1.  Sending Hello Messages . . . . . . . . . . . . . 11\n          \
    \   4.3.2.  Receiving Hello Messages . . . . . . . . . . . . 11\n            \
    \ 4.3.3.  Hello Message Hold Time  . . . . . . . . . . . . 12\n             4.3.4.\
    \  Handling Router Failures . . . . . . . . . . . . 12\n             4.3.5.  Reducing\
    \ Prune Propagation Delay on LANs . . . . 13\n       4.4.  PIM-DM Prune, Join,\
    \ and Graft Messages . . . . . . . . . 13\n             4.4.1.  Upstream Prune,\
    \ Join, and Graft Messages . . . . 14\n                     4.4.1.1.  Transitions\
    \ from the Forwarding\n                               (F) State  . . . . . . .\
    \ . . . . . . . 17\n                     4.4.1.2.  Transitions from the Pruned\n\
    \                               (P) State  . . . . . . . . . . . . . . 18\n  \
    \                   4.4.1.3.  Transitions from the AckPending\n              \
    \                 (AP) State . . . . . . . . . . . . . . 19\n             4.4.2.\
    \  Downstream Prune, Join, and Graft Messages . . . 21\n                     4.4.2.1.\
    \  Transitions from the NoInfo State  . . 23\n                     4.4.2.2.  Transitions\
    \ from the PrunePending\n                               (PP) State . . . . . .\
    \ . . . . . . . . 24\n                     4.4.2.3.  Transitions from the Prune\n\
    \                               (P) State  . . . . . . . . . . . . . . 25\n  \
    \     4.5.  State Refresh  . . . . . . . . . . . . . . . . . . . . . 26\n    \
    \         4.5.1.  Forwarding of State Refresh Messages . . . . . . 26\n      \
    \       4.5.2.  State Refresh Message Origination  . . . . . . . 28\n        \
    \             4.5.2.1.  Transitions from the NotOriginator\n                 \
    \              (NO) State . . . . . . . . . . . . . . 29\n                   \
    \  4.5.2.2.  Transitions from the Originator\n                               (O)\
    \ State  . . . . . . . . . . . . . . 29\n       4.6.  PIM Assert Messages  . .\
    \ . . . . . . . . . . . . . . . . 30\n             4.6.1.  Assert Metrics . .\
    \ . . . . . . . . . . . . . . . 30\n             4.6.2.  AssertCancel Messages\
    \  . . . . . . . . . . . . . 31\n             4.6.3.  Assert State Macros  . .\
    \ . . . . . . . . . . . . 32\n             4.6.4.  (S,G) Assert Message State\
    \ Machine . . . . . . . 32\n                     4.6.4.1.  Transitions from NoInfo\
    \ State  . . . . 34\n                     4.6.4.2.  Transitions from Winner State\
    \  . . . . 35\n                     4.6.4.3.  Transitions from Loser State . .\
    \ . . . 36\n             4.6.5.  Rationale for Assert Rules . . . . . . . . .\
    \ . . 38\n       4.7.  PIM Packet Formats . . . . . . . . . . . . . . . . . .\
    \ . 38\n             4.7.1.  PIM Header . . . . . . . . . . . . . . . . . . .\
    \ 38\n             4.7.2.  Encoded Unicast Address  . . . . . . . . . . . . 39\n\
    \             4.7.3.  Encoded Group Address  . . . . . . . . . . . . . 40\n  \
    \           4.7.4.  Encoded Source Address . . . . . . . . . . . . . 41\n    \
    \         4.7.5.  Hello Message Format . . . . . . . . . . . . . . 42\n      \
    \               4.7.5.1.  Hello Hold Time Option . . . . . . . . 43\n        \
    \             4.7.5.2.  LAN Prune Delay Option . . . . . . . . 43\n          \
    \           4.7.5.3.  Generation ID Option . . . . . . . . . 44\n            \
    \         4.7.5.4.  State Refresh Capable Option . . . . . 44\n             4.7.6.\
    \  Join/Prune Message Format  . . . . . . . . . . . 45\n             4.7.7.  Assert\
    \ Message Format  . . . . . . . . . . . . . 47\n             4.7.8.  Graft Message\
    \ Format . . . . . . . . . . . . . . 48\n             4.7.9.  Graft Ack Message\
    \ Format . . . . . . . . . . . . 48\n             4.7.10. State Refresh Message\
    \ Format . . . . . . . . . . 48\n       4.8.  PIM-DM Timers  . . . . . . . . .\
    \ . . . . . . . . . . . . 50\n   5.  Protocol Interaction Considerations  . .\
    \ . . . . . . . . . . . 53\n       5.1.  PIM-SM Interactions  . . . . . . . .\
    \ . . . . . . . . . . 53\n       5.2.  IGMP Interactions  . . . . . . . . . .\
    \ . . . . . . . . . 54\n       5.3.  Source Specific Multicast (SSM) Interactions\
    \ . . . . . . 54\n       5.4.  Multicast Group Scope Boundary Interactions  .\
    \ . . . . . 54\n   6.  IANA Considerations  . . . . . . . . . . . . . . . . .\
    \ . . . . 54\n       6.1.  PIM Address Family . . . . . . . . . . . . . . . .\
    \ . . . 54\n       6.2.  PIM Hello Options  . . . . . . . . . . . . . . . . .\
    \ . . 55\n   7.  Security Considerations. . . . . . . . . . . . . . . . . . .\
    \ . 55\n       7.1.  Attacks Based on Forged Messages . . . . . . . . . . . .\
    \ 55\n       7.2.  Non-cryptographic Authentication Mechanisms  . . . . . . 56\n\
    \       7.3.  Authentication Using IPsec . . . . . . . . . . . . . . . 56\n  \
    \     7.4.  Denial of Service Attacks  . . . . . . . . . . . . . . . 58\n   8.\
    \  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 58\n   9.  References\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n       9.1.  Normative\
    \ References . . . . . . . . . . . . . . . . . . 58\n       9.2.  Informative\
    \ References . . . . . . . . . . . . . . . . . 59\n   Authors' Addresses . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 60\n   Full Copyright Statement .\
    \ . . . . . . . . . . . . . . . . . . . . 61\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This specification defines a multicast routing algorithm\
    \ for\n   multicast groups that are densely distributed across a network.  This\n\
    \   protocol does not have a topology discovery mechanism often used by a\n  \
    \ unicast routing protocol.  It employs the same packet formats sparse\n   mode\
    \ PIM (PIM-SM) uses.  This protocol is called PIM - Dense Mode.\n   The foundation\
    \ of this design was largely built on Deering's early\n   work on IP multicast\
    \ routing [12].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" are to\n   be interpreted as described in RFC 2119 [11] and indicate\
    \ requirement\n   levels for compliant PIM-DM implementations.\n"
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   Multicast Routing Information Base (MRIB)\n     This is\
    \ the multicast topology table, which is typically derived\n     from the unicast\
    \ routing table, or from routing protocols such as\n     MBGP that carry multicast-specific\
    \ topology information.  PIM-DM\n     uses the MRIB to make decisions regarding\
    \ RPF interfaces.\n   Tree Information Base (TIB)\n     This is the collection\
    \ of state maintained by a PIM router and\n     created by receiving PIM messages\
    \ and IGMP information from local\n     hosts.  It essentially stores the state\
    \ of all multicast\n     distribution trees at that router.\n   Reverse Path Forwarding\
    \ (RPF)\n     RPF is a multicast forwarding mode in which a data packet is\n \
    \    accepted for forwarding only if it is received on an interface used\n   \
    \  to reach the source in unicast.\n   Upstream Interface\n     Interface toward\
    \ the source of the datagram.  Also known as the RPF\n     Interface.\n   Downstream\
    \ Interface\n     All interfaces that are not the upstream interface, including\
    \ the\n     router itself.\n   (S,G) Pair\n     Source S and destination group\
    \ G associated with an IP packet.\n"
- title: 2.2.  Pseudocode Notation
  contents:
  - "2.2.  Pseudocode Notation\n   We use set notation in several places in this specification.\n\
    \   A (+) B\n     is the union of two sets, A and B.\n   A (-) B\n     are the\
    \ elements of set A that are not in set B.\n   NULL\n     is the empty set or\
    \ list.\n   Note that operations MUST be conducted in the order specified.  This\n\
    \   is due to the fact that (-) is not a true difference operator,\n   because\
    \ B is not necessarily a subset of A.  That is, A (+) B (-) C =\n   A (-) C (+)\
    \ B is not a true statement unless C is a subset of both A\n   and B.\n   In addition,\
    \ we use C-like syntax:\n     =   denotes assignment of a variable.\n     == \
    \ denotes a comparison for equality.\n     !=  denotes a comparison for inequality.\n\
    \   Braces { and } are used for grouping.\n"
- title: 3.  PIM-DM Protocol Overview
  contents:
  - "3.  PIM-DM Protocol Overview\n   This section provides an overview of PIM-DM\
    \ behavior.  It is intended\n   as an introduction to how PIM-DM works and is\
    \ NOT definitive.  For\n   the definitive specification, see Section 4, Protocol\
    \ Specification.\n   PIM-DM assumes that when a source starts sending, all downstream\n\
    \   systems want to receive multicast datagrams.  Initially, multicast\n   datagrams\
    \ are flooded to all areas of the network.  PIM-DM uses RPF\n   to prevent looping\
    \ of multicast datagrams while flooding.  If some\n   areas of the network do\
    \ not have group members, PIM-DM will prune off\n   the forwarding branch by instantiating\
    \ prune state.\n   Prune state has a finite lifetime.  When that lifetime expires,\
    \ data\n   will again be forwarded down the previously pruned branch.\n   Prune\
    \ state is associated with an (S,G) pair.  When a new member for\n   a group G\
    \ appears in a pruned area, a router can \"graft\" toward the\n   source S for\
    \ the group, thereby turning the pruned branch back into a\n   forwarding branch.\n\
    \   The broadcast of datagrams followed by pruning of unwanted branches\n   is\
    \ often referred to as a flood and prune cycle and is typical of\n   dense mode\
    \ protocols.\n   To minimize repeated flooding of datagrams and subsequent pruning\n\
    \   associated with a particular (S,G) pair, PIM-DM uses a state refresh\n   message.\
    \  This message is sent by the router(s) directly connected to\n   the source\
    \ and is propagated throughout the network.  When received\n   by a router on\
    \ its RPF interface, the state refresh message causes an\n   existing prune state\
    \ to be refreshed.\n   Compared with multicast routing protocols with built-in\
    \ topology\n   discovery mechanisms (e.g., DVMRP [13]), PIM-DM has a simplified\n\
    \   design and is not hard-wired into a specific topology discovery\n   protocol.\
    \  However, this simplification does incur more overhead by\n   causing flooding\
    \ and pruning to occur on some links that could be\n   avoided if sufficient topology\
    \ information were available; i.e., to\n   decide whether an interface leads to\
    \ any downstream members of a\n   particular group.  Additional overhead is chosen\
    \ in favor of the\n   simplification and flexibility gained by not depending on\
    \ a specific\n   topology discovery protocol.\n   PIM-DM differs from PIM-SM in\
    \ two essential ways: 1) There are no\n   periodic joins transmitted, only explicitly\
    \ triggered prunes and\n   grafts.  2) There is no Rendezvous Point (RP).  This\
    \ is particularly\n   important in networks that cannot tolerate a single point\
    \ of failure.\n   (An RP is the root of a shared multicast distribution tree.\
    \  For more\n   details, see [4]).\n"
- title: 4.  Protocol Specification
  contents:
  - "4.  Protocol Specification\n   The specification of PIM-DM is broken into several\
    \ parts:\n   * Section 4.1 details the protocol state stored.\n   * Section 4.2\
    \ specifies the data packet forwarding rules.\n   * Section 4.3 specifies generation\
    \ and processing of Hello messages.\n   * Section 4.4 specifies the Join, Prune,\
    \ and Graft generation and\n                 processing rules.\n   * Section 4.5\
    \ specifies the State Refresh generation and forwarding\n                 rules.\n\
    \   * Section 4.6 specifies the Assert generation and processing rules.\n   *\
    \ Section 4.7 gives details on PIM-DM Packet Formats.\n   * Section 4.8 summarizes\
    \ PIM-DM timers and their defaults.\n"
- title: 4.1.  PIM Protocol State
  contents:
  - "4.1.  PIM Protocol State\n   This section specifies all the protocol states that\
    \ a PIM-DM\n   implementation should maintain to function correctly.  We term\
    \ this\n   state the Tree Information Base or TIB, as it holds the state of all\n\
    \   the multicast distribution trees at this router.  In this\n   specification,\
    \ we define PIM-DM mechanisms in terms of the TIB.\n   However, only a very simple\
    \ implementation would actually implement\n   packet forwarding operations in\
    \ terms of this state.  Most\n   implementations will use this state to build\
    \ a multicast forwarding\n   table, which would then be updated when the relevant\
    \ state in the TIB\n   changes.\n   Unlike PIM-SM, PIM-DM does not maintain a\
    \ keepalive timer associated\n   with each (S,G) route.  Within PIM-DM, route\
    \ and state information\n   associated with an (S,G) entry MUST be maintained\
    \ as long as any\n   timer associated with that (S,G) entry is active.  When no\
    \ timer\n   associated with an (S,G) entry is active, all information concerning\n\
    \   that (S,G) route may be discarded.\n   Although we precisely specify the state\
    \ to be kept, this does not\n   mean that an implementation of PIM-DM has to hold\
    \ the state in this\n   form.  This is actually an abstract state definition,\
    \ which is needed\n   in order to specify the router's behavior.  A PIM-DM implementation\n\
    \   is free to hold whatever internal state it requires and will still be\n  \
    \ conformant with this specification as long as it results in the same\n   externally\
    \ visible protocol behavior as an abstract router that holds\n   the following\
    \ state.\n"
- title: 4.1.1.  General Purpose State
  contents:
  - "4.1.1.  General Purpose State\n   A router stores the following non-group-specific\
    \ state:\n   For each interface:\n     Hello Timer (HT)\n     State Refresh Capable\n\
    \     LAN Delay Enabled\n     Propagation Delay (PD)\n     Override Interval (OI)\n\
    \     Neighbor State:\n       For each neighbor:\n         Information from neighbor's\
    \ Hello\n         Neighbor's Gen ID.\n         Neighbor's LAN Prune Delay\n  \
    \       Neighbor's Override Interval\n         Neighbor's State Refresh Capability\n\
    \         Neighbor Liveness Timer (NLT)\n"
- title: 4.1.2.  (S,G) State
  contents:
  - "4.1.2.  (S,G) State\n   For every source/group pair (S,G), a router stores the\
    \ following\n   state:\n   (S,G) state:\n     For each interface:\n       Local\
    \ Membership:\n         State: One of {\"NoInfo\", \"Include\"}\n       PIM (S,G)\
    \ Prune State:\n         State: One of {\"NoInfo\" (NI), \"Pruned\" (P), \"PrunePending\"\
    \n                        (PP)}\n                        Prune Pending Timer (PPT)\n\
    \                        Prune Timer (PT)\n       (S,G) Assert Winner State:\n\
    \         State: One of {\"NoInfo\" (NI), \"I lost Assert\" (L), \"I won\n   \
    \                     Assert\" (W)}\n         Assert Timer (AT)\n         Assert\
    \ winner's IP Address\n         Assert winner's Assert Metric\n     Upstream interface-specific:\n\
    \       Graft/Prune State:\n         State: One of {\"NoInfo\" (NI), \"Pruned\"\
    \ (P), \"Forwarding\" (F),\n                        \"AckPending\" (AP) }\n  \
    \       GraftRetry Timer (GRT)\n         Override Timer (OT)\n         Prune Limit\
    \ Timer (PLT)\n       Originator State:\n         Source Active Timer (SAT)\n\
    \         State Refresh Timer (SRT)\n"
- title: 4.1.3.  State Summarization Macros
  contents:
  - "4.1.3.  State Summarization Macros\n   Using the state defined above, the following\
    \ \"macros\" are defined and\n   will be used in the descriptions of the state\
    \ machines and pseudocode\n   in the following sections.\n   The most important\
    \ macros are those defining the outgoing interface\n   list (or \"olist\") for\
    \ the relevant state.\n   immediate_olist(S,G) = pim_nbrs (-) prunes(S,G) (+)\n\
    \                          (pim_include(*,G) (-) pim_exclude(S,G) ) (+)\n    \
    \                      pim_include(S,G) (-) lost_assert(S,G) (-)\n           \
    \               boundary(G)\n   olist(S,G) = immediate_olist(S,G) (-) RPF_interface(S)\n\
    \   The macros pim_include(*,G) and pim_include(S,G) indicate the\n   interfaces\
    \ to which traffic might or might not be forwarded because\n   of hosts that are\
    \ local members on those interfaces.\n   pim_include(*,G) = {all interfaces I\
    \ such that:\n                       local_receiver_include(*,G,I)}\n   pim_include(S,G)\
    \ = {all interfaces I such that:\n                       local_receiver_include(S,G,I)}\n\
    \   pim_exclude(S,G) = {all interfaces I such that:\n                       local_receiver_exclude(S,G,I)}\n\
    \   The macro RPF_interface(S) returns the RPF interface for source S.\n   That\
    \ is to say, it returns the interface used to reach S as indicated\n   by the\
    \ MRIB.\n   The macro local_receiver_include(S,G,I) is true if the IGMP module\
    \ or\n   other local membership mechanism ([1], [2], [3], [6]) has determined\n\
    \   that there are local members on interface I that seek to receive\n   traffic\
    \ sent specifically by S to G.\n   The macro local_receiver_include(*,G,I) is\
    \ true if the IGMP module or\n   other local membership mechanism has determined\
    \ that there are local\n   members on interface I that seek to receive all traffic\
    \ sent to G.\n   Note that this determination is expected to account for membership\n\
    \   joins initiated on or by the router.\n   The macro local_receiver_exclude(S,G,I)\
    \ is true if\n   local_receiver_include(*,G,I) is true but none of the local members\n\
    \   seek to receive traffic from S.\n   The set pim_nbrs is the set of all interfaces\
    \ on which the router has\n   at least one active PIM neighbor.\n   The set prunes(S,G)\
    \ is the set of all interfaces on which the router\n   has received Prune(S,G)\
    \ messages:\n   prunes(S,G) = {all interfaces I such that\n                  DownstreamPState(S,G,I)\
    \ is in Pruned state}\n   The set lost_assert(S,G) is the set of all interfaces\
    \ on which the\n   router has lost an (S,G) Assert.\n   lost_assert(S,G) = {all\
    \ interfaces I such that\n                       lost_assert(S,G,I) == TRUE}\n\
    \   boundary(G) = {all interfaces I with an administratively scoped\n        \
    \          boundary for group G}\n   The following pseudocode macro definitions\
    \ are also used in many\n   places in the specification.  Basically RPF' is the\
    \ RPF neighbor\n   toward a source unless a PIM-DM Assert has overridden the normal\n\
    \   choice of neighbor.\n   neighbor RPF'(S,G) {\n     if ( I_Am_Assert_loser(S,\
    \ G, RPF_interface(S) )) {\n       return AssertWinner(S, G, RPF_interface(S)\
    \ )\n     } else {\n       return MRIB.next_hop( S )\n     }\n   }\n   The macro\
    \ I_Am_Assert_loser(S, G, I) is true if the Assert state\n   machine (in Section\
    \ 4.6) for (S,G) on interface I is in the \"I am\n   Assert Loser\" state.\n"
- title: 4.2.  Data Packet Forwarding Rules
  contents:
  - "4.2.  Data Packet Forwarding Rules\n   The PIM-DM packet forwarding rules are\
    \ defined below in pseudocode.\n   iif is the incoming interface of the packet.\
    \  S is the source address\n   of the packet.  G is the destination address of\
    \ the packet (group\n   address).  RPF_interface(S) is the interface the MRIB\
    \ indicates would\n   be used to route packets to S.\n   First, an RPF check MUST\
    \ be performed to determine whether the packet\n   should be accepted based on\
    \ TIB state and the interface on which that\n   the packet arrived.  Packets that\
    \ fail the RPF check MUST NOT be\n   forwarded, and the router will conduct an\
    \ assert process for the\n   (S,G) pair specified in the packet.  Packets for\
    \ which a route to the\n   source cannot be found MUST be discarded.\n   If the\
    \ RPF check has been passed, an outgoing interface list is\n   constructed for\
    \ the packet.  If this list is not empty, then the\n   packet MUST be forwarded\
    \ to all listed interfaces.  If the list is\n   empty, then the router will conduct\
    \ a prune process for the (S,G)\n   pair specified in the packet.\n   Upon receipt\
    \ of a data packet from S addressed to G on interface iif:\n   if (iif == RPF_interface(S)\
    \ AND UpstreamPState(S,G) != Pruned) {\n       oiflist = olist(S,G)\n   } else\
    \ {\n       oiflist = NULL\n   }\n   forward packet on all interfaces in oiflist\n\
    \   This pseudocode employs the following \"macro\" definition:\n   UpstreamPState(S,G)\
    \ is the state of the Upstream(S,G) state machine\n   in Section 4.4.1.\n"
- title: 4.3.  Hello Messages
  contents:
  - "4.3.  Hello Messages\n   This section describes the generation and processing\
    \ of Hello\n   messages.\n"
- title: 4.3.1.  Sending Hello Messages
  contents:
  - "4.3.1.  Sending Hello Messages\n   PIM-DM uses Hello messages to detect other\
    \ PIM routers.  Hello\n   messages are sent periodically on each PIM enabled interface.\
    \  Hello\n   messages are multicast to the ALL-PIM-ROUTERS group.  When PIM is\n\
    \   enabled on an interface or when a router first starts, the Hello\n   Timer\
    \ (HT) MUST be set to random value between 0 and\n   Triggered_Hello_Delay.  This\
    \ prevents synchronization of Hello\n   messages if multiple routers are powered\
    \ on simultaneously.\n   After the initial Hello message, a Hello message MUST\
    \ be sent every\n   Hello_Period.  A single Hello timer MAY be used to trigger\
    \ sending\n   Hello messages on all active interfaces.  The Hello Timer SHOULD\
    \ NOT\n   be reset except when it expires.\n"
- title: 4.3.2.  Receiving Hello Messages
  contents:
  - "4.3.2.  Receiving Hello Messages\n   When a Hello message is received, the receiving\
    \ router SHALL record\n   the receiving interface, the sender, and any information\
    \ contained in\n   recognized options.  This information is retained for a number\
    \ of\n   seconds in the Hold Time field of the Hello Message.  If a new Hello\n\
    \   message is received from a particular neighbor N, the Neighbor\n   Liveness\
    \ Timer (NLT(N,I)) MUST be reset to the newly received Hello\n   Holdtime.  If\
    \ a Hello message is received from a new neighbor, the\n   receiving router SHOULD\
    \ send its own Hello message after a random\n   delay between 0 and Triggered_Hello_Delay.\n"
- title: 4.3.3.  Hello Message Hold Time
  contents:
  - "4.3.3.  Hello Message Hold Time\n   The Hold Time in the Hello Message should\
    \ be set to a value that can\n   reasonably be expected to keep the Hello active\
    \ until a new Hello\n   message is received.  On most links, this will be 3.5\
    \ times the value\n   of Hello_Period.\n   If the Hold Time is set to '0xffff',\
    \ the receiving router MUST NOT\n   time out that Hello message.  This feature\
    \ might be used for on-\n   demand links to avoid keeping the link up with periodic\
    \ Hello\n   messages.\n   If a Hold Time of '0' is received, the corresponding\
    \ neighbor state\n   expires immediately.  When a PIM router takes an interface\
    \ down or\n   changes IP address, a Hello message with a zero Hold Time SHOULD\
    \ be\n   sent immediately (with the old IP address if the IP address is\n   changed)\
    \ to cause any PIM neighbors to remove the old information\n   immediately.\n"
- title: 4.3.4.  Handling Router Failures
  contents:
  - "4.3.4.  Handling Router Failures\n   If a Hello message is received from an active\
    \ neighbor with a\n   different Generation ID (GenID), the neighbor has restarted\
    \ and may\n   not contain the correct (S,G) state.  A Hello message SHOULD be\
    \ sent\n   after a random delay between 0 and Triggered_Hello_Delay (see 4.8)\n\
    \   before any other messages are sent.  If the neighbor is downstream,\n   the\
    \ router MAY replay the last State Refresh message for any (S,G)\n   pairs for\
    \ which it is the Assert Winner indicating Prune and Assert\n   status to the\
    \ downstream router.  These State Refresh messages SHOULD\n   be sent out immediately\
    \ after the Hello message.  If the neighbor is\n   the upstream neighbor for an\
    \ (S,G) entry, the router MAY cancel its\n   Prune Limit Timer to permit sending\
    \ a prune and reestablishing a\n   Pruned state in the upstream router.\n   Upon\
    \ startup, a router MAY use any State Refresh messages received\n   within Hello_Period\
    \ of its first Hello message on an interface to\n   establish state information.\
    \  The State Refresh source will be the\n   RPF'(S), and Prune status for all\
    \ interfaces will be set according to\n   the Prune Indicator bit in the State\
    \ Refresh message.  If the Prune\n   Indicator is set, the router SHOULD set the\
    \ PruneLimitTimer to\n   Prune_Holdtime and set the PruneTimer on all downstream\
    \ interfaces to\n   the State Refresh's Interval times two.  The router SHOULD\
    \ then\n   propagate the State Refresh as described in Section 4.5.1.\n"
- title: 4.3.5.  Reducing Prune Propagation Delay on LANs
  contents:
  - "4.3.5.  Reducing Prune Propagation Delay on LANs\n   If all routers on a LAN\
    \ support the LAN Prune Delay option, then the\n   PIM routers on that LAN will\
    \ use the values received to adjust their\n   J/P_Override_Interval on that interface\
    \ and the interface is LAN\n   Delay Enabled.  Briefly, to avoid synchronization\
    \ of Prune Override\n   (Join) messages when multiple downstream routers share\
    \ a multi-access\n   link, sending of these messages is delayed by a small random\
    \ amount\n   of time.  The period of randomization is configurable and has a\n\
    \   default value of 3 seconds.\n   Each router on the LAN expresses its view\
    \ of the amount of\n   randomization necessary in the Override Interval field\
    \ of the LAN\n   Prune Delay option.  When all routers on a LAN use the LAN Prune\n\
    \   Delay Option, all routers on the LAN MUST set their Override_Interval\n  \
    \ to the largest Override value on the LAN.\n   The LAN Delay inserted by a router\
    \ in the LAN Prune Delay option\n   expresses the expected message propagation\
    \ delay on the link and\n   SHOULD be configurable by the system administrator.\
    \  When all routers\n   on a link use the LAN Prune Delay Option, all routers\
    \ on the LAN MUST\n   set Propagation Delay to the largest LAN Delay on the LAN.\n\
    \   PIM implementers should enforce a lower bound on the permitted values\n  \
    \ for this delay to allow for scheduling and processing delays within\n   their\
    \ router.  Such delays may cause received messages to be\n   processed later and\
    \ triggered messages to be sent later than\n   intended.  Setting this LAN Prune\
    \ Delay to too low a value may result\n   in temporary forwarding outages, because\
    \ a downstream router will not\n   be able to override a neighbor's prune message\
    \ before the upstream\n   neighbor stops forwarding.\n"
- title: 4.4.  PIM-DM Prune, Join, and Graft Messages
  contents:
  - "4.4.  PIM-DM Prune, Join, and Graft Messages\n   This section describes the generation\
    \ and processing of PIM-DM Join,\n   Prune, and Graft messages.  Prune messages\
    \ are sent toward the\n   upstream neighbor for S to indicate that traffic from\
    \ S addressed to\n   group G is not desired.  In the case of downstream routers\
    \ A and B,\n   where A wishes to continue receiving data and B does not, A will\
    \ send\n   a Join in response to B's Prune to override the Prune.  This is the\n\
    \   only situation in PIM-DM in which a Join message is used.  Finally, a\n  \
    \ Graft message is used to re-join a previously pruned branch to the\n   delivery\
    \ tree.\n"
- title: 4.4.1.  Upstream Prune, Join, and Graft Messages
  contents:
  - "4.4.1.  Upstream Prune, Join, and Graft Messages\n   The Upstream(S,G) state\
    \ machine for sending Prune, Graft, and Join\n   messages is given below.  There\
    \ are three states.\n     Forwarding (F)\n       This is the starting state of\
    \ the Upsteam(S,G) state machine.\n       The state machine is in this state if\
    \ it just started or if\n       oiflist(S,G) != NULL.\n     Pruned (P)\n     \
    \  The set, olist(S,G), is empty.  The router will not forward data\n       from\
    \ S addressed to group G.\n     AckPending (AP)\n       The router was in the\
    \ Pruned(P) state, but a transition has\n       occurred in the Downstream(S,G)\
    \ state machine for one of this\n       (S,G) entry's outgoing interfaces, indicating\
    \ that traffic from S\n       addressed to G should again be forwarded.  A Graft\
    \ message has\n       been sent to RPF'(S), but a Graft Ack message has not yet\
    \ been\n       received.\n   In addition, there are three state-machine-specific\
    \ timers:\n     GraftRetry Timer (GRT(S,G))\n       This timer is set when a Graft\
    \ is sent upstream.  If a\n       corresponding GraftAck is not received before\
    \ the timer expires,\n       then another Graft is sent, and the GraftRetry Timer\
    \ is reset.\n       The timer is stopped when a Graft Ack message is received.\
    \  This\n       timer is normally set to Graft_Retry_Period (see 4.8).\n     Override\
    \ Timer (OT(S,G))\n       This timer is set when a Prune(S,G) is received on the\
    \ upstream\n       interface where olist(S,G) != NULL.  When the timer expires,\
    \ a\n       Join(S,G) message is sent on the upstream interface.  This timer\n\
    \       is normally set to t_override (see 4.8).\n     Prune Limit Timer (PLT(S,G))\n\
    \       This timer is used to rate-limit Prunes on a LAN.  It is only\n      \
    \ used when the Upstream(S,G) state machine is in the Pruned state.\n       A\
    \ Prune cannot be sent if this timer is running.  This timer is\n       normally\
    \ set to t_limit (see 4.8).\n          +-------------+                       \
    \ +-------------+\n          |             |     olist == NULL      |        \
    \     |\n          |   Forward   |----------------------->|   Pruned    |\n  \
    \        |             |                        |             |\n          +-------------+\
    \                        +-------------+\n               ^   |               \
    \                   ^   |\n               |   |                              \
    \    |   |\n               |   |RPF`(S) Changes      olist == NULL|   |\n    \
    \           |   |                                  |   |\n               |   |\
    \         +-------------+          |   |\n               |   +-------->|     \
    \        |----------+   |\n               |             | AckPending  |      \
    \        |\n               +-------------|             |<-------------+\n    \
    \         Rcv GraftAck OR +-------------+ olist != NULL\n           Rcv State\
    \ Refresh\n              With (P==0) OR\n          S Directly Connect\n      \
    \          Figure 1: Upstream Interface State Machine\n   In tabular form, the\
    \ state machine is defined as follows:\n"
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '|                               |            Previous State            |'
  contents:
  - '|                               |            Previous State            |

    '
- title: '|                               +------------+------------+------------+'
  contents:
  - '|                               +------------+------------+------------+

    '
- title: '|            Event              | Forwarding |   Pruned   | AckPending |'
  contents:
  - '|            Event              | Forwarding |   Pruned   | AckPending |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Data packet arrives on        | ->P Send   | ->P Send   | N/A        |'
  contents:
  - '| Data packet arrives on        | ->P Send   | ->P Send   | N/A        |

    '
- title: '| RPF_Interface(S) AND          | Prune(S,G) | Prune(S,G) |            |'
  contents:
  - '| RPF_Interface(S) AND          | Prune(S,G) | Prune(S,G) |            |

    '
- title: '| olist(S,G) == NULL AND        |Set PLT(S,G)|Set PLT(S,G)|            |'
  contents:
  - '| olist(S,G) == NULL AND        |Set PLT(S,G)|Set PLT(S,G)|            |

    '
- title: '| PLT(S,G) not running          |            |            |            |'
  contents:
  - '| PLT(S,G) not running          |            |            |            |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| State Refresh(S,G) received   | ->F  Set   | ->P Reset  |->AP  Set   |'
  contents:
  - '| State Refresh(S,G) received   | ->F  Set   | ->P Reset  |->AP  Set   |

    '
- title: '| from RPF`(S) AND              |    OT(S,G) |  PLT(S,G)  |    OT(S,G) |'
  contents:
  - '| from RPF`(S) AND              |    OT(S,G) |  PLT(S,G)  |    OT(S,G) |

    '
- title: '| Prune Indicator == 1          |            |            |            |'
  contents:
  - '| Prune Indicator == 1          |            |            |            |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| State Refresh(S,G) received   | ->F        | ->P Send   |->F Cancel  |'
  contents:
  - '| State Refresh(S,G) received   | ->F        | ->P Send   |->F Cancel  |

    '
- title: '| from RPF`(S) AND              |            | Prune(S,G) |  GRT(S,G)  |'
  contents:
  - '| from RPF`(S) AND              |            | Prune(S,G) |  GRT(S,G)  |

    '
- title: '| Prune Indicator == 0 AND      |            |Set PLT(S,G)|            |'
  contents:
  - '| Prune Indicator == 0 AND      |            |Set PLT(S,G)|            |

    '
- title: '| PLT(S,G) not running          |            |            |            |'
  contents:
  - '| PLT(S,G) not running          |            |            |            |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '|                               |            Previous State            |'
  contents:
  - '|                               |            Previous State            |

    '
- title: +                               +------------+------------+------------+
  contents:
  - '+                               +------------+------------+------------+

    '
- title: '|            Event              | Forwarding |   Pruned   | AckPending |'
  contents:
  - '|            Event              | Forwarding |   Pruned   | AckPending |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| See Join(S,G) to RPF''(S)      | ->F Cancel | ->P        |->AP Cancel
    |'
  contents:
  - '| See Join(S,G) to RPF''(S)      | ->F Cancel | ->P        |->AP Cancel |

    '
- title: '|                               |    OT(S,G) |            |    OT(S,G) |'
  contents:
  - '|                               |    OT(S,G) |            |    OT(S,G) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| See Prune(S,G)                | ->F Set    | ->P        |->AP Set    |'
  contents:
  - '| See Prune(S,G)                | ->F Set    | ->P        |->AP Set    |

    '
- title: '|                               |    OT(S,G) |            |    OT(S,G) |'
  contents:
  - '|                               |    OT(S,G) |            |    OT(S,G) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| OT(S,G) Expires               | ->F Send   | N/A        |->AP Send   |'
  contents:
  - '| OT(S,G) Expires               | ->F Send   | N/A        |->AP Send   |

    '
- title: '|                               |  Join(S,G) |            |  Join(S,G) |'
  contents:
  - '|                               |  Join(S,G) |            |  Join(S,G) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| olist(S,G)->NULL              | ->P Send   | N/A        |->P Send    |'
  contents:
  - '| olist(S,G)->NULL              | ->P Send   | N/A        |->P Send    |

    '
- title: '|                               | Prune(S,G) |            | Prune(S,G) |'
  contents:
  - '|                               | Prune(S,G) |            | Prune(S,G) |

    '
- title: '|                               |Set PLT(S,G)|            |Set PLT(S,G)|'
  contents:
  - '|                               |Set PLT(S,G)|            |Set PLT(S,G)|

    '
- title: '|                               |            |            | Cancel     |'
  contents:
  - '|                               |            |            | Cancel     |

    '
- title: '|                               |            |            | GRT(S,G)   |'
  contents:
  - '|                               |            |            | GRT(S,G)   |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| olist(S,G)->non-NULL          | N/A        | ->AP Send  | N/A        |'
  contents:
  - '| olist(S,G)->non-NULL          | N/A        | ->AP Send  | N/A        |

    '
- title: '|                               |            | Graft(S,G) |            |'
  contents:
  - '|                               |            | Graft(S,G) |            |

    '
- title: '|                               |            |Set GRT(S,G)|            |'
  contents:
  - '|                               |            |Set GRT(S,G)|            |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| RPF''(S) Changes AND           | ->AP Send  | ->AP Send  |->AP Send   |'
  contents:
  - '| RPF''(S) Changes AND           | ->AP Send  | ->AP Send  |->AP Send   |

    '
- title: '| olist(S,G) != NULL            | Graft(S,G) | Graft(S,G) | Graft(S,G) |'
  contents:
  - '| olist(S,G) != NULL            | Graft(S,G) | Graft(S,G) | Graft(S,G) |

    '
- title: '|                               |Set GRT(S,G)|Set GRT(S,G)|Set GRT(S,G)|'
  contents:
  - '|                               |Set GRT(S,G)|Set GRT(S,G)|Set GRT(S,G)|

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| RPF''(S) Changes AND           | ->P        | ->P Cancel |->P Cancel  |'
  contents:
  - '| RPF''(S) Changes AND           | ->P        | ->P Cancel |->P Cancel  |

    '
- title: '| olist(S,G) == NULL            |            |  PLT(S,G)  |  GRT(S,G)  |'
  contents:
  - '| olist(S,G) == NULL            |            |  PLT(S,G)  |  GRT(S,G)  |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| S becomes directly connected  | ->F        | ->P        |->F Cancel  |'
  contents:
  - '| S becomes directly connected  | ->F        | ->P        |->F Cancel  |

    '
- title: '|                               |            |            |  GRT(S,G)  |'
  contents:
  - '|                               |            |            |  GRT(S,G)  |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| GRT(S,G) Expires              | N/A        | N/A        |->AP Send   |'
  contents:
  - '| GRT(S,G) Expires              | N/A        | N/A        |->AP Send   |

    '
- title: '|                               |            |            | Graft(S,G) |'
  contents:
  - '|                               |            |            | Graft(S,G) |

    '
- title: '|                               |            |            |Set GRT(S,G)|'
  contents:
  - '|                               |            |            |Set GRT(S,G)|

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Receive GraftAck(S,G) from    | ->F        | ->P        |->F Cancel  |'
  contents:
  - '| Receive GraftAck(S,G) from    | ->F        | ->P        |->F Cancel  |

    '
- title: '| RPF''(S)                       |            |            |  GRT(S,G)  |'
  contents:
  - '| RPF''(S)                       |            |            |  GRT(S,G)  |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - "+-------------------------------+------------+------------+------------+\n  \
    \ The transition event \"RcvGraftAck(S,G)\" implies receiving a Graft Ack\n  \
    \ message targeted to this router's address on the incoming interface\n   for\
    \ the (S,G) entry.  If the destination address is not correct, the\n   state transitions\
    \ in this state machine must not occur.\n"
- title: 4.4.1.1.  Transitions from the Forwarding (F) State
  contents:
  - "4.4.1.1.  Transitions from the Forwarding (F) State\n   When the Upstream(S,G)\
    \ state machine is in the Forwarding (F) state,\n   the following events may trigger\
    \ a transition:\n     Data Packet arrives on RPF_Interface(S) AND olist(S,G) ==\
    \ NULL AND\n     S NOT directly connected\n       The Upstream(S,G) state machine\
    \ MUST transition to the Pruned (P)\n       state, send a Prune(S,G) to RPF'(S),\
    \ and set PLT(S,G) to t_limit\n       seconds.\n     State Refresh(S,G) Received\
    \ from RPF'(S)\n       The Upstream(S,G) state machine remains in a Forwarding\
    \ state.\n       If the received State Refresh has the Prune Indicator bit set\
    \ to\n       one, this router must override the upstream router's Prune state\n\
    \       after a short random interval.  If OT(S,G) is not running and the\n  \
    \     Prune Indicator bit equals one, the router MUST set OT(S,G) to\n       t_override\
    \ seconds.\n     See Join(S,G) to RPF'(S)\n       This event is only relevant\
    \ if RPF_interface(S) is a shared\n       medium.  This router sees another router\
    \ on RPF_interface(S) send\n       a Join(S,G) to RPF'(S,G).  If the OT(S,G) is\
    \ running, then it\n       means that the router had scheduled a Join to override\
    \ a\n       previously received Prune.  Another router has responded more\n  \
    \     quickly with a Join, so the local router SHOULD cancel its\n       OT(S,G),\
    \ if it is running.  The Upstream(S,G) state machine\n       remains in the Forwarding\
    \ (F) state.\n     See Prune(S,G) AND S NOT directly connected\n       This event\
    \ is only relevant if RPF_interface(S) is a shared\n       medium.  This router\
    \ sees another router on RPF_interface(S) send\n       a Prune(S,G).  As this\
    \ router is in Forwarding state, it must\n       override the Prune after a short\
    \ random interval.  If OT(S,G) is\n       not running, the router MUST set OT(S,G)\
    \ to t_override seconds.\n       The Upstream(S,G) state machine remains in Forwarding\
    \ (F) state.\n     OT(S,G) Expires AND S NOT directly connected\n       The OverrideTimer\
    \ (OT(S,G)) expires.  The router MUST send a\n       Join(S,G) to RPF'(S) to override\
    \ a previously detected prune.\n       The Upstream(S,G) state machine remains\
    \ in the Forwarding (F)\n       state.\n     olist(S,G) -> NULL AND S NOT directly\
    \ connected\n       The Upstream(S,G) state machine MUST transition to the Pruned\
    \ (P)\n       state, send a Prune(S,G) to RPF'(S), and set PLT(S,G) to t_limit\n\
    \       seconds.\n     RPF'(S) Changes AND olist(S,G) is non-NULL AND S NOT directly\n\
    \     connected\n       Unicast routing or Assert state causes RPF'(S) to change,\n\
    \       including changes to RPF_Interface(S).  The Upstream(S,G) state\n    \
    \   machine MUST transition to the AckPending (AP) state, unicast a\n       Graft\
    \ to the new RPF'(S), and set the GraftRetry Timer (GRT(S,G))\n       to Graft_Retry_Period.\n\
    \     RPF'(S) Changes AND olist(S,G) is NULL\n       Unicast routing or Assert\
    \ state causes RPF'(S) to change,\n       including changes to RPF_Interface(S).\
    \  The Upstream(S,G) state\n       machine MUST transition to the Pruned (P) state.\n"
- title: 4.4.1.2.  Transitions from the Pruned (P) State
  contents:
  - "4.4.1.2.  Transitions from the Pruned (P) State\n   When the Upstream(S,G) state\
    \ machine is in the Pruned (P) state, the\n   following events may trigger a transition:\n\
    \     Data arrives on RPF_interface(S) AND PLT(S,G) not running AND S NOT\n  \
    \   directly connected\n       Either another router on the LAN desires traffic\
    \ from S addressed\n       to G or a previous Prune was lost.  To prevent generating\
    \ a\n       Prune(S,G) in response to every data packet, the PruneLimit Timer\n\
    \       (PLT(S,G)) is used.  Once the PLT(S,G) expires, the router needs\n   \
    \    to send another prune in response to a data packet not received\n       directly\
    \ from the source.  A Prune(S,G) MUST be sent to RPF'(S),\n       and the PLT(S,G)\
    \ MUST be set to t_limit.\n     State Refresh(S,G) Received from RPF'(S)\n   \
    \    The Upstream(S,G) state machine remains in a Pruned state.  If\n       the\
    \ State Refresh has its Prune Indicator bit set to zero and\n       PLT(S,G) is\
    \ not running, a Prune(S,G) MUST be sent to RPF'(S),\n       and the PLT(S,G)\
    \ MUST be set to t_limit.  If the State Refresh\n       has its Prune Indicator\
    \ bit set to one, the router MUST reset\n       PLT(S,G) to t_limit.\n     See\
    \ Prune(S,G) to RPF'(S)\n       A Prune(S,G) is seen on RPF_interface(S) to RPF'(S).\
    \  The\n       Upstream(S,G) state machine stays in the Pruned (P) state.  The\n\
    \       router MAY reset its PLT(S,G) to the value in the Holdtime field\n   \
    \    of the received message if it is greater than the current value\n       of\
    \ the PLT(S,G).\n     olist(S,G)->non-NULL AND S NOT directly connected\n    \
    \   The set of interfaces defined by the olist(S,G) macro becomes\n       non-empty,\
    \ indicating that traffic from S addressed to group G\n       must be forwarded.\
    \  The Upstream(S,G) state machine MUST cancel\n       PLT(S,G), transition to\
    \ the AckPending (AP) state and unicast a\n       Graft message to RPF'(S).  The\
    \ Graft Retry Timer (GRT(S,G)) MUST\n       be set to Graft_Retry_Period.\n  \
    \   RPF'(S) Changes AND olist(S,G) == non-NULL AND S NOT directly\n     connected\n\
    \       Unicast routing or Assert state causes RPF'(S) to change,\n       including\
    \ changes to RPF_Interface(S).  The Upstream(S,G) state\n       machine MUST cancel\
    \ PLT(S,G), transition to the AckPending (AP)\n       state, send a Graft unicast\
    \ to the new RPF'(S), and set the\n       GraftRetry Timer (GRT(S,G)) to Graft_Retry_Period.\n\
    \     RPF'(S) Changes AND olist(S,G) == NULL AND S NOT directly connected\n  \
    \     Unicast routing or Assert state causes RPF'(S) to change,\n       including\
    \ changes to RPF_Interface(S).  The Upstream(S,G) state\n       machine stays\
    \ in the Pruned (P) state and MUST cancel the\n       PLT(S,G) timer.\n     S\
    \ becomes directly connected\n       Unicast routing changed so that S is directly\
    \ connected.  The\n       Upstream(S,G) state machine remains in the Pruned (P)\
    \ state.\n"
- title: 4.4.1.3.  Transitions from the AckPending (AP) State
  contents:
  - "4.4.1.3.  Transitions from the AckPending (AP) State\n   When the Upstream(S,G)\
    \ state machine is in the AckPending (AP) state,\n   the following events may\
    \ trigger a transition:\n     State Refresh(S,G) Received from RPF'(S) with Prune\
    \ Indicator == 1\n       The Upstream(S,G) state machine remains in an AckPending\
    \ state.\n       The router must override the upstream router's Prune state after\n\
    \       a short random interval.  If OT(S,G) is not running and the Prune\n  \
    \     Indicator bit equals one, the router MUST set OT(S,G) to\n       t_override\
    \ seconds.\n     State Refresh(S,G) Received from RPF'(S) with Prune Indicator\
    \ == 0\n       The router MUST cancel its GraftRetry Timer (GRT(S,G)) and\n  \
    \     transition to the Forwarding (F) state.\n     See Join(S,G) to RPF'(S,G)\n\
    \       This event is only relevant if RPF_interface(S) is a shared\n       medium.\
    \  This router sees another router on RPF_interface(S) send\n       a Join(S,G)\
    \ to RPF'(S,G).  If the OT(S,G) is running, then it\n       means that the router\
    \ had scheduled a Join to override a\n       previously received Prune.  Another\
    \ router has responded more\n       quickly with a Join, so the local router SHOULD\
    \ cancel its\n       OT(S,G), if it is running.  The Upstream(S,G) state machine\n\
    \       remains in the AckPending (AP) state.\n     See Prune(S,G)\n       This\
    \ event is only relevant if RPF_interface(S) is a shared\n       medium.  This\
    \ router sees another router on RPF_interface(S) send\n       a Prune(S,G).  As\
    \ this router is in AckPending (AP) state, it\n       must override the Prune\
    \ after a short random interval.  If\n       OT(S,G) is not running, the router\
    \ MUST set OT(S,G) to t_override\n       seconds.  The Upstream(S,G) state machine\
    \ remains in AckPending\n       (AP) state.\n     OT(S,G) Expires\n       The\
    \ OverrideTimer (OT(S,G)) expires.  The router MUST send a\n       Join(S,G) to\
    \ RPF'(S).  The Upstream(S,G) state machine remains in\n       the AckPending\
    \ (AP) state.\n     olist(S,G) -> NULL\n       The set of interfaces defined by\
    \ the olist(S,G) macro becomes\n       null, indicating that traffic from S addressed\
    \ to group G should\n       no longer be forwarded.  The Upstream(S,G) state machine\
    \ MUST\n       transition to the Pruned (P) state.  A Prune(S,G) MUST be\n   \
    \    multicast to the RPF_interface(S), with RPF'(S) named in the\n       upstream\
    \ neighbor field.  The GraftRetry Timer (GRT(S,G)) MUST be\n       cancelled,\
    \ and PLT(S,G) MUST be set to t_limit seconds.\n     RPF'(S) Changes AND olist(S,G)\
    \ does not become NULL AND S NOT\n     directly connected\n       Unicast routing\
    \ or Assert state causes RPF'(S) to change,\n       including changes to RPF_Interface(S).\
    \  The Upstream(S,G) state\n       machine stays in the AckPending (AP) state.\
    \  A Graft MUST be\n       unicast to the new RPF'(S) and the GraftRetry Timer\
    \ (GRT(S,G))\n       reset to Graft_Retry_Period.\n     RPF'(S) Changes AND olist(S,G)\
    \ == NULL AND S NOT directly connected\n       Unicast routing or Assert state\
    \ causes RPF'(S) to change,\n       including changes to RPF_Interface(S).  The\
    \ Upstream(S,G) state\n       machine MUST transition to the Pruned (P) state.\
    \  The GraftRetry\n       Timer (GRT(S,G)) MUST be cancelled.\n     S becomes\
    \ directly connected\n       Unicast routing has changed so that S is directly\
    \ connected.  The\n       GraftRetry Timer MUST be cancelled, and the Upstream(S,G)\
    \ state\n       machine MUST transition to the Forwarding(F) state.\n     GRT(S,G)\
    \ Expires\n       The GraftRetry Timer (GRT(S,G)) expires for this (S,G) entry.\n\
    \       The Upstream(S,G) state machine stays in the AckPending (AP)\n       state.\
    \  Another Graft message for (S,G) SHOULD be unicast to\n       RPF'(S) and the\
    \ GraftRetry Timer (GRT(S,G)) reset to\n       Graft_Retry_Period.  It is RECOMMENDED\
    \ that the router retry a\n       configured number of times before ceasing retries.\n\
    \     See GraftAck(S,G) from RPF'(S)\n       A GraftAck is received from  RPF'(S).\
    \  The GraftRetry Timer MUST\n       be cancelled, and the Upstream(S,G) state\
    \ machine MUST transition\n       to the Forwarding(F) state.\n"
- title: 4.4.2.  Downstream Prune, Join, and Graft Messages
  contents:
  - "4.4.2.  Downstream Prune, Join, and Graft Messages\n   The Prune(S,G) Downstream\
    \ state machine for receiving Prune, Join and\n   Graft messages on interface\
    \ I is given below.  This state machine\n   MUST always be in the NoInfo state\
    \ on the upstream interface.  It\n   contains three states.\n     NoInfo(NI)\n\
    \       The interface has no (S,G) Prune state, and neither the Prune\n      \
    \ timer (PT(S,G,I)) nor the PrunePending timer ((PPT(S,G,I)) is\n       running.\n\
    \     PrunePending(PP)\n       The router has received a Prune(S,G) on this interface\
    \ from a\n       downstream neighbor and is waiting to see whether the prune will\n\
    \       be overridden by another downstream router.  For forwarding\n       purposes,\
    \ the PrunePending state functions exactly like the\n       NoInfo state.\n  \
    \   Pruned(P)\n       The router has received a Prune(S,G) on this interface from\
    \ a\n       downstream neighbor, and the Prune was not overridden.  Data from\n\
    \       S addressed to group G is no longer being forwarded on this\n       interface.\n\
    \   In addition, there are two timers:\n     PrunePending Timer (PPT(S,G,I))\n\
    \       This timer is set when a valid Prune(S,G) is received.  Expiry of\n  \
    \     the PrunePending Timer (PPT(S,G,I)) causes the interface to\n       transition\
    \ to the Pruned state.\n     Prune Timer (PT(S,G,I))\n       This timer is set\
    \ when the PrunePending Timer (PT(S,G,I))\n       expires.  Expiry of the Prune\
    \ Timer (PT(S,G,I)) causes the\n       interface to transition to the NoInfo (NI)\
    \ state, thereby\n       allowing data from S addressed to group G to be forwarded\
    \ on the\n       interface.\n            +-------------+                     \
    \   +-------------+\n            |             |      PPT Expires       |    \
    \         |\n            |PrunePending |----------------------->|   Pruned   \
    \ |\n            |             |                        |             |\n    \
    \        +-------------+                        +-------------+\n            \
    \     |   ^                                      |\n                 |   |   \
    \                                   |\n                 |   |Rcv Prune       \
    \                      |\n                 |   |                             \
    \         |\n                 |   |         +-------------+              |\n \
    \                |   +---------|             |              |\n              \
    \   |             |   NoInfo    |<-------------+\n                 +------------>|\
    \             | Rcv Join/Graft OR\n             Rcv Join/Graft OR +-------------+\
    \ PT Expires OR\n           RPF_Interface(S)->I                 RPF_Interface(S)->I\n\
    \                 Figure 2: Downstream Interface State Machine\n   In tabular\
    \ form, the state machine is as follows:\n"
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '|                               |            Previous State            |'
  contents:
  - '|                               |            Previous State            |

    '
- title: +                               +------------+------------+------------+
  contents:
  - '+                               +------------+------------+------------+

    '
- title: '|            Event              |  No Info   | PrunePend  |   Pruned   |'
  contents:
  - '|            Event              |  No Info   | PrunePend  |   Pruned   |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Receive Prune(S,G)            |->PP  Set   |->PP        |->P Reset   |'
  contents:
  - '| Receive Prune(S,G)            |->PP  Set   |->PP        |->P Reset   |

    '
- title: '|                               | PPT(S,G,I) |            |  PT(S,G,I) |'
  contents:
  - '|                               | PPT(S,G,I) |            |  PT(S,G,I) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Receive Join(S,G)             |->NI        |->NI Cancel |->NI Cancel |'
  contents:
  - '| Receive Join(S,G)             |->NI        |->NI Cancel |->NI Cancel |

    '
- title: '|                               |            | PPT(S,G,I) |  PT(S,G,I) |'
  contents:
  - '|                               |            | PPT(S,G,I) |  PT(S,G,I) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Receive Graft(S,G)            |->NI Send   |->NI Send   |->NI Send   |'
  contents:
  - '| Receive Graft(S,G)            |->NI Send   |->NI Send   |->NI Send   |

    '
- title: '|                               |  GraftAck  |  GraftAck  |  GraftAck  |'
  contents:
  - '|                               |  GraftAck  |  GraftAck  |  GraftAck  |

    '
- title: '|                               |            |  Cancel    |  Cancel    |'
  contents:
  - '|                               |            |  Cancel    |  Cancel    |

    '
- title: '|                               |            | PPT(S,G,I) |  PT(S,G,I) |'
  contents:
  - '|                               |            | PPT(S,G,I) |  PT(S,G,I) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| PPT(S,G) Expires              | N/A        |->P Set     | N/A        |'
  contents:
  - '| PPT(S,G) Expires              | N/A        |->P Set     | N/A        |

    '
- title: '|                               |            |  PT(S,G,I) |            |'
  contents:
  - '|                               |            |  PT(S,G,I) |            |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| PT(S,G) Expires               | N/A        | N/A        |->NI        |'
  contents:
  - '| PT(S,G) Expires               | N/A        | N/A        |->NI        |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| RPF_Interface(S) becomes I    |->NI        |->NI Cancel |->NI Cancel |'
  contents:
  - '| RPF_Interface(S) becomes I    |->NI        |->NI Cancel |->NI Cancel |

    '
- title: '|                               |            | PPT(S,G,I) |  PT(S,G,I) |'
  contents:
  - '|                               |            | PPT(S,G,I) |  PT(S,G,I) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Send State Refresh(S,G) out I |->NI        |->PP        |->P Reset   |'
  contents:
  - '| Send State Refresh(S,G) out I |->NI        |->PP        |->P Reset   |

    '
- title: '|                               |            |            |  PT(S,G,I) |'
  contents:
  - '|                               |            |            |  PT(S,G,I) |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - "+-------------------------------+------------+------------+------------+\n  \
    \ The transition events \"Receive Graft(S,G)\", \"Receive Prune(S,G)\", and\n\
    \   \"Receive Join(S,G)\" denote receiving a Graft, Prune, or Join message\n \
    \  in which this router's address on I is contained in the message's\n   upstream\
    \ neighbor field.  If the upstream neighbor field does not\n   match this router's\
    \ address on I, then these state transitions in\n   this state machine must not\
    \ occur.\n"
- title: 4.4.2.1.  Transitions from the NoInfo State
  contents:
  - "4.4.2.1.  Transitions from the NoInfo State\n   When the Prune(S,G) Downstream\
    \ state machine is in the NoInfo (NI)\n   state, the following events may trigger\
    \ a transition:\n     Receive Prune(S,G)\n       A Prune(S,G) is received on interface\
    \ I with the upstream\n       neighbor field set to the router's address on I.\
    \  The Prune(S,G)\n       Downstream state machine on interface I MUST transition\
    \ to the\n       PrunePending (PP) state.  The PrunePending Timer (PPT(S,G,I))\n\
    \       MUST be set to J/P_Override_Interval if the router has more than\n   \
    \    one neighbor on I.  If the router has only one neighbor on\n       interface\
    \ I, then it SHOULD set the PPT(S,G,I) to zero,\n       effectively transitioning\
    \ immediately to the Pruned (P) state.\n     Receive Graft(S,G)\n       A Graft(S,G)\
    \ is received on the interface I with the upstream\n       neighbor field set\
    \ to the router's address on I.  The Prune(S,G)\n       Downstream state machine\
    \ on interface I stays in the NoInfo (NI)\n       state.  A GraftAck(S,G) MUST\
    \ be unicast to the originator of the\n       Graft(S,G) message.\n"
- title: 4.4.2.2.  Transitions from the PrunePending (PP) State
  contents:
  - "4.4.2.2.  Transitions from the PrunePending (PP) State\n   When the Prune(S,G)\
    \ downstream state machine is in the PrunePending\n   (PP) state, the following\
    \ events may trigger a transition.\n     Receive Join(S,G)\n       A Join(S,G)\
    \ is received on interface I with the upstream neighbor\n       field set to the\
    \ router's address on I.  The Prune(S,G)\n       Downstream state machine on interface\
    \ I MUST transition to the\n       NoInfo (NI) state.  The PrunePending Timer\
    \ (PPT(S,G,I)) MUST be\n       cancelled.\n     Receive Graft(S,G)\n       A Graft(S,G)\
    \ is received on interface I with the upstream\n       neighbor field set to the\
    \ router's address on I.  The Prune(S,G)\n       Downstream state machine on interface\
    \ I MUST transition to the\n       NoInfo (NI) state and MUST unicast a Graft\
    \ Ack message to the\n       Graft originator.  The PrunePending Timer (PPT(S,G,I))\
    \ MUST be\n       cancelled.\n     PPT(S,G,I) Expires\n       The PrunePending\
    \ Timer (PPT(S,G,I)) expires, indicating that no\n       neighbors have overridden\
    \ the previous Prune(S,G) message.  The\n       Prune(S,G) Downstream state machine\
    \ on interface I MUST\n       transition to the Pruned (P) state.  The Prune Timer\
    \ (PT(S,G,I))\n       is started and MUST be initialized to the received\n   \
    \    Prune_Hold_Time minus J/P_Override_Interval.  A PruneEcho(S,G)\n       MUST\
    \ be sent on I if I has more than one PIM neighbor.  A\n       PruneEcho(S,G)\
    \ is simply a Prune(S,G) message multicast by the\n       upstream router to a\
    \ LAN, with itself as the Upstream Neighbor.\n       Its purpose is to add additional\
    \ reliability so that if a Join\n       that should have overridden the Prune\
    \ is lost locally on the LAN,\n       the PruneEcho(S,G) may be received and trigger\
    \ a new Join\n       message.  A PruneEcho(S,G) is OPTIONAL on an interface with\
    \ only\n       one PIM neighbor.  In addition, the router MUST evaluate any\n\
    \       possible transitions in the Upstream(S,G) state machine.\n     RPF_Interface(S)\
    \ becomes interface I\n       The upstream interface for S has changed.  The Prune(S,G)\n\
    \       Downstream state machine on interface I MUST transition to the\n     \
    \  NoInfo (NI) state.  The PrunePending Timer (PPT(S,G,I)) MUST be\n       cancelled.\n"
- title: 4.4.2.3.  Transitions from the Prune (P) State
  contents:
  - "4.4.2.3.  Transitions from the Prune (P) State\n   When the Prune(S,G) Downstream\
    \ state machine is in the Pruned (P)\n   state, the following events may trigger\
    \ a transition.\n     Receive Prune(S,G)\n       A Prune(S,G) is received on the\
    \ interface I with the upstream\n       neighbor field set to the router's address\
    \ on I.  The Prune(S,G)\n       Downstream state machine on interface I remains\
    \ in the Pruned (P)\n       state.  The Prune Timer (PT(S,G,I)) SHOULD be reset\
    \ to the\n       holdtime contained in the Prune(S,G) message if it is greater\n\
    \       than the current value.\n     Receive Join(S,G)\n       A Join(S,G) is\
    \ received on the interface I with the upstream\n       neighbor field set to\
    \ the router's address on I.  The Prune(S,G)\n       downstream state machine\
    \ on interface I MUST transition to the\n       NoInfo (NI) state.  The Prune\
    \ Timer (PT(S,G,I)) MUST be\n       cancelled.  The router MUST evaluate any possible\
    \ transitions in\n       the Upstream(S,G) state machine.\n     Receive Graft(S,G)\n\
    \       A Graft(S,G) is received on interface I with the upstream\n       neighbor\
    \ field set to the router's address on I.  The Prune(S,G)\n       Downstream state\
    \ machine on interface I MUST transition to the\n       NoInfo (NI) state and\
    \ send a Graft Ack back to the Graft's\n       source.  The Prune Timer (PT(S,G,I))\
    \ MUST be cancelled.  The\n       router MUST evaluate any possible transitions\
    \ in the\n       Upstream(S,G) state machine.\n     PT(S,G,I) Expires\n      \
    \ The Prune Timer (PT(S,G,I)) expires, indicating that it is again\n       time\
    \ to flood data from S addressed to group G onto interface I.\n       The Prune(S,G)\
    \ Downstream state machine on interface I MUST\n       transition to the NoInfo\
    \ (NI) state.  The router MUST evaluate\n       any possible transitions in the\
    \ Upstream(S,G) state machine.\n     RPF_Interface(S) becomes interface I\n  \
    \     The upstream interface for S has changed.  The Prune(S,G)\n       Downstream\
    \ state machine on interface I MUST transition to the\n       NoInfo (NI) state.\
    \  The PruneTimer (PT(S,G,I)) MUST be cancelled.\n     Send State Refresh(S,G)\
    \ out interface I\n       The router has refreshed the Prune(S,G) state on interface\
    \ I.\n       The router MUST reset the Prune Timer (PT(S,G,I)) to the Holdtime\n\
    \       from an active Prune received on interface I.  The Holdtime used\n   \
    \    SHOULD be the largest active one but MAY be the most recently\n       received\
    \ active Prune Holdtime.\n"
- title: 4.5.  State Refresh
  contents:
  - "4.5.  State Refresh\n   This section describes the major portions of the state\
    \ refresh\n   mechanism.\n"
- title: 4.5.1.  Forwarding of State Refresh Messages
  contents:
  - "4.5.1.  Forwarding of State Refresh Messages\n   When a State Refresh message,\
    \ SRM, is received, it is forwarded\n   according to the following pseudo-code.\n\
    \   if (iif != RPF_interface(S))\n     return;\n   if (RPF'(S) != srcaddr(SRM))\n\
    \     return;\n   if (StateRefreshRateLimit(S,G) == TRUE)\n     return;\n   for\
    \ each interface I in pim_nbrs {\n     if (TTL(SRM) == 0 OR (TTL(SRM) - 1) < Threshold(I))\n\
    \       continue;     /* Out of TTL, skip this interface */\n     if (boundary(I,G))\n\
    \       continue;     /* This interface is scope boundary, skip it */\n     if\
    \ (I == iif)\n       continue;     /* This is the incoming interface, skip it\
    \ */\n     if (lost_assert(S,G,I) == TRUE)\n       continue;     /* Let the Assert\
    \ Winner do State Refresh */\n     Copy SRM to SRM';   /* Make a copy of SRM to\
    \ forward */\n     if (I contained in prunes(S,G)) {\n       set Prune Indicator\
    \ bit of SRM' to 1;\n       if StateRefreshCapable(I) == TRUE\n         set PT(S,G)\
    \ to largest active holdtime read from a Prune\n         message accepted on I;\n\
    \     } else {\n       set Prune Indicator bit of SRM' to 0;\n     }\n     set\
    \ srcaddr(SRM') to my_addr(I);\n     set TTL of SRM' to TTL(SRM) - 1;\n     set\
    \ metric of SRM' to metric of unicast route used to reach S;\n     set pref of\
    \ SRM' to preference of unicast route used to reach S;\n     set mask of SRM'\
    \ to mask of route used to reach S;\n     if (AssertState == NoInfo) {\n     \
    \  set Assert Override of SRM' to 1;\n     } else {\n       set Assert Override\
    \ of SRM' to 0;\n     }\n     transmit SRM' on I;\n   }\n   The pseudocode above\
    \ employs the following macro definitions.\n   Boundary(I,G) is TRUE if an administratively\
    \ scoped boundary for\n   group G is configured on interface I.\n   StateRefreshCapable(I)\
    \ is TRUE if all neighbors on an interface use\n   the State Refresh option.\n\
    \   StateRefreshRateLimit(S,G) is TRUE if the time elapsed since the last\n  \
    \ received StateRefresh(S,G) is less than the configured\n   RefreshLimitInterval.\n\
    \   TTL(SRM) returns the TTL contained in the State Refresh Message, SRM.\n  \
    \ This is different from the TTL contained in the IP header.\n   Threshold(I)\
    \ returns the minimum TTL that a packet must have before\n   it can be transmitted\
    \ on interface I.\n   srcaddr(SRM) returns the source address contained in the\
    \ network\n   protocol (e.g., IPv4) header of the State Refresh Message, SRM.\n\
    \   my_addr(I) returns this node's network (e.g., IPv4) address on\n   interface\
    \ I.\n"
- title: 4.5.2.  State Refresh Message Origination
  contents:
  - "4.5.2.  State Refresh Message Origination\n   This section describes the origination\
    \ of State Refresh messages.\n   These messages are generated periodically by\
    \ the PIM-DM router\n   directly connected to a source.  One Origination(S,G)\
    \ state machine\n   exists per (S,G) entry in a PIM-DM router.\n   The Origination(S,G)\
    \ state machine has the following states:\n     NotOriginator(NO)\n       This\
    \ is the starting state of the Origination(S,G) state machine.\n       While in\
    \ this state, a router will not originate State Refresh\n       messages for the\
    \ (S,G) pair.\n     Originator(O)\n       When in this state the router will periodically\
    \ originate State\n       Refresh messages.  Only routers directly connected to\
    \ S may\n       transition to this state.\n   In addition, there are two state\
    \ machine specific timers:\n     State Refresh Timer (SRT(S,G))\n       This timer\
    \ controls when State Refresh messages are generated.\n       The timer is initially\
    \ set when that Origination(S,G) state\n       machine transitions to the O state.\
    \  It is cancelled when the\n       Origination(S,G) state machine transitions\
    \ to the NO state.  This\n       timer is normally set to StateRefreshInterval\
    \ (see 4.8).\n     Source Active Timer (SAT(S,G))\n       This timer is first\
    \ set when the Origination(S,G) state machine\n       transitions to the O state\
    \ and is reset on the receipt of every\n       data packet from S addressed to\
    \ group G.  When it expires, the\n       Origination(S,G) state machine transitions\
    \ to the NO state.  This\n       timer is normally set to SourceLifetime (see\
    \ 4.8).\n            +-------------+  Rcv Directly From S   +-------------+\n\
    \            |             |----------------------->|             |\n        \
    \    |NotOriginator|                        | Originator  |\n            |   \
    \          |<-----------------------|             |\n            +-------------+\
    \     SAT Expires OR     +-------------+\n                             S NOT Direct\
    \ Connect\n                     Figure 3: State Refresh State Machine\n   In tabular\
    \ form, the state machine is defined as follows:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                                  |           Previous State          |'
  contents:
  - '|                                  |           Previous State          |

    '
- title: '|                                  +---------------+-------------------+'
  contents:
  - '|                                  +---------------+-------------------+

    '
- title: '|            Event                 | NotOriginator |    Originator     |'
  contents:
  - '|            Event                 | NotOriginator |    Originator     |

    '
- title: +----------------------------------+---------------+-------------------+
  contents:
  - '+----------------------------------+---------------+-------------------+

    '
- title: '| Receive Data from S AND          | ->O           | ->O Reset         |'
  contents:
  - '| Receive Data from S AND          | ->O           | ->O Reset         |

    '
- title: '| S directly connected             | Set SRT(S,G)  |     SAT(S,G)      |'
  contents:
  - '| S directly connected             | Set SRT(S,G)  |     SAT(S,G)      |

    '
- title: '|                                  | Set SAT(S,G)  |                   |'
  contents:
  - '|                                  | Set SAT(S,G)  |                   |

    '
- title: +----------------------------------+---------------+-------------------+
  contents:
  - '+----------------------------------+---------------+-------------------+

    '
- title: '| SRT(S,G) Expires                 | N/A           | ->O    Send       |'
  contents:
  - '| SRT(S,G) Expires                 | N/A           | ->O    Send       |

    '
- title: '|                                  |               | StateRefresh(S,G) |'
  contents:
  - '|                                  |               | StateRefresh(S,G) |

    '
- title: '|                                  |               |  Reset SRT(S,G)   |'
  contents:
  - '|                                  |               |  Reset SRT(S,G)   |

    '
- title: +----------------------------------+---------------+-------------------+
  contents:
  - '+----------------------------------+---------------+-------------------+

    '
- title: '| SAT(S,G) Expires                 | N/A           | ->NO  Cancel      |'
  contents:
  - '| SAT(S,G) Expires                 | N/A           | ->NO  Cancel      |

    '
- title: '|                                  |               |       SRT(S,G)    |'
  contents:
  - '|                                  |               |       SRT(S,G)    |

    '
- title: +----------------------------------+---------------+-------------------+
  contents:
  - '+----------------------------------+---------------+-------------------+

    '
- title: '| S no longer directly connected   | ->NO          | ->NO              |'
  contents:
  - '| S no longer directly connected   | ->NO          | ->NO              |

    '
- title: '|                                  |               |   Cancel SRT(S,G) |'
  contents:
  - '|                                  |               |   Cancel SRT(S,G) |

    '
- title: '|                                  |               |   Cancel SAT(S,G) |'
  contents:
  - '|                                  |               |   Cancel SAT(S,G) |

    '
- title: +----------------------------------+---------------+-------------------+
  contents:
  - '+----------------------------------+---------------+-------------------+

    '
- title: 4.5.2.1.  Transitions from the NotOriginator (NO) State
  contents:
  - "4.5.2.1.  Transitions from the NotOriginator (NO) State\n   When the Originating(S,G)\
    \ state machine is in the NotOriginator (NO)\n   state, the following event may\
    \ trigger a transition:\n     Data Packet received from directly connected Source\
    \ S addressed to\n     group G\n       The router MUST transition to an Originator\
    \ (O) state, set\n       SAT(S,G) to SourceLifetime, and set SRT(S,G) to\n   \
    \    StateRefreshInterval.  The router SHOULD record the TTL of the\n       packet\
    \ for use in State Refresh messages.\n"
- title: 4.5.2.2.  Transitions from the Originator (O) State
  contents:
  - "4.5.2.2.  Transitions from the Originator (O) State\n   When the Originating(S,G)\
    \ state machine is in the Originator (O)\n   state, the following events may trigger\
    \ a transition:\n     Receive Data Packet from S addressed to G\n       The router\
    \ remains in the Originator (O) state and MUST reset\n       SAT(S,G) to SourceLifetime.\
    \  The router SHOULD increase its\n       recorded TTL to match the TTL of the\
    \ packet, if the packet's TTL\n       is larger than the previously recorded TTL.\
    \  A router MAY record\n       the TTL based on an implementation specific sampling\
    \ policy to\n       avoid examining the TTL of every multicast packet it handles.\n\
    \     SRT(S,G) Expires\n       The router remains in the Originator (O) state\
    \ and MUST reset\n       SRT(S,G) to StateRefreshInterval.  The router MUST also\
    \ generate\n       State Refresh messages for transmission, as described in the\n\
    \       State Refresh Forwarding rules (Section 4.5.1), except for the\n     \
    \  TTL.  If the TTL of data packets from S to G are being recorded,\n       then\
    \ the TTL of each State Refresh message is set to the highest\n       recorded\
    \ TTL.  Otherwise, the TTL is set to the configured State\n       Refresh TTL.\
    \  Let I denote the interface over which a State\n       Refresh message is being\
    \ sent.  If the Prune(S,G) Downstream\n       state machine is in the Pruned (P)\
    \ state, then the Prune-\n       Indicator bit MUST be set to 1 in the State Refresh\
    \ message being\n       sent over I. Otherwise, the Prune-Indicator bit MUST be\
    \ set to 0.\n     SAT(S,G) Expires\n       The router MUST cancel the SRT(S,G)\
    \ timer and transition to the\n       NotOriginator (NO) state.\n     S is no\
    \ longer directly connected\n       The router MUST transition to the NotOriginator\
    \ (NO) state and\n       cancel both the SAT(S,G) and SRT(S,G).\n"
- title: 4.6.  PIM Assert Messages
  contents:
  - '4.6.  PIM Assert Messages

    '
- title: 4.6.1.  Assert Metrics
  contents:
  - "4.6.1.  Assert Metrics\n   Assert metrics are defined as follows:\n   struct\
    \ assert_metric {\n     metric_preference;\n     route_metric;\n     ip_address;\n\
    \   };\n   When assert_metrics are compared, the metric_preference and\n   route_metric\
    \ field are compared in order, where the first lower value\n   wins.  If all fields\
    \ are equal, the IP address of the router that\n   sourced the Assert message\
    \ is used as a tie-breaker, with the highest\n   IP address winning.\n   An Assert\
    \ metric for (S,G) to include in (or compare against) an\n   Assert message sent\
    \ on interface I should be computed by using the\n   following pseudocode:\n \
    \  assert_metric\n   my_assert_metric(S,G,I) {\n     if (CouldAssert(S,G,I) ==\
    \ TRUE) {\n       return spt_assert_metric(S,G,I)\n     } else {\n       return\
    \ infinite_assert_metric()\n     }\n   }\n   spt_assert_metric(S,I) gives the\
    \ Assert metric we use if we're\n   sending an Assert based on active (S,G) forwarding\
    \ state:\n   assert_metric\n   spt_assert_metric(S,I) {\n     return {0,MRIB.pref(S),MRIB.metric(S),my_addr(I)}\n\
    \   }\n   MRIB.pref(X) and MRIB.metric(X) are the routing preference and\n   routing\
    \ metrics associated with the route to a particular (unicast)\n   destination\
    \ X, as determined by the MRIB.  my_addr(I) is simply the\n   router's network\
    \ (e.g., IP) address associated with the local\n   interface I.\n   infinite_assert_metric()\
    \ gives the Assert metric we need to send an\n   Assert but doesn't match (S,G)\
    \ forwarding state:\n   assert_metric\n   infinite_assert_metric() {\n     return\
    \ {1,infinity,infinity,0}\n   }\n"
- title: 4.6.2.  AssertCancel Messages
  contents:
  - "4.6.2.  AssertCancel Messages\n   An AssertCancel(S,G) message is simply an Assert\
    \ message for (S,G)\n   with infinite metric.  The Assert winner sends this message\
    \ when it\n   changes its upstream interface to this interface.  Other routers\
    \ will\n   see this metric, causing those with forwarding state to send their\n\
    \   own Asserts and re-establish an Assert winner.\n   AssertCancel messages are\
    \ simply an optimization.  The original\n   Assert timeout mechanism will eventually\
    \ allow a subnet to become\n   consistent; the AssertCancel mechanism simply causes\
    \ faster\n   convergence.  No special processing is required for an AssertCancel\n\
    \   message, as it is simply an Assert message from the current winner.\n"
- title: 4.6.3.  Assert State Macros
  contents:
  - "4.6.3.  Assert State Macros\n   The macro lost_assert(S,G,I), is used in the\
    \ olist computations of\n   Section 4.1.3, and is defined as follows:\n   bool\
    \ lost_assert(S,G,I) {\n     if ( RPF_interface(S) == I ) {\n       return FALSE\n\
    \     } else {\n       return (AssertWinner(S,G,I) != me  AND\n              \
    \ (AssertWinnerMetric(S,G,I) is better than\n                spt_assert_metric(S,G,I)))\n\
    \     }\n   }\n   AssertWinner(S,G,I) defaults to NULL, and AssertWinnerMetric(S,G,I)\n\
    \   defaults to Infinity when in the NoInfo state.\n"
- title: 4.6.4.  (S,G) Assert Message State Machine
  contents:
  - "4.6.4.  (S,G) Assert Message State Machine\n   The (S,G) Assert state machine\
    \ for interface I is shown in Figure 4.\n   There are three states:\n     NoInfo\
    \ (NI)\n       This router has no (S,G) Assert state on interface I.\n     I am\
    \ Assert Winner (W)\n       This router has won an (S,G) Assert on interface I.\
    \  It is now\n       responsible for forwarding traffic from S destined for G\
    \ via\n       interface I.\n     I am Assert Loser (L)\n       This router has\
    \ lost an (S,G) Assert on interface I.  It must not\n       forward packets from\
    \ S destined for G onto interface I.\n   In addition, an Assert Timer (AT(S,G,I))\
    \ is used to time out the\n   Assert state.\n         +-------------+        \
    \                +-------------+\n         |             | Rcv Pref Assert or\
    \ SR  |             |\n         |   Winner    |----------------------->|    Loser\
    \    |\n         |             |                        |             |\n    \
    \     +-------------+                        +-------------+\n              ^\
    \   |                                  ^   |\n              |   |            \
    \    Rcv Pref Assert or|   |\n              |   |AT Expires OR        State Refresh|\
    \   |\n              |   |CouldAssert->FALSE                |   |\n          \
    \    |   |                                  |   |\n              |   |       \
    \  +-------------+          |   |\n              |   +-------->|             |----------+\
    \   |\n              |             |   No Info   |              |\n          \
    \    +-------------|             |<-------------+\n       Rcv Data from dnstrm\
    \ +-------------+ Rcv Inf Assert from Win OR\n     OR Rcv Inferior Assert    \
    \             Rcv Inf SR from Winner OR\n         OR Rcv Inferior SR         \
    \        AT Expires OR\n                                            CouldAssert\
    \ Changes OR\n                                            Winner's NLT Expires\n\
    \                     Figure 4: Assert State Machine\n   In tabular form, the\
    \ state machine is defined as follows:\n"
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '|                               |            Previous State            |'
  contents:
  - '|                               |            Previous State            |

    '
- title: '|                               +------------+------------+------------+'
  contents:
  - '|                               +------------+------------+------------+

    '
- title: '|            Event              |  No Info   |   Winner   |    Loser   |'
  contents:
  - '|            Event              |  No Info   |   Winner   |    Loser   |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| An (S,G) Data packet received | ->W Send   | ->W Send   | ->L        |'
  contents:
  - '| An (S,G) Data packet received | ->W Send   | ->W Send   | ->L        |

    '
- title: '| on downstream interface       | Assert(S,G)| Assert(S,G)|            |'
  contents:
  - '| on downstream interface       | Assert(S,G)| Assert(S,G)|            |

    '
- title: '|                               |    Set     |    Set     |            |'
  contents:
  - '|                               |    Set     |    Set     |            |

    '
- title: '|                               |  AT(S,G,I) |  AT(S,G,I) |            |'
  contents:
  - '|                               |  AT(S,G,I) |  AT(S,G,I) |            |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| Receive Inferior (Assert OR   | N/A        | N/A        |->NI Cancel |'
  contents:
  - '| Receive Inferior (Assert OR   | N/A        | N/A        |->NI Cancel |

    '
- title: '| State Refresh) from Assert    |            |            |  AT(S,G,I) |'
  contents:
  - '| State Refresh) from Assert    |            |            |  AT(S,G,I) |

    '
- title: '| Winner                        |            |            |            |'
  contents:
  - '| Winner                        |            |            |            |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| Receive Inferior (Assert OR   | ->W Send   | ->W Send   | ->L        |'
  contents:
  - '| Receive Inferior (Assert OR   | ->W Send   | ->W Send   | ->L        |

    '
- title: '| State Refresh) from non-Assert| Assert(S,G)| Assert(S,G)|            |'
  contents:
  - '| State Refresh) from non-Assert| Assert(S,G)| Assert(S,G)|            |

    '
- title: '| Winner AND CouldAssert==TRUE  |    Set     |    Set     |            |'
  contents:
  - '| Winner AND CouldAssert==TRUE  |    Set     |    Set     |            |

    '
- title: '|                               |  AT(S,G,I) |  AT(S,G,I) |            |'
  contents:
  - '|                               |  AT(S,G,I) |  AT(S,G,I) |            |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '|                               |            Previous State            |'
  contents:
  - '|                               |            Previous State            |

    '
- title: '|                               +------------+------------+------------+'
  contents:
  - '|                               +------------+------------+------------+

    '
- title: '|            Event              |  No Info   |   Winner   |    Loser   |'
  contents:
  - '|            Event              |  No Info   |   Winner   |    Loser   |

    '
- title: +-------------------------------+------------+------------+------------+
  contents:
  - '+-------------------------------+------------+------------+------------+

    '
- title: '| Receive Preferred Assert OR   | ->L Send   | ->L Send   | ->L  Set   |'
  contents:
  - '| Receive Preferred Assert OR   | ->L Send   | ->L Send   | ->L  Set   |

    '
- title: '| State Refresh                 | Prune(S,G) | Prune(S,G) |  AT(S,G,I) |'
  contents:
  - '| State Refresh                 | Prune(S,G) | Prune(S,G) |  AT(S,G,I) |

    '
- title: '|                               |    Set     |    Set     |            |'
  contents:
  - '|                               |    Set     |    Set     |            |

    '
- title: '|                               |  AT(S,G,I) |  AT(S,G,I) |            |'
  contents:
  - '|                               |  AT(S,G,I) |  AT(S,G,I) |            |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| Send State Refresh            | ->NI       | ->W Reset  | N/A        |'
  contents:
  - '| Send State Refresh            | ->NI       | ->W Reset  | N/A        |

    '
- title: '|                               |            |  AT(S,G,I) |            |'
  contents:
  - '|                               |            |  AT(S,G,I) |            |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| AT(S,G) Expires               | N/A        | ->NI       | ->NI       |'
  contents:
  - '| AT(S,G) Expires               | N/A        | ->NI       | ->NI       |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| CouldAssert -> FALSE          | ->NI       |->NI Cancel |->NI Cancel |'
  contents:
  - '| CouldAssert -> FALSE          | ->NI       |->NI Cancel |->NI Cancel |

    '
- title: '|                               |            |  AT(S,G,I) |  AT(S,G,I) |'
  contents:
  - '|                               |            |  AT(S,G,I) |  AT(S,G,I) |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| CouldAssert -> TRUE           | ->NI       | N/A        |->NI Cancel |'
  contents:
  - '| CouldAssert -> TRUE           | ->NI       | N/A        |->NI Cancel |

    '
- title: '|                               |            |            |  AT(S,G,I) |'
  contents:
  - '|                               |            |            |  AT(S,G,I) |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| Winner''s NLT(N,I) Expires     | N/A        | N/A        |->NI Cancel
    |'
  contents:
  - '| Winner''s NLT(N,I) Expires     | N/A        | N/A        |->NI Cancel |

    '
- title: '|                               |            |            |  AT(S,G,I) |'
  contents:
  - '|                               |            |            |  AT(S,G,I) |

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - '+-------------------------------+--------------------------------------+

    '
- title: '| Receive Prune(S,G), Join(S,G) | ->NI       | ->W        | ->L Send   |'
  contents:
  - '| Receive Prune(S,G), Join(S,G) | ->NI       | ->W        | ->L Send   |

    '
- title: '| or Graft(S,G)                 |            |            | Assert(S,G)|'
  contents:
  - '| or Graft(S,G)                 |            |            | Assert(S,G)|

    '
- title: +-------------------------------+--------------------------------------+
  contents:
  - "+-------------------------------+--------------------------------------+\n  \
    \ Terminology: A \"preferred assert\" is one with a better metric than\n   the\
    \ current winner.  An \"inferior assert\" is one with a worse metric\n   than\
    \ my_assert_metric(S,G,I).\n   The state machine uses the following macro:\n \
    \  CouldAssert(S,G,I) = (RPF_interface(S) != I)\n"
- title: 4.6.4.1.  Transitions from NoInfo State
  contents:
  - "4.6.4.1.  Transitions from NoInfo State\n   In the NoInfo state, the following\
    \ events may trigger transitions:\n     An (S,G) data packet arrives on downstream\
    \ interface I\n       An (S,G) data packet arrived on a downstream interface.\
    \  It is\n       optimistically assumed that this router will be the Assert winner\n\
    \       for this (S,G).  The Assert state machine MUST transition to the\n   \
    \    \"I am Assert Winner\" state, send an Assert(S,G) to interface I,\n     \
    \  store its own address and metric as the Assert Winner, and set\n       the\
    \ Assert_Timer (AT(S,G,I) to Assert_Time, thereby initiating\n       the Assert\
    \ negotiation for (S,G).\n     Receive Inferior (Assert OR State Refresh) AND\n\
    \     CouldAssert(S,G,I)==TRUE\n       An Assert or State Refresh is received\
    \ for (S,G) that is inferior\n       to our own assert metric on interface I.\
    \ The Assert state machine\n       MUST transition to the \"I am Assert Winner\"\
    \ state, send an\n       Assert(S,G) to interface I, store its own address and\
    \ metric as\n       the Assert Winner, and set the Assert Timer (AT(S,G,I)) to\n\
    \       Assert_Time.\n     Receive Preferred Assert or State Refresh\n       The\
    \ received Assert or State Refresh has a better metric than\n       this router's,\
    \ and therefore the Assert state machine MUST\n       transition to the \"I am\
    \ Assert Loser\" state and store the Assert\n       Winner's address and metric.\
    \  If the metric was received in an\n       Assert, the router MUST set the Assert\
    \ Timer (AT(S,G,I)) to\n       Assert_Time.  If the metric was received in a State\
    \ Refresh, the\n       router MUST set the Assert Timer (AT(S,G,I)) to three times\
    \ the\n       received State Refresh Interval.  If CouldAssert(S,G,I) == TRUE,\n\
    \       the router MUST also multicast a Prune(S,G) to the Assert winner\n   \
    \    with a Prune Hold Time equal to the Assert Timer and evaluate any\n     \
    \  changes in its Upstream(S,G) state machine.\n"
- title: 4.6.4.2.  Transitions from Winner State
  contents:
  - "4.6.4.2.  Transitions from Winner State\n   When in \"I am Assert Winner\" state,\
    \ the following events trigger\n   transitions:\n     An (S,G) data packet arrives\
    \ on downstream interface I\n       An (S,G) data packet arrived on a downstream\
    \ interface.  The\n       Assert state machine remains in the \"I am Assert Winner\"\
    \ state.\n       The router MUST send an Assert(S,G) to interface I and set the\n\
    \       Assert Timer (AT(S,G,I) to Assert_Time.\n     Receive Inferior Assert\
    \ or State Refresh\n       An (S,G) Assert is received containing a metric for\
    \ S that is\n       worse than this router's metric for S.  Whoever sent the Assert\n\
    \       is in error.  The router MUST send an Assert(S,G) to interface I\n   \
    \    and reset the Assert Timer (AT(S,G,I)) to Assert_Time.\n     Receive Preferred\
    \ Assert or State Refresh\n       An (S,G) Assert or State Refresh is received\
    \ that has a better\n       metric than this router's metric for S on interface\
    \ I.  The\n       Assert state machine MUST transition to \"I am Assert Loser\"\
    \ state\n       and store the new Assert Winner's address and metric.  If the\n\
    \       metric was received in an Assert, the router MUST set the Assert\n   \
    \    Timer (AT(S,G,I)) to Assert_Time.  If the metric was received in\n      \
    \ a State Refresh, the router MUST set the Assert Timer (AT(S,G,I))\n       to\
    \ three times the State Refresh Interval.  The router MUST also\n       multicast\
    \ a Prune(S,G) to the Assert winner, with a Prune Hold\n       Time equal to the\
    \ Assert Timer, and evaluate any changes in its\n       Upstream(S,G) state machine.\n\
    \     Send State Refresh\n       The router is sending a State Refresh(S,G) message\
    \ on interface\n       I.  The router MUST set the Assert Timer (AT(S,G,I)) to\
    \ three\n       times the State Refresh Interval contained in the State\n    \
    \   Refresh(S,G) message.\n     AT(S,G,I) Expires\n       The (S,G) Assert Timer\
    \ (AT(S,G,I)) expires.  The Assert state\n       machine MUST transition to the\
    \ NoInfo (NI) state.\n     CouldAssert(S,G,I) -> FALSE\n       This router's RPF\
    \ interface changed, making CouldAssert(S,G,I)\n       false.  This router can\
    \ no longer perform the actions of the\n       Assert winner, so the Assert state\
    \ machine MUST transition to\n       NoInfo (NI) state, send an AssertCancel(S,G)\
    \ to interface I,\n       cancel the Assert Timer (AT(S,G,I)), and remove itself\
    \ as the\n       Assert Winner.\n"
- title: 4.6.4.3.  Transitions from Loser State
  contents:
  - "4.6.4.3.  Transitions from Loser State\n   When in \"I am Assert Loser\" state,\
    \ the following transitions can\n   occur:\n     Receive Inferior Assert or State\
    \ Refresh from Current Winner\n       An Assert or State Refresh is received from\
    \ the current Assert\n       winner that is worse than this router's metric for\
    \ S (typically,\n       the winner's metric became worse).  The Assert state machine\
    \ MUST\n       transition to NoInfo (NI) state and cancel AT(S,G,I).  The router\n\
    \       MUST delete the previous Assert Winner's address and metric and\n    \
    \   evaluate any possible transitions to its Upstream(S,G) state\n       machine.\
    \  Usually this router will eventually re-assert and win\n       when data packets\
    \ from S have started flowing again.\n     Receive Preferred Assert or State Refresh\n\
    \       An Assert or State Refresh is received that has a metric better\n    \
    \   than or equal to that of the current Assert winner.  The Assert\n       state\
    \ machine remains in Loser (L) state.  If the metric was\n       received in an\
    \ Assert, the router MUST set the Assert Timer\n       (AT(S,G,I)) to Assert_Time.\
    \  If the metric was received in a\n       State Refresh, the router MUST set\
    \ the Assert Timer (AT(S,G,I))\n       to three times the received State Refresh\
    \ Interval.  If the\n       metric is better than the current Assert Winner, the\
    \ router MUST\n       store the address and metric of the new Assert Winner, and\
    \ if\n       CouldAssert(S,G,I) == TRUE, the router MUST multicast a\n       Prune(S,G)\
    \ to the new Assert winner.\n     AT(S,G,I) Expires\n       The (S,G) Assert Timer\
    \ (AT(S,G,I)) expires.  The Assert state\n       machine MUST transition to NoInfo\
    \ (NI) state.  The router MUST\n       delete the Assert Winner's address and\
    \ metric.  If CouldAssert ==\n       TRUE, the router MUST evaluate any possible\
    \ transitions to its\n       Upstream(S,G) state machine.\n     CouldAssert ->\
    \ FALSE\n       CouldAssert has become FALSE because interface I has become the\n\
    \       RPF interface for S.  The Assert state machine MUST transition to\n  \
    \     NoInfo (NI) state, cancel AT(S,G,I), and delete information\n       concerning\
    \ the Assert Winner on I.\n     CouldAssert -> TRUE\n       CouldAssert has become\
    \ TRUE because interface I used to be the\n       RPF interface for S, and now\
    \ it is not.  The Assert state machine\n       MUST transition to NoInfo (NI)\
    \ state, cancel AT(S,G,I), and\n       delete information concerning the Assert\
    \ Winner on I.\n     Current Assert Winner's NeighborLiveness Timer Expires\n\
    \       The current Assert winner's NeighborLiveness Timer (NLT(N,I)) has\n  \
    \     expired.  The Assert state machine MUST transition to the NoInfo\n     \
    \  (NI) state, delete the Assert Winner's address and metric, and\n       evaluate\
    \ any possible transitions to its Upstream(S,G) state\n       machine.\n     Receive\
    \ Prune(S,G), Join(S,G), or Graft(S,G)\n       A Prune(S,G), Join(S,G), or Graft(S,G)\
    \ message was received on\n       interface I with its upstream neighbor address\
    \ set to the\n       router's address on I.  The router MUST send an Assert(S,G)\
    \ on\n       the receiving interface I to initiate an Assert negotiation.  The\n\
    \       Assert state machine remains in the Assert Loser(L) state.  If a\n   \
    \    Graft(S,G) was received, the router MUST respond with a\n       GraftAck(S,G).\n"
- title: 4.6.5.  Rationale for Assert Rules
  contents:
  - "4.6.5.  Rationale for Assert Rules\n   The following is a summary of the rules\
    \ for generating and processing\n   Assert messages.  It is not intended to be\
    \ definitive (the state\n   machines and pseudocode provide the definitive behavior).\
    \  Instead,\n   it provides some rationale for the behavior.\n   1. The Assert\
    \ winner for (S,G) must act as the local forwarder for\n      (S,G) on behalf\
    \ of all downstream members.\n   2. PIM messages are directed to the RPF' neighbor\
    \ and not to the\n      regular RPF neighbor.\n   3. An Assert loser that receives\
    \ a Prune(S,G), Join(S,G), or\n      Graft(S,G) directed to it initiates a new\
    \ Assert negotiation so\n      that the downstream router can correct its RPF'(S).\n\
    \   4. An Assert winner for (S,G) sends a cancelling assert when it is\n     \
    \ about to stop forwarding on an (S,G) entry.  Example: If a router\n      is\
    \ being taken down, then a canceling assert is sent.\n"
- title: 4.7.  PIM Packet Formats
  contents:
  - "4.7.  PIM Packet Formats\n   All PIM-DM packets use the same format as PIM-SM\
    \ packets.  In the\n   event of a discrepancy, PIM-SM [4] should be considered\
    \ the\n   definitive specification.  All PIM control messages have IP protocol\n\
    \   number 103.  All PIM-DM messages MUST be sent with a TTL of 1.  All\n   PIM-DM\
    \ messages except Graft and Graft Ack messages MUST be sent to\n   the ALL-PIM-ROUTERS\
    \ group.  Graft messages SHOULD be unicast to the\n   RPF'(S).  Graft Ack messages\
    \ MUST be unicast to the sender of the\n   Graft.\n   The IPv4 ALL-PIM-ROUTERS\
    \ group is 224.0.0.13.  The IPv6 ALL-PIM-\n   ROUTERS group is 'ff02::d'.\n"
- title: 4.7.1.  PIM Header
  contents:
  - "4.7.1.  PIM Header\n   All PIM control messages have the following header:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver PIM version number is 2.\n   Type\n     Types for specific PIM messages.\
    \  Available types are as follows:\n     0 = Hello\n     1 = Register (PIM-SM\
    \ only)\n     2 = Register Stop (PIM-SM only)\n     3 = Join/Prune\n     4 = Bootstrap\
    \ (PIM-SM only)\n     5 = Assert\n     6 = Graft\n     7 = Graft Ack\n     8 =\
    \ Candidate RP Advertisement (PIM-SM only)\n     9 = State Refresh\n   Reserved\n\
    \     Set to zero on transmission.  Ignored upon receipt.\n   Checksum\n     The\
    \ checksum is the standard IP checksum; i.e., the 16 bit one's\n     complement\
    \ of the one's complement sum of the entire PIM message.\n     For computing checksum,\
    \ the checksum field is zeroed.\n     For IPv6, the checksum also includes the\
    \ IPv6 \"pseudo-header\", as\n     specified in RFC 2460, Section 8.1 [5].\n"
- title: 4.7.2.  Encoded Unicast Address
  contents:
  - "4.7.2.  Encoded Unicast Address\n   An Encoded Unicast Address has the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |     Unicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n     The PIM Address Family of the 'Unicast Address' field of\
    \ this\n     address.  Values 0 - 127 are as assigned by the IANA for Internet\n\
    \     Address Families in [9].  Values 128 - 250 are reserved to be\n     assigned\
    \ by the IANA for PIM specific Address Families.  Values 251\n     - 255 are designated\
    \ for private use.  As there is no assignment\n     authority for this space;\
    \ collisions should be expected.\n   Encoding Type\n     The type of encoding\
    \ used with a specific Address Family.  The\n     value '0' is reserved for this\
    \ field and represents the native\n     encoding of the Address Family.\n   Unicast\
    \ Address\n     The unicast address as represented by the given Address Family\
    \ and\n     Encoding Type.\n"
- title: 4.7.3.  Encoded Group Address
  contents:
  - "4.7.3.  Encoded Group Address\n   An Encoded Group address has the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Group Multicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n     As described above.\n   Encoding Type\n     As described\
    \ above.\n   B\n     Indicates that the group range should use Bidirectional PIM\
    \ [16].\n     Transmitted as zero; ignored upon receipt.\n   Reserved\n     Transmitted\
    \ as zero.  Ignored upon receipt.\n   Z\n     Indicates that the group range is\
    \ an admin scope zone.  This is\n     used in the Bootstrap Router Mechanism [18]\
    \ only.  For all other\n     purposes, this bit is set to zero and ignored on\
    \ receipt.\n   Mask Len\n     The mask length field is 8 bits.  The value is the\
    \ number of\n     contiguous left justified one bits used as a mask, which, combined\n\
    \     with the address, describes a range of addresses.  It is less than\n   \
    \  or equal to the address length in bits for the given Address Family\n     and\
    \ Encoding Type.  If the message is sent for a single address\n     then the mask\
    \ length MUST equal the address length.  PIM-DM routers\n     MUST only send for\
    \ a single address.\n   Group Multicast Address\n     The address of the multicast\
    \ group.\n"
- title: 4.7.4.  Encoded Source Address
  contents:
  - "4.7.4.  Encoded Source Address\n   An Encoded Source address has the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |  Rsrvd  |S|W|R|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Source Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n     As described above.\n   Encoding Type\n     As described\
    \ above.\n   Rsrvd\n     Reserved.  Transmitted as zero.  Ignored upon receipt.\n\
    \   S\n     The Sparse Bit.  Set to 0 for PIM-DM.  Ignored upon receipt.\n   W\n\
    \     The Wild Card Bit.  Set to 0 for PIM-DM.  Ignored upon receipt.\n   R\n\
    \     The Rendezvous Point Tree bit.  Set to 0 for PIM-DM.  Ignored upon\n   \
    \  receipt.\n   Mask Len\n     As described above.  PIM-DM routers MUST only send\
    \ for a single\n     source address.\n   Source Address\n     The source address.\n"
- title: 4.7.5.  Hello Message Format
  contents:
  - "4.7.5.  Hello Message Format\n   The PIM Hello message, as defined by PIM-SM\
    \ [4], has the following\n   format:\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Option Type          |         Option Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Option Value                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   |        \
    \                       .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Option Type          |         Option Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Option Value                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver, Type, Reserved, Checksum\n     Described above.\n   Option Type\n\
    \     The type of option given in the Option Value field.  Available\n     types\
    \ are as follows:\n       0              Reserved\n       1              Hello\
    \ Hold Time\n       2              LAN Prune Delay\n       3 - 16         Reserved\n\
    \       17             To be assigned by IANA\n       18             Deprecated\
    \ and SHOULD NOT be used\n       19             DR Priority (PIM-SM Only)\n  \
    \     20             Generation ID\n       21             State Refresh Capable\n\
    \       22             Bidir Capable\n       23 - 65000     To be assigned by\
    \ IANA\n       65001 - 65535  Reserved for Private Use [9]\n     Unknown options\
    \ SHOULD be ignored.\n"
- title: 4.7.5.1.  Hello Hold Time Option
  contents:
  - "4.7.5.1.  Hello Hold Time Option\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Type = 1           |           Length = 2          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Hold Time          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Hold Time is the number of seconds a receiver MUST keep the neighbor\n   reachable.\
    \  If the Hold Time is set to '0xffff', the receiver of this\n   message never\
    \ times out the neighbor.  This may be used with dial-\n   on-demand links to\
    \ avoid keeping the link up with periodic Hello\n   messages.  Furthermore, if\
    \ the Holdtime is set to '0', the\n   information is timed out immediately.  The\
    \ Hello Hold Time option\n   MUST be used by PIM-DM routers.\n"
- title: 4.7.5.2.  LAN Prune Delay Option
  contents:
  - "4.7.5.2.  LAN Prune Delay Option\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Type = 2           |           Length = 4          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |T|       LAN Prune Delay       |       Override Interval       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The LAN_Prune_Delay option is used to tune the prune propagation\n   delay\
    \ on multi-access LANs.  The T bit is used by PIM-SM and SHOULD\n   be set to\
    \ 0 by PIM-DM routers and ignored upon receipt.  The LAN\n   Delay and Override\
    \ Interval fields are time intervals in units of\n   milliseconds and are used\
    \ to tune the value of the J/P Override\n   Interval and its derived timer values.\
    \  Section 4.3.5 describes how\n   these values affect the behavior of a router.\
    \  The LAN Prune Delay\n   SHOULD be used by PIM-DM routers.\n"
- title: 4.7.5.3.  Generation ID Option
  contents:
  - "4.7.5.3.  Generation ID Option\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Type = 20           |           Length = 4          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Generation ID                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Generation ID is a random value for the interface on which the Hello\n   message\
    \ is sent.  The Generation ID is regenerated whenever PIM\n   forwarding is started\
    \ or restarted on the interface.  The Generation\n   ID option MAY be used by\
    \ PIM-DM routers.\n"
- title: 4.7.5.4.  State Refresh Capable Option
  contents:
  - "4.7.5.4.  State Refresh Capable Option\n    0                   1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Type = 21           |           Length = 4          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Version = 1  |   Interval    |            Reserved           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Interval field is the router's configured State Refresh Interval\n   in\
    \ seconds.  The Reserved field is set to zero and ignored upon\n   receipt.  The\
    \ State Refresh Capable option MUST be used by State\n   Refresh capable PIM-DM\
    \ routers.\n"
- title: 4.7.6.  Join/Prune Message Format
  contents:
  - "4.7.6.  Join/Prune Message Format\n   PIM Join/Prune messages, as defined in\
    \ PIM-SM [4], have the following\n   format:\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Upstream Neighbor Address (Encoded Unicast Format)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved    |  Num Groups   |          Hold Time            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \       Multicast Group Address 1 (Encoded Group Format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Joined Source Address 1 (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Joined Source Address n (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Pruned Source Address 1 (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Pruned Source Address n (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   |        \
    \                       .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address m (Encoded Group Format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Joined Source Address 1 (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Joined Source Address n (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Pruned Source Address 1 (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Pruned Source Address n (Encoded Source Format)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver, Type, Reserved, Checksum\n     Described above.\n   Upstream Neighbor\
    \ Address\n     The address of the upstream neighbor.  The format for this address\n\
    \     is given in the Encoded Unicast address in Section 4.7.2.  PIM-DM\n    \
    \ routers MUST set this field to the RPF next hop.\n   Reserved\n     Transmitted\
    \ as zero.  Ignored upon receipt.\n   Hold Time\n     The number of seconds a\
    \ receiving PIM-DM router MUST keep a Prune\n     state alive, unless removed\
    \ by a Join or Graft message.  If the\n     Hold Time is '0xffff', the receiver\
    \ MUST NOT remove the Prune state\n     unless a corresponding Join or Graft message\
    \ is received.  The Hold\n     Time is ignored in Join messages.\n   Number of\
    \ Groups\n     Number of multicast group sets contained in the message.\n   Multicast\
    \ Group Address\n     The multicast group address in the Encoded Multicast address\
    \ format\n     given in Section 4.7.3.\n   Number of Joined Sources\n     Number\
    \ of Join source addresses listed for a given group.\n   Number of Pruned Sources\n\
    \     Number of Prune source addresses listed for a given group.\n   Join Source\
    \ Address 1..n\n     This list contains the sources from which the sending router\
    \ wishes\n     to continue to receive multicast messages for the given group on\n\
    \     this interface.  The addresses use the Encoded Source address\n     format\
    \ given in Section 4.7.4.\n   Prune Source Address 1..n\n     This list contains\
    \ the sources from which the sending router does\n     not wish to receive multicast\
    \ messages for the given group on this\n     interface.  The addresses use the\
    \ Encoded Source address format\n     given in Section 4.7.4.\n"
- title: 4.7.7.  Assert Message Format
  contents:
  - "4.7.7.  Assert Message Format\n   PIM Assert Messages, as defined in PIM-SM [4],\
    \ have the following\n   format:\n    0                   1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address (Encoded Group Format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Source Address (Encoded Unicast Format)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|                     Metric Preference                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Metric                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver, Type, Reserved, Checksum\n     Described above.\n   Multicast Group\
    \ Address\n     The multicast group address in the Encoded Multicast address format\n\
    \     given in Section 4.7.3.\n   Source Address\n     The source address in the\
    \ Encoded Unicast address format given in\n     Section 4.7.2.\n   R\n     The\
    \ Rendezvous Point Tree bit.  Set to 0 for PIM-DM.  Ignored upon\n     receipt.\n\
    \   Metric Preference\n     The preference value assigned to the unicast routing\
    \ protocol that\n     provided the route to the source.\n   Metric\n     The cost\
    \ metric of the unicast route to the source.  The metric is\n     in units applicable\
    \ to the unicast routing protocol used.\n"
- title: 4.7.8.  Graft Message Format
  contents:
  - "4.7.8.  Graft Message Format\n   PIM Graft messages use the same format as Join/Prune\
    \ messages, except\n   that the Type field is set to 6.  The source address MUST\
    \ be in the\n   Join section of the message.  The Hold Time field SHOULD be zero\
    \ and\n   SHOULD be ignored when a Graft is received.\n"
- title: 4.7.9.  Graft Ack Message Format
  contents:
  - "4.7.9.  Graft Ack Message Format\n   PIM Graft Ack messages are identical in\
    \ format to the received Graft\n   message, except that the Type field is set\
    \ to 7.  The Upstream\n   Neighbor Address field SHOULD be set to the sender of\
    \ the Graft\n   message and SHOULD be ignored upon receipt.\n"
- title: 4.7.10.  State Refresh Message Format
  contents:
  - "4.7.10.  State Refresh Message Format\n   PIM State Refresh Messages have the\
    \ following format:\n    0                   1                   2           \
    \        3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address (Encoded Group Format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Source Address (Encoded Unicast Format)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Originator Address (Encoded Unicast Format)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|                     Metric Preference                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Metric                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Masklen    |    TTL        |P|N|O|Reserved |   Interval    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver, Type, Reserved, Checksum\n     Described above.\n   Multicast Group\
    \ Address\n     The multicast group address in the Encoded Multicast address format\n\
    \     given in Section 4.7.3.\n   Source Address\n     The address of the data\
    \ source in the Encoded Unicast address\n     format given in Section 4.7.2.\n\
    \   Originator Address\n     The address of the first hop router in the Encoded\
    \ Unicast address\n     format given in Section 4.7.2.\n   R\n     The Rendezvous\
    \ Point Tree bit.  Set to 0 for PIM-DM.  Ignored upon\n     receipt.\n   Metric\
    \ Preference\n     The preference value assigned to the unicast routing protocol\
    \ that\n     provided the route to the source.\n   Metric\n     The cost metric\
    \ of the unicast route to the source.  The metric is\n     in units applicable\
    \ to the unicast routing protocol used.\n   Masklen\n     The length of the address\
    \ mask of the unicast route to the source.\n   TTL\n     Time To Live of the State\
    \ Refresh message.  Decremented each time\n     the message is forwarded.  Note\
    \ that this is different from the IP\n     Header TTL, which is always set to\
    \ 1.\n   P\n     Prune indicator flag.  This MUST be set to 1 if the State Refresh\n\
    \     is to be sent on a Pruned interface.  Otherwise, it MUST be set to\n   \
    \  0.\n   N\n     Prune Now flag.  This SHOULD be set to 1 by the State Refresh\n\
    \     originator on every third State Refresh message and SHOULD be\n     ignored\
    \ upon receipt.  This is for compatibility with earlier\n     versions of state\
    \ refresh.\n   O\n     Assert Override flag.  This SHOULD be set to 1 by upstream\
    \ routers\n     on a LAN if the Assert Timer (AT(S,G)) is not running and SHOULD\
    \ be\n     ignored upon receipt.  This is for compatibility with earlier\n   \
    \  versions of state refresh.\n   Reserved\n     Set to zero and ignored upon\
    \ receipt.\n   Interval\n     Set by the originating router to the interval (in\
    \ seconds) between\n     consecutive State Refresh messages for this (S,G) pair.\n"
- title: 4.8.  PIM-DM Timers
  contents:
  - "4.8.  PIM-DM Timers\n   PIM-DM maintains the following timers.  All timers are\
    \ countdown\n   timers -- they are set to a value and count down to zero, at which\n\
    \   point they typically trigger an action.  Of course they can just as\n   easily\
    \ be implemented as count-up timers, where the absolute expiry\n   time is stored\
    \ and compared against a real-time clock, but the\n   language in this specification\
    \ assumes that they count downward\n   towards zero.\n   Global Timers\n     Hello\
    \ Timer: HT\n     Per interface (I):\n       Per neighbor (N):\n         Neighbor\
    \ Liveness Timer: NLT(N,I)\n       Per (S,G) Pair:\n         (S,G) Assert Timer:\
    \ AT(S,G,I)\n         (S,G) Prune Timer: PT(S,G,I)\n         (S,G) PrunePending\
    \ Timer: PPT(S,G,I)\n       Per (S,G) Pair:\n         (S,G) Graft Retry Timer:\
    \ GRT(S,G)\n         (S,G) Upstream Override Timer: OT(S,G)\n         (S,G) Prune\
    \ Limit Timer: PLT(S,G)\n         (S,G) Source Active Timer: SAT(S,G)\n      \
    \   (S,G) State Refresh Timer: SRT(S,G)\n   When timer values are started or restarted,\
    \ they are set to default\n   values.  The following tables summarize those default\
    \ values.\n"
- title: 'Timer Name: Hello Timer (HT)'
  contents:
  - 'Timer Name: Hello Timer (HT)

    '
- title: +----------------------+--------+--------------------------------------+
  contents:
  - '+----------------------+--------+--------------------------------------+

    '
- title: '| Value Name           | Value  | Explanation                          |'
  contents:
  - '| Value Name           | Value  | Explanation                          |

    '
- title: +----------------------+--------+--------------------------------------+
  contents:
  - '+----------------------+--------+--------------------------------------+

    '
- title: '|Hello_Period          | 30 sec | Periodic interval for hello messages |'
  contents:
  - '|Hello_Period          | 30 sec | Periodic interval for hello messages |

    '
- title: +----------------------+--------+--------------------------------------+
  contents:
  - '+----------------------+--------+--------------------------------------+

    '
- title: '|Triggered_Hello_Delay | 5 sec  | Random interval for initial Hello    |'
  contents:
  - '|Triggered_Hello_Delay | 5 sec  | Random interval for initial Hello    |

    '
- title: '|                      |        | message on bootup or triggered Hello |'
  contents:
  - '|                      |        | message on bootup or triggered Hello |

    '
- title: '|                      |        | message to a rebooting neighbor      |'
  contents:
  - '|                      |        | message to a rebooting neighbor      |

    '
- title: +----------------------+--------+--------------------------------------+
  contents:
  - "+----------------------+--------+--------------------------------------+\n  \
    \ Hello messages are sent on every active interface once every\n   Hello_Period\
    \ seconds.  At system power-up, the timer is initialized\n   to rand(0,Triggered_Hello_Delay)\
    \ to prevent synchronization.  When a\n   new or rebooting neighbor is detected,\
    \ a responding Hello is sent\n   within rand(0,Triggered_Hello_Delay).\n"
- title: 'Timer Name: Neighbor Liveness Timer (NLT(N,I))'
  contents:
  - 'Timer Name: Neighbor Liveness Timer (NLT(N,I))

    '
- title: +-------------------+-----------------+--------------------------------+
  contents:
  - '+-------------------+-----------------+--------------------------------+

    '
- title: '| Value Name        | Value           | Explanation                    |'
  contents:
  - '| Value Name        | Value           | Explanation                    |

    '
- title: +-------------------+-----------------+--------------------------------+
  contents:
  - '+-------------------+-----------------+--------------------------------+

    '
- title: '| Hello Holdtime    | From message    | Hold Time from Hello Message   |'
  contents:
  - '| Hello Holdtime    | From message    | Hold Time from Hello Message   |

    '
- title: +-------------------+-----------------+--------------------------------+
  contents:
  - '+-------------------+-----------------+--------------------------------+

    '
- title: 'Timer Name: PrunePending Timer (PPT(S,G,I))'
  contents:
  - 'Timer Name: PrunePending Timer (PPT(S,G,I))

    '
- title: +-----------------------+---------------+------------------------------+
  contents:
  - '+-----------------------+---------------+------------------------------+

    '
- title: '| Value Name            | Value         | Explanation                  |'
  contents:
  - '| Value Name            | Value         | Explanation                  |

    '
- title: +-----------------------+---------------+------------------------------+
  contents:
  - '+-----------------------+---------------+------------------------------+

    '
- title: '| J/P_Override_Interval | OI(I) + PD(I) | Short time after a Prune to  |'
  contents:
  - '| J/P_Override_Interval | OI(I) + PD(I) | Short time after a Prune to  |

    '
- title: '|                       |               | allow other routers on the   |'
  contents:
  - '|                       |               | allow other routers on the   |

    '
- title: '|                       |               | LAN to send a Join           |'
  contents:
  - '|                       |               | LAN to send a Join           |

    '
- title: +-----------------------+---------------+------------------------------+
  contents:
  - "+-----------------------+---------------+------------------------------+\n  \
    \ The J/P_Override_Interval is the sum of the interface's\n   Override_Interval\
    \ (OI(I)) and Propagation_Delay (PD(I)).  If all\n   routers on a LAN are using\
    \ the LAN Prune Delay option, both\n   parameters MUST be set to the largest value\
    \ on the LAN.  Otherwise,\n   the Override_Interval (OI(I)) MUST be set to 2.5\
    \ seconds, and the\n   Propagation_Delay (PD(I)) MUST be set to 0.5 seconds.\n"
- title: 'Timer Name: Prune Timer (PT(S,G,I))'
  contents:
  - 'Timer Name: Prune Timer (PT(S,G,I))

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| Value Name     | Value          | Explanation                        |'
  contents:
  - '| Value Name     | Value          | Explanation                        |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| Prune Holdtime | From message   | Hold Time read from Prune Message  |'
  contents:
  - '| Prune Holdtime | From message   | Hold Time read from Prune Message  |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: 'Timer Name: Assert Timer (AT(S,G,I))'
  contents:
  - 'Timer Name: Assert Timer (AT(S,G,I))

    '
- title: +--------------------------+---------+---------------------------------+
  contents:
  - '+--------------------------+---------+---------------------------------+

    '
- title: '| Value Name               | Value   | Explanation                     |'
  contents:
  - '| Value Name               | Value   | Explanation                     |

    '
- title: +--------------------------+---------+---------------------------------+
  contents:
  - '+--------------------------+---------+---------------------------------+

    '
- title: '| Assert Time              | 180 sec | Period after last assert before |'
  contents:
  - '| Assert Time              | 180 sec | Period after last assert before |

    '
- title: '|                          |         | assert state is timed out       |'
  contents:
  - '|                          |         | assert state is timed out       |

    '
- title: +--------------------------+---------+---------------------------------+
  contents:
  - "+--------------------------+---------+---------------------------------+\n  \
    \ Note that, for historical reasons, the Assert message lacks a\n   Holdtime field.\
    \  Thus, changing the Assert Time from the default\n   value is not recommended.\
    \  If all members of a LAN are state refresh\n   enabled, the Assert Time will\
    \ be three times the received\n   RefreshInterval(S,G).\n"
- title: 'Timer Name: Graft Retry Timer (GRT(S,G))'
  contents:
  - 'Timer Name: Graft Retry Timer (GRT(S,G))

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '| Value Name         | Value | Explanation                             |'
  contents:
  - '| Value Name         | Value | Explanation                             |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '| Graft_Retry_Period | 3 sec | In the absence of receipt of a GraftAck |'
  contents:
  - '| Graft_Retry_Period | 3 sec | In the absence of receipt of a GraftAck |

    '
- title: '|                    |       | message, the time before retransmission |'
  contents:
  - '|                    |       | message, the time before retransmission |

    '
- title: '|                    |       | of a Graft message                      |'
  contents:
  - '|                    |       | of a Graft message                      |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: 'Timer Name: Upstream Override Timer (OT(S,G))'
  contents:
  - 'Timer Name: Upstream Override Timer (OT(S,G))

    '
- title: +------------+----------------+----------------------------------------+
  contents:
  - '+------------+----------------+----------------------------------------+

    '
- title: '| Value Name | Value          | Explanation                            |'
  contents:
  - '| Value Name | Value          | Explanation                            |

    '
- title: +------------+----------------+----------------------------------------|
  contents:
  - '+------------+----------------+----------------------------------------|

    '
- title: '| t_override | rand(0, OI(I)) | Randomized delay to prevent response   |'
  contents:
  - '| t_override | rand(0, OI(I)) | Randomized delay to prevent response   |

    '
- title: '|            |                | implosion when sending a join message  |'
  contents:
  - '|            |                | implosion when sending a join message  |

    '
- title: '|            |                | to override someone else''s prune       |'
  contents:
  - '|            |                | to override someone else''s prune       |

    '
- title: +------------+----------------+----------------------------------------+
  contents:
  - "+------------+----------------+----------------------------------------+\n  \
    \ t_override is a random value between 0 and the interface's\n   Override_Interval\
    \ (OI(I)).  If all routers on a LAN are using the LAN\n   Prune Delay option,\
    \ the Override_Interval (OI(I)) MUST be set to the\n   largest value on the LAN.\
    \  Otherwise, the Override_Interval (OI(I))\n   MUST be set to 2.5 seconds.\n"
- title: 'Timer Name: Prune Limit Timer (PLT(S,G))'
  contents:
  - 'Timer Name: Prune Limit Timer (PLT(S,G))

    '
- title: +------------+--------------------+------------------------------------+
  contents:
  - '+------------+--------------------+------------------------------------+

    '
- title: '| Value Name | Value              | Explanation                        |'
  contents:
  - '| Value Name | Value              | Explanation                        |

    '
- title: +------------+--------------------+------------------------------------|
  contents:
  - '+------------+--------------------+------------------------------------|

    '
- title: '| t_limit    | Default: 210 secs  | Used to prevent Prune storms on a  |'
  contents:
  - '| t_limit    | Default: 210 secs  | Used to prevent Prune storms on a  |

    '
- title: '|            |                    | LAN                                |'
  contents:
  - '|            |                    | LAN                                |

    '
- title: +------------+--------------------+------------------------------------+
  contents:
  - '+------------+--------------------+------------------------------------+

    '
- title: 'Timer Name: Source Active Timer (SAT(S,G))'
  contents:
  - 'Timer Name: Source Active Timer (SAT(S,G))

    '
- title: +----------------+-------------------+---------------------------------+
  contents:
  - '+----------------+-------------------+---------------------------------+

    '
- title: '| Value Name     | Value             | Explanation                     |'
  contents:
  - '| Value Name     | Value             | Explanation                     |

    '
- title: +----------------+-------------------+---------------------------------+
  contents:
  - '+----------------+-------------------+---------------------------------+

    '
- title: '| SourceLifetime | Default: 210 secs | Period of time after receiving  |'
  contents:
  - '| SourceLifetime | Default: 210 secs | Period of time after receiving  |

    '
- title: '|                |                   | a multicast message a directly  |'
  contents:
  - '|                |                   | a multicast message a directly  |

    '
- title: '|                |                   | attached router will continue   |'
  contents:
  - '|                |                   | attached router will continue   |

    '
- title: '|                |                   | to send State Refresh messages  |'
  contents:
  - '|                |                   | to send State Refresh messages  |

    '
- title: +----------------+-------------------+---------------------------------+
  contents:
  - '+----------------+-------------------+---------------------------------+

    '
- title: 'Timer Name: State Refresh Timer (SRT(S,G))'
  contents:
  - 'Timer Name: State Refresh Timer (SRT(S,G))

    '
- title: +-----------------+------------------+---------------------------------+
  contents:
  - '+-----------------+------------------+---------------------------------+

    '
- title: '| Value Name      | Value            | Explanation                     |'
  contents:
  - '| Value Name      | Value            | Explanation                     |

    '
- title: +-----------------+------------------+---------------------------------+
  contents:
  - '+-----------------+------------------+---------------------------------+

    '
- title: '| RefreshInterval | Default: 60 secs | Interval between successive     |'
  contents:
  - '| RefreshInterval | Default: 60 secs | Interval between successive     |

    '
- title: '|                 |                  | state refresh messages          |'
  contents:
  - '|                 |                  | state refresh messages          |

    '
- title: +-----------------+------------------+---------------------------------+
  contents:
  - '+-----------------+------------------+---------------------------------+

    '
- title: 5.  Protocol Interaction Considerations
  contents:
  - "5.  Protocol Interaction Considerations\n   PIM-DM is designed to be independent\
    \ of underlying unicast routing\n   protocols and will interact only to the extent\
    \ needed to perform RPF\n   checks.  It is generally assumed that multicast area\
    \ and autonomous\n   system boundaries will correspond to the same boundaries\
    \ for unicast\n   routing, though a deployment that does not follow this assumption\
    \ is\n   not precluded by this specification.\n   In general, PIM-DM interactions\
    \ with other multicast routing\n   protocols should be in compliance with RFC\
    \ 2715 [7].  Other specific\n   interactions are noted below.\n"
- title: 5.1.  PIM-SM Interactions
  contents:
  - "5.1.  PIM-SM Interactions\n   PIM-DM is not intended to interact directly with\
    \ PIM-SM, even though\n   they share a common packet format.  It is particularly\
    \ important to\n   note that a router cannot differentiate between a PIM-DM neighbor\
    \ and\n   a PIM-SM neighbor based on Hello messages.\n   In the event that a PIM-DM\
    \ router becomes a neighbor of a PIM-SM\n   router, the two will effectively form\
    \ a simplex link, with the PIM-DM\n   router sending all multicast messages to\
    \ the PIM-SM router while the\n   PIM-SM router sends no multicast messages to\
    \ the PIM-DM router.\n   The common packet format permits a hybrid PIM-SM/DM implementation\n\
    \   that would use PIM-SM when a rendezvous point is known and PIM-DM\n   when\
    \ one is not.  Such an implementation is outside the scope of this\n   document.\n"
- title: 5.2.  IGMP Interactions
  contents:
  - "5.2.  IGMP Interactions\n   PIM-DM will forward received multicast data packets\
    \ to neighboring\n   host group members in all cases except when the PIM-DM router\
    \ is in\n   an Assert Loser state on that interface.  Note that a PIM Prune\n\
    \   message is not permitted to prevent the delivery of messages to a\n   network\
    \ with group members.\n   A PIM-DM Router MAY use the DR Priority option described\
    \ in PIM-SM\n   [14] to elect an IGMP v1 querier.\n"
- title: 5.3.  Source Specific Multicast (SSM) Interactions
  contents:
  - "5.3.  Source Specific Multicast (SSM) Interactions\n   PIM-DM makes no special\
    \ considerations for SSM [15].  All Prunes and\n   Grafts within the protocol\
    \ are for a specific source, so no\n   additional checks have to be made.\n"
- title: 5.4.  Multicast Group Scope Boundary Interactions
  contents:
  - "5.4.  Multicast Group Scope Boundary Interactions\n   Although multicast group\
    \ scope boundaries are generally identical to\n   routing area boundaries, it\
    \ is conceivable that a routing area might\n   be partitioned for a particular\
    \ multicast group.  PIM-DM routers MUST\n   NOT send any messages concerning a\
    \ particular group across that\n   group's scope boundary.\n"
- title: 6.  IANA Considerations
  contents:
  - '6.  IANA Considerations

    '
- title: 6.1.  PIM Address Family
  contents:
  - "6.1.  PIM Address Family\n   The PIM Address Family field was chosen to be 8\
    \ bits as a tradeoff\n   between packet format and use of the IANA assigned numbers.\
    \  When the\n   PIM packet format was designed, only 15 values were assigned for\n\
    \   Address Families, and large numbers of new Address Families were not\n   envisioned;\
    \ 8 bits seemed large enough.  However, the IANA assigns\n   Address Families\
    \ in a 16 bit value.  Therefore, the PIM Address\n   Family is allocated as follows:\n\
    \   Values 0 - 127 are designated to have the same meaning as IANA\n   assigned\
    \ Address Family Numbers [9].\n   Values 128 - 250 are designated to be assigned\
    \ by the IANA based on\n   IESG approval, as defined in [8].\n   Values 251 -\
    \ 255 are designated for Private Use, as defined in [8].\n"
- title: 6.2.  PIM Hello Options
  contents:
  - "6.2.  PIM Hello Options\n   Values 17 - 65000 are to be assigned by the IANA.\
    \  Since the space is\n   large, they may be assigned as First Come First Served,\
    \ as defined in\n   [8].  Assignments are valid for one year and may be renewed.\n\
    \   Permanent assignments require a specification, as defined in [8].\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The IPsec authentication header [10] MAY be used\
    \ to provide data\n   integrity protection and groupwise data origin authentication\
    \ of PIM\n   protocol messages.  Authentication of PIM messages can protect\n\
    \   against unwanted behaviors caused by unauthorized or altered PIM\n   messages.\
    \  In any case, a PIM router SHOULD NOT accept and process\n   PIM messages from\
    \ neighbors unless a valid Hello message has been\n   received from that neighbor.\n\
    \   Note that PIM-DM has no rendezvous point, and therefore no single\n   point\
    \ of failure that may be vulnerable.  Because PIM-DM uses unicast\n   routes provided\
    \ by an unknown routing protocol, it may suffer\n   collateral effects if the\
    \ unicast routing protocol is attacked.\n"
- title: 7.1.  Attacks Based on Forged Messages
  contents:
  - "7.1.  Attacks Based on Forged Messages\n   The extent of possible damage depends\
    \ on the type of counterfeit\n   messages accepted.  We next consider the impact\
    \ of possible\n   forgeries. A forged PIM-DM message is link local and can only\
    \ reach a\n   LAN if it was sent by a local host or if it was allowed onto the\
    \ LAN\n   by a compromised or non-compliant router.\n   1. A forged Hello message\
    \ can cause multicast traffic to be delivered\n      to links where there are\
    \ no legitimate requestors, potentially\n      wasting bandwidth on that link.\
    \  On a multi-access LAN, the\n      effects are limited without the capability\
    \ to forge a Join\n      message, as other routers will Prune the link if the\
    \ traffic is\n      not desired.\n   2. A forged Join/Prune message can cause\
    \ multicast traffic to be\n      delivered to links where there are no legitimate\
    \ requestors,\n      potentially wasting bandwidth on that link.  A forged Prune\n\
    \      message on a multi-access LAN is generally not a significant\n      attack\
    \ in PIM, because any legitimately joined router on the LAN\n      would override\
    \ the Prune with a Join before the upstream router\n      stops forwarding data\
    \ to the LAN.\n   3. A forged Graft message can cause multicast traffic to be\
    \ delivered\n      to links where there are no legitimate requestors, potentially\n\
    \      wasting bandwidth on that link.  In principle, Graft messages\n      could\
    \ be sent multiple hops because they are unicast to the\n      upstream router.\
    \  This should not be a problem, as the remote\n      forger should have no way\
    \ to get a Hello message to the target of\n      the attack.  Without a valid\
    \ Hello message, the receiving router\n      SHOULD NOT accept the Graft.\n  \
    \ 4. A forged GraftAck message has no impact, as it will be ignored\n      unless\
    \ the router has recently sent a Graft to its upstream\n      router.\n   5. By\
    \ forging an Assert message on a multi-access LAN, an attacker\n      could cause\
    \ the legitimate forwarder to stop forwarding traffic to\n      the LAN.  Such\
    \ a forgery would prevent any hosts downstream of\n      that LAN from receiving\
    \ traffic.\n   6. A forged State Refresh message on a multi-access LAN would have\n\
    \      the same impact as a forged Assert message, having the same\n      general\
    \ functions.  In addition, forged State Refresh messages\n      would be propagated\
    \ downstream and might be used in a denial of\n      service attack.  Therefore,\
    \ a PIM-DM router SHOULD rate limit\n      State Refresh messages propagated.\n"
- title: 7.2.  Non-cryptographic Authentication Mechanisms
  contents:
  - "7.2.  Non-cryptographic Authentication Mechanisms\n   A PIM-DM router SHOULD\
    \ provide an option to limit the set of\n   neighbors from which it will accept\
    \ PIM-DM messages.  Either static\n   configuration of IP addresses or an IPSec\
    \ security association may be\n   used.  All options that restrict the range of\
    \ addresses from which\n   packets are accepted MUST default to allowing all packets.\n\
    \   Furthermore, a PIM router SHOULD NOT accept protocol messages from a\n   router\
    \ from which it has not yet received a valid Hello message.\n"
- title: 7.3.  Authentication Using IPsec
  contents:
  - "7.3.  Authentication Using IPsec\n   The IPSec [10] transport mode using the\
    \ Authentication Header (AH) is\n   the recommended method to prevent the above\
    \ attacks in PIM.  The\n   specific AH authentication algorithm and parameters,\
    \ including the\n   choice of authentication algorithm and the choice of key,\
    \ are\n   configured by the network administrator.  The Encapsulating Security\n\
    \   Payload (ESP) MAY also be used to provide both encryption and\n   authentication\
    \ of PIM protocol messages.  When IPsec authentication\n   is used, a PIM router\
    \ SHOULD reject (drop without processing) any\n   unauthorized PIM protocol messages.\n\
    \   To use IPSec, the administrator of a PIM network configures each PIM\n   router\
    \ with one or more Security Associations and associated Security\n   Parameters\
    \ Indices that are used by senders to authenticate PIM\n   protocol messages and\
    \ are used by receivers to authenticate received\n   PIM protocol messages.  This\
    \ document does not describe protocols for\n   establishing Security Associations.\
    \  It assumes that manual\n   configuration of Security Associations is performed,\
    \ but it does not\n   preclude the use of some future negotiation protocol such\
    \ as GDOI\n   [17] to establish Security Associations.\n   The network administrator\
    \ defines a Security Association (SA) and\n   Security Parameters Index (SPI)\
    \ to be used to authenticate all PIM-DM\n   protocol messages from each router\
    \ on each link in a PIM-DM domain.\n   In order to avoid the problem of allocating\
    \ individual keys for each\n   neighbor on a link to each individual router, it\
    \ is acceptable to\n   establish only one authentication key for all PIM-DM routers\
    \ on a\n   link.  This will not specifically authenticate the individual router\n\
    \   sending the message, but will ensure that the sender is a PIM-DM\n   router\
    \ on that link.  If this method is used, the receiver of the\n   message MUST\
    \ ignore the received sequence number, thus disabling\n   anti-replay mechanisms.\
    \  The effects of disabling anti-replay\n   mechanisms are essentially the same\
    \ as the effects of forged\n   messages, described in Section 7.1, with the additional\
    \ protection\n   that the forger can only reuse legitimate messages.\n   The Security\
    \ Policy Database at a PIM-DM router should be configured\n   to ensure that all\
    \ incoming and outgoing PIM-DM packets use the SA\n   associated with the interface\
    \ to which the packet is sent.  Note\n   that, according to [10], there is nominally\
    \ a different Security\n   Association Database (SAD) for each router interface.\
    \  Thus, the\n   selected Security Association for an inbound PIM-DM packet can\
    \ vary\n   depending on the interface on which the packet arrived.  This fact\n\
    \   allows the network administrator to use different authentication\n   methods\
    \ for each link, even though the destination address is the\n   same for most\
    \ PIM-DM packets, regardless of interface.\n"
- title: 7.4.  Denial of Service Attacks
  contents:
  - "7.4.  Denial of Service Attacks\n   There are a number of possible denial of\
    \ service attacks against PIM\n   that can be caused by generating false PIM protocol\
    \ messages or even\n   by generating false data traffic.  Authenticating PIM protocol\n\
    \   traffic prevents some, but not all, of these attacks.  The possible\n   attacks\
    \ include the following:\n   * Sending packets to many different group addresses\
    \ quickly can\n     amount to a denial of service attack in and of itself.  These\n\
    \     messages will initially be flooded throughout the network before\n     they\
    \ are pruned back.  The maintenance of state machines and State\n     Refresh\
    \ messages will be a continual drain on network resources.\n   * Forged State\
    \ Refresh messages sent quickly could be propagated by\n     downstream routers,\
    \ creating a potential denial of service attack.\n     Therefore, a PIM-DM router\
    \ SHOULD limit the rate of State Refresh\n     messages propagated.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   The major features of PIM-DM were originally designed\
    \ by Stephen\n   Deering, Deborah Estrin, Dino Farinacci, Van Jacobson, Ahmed\
    \ Helmy,\n   David Meyer, and Liming Wei.  Additional features for state refresh\n\
    \   were designed by Dino Farinacci, Isidor Kouvelas, and Kurt Windisch.\n   This\
    \ revision was undertaken to incorporate some of the lessons\n   learned during\
    \ the evolution of the PIM-SM specification and early\n   deployments of PIM-DM.\n\
    \   Thanks the PIM Working Group for their comments.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [1]  Deering, S., \"Host extensions for IP multicasting\"\
    , STD 5, RFC\n        1112, August 1989.\n   [2]  Fenner, W., \"Internet Group\
    \ Management Protocol, Version 2\", RFC\n        2236, November 1997.\n   [3]\
    \  Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A.\n        Thyagarajan,\
    \ \"Internet Group Management Protocol, Version 3\",\n        RFC 3376, October\
    \ 2002.\n   [4]  Estrin, D., Farinacci, D., Helmy, A., Thaler, D., Deering, S.,\n\
    \        Handley, M., Jacobson, V., Liu, C., Sharma, P., and L. Wei,\n       \
    \ \"Protocol Independent Multicast-Sparse Mode (PIM-SM): Protocol\n        Specification\"\
    , RFC 2362, June 1998.\n   [5]  Deering, S. and R. Hinden, \"Internet Protocol,\
    \ Version 6 (IPv6)\n        Specification\", RFC 2460, December 1998.\n   [6]\
    \  Deering, S., Fenner, W., and B. Haberman, \"Multicast Listener\n        Discovery\
    \ (MLD) for IPv6\", RFC 2710, October 1999.\n   [7]  Thaler, D., \"Interoperability\
    \ Rules for Multicast Routing\n        Protocols\", RFC 2715, October 1999.\n\
    \   [8]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA\n    \
    \    Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.\n   [9]\
    \  IANA, \"Address Family Numbers\", linked from\n        http://www.iana.org/numbers.html.\n\
    \   [10] Kent, S. and R. Atkinson, \"Security Architecture for the\n        Internet\
    \ Protocol\", RFC 2401, November 1998.\n   [11] Bradner, S., \"Key words for use\
    \ in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [12] Deering, S.E., \"Multicast Routing in a\
    \ Datagram Internetwork\",\n        Ph.D. Thesis, Electrical Engineering Dept.,\
    \ Stanford University,\n        December 1991.\n   [13] Waitzman, D., Partridge,\
    \ C., and S. Deering, \"Distance Vector\n        Multicast Routing Protocol\"\
    , RFC 1075, November 1988.\n   [14] Fenner,  W., Handley, M., Holbrook, H., and\
    \ I. Kouvelas,\n        \"Protocol Independent Multicast - Sparse Mode (PIM-SM):\
    \ Protocol\n        Specification (Revised)\", Work in Progress.\n   [15] Holbrook,\
    \ H. and B. Cain, \"Source Specific Multicast for IP\",\n        Work in Progress.\n\
    \   [16] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, \"Bi-\n   \
    \     directional Protocol Independent Multicast\", Work in Progress.\n   [17]\
    \ Baugher, M., Weis, B., Hardjono, T., and H. Harney, \"The Group\n        Domain\
    \ of Interpretation\", RFC 3547, July 2003.\n   [18] Fenner, W., Handley, M.,\
    \ Kermode, R., and D. Thaler, \"Bootstrap\n        Router (BSR) Mechanism for\
    \ PIM Sparse Mode\", Work in Progress.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Andrew Adams\n   NextHop Technologies\n   825 Victors\
    \ Way, Suite 100\n   Ann Arbor, MI 48108-2738\n   EMail: ala@nexthop.com\n   Jonathan\
    \ Nicholas\n   ITT Industries\n   Aerospace/Communications Division\n   100 Kingsland\
    \ Rd\n   Clifton, NJ  07014\n   EMail: jonathan.nicholas@itt.com\n   William Siadak\n\
    \   NextHop Technologies\n   825 Victors Way, Suite 100\n   Ann Arbor, MI 48108-2738\n\
    \   EMail: wfs@nexthop.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
