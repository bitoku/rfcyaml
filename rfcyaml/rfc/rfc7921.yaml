- title: __initial_text__
  contents:
  - '        An Architecture for the Interface to the Routing System

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes the IETF architecture for a standard,\n\
    \   programmatic interface for state transfer in and out of the Internet\n   routing\
    \ system.  It describes the high-level architecture, the\n   building blocks of\
    \ this high-level architecture, and their\n   interfaces, with particular focus\
    \ on those to be standardized as part\n   of the Interface to the Routing System\
    \ (I2RS).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7921.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Drivers for the I2RS Architecture ..........................5\n  \
    \    1.2. Architectural Overview .....................................6\n   2.\
    \ Terminology ....................................................11\n   3. Key\
    \ Architectural Properties ...................................13\n      3.1. Simplicity\
    \ ................................................13\n      3.2. Extensibility\
    \ .............................................14\n      3.3. Model-Driven Programmatic\
    \ Interfaces ......................14\n   4. Security Considerations ........................................15\n\
    \      4.1. Identity and Authentication ...............................17\n  \
    \    4.2. Authorization .............................................18\n    \
    \  4.3. Client Redundancy .........................................19\n      4.4.\
    \ I2RS in Personal Devices ..................................19\n   5. Network\
    \ Applications and I2RS Client ...........................19\n      5.1. Example\
    \ Network Application: Topology Manager .............20\n   6. I2RS Agent Role\
    \ and Functionality ..............................20\n      6.1. Relationship\
    \ to Its Routing Element .......................20\n      6.2. I2RS State Storage\
    \ ........................................21\n           6.2.1. I2RS Agent Failure\
    \ .................................21\n           6.2.2. Starting and Ending ................................22\n\
    \           6.2.3. Reversion ..........................................23\n  \
    \    6.3. Interactions with Local Configuration .....................23\n    \
    \       6.3.1. Examples of Local Configuration vs. I2RS\n                  Ephemeral\
    \ Configuration ............................24\n      6.4. Routing Components\
    \ and Associated I2RS Services ...........26\n           6.4.1. Routing and Label\
    \ Information Bases ................28\n           6.4.2. IGPs, BGP, and Multicast\
    \ Protocols .................28\n           6.4.3. MPLS ...............................................29\n\
    \           6.4.4. Policy and QoS Mechanisms ..........................29\n  \
    \         6.4.5. Information Modeling, Device Variation, and\n               \
    \   Information Relationships ..........................29\n                 \
    \ 6.4.5.1. Managing Variation: Object\n                           Classes/Types\
    \ and Inheritance .............29\n                  6.4.5.2. Managing Variation:\
    \ Optionality ...........30\n                  6.4.5.3. Managing Variation: Templating\
    \ ............31\n                  6.4.5.4. Object Relationships ......................31\n\
    \                           6.4.5.4.1. Initialization .................31\n  \
    \                         6.4.5.4.2. Correlation Identification .....32\n    \
    \                       6.4.5.4.3. Object References ..............32\n      \
    \                     6.4.5.4.4. Active References ..............32\n   7. I2RS\
    \ Client Agent Interface ....................................32\n      7.1. One\
    \ Control and Data Exchange Protocol ....................32\n      7.2. Communication\
    \ Channels ....................................33\n      7.3. Capability Negotiation\
    \ ....................................33\n      7.4. Scope Policy Specifications\
    \ ...............................34\n      7.5. Connectivity ..............................................34\n\
    \      7.6. Notifications .............................................35\n  \
    \    7.7. Information Collection ....................................35\n    \
    \  7.8. Multi-headed Control ......................................36\n      7.9.\
    \ Transactions ..............................................36\n   8. Operational\
    \ and Manageability Considerations ...................37\n   9. References .....................................................38\n\
    \      9.1. Normative References ......................................38\n  \
    \    9.2. Informative References ....................................38\n   Acknowledgements\
    \ ..................................................39\n   Authors' Addresses\
    \ ................................................40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Routers that form the Internet routing infrastructure maintain\
    \ state\n   at various layers of detail and function.  For example, a typical\n\
    \   router maintains a Routing Information Base (RIB) and implements\n   routing\
    \ protocols such as OSPF, IS-IS, and BGP to exchange\n   reachability information,\
    \ topology information, protocol state, and\n   other information about the state\
    \ of the network with other routers.\n   Routers convert all of this information\
    \ into forwarding entries,\n   which are then used to forward packets and flows\
    \ between network\n   elements.  The forwarding plane and the specified forwarding\
    \ entries\n   then contain active state information that describes the expected\
    \ and\n   observed operational behavior of the router and that is also needed\n\
    \   by the network applications.  Network-oriented applications require\n   easy\
    \ access to this information to learn the network topology, to\n   verify that\
    \ programmed state is installed in the forwarding plane, to\n   measure the behavior\
    \ of various flows, routes or forwarding entries,\n   as well as to understand\
    \ the configured and active states of the\n   router.  Network-oriented applications\
    \ also require easy access to an\n   interface, which will allow them to program\
    \ and control state related\n   to forwarding.\n   This document sets out an architecture\
    \ for a common, standards-based\n   interface to this information.  This Interface\
    \ to the Routing System\n   (I2RS) facilitates control and observation of the\
    \ routing-related\n   state (for example, a Routing Element RIB manager's state),\
    \ as well\n   as enabling network-oriented applications to be built on top of\n\
    \   today's routed networks.  The I2RS is a programmatic asynchronous\n   interface\
    \ for transferring state into and out of the Internet routing\n   system.  This\
    \ I2RS architecture recognizes that the routing system\n   and a router's Operating\
    \ System (OS) provide useful mechanisms that\n   applications could harness to\
    \ accomplish application-level goals.\n   These network-oriented applications\
    \ can leverage the I2RS\n   programmatic interface to create new ways to combine\
    \ retrieving\n   Internet routing data, analyzing this data, and setting state\
    \ within\n   routers.\n   Fundamental to I2RS are clear data models that define\
    \ the semantics\n   of the information that can be written and read.  I2RS provides\
    \ a way\n   for applications to customize network behavior while leveraging the\n\
    \   existing routing system as desired.  I2RS provides a framework for\n   applications\
    \ (including controller applications) to register and to\n   request the appropriate\
    \ information for each particular application.\n   Although the I2RS architecture\
    \ is general enough to support\n   information and data models for a variety of\
    \ data, and aspects of the\n   I2RS solution may be useful in domains other than\
    \ routing, I2RS and\n   this document are specifically focused on an interface\
    \ for routing\n   data.\n   Security is a concern for any new I2RS.  Section 4\
    \ provides an\n   overview of the security considerations for the I2RS architecture.\n\
    \   The detailed requirements for I2RS protocol security are contained in\n  \
    \ [I2RS-PROT-SEC], and the detailed security requirements for\n   environment\
    \ in which the I2RS protocol exists are contained in\n   [I2RS-ENV-SEC].\n"
- title: 1.1.  Drivers for the I2RS Architecture
  contents:
  - "1.1.  Drivers for the I2RS Architecture\n   There are four key drivers that shape\
    \ the I2RS architecture.  First\n   is the need for an interface that is programmatic\
    \ and asynchronous\n   and that offers fast, interactive access for atomic operations.\n\
    \   Second is the access to structured information and state that is\n   frequently\
    \ not directly configurable or modeled in existing\n   implementations or configuration\
    \ protocols.  Third is the ability to\n   subscribe to structured, filterable\
    \ event notifications from the\n   router.  Fourth, the operation of I2RS is to\
    \ be data-model-driven to\n   facilitate extensibility and provide standard data\
    \ models to be used\n   by network applications.\n   I2RS is described as an asynchronous\
    \ programmatic interface, the key\n   properties of which are described in Section\
    \ 5 of [RFC7920].\n   The I2RS architecture facilitates obtaining information\
    \ from the\n   router.  The I2RS architecture provides the ability to not only\
    \ read\n   specific information, but also to subscribe to targeted information\n\
    \   streams, filtered events, and thresholded events.\n   Such an interface also\
    \ facilitates the injection of ephemeral state\n   into the routing system.  Ephemeral\
    \ state on a router is the state\n   that does not survive the reboot of a routing\
    \ device or the reboot of\n   the software handling the I2RS software on a routing\
    \ device.  A non-\n   routing protocol or application could inject state into\
    \ a routing\n   element via the state-insertion functionality of I2RS and that\
    \ state\n   could then be distributed in a routing or signaling protocol and/or\n\
    \   be used locally (e.g., to program the co-located forwarding plane).\n   I2RS\
    \ will only permit modification of state that would be possible to\n   modify\
    \ via Local Configuration; no direct manipulation of protocol-\n   internal, dynamically\
    \ determined data is envisioned.\n"
- title: 1.2.  Architectural Overview
  contents:
  - "1.2.  Architectural Overview\n   Figure 1 shows the basic architecture for I2RS\
    \ between applications\n   using I2RS, their associated I2RS clients, and I2RS\
    \ agents.\n   Applications access I2RS services through I2RS clients.  A single\n\
    \   I2RS client can provide access to one or more applications.  This\n   figure\
    \ also shows the types of data models associated with the\n   routing system (dynamic\
    \ configuration, static configuration, Local\n   Configuration, and routing and\
    \ signaling configuration) that the I2RS\n   agent data models may access or augment.\n\
    \   Figure 1 is similar to Figure 1 in [RFC7920], but the figure in this\n   document\
    \ shows additional detail on how the applications utilize I2RS\n   clients to\
    \ interact with I2RS agents.  It also shows a logical view\n   of the data models\
    \ associated with the routing system rather than a\n   functional view (RIB, Forwarding\
    \ Information Base (FIB), topology,\n   policy, routing/signaling protocols, etc.)\n\
    \   In Figure 1, Clients A and B each provide access to a single\n   application\
    \ (Applications A and B, respectively), while Client P\n   provides access to\
    \ multiple applications.\n   Applications can access I2RS services through local\
    \ or remote\n   clients.  A local client operates on the same physical box as\
    \ the\n   routing system.  In contrast, a remote client operates across the\n\
    \   network.  In the figure, Applications A and B access I2RS services\n   through\
    \ local clients, while Applications C, D, and E access I2RS\n   services through\
    \ a remote client.  The details of how applications\n   communicate with a remote\
    \ client is out of scope for I2RS.\n   An I2RS client can access one or more I2RS\
    \ agents.  In Figure 1,\n   Clients B and P access I2RS agents 1 and 2.  Likewise,\
    \ an I2RS agent\n   can provide service to one or more clients.  In this figure,\
    \ I2RS\n   agent 1 provides services to Clients A, B, and P while Agent 2\n  \
    \ provides services to only Clients B and P.\n   I2RS agents and clients communicate\
    \ with one another using an\n   asynchronous protocol.  Therefore, a single client\
    \ can post multiple\n   simultaneous requests, either to a single agent or to\
    \ multiple\n   agents.  Furthermore, an agent can process multiple requests, either\n\
    \   from a single client or from multiple clients, simultaneously.\n   The I2RS\
    \ agent provides read and write access to selected data on the\n   routing element\
    \ that are organized into I2RS services.  Section 4\n   describes how access is\
    \ mediated by authentication and access control\n   mechanisms.  Figure 1 shows\
    \ I2RS agents being able to write ephemeral\n   static state (e.g., RIB entries)\
    \ and to read from dynamic static\n   (e.g., MPLS Label Switched Path Identifier\
    \ (LSP-ID) or number of\n   active BGP peers).\n   In addition to read and write\
    \ access, the I2RS agent allows clients\n   to subscribe to different types of\
    \ notifications about events\n   affecting different object instances.  One example\
    \ of a notification\n   of such an event (which is unrelated to an object creation,\n\
    \   modification or deletion) is when a next hop in the RIB is resolved\n   in\
    \ a way that allows it to be used by a RIB manager for installation\n   in the\
    \ forwarding plane as part of a particular route.  Please see\n   Sections 7.6\
    \ and 7.7 for details.\n   The scope of I2RS is to define the interactions between\
    \ the I2RS\n   agent and the I2RS client and the associated proper behavior of\
    \ the\n   I2RS agent and I2RS client.\n        ******************   *****************\
    \  *****************\n        *  Application C *   * Application D *  * Application\
    \ E *\n        ******************   *****************  *****************\n   \
    \              ^                  ^                   ^\n                 |--------------|\
    \   |    |--------------|\n                                |   |    |\n      \
    \                          v   v    v\n                              ***************\n\
    \                              *  Client P   *\n                             \
    \ ***************\n                                   ^     ^\n              \
    \                     |     |-------------------------|\n         ***********************\
    \   |      ***********************  |\n         *    Application A    *   |  \
    \    *    Application B    *  |\n         *                     *   |      * \
    \                    *  |\n         *  +----------------+ *   |      *  +----------------+\
    \ *  |\n         *  |   Client A     | *   |      *  |   Client B     | *  |\n\
    \         *  +----------------+ *   |      *  +----------------+ *  |\n      \
    \   ******* ^ *************   |      ***** ^ ****** ^ ******  |\n            \
    \     |                 |            |        |         |\n                 |\
    \   |-------------|            |        |   |-----|\n                 |   |  \
    \ -----------------------|        |   |\n                 |   |   |          \
    \                     |   |\n    ************ v * v * v *********   *****************\
    \ v * v ********\n    *  +---------------------+     *   *  +---------------------+\
    \     *\n    *  |     Agent 1         |     *   *  |    Agent 2          |   \
    \  *\n    *  +---------------------+     *   *  +---------------------+     *\n\
    \    *     ^        ^  ^   ^        *   *     ^        ^  ^   ^        *\n   \
    \ *     |        |  |   |        *   *     |        |  |   |        *\n    * \
    \    v        |  |   v        *   *     v        |  |   v        *\n    * +---------+\
    \  |  | +--------+ *   * +---------+  |  | +--------+ *\n    * | Routing |  |\
    \  | | Local  | *   * | Routing |  |  | | Local  | *\n    * |   and   |  |  |\
    \ | Config | *   * |   and   |  |  | | Config | *\n    * |Signaling|  |  | +--------+\
    \ *   * |Signaling|  |  | +--------+ *\n    * +---------+  |  |         ^  * \
    \  * +---------+  |  |         ^  *\n    *    ^         |  |         |  *   *\
    \    ^         |  |         |  *\n    *    |    |----|  |         |  *   *   \
    \ |    |----|  |         |  *\n    *    v    |       v         v  *   *    v \
    \   |       v         v  *\n    *  +----------+ +------------+ *   *  +----------+\
    \ +------------+ *\n    *  |  Dynamic | |   Static   | *   *  |  Dynamic | | \
    \  Static   | *\n    *  |  System  | |   System   | *   *  |  System  | |   System\
    \   | *\n    *  |  State   | |   State    | *   *  |  State   | |   State    |\
    \ *\n    *  +----------+ +------------+ *   *  +----------+ +------------+ *\n\
    \    *                              *   *                              *\n   \
    \ *  Routing Element 1           *   *  Routing Element 2           *\n    ********************************\
    \   ********************************\n             Figure 1: Architecture of I2RS\
    \ Clients and Agents\n   Routing Element:  A Routing Element implements some subset\
    \ of the\n      routing system.  It does not need to have a forwarding plane\n\
    \      associated with it.  Examples of Routing Elements can include:\n      *\
    \  A router with a forwarding plane and RIB Manager that runs\n         IS-IS,\
    \ OSPF, BGP, PIM, etc.,\n      *  A BGP speaker acting as a Route Reflector,\n\
    \      *  A Label Switching Router (LSR) that implements RSVP-TE,\n         OSPF-TE,\
    \ and the Path Computation Element (PCE) Communication\n         Protocol (PCEP)\
    \ and has a forwarding plane and associated RIB\n         Manager, and\n     \
    \ *  A server that runs IS-IS, OSPF, and BGP and uses Forwarding and\n       \
    \  Control Element Separation (ForCES) to control a remote\n         forwarding\
    \ plane.\n      A Routing Element may be locally managed, whether via command-line\n\
    \      interface (CLI), SNMP, or the Network Configuration Protocol\n      (NETCONF).\n\
    \   Routing and Signaling:  This block represents that portion of the\n      Routing\
    \ Element that implements part of the Internet routing\n      system.  It includes\
    \ not merely standardized protocols (i.e.,\n      IS-IS, OSPF, BGP, PIM, RSVP-TE,\
    \ LDP, etc.), but also the RIB\n      Manager layer.\n   Local Configuration:\
    \  The black box behavior for interactions between\n      the ephemeral state\
    \ that I2RS installs into the routing element;\n      Local Configuration is defined\
    \ by this document and the behaviors\n      specified by the I2RS protocol.\n\
    \   Dynamic System State:  An I2RS agent needs access to state on a\n      routing\
    \ element beyond what is contained in the routing subsystem.\n      Such state\
    \ may include various counters, statistics, flow data,\n      and local events.\
    \  This is the subset of operational state that is\n      needed by network applications\
    \ based on I2RS that is not contained\n      in the routing and signaling information.\
    \  How this information is\n      provided to the I2RS agent is out of scope,\
    \ but the standardized\n      information and data models for what is exposed\
    \ are part of I2RS.\n   Static System State:  An I2RS agent needs access to static\
    \ state on a\n      routing element beyond what is contained in the routing subsystem.\n\
    \      An example of such state is specifying queueing behavior for an\n     \
    \ interface or traffic.  How the I2RS agent modifies or obtains this\n      information\
    \ is out of scope, but the standardized information and\n      data models for\
    \ what is exposed are part of I2RS.\n   I2RS agent:  See the definition in Section\
    \ 2.\n   Application:  A network application that needs to observe the network\n\
    \      or manipulate the network to achieve its service requirements.\n   I2RS\
    \ client:  See the definition in Section 2.\n   As can be seen in Figure 1, an\
    \ I2RS client can communicate with\n   multiple I2RS agents.  Similarly, an I2RS\
    \ agent may communicate with\n   multiple I2RS clients -- whether to respond to\
    \ their requests, to\n   send notifications, etc.  Timely notifications are critical\
    \ so that\n   several simultaneously operating applications have up-to-date\n\
    \   information on the state of the network.\n   As can also be seen in Figure\
    \ 1, an I2RS agent may communicate with\n   multiple clients.  Each client may\
    \ send the agent a variety of write\n   operations.  In order to keep the protocol\
    \ simple, two clients should\n   not attempt to write (modify) the same piece\
    \ of information on an\n   I2RS agent.  This is considered an error.  However,\
    \ such collisions\n   may happen and Section 7.8 (\"Multi-headed Control\") describes\
    \ how the\n   I2RS agent resolves collision by first utilizing priority to resolve\n\
    \   collisions and second by servicing the requests in a first-in, first-\n  \
    \ served basis.  The I2RS architecture includes this definition of\n   behavior\
    \ for this case simply for predictability, not because this is\n   an intended\
    \ result.  This predictability will simplify error handling\n   and suppress oscillations.\
    \  If additional error cases beyond this\n   simple treatment are required, these\
    \ error cases should be resolved\n   by the network applications and management\
    \ systems.\n   In contrast, although multiple I2RS clients may need to supply\
    \ data\n   into the same list (e.g., a prefix or filter list), this is not\n \
    \  considered an error and must be correctly handled.  The nuances so\n   that\
    \ writers do not normally collide should be handled in the\n   information models.\n\
    \   The architectural goal for I2RS is that such errors should produce\n   predictable\
    \ behaviors and be reportable to interested clients.  The\n   details of the associated\
    \ policy is discussed in Section 7.8.  The\n   same policy mechanism (simple priority\
    \ per I2RS client) applies to\n   interactions between the I2RS agent and the\
    \ CLI/SNMP/NETCONF as\n   described in Section 6.3.\n   In addition, it must be\
    \ noted that there may be indirect interactions\n   between write operations.\
    \  A basic example of this is when two\n   different but overlapping prefixes\
    \ are written with different\n   forwarding behavior.  Detection and avoidance\
    \ of such interactions is\n   outside the scope of the I2RS work and is left to\
    \ agent design and\n   implementation.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The following terminology is used in this document.\n   agent\
    \ or I2RS agent:   An I2RS agent provides the supported I2RS\n      services from\
    \ the local system's routing subsystems by interacting\n      with the routing\
    \ element to provide specified behavior.  The I2RS\n      agent understands the\
    \ I2RS protocol and can be contacted by I2RS\n      clients.\n   client or I2RS\
    \ client:   A client implements the I2RS protocol, uses\n      it to communicate\
    \ with I2RS agents, and uses the I2RS services to\n      accomplish a task.  It\
    \ interacts with other elements of the\n      policy, provisioning, and configuration\
    \ system by means outside of\n      the scope of the I2RS effort.  It interacts\
    \ with the I2RS agents\n      to collect information from the routing and forwarding\
    \ system.\n      Based on the information and the policy-oriented interactions,\
    \ the\n      I2RS client may also interact with I2RS agents to modify the state\n\
    \      of their associated routing systems to achieve operational goals.\n   \
    \   An I2RS client can be seen as the part of an application that uses\n     \
    \ and supports I2RS and could be a software library.\n   service or I2RS service:\
    \   For the purposes of I2RS, a service refers\n      to a set of related state\
    \ access functions together with the\n      policies that control their usage.\
    \  The expectation is that a\n      service will be represented by a data model.\
    \  For instance, 'RIB\n      service' could be an example of a service that gives\
    \ access to\n      state held in a device's RIB.\n   read scope:   The read scope\
    \ of an I2RS client within an I2RS agent\n      is the set of information that\
    \ the I2RS client is authorized to\n      read within the I2RS agent.  The read\
    \ scope specifies the access\n      restrictions to both see the existence of\
    \ data and read the value\n      of that data.\n   notification scope:   The notification\
    \ scope is the set of events and\n      associated information that the I2RS client\
    \ can request be pushed\n      by the I2RS agent.  I2RS clients have the ability\
    \ to register for\n      specific events and information streams, but must be\
    \ constrained\n      by the access restrictions associated with their notification\n\
    \      scope.\n   write scope:   The write scope is the set of field values that\
    \ the\n      I2RS client is authorized to write (i.e., add, modify or delete).\n\
    \      This access can restrict what data can be modified or created, and\n  \
    \    what specific value sets and ranges can be installed.\n   scope:   When unspecified\
    \ as either read scope, write scope, or\n      notification scope, the term \"\
    scope\" applies to the read scope,\n      write scope, and notification scope.\n\
    \   resources:   A resource is an I2RS-specific use of memory, storage,\n    \
    \  or execution that a client may consume due to its I2RS operations.\n      The\
    \ amount of each such resource that a client may consume in the\n      context\
    \ of a particular agent may be constrained based upon the\n      client's security\
    \ role.  An example of such a resource could\n      include the number of notifications\
    \ registered for.  These are not\n      protocol-specific resources or network-specific\
    \ resources.\n   role or security role:   A security role specifies the scope,\n\
    \      resources, priorities, etc., that a client or agent has.  If an\n     \
    \ identity has multiple roles in the security system, the identity\n      is permitted\
    \ to perform any operations any of those roles permit.\n      Multiple identities\
    \ may use the same security role.\n   identity:   A client is associated with\
    \ exactly one specific\n      identity.  State can be attributed to a particular\
    \ identity.  It\n      is possible for multiple communication channels to use\
    \ the same\n      identity; in that case, the assumption is that the associated\n\
    \      client is coordinating such communication.\n   identity and scope:   A\
    \ single identity can be associated with\n      multiple roles.  Each role has\
    \ its own scope, and an identity\n      associated with multiple roles can use\
    \ the combined scope of all\n      its roles.  More formally, each identity has:\n\
    \      *  a read scope that is the logical OR of the read scopes\n         associated\
    \ with its roles,\n      *  a write scope that is the logical OR of the write\
    \ scopes\n         associated with its roles, and\n      *  a notification scope\
    \ that is the logical OR of the notification\n         scopes associated with\
    \ its roles.\n   secondary identity:   An I2RS client may supply a secondary opaque\n\
    \      identifier for a secondary identity that is not interpreted by the\n  \
    \    I2RS agent.  An example of the use of the secondary opaque\n      identifier\
    \ is when the I2RS client is a go-between for multiple\n      applications and\
    \ it is necessary to track which application has\n      requested a particular\
    \ operation.\n   ephemeral data:   Ephemeral data is data that does not persist\
    \ across\n      a reboot (software or hardware) or a power on/off condition.\n\
    \      Ephemeral data can be configured data or data recorded from\n      operations\
    \ of the router.  Ephemeral configuration data also has\n      the property that\
    \ a system cannot roll back to a previous\n      ephemeral configuration state.\n\
    \   group:   The NETCONF Access Control Model [RFC6536] uses the term\n      \"\
    group\" in terms of an administrative group that supports the\n      well-established\
    \ distinction between a root account and other\n      types of less-privileged\
    \ conceptual user accounts.  \"Group\" still\n      refers to a single identity\
    \ (e.g., root) that is shared by a group\n      of users.\n   routing system/subsystem:\
    \   A routing system or subsystem is a set of\n      software and/or hardware\
    \ that determines where packets are\n      forwarded.  The I2RS agent is a component\
    \ of a routing system.\n      The term \"packets\" may be qualified to be layer\
    \ 1 frames, layer 2\n      frames, or layer 3 packets.  The phrase \"Internet\
    \ routing system\"\n      implies the packets that have IP as layer 3.  A routing\n\
    \      \"subsystem\" indicates that the routing software/hardware is only\n  \
    \    the subsystem of another larger system.\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\"\
    , \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted\
    \ as described in [RFC2119].\n"
- title: 3.  Key Architectural Properties
  contents:
  - "3.  Key Architectural Properties\n   Several key architectural properties for\
    \ the I2RS protocol are\n   elucidated below (simplicity, extensibility, and model-driven\n\
    \   programmatic interfaces).  However, some architectural properties\n   such\
    \ as performance and scaling are not described below because they\n   are discussed\
    \ in [RFC7920] and because they may vary based on the\n   particular use cases.\n"
- title: 3.1.  Simplicity
  contents:
  - "3.1.  Simplicity\n   There have been many efforts over the years to improve access\
    \ to the\n   information available to the routing and forwarding system.  Making\n\
    \   such information visible and usable to network management and\n   applications\
    \ has many well-understood benefits.  There are two\n   related challenges in\
    \ doing so.  First, the quantity and diversity of\n   information potentially\
    \ available is very large.  Second, the\n   variation both in the structure of\
    \ the data and in the kinds of\n   operations required tends to introduce protocol\
    \ complexity.\n   While the types of operations contemplated here are complex\
    \ in their\n   nature, it is critical that I2RS be easily deployable and robust.\n\
    \   Adding complexity beyond what is needed to satisfy well known and\n   understood\
    \ requirements would hinder the ease of implementation, the\n   robustness of\
    \ the protocol, and the deployability of the protocol.\n   Overly complex data\
    \ models tend to ossify information sets by\n   attempting to describe and close\
    \ off every possible option,\n   complicating extensibility.\n   Thus, one of\
    \ the key aims for I2RS is to keep the protocol and\n   modeling architecture\
    \ simple.  So for each architectural component or\n   aspect, we ask ourselves,\
    \ \"Do we need this complexity, or is the\n   behavior merely nice to have?\"\
    \  If we need the complexity, we should\n   ask ourselves, \"Is this the simplest\
    \ way to provide this complexity\n   in the I2RS external interface?\"\n"
- title: 3.2.  Extensibility
  contents:
  - "3.2.  Extensibility\n   Extensibility of the protocol and data model is very\
    \ important.  In\n   particular, given the necessary scope limitations of the\
    \ initial\n   work, it is critical that the initial design include strong support\n\
    \   for extensibility.\n   The scope of I2RS work is being designed in phases\
    \ to provide\n   deliverable and deployable results at every phase.  Each phase\
    \ will\n   have a specific set of requirements, and the I2RS protocol and data\n\
    \   models will progress toward these requirements.  Therefore, it is\n   clearly\
    \ desirable for the I2RS data models to be easily and highly\n   extensible to\
    \ represent additional aspects of the network elements or\n   network systems.\
    \  It should be easy to integrate data models from\n   I2RS with other data. \
    \ This reinforces the criticality of designing\n   the data models to be highly\
    \ extensible, preferably in a regular and\n   simple fashion.\n   The I2RS Working\
    \ Group is defining operations for the I2RS protocol.\n   It would be optimistic\
    \ to assume that more and different ones may not\n   be needed when the scope\
    \ of I2RS increases.  Thus, it is important to\n   consider extensibility not\
    \ only of the underlying services' data\n   models, but also of the primitives\
    \ and protocol operations.\n"
- title: 3.3.  Model-Driven Programmatic Interfaces
  contents:
  - "3.3.  Model-Driven Programmatic Interfaces\n   A critical component of I2RS is\
    \ the standard information and data\n   models with their associated semantics.\
    \  While many components of the\n   routing system are standardized, associated\
    \ data models for them are\n   not yet available.  Instead, each router uses different\
    \ information,\n   different mechanisms, and different CLI, which makes a standard\n\
    \   interface for use by applications extremely cumbersome to develop and\n  \
    \ maintain.  Well-known data modeling languages exist and may be used\n   for\
    \ defining the data models for I2RS.\n   There are several key benefits for I2RS\
    \ in using model-driven\n   architecture and protocol(s).  First, it allows for\
    \ data-model-\n   focused processing of management data that provides modular\n\
    \   implementation in I2RS clients and I2RS agents.  The I2RS client only\n  \
    \ needs to implement the models the I2RS client is able to access.  The\n   I2RS\
    \ agent only needs to implement the data models the I2RS agent\n   supports.\n\
    \   Second, tools can automate checking and manipulating data; this is\n   particularly\
    \ valuable for both extensibility and for the ability to\n   easily manipulate\
    \ and check proprietary data models.\n   The different services provided by I2RS\
    \ can correspond to separate\n   data models.  An I2RS agent may indicate which\
    \ data models are\n   supported.\n   The purpose of the data model is to provide\
    \ a definition of the\n   information regarding the routing system that can be\
    \ used in\n   operational networks.  If routing information is being modeled for\n\
    \   the first time, a logical information model may be standardized prior\n  \
    \ to creating the data model.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   This I2RS architecture describes interfaces that\
    \ clearly require\n   serious consideration of security.  As an architecture,\
    \ I2RS has been\n   designed to reuse existing protocols that carry network management\n\
    \   information.  Two of the existing protocols that are being reused for\n  \
    \ the I2RS protocol version 1 are NETCONF [RFC6241] and RESTCONF\n   [RESTCONF].\
    \  Additional protocols may be reused in future versions of\n   the I2RS protocol.\n\
    \   The I2RS protocol design process will be to specify additional\n   requirements\
    \ (including security) for the existing protocols in order\n   in order to support\
    \ the I2RS architecture.  After an existing\n   protocol (e.g., NETCONF or RESTCONF)\
    \ has been altered to fit the I2RS\n   requirements, then it will be reviewed\
    \ to determine if it meets these\n   requirements.  During this review of changes\
    \ to existing protocols to\n   serve the I2RS architecture, an in-depth security\
    \ review of the\n   revised protocol should be done.\n   Due to the reuse strategy\
    \ of the I2RS architecture, this security\n   section describes the assumed security\
    \ environment for I2RS with\n   additional details on a) identity and authentication,\
    \ b)\n   authorization, and c) client redundancy.  Each protocol proposed for\n\
    \   inclusion as an I2RS protocol will need to be evaluated for the\n   security\
    \ constraints of the protocol.  The detailed requirements for\n   the I2RS protocol\
    \ and the I2RS security environment will be defined\n   within these global security\
    \ environments.\n   The I2RS protocol security requirements for I2RS protocol\
    \ version 1\n   are contained in [I2RS-PROT-SEC], and the global I2RS security\n\
    \   environment requirements are contained [I2RS-ENV-SEC].\n   First, here is\
    \ a brief description of the assumed security\n   environment for I2RS.  The I2RS\
    \ agent associated with a Routing\n   Element is a trusted part of that Routing\
    \ Element.  For example, it\n   may be part of a vendor-distributed signed software\
    \ image for the\n   entire Routing Element, or it may be a trusted signed application\n\
    \   that an operator has installed.  The I2RS agent is assumed to have a\n   separate\
    \ authentication and authorization channel by which it can\n   validate both the\
    \ identity and permissions associated with an I2RS\n   client.  To support numerous\
    \ and speedy interactions between the I2RS\n   agent and I2RS client, it is assumed\
    \ that the I2RS agent can also\n   cache that particular I2RS clients are trusted\
    \ and their associated\n   authorized scope.  This implies that the permission\
    \ information may\n   be old either in a pull model until the I2RS agent re-requests\
    \ it or\n   in a push model until the authentication and authorization channel\n\
    \   can notify the I2RS agent of changes.\n   Mutual authentication between the\
    \ I2RS client and I2RS agent is\n   required.  An I2RS client must be able to\
    \ trust that the I2RS agent\n   is attached to the relevant Routing Element so\
    \ that write/modify\n   operations are correctly applied and so that information\
    \ received\n   from the I2RS agent can be trusted by the I2RS client.\n   An I2RS\
    \ client is not automatically trustworthy.  Each I2RS client is\n   associated\
    \ with an identity with a set of scope limitations.\n   Applications using an\
    \ I2RS client should be aware that the scope\n   limitations of an I2RS client\
    \ are based on its identity (see\n   Section 4.1) and the assigned role that the\
    \ identity has.  A role\n   sets specific authorization limits on the actions\
    \ that an I2RS client\n   can successfully request of an I2RS agent (see Section\
    \ 4.2).  For\n   example, one I2RS client may only be able to read a static route\n\
    \   table, but another client may be able add an ephemeral route to the\n   static\
    \ route table.\n   If the I2RS client is acting as a broker for multiple applications,\n\
    \   then managing the security, authentication, and authorization for\n   that\
    \ communication is out of scope; nothing prevents the broker from\n   using the\
    \ I2RS protocol and a separate authentication and\n   authorization channel from\
    \ being used.  Regardless of the mechanism,\n   an I2RS client that is acting\
    \ as a broker is responsible for\n   determining that applications using it are\
    \ trusted and permitted to\n   make the particular requests.\n   Different levels\
    \ of integrity, confidentiality, and replay protection\n   are relevant for different\
    \ aspects of I2RS.  The primary\n   communication channel that is used for client\
    \ authentication and then\n   used by the client to write data requires integrity,\
    \ confidentiality\n   and replay protection.  Appropriate selection of a default\
    \ required\n   transport protocol is the preferred way of meeting these\n   requirements.\n\
    \   Other communications via I2RS may not require integrity,\n   confidentiality,\
    \ and replay protection.  For instance, if an I2RS\n   client subscribes to an\
    \ information stream of prefix announcements\n   from OSPF, those may require\
    \ integrity but probably not\n   confidentiality or replay protection.  Similarly,\
    \ an information\n   stream of interface statistics may not even require guaranteed\n\
    \   delivery.  In Section 7.2, additional logins regarding multiple\n   communication\
    \ channels and their use is provided.  From the security\n   perspective, it is\
    \ critical to realize that an I2RS agent may open a\n   new communication channel\
    \ based upon information provided by an I2RS\n   client (as described in Section\
    \ 7.2).  For example, an I2RS client\n   may request notifications of certain\
    \ events, and the agent will open\n   a communication channel to report such events.\
    \  Therefore, to avoid\n   an indirect attack, such a request must be done in\
    \ the context of an\n   authenticated and authorized client whose communications\
    \ cannot have\n   been altered.\n"
- title: 4.1.  Identity and Authentication
  contents:
  - "4.1.  Identity and Authentication\n   As discussed above, all control exchanges\
    \ between the I2RS client and\n   agent should be authenticated and integrity-protected\
    \ (such that the\n   contents cannot be changed without detection).  Further,\
    \ manipulation\n   of the system must be accurately attributable.  In an ideal\n\
    \   architecture, even information collection and notification should be\n   protected;\
    \ this may be subject to engineering trade-offs during the\n   design.\n   I2RS\
    \ clients may be operating on behalf of other applications.  While\n   those applications'\
    \ identities are not needed for authentication or\n   authorization, each application\
    \ should have a unique opaque\n   identifier that can be provided by the I2RS\
    \ client to the I2RS agent\n   for purposes of tracking attribution of operations\
    \ to an application\n   identifier (and from that to the application's identity).\
    \  This\n   tracking of operations to an application supports I2RS functionality\n\
    \   for tracing actions (to aid troubleshooting in routers) and logging\n   of\
    \ network changes.\n"
- title: 4.2.  Authorization
  contents:
  - "4.2.  Authorization\n   All operations using I2RS, both observation and manipulation,\
    \ should\n   be subject to appropriate authorization controls.  Such authorization\n\
    \   is based on the identity and assigned role of the I2RS client\n   performing\
    \ the operations and the I2RS agent in the network element.\n   Multiple identities\
    \ may use the same role(s).  As noted in the\n   definitions of \"identity\" and\
    \ \"role\" above, if multiple roles are\n   associated with an identity then the\
    \ identity is authorized to\n   perform any operation authorized by any of its\
    \ roles.\n   I2RS agents, in performing information collection and manipulation,\n\
    \   will be acting on behalf of the I2RS clients.  As such, each\n   operation\
    \ authorization will be based on the lower of the two\n   permissions of the agent\
    \ itself and of the authenticated client.  The\n   mechanism by which this authorization\
    \ is applied within the device is\n   outside of the scope of I2RS.\n   The appropriate\
    \ or necessary level of granularity for scope can\n   depend upon the particular\
    \ I2RS service and the implementation's\n   granularity.  An approach to a similar\
    \ access control problem is\n   defined in the NETCONF Access Control Model (NACM)\
    \ [RFC6536]; it\n   allows arbitrary access to be specified for a data node instance\n\
    \   identifier while defining meaningful manipulable defaults.  The\n   identity\
    \ within NACM [RFC6536] can be specified as either a user name\n   or a group\
    \ user name (e.g., Root), and this name is linked a scope\n   policy that is contained\
    \ in a set of access control rules.\n   Similarly, it is expected the I2RS identity\
    \ links to one role that\n   has a scope policy specified by a set of access control\
    \ rules.  This\n   scope policy can be provided via Local Configuration, exposed\
    \ as an\n   I2RS service for manipulation by authorized clients, or via some\n\
    \   other method (e.g., Authentication, Authorization, and Accounting\n   (AAA)\
    \ service)\n   While the I2RS agent allows access based on the I2RS client's scope\n\
    \   policy, this does not mean the access is required to arrive on a\n   particular\
    \ transport connection or from a particular I2RS client by\n   the I2RS architecture.\
    \  The operator-applied scope policy may or may\n   not restrict the transport\
    \ connection or the identities that can\n   access a local I2RS agent.\n   When\
    \ an I2RS client is authenticated, its identity is provided to the\n   I2RS agent,\
    \ and this identity links to a role that links to the scope\n   policy.  Multiple\
    \ identities may belong to the same role; for\n   example, such a role might be\
    \ an Internal-Routes-Monitor that allows\n   reading of the portion of the I2RS\
    \ RIB associated with IP prefixes\n   used for internal device addresses in the\
    \ AS.\n"
- title: 4.3.  Client Redundancy
  contents:
  - "4.3.  Client Redundancy\n   I2RS must support client redundancy.  At the simplest,\
    \ this can be\n   handled by having a primary and a backup network application\
    \ that\n   both use the same client identity and can successfully authenticate\n\
    \   as such.  Since I2RS does not require a continuous transport\n   connection\
    \ and supports multiple transport sessions, this can provide\n   some basic redundancy.\
    \  However, it does not address the need for\n   troubleshooting and logging of\
    \ network changes to be informed about\n   which network application is actually\
    \ active.  At a minimum, basic\n   transport information about each connection\
    \ and time can be logged\n   with the identity.\n"
- title: 4.4.  I2RS in Personal Devices
  contents:
  - "4.4.  I2RS in Personal Devices\n   If an I2RS agent or I2RS client is tightly\
    \ correlated with a person\n   (such as if an I2RS agent is running on someone's\
    \ phone to control\n   tethering), then this usage can raise privacy issues, over\
    \ and above\n   the security issues that normally need to be handled in I2RS.\
    \  One\n   example of an I2RS interaction that could raise privacy issues is if\n\
    \   the I2RS interaction enabled easier location tracking of a person's\n   phone.\
    \  The I2RS protocol and data models should consider if privacy\n   issues can\
    \ arise when clients or agents are used for such use cases.\n"
- title: 5.  Network Applications and I2RS Client
  contents:
  - "5.  Network Applications and I2RS Client\n   I2RS is expected to be used by network-oriented\
    \ applications in\n   different architectures.  While the interface between a\
    \ network-\n   oriented application and the I2RS client is outside the scope of\n\
    \   I2RS, considering the different architectures is important to\n   sufficiently\
    \ specify I2RS.\n   In the simplest architecture of direct access, a network-oriented\n\
    \   application has an I2RS client as a library or driver for\n   communication\
    \ with routing elements.\n   In the broker architecture, multiple network-oriented\
    \ applications\n   communicate in an unspecified fashion to a broker application\
    \ that\n   contains an I2RS client.  That broker application requires additional\n\
    \   functionality for authentication and authorization of the network-\n   oriented\
    \ applications; such functionality is out of scope for I2RS,\n   but similar considerations\
    \ to those described in Section 4.2 do\n   apply.  As discussed in Section 4.1,\
    \ the broker I2RS client should\n   determine distinct opaque identifiers for\
    \ each network-oriented\n   application that is using it.  The broker I2RS client\
    \ can pass along\n   the appropriate value as a secondary identifier, which can\
    \ be used\n   for tracking attribution of operations.\n   In a third architecture,\
    \ a routing element or network-oriented\n   application that uses an I2RS client\
    \ to access services on a\n   different routing element may also contain an I2RS\
    \ agent to provide\n   services to other network-oriented applications.  However,\
    \ where the\n   needed information and data models for those services differs\
    \ from\n   that of a conventional routing element, those models are, at least\n\
    \   initially, out of scope for I2RS.  The following section describes an\n  \
    \ example of such a network application.\n"
- title: '5.1.  Example Network Application: Topology Manager'
  contents:
  - "5.1.  Example Network Application: Topology Manager\n   A Topology Manager includes\
    \ an I2RS client that uses the I2RS data\n   models and protocol to collect information\
    \ about the state of the\n   network by communicating directly with one or more\
    \ I2RS agents.  From\n   these I2RS agents, the Topology Manager collects routing\n\
    \   configuration and operational data, such as interface and Label\n   Switched\
    \ Path (LSP) information.  In addition, the Topology Manager\n   may collect link-state\
    \ data in several ways -- via I2RS models, by\n   peering with BGP-LS [RFC7752],\
    \ or by listening into the IGP.\n   The set of functionality and collected information\
    \ that is the\n   Topology Manager may be embedded as a component of a larger\n\
    \   application, such as a path computation application.  As a stand-\n   alone\
    \ application, the Topology Manager could be useful to other\n   network applications\
    \ by providing a coherent picture of the network\n   state accessible via another\
    \ interface.  That interface might use the\n   same I2RS protocol and could provide\
    \ a topology service using\n   extensions to the I2RS data models.\n"
- title: 6.  I2RS Agent Role and Functionality
  contents:
  - "6.  I2RS Agent Role and Functionality\n   The I2RS agent is part of a routing\
    \ element.  As such, it has\n   relationships with that routing element as a whole\
    \ and with various\n   components of that routing element.\n"
- title: 6.1.  Relationship to Its Routing Element
  contents:
  - "6.1.  Relationship to Its Routing Element\n   A Routing Element may be implemented\
    \ with a wide variety of different\n   architectures: an integrated router, a\
    \ split architecture,\n   distributed architecture, etc.  The architecture does\
    \ not need to\n   affect the general I2RS agent behavior.\n   For scalability\
    \ and generality, the I2RS agent may be responsible for\n   collecting and delivering\
    \ large amounts of data from various parts of\n   the routing element.  Those\
    \ parts may or may not actually be part of\n   a single physical device.  Thus,\
    \ for scalability and robustness, it\n   is important that the architecture allow\
    \ for a distributed set of\n   reporting components providing collected data from\
    \ the I2RS agent\n   back to the relevant I2RS clients.  There may be multiple\
    \ I2RS agents\n   within the same router.  In such a case, they must have non-\n\
    \   overlapping sets of information that they manipulate.\n   To facilitate operations,\
    \ deployment, and troubleshooting, it is\n   important that traceability of the\
    \ requests received by I2RS agent's\n   and actions taken be supported via a common\
    \ data model.\n"
- title: 6.2.  I2RS State Storage
  contents:
  - "6.2.  I2RS State Storage\n   State modification requests are sent to the I2RS\
    \ agent in a routing\n   element by I2RS clients.  The I2RS agent is responsible\
    \ for applying\n   these changes to the system, subject to the authorization discussed\n\
    \   above.  The I2RS agent will retain knowledge of the changes it has\n   applied,\
    \ and the client on whose behalf it applied the changes.  The\n   I2RS agent will\
    \ also store active subscriptions.  These sets of data\n   form the I2RS datastore.\
    \  This data is retained by the agent until\n   the state is removed by the client,\
    \ it is overridden by some other\n   operation such as CLI, or the device reboots.\
    \  Meaningful logging of\n   the application and removal of changes are recommended.\
    \  I2RS-applied\n   changes to the routing element state will not be retained\
    \ across\n   routing element reboot.  The I2RS datastore is not preserved across\n\
    \   routing element reboots; thus, the I2RS agent will not attempt to\n   reapply\
    \ such changes after a reboot.\n"
- title: 6.2.1.  I2RS Agent Failure
  contents:
  - "6.2.1.  I2RS Agent Failure\n   It is expected that an I2RS agent may fail independently\
    \ of the\n   associated routing element.  This could happen because I2RS is\n\
    \   disabled on the routing element or because the I2RS agent, which may\n   be\
    \ a separate process or even running on a separate processor,\n   experiences\
    \ an unexpected failure.  Just as routing state learned\n   from a failed source\
    \ is removed, the ephemeral I2RS state will\n   usually be removed shortly after\
    \ the failure is detected or as part\n   of a graceful shutdown process.  To handle\
    \ these two types of\n   failures, the I2RS agent MUST support two different notifications:\
    \ a\n   notification for the I2RS agent terminating gracefully, and a\n   notification\
    \ for the I2RS agent starting up after an unexpected\n   failure.  The two notifications\
    \ are described below followed by a\n   description of their use in unexpected\
    \ failures and graceful\n   shutdowns.\n   NOTIFICATION_I2RS_AGENT_TERMINATING:\
    \   This notification reports that\n      the associated I2RS agent is shutting\
    \ down gracefully and that\n      I2RS ephemeral state will be removed.  It can\
    \ optionally include a\n      timestamp indicating when the I2RS agent will shut\
    \ down.  Use of\n      this timestamp assumes that time synchronization has been\
    \ done,\n      and the timestamp should not have granularity finer than one\n\
    \      second because better accuracy of shutdown time is not guaranteed.\n  \
    \ NOTIFICATION_I2RS_AGENT_STARTING:   This notification signals to the\n     \
    \ I2RS client(s) that the associated I2RS agent has started.  It\n      includes\
    \ an agent-boot-count that indicates how many times the\n      I2RS agent has\
    \ restarted since the associated routing element\n      restarted.  The agent-boot-count\
    \ allows an I2RS client to\n      determine if the I2RS agent has restarted. \
    \ (Note: This\n      notification will be sent by the I2RS agent to I2RS clients\
    \ that\n      are known by the I2RS agent after a reboot.  How the I2RS agent\n\
    \      retains the knowledge of these I2RS clients is out of scope of\n      this\
    \ architecture.)\n   There are two different failure types that are possible,\
    \ and each has\n   different behavior.\n   Unexpected failure:   In this case,\
    \ the I2RS agent has unexpectedly\n      crashed and thus cannot notify its clients\
    \ of anything.  Since\n      I2RS does not require a persistent connection between\
    \ the I2RS\n      client and I2RS agent, it is necessary to have a mechanism for\
    \ the\n      I2RS agent to notify I2RS clients that had subscriptions or\n   \
    \   written ephemeral state; such I2RS clients should be cached by the\n     \
    \ I2RS agent's system in persistent storage.  When the I2RS agent\n      starts,\
    \ it should send a NOTIFICATION_I2RS_AGENT_STARTING to each\n      cached I2RS\
    \ client.\n   Graceful shutdowns:   In this case, the I2RS agent can do specific\n\
    \      limited work as part of the process of being disabled.  The I2RS\n    \
    \  agent must send a NOTIFICATION_I2RS_AGENT_TERMINATING to all its\n      cached\
    \ I2RS clients.  If the I2RS agent restarts after a graceful\n      termination,\
    \ it will send a NOTIFICATION_I2RS_AGENT_STARTING to\n      each cached I2RS client.\n"
- title: 6.2.2.  Starting and Ending
  contents:
  - "6.2.2.  Starting and Ending\n   When an I2RS client applies changes via the I2RS\
    \ protocol, those\n   changes are applied and left until removed or the routing\
    \ element\n   reboots.  The network application may make decisions about what\
    \ to\n   request via I2RS based upon a variety of conditions that imply\n   different\
    \ start times and stop times.  That complexity is managed by\n   the network application\
    \ and is not handled by I2RS.\n"
- title: 6.2.3.  Reversion
  contents:
  - "6.2.3.  Reversion\n   An I2RS agent may decide that some state should no longer\
    \ be applied.\n   An I2RS client may instruct an agent to remove state it has\
    \ applied.\n   In all such cases, the state will revert to what it would have\
    \ been\n   without the I2RS client-agent interaction; that state is generally\n\
    \   whatever was specified via the CLI, NETCONF, SNMP, etc., I2RS agents\n   will\
    \ not store multiple alternative states, nor try to determine\n   which one among\
    \ such a plurality it should fall back to.  Thus, the\n   model followed is not\
    \ like the RIB, where multiple routes are stored\n   at different preferences.\
    \  (For I2RS state in the presence of two\n   I2RS clients, please see Sections\
    \ 1.2 and 7.8)\n   An I2RS client may register for notifications, subject to its\n\
    \   notification scope, regarding state modification or removal by a\n   particular\
    \ I2RS client.\n"
- title: 6.3.  Interactions with Local Configuration
  contents:
  - "6.3.  Interactions with Local Configuration\n   Changes may originate from either\
    \ Local Configuration or from I2RS.\n   The modifications and data stored by I2RS\
    \ are separate from the local\n   device configuration, but conflicts between\
    \ the two must be resolved\n   in a deterministic manner that respects operator-applied\
    \ policy.  The\n   deterministic manner is the result of general I2RS rules, system\n\
    \   rules, knobs adjusted by operator-applied policy, and the rules\n   associated\
    \ with the YANG data model (often in \"MUST\" and \"WHEN\"\n   clauses for dependencies).\n\
    \   The operator-applied policy knobs can determine whether the Local\n   Configuration\
    \ overrides a particular I2RS client's request or vice\n   versa.  Normally, most\
    \ devices will have an operator-applied policy\n   that will prioritize the I2RS\
    \ client's ephemeral configuration\n   changes so that ephemeral data overrides\
    \ the Local Configuration.\n   These operator-applied policy knobs can be implemented\
    \ in many ways.\n   One way is for the routing element to configure a priority\
    \ on the\n   Local Configuration and a priority on the I2RS client's write of\
    \ the\n   ephemeral configuration.  The I2RS mechanism would compare the I2RS\n\
    \   client's priority to write with that priority assigned to the Local\n   Configuration\
    \ in order to determine whether Local Configuration or\n   I2RS client's write\
    \ of ephemeral data wins.\n   To make sure the I2RS client's requests are what\
    \ the operator\n   desires, the I2RS data modules have a general rule that, by\
    \ default,\n   the Local Configuration always wins over the I2RS ephemeral\n \
    \  configuration.\n   The reason for this general rule is if there is no operator-applied\n\
    \   policy to turn on I2RS ephemeral overwrites of Local Configuration,\n   then\
    \ the I2RS overwrites should not occur.  This general rule allows\n   the I2RS\
    \ agents to be installed in routing systems and the\n   communication tested between\
    \ I2RS clients and I2RS agents without the\n   I2RS agent overwriting configuration\
    \ state.  For more details, see\n   the examples below.\n   In the case when the\
    \ I2RS ephemeral state always wins for a data\n   model, if there is an I2RS ephemeral\
    \ state value, it is installed\n   instead of the Local Configuration state value.\
    \  The Local\n   Configuration information is stored so that if/when an I2RS client\n\
    \   removes I2RS ephemeral state, the Local Configuration state can be\n   restored.\n\
    \   When the Local Configuration always wins, some communication between\n   that\
    \ subsystem and the I2RS agent is still necessary.  As an I2RS\n   agent connects\
    \ to the routing subsystem, the I2RS agent must also\n   communicate with the\
    \ Local Configuration to exchange model\n   information so the I2RS agent knows\
    \ the details of each specific\n   device configuration change that the I2RS agent\
    \ is permitted to\n   modify.  In addition, when the system determines that a\
    \ client's I2RS\n   state is preempted, the I2RS agent must notify the affected\
    \ I2RS\n   clients; how the system determines this is implementation dependent.\n\
    \   It is critical that policy based upon the source is used because the\n   resolution\
    \ cannot be time based.  Simply allowing the most recent\n   state to prevail\
    \ could cause race conditions where the final state is\n   not repeatably deterministic.\n"
- title: 6.3.1.  Examples of Local Configuration vs. I2RS Ephemeral Configuration
  contents:
  - "6.3.1.  Examples of Local Configuration vs. I2RS Ephemeral Configuration\n  \
    \ A set of examples is useful in order to illustrated these\n   architecture principles.\
    \  Assume there are three routers: Router A,\n   Router B, and Router C.  There\
    \ are two operator-applied policy knobs\n   that these three routers must have\
    \ regarding ephemeral state.\n   o  Policy Knob 1: Ephemeral configuration overwrites\
    \ Local\n      Configuration.\n   o  Policy Knob 2: Update of Local Configuration\
    \ value supersedes and\n      overwrites the ephemeral configuration.\n   For\
    \ Policy Knob 1, the routers with an I2RS agent receiving a write\n   for an ephemeral\
    \ entry in a data model must consider the following:\n   1.  Does the operator\
    \ policy allow the ephemeral configuration\n       changes to have priority over\
    \ existing Local Configuration?\n   2.  Does the YANG data model have any rules\
    \ associated with the\n       ephemeral configuration (such as the \"MUST\" or\
    \ \"WHEN\" rule)?\n   For this example, there is no \"MUST\" or \"WHEN\" rule\
    \ in the data being\n   written.\n   The policy settings are:\n              \
    \ Policy Knob 1           Policy Knob 2\n               ===================  \
    \   ==================\n   Router A    ephemeral has           ephemeral has\n\
    \               priority                priority\n   Router B    Local Configuration\
    \     Local Configuration\n               has priority            has priority\n\
    \   Router C    ephemeral has           Local Configuration\n               priority\
    \                has priority\n   Router A has the normal operator policy in Policy\
    \ Knob 1 and Policy\n   Knob 2 that prioritizes ephemeral configuration over Local\n\
    \   Configuration in the I2RS agent.  An I2RS client sends a write to an\n   ephemeral\
    \ configuration value via an I2RS agent in Router A.  The\n   I2RS agent overwrites\
    \ the configuration value in the intended\n   configuration, and the I2RS agent\
    \ returns an acknowledgement of the\n   write.  If the Local Configuration value\
    \ changes, Router A stays with\n   the ephemeral configuration written by the\
    \ I2RS client.\n   Router B's operator has no desire to allow ephemeral writes\
    \ to\n   overwrite Local Configuration even though it has installed an I2RS\n\
    \   agent.  Router B's policy prioritizes the Local Configuration over\n   the\
    \ ephemeral write.  When the I2RS agent on Router B receives a\n   write from\
    \ an I2RS client, the I2RS agent will check the operator\n   Policy Knob 1 and\
    \ return a response to the I2RS client indicating the\n   operator policy did\
    \ not allow the overwriting of the Local\n   Configuration.\n   The Router B case\
    \ demonstrates why the I2RS architecture sets the\n   default to the Local Configuration\
    \ wins.  Since I2RS functionality is\n   new, the operator must enable it.  Otherwise,\
    \ the I2RS ephemeral\n   functionality is off.  Router B's operators can install\
    \ the I2RS code\n   and test responses without engaging the I2RS overwrite function.\n\
    \   Router C's operator sets Policy Knob 1 for the I2RS clients to\n   overwrite\
    \ existing Local Configuration and Policy Knob 2 for the\n   Local Configuration\
    \ changes to update ephemeral state.  To understand\n   why an operator might\
    \ set the policy knobs this way, consider that\n   Router C is under the control\
    \ of an operator that has a back-end\n   system that re-writes the Local Configuration\
    \ of all systems at 11\n   p.m. each night.  Any ephemeral change to the network\
    \ is only\n   supposed to last until 11 p.m. when the next Local Configuration\n\
    \   changes are rolled out from the back-end system.  The I2RS client\n   writes\
    \ the ephemeral state during the day, and the I2RS agent on\n   Router C updates\
    \ the value.  At 11 p.m., the back-end configuration\n   system updates the Local\
    \ Configuration via NETCONF, and the I2RS\n   agent is notified that the Local\
    \ Configuration updated this value.\n   The I2RS agent notifies the I2RS client\
    \ that the value has been\n   overwritten by the Local Configuration.  The I2RS\
    \ client in this use\n   case is a part of an application that tracks any ephemeral\
    \ state\n   changes to make sure all ephemeral changes are included in the next\n\
    \   configuration run.\n"
- title: 6.4.  Routing Components and Associated I2RS Services
  contents:
  - "6.4.  Routing Components and Associated I2RS Services\n   For simplicity, each\
    \ logical protocol or set of functionality that\n   can be compactly described\
    \ in a separable information and data model\n   is considered as a separate I2RS\
    \ service.  A routing element need not\n   implement all routing components described\
    \ nor provide the associated\n   I2RS services.  I2RS services should include\
    \ a capability model so\n   that peers can determine which parts of the service\
    \ are supported.\n   Each I2RS service requires an information model that describes\
    \ at\n   least the following: data that can be read, data that can be written,\n\
    \   notifications that can be subscribed to, and the capability model\n   mentioned\
    \ above.\n   The initial services included in the I2RS architecture are as\n \
    \  follows.\n    ***************************     **************    *****************\n\
    \    *      I2RS Protocol      *     *            *    *    Dynamic    *\n   \
    \ *                         *     * Interfaces *    *    Data &     *\n    * \
    \ +--------+  +-------+  *     *            *    *  Statistics   *\n    *  | Client\
    \ |  | Agent |  *     **************    *****************\n    *  +--------+ \
    \ +-------+  *\n    *                         *        **************    *************\n\
    \    ***************************        *            *    *           *\n    \
    \                                   *  Policy    *    * Base QoS  *\n    ********************\
    \    ********   *  Templates *    * Templates *\n    *       +--------+ *    *\
    \      *   *            *    *************\n    *  BGP  | BGP-LS | *    * PIM\
    \  *   **************\n    *       +--------+ *    *      *\n    ********************\
    \    ********       ****************************\n                           \
    \                * MPLS +---------+ +-----+ *\n    **********************************\
    \     *      | RSVP-TE | | LDP | *\n    *    IGPs      +------+ +------+ *   \
    \  *      +---------+ +-----+ *\n    *  +--------+  | OSPF | |IS-IS | *     *\
    \ +--------+               *\n    *  | Common |  +------+ +------+ *     * | Common\
    \ |               *\n    *  +--------+                    *     * +--------+ \
    \              *\n    **********************************     ****************************\n\
    \    **************************************************************\n    * RIB\
    \ Manager                                                *\n    *  +-------------------+\
    \  +---------------+   +------------+ *\n    *  | Unicast/multicast |  | Policy-Based\
    \  |   | RIB Policy | *\n    *  | RIBs & LIBs       |  | Routing       |   | Controls\
    \   | *\n    *  | route instances   |  | (ACLs, etc)   |   +------------+ *\n\
    \    *  +-------------------+  +---------------+                  *\n    **************************************************************\n\
    \                    Figure 2: Anticipated I2RS Services\n   There are relationships\
    \ between different I2RS services -- whether\n   those be the need for the RIB\
    \ to refer to specific interfaces, the\n   desire to refer to common complex types\
    \ (e.g., links, nodes, IP\n   addresses), or the ability to refer to implementation-specific\n\
    \   functionality (e.g., pre-defined templates to be applied to\n   interfaces\
    \ or for QoS behaviors that traffic is directed into).\n   Section 6.4.5 discusses\
    \ information modeling constructs and the range\n   of relationship types that\
    \ are applicable.\n"
- title: 6.4.1.  Routing and Label Information Bases
  contents:
  - "6.4.1.  Routing and Label Information Bases\n   Routing elements may maintain\
    \ one or more information bases.\n   Examples include Routing Information Bases\
    \ such as IPv4/IPv6 Unicast\n   or IPv4/IPv6 Multicast.  Another such example\
    \ includes the MPLS Label\n   Information Bases, per platform, per interface,\
    \ or per context.  This\n   functionality, exposed via an I2RS service, must interact\
    \ smoothly\n   with the same mechanisms that the routing element already uses\
    \ to\n   handle RIB input from multiple sources.  Conceptually, this can be\n\
    \   handled by having the I2RS agent communicate with a RIB Manager as a\n   separate\
    \ routing source.\n   The point-to-multipoint state added to the RIB does not\
    \ need to match\n   to well-known multicast protocol installed state.  The I2RS\
    \ agent can\n   create arbitrary replication state in the RIB, subject to the\n\
    \   advertised capabilities of the routing element.\n"
- title: 6.4.2.  IGPs, BGP, and Multicast Protocols
  contents:
  - "6.4.2.  IGPs, BGP, and Multicast Protocols\n   A separate I2RS service can expose\
    \ each routing protocol on the\n   device.  Such I2RS services may include a number\
    \ of different kinds\n   of operations:\n   o  reading the various internal RIB(s)\
    \ of the routing protocol is\n      often helpful for understanding the state\
    \ of the network.\n      Directly writing to these protocol-specific RIBs or databases\
    \ is\n      out of scope for I2RS.\n   o  reading the various pieces of policy\
    \ information the particular\n      protocol instance is using to drive its operations.\n\
    \   o  writing policy information such as interface attributes that are\n    \
    \  specific to the routing protocol or BGP policy that may indirectly\n      manipulate\
    \ attributes of routes carried in BGP.\n   o  writing routes or prefixes to be\
    \ advertised via the protocol.\n   o  joining/removing interfaces from the multicast\
    \ trees.\n   o  subscribing to an information stream of route changes.\n   o \
    \ receiving notifications about peers coming up or going down.\n   For example,\
    \ the interaction with OSPF might include modifying the\n   local routing element's\
    \ link metrics, announcing a locally attached\n   prefix, or reading some of the\
    \ OSPF link-state database.  However,\n   direct modification of the link-state\
    \ database must not be allowed in\n   order to preserve network state consistency.\n"
- title: 6.4.3.  MPLS
  contents:
  - "6.4.3.  MPLS\n   I2RS services will be needed to expose the protocols that create\n\
    \   transport LSPs (e.g., LDP and RSVP-TE) as well as protocols (e.g.,\n   BGP,\
    \ LDP) that provide MPLS-based services (e.g., pseudowires,\n   L3VPNs, L2VPNs,\
    \ etc).  This should include all local information\n   about LSPs originating\
    \ in, transiting, or terminating in this Routing\n   Element.\n"
- title: 6.4.4.  Policy and QoS Mechanisms
  contents:
  - "6.4.4.  Policy and QoS Mechanisms\n   Many network elements have separate policy\
    \ and QoS mechanisms,\n   including knobs that affect local path computation and\
    \ queue control\n   capabilities.  These capabilities vary widely across implementations,\n\
    \   and I2RS cannot model the full range of information collection or\n   manipulation\
    \ of these attributes.  A core set does need to be\n   included in the I2RS information\
    \ models and supported in the expected\n   interfaces between the I2RS agent and\
    \ the network element, in order\n   to provide basic capabilities and the hooks\
    \ for future extensibility.\n   By taking advantage of extensibility and subclassing,\
    \ information\n   models can specify use of a basic model that can be replaced\
    \ by a\n   more detailed model.\n"
- title: 6.4.5.  Information Modeling, Device Variation, and Information
  contents:
  - "6.4.5.  Information Modeling, Device Variation, and Information\n        Relationships\n\
    \   I2RS depends heavily on information models of the relevant aspects of\n  \
    \ the Routing Elements to be manipulated.  These models drive the data\n   models\
    \ and protocol operations for I2RS.  It is important that these\n   information\
    \ models deal well with a wide variety of actual\n   implementations of Routing\
    \ Elements, as seen between different\n   products and different vendors.  There\
    \ are three ways that I2RS\n   information models can address these variations:\
    \ class or type\n   inheritance, optional features, and templating.\n"
- title: '6.4.5.1.  Managing Variation: Object Classes/Types and Inheritance'
  contents:
  - "6.4.5.1.  Managing Variation: Object Classes/Types and Inheritance\n   Information\
    \ modeled by I2RS from a Routing Element can be described\n   in terms of classes\
    \ or types or object.  Different valid inheritance\n   definitions can apply.\
    \  What is appropriate for I2RS to use is not\n   determined in this architecture;\
    \ for simplicity, \"class\" and\n   \"subclass\" will be used as the example terminology.\
    \  This I2RS\n   architecture does require the ability to address variation in\
    \ Routing\n   Elements by allowing information models to define parent or base\n\
    \   classes and subclasses.\n   The base or parent class defines the common aspects\
    \ that all Routing\n   Elements are expected to support.  Individual subclasses\
    \ can\n   represent variations and additional capabilities.  When applicable,\n\
    \   there may be several levels of refinement.  The I2RS protocol can\n   then\
    \ provide mechanisms to allow an I2RS client to determine which\n   classes a\
    \ given I2RS agent has available.  I2RS clients that only\n   want basic capabilities\
    \ can operate purely in terms of base or parent\n   classes, while a client needing\
    \ more details or features can work\n   with the supported subclass(es).\n   As\
    \ part of I2RS information modeling, clear rules should be specified\n   for how\
    \ the parent class and subclass can relate; for example, what\n   changes can\
    \ a subclass make to its parent?  The description of such\n   rules should be\
    \ done so that it can apply across data modeling tools\n   until the I2RS data\
    \ modeling language is selected.\n"
- title: '6.4.5.2.  Managing Variation: Optionality'
  contents:
  - "6.4.5.2.  Managing Variation: Optionality\n   I2RS information models must be\
    \ clear about what aspects are\n   optional.  For instance, must an instance of\
    \ a class always contain a\n   particular data field X?  If so, must the client\
    \ provide a value for\n   X when creating the object or is there a well-defined\
    \ default value?\n   From the Routing Element perspective, in the above example,\
    \ each\n   information model should provide information regarding the following\n\
    \   questions:\n   o  Is X required for the data field to be accepted and applied?\n\
    \   o  If X is optional, then how does \"X\" as an optional portion of the\n \
    \     data field interact with the required aspects of the data field?\n   o \
    \ Does the data field have defaults for the mandatory portion of the\n      field\
    \ and the optional portions of the field?\n   o  Is X required to be within a\
    \ particular set of values (e.g.,\n      range, length of strings)?\n   The information\
    \ model needs to be clear about what read or write\n   values are set by the client\
    \ and what responses or actions are\n   required by the agent.  It is important\
    \ to indicate what is required\n   or optional in client values and agent responses/actions.\n"
- title: '6.4.5.3.  Managing Variation: Templating'
  contents:
  - "6.4.5.3.  Managing Variation: Templating\n   A template is a collection of information\
    \ to address a problem; it\n   cuts across the notions of class and object instances.\
    \  A template\n   provides a set of defined values for a set of information fields\
    \ and\n   can specify a set of values that must be provided to complete the\n\
    \   template.  Further, a flexible template scheme may allow some of the\n   defined\
    \ values to be overwritten.\n   For instance, assigning traffic to a particular\
    \ service class might\n   be done by specifying a template queueing with a parameter\
    \ to\n   indicate Gold, Silver, or Best Effort.  The details of how that is\n\
    \   carried out are not modeled.  This does assume that the necessary\n   templates\
    \ are made available on the Routing Element via some\n   mechanism other than\
    \ I2RS.  The idea is that by providing suitable\n   templates for tasks that need\
    \ to be accomplished, with templates\n   implemented differently for different\
    \ kinds of Routing Elements, the\n   client can easily interact with the Routing\
    \ Element without concern\n   for the variations that are handled by values included\
    \ in the\n   template.\n   If implementation variation can be exposed in other\
    \ ways, templates\n   may not be needed.  However, templates themselves could\
    \ be objects\n   referenced in the protocol messages, with Routing Elements being\n\
    \   configured with the proper templates to complete the operation.  This\n  \
    \ is a topic for further discussion.\n"
- title: 6.4.5.4.  Object Relationships
  contents:
  - "6.4.5.4.  Object Relationships\n   Objects (in a Routing Element or otherwise)\
    \ do not exist in\n   isolation.  They are related to each other.  One of the\
    \ important\n   things a class definition does is represent the relationships\
    \ between\n   instances of different classes.  These relationships can be very\n\
    \   simple or quite complicated.  The following sections list the\n   information\
    \ relationships that the information models need to\n   support.\n"
- title: 6.4.5.4.1.  Initialization
  contents:
  - "6.4.5.4.1.  Initialization\n   The simplest relationship is that one object instance\
    \ is initialized\n   by copying another.  For example, one may have an object\
    \ instance\n   that represents the default setup for a tunnel, and all new tunnels\n\
    \   have fields copied from there if they are not set as part of\n   establishment.\
    \  This is closely related to the templates discussed\n   above, but not identical.\
    \  Since the relationship is only momentary,\n   it is often not formally represented\
    \ in modeling but only captured in\n   the semantic description of the default\
    \ object.\n"
- title: 6.4.5.4.2.  Correlation Identification
  contents:
  - "6.4.5.4.2.  Correlation Identification\n   Often, it suffices to indicate in\
    \ one object that it is related to a\n   second object, without having a strong\
    \ binding between the two.  So\n   an identifier is used to represent the relationship.\
    \  This can be\n   used to allow for late binding or a weak binding that does\
    \ not even\n   need to exist.  A policy name in an object might indicate that\
    \ if a\n   policy by that name exists, it is to be applied under some\n   circumstance.\
    \  In modeling, this is often represented by the type of\n   the value.\n"
- title: 6.4.5.4.3.  Object References
  contents:
  - "6.4.5.4.3.  Object References\n   Sometimes the relationship between objects\
    \ is stronger.  A valid ARP\n   entry has to point to the active interface over\
    \ which it was derived.\n   This is the classic meaning of an object reference\
    \ in programming.\n   It can be used for relationships like containment or dependence.\n\
    \   This is usually represented by an explicit modeling link.\n"
- title: 6.4.5.4.4.  Active References
  contents:
  - "6.4.5.4.4.  Active References\n   There is an even stronger form of coupling\
    \ between objects if changes\n   in one of the two objects are always to be reflected\
    \ in the state of\n   the other.  For example, if a tunnel has an MTU (maximum\
    \ transmit\n   unit), and link MTU changes need to immediately propagate to the\n\
    \   tunnel MTU, then the tunnel is actively coupled to the link\n   interface.\
    \  This kind of active state coupling implies some sort of\n   internal bookkeeping\
    \ to ensure consistency, often conceptualized as a\n   subscription model across\
    \ objects.\n"
- title: 7.  I2RS Client Agent Interface
  contents:
  - '7.  I2RS Client Agent Interface

    '
- title: 7.1.  One Control and Data Exchange Protocol
  contents:
  - "7.1.  One Control and Data Exchange Protocol\n   This I2RS architecture assumes\
    \ a data-model-driven protocol where the\n   data models are defined in YANG 1.1\
    \ [YANG1.1] and associated YANG\n   based model documents [RFC6991], [RFC7223],\
    \ [RFC7224], [RFC7277],\n   [RFC7317].  Two of the protocols to be expanded to\
    \ support the I2RS\n   protocol are NETCONF [RFC6241] and RESTCONF [RESTCONF].\
    \  This helps\n   meet the goal of simplicity and thereby enhances deployability.\
    \  The\n   I2RS protocol may need to use several underlying transports (TCP,\n\
    \   SCTP (Stream Control Transport Protocol), DCCP (Datagram Congestion\n   Control\
    \ Protocol)), with suitable authentication and integrity-\n   protection mechanisms.\
    \  These different transports can support\n   different types of communication\
    \ (e.g., control, reading,\n   notifications, and information collection) and\
    \ different sets of\n   data.  Whatever transport is used for the data exchange,\
    \ it must also\n   support suitable congestion-control mechanisms.  The transports\n\
    \   chosen should be operator and implementor friendly to ease adoption.\n   Each\
    \ version of the I2RS protocol will specify the following: a)\n   which transports\
    \ may be used by the I2RS protocol, b) which\n   transports are mandatory to implement,\
    \ and c) which transports are\n   optional to implement.\n"
- title: 7.2.  Communication Channels
  contents:
  - "7.2.  Communication Channels\n   Multiple communication channels and multiple\
    \ types of communication\n   channels are required.  There may be a range of requirements\
    \ (e.g.,\n   confidentiality, reliability), and to support the scaling, there\
    \ may\n   need to be channels originating from multiple subcomponents of a\n \
    \  routing element and/or to multiple parts of an I2RS client.  All such\n   communication\
    \ channels will use the same higher-layer I2RS protocol\n   (which combines secure\
    \ transport and I2RS contextual information).\n   The use of additional channels\
    \ for communication will be coordinated\n   between the I2RS client and the I2RS\
    \ agent using this protocol.\n   I2RS protocol communication may be delivered\
    \ in-band via the routing\n   system's data plane.  I2RS protocol communication\
    \ might be delivered\n   out-of-band via a management interface.  Depending on\
    \ what operations\n   are requested, it is possible for the I2RS protocol communication\
    \ to\n   cause the in-band communication channels to stop working; this could\n\
    \   cause the I2RS agent to become unreachable across that communication\n   channel.\n"
- title: 7.3.  Capability Negotiation
  contents:
  - "7.3.  Capability Negotiation\n   The support for different protocol capabilities\
    \ and I2RS services\n   will vary across I2RS clients and Routing Elements supporting\
    \ I2RS\n   agents.  Since each I2RS service is required to include a capability\n\
    \   model (see Section 6.4), negotiation at the protocol level can be\n   restricted\
    \ to protocol specifics and which I2RS services are\n   supported.\n   Capability\
    \ negotiation (such as which transports are supported beyond\n   the minimum required\
    \ to implement) will clearly be necessary.  It is\n   important that such negotiations\
    \ be kept simple and robust, as such\n   mechanisms are often a source of difficulty\
    \ in implementation and\n   deployment.\n   The protocol capability negotiation\
    \ can be segmented into the basic\n   version negotiation (required to ensure\
    \ basic communication), and the\n   more complex capability exchange that can\
    \ take place within the base\n   protocol mechanisms.  In particular, the more\
    \ complex protocol and\n   mechanism negotiation can be addressed by defining\
    \ information models\n   for both the I2RS agent and the I2RS client.  These information\n\
    \   models can describe the various capability options.  This can then\n   represent\
    \ and be used to communicate important information about the\n   agent and the\
    \ capabilities thereof.\n"
- title: 7.4.  Scope Policy Specifications
  contents:
  - "7.4.  Scope Policy Specifications\n   As Sections 4.1 and 4.2 describe, each\
    \ I2RS client will have a unique\n   identity and may have a secondary identity\
    \ (see Section 2) to aid in\n   troubleshooting.  As Section 4 indicates, all\
    \ authentication and\n   authorization mechanisms are based on the primary identity,\
    \ which\n   links to a role with scope policy for reading data, for writing data,\n\
    \   and for limiting the resources that can be consumed.  The\n   specifications\
    \ for data scope policy (for read, write, or resources\n   consumption) need to\
    \ specify the data being controlled by the policy,\n   and acceptable ranges of\
    \ values for the data.\n"
- title: 7.5.  Connectivity
  contents:
  - "7.5.  Connectivity\n   An I2RS client may or may not maintain an active communication\n\
    \   channel with an I2RS agent.  Therefore, an I2RS agent may need to\n   open\
    \ a communication channel to the client to communicate previously\n   requested\
    \ information.  The lack of an active communication channel\n   does not imply\
    \ that the associated I2RS client is non-functional.\n   When communication is\
    \ required, the I2RS agent or I2RS client can\n   open a new communication channel.\n\
    \   State held by an I2RS agent that is owned by an I2RS client should\n   not\
    \ be removed or cleaned up when a client is no longer\n   communicating, even\
    \ if the agent cannot successfully open a new\n   communication channel to the\
    \ client.\n   For many applications, it may be desirable to clean up state if\
    \ a\n   network application dies before removing the state it has created.\n \
    \  Typically, this is dealt with in terms of network application\n   redundancy.\
    \  If stronger mechanisms are desired, mechanisms outside\n   of I2RS may allow\
    \ a supervisory network application to monitor I2RS\n   clients and, based on\
    \ policy known to the supervisor, clean up state\n   if applications die.  More\
    \ complex mechanisms instantiated in the\n   I2RS agent would add complications\
    \ to the I2RS protocol and are thus\n   left for future work.\n   Some examples\
    \ of such a mechanism include the following.  In one\n   option, the client could\
    \ request state cleanup if a particular\n   transport session is terminated. \
    \ The second is to allow state\n   expiration, expressed as a policy associated\
    \ with the I2RS client's\n   role.  The state expiration could occur after there\
    \ has been no\n   successful communication channel to or from the I2RS client\
    \ for the\n   policy-specified duration.\n"
- title: 7.6.  Notifications
  contents:
  - "7.6.  Notifications\n   As with any policy system interacting with the network,\
    \ the I2RS\n   client needs to be able to receive notifications of changes in\n\
    \   network state.  Notifications here refer to changes that are\n   unanticipated,\
    \ represent events outside the control of the systems\n   (such as interface failures\
    \ on controlled devices), or are\n   sufficiently sparse as to be anomalous in\
    \ some fashion.  A\n   notification may also be due to a regular event.\n   Such\
    \ events may be of interest to multiple I2RS clients controlling\n   data handled\
    \ by an I2RS agent and to multiple other I2RS clients that\n   are collecting\
    \ information without exerting control.  The\n   architecture therefore requires\
    \ that it be practical for I2RS clients\n   to register for a range of notifications\
    \ and for the I2RS agents to\n   send notifications to a number of clients.  The\
    \ I2RS client should be\n   able to filter the specific notifications that will\
    \ be received; the\n   specific types of events and filtering operations can vary\
    \ by\n   information model and need to be specified as part of the information\n\
    \   model.\n   The I2RS information model needs to include representation of these\n\
    \   events.  As discussed earlier, the capability information in the\n   model\
    \ will allow I2RS clients to understand which events a given I2RS\n   agent is\
    \ capable of generating.\n   For performance and scaling by the I2RS client and\
    \ general\n   information confidentiality, an I2RS client needs to be able to\n\
    \   register for just the events it is interested in.  It is also\n   possible\
    \ that I2RS might provide a stream of notifications via a\n   publish/subscribe\
    \ mechanism that is not amenable to having the I2RS\n   agent do the filtering.\n"
- title: 7.7.  Information Collection
  contents:
  - "7.7.  Information Collection\n   One of the other important aspects of I2RS is\
    \ that it is intended to\n   simplify collecting information about the state of\
    \ network elements.\n   This includes both getting a snapshot of a large amount\
    \ of data about\n   the current state of the network element and subscribing to\
    \ a feed of\n   the ongoing changes to the set of data or a subset thereof.  This\
    \ is\n   considered architecturally separate from notifications due to the\n \
    \  differences in information rate and total volume.\n"
- title: 7.8.  Multi-headed Control
  contents:
  - "7.8.  Multi-headed Control\n   As described earlier, an I2RS agent interacts\
    \ with multiple I2RS\n   clients who are actively controlling the network element.\
    \  From an\n   architecture and design perspective, the assumption is that by\
    \ means\n   outside of this system, the data to be manipulated within the network\n\
    \   element is appropriately partitioned so that any given piece of\n   information\
    \ is only being manipulated by a single I2RS client.\n   Nonetheless, unexpected\
    \ interactions happen, and two (or more) I2RS\n   clients may attempt to manipulate\
    \ the same piece of data.  This is\n   considered an error case.  This architecture\
    \ does not attempt to\n   determine what the right state of data should be when\
    \ such a\n   collision happens.  Rather, the architecture mandates that there\
    \ be\n   decidable means by which I2RS agents handle the collisions.  The\n  \
    \ mechanism for ensuring predictability is to have a simple priority\n   associated\
    \ with each I2RS client, and the highest priority change\n   remains in effect.\
    \  In the case of priority ties, the first I2RS\n   client whose attribution is\
    \ associated with the data will keep\n   control.\n   In order for this approach\
    \ to multi-headed control to be useful for\n   I2RS clients, it is necessary that\
    \ an I2RS client can register to\n   receive notifications about changes made\
    \ to writeable data, whose\n   state is of specific interest to that I2RS client.\
    \  This is included\n   in the I2RS event mechanisms.  This also needs to apply\
    \ to changes\n   made by CLI/NETCONF/SNMP within the write scope of the I2RS agent,\
    \ as\n   the same priority mechanism (even if it is \"CLI always wins\") applies\n\
    \   there.  The I2RS client may then respond to the situation as it sees\n   fit.\n"
- title: 7.9.  Transactions
  contents:
  - "7.9.  Transactions\n   In the interest of simplicity, the I2RS architecture does\
    \ not include\n   multi-message atomicity and rollback mechanisms.  Rather, it\
    \ includes\n   a small range of error handling for a set of operations included\
    \ in a\n   single message.  An I2RS client may indicate one of the following\n\
    \   three methods of error handling for a given message with multiple\n   operations\
    \ that it sends to an I2RS agent:\n   Perform all or none:  This traditional SNMP\
    \ semantic indicates that\n      the I2RS agent will keep enough state when handling\
    \ a single\n      message to roll back the operations within that message.  Either\n\
    \      all the operations will succeed, or none of them will be applied,\n   \
    \   and an error message will report the single failure that caused\n      them\
    \ not to be applied.  This is useful when there are, for\n      example, mutual\
    \ dependencies across operations in the message.\n   Perform until error:  In\
    \ this case, the operations in the message are\n      applied in the specified\
    \ order.  When an error occurs, no further\n      operations are applied, and\
    \ an error is returned indicating the\n      failure.  This is useful if there\
    \ are dependencies among the\n      operations and they can be topologically sorted.\n\
    \   Perform all storing errors:  In this case, the I2RS agent will\n      attempt\
    \ to perform all the operations in the message and will\n      return error indications\
    \ for each one that fails.  This is useful\n      when there is no dependency\
    \ across the operation or when the I2RS\n      client would prefer to sort out\
    \ the effect of errors on its own.\n   In the interest of robustness and clarity\
    \ of protocol state, the\n   protocol will include an explicit reply to modification\
    \ or write\n   operations even when they fully succeed.\n"
- title: 8.  Operational and Manageability Considerations
  contents:
  - "8.  Operational and Manageability Considerations\n   In order to facilitate troubleshooting\
    \ of routing elements\n   implementing I2RS agents, the routing elements should\
    \ provide for a\n   mechanism to show actively provisioned I2RS state and other\
    \ I2RS\n   agent internal information.  Note that this information may contain\n\
    \   highly sensitive material subject to the security considerations of\n   any\
    \ data models implemented by that agent and thus must be protected\n   according\
    \ to those considerations.  Preferably, this mechanism should\n   use a different\
    \ privileged means other than simply connecting as an\n   I2RS client to learn\
    \ the data.  Using a different mechanism should\n   improve traceability and failure\
    \ management.\n   Manageability plays a key aspect in I2RS.  Some initial examples\n\
    \   include:\n   Resource Limitations:   Using I2RS, applications can consume\n\
    \      resources, whether those be operations in a time frame, entries in\n  \
    \    the RIB, stored operations to be triggered, etc.  The ability to\n      set\
    \ resource limits based upon authorization is important.\n   Configuration Interactions:\
    \   The interaction of state installed via\n      I2RS and via a router's configuration\
    \ needs to be clearly defined.\n      As described in this architecture, a simple\
    \ priority that is\n      configured is used to provide sufficient policy flexibility.\n\
    \   Traceability of Interactions:   The ability to trace the interactions\n  \
    \    of the requests received by the I2RS agent's and actions taken by\n     \
    \ the I2RS agents is needed so that operations can monitor I2RS\n      agents\
    \ during deployment, and troubleshoot software or network\n      problems.\n \
    \  Notification Subscription Service:  The ability for an I2RS client to\n   \
    \   subscribe to a notification stream pushed from the I2RS agent\n      (rather\
    \ than having I2RS client poll the I2RS agent) provides a\n      more scalable\
    \ notification handling for the I2RS agent-client\n      interactions.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7920]  Atlas, A., Ed., Nadeau, T., Ed., and D. Ward, \"Problem\n     \
    \         Statement for the Interface to the Routing System\",\n             \
    \ RFC 7920, DOI 10.17487/RFC7920, June 2016,\n              <http://www.rfc-editor.org/info/rfc7920>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [I2RS-ENV-SEC]\n              Migault, D., Ed.,\
    \ Halpern, J., and S. Hares, \"I2RS\n              Environment Security Requirements\"\
    , Work in Progress,\n              draft-ietf-i2rs-security-environment-reqs-01,\
    \ April 2016.\n   [I2RS-PROT-SEC]\n              Hares, S., Migault, D., and J.\
    \ Halpern, \"I2RS Security\n              Related Requirements\", Work in Progress,\
    \ draft-ietf-i2rs-\n              protocol-security-requirements-06, May 2016.\n\
    \   [RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n       \
    \       Protocol\", Work in Progress, draft-ietf-netconf-\n              restconf-14,\
    \ June 2016.\n   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder,\
    \ J., Ed.,\n              and A. Bierman, Ed., \"Network Configuration Protocol\n\
    \              (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n     \
    \         <http://www.rfc-editor.org/info/rfc6241>.\n   [RFC6536]  Bierman, A.\
    \ and M. Bjorklund, \"Network Configuration\n              Protocol (NETCONF)\
    \ Access Control Model\", RFC 6536,\n              DOI 10.17487/RFC6536, March\
    \ 2012,\n              <http://www.rfc-editor.org/info/rfc6536>.\n   [RFC6991]\
    \  Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n              RFC 6991,\
    \ DOI 10.17487/RFC6991, July 2013,\n              <http://www.rfc-editor.org/info/rfc6991>.\n\
    \   [RFC7223]  Bjorklund, M., \"A YANG Data Model for Interface\n            \
    \  Management\", RFC 7223, DOI 10.17487/RFC7223, May 2014,\n              <http://www.rfc-editor.org/info/rfc7223>.\n\
    \   [RFC7224]  Bjorklund, M., \"IANA Interface Type YANG Module\",\n         \
    \     RFC 7224, DOI 10.17487/RFC7224, May 2014,\n              <http://www.rfc-editor.org/info/rfc7224>.\n\
    \   [RFC7277]  Bjorklund, M., \"A YANG Data Model for IP Management\",\n     \
    \         RFC 7277, DOI 10.17487/RFC7277, June 2014,\n              <http://www.rfc-editor.org/info/rfc7277>.\n\
    \   [RFC7317]  Bierman, A. and M. Bjorklund, \"A YANG Data Model for\n       \
    \       System Management\", RFC 7317, DOI 10.17487/RFC7317, August\n        \
    \      2014, <http://www.rfc-editor.org/info/rfc7317>.\n   [RFC7752]  Gredler,\
    \ H., Ed., Medved, J., Previdi, S., Farrel, A., and\n              S. Ray, \"\
    North-Bound Distribution of Link-State and\n              Traffic Engineering\
    \ (TE) Information Using BGP\", RFC 7752,\n              DOI 10.17487/RFC7752,\
    \ March 2016,\n              <http://www.rfc-editor.org/info/rfc7752>.\n   [YANG1.1]\
    \  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n            \
    \  Work in Progress, draft-ietf-netmod-rfc6020bis-14, June\n              2016.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Significant portions of this draft came from \"Interface\
    \ to the\n   Routing System Framework\" (February 2013) and \"A Policy Framework\
    \ for\n   the Interface to the Routing System\" (February 2013).\n   The authors\
    \ would like to thank Nitin Bahadur, Shane Amante, Ed\n   Crabbe, Ken Gray, Carlos\
    \ Pignataro, Wes George, Ron Bonica, Joe\n   Clarke, Juergen Schoenwalder, Jeff\
    \ Haas, Jamal Hadi Salim, Scott\n   Brim, Thomas Narten, Dean Bogdanovic, Tom\
    \ Petch, Robert Raszuk,\n   Sriganesh Kini, John Mattsson, Nancy Cam-Winget, DaCheng\
    \ Zhang, Qin\n   Wu, Ahmed Abro, Salman Asadullah, Eric Yu, Deborah Brungard,\
    \ Russ\n   Housley, Russ White, Charlie Kaufman, Benoit Claise, Spencer Dawkins,\n\
    \   and Stephen Farrell for their suggestions and review.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alia Atlas\n   Juniper Networks\n   10 Technology Park\
    \ Drive\n   Westford, MA  01886\n   United States\n   Email: akatlas@juniper.net\n\
    \   Joel Halpern\n   Ericsson\n   Email: Joel.Halpern@ericsson.com\n   Susan Hares\n\
    \   Huawei\n   7453 Hickory Hill\n   Saline, MI  48176\n   United States\n   Phone:\
    \ +1 734-604-0332\n   Email: shares@ndzh.com\n   Dave Ward\n   Cisco Systems\n\
    \   Tasman Drive\n   San Jose, CA  95134\n   United States\n   Email: wardd@cisco.com\n\
    \   Thomas D. Nadeau\n   Brocade\n   Email: tnadeau@lucidvision.com\n"
