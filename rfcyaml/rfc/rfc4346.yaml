- title: __initial_text__
  contents:
  - "              The Transport Layer Security (TLS) Protocol\n                 \
    \             Version 1.1\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Version 1.1 of the Transport Layer Security\n\
    \   (TLS) protocol.  The TLS protocol provides communications security\n   over\
    \ the Internet.  The protocol allows client/server applications to\n   communicate\
    \ in a way that is designed to prevent eavesdropping,\n   tampering, or message\
    \ forgery.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Differences from TLS 1.0 ...................................5\n  \
    \    1.2. Requirements Terminology ...................................5\n   2.\
    \ Goals ...........................................................5\n   3. Goals\
    \ of This Document ..........................................6\n   4. Presentation\
    \ Language ...........................................6\n      4.1. Basic Block\
    \ Size ...........................................7\n      4.2. Miscellaneous\
    \ ..............................................7\n      4.3. Vectors ....................................................7\n\
    \      4.4. Numbers ....................................................8\n  \
    \    4.5. Enumerateds ................................................8\n    \
    \  4.6. Constructed Types ..........................................9\n      \
    \     4.6.1. Variants ...........................................10\n      4.7.\
    \ Cryptographic Attributes ..................................11\n      4.8. Constants\
    \ .................................................12\n   5. HMAC and the Pseudorandom\
    \ Function .............................12\n   6. The TLS Record Protocol ........................................14\n\
    \      6.1. Connection States .........................................15\n  \
    \    6.2. Record layer ..............................................17\n    \
    \       6.2.1. Fragmentation ......................................17\n      \
    \     6.2.2. Record Compression and Decompression ...............19\n        \
    \   6.2.3. Record Payload Protection ..........................19\n          \
    \        6.2.3.1. Null or Standard Stream Cipher ............20\n            \
    \      6.2.3.2. CBC Block Cipher ..........................21\n      6.3. Key\
    \ Calculation ...........................................24\n   7. The TLS Handshaking\
    \ Protocols ..................................24\n      7.1. Change Cipher Spec\
    \ Protocol ...............................25\n      7.2. Alert Protocol ............................................26\n\
    \           7.2.1. Closure Alerts .....................................27\n  \
    \         7.2.2. Error Alerts .......................................28\n    \
    \  7.3. Handshake Protocol Overview ...............................31\n      7.4.\
    \ Handshake Protocol ........................................34\n           7.4.1.\
    \ Hello Messages .....................................35\n                  7.4.1.1.\
    \ Hello request .............................35\n                  7.4.1.2. Client\
    \ Hello ..............................36\n                  7.4.1.3. Server Hello\
    \ ..............................39\n           7.4.2. Server Certificate .................................40\n\
    \           7.4.3. Server Key Exchange Message ........................42\n  \
    \         7.4.4. Certificate request ................................44\n    \
    \       7.4.5. Server Hello Done ..................................46\n      \
    \     7.4.6. Client certificate .................................46\n        \
    \   7.4.7. Client Key Exchange Message ........................47\n          \
    \        7.4.7.1. RSA Encrypted Premaster Secret Message ....47\n            \
    \      7.4.7.2. Client Diffie-Hellman Public Value ........50\n           7.4.8.\
    \ Certificate verify .................................50\n           7.4.9. Finished\
    \ ...........................................51\n   8. Cryptographic Computations\
    \ .....................................52\n      8.1. Computing the Master Secret\
    \ ...............................52\n           8.1.1. RSA ................................................53\n\
    \           8.1.2. Diffie-Hellman .....................................53\n  \
    \ 9. Mandatory Cipher Suites ........................................53\n   10.\
    \ Application Data Protocol .....................................53\n   11. Security\
    \ Considerations .......................................53\n   12. IANA Considerations\
    \ ...........................................54\n   A. Appendix - Protocol constant\
    \ values ............................55\n           A.1. Record layer .........................................55\n\
    \           A.2. Change cipher specs message ..........................56\n  \
    \         A.3. Alert messages .......................................56\n    \
    \       A.4. Handshake protocol ...................................57\n      \
    \     A.4.1. Hello messages .....................................57\n        \
    \   A.4.2. Server authentication and key exchange messages ....58\n          \
    \ A.4.3. Client authentication and key exchange messages ....59\n           A.4.4.Handshake\
    \ finalization message ......................60\n           A.5. The CipherSuite\
    \ ......................................60\n           A.6. The Security Parameters\
    \ ..............................63\n   B. Appendix - Glossary ............................................64\n\
    \   C. Appendix - CipherSuite definitions .............................68\n  \
    \ D. Appendix - Implementation Notes ................................69\n    \
    \       D.1 Random Number Generation and Seeding ..................70\n      \
    \     D.2 Certificates and authentication .......................70\n        \
    \   D.3 CipherSuites ..........................................70\n   E. Appendix\
    \ - Backward Compatibility With SSL .....................71\n           E.1. Version\
    \ 2 client hello ...............................72\n           E.2. Avoiding man-in-the-middle\
    \ version rollback ..........74\n   F. Appendix - Security analysis ...................................74\n\
    \           F.1. Handshake protocol ...................................74\n  \
    \         F.1.1. Authentication and key exchange ....................74\n    \
    \       F.1.1.1. Anonymous key exchange ...........................75\n      \
    \     F.1.1.2. RSA key exchange and authentication ..............75\n        \
    \   F.1.1.3. Diffie-Hellman key exchange with authentication ..76\n          \
    \ F.1.2. Version rollback attacks ...........................77\n           F.1.3.\
    \ Detecting attacks against the handshake protocol ...77\n           F.1.4. Resuming\
    \ sessions ..................................78\n           F.1.5. MD5 and SHA\
    \ ........................................78\n           F.2. Protecting application\
    \ data ..........................78\n           F.3. Explicit IVs .........................................79\n\
    \           F.4  Security of Composite Cipher Modes ...................79\n  \
    \         F.5  Denial of Service ....................................80\n    \
    \       F.6. Final notes ..........................................80\n   Normative\
    \ References ..............................................81\n   Informative\
    \ References ............................................82\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The primary goal of the TLS Protocol is to provide privacy\
    \ and data\n   integrity between two communicating applications.  The protocol\
    \ is\n   composed of two layers: the TLS Record Protocol and the TLS Handshake\n\
    \   Protocol.  At the lowest level, layered on top of some reliable\n   transport\
    \ protocol (e.g., TCP[TCP]), is the TLS Record Protocol.  The\n   TLS Record Protocol\
    \ provides connection security that has two basic\n   properties:\n   -  The connection\
    \ is private.  Symmetric cryptography is used for\n      data encryption (e.g.,\
    \ DES [DES], RC4 [SCH] etc.).  The keys for\n      this symmetric encryption are\
    \ generated uniquely for each\n      connection and are based on a secret negotiated\
    \ by another\n      protocol (such as the TLS Handshake Protocol).  The Record\n\
    \      Protocol can also be used without encryption.\n   -  The connection is\
    \ reliable.  Message transport includes a message\n      integrity check using\
    \ a keyed MAC.  Secure hash functions (e.g.,\n      SHA, MD5, etc.) are used for\
    \ MAC computations.  The Record\n      Protocol can operate without a MAC, but\
    \ is generally only used in\n      this mode while another protocol is using the\
    \ Record Protocol as a\n      transport for negotiating security parameters.\n\
    \   The TLS Record Protocol is used for encapsulation of various higher-\n   level\
    \ protocols.  One such encapsulated protocol, the TLS Handshake\n   Protocol,\
    \ allows the server and client to authenticate each other and\n   to negotiate\
    \ an encryption algorithm and cryptographic keys before\n   the application protocol\
    \ transmits or receives its first byte of\n   data.  The TLS Handshake Protocol\
    \ provides connection security that\n   has three basic properties:\n   -  The\
    \ peer's identity can be authenticated using asymmetric, or\n      public key,\
    \ cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This\n      authentication\
    \ can be made optional, but is generally required for\n      at least one of the\
    \ peers.\n   -  The negotiation of a shared secret is secure: the negotiated\n\
    \      secret is unavailable to eavesdroppers, and for any authenticated\n   \
    \   connection the secret cannot be obtained, even by an attacker who\n      can\
    \ place himself in the middle of the connection.\n   -  The negotiation is reliable:\
    \ no attacker can modify the\n      negotiation communication without being detected\
    \ by the parties to\n      the communication.\n   One advantage of TLS is that\
    \ it is application protocol independent.\n   Higher level protocols can layer\
    \ on top of the TLS Protocol\n   transparently.  The TLS standard, however, does\
    \ not specify how\n   protocols add security with TLS; the decisions on how to\
    \ initiate TLS\n   handshaking and how to interpret the authentication certificates\n\
    \   exchanged are left to the judgment of the designers and implementors\n   of\
    \ protocols that run on top of TLS.\n"
- title: 1.1. Differences from TLS 1.0
  contents:
  - "1.1. Differences from TLS 1.0\n   This document is a revision of the TLS 1.0\
    \ [TLS1.0] protocol, and\n   contains some small security improvements, clarifications,\
    \ and\n   editorial improvements.  The major changes are:\n   -  The implicit\
    \ Initialization Vector (IV) is replaced with an\n      explicit IV to protect\
    \ against CBC attacks [CBCATT].\n   -  Handling of padding errors is changed to\
    \ use the bad_record_mac\n      alert rather than the decryption_failed alert\
    \ to protect against\n      CBC attacks.\n   -  IANA registries are defined for\
    \ protocol parameters.\n   -  Premature closes no longer cause a session to be\
    \ nonresumable.\n   -  Additional informational notes were added for various new\
    \ attacks\n      on TLS.\n   In addition, a number of minor clarifications and\
    \ editorial\n   improvements were made.\n"
- title: 1.2. Requirements Terminology
  contents:
  - "1.2. Requirements Terminology\n   In this document, the keywords \"MUST\", \"\
    MUST NOT\", \"REQUIRED\",\n   \"SHOULD\", \"SHOULD NOT\" and \"MAY\" are to be\
    \ interpreted as described\n   in RFC 2119 [REQ].\n"
- title: 2. Goals
  contents:
  - "2. Goals\n   The goals of TLS Protocol, in order of their priority, are as\n\
    \   follows:\n   1. Cryptographic security: TLS should be used to establish a\
    \ secure\n      connection between two parties.\n   2. Interoperability: Independent\
    \ programmers should be able to\n      develop applications utilizing TLS that\
    \ can successfully exchange\n      cryptographic parameters without knowledge\
    \ of one another's code.\n   3. Extensibility: TLS seeks to provide a framework\
    \ into which new\n      public key and bulk encryption methods can be incorporated\
    \ as\n      necessary.  This will also accomplish two sub-goals: preventing\n\
    \      the need to create a new protocol (and risking the introduction of\n  \
    \    possible new weaknesses) and avoiding the need to implement an\n      entire\
    \ new security library.\n   4. Relative efficiency: Cryptographic operations tend\
    \ to be highly\n      CPU intensive, particularly public key operations.  For\
    \ this\n      reason, the TLS protocol has incorporated an optional session\n\
    \      caching scheme to reduce the number of connections that need to be\n  \
    \    established from scratch.  Additionally, care has been taken to\n      reduce\
    \ network activity.\n"
- title: 3. Goals of This Document
  contents:
  - "3. Goals of This Document\n   This document and the TLS protocol itself are based\
    \ on the SSL 3.0\n   Protocol Specification as published by Netscape.  The differences\n\
    \   between this protocol and SSL 3.0 are not dramatic, but they are\n   significant\
    \ enough that TLS 1.1, TLS 1.0, and SSL 3.0 do not\n   interoperate (although\
    \ each protocol incorporates a mechanism by\n   which an implementation can back\
    \ down prior versions).  This document\n   is intended primarily for readers who\
    \ will be implementing the\n   protocol and for those doing cryptographic analysis\
    \ of it.  The\n   specification has been written with this in mind, and it is\
    \ intended\n   to reflect the needs of those two groups.  For that reason, many\
    \ of\n   the algorithm-dependent data structures and rules are included in the\n\
    \   body of the text (as opposed to in an appendix), providing easier\n   access\
    \ to them.\n   This document is not intended to supply any details of service\n\
    \   definition or of interface definition, although it does cover select\n   areas\
    \ of policy as they are required for the maintenance of solid\n   security.\n"
- title: 4. Presentation Language
  contents:
  - "4. Presentation Language\n   This document deals with the formatting of data\
    \ in an external\n   representation.  The following very basic and somewhat casually\n\
    \   defined presentation syntax will be used.  The syntax draws from\n   several\
    \ sources in its structure.  Although it resembles the\n   programming language\
    \ \"C\" in its syntax and XDR [XDR] in both its\n   syntax and intent, it would\
    \ be risky to draw too many parallels.  The\n   purpose of this presentation language\
    \ is to document TLS only; it has\n   no general application beyond that particular\
    \ goal.\n"
- title: 4.1. Basic Block Size
  contents:
  - "4.1. Basic Block Size\n   The representation of all data items is explicitly\
    \ specified.  The\n   basic data block size is one byte (i.e., 8 bits).  Multiple\
    \ byte data\n   items are concatenations of bytes, from left to right, from top\
    \ to\n   bottom.  From the bytestream, a multi-byte item (a numeric in the\n \
    \  example) is formed (using C notation) by:\n       value = (byte[0] << 8*(n-1))\
    \ | (byte[1] << 8*(n-2)) |\n               ... | byte[n-1];\n   This byte ordering\
    \ for multi-byte values is the commonplace network\n   byte order or big endian\
    \ format.\n"
- title: 4.2. Miscellaneous
  contents:
  - "4.2. Miscellaneous\n   Comments begin with \"/*\" and end with \"*/\".\n   Optional\
    \ components are denoted by enclosing them in \"[[ ]]\" double\n   brackets.\n\
    \   Single-byte entities containing uninterpreted data are of type\n   opaque.\n"
- title: 4.3. Vectors
  contents:
  - "4.3. Vectors\n   A vector (single dimensioned array) is a stream of homogeneous\
    \ data\n   elements.  The size of the vector may be specified at documentation\n\
    \   time or left unspecified until runtime.  In either case, the length\n   declares\
    \ the number of bytes, not the number of elements, in the\n   vector.  The syntax\
    \ for specifying a new type, T', that is a fixed-\n   length vector of type T\
    \ is\n       T T'[n];\n   Here, T' occupies n bytes in the data stream, where\
    \ n is a multiple\n   of the size of T.  The length of the vector is not included\
    \ in the\n   encoded stream.\n   In the following example, Datum is defined to\
    \ be three consecutive\n   bytes that the protocol does not interpret, while Data\
    \ is three\n   consecutive Datum, consuming a total of nine bytes.\n       opaque\
    \ Datum[3];      /* three uninterpreted bytes */\n       Datum Data[9];      \
    \  /* 3 consecutive 3 byte vectors */\n   Variable-length vectors are defined\
    \ by specifying a subrange of legal\n   lengths, inclusively, using the notation\
    \ <floor..ceiling>.  When\n   these are encoded, the actual length precedes the\
    \ vector's contents\n   in the byte stream.  The length will be in the form of\
    \ a number\n   consuming as many bytes as required to hold the vector's specified\n\
    \   maximum (ceiling) length.  A variable-length vector with an actual\n   length\
    \ field of zero is referred to as an empty vector.\n       T T'<floor..ceiling>;\n\
    \   In the following example, mandatory is a vector that must contain\n   between\
    \ 300 and 400 bytes of type opaque.  It can never be empty.\n   The actual length\
    \ field consumes two bytes, a uint16, sufficient to\n   represent the value 400\
    \ (see Section 4.4).  On the other hand, longer\n   can represent up to 800 bytes\
    \ of data, or 400 uint16 elements, and it\n   may be empty.  Its encoding will\
    \ include a two-byte actual length\n   field prepended to the vector.  The length\
    \ of an encoded vector must\n   be an even multiple of the length of a single\
    \ element (for example, a\n   17-byte vector of uint16 would be illegal).\n  \
    \     opaque mandatory<300..400>;\n             /* length field is 2 bytes, cannot\
    \ be empty */\n       uint16 longer<0..800>;\n             /* zero to 400 16-bit\
    \ unsigned integers */\n"
- title: 4.4. Numbers
  contents:
  - "4.4. Numbers\n   The basic numeric data type is an unsigned byte (uint8).  All\
    \ larger\n   numeric data types are formed from fixed-length series of bytes\n\
    \   concatenated as described in Section 4.1 and are also unsigned.  The\n   following\
    \ numeric types are predefined.\n       uint8 uint16[2];\n       uint8 uint24[3];\n\
    \       uint8 uint32[4];\n       uint8 uint64[8];\n   All values, here and elsewhere\
    \ in the specification, are stored in\n   \"network\" or \"big-endian\" order;\
    \ the uint32 represented by the hex\n   bytes 01 02 03 04 is equivalent to the\
    \ decimal value 16909060.\n"
- title: 4.5. Enumerateds
  contents:
  - "4.5. Enumerateds\n   An additional sparse data type is available called enum.\
    \  A field of\n   type enum can only assume the values declared in the definition.\n\
    \   Each definition is a different type.  Only enumerateds of the same\n   type\
    \ may be assigned or compared.  Every element of an enumerated\n   must be assigned\
    \ a value, as demonstrated in the following example.\n   Since the elements of\
    \ the enumerated are not ordered, they can be\n   assigned any unique value, in\
    \ any order.\n       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;\n   Enumerateds\
    \ occupy as much space in the byte stream as would its\n   maximal defined ordinal\
    \ value.  The following definition would cause\n   one byte to be used to carry\
    \ fields of type Color.\n       enum { red(3), blue(5), white(7) } Color;\n  \
    \ One may optionally specify a value without its associated tag to\n   force the\
    \ width definition without defining a superfluous element.\n   In the following\
    \ example, Taste will consume two bytes in the data\n   stream but can only assume\
    \ the values 1, 2, or 4.\n       enum { sweet(1), sour(2), bitter(4), (32000)\
    \ } Taste;\n   The names of the elements of an enumeration are scoped within the\n\
    \   defined type.  In the first example, a fully qualified reference to\n   the\
    \ second element of the enumeration would be Color.blue.  Such\n   qualification\
    \ is not required if the target of the assignment is well\n   specified.\n   \
    \    Color color = Color.blue;     /* overspecified, legal */\n       Color color\
    \ = blue;           /* correct, type implicit */\n   For enumerateds that are\
    \ never converted to external representation,\n   the numerical information may\
    \ be omitted.\n       enum { low, medium, high } Amount;\n"
- title: 4.6. Constructed Types
  contents:
  - "4.6. Constructed Types\n   Structure types may be constructed from primitive\
    \ types for\n   convenience.  Each specification declares a new, unique type.\
    \  The\n   syntax for definition is much like that of C.\n       struct {\n  \
    \       T1 f1;\n         T2 f2;\n         ...\n         Tn fn;\n       } [[T]];\n\
    \   The fields within a structure may be qualified using the type's name,\n  \
    \ with a syntax much like that available for enumerateds.  For example,\n   T.f2\
    \ refers to the second field of the previous declaration.\n   Structure definitions\
    \ may be embedded.\n"
- title: 4.6.1. Variants
  contents:
  - "4.6.1. Variants\n   Defined structures may have variants based on some knowledge\
    \ that is\n   available within the environment.  The selector must be an enumerated\n\
    \   type that defines the possible variants the structure defines.  There\n  \
    \ must be a case arm for every element of the enumeration declared in\n   the\
    \ select.  The body of the variant structure may be given a label\n   for reference.\
    \  The mechanism by which the variant is selected at\n   runtime is not prescribed\
    \ by the presentation language.\n       struct {\n           T1 f1;\n        \
    \   T2 f2;\n           ....\n           Tn fn;\n           select (E) {\n    \
    \           case e1: Te1;\n               case e2: Te2;\n               ....\n\
    \               case en: Ten;\n           } [[fv]];\n       } [[Tv]];\n   For\
    \ example:\n       enum { apple, orange } VariantTag;\n       struct {\n     \
    \      uint16 number;\n           opaque string<0..10>; /* variable length */\n\
    \       } V1;\n       struct {\n           uint32 number;\n           opaque string[10];\
    \    /* fixed length */\n       } V2;\n       struct {\n           select (VariantTag)\
    \ { /* value of selector is implicit */\n               case apple: V1;   /* VariantBody,\
    \ tag = apple */\n               case orange: V2;  /* VariantBody, tag = orange\
    \ */\n           } variant_body;       /* optional label on variant */\n     \
    \  } VariantRecord;\n   Variant structures may be qualified (narrowed) by specifying\
    \ a value\n   for the selector prior to the type.  For example, an\n       orange\
    \ VariantRecord\n   is a narrowed type of a VariantRecord containing a variant_body\
    \ of\n   type V2.\n"
- title: 4.7. Cryptographic Attributes
  contents:
  - "4.7. Cryptographic Attributes\n   The four cryptographic operations digital signing,\
    \ stream cipher\n   encryption, block cipher encryption, and public key encryption\
    \ are\n   designated digitally-signed, stream-ciphered, block-ciphered, and\n\
    \   public-key-encrypted, respectively.  A field's cryptographic\n   processing\
    \ is specified by prepending an appropriate key word\n   designation before the\
    \ field's type specification.  Cryptographic\n   keys are implied by the current\
    \ session state (see Section 6.1).\n   In digital signing, one-way hash functions\
    \ are used as input for a\n   signing algorithm.  A digitally-signed element is\
    \ encoded as an\n   opaque vector <0..2^16-1>, where the length is specified by\
    \ the\n   signing algorithm and key.\n   In RSA signing, a 36-byte structure of\
    \ two hashes (one SHA and one\n   MD5) is signed (encrypted with the private key).\
    \  It is encoded with\n   PKCS #1 block type 1, as described in [PKCS1A].\n  \
    \ Note: The standard reference for PKCS#1 is now RFC 3447 [PKCS1B].\n        \
    \ However, to minimize differences with TLS 1.0 text, we are\n         using the\
    \ terminology of RFC 2313 [PKCS1A].\n   In DSS, the 20 bytes of the SHA hash are\
    \ run directly through the\n   Digital Signing Algorithm with no additional hashing.\
    \  This produces\n   two values, r and s.  The DSS signature is an opaque vector,\
    \ as\n   above, the contents of which are the DER encoding of:\n       Dss-Sig-Value\
    \  ::=  SEQUENCE  {\n            r       INTEGER,\n            s       INTEGER\n\
    \       }\n   In stream cipher encryption, the plaintext is exclusive-ORed with\
    \ an\n   identical amount of output generated from a cryptographically secure\n\
    \   keyed pseudorandom number generator.\n   In block cipher encryption, every\
    \ block of plaintext encrypts to a\n   block of ciphertext.  All block cipher\
    \ encryption is done in CBC\n   (Cipher Block Chaining) mode, and all items that\
    \ are block-ciphered\n   will be an exact multiple of the cipher block length.\n\
    \   In public key encryption, a public key algorithm is used to encrypt\n   data\
    \ in such a way that it can be decrypted only with the matching\n   private key.\
    \  A public-key-encrypted element is encoded as an opaque\n   vector <0..2^16-1>,\
    \ where the length is specified by the signing\n   algorithm and key.\n   An RSA-encrypted\
    \ value is encoded with PKCS #1 block type 2, as\n   described in [PKCS1A].\n\
    \   In the following example,\n       stream-ciphered struct {\n           uint8\
    \ field1;\n           uint8 field2;\n           digitally-signed opaque hash[20];\n\
    \       } UserType;\n   the contents of hash are used as input for the signing\
    \ algorithm, and\n   then the entire structure is encrypted with a stream cipher.\
    \  The\n   length of this structure, in bytes, would be equal to two bytes for\n\
    \   field1 and field2, plus two bytes for the length of the signature,\n   plus\
    \ the length of the output of the signing algorithm.  This is\n   known because\
    \ the algorithm and key used for the signing are known\n   prior to encoding or\
    \ decoding this structure.\n"
- title: 4.8. Constants
  contents:
  - "4.8. Constants\n   Typed constants can be defined for purposes of specification\
    \ by\n   declaring a symbol of the desired type and assigning values to it.\n\
    \   Under-specified types (opaque, variable length vectors, and\n   structures\
    \ that contain opaque) cannot be assigned values.  No fields\n   of a multi-element\
    \ structure or vector may be elided.\n   For example:\n       struct {\n     \
    \      uint8 f1;\n           uint8 f2;\n       } Example1;\n       Example1 ex1\
    \ = {1, 4};  /* assigns f1 = 1, f2 = 4 */\n"
- title: 5. HMAC and the Pseudorandom Function
  contents:
  - "5. HMAC and the Pseudorandom Function\n   A number of operations in the TLS record\
    \ and handshake layer require\n   a keyed MAC; this is a secure digest of some\
    \ data protected by a\n   secret.  Forging the MAC is infeasible without knowledge\
    \ of the MAC\n   secret.  The construction we use for this operation is known\
    \ as HMAC,\n   and is described in [HMAC].\n   HMAC can be used with a variety\
    \ of different hash algorithms.  TLS\n   uses it in the handshake with two different\
    \ algorithms, MD5 and SHA-\n   1, denoting these as HMAC_MD5(secret, data) and\
    \ HMAC_SHA(secret,\n   data).  Additional hash algorithms can be defined by cipher\
    \ suites\n   and used to protect record data, but MD5 and SHA-1 are hard coded\n\
    \   into the description of the handshaking for this version of the\n   protocol.\n\
    \   In addition, a construction is required to do expansion of secrets\n   into\
    \ blocks of data for the purposes of key generation or validation.\n   This pseudo-random\
    \ function (PRF) takes as input a secret, a seed,\n   and an identifying label\
    \ and produces an output of arbitrary length.\n   In order to make the PRF as\
    \ secure as possible, it uses two hash\n   algorithms in a way that should guarantee\
    \ its security if either\n   algorithm remains secure.\n   First, we define a\
    \ data expansion function, P_hash(secret, data) that\n   uses a single hash function\
    \ to expand a secret and seed into an\n   arbitrary quantity of output:\n    \
    \   P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +\n                \
    \              HMAC_hash(secret, A(2) + seed) +\n                            \
    \  HMAC_hash(secret, A(3) + seed) + ...\n   Where + indicates concatenation.\n\
    \   A() is defined as:\n       A(0) = seed\n       A(i) = HMAC_hash(secret, A(i-1))\n\
    \   P_hash can be iterated as many times as is necessary to produce the\n   required\
    \ quantity of data.  For example, if P_SHA-1 is being used to\n   create 64 bytes\
    \ of data, it will have to be iterated 4 times (through\n   A(4)), creating 80\
    \ bytes of output data; the last 16 bytes of the\n   final iteration will then\
    \ be discarded, leaving 64 bytes of output\n   data.\n   TLS's PRF is created\
    \ by splitting the secret into two halves and\n   using one half to generate data\
    \ with P_MD5 and the other half to\n   generate data with P_SHA-1, then exclusive-ORing\
    \ the outputs of these\n   two expansion functions together.\n   S1 and S2 are\
    \ the two halves of the secret, and each is the same\n   length.  S1 is taken\
    \ from the first half of the secret, S2 from the\n   second half.  Their length\
    \ is created by rounding up the length of\n   the overall secret, divided by two;\
    \ thus, if the original secret is\n   an odd number of bytes long, the last byte\
    \ of S1 will be the same as\n   the first byte of S2.\n       L_S = length in\
    \ bytes of secret;\n       L_S1 = L_S2 = ceil(L_S / 2);\n   The secret is partitioned\
    \ into two halves (with the possibility of\n   one shared byte) as described above,\
    \ S1 taking the first L_S1 bytes,\n   and S2 the last L_S2 bytes.\n   The PRF\
    \ is then defined as the result of mixing the two pseudorandom\n   streams by\
    \ exclusive-ORing them together.\n       PRF(secret, label, seed) = P_MD5(S1,\
    \ label + seed) XOR\n                                  P_SHA-1(S2, label + seed);\n\
    \   The label is an ASCII string.  It should be included in the exact\n   form\
    \ it is given without a length byte or trailing null character.\n   For example,\
    \ the label \"slithy toves\" would be processed by hashing\n   the following bytes:\n\
    \       73 6C 69 74 68 79 20 74 6F 76 65 73\n   Note that because MD5 produces\
    \ 16-byte outputs and SHA-1 produces\n   20-byte outputs, the boundaries of their\
    \ internal iterations will not\n   be aligned.  Generating an 80-byte output will\
    \ require that P_MD5\n   iterate through A(5), while P_SHA-1 will only iterate\
    \ through A(4).\n"
- title: 6. The TLS Record Protocol
  contents:
  - "6. The TLS Record Protocol\n   The TLS Record Protocol is a layered protocol.\
    \  At each layer,\n   messages may include fields for length, description, and\
    \ content.\n   The Record Protocol takes messages to be transmitted, fragments\
    \ the\n   data into manageable blocks, optionally compresses the data, applies\n\
    \   a MAC, encrypts, and transmits the result.  Received data is\n   decrypted,\
    \ verified, decompressed, reassembled, and then delivered to\n   higher-level\
    \ clients.\n   Four record protocol clients are described in this document: the\n\
    \   handshake protocol, the alert protocol, the change cipher spec\n   protocol,\
    \ and the application data protocol.  In order to allow\n   extension of the TLS\
    \ protocol, additional record types can be\n   supported by the record protocol.\
    \  Any new record types SHOULD\n   allocate type values immediately beyond the\
    \ ContentType values for\n   the four record types described here (see Appendix\
    \ A.1).  All such\n   values must be defined by RFC 2434 Standards Action.  See\
    \ Section 11\n   for IANA Considerations for ContentType values.\n   If a TLS\
    \ implementation receives a record type it does not\n   understand, it SHOULD\
    \ just ignore it.  Any protocol designed for use\n   over TLS MUST be carefully\
    \ designed to deal with all possible attacks\n   against it.  Note that because\
    \ the type and length of a record are\n   not protected by encryption, care SHOULD\
    \ be taken to minimize the\n   value of traffic analysis of these values.\n"
- title: 6.1. Connection States
  contents:
  - "6.1. Connection States\n   A TLS connection state is the operating environment\
    \ of the TLS Record\n   Protocol.  It specifies a compression algorithm, and encryption\n\
    \   algorithm, and a MAC algorithm.  In addition, the parameters for\n   these\
    \ algorithms are known: the MAC secret and the bulk encryption\n   keys for the\
    \ connection in both the read and the write directions.\n   Logically, there are\
    \ always four connection states outstanding: the\n   current read and write states,\
    \ and the pending read and write states.\n   All records are processed under the\
    \ current read and write states.\n   The security parameters for the pending states\
    \ can be set by the TLS\n   Handshake Protocol, and the Change Cipher Spec can\
    \ selectively make\n   either of the pending states current, in which case the\
    \ appropriate\n   current state is disposed of and replaced with the pending state;\
    \ the\n   pending state is then reinitialized to an empty state.  It is illegal\n\
    \   to make a state that has not been initialized with security\n   parameters\
    \ a current state.  The initial current state always\n   specifies that no encryption,\
    \ compression, or MAC will be used.\n   The security parameters for a TLS Connection\
    \ read and write state are\n   set by providing the following values:\n   connection\
    \ end\n      Whether this entity is considered the \"client\" or the \"server\"\
    \ in\n      this connection.\n   bulk encryption algorithm\n      An algorithm\
    \ to be used for bulk encryption.  This specification\n      includes the key\
    \ size of this algorithm, how much of that key is\n      secret, whether it is\
    \ a block or stream cipher, and the block size\n      of the cipher (if appropriate).\n\
    \   MAC algorithm\n      An algorithm to be used for message authentication. \
    \ This\n      specification includes the size of the hash returned by the MAC\n\
    \      algorithm.\n   compression algorithm\n      An algorithm to be used for\
    \ data compression.  This specification\n      must include all information the\
    \ algorithm requires compression.\n   master secret\n      A 48-byte secret shared\
    \ between the two peers in the connection.\n   client random\n      A 32-byte\
    \ value provided by the client.\n   server random\n      A 32-byte value provided\
    \ by the server.\n   These parameters are defined in the presentation language\
    \ as:\n       enum { server, client } ConnectionEnd;\n       enum { null, rc4,\
    \ rc2, des, 3des, des40, idea, aes }\n       BulkCipherAlgorithm;\n       enum\
    \ { stream, block } CipherType;\n       enum { null, md5, sha } MACAlgorithm;\n\
    \       enum { null(0), (255) } CompressionMethod;\n       /* The algorithms specified\
    \ in CompressionMethod,\n          BulkCipherAlgorithm, and MACAlgorithm may be\
    \ added to. */\n       struct {\n           ConnectionEnd          entity;\n \
    \          BulkCipherAlgorithm    bulk_cipher_algorithm;\n           CipherType\
    \             cipher_type;\n           uint8                  key_size;\n    \
    \       uint8                  key_material_length;\n           MACAlgorithm \
    \          mac_algorithm;\n           uint8                  hash_size;\n    \
    \       CompressionMethod      compression_algorithm;\n           opaque     \
    \            master_secret[48];\n           opaque                 client_random[32];\n\
    \           opaque                 server_random[32];\n       } SecurityParameters;\n\
    \   The record layer will use the security parameters to generate the\n   following\
    \ four items:\n       client write MAC secret\n       server write MAC secret\n\
    \       client write key\n       server write key\n   The client write parameters\
    \ are used by the server when receiving and\n   processing records and vice-versa.\
    \  The algorithm used for generating\n   these items from the security parameters\
    \ is described in Section 6.3.\n   Once the security parameters have been set\
    \ and the keys have been\n   generated, the connection states can be instantiated\
    \ by making them\n   the current states.  These current states MUST be updated\
    \ for each\n   record processed.  Each connection state includes the following\n\
    \   elements:\n   compression state\n      The current state of the compression\
    \ algorithm.\n   cipher state\n      The current state of the encryption algorithm.\
    \  This will consist\n      of the scheduled key for that connection.  For stream\
    \ ciphers,\n      this will also contain whatever state information is necessary\
    \ to\n      allow the stream to continue to encrypt or decrypt data.\n   MAC secret\n\
    \      The MAC secret for this connection, as generated above.\n   sequence number\n\
    \      Each connection state contains a sequence number, which is\n      maintained\
    \ separately for read and write states.  The sequence\n      number MUST be set\
    \ to zero whenever a connection state is made the\n      active state.  Sequence\
    \ numbers are of type uint64 and may not\n      exceed 2^64-1.  Sequence numbers\
    \ do not wrap.  If a TLS\n      implementation would need to wrap a sequence number,\
    \ it must\n      renegotiate instead.  A sequence number is incremented after\
    \ each\n      record: specifically, the first record transmitted under a\n   \
    \   particular connection state MUST use sequence number 0.\n"
- title: 6.2. Record layer
  contents:
  - "6.2. Record layer\n   The TLS Record Layer receives uninterpreted data from higher\
    \ layers\n   in non-empty blocks of arbitrary size.\n"
- title: 6.2.1. Fragmentation
  contents:
  - "6.2.1. Fragmentation\n   The record layer fragments information blocks into TLSPlaintext\n\
    \   records carrying data in chunks of 2^14 bytes or less.  Client\n   message\
    \ boundaries are not preserved in the record layer (i.e.,\n   multiple client\
    \ messages of the same ContentType MAY be coalesced\n   into a single TLSPlaintext\
    \ record, or a single message MAY be\n   fragmented across several records).\n\
    \       struct {\n           uint8 major, minor;\n       } ProtocolVersion;\n\
    \       enum {\n           change_cipher_spec(20), alert(21), handshake(22),\n\
    \           application_data(23), (255)\n       } ContentType;\n       struct\
    \ {\n           ContentType type;\n           ProtocolVersion version;\n     \
    \      uint16 length;\n           opaque fragment[TLSPlaintext.length];\n    \
    \   } TLSPlaintext;\n   type\n      The higher-level protocol used to process\
    \ the enclosed fragment.\n   version\n      The version of the protocol being\
    \ employed.  This document\n      describes TLS Version 1.1, which uses the version\
    \ { 3, 2 }.  The\n      version value 3.2 is historical: TLS version 1.1 is a\
    \ minor\n      modification to the TLS 1.0 protocol, which was itself a minor\n\
    \      modification to the SSL 3.0 protocol, which bears the version\n      value\
    \ 3.0.  (See Appendix A.1.)\n   length\n      The length (in bytes) of the following\
    \ TLSPlaintext.fragment.  The\n      length should not exceed 2^14.\n   fragment\n\
    \      The application data.  This data is transparent and is treated as\n   \
    \   an independent block to be dealt with by the higher-level protocol\n     \
    \ specified by the type field.\n   Note: Data of different TLS Record layer content\
    \ types MAY be\n   interleaved.  Application data is generally of lower precedence\
    \ for\n   transmission than other content types.  However, records MUST be\n \
    \  delivered to the network in the same order as they are protected by\n   the\
    \ record layer.  Recipients MUST receive and process interleaved\n   application\
    \ layer traffic during handshakes subsequent to the first\n   one on a connection.\n"
- title: 6.2.2. Record Compression and Decompression
  contents:
  - "6.2.2. Record Compression and Decompression\n   All records are compressed using\
    \ the compression algorithm defined in\n   the current session state.  There is\
    \ always an active compression\n   algorithm; however, initially it is defined\
    \ as\n   CompressionMethod.null.  The compression algorithm translates a\n   TLSPlaintext\
    \ structure into a TLSCompressed structure.  Compression\n   functions are initialized\
    \ with default state information whenever a\n   connection state is made active.\n\
    \   Compression must be lossless and may not increase the content length\n   by\
    \ more than 1024 bytes.  If the decompression function encounters a\n   TLSCompressed.fragment\
    \ that would decompress to a length in excess of\n   2^14 bytes, it should report\
    \ a fatal decompression failure error.\n       struct {\n           ContentType\
    \ type;       /* same as TLSPlaintext.type */\n           ProtocolVersion version;/*\
    \ same as TLSPlaintext.version */\n           uint16 length;\n           opaque\
    \ fragment[TLSCompressed.length];\n       } TLSCompressed;\n   length\n      The\
    \ length (in bytes) of the following TLSCompressed.fragment.\n      The length\
    \ should not exceed 2^14 + 1024.\n   fragment\n      The compressed form of TLSPlaintext.fragment.\n\
    \   Note: A CompressionMethod.null operation is an identity operation; no\n  \
    \       fields are altered.\n   Implementation note: Decompression functions are\
    \ responsible for\n                        ensuring that messages cannot cause\
    \ internal\n                        buffer overflows.\n"
- title: 6.2.3. Record Payload Protection
  contents:
  - "6.2.3. Record Payload Protection\n   The encryption and MAC functions translate\
    \ a TLSCompressed structure\n   into a TLSCiphertext.  The decryption functions\
    \ reverse the process.\n   The MAC of the record also includes a sequence number\
    \ so that\n   missing, extra, or repeated messages are detectable.\n       struct\
    \ {\n           ContentType type;\n           ProtocolVersion version;\n     \
    \      uint16 length;\n           select (CipherSpec.cipher_type) {\n        \
    \       case stream: GenericStreamCipher;\n               case block: GenericBlockCipher;\n\
    \           } fragment;\n       } TLSCiphertext;\n   type\n      The type field\
    \ is identical to TLSCompressed.type.\n   version\n      The version field is\
    \ identical to TLSCompressed.version.\n   length\n      The length (in bytes)\
    \ of the following TLSCiphertext.fragment.\n      The length may not exceed 2^14\
    \ + 2048.\n   fragment\n      The encrypted form of TLSCompressed.fragment, with\
    \ the MAC.\n"
- title: 6.2.3.1. Null or Standard Stream Cipher
  contents:
  - "6.2.3.1. Null or Standard Stream Cipher\n   Stream ciphers (including BulkCipherAlgorithm.null,\
    \ see Appendix A.6)\n   convert TLSCompressed.fragment structures to and from\
    \ stream\n   TLSCiphertext.fragment structures.\n       stream-ciphered struct\
    \ {\n           opaque content[TLSCompressed.length];\n           opaque MAC[CipherSpec.hash_size];\n\
    \       } GenericStreamCipher;\n   The MAC is generated as:\n       HMAC_hash(MAC_write_secret,\
    \ seq_num + TLSCompressed.type +\n                     TLSCompressed.version +\
    \ TLSCompressed.length +\n                     TLSCompressed.fragment));\n   where\
    \ \"+\" denotes concatenation.\n   seq_num\n      The sequence number for this\
    \ record.\n   hash\n      The hashing algorithm specified by\n      SecurityParameters.mac_algorithm.\n\
    \   Note that the MAC is computed before encryption.  The stream cipher\n   encrypts\
    \ the entire block, including the MAC.  For stream ciphers\n   that do not use\
    \ a synchronization vector (such as RC4), the stream\n   cipher state from the\
    \ end of one record is simply used on the\n   subsequent packet.  If the CipherSuite\
    \ is TLS_NULL_WITH_NULL_NULL,\n   encryption consists of the identity operation\
    \ (i.e., the data is not\n   encrypted, and the MAC size is zero, implying that\
    \ no MAC is used).\n   TLSCiphertext.length is TLSCompressed.length plus\n   CipherSpec.hash_size.\n"
- title: 6.2.3.2. CBC Block Cipher
  contents:
  - "6.2.3.2. CBC Block Cipher\n   For block ciphers (such as RC2, DES, or AES), the\
    \ encryption and MAC\n   functions convert TLSCompressed.fragment structures to\
    \ and from block\n   TLSCiphertext.fragment structures.\n       block-ciphered\
    \ struct {\n           opaque IV[CipherSpec.block_length];\n           opaque\
    \ content[TLSCompressed.length];\n           opaque MAC[CipherSpec.hash_size];\n\
    \           uint8 padding[GenericBlockCipher.padding_length];\n           uint8\
    \ padding_length;\n       } GenericBlockCipher;\n   The MAC is generated as described\
    \ in Section 6.2.3.1.\n   IV\n      Unlike previous versions of SSL and TLS, TLS\
    \ 1.1 uses an explicit\n      IV in order to prevent the attacks described by\
    \ [CBCATT].  We\n      recommend the following equivalently strong procedures.\
    \  For\n      clarity we use the following notation.\n      IV\n         The transmitted\
    \ value of the IV field in the GenericBlockCipher\n         structure.\n     \
    \ CBC residue\n         The last ciphertext block of the previous record.\n  \
    \    mask\n         The actual value that the cipher XORs with the plaintext prior\n\
    \         to encryption of the first cipher block of the record.\n      In prior\
    \ versions of TLS, there was no IV field and the CBC\n      residue and mask were\
    \ one and the same.  See Sections 6.1,\n      6.2.3.2, and 6.3, of [TLS1.0] for\
    \ details of TLS 1.0 IV handling.\n      One of the following two algorithms SHOULD\
    \ be used to generate the\n      per-record IV:\n      (1) Generate a cryptographically\
    \ strong random string R of length\n          CipherSpec.block_length.  Place\
    \ R in the IV field.  Set the\n          mask to R.  Thus, the first cipher block\
    \ will be encrypted as\n          E(R XOR Data).\n      (2) Generate a cryptographically\
    \ strong random number R of length\n          CipherSpec.block_length and prepend\
    \ it to the plaintext prior\n          to encryption.  In this case either:\n\
    \          (a) The cipher may use a fixed mask such as zero.\n          (b) The\
    \ CBC residue from the previous record may be used as\n              the mask.\
    \  This preserves maximum code compatibility with\n              TLS 1.0 and SSL\
    \ 3.  It also has the advantage that it does\n              not require the ability\
    \ to quickly reset the IV, which is\n              known to be a problem on some\
    \ systems.\n          In either (2)(a) or (2)(b) the data (R || data) is fed into\n\
    \          the encryption process.  The first cipher block (containing\n     \
    \     E(mask XOR R) is placed in the IV field.  The first block of\n         \
    \ content contains E(IV XOR data).\n      The following alternative procedure\
    \ MAY be used; however, it has\n      not been demonstrated to be as cryptographically\
    \ strong as the\n      above procedures.  The sender prepends a fixed block F\
    \ to the\n      plaintext (or, alternatively, a block generated with a weak PRNG).\n\
    \      He then encrypts as in (2), above, using the CBC residue from the\n   \
    \   previous block as the mask for the prepended block.  Note that in\n      this\
    \ case the mask for the first record transmitted by the\n      application (the\
    \ Finished) MUST be generated using a\n      cryptographically strong PRNG.\n\
    \      The decryption operation for all three alternatives is the same.\n    \
    \  The receiver decrypts the entire GenericBlockCipher structure and\n      then\
    \ discards the first cipher block, corresponding to the IV\n      component.\n\
    \   padding\n      Padding that is added to force the length of the plaintext\
    \ to be\n      an integral multiple of the block cipher's block length.  The\n\
    \      padding MAY be any length up to 255 bytes, as long as it results\n    \
    \  in the TLSCiphertext.length being an integral multiple of the\n      block\
    \ length.  Lengths longer than necessary might be desirable to\n      frustrate\
    \ attacks on a protocol that are based on analysis of the\n      lengths of exchanged\
    \ messages.  Each uint8 in the padding data\n      vector MUST be filled with\
    \ the padding length value.  The receiver\n      MUST check this padding and SHOULD\
    \ use the bad_record_mac alert to\n      indicate padding errors.\n   padding_length\n\
    \      The padding length MUST be such that the total size of the\n      GenericBlockCipher\
    \ structure is a multiple of the cipher's block\n      length.  Legal values range\
    \ from zero to 255, inclusive.  This\n      length specifies the length of the\
    \ padding field exclusive of the\n      padding_length field itself.\n   The encrypted\
    \ data length (TLSCiphertext.length) is one more than the\n   sum of CipherSpec.block_length,\
    \ TLSCompressed.length,\n   CipherSpec.hash_size, and padding_length.\n   Example:\
    \ If the block length is 8 bytes, the content length\n            (TLSCompressed.length)\
    \ is 61 bytes, and the MAC length is 20\n            bytes, then the length before\
    \ padding is 82 bytes (this does\n            not include the IV, which may or\
    \ may not be encrypted, as\n            discussed above).  Thus, the padding length\
    \ modulo 8 must be\n            equal to 6 in order to make the total length an\
    \ even\n            multiple of 8 bytes (the block length).  The padding length\n\
    \            can be 6, 14, 22, and so on, through 254.  If the padding\n     \
    \       length were the minimum necessary, 6, the padding would be 6\n       \
    \     bytes, each containing the value 6.  Thus, the last 8 octets\n         \
    \   of the GenericBlockCipher before block encryption would be\n            xx\
    \ 06 06 06 06 06 06 06, where xx is the last octet of the\n            MAC.\n\
    \   Note: With block ciphers in CBC mode (Cipher Block Chaining), it is\n    \
    \     critical that the entire plaintext of the record be known\n         before\
    \ any ciphertext is transmitted.  Otherwise, it is\n         possible for the\
    \ attacker to mount the attack described in\n         [CBCATT].\n   Implementation\
    \ Note: Canvel et al. [CBCTIME] have demonstrated a\n                        timing\
    \ attack on CBC padding based on the time\n                        required to\
    \ compute the MAC.  In order to defend\n                        against this attack,\
    \ implementations MUST ensure\n                        that record processing\
    \ time is essentially the\n                        same whether or not the padding\
    \ is correct.  In\n                        general, the best way to do this is\
    \ to compute\n                        the MAC even if the padding is incorrect,\
    \ and\n                        only then reject the packet.  For instance, if\n\
    \                        the pad appears to be incorrect, the\n              \
    \          implementation might assume a zero-length pad\n                   \
    \     and then compute the MAC.  This leaves a small\n                       \
    \ timing channel, since MAC performance depends to\n                        some\
    \ extent on the size of the data fragment,\n                        but it is\
    \ not believed to be large enough to be\n                        exploitable,\
    \ due to the large block size of\n                        existing MACs and the\
    \ small size of the timing\n                        signal.\n"
- title: 6.3. Key Calculation
  contents:
  - "6.3. Key Calculation\n   The Record Protocol requires an algorithm to generate\
    \ keys, and MAC\n   secrets from the security parameters provided by the handshake\n\
    \   protocol.\n   The master secret is hashed into a sequence of secure bytes,\
    \ which\n   are assigned to the MAC secrets and keys required by the current\n\
    \   connection state (see Appendix A.6).  CipherSpecs require a client\n   write\
    \ MAC secret, a server write MAC secret, a client write key, and\n   a server\
    \ write key, each of which is generated from the master secret\n   in that order.\
    \  Unused values are empty.\n   When keys and MAC secrets are generated, the master\
    \ secret is used as\n   an entropy source.\n   To generate the key material, compute\n\
    \       key_block = PRF(SecurityParameters.master_secret,\n                  \
    \        \"key expansion\",\n                          SecurityParameters.server_random\
    \ +\n             SecurityParameters.client_random);\n   until enough output has\
    \ been generated.  Then the key_block is\n   partitioned as follows:\n       client_write_MAC_secret[SecurityParameters.hash_size]\n\
    \       server_write_MAC_secret[SecurityParameters.hash_size]\n       client_write_key[SecurityParameters.key_material_length]\n\
    \       server_write_key[SecurityParameters.key_material_length]\n   Implementation\
    \ note: The currently defined cipher suite that requires\n   the most material\
    \ is AES_256_CBC_SHA, defined in [TLSAES].  It\n   requires 2 x 32 byte keys,\
    \ 2 x 20 byte MAC secrets, and 2 x 16 byte\n   Initialization Vectors, for a total\
    \ of 136 bytes of key material.\n"
- title: 7. The TLS Handshaking Protocols
  contents:
  - "7. The TLS Handshaking Protocols\n   TLS has three subprotocols that are used\
    \ to allow peers to agree upon\n   security parameters for the record layer, to\
    \ authenticate themselves,\n   to instantiate negotiated security parameters,\
    \ and to report error\n   conditions to each other.\n   The Handshake Protocol\
    \ is responsible for negotiating a session,\n   which consists of the following\
    \ items:\n   session identifier\n      An arbitrary byte sequence chosen by the\
    \ server to identify an\n      active or resumable session state.\n   peer certificate\n\
    \      X509v3 [X509] certificate of the peer.  This element of the state\n   \
    \   may be null.\n   compression method\n      The algorithm used to compress\
    \ data prior to encryption.\n   cipher spec\n      Specifies the bulk data encryption\
    \ algorithm (such as null, DES,\n      etc.) and a MAC algorithm (such as MD5\
    \ or SHA).  It also defines\n      cryptographic attributes such as the hash_size.\
    \  (See Appendix A.6\n      for formal definition.)\n   master secret\n      48-byte\
    \ secret shared between the client and server.\n   is resumable\n      A flag\
    \ indicating whether the session can be used to initiate new\n      connections.\n\
    \   These items are then used to create security parameters for use by\n   the\
    \ Record Layer when protecting application data.  Many connections\n   can be\
    \ instantiated using the same session through the resumption\n   feature of the\
    \ TLS Handshake Protocol.\n"
- title: 7.1. Change Cipher Spec Protocol
  contents:
  - "7.1. Change Cipher Spec Protocol\n   The change cipher spec protocol exists to\
    \ signal transitions in\n   ciphering strategies.  The protocol consists of a\
    \ single message,\n   which is encrypted and compressed under the current (not\
    \ the pending)\n   connection state.  The message consists of a single byte of\
    \ value 1.\n       struct {\n           enum { change_cipher_spec(1), (255) }\
    \ type;\n       } ChangeCipherSpec;\n   The change cipher spec message is sent\
    \ by both the client and the\n   server to notify the receiving party that subsequent\
    \ records will be\n   protected under the newly negotiated CipherSpec and keys.\
    \  Reception\n   of this message causes the receiver to instruct the Record Layer\
    \ to\n   immediately copy the read pending state into the read current state.\n\
    \   Immediately after sending this message, the sender MUST instruct the\n   record\
    \ layer to make the write pending state the write active state.\n   (See Section\
    \ 6.1.)  The change cipher spec message is sent during the\n   handshake after\
    \ the security parameters have been agreed upon, but\n   before the verifying\
    \ finished message is sent (see Section 7.4.9).\n   Note: If a rehandshake occurs\
    \ while data is flowing on a connection,\n         the communicating parties may\
    \ continue to send data using the\n         old CipherSpec.  However, once the\
    \ ChangeCipherSpec has been\n         sent, the new CipherSpec MUST be used. \
    \ The first side to send\n         the ChangeCipherSpec does not know that the\
    \ other side has\n         finished computing the new keying material (e.g., if\
    \ it has to\n         perform a time consuming public key operation).  Thus, a\
    \ small\n         window of time, during which the recipient must buffer the\n\
    \         data, MAY exist.  In practice, with modern machines this\n         interval\
    \ is likely to be fairly short.\n"
- title: 7.2. Alert Protocol
  contents:
  - "7.2. Alert Protocol\n         One of the content types supported by the TLS Record\
    \ layer is\n         the alert type.  Alert messages convey the severity of the\n\
    \         message and a description of the alert.  Alert messages with a\n   \
    \      level of fatal result in the immediate termination of the\n         connection.\
    \  In this case, other connections corresponding to\n         the session may\
    \ continue, but the session identifier MUST be\n         invalidated, preventing\
    \ the failed session from being used to\n         establish new connections. \
    \ Like other messages, alert messages\n         are encrypted and compressed,\
    \ as specified by the current\n         connection state.\n             enum {\
    \ warning(1), fatal(2), (255) } AlertLevel;\n             enum {\n           \
    \      close_notify(0),\n                 unexpected_message(10),\n          \
    \       bad_record_mac(20),\n                 decryption_failed(21),\n       \
    \          record_overflow(22),\n                 decompression_failure(30),\n\
    \                 handshake_failure(40),\n                 no_certificate_RESERVED\
    \ (41),\n                 bad_certificate(42),\n                 unsupported_certificate(43),\n\
    \                 certificate_revoked(44),\n                 certificate_expired(45),\n\
    \                 certificate_unknown(46),\n                 illegal_parameter(47),\n\
    \                 unknown_ca(48),\n                 access_denied(49),\n     \
    \            decode_error(50),\n                 decrypt_error(51),\n        \
    \         export_restriction_RESERVED(60),\n                 protocol_version(70),\n\
    \                 insufficient_security(71),\n                 internal_error(80),\n\
    \                 user_canceled(90),\n                 no_renegotiation(100),\n\
    \                 (255)\n             } AlertDescription;\n             struct\
    \ {\n                 AlertLevel level;\n                 AlertDescription description;\n\
    \             } Alert;\n"
- title: 7.2.1. Closure Alerts
  contents:
  - "7.2.1. Closure Alerts\n   The client and the server must share knowledge that\
    \ the connection is\n   ending in order to avoid a truncation attack.  Either\
    \ party may\n   initiate the exchange of closing messages.\n   close_notify\n\
    \      This message notifies the recipient that the sender will not send\n   \
    \   any more messages on this connection.  Note that as of TLS 1.1,\n      failure\
    \ to properly close a connection no longer requires that a\n      session not\
    \ be resumed.  This is a change from TLS 1.0 to conform\n      with widespread\
    \ implementation practice.\n   Either party may initiate a close by sending a\
    \ close_notify alert.\n   Any data received after a closure alert is ignored.\n\
    \   Unless some other fatal alert has been transmitted, each party is\n   required\
    \ to send a close_notify alert before closing the write side\n   of the connection.\
    \  The other party MUST respond with a close_notify\n   alert of its own and close\
    \ down the connection immediately,\n   discarding any pending writes.  It is not\
    \ required for the initiator\n   of the close to wait for the responding close_notify\
    \ alert before\n   closing the read side of the connection.\n   If the application\
    \ protocol using TLS provides that any data may be\n   carried over the underlying\
    \ transport after the TLS connection is\n   closed, the TLS implementation must\
    \ receive the responding\n   close_notify alert before indicating to the application\
    \ layer that\n   the TLS connection has ended.  If the application protocol will\
    \ not\n   transfer any additional data, but will only close the underlying\n \
    \  transport connection, then the implementation MAY choose to close the\n   transport\
    \ without waiting for the responding close_notify.  No part\n   of this standard\
    \ should be taken to dictate the manner in which a\n   usage profile for TLS manages\
    \ its data transport, including when\n   connections are opened or closed.\n \
    \  Note: It is assumed that closing a connection reliably delivers\n         pending\
    \ data before destroying the transport.\n"
- title: 7.2.2. Error Alerts
  contents:
  - "7.2.2. Error Alerts\n   Error handling in the TLS Handshake protocol is very\
    \ simple.  When an\n   error is detected, the detecting party sends a message\
    \ to the other\n   party.  Upon transmission or receipt of a fatal alert message,\
    \ both\n   parties immediately close the connection.  Servers and clients MUST\n\
    \   forget any session-identifiers, keys, and secrets associated with a\n   failed\
    \ connection.  Thus, any connection terminated with a fatal\n   alert MUST NOT\
    \ be resumed.  The following error alerts are defined:\n   unexpected_message\n\
    \      An inappropriate message was received.  This alert is always fatal\n  \
    \    and should never be observed in communication between proper\n      implementations.\n\
    \   bad_record_mac\n      This alert is returned if a record is received with\
    \ an incorrect\n      MAC.  This alert also MUST be returned if an alert is sent\
    \ because\n      a TLSCiphertext decrypted in an invalid way: either it wasn't\
    \ an\n      even multiple of the block length, or its padding values, when\n \
    \     checked, weren't correct.  This message is always fatal.\n   decryption_failed\n\
    \      This alert MAY be returned if a TLSCiphertext decrypted in an\n      invalid\
    \ way: either it wasn't an even multiple of the block\n      length, or its padding\
    \ values, when checked, weren't correct.\n      This message is always fatal.\n\
    \   Note: Differentiating between bad_record_mac and decryption_failed\n     \
    \    alerts may permit certain attacks against CBC mode as used in\n         TLS\
    \ [CBCATT].  It is preferable to uniformly use the\n         bad_record_mac alert\
    \ to hide the specific type of the error.\n   record_overflow\n         A TLSCiphertext\
    \ record was received that had a length more than\n         2^14+2048 bytes, or\
    \ a record decrypted to a TLSCompressed\n         record with more than 2^14+1024\
    \ bytes.  This message is always\n         fatal.\n   decompression_failure\n\
    \         The decompression function received improper input (e.g., data\n   \
    \      that would expand to excessive length).  This message is always\n     \
    \    fatal.\n   handshake_failure\n         Reception of a handshake_failure alert\
    \ message indicates that\n         the sender was unable to negotiate an acceptable\
    \ set of\n         security parameters given the options available.  This is a\n\
    \         fatal error.\n   no_certificate_RESERVED\n         This alert was used\
    \ in SSLv3 but not in TLS.  It should not be\n         sent by compliant implementations.\n\
    \   bad_certificate\n         A certificate was corrupt, contained signatures\
    \ that did not\n         verify correctly, etc.\n   unsupported_certificate\n\
    \         A certificate was of an unsupported type.\n   certificate_revoked\n\
    \         A certificate was revoked by its signer.\n   certificate_expired\n \
    \        A certificate has expired or is not currently valid.\n   certificate_unknown\n\
    \         Some other (unspecified) issue arose in processing the\n         certificate,\
    \ rendering it unacceptable.\n   illegal_parameter\n         A field in the handshake\
    \ was out of range or inconsistent with\n         other fields.  This is always\
    \ fatal.\n   unknown_ca\n         A valid certificate chain or partial chain was\
    \ received, but\n         the certificate was not accepted because the CA certificate\n\
    \         could not be located or couldn't be matched with a known,\n        \
    \ trusted CA.  This message is always fatal.\n   access_denied\n         A valid\
    \ certificate was received, but when access control was\n         applied, the\
    \ sender decided not to proceed with negotiation.\n         This message is always\
    \ fatal.\n   decode_error\n         A message could not be decoded because some\
    \ field was out of\n         the specified range or the length of the message\
    \ was incorrect.\n         This message is always fatal.\n   decrypt_error\n \
    \        A handshake cryptographic operation failed, including being\n       \
    \  unable to correctly verify a signature, decrypt a key exchange,\n         or\
    \ validate a finished message.\n   export_restriction_RESERVED\n         This\
    \ alert was used in TLS 1.0 but not TLS 1.1.\n   protocol_version\n         The\
    \ protocol version the client has attempted to negotiate is\n         recognized\
    \ but not supported.  (For example, old protocol\n         versions might be avoided\
    \ for security reasons).  This message\n         is always fatal.\n   insufficient_security\n\
    \         Returned instead of handshake_failure when a negotiation has\n     \
    \    failed specifically because the server requires ciphers more\n         secure\
    \ than those supported by the client.  This message is\n         always fatal.\n\
    \   internal_error\n         An internal error unrelated to the peer or the correctness\
    \ of\n         the protocol (such as a memory allocation failure) makes it\n \
    \        impossible to continue.  This message is always fatal.\n   user_canceled\n\
    \         This handshake is being canceled for some reason unrelated to a\n  \
    \       protocol failure.  If the user cancels an operation after the\n      \
    \   handshake is complete, just closing the connection by sending a\n        \
    \ close_notify is more appropriate.  This alert should be\n         followed by\
    \ a close_notify.  This message is generally a\n         warning.\n   no_renegotiation\n\
    \         Sent by the client in response to a hello request or by the\n      \
    \   server in response to a client hello after initial handshaking.\n        \
    \ Either of these would normally lead to renegotiation; when that\n         is\
    \ not appropriate, the recipient should respond with this\n         alert.  At\
    \ that point, the original requester can decide\n         whether to proceed with\
    \ the connection.  One case where this\n         would be appropriate is where\
    \ a server has spawned a process to\n         satisfy a request; the process might\
    \ receive security\n         parameters (key length, authentication, etc.) at\
    \ startup and it\n         might be difficult to communicate changes to these\
    \ parameters\n         after that point.  This message is always a warning.\n\
    \   For all errors where an alert level is not explicitly specified, the\n   sending\
    \ party MAY determine at its discretion whether this is a fatal\n   error or not;\
    \ if an alert with a level of warning is received, the\n   receiving party MAY\
    \ decide at its discretion whether to treat this as\n   a fatal error or not.\
    \  However, all messages that are transmitted\n   with a level of fatal MUST be\
    \ treated as fatal messages.\n   New alert values MUST be defined by RFC 2434\
    \ Standards Action.  See\n   Section 11 for IANA Considerations for alert values.\n"
- title: 7.3. Handshake Protocol Overview
  contents:
  - "7.3. Handshake Protocol Overview\n   The cryptographic parameters of the session\
    \ state are produced by the\n   TLS Handshake Protocol, which operates on top\
    \ of the TLS Record\n   Layer.  When a TLS client and server first start communicating,\
    \ they\n   agree on a protocol version, select cryptographic algorithms,\n   optionally\
    \ authenticate each other, and use public-key encryption\n   techniques to generate\
    \ shared secrets.\n   The TLS Handshake Protocol involves the following steps:\n\
    \   -  Exchange hello messages to agree on algorithms, exchange random\n     \
    \ values, and check for session resumption.\n   -  Exchange the necessary cryptographic\
    \ parameters to allow the\n      client and server to agree on a premaster secret.\n\
    \   -  Exchange certificates and cryptographic information to allow the\n    \
    \  client and server to authenticate themselves.\n   -  Generate a master secret\
    \ from the premaster secret and exchanged\n      random values.\n   -  Provide\
    \ security parameters to the record layer.\n   -  Allow the client and server\
    \ to verify that their peer has\n      calculated the same security parameters\
    \ and that the handshake\n      occurred without tampering by an attacker.\n \
    \  Note that higher layers should not be overly reliant on whether TLS\n   always\
    \ negotiates the strongest possible connection between two\n   peers.  There are\
    \ a number of ways in which a man-in-the-middle\n   attacker can attempt to make\
    \ two entities drop down to the least\n   secure method they support.  The protocol\
    \ has been designed to\n   minimize this risk, but there are still attacks available.\
    \  For\n   example, an attacker could block access to the port a secure service\n\
    \   runs on, or attempt to get the peers to negotiate an unauthenticated\n   connection.\
    \  The fundamental rule is that higher levels must be\n   cognizant of what their\
    \ security requirements are and never transmit\n   information over a channel\
    \ less secure than what they require.  The\n   TLS protocol is secure in that\
    \ any cipher suite offers its promised\n   level of security: if you negotiate\
    \ 3DES with a 1024 bit RSA key\n   exchange with a host whose certificate you\
    \ have verified, you can\n   expect to be that secure.\n   However, one SHOULD\
    \ never send data over a link encrypted with 40-bit\n   security unless one feels\
    \ that data is worth no more than the effort\n   required to break that encryption.\n\
    \   These goals are achieved by the handshake protocol, which can be\n   summarized\
    \ as follows: The client sends a client hello message to\n   which the server\
    \ must respond with a server hello message, or else a\n   fatal error will occur\
    \ and the connection will fail.  The client\n   hello and server hello are used\
    \ to establish security enhancement\n   capabilities between client and server.\
    \  The client hello and server\n   hello establish the following attributes: Protocol\
    \ Version, Session\n   ID, Cipher Suite, and Compression Method.  Additionally,\
    \ two random\n   values are generated and exchanged: ClientHello.random and\n\
    \   ServerHello.random.\n   The actual key exchange uses up to four messages:\
    \ the server\n   certificate, the server key exchange, the client certificate,\
    \ and the\n   client key exchange.  New key exchange methods can be created by\n\
    \   specifying a format for these messages and by defining the use of the\n  \
    \ messages to allow the client and server to agree upon a shared\n   secret. \
    \ This secret MUST be quite long; currently defined key\n   exchange methods exchange\
    \ secrets that range from 48 to 128 bytes in\n   length.\n   Following the hello\
    \ messages, the server will send its certificate,\n   if it is to be authenticated.\
    \  Additionally, a server key exchange\n   message may be sent, if it is required\
    \ (e.g., if the server has no\n   certificate, or if its certificate is for signing\
    \ only).  If the\n   server is authenticated, it may request a certificate from\
    \ the\n   client, if that is appropriate to the cipher suite selected.  Next,\n\
    \   the server will send the server hello done message, indicating that\n   the\
    \ hello-message phase of the handshake is complete.  The server\n   will then\
    \ wait for a client response.  If the server has sent a\n   certificate request\
    \ message, the client must send the certificate\n   message.  The client key exchange\
    \ message is now sent, and the\n   content of that message will depend on the\
    \ public key algorithm\n   selected between the client hello and the server hello.\
    \  If the\n   client has sent a certificate with signing ability, a digitally-\n\
    \   signed certificate verify message is sent to explicitly verify the\n   certificate.\n\
    \   At this point, a change cipher spec message is sent by the client,\n   and\
    \ the client copies the pending Cipher Spec into the current Cipher\n   Spec.\
    \  The client then immediately sends the finished message under\n   the new algorithms,\
    \ keys, and secrets.  In response, the server will\n   send its own change cipher\
    \ spec message, transfer the pending to the\n   current Cipher Spec, and send\
    \ its finished message under the new\n   Cipher Spec.  At this point, the handshake\
    \ is complete, and the\n   client and server may begin to exchange application\
    \ layer data.  (See\n   flow chart below.)  Application data MUST NOT be sent\
    \ prior to the\n   completion of the first handshake (before a cipher suite other\n\
    \   TLS_NULL_WITH_NULL_NULL is established).\n      Client                   \
    \                            Server\n      ClientHello                  -------->\n\
    \                                                      ServerHello\n         \
    \                                            Certificate*\n                  \
    \                             ServerKeyExchange*\n                           \
    \                   CertificateRequest*\n                                   <--------\
    \      ServerHelloDone\n      Certificate*\n      ClientKeyExchange\n      CertificateVerify*\n\
    \      [ChangeCipherSpec]\n      Finished                     -------->\n    \
    \                                           [ChangeCipherSpec]\n             \
    \                      <--------             Finished\n      Application Data\
    \             <------->     Application Data\n             Fig. 1. Message flow\
    \ for a full handshake\n      * Indicates optional or situation-dependent messages\
    \ that are not\n        always sent.\n   Note: To help avoid pipeline stalls,\
    \ ChangeCipherSpec is an\n         independent TLS Protocol content type, and\
    \ is not actually a\n         TLS handshake message.\n   When the client and server\
    \ decide to resume a previous session or\n   duplicate an existing session (instead\
    \ of negotiating new security\n   parameters), the message flow is as follows:\n\
    \   The client sends a ClientHello using the Session ID of the session to\n  \
    \ be resumed.  The server then checks its session cache for a match.\n   If a\
    \ match is found, and the server is willing to re-establish the\n   connection\
    \ under the specified session state, it will send a\n   ServerHello with the same\
    \ Session ID value.  At this point, both\n   client and server MUST send change\
    \ cipher spec messages and proceed\n   directly to finished messages.  Once the\
    \ re-establishment is\n   complete, the client and server MAY begin to exchange\
    \ application\n   layer data.  (See flow chart below.)  If a Session ID match\
    \ is not\n   found, the server generates a new session ID and the TLS client and\n\
    \   server perform a full handshake.\n      Client                           \
    \                     Server\n      ClientHello                   -------->\n\
    \                                                       ServerHello\n        \
    \                                        [ChangeCipherSpec]\n                \
    \                    <--------             Finished\n      [ChangeCipherSpec]\n\
    \      Finished                      -------->\n      Application Data       \
    \       <------->     Application Data\n          Fig. 2. Message flow for an\
    \ abbreviated handshake\n   The contents and significance of each message will\
    \ be presented in\n   detail in the following sections.\n"
- title: 7.4. Handshake Protocol
  contents:
  - "7.4. Handshake Protocol\n   The TLS Handshake Protocol is one of the defined\
    \ higher-level clients\n   of the TLS Record Protocol.  This protocol is used\
    \ to negotiate the\n   secure attributes of a session.  Handshake messages are\
    \ supplied to\n   the TLS Record Layer, where they are encapsulated within one\
    \ or more\n   TLSPlaintext structures, which are processed and transmitted as\n\
    \   specified by the current active session state.\n      enum {\n          hello_request(0),\
    \ client_hello(1), server_hello(2),\n          certificate(11), server_key_exchange\
    \ (12),\n          certificate_request(13), server_hello_done(14),\n         \
    \ certificate_verify(15), client_key_exchange(16),\n          finished(20), (255)\n\
    \      } HandshakeType;\n      struct {\n          HandshakeType msg_type;   \
    \ /* handshake type */\n          uint24 length;             /* bytes in message\
    \ */\n          select (HandshakeType) {\n              case hello_request:  \
    \     HelloRequest;\n              case client_hello:        ClientHello;\n  \
    \            case server_hello:        ServerHello;\n              case certificate:\
    \         Certificate;\n              case server_key_exchange: ServerKeyExchange;\n\
    \              case certificate_request: CertificateRequest;\n              case\
    \ server_hello_done:   ServerHelloDone;\n              case certificate_verify:\
    \  CertificateVerify;\n              case client_key_exchange: ClientKeyExchange;\n\
    \              case finished:            Finished;\n          } body;\n      }\
    \ Handshake;\n   The handshake protocol messages are presented below in the order\
    \ they\n   MUST be sent; sending handshake messages in an unexpected order\n \
    \  results in a fatal error.  Unneeded handshake messages can be\n   omitted,\
    \ however.  Note one exception to the ordering: the\n   Certificate message is\
    \ used twice in the handshake (from server to\n   client, then from client to\
    \ server), but is described only in its\n   first position.  The one message that\
    \ is not bound by these ordering\n   rules is the Hello Request message, which\
    \ can be sent at any time,\n   but which should be ignored by the client if it\
    \ arrives in the middle\n   of a handshake.\n   New Handshake message type values\
    \ MUST be defined via RFC 2434\n   Standards Action.  See Section 11 for IANA\
    \ Considerations for these\n   values.\n"
- title: 7.4.1. Hello Messages
  contents:
  - "7.4.1. Hello Messages\n   The hello phase messages are used to exchange security\
    \ enhancement\n   capabilities between the client and server.  When a new session\n\
    \   begins, the Record Layer's connection state encryption, hash, and\n   compression\
    \ algorithms are initialized to null.  The current\n   connection state is used\
    \ for renegotiation messages.\n"
- title: 7.4.1.1. Hello request
  contents:
  - "7.4.1.1. Hello request\n   When this message will be sent:\n      The hello request\
    \ message MAY be sent by the server at any time.\n   Meaning of this message:\n\
    \      Hello request is a simple notification that the client should\n      begin\
    \ the negotiation process anew by sending a client hello\n      message when convenient.\
    \  This message will be ignored by the\n      client if the client is currently\
    \ negotiating a session.  This\n      message may be ignored by the client if\
    \ it does not wish to\n      renegotiate a session, or the client may, if it wishes,\
    \ respond\n      with a no_renegotiation alert.  Since handshake messages are\n\
    \      intended to have transmission precedence over application data, it\n  \
    \    is expected that the negotiation will begin before no more than a\n     \
    \ few records are received from the client.  If the server sends a\n      hello\
    \ request but does not receive a client hello in response, it\n      may close\
    \ the connection with a fatal alert.\n      After sending a hello request, servers\
    \ SHOULD not repeat the\n      request until the subsequent handshake negotiation\
    \ is complete.\n         Structure of this message:\n             struct { } HelloRequest;\n\
    \   Note: This message MUST NOT be included in the message hashes that\n     \
    \    are maintained throughout the handshake and used in the\n         finished\
    \ messages and the certificate verify message.\n"
- title: 7.4.1.2. Client Hello
  contents:
  - "7.4.1.2. Client Hello\n   When this message will be sent:\n      When a client\
    \ first connects to a server it is required to send\n      the client hello as\
    \ its first message.  The client can also send a\n      client hello in response\
    \ to a hello request or on its own\n      initiative in order to renegotiate the\
    \ security parameters in an\n      existing connection.\n   Structure of this\
    \ message:\n      The client hello message includes a random structure, which\
    \ is\n      used later in the protocol.\n      struct {\n         uint32 gmt_unix_time;\n\
    \         opaque random_bytes[28];\n      } Random;\n   gmt_unix_time The current\
    \ time and date in standard UNIX 32-bit\n      format (seconds since the midnight\
    \ starting Jan 1, 1970, GMT,\n      ignoring leap seconds) according to the sender's\
    \ internal clock.\n      Clocks are not required to be set correctly by the basic\
    \ TLS\n      Protocol; higher-level or application protocols may define\n    \
    \  additional requirements.\n         random_bytes\n             28 bytes generated\
    \ by a secure random number generator.\n   The client hello message includes a\
    \ variable-length session\n   identifier.  If not empty, the value identifies\
    \ a session between the\n   same client and server whose security parameters the\
    \ client wishes to\n   reuse.  The session identifier MAY be from an earlier connection,\n\
    \   from this connection, or from another currently active connection.\n   The\
    \ second option is useful if the client only wishes to update the\n   random structures\
    \ and derived values of a connection, and the third\n   option makes it possible\
    \ to establish several independent secure\n   connections without repeating the\
    \ full handshake protocol.  These\n   independent connections may occur sequentially\
    \ or simultaneously; a\n   SessionID becomes valid when the handshake negotiating\
    \ it completes\n   with the exchange of Finished messages and persists until it\
    \ is\n   removed due to aging or because a fatal error was encountered on a\n\
    \   connection associated with the session.  The actual contents of the\n   SessionID\
    \ are defined by the server.\n      opaque SessionID<0..32>;\n   Warning: Because\
    \ the SessionID is transmitted without encryption or\n            immediate MAC\
    \ protection, servers MUST not place\n            confidential information in\
    \ session identifiers or let the\n            contents of fake session identifiers\
    \ cause any breach of\n            security.  (Note that the content of the handshake\
    \ as a\n            whole, including the SessionID, is protected by the Finished\n\
    \            messages exchanged at the end of the handshake.)\n   The CipherSuite\
    \ list, passed from the client to the server in the\n   client hello message,\
    \ contains the combinations of cryptographic\n   algorithms supported by the client\
    \ in order of the client's\n   preference (favorite choice first).  Each CipherSuite\
    \ defines a key\n   exchange algorithm, a bulk encryption algorithm (including\
    \ secret key\n   length), and a MAC algorithm.  The server will select a cipher\
    \ suite\n   or, if no acceptable choices are presented, return a handshake\n \
    \  failure alert and close the connection.\n      uint8 CipherSuite[2];    /*\
    \ Cryptographic suite selector */\n   The client hello includes a list of compression\
    \ algorithms supported\n   by the client, ordered according to the client's preference.\n\
    \      enum { null(0), (255) } CompressionMethod;\n      struct {\n          ProtocolVersion\
    \ client_version;\n          Random random;\n          SessionID session_id;\n\
    \          CipherSuite cipher_suites<2..2^16-1>;\n          CompressionMethod\
    \ compression_methods<1..2^8-1>;\n      } ClientHello;\n   client_version\n  \
    \    The version of the TLS protocol by which the client wishes to\n      communicate\
    \ during this session.  This SHOULD be the latest\n      (highest valued) version\
    \ supported by the client.  For this\n      version of the specification, the\
    \ version will be 3.2.  (See\n      Appendix E for details about backward compatibility.)\n\
    \   random\n      A client-generated random structure.\n   session_id\n      The\
    \ ID of a session the client wishes to use for this connection.\n      This field\
    \ should be empty if no session_id is available or if the\n      client wishes\
    \ to generate new security parameters.\n   cipher_suites\n      This is a list\
    \ of the cryptographic options supported by the\n      client, with the client's\
    \ first preference first.  If the\n      session_id field is not empty (implying\
    \ a session resumption\n      request) this vector MUST include at least the cipher_suite\
    \ from\n      that session.  Values are defined in Appendix A.5.\n   compression_methods\n\
    \      This is a list of the compression methods supported by the client,\n  \
    \    sorted by client preference.  If the session_id field is not empty\n    \
    \  (implying a session resumption request) it MUST include the\n      compression_method\
    \ from that session.  This vector MUST contain,\n      and all implementations\
    \ MUST support, CompressionMethod.null.\n      Thus, a client and server will\
    \ always be able to agree on a\n      compression method.\n   After sending the\
    \ client hello message, the client waits for a server\n   hello message.  Any\
    \ other handshake message returned by the server\n   except for a hello request\
    \ is treated as a fatal error.\n   Forward compatibility note:  In the interests\
    \ of forward\n   compatibility, it is permitted that a client hello message include\n\
    \   extra data after the compression methods.  This data MUST be included\n  \
    \ in the handshake hashes, but must otherwise be ignored.  This is the\n   only\
    \ handshake message for which this is legal; for all other\n   messages, the amount\
    \ of data in the message MUST match the\n   description of the message precisely.\n\
    \      Note: For the intended use of trailing data in the ClientHello,\n     \
    \    see RFC 3546 [TLSEXT].\n"
- title: 7.4.1.3. Server Hello
  contents:
  - "7.4.1.3. Server Hello\n   The server will send this message in response to a\
    \ client hello\n   message when it was able to find an acceptable set of algorithms.\
    \  If\n   it cannot find such a match, it will respond with a handshake failure\n\
    \   alert.\n   Structure of this message:\n       struct {\n           ProtocolVersion\
    \ server_version;\n           Random random;\n           SessionID session_id;\n\
    \           CipherSuite cipher_suite;\n           CompressionMethod compression_method;\n\
    \       } ServerHello;\n   server_version\n      This field will contain the lower\
    \ of that suggested by the client\n      in the client hello and the highest supported\
    \ by the server.  For\n      this version of the specification, the version is\
    \ 3.2.  (See\n      Appendix E for details about backward compatibility.)\n  \
    \ random\n      This structure is generated by the server and MUST be\n      independently\
    \ generated from the ClientHello.random.\n   session_id\n      This is the identity\
    \ of the session corresponding to this\n      connection.  If the ClientHello.session_id\
    \ was non-empty, the\n      server will look in its session cache for a match.\
    \  If a match is\n      found and the server is willing to establish the new connection\n\
    \      using the specified session state, the server will respond with\n     \
    \ the same value as was supplied by the client.  This indicates a\n      resumed\
    \ session and dictates that the parties must proceed\n      directly to the finished\
    \ messages.  Otherwise this field will\n      contain a different value identifying\
    \ the new session.  The server\n      may return an empty session_id to indicate\
    \ that the session will\n      not be cached and therefore cannot be resumed.\
    \  If a session is\n      resumed, it must be resumed using the same cipher suite\
    \ it was\n      originally negotiated with.\n   cipher_suite\n      The single\
    \ cipher suite selected by the server from the list in\n      ClientHello.cipher_suites.\
    \  For resumed sessions, this field is\n      the value from the state of the\
    \ session being resumed.\n   compression_method The single compression algorithm\
    \ selected by the\n      server from the list in ClientHello.compression_methods.\
    \  For\n      resumed sessions this field is the value from the resumed session\n\
    \      state.\n"
- title: 7.4.2. Server Certificate
  contents:
  - "7.4.2. Server Certificate\n   When this message will be sent:\n      The server\
    \ MUST send a certificate whenever the agreed-upon key\n      exchange method\
    \ is not an anonymous one.  This message will always\n      immediately follow\
    \ the server hello message.\n   Meaning of this message:\n      The certificate\
    \ type MUST be appropriate for the selected cipher\n      suite's key exchange\
    \ algorithm, and is generally an X.509v3\n      certificate.  It MUST contain\
    \ a key that matches the key exchange\n      method, as follows.  Unless otherwise\
    \ specified, the signing\n      algorithm for the certificate MUST be the same\
    \ as the algorithm\n      for the certificate key.  Unless otherwise specified,\
    \ the public\n      key MAY be of any length.\n      Key Exchange Algorithm  Certificate\
    \ Key Type\n      RSA                     RSA public key; the certificate MUST\n\
    \                              allow the key to be used for encryption.\n    \
    \  DHE_DSS                 DSS public key.\n      DHE_RSA                 RSA\
    \ public key that can be used for\n                              signing.\n  \
    \    DH_DSS                  Diffie-Hellman key. The algorithm used\n        \
    \                      to sign the certificate MUST be DSS.\n      DH_RSA    \
    \              Diffie-Hellman key. The algorithm used\n                      \
    \        to sign the certificate MUST be RSA.\n   All certificate profiles and\
    \ key and cryptographic formats are\n   defined by the IETF PKIX working group\
    \ [PKIX].  When a key usage\n   extension is present, the digitalSignature bit\
    \ MUST be set for the\n   key to be eligible for signing, as described above,\
    \ and the\n   keyEncipherment bit MUST be present to allow encryption, as described\n\
    \   above.  The keyAgreement bit must be set on Diffie-Hellman\n   certificates.\n\
    \   As CipherSuites that specify new key exchange methods are specified\n   for\
    \ the TLS Protocol, they will imply certificate format and the\n   required encoded\
    \ keying information.\n   Structure of this message:\n      opaque ASN.1Cert<1..2^24-1>;\n\
    \      struct {\n          ASN.1Cert certificate_list<0..2^24-1>;\n      } Certificate;\n\
    \   certificate_list\n      This is a sequence (chain) of X.509v3 certificates.\
    \  The sender's\n      certificate must come first in the list.  Each following\n\
    \      certificate must directly certify the one preceding it.  Because\n    \
    \  certificate validation requires that root keys be distributed\n      independently,\
    \ the self-signed certificate that specifies the root\n      certificate authority\
    \ may optionally be omitted from the chain,\n      under the assumption that the\
    \ remote end must already possess it\n      in order to validate it in any case.\n\
    \   The same message type and structure will be used for the client's\n   response\
    \ to a certificate request message.  Note that a client MAY\n   send no certificates\
    \ if it does not have an appropriate certificate\n   to send in response to the\
    \ server's authentication request.\n      Note: PKCS #7 [PKCS7] is not used as\
    \ the format for the\n         certificate vector because PKCS #6 [PKCS6] extended\n\
    \         certificates are not used.  Also, PKCS #7 defines a SET rather\n   \
    \      than a SEQUENCE, making the task of parsing the list more\n         difficult.\n"
- title: 7.4.3. Server Key Exchange Message
  contents:
  - "7.4.3. Server Key Exchange Message\n   When this message will be sent:\n    \
    \  This message will be sent immediately after the server certificate\n      message\
    \ (or the server hello message, if this is an anonymous\n      negotiation).\n\
    \      The server key exchange message is sent by the server only when\n     \
    \ the server certificate message (if sent) does not contain enough\n      data\
    \ to allow the client to exchange a premaster secret.  This is\n      true for\
    \ the following key exchange methods:\n           DHE_DSS\n           DHE_RSA\n\
    \           DH_anon\n      It is not legal to send the server key exchange message\
    \ for the\n      following key exchange methods:\n           RSA\n           DH_DSS\n\
    \           DH_RSA\n   Meaning of this message:\n      This message conveys cryptographic\
    \ information to allow the client\n      to communicate the premaster secret:\
    \ either an RSA public key with\n      which to encrypt the premaster secret,\
    \ or a Diffie-Hellman public\n      key with which the client can complete a key\
    \ exchange (with the\n      result being the premaster secret).\n   As additional\
    \ CipherSuites are defined for TLS that include new key\n   exchange algorithms,\
    \ the server key exchange message will be sent if\n   and only if the certificate\
    \ type associated with the key exchange\n   algorithm does not provide enough\
    \ information for the client to\n   exchange a premaster secret.\n   Structure\
    \ of this message:\n      enum { rsa, diffie_hellman } KeyExchangeAlgorithm;\n\
    \      struct {\n          opaque rsa_modulus<1..2^16-1>;\n          opaque rsa_exponent<1..2^16-1>;\n\
    \      } ServerRSAParams;\n      rsa_modulus\n          The modulus of the server's\
    \ temporary RSA key.\n      rsa_exponent\n          The public exponent of the\
    \ server's temporary RSA key.\n      struct {\n          opaque dh_p<1..2^16-1>;\n\
    \          opaque dh_g<1..2^16-1>;\n          opaque dh_Ys<1..2^16-1>;\n     \
    \ } ServerDHParams;     /* Ephemeral DH parameters */\n      dh_p\n          The\
    \ prime modulus used for the Diffie-Hellman operation.\n      dh_g\n         \
    \ The generator used for the Diffie-Hellman operation.\n      dh_Ys\n        The\
    \ server's Diffie-Hellman public value (g^X mod p).\n      struct {\n        \
    \  select (KeyExchangeAlgorithm) {\n              case diffie_hellman:\n     \
    \             ServerDHParams params;\n                  Signature signed_params;\n\
    \              case rsa:\n                  ServerRSAParams params;\n        \
    \          Signature signed_params;\n          };\n      } ServerKeyExchange;\n\
    \      struct {\n          select (KeyExchangeAlgorithm) {\n              case\
    \ diffie_hellman:\n                  ServerDHParams params;\n              case\
    \ rsa:\n                  ServerRSAParams params;\n          };\n       } ServerParams;\n\
    \      params\n          The server's key exchange parameters.\n      signed_params\n\
    \          For non-anonymous key exchanges, a hash of the corresponding\n    \
    \      params value, with the signature appropriate to that hash\n          applied.\n\
    \      md5_hash\n          MD5(ClientHello.random + ServerHello.random + ServerParams);\n\
    \      sha_hash\n          SHA(ClientHello.random + ServerHello.random + ServerParams);\n\
    \      enum { anonymous, rsa, dsa } SignatureAlgorithm;\n      struct {\n    \
    \      select (SignatureAlgorithm) {\n              case anonymous: struct { };\n\
    \              case rsa:\n                  digitally-signed struct {\n      \
    \                opaque md5_hash[16];\n                      opaque sha_hash[20];\n\
    \                  };\n              case dsa:\n                  digitally-signed\
    \ struct {\n                      opaque sha_hash[20];\n                  };\n\
    \              };\n          };\n      } Signature;\n"
- title: 7.4.4. Certificate request
  contents:
  - "7.4.4. Certificate request\n   When this message will be sent:\n      A non-anonymous\
    \ server can optionally request a certificate from\n      the client, if it is\
    \ appropriate for the selected cipher suite.\n      This message, if sent, will\
    \ immediately follow the Server Key\n      Exchange message (if it is sent; otherwise,\
    \ the Server Certificate\n      message).\n   Structure of this message:\n   \
    \   enum {\n          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n\
    \       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n       fortezza_dms_RESERVED(20),\n\
    \          (255)\n      } ClientCertificateType;\n      opaque DistinguishedName<1..2^16-1>;\n\
    \      struct {\n          ClientCertificateType certificate_types<1..2^8-1>;\n\
    \          DistinguishedName certificate_authorities<0..2^16-1>;\n      } CertificateRequest;\n\
    \      certificate_types\n         This field is a list of the types of certificates\
    \ requested,\n         sorted in order of the server's preference.\n      certificate_authorities\n\
    \         A list of the distinguished names of acceptable certificate\n      \
    \   authorities.  These distinguished names may specify a desired\n         distinguished\
    \ name for a root CA or for a subordinate CA; thus,\n         this message can\
    \ be used to describe both known roots and a\n         desired authorization space.\
    \  If the certificate_authorities\n         list is empty then the client MAY\
    \ send any certificate of the\n         appropriate ClientCertificateType, unless\
    \ there is some\n         external arrangement to the contrary.\n   ClientCertificateType\
    \ values are divided into three groups:\n      1. Values from 0 (zero) through\
    \ 63 decimal (0x3F) inclusive are\n         reserved for IETF Standards Track\
    \ protocols.\n      2. Values from 64 decimal (0x40) through 223 decimal (0xDF)\n\
    \         inclusive are reserved for assignment for non-Standards Track\n    \
    \     methods.\n      3. Values from 224 decimal (0xE0) through 255 decimal (0xFF)\n\
    \         inclusive are reserved for private use.\n   Additional information describing\
    \ the role of IANA in the allocation\n   of ClientCertificateType code points\
    \ is described in Section 11.\n   Note: Values listed as RESERVED may not be used.\
    \  They were used in\n         SSLv3.\n   Note: DistinguishedName is derived from\
    \ [X501].  DistinguishedNames\n         are represented in DER-encoded format.\n\
    \   Note: It is a fatal handshake_failure alert for an anonymous server\n    \
    \     to request client authentication.\n"
- title: 7.4.5. Server Hello Done
  contents:
  - "7.4.5. Server Hello Done\n   When this message will be sent:\n      The server\
    \ hello done message is sent by the server to indicate\n      the end of the server\
    \ hello and associated messages.  After\n      sending this message, the server\
    \ will wait for a client response.\n   Meaning of this message:\n      This message\
    \ means that the server is done sending messages to\n      support the key exchange,\
    \ and the client can proceed with its\n      phase of the key exchange.\n    \
    \  Upon receipt of the server hello done message, the client SHOULD\n      verify\
    \ that the server provided a valid certificate, if required\n      and check that\
    \ the server hello parameters are acceptable.\n   Structure of this message:\n\
    \      struct { } ServerHelloDone;\n"
- title: 7.4.6. Client certificate
  contents:
  - "7.4.6. Client certificate\n   When this message will be sent:\n      This is\
    \ the first message the client can send after receiving a\n      server hello\
    \ done message.  This message is only sent if the\n      server requests a certificate.\
    \  If no suitable certificate is\n      available, the client SHOULD send a certificate\
    \ message containing\n      no certificates.  That is, the certificate_list structure\
    \ has a\n      length of zero.  If client authentication is required by the\n\
    \      server for the handshake to continue, it may respond with a fatal\n   \
    \   handshake failure alert.  Client certificates are sent using the\n      Certificate\
    \ structure defined in Section 7.4.2.\n   Note: When using a static Diffie-Hellman\
    \ based key exchange method\n      (DH_DSS or DH_RSA), if client authentication\
    \ is requested, the\n      Diffie-Hellman group and generator encoded in the client's\n\
    \      certificate MUST match the server specified Diffie-Hellman\n      parameters\
    \ if the client's parameters are to be used for the key\n      exchange.\n"
- title: 7.4.7. Client Key Exchange Message
  contents:
  - "7.4.7. Client Key Exchange Message\n   When this message will be sent:\n    \
    \  This message is always sent by the client.  It MUST immediately\n      follow\
    \ the client certificate message, if it is sent.  Otherwise\n      it MUST be\
    \ the first message sent by the client after it receives\n      the server hello\
    \ done message.\n   Meaning of this message:\n      With this message, the premaster\
    \ secret is set, either though\n      direct transmission of the RSA-encrypted\
    \ secret or by the\n      transmission of Diffie-Hellman parameters that will\
    \ allow each\n      side to agree upon the same premaster secret.  When the key\n\
    \      exchange method is DH_RSA or DH_DSS, client certification has been\n  \
    \    requested, and the client was able to respond with a certificate\n      that\
    \ contained a Diffie-Hellman public key whose parameters (group\n      and generator)\
    \ matched those specified by the server in its\n      certificate, this message\
    \ MUST not contain any data.\n   Structure of this message:\n      The choice\
    \ of messages depends on which key exchange method has\n      been selected. \
    \ See Section 7.4.3 for the KeyExchangeAlgorithm\n      definition.\n      struct\
    \ {\n          select (KeyExchangeAlgorithm) {\n              case rsa: EncryptedPreMasterSecret;\n\
    \              case diffie_hellman: ClientDiffieHellmanPublic;\n          } exchange_keys;\n\
    \      } ClientKeyExchange;\n"
- title: 7.4.7.1. RSA Encrypted Premaster Secret Message
  contents:
  - "7.4.7.1. RSA Encrypted Premaster Secret Message\n   Meaning of this message:\n\
    \      If RSA is being used for key agreement and authentication, the\n      client\
    \ generates a 48-byte premaster secret, encrypts it using the\n      public key\
    \ from the server's certificate or the temporary RSA key\n      provided in a\
    \ server key exchange message, and sends the result in\n      an encrypted premaster\
    \ secret message.  This structure is a\n      variant of the client key exchange\
    \ message and is not a message in\n      itself.\n   Structure of this message:\n\
    \      struct {\n          ProtocolVersion client_version;\n          opaque random[46];\n\
    \      } PreMasterSecret;\n      client_version The latest (newest) version supported\
    \ by the\n         client.  This is used to detect version roll-back attacks.\n\
    \         Upon receiving the premaster secret, the server SHOULD check\n     \
    \    that this value matches the value transmitted by the client in\n        \
    \ the client hello message.\n      random\n          46 securely-generated random\
    \ bytes.\n      struct {\n          public-key-encrypted PreMasterSecret pre_master_secret;\n\
    \      } EncryptedPreMasterSecret;\n      pre_master_secret\n          This random\
    \ value is generated by the client and is used to\n          generate the master\
    \ secret, as specified in Section 8.1.\n   Note: An attack discovered by Daniel\
    \ Bleichenbacher [BLEI] can be\n         used to attack a TLS server that is using\
    \ PKCS#1 v 1.5 encoded\n         RSA.  The attack takes advantage of the fact\
    \ that, by failing\n         in different ways, a TLS server can be coerced into\
    \ revealing\n         whether a particular message, when decrypted, is properly\n\
    \         PKCS#1 v1.5 formatted or not.\n         The best way to avoid vulnerability\
    \ to this attack is to treat\n         incorrectly formatted messages in a manner\
    \ indistinguishable\n         from correctly formatted RSA blocks.  Thus, when\
    \ a server\n         receives an incorrectly formatted RSA block, it should generate\n\
    \         a random 48-byte value and proceed using it as the premaster\n     \
    \    secret.  Thus, the server will act identically whether the\n         received\
    \ RSA block is correctly encoded or not.\n         [PKCS1B] defines a newer version\
    \ of PKCS#1 encoding that is\n         more secure against the Bleichenbacher\
    \ attack.  However, for\n         maximal compatibility with TLS 1.0, TLS 1.1\
    \ retains the\n         original encoding.  No variants of the Bleichenbacher\
    \ attack\n         are known to exist provided that the above recommendations\
    \ are\n         followed.\n   Implementation Note: Public-key-encrypted data is\
    \ represented as an\n                        opaque vector <0..2^16-1> (see Section\
    \ 4.7).\n                        Thus, the RSA-encrypted PreMasterSecret in a\n\
    \                        ClientKeyExchange is preceded by two length\n       \
    \                 bytes.  These bytes are redundant in the case of\n         \
    \               RSA because the EncryptedPreMasterSecret is the\n            \
    \            only data in the ClientKeyExchange and its\n                    \
    \    length can therefore be unambiguously\n                        determined.\
    \  The SSLv3 specification was not\n                        clear about the encoding\
    \ of public-key-encrypted\n                        data, and therefore many SSLv3\
    \ implementations\n                        do not include the length bytes, encoding\
    \ the\n                        RSA encrypted data directly in the\n          \
    \              ClientKeyExchange message.\n                        This specification\
    \ requires correct encoding of\n                        the EncryptedPreMasterSecret\
    \ complete with\n                        length bytes.  The resulting PDU is incompatible\n\
    \                        with many SSLv3 implementations.  Implementors\n    \
    \                    upgrading from SSLv3 must modify their\n                \
    \        implementations to generate and accept the\n                        correct\
    \ encoding.  Implementors who wish to be\n                        compatible with\
    \ both SSLv3 and TLS should make\n                        their implementation's\
    \ behavior dependent on the\n                        protocol version.\n   Implementation\
    \ Note: It is now known that remote timing-based attacks\n                   \
    \     on SSL are possible, at least when the client\n                        and\
    \ server are on the same LAN.  Accordingly,\n                        implementations\
    \ that use static RSA keys SHOULD\n                        use RSA blinding or\
    \ some other anti-timing\n                        technique, as described in [TIMING].\n\
    \   Note: The version number in the PreMasterSecret MUST be the version\n    \
    \     offered by the client in the ClientHello, not the version\n         negotiated\
    \ for the connection.  This feature is designed to\n         prevent rollback\
    \ attacks.  Unfortunately, many implementations\n         use the negotiated version\
    \ instead, and therefore checking the\n         version number may lead to failure\
    \ to interoperate with such\n         incorrect client implementations.  Client\
    \ implementations, MUST\n         and Server implementations MAY, check the version\
    \ number.  In\n         practice, since the TLS handshake MACs prevent downgrade\
    \ and no\n         good attacks are known on those MACs, ambiguity is not\n  \
    \       considered a serious security risk.  Note that if servers\n         choose\
    \ to check the version number, they should randomize the\n         PreMasterSecret\
    \ in case of error, rather than generate an\n         alert, in order to avoid\
    \ variants on the Bleichenbacher attack.\n         [KPR03]\n"
- title: 7.4.7.2. Client Diffie-Hellman Public Value
  contents:
  - "7.4.7.2. Client Diffie-Hellman Public Value\n   Meaning of this message:\n  \
    \    This structure conveys the client's Diffie-Hellman public value\n      (Yc)\
    \ if it was not already included in the client's certificate.\n      The encoding\
    \ used for Yc is determined by the enumerated\n      PublicValueEncoding.  This\
    \ structure is a variant of the client\n      key exchange message and not a message\
    \ in itself.\n   Structure of this message:\n      enum { implicit, explicit }\
    \ PublicValueEncoding;\n      implicit\n          If the client certificate already\
    \ contains a suitable Diffie-\n          Hellman key, then Yc is implicit and\
    \ does not need to be sent\n          again.  In this case, the client key exchange\
    \ message will be\n          sent, but it MUST be empty.\n      explicit\n   \
    \       Yc needs to be sent.\n      struct {\n          select (PublicValueEncoding)\
    \ {\n              case implicit: struct { };\n              case explicit: opaque\
    \ dh_Yc<1..2^16-1>;\n          } dh_public;\n      } ClientDiffieHellmanPublic;\n\
    \      dh_Yc\n          The client's Diffie-Hellman public value (Yc).\n"
- title: 7.4.8. Certificate verify
  contents:
  - "7.4.8. Certificate verify\n   When this message will be sent:\n      This message\
    \ is used to provide explicit verification of a client\n      certificate.  This\
    \ message is only sent following a client\n      certificate that has signing\
    \ capability (i.e., all certificates\n      except those containing fixed Diffie-Hellman\
    \ parameters).  When\n      sent, it MUST immediately follow the client key exchange\
    \ message.\n   Structure of this message:\n      struct {\n           Signature\
    \ signature;\n      } CertificateVerify;\n      The Signature type is defined\
    \ in 7.4.3.\n      CertificateVerify.signature.md5_hash\n          MD5(handshake_messages);\n\
    \      CertificateVerify.signature.sha_hash\n          SHA(handshake_messages);\n\
    \   Here handshake_messages refers to all handshake messages sent or\n   received\
    \ starting at client hello up to but not including this\n   message, including\
    \ the type and length fields of the handshake\n   messages.  This is the concatenation\
    \ of all the Handshake structures,\n   as defined in 7.4, exchanged thus far.\n"
- title: 7.4.9. Finished
  contents:
  - "7.4.9. Finished\n   When this message will be sent:\n      A finished message\
    \ is always sent immediately after a change\n      cipher spec message to verify\
    \ that the key exchange and\n      authentication processes were successful. \
    \ It is essential that a\n      change cipher spec message be received between\
    \ the other handshake\n      messages and the Finished message.\n   Meaning of\
    \ this message:\n      The finished message is the first protected with the just-\n\
    \      negotiated algorithms, keys, and secrets.  Recipients of finished\n   \
    \   messages MUST verify that the contents are correct.  Once a side\n      has\
    \ sent its Finished message and received and validated the\n      Finished message\
    \ from its peer, it may begin to send and receive\n      application data over\
    \ the connection.\n      struct {\n          opaque verify_data[12];\n      }\
    \ Finished;\n      verify_data\n          PRF(master_secret, finished_label, MD5(handshake_messages)\
    \ +\n          SHA-1(handshake_messages)) [0..11];\n      finished_label\n   \
    \       For Finished messages sent by the client, the string \"client\n      \
    \    finished\".  For Finished messages sent by the server, the\n          string\
    \ \"server finished\".\n      handshake_messages\n          All of the data from\
    \ all messages in this handshake (not\n          including any HelloRequest messages)\
    \ up to but not including\n          this message.  This is only data visible\
    \ at the handshake\n          layer and does not include record layer headers.\
    \  This is the\n          concatenation of all the Handshake structures, as defined\
    \ in\n          7.4, exchanged thus far.\n   It is a fatal error if a finished\
    \ message is not preceded by a change\n   cipher spec message at the appropriate\
    \ point in the handshake.\n   The value handshake_messages includes all handshake\
    \ messages starting\n   at client hello up to, but not including, this finished\
    \ message.\n   This may be different from handshake_messages in Section 7.4.8\n\
    \   because it would include the certificate verify message (if sent).\n   Also,\
    \ the handshake_messages for the finished message sent by the\n   client will\
    \ be different from that for the finished message sent by\n   the server, because\
    \ the one that is sent second will include the\n   prior one.\n   Note: Change\
    \ cipher spec messages, alerts, and any other record types\n         are not handshake\
    \ messages and are not included in the hash\n         computations.  Also, Hello\
    \ Request messages are omitted from\n         handshake hashes.\n"
- title: 8. Cryptographic Computations
  contents:
  - "8. Cryptographic Computations\n   In order to begin connection protection, the\
    \ TLS Record Protocol\n   requires specification of a suite of algorithms, a master\
    \ secret, and\n   the client and server random values.  The authentication, encryption,\n\
    \   and MAC algorithms are determined by the cipher_suite selected by the\n  \
    \ server and revealed in the server hello message.  The compression\n   algorithm\
    \ is negotiated in the hello messages, and the random values\n   are exchanged\
    \ in the hello messages.  All that remains is to\n   calculate the master secret.\n"
- title: 8.1. Computing the Master Secret
  contents:
  - "8.1. Computing the Master Secret\n   For all key exchange methods, the same algorithm\
    \ is used to convert\n   the pre_master_secret into the master_secret.  The pre_master_secret\n\
    \   should be deleted from memory once the master_secret has been\n   computed.\n\
    \       master_secret = PRF(pre_master_secret, \"master secret\",\n          \
    \                 ClientHello.random + ServerHello.random)\n       [0..47];\n\
    \   The master secret is always exactly 48 bytes in length.  The length\n   of\
    \ the premaster secret will vary depending on key exchange method.\n"
- title: 8.1.1. RSA
  contents:
  - "8.1.1. RSA\n   When RSA is used for server authentication and key exchange, a\
    \ 48-\n   byte pre_master_secret is generated by the client, encrypted under\n\
    \   the server's public key, and sent to the server.  The server uses its\n  \
    \ private key to decrypt the pre_master_secret.  Both parties then\n   convert\
    \ the pre_master_secret into the master_secret, as specified\n   above.\n   RSA\
    \ digital signatures are performed using PKCS #1 [PKCS1] block type\n   1. RSA\
    \ public key encryption is performed using PKCS #1 block type 2.\n"
- title: 8.1.2. Diffie-Hellman
  contents:
  - "8.1.2. Diffie-Hellman\n   A conventional Diffie-Hellman computation is performed.\
    \  The\n   negotiated key (Z) is used as the pre_master_secret, and is converted\n\
    \   into the master_secret, as specified above.  Leading bytes of Z that\n   contain\
    \ all zero bits are stripped before it is used as the\n   pre_master_secret.\n\
    \   Note: Diffie-Hellman parameters are specified by the server and may\n    \
    \     be either ephemeral or contained within the server's\n         certificate.\n"
- title: 9. Mandatory Cipher Suites
  contents:
  - "9. Mandatory Cipher Suites\n   In the absence of an application profile standard\
    \ specifying\n   otherwise, a TLS compliant application MUST implement the cipher\n\
    \   suite TLS_RSA_WITH_3DES_EDE_CBC_SHA.\n"
- title: 10. Application Data Protocol
  contents:
  - "10. Application Data Protocol\n   Application data messages are carried by the\
    \ Record Layer and are\n   fragmented, compressed, and encrypted based on the\
    \ current connection\n   state.  The messages are treated as transparent data\
    \ to the record\n   layer.\n"
- title: 11. Security Considerations
  contents:
  - "11. Security Considerations\n   Security issues are discussed throughout this\
    \ memo, especially in\n   Appendices D, E, and F.\n"
- title: 12. IANA Considerations
  contents:
  - "12. IANA Considerations\n   This document describes a number of new registries\
    \ that have been\n   created by IANA.  We recommended that they be placed as individual\n\
    \   registries items under a common TLS category.\n   Section 7.4.3 describes\
    \ a TLS ClientCertificateType Registry to be\n   maintained by the IANA, defining\
    \ a number of such code point\n   identifiers.  ClientCertificateType identifiers\
    \ with values in the\n   range 0-63 (decimal) inclusive are assigned via RFC 2434\
    \ Standards\n   Action.  Values from the range 64-223 (decimal) inclusive are\n\
    \   assigned via [RFC2434] Specification Required.  Identifier values\n   from\
    \ 224-255 (decimal) inclusive are reserved for RFC 2434 Private\n   Use.  The\
    \ registry will initially be populated with the values in\n   this document, Section\
    \ 7.4.4.\n   Section A.5 describes a TLS Cipher Suite Registry to be maintained\
    \ by\n   the IANA, and it defines a number of such cipher suite identifiers.\n\
    \   Cipher suite values with the first byte in the range 0-191 (decimal)\n   inclusive\
    \ are assigned via RFC 2434 Standards Action.  Values with\n   the first byte\
    \ in the range 192-254 (decimal) are assigned via RFC\n   2434 Specification Required.\
    \  Values with the first byte 255\n   (decimal) are reserved for RFC 2434 Private\
    \ Use.  The registry will\n   initially be populated with the values from Section\
    \ A.5 of this\n   document, [TLSAES], and from Section 3 of [TLSKRB].\n   Section\
    \ 6 requires that all ContentType values be defined by RFC 2434\n   Standards\
    \ Action.  IANA has created a TLS ContentType registry,\n   initially populated\
    \ with values from Section 6.2.1 of this document.\n   Future values MUST be allocated\
    \ via Standards Action as described in\n   [RFC2434].\n   Section 7.2.2 requires\
    \ that all Alert values be defined by RFC 2434\n   Standards Action.  IANA has\
    \ created a TLS Alert registry, initially\n   populated with values from Section\
    \ 7.2 of this document and from\n   Section 4 of [TLSEXT].  Future values MUST\
    \ be allocated via Standards\n   Action as described in [RFC2434].\n   Section\
    \ 7.4 requires that all HandshakeType values be defined by RFC\n   2434 Standards\
    \ Action.  IANA has created a TLS HandshakeType\n   registry, initially populated\
    \ with values from Section 7.4 of this\n   document and from Section 2.4 of [TLSEXT].\
    \  Future values MUST be\n   allocated via Standards Action as described in [RFC2434].\n"
- title: Appendix A. Protocol Constant Values
  contents:
  - "Appendix A. Protocol Constant Values\n   This section describes protocol types\
    \ and constants.\n"
- title: A.1. Record Layer
  contents:
  - "A.1. Record Layer\n   struct {\n       uint8 major, minor;\n   } ProtocolVersion;\n\
    \   ProtocolVersion version = { 3, 2 };     /* TLS v1.1 */\n   enum {\n      \
    \ change_cipher_spec(20), alert(21), handshake(22),\n       application_data(23),\
    \ (255)\n   } ContentType;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       opaque fragment[TLSPlaintext.length];\n\
    \   } TLSPlaintext;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       opaque fragment[TLSCompressed.length];\n\
    \   } TLSCompressed;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       select (CipherSpec.cipher_type) {\n\
    \           case stream: GenericStreamCipher;\n           case block:  GenericBlockCipher;\n\
    \       } fragment;\n   } TLSCiphertext;\n   stream-ciphered struct {\n      \
    \ opaque content[TLSCompressed.length];\n       opaque MAC[CipherSpec.hash_size];\n\
    \   } GenericStreamCipher;\n   block-ciphered struct {\n       opaque IV[CipherSpec.block_length];\n\
    \       opaque content[TLSCompressed.length];\n       opaque MAC[CipherSpec.hash_size];\n\
    \       uint8 padding[GenericBlockCipher.padding_length];\n       uint8 padding_length;\n\
    \   } GenericBlockCipher;\n"
- title: A.2. Change Cipher Specs Message
  contents:
  - "A.2. Change Cipher Specs Message\n   struct {\n       enum { change_cipher_spec(1),\
    \ (255) } type;\n   } ChangeCipherSpec;\n"
- title: A.3. Alert Messages
  contents:
  - "A.3. Alert Messages\n   enum { warning(1), fatal(2), (255) } AlertLevel;\n  \
    \     enum {\n           close_notify(0),\n           unexpected_message(10),\n\
    \           bad_record_mac(20),\n           decryption_failed(21),\n         \
    \  record_overflow(22),\n           decompression_failure(30),\n           handshake_failure(40),\n\
    \           no_certificate_RESERVED (41),\n           bad_certificate(42),\n \
    \          unsupported_certificate(43),\n           certificate_revoked(44),\n\
    \           certificate_expired(45),\n           certificate_unknown(46),\n  \
    \         illegal_parameter(47),\n           unknown_ca(48),\n           access_denied(49),\n\
    \           decode_error(50),\n           decrypt_error(51),\n           export_restriction_RESERVED(60),\n\
    \           protocol_version(70),\n           insufficient_security(71),\n   \
    \        internal_error(80),\n           user_canceled(90),\n           no_renegotiation(100),\n\
    \           (255)\n       } AlertDescription;\n   struct {\n       AlertLevel\
    \ level;\n       AlertDescription description;\n   } Alert;\n"
- title: A.4. Handshake Protocol
  contents:
  - "A.4. Handshake Protocol\n   enum {\n       hello_request(0), client_hello(1),\
    \ server_hello(2),\n       certificate(11), server_key_exchange (12),\n      \
    \ certificate_request(13), server_hello_done(14),\n       certificate_verify(15),\
    \ client_key_exchange(16),\n       finished(20), (255)\n   } HandshakeType;\n\
    \   struct {\n       HandshakeType msg_type;\n       uint24 length;\n       select\
    \ (HandshakeType) {\n           case hello_request:       HelloRequest;\n    \
    \       case client_hello:        ClientHello;\n           case server_hello:\
    \        ServerHello;\n           case certificate:         Certificate;\n   \
    \        case server_key_exchange: ServerKeyExchange;\n           case certificate_request:\
    \ CertificateRequest;\n           case server_hello_done:   ServerHelloDone;\n\
    \           case certificate_verify:  CertificateVerify;\n           case client_key_exchange:\
    \ ClientKeyExchange;\n           case finished:            Finished;\n       }\
    \ body;\n   } Handshake;\n"
- title: A.4.1. Hello messages
  contents:
  - "A.4.1. Hello messages\n   struct { } HelloRequest;\n   struct {\n       uint32\
    \ gmt_unix_time;\n       opaque random_bytes[28];\n   } Random;\n   opaque SessionID<0..32>;\n\
    \   uint8 CipherSuite[2];\n   enum { null(0), (255) } CompressionMethod;\n   struct\
    \ {\n       ProtocolVersion client_version;\n       Random random;\n       SessionID\
    \ session_id;\n       CipherSuite cipher_suites<2..2^16-1>;\n       CompressionMethod\
    \ compression_methods<1..2^8-1>;\n   } ClientHello;\n   struct {\n       ProtocolVersion\
    \ server_version;\n       Random random;\n       SessionID session_id;\n     \
    \  CipherSuite cipher_suite;\n       CompressionMethod compression_method;\n \
    \  } ServerHello;\n"
- title: A.4.2. Server Authentication and Key Exchange Messages
  contents:
  - "A.4.2. Server Authentication and Key Exchange Messages\n   opaque ASN.1Cert<2^24-1>;\n\
    \   struct {\n       ASN.1Cert certificate_list<0..2^24-1>;\n   } Certificate;\n\
    \   enum { rsa, diffie_hellman } KeyExchangeAlgorithm;\n   struct {\n       opaque\
    \ rsa_modulus<1..2^16-1>;\n       opaque rsa_exponent<1..2^16-1>;\n   } ServerRSAParams;\n\
    \   struct {\n       opaque dh_p<1..2^16-1>;\n       opaque dh_g<1..2^16-1>;\n\
    \       opaque dh_Ys<1..2^16-1>;\n   } ServerDHParams;\n   struct {\n       select\
    \ (KeyExchangeAlgorithm) {\n           case diffie_hellman:\n               ServerDHParams\
    \ params;\n               Signature signed_params;\n           case rsa:\n   \
    \            ServerRSAParams params;\n               Signature signed_params;\n\
    \       };\n   } ServerKeyExchange;\n   enum { anonymous, rsa, dsa } SignatureAlgorithm;\n\
    \   struct {\n       select (KeyExchangeAlgorithm) {\n           case diffie_hellman:\n\
    \               ServerDHParams params;\n           case rsa:\n               ServerRSAParams\
    \ params;\n       };\n   } ServerParams;\n   struct {\n       select (SignatureAlgorithm)\
    \ {\n           case anonymous: struct { };\n           case rsa:\n          \
    \     digitally-signed struct {\n                   opaque md5_hash[16];\n   \
    \                opaque sha_hash[20];\n               };\n           case dsa:\n\
    \               digitally-signed struct {\n                   opaque sha_hash[20];\n\
    \               };\n           };\n       };\n   } Signature;\n   enum {\n   \
    \    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n    rsa_ephemeral_dh_RESERVED(5),\
    \ dss_ephemeral_dh_RESERVED(6),\n    fortezza_dms_RESERVED(20),\n    (255)\n \
    \  } ClientCertificateType;\n   opaque DistinguishedName<1..2^16-1>;\n   struct\
    \ {\n       ClientCertificateType certificate_types<1..2^8-1>;\n       DistinguishedName\
    \ certificate_authorities<0..2^16-1>;\n   } CertificateRequest;\n   struct { }\
    \ ServerHelloDone;\n"
- title: A.4.3. Client Authentication and Key Exchange Messages
  contents:
  - "A.4.3. Client Authentication and Key Exchange Messages\n   struct {\n       select\
    \ (KeyExchangeAlgorithm) {\n           case rsa: EncryptedPreMasterSecret;\n \
    \          case diffie_hellman: ClientDiffieHellmanPublic;\n       } exchange_keys;\n\
    \   } ClientKeyExchange;\n   struct {\n       ProtocolVersion client_version;\n\
    \       opaque random[46];\n   }\n   PreMasterSecret;\n   struct {\n       public-key-encrypted\
    \ PreMasterSecret pre_master_secret;\n   } EncryptedPreMasterSecret;\n   enum\
    \ { implicit, explicit } PublicValueEncoding;\n   struct {\n       select (PublicValueEncoding)\
    \ {\n           case implicit: struct {};\n           case explicit: opaque DH_Yc<1..2^16-1>;\n\
    \       } dh_public;\n   } ClientDiffieHellmanPublic;\n   struct {\n       Signature\
    \ signature;\n   } CertificateVerify;\n"
- title: A.4.4. Handshake Finalization Message
  contents:
  - "A.4.4. Handshake Finalization Message\n   struct {\n       opaque verify_data[12];\n\
    \   } Finished;\n"
- title: A.5. The CipherSuite
  contents:
  - "A.5. The CipherSuite\n   The following values define the CipherSuite codes used\
    \ in the client\n   hello and server hello messages.\n   A CipherSuite defines\
    \ a cipher specification supported in TLS Version\n   1.1.\n   TLS_NULL_WITH_NULL_NULL\
    \ is specified and is the initial state of a\n   TLS connection during the first\
    \ handshake on that channel, but must\n   not be negotiated, as it provides no\
    \ more protection than an\n   unsecured connection.\n    CipherSuite TLS_NULL_WITH_NULL_NULL\
    \                = { 0x00,0x00 };\n   The following CipherSuite definitions require\
    \ that the server provide\n   an RSA certificate that can be used for key exchange.\
    \  The server may\n   request either an RSA or a DSS signature-capable certificate\
    \ in the\n   certificate request message.\n    CipherSuite TLS_RSA_WITH_NULL_MD5\
    \                  = { 0x00,0x01 };\n    CipherSuite TLS_RSA_WITH_NULL_SHA   \
    \               = { 0x00,0x02 };\n    CipherSuite TLS_RSA_WITH_RC4_128_MD5   \
    \            = { 0x00,0x04 };\n    CipherSuite TLS_RSA_WITH_RC4_128_SHA      \
    \         = { 0x00,0x05 };\n    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA        \
    \      = { 0x00,0x07 };\n    CipherSuite TLS_RSA_WITH_DES_CBC_SHA            \
    \   = { 0x00,0x09 };\n    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          =\
    \ { 0x00,0x0A };\n   The following CipherSuite definitions are used for server-\n\
    \   authenticated (and optionally client-authenticated) Diffie-Hellman.\n   DH\
    \ denotes cipher suites in which the server's certificate contains\n   the Diffie-Hellman\
    \ parameters signed by the certificate authority\n   (CA).  DHE denotes ephemeral\
    \ Diffie-Hellman, where the Diffie-Hellman\n   parameters are signed by a DSS\
    \ or RSA certificate that has been\n   signed by the CA.  The signing algorithm\
    \ used is specified after the\n   DH or DHE parameter.  The server can request\
    \ an RSA or DSS\n   signature-capable certificate from the client for client\n\
    \   authentication or it may request a Diffie-Hellman certificate.  Any\n   Diffie-Hellman\
    \ certificate provided by the client must use the\n   parameters (group and generator)\
    \ described by the server.\n    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA      \
    \      = { 0x00,0x0C };\n    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA    \
    \   = { 0x00,0x0D };\n    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            =\
    \ { 0x00,0x0F };\n    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10\
    \ };\n    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };\n\
    \    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };\n   \
    \ CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };\n    CipherSuite\
    \ TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };\n   The following cipher\
    \ suites are used for completely anonymous\n   Diffie-Hellman communications in\
    \ which neither party is\n   authenticated.  Note that this mode is vulnerable\
    \ to man-in-the-\n   middle attacks and is therefore deprecated.\n    CipherSuite\
    \ TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };\n    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA\
    \           = { 0x00,0x1A };\n    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\
    \      = { 0x00,0x1B };\n   When SSLv3 and TLS 1.0 were designed, the United States\
    \ restricted\n   the export of cryptographic software containing certain strong\n\
    \   encryption algorithms.  A series of cipher suites were designed to\n   operate\
    \ at reduced key lengths in order to comply with those\n   regulations.  Due to\
    \ advances in computer performance, these\n   algorithms are now unacceptably\
    \ weak, and export restrictions have\n   since been loosened.  TLS 1.1 implementations\
    \ MUST NOT negotiate\n   these cipher suites in TLS 1.1 mode.  However, for backward\n\
    \   compatibility they may be offered in the ClientHello for use with TLS\n  \
    \ 1.0 or SSLv3-only servers.  TLS 1.1 clients MUST check that the\n   server did\
    \ not choose one of these cipher suites during the\n   handshake.  These ciphersuites\
    \ are listed below for informational\n   purposes and to reserve the numbers.\n\
    \    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };\n   \
    \ CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };\n    CipherSuite\
    \ TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };\n    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\
    \   = { 0x00,0x0B };\n    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   =\
    \ { 0x00,0x0E };\n    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11\
    \ };\n    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };\n\
    \    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };\n   \
    \ CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };\n   The\
    \ following cipher suites were defined in [TLSKRB] and are included\n   here for\
    \ completeness.  See [TLSKRB] for details:\n    CipherSuite    TLS_KRB5_WITH_DES_CBC_SHA\
    \           = { 0x00,0x1E }:\n    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_SHA\
    \      = { 0x00,0x1F };\n    CipherSuite    TLS_KRB5_WITH_RC4_128_SHA        \
    \   = { 0x00,0x20 };\n    CipherSuite    TLS_KRB5_WITH_IDEA_CBC_SHA          =\
    \ { 0x00,0x21 };\n    CipherSuite    TLS_KRB5_WITH_DES_CBC_MD5           = { 0x00,0x22\
    \ };\n    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_MD5      = { 0x00,0x23 };\n\
    \    CipherSuite    TLS_KRB5_WITH_RC4_128_MD5           = { 0x00,0x24 };\n   \
    \ CipherSuite    TLS_KRB5_WITH_IDEA_CBC_MD5          = { 0x00,0x25 };\n   The\
    \ following exportable cipher suites were defined in [TLSKRB] and\n   are included\
    \ here for completeness.  TLS 1.1 implementations MUST NOT\n   negotiate these\
    \ cipher suites.\n    CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA    = {\
    \ 0x00,0x26};\n    CipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA    = { 0x00,0x27};\n\
    \    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_SHA        = { 0x00,0x28};\n   \
    \ CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5    = { 0x00,0x29};\n    CipherSuite\
    \  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5    = { 0x00,0x2A};\n    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_MD5\
    \        = { 0x00,0x2B};\n   The following cipher suites were defined in [TLSAES]\
    \ and are included\n   here for completeness.  See [TLSAES] for details:\n   \
    \      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA      = { 0x00, 0x2F };\n     \
    \    CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA   = { 0x00, 0x30 };\n       \
    \  CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA   = { 0x00, 0x31 };\n         CipherSuite\
    \ TLS_DHE_DSS_WITH_AES_128_CBC_SHA  = { 0x00, 0x32 };\n         CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA\
    \  = { 0x00, 0x33 };\n         CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA  =\
    \ { 0x00, 0x34 };\n         CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA      = {\
    \ 0x00, 0x35 };\n         CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA   = { 0x00,\
    \ 0x36 };\n         CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA   = { 0x00, 0x37\
    \ };\n         CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA  = { 0x00, 0x38 };\n\
    \         CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA  = { 0x00, 0x39 };\n  \
    \       CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA  = { 0x00, 0x3A };\n    The\
    \ cipher suite space is divided into three regions:\n      1. Cipher suite values\
    \ with first byte 0x00 (zero) through decimal\n         191 (0xBF) inclusive are\
    \ reserved for the IETF Standards Track\n         protocols.\n      2. Cipher\
    \ suite values with first byte decimal 192 (0xC0) through\n         decimal 254\
    \ (0xFE) inclusive are reserved for assignment for\n         non-Standards Track\
    \ methods.\n      3. Cipher suite values with first byte 0xFF are reserved for\n\
    \         private use.\n   Additional information describing the role of IANA\
    \ in the allocation\n   of cipher suite code points is described in Section 11.\n\
    \   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are\n    \
    \     reserved to avoid collision with Fortezza-based cipher suites\n        \
    \ in SSL 3.\n"
- title: A.6. The Security Parameters
  contents:
  - "A.6. The Security Parameters\n         These security parameters are determined\
    \ by the TLS Handshake\n         Protocol and provided as parameters to the TLS\
    \ Record Layer in\n         order to initialize a connection state.  SecurityParameters\n\
    \         includes:\n            enum { null(0), (255) } CompressionMethod;\n\
    \            enum { server, client } ConnectionEnd;\n            enum { null,\
    \ rc4, rc2, des, 3des, des40, aes, idea }\n            BulkCipherAlgorithm;\n\
    \            enum { stream, block } CipherType;\n            enum { null, md5,\
    \ sha } MACAlgorithm;\n         /* The algorithms specified in CompressionMethod,\n\
    \         BulkCipherAlgorithm, and MACAlgorithm may be added to. */\n        \
    \    struct {\n                ConnectionEnd entity;\n                BulkCipherAlgorithm\
    \ bulk_cipher_algorithm;\n                CipherType cipher_type;\n          \
    \      uint8 key_size;\n                uint8 key_material_length;\n         \
    \       MACAlgorithm mac_algorithm;\n                uint8 hash_size;\n      \
    \          CompressionMethod compression_algorithm;\n                opaque master_secret[48];\n\
    \                opaque client_random[32];\n                opaque server_random[32];\n\
    \            } SecurityParameters;\n"
- title: Appendix B. Glossary
  contents:
  - "Appendix B. Glossary\n   Advanced Encryption Standard (AES)\n      AES is a widely\
    \ used symmetric encryption algorithm.  AES is a\n      block cipher with a 128,\
    \ 192, or 256 bit keys and a 16 byte block\n      size. [AES] TLS currently only\
    \ supports the 128 and 256 bit key\n      sizes.\n   application protocol\n  \
    \    An application protocol is a protocol that normally layers\n      directly\
    \ on top of the transport layer (e.g., TCP/IP).  Examples\n      include HTTP,\
    \ TELNET, FTP, and SMTP.\n   asymmetric cipher\n      See public key cryptography.\n\
    \   authentication\n      Authentication is the ability of one entity to determine\
    \ the\n      identity of another entity.\n   block cipher\n      A block cipher\
    \ is an algorithm that operates on plaintext in\n      groups of bits, called\
    \ blocks. 64 bits is a common block size.\n   bulk cipher\n      A symmetric encryption\
    \ algorithm used to encrypt large quantities\n      of data.\n   cipher block\
    \ chaining (CBC)\n      CBC is a mode in which every plaintext block encrypted\
    \ with a\n      block cipher is first exclusive-ORed with the previous ciphertext\n\
    \      block (or, in the case of the first block, with the initialization\n  \
    \    vector).  For decryption, every block is first decrypted, then\n      exclusive-ORed\
    \ with the previous ciphertext block (or IV).\n   certificate\n      As part of\
    \ the X.509 protocol (a.k.a. ISO Authentication\n      framework), certificates\
    \ are assigned by a trusted Certificate\n      Authority and provide a strong\
    \ binding between a party's identity\n      or some other attributes and its public\
    \ key.\n   client\n      The application entity that initiates a TLS connection\
    \ to a\n      server.  This may or may not imply that the client initiated the\n\
    \      underlying transport connection.  The primary operational\n      difference\
    \ between the server and client is that the server is\n      generally authenticated,\
    \ while the client is only optionally\n      authenticated.\n   client write key\n\
    \      The key used to encrypt data written by the client.\n   client write MAC\
    \ secret\n      The secret data used to authenticate data written by the client.\n\
    \   connection\n      A connection is a transport (in the OSI layering model definition)\n\
    \      that provides a suitable type of service.  For TLS, such\n      connections\
    \ are peer-to-peer relationships.  The connections are\n      transient.  Every\
    \ connection is associated with one session.\n   Data Encryption Standard\n  \
    \    DES is a very widely used symmetric encryption algorithm.  DES is\n     \
    \ a block cipher with a 56 bit key and an 8 byte block size.  Note\n      that\
    \ in TLS, for key generation purposes, DES is treated as having\n      an 8 byte\
    \ key length (64 bits), but it still only provides 56 bits\n      of protection.\
    \  (The low bit of each key byte is presumed to be\n      set to produce odd parity\
    \ in that key byte.)  DES can also be\n      operated in a mode where three independent\
    \ keys and three\n      encryptions are used for each block of data; this uses\
    \ 168 bits of\n      key (24 bytes in the TLS key generation method) and provides\
    \ the\n      equivalent of 112 bits of security.  [DES], [3DES]\n   Digital Signature\
    \ Standard (DSS)\n      A standard for digital signing, including the Digital\
    \ Signing\n      Algorithm, approved by the National Institute of Standards and\n\
    \      Technology, defined in NIST FIPS PUB 186, \"Digital Signature\n      Standard,\"\
    \ published May 1994 by the U.S. Dept. of Commerce.\n      [DSS]\n   digital signatures\n\
    \      Digital signatures utilize public key cryptography and one-way\n      hash\
    \ functions to produce a signature of the data that can be\n      authenticated,\
    \ and is difficult to forge or repudiate.\n   handshake\n      An initial negotiation\
    \ between client and server that establishes\n      the parameters of their transactions.\n\
    \   Initialization Vector (IV)\n      When a block cipher is used in CBC mode,\
    \ the initialization vector\n      is exclusive-ORed with the first plaintext\
    \ block prior to\n      encryption.\n   IDEA\n      A 64-bit block cipher designed\
    \ by Xuejia Lai and James Massey.\n      [IDEA]\n   Message Authentication Code\
    \ (MAC)\n      A Message Authentication Code is a one-way hash computed from a\n\
    \      message and some secret data.  It is difficult to forge without\n     \
    \ knowing the secret data.  Its purpose is to detect if the message\n      has\
    \ been altered.\n   master secret\n      Secure secret data used for generating\
    \ encryption keys, MAC\n      secrets, and IVs.\n   MD5\n      MD5 is a secure\
    \ hashing function that converts an arbitrarily long\n      data stream into a\
    \ digest of fixed size (16 bytes).  [MD5]\n   public key cryptography\n      A\
    \ class of cryptographic techniques employing two-key ciphers.\n      Messages\
    \ encrypted with the public key can only be decrypted with\n      the associated\
    \ private key.  Conversely, messages signed with the\n      private key can be\
    \ verified with the public key.\n   one-way hash function\n      A one-way transformation\
    \ that converts an arbitrary amount of data\n      into a fixed-length hash. \
    \ It is computationally hard to reverse\n      the transformation or to find collisions.\
    \  MD5 and SHA are\n      examples of one-way hash functions.\n   RC2\n      A\
    \ block cipher developed by Ron Rivest at RSA Data Security, Inc.\n      [RSADSI]\
    \ described in [RC2].\n   RC4\n      A stream cipher invented by Ron Rivest. \
    \ A compatible cipher is\n      described in [SCH].\n   RSA\n      A very widely\
    \ used public-key algorithm that can be used for\n      either encryption or digital\
    \ signing.  [RSA]\n   server\n      The server is the application entity that\
    \ responds to requests for\n      connections from clients.  See also under client.\n\
    \   session\n      A TLS session is an association between a client and a server.\n\
    \      Sessions are created by the handshake protocol.  Sessions define a\n  \
    \    set of cryptographic security parameters that can be shared among\n     \
    \ multiple connections.  Sessions are used to avoid the expensive\n      negotiation\
    \ of new security parameters for each connection.\n   session identifier\n   \
    \   A session identifier is a value generated by a server that\n      identifies\
    \ a particular session.\n   server write key\n      The key used to encrypt data\
    \ written by the server.\n   server write MAC secret\n      The secret data used\
    \ to authenticate data written by the server.\n   SHA\n      The Secure Hash Algorithm\
    \ is defined in FIPS PUB 180-2.  It\n      produces a 20-byte output.  Note that\
    \ all references to SHA\n      actually use the modified SHA-1 algorithm.  [SHA]\n\
    \   SSL\n      Netscape's Secure Socket Layer protocol [SSL3].  TLS is based on\n\
    \      SSL Version 3.0\n   stream cipher\n      An encryption algorithm that converts\
    \ a key into a\n      cryptographically strong keystream, which is then exclusive-ORed\n\
    \      with the plaintext.\n   symmetric cipher\n      See bulk cipher.\n   Transport\
    \ Layer Security (TLS)\n      This protocol; also, the Transport Layer Security\
    \ working group of\n      the Internet Engineering Task Force (IETF).  See \"\
    Comments\" at the\n      end of this document.\n"
- title: Appendix C. CipherSuite Definitions
  contents:
  - 'Appendix C. CipherSuite Definitions

    '
- title: CipherSuite                           Key Exchange   Cipher      Hash
  contents:
  - 'CipherSuite                           Key Exchange   Cipher      Hash

    '
- title: TLS_NULL_WITH_NULL_NULL               NULL           NULL        NULL
  contents:
  - 'TLS_NULL_WITH_NULL_NULL               NULL           NULL        NULL

    '
- title: TLS_RSA_WITH_NULL_MD5                 RSA            NULL         MD5
  contents:
  - 'TLS_RSA_WITH_NULL_MD5                 RSA            NULL         MD5

    '
- title: TLS_RSA_WITH_NULL_SHA                 RSA            NULL         SHA
  contents:
  - 'TLS_RSA_WITH_NULL_SHA                 RSA            NULL         SHA

    '
- title: TLS_RSA_WITH_RC4_128_MD5              RSA            RC4_128      MD5
  contents:
  - 'TLS_RSA_WITH_RC4_128_MD5              RSA            RC4_128      MD5

    '
- title: TLS_RSA_WITH_RC4_128_SHA              RSA            RC4_128      SHA
  contents:
  - 'TLS_RSA_WITH_RC4_128_SHA              RSA            RC4_128      SHA

    '
- title: TLS_RSA_WITH_IDEA_CBC_SHA             RSA            IDEA_CBC     SHA
  contents:
  - 'TLS_RSA_WITH_IDEA_CBC_SHA             RSA            IDEA_CBC     SHA

    '
- title: TLS_RSA_WITH_DES_CBC_SHA              RSA            DES_CBC      SHA
  contents:
  - 'TLS_RSA_WITH_DES_CBC_SHA              RSA            DES_CBC      SHA

    '
- title: TLS_RSA_WITH_3DES_EDE_CBC_SHA         RSA            3DES_EDE_CBC SHA
  contents:
  - 'TLS_RSA_WITH_3DES_EDE_CBC_SHA         RSA            3DES_EDE_CBC SHA

    '
- title: TLS_DH_DSS_WITH_DES_CBC_SHA           DH_DSS         DES_CBC      SHA
  contents:
  - 'TLS_DH_DSS_WITH_DES_CBC_SHA           DH_DSS         DES_CBC      SHA

    '
- title: TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      DH_DSS         3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      DH_DSS         3DES_EDE_CBC SHA

    '
- title: TLS_DH_RSA_WITH_DES_CBC_SHA           DH_RSA         DES_CBC      SHA
  contents:
  - 'TLS_DH_RSA_WITH_DES_CBC_SHA           DH_RSA         DES_CBC      SHA

    '
- title: TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      DH_RSA         3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      DH_RSA         3DES_EDE_CBC SHA

    '
- title: TLS_DHE_DSS_WITH_DES_CBC_SHA          DHE_DSS        DES_CBC      SHA
  contents:
  - 'TLS_DHE_DSS_WITH_DES_CBC_SHA          DHE_DSS        DES_CBC      SHA

    '
- title: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     DHE_DSS        3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     DHE_DSS        3DES_EDE_CBC SHA

    '
- title: TLS_DHE_RSA_WITH_DES_CBC_SHA          DHE_RSA        DES_CBC      SHA
  contents:
  - 'TLS_DHE_RSA_WITH_DES_CBC_SHA          DHE_RSA        DES_CBC      SHA

    '
- title: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     DHE_RSA        3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     DHE_RSA        3DES_EDE_CBC SHA

    '
- title: TLS_DH_anon_WITH_RC4_128_MD5          DH_anon        RC4_128      MD5
  contents:
  - 'TLS_DH_anon_WITH_RC4_128_MD5          DH_anon        RC4_128      MD5

    '
- title: TLS_DH_anon_WITH_DES_CBC_SHA          DH_anon        DES_CBC      SHA
  contents:
  - 'TLS_DH_anon_WITH_DES_CBC_SHA          DH_anon        DES_CBC      SHA

    '
- title: TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     DH_anon        3DES_EDE_CBC SHA
  contents:
  - "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     DH_anon        3DES_EDE_CBC SHA\n     \
    \ Key\n      Exchange\n      Algorithm     Description                       \
    \ Key size limit\n      DHE_DSS       Ephemeral DH with DSS signatures   None\n\
    \      DHE_RSA       Ephemeral DH with RSA signatures   None\n      DH_anon  \
    \     Anonymous DH, no signatures        None\n      DH_DSS        DH with DSS-based\
    \ certificates     None\n      DH_RSA        DH with RSA-based certificates  \
    \   None\n                                                       RSA = none\n\
    \      NULL          No key exchange                    N/A\n      RSA       \
    \    RSA key exchange                   None\n                         Key   \
    \   Expanded     IV    Block\n    Cipher       Type  Material Key Material   Size\
    \   Size\n    NULL         Stream   0          0         0     N/A\n    IDEA_CBC\
    \     Block   16         16         8      8\n    RC2_CBC_40   Block    5    \
    \     16         8      8\n    RC4_40       Stream   5         16         0  \
    \   N/A\n    RC4_128      Stream  16         16         0     N/A\n    DES40_CBC\
    \    Block    5          8         8      8\n    DES_CBC      Block    8     \
    \     8         8      8\n    3DES_EDE_CBC Block   24         24         8   \
    \   8\n   Type\n      Indicates whether this is a stream cipher or a block cipher\n\
    \      running in CBC mode.\n   Key Material\n      The number of bytes from the\
    \ key_block that are used for\n      generating the write keys.\n   Expanded Key\
    \ Material\n      The number of bytes actually fed into the encryption algorithm.\n\
    \   IV Size\n      The amount of data needed to be generated for the initialization\n\
    \      vector.  Zero for stream ciphers; equal to the block size for\n      block\
    \ ciphers.\n   Block Size\n      The amount of data a block cipher enciphers in\
    \ one chunk; a block\n      cipher running in CBC mode can only encrypt an even\
    \ multiple of\n      its block size.\n         Hash      Hash      Padding\n \
    \      function    Size       Size\n         NULL       0          0\n       \
    \  MD5        16         48\n         SHA        20         40\n"
- title: Appendix D. Implementation Notes
  contents:
  - "Appendix D. Implementation Notes\n   The TLS protocol cannot prevent many common\
    \ security mistakes.  This\n   section provides several recommendations to assist\
    \ implementors.\n"
- title: D.1. Random Number Generation and Seeding
  contents:
  - "D.1. Random Number Generation and Seeding\n   TLS requires a cryptographically\
    \ secure pseudorandom number generator\n   (PRNG).  Care must be taken in designing\
    \ and seeding PRNGs.  PRNGs\n   based on secure hash operations, most notably\
    \ MD5 and/or SHA, are\n   acceptable, but cannot provide more security than the\
    \ size of the\n   random number generator state.  (For example, MD5-based PRNGs\
    \ usually\n   provide 128 bits of state.)\n   To estimate the amount of seed material\
    \ being produced, add the\n   number of bits of unpredictable information in each\
    \ seed byte.  For\n   example, keystroke timing values taken from a PC compatible's\
    \ 18.2 Hz\n   timer provide 1 or 2 secure bits each, even though the total size\
    \ of\n   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would\n\
    \   thus require approximately 100 such timer values.\n   [RANDOM] provides guidance\
    \ on the generation of random values.\n"
- title: D.2 Certificates and Authentication
  contents:
  - "D.2 Certificates and Authentication\n   Implementations are responsible for verifying\
    \ the integrity of\n   certificates and should generally support certificate revocation\n\
    \   messages.  Certificates should always be verified to ensure proper\n   signing\
    \ by a trusted Certificate Authority (CA).  The selection and\n   addition of\
    \ trusted CAs should be done very carefully.  Users should\n   be able to view\
    \ information about the certificate and root CA.\n"
- title: D.3 CipherSuites
  contents:
  - "D.3 CipherSuites\n   TLS supports a range of key sizes and security levels, including\
    \ some\n   that provide no or minimal security.  A proper implementation will\n\
    \   probably not support many cipher suites.  For example, 40-bit\n   encryption\
    \ is easily broken, so implementations requiring strong\n   security should not\
    \ allow 40-bit keys.  Similarly, anonymous Diffie-\n   Hellman is strongly discouraged\
    \ because it cannot prevent man-in-\n   the-middle attacks.  Applications should\
    \ also enforce minimum and\n   maximum key sizes.  For example, certificate chains\
    \ containing 512-\n   bit RSA keys or signatures are not appropriate for high-security\n\
    \   applications.\n"
- title: Appendix E. Backward Compatibility with SSL
  contents:
  - "Appendix E. Backward Compatibility with SSL\n   For historical reasons and in\
    \ order to avoid a profligate consumption\n   of reserved port numbers, application\
    \ protocols that are secured by\n   TLS 1.1, TLS 1.0, SSL 3.0, and SSL 2.0 all\
    \ frequently share the same\n   connection port.  For example, the https protocol\
    \ (HTTP secured by\n   SSL or TLS) uses port 443 regardless of which security\
    \ protocol it is\n   using.  Thus, some mechanism must be determined to distinguish\
    \ and\n   negotiate among the various protocols.\n   TLS versions 1.1 and 1.0,\
    \ and SSL 3.0 are very similar; thus,\n   supporting both is easy.  TLS clients\
    \ who wish to negotiate with such\n   older servers SHOULD send client hello messages\
    \ using the SSL 3.0\n   record format and client hello structure, sending {3,\
    \ 2} for the\n   version field to note that they support TLS 1.1. If the server\n\
    \   supports only TLS 1.0 or SSL 3.0, it will respond with a downrev 3.0\n   server\
    \ hello; if it supports TLS 1.1 it will respond with a TLS 1.1\n   server hello.\
    \  The negotiation then proceeds as appropriate for the\n   negotiated protocol.\n\
    \   Similarly, a TLS 1.1  server that wishes to interoperate with TLS 1.0\n  \
    \ or SSL 3.0 clients SHOULD accept SSL 3.0 client hello messages and\n   respond\
    \ with a SSL 3.0 server hello if an SSL 3.0 client hello with a\n   version field\
    \ of {3, 0} is received, denoting that this client does\n   not support TLS. \
    \ Similarly, if a SSL 3.0 or TLS 1.0 hello with a\n   version field of {3, 1}\
    \ is received, the server SHOULD respond with a\n   TLS 1.0 hello with a version\
    \ field of {3, 1}.\n   Whenever a client already knows the highest protocol known\
    \ to a\n   server (for example, when resuming a session), it SHOULD initiate the\n\
    \   connection in that native protocol.\n   TLS 1.1 clients that support SSL Version\
    \ 2.0 servers MUST send SSL\n   Version 2.0 client hello messages [SSL2].  TLS\
    \ servers SHOULD accept\n   either client hello format if they wish to support\
    \ SSL 2.0 clients on\n   the same connection port.  The only deviations from the\
    \ Version 2.0\n   specification are the ability to specify a version with a value\
    \ of\n   three and the support for more ciphering types in the CipherSpec.\n \
    \ Warning: The ability to send Version 2.0 client hello messages will be\n   \
    \    phased out with all due haste.  Implementors SHOULD make every\n       effort\
    \ to move forward as quickly as possible.  Version 3.0\n       provides better\
    \ mechanisms for moving to newer versions.\n       The following cipher specifications\
    \ are carryovers from SSL\n       Version 2.0. These are assumed to use RSA for\
    \ key exchange and\n       authentication.\n        V2CipherSpec TLS_RC4_128_WITH_MD5\
    \          = { 0x01,0x00,0x80 };\n        V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5\
    \ = { 0x02,0x00,0x80 };\n        V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  =\
    \ { 0x03,0x00,0x80 };\n        V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5\n\
    \                                                   = { 0x04,0x00,0x80 };\n  \
    \      V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };\n    \
    \    V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };\n      \
    \  V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };\n       Cipher\
    \ specifications native to TLS can be included in Version\n       2.0 client hello\
    \ messages using the syntax below.  Any\n       V2CipherSpec element with its\
    \ first byte equal to zero will be\n       ignored by Version 2.0 servers.  Clients\
    \ sending any of the above\n       V2CipherSpecs SHOULD also include the TLS equivalent\
    \ (see\n       Appendix A.5):\n        V2CipherSpec (see TLS name) = { 0x00, CipherSuite\
    \ };\n   Note: TLS 1.1 clients may generate the SSLv2 EXPORT cipher suites in\n\
    \       handshakes for backward compatibility but MUST NOT negotiate them\n  \
    \     in TLS 1.1 mode.\n"
- title: E.1. Version 2 Client Hello
  contents:
  - "E.1. Version 2 Client Hello\n   The Version 2.0 client hello message is presented\
    \ below using this\n   document's presentation model.  The true definition is\
    \ still assumed\n   to be the SSL Version 2.0 specification.  Note that this message\
    \ MUST\n   be sent directly on the wire, not wrapped as an SSLv3 record\n    \
    \ uint8 V2CipherSpec[3];\n     struct {\n         uint16 msg_length;\n       \
    \  uint8 msg_type;\n         Version version;\n         uint16 cipher_spec_length;\n\
    \         uint16 session_id_length;\n         uint16 challenge_length;\n     \
    \    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n         opaque\
    \ session_id[V2ClientHello.session_id_length];\n         opaque challenge[V2ClientHello.challenge_length;\n\
    \     } V2ClientHello;\n   msg_length\n      This field is the length of the following\
    \ data in bytes.  The high\n      bit MUST be 1 and is not part of the length.\n\
    \   msg_type\n      This field, in conjunction with the version field, identifies\
    \ a\n      version 2 client hello message.  The value SHOULD be one (1).\n   version\n\
    \      The highest version of the protocol supported by the client\n      (equals\
    \ ProtocolVersion.version; see Appendix A.1).\n   cipher_spec_length\n      This\
    \ field is the total length of the field cipher_specs.  It\n      cannot be zero\
    \ and MUST be a multiple of the V2CipherSpec length\n      (3).\n   session_id_length\n\
    \      This field MUST have a value of zero.\n   challenge_length\n      The length\
    \ in bytes of the client's challenge to the server to\n      authenticate itself.\
    \  When using the SSLv2 backward compatible\n      handshake the client MUST use\
    \ a 32-byte challenge.\n   cipher_specs\n      This is a list of all CipherSpecs\
    \ the client is willing and able\n      to use.  There MUST be at least one CipherSpec\
    \ acceptable to the\n      server.\n   session_id\n      This field MUST be empty.\n\
    \   challenge The client challenge to the server for the server to\n      identify\
    \ itself is a (nearly) arbitrary-length random.  The TLS\n      server will right-justify\
    \ the challenge data to become the\n      ClientHello.random data (padded with\
    \ leading zeroes, if\n      necessary), as specified in this protocol specification.\
    \  If the\n      length of the challenge is greater than 32 bytes, only the last\
    \ 32\n      bytes are used.  It is legitimate (but not necessary) for a V3\n \
    \     server to reject a V2 ClientHello that has fewer than 16 bytes of\n    \
    \  challenge data.\n      Note: Requests to resume a TLS session MUST use a TLS\
    \ client\n            hello.\n"
- title: E.2. Avoiding Man-in-the-Middle Version Rollback
  contents:
  - "E.2. Avoiding Man-in-the-Middle Version Rollback\n   When TLS clients fall back\
    \ to Version 2.0 compatibility mode, they\n   SHOULD use special PKCS #1 block\
    \ formatting.  This is done so that\n   TLS servers will reject Version 2.0 sessions\
    \ with TLS-capable\n   clients.\n   When TLS clients are in Version 2.0 compatibility\
    \ mode, they set the\n   right-hand (least significant) 8 random bytes of the\
    \ PKCS padding\n   (not including the terminal null of the padding) for the RSA\n\
    \   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY\n   to\
    \ 0x03 (the other padding bytes are random).  After decrypting the\n   ENCRYPTED-KEY-DATA\
    \ field, servers that support TLS SHOULD issue an\n   error if these eight padding\
    \ bytes are 0x03.  Version 2.0 servers\n   receiving blocks padded in this manner\
    \ will proceed normally.\n"
- title: Appendix F. Security Analysis
  contents:
  - "Appendix F. Security Analysis\n   The TLS protocol is designed to establish a\
    \ secure connection between\n   a client and a server communicating over an insecure\
    \ channel.  This\n   document makes several traditional assumptions, including\
    \ that\n   attackers have substantial computational resources and cannot obtain\n\
    \   secret information from sources outside the protocol.  Attackers are\n   assumed\
    \ to have the ability to capture, modify, delete, replay, and\n   otherwise tamper\
    \ with messages sent over the communication channel.\n   This appendix outlines\
    \ how TLS has been designed to resist a variety\n   of attacks.\n"
- title: F.1. Handshake Protocol
  contents:
  - "F.1. Handshake Protocol\n   The handshake protocol is responsible for selecting\
    \ a CipherSpec and\n   generating a Master Secret, which together comprise the\
    \ primary\n   cryptographic parameters associated with a secure session.  The\n\
    \   handshake protocol can also optionally authenticate parties who have\n   certificates\
    \ signed by a trusted certificate authority.\n"
- title: F.1.1. Authentication and Key Exchange
  contents:
  - "F.1.1. Authentication and Key Exchange\n   TLS supports three authentication\
    \ modes: authentication of both\n   parties, server authentication with an unauthenticated\
    \ client, and\n   total anonymity.  Whenever the server is authenticated, the\
    \ channel\n   is secure against man-in-the-middle attacks, but completely anonymous\n\
    \   sessions are inherently vulnerable to such attacks.  Anonymous\n   servers\
    \ cannot authenticate clients.  If the server is authenticated,\n   its certificate\
    \ message must provide a valid certificate chain\n   leading to an acceptable\
    \ certificate authority.  Similarly,\n   authenticated clients must supply an\
    \ acceptable certificate to the\n   server.  Each party is responsible for verifying\
    \ that the other's\n   certificate is valid and has not expired or been revoked.\n\
    \   The general goal of the key exchange process is to create a\n   pre_master_secret\
    \ known to the communicating parties and not to\n   attackers.  The pre_master_secret\
    \ will be used to generate the\n   master_secret (see Section 8.1).  The master_secret\
    \ is required to\n   generate the finished messages, encryption keys, and MAC\
    \ secrets (see\n   Sections 7.4.8, 7.4.9, and 6.3).  By sending a correct finished\n\
    \   message, parties thus prove that they know the correct\n   pre_master_secret.\n"
- title: F.1.1.1. Anonymous Key Exchange
  contents:
  - "F.1.1.1. Anonymous Key Exchange\n   Completely anonymous sessions can be established\
    \ using RSA or Diffie-\n   Hellman for key exchange.  With anonymous RSA, the\
    \ client encrypts a\n   pre_master_secret with the server's uncertified public\
    \ key extracted\n   from the server key exchange message.  The result is sent\
    \ in a client\n   key exchange message.  Since eavesdroppers do not know the server's\n\
    \   private key, it will be infeasible for them to decode the\n   pre_master_secret.\n\
    \   Note: No anonymous RSA Cipher Suites are defined in this document.\n   With\
    \ Diffie-Hellman, the server's public parameters are contained in\n   the server\
    \ key exchange message and the client's are sent in the\n   client key exchange\
    \ message.  Eavesdroppers who do not know the\n   private values should not be\
    \ able to find the Diffie-Hellman result\n   (i.e., the pre_master_secret).\n\
    \   Warning: Completely anonymous connections only provide protection\n      \
    \      against passive eavesdropping.  Unless an independent\n            tamper-proof\
    \ channel is used to verify that the finished\n            messages were not replaced\
    \ by an attacker, server\n            authentication is required in environments\
    \ where active\n            man-in-the-middle attacks are a concern.\n"
- title: F.1.1.2. RSA Key Exchange and Authentication
  contents:
  - "F.1.1.2. RSA Key Exchange and Authentication\n   With RSA, key exchange and server\
    \ authentication are combined.  The\n   public key either may be contained in\
    \ the server's certificate or may\n   be a temporary RSA key sent in a server\
    \ key exchange message.  When\n   temporary RSA keys are used, they are signed\
    \ by the server's RSA\n   certificate.  The signature includes the current ClientHello.random,\n\
    \   so old signatures and temporary keys cannot be replayed.  Servers may\n  \
    \ use a single temporary RSA key for multiple negotiation sessions.\n   Note:\
    \ The temporary RSA key option is useful if servers need large\n         certificates\
    \ but must comply with government-imposed size\n         limits on keys used for\
    \ key exchange.\n   Note that if ephemeral RSA is not used, compromise of the\
    \ server's\n   static RSA key results in a loss of confidentiality for all sessions\n\
    \   protected under that static key.  TLS users desiring Perfect Forward\n   Secrecy\
    \ should use DHE cipher suites.  The damage done by exposure of\n   a private\
    \ key can be limited by changing one's private key (and\n   certificate) frequently.\n\
    \   After verifying the server's certificate, the client encrypts a\n   pre_master_secret\
    \ with the server's public key.  By successfully\n   decoding the pre_master_secret\
    \ and producing a correct finished\n   message, the server demonstrates that it\
    \ knows the private key\n   corresponding to the server certificate.\n   When\
    \ RSA is used for key exchange, clients are authenticated using\n   the certificate\
    \ verify message (see Section 7.4.8).  The client signs\n   a value derived from\
    \ the master_secret and all preceding handshake\n   messages.  These handshake\
    \ messages include the server certificate,\n   which binds the signature to the\
    \ server, and ServerHello.random,\n   which binds the signature to the current\
    \ handshake process.\n"
- title: F.1.1.3. Diffie-Hellman Key Exchange with Authentication
  contents:
  - "F.1.1.3. Diffie-Hellman Key Exchange with Authentication\n   When Diffie-Hellman\
    \ key exchange is used, the server can either\n   supply a certificate containing\
    \ fixed Diffie-Hellman parameters or\n   use the server key exchange message to\
    \ send a set of temporary\n   Diffie-Hellman parameters signed with a DSS or RSA\
    \ certificate.\n   Temporary parameters are hashed with the hello.random values\
    \ before\n   signing to ensure that attackers do not replay old parameters.  In\n\
    \   either case, the client can verify the certificate or signature to\n   ensure\
    \ that the parameters belong to the server.\n   If the client has a certificate\
    \ containing fixed Diffie-Hellman\n   parameters, its certificate contains the\
    \ information required to\n   complete the key exchange.  Note that in this case\
    \ the client and\n   server will generate the same Diffie-Hellman result (i.e.,\n\
    \   pre_master_secret) every time they communicate.  To prevent the\n   pre_master_secret\
    \ from staying in memory any longer than necessary,\n   it should be converted\
    \ into the master_secret as soon as possible.\n   Client Diffie-Hellman parameters\
    \ must be compatible with those\n   supplied by the server for the key exchange\
    \ to work.\n   If the client has a standard DSS or RSA certificate or is\n   unauthenticated,\
    \ it sends a set of temporary parameters to the server\n   in the client key exchange\
    \ message, then optionally uses a\n   certificate verify message to authenticate\
    \ itself.\n   If the same DH keypair is to be used for multiple handshakes, either\n\
    \   because the client or server has a certificate containing a fixed DH\n   keypair\
    \ or because the server is reusing DH keys, care must be taken\n   to prevent\
    \ small subgroup attacks.  Implementations SHOULD follow the\n   guidelines found\
    \ in [SUBGROUP].\n   Small subgroup attacks are most easily avoided by using one\
    \ of the\n   DHE ciphersuites and generating a fresh DH private key (X) for each\n\
    \   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can\n   be\
    \ computed very quickly, therefore the performance cost is\n   minimized.  Additionally,\
    \ using a fresh key for each handshake\n   provides Perfect Forward Secrecy. \
    \ Implementations SHOULD generate a\n   new X for each handshake when using DHE\
    \ ciphersuites.\n"
- title: F.1.2. Version Rollback Attacks
  contents:
  - "F.1.2. Version Rollback Attacks\n   Because TLS includes substantial improvements\
    \ over SSL Version 2.0,\n   attackers may try to make TLS-capable clients and\
    \ servers fall back\n   to Version 2.0. This attack can occur if (and only if)\
    \ two TLS-\n   capable parties use an SSL 2.0 handshake.\n   Although the solution\
    \ using non-random PKCS #1 block type 2 message\n   padding is inelegant, it provides\
    \ a reasonably secure way for Version\n   3.0 servers to detect the attack.  This\
    \ solution is not secure\n   against attackers who can brute force the key and\
    \ substitute a new\n   ENCRYPTED-KEY-DATA message containing the same key (but\
    \ with normal\n   padding) before the application specified wait threshold has\
    \ expired.\n   Parties concerned about attacks of this scale should not use 40-bit\n\
    \   encryption keys.  Altering the padding of the least-significant 8\n   bytes\
    \ of the PKCS padding does not impact security for the size of\n   the signed\
    \ hashes and RSA key lengths used in the protocol, since\n   this is essentially\
    \ equivalent to increasing the input block size by\n   8 bytes.\n"
- title: F.1.3. Detecting Attacks against the Handshake Protocol
  contents:
  - "F.1.3. Detecting Attacks against the Handshake Protocol\n   An attacker might\
    \ try to influence the handshake exchange to make the\n   parties select different\
    \ encryption algorithms than they would\n   normally chooses.\n   For this attack,\
    \ an attacker must actively change one or more\n   handshake messages.  If this\
    \ occurs, the client and server will\n   compute different values for the handshake\
    \ message hashes.  As a\n   result, the parties will not accept each others' finished\
    \ messages.\n   Without the master_secret, the attacker cannot repair the finished\n\
    \   messages, so the attack will be discovered.\n"
- title: F.1.4. Resuming Sessions
  contents:
  - "F.1.4. Resuming Sessions\n   When a connection is established by resuming a session,\
    \ new\n   ClientHello.random and ServerHello.random values are hashed with the\n\
    \   session's master_secret.  Provided that the master_secret has not\n   been\
    \ compromised and that the secure hash operations used to produce\n   the encryption\
    \ keys and MAC secrets are secure, the connection should\n   be secure and effectively\
    \ independent from previous connections.\n   Attackers cannot use known encryption\
    \ keys or MAC secrets to\n   compromise the master_secret without breaking the\
    \ secure hash\n   operations (which use both SHA and MD5).\n   Sessions cannot\
    \ be resumed unless both the client and server agree.\n   If either party suspects\
    \ that the session may have been compromised,\n   or that certificates may have\
    \ expired or been revoked, it should\n   force a full handshake.  An upper limit\
    \ of 24 hours is suggested for\n   session ID lifetimes, since an attacker who\
    \ obtains a master_secret\n   may be able to impersonate the compromised party\
    \ until the\n   corresponding session ID is retired.  Applications that may be\
    \ run in\n   relatively insecure environments should not write session IDs to\n\
    \   stable storage.\n"
- title: F.1.5. MD5 and SHA
  contents:
  - "F.1.5. MD5 and SHA\n   TLS uses hash functions very conservatively.  Where possible,\
    \ both\n   MD5 and SHA are used in tandem to ensure that non-catastrophic flaws\n\
    \   in one algorithm will not break the overall protocol.\n"
- title: F.2. Protecting Application Data
  contents:
  - "F.2. Protecting Application Data\n   The master_secret is hashed with the ClientHello.random\
    \ and\n   ServerHello.random to produce unique data encryption keys and MAC\n\
    \   secrets for each connection.\n   Outgoing data is protected with a MAC before\
    \ transmission.  To\n   prevent message replay or modification attacks, the MAC\
    \ is computed\n   from the MAC secret, the sequence number, the message length,\
    \ the\n   message contents, and two fixed character strings.  The message type\n\
    \   field is necessary to ensure that messages intended for one TLS\n   Record\
    \ Layer client are not redirected to another.  The sequence\n   number ensures\
    \ that attempts to delete or reorder messages will be\n   detected.  Since sequence\
    \ numbers are 64 bits long, they should never\n   overflow.  Messages from one\
    \ party cannot be inserted into the\n   other's output, since they use independent\
    \ MAC secrets.  Similarly,\n   the server-write and client-write keys are independent,\
    \ so stream\n   cipher keys are used only once.\n   If an attacker does break\
    \ an encryption key, all messages encrypted\n   with it can be read.  Similarly,\
    \ compromise of a MAC key can make\n   message modification attacks possible.\
    \  Because MACs are also\n   encrypted, message-alteration attacks generally require\
    \ breaking the\n   encryption algorithm as well as the MAC.\n   Note: MAC secrets\
    \ may be larger than encryption keys, so messages can\n         remain tamper\
    \ resistant even if encryption keys are broken.\n"
- title: F.3. Explicit IVs
  contents:
  - "F.3. Explicit IVs\n   [CBCATT] describes a chosen plaintext attack on TLS that\
    \ depends on\n   knowing the IV for a record.  Previous versions of TLS [TLS1.0]\
    \ used\n   the CBC residue of the previous record as the IV and therefore\n  \
    \ enabled this attack.  This version uses an explicit IV in order to\n   protect\
    \ against this attack.\n"
- title: F.4. Security of Composite Cipher Modes
  contents:
  - "F.4. Security of Composite Cipher Modes\n   TLS secures transmitted application\
    \ data via the use of symmetric\n   encryption and authentication functions defined\
    \ in the negotiated\n   ciphersuite.  The objective is to protect both the integrity\
    \ and\n   confidentiality of the transmitted data from malicious actions by\n\
    \   active attackers in the network.  It turns out that the order in\n   which\
    \ encryption and authentication functions are applied to the data\n   plays an\
    \ important role for achieving this goal [ENCAUTH].\n   The most robust method,\
    \ called encrypt-then-authenticate, first\n   applies encryption to the data and\
    \ then applies a MAC to the\n   ciphertext.  This method ensures that the integrity\
    \ and\n   confidentiality goals are obtained with ANY pair of encryption and\n\
    \   MAC functions, provided that the former is secure against chosen\n   plaintext\
    \ attacks and that the MAC is secure against chosen-message\n   attacks.  TLS\
    \ uses another method, called authenticate-then-encrypt,\n   in which first a\
    \ MAC is computed on the plaintext and then the\n   concatenation of plaintext\
    \ and MAC is encrypted.  This method has\n   been proven secure for CERTAIN combinations\
    \ of encryption functions\n   and MAC functions, but it is not guaranteed to be\
    \ secure in general.\n   In particular, it has been shown that there exist perfectly\
    \ secure\n   encryption functions (secure even in the information-theoretic sense)\n\
    \   that combined with any secure MAC function, fail to provide the\n   confidentiality\
    \ goal against an active attack.  Therefore, new\n   ciphersuites and operation\
    \ modes adopted into TLS need to be analyzed\n   under the authenticate-then-encrypt\
    \ method to verify that they\n   achieve the stated integrity and confidentiality\
    \ goals.\n   Currently, the security of the authenticate-then-encrypt method has\n\
    \   been proven for some important cases.  One is the case of stream\n   ciphers\
    \ in which a computationally unpredictable pad of the length of\n   the message,\
    \ plus the length of the MAC tag, is produced using a\n   pseudo-random generator\
    \ and this pad is xor-ed with the concatenation\n   of plaintext and MAC tag.\
    \  The other is the case of CBC mode using a\n   secure block cipher.  In this\
    \ case, security can be shown if one\n   applies one CBC encryption pass to the\
    \ concatenation of plaintext and\n   MAC and uses a new, independent, and unpredictable\
    \ IV for each new\n   pair of plaintext and MAC.  In previous versions of SSL,\
    \ CBC mode was\n   used properly EXCEPT that it used a predictable IV in the form\
    \ of the\n   last block of the previous ciphertext.  This made TLS open to chosen\n\
    \   plaintext attacks.  This version of the protocol is immune to those\n   attacks.\
    \  For exact details in the encryption modes proven secure,\n   see [ENCAUTH].\n"
- title: F.5. Denial of Service
  contents:
  - "F.5. Denial of Service\n   TLS is susceptible to a number of denial of service\
    \ (DoS) attacks.\n   In particular, an attacker who initiates a large number of\
    \ TCP\n   connections can cause a server to consume large amounts of CPU doing\n\
    \   RSA decryption.  However, because TLS is generally used over TCP, it\n   is\
    \ difficult for the attacker to hide his point of origin if proper\n   TCP SYN\
    \ randomization is used [SEQNUM] by the TCP stack.\n   Because TLS runs over TCP,\
    \ it is also susceptible to a number of\n   denial of service attacks on individual\
    \ connections.  In particular,\n   attackers can forge RSTs, thereby terminating\
    \ connections, or forge\n   partial TLS records, thereby causing the connection\
    \ to stall.  These\n   attacks cannot in general be defended against by a TCP-using\n\
    \   protocol.  Implementors or users who are concerned with this class of\n  \
    \ attack should use IPsec AH [AH-ESP] or ESP [AH-ESP].\n"
- title: F.6. Final Notes
  contents:
  - "F.6. Final Notes\n   For TLS to be able to provide a secure connection, both\
    \ the client\n   and server systems, keys, and applications must be secure.  In\n\
    \   addition, the implementation must be free of security errors.\n   The system\
    \ is only as strong as the weakest key exchange and\n   authentication algorithm\
    \ supported, and only trustworthy\n   cryptographic functions should be used.\
    \  Short public keys, 40-bit\n   bulk encryption keys, and anonymous servers should\
    \ be used with great\n   caution.  Implementations and users must be careful when\
    \ deciding\n   which certificates and certificate authorities are acceptable;\
    \ a\n   dishonest certificate authority can do tremendous damage.\n"
- title: Normative References
  contents:
  - "Normative References\n   [AES]      National Institute of Standards and Technology,\n\
    \              \"Specification for the Advanced Encryption Standard (AES)\"\n\
    \              FIPS 197.  November 26, 2001.\n   [3DES]     W. Tuchman, \"Hellman\
    \ Presents No Shortcut Solutions To\n              DES,\" IEEE Spectrum, v. 16,\
    \ n. 7, July 1979, pp. 40-41.\n   [DES]      ANSI X3.106, \"American National\
    \ Standard for Information\n              Systems-Data Link Encryption,\" American\
    \ National Standards\n              Institute, 1983.\n   [DSS]      NIST FIPS\
    \ PUB 186-2, \"Digital Signature Standard,\"\n              National Institute\
    \ of Standards and Technology, U.S.\n              Department of Commerce, 2000.\n\
    \   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:  Keyed-\n  \
    \            Hashing for Message Authentication\", RFC 2104, February\n      \
    \        1997.\n   [IDEA]     X. Lai, \"On the Design and Security of Block Ciphers,\"\
    \ ETH\n              Series in Information Processing, v. 1, Konstanz:\n     \
    \         Hartung-Gorre Verlag, 1992.\n   [MD5]      Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm \", RFC 1321,\n              April 1992.\n   [PKCS1A]   B. Kaliski,\
    \ \"Public-Key Cryptography Standards (PKCS) #1:\n              RSA Cryptography\
    \ Specifications Version 1.5\", RFC 2313,\n              March 1998.\n   [PKCS1B]\
    \   J. Jonsson, B. Kaliski, \"Public-Key Cryptography Standards\n            \
    \  (PKCS) #1: RSA Cryptography Specifications Version 2.1\",\n              RFC\
    \ 3447, February 2003.\n   [PKIX]     Housley, R., Polk, W., Ford, W., and D.\
    \ Solo, \"Internet\n              X.509 Public Key Infrastructure Certificate\
    \ and\n              Certificate Revocation List (CRL) Profile\", RFC 3280,\n\
    \              April 2002.\n   [RC2]      Rivest, R., \"A Description of the RC2(r)\
    \ Encryption\n              Algorithm\", RFC 2268, March 1998.\n   [SCH]     \
    \ B. Schneier. \"Applied Cryptography: Protocols, Algorithms,\n              and\
    \ Source Code in C, 2ed\", Published by John Wiley &\n              Sons, Inc.\
    \ 1996.\n   [SHA]      NIST FIPS PUB 180-2, \"Secure Hash Standard,\" National\n\
    \              Institute of Standards and Technology, U.S. Department of\n   \
    \           Commerce., August 2001.\n   [REQ]      Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n\
    \              October 1998.\n   [TLSAES]   Chown, P., \"Advanced Encryption Standard\
    \ (AES)\n              Ciphersuites for Transport Layer Security (TLS)\", RFC\n\
    \              3268, June 2002.\n   [TLSEXT]   Blake-Wilson, S., Nystrom, M.,\
    \ Hopwood, D., Mikkelsen, J.,\n              and T. Wright, \"Transport Layer\
    \ Security (TLS)\n              Extensions\", RFC 3546, June 2003.\n   [TLSKRB]\
    \   Medvinsky, A. and M. Hur, \"Addition of Kerberos Cipher\n              Suites\
    \ to Transport Layer Security (TLS)\", RFC 2712,\n              October 1999.\n"
- title: Informative References
  contents:
  - "Informative References\n   [AH-ESP]   Kent, S., \"IP Authentication Header\"\
    , RFC 4302, December\n              2005.\n              Eastlake 3rd, D., \"\
    Cryptographic Algorithm Implementation\n              Requirements for Encapsulating\
    \ Security Payload (ESP) and\n              Authentication Header (AH)\", RFC\
    \ 4305, December 2005.\n   [BLEI]     Bleichenbacher D., \"Chosen Ciphertext Attacks\
    \ against\n              Protocols Based on RSA Encryption Standard PKCS #1\"\
    \ in\n              Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,\n   \
    \           pages:  1-12, 1998.\n   [CBCATT]   Moeller, B., \"Security of CBC\
    \ Ciphersuites in SSL/TLS:\n              Problems and Countermeasures\",\n  \
    \            http://www.openssl.org/~bodo/tls-cbc.txt.\n   [CBCTIME]  Canvel,\
    \ B., \"Password Interception in a SSL/TLS Channel\",\n              http://lasecwww.epfl.ch/memo_ssl.shtml,\
    \ 2003.\n   [ENCAUTH]  Krawczyk, H., \"The Order of Encryption and Authentication\n\
    \              for Protecting Communications (Or: How Secure is SSL?)\",\n   \
    \           Crypto 2001.\n   [KPR03]    Klima, V., Pokorny, O., Rosa, T., \"Attacking\
    \ RSA-based\n              Sessions in SSL/TLS\", http://eprint.iacr.org/2003/052/,\n\
    \              March 2003.\n   [PKCS6]    RSA Laboratories, \"PKCS #6: RSA Extended\
    \ Certificate\n              Syntax Standard,\" version 1.5, November 1993.\n\
    \   [PKCS7]    RSA Laboratories, \"PKCS #7: RSA Cryptographic Message\n      \
    \        Syntax Standard,\" version 1.5, November 1993.\n   [RANDOM]   Eastlake,\
    \ D., 3rd, Schiller, J., and S. Crocker,\n              \"Randomness Requirements\
    \ for Security\", BCP 106, RFC 4086,\n              June 2005.\n   [RSA]     \
    \ R. Rivest, A. Shamir, and L. M. Adleman, \"A Method for\n              Obtaining\
    \ Digital Signatures and Public-Key\n              Cryptosystems,\" Communications\
    \ of the ACM, v. 21, n. 2,\n              Feb 1978, pp.  120-126.\n   [SEQNUM]\
    \   Bellovin, S., \"Defending Against Sequence Number Attacks\",\n           \
    \   RFC 1948, May 1996.\n   [SSL2]     Hickman, Kipp, \"The SSL Protocol\", Netscape\
    \ Communications\n              Corp., Feb 9, 1995.\n   [SSL3]     A. Frier, P.\
    \ Karlton, and P. Kocher, \"The SSL 3.0\n              Protocol\", Netscape Communications\
    \ Corp., Nov 18, 1996.\n   [SUBGROUP] Zuccherato, R., \"Methods for Avoiding the\
    \ \"Small-Subgroup\"\n              Attacks on the Diffie-Hellman Key Agreement\
    \ Method for\n              S/MIME\", RFC 2785, March 2000.\n   [TCP]      Hellstrom,\
    \ G. and P. Jones, \"RTP Payload for Text\n              Conversation\", RFC 4103,\
    \ June 2005.\n   [TIMING]   Boneh, D., Brumley, D., \"Remote timing attacks are\n\
    \              practical\", USENIX Security Symposium 2003.\n   [TLS1.0]   Dierks,\
    \ T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246,\
    \ January 1999.\n   [X501]     ITU-T Recommendation X.501: Information Technology\
    \ - Open\n              Systems Interconnection - The Directory: Models, 1993.\n\
    \   [X509]     ITU-T Recommendation X.509 (1997 E): Information\n            \
    \  Technology - Open Systems Interconnection - \"The Directory\n             \
    \ - Authentication Framework\". 1988.\n   [XDR]      Srinivasan, R., \"XDR: External\
    \ Data Representation\n              Standard\", RFC 1832, August 1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Working Group Chairs\n   Win Treese\n   EMail: treese@acm.org\n\
    \   Eric Rescorla\n   EMail: ekr@rtfm.com\n"
- title: Editors
  contents:
  - "Editors\n   Tim Dierks\n   Independent\n   EMail: tim@dierks.org\n   Eric Rescorla\n\
    \   RTFM, Inc.\n   EMail: ekr@rtfm.com\n"
- title: Other Contributors
  contents:
  - "Other Contributors\n   Christopher Allen (co-editor of TLS 1.0)\n   Alacrity\
    \ Ventures\n   EMail: ChristopherA@AlacrityManagement.com\n   Martin Abadi\n \
    \  University of California, Santa Cruz\n   EMail: abadi@cs.ucsc.edu\n   Ran Canetti\n\
    \   IBM\n   EMail: canetti@watson.ibm.com\n   Taher Elgamal\n   Securify\n   EMail:\
    \ taher@securify.com\n   Anil Gangolli\n   EMail: anil@busybuddha.org\n   Kipp\
    \ Hickman\n   Phil Karlton (co-author of SSLv3)\n   Paul Kocher (co-author of\
    \ SSLv3)\n   Cryptography Research\n   EMail: paul@cryptography.com\n   Hugo Krawczyk\n\
    \   Technion Israel Institute of Technology\n   EMail: hugo@ee.technion.ac.il\n\
    \   Robert Relyea\n   Netscape Communications\n   EMail: relyea@netscape.com\n\
    \   Jim Roskind\n   Netscape Communications\n   EMail: jar@netscape.com\n   Michael\
    \ Sabin\n   Dan Simon\n   Microsoft, Inc.\n   EMail: dansimon@microsoft.com\n\
    \   Tom Weinstein\n"
- title: Comments
  contents:
  - "Comments\n   The discussion list for the IETF TLS working group is located at\
    \ the\n   e-mail address <ietf-tls@lists.consensus.com>. Information on the\n\
    \   group and information on how to subscribe to the list is at\n   <http://lists.consensus.com/>.\n\
    \   Archives of the list can be found at:\n       <http://www.imc.org/ietf-tls/mail-archive/>\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
