- contents:
  - "                Version 2 of the Protocol Operations for\n             the Simple
    Network Management Protocol (SNMP)\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines version 2 of the protocol operations for the\n
    \  Simple Network Management Protocol (SNMP).  It defines the syntax and\n   elements
    of procedure for sending, receiving, and processing SNMP\n   PDUs.  This document
    obsoletes RFC 1905.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ................................................
    \   3\n   2. Overview ....................................................    4\n
    \  2.1. Management Information ....................................    4\n   2.2.
    Retransmission of Requests ................................    4\n   2.3. Message
    Sizes .............................................    4\n   2.4. Transport Mappings
    ........................................    5\n   2.5. SMIv2 Data Type Mappings
    ..................................    6\n   3. Definitions .................................................
    \   6\n   4. Protocol Specification ......................................    9\n
    \  4.1. Common Constructs .........................................    9\n   4.2.
    PDU Processing ............................................   10\n   4.2.1. The
    GetRequest-PDU ......................................   10\n   4.2.2. The GetNextRequest-PDU
    ..................................   11\n   4.2.2.1. Example of Table Traversal
    ............................   12\n   4.2.3. The GetBulkRequest-PDU ..................................
    \  14\n   4.2.3.1. Another Example of Table Traversal ....................   17\n
    \  4.2.4. The Response-PDU ........................................   18\n   4.2.5.
    The SetRequest-PDU ......................................   19\n   4.2.6. The
    SNMPv2-Trap-PDU .....................................   22\n   4.2.7. The InformRequest-PDU
    ...................................   23\n   5. Notice on Intellectual Property
    .............................   24\n   6. Acknowledgments .............................................
    \  24\n   7. Security Considerations .....................................   26\n
    \  8. References ..................................................   26\n   8.1.
    Normative References ......................................   26\n   8.2. Informative
    References ....................................   27\n   9. Changes from RFC 1905
    .......................................   28\n   10. Editor's Address ...........................................
    \  30\n   11. Full Copyright Statement ...................................   31\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The SNMP Management Framework at the time of this writing
    consists of\n   five major components:\n      -  An overall architecture, described
    in STD 62, RFC 3411\n         [RFC3411].\n      -  Mechanisms for describing and
    naming objects and events for the\n         purpose of management.  The first
    version of this Structure of\n         Management Information (SMI) is called
    SMIv1 and described in\n         STD 16, RFC 1155 [RFC1155], STD 16, RFC 1212
    [RFC1212] and RFC\n         1215 [RFC1215].  The second version, called SMIv2,
    is described\n         in STD 58, RFC 2578 [RFC2578], STD 58, RFC 2579 [RFC2579]
    and\n         STD 58, RFC 2580 [RFC2580].\n      -  Message protocols for transferring
    management information.  The\n         first version of the SNMP message protocol
    is called SNMPv1 and\n         described in STD 15, RFC 1157 [RFC1157].  A second
    version of\n         the SNMP message protocol, which is not an Internet standards\n
    \        track protocol, is called SNMPv2c and described in RFC 1901\n         [RFC1901]
    and STD 62, RFC 3417 [RFC3417].  The third version of\n         the message protocol
    is called SNMPv3 and described in STD 62,\n         RFC 3417 [RFC3417], RFC 3412
    [RFC3412] and RFC 3414 [RFC3414].\n      -  Protocol operations for accessing
    management information.  The\n         first set of protocol operations and associated
    PDU formats is\n         described in STD 15, RFC 1157 [RFC1157].  A second set
    of\n         protocol operations and associated PDU formats is described in\n
    \        this document.\n      -  A set of fundamental applications described
    in STD 62, RFC 3413\n         [RFC3413] and the view-based access control mechanism
    described\n         in STD 62, RFC 3415 [RFC3415].\n   A more detailed introduction
    to the SNMP Management Framework at the\n   time of this writing can be found
    in RFC 3410 [RFC3410].\n   Managed objects are accessed via a virtual information
    store, termed\n   the Management Information Base or MIB.  Objects in the MIB
    are\n   defined using the mechanisms defined in the SMI.\n   This document, Version
    2 of the Protocol Operations for the Simple\n   Network Management Protocol, defines
    the operations of the protocol\n   with respect to the sending and receiving of
    PDUs to be carried by\n   the message protocol.\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   SNMP entities supporting command generator or notification receiver\n
    \  applications (traditionally called \"managers\") communicate with SNMP\n   entities
    supporting command responder or notification originator\n   applications (traditionally
    called \"agents\").  The purpose of this\n   protocol is the transport of management
    information and operations.\n"
  - contents:
    - "2.1.  Management Information\n   The term \"variable\" refers to an instance
      of a non-aggregate object\n   type defined according to the conventions set
      forth in the SMI\n   [RFC2578] or the textual conventions based on the SMI [RFC2579].
      \ The\n   term \"variable binding\" normally refers to the pairing of the name
      of\n   a variable and its associated value.  However, if certain kinds of\n
      \  exceptional conditions occur during processing of a retrieval\n   request,
      a variable binding will pair a name and an indication of\n   that exception.\n
      \  A variable-binding list is a simple list of variable bindings.\n   The name
      of a variable is an OBJECT IDENTIFIER which is the\n   concatenation of the
      OBJECT IDENTIFIER of the corresponding object-\n   type together with an OBJECT
      IDENTIFIER fragment identifying the\n   instance.  The OBJECT IDENTIFIER of
      the corresponding object-type is\n   called the OBJECT IDENTIFIER prefix of
      the variable.\n"
    title: 2.1.  Management Information
  - contents:
    - "2.2.  Retransmission of Requests\n   For all types of request in this protocol,
      the receiver is required\n   under normal circumstances, to generate and transmit
      a response to\n   the originator of the request.  Whether or not a request should
      be\n   retransmitted if no corresponding response is received in an\n   appropriate
      time interval, is at the discretion of the application\n   originating the request.
      \ This will normally depend on the urgency of\n   the request.  However, such
      an application needs to act responsibly\n   in respect to the frequency and
      duration of re-transmissions.  See\n   BCP 41 [RFC2914] for discussion of relevant
      congestion control\n   principles.\n"
    title: 2.2.  Retransmission of Requests
  - contents:
    - "2.3.  Message Sizes\n   The maximum size of an SNMP message is limited to the
      minimum of:\n   (1)   the maximum message size which the destination SNMP entity
      can\n         accept; and,\n   (2)   the maximum message size which the source
      SNMP entity can\n         generate.\n   The former may be known on a per-recipient
      basis; and in the absence\n   of such knowledge, is indicated by transport domain
      used when sending\n   the message.  The latter is imposed by implementation-specific
      local\n   constraints.\n   Each transport mapping for the SNMP indicates the
      minimum message\n   size which a SNMP implementation must be able to produce
      or consume.\n   Although implementations are encouraged to support larger values\n
      \  whenever possible, a conformant implementation must never generate\n   messages
      larger than allowed by the receiving SNMP entity.\n   One of the aims of the
      GetBulkRequest-PDU, specified in this\n   protocol, is to minimize the number
      of protocol exchanges required to\n   retrieve a large amount of management
      information.  As such, this PDU\n   type allows an SNMP entity supporting command
      generator applications\n   to request that the response be as large as possible
      given the\n   constraints on message sizes.  These constraints include the limits\n
      \  on the size of messages which the SNMP entity supporting command\n   responder
      applications can generate, and the SNMP entity supporting\n   command generator
      applications can receive.\n   However, it is possible that such maximum sized
      messages may be\n   larger than the Path MTU of the path across the network
      traversed by\n   the messages.  In this situation, such messages are subject
      to\n   fragmentation.  Fragmentation is generally considered to be harmful\n
      \  [FRAG], since among other problems, it leads to a decrease in the\n   reliability
      of the transfer of the messages.  Thus, an SNMP entity\n   which sends a GetBulkRequest-PDU
      must take care to set its parameters\n   accordingly, so as to reduce the risk
      of fragmentation.  In\n   particular, under conditions of network stress, only
      small values\n   should be used for max-repetitions.\n"
    title: 2.3.  Message Sizes
  - contents:
    - "2.4.  Transport Mappings\n   It is important to note that the exchange of SNMP
      messages requires\n   only an unreliable datagram service, with every message
      being\n   entirely and independently contained in a single transport datagram.\n
      \  Specific transport mappings and encoding rules are specified\n   elsewhere
      [RFC3417].  However, the preferred mapping is the use of\n   the User Datagram
      Protocol [RFC768].\n"
    title: 2.4.  Transport Mappings
  - contents:
    - "2.5.  SMIv2 Data Type Mappings\n   The SMIv2 [RFC2578] defines 11 base types
      (INTEGER, OCTET STRING,\n   OBJECT IDENTIFIER, Integer32, IpAddress, Counter32,
      Gauge32,\n   Unsigned32, TimeTicks, Opaque, Counter64) and the BITS construct.\n
      \  The SMIv2 base types are mapped to the corresponding selection type\n   in
      the SimpleSyntax and ApplicationSyntax choices of the ASN.1 SNMP\n   protocol
      definition.  Note that the INTEGER and Integer32 SMIv2 base\n   types are mapped
      to the integer-value selection type of the\n   SimpleSyntax choice.  Similarly,
      the Gauge32 and Unsigned32 SMIv2\n   base types are mapped to the unsigned-integer-value
      selection type of\n   the ApplicationSyntax choice.\n   The SMIv2 BITS construct
      is mapped to the string-value selection type\n   of the SimpleSyntax choice.
      \ A BITS value is encoded as an OCTET\n   STRING, in which all the named bits
      in (the definition of) the\n   bitstring, commencing with the first bit and
      proceeding to the last\n   bit, are placed in bits 8 (high order bit) to 1 (low
      order bit) of\n   the first octet, followed by bits 8 to 1 of each subsequent
      octet in\n   turn, followed by as many bits as are needed of the final subsequent\n
      \  octet, commencing with bit 8.  Remaining bits, if any, of the final\n   octet
      are set to zero on generation and ignored on receipt.\n"
    title: 2.5.  SMIv2 Data Type Mappings
  title: 2.  Overview
- contents:
  - "3.  Definitions\n   The PDU syntax is defined using ASN.1 notation [ASN1].\n
    \  SNMPv2-PDU DEFINITIONS ::= BEGIN\n   ObjectName ::= OBJECT IDENTIFIER\n   ObjectSyntax
    ::= CHOICE {\n         simple           SimpleSyntax,\n         application-wide
    ApplicationSyntax }\n   SimpleSyntax ::= CHOICE {\n         integer-value   INTEGER
    (-2147483648..2147483647),\n         string-value    OCTET STRING (SIZE (0..65535)),\n
    \        objectID-value  OBJECT IDENTIFIER }\n   ApplicationSyntax ::= CHOICE
    {\n         ipAddress-value        IpAddress,\n         counter-value          Counter32,\n
    \        timeticks-value        TimeTicks,\n         arbitrary-value        Opaque,\n
    \        big-counter-value      Counter64,\n         unsigned-integer-value Unsigned32
    }\n   IpAddress ::= [APPLICATION 0] IMPLICIT OCTET STRING (SIZE (4))\n   Counter32
    ::= [APPLICATION 1] IMPLICIT INTEGER (0..4294967295)\n   Unsigned32 ::= [APPLICATION
    2] IMPLICIT INTEGER (0..4294967295)\n   Gauge32 ::= Unsigned32\n   TimeTicks ::=
    [APPLICATION 3] IMPLICIT INTEGER (0..4294967295)\n   Opaque ::= [APPLICATION 4]
    IMPLICIT OCTET STRING\n   Counter64 ::= [APPLICATION 6]\n                 IMPLICIT
    INTEGER (0..18446744073709551615)\n   -- protocol data units\n   PDUs ::= CHOICE
    {\n        get-request      GetRequest-PDU,\n        get-next-request GetNextRequest-PDU,\n
    \       get-bulk-request GetBulkRequest-PDU,\n        response         Response-PDU,\n
    \       set-request      SetRequest-PDU,\n        inform-request   InformRequest-PDU,\n
    \       snmpV2-trap      SNMPv2-Trap-PDU,\n        report           Report-PDU
    }\n   -- PDUs\n   GetRequest-PDU ::= [0] IMPLICIT PDU\n   GetNextRequest-PDU ::=
    [1] IMPLICIT PDU\n   Response-PDU ::= [2] IMPLICIT PDU\n   SetRequest-PDU ::=
    [3] IMPLICIT PDU\n   -- [4] is obsolete\n   GetBulkRequest-PDU ::= [5] IMPLICIT
    BulkPDU\n   InformRequest-PDU ::= [6] IMPLICIT PDU\n   SNMPv2-Trap-PDU ::= [7]
    IMPLICIT PDU\n   --   Usage and precise semantics of Report-PDU are not defined\n
    \  --   in this document.  Any SNMP administrative framework making\n   --   use
    of this PDU must define its usage and semantics.\n   Report-PDU ::= [8] IMPLICIT
    PDU\n   max-bindings INTEGER ::= 2147483647\n   PDU ::= SEQUENCE {\n           request-id
    INTEGER (-214783648..214783647),\n           error-status                -- sometimes
    ignored\n               INTEGER {\n                   noError(0),\n                   tooBig(1),\n
    \                  noSuchName(2),      -- for proxy compatibility\n                   badValue(3),
    \       -- for proxy compatibility\n                   readOnly(4),        --
    for proxy compatibility\n                   genErr(5),\n                   noAccess(6),\n
    \                  wrongType(7),\n                   wrongLength(8),\n                   wrongEncoding(9),\n
    \                  wrongValue(10),\n                   noCreation(11),\n                   inconsistentValue(12),\n
    \                  resourceUnavailable(13),\n                   commitFailed(14),\n
    \                  undoFailed(15),\n                   authorizationError(16),\n
    \                  notWritable(17),\n                   inconsistentName(18)\n
    \              },\n           error-index                 -- sometimes ignored\n
    \              INTEGER (0..max-bindings),\n           variable-bindings           --
    values are sometimes ignored\n               VarBindList\n       }\n   BulkPDU
    ::=                         -- must be identical in\n       SEQUENCE {                      --
    structure to PDU\n           request-id      INTEGER (-214783648..214783647),\n
    \          non-repeaters   INTEGER (0..max-bindings),\n           max-repetitions
    INTEGER (0..max-bindings),\n           variable-bindings           -- values are
    ignored\n               VarBindList\n       }\n   -- variable binding\n   VarBind
    ::= SEQUENCE {\n           name ObjectName,\n           CHOICE {\n               value
    \         ObjectSyntax,\n               unSpecified    NULL,    -- in retrieval
    requests\n                                       -- exceptions in responses\n
    \              noSuchObject   [0] IMPLICIT NULL,\n               noSuchInstance
    [1] IMPLICIT NULL,\n               endOfMibView   [2] IMPLICIT NULL\n           }\n
    \      }\n   -- variable-binding list\n   VarBindList ::= SEQUENCE (SIZE (0..max-bindings))
    OF VarBind\n   END\n"
  title: 3.  Definitions
- contents:
  - '4.  Protocol Specification

    '
  - contents:
    - "4.1.  Common Constructs\n   The value of the request-id field in a Response-PDU
      takes the value\n   of the request-id field in the request PDU to which it is
      a response.\n   By use of the request-id value, an application can distinguish
      the\n   (potentially multiple) outstanding requests, and thereby correlate\n
      \  incoming responses with outstanding requests.  In cases where an\n   unreliable
      datagram service is used, the request-id also provides a\n   simple means of
      identifying messages duplicated by the network.  Use\n   of the same request-id
      on a retransmission of a request allows the\n   response to either the original
      transmission or the retransmission to\n   satisfy the request.  However, in
      order to calculate the round trip\n   time for transmission and processing of
      a request-response\n   transaction, the application needs to use a different
      request-id\n   value on a retransmitted request.  The latter strategy is recommended\n
      \  for use in the majority of situations.\n   A non-zero value of the error-status
      field in a Response-PDU is used\n   to indicate that an error occurred to prevent
      the processing of the\n   request.  In these cases, a non-zero value of the
      Response-PDU's\n   error-index field provides additional information by identifying\n
      \  which variable binding in the list caused the error.  A variable\n   binding
      is identified by its index value.  The first variable binding\n   in a variable-binding
      list is index one, the second is index two,\n   etc.\n   SNMP limits OBJECT
      IDENTIFIER values to a maximum of 128 sub-\n   identifiers, where each sub-identifier
      has a maximum value of\n   2**32-1.\n"
    title: 4.1.  Common Constructs
  - contents:
    - "4.2.  PDU Processing\n   In the elements of procedure below, any field of a
      PDU which is not\n   referenced by the relevant procedure is ignored by the
      receiving SNMP\n   entity.  However, all components of a PDU, including those
      whose\n   values are ignored by the receiving SNMP entity, must have valid\n
      \  ASN.1 syntax and encoding.  For example, some PDUs (e.g., the\n   GetRequest-PDU)
      are concerned only with the name of a variable and\n   not its value.  In this
      case, the value portion of the variable\n   binding is ignored by the receiving
      SNMP entity.  The unSpecified\n   value is defined for use as the value portion
      of such bindings.\n   On generating a management communication, the message
      \"wrapper\" to\n   encapsulate the PDU is generated according to the \"Elements
      of\n   Procedure\" of the administrative framework in use.  The definition of\n
      \  \"max-bindings\" imposes an upper bound on the number of variable\n   bindings.
      \ In practice, the size of a message is also limited by\n   constraints on the
      maximum message size.  A compliant implementation\n   must support as many variable
      bindings in a PDU or BulkPDU as fit\n   into the overall maximum message size
      limit of the SNMP engine, but\n   no more than 2147483647 variable bindings.\n
      \  On receiving a management communication, the \"Elements of Procedure\"\n
      \  of the administrative framework in use is followed, and if those\n   procedures
      indicate that the operation contained within the message\n   is to be performed
      locally, then those procedures also indicate the\n   MIB view which is visible
      to the operation.\n"
    - contents:
      - "4.2.1.  The GetRequest-PDU\n   A GetRequest-PDU is generated and transmitted
        at the request of an\n   application.\n   Upon receipt of a GetRequest-PDU,
        the receiving SNMP entity processes\n   each variable binding in the variable-binding
        list to produce a\n   Response-PDU.  All fields of the Response-PDU have the
        same values as\n   the corresponding fields of the received request except
        as indicated\n   below.  Each variable binding is processed as follows:\n
        \  (1)   If the variable binding's name exactly matches the name of a\n         variable
        accessible by this request, then the variable\n         binding's value field
        is set to the value of the named\n         variable.\n   (2)   Otherwise,
        if the variable binding's name does not have an\n         OBJECT IDENTIFIER
        prefix which exactly matches the OBJECT\n         IDENTIFIER prefix of any
        (potential) variable accessible by\n         this request, then its value
        field is set to \"noSuchObject\".\n   (3)   Otherwise, the variable binding's
        value field is set to\n         \"noSuchInstance\".\n   If the processing
        of any variable binding fails for a reason other\n   than listed above, then
        the Response-PDU is re-formatted with the\n   same values in its request-id
        and variable-bindings fields as the\n   received GetRequest-PDU, with the
        value of its error-status field set\n   to \"genErr\", and the value of its
        error-index field is set to the\n   index of the failed variable binding.\n
        \  Otherwise, the value of the Response-PDU's error-status field is set\n
        \  to \"noError\", and the value of its error-index field is zero.\n   The
        generated Response-PDU is then encapsulated into a message.  If\n   the size
        of the resultant message is less than or equal to both a\n   local constraint
        and the maximum message size of the originator, it\n   is transmitted to the
        originator of the GetRequest-PDU.\n   Otherwise, an alternate Response-PDU
        is generated.  This alternate\n   Response-PDU is formatted with the same
        value in its request-id field\n   as the received GetRequest-PDU, with the
        value of its error-status\n   field set to \"tooBig\", the value of its error-index
        field set to\n   zero, and an empty variable-bindings field.  This alternate\n
        \  Response-PDU is then encapsulated into a message.  If the size of the\n
        \  resultant message is less than or equal to both a local constraint\n   and
        the maximum message size of the originator, it is transmitted to\n   the originator
        of the GetRequest-PDU.  Otherwise, the snmpSilentDrops\n   [RFC3418] counter
        is incremented and the resultant message is\n   discarded.\n"
      title: 4.2.1.  The GetRequest-PDU
    - contents:
      - "4.2.2.  The GetNextRequest-PDU\n   A GetNextRequest-PDU is generated and
        transmitted at the request of\n   an application.\n   Upon receipt of a GetNextRequest-PDU,
        the receiving SNMP entity\n   processes each variable binding in the variable-binding
        list to\n   produce a Response-PDU.  All fields of the Response-PDU have the
        same\n   values as the corresponding fields of the received request except
        as\n   indicated below.  Each variable binding is processed as follows:\n
        \     (1)   The variable is located which is in the lexicographically\n            ordered
        list of the names of all variables which are\n            accessible by this
        request and whose name is the first\n            lexicographic successor of
        the variable binding's name in\n            the incoming GetNextRequest-PDU.
        \ The corresponding variable\n            binding's name and value fields
        in the Response-PDU are set\n            to the name and value of the located
        variable.\n      (2)   If the requested variable binding's name does not\n
        \           lexicographically precede the name of any variable\n            accessible
        by this request, i.e., there is no lexicographic\n            successor, then
        the corresponding variable binding produced\n            in the Response-PDU
        has its value field set to\n            \"endOfMibView\", and its name field
        set to the variable\n            binding's name in the request.\n   If the
        processing of any variable binding fails for a reason other\n   than listed
        above, then the Response-PDU is re-formatted with the\n   same values in its
        request-id and variable-bindings fields as the\n   received GetNextRequest-PDU,
        with the value of its error-status field\n   set to \"genErr\", and the value
        of its error-index field is set to the\n   index of the failed variable binding.\n
        \  Otherwise, the value of the Response-PDU's error-status field is set\n
        \  to \"noError\", and the value of its error-index field is zero.\n   The
        generated Response-PDU is then encapsulated into a message.  If\n   the size
        of the resultant message is less than or equal to both a\n   local constraint
        and the maximum message size of the originator, it\n   is transmitted to the
        originator of the GetNextRequest-PDU.\n   Otherwise, an alternate Response-PDU
        is generated.  This alternate\n   Response-PDU is formatted with the same
        values in its request-id\n   field as the received GetNextRequest-PDU, with
        the value of its\n   error-status field set to \"tooBig\", the value of its
        error-index\n   field set to zero, and an empty variable-bindings field.  This\n
        \  alternate Response-PDU is then encapsulated into a message.  If the\n   size
        of the resultant message is less than or equal to both a local\n   constraint
        and the maximum message size of the originator, it is\n   transmitted to the
        originator of the GetNextRequest-PDU.  Otherwise,\n   the snmpSilentDrops
        [RFC3418] counter is incremented and the\n   resultant message is discarded.\n"
      - contents:
        - "4.2.2.1.  Example of Table Traversal\n   An important use of the GetNextRequest-PDU
          is the traversal of\n   conceptual tables of information within a MIB.  The
          semantics of this\n   type of request, together with the method of identifying
          individual\n   instances of objects in the MIB, provides access to related
          objects\n   in the MIB as if they enjoyed a tabular organization.\n   In
          the protocol exchange sketched below, an application retrieves the\n   media-dependent
          physical address and the address-mapping type for\n   each entry in the
          IP net-to-media Address Translation Table [RFC1213]\n   of a particular
          network element.  It also retrieves the value of\n   sysUpTime [RFC3418],
          at which the mappings existed.  Suppose that the\n   command responder's
          IP net-to-media table has three entries:\n   Interface-Number  Network-Address
          \ Physical-Address  Type\n      1            10.0.0.51     00:00:10:01:23:45
          \ static\n      1             9.2.3.4      00:00:10:54:32:10  dynamic\n
          \     2            10.0.0.15     00:00:10:98:76:54  dynamic\n   The SNMP
          entity supporting a command generator application begins by\n   sending
          a GetNextRequest-PDU containing the indicated OBJECT\n   IDENTIFIER values
          as the requested variable names:\n    GetNextRequest ( sysUpTime,\n                   ipNetToMediaPhysAddress,\n
          \                  ipNetToMediaType )\n   The SNMP entity supporting a command
          responder application responds\n   with a Response-PDU:\n    Response ((
          sysUpTime.0 =  \"123456\" ),\n               ( ipNetToMediaPhysAddress.1.9.2.3.4
          = \"000010543210\" ),\n            ( ipNetToMediaType.1.9.2.3.4 =  \"dynamic\"
          ))\n   The SNMP entity supporting the command generator application\n   continues
          with:\n    GetNextRequest ( sysUpTime,\n                   ipNetToMediaPhysAddress.1.9.2.3.4,\n
          \                  ipNetToMediaType.1.9.2.3.4 )\n   The SNMP entity supporting
          the command responder application responds\n   with:\n    Response (( sysUpTime.0
          =  \"123461\" ),\n               ( ipNetToMediaPhysAddress.1.10.0.0.51 =
          \"000010012345\" ),\n            ( ipNetToMediaType.1.10.0.0.51 =  \"static\"
          ))\n   The SNMP entity supporting the command generator application\n   continues
          with:\n    GetNextRequest ( sysUpTime,\n                   ipNetToMediaPhysAddress.1.10.0.0.51,\n
          \                  ipNetToMediaType.1.10.0.0.51 )\n   The SNMP entity supporting
          the command responder application responds\n   with:\n    Response (( sysUpTime.0
          =  \"123466\" ),\n               ( ipNetToMediaPhysAddress.2.10.0.0.15 =
          \"000010987654\" ),\n            ( ipNetToMediaType.2.10.0.0.15 =  \"dynamic\"
          ))\n   The SNMP entity supporting the command generator application\n   continues
          with:\n    GetNextRequest ( sysUpTime,\n                   ipNetToMediaPhysAddress.2.10.0.0.15,\n
          \                  ipNetToMediaType.2.10.0.0.15 )\n   As there are no further
          entries in the table, the SNMP entity\n   supporting the command responder
          application responds with the\n   variables that are next in the lexicographical
          ordering of the\n   accessible object names, for example:\n    Response
          (( sysUpTime.0 =  \"123471\" ),\n               ( ipNetToMediaNetAddress.1.9.2.3.4
          = \"9.2.3.4\" ),\n            ( ipRoutingDiscards.0 =  \"2\" ))\n   Note
          how, having reached the end of the column for\n   ipNetToMediaPhysAddress,
          the second variable binding from the command\n   responder application has
          now \"wrapped\" to the first row in the next\n   column.  Furthermore, note
          how, having reached the end of the\n   ipNetToMediaTable for the third variable
          binding, the command\n   responder application has responded with the next
          available object,\n   which is outside that table.  This response signals
          the end of the\n   table to the command generator application.\n"
        title: 4.2.2.1.  Example of Table Traversal
      title: 4.2.2.  The GetNextRequest-PDU
    - contents:
      - "4.2.3.  The GetBulkRequest-PDU\n   A GetBulkRequest-PDU is generated and
        transmitted at the request of\n   an application.  The purpose of the GetBulkRequest-PDU
        is to request\n   the transfer of a potentially large amount of data, including,
        but\n   not limited to, the efficient and rapid retrieval of large tables.\n
        \  Upon receipt of a GetBulkRequest-PDU, the receiving SNMP entity\n   processes
        each variable binding in the variable-binding list to\n   produce a Response-PDU
        with its request-id field having the same\n   value as in the request.\n   For
        the GetBulkRequest-PDU type, the successful processing of each\n   variable
        binding in the request generates zero or more variable\n   bindings in the
        Response-PDU.  That is, the one-to-one mapping\n   between the variable bindings
        of the GetRequest-PDU, GetNextRequest-\n   PDU, and SetRequest-PDU types and
        the resultant Response-PDUs does\n   not apply for the mapping between the
        variable bindings of a\n   GetBulkRequest-PDU and the resultant Response-PDU.\n
        \  The values of the non-repeaters and max-repetitions fields in the\n   request
        specify the processing requested.  One variable binding in\n   the Response-PDU
        is requested for the first N variable bindings in\n   the request and M variable
        bindings are requested for each of the R\n   remaining variable bindings in
        the request.  Consequently, the total\n   number of requested variable bindings
        communicated by the request is\n   given by N + (M * R), where N is the minimum
        of:  a) the value of the\n   non-repeaters field in the request, and b) the
        number of variable\n   bindings in the request; M is the value of the max-repetitions
        field\n   in the request; and R is the maximum of:  a) number of variable\n
        \  bindings in the request - N, and b)  zero.\n   The receiving SNMP entity
        produces a Response-PDU with up to the\n   total number of requested variable
        bindings communicated by the\n   request.  The request-id shall have the same
        value as the received\n   GetBulkRequest-PDU.\n   If N is greater than zero,
        the first through the (N)-th variable\n   bindings of the Response-PDU are
        each produced as follows:\n   (1)   The variable is located which is in the
        lexicographically\n         ordered list of the names of all variables which
        are accessible\n         by this request and whose name is the first lexicographic\n
        \        successor of the variable binding's name in the incoming\n         GetBulkRequest-PDU.
        \ The corresponding variable binding's name\n         and value fields in
        the Response-PDU are set to the name and\n         value of the located variable.\n
        \  (2)   If the requested variable binding's name does not\n         lexicographically
        precede the name of any variable accessible\n         by this request, i.e.,
        there is no lexicographic successor,\n         then the corresponding variable
        binding produced in the\n         Response-PDU has its value field set to
        \"endOfMibView\", and its\n         name field set to the variable binding's
        name in the request.\n   If M and R are non-zero, the (N + 1)-th and subsequent
        variable\n   bindings of the Response-PDU are each produced in a similar manner.\n
        \  For each iteration i, such that i is greater than zero and less than\n
        \  or equal to M, and for each repeated variable, r, such that r is\n   greater
        than zero and less than or equal to R, the (N + ( (i-1) * R )\n   + r)-th
        variable binding of the Response-PDU is produced as follows:\n   (1)   The
        variable which is in the lexicographically ordered list of\n         the names
        of all variables which are accessible by this request\n         and whose
        name is the (i)-th lexicographic successor of the (N\n         + r)-th variable
        binding's name in the incoming\n         GetBulkRequest-PDU is located and
        the variable binding's name\n         and value fields are set to the name
        and value of the located\n         variable.\n   (2)   If there is no (i)-th
        lexicographic successor, then the\n         corresponding variable binding
        produced in the Response-PDU has\n         its value field set to \"endOfMibView\",
        and its name field set\n         to either the last lexicographic successor,
        or if there are no\n         lexicographic successors, to the (N + r)-th variable
        binding's\n         name in the request.\n   While the maximum number of variable
        bindings in the Response-PDU is\n   bounded by N + (M * R), the response may
        be generated with a lesser\n   number of variable bindings (possibly zero)
        for either of three\n   reasons.\n   (1)   If the size of the message encapsulating
        the Response-PDU\n         containing the requested number of variable bindings
        would be\n         greater than either a local constraint or the maximum message\n
        \        size of the originator, then the response is generated with a\n         lesser
        number of variable bindings.  This lesser number is the\n         ordered
        set of variable bindings with some of the variable\n         bindings at the
        end of the set removed, such that the size of\n         the message encapsulating
        the Response-PDU is approximately\n         equal to but no greater than either
        a local constraint or the\n         maximum message size of the originator.
        \ Note that the number\n         of variable bindings removed has no relationship
        to the values\n         of N, M, or R.\n   (2)   The response may also be
        generated with a lesser number of\n         variable bindings if for some
        value of iteration i, such that i\n         is greater than zero and less
        than or equal to M, that all of\n         the generated variable bindings
        have the value field set to\n         \"endOfMibView\".  In this case, the
        variable bindings may be\n         truncated after the (N + (i * R))-th variable
        binding.\n   (3)   In the event that the processing of a request with many\n
        \        repetitions requires a significantly greater amount of\n         processing
        time than a normal request, then a command responder\n         application
        may terminate the request with less than the full\n         number of repetitions,
        providing at least one repetition is\n         completed.\n   If the processing
        of any variable binding fails for a reason other\n   than listed above, then
        the Response-PDU is re-formatted with the\n   same values in its request-id
        and variable-bindings fields as the\n   received GetBulkRequest-PDU, with
        the value of its error-status field\n   set to \"genErr\", and the value of
        its error-index field is set to the\n   index of the variable binding in the
        original request which\n   corresponds to the failed variable binding.\n   Otherwise,
        the value of the Response-PDU's error-status field is set\n   to \"noError\",
        and the value of its error-index field to zero.\n   The generated Response-PDU
        (possibly with an empty variable-bindings\n   field) is then encapsulated
        into a message.  If the size of the\n   resultant message is less than or
        equal to both a local constraint\n   and the maximum message size of the originator,
        it is transmitted to\n   the originator of the GetBulkRequest-PDU.  Otherwise,
        the\n   snmpSilentDrops [RFC3418] counter is incremented and the resultant\n
        \  message is discarded.\n"
      - contents:
        - "4.2.3.1.  Another Example of Table Traversal\n   This example demonstrates
          how the GetBulkRequest-PDU can be used as\n   an alternative to the GetNextRequest-PDU.
          \ The same traversal of the\n   IP net-to-media table as shown in Section
          4.2.2.1 is achieved with\n   fewer exchanges.\n   The SNMP entity supporting
          the command generator application begins\n   by sending a GetBulkRequest-PDU
          with the modest max-repetitions value\n   of 2, and containing the indicated
          OBJECT IDENTIFIER values as the\n   requested variable names:\n    GetBulkRequest
          [ non-repeaters = 1, max-repetitions = 2 ]\n                  ( sysUpTime,\n
          \                   ipNetToMediaPhysAddress,\n                    ipNetToMediaType
          )\n   The SNMP entity supporting the command responder application responds\n
          \  with a Response-PDU:\n    Response (( sysUpTime.0 =  \"123456\" ),\n
          \              ( ipNetToMediaPhysAddress.1.9.2.3.4 = \"000010543210\" ),\n
          \           ( ipNetToMediaType.1.9.2.3.4 =  \"dynamic\" ),\n               (
          ipNetToMediaPhysAddress.1.10.0.0.51 = \"000010012345\" ),\n            (
          ipNetToMediaType.1.10.0.0.51 =  \"static\" ))\n   The SNMP entity supporting
          the command generator application\n   continues with:\n     GetBulkRequest
          [ non-repeaters = 1, max-repetitions = 2 ]\n                     ( sysUpTime,\n
          \                      ipNetToMediaPhysAddress.1.10.0.0.51,\n                       ipNetToMediaType.1.10.0.0.51
          )\n   The SNMP entity supporting the command responder application responds\n
          \  with:\n    Response (( sysUpTime.0 =  \"123466\" ),\n               (
          ipNetToMediaPhysAddress.2.10.0.0.15 = \"000010987654\" ),\n               (
          ipNetToMediaType.2.10.0.0.15 = \"dynamic\" ),\n               ( ipNetToMediaNetAddress.1.9.2.3.4
          = \"9.2.3.4\" ),\n            ( ipRoutingDiscards.0 =  \"2\" ))\n   Note
          how, as in the first example, the variable bindings in the\n   response
          indicate that the end of the table has been reached.  The\n   fourth variable
          binding does so by returning information from the\n   next available column;
          the fifth variable binding does so by\n   returning information from the
          first available object\n   lexicographically following the table.  This
          response signals the end\n   of the table to the command generator application.\n"
        title: 4.2.3.1.  Another Example of Table Traversal
      title: 4.2.3.  The GetBulkRequest-PDU
    - contents:
      - "4.2.4.  The Response-PDU\n   The Response-PDU is generated by an SNMP entity
        only upon receipt of\n   a GetRequest-PDU, GetNextRequest-PDU, GetBulkRequest-PDU,\n
        \  SetRequest-PDU, or InformRequest-PDU, as described elsewhere in this\n
        \  document.\n   If the error-status field of the Response-PDU is non-zero,
        the value\n   fields of the variable bindings in the variable binding list
        are\n   ignored.\n   If both the error-status field and the error-index field
        of the\n   Response-PDU are non-zero, then the value of the error-index field
        is\n   the index of the variable binding (in the variable-binding list of\n
        \  the corresponding request) for which the request failed.  The first\n   variable
        binding in a request's variable-binding list is index one,\n   the second
        is index two, etc.\n   A compliant SNMP entity supporting a command generator
        application\n   must be able to properly receive and handle a Response-PDU
        with an\n   error-status field equal to \"noSuchName\", \"badValue\", or \"readOnly\".\n
        \  (See sections 1.3 and 4.3 of [RFC2576].)\n   Upon receipt of a Response-PDU,
        the receiving SNMP entity presents\n   its contents to the application which
        generated the request with the\n   same request-id value.  For more details,
        see [RFC3412].\n"
      title: 4.2.4.  The Response-PDU
    - contents:
      - "4.2.5.  The SetRequest-PDU\n   A SetRequest-PDU is generated and transmitted
        at the request of an\n   application.\n   Upon receipt of a SetRequest-PDU,
        the receiving SNMP entity\n   determines the size of a message encapsulating
        a Response-PDU having\n   the same values in its request-id and variable-bindings
        fields as the\n   received SetRequest-PDU, and the largest possible sizes
        of the\n   error-status and error-index fields.  If the determined message
        size\n   is greater than either a local constraint or the maximum message
        size\n   of the originator, then an alternate Response-PDU is generated,\n
        \  transmitted to the originator of the SetRequest-PDU, and processing\n   of
        the SetRequest-PDU terminates immediately thereafter.  This\n   alternate
        Response-PDU is formatted with the same values in its\n   request-id field
        as the received SetRequest-PDU, with the value of\n   its error-status field
        set to \"tooBig\", the value of its error-index\n   field set to zero, and
        an empty variable-bindings field.  This\n   alternate Response-PDU is then
        encapsulated into a message.  If the\n   size of the resultant message is
        less than or equal to both a local\n   constraint and the maximum message
        size of the originator, it is\n   transmitted to the originator of the SetRequest-PDU.
        \ Otherwise, the\n   snmpSilentDrops [RFC3418] counter is incremented and
        the resultant\n   message is discarded.  Regardless, processing of the SetRequest-PDU\n
        \  terminates.\n   Otherwise, the receiving SNMP entity processes each variable
        binding\n   in the variable-binding list to produce a Response-PDU.  All fields\n
        \  of the Response-PDU have the same values as the corresponding fields\n
        \  of the received request except as indicated below.\n   The variable bindings
        are conceptually processed as a two phase\n   operation.  In the first phase,
        each variable binding is validated;\n   if all validations are successful,
        then each variable is altered in\n   the second phase.  Of course, implementors
        are at liberty to\n   implement either the first, or second, or both, of these
        conceptual\n   phases as multiple implementation phases.  Indeed, such multiple\n
        \  implementation phases may be necessary in some cases to ensure\n   consistency.\n
        \  The following validations are performed in the first phase on each\n   variable
        binding until they are all successful, or until one fails:\n   (1)   If the
        variable binding's name specifies an existing or non-\n         existent variable
        to which this request is/would be denied\n         access because it is/would
        not be in the appropriate MIB view,\n         then the value of the Response-PDU's
        error-status field is set\n         to \"noAccess\", and the value of its
        error-index field is set to\n         the index of the failed variable binding.\n
        \  (2)   Otherwise, if there are no variables which share the same\n         OBJECT
        IDENTIFIER prefix as the variable binding's name, and\n         which are
        able to be created or modified no matter what new\n         value is specified,
        then the value of the Response-PDU's\n         error-status field is set to
        \"notWritable\", and the value of\n         its error-index field is set to
        the index of the failed\n         variable binding.\n   (3)   Otherwise, if
        the variable binding's value field specifies,\n         according to the ASN.1
        language, a type which is inconsistent\n         with that required for all
        variables which share the same\n         OBJECT IDENTIFIER prefix as the variable
        binding's name, then\n         the value of the Response-PDU's error-status
        field is set to\n         \"wrongType\", and the value of its error-index
        field is set to\n         the index of the failed variable binding.\n   (4)
        \  Otherwise, if the variable binding's value field specifies,\n         according
        to the ASN.1 language, a length which is inconsistent\n         with that
        required for all variables which share the same\n         OBJECT IDENTIFIER
        prefix as the variable binding's name, then\n         the value of the Response-PDU's
        error-status field is set to\n         \"wrongLength\", and the value of its
        error-index field is set to\n         the index of the failed variable binding.\n
        \  (5)   Otherwise, if the variable binding's value field contains an\n         ASN.1
        encoding which is inconsistent with that field's ASN.1\n         tag, then
        the value of the Response-PDU's error-status field is\n         set to \"wrongEncoding\",
        and the value of its error-index field\n         is set to the index of the
        failed variable binding.  (Note that\n         not all implementation strategies
        will generate this error.)\n   (6)   Otherwise, if the variable binding's
        value field specifies a\n         value which could under no circumstances
        be assigned to the\n         variable, then the value of the Response-PDU's
        error-status\n         field is set to \"wrongValue\", and the value of its
        error-index\n         field is set to the index of the failed variable binding.\n
        \  (7)   Otherwise, if the variable binding's name specifies a variable\n
        \        which does not exist and could not ever be created (even though\n
        \        some variables sharing the same OBJECT IDENTIFIER prefix might\n
        \        under some circumstances be able to be created), then the value\n
        \        of the Response-PDU's error-status field is set to\n         \"noCreation\",
        and the value of its error-index field is set to\n         the index of the
        failed variable binding.\n   (8)   Otherwise, if the variable binding's name
        specifies a variable\n         which does not exist but can not be created
        under the present\n         circumstances (even though it could be created
        under other\n         circumstances), then the value of the Response-PDU's
        error-\n         status field is set to \"inconsistentName\", and the value
        of its\n         error-index field is set to the index of the failed variable\n
        \        binding.\n   (9)   Otherwise, if the variable binding's name specifies
        a variable\n         which exists but can not be modified no matter what new
        value\n         is specified, then the value of the Response-PDU's error-status\n
        \        field is set to \"notWritable\", and the value of its error-index\n
        \        field is set to the index of the failed variable binding.\n   (10)
        \ Otherwise, if the variable binding's value field specifies a\n         value
        that could under other circumstances be held by the\n         variable, but
        is presently inconsistent or otherwise unable to\n         be assigned to
        the variable, then the value of the Response-\n         PDU's error-status
        field is set to \"inconsistentValue\", and the\n         value of its error-index
        field is set to the index of the\n         failed variable binding.\n   (11)
        \ When, during the above steps, the assignment of the value\n         specified
        by the variable binding's value field to the\n         specified variable
        requires the allocation of a resource which\n         is presently unavailable,
        then the value of the Response-PDU's\n         error-status field is set to
        \"resourceUnavailable\", and the\n         value of its error-index field
        is set to the index of the\n         failed variable binding.\n   (12)  If
        the processing of the variable binding fails for a reason\n         other
        than listed above, then the value of the Response-PDU's\n         error-status
        field is set to \"genErr\", and the value of its\n         error-index field
        is set to the index of the failed variable\n         binding.\n   (13)  Otherwise,
        the validation of the variable binding succeeds.\n   At the end of the first
        phase, if the validation of all variable\n   bindings succeeded, then the
        value of the Response-PDU's error-status\n   field is set to \"noError\" and
        the value of its error-index field is\n   zero, and processing continues as
        follows.\n   For each variable binding in the request, the named variable
        is\n   created if necessary, and the specified value is assigned to it.\n
        \  Each of these variable assignments occurs as if simultaneously with\n   respect
        to all other assignments specified in the same request.\n   However, if the
        same variable is named more than once in a single\n   request, with different
        associated values, then the actual assignment\n   made to that variable is
        implementation-specific.\n   If any of these assignments fail (even after
        all the previous\n   validations), then all other assignments are undone,
        and the\n   Response-PDU is modified to have the value of its error-status
        field\n   set to \"commitFailed\", and the value of its error-index field
        set to\n   the index of the failed variable binding.\n   If and only if it
        is not possible to undo all the assignments, then\n   the Response-PDU is
        modified to have the value of its error-status\n   field set to \"undoFailed\",
        and the value of its error-index field is\n   set to zero.  Note that implementations
        are strongly encouraged to\n   take all possible measures to avoid use of
        either \"commitFailed\" or\n   \"undoFailed\" - these two error-status codes
        are not to be taken as\n   license to take the easy way out in an implementation.\n
        \  Finally, the generated Response-PDU is encapsulated into a message,\n   and
        transmitted to the originator of the SetRequest-PDU.\n"
      title: 4.2.5.  The SetRequest-PDU
    - contents:
      - "4.2.6.  The SNMPv2-Trap-PDU\n   An SNMPv2-Trap-PDU is generated and transmitted
        by an SNMP entity on\n   behalf of a notification originator application.
        \ The SNMPv2-Trap-PDU\n   is often used to notify a notification receiver
        application at a\n   logically remote SNMP entity that an event has occurred
        or that a\n   condition is present.  There is no confirmation associated with
        this\n   notification delivery mechanism.\n   The destination(s) to which
        an SNMPv2-Trap-PDU is sent is determined\n   in an implementation-dependent
        fashion by the SNMP entity.  The first\n   two variable bindings in the variable
        binding list of an SNMPv2-\n   Trap-PDU are sysUpTime.0 [RFC3418] and snmpTrapOID.0
        [RFC3418]\n   respectively.  If the OBJECTS clause is present in the invocation
        of\n   the corresponding NOTIFICATION-TYPE macro, then each corresponding\n
        \  variable, as instantiated by this notification, is copied, in order,\n
        \  to the variable-bindings field.  If any additional variables are\n   being
        included (at the option of the generating SNMP entity), then\n   each is copied
        to the variable-bindings field.\n"
      title: 4.2.6.  The SNMPv2-Trap-PDU
    - contents:
      - "4.2.7.  The InformRequest-PDU\n   An InformRequest-PDU is generated and transmitted
        by an SNMP entity\n   on behalf of a notification originator application.
        \ The\n   InformRequest-PDU is often used to notify a notification receiver\n
        \  application that an event has occurred or that a condition is\n   present.
        \ This is a confirmed notification delivery mechanism,\n   although there
        is, of course, no guarantee of delivery.\n   The destination(s) to which an
        InformRequest-PDU is sent is specified\n   by the notification originator
        application.  The first two variable\n   bindings in the variable binding
        list of an InformRequest-PDU are\n   sysUpTime.0 [RFC3418] and snmpTrapOID.0
        [RFC3418] respectively.  If\n   the OBJECTS clause is present in the invocation
        of the corresponding\n   NOTIFICATION-TYPE macro, then each corresponding
        variable, as\n   instantiated by this notification, is copied, in order, to
        the\n   variable-bindings field.  If any additional variables are being\n
        \  included (at the option of the generating SNMP entity), then each is\n
        \  copied to the variable-bindings field.\n   Upon receipt of an InformRequest-PDU,
        the receiving SNMP entity\n   determines the size of a message encapsulating
        a Response-PDU with\n   the same values in its request-id, error-status, error-index
        and\n   variable-bindings fields as the received InformRequest-PDU.  If the\n
        \  determined message size is greater than either a local constraint or\n
        \  the maximum message size of the originator, then an alternate\n   Response-PDU
        is generated, transmitted to the originator of the\n   InformRequest-PDU,
        and processing of the InformRequest-PDU terminates\n   immediately thereafter.
        \ This alternate Response-PDU is formatted\n   with the same values in its
        request-id field as the received\n   InformRequest-PDU, with the value of
        its error-status field set to\n   \"tooBig\", the value of its error-index
        field set to zero, and an\n   empty variable-bindings field.  This alternate
        Response-PDU is then\n   encapsulated into a message.  If the size of the
        resultant message is\n   less than or equal to both a local constraint and
        the maximum message\n   size of the originator, it is transmitted to the originator
        of the\n   InformRequest-PDU.  Otherwise, the snmpSilentDrops [RFC3418] counter\n
        \  is incremented and the resultant message is discarded.  Regardless,\n   processing
        of the InformRequest-PDU terminates.\n   Otherwise, the receiving SNMP entity:\n
        \  (1)   presents its contents to the appropriate application;\n   (2)   generates
        a Response-PDU with the same values in its request-id\n         and variable-bindings
        fields as the received InformRequest-PDU,\n         with the value of its
        error-status field set to \"noError\" and\n         the value of its error-index
        field set to zero; and\n   (3)   transmits the generated Response-PDU to the
        originator of the\n         InformRequest-PDU.\n"
      title: 4.2.7.  The InformRequest-PDU
    title: 4.2.  PDU Processing
  title: 4.  Protocol Specification
- contents:
  - "5.  Notice on Intellectual Property\n   The IETF takes no position regarding
    the validity or scope of any\n   intellectual property or other rights that might
    be claimed to\n   pertain to the implementation or use of the technology described
    in\n   this document or the extent to which any license under such rights\n   might
    or might not be available; neither does it represent that it\n   has made any
    effort to identify any such rights.  Information on the\n   IETF's procedures
    with respect to rights in standards-track and\n   standards-related documentation
    can be found in BCP-11.  Copies of\n   claims of rights made available for publication
    and any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 5.  Notice on Intellectual Property
- contents:
  - "6.  Acknowledgments\n   This document is the product of the SNMPv3 Working Group.
    \ Some\n   special thanks are in order to the following Working Group members:\n
    \     Randy Bush\n      Jeffrey D. Case\n      Mike Daniele\n      Rob Frye\n
    \     Lauren Heintz\n      Keith McCloghrie\n      Russ Mundy\n      David T.
    Perkins\n      Randy Presuhn\n      Aleksey Romanov\n      Juergen Schoenwaelder\n
    \     Bert Wijnen\n   This version of the document, edited by Randy Presuhn, was
    initially\n   based on the work of a design team whose members were:\n      Jeffrey
    D. Case\n      Keith McCloghrie\n      David T. Perkins\n      Randy Presuhn\n
    \     Juergen Schoenwaelder\n   The previous versions of this document, edited
    by Keith McCloghrie,\n   was the result of significant work by four major contributors:\n
    \     Jeffrey D. Case\n      Keith McCloghrie\n      Marshall T. Rose\n      Steven
    Waldbusser\n   Additionally, the contributions of the SNMPv2 Working Group to
    the\n   previous versions are also acknowledged.  In particular, a special\n   thanks
    is extended for the contributions of:\n      Alexander I. Alten\n      Dave Arneson\n
    \     Uri Blumenthal\n      Doug Book\n      Kim Curran\n      Jim Galvin\n      Maria
    Greene\n      Iain Hanson\n      Dave Harrington\n      Nguyen Hien\n      Jeff
    Johnson\n      Michael Kornegay\n      Deirdre Kostick\n      David Levi\n      Daniel
    Mahoney\n      Bob Natale\n      Brian O'Keefe\n      Andrew Pearson\n      Dave
    Perkins\n      Randy Presuhn\n      Aleksey Romanov\n      Shawn Routhier\n      Jon
    Saperia\n      Juergen Schoenwaelder\n      Bob Stewart\n      Kaj Tesink\n      Glenn
    Waters\n      Bert Wijnen\n"
  title: 6.  Acknowledgments
- contents:
  - "7.  Security Considerations\n   The protocol defined in this document by itself
    does not provide a\n   secure environment.  Even if the network itself is secure
    (for\n   example by using IPSec), there is no control as to who on the secure\n
    \  network is allowed access to management information.\n   It is recommended
    that the implementors consider the security\n   features as provided by the SNMPv3
    framework.  Specifically, the use\n   of the User-based Security Model STD 62,
    RFC 3414 [RFC3414] and the\n   View-based Access Control Model STD 62, RFC 3415
    [RFC3415] is\n   recommended.\n   It is then a customer/user responsibility to
    ensure that the SNMP\n   entity is properly configured so that:\n      -  only
    those principals (users) having legitimate rights can\n         access or modify
    the values of any MIB objects supported by\n         that entity;\n      -  the
    occurrence of particular events on the entity will be\n         communicated appropriately;\n
    \     -  the entity responds appropriately and with due credence to\n         events
    and information that have been communicated to it.\n"
  title: 7.  Security Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC768]    Postel, J., \"User Datagram Protocol\",
      STD 6, RFC 768,\n               August 1980.\n   [RFC2578]   McCloghrie, K.,
      Perkins, D., Schoenwaelder, J., Case, J.,\n               Rose, M. and S. Waldbusser,
      \"Structure of Management\n               Information Version 2 (SMIv2)\", STD
      58, RFC 2578, April\n               1999.\n   [RFC2579]   McCloghrie, K., Perkins,
      D., Schoenwaelder, J., Case, J.,\n               Rose, M. and S. Waldbusser,
      \"Textual Conventions for\n               SMIv2\", STD 58, RFC 2579, April 1999.\n
      \  [RFC2580]   McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,\n               Rose,
      M. and S. Waldbusser, \"Conformance Statements for\n               SMIv2\",
      STD 58, RFC 2580, April 1999.\n   [RFC3411]   Harrington, D., Presuhn, R. and
      B. Wijnen, \"An\n               Architecture for Describing Simple Network Management\n
      \              Protocol (SNMP) Management Frameworks\", STD 62, RFC 3411,\n
      \              December 2002.\n   [RFC3412]   Case, J., Harrington, D., Presuhn,
      R. and B. Wijnen,\n               \"Message Processing and Dispatching for the
      Simple\n               Network Management Protocol (SNMP)\", STD 62, RFC 3412,\n
      \              December 2002.\n   [RFC3413]   Levi, D., Meyer, P. and B. Stewart,
      \"Simple Network\n               Management Protocol (SNMP) Applications\",
      STD 62, RFC\n               3413, December 2002.\n   [RFC3414]   Blumenthal,
      U. and B. Wijnen, \"The User-Based Security\n               Model (USM) for
      Version 3 of the Simple Network\n               Management Protocol (SNMPv3)\",
      STD 62, RFC 3414, December\n               2002.\n   [RFC3415]   Wijnen, B.,
      Presuhn, R. and K. McCloghrie, \"View-based\n               Access Control Model
      (VACM) for the Simple Network\n               Management Protocol (SNMP)\",
      STD 62, RFC 3415, December\n               2002.\n   [RFC3417]   Presuhn, R.,
      Case, J., McCloghrie, K., Rose, M. and S.\n               Waldbusser, \"Transport
      Mappings for the Simple Network\n               Management Protocol\", STD 62,
      RFC 3417, December 2002.\n   [RFC3418]   Presuhn, R., Case, J., McCloghrie,
      K., Rose, M. and S.\n               Waldbusser, \"Management Information Base
      (MIB) for the\n               Simple Network Management Protocol (SNMP)\", STD
      62, RFC\n               3418, December 2002.\n   [ASN1]      Information processing
      systems - Open Systems\n               Interconnection - Specification of Abstract
      Syntax\n               Notation One (ASN.1), International Organization for\n
      \              Standardization.  International Standard 8824, December\n               1987.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [FRAG]      Kent, C. and J. Mogul, \"Fragmentation
      Considered\n               Harmful,\" Proceedings, ACM SIGCOMM '87, Stowe, VT,
      August\n               1987.\n   [RFC1155]   Rose, M. and K. McCloghrie, \"Structure
      and Identification\n               of Management Information for TCP/IP-based
      Internets\",\n               STD 16, RFC 1155, May 1990.\n   [RFC1157]   Case,
      J., Fedor, M., Schoffstall, M. and J. Davin,\n               \"Simple Network
      Management Protocol\", STD 15, RFC 1157,\n               May 1990.\n   [RFC1212]
      \  Rose, M. and K. McCloghrie, \"Concise MIB Definitions\",\n               STD
      16, RFC 1212, March 1991.\n   [RFC1213]   McCloghrie, K. and M. Rose, Editors,
      \"Management\n               Information Base for Network Management of TCP/IP-based\n
      \              internets: MIB-II\", STD 17, RFC 1213, March 1991.\n   [RFC1215]
      \  Rose, M., \"A Convention for Defining Traps for use with\n               the
      SNMP\", RFC 1215, March 1991.\n   [RFC1901]   Case, J., McCloghrie, K., Rose,
      M. and S. Waldbusser,\n               \"Introduction to Community-based SNMPv2\",
      RFC 1901,\n               January 1996.\n   [RFC2576]   Frye, R., Levi, D.,
      Routhier, S. and B. Wijnen,\n               \"Coexistence between Version 1,
      Version 2, and Version 3\n               of the Internet-Standard Network Management
      Framework\",\n               RFC 2576, March 2000.\n   [RFC2863]   McCloghrie,
      K. and F. Kastenholz, \"The Interfaces Group\n               MIB\", RFC 2863,
      June 2000.\n   [RFC2914]   Floyd, S., \"Congestion Control Principles\", BCP
      41, RFC\n               2914, September 2000.\n   [RFC3410]   Case, J., Mundy,
      R., Partain, D. and B. Stewart,\n               \"Introduction and Applicability
      Statements for Internet-\n               Standard Management Framework\", RFC
      3410, December 2002.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "9.  Changes from RFC 1905\n   These are the changes from RFC 1905:\n      -  Corrected
    spelling error in copyright statement;\n      -  Updated copyright date;\n      -
    \ Updated with new editor's name and contact information;\n      -  Added notice
    on intellectual property;\n      -  Cosmetic fixes to layout and typography;\n
    \     -  Added table of contents;\n      -  Title changed;\n      -  Updated document
    headers and footers;\n      -  Deleted the old clause 2.3, entitled \"Access to
    Management\n         Information\";\n      -  Changed the way in which request-id
    was defined, though with\n         the same ultimate syntax and semantics, to
    avoid coupling with\n         SMI.  This does not affect the protocol in any way;\n
    \     -  Replaced the word \"exception\" with the word \"error\" in the old\n
    \        clause 4.1.  This does not affect the protocol in any way;\n      -  Deleted
    the first two paragraphs of the old clause 4.2;\n      -  Clarified the maximum
    number of variable bindings that an\n         implementation must support in a
    PDU.  This does not affect the\n         protocol in any way;\n      -  Replaced
    occurrences of \"SNMPv2 application\" with\n         \"application\";\n      -
    \ Deleted three sentences in old clause 4.2.3 describing the\n         handling
    of an impossible situation.  This does not affect the\n         protocol in any
    way;\n      -  Clarified the use of the SNMPv2-Trap-Pdu in the old clause\n         4.2.6.
    \ This does not affect the protocol in any way;\n      -  Aligned description
    of the use of the InformRequest-Pdu in old\n         clause 4.2.7 with the architecture.
    \ This does not affect the\n         protocol in any way;\n      -  Updated references;\n
    \     -  Re-wrote introduction clause;\n      -  Replaced manager/agent/SNMPv2
    entity terminology with\n         terminology from RFC 2571.  This does not affect
    the protocol\n         in any way;\n      -  Eliminated IMPORTS from the SMI,
    replaced with equivalent in-\n         line ASN.1.  This does not affect the protocol
    in any way;\n      -  Added notes calling attention to two different manifestations\n
    \        of reaching the end of a table in the table walk examples;\n      -  Added
    content to security considerations clause;\n      -  Updated ASN.1 comment on
    use of Report-PDU.  This does not\n         affect the protocol in any way;\n
    \     -  Updated acknowledgments section;\n      -  Included information on handling
    of BITS;\n      -  Deleted spurious comma in ASN.1 definition of PDUs;\n      -
    \ Added abstract;\n      -  Made handling of additional variable bindings in informs\n
    \        consistent with that for traps.  This was a correction of an\n         editorial
    oversight, and reflects implementation practice;\n      -  Added reference to
    RFC 2914.\n"
  title: 9.  Changes from RFC 1905
- contents:
  - "10.  Editor's Address\n   Randy Presuhn\n   BMC Software, Inc.\n   2141 North
    First Street\n   San Jose, CA  95131\n   USA\n   Phone: +1 408 546 1006\n   EMail:
    randy_presuhn@bmc.com\n"
  title: 10.  Editor's Address
- contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2002).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 11.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
